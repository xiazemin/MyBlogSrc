I"¥<p>zend_string å’Œcharï¼Šä¸æ˜¯ä¸€ä¸ªä¸œè¥¿ï¼Œå› æ­¤è½¬æ¢çš„æ—¶å€™ç‰¹åˆ«æ³¨æ„
å†™æ‰©å±•çš„æ—¶å€™é‡åˆ°äº†ä¸€ä¸ªbug
æ˜æ˜å†™è¿›å»äº†
    add_assoc_long(MYFILE_G(my_func_set), func_name, timeElipsed);
    ä½†æ˜¯å–å‡ºæ¥ä¸€ç›´æ˜¯0
 zval* lastVal = zend_hash_find(Z_ARRVAL_P(MYFILE_G(my_func_set)),key);
 æ’æŸ¥å‘ç°keyçš„ç±»å‹ä¸å¯¹
 å†™è¿›å»æ˜¯charï¼Š å–å‡ºæ¥å´æ˜¯zend_stringä¸€å®šè¦æ³¨æ„
<!-- more --></p>

<p>https://www.cnblogs.com/pingyeaa/p/9688248.html
ä¸€ã€å­—ç¬¦ä¸²çš„ç»“æ„
Copy
struct _zend_string {
	zend_refcounted_h gc;       /* å­—ç¬¦ä¸²ç±»åˆ«åŠå¼•ç”¨è®¡æ•° <em>/
	zend_ulong        h;        /</em> å­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼ <em>/
	size_t            len;      /</em> å­—ç¬¦ä¸²çš„é•¿åº¦ <em>/
	char              val[1];   /</em> æŸ”æ€§æ•°ç»„ï¼Œå­—ç¬¦ä¸²å­˜å‚¨ä½ç½® */
};
zend_refcounted_hå¯¹åº”çš„ç»“æ„ä½“ï¼š</p>

<p>Copy
typedef struct _zend_refcounted_h {
	uint32_t         refcount;			/* å¼•ç”¨è®¡æ•° <em>/
	union {
		struct {
			ZEND_ENDIAN_LOHI_3(
				zend_uchar    type,   <br />
				zend_uchar    flags,    /</em> å­—ç¬¦ä¸²çš„ç±»å‹ <em>/
				uint16_t      gc_info   /</em> åƒåœ¾å›æ”¶ä¿¡æ¯ */
			)
		} v;
		uint32_t type_info;
	} u;
} zend_refcounted_h;</p>

<p>ä¸‹é¢æˆ‘ä»¬æ¥äº†è§£ä¸€ä¸‹å…·ä½“æ¯ä¸ªæˆå‘˜çš„ä½œç”¨ï¼š</p>

<p>gcï¼šå°±æ˜¯_zend_refcounted_hç»“æ„ä½“ï¼Œä¸»è¦ä½œç”¨æ˜¯å¼•ç”¨è®¡æ•°ä»¥åŠæ ‡è®°å˜é‡çš„ç±»åˆ«ã€‚
hï¼šå­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼ï¼Œåœ¨å­—ç¬¦ä¸²è¢«ç”¨æ¥å½“æ•°ç»„çš„keyæ—¶æ‰åˆå§‹åŒ–ï¼Œè¿™æ ·å¦‚æœåŒä¸€ä¸ªå­—ç¬¦ä¸²è¢«å¤šæ¬¡ç”¨æ¥åškeyï¼Œå°±ä¸ä¼šé‡å¤è®¡ç®—äº†ã€‚
valï¼šè¿™é‡Œçš„char[1]å¹¶ä¸æ„å‘³ç€åªå­˜å‚¨1ä½ï¼Œchar[1]è¢«ç§°ä¸ºæŸ”æ€§æ•°ç»„ï¼Œä¸‹é¢æ¥äº†è§£ä¸€ä¸‹PHPåœ¨å­—ç¬¦ä¸²å†…å­˜åˆ†é…æ—¶åšäº†ä»€ä¹ˆã€‚
Copy
static zend_always_inline zend_string *zend_string_alloc(size_t len, int persistent)
{
	zend_string *ret = (zend_string *)pemalloc(ZEND_MM_ALIGNED_SIZE(_ZSTR_STRUCT_SIZE(len)), persistent);
    â€¦â€¦
}
å®æ›¿æ¢åï¼š</p>

<p>Copy
static zend_always_inline zend_string *zend_string_alloc(size_t len, int persistent)
{
	zend_string *ret = (zend_string *)pemalloc(ZEND_MM_ALIGNED_SIZE(XtOffsetOf(zend_string, val) + len + 1), persistent);
    â€¦â€¦
}
ç¤ºä¾‹ä¸­çš„ä»£ç XtOffsetOf(zend_string, val)è¡¨ç¤ºè®¡ç®—å‡ºzend_stringç»“æ„ä½“çš„å¤§å°ï¼Œè€Œlenå°±æ˜¯è¦åˆ†é…å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œæœ€åçš„+1æ˜¯ç•™ç»™ç»“æŸå­—ç¬¦\0çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåˆ†é…å†…å­˜æ—¶ä¸ä»…ä»…åˆ†é…ç»“æ„ä½“å¤§å°çš„å†…å­˜ï¼Œè¿˜è¦é¡¾åŠåˆ°é•¿åº¦ä¸å¯æ§çš„valï¼Œè¿™æ ·ä¸ä»…æŸ”æ€§çš„åˆ†é…äº†å†…å­˜ï¼Œè¿˜ä½¿å®ƒä¸å…¶ä»–æˆå‘˜å­˜å‚¨åœ¨åŒä¸€å—è¿ç»­çš„ç©ºé—´ä¸­ï¼Œåœ¨åˆ†é…ã€é‡Šæ”¾å†…å­˜æ—¶å¯ä»¥æŠŠstructç»Ÿä¸€å¤„ç†ã€‚</p>

<p>lenï¼šå­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œé¿å…é‡å¤è®¡ç®—æµªè´¹æ—¶é—´ï¼Œå…¸å‹çš„ç©ºé—´æ¢æ—¶é—´åšæ³•ã€‚
äºŒã€å­—ç¬¦ä¸²çš„äºŒè¿›åˆ¶å®‰å…¨
å­¦ä¹ è¿‡Cè¯­è¨€çš„åº”è¯¥çŸ¥é“ï¼Œå­—ç¬¦ä¸²ä¸­é™¤äº†æœ€åä¸€ä¸ªå­—ç¬¦å¤–ä¸å…è®¸å«æœ‰\0ï¼Œå¦åˆ™ä¼šè¢«è®¤ä¸ºæ˜¯å­—ç¬¦ä¸²çš„ç»“æŸå­—ç¬¦ï¼Œè¿™å°±å¯¼è‡´äº†Cè¯­è¨€çš„å­—ç¬¦ä¸²æœ‰å¾ˆå¤šçš„é™åˆ¶ï¼Œæ¯”å¦‚ä¸å­˜å‚¨å›¾ç‰‡ã€æ–‡ä»¶ç­‰äºŒè¿›åˆ¶æ•°æ®ã€‚ä½†æ˜¯PHPå°±æ²¡æœ‰è¿™æ ·çš„é™åˆ¶ï¼Œå®ƒçš„å­—ç¬¦ä¸²å¯ä»¥å­˜å‚¨äºŒè¿›åˆ¶æ•°æ®ï¼Œå¹¶ä¸ä¼šå‡ºç°ä»»ä½•æŠ¥é”™ï¼Œè€ŒPHPçš„è¿™ç§èƒ½åŠ›å°±å«åšå­—ç¬¦ä¸²çš„äºŒè¿›åˆ¶å®‰å…¨ã€‚</p>

<p>Cè¯­è¨€ä»£ç å¦‚ä¸‹ï¼š</p>

<p>Copy
main() {
    char a[] = â€œaaa\0bâ€;    /* å«æœ‰\0çš„å­—ç¬¦ä¸² <em>/
    printf(â€œ%d\nâ€, strlen(a));  /</em> é•¿åº¦ä¸º3ï¼Œ\0åçš„bè¢«å¿½ç•¥ */
}
PHPä»£ç ï¼š</p>

<p>Copy
&lt;?php
    $a = â€œaaa\0bâ€;
    echo strlen($a);    //è¾“å‡º5
?&gt;
ä½†æ˜¯PHPä¸æ˜¯Cè¯­è¨€å†™çš„å—ï¼Ÿä¸ºä»€ä¹ˆPHPä¸ä¼šæŠ¥é”™ï¼Ÿæˆ‘ä»¬å†æ¥å›é¡¾ä¸€ä¸‹zend_stringç»“æ„ä½“ï¼Œè¿˜è®°å¾—æˆå‘˜å˜é‡lenå—ï¼Ÿå®ƒæ˜¯å®ç°äºŒè¿›åˆ¶å®‰å…¨çš„å…³é”®ï¼Œæˆ‘ä»¬ä¸éœ€è¦åƒCä¸€æ ·é€šè¿‡\0æ¥åˆ¤å®šå­—ç¬¦ä¸²æ˜¯å¦è¢«è¯»å–å®Œæˆï¼Œè€Œæ˜¯é€šè¿‡é•¿åº¦lenæ¥åˆ¤æ–­ï¼Œè¿™æ ·å°±ä¿è¯äº†å­—ç¬¦ä¸²çš„äºŒè¿›åˆ¶å®‰å…¨ã€‚</p>

<p>ä¸‰ã€zend_string API
åœ¨äº†è§£äº†zend_stringç»“æ„ä¹‹åï¼Œæˆ‘ä»¬æ¥äº†è§£ä¸€ä¸‹ç”¨æ¥æ“ä½œzend_stringçš„å‡½æ•°é›†åˆã€‚</p>

<p>å‡½æ•°	ä½œç”¨
zend_interned_strings_init	åˆå§‹åŒ–å†…éƒ¨å­—ç¬¦ä¸²å­˜å‚¨å“ˆå¸Œè¡¨ï¼Œå¹¶æŠŠPHPçš„å…³é”®å­—ç­‰å­—ç¬¦ä¸²ä¿¡æ¯å†™è¿›å»
zend_new_interned_string	æŠŠä¸€ä¸ªzend_stringå†™å…¥CG(interned_strings)å“ˆå¸Œè¡¨ä¸­
zend_interned_strings_snapshot	å°†CG(interned_strings)å“ˆå¸Œè¡¨ä¸­çš„å­—ç¬¦ä¸²æ ‡è®°ä¸ºæ°¸ä¹…å­—ç¬¦ä¸²ï¼Œè¿™é‡Œæ ‡è®°çš„åªæœ‰PHPå…³é”®å­—ã€å†…éƒ¨å‡½æ•°åã€å†…éƒ¨æ–¹æ³•åç­‰
zend_interned_strings_restore	é”€æ¯CG(interned_strings)å“ˆå¸Œè¡¨ä¸­ç±»å‹ä¸ºéæ°¸ä¹…å­—ç¬¦ä¸²çš„å€¼ï¼Œåœ¨php_request_shutdowné˜¶æ®µé‡Šæ”¾
zend_interned_strings_dtor	é”€æ¯æ•´ä¸ªCG(interned_strings)å“ˆå¸Œè¡¨ï¼Œåœ¨php_module_shutdowné˜¶æ®µé‡Šæ”¾
zend_string_hash_val	å¾—åˆ°å­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼ï¼Œæ²¡æœ‰åˆ™å®æ—¶è®¡ç®—
zend_string_forget_hash_val	å°†å­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼ç½®ä¸º0
zend_string_refcount	è¯»å–å­—ç¬¦ä¸²çš„å¼•ç”¨è®¡æ•°
zend_string_addref	å¼•ç”¨è®¡æ•°+1
zend_string_delref	å¼•ç”¨è®¡æ•°-1
zend_string_alloc	åˆ†é…å†…å­˜åŠåˆå§‹åŒ–å­—ç¬¦ä¸²çš„å€¼
zend_string_init	åˆå§‹åŒ–å­—ç¬¦ä¸²å¹¶åœ¨æœ€åè¿½åŠ \0
zend_string_cop	ä½¿ç”¨å¼•ç”¨è®¡æ•°æ–¹å¼å¤åˆ¶å­—ç¬¦ä¸²
zend_string_dup	ç›´æ¥å¤åˆ¶ä¸€ä¸ªå­—ç¬¦ä¸²
zend_string_extend	æ‰©å®¹åˆ°lenï¼Œä¿ç•™åŸæ¥çš„å€¼
zend_string_truncate	æˆªæ–­åˆ°lenï¼Œä¿ç•™å¼€å¤´åˆ°lençš„å€¼
zend_string_free	é‡Šæ”¾å­—ç¬¦ä¸²å†…å­˜
zend_string_release	GCå¼•ç”¨é€’å‡ï¼Œç›´åˆ°ä¸º0æ—¶é‡Šæ”¾å†…å­˜
zend_string_equals	æ™®é€šåˆ¤ç­‰
zend_string_equals_ci	åŸºäºäºŒè¿›åˆ¶å®‰å…¨ï¼Œä¸¤ä¸ªzend_stringç±»å‹å­—ç¬¦ä¸²åˆ¤ç­‰
zend_string_equals_literal_ci	åŸºäºäºŒè¿›åˆ¶å®‰å…¨ï¼Œzend_stringç±»å‹å’Œchar*å­—ç¬¦ä¸²åˆ¤ç­‰
zend_inline_hash_func	è®¡ç®—å­—ç¬¦ä¸²çš„å“ˆå¸Œå€¼
zend_intern_known_strings	å¾€zend_intern_known_stringså…¨å±€æ•°ç»„å†™å…¥str
ä¸‹é¢æŒ‘å‡ ä¸ªå‡½æ•°æ¥ä»‹ç»ä¸€ä¸‹ã€‚</p>

<p>3.1ã€zend_string_initå‡½æ•°#
zend_string_initå‡½æ•°ä¸»è¦è´Ÿè´£æŠŠä¸€ä¸ªæ™®é€šçš„å­—ç¬¦ä¸²è½¬åŒ–ä¸ºzend_stringç»“æ„ä½“ã€‚</p>

<p>Copy
static zend_always_inline zend_string *zend_string_init(const char *str, size_t len, int persistent)
{
	zend_string *ret = zend_string_alloc(len, persistent);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>memcpy(ZSTR_VAL(ret), str, len);
ZSTR_VAL(ret)[len] = '\0';
return ret; } ç”³è¯·ä¸€å—è¿ç»­çš„å†…å­˜ï¼Œè¿™ä¸ªåœ¨ä¸Šæ–‡ä¸­å·²ç»æåˆ°ï¼Œç”³è¯·çš„å†…å­˜å¤§å°æ˜¯zend_stringç»“æ„ä½“å¤§å°+å­—ç¬¦ä¸²é•¿åº¦+1ã€‚ æŒ‡é’ˆåç§»åˆ°valä½ç½®ï¼Œå¼€å§‹å­—ç¬¦ä¸²æ‹·è´ã€‚ åœ¨zend_string.valç»“å°¾è¿½åŠ \0ã€‚ 3.2ã€zend_string_extendå‡½æ•°# è¯¥å‡½æ•°ä¸»è¦ç”¨äºå¯¹å­—ç¬¦ä¸²çš„æ‰©å®¹ï¼Œæ³¨æ„è¿™é‡Œæ‰©å®¹ä¸ä¼šæ”¹å˜åŸæ¥ä¿å­˜çš„å€¼ï¼Œåªæ˜¯æŠŠé•¿åº¦æ‰©å¤§åˆ°lenã€‚
</code></pre></div></div>

<p>Copy
static zend_always_inline zend_string *zend_string_extend(zend_string *s, size_t len, int persistent)
{
	zend_string *ret;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZEND_ASSERT(len &gt;= ZSTR_LEN(s));
if (!ZSTR_IS_INTERNED(s)) {
	if (EXPECTED(GC_REFCOUNT(s) == 1)) {
		ret = (zend_string *)perealloc(s, ZEND_MM_ALIGNED_SIZE(_ZSTR_STRUCT_SIZE(len)), persistent);
		ZSTR_LEN(ret) = len;
		zend_string_forget_hash_val(ret);
		return ret;
	} else {
		GC_REFCOUNT(s)--;
	}
}
ret = zend_string_alloc(len, persistent);
memcpy(ZSTR_VAL(ret), ZSTR_VAL(s), ZSTR_LEN(s) + 1);
return ret; } å¦‚æœä¸æ˜¯å†…éƒ¨å­—ç¬¦ä¸²å¹¶ä¸”å¼•ç”¨è®¡æ•°ä¸º1æ—¶ï¼Œç›´æ¥è°ƒç”¨pereallocåˆ†é…å†…å­˜ã€‚ å¦‚æœå­—ç¬¦ä¸²çš„å¼•ç”¨è®¡æ•°å¤§äº1æˆ–è€…æ˜¯å†…éƒ¨å­—ç¬¦ä¸²æ—¶ï¼Œå°±ä¸èƒ½åœ¨åŸæ¥çš„åŸºç¡€ä¸Šæ‰©å®¹äº†ï¼Œå…ˆé€šè¿‡zend_string_allocç”³è¯·ä¸€å—æ–°å†…å­˜ï¼Œè®©åå°†æ—§å†…å®¹æ‹·è´åˆ°æ–°å†…å­˜ä¸­ã€‚ 3.3ã€zend_string_equals_ciå‡½æ•°# ä¸»è¦åŸºäºäºŒè¿›åˆ¶å®‰å…¨å¯¹ä¸¤ä¸ªå­—ç¬¦ä¸²è¿›è¡Œåˆ¤ç­‰ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹PHPæ˜¯æ€ä¹ˆæ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²çš„ã€‚
</code></pre></div></div>

<p>Copy
#define zend_string_equals_ci(s1, s2) <br />
	(ZSTR_LEN(s1) == ZSTR_LEN(s2) &amp;&amp; !zend_binary_strcasecmp(ZSTR_VAL(s1), ZSTR_LEN(s1), ZSTR_VAL(s2), ZSTR_LEN(s2)))</p>

<p>å…ˆæ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦æ˜¯å¦ç›¸ç­‰ï¼Œæ³¨æ„è¿™é‡Œæ˜¯é€šè¿‡zend_stringä¸­çš„lenæ¥æ¯”è¾ƒçš„ã€‚
zend_binary_strcasecmpå‡½æ•°åœ¨é•¿åº¦æ¯”è¾ƒå®Œæˆåï¼Œè¿›è¡Œé€ä¸ªå­—ç¬¦è¿›è¡Œæ¯”è¾ƒã€‚å…ˆéå†æ•´ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œå–å‡ºæ¯ä¸ªå­—ç¬¦ï¼Œè½¬æ¢ä¸ºASCç è¿›è¡Œåˆ¤ç­‰ï¼Œå¦‚æœä¸ç­‰åˆ™è¿”å›å·®å€¼ã€‚å¾ªç¯å®Œäº†è¿˜æ²¡å‘ç°å·®å¼‚çš„è¯å°±è¿”å›ä¸¤è€…çš„é•¿åº¦å·®ï¼Œå¦‚æœé•¿åº¦ç›¸ç­‰å°±è¿”å›0ã€‚æ„Ÿè§‰è¿™é‡Œåšçš„æœ‰ç‚¹å¤šä½™ï¼Œå‚æ•°ä¼ è¿›æ¥ä¹‹å‰å°±å·²ç»åšäº†é•¿åº¦åˆ¤ç­‰äº†ã€‚
Copy
ZEND_API int ZEND_FASTCALL zend_binary_strcasecmp(const char <em>s1, size_t len1, const char *s2, size_t len2) /</em> {{{ */
{
	size_t len;
	int c1, c2;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (s1 == s2) {
	return 0;
}

len = MIN(len1, len2);
while (len--) {
	c1 = zend_tolower_ascii(*(unsigned char *)s1++);
	c2 = zend_tolower_ascii(*(unsigned char *)s2++);
	if (c1 != c2) {
		return c1 - c2;
	}
}

return (int)(len1 - len2); } æ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥åˆ°æºç ä¸­æŸ¥çœ‹ã€‚
</code></pre></div></div>

<p>å››ã€å‚è€ƒæ–‡çŒ®
ã€ŠPHP7åº•å±‚è®¾è®¡ä¸æºç å®ç°ã€‹
ã€ŠPHP7å†…æ ¸å‰–æã€‹
http://cs.potsdam.edu/Documentation/php/html/zend-api.add-index-zval.html
https://www.php.net/manual/ru/internals2.variables.tables.php
https://github.com/microsoft/msphpsql/issues/999
https://chrhust.wordpress.com/2015/07/03/php%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9Ahashtable-array%E5%8F%8A%E5%85%B6%E4%BB%96/
https://www.laruence.com/2020/03/23/5605.html
https://www.laruence.com/2020/02/25/3182.html
https://twosee.cn/2018/07/17/custom-zend-object-hack-way/
https://www.laruence.com/2018/04/08/3170.html
https://www.kancloud.cn/lifei6671/php-kernel/674637</p>

<p>https://wiki.jikexueyuan.com/project/extending-embedding-php/8.2.html
ZendæŠŠä¸HashTableæœ‰å…³çš„APIåˆ†æˆäº†å¥½å‡ ç±»ä»¥ä¾¿äºæˆ‘ä»¬å¯»æ‰¾ï¼Œè¿™äº›APIçš„è¿”å›å€¼å¤§å¤šéƒ½æ˜¯å¸¸é‡SUCCESSæˆ–è€…FAILUREã€‚</p>

<p>åˆ›å»ºHashTable
ä¸‹é¢åœ¨ä»‹ç»å‡½æ•°åŸå‹çš„æ—¶å€™éƒ½ä½¿ç”¨äº†htåç§°ï¼Œä½†æ˜¯æˆ‘ä»¬åœ¨ç¼–å†™æ‰©å±•çš„æ—¶å€™ï¼Œ ä¸€å®šä¸è¦ä½¿ç”¨è¿™ä¸ªåç§°ï¼Œå› ä¸ºä¸€äº›PHPå®å±•å¼€åä¼šå£°æ˜è¿™ä¸ªåç§°çš„å˜é‡ï¼Œ è¿›è€Œå¼•å‘å‘½åå†²çªã€‚</p>

<p>åˆ›å»ºå¹¶åˆå§‹åŒ–ä¸€ä¸ªHashTableéå¸¸ç®€å•ï¼Œåªè¦ä½¿ç”¨zend_hash_initå‡½æ•°å³å¯ï¼Œå®ƒçš„å®šä¹‰å¦‚ä¸‹ï¼š</p>

<p>int zend_hash_init(
    HashTable *ht,
    uint nSize,
    hash_func_t pHashFunction,
    dtor_func_t pDestructor,
    zend_bool persistent
);
*htæ˜¯æŒ‡é’ˆï¼ŒæŒ‡å‘ä¸€ä¸ªHashTableï¼Œæˆ‘ä»¬æ—¢å¯ä»¥&amp;ä¸€ä¸ªå·²å­˜åœ¨çš„HashTableå˜é‡ï¼Œ ä¹Ÿå¯ä»¥é€šè¿‡emalloc()ã€pemalloc()ç­‰å‡½æ•°æ¥ç›´æ¥ç”³è¯·ä¸€å—å†…å­˜ï¼Œ ä¸è¿‡æœ€å¸¸ç”¨çš„æ–¹æ³•è¿˜æ˜¯ç”¨ALLOC_HASHTABLE(ht)å®æ¥è®©å†…æ ¸è‡ªåŠ¨çš„æ›¿æˆ‘ä»¬å®Œæˆè¿™é¡¹å·¥ä½œã€‚ ALLOC_HASHTABLE(ht)æ‰€åšçš„å·¥ä½œç›¸å½“äºht = emalloc(sizeof(HashTable));</p>

<p>nSizeä»£è¡¨ç€è¿™ä¸ªHashTableå¯ä»¥æ‹¥æœ‰çš„å…ƒç´ çš„æœ€å¤§æ•°é‡(HashTableèƒ½å¤ŸåŒ…å«ä»»æ„æ•°é‡çš„å…ƒç´ ï¼Œ è¿™ä¸ªå€¼åªæ˜¯ä¸ºäº†æå‰ç”³è¯·å¥½å†…å­˜ï¼Œæé«˜æ€§èƒ½ï¼Œçœçš„ä¸åœçš„è¿›è¡Œrehashæ“ä½œ)ã€‚ åœ¨æˆ‘ä»¬æ·»åŠ æ–°çš„å…ƒç´ æ—¶ï¼Œè¿™ä¸ªå€¼ä¼šæ ¹æ®æƒ…å†µå†³å®šæ˜¯å¦è‡ªåŠ¨å¢é•¿ï¼Œæœ‰è¶£çš„æ˜¯ï¼Œ è¿™ä¸ªå€¼æ°¸è¿œéƒ½æ˜¯2çš„æ¬¡æ–¹ï¼Œå¦‚æœä½ ç»™å®ƒçš„å€¼ä¸æ˜¯ä¸€ä¸ª2çš„æ¬¡æ–¹çš„å½¢å¼ï¼Œ é‚£å®ƒå°†è‡ªåŠ¨è°ƒæ•´æˆå¤§äºå®ƒçš„æœ€å°çš„2çš„æ¬¡æ–¹å€¼ã€‚ å®ƒçš„è®¡ç®—æ–¹æ³•å°±åƒè¿™æ ·ï¼šnSize = pow(2, ceil(log(nSize, 2)));</p>

<p>pHashFunctionæ˜¯æ—©æœŸçš„Zend Engineä¸­çš„ä¸€ä¸ªå‚æ•°ï¼Œä¸ºäº†å…¼å®¹æ²¡æœ‰å»æ‰å®ƒï¼Œ ä½†å®ƒå·²ç»æ²¡æœ‰ç”¨å¤„äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥èµ‹æˆNULLå°±å¯ä»¥äº†ã€‚åœ¨åŸæ¥ï¼Œ å®ƒå…¶å®æ˜¯ä¸€ä¸ªé’©å­ï¼Œç”¨æ¥è®©ç”¨æˆ·è‡ªå·±hookä¸€ä¸ªæ•£åˆ—å‡½æ•°ï¼Œæ›¿æ¢phpé»˜è®¤çš„DJBX33Aç®—æ³•å®ç°ã€‚</p>

<p>pDestructorä¹Ÿä»£è¡¨ç€ä¸€ä¸ªå›è°ƒå‡½æ•°ï¼Œå½“æˆ‘ä»¬åˆ é™¤æˆ–è€…ä¿®æ”¹HashTableä¸­å…¶ä¸­ä¸€ä¸ªå…ƒç´ æ—¶å€™ä¾¿ä¼šè°ƒç”¨ï¼Œ å®ƒçš„å‡½æ•°åŸå‹å¿…é¡»æ˜¯è¿™æ ·çš„ï¼švoid method_name(void pElement);è¿™é‡Œçš„pElementæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘HashTableä¸­é‚£ä¹ˆå°†è¦è¢«åˆ é™¤æˆ–è€…ä¿®æ”¹çš„é‚£ä¸ªæ•°æ®ï¼Œè€Œæ•°æ®çš„ç±»å‹å¾€å¾€ä¹Ÿæ˜¯ä¸ªæŒ‡é’ˆã€‚</p>

<p>persistentæ˜¯æœ€åä¸€ä¸ªå‚æ•°ï¼Œå®ƒçš„å«ä¹‰éå¸¸ç®€å•ã€‚ å¦‚æœå®ƒä¸ºtrueï¼Œé‚£ä¹ˆè¿™ä¸ªHashTableå°†æ°¸è¿œå­˜åœ¨äºå†…å­˜ä¸­ï¼Œè€Œä¸ä¼šåœ¨RSHUTDOWNé˜¶æ®µè‡ªåŠ¨è¢«æ³¨é”€æ‰ã€‚ æ­¤æ—¶ç¬¬ä¸€ä¸ªå‚æ•°htæ‰€æŒ‡å‘çš„åœ°å€å¿…é¡»æ˜¯é€šè¿‡pemalloc()å‡½æ•°ç”³è¯·çš„ã€‚
ä¸¾ä¸ªä¾‹å­ï¼ŒPHPå†…æ ¸åœ¨æ¯ä¸ªRequestè¯·æ±‚çš„å¤´éƒ¨éƒ½è°ƒç”¨äº†è¿™ä¸ªå‡½æ•°æ¥åˆå§‹åŒ–symbol_tableã€‚</p>

<p>zend_hash_init(&amp;EG(symbol_table), 50, NULL, ZVAL_PTR_DTOR, 0);</p>

<p>//#define ZVAL_PTR_DTOR (void (*)(void *)) zval_ptr_dtor_wrapper
å¦‚ä½ æ‰€è§ï¼Œæ¯ä¸ªå…ƒç´ åœ¨ä»ç¬¦å·è¡¨é‡Œåˆ é™¤çš„æ—¶å€™(æ¯”å¦‚æ‰§è¡Œâ€&lt;?php unset($foo);â€æ“ä½œ)ï¼Œéƒ½ä¼šè§¦å‘ZVAL_PTR_DTORå®ä»£è¡¨çš„å‡½æ•°æ¥å¯¹å…¶è¿›è¡Œä¸å¼•ç”¨è®¡æ•°æœ‰å…³çš„æ“ä½œã€‚</p>

<p>å› ä¸º50ä¸æ˜¯2çš„æ•´æ•°å¹‚å½¢å¼ï¼Œæ‰€ä»¥å®ƒä¼šåœ¨å‡½æ•°æ‰§è¡Œæ—¶è¢«è°ƒæˆæˆ64ã€‚</p>

<p>æ·»åŠ &amp;&amp;ä¿®æ”¹
æˆ‘ä»¬æœ‰å››ä¸ªå¸¸ç”¨çš„å‡½æ•°æ¥å®Œæˆè¿™é¡¹æ“ä½œï¼Œå®ƒä»¬çš„åŸå‹åˆ†åˆ«å¦‚ä¸‹ï¼š</p>

<p>int zend_hash_add(
    HashTable <em>ht,      //å¾…æ“ä½œçš„ht
    char *arKey,            //ç´¢å¼•ï¼Œå¦‚â€my_keyâ€
    uint nKeyLen,       //å­—ç¬¦ä¸²ç´¢å¼•çš„é•¿åº¦ï¼Œå¦‚6
    void **pData,       //è¦æ’å…¥çš„æ•°æ®ï¼Œæ³¨æ„å®ƒæ˜¯void **ç±»å‹çš„ã€‚int *p,i=1;p=&amp;i,pData=&amp;p;ã€‚
    uint nDataSize,
    void *pDest         //å¦‚æœæ“ä½œæˆåŠŸï¼Œåˆ™pDest=</em>pData;
);</p>

<p>int zend_hash_update(
    HashTable *ht,
    char *arKey,
    uint nKeyLen,
    void *pData,
    uint nDataSize,
    void **pDest
);</p>

<p>int zend_hash_index_update(
    HashTable *ht,
    ulong h,
    void *pData,
    uint nDataSize,
    void **pDest
);</p>

<p>int zend_hash_next_index_insert(
    HashTable *ht,
    void *pData,
    uint nDataSize,
    void **pDest
);
å‰ä¸¤ä¸ªå‡½æ•°ç”¨æˆ·æ·»åŠ å¸¦å­—ç¬¦ä¸²ç´¢å¼•çš„æ•°æ®åˆ°HashTableä¸­ï¼Œå°±åƒæˆ‘ä»¬åœ¨PHPä¸­ä½¿ç”¨çš„é‚£æ ·:$foo[â€˜barâ€™] = â€˜bazâ€™;ç”¨Cæ¥å®Œæˆä¾¿æ˜¯ï¼š</p>

<p>zend_hash_add(fooHashTbl, â€œbarâ€, sizeof(â€œbarâ€), &amp;barZval, sizeof(zval*), NULL);
zend_hash_add()å’Œzend_hash_update()å”¯ä¸€çš„åŒºåˆ«å°±æ˜¯å¦‚æœè¿™ä¸ªkeyå·²ç»å­˜åœ¨äº†ï¼Œé‚£ä¹ˆzend_hash_add()å°†è¿”å›FAILUREï¼Œè€Œä¸ä¼šä¿®æ”¹åŸæœ‰æ•°æ®ã€‚</p>

<p>æ¥ä¸‹æ¥çš„ä¸¤ä¸ªå‡½æ•°ç”¨äºåƒHTä¸­æ·»åŠ æ•°å­—ç´¢å¼•çš„æ•°æ®ï¼Œzend_hash_next_index_insert()å‡½æ•°åˆ™ä¸éœ€è¦ç´¢å¼•å€¼å‚æ•°ï¼Œè€Œæ˜¯è‡ªå·±ç›´æ¥è®¡ç®—å‡ºä¸‹ä¸€ä¸ªæ•°å­—ç´¢å¼•å€¼.</p>

<p>ä½†æ˜¯å¦‚æœæˆ‘ä»¬æƒ³è·å–ä¸‹ä¸€ä¸ªå…ƒç´ çš„æ•°å­—ç´¢å¼•å€¼ï¼Œä¹Ÿæ˜¯æœ‰åŠæ³•çš„ï¼Œå¯ä»¥ä½¿ç”¨zend_hash_next_free_element()å‡½æ•°ï¼š</p>

<p>ulong nextid = zend_hash_next_free_element(ht);
zend_hash_index_update(ht, nextid, &amp;data, sizeof(data), NULL);
æ‰€æœ‰è¿™äº›å‡½æ•°ä¸­ï¼Œå¦‚æœpDestä¸ä¸ºNULLï¼Œå†…æ ¸ä¾¿ä¼šä¿®æ”¹å…¶å€¼ä¸ºè¢«æ“ä½œçš„é‚£ä¸ªå…ƒç´ çš„åœ°å€ã€‚åœ¨ä¸‹é¢çš„ä»£ç ä¸­è¿™ä¸ªå‚æ•°ä¹Ÿæœ‰åŒæ ·çš„åŠŸèƒ½ã€‚</p>

<p>æŸ¥æ‰¾
å› ä¸ºHashTableä¸­æœ‰ä¸¤ç§ç±»å‹çš„ç´¢å¼•å€¼ï¼Œæ‰€ä»¥éœ€è¦ä¸¤ä¸ªå‡½æ•°æ¥æ‰§è¡Œfindæ“ä½œã€‚</p>

<p>int zend_hash_find(HashTable *ht, char *arKey, uint nKeyLength,void **pData);
int zend_hash_index_find(HashTable *ht, ulong h, void **pData);
ç¬¬ä¸€ç§å°±æ˜¯æˆ‘ä»¬å¤„ç†PHPè¯­è¨€ä¸­å­—ç¬¦ä¸²ç´¢å¼•æ•°ç»„æ—¶ä½¿ç”¨çš„ï¼Œç¬¬äºŒç§æ˜¯æˆ‘ä»¬å¤„ç†PHPè¯­è¨€ä¸­æ•°å­—ç´¢å¼•æ•°ç»„ä½¿ç”¨çš„ã€‚</p>

<p>Recall from Chapter 2 that when data is added to a HashTable, a new memory block is allocated for it and the data passed in is copied; when the data is extracted back out it is the pointer to that data which is returned. The following code fragment adds data1 to the HashTable, and then extracts it back out such that at the end of the routine, data2 contains the same contents as data1 even though the pointers refer to different memory addresses.</p>

<p>void hash_sample(HashTable <em>ht, sample_data *data1)
{
    sample_data *data2;
    ulong targetID = zend_hash_next_free_element(ht);
    if (zend_hash_index_update(ht, targetID,
            data1, sizeof(sample_data), NULL) == FAILURE) {
            /</em> Should never happen <em>/
            return;
    }
    if(zend_hash_index_find(ht, targetID, (void **)&amp;data2) == FAILURE) {
        /</em> Very unlikely since we just added this element <em>/
        return;
    }
    /</em> data1 != data2, however *data1 == *data2 */
}
é™¤äº†è¯»å–ï¼Œæˆ‘ä»¬è¿˜éœ€è¦æ£€æµ‹æŸä¸ªkeyæ˜¯å¦å­˜åœ¨ï¼š</p>

<p>int zend_hash_exists(HashTable *ht, char *arKey, uint nKeyLen);
int zend_hash_index_exists(HashTable *ht, ulong h);
è¿™ä¸¤ä¸ªå‡½æ•°è¿”å›SUCCESSæˆ–è€…FAILUREï¼Œåˆ†åˆ«ä»£è¡¨ç€æ˜¯å¦å­˜åœ¨ï¼š</p>

<p>if( zend_hash_exists(EG(active_symbol_table),â€fooâ€, sizeof(â€œfooâ€)) == SUCCESS )
{
    /* $foo is set <em>/
}
else
{
    /</em> $foo does not exist */
}
æé€Ÿ!
ulong zend_get_hash_value(char *arKey, uint nKeyLen);
å½“æˆ‘ä»¬éœ€è¦å¯¹åŒä¸€ä¸ªå­—ç¬¦ä¸²çš„keyè¿›è¡Œè®¸å¤šæ“ä½œæ—¶å€™ï¼Œæ¯”å¦‚å…ˆæ£€æµ‹æœ‰æ²¡ï¼Œç„¶åæ’å…¥ï¼Œç„¶åä¿®æ”¹ç­‰ç­‰ï¼Œè¿™æ—¶æˆ‘ä»¬ä¾¿å¯ä»¥ä½¿ç”¨zend_get_hash_valueå‡½æ•°æ¥å¯¹æˆ‘ä»¬çš„æ“ä½œè¿›è¡ŒåŠ é€Ÿï¼è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼å¯ä»¥å’Œquickç³»åˆ—å‡½æ•°ä½¿ç”¨ï¼Œè¾¾åˆ°åŠ é€Ÿçš„ç›®çš„(å°±æ˜¯ä¸å†é‡å¤è®¡ç®—è¿™ä¸ªå­—ç¬¦ä¸²çš„æ•£åˆ—å€¼ï¼Œè€Œç›´æ¥ä½¿ç”¨å·²å‡†å¤‡å¥½çš„)ï¼</p>

<p>int zend_hash_quick_add(
    HashTable *ht,
    char *arKey,
    uint nKeyLen,
    ulong hashval,
    void *pData,
    uint nDataSize,
    void **pDest
);</p>

<p>int zend_hash_quick_update(
    HashTable *ht,
    char *arKey,
    uint nKeyLen,
    ulong hashval,
    void *pData,
    uint nDataSize,
    void **pDest
);</p>

<p>int zend_hash_quick_find(
    HashTable *ht,
    char *arKey,
    uint nKeyLen,
    ulong hashval,
    void **pData
);</p>

<p>int zend_hash_quick_exists(
    HashTable *ht,
    char *arKey,
    uint nKeyLen,
    ulong hashval
);
è™½ç„¶å¾ˆæ„å¤–ï¼Œä½†ä½ è¿˜æ˜¯è¦æ¥å—æ²¡æœ‰zend_hash_quick_del()è¿™ä¸ªå‡½æ•°ã€‚quickç±»å‡½æ•°ä¼šåœ¨ä¸‹é¢è¿™ç§åœºåˆä¸­ç”¨åˆ°ï¼š</p>

<p>void php_sample_hash_copy(HashTable *hta, HashTable *htb,char *arKey, uint nKeyLen TSRMLS_DC)
{
    ulong hashval = zend_get_hash_value(arKey, nKeyLen);
    zval **copyval;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (zend_hash_quick_find(hta, arKey, nKeyLen,hashval, (void**)&amp;copyval) == FAILURE)
{
    //æ ‡æ˜ä¸å­˜åœ¨è¿™ä¸ªç´¢å¼•
    return;
}

//è¿™ä¸ªzvalå·²ç»è¢«å…¶å®ƒçš„Hashtableä½¿ç”¨äº†ï¼Œè¿™é‡Œæˆ‘ä»¬è¿›è¡Œå¼•ç”¨è®¡æ•°æ“ä½œã€‚
(*copyval)-&gt;refcount__gc++;
zend_hash_quick_update(htb, arKey, nKeyLen, hashval,copyval, sizeof(zval*), NULL); } å¤åˆ¶ä¸åˆå¹¶(Copy And Merge) åœ¨PHPè¯­è¨€ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸éœ€è¦è¿›è¡Œæ•°ç»„é—´çš„Copyä¸Mergeæ“ä½œï¼Œæ‰€ä»¥phpè¯­è¨€ä¸­çš„æ•°ç»„åœ¨Cè¯­è¨€ä¸­çš„å®ç°HashTableä¹Ÿè‚¯å®šä¼šç»å¸¸ç¢°åˆ°è¿™ç§æƒ…å†µã€‚ä¸ºäº†ç®€åŒ–è¿™ä¸€ç±»æ“ä½œï¼Œå†…æ ¸ä¸­æ—©å·²å‡†å¤‡å¥½äº†ç›¸åº”çš„APIä¾›æˆ‘ä»¬ä½¿ç”¨ã€‚
</code></pre></div></div>

<p>void zend_hash_copy(
    HashTable <em>target,
    HashTable *source,
    copy_ctor_func_t pCopyConstructor,
    void *tmp,
    uint size
);
*sourceä¸­çš„æ‰€æœ‰å…ƒç´ éƒ½ä¼šé€šè¿‡pCopyConstructorå‡½æ•°Copyåˆ°</em>targetä¸­å»ï¼Œæˆ‘ä»¬è¿˜æ˜¯ä»¥PHPè¯­è¨€ä¸­çš„æ•°ç»„ä¸¾ä¾‹ï¼ŒpCopyConstructorè¿™ä¸ªhookä½¿å¾—æˆ‘ä»¬å¯ä»¥åœ¨copyå˜é‡çš„æ—¶å€™å¯¹ä»–ä»¬çš„ref_countè¿›è¡ŒåŠ ä¸€æ“ä½œã€‚targetä¸­åŸæœ‰çš„ä¸sourceä¸­ç´¢å¼•ä½ç½®çš„æ•°æ®ä¼šè¢«æ›¿æ¢æ‰ï¼Œè€Œå…¶å®ƒçš„å…ƒç´ åˆ™ä¼šè¢«ä¿ç•™ï¼ŒåŸå°ä¸åŠ¨ã€‚</p>

<p>tmpå‚æ•°æ˜¯ä¸ºäº†å…¼å®¹PHP4.0.3ä»¥å‰ç‰ˆæœ¬çš„ï¼Œç°åœ¨èµ‹å€¼ä¸ºNULLå³å¯ã€‚
sizeå‚æ•°ä»£è¡¨æ¯ä¸ªå…ƒç´ çš„å¤§å°ï¼Œå¯¹äºPHPè¯­è¨€ä¸­çš„æ•°ç»„æ¥è¯´ï¼Œè¿™é‡Œçš„ä¾¿æ˜¯sizeof(zval*)äº†ã€‚
void zend_hash_merge(
    HashTable *target,
    HashTable *source,
    copy_ctor_func_t pCopyConstructor,
    void *tmp,
    uint size,
    int overwrite
);
zend_hash_merge()ä¸zend_hash_copyå”¯ä¸€çš„ä¸åŒä¾¿æ˜¯å¤šäº†ä¸ªintç±»å‹çš„overwriteå‚æ•°ï¼Œå½“å…¶å€¼é0çš„æ—¶å€™ï¼Œä¸¤ä¸ªå‡½æ•°çš„å·¥ä½œæ˜¯å®Œå…¨ä¸€æ ·çš„ï¼›å¦‚æœoverwriteå‚æ•°ä¸º0ï¼Œåˆ™zend_hash_mergeå‡½æ•°å°±ä¸ä¼šå¯¹targetä¸­å·²æœ‰ç´¢å¼•çš„å€¼è¿›è¡Œæ›¿æ¢äº†ã€‚</p>

<p>typedef zend_bool (*merge_checker_func_t)(HashTable *target_ht,void *source_data, zend_hash_key *hash_key, void *pParam);
void zend_hash_merge_ex(
    HashTable *target,
    HashTable *source,
    copy_ctor_func_t pCopyConstructor, 
    uint size,
    merge_checker_func_t pMergeSource,
    void *pParam
);
è¿™ä¸ªå‡½æ•°åˆç¹çäº†äº›ï¼Œä¸zend_hash_copyç›¸æ¯”ï¼Œå…¶å¤šäº†ä¸¤ä¸ªå‚æ•°ï¼Œå¤šå‡ºæ¥çš„pMergeSoureå›è°ƒå‡½æ•°å…è®¸æˆ‘ä»¬é€‰æ‹©æ€§çš„è¿›è¡Œmergeï¼Œè€Œä¸æ˜¯å…¨éƒ½mergeã€‚The final form of this group of functions allows for selective copying using a merge checker function. The following example shows zend_hash_merge_ex() in use to copy only the associatively indexed members of the source HashTable (which happens to be a userspace variable array):</p>

<p>zend_bool associative_only(HashTable *ht, void *pData,zend_hash_key *hash_key, void *pParam)
{
    //å¦‚æœæ˜¯å­—ç¬¦ä¸²ç´¢å¼•
    return (hash_key-&gt;arKey &amp;&amp; hash_key-&gt;nKeyLength);
}</p>

<p>void merge_associative(HashTable <em>target, HashTable *source)
{
    zend_hash_merge_ex(target, source, zval_add_ref,sizeof(zval</em>), associative_only, NULL);
}
éå†
åœ¨PHPè¯­è¨€ä¸­ï¼Œæˆ‘ä»¬æœ‰å¾ˆå¤šæ–¹æ³•æ¥éå†ä¸€ä¸ªæ•°ç»„ï¼Œå¯¹äºæ•°ç»„çš„æœ¬è´¨HashTableï¼Œæˆ‘ä»¬ä¹Ÿæœ‰å¾ˆå¤šåŠæ³•æ¥å¯¹å…¶è¿›è¡Œéå†æ“ä½œã€‚é¦–å…ˆæœ€ç®€å•çš„ä¸€ç§åŠæ³•ä¾¿æ˜¯ä½¿ç”¨ä¸€ç§ä¸PHPè¯­è¨€ä¸­forechè¯­å¥åŠŸèƒ½ç±»ä¼¼çš„å‡½æ•°â€”â€”zend_hash_applyï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªå›è°ƒå‡½æ•°ï¼Œå¹¶å°†HashTableçš„æ¯ä¸€ä¸ªå…ƒç´ éƒ½ä¼ é€’ç»™å®ƒã€‚</p>

<p>typedef int (*apply_func_t)(void *pDest TSRMLS_DC);
void zend_hash_apply(HashTable *ht,apply_func_t apply_func TSRMLS_DC);
ä¸‹é¢æ˜¯å¦å¤–ä¸€ç§éå†å‡½æ•°ï¼š</p>

<p>typedef int (*apply_func_arg_t)(void *pDest,void *argument TSRMLS_DC);
void zend_hash_apply_with_argument(HashTable *ht,apply_func_arg_t apply_func, void *data TSRMLS_DC);
é€šè¿‡ä¸Šé¢çš„å‡½æ•°å¯ä»¥åœ¨æ‰§è¡Œéå†æ—¶å‘å›è°ƒå‡½æ•°ä¼ é€’ä»»æ„æ•°é‡çš„å€¼ï¼Œè¿™åœ¨ä¸€äº›diyæ“ä½œä¸­éå¸¸æœ‰ç”¨ã€‚</p>

<p>ä¸Šè¿°å‡½æ•°å¯¹ä¼ ç»™å®ƒä»¬çš„å›è°ƒå‡½æ•°çš„è¿”å›å€¼æœ‰ä¸€ä¸ªå…±åŒçš„çº¦å®šï¼Œè¯¦ç»†ä»‹ç»ä¸‹ä¸‹è¡¨ï¼š</p>

<p>è¡¨æ ¼ 8.1. å›è°ƒå‡½æ•°çš„è¿”å›å€¼
Constant                        Meaning</p>

<p>ZEND_HASH_APPLY_KEEP        ç»“æŸå½“å‰è¯·æ±‚ï¼Œè¿›å…¥ä¸‹ä¸€ä¸ªå¾ªç¯ã€‚ä¸PHPè¯­è¨€forechè¯­å¥ä¸­çš„ä¸€æ¬¡å¾ªç¯æ‰§è¡Œå®Œæ¯•æˆ–è€…é‡åˆ°continueå…³é”®å­—çš„ä½œç”¨ä¸€æ ·ã€‚
ZEND_HASH_APPLY_STOP        è·³å‡ºï¼Œä¸PHPè¯­è¨€forechè¯­å¥ä¸­çš„breakå…³é”®å­—çš„ä½œç”¨ä¸€æ ·ã€‚
ZEND_HASH_APPLY_REMOVE      åˆ é™¤å½“å‰çš„å…ƒç´ ï¼Œç„¶åç»§ç»­å¤„ç†ä¸‹ä¸€ä¸ªã€‚ç›¸å½“äºåœ¨PHPè¯­è¨€ä¸­ï¼šunset($foo[$key]);continu;
æˆ‘ä»¬æ¥ä¸€ä¸‹PHPè¯­è¨€ä¸­çš„forechå¾ªç¯ï¼š</p>

<p>&lt;?php
foreach($arr as $val) {
    echo â€œThe value is: $val\nâ€;
}
?&gt;
é‚£æˆ‘ä»¬çš„å›è°ƒå‡½æ•°åœ¨Cè¯­è¨€ä¸­åº”è¯¥è¿™æ ·å†™ï¼š</p>

<p>int php_sample_print_zval(zval **val TSRMLS_DC)
{
    //é‡æ–°copyä¸€ä¸ªzvalï¼Œé˜²æ­¢ç ´ååŸæ•°æ®
    zval tmpcopy = **val;
    zval_copy_ctor(&amp;tmpcopy);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//è½¬æ¢ä¸ºå­—ç¬¦ä¸²
INIT_PZVAL(&amp;tmpcopy);
convert_to_string(&amp;tmpcopy);

//å¼€å§‹è¾“å‡º
php_printf("The value is: ");
PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));
php_printf("\n");

//æ¯å°¸ç­è¿¹
zval_dtor(&amp;tmpcopy);

//è¿”å›ï¼Œç»§ç»­éå†ä¸‹ä¸€ä¸ªï½
return ZEND_HASH_APPLY_KEEP; } éå†æˆ‘ä»¬çš„HashTableï¼š
</code></pre></div></div>

<p>//ç”Ÿæˆä¸€ä¸ªåä¸ºarrhtã€å…ƒç´ ä¸ºzval*ç±»å‹çš„HashTable
zend_hash_apply(arrht, php_sample_print_zval TSRMLS_CC);
å†æ¬¡æé†’ï¼Œä¿å­˜åœ¨HashTableä¸­çš„å…ƒç´ å¹¶ä¸æ˜¯çœŸæ­£çš„æœ€ç»ˆå˜é‡ï¼Œè€Œæ˜¯æŒ‡å‘å®ƒçš„ä¸€ä¸ªæŒ‡é’ˆã€‚æˆ‘ä»¬çš„ä¸Šé¢çš„éå†å‡½æ•°æ¥æ”¶çš„æ˜¯ä¸€ä¸ªzval**ç±»å‹çš„å‚æ•°ã€‚</p>

<p>typedef int (*apply_func_args_t)(void *pDest,int num_args, va_list args, zend_hash_key *hash_key);
void zend_hash_apply_with_arguments(HashTable *ht,apply_func_args_t apply_func, int numargs, â€¦);
ä¸ºäº†èƒ½åœ¨éå†æ—¶åŒæ—¶æ¥æ”¶ç´¢å¼•çš„å€¼ï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨ç¬¬ä¸‰ç§å½¢å¼çš„zend_hash_applyï¼å°±åƒPHPè¯­è¨€ä¸­è¿™æ ·çš„åŠŸèƒ½ï¼š</p>

<p>&lt;?php
foreach($arr as $key =&gt; $val)
{
    echo â€œThe value of $key is: $val\nâ€;
}
?&gt;
ä¸ºäº†é…åˆzend_hash_apply_with_arguments()å‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦å¯¹æˆ‘ä»¬çš„éå†æ‰§è¡Œå‡½æ•°åšä¸€ä¸‹å°å°çš„æ”¹åŠ¨ï¼Œä½¿å…¶æ¥å—ç´¢å¼•ä½œä¸ºä¸€ä¸ªå‚æ•°ï¼š</p>

<p>int php_sample_print_zval_and_key(zval <em>*val,int num_args,va_list args,zend_hash_key *hash_key)
{
    //é‡æ–°copyä¸€ä¸ªzvalï¼Œé˜²æ­¢ç ´ååŸæ•°æ®
    zval tmpcopy = **val;
    /</em> tsrm_ls is needed by output functions */
    TSRMLS_FETCH();
    zval_copy_ctor(&amp;tmpcopy);
    INIT_PZVAL(&amp;tmpcopy);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//è½¬æ¢ä¸ºå­—ç¬¦ä¸²
convert_to_string(&amp;tmpcopy);

//æ‰§è¡Œè¾“å‡º
php_printf("The value of ");
if (hash_key-&gt;nKeyLength)
{
    //å¦‚æœæ˜¯å­—ç¬¦ä¸²ç±»å‹çš„key
    PHPWRITE(hash_key-&gt;arKey, hash_key-&gt;nKeyLength);
}
else
{
    //å¦‚æœæ˜¯æ•°å­—ç±»å‹çš„key
    php_printf("%ld", hash_key-&gt;h);
}

php_printf(" is: ");
PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));
php_printf("\n");

//æ¯å°¸ç­è¿¹
zval_dtor(&amp;tmpcopy);
/* continue; */
return ZEND_HASH_APPLY_KEEP; } æ‰§è¡Œéå†ï¼š
</code></pre></div></div>

<p>zend_hash_apply_with_arguments(arrht,php_sample_print_zval_and_key, 0);
è¿™ä¸ªå‡½æ•°é€šè¿‡Cè¯­è¨€ä¸­çš„å¯å˜å‚æ•°ç‰¹æ€§æ¥æ¥æ”¶å‚æ•°ã€‚This particular example required no arguments to be passed; for information on extracting variable argument lists from va_list args, see the POSIX documentation pages for va_start(), va_arg(), and va_end().</p>

<p>å½“æˆ‘ä»¬æ£€æŸ¥è¿™ä¸ªhash_keyæ˜¯å­—ç¬¦ä¸²ç±»å‹è¿˜æ˜¯æ•°å­—ç±»å‹æ—¶ï¼Œæ˜¯é€šè¿‡nKeyLengthå±æ€§æ¥æ£€æµ‹çš„,è€Œä¸æ˜¯arKeyå±æ€§ã€‚è¿™æ˜¯å› ä¸ºå†…æ ¸æœ‰æ—¶å€™ä¼šç•™åœ¨arKeyå±æ€§é‡Œäº›è„æ•°æ®ï¼Œä½†nKeyLengthå±æ€§æ˜¯å®‰å…¨çš„ï¼Œå¯ä»¥å®‰å…¨çš„ä½¿ç”¨ã€‚ç”šè‡³å¯¹äºç©ºå­—ç¬¦ä¸²ç´¢å¼•ï¼Œå®ƒä¹Ÿç…§æ ·èƒ½å¤„ç†ã€‚æ¯”å¦‚ï¼š$foo[â€™â€™] =â€Barâ€;ç´¢å¼•çš„å€¼æ˜¯NULLå­—ç¬¦ï¼Œä½†å®ƒçš„é•¿åº¦å´æ˜¯åŒ…æ‹¬æœ€åè¿™ä¸ªNULLå­—ç¬¦çš„ï¼Œæ‰€ä»¥ä¸º1ã€‚</p>

<p>å‘å‰éå†HashTable
æœ‰æ—¶æˆ‘ä»¬å¸Œæœ›ä¸ç”¨å›è°ƒå‡½æ•°ä¹Ÿèƒ½éå†ä¸€ä¸ªæ•°ç»„çš„æ•°æ®ï¼Œä¸ºäº†å®ç°è¿™ä¸ªåŠŸèƒ½ï¼Œå†…æ ¸ç‰¹æ„çš„ä¸ºæ¯ä¸ªHashTableåŠ äº†ä¸ªå±æ€§ï¼šThe internal pointerï¼ˆå†…éƒ¨æŒ‡é’ˆï¼‰ã€‚</p>

<p>æˆ‘ä»¬è¿˜æ˜¯ä»¥PHPè¯­è¨€ä¸­çš„æ•°ç»„ä¸¾ä¾‹ï¼Œæœ‰ä»¥ä¸‹å‡½æ•°æ¥å¤„ç†å®ƒæ‰€å¯¹åº”çš„é‚£ä¸ªHashTableçš„å†…éƒ¨æŒ‡é’ˆï¼šreset(), key(), current(), next(), prev(), each(), and end()ã€‚</p>

<p>&lt;?php
    $arr = array(â€˜aâ€™=&gt;1, â€˜bâ€™=&gt;2, â€˜câ€™=&gt;3);
    reset($arr);
    while (list($key, $val) = each($arr)) {
        /* Do something with $key and $val */
    }
    reset($arr);
    $firstkey = key($arr);
    $firstval = current($arr);
    $bval = next($arr);
    $cval = next($arr);
?&gt;
ZENDå†…æ ¸ä¸­æœ‰ä¸€ç»„æ“ä½œHashTableçš„åŠŸèƒ½ä¸ä»¥ä¸Šå‡½æ•°åŠŸèƒ½ç±»ä¼¼çš„å‡½æ•°ï¼š</p>

<p>/* reset() */
void zend_hash_internal_pointer_reset(HashTable *ht);</p>

<p>/* key() */
int zend_hash_get_current_key(HashTable *ht,char **strIdx, unit *strIdxLen,ulong *numIdx, zend_bool duplicate);</p>

<p>/* current() */
int zend_hash_get_current_data(HashTable *ht, void **pData);</p>

<p>/* next()/each() */
int zend_hash_move_forward(HashTable *ht);</p>

<p>/* prev() */
int zend_hash_move_backwards(HashTable *ht);</p>

<p>/* end() */
void zend_hash_internal_pointer_end(HashTable *ht);</p>

<p>/* å…¶ä»–çš„â€¦â€¦ */
int zend_hash_get_current_key_type(HashTable *ht);
int zend_hash_has_more_elements(HashTable *ht);
PHPè¯­è¨€ä¸­çš„next()ã€prev()ã€end()å‡½æ•°åœ¨ç§»åŠ¨å®ŒæŒ‡é’ˆä¹‹åï¼Œéƒ½é€šè¿‡è°ƒç”¨zend_hash_get_current_data()å‡½æ•°æ¥è·å–å½“å‰æ‰€æŒ‡çš„å…ƒç´ å¹¶è¿”å›ã€‚è€Œeach()è™½ç„¶å’Œnext()å¾ˆåƒï¼Œå´æ˜¯ä½¿ç”¨zend_hash_get_current_key()å‡½æ•°çš„è¿”å›å€¼æ¥ä½œä¸ºå®ƒçš„è¿”å›å€¼ã€‚</p>

<p>ç°åœ¨æˆ‘ä»¬ç”¨å¦å¤–ä¸€ç§æ–¹æ³•æ¥å®ç°ä¸Šé¢çš„forechï¼š</p>

<p>void php_sample_print_var_hash(HashTable *arrht)
{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for(
    zend_hash_internal_pointer_reset(arrht);
    zend_hash_has_more_elements(arrht) == SUCCESS;
    zend_hash_move_forward(arrht))
{
    char *key;
    uint keylen;
    ulong idx;
    int type;
    zval **ppzval, tmpcopy;

    type = zend_hash_get_current_key_ex(arrht, &amp;key, &amp;keylen,&amp;idx, 0, NULL);
    if (zend_hash_get_current_data(arrht, (void**)&amp;ppzval) == FAILURE)
    {
        /* Should never actually fail
         * since the key is known to exist. */
        continue;
    }

    //é‡æ–°copyä¸€ä¸ªzvalï¼Œé˜²æ­¢ç ´ååŸæ•°æ®
    tmpcopy = **ppzval;
    zval_copy_ctor(&amp;tmpcopy);
    INIT_PZVAL(&amp;tmpcopy);

    convert_to_string(&amp;tmpcopy);

    /* Output */
    php_printf("The value of ");
    if (type == HASH_KEY_IS_STRING)
    {
        /* String Key / Associative */
        PHPWRITE(key, keylen);
    } else {
        /* Numeric Key */
        php_printf("%ld", idx);
    }
    php_printf(" is: ");
    PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));
    php_printf("\n");
    /* Toss out old copy */
    zval_dtor(&amp;tmpcopy);
} } ä¸Šé¢çš„ä»£ç ä½ åº”è¯¥éƒ½èƒ½çœ‹æ‡‚äº†ï¼Œå”¯ä¸€è¿˜æ²¡æ¥è§¦åˆ°çš„å¯èƒ½æ˜¯zend_hash_get_current_key()å‡½æ•°çš„è¿”å›å€¼ï¼Œå®ƒçš„è¿”å›å€¼è§è¡¨8.2ã€‚
</code></pre></div></div>

<p>Constant                            Meaning</p>

<p>HASH_KEY_IS_STRING              å½“å‰å…ƒç´ çš„ç´¢å¼•æ˜¯å­—ç¬¦ä¸²ç±»å‹çš„ã€‚therefore, a pointer to the elementâ€™s key name will be populated into strIdx, and its length will be populated into stdIdxLen. If the duplicate flag is set to a nonzero value, the key will be estrndup()â€™d before being populated into strIdx. The calling application is expected to free this duplicated string.</p>

<p>HASH_KEY_IS_LONG                å½“å‰å…ƒç´ çš„ç´¢å¼•æ˜¯æ•°å­—å‹çš„ã€‚
HASH_KEY_NON_EXISTANT           HashTableä¸­çš„å†…éƒ¨æŒ‡é’ˆå·²ç»ç§»åŠ¨åˆ°å°¾éƒ¨ï¼Œä¸æŒ‡å‘ä»»ä½•å…ƒç´ ã€‚
Preserving the Internal Pointer
åœ¨æˆ‘ä»¬éå†ä¸€ä¸ªHashTableæ—¶ï¼Œä¸€èˆ¬æ˜¯å¾ˆéš¾é™·å…¥æ­»å¾ªç¯çš„ã€‚When iterating through a HashTable, particularly one containing userspace variables, itâ€™s not uncommon to encounter circular references, or at least self-overlapping loops. If one iteration context starts looping through a HashTable and the internal pointer reachesfor examplethe halfway mark, a subordinate iterator starts looping through the same HashTable and would obliterate the current internal pointer position, leaving the HashTable at the end when it arrived back at the first loop.</p>

<p>The way this is resolvedboth within the zend_hash_apply implementation and within custom move forward usesis to supply an external pointer in the form of a HashPosition variable.</p>

<p>Each of the zendhash() functions listed previously has a zendhash_ex() counterpart that accepts one additional parameter in the form of a pointer to a HashPostion data type. Because the HashPosition variable is seldom used outside of a short-lived iteration loop, itâ€™s sufficient to declare it as an immediate variable. You can then dereference it on usage such as in the following variation on the php_sample_print_var_hash() function you saw earlier:</p>

<p>void php_sample_print_var_hash(HashTable *arrht)
{
    HashPosition pos;
    for(zend_hash_internal_pointer_reset_ex(arrht, &amp;pos);
    zend_hash_has_more_elements_ex(arrht, &amp;pos) == SUCCESS;
    zend_hash_move_forward_ex(arrht, &amp;pos)) {
        char *key;
        uint keylen;
        ulong idx;
        int type;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    zval **ppzval, tmpcopy;

    type = zend_hash_get_current_key_ex(arrht,
                            &amp;key, &amp;keylen,
                            &amp;idx, 0, &amp;pos);
    if (zend_hash_get_current_data_ex(arrht,
                (void**)&amp;ppzval, &amp;pos) == FAILURE) {
        /* Should never actually fail
         * since the key is known to exist. */
        continue;
    }
    /* Duplicate the zval so that
     * the original's contents are not destroyed */
    tmpcopy = **ppzval;
    zval_copy_ctor(&amp;tmpcopy);
    /* Reset refcount &amp; Convert */
    INIT_PZVAL(&amp;tmpcopy);
    convert_to_string(&amp;tmpcopy);
    /* Output */
    php_printf("The value of ");
    if (type == HASH_KEY_IS_STRING) {
        /* String Key / Associative */
        PHPWRITE(key, keylen);
    } else {
        /* Numeric Key */
        php_printf("%ld", idx);
    }
    php_printf(" is: ");
    PHPWRITE(Z_STRVAL(tmpcopy), Z_STRLEN(tmpcopy));
    php_printf("\n");
    /* Toss out old copy */
    zval_dtor(&amp;tmpcopy);
} } With these very slight additions, the HashTable's true internal pointer is preserved in whatever state it was initially in on entering the function. When it comes to working with internal pointers of userspace variable HashTables (that is, arrays), this extra step will very likely make the difference between whether the scripter's code works as expected.
</code></pre></div></div>

<p>åˆ é™¤
å†…æ ¸ä¸­ä¸€å…±é¢„ç½®äº†å››ä¸ªåˆ é™¤HashTableå…ƒç´ çš„å‡½æ•°ï¼Œå¤´ä¸¤ä¸ªæ˜¯ç”¨æˆ·åˆ é™¤æŸä¸ªç¡®å®šç´¢å¼•çš„æ•°æ®ï¼š</p>

<p>int zendhashdel(HashTable ht, char arKey, uint nKeyLen); int zendhashindex_del(HashTable *ht, ulong h);</p>

<p>å®ƒä»¬ä¸¤ä¸ªåˆ†åˆ«ç”¨æ¥åˆ é™¤å­—ç¬¦ä¸²ç´¢å¼•å’Œæ•°å­—ç´¢å¼•çš„æ•°æ®ï¼Œæ“ä½œå®Œæˆåéƒ½è¿”å›SUCCESSæˆ–è€…FAILUREè¡¨ç¤ºæˆåŠŸorå¤±è´¥ã€‚ å›é¡¾ä¸€ä¸‹æœ€ä¸Šé¢çš„å™è¿°ï¼Œå½“ä¸€ä¸ªå…ƒç´ è¢«åˆ é™¤æ—¶ï¼Œä¼šæ¿€æ´»HashTableçš„destructorå›è°ƒå‡½æ•°ã€‚</p>

<p>void zend_hash_clean(HashTable *ht);
void zend_hash_destroy(HashTable *ht);
å‰è€…ç”¨äºå°†HashTableä¸­çš„å…ƒç´ å…¨éƒ¨åˆ é™¤ï¼Œè€Œåè€…æ˜¯å°†è¿™ä¸ªHashTableè‡ªèº«ä¹Ÿæ¯ç­æ‰ã€‚ ç°åœ¨è®©æˆ‘ä»¬æ¥å®Œæ•´çš„å›é¡¾ä¸€ä¸‹HashTableçš„åˆ›å»ºã€æ·»åŠ ã€åˆ é™¤æ“ä½œã€‚</p>

<p>int sample_strvec_handler(int argc, char **argv TSRMLS_DC)
{
    HashTable *ht;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//åˆ†é…å†…å­˜
ALLOC_HASHTABLE(ht);

//åˆå§‹åŒ–
if (zend_hash_init(ht, argc, NULL,ZVAL_PTR_DTOR, 0) == FAILURE) {
    FREE_HASHTABLE(ht);
    return FAILURE;
}

//å¡«å……æ•°æ®
while (argc) {
    zval *value;
    MAKE_STD_ZVAL(value);
    ZVAL_STRING(value, argv[argc], 1);
    argv++;
    if (zend_hash_next_index_insert(ht, (void**)&amp;value,
                        sizeof(zval*)) == FAILURE) {
        /* Silently skip failed additions */
        zval_ptr_dtor(&amp;value);
    }
}

//å®Œæˆå·¥ä½œ
process_hashtable(ht);

//æ¯å°¸ç­è¿¹
zend_hash_destroy(ht);

//é‡Šæ”¾ht ä¸ºä»€ä¹ˆä¸åœ¨destroyé‡Œfreeå‘¢ï¼Œæ±‚è§£é‡Šï¼
FREE_HASHTABLE(ht);
return SUCCESS; } æ’åºã€æ¯”è¾ƒand Going to the Extreme(s) é’ˆå¯¹HashTableæ“ä½œçš„Zend Apiä¸­æœ‰å¾ˆå¤šéƒ½éœ€è¦å›è°ƒå‡½æ•°ã€‚é¦–å…ˆè®©æˆ‘ä»¬æ¥å¤„ç†ä¸€ä¸‹å¯¹HashTableä¸­å…ƒç´ å¤§å°æ¯”è¾ƒçš„é—®é¢˜ï¼š
</code></pre></div></div>

<p>typedef int (*compare_func_t)(void *a, void *b TSRMLS_DC);
è¿™å¾ˆåƒPHPè¯­è¨€ä¸­usortå‡½æ•°éœ€è¦çš„å‚æ•°ï¼Œå®ƒå°†æ¯”è¾ƒä¸¤ä¸ªå€¼aä¸bï¼Œå¦‚æœa&gt;b,åˆ™è¿”å›1ï¼Œç›¸ç­‰åˆ™è¿”å›0ï¼Œå¦åˆ™è¿”å›-1ã€‚ä¸‹é¢æ˜¯zend_hash_minmaxå‡½æ•°çš„å£°æ˜ï¼Œå®ƒå°±éœ€è¦æˆ‘ä»¬ä¸Šé¢å£°æ˜çš„é‚£ä¸ªç±»å‹çš„å‡½æ•°ä½œä¸ºå›è°ƒå‡½æ•°ï¼š int zend_hash_minmax(HashTable *ht, compare_func_t compar,int flag, void **pData TSRMLS_DC); è¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½æˆ‘ä»¬ä»å®ƒçš„åç§°ä¸­ä¾¿èƒ½è‚¯å®šï¼Œå®ƒç”¨æ¥æ¯”è¾ƒHashTableä¸­çš„å…ƒç´ å¤§å°ã€‚å¦‚æœflag==0åˆ™è¿”å›æœ€å°å€¼ï¼Œå¦åˆ™è¿”å›æœ€å¤§å€¼ï¼</p>

<p>ä¸‹é¢è®©æˆ‘ä»¬æ¥åˆ©ç”¨è¿™ä¸ªå‡½æ•°æ¥å¯¹ç”¨æˆ·ç«¯å®šä¹‰çš„æ‰€æœ‰å‡½æ•°æ ¹æ®å‡½æ•°åæ‰¾åˆ°æœ€å¤§å€¼ä¸æœ€å°å€¼(å¤§å°å†™ä¸æ•æ„Ÿï½)ã€‚</p>

<p>//å…ˆå®šä¹‰ä¸€ä¸ªæ¯”è¾ƒå‡½æ•°ï¼Œä½œä¸ºzend_hash_minmaxçš„å›è°ƒå‡½æ•°ã€‚
int fname_compare(zend_function *a, zend_function *b TSRMLS_DC)
{
    return strcasecmp(a-&gt;common.function_name, b-&gt;common.function_name);
}</p>

<p>void php_sample_funcname_sort(TSRMLS_D)
{
    zend_function *fe;
    if (zend_hash_minmax(EG(function_table), fname_compare,0, (void **)&amp;fe) == SUCCESS)
    {
        php_printf(â€œMin function: %s\nâ€, fe-&gt;common.function_name);
    }
    if (zend_hash_minmax(EG(function_table), fname_compare,1, (void **)&amp;fe) == SUCCESS)
    {
        php_printf(â€œMax function: %s\nâ€, fe-&gt;common.function_name);
    }
}
zend_hash_compare()ä¹Ÿè®¸è¦å›è°ƒå‡½æ•°ï¼Œå®ƒçš„åŠŸèƒ½æ˜¯å°†HashTableçœ‹ä½œä¸€ä¸ªæ•´ä½“ä¸å¦ä¸€ä¸ªHashTableåšæ¯”è¾ƒï¼Œå¦‚æœå‰è€…å¤§äºåè€…è¿”å›1ï¼Œç›¸ç­‰è¿”å›0ï¼Œå¦åˆ™è¿”å›-1ã€‚</p>

<p>int zendhashcompare(HashTable hta, HashTable htb,comparefunct compar, zendbool ordered TSRMLSDC);</p>

<p>é»˜è®¤æƒ…å†µä¸‹å®ƒå¾€å¾€æ˜¯å…ˆåˆ¤æ–­å„ä¸ªHashTableå…ƒç´ çš„ä¸ªæ•°ï¼Œä¸ªæ•°å¤šçš„æœ€å¤§ï¼ å¦‚æœä¸¤è€…çš„å…ƒç´ ä¸€æ ·å¤šï¼Œç„¶åå°±æ¯”è¾ƒå®ƒä»¬å„è‡ªçš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ŒIf the ordered flag is set, it compares keys/indices with the first element of htb string keys are compared first on length, and then on binary sequence using memcmp(). If the keys are equal, the value of the element is compared with the first element of htb using the comparison callback function.</p>

<p>If the ordered flag is not set, the data portion of the first element of hta is compared against the element with a matching key/index in htb using the comparison callback function. If no matching element can be found for htb, then hta is considered greater than htb and 1 is returned.</p>

<p>If at the end of a given loop, hta and htb are still considered equal, comparison continues with the next element of hta until a difference is found or all elements have been exhausted, in which case 0 is returned.</p>

<p>å¦å¤–ä¸€ä¸ªé‡è¦çš„éœ€è¦å›è°ƒå‡½æ•°çš„APIä¾¿æ˜¯æ’åºå‡½æ•°ï¼Œå®ƒéœ€è¦çš„å›è°ƒå‡½æ•°å½¢å¼æ˜¯è¿™æ ·çš„ï¼š</p>

<p>typedef void (<em>sort_func_t)(void **Buckets, size_t numBuckets,size_t sizBucket, compare_func_t comp TSRMLS_DC);
This callback will be triggered once, and receive a vector of all the Buckets (elements) in the HashTable as a series of pointers. These Buckets may be swapped around within the vector according to the sort functionâ€™s own logic with or without the use of the comparison callback. In practice, sizBucket will always be sizeof(Bucket</em>).</p>

<p>Unless you plan on implementing your own alternative bubblesort method, you wonâ€™t need to implement a sort function yourself. A predefined sort methodzend_qsortalready exists for use as a callback to zend_hash_sort() leaving you to implement the comparison function only.</p>

<p>int zend_hash_sort(HashTable *ht, sort_func_t sort_func,compare_func_t compare_func, int renumber TSRMLS_DC);
æœ€åä¸€ä¸ªå‚æ•°å¦‚æœä¸ºTRUEï¼Œåˆ™ä¼šæŠ›å¼ƒHashTableä¸­åŸæœ‰çš„ç´¢å¼•-é”®å…³ç³»ï¼Œå°†å¯¹æ’åˆ—å¥½çš„æ–°å€¼èµ‹äºˆæ–°çš„æ•°å­—é”®å€¼ã€‚PHPè¯­è¨€ä¸­çš„sortå‡½æ•°å®ç°å¦‚ä¸‹ï¼š</p>

<p>zend_hash_sort(target_hash, zend_qsort,array_data_compare, 1 TSRMLS_CC);
array_data_compareæ˜¯ä¸€ä¸ªè¿”å›compare_func_tç±»å‹æ•°æ®çš„å‡½æ•°ï¼Œå®ƒå°†æŒ‰ç…§HashTableä¸­zval*å€¼çš„å¤§å°è¿›è¡Œæ’åºã€‚</p>

<p>https://www.cnblogs.com/niniwzw/archive/2010/03/09/1681932.html
1.å¸¸ç”¨çš„é€šç”¨åŠŸèƒ½å·²ç»å°è£…å¥½äº†ï¼Œåœ¨å¦‚zen_API.h å¤´æ–‡ä»¶ä¸­ï¼Œä¸ç”¨è´¹åŠ›æŸ¥çœ‹å†…éƒ¨ç»†èŠ‚ï¼Œæµªè´¹æ—¶é—´ã€‚ï¼ˆå‚è€ƒï¼šExtending and Embedding PHP çš„é™„å½•Aï¼‰
2.åœ¨terminalä¸­è¿è¡Œæµ‹è¯•ç¨‹åºï¼Œå¯ä»¥çœ‹åˆ°æ‰©å±•çš„å†…éƒ¨é”™è¯¯è¾“å‡ºï¼Œè¿™ä¸€ç‚¹å¯¹äºè§£å†³å†…å­˜æ³„æ¼é—®é¢˜å°¤å…¶é‡è¦ã€‚ï¼ˆç¼–è¯‘ä¸€ä¸ªdebug çš„ libï¼‰
3.å¼€å‘è¿‡ç¨‹ä¸­ä¿®æ”¹Makefileä¸­çš„â€œCFLAGS = -g -O2â€ï¼Œå»æ‰ä¼˜åŒ–é€‰é¡¹ï¼Œå¢åŠ -Wallå’Œ-pedanticï¼Œä¾¿äºè°ƒè¯•å’Œæ˜¾ç¤ºç¼–è¯‘è­¦å‘Šï¼›
4.æŸzval<em>ï¼Œä½†å…¶strvaléæ‹·è´çš„ï¼Œä¸å¯ç”¨zval_ptr_dtor(zval<strong>)ï¼Œè¦ç”¨efree(void*)ã€‚
5.terminalä¸­çš„$_SERVER[â€˜PWDâ€™]æœ‰å€¼ï¼Œä½†æ˜¯æ— æ³•é€šè¿‡zend_getenv()å–å¾—ï¼ŒåŸå› åº”è¯¥æ˜¯è¯¥å€¼æ— æ„ä¹‰æˆ–ä¸å¯é ã€‚
6.è°ƒç”¨â€œå¯¼å‡ºå‡½æ•°â€ï¼Œå¯åˆ©ç”¨INTERNAL_FUNCTION_PARAM_PASSTHRUä¼ å‚ï¼›å£°æ˜çš„éå¯¼å‡ºå‡½æ•°å¯é€šè¿‡INTERNAL_FUNCTION_PARAMä½¿ç”¨â€œå¯¼å‡ºå‡½æ•°â€çš„å‚æ•°ã€‚
7.æ³¨æ„ï¼šRETURN_TYPEç”¨åœ¨é€‰æ‹©åˆ†ä¹‹å’Œå¾ªç¯ç­‰å¤„æ—¶ï¼Œæœ€å¥½ç½®äºèŠ±æ‹¬å·ä¸­ï¼Œ
æˆ–è€…ä¸ç”¨åˆ†å·ï¼Œå› ä¸ºï¼š#define RETURN_BOOL(b) { RETVAL_BOOL(b); return; }ã€‚
8.å¦‚æœå‡½æ•°çš„å‚æ•°æ˜¯å¼•ç”¨çš„ï¼Œä¸”éæ ‡é‡ï¼Œè¦å…ˆææ„ï¼Œä»¥é˜²å†…å­˜æ³„éœ²ã€‚
9.æŠ›å‡ºå¼‚å¸¸å‰æœ€å¥½åˆ¤æ–­EG(exception)ä¸­æ˜¯å¦å·²ç»å­˜åœ¨å¼‚å¸¸ï¼Œå¦åˆ™ä¼šé€ æˆå†…å­˜æ³„éœ²ã€‚
10.å½“WebæœåŠ¡å™¨APIæ˜¯ISAPI (IIS)çš„æ—¶å€™ï¼Œzend_getenvå‡½æ•°æ˜¯ä¸èµ·ä½œç”¨çš„ã€‚
11.å‘zend_stack_push()ä¼ å…¥æ•°æ®æŒ‡é’ˆï¼Œå®é™…å­˜å‚¨(copy)çš„æ˜¯è¯¥æŒ‡é’ˆæŒ‡å‘çš„æ•°æ®ï¼Œæ¢å¥è¯è¯´ï¼Œä¼ å…¥çš„åº”è¯¥æ˜¯è¦å­˜å‚¨çš„æ•°æ®çš„æŒ‡é’ˆã€‚
ZEND_API int zend_stack_push(zend_stack *stack, void *element, int size);
ZEND_API int zend_stack_top(zend_stack *stack, void **element);
å…¶ä¸­ï¼Œsize == sizeof(*element);
ç±»ä¼¼åœ°ï¼Œzend_hashä¹Ÿæ˜¯å¦‚æ­¤ï¼Œæ¯”è¾ƒzend_hash_updateå’Œzend_hash_findã€‚
12.ä½¿ç”¨add_assoc_zval(HashTable*, const char*, zval*)å­˜å‚¨çš„æ˜¯zval*ï¼Œè€Œézvalï¼Œå› æ­¤ï¼Œ
å­˜å‚¨ç”¨æˆ·ä¼ å…¥çš„å‚æ•°æ—¶å€™ï¼Œè¦å…ˆæ‹·è´ä¸€ä»½æ–°çš„zvalï¼Œå¦åˆ™ä¼šå‘ç”Ÿä¸å¯é¢„æ–™çš„äº‹æƒ…ã€‚
13.zval_dtor(zval*)é‡Šæ”¾å˜é‡åŠå…¶å†…éƒ¨çš„å¼•ç”¨å†…å­˜ï¼Œzval_ptr_dtor(zval</strong>)å…ˆæ£€æŸ¥refcount
å†å†³å®šæ˜¯å¦è°ƒç”¨zval_dtor(zval</em>)ï¼Œzval_copy_dtor(zval*)ä»…æ‰§è¡Œæ·±å±‚çš„æ‹·è´ï¼Œå³åªæ‹·è´
èµ·å†…éƒ¨å¼•ç”¨çš„å†…å­˜ï¼Œè€Œä¸æ‹·è´zvalï¼›</p>

<p>14.å¦‚ä½¿ç”¨VCç¼–è¯‘winçš„åŠ¨æ€é“¾æ¥åº“ï¼Œè€Œä¸”ä»£ç ä¸­è°ƒç”¨äº†zendå‡½æ•°ï¼Œå¦‚zend_getenvï¼Œåœ¨zend.hä¸­å®šä¹‰ä¸ºï¼š</p>

<p>extern â€œCâ€ {
extern ZEND_API char <em>(</em>zend_getenv)(char <em>name, size_t name_len TSRMLS_DC);
}
éœ€è¦å¼•å…¥è¯¥å‡½æ•°ï¼Œå¦‚è¦ä½¿ç”¨ZEND_APIï¼Œéœ€è¦äº‹å…ˆå–æ¶ˆLIBZEND_EXPORTSï¼ˆåŒ…æ‹¬VCâ€œè®¾ç½®â€ä¸­çš„é¢„å¤„ç†å®šä¹‰ï¼‰ï¼Œæˆ–è€…ä½¿ç”¨ZEND_DLIMPORTï¼Œ
ZEND_DLIMPORT char *(</em>zend_getenv)(char *name, size_t name_len TSRMLS_DC);
ä¸‹é¢å–è‡ªï¼šzend_config.w32.h</p>

<p>å¤åˆ¶ä»£ç ä»£ç å¦‚ä¸‹:</p>

<p>#ifdef LIBZEND_EXPORTS</p>
<h1 id="define-zend_api-__declspecdllexport">define ZEND_API __declspec(dllexport)</h1>
<p>#else</p>
<h1 id="define-zend_api-__declspecdllimport">define ZEND_API __declspec(dllimport)</h1>
<p>#endif
#define ZEND_DLEXPORT __declspec(dllexport)
#define ZEND_DLIMPORT __declspec(dllimport)</p>

<p>https://zhuanlan.zhihu.com/p/84221387
https://blog.csdn.net/caohao0591/article/details/82191001
https://www.php.net/manual/en/internals2.variables.tables.php
https://learnku.com/articles/9173/2-analysis-of-zval
https://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html
https://segmentfault.com/a/1190000007575322
https://www.bo56.com/php7%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%E4%B9%8B%E9%85%8D%E7%BD%AE%E9%A1%B9/</p>

:ET