I",<p>go-mir v2.0.0 发布了，推荐使用。</p>

<p>功能特性：</p>

<p>使用Go结构体标签定义handler路由信息；
自动根据定义的结构体标签信息生成handler接口，开发者实现相应接口后注册到router，与gRPC的使用方式类似；
内置支持gin、go-chi、mux、httprouter的代码生成器；
自带脚手架mirc自动生成gin、go-chi、mux、httprouter样式的模板工程代码；
开发详情：</p>

<p>与版本 v1不同，版本v2采用代码生成的方式从定义的结构体标签信息生成handler接口，开发者实现相应接口完成Web API的功能，非常漂亮的支持了基于接口编程的范式。
<!-- more -->
go-mir v1的架构大体是这样：</p>

<p>这套架构主要是使用了golang的反射机制对struct tag解析然后注册路由信息到web engine，只影响启动时间，不会有运行时损耗，总体来说，方便了接口定义，对代码组织很有益处。</p>

<p>go-mir v2版本大体架构如下：</p>

<p>v2版本升级采用代码生成的方式生成接口代码，同样也是采用golang内置的struct tag定义路由信息；不同于v1版本在引擎启动时解析后注册路由信息到web引擎，这里参考grpc的接口生成方式，生成接口定义文件，业务逻辑只要实现了接口，注册接口实现的对象到相应的web引擎，启动后就可以对外通过RESTfull接口获取服务。</p>

<p>代码示例：(eg: gin style)</p>

<p>生成样板代码
% go get github.com/alimy/mir/mirc/v2@latest
% mirc new -d mir-examples
% tree mir-examples
mir-examples
├── Makefile
├── README.md
├── go.mod
├── main.go
└── mirc
    ├── main.go
    └── routes
        ├── site.go
        ├── v1
        │   └── site.go
        └── v2
            └── site.go</p>

<p>% cd mir-examples
% make generate
自定义路由信息，比如：
// file: mirc/routes/site.go</p>

<p>package routes</p>

<p>import “github.com/alimy/mir/v2”</p>

<p>// Site mir’s struct tag define
type Site struct {
	Chain    mir.Chain <code class="language-plaintext highlighter-rouge">mir:"-"</code>
	Index    mir.Get   <code class="language-plaintext highlighter-rouge">mir:"/index/"</code>
	Articles mir.Get   <code class="language-plaintext highlighter-rouge">mir:"/articles/:category/"</code>
}
定义生成器入口，比如</p>

<p>% cat mirc/main.go
package main</p>

<p>import (
	“log”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/alimy/mir/v2/core"
"github.com/alimy/mir/v2/engine"

routes "github.com/alimy/mir/v2/examples/mirc/routes"
v1 "github.com/alimy/mir/v2/examples/mirc/routes/v1"
v2 "github.com/alimy/mir/v2/examples/mirc/routes/v2" )
</code></pre></div></div>

<p>//go:generate go run main.go
func main() {
	log.Println(“generate code start”)
	entries := mirEntries()
	opts := &amp;core.Options{
		GeneratorName: core.GeneratorGin,
		GeneratorOpts: core.InitOpts{
			core.OptSinkPath: “./gen”,
		},
	}
	if err := engine.Generate(entries, opts); err != nil {
		log.Fatal(err)
	}
	log.Println(“generate code finish”)
}</p>

<p>func mirEntries() []interface{} {
	return []interface{}{
		new(routes.Site),
		new(v1.Site),
		new(v2.Site),
	}
}
自动生成接口，基于上面的定义，生成器将自动生成接口定义文件，如下：
% make generate
% cat mirc/gen/api/site.go
// Code generated by go-mir. DO NOT EDIT.</p>

<p>package api</p>

<p>import (
	“github.com/gin-gonic/gin”
)</p>

<p>// Site mir’s struct tag define
type Site interface {
	Chain() gin.HandlersChain
	Index(c *gin.Context)
	Articles(c *gin.Context)
}</p>

<p>// RegisterSiteServant register site to gin
func RegisterSiteServant(e *gin.Engine, s Site) {
	router := e</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// use chain for router
middlewares := s.Chain()
router.Use(middlewares...)

// register route info to router
router.Handle("GET", "/index/", s.Index)
router.Handle("GET", "/articles/:category/", s.Articles) } 注册接口实现对象到相对应的router，比如： package main
</code></pre></div></div>

<p>import (
	“log”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/gin-gonic/gin"

"github.com/alimy/mir/v2/examples/mirc/gen/api"
"github.com/alimy/mir/v2/examples/mirc/gen/api/v1"
"github.com/alimy/mir/v2/examples/mirc/gen/api/v2"
"github.com/alimy/mir/v2/examples/servants" )
</code></pre></div></div>

<p>func main() {
	e := gin.New()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// register servants to engine
registerServants(e)

// start servant service
if err := e.Run(); err != nil {
	log.Fatal(err)
} }
</code></pre></div></div>

<p>func registerServants(e *gin.Engine) {
	// register default group routes
	api.RegisterSiteServant(e, servants.EmptySiteWithNoGroup{})</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// register routes for group v1
v1.RegisterSiteServant(e, servants.EmptySiteV1{})

// register routes for group v2
v2.RegisterSiteServant(e, servants.EmptySiteV2{}) } 最后，构建并运行应用: % make run
</code></pre></div></div>
:ET