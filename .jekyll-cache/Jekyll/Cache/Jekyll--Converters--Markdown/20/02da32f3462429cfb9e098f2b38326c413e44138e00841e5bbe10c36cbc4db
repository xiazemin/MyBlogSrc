I"½?<p>goè‡ªå¸¦çš„runtimeåŒ…æ‹¥æœ‰å„ç§åŠŸèƒ½ï¼ŒåŒ…æ‹¬goroutineæ•°é‡ï¼Œè®¾ç½®é€»è¾‘çº¿ç¨‹æ•°é‡ï¼Œå½“å‰goç‰ˆæœ¬ï¼Œå½“å‰ç³»ç»Ÿç±»å‹ç­‰ç­‰ã€‚å‰ä¸¤å¤©å‘ç°äº†goæ ‡å‡†åº“è¿˜æœ‰ä¸€ä¸ªæ›´å¥½ç”¨çš„å¯ä»¥ç›‘æ§æœåŠ¡è¿è¡Œå„é¡¹æŒ‡æ ‡å’ŒçŠ¶æ€çš„åŒ…â€”-expvarã€‚ expvaråŒ…ä¸ºç›‘æ§å˜é‡æä¾›äº†ä¸€ä¸ªæ ‡å‡†åŒ–çš„æ¥å£ï¼Œå®ƒä»¥ JSON æ ¼å¼é€šè¿‡ /debug/vars æ¥å£ä»¥ HTTP çš„æ–¹å¼å…¬å¼€è¿™äº›ç›‘æ§å˜é‡ä»¥åŠæˆ‘è‡ªå®šä¹‰çš„å˜é‡ã€‚é€šè¿‡å®ƒï¼Œå†åŠ ä¸ŠmetricBeatï¼ŒESå’ŒKibanaï¼Œå¯ä»¥å¾ˆè½»æ¾çš„å¯¹æœåŠ¡è¿›è¡Œç›‘æ§ã€‚æˆ‘è¿™é‡Œæ˜¯ç”¨ginæŠŠæ¥å£æš´éœ²å‡ºæ¥ï¼Œå…¶å®ç”¨åˆ«çš„webæ¡†æ¶ä¹Ÿéƒ½å¯ä»¥ã€‚ä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹å¦‚ä½•ä½¿ç”¨å®ƒï¼ˆç¤ºä¾‹ä»£ç ä½¿ç”¨GIN HTTP web frameworkï¼‰ï¼š
<!-- more -->
package main</p>

<p>import (
	â€œexpvarâ€
	â€œgithub.com/gin-gonic/ginâ€
	â€œnet/httpâ€
	â€œnet/http/pprofâ€
	â€œtimeâ€
)</p>

<p>func main() {
	router := gin.Default()
	router.GET(â€œ/debug/varsâ€, monitor.GetCurrentRunningStats)
	s := &amp;http.Server{
		Addr:           â€œ:9090â€,
		Handler:        router,
		ReadTimeout:    5 * time.Second,
		WriteTimeout:   5 * time.Second,
		MaxHeaderBytes: 1 Â«Â 20,
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s.ListenAndServe() } å¯¹åº”çš„handler package monitor
</code></pre></div></div>

<p>import (
	â€œencoding/jsonâ€
	â€œexpvarâ€
	â€œfmtâ€
	â€œgithub.com/gin-gonic/ginâ€
	â€œnet/httpâ€
	â€œruntimeâ€
	â€œtimeâ€
)</p>

<p>// å¼€å§‹æ—¶é—´
var start = time.Now()</p>

<p>// calculateUptime è®¡ç®—è¿è¡Œæ—¶é—´
func calculateUptime() interface{} {
	return time.Since(start).String()
}</p>

<p>// currentGoVersion å½“å‰ Golang ç‰ˆæœ¬
func currentGoVersion() interface{} {
	return runtime.Version()
}</p>

<p>// getNumCPUs è·å– CPU æ ¸å¿ƒæ•°é‡
func getNumCPUs() interface{} {
	return runtime.NumCPU()
}</p>

<p>// getGoOS å½“å‰ç³»ç»Ÿç±»å‹
func getGoOS() interface{} {
	return runtime.GOOS
}</p>

<p>// getNumGoroutins å½“å‰ goroutine æ•°é‡
func getNumGoroutins() interface{} {
	return runtime.NumGoroutine()
}</p>

<p>// getNumCgoCall CGo è°ƒç”¨æ¬¡æ•°
func getNumCgoCall() interface{} {
	return runtime.NumCgoCall()
}</p>

<p>var lastPause uint32</p>

<p>// getLastGCPauseTime è·å–ä¸Šæ¬¡ GC çš„æš‚åœæ—¶é—´
func getLastGCPauseTime() interface{} {
	var gcPause uint64
	ms := new(runtime.MemStats)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>statString := expvar.Get("memstats").String()
if statString != "" {
	json.Unmarshal([]byte(statString), ms)

	if lastPause == 0 || lastPause != ms.NumGC {
		gcPause = ms.PauseNs[(ms.NumGC+255)%256]
		lastPause = ms.NumGC
	}
}

return gcPause }
</code></pre></div></div>

<p>// GetCurrentRunningStats è¿”å›å½“å‰è¿è¡Œä¿¡æ¯
func GetCurrentRunningStats(c *gin.Context) {
	c.Writer.Header().Set(â€œContent-Typeâ€, â€œapplication/json; charset=utf-8â€)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>first := true
report := func(key string, value interface{}) {
	if !first {
		fmt.Fprintf(c.Writer, ",\n")
	}
	first = false
	if str, ok := value.(string); ok {
		fmt.Fprintf(c.Writer, "%q: %q", key, str)
	} else {
		fmt.Fprintf(c.Writer, "%q: %v", key, value)
	}
}

fmt.Fprintf(c.Writer, "{\n")
expvar.Do(func(kv expvar.KeyValue) {
	report(kv.Key, kv.Value)
})
fmt.Fprintf(c.Writer, "\n}\n")

c.String(http.StatusOK, "") }
</code></pre></div></div>

<p>func init() { //è¿™äº›éƒ½æ˜¯æˆ‘è‡ªå®šä¹‰çš„å˜é‡ï¼Œå‘å¸ƒåˆ°expvarä¸­ï¼Œæ¯æ¬¡è¯·æ±‚æ¥å£ï¼Œexpvarä¼šè‡ªåŠ¨å»è·å–è¿™äº›å˜é‡ï¼Œå¹¶è¿”å›ç»™æˆ‘
	expvar.Publish(â€œè¿è¡Œæ—¶é—´â€, expvar.Func(calculateUptime))
	expvar.Publish(â€œversionâ€, expvar.Func(currentGoVersion))
	expvar.Publish(â€œcoresâ€, expvar.Func(getNumCPUs))
	expvar.Publish(â€œosâ€, expvar.Func(getGoOS))
	expvar.Publish(â€œcgoâ€, expvar.Func(getNumCgoCall))
	expvar.Publish(â€œgoroutineâ€, expvar.Func(getNumGoroutins))
	expvar.Publish(â€œgcpauseâ€, expvar.Func(getLastGCPauseTime))
}
è¿è¡Œç¨‹åºï¼Œè®¿é—®http://localhost:9090/debug/varsï¼Œå¦‚ä¸‹</p>

<p>1530461378444</p>

<p>å¯ä»¥çœ‹åˆ°ï¼Œexpvarè¿”å›ç»™äº†æˆ‘æˆ‘ä¹‹å‰è‡ªå®šä¹‰çš„æ•°æ®ï¼Œä»¥åŠå®ƒæœ¬èº«è¦é»˜è®¤è¿”å›çš„æ•°æ®ï¼Œæ¯”å¦‚memstatsã€‚è¿™ä¸ªmemstatsæ˜¯å¹²å˜›çš„å‘¢ï¼Œå…¶å®çœ‹åˆ°è¿™äº›å­—æ®µåå°±å¯ä»¥çŸ¥é“ï¼Œæ˜¯å„ç§å†…å­˜å †æ ˆä»¥åŠGCçš„ä¸€äº›ä¿¡æ¯ï¼Œå…·ä½“å¯ä»¥çœ‹æºç æ³¨é‡Šï¼š
type MemStats struct {
   // General statistics.</p>

<p>// Alloc is bytes of allocated heap objects.
   //
   // This is the same as HeapAlloc (see below).
   Alloc uint64</p>

<p>// TotalAlloc is cumulative bytes allocated for heap objects.
   //
   // TotalAlloc increases as heap objects are allocated, but
   // unlike Alloc and HeapAlloc, it does not decrease when
   // objects are freed.
   TotalAlloc uint64</p>

<p>// Sys is the total bytes of memory obtained from the OS.
   //
   // Sys is the sum of the XSys fields below. Sys measures the
   // virtual address space reserved by the Go runtime for the
   // heap, stacks, and other internal data structures. Itâ€™s
   // likely that not all of the virtual address space is backed
   // by physical memory at any given moment, though in general
   // it all was at some point.
   Sys uint64</p>

<p>// Lookups is the number of pointer lookups performed by the
   // runtime.
   //
   // This is primarily useful for debugging runtime internals.
   Lookups uint64</p>

<p>// Mallocs is the cumulative count of heap objects allocated.
   // The number of live objects is Mallocs - Frees.
   Mallocs uint64</p>

<p>// Frees is the cumulative count of heap objects freed.
   Frees uint64</p>

<p>// Heap memory statistics.
   //
   // Interpreting the heap statistics requires some knowledge of
   // how Go organizes memory. Go divides the virtual address
   // space of the heap into â€œspansâ€, which are contiguous
   // regions of memory 8K or larger. A span may be in one of
   // three states:
   //
   // An â€œidleâ€ span contains no objects or other data. The
   // physical memory backing an idle span can be released back
   // to the OS (but the virtual address space never is), or it
   // can be converted into an â€œin useâ€ or â€œstackâ€ span.
   //
   // An â€œin useâ€ span contains at least one heap object and may
   // have free space available to allocate more heap objects.
   //
   // A â€œstackâ€ span is used for goroutine stacks. Stack spans
   // are not considered part of the heap. A span can change
   // between heap and stack memory; it is never used for both
   // simultaneously.</p>

<p>// HeapAlloc is bytes of allocated heap objects.
   //
   // â€œAllocatedâ€ heap objects include all reachable objects, as
   // well as unreachable objects that the garbage collector has
   // not yet freed. Specifically, HeapAlloc increases as heap
   // objects are allocated and decreases as the heap is swept
   // and unreachable objects are freed. Sweeping occurs
   // incrementally between GC cycles, so these two processes
   // occur simultaneously, and as a result HeapAlloc tends to
   // change smoothly (in contrast with the sawtooth that is
   // typical of stop-the-world garbage collectors).
   HeapAlloc uint64</p>

<p>// HeapSys is bytes of heap memory obtained from the OS.
   //
   // HeapSys measures the amount of virtual address space
   // reserved for the heap. This includes virtual address space
   // that has been reserved but not yet used, which consumes no
   // physical memory, but tends to be small, as well as virtual
   // address space for which the physical memory has been
   // returned to the OS after it became unused (see HeapReleased
   // for a measure of the latter).
   //
   // HeapSys estimates the largest size the heap has had.
   HeapSys uint64</p>

<p>// HeapIdle is bytes in idle (unused) spans.
   //
   // Idle spans have no objects in them. These spans could be
   // (and may already have been) returned to the OS, or they can
   // be reused for heap allocations, or they can be reused as
   // stack memory.
   //
   // HeapIdle minus HeapReleased estimates the amount of memory
   // that could be returned to the OS, but is being retained by
   // the runtime so it can grow the heap without requesting more
   // memory from the OS. If this difference is significantly
   // larger than the heap size, it indicates there was a recent
   // transient spike in live heap size.
   HeapIdle uint64</p>

<p>// HeapInuse is bytes in in-use spans.
   //
   // In-use spans have at least one object in them. These spans
   // can only be used for other objects of roughly the same
   // size.
   //
   // HeapInuse minus HeapAlloc esimates the amount of memory
   // that has been dedicated to particular size classes, but is
   // not currently being used. This is an upper bound on
   // fragmentation, but in general this memory can be reused
   // efficiently.
   HeapInuse uint64</p>

<p>// HeapReleased is bytes of physical memory returned to the OS.
   //
   // This counts heap memory from idle spans that was returned
   // to the OS and has not yet been reacquired for the heap.
   HeapReleased uint64</p>

<p>// HeapObjects is the number of allocated heap objects.
   //
   // Like HeapAlloc, this increases as objects are allocated and
   // decreases as the heap is swept and unreachable objects are
   // freed.
   HeapObjects uint64</p>

<p>// Stack memory statistics.
   //
   // Stacks are not considered part of the heap, but the runtime
   // can reuse a span of heap memory for stack memory, and
   // vice-versa.</p>

<p>// StackInuse is bytes in stack spans.
   //
   // In-use stack spans have at least one stack in them. These
   // spans can only be used for other stacks of the same size.
   //
   // There is no StackIdle because unused stack spans are
   // returned to the heap (and hence counted toward HeapIdle).
   StackInuse uint64</p>

<p>// StackSys is bytes of stack memory obtained from the OS.
   //
   // StackSys is StackInuse, plus any memory obtained directly
   // from the OS for OS thread stacks (which should be minimal).
   StackSys uint64</p>

<p>// Off-heap memory statistics.
   //
   // The following statistics measure runtime-internal
   // structures that are not allocated from heap memory (usually
   // because they are part of implementing the heap). Unlike
   // heap or stack memory, any memory allocated to these
   // structures is dedicated to these structures.
   //
   // These are primarily useful for debugging runtime memory
   // overheads.</p>

<p>// MSpanInuse is bytes of allocated mspan structures.
   MSpanInuse uint64</p>

<p>// MSpanSys is bytes of memory obtained from the OS for mspan
   // structures.
   MSpanSys uint64</p>

<p>// MCacheInuse is bytes of allocated mcache structures.
   MCacheInuse uint64</p>

<p>// MCacheSys is bytes of memory obtained from the OS for
   // mcache structures.
   MCacheSys uint64</p>

<p>// BuckHashSys is bytes of memory in profiling bucket hash tables.
   BuckHashSys uint64</p>

<p>// GCSys is bytes of memory in garbage collection metadata.
   GCSys uint64</p>

<p>// OtherSys is bytes of memory in miscellaneous off-heap
   // runtime allocations.
   OtherSys uint64</p>

<p>// Garbage collector statistics.</p>

<p>// NextGC is the target heap size of the next GC cycle.
   //
   // The garbage collectorâ€™s goal is to keep HeapAlloc â‰¤ NextGC.
   // At the end of each GC cycle, the target for the next cycle
   // is computed based on the amount of reachable data and the
   // value of GOGC.
   NextGC uint64</p>

<p>// LastGC is the time the last garbage collection finished, as
   // nanoseconds since 1970 (the UNIX epoch).
   LastGC uint64</p>

<p>// PauseTotalNs is the cumulative nanoseconds in GC
   // stop-the-world pauses since the program started.
   //
   // During a stop-the-world pause, all goroutines are paused
   // and only the garbage collector can run.
   PauseTotalNs uint64</p>

<p>// PauseNs is a circular buffer of recent GC stop-the-world
   // pause times in nanoseconds.
   //
   // The most recent pause is at PauseNs[(NumGC+255)%256]. In
   // general, PauseNs[N%256] records the time paused in the most
   // recent N%256th GC cycle. There may be multiple pauses per
   // GC cycle; this is the sum of all pauses during a cycle.
   PauseNs [256]uint64</p>

<p>// PauseEnd is a circular buffer of recent GC pause end times,
   // as nanoseconds since 1970 (the UNIX epoch).
   //
   // This buffer is filled the same way as PauseNs. There may be
   // multiple pauses per GC cycle; this records the end of the
   // last pause in a cycle.
   PauseEnd [256]uint64</p>

<p>// NumGC is the number of completed GC cycles.
   NumGC uint32</p>

<p>// NumForcedGC is the number of GC cycles that were forced by
   // the application calling the GC function.
   NumForcedGC uint32</p>

<p>// GCCPUFraction is the fraction of this programâ€™s available
   // CPU time used by the GC since the program started.
   //
   // GCCPUFraction is expressed as a number between 0 and 1,
   // where 0 means GC has consumed none of this programâ€™s CPU. A
   // programâ€™s available CPU time is defined as the integral of
   // GOMAXPROCS since the program started. That is, if
   // GOMAXPROCS is 2 and a program has been running for 10
   // seconds, its â€œavailable CPUâ€ is 20 seconds. GCCPUFraction
   // does not include CPU time used for write barrier activity.
   //
   // This is the same as the fraction of CPU reported by
   // GODEBUG=gctrace=1.
   GCCPUFraction float64</p>

<p>// EnableGC indicates that GC is enabled. It is always true,
   // even if GOGC=off.
   EnableGC bool</p>

<p>// DebugGC is currently unused.
   DebugGC bool</p>

<p>// BySize reports per-size class allocation statistics.
   //
   // BySize[N] gives statistics for allocations of size S where
   // BySize[N-1].Size &lt; S â‰¤ BySize[N].Size.
   //
   // This does not report allocations larger than BySize[60].Size.
   BySize [61]struct {
      // Size is the maximum byte size of an object in this
      // size class.
      Size uint32</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // Mallocs is the cumulative count of heap objects
  // allocated in this size class. The cumulative bytes
  // of allocation is Size*Mallocs. The number of live
  // objects in this size class is Mallocs - Frees.
  Mallocs uint64

  // Frees is the cumulative count of heap objects freed
  // in this size class.
  Frees uint64    } } å¦‚æœéœ€è¦æŸ¥çœ‹å…¶å¯¹åº”çš„ç¿»è¯‘ï¼Œè¯·çœ‹è¿™é‡Œ
</code></pre></div></div>

<p>pprof
æœ‰å…³pprofçš„åŸºæœ¬ä»‹ç»å’Œä½¿ç”¨ï¼Œå¯ä»¥å‚è€ƒè¿™é‡Œï¼Œæœ€ç®€å•çš„ä½¿ç”¨æ–¹å¼å¦‚ä¸‹
package main</p>

<p>import (
	â€œnet/httpâ€
	_ â€œnet/http/pprofâ€
)</p>

<p>func main() {
	http.ListenAndServe(â€œ:9090â€, nil)
}
è¿è¡Œç¨‹åºï¼Œè®¿é—®http://localhost:9090/debug/pprofå¯ä»¥çœ‹åˆ°å¦‚ä¸‹ç»“æœ</p>

<p>1530462279152</p>

<p>é…åˆgo tool pprofä¸€èµ·ä½¿ç”¨ï¼Œä¾‹å¦‚æŸ¥çœ‹cpuè¯¦æƒ…ï¼Œå¯ä»¥é€šè¿‡å¦‚ä¸‹å‘½ä»¤å®ç°
root@kaku-Inspiron-7537:~/blog# go tool pprof localhost:9090/debug/pprof/profile
Fetching profile over HTTP from http://localhost:9090/debug/pprof/profile
Saved profile in /root/pprof/pprof.<em>__go_build_main_go__1</em>.samples.cpu.002.pb.gz
File: <em>__go_build_main_go__1</em>
Type: cpu
Time: Jul 2, 2018 at 12:44am (CST)
Duration: 30s, Total samples = 0 
Entering interactive mode (type â€œhelpâ€ for commands, â€œoâ€ for options)
(pprof) web
æ‰§è¡Œå®Œä¹‹åï¼Œå¦‚æœæœ¬åœ°å®‰è£…äº†graphvizå’Œchromeï¼Œåˆ™è‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨ï¼Œå¯ä»¥åœ¨å…¶ä¸­çœ‹åˆ°å¦‚ä¸‹å›¾ç‰‡</p>

<p>1530463634094</p>

<p>å› ä¸ºç¤ºä¾‹ç¨‹åºæ²¡æœ‰ä»»ä½•å…¶ä»–ä»£ç ï¼Œä¹‹æš´éœ²äº†httpæœåŠ¡ï¼Œæ‰€ä»¥çœ‹åˆ°çš„ç»“æœæ¯”è¾ƒå•è°ƒ</p>

<p>Prometheus
Prometheus clientå†…ç½®äº†golang metricsæš´éœ²çš„handlerï¼Œåªéœ€è¦ç®€å•è°ƒç”¨å³å¯å®ç°ï¼Œå¦‚ä¸‹
package main</p>

<p>import (
    â€œgithub.com/prometheus/client_golang/prometheus/promhttpâ€
    â€œnet/httpâ€
)</p>

<p>func main() {
    http.Handle(â€œ/metricsâ€, promhttp.Handler())
    panic(http.ListenAndServe(â€œ:9090â€, nil))
}
è¿è¡Œç¨‹åºï¼Œè®¿é—®http://localhost:9090/metrics å³å¯ã€‚</p>

<p>åŒæ—¶å¯ä»¥é€šè¿‡Prometheusæ¥é‡‡é›†æ­¤Endpointæš´éœ²å‡ºæ¥çš„æ•°æ®ï¼Œä¹Ÿå¯ä»¥è¿›è¡Œè‡ªå®šä¹‰æ•°æ®çš„é‡‡é›†</p>
:ET