I"¢:<p>https://gocn.vip/topics/9884
go 1.14 ä¸­æ¯”è¾ƒå¤§çš„æ›´æ–°æœ‰ä¿¡å·çš„æŠ¢å è°ƒåº¦ã€defer å†…è”ä¼˜åŒ–ï¼Œå®šæ—¶å™¨ä¼˜åŒ–ç­‰ã€‚å‰å‡ å¤©åˆšå†™å®Œäº† golang 1.14 timer å®šæ—¶å™¨çš„ä¼˜åŒ–ï¼Œæœ‰å…´è¶£çš„æœ‹å‹å¯ä»¥çœ‹çœ‹go1.14 åŸºäº netpoll ä¼˜åŒ– timer å®šæ—¶å™¨å®ç°åŸç†</p>

<p>golang åœ¨ä¹‹å‰çš„ç‰ˆæœ¬ä¸­å·²ç»å®ç°äº†æŠ¢å è°ƒåº¦ï¼Œä¸ç®¡æ˜¯é™·å…¥åˆ°å¤§é‡è®¡ç®—è¿˜æ˜¯ç³»ç»Ÿè°ƒç”¨ï¼Œå¤§å¤šå¯è¢« sysmon æ‰«æåˆ°å¹¶è¿›è¡ŒæŠ¢å ã€‚ä½†æœ‰äº›åœºæ™¯æ˜¯æ— æ³•æŠ¢å æˆåŠŸçš„ã€‚æ¯”å¦‚è½®è¯¢è®¡ç®— for { i++ } ç­‰ï¼Œè¿™ç±»æ“ä½œæ— æ³•è¿›è¡Œ newstackã€morestackã€syscallï¼Œæ‰€ä»¥æ— æ³•æ£€æµ‹ stackguard0 = stackpreemptã€‚</p>

<p>go team å·²ç»æ„è¯†åˆ°æŠ¢å æ˜¯ä¸ªé—®é¢˜ï¼Œæ‰€ä»¥åœ¨ 1.14 ä¸­åŠ å…¥äº†åŸºäºä¿¡å·çš„åç¨‹è°ƒåº¦æŠ¢å ã€‚åŸç†æ˜¯è¿™æ ·çš„ï¼Œé¦–å…ˆæ³¨å†Œç»‘å®š SIGURG ä¿¡å·åŠå¤„ç†æ–¹æ³• runtime.doSigPreemptï¼Œsysmon ä¼šé—´éš”æ€§æ£€æµ‹è¶…æ—¶çš„ pï¼Œç„¶åå‘é€ä¿¡å·ï¼Œm æ”¶åˆ°ä¿¡å·åä¼‘çœ æ‰§è¡Œçš„ goroutine å¹¶ä¸”è¿›è¡Œé‡æ–°è°ƒåº¦ã€‚
<!-- more -->
å¯¹æ¯”æµ‹è¯•:
// xiaorui.cc</p>

<p>package main</p>

<p>import (
    â€œruntimeâ€
)</p>

<p>func main() {
    runtime.GOMAXPROCS(1)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go func() {
    panic("already call")
}()

for {
} } ä¸Šé¢çš„æµ‹è¯•æ€è·¯æ˜¯å…ˆé’ˆå¯¹ GOMAXPROCS çš„ p é…ç½®ä¸º 1ï¼Œè¿™æ ·å°±å¯ä»¥è§„é¿å¹¶å‘è€Œå½±å“æŠ¢å çš„æµ‹è¯•ï¼Œç„¶å go å…³é”®å­—ä¼šæŠŠå½“å‰ä¼ é€’çš„å‡½æ•°å°è£…åç¨‹ç»“æ„,æ‰”åˆ° runq é˜Ÿåˆ—é‡Œç­‰å¾… runtime è°ƒåº¦ï¼Œç”±äºæ˜¯å¼‚æ­¥æ‰§è¡Œï¼Œæ‰€ä»¥å°±æ‰§è¡Œåˆ° for æ­»å¾ªç¯æ— æ³•é€€å‡ºã€‚
</code></pre></div></div>

<p>go1.14 æ˜¯å¯ä»¥æ‰§è¡Œåˆ° panicï¼Œè€Œ 1.13 ç‰ˆæœ¬ä¸€ç›´æŒ‚åœ¨æ­»å¾ªç¯ä¸Šã€‚é‚£ä¹ˆåœ¨ go1.13 æ˜¯å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Ÿ è¦ä¹ˆå¹¶å‘åŠ å¤§ï¼Œè¦ä¹ˆæ‰§è¡Œä¸€ä¸ª syscallï¼Œè¦ä¹ˆæ‰§è¡Œå¤æ‚çš„å‡½æ•°äº§ç”Ÿ morestack æ‰©æ ˆã€‚å¯¹æ¯” go1.13 ç‰ˆï¼Œé€šè¿‡ strace å¯ä»¥çœ‹åˆ° go1.14 å¤šäº†ä¸€æ­¥å‘é€ä¿¡å·ä¸­æ–­ã€‚è¿™çœ‹ä¼¼å°±æ˜¯æ–‡ç« å¼€å¤´è®²åˆ°çš„åŸºäºä¿¡å·çš„æŠ¢å å¼è°ƒåº¦äº†ã€‚</p>

<p>åŸç åˆ†æ:
ä»¥å‰å†™è¿‡æ–‡ç« æ¥åˆ†æ go sysmon() çš„å·¥ä½œï¼Œåœ¨æ–°ç‰ˆ go 1.14 é‡Œå…¶ä»–åŠŸèƒ½è·Ÿä»¥å‰ä¸€æ ·ï¼Œåªæ˜¯åŠ å…¥äº†ä¿¡å·æŠ¢å ã€‚</p>

<p>æ€ä¹ˆæ³¨å†Œçš„ sigurg ä¿¡å·ï¼Ÿ
// xiaorui.cc</p>

<p>const sigPreempt = _SIGURG</p>

<p>func initsig(preinit bool) {
    for i := uint32(0); i &lt; _NSIG; i++ {
        fwdSig[i] = getsig(i)
        ,,,
        setsig(i, funcPC(sighandler)) // æ³¨å†Œä¿¡å·å¯¹åº”çš„å›è°ƒæ–¹æ³•
    }
}</p>

<p>func sighandler(sig uint32, info *siginfo, ctxt unsafe.Pointer, gp *g) {
    ,,,
    if sig == sigPreempt {  // å¦‚æœæ˜¯æŠ¢å ä¿¡å·
        // Might be a preemption signal.
        doSigPreempt(gp, c)
    }
    ,,,
}</p>

<p>// æ‰§è¡ŒæŠ¢å 
func doSigPreempt(gp *g, ctxt *sigctxt) {
    if wantAsyncPreempt(gp) &amp;&amp; isAsyncSafePoint(gp, ctxt.sigpc(), ctxt.sigsp(), ctxt.siglr()) {
        // Inject a call to asyncPreempt.
        ctxt.pushCall(funcPC(asyncPreempt))  // æ‰§è¡ŒæŠ¢å çš„å…³é”®æ–¹æ³•
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Acknowledge the preemption.
atomic.Xadd(&amp;gp.m.preemptGen, 1) } go åœ¨å¯åŠ¨æ—¶æŠŠæ‰€æœ‰çš„ä¿¡å·éƒ½æ³¨å†Œäº†ä¸€éï¼ŒåŒ…æ‹¬å¯é çš„ä¿¡å·ã€‚(æˆªå›¾ä¸ºéƒ¨åˆ†)
</code></pre></div></div>

<p>ç”±è°å»å‘èµ·æ£€æµ‹æŠ¢å ?
go1.14 ä¹‹å‰çš„ç‰ˆæœ¬æ˜¯æ˜¯ç”± sysmon æ£€æµ‹æŠ¢å ï¼Œåˆ°äº† go1.14 å½“ç„¶ä¹Ÿæ˜¯ç”± sysmon æ“ä½œã€‚runtime åœ¨å¯åŠ¨æ—¶ä¼šåˆ›å»ºä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œ sysmonï¼Œä¸ºä»€ä¹ˆè¦ç‹¬ç«‹æ‰§è¡Œï¼Ÿ sysmon æ˜¯ golang çš„ runtime ç³»ç»Ÿæ£€æµ‹å™¨ï¼Œsysmon å¯è¿›è¡Œ forcegcã€netpollã€retake ç­‰æ“ä½œã€‚æ‹¿æŠ¢å åŠŸèƒ½æ¥è¯´ï¼Œå¦‚ sysmon æ”¾åˆ° pmg è°ƒåº¦æ¨¡å‹é‡Œï¼Œæ¯ä¸ª p ä¸Šé¢çš„ goroutine æ°å¥½é˜»å¡äº†ï¼Œé‚£ä¹ˆè¿˜æ€ä¹ˆæ‰§è¡ŒæŠ¢å ï¼Ÿ</p>

<p>æ‰€ä»¥ sysmon æ‰è¦ç‹¬ç«‹ç»‘å®šè¿è¡Œï¼Œå°±ä¸Šé¢çš„è„šæœ¬åœ¨æµ‹è¯•è¿è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œè™½ç„¶çœ‹ä¼¼é˜»å¡çŠ¶æ€ï¼Œä½†è¿›è¡Œ strace å¯çœ‹åˆ° sysmon åœ¨ä¸æ–­ä¼‘çœ å”¤é†’æ“ä½œã€‚sysmon å¯åŠ¨åä¼šé—´éš”æ€§çš„è¿›è¡Œç›‘æ§ï¼Œæœ€é•¿é—´éš” 10msï¼Œæœ€çŸ­é—´éš” 20usã€‚å¦‚æœæŸåç¨‹ç‹¬å  P è¶…è¿‡ 10msï¼Œé‚£ä¹ˆå°±ä¼šè¢«æŠ¢å ï¼</p>

<p>sysmon ä¾èµ– schedwhen å’Œ schedtick æ¥è®°å½•ä¸Šæ¬¡çš„ç›‘æ§ä¿¡æ¯ï¼Œschedwhen è®°å½•ä¸Šæ¬¡çš„æ£€æµ‹æ—¶é—´ï¼Œschedtick æ¥åŒºåˆ†è°ƒåº¦æ—¶æ•ˆã€‚æ¯”å¦‚ sysmon åœ¨ä¸¤æ¬¡ç›‘æ§æ£€æµ‹æœŸé—´ï¼Œå·²ç»å‘ç”Ÿäº†å¤šæ¬¡ runtime.schedule åç¨‹è°ƒåº¦åˆ‡æ¢ï¼Œæ¯æ¬¡è°ƒåº¦æ—¶éƒ½ä¼šæ›´æ–° schedtick å€¼ã€‚æ‰€ä»¥ retake å‘ç° sysmontick.schedtick å€¼ä¸åŒæ—¶é‡æ–°è®°å½• schedtickã€‚</p>

<p>runtime/proc.go</p>

<p>// xiaorui.cc</p>

<p>func main() {
    g := getg()
    ,,,
    if GOARCH != â€œwasmâ€ {
        systemstack(func() {
            newm(sysmon, nil)
        })
    }
    ,,,
}</p>

<p>func schedule() {
    ,,,
    execute(gp, inheritTime)
}</p>

<p>func execute(gp *g, inheritTime bool) {
    if !inheritTime {
        <em>g</em>.m.p.ptr().schedtick++
    }
    ,,,
}</p>

<p>func sysmon(){
    ,,,
         // retake Pâ€™s blocked in syscalls
         // and preempt long running Gâ€™s
         if retake(now) != 0 {
             idle = 0
         } else {
             idle++
         }
    ,,,
}</p>

<p>// è®°å½•æ¯æ¬¡æ£€æŸ¥çš„ä¿¡æ¯
type sysmontick struct {
    schedtick   uint32
    schedwhen   int64
    syscalltick uint32
    syscallwhen int64
}</p>

<p>const forcePreemptNS = 10 * 1000 * 1000 // æŠ¢å çš„æ—¶é—´é˜ˆå€¼ 10ms</p>

<p>func retake(now int64) uint32 {
    n := 0
    lock(&amp;allpLock)
    for i := 0; i &lt; len(allp); i++ {
        <em>p</em> := allp[i]
        if <em>p</em> == nil {
            continue
        }
        pd := &amp;<em>p</em>.sysmontick
        s := <em>p</em>.status
        if s == <em>Prunning || s == _Psyscall {
            // Preempt G if itâ€™s running for too long.
            t := int64(_p</em>.schedtick)
            if int64(pd.schedtick) != t {
                pd.schedtick = uint32(t)
                pd.schedwhen = now // è®°å½•å½“å‰æ£€æµ‹æ—¶é—´
            // ä¸Šæ¬¡æ—¶é—´åŠ 10mså°äºå½“å‰æ—¶é—´ï¼Œé‚£ä¹ˆè¯´æ˜è¶…è¿‡ï¼Œéœ€è¿›è¡ŒæŠ¢å ã€‚
            } else if pd.schedwhen+forcePreemptNS &lt;= now {
                preemptone(<em>p</em>)
            }
        }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // ä¸‹é¢çœç•¥æ‰æ…¢ç³»ç»Ÿè°ƒç”¨çš„æŠ¢å æè¿°ã€‚
    if s == _Psyscall {
        // åŸå­æ›´ä¸ºpçŠ¶æ€ä¸ºç©ºé—²çŠ¶æ€
        if atomic.Cas(&amp;_p_.status, s, _Pidle) {
            ,,,
            handoffp(_p_)  // å¼ºåˆ¶å¸è½½P, ç„¶åstartmæ¥å…³è”
        }
    ,,, } 
</code></pre></div></div>

<p>func preemptone(<em>p</em> *p) bool {
    mp := <em>p</em>.m.ptr()
    ,,,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gp.preempt = true

,,,
gp.stackguard0 = stackPreempt

// Request an async preemption of this P.
if preemptMSupported &amp;&amp; debug.asyncpreemptoff == 0 {
    _p_.preempt = true
    preemptM(mp)
}

return true } å‘é€ SIGURG ä¿¡å·ï¼Ÿ signal_unix.go
</code></pre></div></div>

<p>// xiaorui.cc</p>

<p>// ç»™må‘é€sigurgä¿¡å·
func preemptM(mp *m) {
    if !pushCallSupported {
        // This architecture doesnâ€™t support ctxt.pushCall
        // yet, so doSigPreempt wonâ€™t work.
        return
    }
    if GOOS == â€œdarwinâ€ &amp;&amp; (GOARCH == â€œarmâ€ || GOARCH == â€œarm64â€) &amp;&amp; !iscgo {
        return
    }
    signalM(mp, sigPreempt)
}
æ”¶åˆ° sigurg ä¿¡å·åå¦‚ä½•å¤„ç† ?
preemptPark æ–¹æ³•ä¼šè§£ç»‘ mg çš„å…³ç³»ï¼Œå°å­˜å½“å‰åç¨‹ï¼Œç»§è€Œé‡æ–°è°ƒåº¦ runtime.schedule() è·å–å¯æ‰§è¡Œçš„åç¨‹ï¼Œè‡³äºè¢«æŠ¢å çš„åç¨‹åé¢ä¼šå»é‡å¯ã€‚</p>

<p>goschedImpl æ“ä½œå°±ç®€å•çš„å¤šï¼ŒæŠŠå½“å‰åç¨‹çš„çŠ¶æ€ä»_Grunning æ­£åœ¨æ‰§è¡Œæ”¹æˆ _Grunnable å¯æ‰§è¡Œï¼Œä½¿ç”¨ globrunqput æ–¹æ³•æŠŠæŠ¢å çš„åç¨‹æ”¾åˆ°å…¨å±€é˜Ÿåˆ—é‡Œï¼Œæ ¹æ® pmg çš„åç¨‹è°ƒåº¦è®¾è®¡ï¼Œglobalrunq è¦åäºæœ¬åœ° runq è¢«è°ƒåº¦ã€‚</p>

<p>runtime/preempt.go</p>

<p>// xiaorui.cc</p>

<p>//go:generate go run mkpreempt.go</p>

<p>// asyncPreempt saves all user registers and calls asyncPreempt2.
//
// When stack scanning encounters an asyncPreempt frame, it scans that
// frame and its parent frame conservatively.
func asyncPreempt()</p>

<p>//go:nosplit
func asyncPreempt2() {
    gp := getg()
    gp.asyncSafePoint = true
    if gp.preemptStop {
        mcall(preemptPark)
    } else {
        mcall(gopreempt_m)
    }
    gp.asyncSafePoint = false
}
runtime/proc.go</p>

<p>// xiaorui.cc</p>

<p>// preemptPark parks gp and puts it in _Gpreempted.
//
//go:systemstack
func preemptPark(gp *g) {
    ,,,
    status := readgstatus(gp)
    if status&amp;^_Gscan != _Grunning {
        dumpgstatus(gp)
        throw(â€œbad g statusâ€)
    }
    ,,,
    schedule()
}</p>

<p>func goschedImpl(gp *g) {
    status := readgstatus(gp)
    ,,,
    casgstatus(gp, _Grunning, _Grunnable)
    dropg()
    lock(&amp;sched.lock)
    globrunqput(gp)
    unlock(&amp;sched.lock)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>schedule() } æºç è§£æç²—ç•¥çš„åˆ†æå®Œäº†ï¼Œè¿˜æœ‰ä¸€äº›ç»†èŠ‚ä¸å¥½è¯»æ‡‚ï¼Œä½†ä¿¡å·æŠ¢å å®ç°çš„å¤§æ–¹å‘æ‘¸çš„ 89 ä¸ç¦» 10 äº†ã€‚
</code></pre></div></div>

<p>æŠ¢å æ˜¯å¦å½±å“æ€§èƒ½ ï¼Ÿ
æŠ¢å åˆ†ä¸º_Prunning å’Œ Psyscallï¼ŒPsyscall æŠ¢å é€šå¸¸æ˜¯ç”±äºé˜»å¡æ€§ç³»ç»Ÿè°ƒç”¨å¼•èµ·çš„ï¼Œæ¯”å¦‚ç£ç›˜ ioã€cgoã€‚Prunning æŠ¢å é€šå¸¸æ˜¯ç”±äºä¸€äº›ç±»ä¼¼æ­»å¾ªç¯çš„è®¡ç®—é€»è¾‘å¼•èµ·çš„ã€‚</p>

<p>è¿‡åº¦çš„å‘é€ä¿¡å·æ¥ä¸­æ–­ m è¿›è¡ŒæŠ¢å å¤šå°‘ä¼šå½±å“æ€§èƒ½çš„ï¼Œä¸»è¦æ˜¯è½¯ä¸­æ–­å’Œä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚åœ¨å¹³å¸¸çš„ä¸šåŠ¡é€»è¾‘ä¸‹ï¼Œå¾ˆéš¾å‘ç”Ÿåç¨‹é˜»å¡è°ƒåº¦çš„é—®é¢˜ã€‚ğŸ˜…</p>

<p>æ…¢ç³»ç»Ÿè°ƒåº¦çš„é”™è¯¯å¤„ç†ï¼Ÿ
EINTR é”™è¯¯é€šå¸¸æ˜¯ç”±äºè¢«ä¿¡å·ä¸­æ–­å¼•èµ·çš„é”™è¯¯ï¼Œæ¯”å¦‚åœ¨æ‰§è¡Œ epollwaitã€acceptã€read&amp;write ç­‰æ“ä½œæ—¶ï¼Œæ”¶åˆ°ä¿¡å·ï¼Œé‚£ä¹ˆè¯¥ç³»ç»Ÿè°ƒç”¨ä¼šè¢«æ‰“æ–­ä¸­æ–­ï¼Œç„¶åå»æ‰§è¡Œä¿¡å·æ³¨å†Œçš„å›è°ƒæ–¹æ³•ï¼Œå®Œäº‹åä¼šè¿”å› eintr é”™è¯¯ã€‚</p>

<p>ä¸‹é¢æ˜¯ golang çš„å¤„ç†æ–¹æ³•ï¼Œç”±äº golang çš„ netpoll è®¾è®¡ä½¿å¤šæ•°çš„ io ç›¸å…³çš„ syscall æ“ä½œéé˜»å¡åŒ–ï¼Œæ‰€ä»¥å°±åªæœ‰ epollwait æœ‰è¯¥é—®é¢˜ã€‚</p>

<p>// xiaorui.cc</p>

<p>func netpoll(delay int64) gList {
    ,,,
    var events [128]epollevent
retry:
    n := epollwait(epfd, &amp;events[0], int32(len(events)), waitms)
    if n &lt; 0 {
        if n != -_EINTR {
            println(â€œruntime: epollwait on fdâ€, epfd, â€œfailed withâ€, -n)
            throw(â€œruntime: netpoll failedâ€)
        }
        goto retry
    }
    ,,,
}</p>

<p>func netpollBreak() {
    for {
        var b byte
        n := write(netpollBreakWr, unsafe.Pointer(&amp;b), 1)
        if n == 1 {
            break
        }
        if n == -_EINTR {
            continue
        }
        ,,,
    }
}
é€šå¸¸éœ€è¦æ‰‹åŠ¨æ¥è§£å†³ EINTR çš„é”™è¯¯é—®é¢˜ï¼Œè™½ç„¶å¯é€šè¿‡ SA_RESTART æ¥é‡å¯è¢«ä¸­æ–­çš„ç³»ç»Ÿè°ƒç”¨ï¼Œä½†ä¸ç®¡æ˜¯ syscall å…¼å®¹å’Œä¸šåŠ¡ä¸Šæœ‰å¯èƒ½å‡ºç°åå·®ã€‚</p>

<p>// xiaorui.cc</p>

<p>// epoll_wait
if(  -1 == epoll_wait() )
{
    if(errno!=EINTR)
    {
          return -1;
    }
}</p>

<p>// read 
again:
          if ((n = read(fdï¼Œ bufï¼Œ BUFFSIZE)) &lt; 0) {
             if (errno == EINTR)
                  goto again;
          }
é…ç½® SA_RESTART åï¼Œçº¿ç¨‹è¢«ä¸­æ–­åè¿˜å¯ç»§ç»­æ‰§è¡Œè¢«ä¸­æ–­çš„ç³»ç»Ÿè°ƒç”¨ã€‚</p>

<p>// xiaorui.cc</p>

<p>â€” SIGINT {si_signo=SIGINT, si_code=SI_KERNEL, si_value={int=0, ptr=0x100000000}} â€”
rt_sigreturn()                          = -1 EINTR (Interrupted system call)
futex(0x1b97a30, FUTEX_WAIT_PRIVATE, 0, NULL) = ? ERESTARTSYS (To be restarted if SA_RESTART is set)
â€” SIGINT {si_signo=SIGINT, si_code=SI_KERNEL, si_value={int=0, ptr=0x100000000}} â€”
rt_sigreturn()                          = -1 EINTR (Interrupted system call)
â€¦
ä¿¡å·çš„åŸç†ï¼Ÿ
æˆ‘ä»¬å¯¹ä¸€ä¸ªè¿›ç¨‹å‘é€ä¿¡å·åï¼Œå†…æ ¸æŠŠä¿¡å·æŒ‚è½½åˆ°ç›®æ ‡è¿›ç¨‹çš„ä¿¡å· pending é˜Ÿåˆ—ä¸Šå»ï¼Œç„¶åè¿›è¡Œè§¦å‘è½¯ä¸­æ–­è®¾ç½®ç›®æ ‡è¿›ç¨‹ä¸º running çŠ¶æ€ã€‚å½“è¿›ç¨‹è¢«å”¤é†’æˆ–è€…è°ƒåº¦åè·å– CPU åï¼Œæ‰ä¼šä»å†…æ ¸æ€è½¬åˆ°ç”¨æˆ·æ€æ—¶æ£€æµ‹æ˜¯å¦æœ‰ signal ç­‰å¾…å¤„ç†ï¼Œç­‰è¿›ç¨‹å¤„ç†å®Œåä¼šæŠŠç›¸åº”çš„ä¿¡å·ä»é“¾è¡¨ä¸­å»æ‰ã€‚</p>

<p>é€šè¿‡ kill -l æ‹¿åˆ°å½“å‰ç³»ç»Ÿæ”¯æŒçš„ä¿¡å·åˆ—è¡¨ï¼Œ1-31 ä¸ºä¸å¯é ä¿¡å·ï¼Œä¹Ÿæ˜¯éå®æ—¶ä¿¡å·ï¼Œä¿¡å·æœ‰å¯èƒ½ä¼šä¸¢å¤±ï¼Œæ¯”å¦‚å‘é€å¤šæ¬¡ç›¸åŒçš„ä¿¡å·ï¼Œè¿›ç¨‹åªèƒ½æ”¶åˆ°ä¸€æ¬¡ã€‚</p>

<p>// xiaorui.cc</p>

<p>// Print a list of signal names.  These are found in /usr/include/linux/signal.h</p>

<p>kill -l</p>

<p>1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL     5) SIGTRAP
6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1
11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM
16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP
21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ
26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR
31) SIGSYS<br />
åœ¨ Linux ä¸­çš„ posix çº¿ç¨‹æ¨¡å‹ä¸­ï¼Œçº¿ç¨‹æ‹¥æœ‰ç‹¬ç«‹çš„è¿›ç¨‹å·ï¼Œå¯ä»¥é€šè¿‡ getpid() å¾—åˆ°çº¿ç¨‹çš„è¿›ç¨‹å·ï¼Œè€Œçº¿ç¨‹å·ä¿å­˜åœ¨ pthread_t çš„å€¼ä¸­ã€‚è€Œä¸»çº¿ç¨‹çš„è¿›ç¨‹å·å°±æ˜¯æ•´ä¸ªè¿›ç¨‹çš„è¿›ç¨‹å·ï¼Œå› æ­¤å‘ä¸»è¿›ç¨‹å‘é€ä¿¡å·åªä¼šå°†ä¿¡å·å‘é€åˆ°ä¸»çº¿ç¨‹ä¸­å»ã€‚å¦‚æœä¸»çº¿ç¨‹è®¾ç½®äº†ä¿¡å·å±è”½ï¼Œåˆ™ä¿¡å·ä¼šæŠ•é€’åˆ°ä¸€ä¸ªå¯ä»¥å¤„ç†çš„çº¿ç¨‹ä¸­å»ã€‚</p>

<p>æ³¨å†Œçš„ä¿¡å·å¤„ç†å‡½æ•°éƒ½æ˜¯çº¿ç¨‹å…±äº«çš„ï¼Œä¸€ä¸ªä¿¡å·åªå¯¹åº”ä¸€ä¸ªå¤„ç†å‡½æ•°ï¼Œä¸”æœ€åä¸€æ¬¡ä¸ºå‡†ã€‚å­çº¿ç¨‹ä¹Ÿå¯æ›´æ”¹ä¿¡å·å¤„ç†å‡½æ•°ï¼Œä¸”éšæ—¶éƒ½å¯æ”¹ã€‚</p>

<p>å¤šçº¿ç¨‹ä¸‹å‘é€åŠæ¥æ”¶ä¿¡å·çš„é—®é¢˜ï¼Ÿ
é»˜è®¤æƒ…å†µä¸‹åªæœ‰ä¸»çº¿ç¨‹æ‰å¯å¤„ç† signalï¼Œå°±ç®—æŒ‡å®šå­çº¿ç¨‹å‘é€ signalï¼Œä¹Ÿæ˜¯ä¸»çº¿ç¨‹æ¥æ”¶å¤„ç†ä¿¡å·ã€‚</p>

<p>é‚£ä¹ˆ Golang å¦‚ä½•åšåˆ°ç»™æŒ‡å®šå­çº¿ç¨‹å‘ signal ä¸”å¤„ç†çš„ï¼Ÿå¦‚ä½•æŒ‡å®šç»™æŸä¸ªçº¿ç¨‹å‘é€ signalï¼Ÿ åœ¨ glibc ä¸‹å¯ä»¥ä½¿ç”¨ pthread_kill æ¥ç»™çº¿ç¨‹å‘ signalï¼Œå®ƒåº•å±‚è°ƒç”¨çš„æ˜¯ SYS_tgkill ç³»ç»Ÿè°ƒç”¨ã€‚</p>

<p>// xiaorui.cc</p>

<p>#include â€œpthread_impl.hâ€</p>

<p>int pthread_kill(pthread_t t, int sig)
{
    int r;
    __lock(t-&gt;killlock);
    r = t-&gt;dead ? ESRCH : -__syscall(SYS_tgkill, t-&gt;pid, t-&gt;tid, sig);
    __unlock(t-&gt;killlock);
    return r;
}
é‚£ä¹ˆåœ¨ go runtime/sys_linux_amd64.s é‡Œæ‰¾åˆ°äº† SYS_tgkill çš„æ±‡ç¼–å®ç°ã€‚os_linux.go ä¸­ signalM è°ƒç”¨çš„å°±æ˜¯ tgkill çš„å®ç°ã€‚</p>

<p>// xiaorui.cc
#define SYS_tgkill      234</p>

<p>TEXT Â·tgkill(SB),NOSPLIT,$0
    MOVQ    tgid+0(FP), DI
    MOVQ    tid+8(FP), SI
    MOVQ    sig+16(FP), DX
    MOVL    $SYS_tgkill, AX
    SYSCALL
    RET
// xiaorui.cc</p>

<p>func tgkill(tgid, tid, sig int)</p>

<p>// signalM sends a signal to mp.
func signalM(mp *m, sig int) {
    tgkill(getpid(), int(mp.procid), sig)
}
æ€»ç»“ï¼š
éšç€ go ç‰ˆæœ¬ä¸æ–­æ›´æ–°ï¼Œruntime çš„åŠŸèƒ½è¶Šæ¥è¶Šå®Œå–„ã€‚ç°åœ¨çœ‹æ¥åŸºäºä¿¡å·çš„æŠ¢å å¼è°ƒåº¦æ˜¾å¾—å¾ˆç²¾å¦™ã€‚ä¸‹ä¸€ç¯‡æ–‡ç« ç»§ç»­å†™ go1.4 defer çš„ä¼˜åŒ–ï¼Œç®€å•è¯´åœ¨å¤šåœºæ™¯ä¸‹ç¼–è¯‘å™¨æ¶ˆé™¤äº† deferproc å‹å…¥å’Œ deferreturn æ’å…¥è°ƒç”¨ï¼Œè€Œæ˜¯ç›´æ¥è°ƒç”¨å»¶è¿Ÿæ–¹æ³•</p>
:ET