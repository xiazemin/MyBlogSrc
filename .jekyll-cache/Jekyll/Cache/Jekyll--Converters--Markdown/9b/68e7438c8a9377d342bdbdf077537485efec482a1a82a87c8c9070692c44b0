I"±_<p>https://opensource.apple.com/source/dyld/dyld-353.2.1/include/mach-o/dyld-interposing.h
//  ÊºîÁ§∫‰ª£Á†Å 
// #import &lt;mach-o/dyld-interposing.h&gt;
// from dyld-interposing.h
#define DYLD_INTERPOSE(<em>replacement,_replacee) <strong>attribute</strong>((used)) static struct{ const void* replacement; const void* replacee; } _interpose</em>##_replacee <strong>attribute</strong> ((section (‚Äú__DATA,__interpose‚Äù))) = { (const void<em>)(unsigned long)&amp;_replacement, (const void</em>)(unsigned long)&amp;_replacee };</p>

<p>ssize_t hacked_write(int fildes, const void *buf, size_t nbyte)
{
    printf(‚Äú[++++]into hacked_writeÔºçÔºçÔºçby piaoyun‚Äù);
    return write(fildes, buf, nbyte);
}</p>

<p>DYLD_INTERPOSE(hacked_write, write);</p>

<p>// ÂÜçÊù•‰∏™ÊºîÁ§∫‰ª£Á†ÅÔºö</p>

<p>// ÁºñËØë
// cc -dynamiclib main.c -o libHook.dylib -Wall
// Âº∫Ë°åÊ≥®ÂÖ•lsÊµãËØï
// DYLD_INSERT_LIBRARIES=libHook.dylib ls
#include &lt;malloc/malloc.h&gt;</p>

<p>#define DYLD_INTERPOSE(<em>replacement,_replacee) <br />
<strong>attribute</strong>((used)) static struct{ const void* replacement; const void* replacee; } _interpose</em>##_replacee <br />
<strong>attribute</strong> ((section (‚Äú__DATA,__interpose‚Äù))) = { (const void<em>)(unsigned long)&amp;_replacement, (const void</em>)(unsigned long)&amp;_replacee };</p>

<p>void *hacked_malloc(size_t size){
    void *ret = malloc(size);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>malloc_printf("+ %p %d\n", ret, size);
return ret; }
</code></pre></div></div>

<p>void hacked_free(void *freed){
    malloc_printf(‚Äú- %p\n‚Äù, freed);
    free(freed);
}</p>

<p>DYLD_INTERPOSE(hacked_malloc, malloc)
DYLD_INTERPOSE(hacked_free, free);</p>

<!-- more -->
<p>/*</p>
<ul>
  <li>Copyright (c) 2005-2008 Apple Computer, Inc. All rights reserved.
 *</li>
  <li>@APPLE_LICENSE_HEADER_START@</li>
  <li></li>
  <li>This file contains Original Code and/or Modifications of Original Code</li>
  <li>as defined in and that are subject to the Apple Public Source License</li>
  <li>Version 2.0 (the ‚ÄòLicense‚Äô). You may not use this file except in</li>
  <li>compliance with the License. Please obtain a copy of the License at</li>
  <li>http://www.opensource.apple.com/apsl/ and read it before using this</li>
  <li>file.</li>
  <li></li>
  <li>The Original Code and all software distributed under the License are</li>
  <li>distributed on an ‚ÄòAS IS‚Äô basis, WITHOUT WARRANTY OF ANY KIND, EITHER</li>
  <li>EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,</li>
  <li>INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,</li>
  <li>FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.</li>
  <li>Please see the License for the specific language governing rights and</li>
  <li>limitations under the License.</li>
  <li></li>
  <li>@APPLE_LICENSE_HEADER_END@
 */</li>
</ul>

<p>#if !defined(<em>DYLD_INTERPOSING_H</em>)
#define <em>DYLD_INTERPOSING_H</em></p>

<p>/*</p>
<ul>
  <li>Example:
 *</li>
  <li>static</li>
  <li>int</li>
  <li>my_open(const char* path, int flags, mode_t mode)</li>
  <li>{</li>
  <li>int value;</li>
  <li>// do stuff before open (including changing the arguments)</li>
  <li>value = open(path, flags, mode);</li>
  <li>// do stuff after open (including changing the return value(s))</li>
  <li>return value;</li>
  <li>}</li>
  <li>DYLD_INTERPOSE(my_open, open)
 */</li>
</ul>

<p>#define DYLD_INTERPOSE(<em>replacement,_replacee) <br />
   <strong>attribute</strong>((used)) static struct{ const void* replacement; const void* replacee; } _interpose</em>##_replacee <br />
            <strong>attribute</strong> ((section (‚Äú__DATA,__interpose‚Äù))) = { (const void<em>)(unsigned long)&amp;_replacement, (const void</em>)(unsigned long)&amp;_replacee };</p>

<p>#endif</p>

<p>https://www.cnblogs.com/cobbliu/p/7347923.html?utm_source=itdadao&amp;utm_medium=referral</p>

<p>There are times when you want to wrap a library function in order to provide some additional functionality. A common example of this is wrapping the standard library‚Äôs malloc() and free() so that you can easily track memory allocations in your program. While there are several techniques for wrapping library functions, one well-known method is using dlsym() with RTLD_NEXT to locate the wrapped function‚Äôs address so that you can correctly forward calls to it.</p>

<p>Problem
So what can go wrong? Let‚Äôs look at an example:</p>

<p>LibWrap.h</p>

<p>void* memAlloc(size_t s);
// Allocate a memory block of size ‚Äòs‚Äô bytes.
void memDel(void* p);
// Free the block of memory pointed to by ‚Äòp‚Äô.
LibWrap.c</p>

<p>#define _GNU_SOURCE
#include <dlfcn.h>
#include "LibWrap.h"</dlfcn.h></p>

<p>static void* malloc(size_t s) {
   // Wrapper for standard library‚Äôs ‚Äòmalloc‚Äô.
   // The ‚Äòstatic‚Äô keyword forces all calls to malloc() in this file to resolve
   // to this functions.
   void* (*origMalloc)(size_t) = dlsym(RTLD_NEXT,‚Äùmalloc‚Äù);
   return origMalloc(s);
}</p>

<p>static void free(void* p) {
   // Wrapper for standard library‚Äôs ‚Äòfree‚Äô.
   // The ‚Äòstatic‚Äô keyword forces all calls to free() in this file to resolve
   // to this functions.
   void (<em>origFree)(void</em>) = dlsym(RTLD_NEXT,‚Äùfree‚Äù);
   origFree(p);
}</p>

<p>void* memAlloc(size_t s) {
   return malloc(s);
   // Call the malloc() wrapper.
}</p>

<p>void memDel(void* p) {
   free(p);
   // Call the free() wrapper.
}
Main.c</p>

<p>#include <malloc.h>
#include "LibWrap.h"</malloc.h></p>

<p>int main() {
   struct mallinfo beforeMalloc = mallinfo();
   printf(‚ÄúBytes allocated before malloc: %d\n‚Äù,beforeMalloc.uordblks);</p>

<p>void* p = memAlloc(57);
   struct mallinfo afterMalloc = mallinfo();
   printf(‚ÄúBytes allocated after malloc: %d\n‚Äù,afterMalloc.uordblks);</p>

<p>memDel(p);
   struct mallinfo afterFree = mallinfo();
   printf(‚ÄúBytes allocated after free: %d\n‚Äù,afterFree.uordblks);</p>

<p>return 0;
}
First compile LibWrap.c into a shared library:</p>

<p>$ gcc -Wall -Werror -fPIC -shared -o libWrap.so LibWrap.c
Next compile Main.c and link it against the libWrap.so that we just created:</p>

<p>$ gcc -Wall -Werror -o Main Main.c ./libWrap.so -ldl
Time to run the program!</p>

<p>$ ./Main
Bytes allocated before malloc: 0
Bytes allocated after malloc: 80
Bytes allocated after free: 0
So far, so good. No surprises. We allocated a bunch of memory and then freed it. The statistics returned by mallinfo() confirm this.</p>

<p>Out of curiosity, let‚Äôs look at ldd output for the application binary we created.</p>

<p>$ ldd Main
       linux-vdso.so.1 =&gt;  (0x00007fff1b1fe000)
       ./libWrap.so (0x00007fe7d2755000)
       libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fe7d2542000)
       libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe7d217c000)
       /lib64/ld-linux-x86-64.so.2 (0x00007fe7d2959000)</p>

<p>Take note of the relative placement of libWrap.so with respect to libc.so.6: libWrap.socomes before libc.so.6. Remember this. It will be important later.</p>

<p>Now for fun, let‚Äôs re-compile Main.c with libc.so.6 explicitly specified on the command-line and coming before libWrap.so:</p>

<p>$ gcc -Wall -Werror -o Main Main.c /lib/x86_64-linux-gnu/libc.so.6 ./libWrap.so -ldl
Re-run:</p>

<p>$ ./Main
Bytes allocated before malloc: 0
Bytes allocated after malloc: 80
Bytes allocated after free: 80
Uh oh, why are we leaking memory all of a sudden? We de-allocate everything we allocate, so why the memory leak?</p>

<p>It turns out that the leak is occurring because we are not actually forwarding malloc() and free() calls to libc.so.6‚Äòs implementations. Instead, we are forwarding them to malloc() and free() inside ld-linux-x86-64.so.2!</p>

<p>‚ÄúWhat are you talking about?!‚Äù you might be asking.</p>

<p>Well, it just so happens that ld-linux-x86-64.so.2, which is the dynamic linker/loader, has its own copy of malloc() and free(). Why? Because ld-linux has to allocate memory from the heap before it loads libc.so.6. But the version of malloc/free that ld-linuxhas does not actually free memory!</p>

<p>[RTLD_NEXT] will find the next occurrence of a function in the search order after the current library. This allows one to provide a wrapper around a function in another shared library.But why does libWrap.so forward calls to ld-linux instead of libc? The answer comes down to how dlsym() searches for symbols when RTLD_NEXT is specified. Here‚Äôs the relevant excerpt from the dlsym(3) man page:‚Äî dlsym(3)</p>

<p>To understand this better, take a look at ldd output for the new Main binary:</p>

<p>$ ldd Main
        linux-vdso.so.1 =&gt;  (0x00007fffe1da0000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f32c2e91000)
        ./libWrap.so (0x00007f32c2c8f000)
        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f32c2a8a000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f32c3267000)
Unlike earlier, libWrap.so comes after libc.so.6. So when dlsym() is called inside libWrap.so to search for functions, it skips libc.so.6 since it precedes libWrap.so in the search order list. That means the searches continue through to ld-linux-x86-64.so.2where they find linker/loader‚Äôs malloc/free and return pointers to those functions. And so, libWrap.so ends up forwading calls to ld-linux instead of libc!</p>

<p>The answer is unfortunately no. At OptumSoft, we recently encountered this very same memory leak with a binary compiled using the standard ./configure &amp;&amp; make on x86-64 Ubuntu 14.04.1 LTS. For reasons we don‚Äôt understand, the linking order for the binary was such that using dlsym() with RTLD_NEXT to lookup malloc/free resulted in pointers to implementations inside ld-linux. It took a ton of effort and invaluable help from Mozilla‚Äôs rr tool to root-cause the issue. After the whole ordeal, we decided to write a blog post about this strange behavior in case someone else encounters it in the future.At this point you might be wondering: We ran a somewhat funky command to build our application and then encountered a memory leak due to weird library linking order caused by said command. Isn‚Äôt this whole thing a silly contrived scenario?</p>

<p>Solution
If you find dlsym() with RTLD_NEXT returning pointers to malloc/free inside ld-linux, what can you do?</p>

<p>For starters, you need to detect that a function address indeed does belong to ld-linuxusing dladdr():</p>

<p>void* func = dlsym(RTLD_NEXT,‚Äùmalloc‚Äù);
Dl_info dlInfo;
if(!dladdr(func,&amp;dlInfo)) {
   // dladdr() failed.
}
if(strstr(dlInfo.dli_fname,‚Äùld-linux‚Äù)) {
   // ‚Äòmalloc‚Äô is inside linker/loader.
}
Once you have figured out that a function is inside ld-linux, you need to decide what to do next. Unfortunately, there is no straightforward way to continue searching for the same function name in all other libraries. But if you know the name of a specific library in which the function exists (e.g. libc), you can use dlopen() and dlsym() to fetch the desired pointer:</p>

<p>void* handle = dlopen(‚Äúlibc.so.6‚Äù,RTLD_LAZY);
// NOTE: libc.so.6 may <em>not</em> exist on Alpha and IA-64 architectures.
if(!handle) {
   // dlopen() failed.
}
void* func = dlsym(handle,‚Äùfree‚Äù);
if(!func) {
   // Bad! ‚Äòfree‚Äô was not found inside libc.
}</p>

<p>Summary
One can use dlsym() with RTLD_NEXT to implement wrappers around malloc() and free().
Due to unexpected linking behavior, dlsym() when using RTLD_NEXT can return pointers to malloc/free implementations inside ld-linux (dynamic linker/loader). Using ld-linux‚Äòs malloc/free for general heap allocations leads to memory leaks because that particular version of free() doesn‚Äôt actually release memory.
You can check if an address returned by dlsym() belongs to ld-linux via dladdr(). You can also lookup a function in a specific library using dlopen() and dlsym().</p>

<p>dlsymÁî®Ê≥ï</p>
<ol>
  <li>
    <p>ÂåÖÂê´Â§¥Êñá‰ª∂ #include<dlfcn.h></dlfcn.h></p>
  </li>
  <li>
    <p>ÂáΩÊï∞ÂÆö‰πâ void <em>dlsym(void *handle, const char</em> symbol);</p>
  </li>
</ol>

<p>handleÊòØ‰ΩøÁî®dlopenÂáΩÊï∞‰πãÂêéËøîÂõûÁöÑÂè•ÊüÑÔºåsymbolÊòØË¶ÅÊ±ÇËé∑ÂèñÁöÑÂáΩÊï∞ÁöÑÂêçÁß∞ÔºåÂáΩÊï∞ÔºåËøîÂõûÂÄºÊòØvoid*,ÊåáÂêëÂáΩÊï∞ÁöÑÂú∞ÂùÄÔºå‰æõË∞ÉÁî®‰ΩøÁî®</p>

<p>dlsym‰∏édlopenÁöÑ‰ª•Â¶Ç‰∏ã‰æãÂ≠êËß£ÈáäÔºö</p>

<p>#include<dlfcn.h></dlfcn.h></p>

<p>void * handle = dlopen(‚Äú./testListDB.so‚Äù,RTLD_LAZY);</p>

<p>Â¶ÇÊûúcreateListDBÂáΩÊï∞ÂÆö‰πâ‰∏∫int32_t createListDB(std::string);</p>

<p>ÈÇ£‰πàdlsymÁöÑÁî®Ê≥ïÂàô‰∏∫Ôºöint32_t  (<em>create_listDB)(std::string) = reinterpret_cast&lt;int32_t (</em>)(std::string)&gt;(dlsym(handle, ‚ÄúcreateListDB‚Äù))</p>

<p>createListDBÂ∫ìÂáΩÊï∞ÁöÑÂÆö‰πâË¶ÅÁî®externÊù•Â£∞ÊòéÔºåËøôÊ†∑Âú®‰∏ªÂáΩÊï∞‰∏≠ÊâçËÉΩÈÄöËøácreateListDBÊù•Êü•ÊâæÂáΩÊï∞Ôºå</p>

<p>Áõ∏ÊØî‰∫éÂ∑≤Áü•ÂáΩÊï∞ÁöÑÊâÄÂú®Âä®ÊÄÅÂ∫ìÔºåÂáΩÊï∞dlsymÁöÑÂèÇÊï∞RTLD_NEXTÂèØ‰ª•Âú®ÂØπÂáΩÊï∞ÂÆûÁé∞ÊâÄÂú®Âä®ÊÄÅÂ∫ìÂêçÁß∞Êú™Áü•ÁöÑÊÉÖÂÜµ‰∏ãÂÆåÊàêÂØπÂ∫ìÂáΩÊï∞ÁöÑÊõø‰ª£„ÄÇËøôÊèê‰æõ‰∫ÜÂ∑®Â§ßÁöÑ‰æøÂà©„ÄÇ‰ΩÜÊòØÂá°ÊòØÊúâ‰∏ÄÂà©ÂøÖÊúâ‰∏ÄÂºäÔºåÂú®‰ΩøÁî®ËØ•ÂèÇÊï∞Êó∂ÔºåÈúÄË¶ÅÊ≥®ÊÑè‰∏Ä‰∫õÈóÆÈ¢ò„ÄÇ</p>

<p>‰ΩøÁî®ÁöÑÂáΩÊï∞Êñá‰ª∂
mainÂáΩÊï∞.c</p>

<p>#include <stdio.h>
#include <malloc.h></malloc.h></stdio.h></p>

<p>int main (void) {
    struct mallinfo bfmalloc = mallinfo();
    printf(‚Äúbfmalloc: %d\n‚Äù,bfmalloc.uordblks);
    int *p = malloc(32);
    struct mallinfo afmalloc  = mallinfo();
    printf(‚Äúafmalloc: %d\n‚Äù,afmalloc.uordblks);
    free(p);
    struct mallinfo fmalloc = mallinfo();
    printf(‚Äúfmalloc: %d\n‚Äù,fmalloc.uordblks);
    return 0;
}</p>

<p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
ÂåÖË£ÖÂáΩÊï∞ÂÆûÁé∞Êñá‰ª∂.h</p>

<p>void *memAlloc(size_t size);
void memFree(void *ptr);
1
2
ÂåÖË£ÖÂÆûÁé∞Êñá‰ª∂.c</p>

<p>#ifdef RUNTIME
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <assert.h>
#include "mymalloc.h"
void *malloc(size_t size) {
    void*(*mallocp)(size_t size);
    char *error;
    mallocp = dlsym(RTLD_NEXT,"malloc");
    assert(dlerror() == NULL);
    char *ptr = mallocp(size);
    return ptr;
}
void free(void *ptr) {
    assert(ptr != NULL);
    char *error;
    void (*freep)(void *ptr);
    freep = dlsym(RTLD_NEXT,"free");
    assert(dlerror() == NULL);
    freep(ptr);
}
void *memAlloc (size_t size) {
    void *ptr = malloc(size);
    printf("ret:%d : %p\n",size,ptr);
    return ptr;
}
void memFree(void *ptr) {
    free(ptr);
    printf("free ret: %p\n",ptr);
}
#endif
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
Êàë‰ª¨È¶ñÂÖàÁºñËØëÂπ∂ËøêË°å‰∏Ä‰∏ãÁ®ãÂ∫èÔºåÁúãÁúãËøêË°åÁªìÊûú
ÁºñËØëÊ≠•È™§Ôºö</assert.h></malloc.h></stdlib.h></stdio.h></dlfcn.h></p>

<p>gcc -DRUNTIME -shared -fPIC -o mymalloc.so mymalloc.c
gcc -o t main.c ./mymalloc.so -ldl
1
2
ËøêË°å./t</p>

<p>Êàë‰ª¨ÂèØ‰ª•ÂæàÊòéÊòæÁöÑÁúãÂà∞ÔºåÊàë‰ª¨Âπ∂Ê≤°ÊúâÈáäÊîæÊéâÊàë‰ª¨ÊâÄÁî≥ËØ∑ÁöÑÁ©∫Èó¥ÔºåËôΩÁÑ∂Êàë‰ª¨ÊòæÁ§∫ÁöÑË∞ÉÁî®‰∫ÜÂÜÖÂ≠òÂàÜÈÖçÂáΩÊï∞free„ÄÇÈÇ£‰πà‰∏∫‰ªÄ‰πà‰ºöÈÄ†ÊàêÂÜÖÂ≠òÊ≥ÑÈú≤Âë¢ÔºüÁÆÄÂçïÁöÑÊù•ËØ¥ÂéüÂõ†ÊòØÂõ†‰∏∫Âú®‰ΩøÁî®‰∫ÜRTLD_NEXTÂèÇÊï∞ÂêéÔºåÁºñËØëÂô®Âú®Êü•ËØ¢ÂáΩÊï∞ÁöÑÂÆûÁé∞Â∫ìÊó∂ÔºåÂØπÂ∫ìÁöÑËÆøÈóÆÈ°∫Â∫è‰∏çÂêåÈÄ†ÊàêÁöÑÔºåËØ¶ÁªÜÁöÑÂéüÂõ†Â§ßÂÆ∂ÂèØ‰ª•ÂèÇËÄÉ‰∏ãÈù¢ËøôÁØáÂçöÊñáÔºö
Dangers of using dlsym() with RTLD_NEXT</p>

<p>ÂÖ∂Ê¨°Âú®‰ΩøÁî®ËØ•ÂèÇÊï∞Êó∂ËøòÁ¢∞Âà∞‰∫Ü‰∏Ä‰∏™ÈóÆÈ¢òÔºö‰∏çËÉΩÂú®mallocÁöÑÂÆûÁé∞Êñá‰ª∂ÈáåÈù¢Âä†ÂÖ•‰ªª‰ΩïÂ∏¶ÊúâÁºìÂÜ≤ÁöÑËæìÂá∫ËØ≠Âè•ÔºåÂê¶Âàô‰æøÊàñÈÄ†ÊàêÊÆµÈîôËØØÔºöÊúâÂÖ¥Ë∂£ÁöÑËØªËÄÖÂèØ‰ª•ËØï‰∏Ä‰∏ã„ÄÇËøô‰∏™ÊòØÂä†‰∫ÜprintfËØ≠Âè•‰πãÂêéÔºåÂáΩÊï∞ÁöÑË∞ÉÁî®Ê†à</p>

<p>Ëá≥‰∫éÁ®ãÂ∫è‰∏∫‰ªÄ‰πà‰ºöÂú®__vfprintf_internal()Â≠êÂáΩÊï∞Â§ÑÂÆïÊéâÔºåÊàëÊúâ‰∏Ä‰∏™Â§ßËÉÜÁöÑÊÉ≥Ê≥ïÔºö</p>

<p>ÂΩìÂä†‰∫ÜÂ∏¶ÁºìÂÜ≤ÁöÑËæìÂá∫ËØ≠Âè•Ôºö‰ª•printf‰∏∫‰æãÔºåÁ®ãÂ∫èÁöÑÁºñËØëÊòØÊ≤°ÊúâÈóÆÈ¢òÁöÑÔºå‰ΩÜÊòØÂΩìÁ®ãÂ∫èËøêË°åÊó∂‰æø‰ºö‰∫ßÁîüÈîôËØØ„ÄÇÂéüÂõ†ÊòØÂõ†‰∏∫ÔºöprintfÂáΩÊï∞È¶ñÂÖà‰ºöÂ∞ÜÊ†ºÂºèÊéßÂà∂‰∏≤ËØ≠Âè•ÂÜôÂÖ•Âà∞Ëá™Â∑±ÁöÑÁºìÂÜ≤Âå∫ÈáåÈù¢ÔºåÊ≠§Êó∂‰øÆÊîπ‰∫ÜÂÜÖÂ≠ò‰∏≠ÁöÑÂè™ËØªÊñáÊú¨ÊÆµÔºåÊâÄ‰ª•‰ºöÂØºËá¥Á®ãÂ∫èËß¶Âèë‰∏ÄËà¨‰øùÊä§ÊïÖÈöúÂ§ÑÁêÜÊµÅÁ®ã„ÄÇÈÇ£‰πàÊàë‰ª¨Â¶Ç‰ΩïÂç∞ËØÅËøô‰∏™ÁåúÊÉ≥Âë¢ÔºüÂèØ‰ª•Âà©Áî®stderrÊ†áÂáÜÈîôËØØËæìÂá∫Êù•ÊâìÂç∞Êàë‰ª¨ÊÉ≥Ë¶ÅËæìÂá∫ÁöÑËØ≠Âè•ÔºåÊ≠§Êó∂‰Ω†‰æø‰ºöÂèëÁé∞Á®ãÂ∫èÂæó‰ª•Ê≠£Â∏∏ËøêË°åÔºåÂπ∂Ê≤°ÊúâÂºïÂèë‰ªª‰ΩïÁöÑÊïÖÈöú„ÄÇ
Â¶ÇÊûúÊúâÂº∫Ëø´ÁóáÂ∞±ÊÉ≥Âú®mallocÁöÑÂÆûÁé∞Êñá‰ª∂‰∏≠Âä†ÂÖ•printfËØ≠Âè•ÔºåÈÇ£‰πàÂèØ‰ª•ÂÉè‰∏äÈù¢ÁöÑmemAlloc‰∏ÄÊ†∑Âä†‰∏ÄÂ±ÇÂåÖË£ÖÂáΩÊï∞ÔºåÂú®ËØ•ÂáΩÊï∞‰∏≠ÂèØ‰ª•ÊâßË°åÊõø‰ª£ÂéüÊù•Â∫ìÂáΩÊï∞ÂäüËÉΩÁöÑÊâßË°åÈÄªËæë„ÄÇ</p>

<p>ÂΩìÁÑ∂‰∫Ü‰Ω†‰πüÂèØ‰ª•ÈááÁî®Âú®ÁºñËØëÊó∂ÊúüÊàñËÄÖÈìæÊé•Êó∂ÊúüÂÆåÊàêÂØπÂáΩÊï∞ÁöÑ ‚ÄúÊâìÊ°©‚ÄùÔºåÂú®Ê≠§‰æø‰∏çÂú®ËµòËø∞„ÄÇ</p>

<p>I reduced my problem using below test codes,</p>

<p>main.cc</p>

<p>#include <iostream></iostream></p>

<p>int main(int argc, const char** argv) {
  void init2();
  init2();
  return 0;
}
2.cc</p>

<p>#include <iostream></iostream></p>

<p>int init2() {
  void init1();
  init1();
  std::cout¬´‚Äúinit2 called\n‚Äù;
  return 0;
}
1.cc</p>

<p>#include <dlfcn.h>
#include <pthread.h>
#include <stdio.h>
#include <iostream></iostream></stdio.h></pthread.h></dlfcn.h></p>

<p>typedef FILE* (<em>FopenFunction)(const char</em> path, const char* mode);</p>

<p>static FopenFunction g_libc_fopen = NULL;</p>

<p>void init1() {
 g_libc_fopen = reinterpret_cast<FopenFunction>(
          dlsym(RTLD_NEXT, "fopen"));</FopenFunction></p>

<p>std::cout¬´‚Äúinit1: fopen addr:‚Äù¬´(void*)g_libc_fopen¬´‚Äú\n‚Äù;
}</p>

<p><strong>attribute</strong> ((<strong>visibility</strong>(‚Äúdefault‚Äù)))
FILE* fopen_override(const char* path, const char* mode)  <strong>asm</strong> (‚Äúfopen‚Äù);</p>

<p><strong>attribute</strong> ((<strong>visibility</strong>(‚Äúdefault‚Äù)))
FILE* fopen_override(const char* path, const char* mode) {
  return g_libc_fopen(path, mode);
}
Compiled 1.cc into a lib1.so and 2.cc into lib2.so like below,</p>

<p>g++ 1.cc -shared -ldl -fvisibility=default -fPIC -o lib1.so -L.
g++ 2.cc -shared -ldl -fvisibility=default -fPIC -o lib2.so -l1 -L.
g++ main.cc -l2 -l1 -L.
Above steps will produce lib1.so, lib2.so and a.out. The problem here is while running the executable a.out, it is unable to lookup the original ‚Äúfread‚Äù symbol when using dlsym(RTLD_NEXT).</p>

<p>The output is,</p>

<p>arunprasadr@demo:~/works/myex/c++/rtdl_next$ LD_LIBRARY_PATH=./ ./a.out
init1: fopen addr:0
init2 called
But if the change the link process of lib2.so(like below), it seems to be working</p>

<p>g++ 2.cc -shared -ldl -fvisibility=default -fPIC -o lib2.so -L.
g++ main.cc -l2 -l1 -L.
LD_LIBRARY_PATH=./ ./a.out
output:</p>

<p>arunprasadr@demo:~/works/myex/c++/rtdl_next$ LD_LIBRARY_PATH=./ ./a.out
init1: fopen addr:0x7f9e84a9e2c0
init2 called
Can anyone please explain what is happening in the background? Thanks in advance.</p>

<p>gcc glibc dlopen dlsym uclibc
shareimprove this question
asked Apr 8 ‚Äò14 at 8:57</p>

<p>Arunprasad Rajkumar
1,14299 silver badges2626 bronze badges
add a comment
1 Answer
activeoldestvotes</p>

<p>2</p>

<p>This is an interesting (and unexpected for me) result.</p>

<p>First, using your original commands, I observe:</p>

<p>LD_DEBUG=symbols,bindings LD_LIBRARY_PATH=./ ./a.out |&amp; grep fopen
     10204: symbol=fopen;  lookup in file=/lib/x86_64-linux-gnu/libm.so.6 [0]
     10204: symbol=fopen;  lookup in file=/lib64/ld-linux-x86-64.so.2 [0]
     10204: symbol=fopen;  lookup in file=/lib/x86_64-linux-gnu/libgcc_s.so.1 [0]
     10204: symbol=fopen;  lookup in file=/lib/x86_64-linux-gnu/libdl.so.2 [0]
init1: fopen addr:0
Compare this with the with the same output, but removing -l1 from lib2.sos link line:</p>

<p>LD_DEBUG=symbols,bindings LD_LIBRARY_PATH=./ ./a.out |&amp; grep fopen
     10314: symbol=fopen;  lookup in file=/usr/lib/x86_64-linux-gnu/libstdc++.so.6 [0]
     10314: symbol=fopen;  lookup in file=/lib/x86_64-linux-gnu/libc.so.6 [0]
     10314: binding file ./lib1.so [0] to /lib/x86_64-linux-gnu/libc.so.6 [0]: normal symbol `fopen‚Äô
init1: fopen addr:0x7f03692352c0
The question then is: why isn‚Äôt the loader searching libc.so.6 for fopen in the first case?</p>

<p>The answer: the loader has a linear list of libraries in the _r_debug.r_map link chain, and for RTLD_NEXT will search libraries after the one that is calling dlopen.</p>

<p>Is the order of libraries different for case 1 and case 2? You bet:</p>

<p>case 1:</p>

<p>LD_LIBRARY_PATH=./ ldd ./a.out
    linux-vdso.so.1 =&gt;  (0x00007fff2f1ff000)
    lib2.so =&gt; ./lib2.so (0x00007f54a2b12000)
    libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f54a27f1000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f54a2430000)
    lib1.so =&gt; ./lib1.so (0x00007f54a222e000)
    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f54a1f32000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f54a2d16000)
    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f54a1d1b000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f54a1b17000)
case 2:</p>

<p>LD_LIBRARY_PATH=./ ldd ./a.out
    linux-vdso.so.1 =&gt;  (0x00007fff39fff000)
    lib2.so =&gt; ./lib2.so (0x00007f8502329000)
    lib1.so =&gt; ./lib1.so (0x00007f8502127000)
    libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f8501e05000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8501a45000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f8501841000)
    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f8501544000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f850252d000)
    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f850132e000)
It should now be clear, that for case 2 libc.so.6 follows lib1.so, but for case 1 it does not.</p>

<p>I do not yet understand what causes this particular ordering though. I‚Äôll have to think some more about it.</p>

<p>OS XÁ≥ªÁªü‰∏≠Ôºå‰ªÖÊúâÂæàÂ∞ëÁöÑËøõÁ®ãÂè™ÈúÄË¶ÅÂÜÖÊ†∏Âä†ËΩΩÂô®Â∞±ÂèØ‰ª•ÂÆåÊàêÔºåÂá†‰πéÊâÄÊúâÁöÑÁ®ãÂ∫èÈÉΩÊòØÂä®ÊÄÅËøûÊé•ÁöÑÔºåÈÄöÂ∏∏ÈááÁî®/usr/lib/dyld‰Ωú‰∏∫Âä®ÊÄÅÈìæÊé•Âô®„ÄÇ
‰Ωú‰∏∫‰∏Ä‰∏™ÁßÅÊúâÁöÑÂä†ËΩΩÂô®ÔºådyldÊèê‰æõ‰∫Ü‰∏Ä‰∫õÁã¨ÊúâÁöÑÁâπÊÄßÔºåÂ¶ÇÂáΩÊï∞Êã¶Êà™Á≠â„ÄÇDYLD_INTERPOSEÂÆèÂÆö‰πâÂÖÅËÆ∏‰∏Ä‰∏™Â∫ìÂ∞ÜÂÖ∂ÂáΩÊï∞ÂÆûÁé∞ÊõøÊç¢‰∏∫Âè¶‰∏Ä‰∏™ÂáΩÊï∞ÂÆûÁé∞„ÄÇ‰ª•‰∏ã‰ª£Á†ÅÂèñËá™dyldÁöÑÊ∫ê‰ª£Á†ÅÔºåÊºîÁ§∫‰∫ÜËøô‰∏™ÂäüËÉΩ„ÄÇ</p>

<p>#if !defined(<em>DYLD_INTERPOSING_H</em>)
#define <em>DYLD_INTERPOSING_H</em></p>

<p>#define DYLD_INTERPOSE(<em>replacment,_replacee) \ <strong>attribute</strong>((used)) static strut{const void* replacment;const void* replacee;}
_interpose</em>##_replace \ <strong>attribute</strong>((section (‚Äú__DATA,__interpose‚Äù))) = { (const void<em>)(unsigned long)&amp;_replacement, (const void</em>)(unsigned long)&amp;_replacee};</p>

<p>#endif
dyldÁöÑÂáΩÊï∞Êã¶Êà™ÂäüËÉΩÊèê‰æõ‰∫Ü‰∏Ä‰∏™Êñ∞ÁöÑ__DATAÂå∫ÔºåÂêç‰∏∫__interpose,Âú®Ëøô‰∏™Âå∫‰∏≠‰æùÊ¨°ÂàóÂá∫‰∫ÜÊõøÊç¢ÂáΩÊï∞ÂíåË¢´ÊõøÊç¢ÁöÑÂáΩÊï∞ÔºåÂÖ∂‰ªñ‰∫ãÊÉÖÂ∞±‰∫§Áî±dyldÂ§ÑÁêÜ‰∫Ü„ÄÇ
‰∏ãÈù¢ÈÄöËøá‰∏Ä‰∏™ÂÆûÈ™åÂ±ïÁ§∫Â¶Ç‰ΩïÈÄöËøáÂáΩÊï∞Êã¶Êà™Êú∫Âà∂Ë∑üË∏™mallocÔºàÔºâÂáΩÊï∞</p>

<p>#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include &lt;malloc/malloc.h&gt;</stdlib.h></fcntl.h></unistd.h></stdio.h></p>

<p>//Ê†áÂáÜÁöÑinterposeÊï∞ÊçÆÁªìÊûÑ
typedef struct interpose_s{
    void *new_func;
    void *orig_fnc;
}interpose_t;</p>

<p>//Êàë‰ª¨ÁöÑÂéüÂûã
void *my_malloc(int size);//ÂØπÂ∫îÁúüÂÆûÁöÑmallocÂáΩÊï∞
void my_free(void *);//ÂØπÂ∫îÁúüÂÆûÁöÑfreeÂáΩÊï∞</p>

<p>static const interpose_t interposing_functions[] <br />
<strong>attribute</strong> ((section (‚Äú__DATA,__interpose‚Äù))) ={{(void *)my_free,(void *)free},{(void *)my_malloc,(void *)malloc}};</p>

<p>void *my_malloc (int size){
    //Âú®Êàë‰ª¨ÁöÑÂáΩÊï∞‰∏≠ÔºåË¶ÅËÆøÈóÆÁúüÊ≠£ÁöÑmalloc()ÂáΩÊï∞ÔºåÂõ†‰∏∫‰∏çÊÉ≥Ëá™Â∑±ÁÆ°ÁêÜÊï¥‰∏™Â†ÜÔºåÊâÄ‰ª•Â∞±Ë∞ÉÁî®‰∫ÜÂéüÊù•ÁöÑmalloc()
    void *returned = malloc(size);
    //Ë∞ÉÁî®malloc_printfÊòØÂõ†‰∏∫printf‰∏≠‰ºöË∞ÉÁî®malloc(),‰∫ßÁîüÊó†ÈôêÈÄíÂΩíË∞ÉÁî®„ÄÇ
    malloc_printf(‚Äú+ %p %d\n‚Äù,returned,size);
    return (returned);
}</p>

<p>void my_free(void *freed){
    malloc_printf(‚Äú- %p\n‚Äù,freed);
    free(freed);
}</p>

<p>int main(int argc, const char * argv[]) {
    // ÈáäÊîæÂÜÖÂ≠ò‚Äî‚ÄîÊâìÂç∞Âá∫Âú∞ÂùÄÔºåÁÑ∂ÂêéË∞ÉÁî®ÁúüÊ≠£ÁöÑfree()
    printf(‚ÄúHello, World!\n‚Äù);
    return 0;
}
Âú®ÁªàÁ´Ø‰∏≠ÊâßË°å‰ª•‰∏ã‰ª£Á†ÅÁºñËØë‰∏∫dylibÂπ∂Âº∫Âà∂ÊèíÂÖ•ls‰∏≠</p>

<p>cc -dynamiclib 1.c -o libMTrace.dylib -Wall
DYLD_INSERT_LIBRARIES=libMTrace.dylib ls</p>

<p>ÊúÄÁªà‰ºöÂèëÁé∞Ë∞ÉÁî®mallocÁöÑÂú∞Êñπ‰ºöÊâìÂç∞ËøôÊ†∑ÁöÑ‰ø°ÊÅØ</p>

<p>ls(24346) malloc: + 0x100100020 88
ls(24346) malloc: + 0x100800000 4096
ls(24346) malloc: + 0x100801000 2160
ls(24346) malloc: - 0x100800000
ls(24346) malloc: + 0x100801a00 3312</p>
:ET