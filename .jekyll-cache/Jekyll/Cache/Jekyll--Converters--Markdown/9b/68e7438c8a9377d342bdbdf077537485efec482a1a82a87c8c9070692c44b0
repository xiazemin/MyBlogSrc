I"±_<p>https://opensource.apple.com/source/dyld/dyld-353.2.1/include/mach-o/dyld-interposing.h
//  æ¼”ç¤ºä»£ç  
// #import &lt;mach-o/dyld-interposing.h&gt;
// from dyld-interposing.h
#define DYLD_INTERPOSE(<em>replacement,_replacee) <strong>attribute</strong>((used)) static struct{ const void* replacement; const void* replacee; } _interpose</em>##_replacee <strong>attribute</strong> ((section (â€œ__DATA,__interposeâ€))) = { (const void<em>)(unsigned long)&amp;_replacement, (const void</em>)(unsigned long)&amp;_replacee };</p>

<p>ssize_t hacked_write(int fildes, const void *buf, size_t nbyte)
{
    printf(â€œ[++++]into hacked_writeï¼ï¼ï¼by piaoyunâ€);
    return write(fildes, buf, nbyte);
}</p>

<p>DYLD_INTERPOSE(hacked_write, write);</p>

<p>// å†æ¥ä¸ªæ¼”ç¤ºä»£ç ï¼š</p>

<p>// ç¼–è¯‘
// cc -dynamiclib main.c -o libHook.dylib -Wall
// å¼ºè¡Œæ³¨å…¥lsæµ‹è¯•
// DYLD_INSERT_LIBRARIES=libHook.dylib ls
#include &lt;malloc/malloc.h&gt;</p>

<p>#define DYLD_INTERPOSE(<em>replacement,_replacee) <br />
<strong>attribute</strong>((used)) static struct{ const void* replacement; const void* replacee; } _interpose</em>##_replacee <br />
<strong>attribute</strong> ((section (â€œ__DATA,__interposeâ€))) = { (const void<em>)(unsigned long)&amp;_replacement, (const void</em>)(unsigned long)&amp;_replacee };</p>

<p>void *hacked_malloc(size_t size){
    void *ret = malloc(size);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>malloc_printf("+ %p %d\n", ret, size);
return ret; }
</code></pre></div></div>

<p>void hacked_free(void *freed){
    malloc_printf(â€œ- %p\nâ€, freed);
    free(freed);
}</p>

<p>DYLD_INTERPOSE(hacked_malloc, malloc)
DYLD_INTERPOSE(hacked_free, free);</p>

<!-- more -->
<p>/*</p>
<ul>
  <li>Copyright (c) 2005-2008 Apple Computer, Inc. All rights reserved.
 *</li>
  <li>@APPLE_LICENSE_HEADER_START@</li>
  <li></li>
  <li>This file contains Original Code and/or Modifications of Original Code</li>
  <li>as defined in and that are subject to the Apple Public Source License</li>
  <li>Version 2.0 (the â€˜Licenseâ€™). You may not use this file except in</li>
  <li>compliance with the License. Please obtain a copy of the License at</li>
  <li>http://www.opensource.apple.com/apsl/ and read it before using this</li>
  <li>file.</li>
  <li></li>
  <li>The Original Code and all software distributed under the License are</li>
  <li>distributed on an â€˜AS ISâ€™ basis, WITHOUT WARRANTY OF ANY KIND, EITHER</li>
  <li>EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,</li>
  <li>INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,</li>
  <li>FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.</li>
  <li>Please see the License for the specific language governing rights and</li>
  <li>limitations under the License.</li>
  <li></li>
  <li>@APPLE_LICENSE_HEADER_END@
 */</li>
</ul>

<p>#if !defined(<em>DYLD_INTERPOSING_H</em>)
#define <em>DYLD_INTERPOSING_H</em></p>

<p>/*</p>
<ul>
  <li>Example:
 *</li>
  <li>static</li>
  <li>int</li>
  <li>my_open(const char* path, int flags, mode_t mode)</li>
  <li>{</li>
  <li>int value;</li>
  <li>// do stuff before open (including changing the arguments)</li>
  <li>value = open(path, flags, mode);</li>
  <li>// do stuff after open (including changing the return value(s))</li>
  <li>return value;</li>
  <li>}</li>
  <li>DYLD_INTERPOSE(my_open, open)
 */</li>
</ul>

<p>#define DYLD_INTERPOSE(<em>replacement,_replacee) <br />
   <strong>attribute</strong>((used)) static struct{ const void* replacement; const void* replacee; } _interpose</em>##_replacee <br />
            <strong>attribute</strong> ((section (â€œ__DATA,__interposeâ€))) = { (const void<em>)(unsigned long)&amp;_replacement, (const void</em>)(unsigned long)&amp;_replacee };</p>

<p>#endif</p>

<p>https://www.cnblogs.com/cobbliu/p/7347923.html?utm_source=itdadao&amp;utm_medium=referral</p>

<p>There are times when you want to wrap a library function in order to provide some additional functionality. A common example of this is wrapping the standard libraryâ€™s malloc() and free() so that you can easily track memory allocations in your program. While there are several techniques for wrapping library functions, one well-known method is using dlsym() with RTLD_NEXT to locate the wrapped functionâ€™s address so that you can correctly forward calls to it.</p>

<p>Problem
So what can go wrong? Letâ€™s look at an example:</p>

<p>LibWrap.h</p>

<p>void* memAlloc(size_t s);
// Allocate a memory block of size â€˜sâ€™ bytes.
void memDel(void* p);
// Free the block of memory pointed to by â€˜pâ€™.
LibWrap.c</p>

<p>#define _GNU_SOURCE
#include <dlfcn.h>
#include "LibWrap.h"</dlfcn.h></p>

<p>static void* malloc(size_t s) {
   // Wrapper for standard libraryâ€™s â€˜mallocâ€™.
   // The â€˜staticâ€™ keyword forces all calls to malloc() in this file to resolve
   // to this functions.
   void* (*origMalloc)(size_t) = dlsym(RTLD_NEXT,â€mallocâ€);
   return origMalloc(s);
}</p>

<p>static void free(void* p) {
   // Wrapper for standard libraryâ€™s â€˜freeâ€™.
   // The â€˜staticâ€™ keyword forces all calls to free() in this file to resolve
   // to this functions.
   void (<em>origFree)(void</em>) = dlsym(RTLD_NEXT,â€freeâ€);
   origFree(p);
}</p>

<p>void* memAlloc(size_t s) {
   return malloc(s);
   // Call the malloc() wrapper.
}</p>

<p>void memDel(void* p) {
   free(p);
   // Call the free() wrapper.
}
Main.c</p>

<p>#include <malloc.h>
#include "LibWrap.h"</malloc.h></p>

<p>int main() {
   struct mallinfo beforeMalloc = mallinfo();
   printf(â€œBytes allocated before malloc: %d\nâ€,beforeMalloc.uordblks);</p>

<p>void* p = memAlloc(57);
   struct mallinfo afterMalloc = mallinfo();
   printf(â€œBytes allocated after malloc: %d\nâ€,afterMalloc.uordblks);</p>

<p>memDel(p);
   struct mallinfo afterFree = mallinfo();
   printf(â€œBytes allocated after free: %d\nâ€,afterFree.uordblks);</p>

<p>return 0;
}
First compile LibWrap.c into a shared library:</p>

<p>$ gcc -Wall -Werror -fPIC -shared -o libWrap.so LibWrap.c
Next compile Main.c and link it against the libWrap.so that we just created:</p>

<p>$ gcc -Wall -Werror -o Main Main.c ./libWrap.so -ldl
Time to run the program!</p>

<p>$ ./Main
Bytes allocated before malloc: 0
Bytes allocated after malloc: 80
Bytes allocated after free: 0
So far, so good. No surprises. We allocated a bunch of memory and then freed it. The statistics returned by mallinfo() confirm this.</p>

<p>Out of curiosity, letâ€™s look at ldd output for the application binary we created.</p>

<p>$ ldd Main
       linux-vdso.so.1 =&gt;  (0x00007fff1b1fe000)
       ./libWrap.so (0x00007fe7d2755000)
       libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fe7d2542000)
       libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fe7d217c000)
       /lib64/ld-linux-x86-64.so.2 (0x00007fe7d2959000)</p>

<p>Take note of the relative placement of libWrap.so with respect to libc.so.6: libWrap.socomes before libc.so.6. Remember this. It will be important later.</p>

<p>Now for fun, letâ€™s re-compile Main.c with libc.so.6 explicitly specified on the command-line and coming before libWrap.so:</p>

<p>$ gcc -Wall -Werror -o Main Main.c /lib/x86_64-linux-gnu/libc.so.6 ./libWrap.so -ldl
Re-run:</p>

<p>$ ./Main
Bytes allocated before malloc: 0
Bytes allocated after malloc: 80
Bytes allocated after free: 80
Uh oh, why are we leaking memory all of a sudden? We de-allocate everything we allocate, so why the memory leak?</p>

<p>It turns out that the leak is occurring because we are not actually forwarding malloc() and free() calls to libc.so.6â€˜s implementations. Instead, we are forwarding them to malloc() and free() inside ld-linux-x86-64.so.2!</p>

<p>â€œWhat are you talking about?!â€ you might be asking.</p>

<p>Well, it just so happens that ld-linux-x86-64.so.2, which is the dynamic linker/loader, has its own copy of malloc() and free(). Why? Because ld-linux has to allocate memory from the heap before it loads libc.so.6. But the version of malloc/free that ld-linuxhas does not actually free memory!</p>

<p>[RTLD_NEXT] will find the next occurrence of a function in the search order after the current library. This allows one to provide a wrapper around a function in another shared library.But why does libWrap.so forward calls to ld-linux instead of libc? The answer comes down to how dlsym() searches for symbols when RTLD_NEXT is specified. Hereâ€™s the relevant excerpt from the dlsym(3) man page:â€” dlsym(3)</p>

<p>To understand this better, take a look at ldd output for the new Main binary:</p>

<p>$ ldd Main
        linux-vdso.so.1 =&gt;  (0x00007fffe1da0000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f32c2e91000)
        ./libWrap.so (0x00007f32c2c8f000)
        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f32c2a8a000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f32c3267000)
Unlike earlier, libWrap.so comes after libc.so.6. So when dlsym() is called inside libWrap.so to search for functions, it skips libc.so.6 since it precedes libWrap.so in the search order list. That means the searches continue through to ld-linux-x86-64.so.2where they find linker/loaderâ€™s malloc/free and return pointers to those functions. And so, libWrap.so ends up forwading calls to ld-linux instead of libc!</p>

<p>The answer is unfortunately no. At OptumSoft, we recently encountered this very same memory leak with a binary compiled using the standard ./configure &amp;&amp; make on x86-64 Ubuntu 14.04.1 LTS. For reasons we donâ€™t understand, the linking order for the binary was such that using dlsym() with RTLD_NEXT to lookup malloc/free resulted in pointers to implementations inside ld-linux. It took a ton of effort and invaluable help from Mozillaâ€™s rr tool to root-cause the issue. After the whole ordeal, we decided to write a blog post about this strange behavior in case someone else encounters it in the future.At this point you might be wondering: We ran a somewhat funky command to build our application and then encountered a memory leak due to weird library linking order caused by said command. Isnâ€™t this whole thing a silly contrived scenario?</p>

<p>Solution
If you find dlsym() with RTLD_NEXT returning pointers to malloc/free inside ld-linux, what can you do?</p>

<p>For starters, you need to detect that a function address indeed does belong to ld-linuxusing dladdr():</p>

<p>void* func = dlsym(RTLD_NEXT,â€mallocâ€);
Dl_info dlInfo;
if(!dladdr(func,&amp;dlInfo)) {
   // dladdr() failed.
}
if(strstr(dlInfo.dli_fname,â€ld-linuxâ€)) {
   // â€˜mallocâ€™ is inside linker/loader.
}
Once you have figured out that a function is inside ld-linux, you need to decide what to do next. Unfortunately, there is no straightforward way to continue searching for the same function name in all other libraries. But if you know the name of a specific library in which the function exists (e.g. libc), you can use dlopen() and dlsym() to fetch the desired pointer:</p>

<p>void* handle = dlopen(â€œlibc.so.6â€,RTLD_LAZY);
// NOTE: libc.so.6 may <em>not</em> exist on Alpha and IA-64 architectures.
if(!handle) {
   // dlopen() failed.
}
void* func = dlsym(handle,â€freeâ€);
if(!func) {
   // Bad! â€˜freeâ€™ was not found inside libc.
}</p>

<p>Summary
One can use dlsym() with RTLD_NEXT to implement wrappers around malloc() and free().
Due to unexpected linking behavior, dlsym() when using RTLD_NEXT can return pointers to malloc/free implementations inside ld-linux (dynamic linker/loader). Using ld-linuxâ€˜s malloc/free for general heap allocations leads to memory leaks because that particular version of free() doesnâ€™t actually release memory.
You can check if an address returned by dlsym() belongs to ld-linux via dladdr(). You can also lookup a function in a specific library using dlopen() and dlsym().</p>

<p>dlsymç”¨æ³•</p>
<ol>
  <li>
    <p>åŒ…å«å¤´æ–‡ä»¶ #include<dlfcn.h></dlfcn.h></p>
  </li>
  <li>
    <p>å‡½æ•°å®šä¹‰ void <em>dlsym(void *handle, const char</em> symbol);</p>
  </li>
</ol>

<p>handleæ˜¯ä½¿ç”¨dlopenå‡½æ•°ä¹‹åè¿”å›çš„å¥æŸ„ï¼Œsymbolæ˜¯è¦æ±‚è·å–çš„å‡½æ•°çš„åç§°ï¼Œå‡½æ•°ï¼Œè¿”å›å€¼æ˜¯void*,æŒ‡å‘å‡½æ•°çš„åœ°å€ï¼Œä¾›è°ƒç”¨ä½¿ç”¨</p>

<p>dlsymä¸dlopençš„ä»¥å¦‚ä¸‹ä¾‹å­è§£é‡Šï¼š</p>

<p>#include<dlfcn.h></dlfcn.h></p>

<p>void * handle = dlopen(â€œ./testListDB.soâ€,RTLD_LAZY);</p>

<p>å¦‚æœcreateListDBå‡½æ•°å®šä¹‰ä¸ºint32_t createListDB(std::string);</p>

<p>é‚£ä¹ˆdlsymçš„ç”¨æ³•åˆ™ä¸ºï¼šint32_t  (<em>create_listDB)(std::string) = reinterpret_cast&lt;int32_t (</em>)(std::string)&gt;(dlsym(handle, â€œcreateListDBâ€))</p>

<p>createListDBåº“å‡½æ•°çš„å®šä¹‰è¦ç”¨externæ¥å£°æ˜ï¼Œè¿™æ ·åœ¨ä¸»å‡½æ•°ä¸­æ‰èƒ½é€šè¿‡createListDBæ¥æŸ¥æ‰¾å‡½æ•°ï¼Œ</p>

<p>ç›¸æ¯”äºå·²çŸ¥å‡½æ•°çš„æ‰€åœ¨åŠ¨æ€åº“ï¼Œå‡½æ•°dlsymçš„å‚æ•°RTLD_NEXTå¯ä»¥åœ¨å¯¹å‡½æ•°å®ç°æ‰€åœ¨åŠ¨æ€åº“åç§°æœªçŸ¥çš„æƒ…å†µä¸‹å®Œæˆå¯¹åº“å‡½æ•°çš„æ›¿ä»£ã€‚è¿™æä¾›äº†å·¨å¤§çš„ä¾¿åˆ©ã€‚ä½†æ˜¯å‡¡æ˜¯æœ‰ä¸€åˆ©å¿…æœ‰ä¸€å¼Šï¼Œåœ¨ä½¿ç”¨è¯¥å‚æ•°æ—¶ï¼Œéœ€è¦æ³¨æ„ä¸€äº›é—®é¢˜ã€‚</p>

<p>ä½¿ç”¨çš„å‡½æ•°æ–‡ä»¶
mainå‡½æ•°.c</p>

<p>#include <stdio.h>
#include <malloc.h></malloc.h></stdio.h></p>

<p>int main (void) {
    struct mallinfo bfmalloc = mallinfo();
    printf(â€œbfmalloc: %d\nâ€,bfmalloc.uordblks);
    int *p = malloc(32);
    struct mallinfo afmalloc  = mallinfo();
    printf(â€œafmalloc: %d\nâ€,afmalloc.uordblks);
    free(p);
    struct mallinfo fmalloc = mallinfo();
    printf(â€œfmalloc: %d\nâ€,fmalloc.uordblks);
    return 0;
}</p>

<p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
åŒ…è£…å‡½æ•°å®ç°æ–‡ä»¶.h</p>

<p>void *memAlloc(size_t size);
void memFree(void *ptr);
1
2
åŒ…è£…å®ç°æ–‡ä»¶.c</p>

<p>#ifdef RUNTIME
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <assert.h>
#include "mymalloc.h"
void *malloc(size_t size) {
    void*(*mallocp)(size_t size);
    char *error;
    mallocp = dlsym(RTLD_NEXT,"malloc");
    assert(dlerror() == NULL);
    char *ptr = mallocp(size);
    return ptr;
}
void free(void *ptr) {
    assert(ptr != NULL);
    char *error;
    void (*freep)(void *ptr);
    freep = dlsym(RTLD_NEXT,"free");
    assert(dlerror() == NULL);
    freep(ptr);
}
void *memAlloc (size_t size) {
    void *ptr = malloc(size);
    printf("ret:%d : %p\n",size,ptr);
    return ptr;
}
void memFree(void *ptr) {
    free(ptr);
    printf("free ret: %p\n",ptr);
}
#endif
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
æˆ‘ä»¬é¦–å…ˆç¼–è¯‘å¹¶è¿è¡Œä¸€ä¸‹ç¨‹åºï¼Œçœ‹çœ‹è¿è¡Œç»“æœ
ç¼–è¯‘æ­¥éª¤ï¼š</assert.h></malloc.h></stdlib.h></stdio.h></dlfcn.h></p>

<p>gcc -DRUNTIME -shared -fPIC -o mymalloc.so mymalloc.c
gcc -o t main.c ./mymalloc.so -ldl
1
2
è¿è¡Œ./t</p>

<p>æˆ‘ä»¬å¯ä»¥å¾ˆæ˜æ˜¾çš„çœ‹åˆ°ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰é‡Šæ”¾æ‰æˆ‘ä»¬æ‰€ç”³è¯·çš„ç©ºé—´ï¼Œè™½ç„¶æˆ‘ä»¬æ˜¾ç¤ºçš„è°ƒç”¨äº†å†…å­˜åˆ†é…å‡½æ•°freeã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆä¼šé€ æˆå†…å­˜æ³„éœ²å‘¢ï¼Ÿç®€å•çš„æ¥è¯´åŸå› æ˜¯å› ä¸ºåœ¨ä½¿ç”¨äº†RTLD_NEXTå‚æ•°åï¼Œç¼–è¯‘å™¨åœ¨æŸ¥è¯¢å‡½æ•°çš„å®ç°åº“æ—¶ï¼Œå¯¹åº“çš„è®¿é—®é¡ºåºä¸åŒé€ æˆçš„ï¼Œè¯¦ç»†çš„åŸå› å¤§å®¶å¯ä»¥å‚è€ƒä¸‹é¢è¿™ç¯‡åšæ–‡ï¼š
Dangers of using dlsym() with RTLD_NEXT</p>

<p>å…¶æ¬¡åœ¨ä½¿ç”¨è¯¥å‚æ•°æ—¶è¿˜ç¢°åˆ°äº†ä¸€ä¸ªé—®é¢˜ï¼šä¸èƒ½åœ¨mallocçš„å®ç°æ–‡ä»¶é‡Œé¢åŠ å…¥ä»»ä½•å¸¦æœ‰ç¼“å†²çš„è¾“å‡ºè¯­å¥ï¼Œå¦åˆ™ä¾¿æˆ–é€ æˆæ®µé”™è¯¯ï¼šæœ‰å…´è¶£çš„è¯»è€…å¯ä»¥è¯•ä¸€ä¸‹ã€‚è¿™ä¸ªæ˜¯åŠ äº†printfè¯­å¥ä¹‹åï¼Œå‡½æ•°çš„è°ƒç”¨æ ˆ</p>

<p>è‡³äºç¨‹åºä¸ºä»€ä¹ˆä¼šåœ¨__vfprintf_internal()å­å‡½æ•°å¤„å®•æ‰ï¼Œæˆ‘æœ‰ä¸€ä¸ªå¤§èƒ†çš„æƒ³æ³•ï¼š</p>

<p>å½“åŠ äº†å¸¦ç¼“å†²çš„è¾“å‡ºè¯­å¥ï¼šä»¥printfä¸ºä¾‹ï¼Œç¨‹åºçš„ç¼–è¯‘æ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼Œä½†æ˜¯å½“ç¨‹åºè¿è¡Œæ—¶ä¾¿ä¼šäº§ç”Ÿé”™è¯¯ã€‚åŸå› æ˜¯å› ä¸ºï¼šprintfå‡½æ•°é¦–å…ˆä¼šå°†æ ¼å¼æ§åˆ¶ä¸²è¯­å¥å†™å…¥åˆ°è‡ªå·±çš„ç¼“å†²åŒºé‡Œé¢ï¼Œæ­¤æ—¶ä¿®æ”¹äº†å†…å­˜ä¸­çš„åªè¯»æ–‡æœ¬æ®µï¼Œæ‰€ä»¥ä¼šå¯¼è‡´ç¨‹åºè§¦å‘ä¸€èˆ¬ä¿æŠ¤æ•…éšœå¤„ç†æµç¨‹ã€‚é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•å°è¯è¿™ä¸ªçŒœæƒ³å‘¢ï¼Ÿå¯ä»¥åˆ©ç”¨stderræ ‡å‡†é”™è¯¯è¾“å‡ºæ¥æ‰“å°æˆ‘ä»¬æƒ³è¦è¾“å‡ºçš„è¯­å¥ï¼Œæ­¤æ—¶ä½ ä¾¿ä¼šå‘ç°ç¨‹åºå¾—ä»¥æ­£å¸¸è¿è¡Œï¼Œå¹¶æ²¡æœ‰å¼•å‘ä»»ä½•çš„æ•…éšœã€‚
å¦‚æœæœ‰å¼ºè¿«ç—‡å°±æƒ³åœ¨mallocçš„å®ç°æ–‡ä»¶ä¸­åŠ å…¥printfè¯­å¥ï¼Œé‚£ä¹ˆå¯ä»¥åƒä¸Šé¢çš„memAllocä¸€æ ·åŠ ä¸€å±‚åŒ…è£…å‡½æ•°ï¼Œåœ¨è¯¥å‡½æ•°ä¸­å¯ä»¥æ‰§è¡Œæ›¿ä»£åŸæ¥åº“å‡½æ•°åŠŸèƒ½çš„æ‰§è¡Œé€»è¾‘ã€‚</p>

<p>å½“ç„¶äº†ä½ ä¹Ÿå¯ä»¥é‡‡ç”¨åœ¨ç¼–è¯‘æ—¶æœŸæˆ–è€…é“¾æ¥æ—¶æœŸå®Œæˆå¯¹å‡½æ•°çš„ â€œæ‰“æ¡©â€ï¼Œåœ¨æ­¤ä¾¿ä¸åœ¨èµ˜è¿°ã€‚</p>

<p>I reduced my problem using below test codes,</p>

<p>main.cc</p>

<p>#include <iostream></iostream></p>

<p>int main(int argc, const char** argv) {
  void init2();
  init2();
  return 0;
}
2.cc</p>

<p>#include <iostream></iostream></p>

<p>int init2() {
  void init1();
  init1();
  std::coutÂ«â€œinit2 called\nâ€;
  return 0;
}
1.cc</p>

<p>#include <dlfcn.h>
#include <pthread.h>
#include <stdio.h>
#include <iostream></iostream></stdio.h></pthread.h></dlfcn.h></p>

<p>typedef FILE* (<em>FopenFunction)(const char</em> path, const char* mode);</p>

<p>static FopenFunction g_libc_fopen = NULL;</p>

<p>void init1() {
 g_libc_fopen = reinterpret_cast<FopenFunction>(
          dlsym(RTLD_NEXT, "fopen"));</FopenFunction></p>

<p>std::coutÂ«â€œinit1: fopen addr:â€Â«(void*)g_libc_fopenÂ«â€œ\nâ€;
}</p>

<p><strong>attribute</strong> ((<strong>visibility</strong>(â€œdefaultâ€)))
FILE* fopen_override(const char* path, const char* mode)  <strong>asm</strong> (â€œfopenâ€);</p>

<p><strong>attribute</strong> ((<strong>visibility</strong>(â€œdefaultâ€)))
FILE* fopen_override(const char* path, const char* mode) {
  return g_libc_fopen(path, mode);
}
Compiled 1.cc into a lib1.so and 2.cc into lib2.so like below,</p>

<p>g++ 1.cc -shared -ldl -fvisibility=default -fPIC -o lib1.so -L.
g++ 2.cc -shared -ldl -fvisibility=default -fPIC -o lib2.so -l1 -L.
g++ main.cc -l2 -l1 -L.
Above steps will produce lib1.so, lib2.so and a.out. The problem here is while running the executable a.out, it is unable to lookup the original â€œfreadâ€ symbol when using dlsym(RTLD_NEXT).</p>

<p>The output is,</p>

<p>arunprasadr@demo:~/works/myex/c++/rtdl_next$ LD_LIBRARY_PATH=./ ./a.out
init1: fopen addr:0
init2 called
But if the change the link process of lib2.so(like below), it seems to be working</p>

<p>g++ 2.cc -shared -ldl -fvisibility=default -fPIC -o lib2.so -L.
g++ main.cc -l2 -l1 -L.
LD_LIBRARY_PATH=./ ./a.out
output:</p>

<p>arunprasadr@demo:~/works/myex/c++/rtdl_next$ LD_LIBRARY_PATH=./ ./a.out
init1: fopen addr:0x7f9e84a9e2c0
init2 called
Can anyone please explain what is happening in the background? Thanks in advance.</p>

<p>gcc glibc dlopen dlsym uclibc
shareimprove this question
asked Apr 8 â€˜14 at 8:57</p>

<p>Arunprasad Rajkumar
1,14299 silver badges2626 bronze badges
add a comment
1 Answer
activeoldestvotes</p>

<p>2</p>

<p>This is an interesting (and unexpected for me) result.</p>

<p>First, using your original commands, I observe:</p>

<p>LD_DEBUG=symbols,bindings LD_LIBRARY_PATH=./ ./a.out |&amp; grep fopen
     10204: symbol=fopen;  lookup in file=/lib/x86_64-linux-gnu/libm.so.6 [0]
     10204: symbol=fopen;  lookup in file=/lib64/ld-linux-x86-64.so.2 [0]
     10204: symbol=fopen;  lookup in file=/lib/x86_64-linux-gnu/libgcc_s.so.1 [0]
     10204: symbol=fopen;  lookup in file=/lib/x86_64-linux-gnu/libdl.so.2 [0]
init1: fopen addr:0
Compare this with the with the same output, but removing -l1 from lib2.sos link line:</p>

<p>LD_DEBUG=symbols,bindings LD_LIBRARY_PATH=./ ./a.out |&amp; grep fopen
     10314: symbol=fopen;  lookup in file=/usr/lib/x86_64-linux-gnu/libstdc++.so.6 [0]
     10314: symbol=fopen;  lookup in file=/lib/x86_64-linux-gnu/libc.so.6 [0]
     10314: binding file ./lib1.so [0] to /lib/x86_64-linux-gnu/libc.so.6 [0]: normal symbol `fopenâ€™
init1: fopen addr:0x7f03692352c0
The question then is: why isnâ€™t the loader searching libc.so.6 for fopen in the first case?</p>

<p>The answer: the loader has a linear list of libraries in the _r_debug.r_map link chain, and for RTLD_NEXT will search libraries after the one that is calling dlopen.</p>

<p>Is the order of libraries different for case 1 and case 2? You bet:</p>

<p>case 1:</p>

<p>LD_LIBRARY_PATH=./ ldd ./a.out
    linux-vdso.so.1 =&gt;  (0x00007fff2f1ff000)
    lib2.so =&gt; ./lib2.so (0x00007f54a2b12000)
    libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f54a27f1000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f54a2430000)
    lib1.so =&gt; ./lib1.so (0x00007f54a222e000)
    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f54a1f32000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f54a2d16000)
    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f54a1d1b000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f54a1b17000)
case 2:</p>

<p>LD_LIBRARY_PATH=./ ldd ./a.out
    linux-vdso.so.1 =&gt;  (0x00007fff39fff000)
    lib2.so =&gt; ./lib2.so (0x00007f8502329000)
    lib1.so =&gt; ./lib1.so (0x00007f8502127000)
    libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f8501e05000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f8501a45000)
    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f8501841000)
    libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f8501544000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f850252d000)
    libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f850132e000)
It should now be clear, that for case 2 libc.so.6 follows lib1.so, but for case 1 it does not.</p>

<p>I do not yet understand what causes this particular ordering though. Iâ€™ll have to think some more about it.</p>

<p>OS Xç³»ç»Ÿä¸­ï¼Œä»…æœ‰å¾ˆå°‘çš„è¿›ç¨‹åªéœ€è¦å†…æ ¸åŠ è½½å™¨å°±å¯ä»¥å®Œæˆï¼Œå‡ ä¹æ‰€æœ‰çš„ç¨‹åºéƒ½æ˜¯åŠ¨æ€è¿æ¥çš„ï¼Œé€šå¸¸é‡‡ç”¨/usr/lib/dyldä½œä¸ºåŠ¨æ€é“¾æ¥å™¨ã€‚
ä½œä¸ºä¸€ä¸ªç§æœ‰çš„åŠ è½½å™¨ï¼Œdyldæä¾›äº†ä¸€äº›ç‹¬æœ‰çš„ç‰¹æ€§ï¼Œå¦‚å‡½æ•°æ‹¦æˆªç­‰ã€‚DYLD_INTERPOSEå®å®šä¹‰å…è®¸ä¸€ä¸ªåº“å°†å…¶å‡½æ•°å®ç°æ›¿æ¢ä¸ºå¦ä¸€ä¸ªå‡½æ•°å®ç°ã€‚ä»¥ä¸‹ä»£ç å–è‡ªdyldçš„æºä»£ç ï¼Œæ¼”ç¤ºäº†è¿™ä¸ªåŠŸèƒ½ã€‚</p>

<p>#if !defined(<em>DYLD_INTERPOSING_H</em>)
#define <em>DYLD_INTERPOSING_H</em></p>

<p>#define DYLD_INTERPOSE(<em>replacment,_replacee) \ <strong>attribute</strong>((used)) static strut{const void* replacment;const void* replacee;}
_interpose</em>##_replace \ <strong>attribute</strong>((section (â€œ__DATA,__interposeâ€))) = { (const void<em>)(unsigned long)&amp;_replacement, (const void</em>)(unsigned long)&amp;_replacee};</p>

<p>#endif
dyldçš„å‡½æ•°æ‹¦æˆªåŠŸèƒ½æä¾›äº†ä¸€ä¸ªæ–°çš„__DATAåŒºï¼Œåä¸º__interpose,åœ¨è¿™ä¸ªåŒºä¸­ä¾æ¬¡åˆ—å‡ºäº†æ›¿æ¢å‡½æ•°å’Œè¢«æ›¿æ¢çš„å‡½æ•°ï¼Œå…¶ä»–äº‹æƒ…å°±äº¤ç”±dyldå¤„ç†äº†ã€‚
ä¸‹é¢é€šè¿‡ä¸€ä¸ªå®éªŒå±•ç¤ºå¦‚ä½•é€šè¿‡å‡½æ•°æ‹¦æˆªæœºåˆ¶è·Ÿè¸ªmallocï¼ˆï¼‰å‡½æ•°</p>

<p>#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdlib.h>
#include &lt;malloc/malloc.h&gt;</stdlib.h></fcntl.h></unistd.h></stdio.h></p>

<p>//æ ‡å‡†çš„interposeæ•°æ®ç»“æ„
typedef struct interpose_s{
    void *new_func;
    void *orig_fnc;
}interpose_t;</p>

<p>//æˆ‘ä»¬çš„åŸå‹
void *my_malloc(int size);//å¯¹åº”çœŸå®çš„mallocå‡½æ•°
void my_free(void *);//å¯¹åº”çœŸå®çš„freeå‡½æ•°</p>

<p>static const interpose_t interposing_functions[] <br />
<strong>attribute</strong> ((section (â€œ__DATA,__interposeâ€))) ={{(void *)my_free,(void *)free},{(void *)my_malloc,(void *)malloc}};</p>

<p>void *my_malloc (int size){
    //åœ¨æˆ‘ä»¬çš„å‡½æ•°ä¸­ï¼Œè¦è®¿é—®çœŸæ­£çš„malloc()å‡½æ•°ï¼Œå› ä¸ºä¸æƒ³è‡ªå·±ç®¡ç†æ•´ä¸ªå †ï¼Œæ‰€ä»¥å°±è°ƒç”¨äº†åŸæ¥çš„malloc()
    void *returned = malloc(size);
    //è°ƒç”¨malloc_printfæ˜¯å› ä¸ºprintfä¸­ä¼šè°ƒç”¨malloc(),äº§ç”Ÿæ— é™é€’å½’è°ƒç”¨ã€‚
    malloc_printf(â€œ+ %p %d\nâ€,returned,size);
    return (returned);
}</p>

<p>void my_free(void *freed){
    malloc_printf(â€œ- %p\nâ€,freed);
    free(freed);
}</p>

<p>int main(int argc, const char * argv[]) {
    // é‡Šæ”¾å†…å­˜â€”â€”æ‰“å°å‡ºåœ°å€ï¼Œç„¶åè°ƒç”¨çœŸæ­£çš„free()
    printf(â€œHello, World!\nâ€);
    return 0;
}
åœ¨ç»ˆç«¯ä¸­æ‰§è¡Œä»¥ä¸‹ä»£ç ç¼–è¯‘ä¸ºdylibå¹¶å¼ºåˆ¶æ’å…¥lsä¸­</p>

<p>cc -dynamiclib 1.c -o libMTrace.dylib -Wall
DYLD_INSERT_LIBRARIES=libMTrace.dylib ls</p>

<p>æœ€ç»ˆä¼šå‘ç°è°ƒç”¨mallocçš„åœ°æ–¹ä¼šæ‰“å°è¿™æ ·çš„ä¿¡æ¯</p>

<p>ls(24346) malloc: + 0x100100020 88
ls(24346) malloc: + 0x100800000 4096
ls(24346) malloc: + 0x100801000 2160
ls(24346) malloc: - 0x100800000
ls(24346) malloc: + 0x100801a00 3312</p>
:ET