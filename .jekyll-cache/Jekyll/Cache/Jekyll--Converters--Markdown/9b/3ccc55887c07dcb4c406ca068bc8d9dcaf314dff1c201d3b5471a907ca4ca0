I"?<p>https://github.com/golang/groupcache
ç¼“å­˜æ›´æ–°é—®é¢˜
å½“ç¼“å­˜å¤±æ•ˆæ—¶ï¼Œéœ€è¦å»æ•°æ®å­˜å‚¨å±‚è·å–æ•°æ®ï¼Œç„¶åå­˜å‚¨åˆ°ç¼“å­˜ä¸­ã€‚</p>

<p>é€šå¸¸ç¼“å­˜æ›´æ–°æ–¹æ¡ˆï¼š</p>

<p>ä¸šåŠ¡ä»£ç ä¸­ï¼Œæ ¹æ®keyä»ç¼“å­˜æ‹¿ä¸åˆ°æ•°æ®ï¼Œè®¿é—®å­˜å‚¨å±‚è·å–æ•°æ®åæ›´æ–°ç¼“å­˜
ç”±ä¸“é—¨çš„å®šæ—¶è„šæœ¬åœ¨ç¼“å­˜å¤±æ•ˆå‰å¯¹å…¶è¿›è¡Œæ›´æ–°
é€šè¿‡åˆ†å¸ƒå¼é”ï¼Œå®ç°åªæœ‰ä¸€ä¸ªè¯·æ±‚è´Ÿè´£ç¼“å­˜æ›´æ–°ï¼Œå…¶ä»–è¯·æ±‚ç­‰å¾…ï¼šä¸€ç§åŸºäºå“¨å…µçš„ç¼“å­˜è®¿é—®ç­–ç•¥
æœåŠ¡ä¸­æŸä¸ªæ¥å£è¯·æ±‚é‡æš´å¢é—®é¢˜
æ¯”å¦‚æŸä¸ªå¸–å­çªç„¶å¾ˆç«ï¼Œå¸–å­ä¸‹æœ‰éå¸¸å¤šçš„è·Ÿå¸–å›å¤ï¼Œè´Ÿè´£æä¾›å¸–å­å†…å®¹ã€å›å¸–å†…å®¹çš„æ¥å£ï¼Œå¯¹äºè¯¥å¸–å­çš„è¯·æ±‚é‡å°±ä¼šéå¸¸å¤šã€‚</p>

<p>å¦‚æœæ¯ä¸ªè¯·æ±‚éƒ½è½åˆ°ä¸‹æ¸¸æœåŠ¡ï¼Œé€šå¸¸ä¼šå¯¼è‡´ä¸‹æ¸¸æœåŠ¡ç¬æ—¶è´Ÿè½½å‡é«˜ã€‚å¦‚æœä½¿ç”¨ç¼“å­˜ï¼Œå¦‚ä½•åˆ¤æ–­å½“å‰æ¥å£è¯·æ±‚çš„å†…å®¹éœ€è¦ç¼“å­˜ä¸‹æ¥ï¼Ÿç¼“å­˜çš„è¿‡æœŸã€æ›´æ–°é—®é¢˜ï¼Ÿ</p>

<p>golang singleflight
è¯¥åº“æä¾›äº†ä¸€ä¸ªç®€å•æœ‰æ•ˆçš„æ–¹æ¡ˆåº”å¯¹ä¸Šé¢æåˆ°çš„é—®é¢˜ï¼Œåˆæ¬¡è§è¯†åˆ° singleflight æ˜¯åœ¨ golang/groupcache ä¸­ã€‚</p>

<p>groupcache ç¼“å­˜æ›´æ–°èƒ½å¤Ÿåšåˆ°å¯¹åŒä¸€ä¸ªå¤±æ•ˆkeyçš„å¤šä¸ªè¯·æ±‚ï¼Œåªæœ‰ä¸€ä¸ªè¯·æ±‚æ‰§è¡Œå¯¹keyçš„æ›´æ–°æ“ä½œï¼Œå…¶æ–‡æ¡£ç›¸å…³æè¿°å¦‚ä¸‹ï¼š</p>

<p>comes with a cache filling mechanism. Whereas memcached just says â€œSorry, cache missâ€, often resulting in a thundering herd of database (or whatever) loads from an unbounded number of clients (which has resulted in several fun outages), groupcache coordinates cache fills such that only one load in one process of an entire replicated set of processes populates the cache, then multiplexes the loaded value to all callers.</p>

<p>ä» singleflight çš„ test å¯ä»¥äº†è§£åˆ°å…¶ç”¨æ³•ï¼š</p>

<p>func TestDoDupSuppress(t *testing.T) {
	var g Group
	c := make(chan string)
	var calls int32
	fn := func() (interface{}, error) {
		atomic.AddInt32(&amp;calls, 1)
		return &lt;-c, nil
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const n = 10
var wg sync.WaitGroup
for i := 0; i &lt; n; i++ {
	wg.Add(1)
	go func() { // nä¸ªåç¨‹åŒæ—¶è°ƒç”¨äº†g.Doï¼Œfnä¸­çš„é€»è¾‘åªä¼šè¢«ä¸€ä¸ªåç¨‹æ‰§è¡Œ
		v, err := g.Do("key", fn)
		if err != nil {
			t.Errorf("Do error: %v", err)
		}
		if v.(string) != "bar" {
			t.Errorf("got %q; want %q", v, "bar")
		}
		wg.Done()
	}()
}
time.Sleep(100 * time.Millisecond) // let goroutines above block
c &lt;- "bar"
wg.Wait()
if got := atomic.LoadInt32(&amp;calls); got != 1 {
	t.Errorf("number of calls = %d; want 1", got)
} } è¯¥æµ‹è¯•ç”¨ä¾‹ä¸­ï¼Œåªæœ‰1ä¸ªåç¨‹æ‰§è¡Œäº†fnï¼Œå…¶ä»–9ä¸ªåç¨‹èƒ½æ‹¿åˆ°fnæ‰§è¡Œåçš„è¿”å›ç»“æœã€‚å³fnåªæ‰§è¡Œäº†1æ¬¡ï¼Œä½†å…¶ç»“æœä¼šè¿”å›ç»™å¤šä¸ªåç¨‹ã€‚
</code></pre></div></div>

<p>çœ‹ä¸‹ singleflight æ˜¯å¦‚ä½•åšåˆ°è¿™ä¸€ç‚¹çš„ï¼š</p>

<p>// call is an in-flight or completed Do call
type call struct {
	wg  sync.WaitGroup
	val interface{}
	err error
}
call ç”¨æ¥è¡¨ç¤ºä¸€ä¸ªæ­£åœ¨æ‰§è¡Œæˆ–å·²å®Œæˆçš„å‡½æ•°è°ƒç”¨ã€‚</p>

<p>// Group represents a class of work and forms a namespace in which
// units of work can be executed with duplicate suppression.
type Group struct {
	mu sync.Mutex       // protects m
	m  map[string]*call // lazily initialized
}
Group å¯ä»¥çœ‹åšæ˜¯ä»»åŠ¡çš„åˆ†ç±»ã€‚</p>

<p>// Do executes and returns the results of the given function, making
// sure that only one execution is in-flight for a given key at a
// time. If a duplicate comes in, the duplicate caller waits for the
// original to complete and receives the same results.
func (g <em>Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) {
	g.mu.Lock()
	if g.m == nil {
		g.m = make(map[string]</em>call)
	}
	if c, ok := g.m[key]; ok {
		g.mu.Unlock()
		c.wg.Wait()
		return c.val, c.err
	}
	c := new(call)
	c.wg.Add(1)
	g.m[key] = c
	g.mu.Unlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c.val, c.err = fn()
c.wg.Done()

g.mu.Lock()
delete(g.m, key)
g.mu.Unlock()

return c.val, c.err } åœ¨ Do å‡½æ•°çš„æºç ä¸­ï¼Œg.m çš„è¯»å†™è¢« g.mu äº’æ–¥é”ä¿æŠ¤ï¼Œfn çš„è¿”å›ç»“æœå­˜å‚¨åœ¨ call.valã€call.err ä¸­ï¼Œé€šè¿‡ sync.WaitGroup å®ç°ç­‰å¾… fn æ‰§è¡Œç»“æŸã€‚
</code></pre></div></div>

<p>å›åˆ°æœ¬æ–‡å¼€å¤´æåˆ°çš„é—®é¢˜ï¼Œå¯¹äºç¼“å­˜çš„æ›´æ–°ï¼Œå¯ä»¥è¿™æ ·å®ç°ï¼š</p>

<p>if (cacheMiss) {
    fn = func() (interface{}, error) {
        // ç¼“å­˜æ›´æ–°é€»è¾‘
    }
    data, err = g.Do(cacheKey, fn)
}
å¯¹äºé˜²æ­¢æš´å¢çš„æ¥å£è¯·æ±‚å¯¹ä¸‹æ¸¸æœåŠ¡é€ æˆç¬æ—¶é«˜è´Ÿè½½ï¼Œå¯ä»¥è¿™æ ·å®ç°ï¼š</p>

<p>fn = func() (interface{}, error) {
    // å‘é€è¯·æ±‚åˆ°å…¶ä»–æœåŠ¡æ¥å£
}
data, err = g.Do(apiNameWithParams, fn)</p>

<p>ç¼“å­˜å‡»ç©¿
â€‚â€‚â€‚â€‚ç»™ç¼“å­˜åŠ ä¸€ä¸ªè¿‡æœŸæ—¶é—´ï¼Œä¸‹æ¬¡æœªå‘½ä¸­ç¼“å­˜æ—¶å†å»ä»æ•°æ®æºè·å–ç»“æœå†™å…¥æ–°çš„ç¼“å­˜ï¼Œè¿™ä¸ªæ˜¯åç«¯å¼€å‘äººå‘˜å†ç†Ÿæ‚‰ä¸è¿‡çš„åŸºæ“ã€‚æœ¬äººä¹‹å‰åœ¨åšç›´æ’­å¹³å°æ´»åŠ¨ä¸šåŠ¡çš„æ—¶å€™ï¼Œå½“æ—¶å¸¦ç€è¿™ä»½å†ç†Ÿç»ƒä¸è¿‡çš„è‡ªä¿¡ï¼ŒæŠŠå¤æ‚çš„æ•°æ®åº“é“¾è¡¨è¯­å¥å†™å¥½ï¼Œå„ç§å¾®æœåŠ¡ä¹‹é—´è°ƒç”¨ææ•°æ®æœ€åç®—å¥½çš„ç»“æœï¼Œä¸¢è¿›äº†ç¼“å­˜ç„¶åè®¾äº†ä¸€ä¸ªè¿‡æœŸæ—¶é—´ï¼Œå½“æ—¶å™¼é‡Œå•ªå•¦ä¸¤ä¸‹å†™å®Œä»£ç è§‰å¾—ç¨³å¦‚é“è›‹ï¼Œç»“æœåœ¨æ´»åŠ¨å¿«ç»“æŸä¹‹å‰ï¼Œæ•°æ®åº“å¾ˆå‹å¥½çš„æŒ‚æ‰äº†ã€‚å½“æ—¶å›å»æŸ¥çœ‹ç›‘æ§åå‘ç°ï¼Œæ˜¯åœ¨æ´»åŠ¨å¿«ç»“æŸå‰ï¼Œå¤§é‡ç”¨æˆ·éƒ½åœ¨ç–¯ç‹‚çš„åˆ·æ´»åŠ¨é¡µï¼Œå¯¼è‡´ç¼“å­˜è¿‡æœŸçš„ç¬é—´æœ‰å¤§é‡æœªå‘½ä¸­ç¼“å­˜çš„è¯·æ±‚ç›´æ¥æ‰“åˆ°æ•°æ®åº“ä¸Šæ‰€å¯¼è‡´çš„ï¼Œæ‰€ä»¥è¿™ä¸ªç»å…¸çš„é—®é¢˜ç¨ä¸æ³¨æ„è¿˜æ˜¯å®³æ­»äºº</p>

<p>â€‚â€‚â€‚â€‚é˜²ç¼“å­˜å‡»ç©¿çš„æ–¹å¼æœ‰å¾ˆå¤šç§ï¼Œæ¯”å¦‚é€šè¿‡è®¡åˆ’ä»»åŠ¡æ¥è·Ÿæ–°ç¼“å­˜ä½¿å¾—ä»å‰ç«¯è¿‡æ¥çš„æ‰€æœ‰è¯·æ±‚éƒ½æ˜¯ä»ç¼“å­˜è¯»å–ç­‰ç­‰ã€‚ä¹‹å‰è¯»è¿‡ groupCacheçš„æºç ï¼Œå‘ç°é‡Œé¢æœ‰ä¸€ä¸ªå¾ˆæœ‰æ„æ€çš„åº“ï¼Œå«singleFlight, å› ä¸ºgroupCacheä»èŠ‚ç‚¹ä¸Šè·å–ç¼“å­˜å¦‚æœæœªå‘½ä¸­ï¼Œåˆ™ä¼šå»å…¶ä»–èŠ‚ç‚¹å¯»æ‰¾ï¼Œå…¶ä»–èŠ‚ç‚¹è¿˜æ²¡æœ‰çš„è¯å†ä»æ•°æ®æºè·å–ï¼Œæ‰€ä»¥è¿™ä¸ªæ­¥éª¤å¯¹äºé˜²å‡»ç©¿éå¸¸æœ‰å¿…è¦ã€‚singleFlightä½¿å¾—groupCacheåœ¨å¤šä¸ªå¹¶å‘è¯·æ±‚å¯¹ä¸€ä¸ªå¤±æ•ˆçš„keyè¿›è¡Œæºæ•°æ®è·å–æ—¶ï¼Œåªè®©å…¶ä¸­ä¸€ä¸ªå¾—åˆ°æ‰§è¡Œï¼Œå…¶ä½™é˜»å¡ç­‰å¾…åˆ°æ‰§è¡Œçš„é‚£ä¸ªè¯·æ±‚å®Œæˆåï¼Œå°†ç»“æœä¼ é€’ç»™é˜»å¡çš„å…¶ä»–è¯·æ±‚è¾¾åˆ°é˜²æ­¢å‡»ç©¿çš„æ•ˆæœã€‚
â€‚â€‚â€‚â€‚
â€‚â€‚â€‚â€‚https://mp.weixin.qq.com/s/lSBIPbMXcjoWgrqMVoDanA
<!-- more -->
å¦‚æœä½ æ›¾ç»ä½¿ç”¨è¿‡ Go ä¸€æ®µæ—¶é—´ï¼Œé‚£ä¹ˆä½ å¯èƒ½äº†è§£ä¸€äº› Go ä¸­çš„å¹¶å‘åŸè¯­ï¼š</p>

<p>go å…³é”®å­—ç”¨æ¥ç”Ÿæˆ goroutines ï¼›channel ç”¨äº goroutines ä¹‹é—´é€šä¿¡ ï¼›context ç”¨äºä¼ æ’­å–æ¶ˆ ï¼›sync å’Œ sync/atomic åŒ…ç”¨äºä½çº§åˆ«çš„åŸè¯­ï¼Œä¾‹å¦‚äº’æ–¥é”å’Œå†…å­˜çš„åŸå­æ“ä½œ ã€‚è¿™äº›è¯­è¨€ç‰¹æ€§å’ŒåŒ…ç»„åˆåœ¨ä¸€èµ·ï¼Œä¸ºæ„å»ºé«˜å¹¶å‘çš„åº”ç”¨ç¨‹åºæä¾›äº†ä¸°å¯Œçš„å·¥å…·é›†ã€‚ä½ å¯èƒ½è¿˜æ²¡æœ‰å‘ç°åœ¨æ‰©å±•åº“ golang.org/x/sync ä¸­ï¼Œæä¾›äº†ä¸€ç³»åˆ—æ›´é«˜çº§åˆ«çš„å¹¶å‘åŸè¯­ã€‚æˆ‘ä»¬å°†åœ¨æœ¬æ–‡ä¸­æ¥è°ˆè°ˆè¿™äº›å†…å®¹ã€‚</p>

<p>SingleflightåŒ…
æ­£å¦‚æ–‡æ¡£ä¸­æ‰€æè¿°ï¼Œè¿™ä¸ªåŒ…æä¾›äº†ä¸€ä¸ªé‡å¤å‡½æ•°è°ƒç”¨æŠ‘åˆ¶çš„æœºåˆ¶ã€‚</p>

<p>å¦‚æœä½ æ­£åœ¨å¤„ç†è®¡ç®—é‡å¤§ï¼ˆä¹Ÿå¯èƒ½ä»…ä»…æ˜¯æ…¢ï¼Œæ¯”å¦‚ç½‘ç»œè®¿é—®ï¼‰çš„ç”¨æˆ·è¯·æ±‚æ—¶ï¼Œè¿™ä¸ªåŒ…å°±å¾ˆæœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œä½ çš„æ•°æ®åº“ä¸­åŒ…å«æ¯ä¸ªåŸå¸‚çš„å¤©æ°”ä¿¡æ¯ï¼Œå¹¶ä¸”ä½ æƒ³å°†è¿™äº›æ•°æ®ä»¥ API çš„å½¢å¼æä¾›æœåŠ¡ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œå¯èƒ½åŒæ—¶æœ‰å¤šä¸ªç”¨æˆ·æƒ³æŸ¥è¯¢åŒä¸€åŸå¸‚çš„å¤©æ°”ã€‚</p>

<p>åœ¨è¿™ç§åœºæ™¯ä¸‹ï¼Œå¦‚æœä½ åªæŸ¥è¯¢ä¸€æ¬¡æ•°æ®åº“ç„¶åå°†ç»“æœå…±äº«ç»™æ‰€æœ‰ç­‰å¾…çš„è¯·æ±‚ï¼Œè¿™æ ·ä¸æ˜¯æ›´å¥½å—ï¼Ÿè¿™å°±æ˜¯ singleflight æä¾›çš„åŠŸèƒ½ã€‚</p>

<p>åœ¨ä½¿ç”¨çš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦è¦åˆ›å»ºä¸€ä¸ª singleflight.Groupã€‚å®ƒéœ€è¦åœ¨æ‰€æœ‰è¯·æ±‚ä¸­å…±äº«æ‰èƒ½å·¥ä½œã€‚ç„¶åå°†ç¼“æ…¢æˆ–è€…å¼€é”€å¤§çš„æ“ä½œåŒ…è£…åˆ° group.Do(key, fn) çš„è°ƒç”¨ä¸­ã€‚å¯¹åŒä¸€ä¸ª key çš„å¤šä¸ªå¹¶å‘è¯·æ±‚å°†ä»…è°ƒç”¨ fn ä¸€æ¬¡ï¼Œå¹¶ä¸”å°† fn çš„ç»“æœè¿”å›ç»™æ‰€æœ‰è°ƒç”¨è€…ã€‚</p>

<p>å®é™…ä¸­çš„ä½¿ç”¨å¦‚ä¸‹:</p>

<p>package weather
type Info struct {
    TempC, TempF int // temperature in Celsius and Farenheit
    Conditions string // â€œsunnyâ€, â€œsnowingâ€, etc
}</p>

<p>var group singleflight.Group</p>

<p>func City(city string) (<em>Info, error) {
    results, err, _ := group.Do(city, func() (interface{}, error) {
        info, err := fetchWeatherFromDB(city) // æ…¢æ“ä½œ
        return info, err
    })
    if err != nil {
        return nil, fmt.Errorf(â€œweather.City %s: %wâ€, city, err)
    }
    return results.(</em>Info), nil
}
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬ä¼ é€’ç»™ group.Do çš„é—­åŒ…å¿…é¡»è¿”å› (interface{}, error) æ‰èƒ½å’Œ Go ç±»å‹ç³»ç»Ÿä¸€èµ·ä½¿ç”¨ã€‚ä¸Šé¢çš„ä¾‹å­ä¸­å¿½ç•¥äº† group.Do çš„ç¬¬ä¸‰ä¸ªè¿”å›å€¼ï¼Œè¯¥å€¼æ˜¯ç”¨æ¥è¡¨ç¤ºç»“æœæ˜¯å¦åœ¨å¤šä¸ªè°ƒç”¨æ–¹ä¹‹é—´å…±äº«ã€‚</p>

<p>å¦‚æœéœ€è¦æŸ¥çœ‹æ›´å¤šå®Œæ•´çš„ä¾‹å­ï¼Œå¯ä»¥æŸ¥çœ‹ Encore Playground ä¸­çš„ä»£ç ã€‚</p>

<p>errgroup åŒ…
å¦ä¸€ä¸ªæœ‰ç”¨çš„åŒ…æ˜¯ errgroup packageã€‚å®ƒå’Œ sync.WaitGroup æ¯”è¾ƒç›¸ä¼¼ï¼Œä½†æ˜¯ä¼šå°†ä»»åŠ¡è¿”å›çš„é”™è¯¯å›ä¼ ç»™é˜»å¡çš„è°ƒç”¨æ–¹ã€‚</p>

<p>å½“ä½ æœ‰å¤šä¸ªç­‰å¾…çš„æ“ä½œï¼Œä½†åˆæƒ³çŸ¥é“å®ƒä»¬æ˜¯å¦éƒ½å·²ç»æˆåŠŸå®Œæˆæ—¶ï¼Œè¿™ä¸ªåŒ…å°±å¾ˆæœ‰ç”¨ã€‚è¿˜æ˜¯ä»¥ä¸Šé¢çš„å¤©æ°”ä¸ºä¾‹ï¼Œå‡å¦‚ä½ è¦ä¸€æ¬¡æŸ¥è¯¢å¤šä¸ªåŸå¸‚çš„å¤©æ°”ï¼Œå¹¶ä¸”è¦ç¡®ä¿å…¶ä¸­æ‰€æœ‰çš„æŸ¥è¯¢éƒ½æˆåŠŸè¿”å›ã€‚</p>

<p>é¦–å…ˆå®šä¹‰ä¸€ä¸ª errgroup.Groupï¼Œç„¶åä¸ºæ¯ä¸ªåŸå¸‚éƒ½ä½¿ç”¨ group.Go(fn func() error) æ–¹æ³•ã€‚è¯¥æ–¹æ³•ä¼šç”Ÿæˆä¸€ä¸ª goroutine æ¥æ‰§è¡Œè¿™ä¸ªä»»åŠ¡ã€‚å½“ç”Ÿæˆä½ æƒ³æ‰§è¡Œçš„æ‰€æœ‰ä»»åŠ¡æ—¶ï¼Œä½¿ç”¨ group.Wait() ç­‰å¾…å®ƒä»¬å®Œæˆã€‚éœ€è¦æ³¨æ„å’Œ sync.WaitGroup æœ‰ä¸€ç‚¹ä¸åŒçš„æ˜¯ï¼Œè¯¥æ–¹æ³•ä¼šè¿”å›é”™è¯¯ã€‚å½“ä¸”ä»…å½“æ‰€æœ‰ä»»åŠ¡éƒ½è¿”å› nil æ—¶ï¼Œæ‰ä¼šè¿”å›ä¸€ä¸ª nil é”™è¯¯ã€‚</p>

<p>å®é™…ä¸­çš„ä½¿ç”¨å¦‚ä¸‹:</p>

<p>func Cities(cities â€¦string) ([]<em>Info, error) {
    var g errgroup.Group
    var mu sync.Mutex
    res := make([]</em>Info, len(cities)) // res[i] corresponds to cities[i]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i, city := range cities {
    i, city := i, city // ä¸ºä¸‹é¢çš„é—­åŒ…åˆ›å»ºå±€éƒ¨å˜é‡
    g.Go(func() error {
        info, err := City(city)
        mu.Lock()
        res[i] = info
        mu.Unlock()
        return err
    })
}
if err := g.Wait(); err != nil {
    return nil, err
}
return res, nil } è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ª res åˆ‡ç‰‡æ¥å­˜å‚¨æ¯ä¸ª goroutine æ‰§è¡Œçš„ç»“æœã€‚å°½ç®¡ä¸Šé¢çš„ä»£ç æ²¡æœ‰ä½¿ç”¨ mu äº’æ–¥é”ä¹Ÿæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä½†æ˜¯æ¯ä¸ª goroutine éƒ½æ˜¯åœ¨åˆ‡ç‰‡ä¸­è‡ªå·±çš„ä½ç½®å†™å…¥ç»“æœï¼Œå› æ­¤æˆ‘ä»¬ä¸å¾—ä¸ä½¿ç”¨ä¸€ä¸ªåˆ‡ç‰‡ï¼Œä»¥é˜²ä»£ç å˜åŒ–ã€‚
</code></pre></div></div>

<p>é™åˆ¶å¹¶å‘
ä¸Šé¢çš„ä»£ç å°†åŒæ—¶æŸ¥æ‰¾ç»™å®šåŸå¸‚çš„å¤©æ°”ä¿¡æ¯ã€‚å¦‚æœåŸå¸‚æ•°é‡æ¯”è¾ƒå°‘ï¼Œé‚£è¿˜ä¸é”™ï¼Œä½†æ˜¯å¦‚æœåŸå¸‚æ•°é‡å¾ˆå¤šï¼Œå¯èƒ½ä¼šå¯¼è‡´æ€§èƒ½é—®é¢˜ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå°±åº”è¯¥å¼•å…¥é™åˆ¶å¹¶å‘äº†ã€‚</p>

<p>åœ¨ Go ä¸­ä½¿ç”¨ semaphores ä¿¡å·é‡è®©å®ç°é™åˆ¶å¹¶å‘å˜å¾—éå¸¸ç®€å•ã€‚ä¿¡å·é‡æ˜¯ä½ å­¦ä¹ è®¡ç®—æœºç§‘å­¦ä¸­å¯èƒ½å·²ç»é‡åˆ°è¿‡çš„å¹¶å‘åŸè¯­ï¼Œå¦‚æœæ²¡æœ‰é‡åˆ°ä¹Ÿä¸ç”¨æ‹…å¿ƒã€‚ä½ å¯ä»¥å‡ºäºå¤šç§ç›®çš„æ¥ä½¿ç”¨ä¿¡å·é‡ï¼Œä½†æ˜¯è¿™é‡Œæˆ‘ä»¬åªä½¿ç”¨å®ƒæ¥è¿½è¸ªè¿è¡Œä¸­çš„ä»»åŠ¡çš„æ•°é‡ï¼Œå¹¶é˜»å¡ç›´åˆ°æœ‰ç©ºé—´å¯ä»¥æ‰§è¡Œå…¶ä»–ä»»åŠ¡ã€‚</p>

<p>åœ¨ Go ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ channel æ¥å®ç°ä¿¡å·é‡çš„åŠŸèƒ½ã€‚å¦‚æœæˆ‘ä»¬ä¸€æ¬¡éœ€è¦æœ€å¤šæ‰§è¡Œ 10 ä¸ªä»»åŠ¡ï¼Œåˆ™éœ€è¦åˆ›å»ºä¸€ä¸ªå®¹é‡ä¸º 10 çš„ channelï¼šsemaphore := make(chan struct{}, 10)ã€‚ä½ å¯ä»¥æƒ³è±¡å®ƒä¸ºä¸€ä¸ªå¯ä»¥å®¹çº³ 10 ä¸ªçƒçš„ç®¡é“ã€‚</p>

<p>å¦‚æœæƒ³æ‰§è¡Œä¸€ä¸ªæ–°çš„ä»»åŠ¡ï¼Œæˆ‘ä»¬åªéœ€è¦ç»™ channel å‘é€ä¸€ä¸ªå€¼ï¼šsemaphore &lt;- struct{}{}ï¼Œå¦‚æœå·²ç»æœ‰å¾ˆå¤šä»»åŠ¡åœ¨è¿è¡Œçš„è¯ï¼Œå°†ä¼šé˜»å¡ã€‚è¿™ç±»ä¼¼äºå°†ä¸€ä¸ªçƒæ¨å…¥ç®¡é“ï¼Œå¦‚æœç®¡é“å·²æ»¡ï¼Œåˆ™éœ€è¦ç­‰å¾…ç›´åˆ°æœ‰ç©ºé—´ä¸ºæ­¢ã€‚</p>

<p>å½“é€šè¿‡ &lt;-semaphore èƒ½ä»è¯¥ channel ä¸­å–å‡ºä¸€ä¸ªå€¼æ—¶ï¼Œè¿™è¡¨ç¤ºä¸€ä¸ªä»»åŠ¡å®Œæˆäº†ã€‚è¿™ç±»ä¼¼äºåœ¨ç®¡é“å¦ä¸€ç«¯æ‹¿å‡ºä¸€ä¸ªçƒï¼Œè¿™å°†ä¸ºå¡å…¥ä¸‹ä¸€ä¸ªçƒæä¾›äº†ç©ºé—´ã€‚</p>

<p>å¦‚æè¿°ä¸€æ ·ï¼Œæˆ‘ä»¬ä¿®æ”¹åçš„ Cities ä»£ç å¦‚ä¸‹ï¼š</p>

<p>func Cities(cities â€¦string) ([]<em>Info, error) {
    var g errgroup.Group
    var mu sync.Mutex
    res := make([]</em>Info, len(cities)) // res[i] corresponds to cities[i]
    sem := make(chan struct{}, 10)
    for i, city := range cities {
        i, city := i, city // create locals for closure below
        sem &lt;- struct{}{}
        g.Go(func() error {
            info, err := City(city)
            mu.Lock()
            res[i] = info
            mu.Unlock()
            &lt;-sem
            return err
        })
    }
    if err := g.Wait(); err != nil {
        return nil, err
    }
    return res, nil
}
åŠ æƒé™åˆ¶å¹¶å‘
æœ€åï¼Œå½“ä½ æƒ³è¦é™åˆ¶å¹¶å‘çš„æ—¶å€™ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰ä»»åŠ¡ä¼˜å…ˆçº§éƒ½ä¸€æ ·ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æ¶ˆè€—çš„èµ„æºå°†ä¾æ®é«˜ã€ä½ä¼˜å…ˆçº§ä»»åŠ¡çš„åˆ†å¸ƒä»¥åŠå®ƒä»¬å¦‚ä½•å¼€å§‹è¿è¡Œè€Œå‘ç”Ÿå˜åŒ–ã€‚</p>

<p>åœ¨è¿™ç§åœºæ™¯ä¸‹ä½¿ç”¨åŠ æƒé™åˆ¶å¹¶å‘æ˜¯ä¸€ç§ä¸é”™çš„è§£å†³æ–¹å¼ã€‚å®ƒçš„å·¥ä½œåŸç†å¾ˆç®€å•ï¼šæˆ‘ä»¬ä¸éœ€è¦ä¸ºåŒæ—¶è¿è¡Œçš„ä»»åŠ¡æ•°é‡åšé¢„ä¼°ï¼Œè€Œæ˜¯ä¸ºæ¯ä¸ªä»»åŠ¡æä¾›ä¸€ä¸ª â€œcostâ€ï¼Œå¹¶ä»ä¿¡å·é‡ä¸­è·å–å’Œé‡Šæ”¾å®ƒã€‚</p>

<p>æˆ‘ä»¬ä¸å†ä½¿ç”¨ channel æ¥åšè¿™ä»¶äº‹ï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦ç«‹å³è·å–å¹¶é‡Šæ”¾ â€œcostâ€ã€‚å¹¸è¿çš„æ˜¯ï¼Œâ€æ‰©å±•åº“â€ golang.org/x/sync/sempahore å®ç°äº†åŠ æƒä¿¡å·é‡ã€‚</p>

<p>sem &lt;- struct{}{} æ“ä½œå« â€œè·å–â€ï¼Œ&lt;-sem æ“ä½œå« â€œé‡Šæ”¾â€ã€‚ä½ å¯èƒ½ä¼šæ³¨æ„åˆ° semaphore.Acquire æ–¹æ³•ä¼šè¿”å›é”™è¯¯ï¼Œé‚£æ˜¯å› ä¸ºå®ƒå¯ä»¥å’Œ context åŒ…ä¸€èµ·ä½¿ç”¨æ¥æ§åˆ¶æå‰ç»“æŸã€‚åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘ä»¬å°†å¿½ç•¥å®ƒã€‚</p>

<p>å®é™…ä¸Šï¼Œå¤©æ°”æŸ¥è¯¢çš„ä¾‹å­æ¯”è¾ƒç®€å•ï¼Œä¸é€‚ç”¨åŠ æƒä¿¡å·é‡ï¼Œä½†æ˜¯ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å‡è®¾ cost å˜é‡éšåŸå¸‚åç§°é•¿åº¦è€Œå˜åŒ–ã€‚ç„¶åï¼Œæˆ‘ä»¬ä¿®æ”¹å¦‚ä¸‹ï¼š</p>

<p>func Cities(cities â€¦string) ([]<em>Info, error) {
    ctx := context.TODO() // éœ€è¦çš„æ—¶å€™ï¼Œå¯ä»¥ç”¨ context æ›¿æ¢ 
    var g errgroup.Group
    var mu sync.Mutex
    res := make([]</em>Info, len(cities)) // res[i] å¯¹åº” cities[i]
    sem := semaphore.NewWeighted(100) // å¹¶å‘å¤„ç† 100 ä¸ªå­—ç¬¦
    for i, city := range cities {
        i, city := i, city // ä¸ºé—­åŒ…åˆ›å»ºå±€éƒ¨å˜é‡
        cost := int64(len(city))
        if err := sem.Acquire(ctx, cost); err != nil {
            break
        }
        g.Go(func() error {
            info, err := City(city)
            mu.Lock()
            res[i] = info
            mu.Unlock()
            sem.Release(cost)
            return err
        })
    }
    if err := g.Wait(); err != nil {
        return nil, err
    } else if err := ctx.Err(); err != nil {
        return nil, err
    }
    return res, nil
}
socketFuncåˆ›å»ºäº† socketï¼Œé€šçŸ¥å°† socket è®¾ç½®éé˜»å¡ï¼ˆSOCK_NONBLOCKï¼‰ä»¥åŠ fork æ—¶å…³é—­ï¼ˆSOCK_CLOEXECï¼‰ï¼Œè¿™ä¸¤ä¸ªæ ‡å¿—æ˜¯åœ¨ linux å†…æ ¸ç‰ˆæœ¬ 2.6.27 ä¹‹åæ·»åŠ ï¼Œåœ¨æ­¤ä¹‹å‰çš„ç‰ˆæœ¬ä»£ç å°†ä¼šèµ°åˆ°syscall.ForkLock.RLock()ï¼Œä¸»è¦æ˜¯ä¸ºäº†é˜²æ­¢åœ¨ fork æ—¶å¯¼è‡´æ–‡ä»¶æè¿°ç¬¦æ³„éœ²ã€‚</p>

<p>å½“ socket åˆ›å»ºä¹‹åè¿›å…¥æ–°å»º fd æµç¨‹ï¼Œåœ¨ Go çš„åŒ…è£…å±‚é¢ï¼Œfd å‡ä»¥netFDç»“æ„è¡¨ç¤ºï¼Œè¯¥æ¥å£æè¿°åŸå§‹ socket çš„åœ°å€ä¿¡æ¯ã€åè®®ç±»å‹ã€åè®®æ—ä»¥åŠ optionï¼ŒnetFDåœ¨æ•´ä¸ªåŒ…è£…ç»“æ„ä¸­å±…äºç”¨æˆ·æ¥å£çš„ä¸‹ä¸€å±‚ã€‚æœ€åè¿›å…¥ç›‘å¬é€»è¾‘ï¼Œé€»è¾‘èµ°å‘åŒºåˆ† TCP å’Œ UDPï¼Œè€Œç›‘å¬é€»è¾‘æ¯”è¾ƒç®€å•ï¼Œå³è°ƒç”¨ç³»ç»Ÿ bind å’Œ listen æ¥å£ (net/sock_posix.go)ï¼š</p>

<p>func (fd *netFD) listenStream(laddr sockaddr, backlog int, ctrlFn func(string, string, syscall.RawConn) error) error {
    // â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ctrlFn != nil {
    c, err := newRawConn(fd)
    if err != nil {
        return err
    }
    if err := ctrlFn(fd.ctrlNetwork(), laddr.String(), c); err != nil {
        return err
    }
}
if err = syscall.Bind(fd.pfd.Sysfd, lsa); err != nil {
    return os.NewSyscallError("bind", err)
}
if err = listenFunc(fd.pfd.Sysfd, backlog); err != nil {
    return os.NewSyscallError("listen", err)
}
if err = fd.init(); err != nil {
    return err
}
lsa, _ = syscall.Getsockname(fd.pfd.Sysfd)
fd.setAddr(fd.addrFunc()(lsa), nil)
return nil } ç»“è®º ä¸Šé¢çš„ä¾‹å­å±•ç¤ºäº†åœ¨ Go ä¸­é€šè¿‡å¾®è°ƒæ¥å®ç°éœ€è¦çš„å¹¶å‘æ¨¡å¼æ˜¯å¤šä¹ˆç®€å•ã€‚
</code></pre></div></div>
:ET