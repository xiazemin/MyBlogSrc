I"Ô]<p>https://github.com/emicklei/go-restful-swagger12
https://github.com/emicklei/go-restful-openapi
https://github.com/emicklei/go-restful
https://github.com/ant0ine/go-json-rest/
go-restfulåº“ï¼šhttps://github.com/emicklei/go-restful</p>

<p>go-restfulé¡¹ç›®æ˜¯ä¸€ä¸ªå¼€æºçš„ã€åŸºäºGolangå¼€å‘çš„ã€ç”¨äºæ„å»ºRESTé£æ ¼çš„WebæœåŠ¡çš„åº“ã€‚</p>

<p>REST
RESTè¦æ±‚å¼€å‘è€…æ˜¾å¼åœ°ä½¿ç”¨HTTPæ–¹æ³•ï¼Œå¹¶ä¸HTTPåè®®çš„å®šä¹‰ä¿æŒä¸€è‡´ã€‚RESTçš„åŸºæœ¬è®¾è®¡åŸåˆ™æ˜¯å†åˆ›å»ºã€è¯»å–ã€æ›´æ–°å’Œåˆ é™¤ï¼ˆCRUDï¼‰æ“ä½œå’ŒHTTPæ–¹æ³•ä¹‹é—´å»ºç«‹èµ·ä¸€å¯¹ä¸€çš„æ˜ å°„ã€‚æ ¹æ®è¯¥æ˜ å°„ï¼š</p>

<p>GET = æ£€ç´¢èµ„æºçš„è¡¨ç¤º
POST = åˆ›å»ºï¼Œä½¿ç”¨æŸç§æœåŠ¡å™¨ç«¯çš„ç®—æ³•å°†å†…å®¹å‘é€åˆ°æœåŠ¡å™¨ä»¥åˆ›å»ºæŒ‡å®šèµ„æºæˆ–èµ„æºçš„é›†åˆ
PUT = åˆ›å»ºï¼Œå¦‚æœå‘é€æŒ‡å®šURIçš„å®Œæ•´å†…å®¹
PUT = æ›´æ–°ï¼Œå¦‚æœè¦æ›´æ–°æŒ‡å®šURIçš„å®Œæ•´å†…å®¹
DELETE = åˆ é™¤ï¼Œå¦‚æœè¦è¯·æ±‚æœåŠ¡å™¨åˆ é™¤æŒ‡å®šçš„èµ„æº
PATCH = æ›´æ–°ï¼Œæ›´æ–°æŸä¸ªèµ„æºçš„éƒ¨åˆ†å†…å®¹
OPTIONS = è·å–è¯·æ±‚URIç›¸å…³çš„é€šä¿¡é€‰é¡¹çš„ä¿¡æ¯
<!-- more -->
go-restfulåº“çš„ç‰¹å¾
è·¯ç”±è¯·æ±‚ï¼šæ”¯æŒå‡½æ•°æ˜ å°„åˆ°è·¯å¾„å‚æ•°ï¼ˆä¾‹å¦‚{id}ï¼‰
è·¯ç”±å¯é…ç½®
ï¼ˆé»˜è®¤ï¼‰å¿«é€Ÿè·¯ç”±ç®—æ³•ï¼Œå…è®¸URLè·¯å¾„ä¸Šå‡ºç°é™æ€å…ƒç´ ã€æ­£åˆ™è¡¨è¾¾å¼ã€åŠ¨æ€å‚æ•°ã€‚æ¯”å¦‚ /meetings/{id} æˆ–è€… /static/{subpath:*}
JSR311è§„èŒƒå®ç°çš„è·¯ç”±ç®—æ³•
æä¾›äº†Request APIç”¨äºä»JSON/XMLè¯»å–ç»“æ„å’Œè®¿é—®å„ç§å‚æ•°ï¼ˆè·¯å¾„å‚æ•°ã€æŸ¥è¯¢å‚æ•°ã€å¤´éƒ¨å‚æ•°ï¼‰
æä¾›äº†Response APIç”¨äºå°†ç»“æ„ï¼ˆstructï¼‰å†™å…¥åˆ°JSON/XMLä»¥åŠè®¾ç½®å¤´éƒ¨
æ”¯æŒä½¿ç”¨EntityReaderWriteræ³¨å†Œçš„è‡ªå®šä¹‰ç¼–ç 
æ”¯æŒåœ¨æœåŠ¡çº§æˆ–è·¯ç”±çº§å¯¹è¯·æ±‚åˆ°å“åº”æµçš„è¿‡æ»¤å’Œæ‹¦æˆª
æ”¯æŒä½¿ç”¨å±æ€§æ¥å®šä¹‰è¯·æ±‚èŒƒå›´çš„å˜é‡
å®¹å™¨Containeræ”¯æŒä¸åŒHTTPç«¯ç‚¹ä¸Šçš„WebService
è¯·æ±‚å’Œå“åº”çš„æœ‰æ•ˆè´Ÿè½½ä¸Šçš„å†…å®¹ç¼–ç (gzip,deflate)
ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰è‡ªåŠ¨å“åº”OPTIONSè¯·æ±‚
ï¼ˆä½¿ç”¨è¿‡æ»¤å™¨ï¼‰è‡ªåŠ¨å¤„ç†CORSè¯·æ±‚
æ”¯æŒSwagger UIç¼–å†™çš„APIæ–‡æ¡£å£°æ˜ï¼ˆé˜…è¯»go-restful-openapiå’Œgo-restful-swagger12ï¼‰
é’ˆå¯¹HTTP 500çŠ¶æ€ç çš„ææ…Œæ¢å¤ï¼Œä½¿ç”¨RecoverHandler(â€¦)è‡ªå®šä¹‰å¤„ç†
è·¯ç”±é”™è¯¯äº§ç”ŸHTTP 404/405/406/415ç­‰é”™è¯¯ï¼Œä½¿ç”¨ServiceErrorHandler(â€¦)è‡ªå®šä¹‰å¤„ç†
å¯é…ç½®çš„æ—¥å¿—è·Ÿè¸ª
ä½¿ç”¨CompressorProvideræ³¨å†Œè‡ªå®šä¹‰gzip/deflateçš„è¯»å…¥å™¨å’Œè¾“å‡ºå™¨
äºŒã€è¯¦è§£
1ã€WebServices and Routes
WebServiceæ‹¥æœ‰ä¸€ä¸ªRouteå¯¹è±¡çš„é›†åˆï¼Œè¿™äº›Routeå¯¹è±¡è´Ÿè´£åˆ†å‘å³å°†åˆ°æ¥çš„HTTPè¯·æ±‚åˆ°ç›¸åº”çš„å‡½æ•°è°ƒç”¨ã€‚ä¸€èˆ¬æ¥è¯´ï¼ŒWebServiceæœ‰ä¸€ä¸ªrootæ ¹è·¯å¾„ï¼ˆä¾‹å¦‚ï¼š/usersï¼‰ï¼Œè¿˜ä¸ºè·¯ç”±å®šä¹‰äº†å¸¸è§çš„MIMEç±»å‹ã€‚WebServiceå¿…é¡»æ·»åŠ åˆ°æŸä¸ªå®¹å™¨ä»¥ä¾¿èƒ½ä»æœåŠ¡å™¨å¤„ç†HTTPè¯·æ±‚ã€‚</p>

<p>Routeæ˜¯æ ¹æ®HTTPåˆ†å‘ã€URLè·¯å¾„å’ŒMIMEç±»å‹æ‰€å®šä¹‰çš„ã€‚</p>

<p>æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…è·¯ç”±
è·¯ç”±å‚æ•°å¯ä»¥ä½¿ç”¨æ ¼å¼â€œuri/{var[:regexp]}â€æˆ–æŒ‡å®šç‰ˆæœ¬çš„â€œuri/{var:*}â€åŒ¹é…è·¯å¾„å°¾éƒ¨è¿›è¡ŒæŒ‡å®šã€‚ä¾‹å¦‚ï¼Œ/persons/{name:[A-Z][A-Z]} å¯ç”¨æ¥é™åˆ¶nameå‚æ•°çš„å€¼åªèƒ½åŒ…å«å¤§å†™å­—æ¯ã€‚æ­£åˆ™è¡¨è¾¾å¼å¿…é¡»ä½¿ç”¨regexpåŒ…ä¸­çš„æ ‡å‡†Goè¯­æ³•è¿›è¡Œæè¿°ã€‚https://code.google.com/p/re2/wiki/Syntaxï¼Œæ­¤åŠŸèƒ½éœ€è¦ä½¿ç”¨CurlyRouterã€‚</p>

<p>2ã€å®¹å™¨ï¼ˆContainerï¼‰
å®¹å™¨å¯ä»¥holdä½ä¸€å¥—WebServiceçš„é›†åˆã€è¿‡æ»¤å™¨ã€ä¸€ä¸ªç”¨äºhttpè¯·æ±‚å¤šè·¯å¤ç”¨çš„http.ServeMuxã€‚ä½¿ç”¨è¯­å¥â€œrestful.Add(â€¦)â€å’Œâ€œrestful.Filter(â€¦)â€ï¼Œå‰è€…å¯ä»¥åœ¨å®¹å™¨æ³¨å†Œä¸€ä¸ªWebServiceï¼Œåè€…å¯ä»¥è¿‡æ»¤ã€‚go-restfulé»˜è®¤çš„å®¹å™¨ä½¿ç”¨http.DefaultServeMuxã€‚ç”¨æˆ·å¯ä»¥åˆ›å»ºè‡ªå·±çš„å®¹å™¨ï¼Œä»¥åŠä¸ºæŒ‡å®šçš„å®¹å™¨åˆ›å»ºä¸€ä¸ªæ–°çš„http.Serverã€‚</p>

<p>container := restful.NewContainer()
server := &amp;http.Server{Addr: â€œ:8081â€, Handler: container}
1
2
3ã€è¿‡æ»¤å™¨ï¼ˆFilterï¼‰
è¿‡æ»¤å™¨å¯ä»¥åŠ¨æ€æ‹¦æˆªè¯·æ±‚å’Œå“åº”ï¼Œä»¥åŠè½¬æ¢æˆ–ä½¿ç”¨è¯·æ±‚å’Œå“åº”ä¸­åŒ…å«çš„ä¿¡æ¯ã€‚ç”¨æˆ·å¯ä»¥ä½¿ç”¨è¿‡æ»¤å™¨æ¥æ‰§è¡Œå¸¸è§„çš„æ—¥å¿—è®°å½•ã€æµ‹é‡ã€éªŒè¯ã€é‡å®šå‘ã€è®¾ç½®å“åº”å¤´éƒ¨Headerç­‰ã€‚restfulåŒ…ä¸­æœ‰ä¸‰ä¸ªé’ˆå¯¹è¯·æ±‚ã€å“åº”æµçš„é’©å­ï¼Œè¿˜å¯ä»¥æ·»åŠ è¿‡æ»¤å™¨ã€‚æ¯ä¸ªè¿‡æ»¤å™¨å¿…é¡»å®šä¹‰ä¸€ä¸ªFilterFunctionï¼š</p>

<p>func(req *restful.Request, resp *restful.Response, chain *restful.FilterChain)
1
ä½¿ç”¨å¦‚ä¸‹è¯­å¥ä¼ é€’è¯·æ±‚/å“åº”å¯¹åˆ°ä¸‹ä¸€ä¸ªè¿‡æ»¤å™¨æˆ–RouteFunctionï¼š</p>

<p>chain.ProcessFilter(req, resp)
1
4ã€å®¹å™¨è¿‡æ»¤å™¨ï¼ˆContainer Filterï¼‰
åœ¨æ³¨å†ŒWebServiceä¹‹å‰å¤„ç†ï¼š</p>

<p>// å®‰è£…ä¸€ä¸ªï¼ˆå…¨å±€çš„ï¼‰è¿‡æ»¤å™¨åˆ°é»˜è®¤çš„å®¹å™¨
restful.Filter(globalLogging)
1
2
5ã€WebServiceè¿‡æ»¤å™¨ï¼ˆWebService Filterï¼‰
åœ¨è·¯ç”±WebServiceä¹‹å‰å¤„ç†ï¼š</p>

<p>// å®‰è£…ä¸€ä¸ªWebServiceè¿‡æ»¤å™¨
ws.Filter(webserviceLogging).Filter(measureTime)
1
2
6ã€è·¯ç”±è¿‡æ»¤å™¨ï¼ˆRoute Filterï¼‰
åœ¨è°ƒç”¨è·¯ç”±Routeç›¸å…³çš„å‡½æ•°ä¹‹å‰å¤„ç†ï¼š</p>

<p>// å®‰è£…2ä¸ªé“¾å¼çš„è·¯ç”±è¿‡æ»¤å™¨
ws.Route(ws.GET(â€œ/{user-id}â€).Filter(routeLogging).Filter(NewCountFilter().routeCounter))
1
2
ä¾‹å­å¯è§ï¼šhttps://github.com/emicklei/go-restful/blob/master/examples/restful-filters.go</p>

<p>7ã€å“åº”ç¼–ç ï¼ˆResponse Encodingï¼‰
æ”¯æŒä¸¤ç§å“åº”ç¼–ç ï¼šgzipå’Œdeflateã€‚è¦ä¸ºæ‰€æœ‰çš„å“åº”å¯ç”¨å®ƒä»¬ï¼š</p>

<p>restful.DefaultContainer.EnableContentEncoding(true)
1
å¦‚æœæŸä¸ªHttpè¯·æ±‚åŒ…å«äº†Accept-Encodingå¤´éƒ¨ï¼Œé‚£ä¹ˆå“åº”å†…å®¹å¿…é¡»ä½¿ç”¨æŒ‡å®šçš„ç¼–ç è¿›è¡Œå‹ç¼©ã€‚æˆ–è€…ï¼Œå¯ä»¥åˆ›å»ºä¸€ä¸ªè¿‡æ»¤å™¨æ‰§è¡Œç¼–ç å¹¶å®‰è£…å®ƒåˆ°æ¯ä¸€ä¸ªWebServiceå’ŒRouteã€‚</p>

<p>è§ä¾‹å­ï¼šhttps://github.com/emicklei/go-restful/blob/master/examples/restful-encoding-filter.go</p>

<p>8ã€OPTIONSæ”¯æŒ
é€šè¿‡å®‰è£…é¢„å®šä¹‰çš„å®¹å™¨è¿‡æ»¤å™¨ï¼Œä½ çš„WebServiceå¯ä»¥å“åº”HTTP OPTIONSè¯·æ±‚ã€‚</p>

<p>Filter(OPTIONSFilter())
1
9ã€CORS
é€šè¿‡å®‰è£…CrossOriginResourceSharingè¿‡æ»¤å™¨ï¼Œä½ çš„WebServiceå¯ä»¥å¤„ç†CORSè¯·æ±‚ã€‚</p>

<p>cors := CrossOriginResourceSharing{ExposeHeaders: []string{â€œX-My-Headerâ€}, CookiesAllowed: false, Container: DefaultContainer}
Filter(cors.Filter)
1
2
10ã€å¼‚å¸¸å¤„ç†
æ„æƒ³ä¸åˆ°çš„äº‹æƒ…å‘ç”Ÿã€‚å¦‚æœå› ä¸ºæ•…éšœè€Œä¸èƒ½å¤„ç†è¯·æ±‚ï¼ŒæœåŠ¡ç«¯éœ€è¦é€šè¿‡å“åº”å‘Šè¯‰å®¢æˆ·ç«¯å‘ç”Ÿäº†ä»€ä¹ˆå’Œä¸ºä»€ä¹ˆã€‚å› æ­¤ä½¿ç”¨HTTPçŠ¶æ€ç ï¼Œæ›´é‡è¦çš„æ˜¯è¦æ­£ç¡®çš„ä½¿ç”¨çŠ¶æ€ç ã€‚</p>

<p>400: Bad Request
å¦‚æœè·¯å¾„æˆ–æŸ¥è¯¢å‚æ•°æ— æ•ˆï¼ˆå†…å®¹æˆ–ç±»å‹ï¼‰ï¼Œé‚£ä¹ˆä½¿ç”¨http.StatusBadRequestã€‚</p>

<p>404: Not Found
å°½ç®¡URIæœ‰æ•ˆï¼Œä½†è¯·æ±‚çš„èµ„æºå¯èƒ½ä¸å¯ç”¨ã€‚</p>

<p>500: Internal Server Error
å¦‚æœåº”ç”¨ç¨‹åºé€»è¾‘æ— æ³•å¤„ç†è¯·æ±‚ï¼ˆæˆ–ç¼–å†™å“åº”ï¼‰ï¼Œåˆ™ä½¿ç”¨http.StatusInternalServerErrorã€‚</p>

<p>405: Method Not Allowed
è¯·æ±‚çš„URLæ˜¯æœ‰æ•ˆçš„ï¼Œä½†è¯·æ±‚ä½¿ç”¨çš„HTTPæ–¹æ³•ï¼ˆGETï¼ŒPUTï¼ŒPOSTï¼Œâ€¦ï¼‰æ˜¯ä¸å…è®¸çš„ã€‚</p>

<p>406: Not Acceptable
è¯·æ±‚çš„å¤´éƒ¨æ²¡æœ‰æˆ–è®¾ç½®äº†æœªçŸ¥Accept Headerã€‚</p>

<p>415: Unsupported Media Type
è¯·æ±‚çš„å¤´éƒ¨æ²¡æœ‰æˆ–è®¾ç½®äº†æœªçŸ¥çš„Content-TypeæŠ¥å¤´ã€‚</p>

<p>11ã€ServiceError
é™¤äº†è®¾ç½®HTTPçŠ¶æ€ç ï¼Œè¿˜åº”è¯¥ä¸ºå“åº”é€‰æ‹©å†™é€‚å½“çš„ServiceErroræ¶ˆæ¯ã€‚</p>

<p>12ã€æ€§èƒ½é€‰é¡¹ï¼ˆPerformance Optionsï¼‰
è¿™ä¸ªåŒ…æœ‰å‡ ä¸ªé€‰é¡¹ï¼Œå®ƒä»¬å¯èƒ½ä¼šå½±å“æœåŠ¡çš„æ€§èƒ½ã€‚é‡è¦çš„æ˜¯è¦ç†è§£è¿™äº›é€‰é¡¹ï¼Œæ­£ç¡®åœ°è®¾ç½®å®ƒä»¬ã€‚</p>

<p>restful.DefaultContainer.DoNotRecover(false)
DoNotRecoveræ§åˆ¶æ˜¯å¦å› è¿”å›HTTP 500çŠ¶æ€ç è€Œï¼ˆææ…Œï¼‰åœæ­¢æœåŠ¡ã€‚å¦‚æœè®¾ç½®ä¸ºfalseï¼Œé‚£ä¹ˆå®¹å™¨Containerä¼šæ¢å¤æœåŠ¡ã€‚é»˜è®¤å€¼ä¸ºtrueã€‚</p>

<p>restful.SetCompressorProvider(NewBoundedCachedCompressors(20, 20))
å¦‚æœå¯ç”¨äº†å†…å®¹ç¼–ç ï¼Œé‚£ä¹ˆè·å¾—æ–°gzip/zlibè¾“å‡ºå™¨ï¼ˆwriterï¼‰å’Œè¯»å…¥å™¨ï¼ˆreaderï¼‰çš„é»˜è®¤ç­–ç•¥æ˜¯ä½¿ç”¨sync.Poolã€‚ç”±äºè¾“å‡ºå™¨writeræ˜¯æ˜‚è´µçš„ç»“æ„ï¼Œå½“ä½¿ç”¨é¢„åŠ è½½ç¼“å­˜æ—¶æ€§èƒ½æé«˜éå¸¸æ˜æ˜¾ã€‚ä½ ä¹Ÿå¯ä»¥æ³¨å…¥è‡ªå·±çš„å®ç°ã€‚</p>

<p>13ã€æ•…éšœæ’é™¤ï¼ˆTrouble shootingï¼‰
è¿™ä¸ªåŒ…å¯ä»¥å¯¹å®Œæ•´çš„Httpè¯·æ±‚çš„åŒ¹é…è¿‡ç¨‹å’Œè¿‡æ»¤å™¨è°ƒç”¨äº§ç”Ÿè¯¦ç»†çš„æ—¥å¿—è®°å½•ã€‚å¯ç”¨æ­¤åŠŸèƒ½éœ€è¦ä½ è®¾ç½®restful.StdLoggerçš„å®ç°ï¼Œä¾‹å¦‚log.Loggerï¼š</p>

<p>restful.TraceLogger(log.New(os.Stdout, â€œ[restful] â€œ, log.LstdFlags|logs.Lshortfile))
1
ä½¿ç”¨æ¡ˆä¾‹
https://github.com/emicklei/mora
https://github.com/emicklei/landskape</p>

<p>RESTï¼ˆRepresentational State Transferï¼Œè¡¨ç°å±‚çŠ¶æ€è½¬åŒ–ï¼‰æ˜¯è¿‘å‡ å¹´ä½¿ç”¨è¾ƒå¹¿æ³›çš„åˆ†å¸ƒå¼ç»“ç‚¹é—´åŒæ­¥é€šä¿¡çš„å®ç°æ–¹å¼ã€‚RESTåŸåˆ™æè¿°ç½‘ç»œä¸­client-serverçš„ä¸€ç§äº¤äº’å½¢å¼ï¼Œå³ç”¨URLå®šä½èµ„æºï¼Œç”¨HTTPæ–¹æ³•æè¿°æ“ä½œçš„äº¤äº’å½¢å¼ã€‚å¦‚æœCSä¹‹é—´äº¤äº’çš„ç½‘ç»œæ¥å£æ»¡è¶³RESTé£æ ¼ï¼Œåˆ™ç§°ä¸ºRESTful APIã€‚ä»¥ä¸‹æ˜¯ ç†è§£RESTfulæ¶æ„ æ€»ç»“çš„RESTåŸåˆ™ï¼š</p>

<p>ç½‘ç»œä¸Šçš„èµ„æºé€šè¿‡URIç»Ÿä¸€æ ‡ç¤ºã€‚
å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¹‹é—´ä¼ é€’ï¼Œè¿™ç§èµ„æºçš„æŸç§è¡¨ç°å±‚ã€‚è¡¨ç°å±‚å¯ä»¥æ˜¯jsonï¼Œæ–‡æœ¬ï¼ŒäºŒè¿›åˆ¶æˆ–è€…å›¾ç‰‡ç­‰ã€‚
å®¢æˆ·ç«¯é€šè¿‡HTTPçš„å››ä¸ªåŠ¨è¯ï¼Œå¯¹æœåŠ¡ç«¯èµ„æºè¿›è¡Œæ“ä½œï¼Œå®ç°è¡¨ç°å±‚çŠ¶æ€è½¬åŒ–ã€‚
ä¸ºä»€ä¹ˆè¦è®¾è®¡RESTfulçš„APIï¼Œä¸ªäººç†è§£åŸå› åœ¨äºï¼šç”¨HTTPçš„æ“ä½œç»Ÿä¸€æ•°æ®æ“ä½œæ¥å£ï¼Œé™åˆ¶URLä¸ºèµ„æºï¼Œå³æ¯æ¬¡è¯·æ±‚å¯¹åº”æŸç§èµ„æºçš„æŸç§æ“ä½œï¼Œè¿™ç§ æ— çŠ¶æ€çš„è®¾è®¡å¯ä»¥å®ç°client-serverçš„è§£è€¦åˆ†ç¦»ï¼Œä¿è¯ç³»ç»Ÿä¸¤ç«¯éƒ½æœ‰æ¨ªå‘æ‰©å±•èƒ½åŠ›ã€‚</p>

<p>go-restful</p>

<p>go-restful is a package for building REST-style Web Services using Google Goã€‚go-restfulå®šä¹‰äº†Container WebServiceå’ŒRouteä¸‰ä¸ªé‡è¦æ•°æ®ç»“æ„ã€‚</p>

<p>Route è¡¨ç¤ºä¸€æ¡è·¯ç”±ï¼ŒåŒ…å« URL/HTTP method/è¾“å…¥è¾“å‡ºç±»å‹/å›è°ƒå¤„ç†å‡½æ•°RouteFunction
WebService è¡¨ç¤ºä¸€ä¸ªæœåŠ¡ï¼Œç”±å¤šä¸ªRouteç»„æˆï¼Œä»–ä»¬å…±äº«åŒä¸€ä¸ªRoot Path
Container è¡¨ç¤ºä¸€ä¸ªæœåŠ¡å™¨ï¼Œç”±å¤šä¸ªWebServiceå’Œä¸€ä¸ª http.ServerMux ç»„æˆï¼Œä½¿ç”¨RouteSelectorè¿›è¡Œåˆ†å‘
æœ€ç®€å•çš„ä½¿ç”¨å®ä¾‹ï¼Œå‘WebServiceæ³¨å†Œè·¯ç”±ï¼Œå°†WebServiceæ·»åŠ åˆ°Containerä¸­ï¼Œç”±Containerè´Ÿè´£åˆ†å‘ã€‚
func main() {
  ws := new(restful.WebService)
  ws.Path(â€œ/usersâ€)
  ws.Route(ws.GET(â€œ/â€).To(u.findAllUsers).
    Doc(â€œget all usersâ€).
    Metadata(restfulspec.KeyOpenAPITags, tags).
    Writes([]User{}).
    Returns(200, â€œOKâ€, []User{}))</p>

<p>container := restful.NewContainer().Add(ws)
 http.ListenAndServe(â€œ:8080â€, container)
}
container</p>

<p>containeræ˜¯æ ¹æ®æ ‡å‡†åº“httpçš„è·¯ç”±å™¨ServeMuxå†™çš„ï¼Œå¹¶ä¸”å®ƒé€šè¿‡ServeMuxçš„è·¯ç”±è¡¨å®ç°äº†Handleræ¥å£ï¼Œå¯å‚è€ƒä»¥å‰çš„è¿™ç¯‡ HTTPåè®®ä¸Goçš„å®ç° ã€‚
type Container struct {
  webServicesLock    sync.RWMutex
  webServices      []<em>WebService
  ServeMux        *http.ServeMux
  isRegisteredOnRoot   bool
  containerFilters    []FilterFunction
  doNotRecover      bool // default is true
  recoverHandleFunc   RecoverHandleFunction
  serviceErrorHandleFunc ServiceErrorHandleFunction
  router         RouteSelector // default is a CurlyRouter
  contentEncodingEnabled bool     // default is false
}
func (c *Container)ServeHTTP(httpwriter http.ResponseWriter, httpRequest *http.Request) {
  c.ServeMux.ServeHTTP(httpwriter, httpRequest)
}
å¾€Containerå†…æ·»åŠ WebServiceï¼Œå†…éƒ¨ç»´æŠ¤çš„webServicesä¸èƒ½æœ‰é‡å¤çš„RootPathï¼Œ
func (c *Container)Add(service *WebService)</em>Container {
  c.webServicesLock.Lock()
  defer c.webServicesLock.Unlock()
  if !c.isRegisteredOnRoot {
    c.isRegisteredOnRoot = c.addHandler(service, c.ServeMux)
  }
  c.webServices = append(c.webServices, service)
  return c
}
æ·»åŠ åˆ°containerå¹¶æ³¨å†Œåˆ°muxçš„æ˜¯dispatchè¿™ä¸ªå‡½æ•°ï¼Œå®ƒè´Ÿè´£æ ¹æ®ä¸åŒWebServiceçš„rootPathè¿›è¡Œåˆ†å‘ã€‚
func (c *Container)addHandler(service *WebService, serveMux *http.ServeMux)bool {
  pattern := fixedPrefixPath(service.RootPath())
  serveMux.HandleFunc(pattern, c.dispatch)
}
webservice</p>

<p>æ¯ç»„webserviceè¡¨ç¤ºä¸€ä¸ªå…±äº«rootPathçš„æœåŠ¡ï¼Œå…¶ä¸­rootPathé€šè¿‡ ws.Path() è®¾ç½®ã€‚
type WebService struct {
  rootPath    string
  pathExpr    <em>pathExpression 
  routes     []Route
  produces    []string
  consumes    []string
  pathParameters []</em>Parameter
  filters    []FilterFunction
  documentation string
  apiVersion   string</p>

<p>typeNameHandleFunc TypeNameHandleFunction
  dynamicRoutes bool
  routesLock sync.RWMutex
}
é€šè¿‡Routeæ³¨å†Œçš„è·¯ç”±æœ€ç»ˆæ„æˆRouteç»“æ„ä½“ï¼Œæ·»åŠ åˆ°WebServiceçš„routesä¸­ã€‚
func (w <em>WebService)Route(builder *RouteBuilder)</em>WebService {
  w.routesLock.Lock()
  defer w.routesLock.Unlock()
  builder.copyDefaults(w.produces, w.consumes)
  w.routes = append(w.routes, builder.Build())
  return w
}
route</p>

<p>é€šè¿‡RouteBuilderæ„é€ Routeä¿¡æ¯ï¼ŒPathç»“åˆäº†rootPathå’ŒsubPathã€‚Functionæ˜¯è·¯ç”±Handlerï¼Œå³å¤„ç†å‡½æ•°ï¼Œå®ƒé€šè¿‡ ws.Get(subPath).To(function) çš„æ–¹å¼åŠ å…¥ã€‚Filterså®ç°äº†ä¸ªç±»ä¼¼gRPCæ‹¦æˆªå™¨çš„ä¸œè¥¿ï¼Œä¹Ÿç±»ä¼¼go-chassisçš„chainã€‚
type Route struct {
  Method  string
  Produces []string
  Consumes []string
  Path   string // webservice root path + described path
  Function RouteFunction
  Filters []FilterFunction
  If    []RouteSelectionConditionFunction
  // cached values for dispatching
  relativePath string
  pathParts  []string
  pathExpr   <em>pathExpression
  // documentation
  Doc           string
  Notes          string
  Operation        string
  ParameterDocs      []</em>Parameter
  ResponseErrors     map[int]ResponseError
  ReadSample, WriteSample interface{} 
  Metadata map[string]interface{}
  Deprecated bool
}
dispatch</p>

<p>serverä¾§çš„ä¸»è¦åŠŸèƒ½å°±æ˜¯è·¯ç”±é€‰æ‹©å’Œåˆ†å‘ã€‚httpåŒ…å®ç°äº†ä¸€ä¸ª ServeMux ï¼Œgo-restfulåœ¨è¿™ä¸ªåŸºç¡€ä¸Šå°è£…äº†å¤šä¸ªæœåŠ¡ï¼Œå¦‚ä½•åœ¨ä»containerå¼€å§‹å°†è·¯ç”±åˆ†å‘ç»™webserviceï¼Œå†ç”±webserviceåˆ†å‘ç»™å…·ä½“å¤„ç†å‡½æ•°ã€‚è¿™äº›éƒ½åœ¨ dispatch ä¸­å®ç°ã€‚</p>

<p>SelectRouteæ ¹æ®Reqåœ¨æ³¨å†Œçš„WebServiceä¸­é€‰æ‹©åŒ¹é…çš„WebServiceå’ŒåŒ¹é…çš„Routeã€‚å…¶ä¸­è·¯ç”±é€‰æ‹©å™¨é»˜è®¤æ˜¯ CurlyRouter ã€‚
è§£æpathParamsï¼Œå°†wrapçš„è¯·æ±‚å’Œç›¸åº”äº¤ç»™è·¯ç”±çš„å¤„ç†å‡½æ•°å¤„ç†ã€‚å¦‚æœæœ‰filterså®šä¹‰ï¼Œåˆ™é“¾å¼å¤„ç†ã€‚
func (c *Container)dispatch(httpWriter http.ResponseWriter, httpRequest *http.Request) {
  func() {
    c.webServicesLock.RLock()
    defer c.webServicesLock.RUnlock()
    webService, route, err = c.router.SelectRoute(
      c.webServices,
      httpRequest)
  }()</p>

<p>pathProcessor, routerProcessesPath := c.router.(PathProcessor)
  pathParams := pathProcessor.ExtractParameters(route, webService, httpRequest.URL.Path)
  wrappedRequest, wrappedResponse := route.wrapRequestResponse(writer,
  httpRequest, pathParams)</p>

<p>if len(c.containerFilters)+len(webService.filters)+len(route.Filters) &gt; 0 {
    chain := FilterChain{Filters: allFilters, Target: func(req *Request, resp *Response) {
      // handle request by route after passing all filters
      route.Function(wrappedRequest, wrappedResponse)
    }}
    chain.ProcessFilter(wrappedRequest, wrappedResponse)
  } else {
    route.Function(wrappedRequest, wrappedResponse)
  }
}
go-chassis</p>

<p>go-chassiså®ç°çš„rest-serveræ˜¯åœ¨go-restfulä¸Šçš„ä¸€å±‚å°è£…ã€‚Registeræ—¶åªè¦å°†æ³¨å†Œçš„schemaè§£ææˆroutesï¼Œå¹¶æ³¨å†Œåˆ°webServiceä¸­ï¼ŒStartå¯åŠ¨serveræ—¶ container.Add(r.ws) ï¼ŒåŒæ—¶å°†containerä½œä¸ºhandleräº¤ç»™ http.Server , æœ€åå¼€å§‹ListenAndServeå³å¯ã€‚
type restfulServer struct {
  microServiceName string
  container    *restful.Container
  ws        *restful.WebService
  opts       server.Options
  mux       sync.RWMutex
  exit       chan chan error
  server      *http.Server
}
æ ¹æ®Methodä¸åŒï¼Œå‘WebServiceæ³¨å†Œä¸åŒæ–¹æ³•çš„handleï¼Œä»schemaè¯»å–çš„routesä¿¡æ¯åŒ…å«Methodï¼ŒFuncä»¥åŠPathPatternã€‚
func (r *restfulServer)Register(schemainterface{}, options â€¦server.RegisterOption)(string, error) {
  schemaType := reflect.TypeOf(schema)
  schemaValue := reflect.ValueOf(schema)
  var schemaName string
  tokens := strings.Split(schemaType.String(), â€œ.â€)
  if len(tokens) &gt;= 1 {
    schemaName = tokens[len(tokens)-1]
  }</p>

<p>routes, err := GetRoutes(schema)
  for _, route := range routes {
    lager.Logger.Infof(â€œAdd route path: [%s] Method: [%s] Func: [%s]. â€œ,
      route.Path, route.Method, route.ResourceFuncName)
    method, exist := schemaType.MethodByName(route.ResourceFuncName)
    â€¦
    handle := func(req *restful.Request, rep *restful.Response) {
      c, err := handler.GetChain(common.Provider, r.opts.ChainName)
      inv := invocation.Invocation{
        MicroServiceName:  config.SelfServiceName,
        SourceMicroService: req.HeaderParameter(common.HeaderSourceName),
        Args:        req,
        Protocol:      common.ProtocolRest,
        SchemaID:      schemaName,
        OperationID:    method.Name,
      }
      bs := NewBaseServer(context.TODO())
      bs.req = req
      bs.resp = rep
      c.Next(&amp;inv, func(ir *invocation.InvocationResponse)error {
        if ir.Err != nil {
          return ir.Err
        }
        method.Func.Call([]reflect.Value{schemaValue, reflect.ValueOf(bs)})
        if bs.resp.StatusCode() &gt;= http.StatusBadRequest {
          return â€¦
        }
        return nil
      })
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>switch route.Method {
case http.MethodGet:
  r.ws.Route(r.ws.GET(route.Path).To(handle).
   Doc(route.ResourceFuncName).
   Operation(route.ResourceFuncName))
...
}   }   return reflect.TypeOf(schema).String(), nil }
</code></pre></div></div>

<p>ä¸€ã€go-json-restæ¡†æ¶ä»‹ç»
go-json-restï¼ˆhttps://github.com/ant0ine/go-json-rest/ï¼‰æ˜¯åŸºäºnet/httpçš„ä¸€ä¸ªå°å°è£…ï¼Œå¯å¸®åŠ©è½»æ¾æ„å»ºRESTful JSON APIã€‚å®ƒä½¿ç”¨åŸºäºTrieçš„å®ç°æä¾›å¿«é€Ÿå’Œå¯æ‹“å±•çš„è¯·æ±‚è·¯ç”±ï¼Œå¸®åŠ©å¤„ç†JSONè¯·æ±‚å’Œå“åº”ã€‚å®ƒæ‹¥æœ‰ä¸°å¯Œçš„ä¸­é—´ä»¶ï¼Œæ¯”å¦‚CORSï¼ŒAuthï¼ŒGzipï¼ŒStatusç­‰ï¼Œå¯å¸®åŠ©å®ç°å’Œæ‹“å±•åŠŸèƒ½ã€‚æ­¤å¤–ï¼Œè¿˜æœ‰ä¸€äº›ä¸go-json-restå…¼å®¹çš„ç¬¬ä¸‰æ–¹ä¸­é—´ä»¶ï¼Œæ¯”å¦‚JWTï¼ŒAuthTokenç­‰</p>

<p>äºŒã€go-json-restçš„ç®€å•å®ç”¨
ä½¿ç”¨å‘½ä»¤è¿›è¡Œå®‰è£…ï¼š</p>

<p>go get github.com/ant0ine/go-json-rest/rest
æ–°å»ºä¸€ä¸ªmain.goï¼Œå¯¼å…¥go-json-restï¼Œè¿™é‡Œä»¥ä¸€ä¸ªç®€å•ä¾‹å­è¿›è¡Œè¯´æ˜ï¼š</p>

<p>package main</p>

<p>import (
	â€œgithub.com/ant0ine/go-json-rest/restâ€
	â€œlogâ€
	â€œnet/httpâ€
)</p>

<p>func main() {
	api := rest.NewApi()
	api.Use(rest.DefaultDevStackâ€¦)
	router, err := rest.MakeRouter(
		rest.Get(â€œ/messageâ€, func(w rest.ResponseWriter, req *rest.Request) {
			w.WriteJson(map[string]string{â€œBodyâ€: â€œHello World!â€})
		}),
	)
	if err != nil {
		log.Fatal(err)
	}
	api.SetApp(router)
	http.Handle(â€œ/api/â€, http.StripPrefix(â€œ/apiâ€, api.MakeHandler()))
	log.Fatal(http.ListenAndServe(â€œ:8080â€, nil))
}
åœ¨æµè§ˆå™¨ç«¯è¾“å…¥http://localhost:8080/api/message
ä¸‰ã€go-json-reståœ¨é¡¹ç›®ä¸­å¼€å‘
å¯ä»¥æŒ‰ç…§è®¾è®¡æ¨¡å‹ã€è¿æ¥æ•°æ®åº“ã€è®¾è®¡æ§åˆ¶å™¨ã€é…ç½®è·¯ç”±æµç¨‹è¿›è¡Œå¼€å‘ã€‚</p>

<p>é¡¹ç›®åœºæ™¯ï¼šéœ€è¦å®ç°ä¸€ä¸ªç”¨æˆ·ç®¡ç†ç³»ç»Ÿï¼Œè¯¥ç³»ç»Ÿä¸»è¦æ˜¯å¯¹ç”¨æˆ·çš„åŸºæœ¬ä¿¡æ¯è¿›è¡Œç®¡ç†ã€‚</p>

<p>è®¾è®¡æ¨¡å‹
è¯¥ç³»ç»Ÿæœ€æ ¸å¿ƒçš„æ˜¯ç”¨æˆ·æ¨¡å—ï¼Œæ¨¡å‹è®¾è®¡æ—¶éœ€è¦è€ƒè™‘çš„æ˜¯ç”¨æˆ·çš„å±æ€§ä¿¡æ¯ï¼Œæ¯”å¦‚é‚®ç®±ã€è”ç³»æ–¹å¼ç­‰ç­‰ã€‚æ¨¡å‹æ„å»ºå¦‚ä¸‹ï¼Œå·¦è¾¹è¡¨ç¤ºgolangå®ç°çš„ç»“æ„ä½“ï¼Œå³è¾¹è¡¨ç¤ºæ•°æ®è¡¨è®¾è®¡ã€‚</p>

<p>è¿æ¥æ•°æ®åº“
è¿™é‡Œä½¿ç”¨çš„gormæ¥æ“ä½œæ•°æ®åº“ï¼Œå®ƒæ˜¯golangè¯­è¨€å†™çš„ORMåº“ã€‚</p>

<p>æºç åœ°å€ï¼šhttps://github.com/jinzhu/gorm</p>

<p>ä¸­æ–‡æ–‡æ¡£ï¼šhttp://gorm.book.jasperxu.com/</p>

<p>è¿™ä¸€æ­¥éª¤ä¸»è¦æ˜¯å¯¹æ•°æ®åº“è¿æ¥ç›¸å…³è¿›è¡Œè®¾ç½®ï¼Œä½¿ç”¨æ—¶éœ€è¦å…ˆä¸‹è½½å®‰è£…gormæºç ï¼Œç„¶åå¯¼å…¥gormåŠé©±åŠ¨ï¼Œä¸‹é¢å±•ç¤ºgormè¿æ¥æ•°æ®åº“ç¤ºä¾‹ï¼š</p>

<p>package db</p>

<p>import (
	â€œgithub.com/jinzhu/gormâ€
    _ â€œgithub.com/jinzhu/gorm/dialects/mysqlâ€
	â€œtimeâ€
	â€œlogâ€
)</p>

<p>type BaseGorm struct {
	DB *gorm.DB
}</p>

<p>var baseDB *gorm.DB</p>

<p>func (this <em>BaseGorm) InitDB() {
	var err error
	this.DB, err = gorm.Open(â€œmysqlâ€, â€œroot:@tcp(localhost:3306)/userdb?charset=utf8&amp;parseTime=true&amp;loc=Localâ€)
	if err != nil {
		log.Fatal(err)
		return
	}
	this.DB.SingularTable(true)
	this.DB.DB().SetMaxIdleConns(10)
	this.DB.DB().SetMaxOpenConns(100)
	this.DB.DB().SetConnMaxLifetime(300</em>time.Second)
	this.DB.LogMode(true)
	baseDB = this.DB
}
func (this *BaseGorm) GetDB() (DB *gorm.DB) {
	if baseDB != nil {
		DB = baseDB
	} else {
		log.Fatal(â€œDB not initial.â€)
		return
	}
	return
}</p>

<p>è®¾è®¡æ§åˆ¶å™¨
è®¾è®¡æ§åˆ¶å™¨ï¼Œå…¶å®å°±æ˜¯æ¥å£çš„è®¾è®¡ã€‚å› ä¸ºè¿™ä¸ªç³»ç»Ÿä¸»è¦æ˜¯å¯¹ç”¨æˆ·çš„åŸºæœ¬ä¿¡æ¯è¿›è¡Œç®¡ç†ï¼Œå¤§è‡´å¯è®¾è®¡ä¸ºï¼šç™»é™†ã€æ³¨å†Œã€é€€å‡ºã€æ–°å¢ç”¨æˆ·ã€ä¿®æ”¹ç”¨æˆ·ã€åˆ é™¤ç”¨æˆ·ã€æŸ¥çœ‹ç”¨æˆ·ï¼ˆè·å–æ‰€æœ‰ç”¨æˆ·ä¿¡æ¯ã€è·å–æŒ‡å®šidçš„ç”¨æˆ·ä¿¡æ¯ï¼‰æ¥å£ã€‚</p>

<p>è¦å®ç°æ¥å£ï¼Œå¯æŒ‰ç…§ä¸‰æ­¥èµ°ç­–ç•¥è¿›è¡Œï¼šç¬¬ä¸€æ­¥ï¼šè§£æè·å–æ•°æ®ï¼ˆæ¯”å¦‚éœ€è¦æ–°å¢æ–°ç”¨æˆ·ï¼Œä¼špostä¸€äº›jsonç±»å‹æ•°æ®ï¼›åˆ é™¤ç”¨æˆ·ï¼Œéœ€è¦deleteåˆ°å…·ä½“çš„idå€¼ç­‰ï¼‰ï¼›ç¬¬äºŒæ­¥ï¼šé€šè¿‡gormæ¥æ“ä½œæ•°æ®åº“ï¼›ç¬¬ä¸‰æ­¥ï¼šè¿”å›ç»“æœï¼Œä½œå‡ºå“åº”ã€‚ä¸‹é¢å±•ç¤ºçš„æ˜¯æŸ¥è¯¢æŒ‡å®šidçš„ç”¨æˆ·ä¿¡æ¯æ¥å£å®ç°ï¼š</p>

<p>func (userController *UserController) QueryUserById(w rest.ResponseWriter, r *rest.Request) {
	returnJson := make(map[string]interface{})</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//è§£æè·å–æ•°æ®
id := r.PathParam("id")
userId, _ := strconv.Atoi(id)

//é€šè¿‡gormæ“ä½œæ•°æ®åº“
baseGorm:=db.BaseGorm{}
userInfo, err := baseGorm.QueryUserInfoById(userId)
if err != nil {
	log.Fatal(err)
	//æ“ä½œå¤±è´¥è¿”å›ç»“æœ
	returnJson["code"] = 1
	returnJson["msg"] = err.Error()
	panic(w.WriteJson(returnJson))
	return
}

//æ“ä½œæˆåŠŸè¿”å›ç»“æœ
returnJson["code"] = 0
returnJson["msg"] = "query userInfo success!"
returnJson["user"] = userInfo
w.WriteJson(returnJson) }
</code></pre></div></div>

<p>é…ç½®è·¯ç”±
è¿™ä¸€æ­¥éª¤éœ€è¦å°†URIä¸æ¥å£è¿›è¡Œå¯¹æ¥ï¼Œå½“å®¢æˆ·ç«¯è®¿é—®URIæ—¶ï¼Œå¯ä»¥è®¿é—®åˆ°å¯¹åº”çš„æ¥å£ï¼Œè·å–æœŸæœ›çš„ç»“æœã€‚å½“ç„¶ï¼Œå¯ä»¥åœ¨è¿™é‡Œä½¿ç”¨ä¸­é—´ä»¶ï¼Œæ¯”å¦‚AuthTokenMiddlewareç­‰ã€‚</p>

<p>package main</p>

<p>import (
	â€œgithub.com/ant0ine/go-json-rest/restâ€
	â€œlogâ€
	â€œnet/httpâ€
	â€œuserMgmtDemo/controllerâ€
	â€œuserMgmtDemo/dbâ€
	â€œuserMgmtDemo/commonâ€
)</p>

<p>func main() {
	new(db.BaseGorm).InitDB()
	api := rest.NewApi()
	api.Use(rest.DefaultDevStackâ€¦)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ä½¿ç”¨ç¬¬ä¸‰æ–¹ä¸­é—´ä»¶AuthTokenMiddlewareï¼Œå¯¹tokenè¿›è¡ŒéªŒè¯
tokenAuthMiddleware := &amp;common.AuthTokenMiddleware{
	Realm: "jwt auth",
	Authenticator: func(token string) string {
		var baseGorm *db.BaseGorm
		userInfo, count, err := baseGorm.QueryUseInfoByToken(token)
		if err != nil || count == 0 {
			return ""
		} else {
			return userInfo.Deadline
		}
	},//è¿”å›ä¸ºç©ºï¼Œåˆ™è¯´æ˜tokenéªŒè¯ä¸é€šè¿‡ï¼Œä¸èƒ½ç»§ç»­è®¿é—®æ¥å£ï¼›è¿”å›æœ‰å€¼ï¼Œå†å°†å…¶ä¸æ•°æ®åº“ä¸­çš„å¤±æ•ˆæ—¶é—´å­—æ®µè¿›è¡Œå¯¹æ¯”ï¼Œåˆ¤æ–­æ˜¯å¦å¤±æ•ˆï¼Œå¤±æ•ˆåˆ™ä¸èƒ½ç»§ç»­è®¿é—®æ¥å£
	Authorizer: nil,
}

//ä½¿ç”¨go-json-restè‡ªå¸¦çš„ä¸­é—´ä»¶IfMiddlewareç­›é€‰åˆ¤æ–­
//å› ä¸ºloginã€registeræ¥å£åœ¨ä½¿ç”¨æ—¶æ²¡æœ‰tokenï¼Œä¸èƒ½ç»è¿‡AuthTokenMiddlewareä¸­é—´ä»¶éªŒè¯ï¼Œå› æ­¤éœ€è¦å°†å…¶è¿‡æ»¤
api.Use(&amp;rest.IfMiddleware{
	Condition: func(request *rest.Request) bool {
		var arr = []string{
			"/login","/register",
		}
		for _, item := range arr {
			if item == request.URL.Path {
				return false
			}
		}
		return true
	},
	IfTrue: tokenAuthMiddleware,
})

router, err := rest.MakeRouter(
	rest.Post("/login",new (controller.WebController).Login),
	rest.Post("/register",new (controller.WebController).Register),
	rest.Put("/loginout/:id",new (controller.WebController).Loginout),
	rest.Get("/users/:id", new (controller.UserController).QueryUserById),
	rest.Get("/users",new (controller.UserController).QueryAllUser),
	rest.Delete("/users/:id", new (controller.UserController).DeleteUser),
	rest.Put("/users",new (controller.UserController).UpdateUser),
)
if err != nil {
	log.Fatal(err)
}
api.SetApp(router)
http.Handle("/api/", http.StripPrefix("/api", api.MakeHandler()))
log.Fatal(http.ListenAndServe(":8080", nil)) }
</code></pre></div></div>

<p>è‡³æ­¤ï¼Œä½¿ç”¨go-json-restæ¡†æ¶å°±å¼€å‘å®Œæˆäº†ã€‚å¦‚è‹¥éœ€è¦æµ‹è¯•æ¥å£æ˜¯å¤Ÿè¿è¡Œæ­£ç¡®ï¼Œå¯ä»¥ä½¿ç”¨Postmanå·¥å…·è¿›è¡Œæµ‹è¯•ï¼Œéå¸¸æ–¹ä¾¿ã€‚</p>
:ET