I"âû<p>https://github.com/lxc/lxc
lxc_start.c
int main(int argc, char *argv[])
{
    int err = 1;
    struct lxc_conf *conf;    //åˆå§‹åŒ–configç»“æ„
    char *const *args;		 //ä¼ é€’çš„å‚æ•°
    char *rcfile = NULL;		 //æŒ‡å®šé…ç½®æ–‡ä»¶
    char *const default_args[] = {    //é»˜è®¤çš„argså‚æ•°
        â€œ/sbin/initâ€,
        NULL,
    };<br />
struct lxc_container *c;    //lxc-container çš„ç»“æ„ä½“
â€¦.
}
<!-- more -->
lxc_confè¿™ä¸ªæ•°æ®ç»“æ„
struct lxc_conf {
    int is_execute;		//å®¹å™¨æ˜¯å¦åœ¨æ‰§è¡Œ
    char *fstab;			//fstabï¼Ÿ
    int tty;				//ttyçš„ä¸ªæ•°
    int pts;				//ptsçš„ä¸ªæ•°ï¼Ÿ
    int reboot;			//é‡å¯ï¼Ÿ
    int need_utmp_watch;		//å­—é¢ç¿»è¯‘ éœ€è¦utmp æŸ¥çœ‹
    signed long personality;		//å­—é¢ç¿»è¯‘ ç‰¹ç‚¹	
    struct utsname *utsname;	//ustname
    struct lxc_list cgroup;		//cgroup list lxc_liståªæ˜¯ç®€å•çš„é“¾è¡¨ç»“æ„
    struct lxc_list id_map;		//id_map list
    struct lxc_list network;		//network list
    struct saved_nic *saved_nics;//saved_nics ç»“æ„
    int num_savednics;			//savednicsæ•°é‡ï¼Ÿ
    int auto_mounts;			//auto_mounts?
    struct lxc_list mount_list;		//mount_list list?
    struct lxc_list caps;			//caps listï¼Ÿ
    struct lxc_list keepcaps;		//keepcaps list?
    struct lxc_tty_info tty_info;	//ttyçš„ç›¸å…³ä¿¡æ¯
    struct lxc_console console;	//consoleçš„ç»“æ„ä½“
    struct lxc_rootfs rootfs;		//rootfsçš„ç»“æ„ä½“
    char *ttydir;					//ttyç›®å½•
int close_all_fds;			//å…³é—­æ‰€æœ‰fd
struct lxc_list hooks[NUM_LXC_HOOKS];	//hooks å‡½æ•°</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char *lsm_aa_profile;   //?
char *lsm_se_context;	//?
int tmp_umount_proc;	//?
char *seccomp;  // filename with the seccomp rules #if HAVE_SCMP_FILTER_CTX
scmp_filter_ctx seccomp_ctx; #endif
int maincmd_fd;		//?
int autodev;  // if 1, mount and fill a /dev at start
int haltsignal; // signal used to halt container
int stopsignal; // signal used to hard stop container
int kmsg;  // if 1, create /dev/kmsg symlink
char *rcfile;   // Copy of the top level rcfile we read
 
// Logfile and loglevel can be set in a container config file.
// Those function as defaults.  The defaults can be overriden
// by command line.  However we don't want the command line
// specified values to be saved on c-&gt;save_config().  So we
// store the config file specified values here.
char *logfile;  // the logfile as specifed in config
int loglevel;   // loglevel as specifed in config (if any)
 
int inherit_ns_fd[LXC_NS_MAX];
 
int start_auto;
int start_delay;
int start_order;
struct lxc_list groups;
int nbd_idx;
 
/* set to true when rootfs has been setup */
bool rootfs_setup; };
</code></pre></div></div>

<p>lxc_containerçš„ç»“æ„ä½“</p>

<p>/*!</p>
<ul>
  <li>
    <p>An LXC container.
 */
struct lxc_container {
 // private fields
char *name; 		 //container çš„åå­—
char *configfile; 		 // configuration file çš„è·¯å¾„
char *pidfile;   		 // å­˜å‚¨pid çš„æ–‡ä»¶å
struct lxc_lock *slock;  //Container semaphore lock. å®¹å™¨çš„ä¿¡å·é”
 struct lxc_lock *privlock;//å®¹å™¨çš„ç§æœ‰ä¿¡å·é”
 int numthreads;			//å®¹å™¨çš„å¼•ç”¨æ•°é‡ï¼Œç”±privlockä¿æŠ¤
 struct lxc_conf *lxc_conf;</p>

    <p>// public fields
 char *error_string;		//å…¨å±€å˜é‡ å¯è¯»çš„æœ€åæ˜¾ç¤ºçš„error
 int error_num;			//æœ€åerrorçš„æ•°å­—
 bool daemonize;		//å®¹å™¨æ˜¯å¦å¸Œæœ›å¼€å¯å®ˆæŠ¤è¿›ç¨‹
char *config_path;		// configuration file çš„è·¯å¾„ å’Œä¸Šé¢çš„åŒºåˆ«ï¼Ÿ å…¨å±€ï¼Ÿ
â€¦â€¦.					//ä¸€å †æˆå‘˜å‡½æ•°   æš‚ä¸çœ‹
}</p>
  </li>
</ul>

<p>lxc_list_init(&amp;defines);Â Â Â Â Â Â Â Â Â Â Â Â  //åˆå§‹åŒ–list</p>

<p>defineså®šä¹‰åœ¨æ–‡ä»¶å¼€å§‹ï¼Œä¸ºå…¨å±€å˜é‡</p>

<p>static structlxc_list defines;</p>

<p>if(lxc_caps_init())Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //capsåˆå§‹åŒ–</p>

<p>Â Â Â Â Â Â Â  return err;</p>

<p>åˆ°è¿™ä¸ªå‡½æ•°é‡Œçœ‹ä¸€ä¸‹ã€‚</p>

<p>int lxc_caps_init(void)
{
    uid_t uid = getuid();
    gid_t gid = getgid();
    uid_t euid = geteuid();	//æœ‰æ•ˆuid</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!uid) {				//rootæƒé™è¿è¡Œçš„è¯å°±çœäº†åé¢çš„æ­¥éª¤äº†
    INFO("command is run as 'root'");
    return 0;
}   
 
if (uid &amp;&amp; !euid) {
    INFO("command is run as setuid root (uid : %d)", uid);
 
    if (prctl(PR_SET_KEEPCAPS, 1)) {		//prctl è®¾ç½®è¿›ç¨‹çš„é€‰é¡¹ï¼Œä¸ºä¸‹é¢setï¼Ÿ
        ERROR("failed to 'PR_SET_KEEPCAPS': %m");
        return -1; 
    }   
 
    if (setresgid(gid, gid, gid)) {
        ERROR("failed to change gid to '%d': %m", gid);
        return -1; 
    }   
 
    if (setresuid(uid, uid, uid)) {
        ERROR("failed to change uid to '%d': %m", uid);
        return -1; 
    }   
 
    if (lxc_caps_up()) {
        ERROR("failed to restore capabilities: %m");
        return -1; 
    }   
}   
</code></pre></div></div>

<p>if (uid == euid)
INFO(â€œcommand is run as user â€˜%dâ€™â€, uid);</p>

<p>return 0;
}</p>

<p>æ¥ç€å°±æ˜¯è¯»ä¼ è¿‡æ¥çš„å‚æ•°</p>

<p>if(lxc_arguments_parse(&amp;my_args, argc, argv))</p>

<p>Â Â Â Â Â Â Â  return err;</p>

<p>è¿™ä¸ªå‡½æ•°å°±æ²¡ç»†çœ‹ï¼Œåªéœ€çŸ¥é“å°†å‚æ•°ä¼ ç»™my_args</p>

<p>åˆ¤æ–­æœ‰æ²¡æœ‰æŒ‡å®š åˆå§‹æ‰§è¡Œçš„å‚æ•°ï¼Œæ²¡æœ‰çš„è¯æŒ‡å®šé»˜è®¤å‚æ•°</p>

<p>if (!my_args.argc)</p>

<p>Â Â Â Â Â Â Â  args = default_args;</p>

<p>Â Â Â  elseÂ Â Â Â Â Â Â </p>

<p>Â Â Â Â Â Â Â  args = my_args.argv;</p>

<p>Â </p>

<p>åˆå§‹åŒ–ä¸€å †logçš„ï¼Œæš‚æ—¶ä¹Ÿæ²¡ç»†çœ‹</p>

<p>if (lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,
             my_args.progname, my_args.quiet, my_args.lxcpath[0]))
        return err;
lxc_log_options_no_override();</p>

<p>const char <em>lxcpath = my_args.lxcpath[0];		//lxcpath å¾ˆæœ‰æ„æ€
// lxc_global_config_value(â€œlxc.lxcpathâ€)è¿™ä¸ªå†™çš„è¿˜æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œæ€»ä¹‹lxcpathä¼šæ˜¯é»˜è®¤çš„è·¯å¾„
//æŒ‡å®šconfigçš„ä½ç½®ï¼Œå¦‚æœæ²¡æŒ‡å®šï¼Œåˆ™ä½¿ç”¨é»˜è®¤çš„è·¯å¾„çš„configï¼Œé€šè¿‡é…ç½®åˆ›å»ºæ–°çš„
/</em>
     * rcfile possibilities:
     * 1. rcfile from random path specified in cli option
     * 2. rcfile not specified, use $lxcpath/$lxcname/config
     * 3. rcfile not specified and does not exist.
     <em>/
    /</em> rcfile is specified in the cli option */
    if (my_args.rcfile) {
        rcfile = (char *)my_args.rcfile;
        c = lxc_container_new(my_args.name, lxcpath);
        if (!c) {
            ERROR(â€œFailed to create lxc_containerâ€);
            return err;
        }
        c-&gt;clear_config(c);
        if (!c-&gt;load_config(c, rcfile)) {
            ERROR(â€œFailed to load rcfileâ€);
            lxc_container_put(c);
            return err;
        }
}
 } else {
        int rc;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rc = asprintf(&amp;rcfile, "%s/%s/config", lxcpath, my_args.name);
    if (rc == -1) {
        SYSERROR("failed to allocate memory");
        return err;
    }
    INFO("using rcfile %s", rcfile);
 
    /* container configuration does not exist */
    if (access(rcfile, F_OK)) {
        free(rcfile);
        rcfile = NULL;
    }
    c = lxc_container_new(my_args.name, lxcpath);
    if (!c) {
        ERROR("Failed to create lxc_container");
        return err;
    } }
</code></pre></div></div>

<p>é‡Œé¢æœ€ä¸»è¦çš„å‡½æ•°c = lxc_container_new(my_args.name, lxcpath);</p>

<p>struct lxc_container *lxc_container_new(const char *name, const char *configpath)
{
    struct lxc_container *c;			//ç»“æ„ä½“lxc_container å‰é¢åˆ†æè¿‡äº†</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c = malloc(sizeof(*c));			//åˆ›å»º
if (!c) {
    fprintf(stderr, "failed to malloc lxc_container\n");
    return NULL;
}    
memset(c, 0, sizeof(*c));		   //åˆå§‹0
 
if (configpath)
    c-&gt;config_path = strdup(configpath);			//config_path
else 
    c-&gt;config_path = strdup(lxc_global_config_value("lxc.lxcpath"));
 
if (!c-&gt;config_path) {
    fprintf(stderr, "Out of memory\n");
    goto err; 
}    
 
remove_trailing_slashes(c-&gt;config_path);
c-&gt;name = malloc(strlen(name)+1);
if (!c-&gt;name) {
    fprintf(stderr, "Error allocating lxc_container name\n");
    goto err; 
}    
strcpy(c-&gt;name, name);
 
c-&gt;numthreads = 1; 
 // lockè¿™éƒ¨åˆ†æ²¡ç»†çœ‹
if (!(c-&gt;slock = lxc_newlock(c-&gt;config_path, name))) {
    fprintf(stderr, "failed to create lock\n");
    goto err; 
}
 if (!(c-&gt;privlock = lxc_newlock(NULL, NULL))) {
    fprintf(stderr, "failed to alloc privlock\n");
    goto err;
}
 // set config path
 if (!set_config_filename(c)) {
    fprintf(stderr, "Error allocating config file pathname\n");
    goto err;
}
 //load config path
if (file_exists(c-&gt;configfile) &amp;&amp; !lxcapi_load_config(c, NULL))
    goto err;
 //åˆ¤æ–­å®¹å™¨æ˜¯å¦åˆ›å»ºå¤±è´¥
 if (ongoing_create(c) == 2) {
    ERROR("Error: %s creation was not completed", c-&gt;name);
    lxcapi_destroy(c);
    lxcapi_clear_config(c);
}
c-&gt;daemonize = true;
c-&gt;pidfile = NULL;
 â€¦â€¦ 				//åé¢éƒ½æ˜¯æˆå‘˜å‡½æ•°èµ‹å€¼ } ç°åœ¨å›åˆ°lxc_start çš„mainå‡½æ•°ä¸­ //åˆ¤æ–­å®¹å™¨æ˜¯å¦åœ¨è¿è¡Œ if (c-&gt;is_running(c)) {
    ERROR("Container is already running.");
    err = 0;
    goto out;  } /*         * We should use set_config_item() over &amp;defines, which would handle   * unset c-&gt;lxc_conf for us and let us not use lxc_config_define_load()   */ //åŠ è½½configæ–‡ä»¶  if (!c-&gt;lxc_conf)
 c-&gt;lxc_conf = lxc_conf_init();  conf = c-&gt;lxc_conf; if (lxc_config_define_load(&amp;defines, conf))
    goto out; //æç¤ºä¿¡æ¯ if (!rcfile &amp;&amp; !strcmp("/sbin/init", args[0])) {
    ERROR("Executing '/sbin/init' with no configuration file may crash the host");
    goto out;
}
 
if (ensure_path(&amp;conf-&gt;console.path, my_args.console) &lt; 0) {
    ERROR("failed to ensure console path '%s'", my_args.console);
    goto out;
}
 
if (ensure_path(&amp;conf-&gt;console.log_path, my_args.console_log) &lt; 0) {
    ERROR("failed to ensure console log '%s'", my_args.console_log);
    goto out;
}
// pid æ–‡ä»¶
if (my_args.pidfile != NULL) {
    if (ensure_path(&amp;c-&gt;pidfile, my_args.pidfile) &lt; 0) {
        ERROR("failed to ensure pidfile '%s'", my_args.pidfile);
        goto out;
    }
}
//ä¸€äº›share_ns çš„é…ç½®ï¼Œæœªç»†çœ‹
 int i;
for (i = 0; i &lt; LXC_NS_MAX; i++) {
    if (my_args.share_ns[i] == NULL)
        continue;
 
    int pid = pid_from_lxcname(my_args.share_ns[i], lxcpath);
    if (pid &lt; 1)
        goto out;
 
    int fd = open_ns(pid, ns_info[i].proc_name);
    if (fd &lt; 0)
        goto out;
    conf-&gt;inherit_ns_fd[i] = fd;
}
//åˆå§‹åŒ–ä¸º1
if (!my_args.daemonize) {
    c-&gt;want_daemonize(c, false);
}
 
if (my_args.close_all_fds)
    c-&gt;want_close_all_fds(c, true);
 
err = c-&gt;start(c, 0, args) ? 0 : 1;
 
if (err) {
    ERROR("The container failed to start.");
    if (my_args.daemonize)
        ERROR("To get more details, run the container in foreground mode.");
    ERROR("Additional information can be obtained by setting the "
          "--logfile and --logpriority options.");
    err = c-&gt;error_num;
    lxc_container_put(c);
    return err;
}
</code></pre></div></div>

<p>out:
    lxc_container_put(c);
    return err;
}
ç›´æ¥åˆ°c-&gt;start è¿‡ç¨‹startæ˜¯è°ƒç”¨ lxcapi_start è¿™ä¸ªå‡½æ•°æŒ‡é’ˆï¼Œç°åœ¨å»çœ‹ä¸‹è¿™ä¸ªå‡½æ•°åˆ°åº•æ˜¯æ€ä¹ˆè®²lxc container å¯åŠ¨èµ·æ¥çš„ã€‚</p>

<p>Â Â Â  ä¼ è¿‡æ¥çš„å‚æ•°æ˜¯container cï¼Œuseinit 0ï¼Œargv=args å³æŒ‡å®šçš„åˆå§‹åŒ–ç¨‹åº</p>

<p>static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])
{
    int ret;
    struct lxc_conf *conf;
    bool daemonize = false;				//å®ˆæŠ¤è¿›ç¨‹ä¸ºfalse
    FILE *pid_fp = NULL;				//pid_fileæ–‡ä»¶çš„æŒ‡é’ˆ
    char *default_args[] = {				//åˆæ˜¯default_args
        â€œ/sbin/initâ€,
        NULL,
    };</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* container exists */
if (!c)								//åˆ¤æ–­å®¹å™¨æ˜¯å¦å­˜åœ¨
    return false;
/* container has been setup */
if (!c-&gt;lxc_conf)						//configåŠ è½½å®Œç¾
    return false;
 
if ((ret = ongoing_create(c)) &lt; 0) {		//å®¹å™¨æ˜¯å¦åˆ›å»ºå®Œæ•´
    ERROR("Error checking for incomplete creation");
    return false;
}
if (ret == 2) {
    ERROR("Error: %s creation was not completed", c-&gt;name);
    c-&gt;destroy(c);
    return false;
} else if (ret == 1) {
    ERROR("Error: creation of %s is ongoing", c-&gt;name);
    return false;
}
 
 /* is this app meant to be run through lxcinit, as in lxc-execute? */
if (useinit &amp;&amp; !argv)					//è¿˜æ˜¯åˆ¤æ–­
    return false;
 
if (container_mem_lock(c))			//lock
    return false;
conf = c-&gt;lxc_conf;					//confèµ‹å€¼
daemonize = c-&gt;daemonize;			//true
container_mem_unlock(c);		//unlock
 
if (useinit) {						//0
    ret = lxc_execute(c-&gt;name, argv, 1, conf, c-&gt;config_path);
    return ret == 0 ? true : false;
}
 
if (!argv)
    argv = default_args;			//åˆé‡æ–°åˆ¤æ–­ args æ˜¯å¦ä¸ºç©ºï¼Œç©ºå³èµ‹å€¼
 /*
* say, I'm not sure - what locks do we want here?  Any?
* Is liblxc's locking enough here to protect the on disk
* container?  We don't want to exclude things like lxc_info
* while container is running...
 * è¿™æ®µæ³¨é‡Šç»™è·ªäº†ï¼Œè¿˜æ˜¯è€è€å®å®çœ‹ä»–æƒ³å¹²å˜›å§
*/
if (daemonize) {					//true
    lxc_monitord_spawn(c-&gt;config_path);	//startå¥½åƒè·Ÿå‰é¢çš„ç‰ˆæœ¬å·®åˆ«
 
    pid_t pid = fork();
    if (pid &lt; 0)
        return false;
 
    if (pid != 0) {
        /* Set to NULL because we don't want father unlink
         * the PID file, child will do the free and unlink.
         */
        c-&gt;pidfile = NULL;
        return wait_on_daemonized_start(c, pid);		//ç­‰ä¸‹è¿›å»ï¼Œé‡Œé¢æœ‰waitpidï¼Œæ‰€ä»¥å…ˆçœ‹åé¢
    }
 
    /* second fork to be reparented by init */
    pid = fork();										//ä¸¤æ¬¡fork
    if (pid &lt; 0) {
        SYSERROR("Error doing dual-fork");
        return false;
    }
    if (pid != 0)
        exit(0);
    /* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */
    if (chdir("/")) {									//rootç›®å½•
        SYSERROR("Error chdir()ing to /.");
        return false;
    }
    lxc_check_inherited(conf, -1);
    close(0);					//pipe file? close(1);
    close(2);
    open("/dev/zero", O_RDONLY);
    open("/dev/null", O_RDWR);
    open("/dev/null", O_RDWR);
    setsid();
} else {
    if (!am_single_threaded()) {
        ERROR("Cannot start non-daemonized container when threaded");
        return false;
    }
} /* We need to write PID file after daeminize, so we always
 * write the right PID.
 */
if (c-&gt;pidfile) {								//å†™å…¥pid åˆ°pidfile
    pid_fp = fopen(c-&gt;pidfile, "w");
    if (pid_fp == NULL) {
        SYSERROR("Failed to create pidfile '%s' for '%s'",
             c-&gt;pidfile, c-&gt;name);
        return false;
    }
 
    if (fprintf(pid_fp, "%d\n", getpid()) &lt; 0) {
        SYSERROR("Failed to write '%s'", c-&gt;pidfile);
        fclose(pid_fp);
        pid_fp = NULL;
        return false;
    }
 
    fclose(pid_fp);
    pid_fp = NULL;
}
</code></pre></div></div>

<p>reboot:
		â€¦..     			
}</p>

<p>ç°åœ¨åˆ° wait_on_daemonized_start(c, pid) é‡Œé¢çœ‹çœ‹å‡½æ•°è°ƒç”¨çš„æƒ…å†µ</p>

<p>è¿™ä¸ªå°±æ˜¯ä¸»çº¿ç¨‹çš„pid åœ¨ç­‰å¾…å…¶ä»–å­çº¿ç¨‹å·¥ä½œå®Œï¼Œç„¶åæ‰§è¡Œï¼Œåªèƒ½ç¡¬ç€å¤´çš®ç»§ç»­çœ‹äº†ã€‚</p>

<p>static bool wait_on_daemonized_start(struct lxc_container <em>c, int pid)
{
    /</em> weâ€™ll probably want to make this timeout configurable? */
    int timeout = 5, ret, status;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * our child is going to fork again, then exit.  reap the
 * child
 */
ret = waitpid(pid, &amp;status, 0);
if (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)
    DEBUG("failed waiting for first dual-fork child");
return lxcapi_wait(c, "RUNNING", timeout); } å‡½æ•°å¾ˆç®€å• ç›´æ¥è°ƒç”¨äº†lxcapi_waitã€‚
</code></pre></div></div>

<p>static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)
{
    int ret;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!c)
    return false;
 
ret = lxc_wait(c-&gt;name, state, timeout, c-&gt;config_path);
return ret == 0; }
</code></pre></div></div>

<p>è¿™ä¸ªä¾æ—§å¾ˆç®€å•åˆè·³èµ°äº†ã€‚ã€‚ã€‚lxc_waitäº†</p>

<p>è¿™ä¸ªå‡½æ•°ç°åœ¨å…ˆä¸ç»†è¯´äº†ï¼Œåªæ˜¯æ£€æŸ¥å®¹å™¨åˆ›å»ºæ˜¯å¦è¶…æ—¶çš„é—®é¢˜ã€‚</p>

<p>reboot:
Â  Â  conf-&gt;reboot = 0;
Â  Â  ret = lxc_start(c-&gt;name, argv, conf, c-&gt;config_path);
Â  Â  â€¦..
}
reboot åˆè°ƒç”¨lxc-start æ³ªå¥”ã€‚
int lxc_start(const char *name, char *const argv[], struct lxc_conf *conf,
Â  Â  Â  Â  Â  const char *lxcpath)
{
Â  Â  struct start_args start_arg = { //åˆæäº†ä¸€ä¸ªstart_argså®åœ¨ä¸æ‡‚
Â  Â  Â  Â  .argv = argv,
Â  Â  }; Â Â </p>

<p>Â  Â  if (lxc_check_inherited(conf, -1))Â 
Â  Â  Â  Â  return -1;</p>

<p>Â  Â  conf-&gt;need_utmp_watch = 1;Â 
Â  Â  return __lxc_start(name, conf, &amp;start_ops, &amp;start_arg, lxcpath); //okï¼Œå¹²ä¸Šäº†
}
My god æ„Ÿè§‰å¥½æˆæ‰åˆšåˆšå¼€å§‹ã€‚ã€‚ã€‚ã€‚
è¿™é‡Œé¢å°±æ˜¯lxc-startçš„å…¨éƒ¨ï¼Œæ‰€ä»¥åˆ†å¼€æ¥è®²ï¼Œå‰é¢çš„åºŸè¯å¤ªå¤šï¼Œè¿™æ¬¡çœ‹é‡ç‚¹
int __lxc_start(const char <em>name, struct lxc_conf *conf,
Â  Â  Â  Â  struct lxc_operations</em> ops, void *data, const char *lxcpath)
{
Â  Â  struct lxc_handler *handler; //ç»“æ„ä½“ï¼Œä¿å­˜containerçš„ä¸€äº›å±æ€§
Â  Â  int err = -1;
Â  Â  int status;
Â  Â  int netnsfd = -1;</p>

<p>handler = lxc_init(name, conf, lxcpath); //init
è¿™æ—¶å€™è¦è·³åˆ°initä¸­å»çœ‹çœ‹
struct lxc_handler *lxc_init(const char *name, struct lxc_conf *conf, const char *lxcpath)
{
Â  Â  struct lxc_handler *handler;</p>

<p>Â  Â  handler = malloc(sizeof(*handler)); //åˆå§‹åŒ–ä¸€å † handler
Â  Â  if (!handler)
Â  Â  Â  Â  return NULL;</p>

<p>Â  Â  memset(handler, 0, sizeof(*handler));</p>

<p>Â  Â  handler-&gt;conf = conf;
Â  Â  handler-&gt;lxcpath = lxcpath;
Â  Â  handler-&gt;pinfd = -1;</p>

<p>Â  Â  lsm_init();</p>

<p>handler-&gt;name = strdup(name);
if (!handler-&gt;name) {
Â  Â  Â  Â  ERROR(â€œfailed to allocate memoryâ€);
Â  Â  Â  Â  goto out_free;
Â  Â }
Â if (lxc_cmd_init(name, handler, lxcpath)) //cmd_init
Â  Â  Â  Â  goto out_free_name;
if (lxc_read_seccomp_config(conf) != 0) { //è¿™è´§ç›´æ¥è¿”å›0ï¼Œä»€ä¹ˆéƒ½æ²¡æœ‰
Â  Â  Â  Â ERROR(â€œfailed loading seccomp policyâ€);
Â  Â  Â goto out_close_maincmd_fd;
}
/* Begin by setting the state to STARTING <em>/
Â  Â  if (lxc_set_state(name, handler, STARTING)) { //STARTING enum ç±»å‹
Â  Â  Â  Â  ERROR(â€œfailed to set state â€˜%sâ€™â€, lxc_state2str(STARTING));
Â  Â  Â  Â  goto out_close_maincmd_fd;
Â  Â  }
/</em> Start of environment variable setup for hooks <em>/
Â  Â  if (setenv(â€œLXC_NAMEâ€, name, 1)) {
Â  Â  Â  Â  SYSERROR(â€œfailed to set environment variable for container nameâ€);
Â  Â  }
Â  Â  if (setenv(â€œLXC_CONFIG_FILEâ€, conf-&gt;rcfile, 1)) {
Â  Â  Â  Â  SYSERROR(â€œfailed to set environment variable for config pathâ€);
Â  Â  }
Â  Â  if (setenv(â€œLXC_ROOTFS_MOUNTâ€, conf-&gt;rootfs.mount, 1)) {
Â  Â  Â  Â  SYSERROR(â€œfailed to set environment variable for rootfs mountâ€);
Â  Â  }
Â  Â  if (setenv(â€œLXC_ROOTFS_PATHâ€, conf-&gt;rootfs.path, 1)) {
Â  Â  Â  Â  SYSERROR(â€œfailed to set environment variable for rootfs mountâ€);
Â  Â  }
Â  Â  if (conf-&gt;console.path &amp;&amp; setenv(â€œLXC_CONSOLEâ€, conf-&gt;console.path, 1)) {
Â  Â  Â  Â  SYSERROR(â€œfailed to set environment variable for console pathâ€);
Â  Â  }
Â  Â  if (conf-&gt;console.log_path &amp;&amp; setenv(â€œLXC_CONSOLE_LOGPATHâ€, conf-&gt;console.log_path, 1)) {
Â  Â  Â  Â  SYSERROR(â€œfailed to set environment variable for console logâ€);
}
Prestart åœ¨è¿™ä¸ªä½ç½®ï¼Œè¿™ä¸ªæ˜¯å¯ä»¥é…ç½®åˆ°configæ–‡ä»¶ä¸­çš„
/</em> End of environment variable setup for hooks <em>/
if (run_lxc_hooks(name, â€œpre-startâ€, conf, handler-&gt;lxcpath, NULL)) {
Â  Â  Â ERROR(â€œfailed to run pre-start hooks for container â€˜%sâ€™.â€, name);
Â  Â  Â goto out_aborting;
}
//åˆ›å»ºttyÂ 
if (lxc_create_tty(name, conf)) {
Â  Â  Â  Â  ERROR(â€œfailed to create the ttysâ€);
Â  Â  Â  Â  goto out_aborting;
}
è¿™ä¸ªå‡½æ•°æ‰“å¼€çš„æ˜¯/dev/ptmxè¿™ä¸ªä¸œè¥¿è¿˜ä¸æ˜¯å¾ˆäº†è§£ï¼Œå›å¤´ç»†çœ‹
å’Œpts æ˜¯ä¸»ä»è®¾å¤‡ï¼Œç„¶ååˆ†é…ptyï¼Ÿ
/</em> the signal fd has to be created before forking otherwise
Â  Â  Â * if the child process exits before we setup the signal fd,
Â  Â  Â * the event will be lost and the command will be stuck */
Â  Â  handler-&gt;sigfd = setup_signal_fd(&amp;handler-&gt;oldmask);
Â  Â  if (handler-&gt;sigfd &lt; 0) {
Â  Â  Â  Â  ERROR(â€œfailed to set sigchild fd handlerâ€);
Â  Â  Â  Â  goto out_delete_tty;
Â  Â  }</p>

<p>Â  Â  /* do this after setting up signals since it might unblock SIGWINCH */
Â  Â  if (lxc_console_create(conf)) {
Â  Â  Â  Â  ERROR(â€œfailed to create consoleâ€);
Â  Â  Â  Â  goto out_restore_sigmask;
Â  Â  }</p>

<p>Â  Â  if (ttys_shift_ids(conf) &lt; 0) {
Â  Â  Â  Â  ERROR(â€œFailed to shift tty into containerâ€);
Â  Â  Â  Â  goto out_restore_sigmask;
Â  Â  }</p>

<p>Â  Â  INFO(â€œâ€˜%sâ€™ is initializedâ€, name);
Â  Â  return handler;
}
Initå®Œæˆï¼Œå›åˆ°__lxc_startä¸­
if (!handler) {
Â  Â  Â  Â  ERROR(â€œfailed to initialize the containerâ€);
Â  Â  Â  Â  return -1;
Â  Â  }
Â  Â  handler-&gt;ops = ops;
Â  Â  handler-&gt;data = data;
// lxcæ˜¯å¦æ”¯æŒrebootï¼Œé…ç½®ä¸­handler-&gt;conf-&gt;need_utmp_watch=1è¡¨ç¤ºæ”¯æŒ
Â  Â  if (must_drop_cap_sys_boot(handler-&gt;conf)) {
Â  Â  Â  Â  #if HAVE_SYS_CAPABILITY_H
Â  Â  Â  Â  DEBUG(â€œDropping cap_sys_bootâ€);
Â  Â  Â  Â  #else
Â  Â  Â  Â  DEBUG(â€œCanâ€™t drop cap_sys_boot as capabilities arenâ€™t supportedâ€);
Â  Â  Â  Â  #endif
Â  Â  } else {
Â  Â  Â  Â  DEBUG(â€œNot dropping cap_sys_boot or watching utmpâ€);
Â  Â  Â  Â  handler-&gt;conf-&gt;need_utmp_watch = 0;
}
if (geteuid() == 0 &amp;&amp; !lxc_list_empty(&amp;conf-&gt;id_map)) { //effective uid
Â  Â  Â  Â  /* if the backing store is a device, mount it here and now */
Â  Â  Â  Â  if (rootfs_is_blockdev(conf)) {
Â  Â  Â  Â  Â  Â  if (unshare(CLONE_NEWNS) &lt; 0) {
Â  Â  Â  Â  Â  Â  Â  Â  ERROR(â€œError unsharing mountsâ€);
Â  Â  Â  Â  Â  Â  Â  Â  goto out_fini_nonet;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  remount_all_slave();
Â  Â  Â  Â  Â  Â  if (do_rootfs_setup(conf, name, lxcpath) &lt; 0) {
Â  Â  Â  Â  Â  Â  Â  Â  ERROR(â€œError setting up rootfs mount as root before spawnâ€);
Â  Â  Â  Â  Â  Â  Â  Â  goto out_fini_nonet;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  INFO(â€œSet up container rootfs as host rootâ€);
Â  Â  Â  Â  }
Â  Â  }
err = lxc_spawn(handler);
Â  Â  if (err) {
Â  Â  Â  Â  ERROR(â€œfailed to spawn â€˜%sâ€™â€, name);
Â  Â  Â  Â  goto out_fini_nonet;
}
Ok åˆä¸€ä¸ªspawnï¼Œè¿›å»çœ‹çœ‹
static int lxc_spawn(struct lxc_handler *handler)
{
Â  Â  int failed_before_rename = 0;
Â  Â  const char *name = handler-&gt;name;
Â  Â  bool cgroups_connected = false;
Â  Â  int saved_ns_fd[LXC_NS_MAX]; //LXC_NS_MAX
Â  Â  int preserve_mask = 0, i;
Â  Â  int netpipepair[2], nveths; //ç½‘ç»œç›¸å…³</p>

<p>Â  Â  netpipe = -1;
for (i = 0; i &lt; LXC_NS_MAX; i++)
Â  Â  Â  Â  if (handler-&gt;conf-&gt;inherit_ns_fd[i] != -1) //æš‚æ—¶å¿½ç•¥
Â  Â  Â  Â  Â  Â  preserve_mask |= ns_info[i].clone_flag;</p>

<p>Â  Â  if (lxc_sync_init(handler)) //åŒæ­¥socketpair
Â  Â  Â  Â  return -1;</p>

<p>Â  Â  handler-&gt;clone_flags = CLONE_NEWPID|CLONE_NEWNS;
Â  Â  if (!lxc_list_empty(&amp;handler-&gt;conf-&gt;id_map)) {//id_mapç©ºï¼Œåˆå§‹NEWUSER
Â INFO(â€œCloning a new user namespaceâ€);
Â  Â  Â  Â  handler-&gt;clone_flags |= CLONE_NEWUSER;
Â  Â  }
//è¿™é‡Œå¼€å§‹åˆ›å»ºNEWNETäº†
if (handler-&gt;conf-&gt;inherit_ns_fd[LXC_NS_NET] == -1) {
Â  Â  Â  Â  if (!lxc_requests_empty_network(handler))
Â  Â  Â  Â  Â  Â  handler-&gt;clone_flags |= CLONE_NEWNET;
Â  Â Â 
Â  Â  Â  Â  if (!lxc_list_empty(&amp;handler-&gt;conf-&gt;network)) {
Â  Â Â 
Â  Â  Â  Â  Â  Â  /* Find gateway addresses from the link device, which is
Â  Â  Â  Â  Â  Â  Â * no longer accessible inside the container. Do this
Â  Â  Â  Â  Â  Â  Â * before creating network interfaces, since goto
Â  Â  Â  Â  Â  Â  Â * out_delete_net does not work before lxc_clone. */
Â  Â  Â  Â  Â  Â  if (lxc_find_gateway_addresses(handler)) {
Â  Â  Â  Â  Â  Â  Â  Â  ERROR(â€œfailed to find gateway addressesâ€);
Â  Â  Â  Â  Â  Â  Â  Â  lxc_sync_fini(handler);
Â  Â  Â  Â  Â  Â  Â  Â  return -1;
Â  Â  Â  Â  Â  Â  }</p>

<p>Â  Â  Â  Â  Â  Â  /* that should be done before the clone because we will
Â  Â  Â  Â  Â  Â  Â * fill the netdev index and use them in the child
Â  Â  Â  Â  Â  Â  Â */
Â  Â  Â  Â  Â  Â  if (lxc_create_network(handler)) {
Â  Â  Â  Â  Â  Â  Â  Â  ERROR(â€œfailed to create the networkâ€);
Â  Â  Â  Â  Â  Â  Â  Â  lxc_sync_fini(handler);
Â  Â  Â  Â  Â  Â  Â  Â  return -1;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
if (save_phys_nics(handler-&gt;conf)) { //save phys nics
Â  Â  Â  Â  Â  Â  ERROR(â€œfailed to save physical nic infoâ€);
Â  Â  Â  Â  Â  Â  goto out_abort;
Â  Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  Â  INFO(â€œInheriting a net namespaceâ€);
Â  Â  }
if (handler-&gt;conf-&gt;inherit_ns_fd[LXC_NS_IPC] == -1) { //NS_IPC
Â  Â  Â  Â  handler-&gt;clone_flags |= CLONE_NEWIPC;
Â  Â  } else {
Â  Â  Â  Â  INFO(â€œInheriting an IPC namespaceâ€);
Â  Â  }</p>

<p>Â  Â  if (handler-&gt;conf-&gt;inherit_ns_fd[LXC_NS_UTS] == -1) { //NS_UTS
Â  Â  Â  Â  handler-&gt;clone_flags |= CLONE_NEWUTS;
Â  Â  } else {
Â  Â  Â  Â  INFO(â€œInheriting a UTS namespaceâ€);
Â  Â  }
if (!cgroup_init(handler)) { //init cgroup
Â  Â  Â  Â  ERROR(â€œfailed initializing cgroup supportâ€);
Â  Â  Â  Â  goto out_delete_net;
Â  Â  }
//è¿™é‡Œopsä¸€ç›´ä¸ºç©ºï¼Œæäº†åŠå¤©ä¸çŸ¥é“æ˜¯æ€ä¹ˆåˆå§‹åŒ–opsçš„
//<strong>attribute</strong>((constructor))å¾ˆå¤§å¯èƒ½æ˜¯è¿™ä¸ª
Â  Â  cgroups_connected = true;</p>

<p>Â  Â  if (!cgroup_create(handler)) { 
Â  Â  Â  Â  ERROR(â€œfailed creating cgroupsâ€);
Â  Â  Â  Â  goto out_delete_net;
Â  Â  }
/*
Â  Â  Â * if the rootfs is not a blockdev, prevent the container from
Â  Â  Â * marking it readonly.
Â  Â  Â *
Â  Â  Â * if the container is unprivileged then skip rootfs pinning
Â  Â  Â <em>/
Â  Â  if (lxc_list_empty(&amp;handler-&gt;conf-&gt;id_map)) { //åˆšæ‰æ˜¯ç©ºï¼Ÿ
Â  Â  Â  Â  handler-&gt;pinfd = pin_rootfs(handler-&gt;conf-&gt;rootfs.path);
Â  Â  Â  Â  if (handler-&gt;pinfd == -1)
Â  Â  Â  Â  Â  Â  INFO(â€œfailed to pin the containerâ€™s rootfsâ€);
Â  Â  }
if (preserve_ns(saved_ns_fd, preserve_mask) &lt; 0) //æ‰“å¼€/prco/self/nsä¸‹é¢çš„ä¸œè¥¿
Â  Â  Â  Â  goto out_delete_net;
Â  Â  if (attach_ns(handler-&gt;conf-&gt;inherit_ns_fd) &lt; 0) //
Â  Â  Â  Â  goto out_delete_net;
//ä¸‹é¢æ˜¯åˆ›å»ºç½‘ç»œçš„pipe?
Â  Â  if (am_unpriv() &amp;&amp; (nveths = count_veths(&amp;handler-&gt;conf-&gt;network))) {
Â  Â  Â  Â  if (pipe(netpipepair) &lt; 0) {
Â  Â  Â  Â  Â  Â  SYSERROR(â€œError creating pipeâ€);
Â  Â  Â  Â  Â  Â  goto out_delete_net;
Â  Â  Â  Â  }
Â  Â  Â  Â  /</em> store netpipe in the global var for do_startâ€™s use <em>/
Â  Â  Â  Â  netpipe = netpipepair[0];
Â  Â  }
/</em> Create a process in a new set of namespaces */
Â  Â  handler-&gt;pid = lxc_clone(do_start, handler, handler-&gt;clone_flags);
Â  Â  if (handler-&gt;pid &lt; 0) {
Â  Â  Â  Â  SYSERROR(â€œfailed to fork into a new namespaceâ€);
Â  Â  Â  Â  goto out_delete_net;
my god lxc_clone åˆè¦è·³äº†ã€‚ã€‚ã€‚
é¦–å…ˆçœ‹ä¸‹ä¼ é€’çš„å‚æ•°å§
do_startå‡½æ•°æŒ‡é’ˆ ï¼Œhandlerï¼Œ handler-&gt;clone_flagsï¼Œä¸€å †NSçš„è®¾ç½®
ç®€è¿°ä¸‹lxc_cloneå‡½æ•°é‡Œé¢çš„æµç¨‹
æŒ‡å®šä¸€é¡µå†…å­˜å¤§å°åšä¸ºå­è¿›ç¨‹çš„æ ˆç©ºé—´ï¼Œç„¶åè°ƒç”¨ç³»ç»Ÿçš„clone è¿›è¡Œcloneï¼Œå›å¤´å¼€ä¸€ç« è¯´é‡Œé¢çš„ä¸€äº›å‡½æ•°è°ƒç”¨ã€‚
ret = clone(do_clone, stack Â + stack_size, flags | SIGCHLD, &amp;clone_arg);
static int do_clone(void *arg)
{
Â  Â  struct clone_arg *clone_arg = arg;
Â  Â  return clone_arg-&gt;fn(clone_arg-&gt;arg);
}
Do_cloneé‡Œè°ƒç”¨åˆšæ‰çš„cloneçš„æŒ‡é’ˆdo_start
Okï¼Œåˆ°do_startä¸­å»çœ‹ï¼Œ
static int do_start(void *data)
{
Â  Â  struct lxc_handler *handler = data;
Â  Â  const char *lsm_label = NULL;</p>

<p>Â  Â  if (sigprocmask(SIG_SETMASK, &amp;handler-&gt;oldmask, NULL)) {
Â  Â  Â  Â  SYSERROR(â€œfailed to set sigprocmaskâ€);
Â  Â  Â  Â  return -1;
Â  Â  }</p>

<p>Â  Â  Â  Â  /* This prctl must be before the synchro, so if the parent
Â  Â  Â * dies before we set the parent death signal, we will detect
Â  Â  Â * its death with the synchro right after, otherwise we have
Â  Â  Â * a window where the parent can exit before we set the pdeath
Â  Â  Â * signal leading to a unsupervized container.
Â  Â  Â */
Â  Â  if (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0)) { //å’Œå‰é¢çš„prctlä¸€æ ·
Â  Â  Â  Â  SYSERROR(â€œfailed to set pdeath signalâ€);
Â  Â  Â  Â  return -1;
Â  Â  }</p>

<p>lxc_sync_fini_parent(handler);
/* donâ€™t leak the pinfd to the container */
Â  Â  if (handler-&gt;pinfd &gt;= 0) {
Â  Â  Â  Â  close(handler-&gt;pinfd);
Â  Â  }</p>

<p>Â  Â  /* Tell the parent task it can begin to configure the
Â  Â  Â * container and wait for it to finish
Â  Â  Â <em>/
Â  Â  if (lxc_sync_barrier_parent(handler, LXC_SYNC_CONFIGURE))
Â  Â  Â  Â  return -1;
Â  Â  Â  Â Â 
Â  Â  if (read_unpriv_netifindex(&amp;handler-&gt;conf-&gt;network) &lt; 0)
Â  Â  Â  Â  goto out_warn_father;
/</em>
Â  Â  Â * if we are in a new user namespace, become root there to have
Â  Â  Â * privilege over our namespace
Â  Â  Â <em>/
Â  Â  if (!lxc_list_empty(&amp;handler-&gt;conf-&gt;id_map)) { //è®¾ç½®gid uidã€‚ã€‚
Â  Â  Â  Â  NOTICE(â€œswitching to gid/uid 0 in new user namespaceâ€);
Â  Â  Â  Â  if (setgid(0)) {
Â  Â  Â  Â  Â  Â  SYSERROR(â€œsetgidâ€);
Â  Â  Â  Â  Â  Â  goto out_warn_father;
Â  Â  Â  Â  }
Â  Â  Â  Â  if (setuid(0)) {
Â  Â  Â  Â  Â  Â  SYSERROR(â€œsetuidâ€);
Â  Â  Â  Â  Â  Â  goto out_warn_father;
Â  Â  Â  Â  }
Â  Â  Â  Â  if (setgroups(0, NULL)) {
Â  Â  Â  Â  Â  Â  SYSERROR(â€œsetgroupsâ€);
Â  Â  Â  Â  Â  Â  goto out_warn_father;
Â  Â  Â  Â  }
Â  Â  }
#if HAVE_SYS_CAPABILITY_H //è¿™ä¸ªè·Ÿç¼–è¯‘æ—¶å€™æœ‰å…³ï¼Œconfigä¸­ä¹Ÿæœ‰ä¸€æ¡
Â  Â  if (handler-&gt;conf-&gt;need_utmp_watch) {
Â  Â  Â  Â  if (prctl(PR_CAPBSET_DROP, CAP_SYS_BOOT, 0, 0, 0)) {
Â  Â  Â  Â  Â  Â  SYSERROR(â€œfailed to remove CAP_SYS_BOOT capabilityâ€);
Â  Â  Â  Â  Â  Â  goto out_warn_father;
Â  Â  Â  Â  }
Â  Â  Â  Â  DEBUG(â€œDropped cap_sys_bootâ€);
Â  Â  }
#endif
/</em> Setup the container, ip, names, utsname, â€¦ <em>/
Â  Â  if (lxc_setup(handler)) { //ç»ˆäºè¦é…ç½®containeräº†
Â  Â  Â  Â  ERROR(â€œfailed to setup the containerâ€);
Â  Â  Â  Â  goto out_warn_father;
Â  Â  }
Setupçš„ä»£ç å°±ä¸æ”¾å‡ºæ¥äº†ï¼Œä¸»è¦çš„å‡½æ•°è´´ä¸Šæ¥ã€‚
setup_utsname(lxc_conf-&gt;utsname)
setup_network(&amp;lxc_conf-&gt;network)
run_lxc_hooks(name, â€œpre-mountâ€, lxc_conf)
setup_rootfs(lxc_conf)
if (lxc_conf-&gt;autodev) mount_autodev(lxc_conf-&gt;rootfs.mount)
setup_mount(&amp;lxc_conf-&gt;rootfs, lxc_conf-&gt;fstab, name)
run_lxc_hooks(name, â€œmountâ€, lxc_conf)
if (lxc_conf-&gt;autodev) {
run_lxc_hooks(name, â€œautodevâ€, lxc_conf)
setup_autodev(lxc_conf-&gt;rootfs.mount) }
setup_console(&amp;lxc_conf-&gt;rootfs, &amp;lxc_conf-&gt;console, lxc_conf-&gt;ttydir)
setup_tty(&amp;lxc_conf-&gt;rootfs, &amp;lxc_conf-&gt;tty_info, lxc_conf-&gt;ttydir)
setup_pivot_root(&amp;lxc_conf-&gt;rootfs)
setup_pts(lxc_conf-&gt;pts)
setup_personality(lxc_conf-&gt;personality)
setup_caps(&amp;lxc_conf-&gt;caps)
åé¢å†å¥½å¥½çš„ç ”ç©¶ï¼Œå…ˆæŠŠæ­¥éª¤ç†æ¸…ã€‚ä¸‹é¢å‡ ä¸ªå…ˆçœ‹æ³¨é‡Šäº†ã€‚
/</em> ask father to setup cgroups and wait for him to finish */
Â  Â  if (lxc_sync_barrier_parent(handler, LXC_SYNC_CGROUP))
Â  Â  Â  Â  return -1;</p>

<p>Â  Â  /* Set the label to change to when we exec(2) the containerâ€™s init <em>/
Â  Â  if (!strcmp(lsm_name(), â€œAppArmorâ€))
Â  Â  Â  Â  lsm_label = handler-&gt;conf-&gt;lsm_aa_profile;
Â  Â  else if (!strcmp(lsm_name(), â€œSELinuxâ€))
Â  Â  Â  Â  lsm_label = handler-&gt;conf-&gt;lsm_se_context;
Â  Â  if (lsm_process_label_set(lsm_label, 1, 1) &lt; 0)
Â  Â  Â  Â  goto out_warn_father;
/</em> Some initâ€™s such as busybox will set sane tty settings on stdin,
Â  Â  Â * stdout, stderr which it thinks is the console. We already set them
Â  Â  Â * the way we wanted on the real terminal, and we want init to do its
Â  Â  Â * setup on its console ie. the pty allocated in lxc_console_create()
Â  Â  Â * so make sure that that pty is stdin,stdout,stderr.
Â  Â  Â */
Â  Â  if (lxc_console_set_stdfds(handler) &lt; 0)
Â  Â  Â  Â  goto out_warn_father;</p>

<p>Â  Â  /* If we mounted a temporary proc, then unmount it now */
tmp_proc_unmount(handler-&gt;conf);
if (lxc_seccomp_load(handler-&gt;conf) != 0)
Â  Â  Â  Â  goto out_warn_father;</p>

<p>Â  Â  if (run_lxc_hooks(handler-&gt;name, â€œstartâ€, handler-&gt;conf, handler-&gt;lxcpath, NULL)) {
Â  Â  Â  Â  ERROR(â€œfailed to run start hooks for container â€˜%sâ€™.â€, handler-&gt;name);
Â  Â  Â  Â  goto out_warn_father;
Â  Â  }
/* The clearenv() and putenv() calls have been moved here
Â  Â  Â * to allow us to use environment variables passed to the various
Â  Â  Â * hooks, such as the start hook above. Â Not all of the
Â  Â  Â * variables like CONFIG_PATH or ROOTFS are valid in this
Â  Â  Â * context but others are. <em>/
Â  Â  if (clearenv()) {
Â  Â  Â  Â  SYSERROR(â€œfailed to clear environmentâ€);
Â  Â  Â  Â  /</em> donâ€™t error out though */
Â  Â  } Â  Â </p>

<p>Â  Â  if (putenv(â€œcontainer=lxcâ€)) {
Â  Â  Â  Â  SYSERROR(â€œfailed to set environment variableâ€);
Â  Â  Â  Â  goto out_warn_father;
Â  Â  } Â  Â </p>

<p>Â  Â  close(handler-&gt;sigfd);</p>

<p>Â  Â  /* after this call, we are in error because this
Â  Â  Â * ops should not return as it execs <em>/
Â  Â  handler-&gt;ops-&gt;start(handler, handler-&gt;data); //çœ‹æ€ä¹ˆè·³å›å»
handleråœ¨lxc_start è·³åˆ°__lxc_start çš„æ—¶å€™å°±ç»™opsçš„start èµ‹å€¼å‡½æ•°æŒ‡é’ˆstartäº†ï¼Œå› æ­¤ç›´æ¥è·³åˆ°startå‡½æ•°ä¸­ã€‚
static int start(struct lxc_handler *handler, void</em> data)
{
Â  Â  struct start_args *arg = data;</p>

<p>Â  Â  NOTICE(â€œexecâ€™ing â€˜%sâ€™â€, arg-&gt;argv[0]);</p>

<p>Â  Â  execvp(arg-&gt;argv[0], arg-&gt;argv);
Â  Â  SYSERROR(â€œfailed to exec %sâ€, arg-&gt;argv[0]);
Â  Â  return 0;
}
è¿™é‡Œé¢å¼€å§‹æ‰§è¡Œå®¹å™¨çš„rootfsä¸‹é¢çš„ç¬¬ä¸€ä¸ªå¯åŠ¨é€‰é¡¹ï¼Œdefault_argsæ˜¯/sbin/initï¼Œå¯ä»¥åœ¨startçš„æ—¶å€™æŒ‡å®šã€‚
Ok ä»cloneä¸­å›åˆ° lxc_spawnè¿™ä¸ªä¸­çœ‹åé¢æ€ä¹ˆæ‰§è¡Œçš„ã€‚
if (attach_ns(saved_ns_fd))
Â  Â  Â  Â  WARN(â€œfailed to restore saved namespacesâ€);</p>

<p>Â  Â  lxc_sync_fini_child(handler);
//ä¸€äº›cgroupçš„é…ç½®ï¼Œå°†å¯¹ç”¨çš„namespaceå†™å…¥cgroupä¸­
Â  Â  if (lxc_sync_wait_child(handler, LXC_SYNC_CONFIGURE))
Â  Â  Â  Â  failed_before_rename = 1;
if (!cgroup_create_legacy(handler)) {
Â  Â  Â  Â  ERROR(â€œfailed to setup the legacy cgroups for %sâ€, name);
Â  Â  Â  Â  goto out_delete_net;
Â  Â  }
Â  Â  if (!cgroup_setup_limits(handler, false)) {
Â  Â  Â  Â  ERROR(â€œfailed to setup the cgroup limits for â€˜%sâ€™â€, name);
Â  Â  Â  Â  goto out_delete_net;
Â  Â  }
Â  Â  Â  Â Â 
Â  Â  if (!cgroup_enter(handler))
Â  Â  Â  Â  goto out_delete_net;
Â  Â Â 
Â  Â  if (!cgroup_chown(handler))Â 
Â  Â  Â  Â  goto out_delete_net;
Â  Â Â 
Â  Â  if (failed_before_rename)
Â  Â  Â  Â  goto out_delete_net;
//ç½‘ç»œé…ç½®
/* Create the network configuration */
Â  Â  if (handler-&gt;clone_flags &amp; CLONE_NEWNET) {
Â  Â  Â  Â  if (lxc_assign_network(&amp;handler-&gt;conf-&gt;network, handler-&gt;pid)) {
Â  Â  Â  Â  Â  Â  ERROR(â€œfailed to create the configured networkâ€);
Â  Â  Â  Â  Â  Â  goto out_delete_net;
Â  Â  Â  Â  }
Â  Â  }</p>

<p>Â  Â  if (netpipe != -1) {
Â  Â  Â  Â  struct lxc_list <em>iterator;
Â  Â  Â  Â  struct lxc_netdev *netdev;
Â  Â Â 
Â  Â  Â  Â  close(netpipe);
Â  Â  Â  Â  lxc_list_for_each(iterator, &amp;handler-&gt;conf-&gt;network) {
Â  Â  Â  Â  Â  Â  netdev = iterator-&gt;elem;
Â  Â  Â  Â  Â  Â  if (netdev-&gt;type != LXC_NET_VETH)
Â  Â  Â  Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  Â  Â  if (write(netpipepair[1], netdev-&gt;name, IFNAMSIZ) != IFNAMSIZ) {
Â  Â  Â  Â  Â  Â  Â  Â  ERROR(â€œError writing veth name to containerâ€);
Â  Â  Â  Â  Â  Â  Â  Â  goto out_delete_net;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  close(netpipepair[1]);
}
/</em> map the container uids - the container became an invalid
Â  Â  Â * userid the moment it was cloned with CLONE_NEWUSER - this
Â  Â  Â * call doesnâ€™t change anything immediately, but allows the
Â  Â  Â * container to setuid(0) (0 being mapped to something else on
Â  Â  Â * the host) later to become a valid uid again */
Â  Â  if (lxc_map_ids(&amp;handler-&gt;conf-&gt;id_map, handler-&gt;pid)) {
Â  Â  Â  Â  ERROR(â€œfailed to set up id mappingâ€);
Â  Â  Â  Â  goto out_delete_net;
Â  Â  }</p>

<p>Â  Â  /* Tell the child to continue its initialization. Â weâ€™ll get
Â  Â  Â * LXC_SYNC_CGROUP when it is ready for us to setup cgroups
Â  Â  Â */
Â  Â  if (lxc_sync_barrier_child(handler, LXC_SYNC_POST_CONFIGURE))
Â  Â  Â  Â  goto out_delete_net;</p>

<p>Â  Â  if (!cgroup_setup_limits(handler, true)) {
Â  Â  Â  Â  ERROR(â€œfailed to setup the devices cgroup for â€˜%sâ€™â€, name);
Â  Â  Â  Â  goto out_delete_net;
Â  Â  }</p>

<p>Â  Â  cgroup_disconnect();
Â  Â  cgroups_connected = false;
/* Tell the child to complete its initialization and wait for
Â  Â  Â * it to exec or return an error. Â (the child will never
Â  Â  Â * return LXC_SYNC_POST_CGROUP+1. Â It will either close the
Â  Â  Â * sync pipe, causing lxc_sync_barrier_child to return
Â  Â  Â * success, or return a different value, causing us to error
Â  Â  Â * out).
Â  Â  Â */
Â  Â  if (lxc_sync_barrier_child(handler, LXC_SYNC_POST_CGROUP))
Â  Â  Â  Â  return -1;</p>

<p>Â  Â  if (detect_shared_rootfs())
Â  Â  Â  Â  umount2(handler-&gt;conf-&gt;rootfs.mount, MNT_DETACH);</p>

<p>Â  Â  if (handler-&gt;ops-&gt;post_start(handler, handler-&gt;data)) //post_startä»€ä¹ˆä¹Ÿæ²¡å¹²ï¼Œå°±èµ‹å€¼ï¼Œç›´æ¥returnäº†
Â  Â  Â  Â  goto out_abort;</p>

<p>Â  Â  if (lxc_set_state(name, handler, RUNNING)) {
Â  Â  Â  Â  ERROR(â€œfailed to set state to %sâ€,
Â  Â  Â  Â  Â  Â  Â  Â  Â  lxc_state2str(RUNNING));
Â  Â  Â  Â  goto out_abort;
Â  Â  }</p>

<p>Â  Â  lxc_sync_fini(handler);</p>

<p>Â  Â  return 0;
ç°åœ¨spawå‡½æ•°ç»“æŸï¼Œå¾ˆå¤šç»†èŠ‚éƒ½æ²¡çœ‹ï¼Œé‡Œé¢æ¯ä¸ªåœ°æ–¹ä¼°è®¡éƒ½è¦çœ‹å¾ˆä¹…ï¼Œå…ˆæŠŠæ¡ä¸‹æµç¨‹å§ã€‚
netnsfd = get_netns_fd(handler-&gt;pid);</p>

<p>Â  Â  err = lxc_poll(name, handler);
Â  Â  if (err) {
Â  Â  Â  Â  ERROR(â€œmainloop exited with an errorâ€);
Â  Â  Â  Â  if (netnsfd &gt;= 0)
Â  Â  Â  Â  Â  Â  close(netnsfd);
Â  Â  Â  Â  goto out_abort;
Â  Â  }
åˆæ¥äº†ä¸€ä¸ªpollå‡½æ•°
çœ‹çœ‹pollåšäº†ä»€ä¹ˆ
è°ƒç”¨epoll_createç”¨äºé€šä¿¡
lxc_mainloop_open(&amp;descr)
æ³¨å†Œå„ç§epolläº‹ä»¶
lxc_mainloop_add_handler(&amp;descr, sigfd, signal_handler, &amp;pid)
lxc_console_mainloop_add(&amp;descr, handler)
lxc_command_mainloop_add(name, &amp;descr, handler)
if (handler-&gt;conf-&gt;need_utmp_watch) lxc_utmp_mainloop_add(&amp;descr, handler)
æœ€åè¿”å›çš„æ—¶å€™åˆè°ƒç”¨äº†lxc_mainloop(&amp;descr)
while (waitpid(handler-&gt;pid, &amp;status, 0) &lt; 0 &amp;&amp; errno == EINTR)
Â  Â  Â  Â  continue;</p>

<p>Â  Â  /*
Â  Â  Â * If the child process exited but was not signaled,
Â  Â  Â * it didnâ€™t call reboot. Â This should mean it was an
Â  Â  Â * lxc-execute which simply exited. Â In any case, treat
Â  Â  Â * it as a â€˜haltâ€™
Â  Â  Â <em>/
Â  Â  Â  Â  if (WIFSIGNALED(status)) {
Â  Â  Â  Â  switch(WTERMSIG(status)) {
Â  Â  Â  Â  case SIGINT: /</em> halt <em>/
Â  Â  Â  Â  Â  Â  DEBUG(â€œContainer haltingâ€);
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  case SIGHUP: /</em> reboot <em>/
Â  Â  Â  Â  Â  Â  DEBUG(â€œContainer rebootingâ€);
Â  Â  Â  Â  Â  Â  handler-&gt;conf-&gt;reboot = 1;
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  case SIGSYS: /</em> seccomp */
Â  Â  Â  Â  Â  Â  DEBUG(â€œContainer violated its seccomp policyâ€);
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  default:
Â  Â  Â  Â  Â  Â  DEBUG(â€œunknown exit status for init: %dâ€, WTERMSIG(status));
Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  }
Â  Â  Â  Â  }</p>

<p>Â  Â  lxc_rename_phys_nics_on_shutdown(netnsfd, handler-&gt;conf);
Â  Â  if (netnsfd &gt;= 0)
Â  Â  Â  Â  close(netnsfd);</p>

<p>Â  Â  if (handler-&gt;pinfd &gt;= 0) {
Â  Â  Â  Â  close(handler-&gt;pinfd);
Â  Â  Â  Â  handler-&gt;pinfd = -1;
}</p>

<p>Â  Â  lxc_monitor_send_exit_code(name, status, handler-&gt;lxcpath);
Â  Â  err = Â lxc_error_set_and_log(handler-&gt;pid, status);
}</p>

<p>1ã€é¦–å…ˆå°±æ˜¯ç¬¬ä¸€ä¸ªlxc_check_inheritedå‡½æ•°</p>

<p>dir = opendir(â€œ/proc/self/fdâ€);</p>

<p>Â Â Â  if (!dir) {</p>

<p>Â Â Â Â Â Â Â  WARN(â€œfailed to opendirectory: %mâ€);</p>

<p>Â Â Â Â Â Â Â  return -1;</p>

<p>}</p>

<p>æ­¤å‡½æ•°æ˜¯æ ¹æ®é…ç½®å°†/proc/self/fdä¸‹ï¼Œå…³é—­fdã€‚</p>

<p>ç„¶åå°±è·³åˆ°__lxc_startä¸­</p>

<p>2ã€çœ‹ä¸‹lxc-init</p>

<p>åœ¨initä¸­ è®¾ç½®ä¸€äº›å…³äºLXC_XXXçš„ç¯å¢ƒå˜é‡ï¼ŒçŒœæµ‹ç”¨äºåé¢çš„ä½¿ç”¨ã€‚</p>

<p>å¯ä»¥å†lxcå¯åŠ¨çš„æ—¶å€™åŠ ä¸€äº›è„šæœ¬ã€‚</p>

<p>ä¼šåœ¨hookä¸­å…ˆæ‰§è¡Œpre-startçš„å‰ç¼€çš„è„šæœ¬</p>

<p>if (run_lxc_hooks(name, â€œpre-startâ€, conf,handler-&gt;lxcpath, NULL)) {</p>

<p>Â Â Â Â Â Â Â  ERROR(â€œfailed to runpre-start hooks for container â€˜%sâ€™.â€, name);</p>

<p>Â Â Â Â Â Â Â  goto out_aborting;</p>

<p>}</p>

<p>ç»§ç»­ï¼Œåé¢æœ‰è°ƒç”¨lxc_create_ttyï¼Œç»†è‡´ç ”ç©¶å‘ç°ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯æ ¹æ®confä¸­è®¾ç½®ttyçš„ä¸ªæ•°ï¼Œé€šè¿‡openttyå‡½æ•°æ¥åˆ›å»ºptsç»™å®¹å™¨ä½¿ç”¨ã€‚</p>

<p>ret = openpty(&amp;pty_info-&gt;master, &amp;pty_info-&gt;slave,pty_info-&gt;name,NULL, NULL);</p>

<p>è¿™ä¸ªå¯ä»¥å†configæ–‡ä»¶ä¸­è®¾ç½®ttyçš„ä¸ªæ•°</p>

<p>ttyçš„ä½œç”¨æ˜¯ï¼Œå¦‚æœå®¹å™¨é…ç½®äº†æ ¹æ–‡ä»¶ç³»ç»Ÿå’Œinittabæ–‡ä»¶è®¾ç½®å¯åŠ¨getttyï¼ŒåŒæ—¶åœ¨inittabä¸­getttyçš„ä¸ªæ•°ä¸èƒ½è¶…è¿‡è®¾ç½®çš„ttyçš„ä¸ªæ•°ï¼Œå¦åˆ™ä¼šå‡ºé—®é¢˜</p>

<p>åŒç† lxc_console_create ä¹Ÿæ˜¯ä¸€æ ·</p>

<p>å¦‚æœå®¹å™¨é…ç½®äº†æ ¹æ–‡ä»¶ç³»ç»Ÿå’Œinittabæ–‡ä»¶è®¾ç½®ä½¿ç”¨æ§åˆ¶å°,æ‚¨å¯èƒ½å¸Œæœ›æŒ‡å®šè¯¥æ§åˆ¶å°çš„è¾“å‡ºã€‚å¯ä»¥åœ¨configä¸­è®¾ç½®lxc.console.logfileæ¥æŒ‡å®šè¾“å‡ºçš„ä½ç½®ï¼Œlxc.consoleæŒ‡å®šconsoleçš„ä¸ªæ•°</p>

<p>ç„¶åé€šè¿‡ttys_shift_idsæ¥è®¾ç½®ttyçš„ownerã€‚</p>

<p>è¿™æ ·initçš„åˆå§‹åŒ–è¿‡ç¨‹å°±ç»“æŸäº†ã€‚</p>

<p>3ã€ç„¶ååˆ°must_drop_cap_sys_boot(handler-&gt;conf)è¿™ä¸ªæ­¥éª¤ä¸­ã€‚</p>

<p>è¿™ä¸ªå‡½æ•°ä¼šè¯»ç³»ç»Ÿä¸­/proc/sys/kernel/ctrl-alt-delè¿™ä¸ªæ–‡ä»¶ï¼Œåˆ¤æ–­ç¡®å®šcmdçš„å‘½ä»¤ï¼Œcmd = v ?LINUX_REBOOT_CMD_CAD_ON : LINUX_REBOOT_CMD_CAD_OFF;</p>

<p>ç„¶åä¼šç³»ç»Ÿè°ƒç”¨cloneï¼Œå…¶ä¸­å‡½æ•°æŒ‡é’ˆä¸ºcontainer_reboot_supportedï¼Œæœ€ç»ˆä¼šè°ƒç”¨rebootè¿™ä¸ªå‡½æ•°ï¼Œ</p>

<p>é€šè¿‡man rebootå¯ä»¥çœ‹åˆ°ç»†èŠ‚</p>

<p>LINUX_REBOOT_CMD_CAD_OFF</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â (RB_DISABLE_CAD,Â  0).Â Â  CADÂ isÂ  disabled.Â Â  ThisÂ meansÂ  thatÂ  the CAD keystroke will cause a SIGINT signalto be sent to init</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â  (process 1),whereupon this process may decide upon a proper action (maybe: kill allprocesses, sync, reboot).</p>

<p>Â </p>

<p>Â Â Â Â Â Â  LINUX_REBOOT_CMD_CAD_ON</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â  (RB_ENABLE_CAD,0x89abcdef).Â  CAD is enabled.Â  This means that the CAD keystroke willimmediately cause theÂ  actionÂ  associated</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â  withLINUX_REBOOT_CMD_RESTART.</p>

<p>é‚£ä¹ˆï¼Œé—®é¢˜æ¥äº†ï¼Œåˆ°åº•rebootä»€ä¹ˆä¸œè¥¿ï¼Œç³»ç»Ÿï¼Ÿè¿˜æ˜¯containerï¼Ÿä¸€ä¸ªå·²ç»å¯åŠ¨ï¼Œä¸€ä¸ªæ­£åœ¨startè¿‡ç¨‹ã€‚</p>

<table>
  <tbody>
    <tr>
      <td>æš‚æ—¶è¿˜æ²¡ææ‡‚ï¼Œæ˜¯ä¸æ˜¯NEWPID</td>
      <td>NEWUSER å¯åŠ¨çš„æ–°çš„namespaceçš„ç©ºé—´ä¸­çš„ä¸œè¥¿ï¼Œå¯èƒ½å‘SIGINTä¿¡å·ç»™ä¸»æœºçš„initçš„è¿›ç¨‹ã€‚å°†ä»¥å‰å¯åŠ¨çš„containerå‰©ä½™çš„éƒ¨åˆ†é‡æ–°å¯åŠ¨ï¼Ÿå…ˆmarkä¸€ä¸‹ã€‚</td>
    </tr>
  </tbody>
</table>

<p>4ã€ç„¶ååˆ¤æ–­if (geteuid() == 0&amp;&amp; !lxc_list_empty(&amp;conf-&gt;id_map))ï¼Œid_mapæ˜¯ç©ºçš„ï¼Œå› ä¸ºç›®å‰æ‰€æœ‰çš„çš„æµç¨‹ï¼Œéƒ½æ˜¯ä»¥privilegecontainerè¯´çš„ï¼Œæ‰€æœ‰érootçš„ç”¨æˆ·å°±ä¸åˆ†æäº†ã€‚</p>

<p>æ£€æŸ¥rootfs_is_blockdev(conf) æ„Ÿè§‰å‡½æ•°æ˜¯åœ¨åˆ¤æ–­rootfsçš„è·¯å¾„æ˜¯å¦ä¸ºblockdevï¼Œç„¶åremount_all_slaveæ‰“å¼€/proc/self/mountinfoç„¶åå°†shared enties æ”¹å˜åˆ°slaveä¸­ï¼Œå°±çœ‹å½“å‰çš„ç³»ç»Ÿæœ‰æ²¡æœ‰share entriesäº†ã€‚</p>

<p>ç„¶åè°ƒç”¨do_rootfs_setup(conf, name,lxcpath) å°†container rootfs æŒ‚è½½ä¸Šå»ã€‚åŒæ—¶ä¹Ÿé€šè¿‡pre-mountçš„è„šæœ¬å°†è‡ªå®šä¹‰çš„ä¸€äº›mount åŠ è¿›å»ï¼Œå› æ­¤ï¼Œè¿™ä¸ªåœ°æ–¹ä¹Ÿå¯ä»¥è‡ªå·±è‡ªå®šä¹‰ï¼Œå¤ç”¨ä¸€äº›ä¸œè¥¿</p>

<table>
  <tbody>
    <tr>
      <td>ç„¶åè°ƒç”¨setup_rootfsï¼Œå…ˆæ˜¯è°ƒç”¨mount(â€œâ€,â€/â€, NULL, MS_SLAVE</td>
      <td>MS_REC, 0)ï¼Œmount /ï¼Œè°ƒç”¨bdev_initï¼Œåˆå§‹åŒ–rootfsã€‚</td>
    </tr>
  </tbody>
</table>

<p>5ã€ç„¶åè¿›å»lxc-spawnè¿™ä¸ªå‡½æ•°ä¸­ï¼Œåœ¨åˆ«çš„åœ°æ–¹å¾ˆå¤šæ¬¡è§åˆ°spawnè¿™ä¸ªå‡½æ•°ï¼ŒåªçŸ¥é“spawnçš„è‹±æ–‡æ„æ€æ˜¯äº§åµçš„æ„æ€ã€‚è¿™ä¸ªå‡½æ•°ä¸Šæ¬¡åˆ†æï¼Œé‡Œé¢æœ‰å¾ˆå¤šäº‹åœ¨åšã€‚</p>

<p>é¦–å…ˆå°†ä»¥å‰çš„cloneflag ä¿å­˜ï¼Œè®°å¾—startçš„åˆšå¼€å§‹åˆå§‹åŒ–çš„æ—¶å€™å¦‚æœæ²¡è®¾ç½®ï¼Œns_infoä¸­éƒ½è®¾ç½®é»˜è®¤çš„-1ï¼Œç„¶åå°±æ˜¯åŒæ­¥handlerï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚</p>

<p>ç„¶åå°±æ˜¯è®²handlerçš„clone_flagsè®¾ç½®CLONE_NEWXXX,è·å–ç‰©ç†ç½‘ç»œï¼Œç­‰ç­‰è®¾ç½®ä¸€å †ä¸œè¥¿ï¼Œ ç„¶åå°±è¦æƒ³åŠæ³•å°†cgroupä¸namespaceè”ç³»åˆ°ä¸€å—äº†ï¼Œåˆ°cgroup_inité‡Œé¢çœ‹çœ‹æ˜¯ä»€ä¹ˆæµç¨‹ã€‚</p>

<p>é¦–å…ˆï¼Œå‰é¢ä¸€ç›´è¿·æƒ‘çš„opsæ€ä¹ˆè¢«åˆå§‹åŒ–çš„é—®é¢˜ï¼Œ</p>

<p><strong>attribute</strong>((constructor))</p>

<p>void cgroup_ops_init(void)</p>

<p>è¿™ä¸ªç»“æ„ï¼Œåœ¨å‡½æ•°æœªè°ƒç”¨ä¹‹å‰å°±è¢«æ‰§è¡Œäº†ï¼Œè¿™ä¸ªå›å¤´ä¼šåœ¨æ‚ç¯‡ä¸­è®²åˆ°ï¼Œé¦–å…ˆç¨‹åºä¼šæ ¹æ®ç³»ç»Ÿä¸­æ˜¯å¦æœ‰cgmanager æ¥ä½¿ç”¨ä¸åŒçš„åˆå§‹åŒ–å‡½æ•°ï¼Œæœ¬æ–‡å°±é»˜è®¤æ²¡æœ‰cgmanagerï¼Œè°ƒç”¨é€šç”¨çš„cgfs_ops_initï¼›è¿”å›ä¸€ä¸ªå¼•ç”¨å€¼ï¼Œè¿”å›é™æ€å˜é‡cgfs_opsï¼›å°†ä¸€äº›æŒ‡é’ˆèµ‹å€¼ï¼Œokï¼Œçœ‹cgroup_initåˆå§‹åŒ–è¿‡ç¨‹ï¼ŒinitæŒ‡å‘cgfs_initï¼Œå› æ­¤åˆ°cgfs_initè¿™ä¸ªå‡½æ•°ä¸­çœ‹ä¸€ä¸‹</p>

<p>é¦–å…ˆåˆå§‹åŒ–cgfs_dataçš„æ•°æ®ç»“æ„ï¼Œç„¶åè®¾ç½®cgroup_patternä¸ºå…¨å±€å˜é‡ä¸­lxc.cgroup.patternå³åœ¨ç¼–è¯‘ä¸­çš„DEFAULT_CGROUP_PATTERNï¼Œé»˜è®¤çš„æ˜¯/lxc/%nï¼Œè¿™ä¸ªæš‚æ—¶ä¸çŸ¥é“å«ä¹‰ã€‚ç»§ç»­çœ‹</p>

<p>ç„¶åè°ƒç”¨lxc_cgroup_load_metaåŠ è½½metadataï¼Œå‡½æ•°ä¸­ä¼šåˆ¤æ–­cgroupçš„ä½¿ç”¨æƒ…å†µï¼Œç„¶åä¼šè°ƒç”¨lxc_cgroup_load_meta2çš„å‡½æ•°ï¼Œä¼šæŸ¥æ‰¾å­ç³»ç»Ÿçš„ç™½åå•ï¼Œæˆ–è€…æŒ‡å®šçš„hierarchiesã€‚</p>

<p>æœ€ç»ˆè¿”å›ç»™handler-&gt;cgroup_dataã€‚</p>

<p>ç„¶åè°ƒç”¨cgroup_create(handler)æ¥åˆ›å»ºcgroupï¼Œè°ƒç”¨opsçš„createï¼Œcreateçš„æŒ‡é’ˆæŒ‡å‘cgfs_createï¼Œæ˜¯ä¸ªå†…è”å‡½æ•°ï¼Œæœ€ç»ˆè°ƒç”¨lxc_cgroupfs_createï¼Œlxc_cgroupfs_create(d-&gt;name,d-&gt;cgroup_pattern, md, NULL)ç”¨æ¥åˆ›å»ºnew cgroup</p>

<p>/* we will modify the result of this operation directly,</p>

<p>Â Â Â Â  * so we donâ€™t have to copythe data structure</p>

<p>Â Â Â Â  */</p>

<p>Â Â  base_info = (path_pattern[0]== â€˜/â€™) ?</p>

<p>Â Â Â Â lxc_cgroup_process_info_get_init(meta_data) :Â Â Â  //patternä¸º/lxc/%n</p>

<p>Â Â Â Â  lxc_cgroup_process_info_get_self(meta_data);</p>

<p>Â Â Â  if (!base_info)</p>

<p>Â Â Â Â Â Â Â  return NULL;</p>

<p>å…¶ä¸­get_initä¸ºreturnlxc_cgroup_process_info_get(1, meta);pid ä¸º1å·è¿›ç¨‹getæ•°æ®ï¼Œæ ¹æ®/proc/1/cgroupä¸­çš„ä¿¡æ¯æ·»åŠ åˆ°cgroup_process_infoçš„é“¾è¡¨ä¸­ã€‚</p>

<p>new_cgroup_paths = calloc(meta_data-&gt;maximum_hierarchy + 1,sizeof(char *));</p>

<p>Â Â Â  if (!new_cgroup_paths)</p>

<p>Â Â Â Â Â Â Â  goto out_initial_error;</p>

<p>Â </p>

<p>Â Â Â  new_cgroup_paths_sub =calloc(meta_data-&gt;maximum_hierarchy + 1, sizeof(char *));</p>

<p>Â Â Â  if (!new_cgroup_paths_sub)</p>

<p>Â Â Â Â Â Â Â  goto out_initial_error;</p>

<p>åˆ†é…ç©ºé—´</p>

<p>/* find mount points we can use */</p>

<p>Â Â Â  for (info_ptr = base_info;info_ptr; info_ptr = info_ptr-&gt;next) {</p>

<p>Â Â Â Â Â Â Â  h =info_ptr-&gt;hierarchy;</p>

<p>Â Â Â Â Â Â Â  mp =lxc_cgroup_find_mount_point(h, info_ptr-&gt;cgroup_path, true);</p>

<p>Â Â Â Â Â Â Â  if (!mp) {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  ERROR(â€œCould notfind writable mount point for cgroup hierarchy %d while trying to createcgroup.â€, h-&gt;index);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  gotoout_initial_error;</p>

<p>Â Â Â Â Â Â Â  }</p>

<p>Â Â Â Â Â Â Â  info_ptr-&gt;designated_mount_point= mp;</p>

<p>Â </p>

<p>Â Â Â Â Â Â Â  if(lxc_string_in_array(â€œnsâ€, (const char **)h-&gt;subsystems))</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  continue;</p>

<p>Â Â Â Â Â Â Â  if(handle_cgroup_settings(mp, info_ptr-&gt;cgroup_path) &lt; 0) {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  ERROR(â€œCould notset clone_children to 1 for cpuset hierarchy in parent cgroup.â€);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  gotoout_initial_error;</p>

<p>Â Â Â Â Â Â Â  }</p>

<p>}</p>

<p>/* normalize the path */</p>

<p>Â Â Â  cgroup_path_components =lxc_normalize_path(path_pattern);</p>

<p>Â Â Â  if (!cgroup_path_components)</p>

<p>Â Â Â Â Â Â Â  goto out_initial_error;</p>

<p>æ¥çœ‹ä¸»è¦çš„find_name_on_this_levelç¨‹åºå—</p>

<p>/* determine name of the path component we should create */</p>

<p>Â Â Â Â Â Â Â  if (contains_name&amp;&amp; suffix &gt; 0) {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  char *buf =calloc(strlen(name) + 32, 1);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  if (!buf)</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  gotoout_initial_error;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  snprintf(buf, strlen(name)+ 32, â€œ%s-%uâ€, name, suffix);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  current_component =lxc_string_replace(â€œ%nâ€, buf, p_eff);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  free(buf);</p>

<p>Â Â Â Â Â Â Â  } else {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  current_component =contains_name ? lxc_string_replace(â€œ%nâ€, name, p_eff) : p_eff;</p>

<p>Â Â Â Â Â Â Â  }</p>

<p>Â Â Â Â Â Â Â  parts[0] = path_so_far;</p>

<p>Â Â Â Â Â Â Â  parts[1] =current_component;</p>

<p>Â Â Â Â Â Â Â  parts[2] = NULL;</p>

<p>Â Â Â Â Â Â Â  current_subpath =path_so_far ? lxc_string_join(â€œ/â€, (const char **)parts, false) :current_component;</p>

<p>/* Now go through each hierarchy and try to create the</p>

<p>Â Â Â Â Â Â Â Â  * corresponding cgroup</p>

<p>Â Â Â Â Â Â Â Â  */</p>

<p>å…¶ä¸­æœ€ä¸»è¦çš„æ˜¯</p>

<p>r = create_cgroup(info_ptr-&gt;designated_mount_point,current_entire_path);æ¥åˆ›å»ºcgroupçš„ç›®å½•å±‚çº§ã€‚</p>

<p>ç†ä¸€ä¸‹å¤´ç»ªï¼Œcgroupé€šè¿‡cgroup.patternd çš„æ¨¡å¼ï¼Œç„¶åè¯»å–/proc/1/cgroupä¸‹å»åˆ›å»ºç›¸åº”çš„cgroupå±‚çº§ï¼Œæœ€ååˆ›å»ºcgroupçš„ç›®å½•ã€‚</p>

<p>6ã€å›åˆ°lxc-spawnä¸­ï¼Œç„¶ååˆ°é€šè¿‡ä¸€äº›ç½‘ç»œçš„netpipepairè®¾ç½®ï¼Œè¿™äº›éƒ½ä¸æ˜¯æˆ‘ä»¬å…³å¿ƒçš„ã€‚</p>

<p>æœ€åè°ƒç”¨lxc_cloneå‡½æ•°è°ƒç”¨do_startæ¥å¯¹containerè¿›è¡Œä¸€ç³»åˆ—çš„åˆå§‹åŒ–æ“ä½œï¼Œé¦–å…ˆæ˜¯lxc_setup å‰é¢ä¹Ÿä»‹ç»äº†ï¼Œé€šè¿‡åˆå§‹åŒ–ï¼Œmount rootfsï¼Œç½‘ç»œï¼Œautodevï¼Œè‡ªåŠ¨æŒ‚è½½/proc,/sysç­‰æ–‡ä»¶ï¼Œç„¶åè®¾ç½®ttyï¼Œconsoleç­‰è®¾ç½®æ ‡å‡†è¾“å…¥è¾“å‡ºçš„ä½ç½®ï¼Œç­‰ç­‰ã€‚</p>

<p>ç„¶åå¯ä»¥è®¾ç½®if(run_lxc_hooks(handler-&gt;name, â€œstartâ€, handler-&gt;conf,handler-&gt;lxcpath, NULL)) startè„šæœ¬æ¥è¾…åŠ©å·¥ä½œï¼Œè¿™ä¸ªä¹Ÿæ˜¯å¯ä»¥è‡ªå®šä¹‰çš„å†…å®¹</p>

<p>æœ€ååœ¨do_startå‡½æ•°ä¸­è°ƒç”¨handler-&gt;ops-&gt;start(handler,handler-&gt;data);</p>

<p>opsä¸ºlxcçš„operationä¸­çš„å†…å®¹ï¼Œæ¥çœ‹çœ‹æƒ³å¹²å˜›ã€‚execvp(arg-&gt;argv[0],arg-&gt;argv);æ‰§è¡Œstart containeräº†ï¼Œè¿™é‡Œé¢ï¼Œæˆ‘ä»¬ç”¨åˆ°çš„æ˜¯/initä¸æ˜¯é»˜è®¤çš„/sbin/initï¼Œå› ä¸ºæˆ‘ä»¬çš„å®¹å™¨ä¸æ˜¯æ ‡å‡†çš„å®¹å™¨ï¼Œæ‰€ä»¥è¿™ç‚¹æ˜¯ä¸åŒçš„ã€‚</p>

<p>é‡Œé¢æ³¨é‡Šä¹Ÿè°ˆåˆ°äº†ï¼Œå½“æˆ‘ä»¬æ‰§è¡Œè¿™ä¸ª/initçš„æ—¶å€™ï¼Œå‡½æ•°å°±ä¸ä¼šè¿”å›æ¥äº†ï¼Œé‚£ä¹ˆåé¢çš„ç¨‹åºæ€ä¹ˆåŠï¼Ÿ</p>

<p>æ‰€ä»¥åœ¨do_startä¸­å­è¿›ç¨‹ä¸€ç›´ç­‰åˆ°çˆ¶è¿›ç¨‹å®Œæˆå·¥ä½œå’Œé…ç½®ã€‚</p>

<p>/* Tell the parent task it can begin to configure the</p>

<p>Â Â Â Â  * container and wait for itto finish</p>

<p>Â Â Â Â  */</p>

<p>Â Â Â  if(lxc_sync_barrier_parent(handler, LXC_SYNC_CONFIGURE))</p>

<p>Â Â Â Â Â Â Â  return -1;</p>

<p>ç„¶åçˆ¶è¿›ç¨‹è¿›è¡Œä¸€ç³»åˆ—çš„é…ç½®ï¼Œå…¶ä¸­æœ€ä¸»è¦çš„å°±æ˜¯cgroupçš„é…ç½®ï¼Œå¦‚æœå®¹å™¨æ²¡æœ‰cgroupçš„è¯ï¼Œèµ„æºåˆ’åˆ†å°±æˆé—®é¢˜äº†ï¼Œ</p>

<p>cgroup_setup_limits èµ„æºé™åˆ¶ï¼Œcgroup_enterå°†pidè¿›ç¨‹åŠ å…¥taskä»»åŠ¡ä¸­ï¼Œç­‰ç­‰è®¾ç½®cgroup</p>

<p>ç„¶åè¿˜æ˜¯é…ç½®ç½‘ç»œï¼Œå°†containeråŠ å…¥åˆ°vethå½“ä¸­ï¼Œè¿™å½“å¹´è¿˜æ˜¯è¦çœ‹è‡ªå·±configç½‘ç»œç›¸å…³çš„é…ç½®ï¼Œsoï¼Œç½‘ç»œé…ç½®æœ‰å¾ˆå¤šï¼Œå°±å¿½ç•¥ç½‘ç»œçš„é—®é¢˜äº†ã€‚</p>

<p>ç„¶ååˆå‘Šè¯‰å­è¿›ç¨‹ç»§ç»­åˆå§‹åŒ–è¿‡ç¨‹</p>

<p>/* Tell the child to continue its initialization.Â  weâ€™ll get</p>

<p>Â Â Â Â  * LXC_SYNC_CGROUP when it isready for us to setup cgroups</p>

<p>Â Â Â Â  */</p>

<p>Â Â Â  if(lxc_sync_barrier_child(handler, LXC_SYNC_POST_CONFIGURE))</p>

<p>Â Â Â Â Â Â Â  goto out_delete_net;</p>

<p>ç„¶åå½“å­è¿›ç¨‹setupè¿‡ç¨‹å®Œæˆä¹‹åï¼Œè®©çˆ¶è¿›ç¨‹è®¾ç½®cgroupï¼ŒåŒæ—¶çˆ¶è¿›ç¨‹è®¾ç½®å®Œcgroupæ—¶ï¼Œä¹Ÿé€šçŸ¥å­è¿›ç¨‹å®Œæˆï¼Œæ­¤æ—¶å­è¿›ç¨‹å°±çœŸæ­£è¿›å…¥åˆ°containerçš„initçš„è¿›ç¨‹äº†ã€‚</p>

<p>ä¸€ç›´æ²¡å‘ç°è¿™ä¸ªLXC_SYNC_POST_CGROUPwait å­è¿›ç¨‹çš„ä¿¡å·è°å‘ç»™ä»–ï¼Œè¿™ä¸ªæ¯”è¾ƒç–‘æƒ‘ï¼Ÿ</p>

<p>æœ€åå‘ç°æ˜¯do_statè¿™ä¸ªå‡½æ•°ifåˆ¤æ–­å¤±è´¥ågotoçš„ï¼Œåˆ™è¡¨ç¤ºä¸­é—´ä¼šerrorï¼Œæœ€åè¿˜æœ‰ä¸ªpost_cgroupï¼Œæ³¨é‡Šæ˜¯è¿™æ ·è¯´é“ã€‚</p>

<p>/* Tell the child to complete its initialization and wait for</p>

<p>Â Â Â Â  * it to exec or return anerror.Â  (the child will never</p>

<p>Â Â Â Â  * returnLXC_SYNC_POST_CGROUP+1.Â  It will eitherclose the</p>

<p>Â Â Â Â  * sync pipe, causinglxc_sync_barrier_child to return</p>

<p>Â Â Â Â  * success, or return adifferent value, causing us to error</p>

<p>Â Â Â Â  * out).</p>

<p>Â Â Â Â  */</p>

<p>Â Â Â  if(lxc_sync_barrier_child(handler, LXC_SYNC_POST_CGROUP))</p>

<p>Â Â Â Â Â Â Â  return -1;</p>

<p>ç„¶åå°±æ˜¯è°ƒç”¨post-startï¼ŒNOTICE è¿è¡Œçš„pidï¼Œæœ€åè®¾ç½®containerçš„çŠ¶æ€ä¸ºRUNNING,è‡³æ­¤spawnå°±ç»“æŸäº†ã€‚</p>

<p>å›åˆ°__lxc_startä¸­ï¼Œget_netns_fdè·å¾—networkçš„çŠ¶æ€ï¼Œç„¶åè¿›å…¥lxc_pollä¸­.åé¢æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œç°åœ¨ä¸»è¦è€ƒè™‘lxc åœ¨exec containerçš„initçš„è¿›ç¨‹è¿‡åï¼Œlxcæ˜¯å¦‚ä½•ç»§ç»­æ¥ç®¡ç¨‹åºçš„ã€‚</p>

<p>lxc startéƒ¨åˆ†çš„æºç çš„å¤§è‡´å·¥ä½œæµç¨‹å·²ç»ç†Ÿæ‚‰ï¼Œé‚£ä¹ˆå°±è¦å…³æ³¨ä»–çš„æ ¸å¿ƒå†…å®¹äº†ï¼Œå°±æ˜¯å…³äºnamespace å’Œ cgroupçš„å†…å®¹äº†ã€‚</p>

<p>æ ¹æ®å‰é¢çš„åˆ†æå·²ç»çŸ¥é“ï¼Œlxcæ ¹æ®ä¸€äº›é…ç½®ä¼šè‡ªåŠ¨å°†flagè®¾ç½®æˆCLONE_NEWXXX,ç„¶åä¼šé€šè¿‡cgroup init æ¥åˆå§‹åŒ–ä¸€å † cgroupã€‚æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹ã€‚</p>

<p>é¦–å…ˆé€šè¿‡cgroup_create æ¥åˆ›å»º cgroupï¼Œå‰é¢ä»‹ç»éƒ½æ˜¯æœ‰ä¸ªops æŒ‡å‘å‡½æ•°æŒ‡é’ˆï¼Œè¿™é‡Œå…ˆå‡è®¾æˆ‘ä»¬ç”¨çš„cgfsï¼Œç†è®ºä¸Šåº”è¯¥å’Œcgroupmanageræ˜¯ä¸€æ ·çš„æ–¹å¼ï¼Œå¯èƒ½ç»†èŠ‚æœ‰åŒºåˆ«è€Œå·²ã€‚</p>

<p>é‚£ä¹ˆé¡ºç†æˆç« createæŒ‡å‘cgfs_createï¼Œåé¢å°±ç›´æ¥è¯´å‡½æ•°æŒ‡é’ˆçš„ä½ç½®äº†ã€‚</p>

<p>å‡½æ•°å†…éƒ¨é€šè¿‡è°ƒç”¨lxc_cgroupfs_createã€‚é‚£ä¹ˆå°±è¦ä»create a newcgroup</p>

<p>static struct cgroup_process_info <em>lxc_cgroupfs_create(const char</em>name, const char <em>path_pattern, struct cgroup_meta_data *meta_data, const char</em>sub_pattern)</p>

<p>Â </p>

<p>char**cgroup_path_components = NULL;</p>

<p>Â Â Â  char **p = NULL;</p>

<p>Â Â Â  char *path_so_far = NULL;</p>

<p>Â Â Â  char **new_cgroup_paths =NULL;</p>

<p>Â Â Â  char **new_cgroup_paths_sub =NULL;</p>

<p>Â Â Â  struct cgroup_mount_point*mp;</p>

<p>Â Â Â  struct cgroup_hierarchy *h;</p>

<p>Â Â Â  struct cgroup_process_info*base_info = NULL;</p>

<p>Â Â Â  struct cgroup_process_info*info_ptr;</p>

<p>Â Â Â  int saved_errno;</p>

<p>Â Â Â  int r;</p>

<p>Â Â Â  unsigned suffix = 0;</p>

<p>Â Â Â  bool had_sub_pattern = false;</p>

<p>size_t i;</p>

<p>Â </p>

<p>if (!is_valid_cgroup(name)){Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  //åˆ¤æ–­name æ˜¯å¦æœ‰æ•ˆ</p>

<p>Â Â Â Â Â Â Â  ERROR(â€œInvalidcgroup name: â€˜%sâ€™â€, name);</p>

<p>Â Â Â Â Â Â Â  errno = EINVAL;</p>

<p>Â Â Â Â Â Â Â  return NULL;</p>

<p>}</p>

<p>Â </p>

<p>if (!strstr(path_pattern,â€%nâ€)) {</p>

<p>Â Â Â Â Â Â Â  ERROR(â€œInvalidcgroup path pattern: â€˜%sâ€™; contains no %%n for specifying container nameâ€,path_pattern);</p>

<p>Â Â Â Â Â Â Â  errno = EINVAL;</p>

<p>Â Â Â Â Â Â Â  return NULL;</p>

<p>}</p>

<p>æ ¹æ®privilege å’ŒunprivilegeÂ  containerçš„ä¸åŒè¯»å–åˆ°proc ä¸‹é¢çš„pidçš„ä¸åŒæ¥ç¡®å®šä¸åŒçš„cgroup ä¿¡æ¯ã€‚</p>

<p>base_info = (path_pattern[0]== â€˜/â€™) ?</p>

<p>Â Â Â Â Â Â Â lxc_cgroup_process_info_get_init(meta_data) :</p>

<p>Â Â Â Â Â Â Â lxc_cgroup_process_info_get_self(meta_data);</p>

<p>Â Â Â  if (!base_info)</p>

<p>Â Â Â Â Â Â Â  return NULL;</p>

<p>new_cgroup_paths =calloc(meta_data-&gt;maximum_hierarchy + 1, sizeof(char *));</p>

<p>Â Â Â  if (!new_cgroup_paths)</p>

<p>Â Â Â Â Â Â Â  goto out_initial_error;</p>

<p>Â </p>

<p>åœ¨è‡ªå·±æœºå­ä¸Šé¢ï¼Œçœ‹åˆ°çš„cgroupï¼š</p>

<p>gudh@lxc-D3F2-CM:~$ cat/proc/self/cgroup</p>

<p>11:name=systemd:/user/1004.user/5.session</p>

<p>10:hugetlb:/user/1004.user/5.session</p>

<p>9:perf_event:/user/1004.user/5.session</p>

<p>8:blkio:/user/1004.user/5.session</p>

<p>7:freezer:/user/1004.user/5.session</p>

<p>6:devices:/user/1004.user/5.session</p>

<p>5:memory:/user/1004.user/5.session</p>

<p>4:cpuacct:/user/1004.user/5.session</p>

<p>3:cpu:/user/1004.user/5.session</p>

<p>2:cpuset:/user/1004.user/5.session</p>

<p>gudh@lxc-D3F2-CM:~$ id</p>

<p>uid=1004(gudh)gid=1004(gudh) groups=1004(gudh),0(root),4(adm)</p>

<p>gudh@lxc-D3F2-CM:~$ cat/proc/1/cgroup</p>

<p>11:name=systemd:/</p>

<p>10:hugetlb:/</p>

<p>9:perf_event:/</p>

<p>8:blkio:/</p>

<p>7:freezer:/</p>

<p>6:devices:/</p>

<p>5:memory:/</p>

<p>4:cpuacct:/</p>

<p>3:cpu:/</p>

<p>2:cpuset:/</p>

<p>ç„¶åå°±æ˜¯åˆ†é…pathçš„å¤§å°</p>

<p>Â Â Â  new_cgroup_paths_sub =calloc(meta_data-&gt;maximum_hierarchy + 1, sizeof(char *));</p>

<p>Â Â Â  if (!new_cgroup_paths_sub)</p>

<p>Â Â Â Â Â Â Â  goto out_initial_error;</p>

<p>Â </p>

<p>æŸ¥æ‰¾å¯ä»¥æŒ‚è½½çš„ç‚¹ï¼Œç„¶ååˆ›å»ºã€‚</p>

<p>/* find mount points we canuse */</p>

<p>Â Â Â  for (info_ptr = base_info; info_ptr;info_ptr = info_ptr-&gt;next) {</p>

<p>Â Â Â Â Â Â Â  h = info_ptr-&gt;hierarchy;</p>

<p>Â Â Â Â Â Â Â  mp = lxc_cgroup_find_mount_point(h,info_ptr-&gt;cgroup_path, true);</p>

<p>Â Â Â Â Â Â Â  if (!mp) {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  ERROR(â€œCould not find writablemount point for cgroup hierarchy %d while trying to create cgroup.â€,h-&gt;index);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  goto out_initial_error;</p>

<p>Â Â Â Â Â Â Â  }</p>

<p>Â Â Â Â Â Â Â  info_ptr-&gt;designated_mount_point =mp;</p>

<p>Â </p>

<p>Â Â Â Â Â Â Â  if (lxc_string_in_array(â€œnsâ€,(const char **)h-&gt;subsystems))</p>

<p>Â Â Â Â Â Â Â Â  Â Â Â continue;</p>

<p>Â Â Â Â Â Â Â  if (handle_cgroup_settings(mp,info_ptr-&gt;cgroup_path) &lt; 0) {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  ERROR(â€œCould not setclone_children to 1 for cpuset hierarchy in parent cgroup.â€);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  goto out_initial_error;</p>

<p>Â Â Â Â Â Â Â  }</p>

<p>Â Â Â  }</p>

<p>Â </p>

<p>cgroup_path_components = lxc_normalize_path(path_pattern);</p>

<p>Â Â Â  if (!cgroup_path_components)</p>

<p>Â Â Â Â Â Â Â  goto out_initial_error;</p>

<p>Â </p>

<p>ç„¶åæ ¹æ®normalizeçš„pathå»åˆ›å»ºä»–ä»¬ã€‚</p>

<p>/* go through the pathcomponents to see if we can create them */</p>

<table>
  <tbody>
    <tr>
      <td>Â Â Â  for (p = cgroup_path_components; *p</td>
      <td>Â </td>
      <td>(sub_pattern &amp;&amp; !had_sub_pattern); p++) {</td>
    </tr>
  </tbody>
</table>

<p>Â Â Â Â Â Â Â  /* we only want to create the samecomponent with -1, -2, etc.</p>

<p>Â Â Â Â Â Â Â Â  * if the component contains thecontainer name itself, otherwise</p>

<p>Â Â Â Â Â Â Â Â  * itâ€™s not an error if it alreadyexists</p>

<p>Â Â Â Â Â Â Â Â  */</p>

<p>Â Â Â Â Â Â Â  char <em>p_eff = *p ? *p : (char</em>)sub_pattern;</p>

<p>Â Â Â Â Â Â Â  bool contains_name = strstr(p_eff,â€%nâ€);</p>

<p>Â Â Â Â Â Â Â  char *current_component = NULL;</p>

<p>Â Â Â Â Â Â Â  char *current_subpath = NULL;</p>

<p>Â Â Â Â Â Â Â  char *current_entire_path = NULL;</p>

<p>Â Â Â Â Â Â Â  char *parts[3];</p>

<p>Â Â Â Â Â Â Â  size_t j = 0;</p>

<p>Â Â Â Â Â Â Â  i = 0;</p>

<p>Â </p>

<p>Â Â Â Â Â Â Â /* if we are processing the subpattern, we want to make sure</p>

<p>Â Â Â Â Â Â Â Â  * loop is ended the next time around</p>

<p>Â Â Â Â Â Â Â Â  */</p>

<p>Â Â Â Â Â Â Â  if (!*p) {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  had_sub_pattern = true;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  pâ€“;</p>

<p>Â Â Â Â Â Â Â  }</p>

<p>Â </p>

<p>ç„¶åå°±åˆ°find_name_on_this_levelï¼Œè¿™é‡Œé¢pattern åº”è¯¥æ˜¯/lxc/%n</p>

<p>Â </p>

<p>Â Â Â Â Â Â Â  goto find_name_on_this_level;</p>

<p>find_name_on_this_level:</p>

<p>Â Â Â Â Â Â Â  /* determine name of the path componentwe should create */</p>

<p>Â Â Â Â Â Â Â  if (contains_name &amp;&amp; suffix&gt; 0) {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  char *buf = calloc(strlen(name) +32, 1);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  if (!buf)</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â goto out_initial_error;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  snprintf(buf, strlen(name) + 32,â€%s-%uâ€, name, suffix);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  current_component =lxc_string_replace(â€œ%nâ€, buf, p_eff);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  free(buf);</p>

<p>Â Â Â Â Â Â Â  } else {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  current_component = contains_name ?lxc_string_replace(â€œ%nâ€, name, p_eff) : p_eff;</p>

<p>Â Â Â Â Â Â Â  }</p>

<p>Â Â Â Â Â Â Â  parts[0] = path_so_far;</p>

<p>Â Â Â Â Â Â Â  parts[1] = current_component;</p>

<p>Â Â Â Â Â Â Â  parts[2] = NULL;</p>

<p>Â Â Â Â Â Â Â  current_subpath = path_so_far ?lxc_string_join(â€œ/â€, (const char **)parts, false) :current_component;</p>

<p>ç´§æ¥ç€åˆ›å»ºç›¸åº”çš„cgroup</p>

<p>for (i = 0, info_ptr =base_info; info_ptr; info_ptr = info_ptr-&gt;next, i++) {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  char *parts2[3];</p>

<p>Â </p>

<p>Â Â Â Â Â Â Â Â Â Â Â  if(lxc_string_in_array(â€œnsâ€, (const char**)info_ptr-&gt;hierarchy-&gt;subsystems))</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  continue;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  current_entire_path = NULL;</p>

<p>Â </p>

<p>Â Â Â Â Â Â Â Â Â Â Â  parts2[0] =!strcmp(info_ptr-&gt;cgroup_path, â€œ/â€) ? â€œâ€ :info_ptr-&gt;cgroup_path;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  parts2[1] = current_subpath;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  parts2[2] = NULL;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  current_entire_path = lxc_string_join(â€œ/â€,(const char **)parts2, false);</p>

<p>Â </p>

<p>Â Â Â Â Â Â Â Â Â Â Â  if (!*p) {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  /* we are processing thesubpath, so only update that one */</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  free(new_cgroup_paths_sub[i]);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  new_cgroup_paths_sub[i] =strdup(current_entire_path);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (!new_cgroup_paths_sub[i])</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  goto cleanup_from_error;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  } else {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  /* remember which path was usedon this controller */</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  free(new_cgroup_paths[i]);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  new_cgroup_paths[i] =strdup(current_entire_path);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (!new_cgroup_paths[i])</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  goto cleanup_from_error;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  }</p>

<p>Â </p>

<p>Â Â Â Â Â Â Â Â Â Â Â  r =create_cgroup(info_ptr-&gt;designated_mount_point, current_entire_path);</p>

<p>è¿™æ ·å°±å®Œæˆç›¸åº”çš„ä»£ç è®¾ç½®ã€‚</p>

<p>å¯¹äºpattern ä¸º/lxc/%n å°±åˆ†ä¸¤æ¬¡ä¸åŒåˆ›å»ºåœ¨ç›¸åº”çš„ç›®å½•ï¼Œè¿™æ ·cgroup subpath ä¹ŸåŒæ—¶å—åˆ°é¡¶å±‚/lxc çš„æ§åˆ¶ï¼Œcgroupå°±æˆåŠŸåˆ›å»ºäº†ã€‚</p>

<p>Â </p>

<p>Â Â Â Â Â Â  ç„¶åå°±åˆ°cgroup_create_legacyæœ€ç»ˆè°ƒç”¨lxc_cgroup_create_legacy</p>

<p>ç›´æ¥çœ‹æ³¨é‡Š</p>

<p>/*Â Â </p>

<p>Â Â Â Â  * if cgroup is mounted at/cgroup and task is in cgroup /ab/, pid 2375 and</p>

<p>Â Â Â Â  * name is c1,</p>

<p>Â Â Â Â  * dir: /ab</p>

<p>Â Â Â Â  * fulloldpath =/cgroup/ab/2375</p>

<p>Â Â Â Â  * fullnewpath =/cgroup/ab/c1</p>

<p>Â Â Â Â  * newname = /ab/c1</p>

<p>Â Â Â Â  */</p>

<p>å¦‚æœè€åå­—ä¸º/sys/cgroup/cpu/lxc/android/2375</p>

<p>é‚£ä¹ˆå°±æ”¹æˆ/sys/cgroup/cpu/lxc/android/android?</p>

<p>åŠ å…¥cgroupä¸€äº›åˆ›å»ºfileçš„ capability</p>

<p>Â </p>

<p>cgroup_setup_limits åå­—å¾ˆæ˜æ˜¾è®¾ç½®é™é¢ with_deviceæ˜¯false</p>

<p>å°†åœ¨configä¸­åŠ å…¥çš„device.allow å’Œdevice.deny é…ç½®</p>

<p>æ‰‹åŠ¨è®¾ç½®çš„åœ°æ–¹</p>

<p>Â </p>

<p>ç„¶åå°±æ˜¯cgfs_enter æœ€ååˆ°lxc_cgroupfs_enter</p>

<p>lxc_cgroup_find_mount_point æŸ¥æ‰¾pathä¸‹é¢çš„mount point</p>

<p>cgroup_to_absolute_path absolute path</p>

<p>lxc_write_to_fileç„¶åå°†pidå†™å…¥åˆ°cgroupçš„absolutepathä¸‹é¢</p>

<p>è¿™æ ·å°±å°†pid ä¸cgroupæˆåŠŸç»‘å®šã€‚
cgroup_chown chownçš„æŒ‡é’ˆç›®å‰æ˜¯NULL æš‚æ—¶ä¸åˆ†æ
åé¢åˆæ¥äº†ä¸€æ¬¡ cgroup_setup_limits è¿™æ˜¯with_device æ˜¯true
æ­¤æ—¶åº”è¯¥å°±å®Œæˆäº†cgroupçš„ç›¸å…³è®¾ç½®</p>
:ET