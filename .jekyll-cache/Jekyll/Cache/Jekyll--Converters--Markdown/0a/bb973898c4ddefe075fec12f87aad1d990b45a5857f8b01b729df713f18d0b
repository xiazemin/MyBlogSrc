I"ö<p>æ–¹ä¾¿çš„å¹¶å‘ï¼Œæ˜¯Golangçš„ä¸€å¤§ç‰¹è‰²ä¼˜åŠ¿ï¼Œè€Œä½¿ç”¨å¹¶å‘ï¼Œå¯¹syncåŒ…çš„WaitGroupä¸ä¼šé™Œç”Ÿã€‚WaitGroupä¸»è¦ç”¨æ¥åšGolangå¹¶å‘å®ä¾‹å³Goroutineçš„ç­‰å¾…ï¼Œå½“ä½¿ç”¨goå¯åŠ¨å¤šä¸ªå¹¶å‘ç¨‹åºï¼Œé€šè¿‡waitgroupå¯ä»¥ç­‰å¾…æ‰€æœ‰goç¨‹åºç»“æŸåå†æ‰§è¡Œåé¢çš„ä»£ç é€»è¾‘ï¼Œæ¯”å¦‚ï¼š
func Main() {
    wg := sync.WaitGroup{}
    for i := 0; i &lt; 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            time.Sleep(10 * time.Second)
        }()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>}
wg.Wait() // ç­‰å¾…åœ¨æ­¤ï¼Œç­‰æ‰€æœ‰go funcé‡Œéƒ½æ‰§è¡Œäº†Done()æ‰ä¼šé€€å‡º }
</code></pre></div></div>

<p>https://juejin.im/post/5e5b62f86fb9a07cb1578fda
<!-- more -->
å®ç°åŸç†
WaitGroupå¯¹å¤–æä¾›ä¸‰ä¸ªæ–¹æ³•ï¼ŒAdd(int),Done()å’ŒWait(), å…¶ä¸­Done()æ˜¯è°ƒç”¨äº†Add(-1)ï¼Œä¸€èˆ¬ä½¿ç”¨æ–¹æ³•æ˜¯ï¼Œå…ˆç»Ÿä¸€Addï¼Œåœ¨goroutineé‡Œå¹¶å‘çš„Doneï¼Œç„¶åWaitã€‚
WaitGroupä¸»è¦ç»´æŠ¤äº†2ä¸ªè®¡æ•°å™¨ï¼Œä¸€ä¸ªæ˜¯è¯·æ±‚è®¡æ•°å™¨ vï¼Œä¸€ä¸ªæ˜¯ç­‰å¾…è®¡æ•°å™¨ wï¼ŒäºŒè€…ç»„æˆä¸€ä¸ª64bitçš„å€¼ï¼Œè¯·æ±‚è®¡æ•°å™¨å é«˜32bitï¼Œç­‰å¾…è®¡æ•°å™¨å ä½32bitã€‚
æ¯æ¬¡Addæ‰§è¡Œï¼Œè¯·æ±‚è®¡æ•°å™¨våŠ 1ï¼ŒDoneæ–¹æ³•æ‰§è¡Œï¼Œè¯·æ±‚è®¡æ•°å™¨å‡1ï¼Œvä¸º0æ—¶é€šè¿‡ä¿¡å·é‡å”¤é†’Wait()ã€‚
é‚£ä¹ˆç­‰å¾…è®¡æ•°å™¨æ‹¿æ¥å¹²å˜›ï¼Ÿæ˜¯å› ä¸ºåŒä¸€ä¸ªå®ä¾‹çš„Wait()æ–¹æ³•æ”¯æŒå¤šå¤„è°ƒç”¨ï¼Œæ¯ä¸€æ¬¡Wait()æ–¹æ³•æ‰§è¡Œï¼Œç­‰å¾…è®¡æ•°å™¨ w å°±ä¼šåŠ 1ï¼Œè€Œå½“è¯·æ±‚è®¡æ•°å™¨vä¸º0è§¦å‘Wait()æ—¶ï¼Œè¦æ ¹æ®wçš„æ•°é‡å‘é€wä»½çš„ä¿¡å·é‡ï¼Œæ­£ç¡®çš„è§¦å‘æ‰€æœ‰çš„Wait()ï¼Œè¿™è™½ç„¶ä¸æ˜¯å¸¸ç”¨çš„ä¸€ä¸ªç‰¹æ€§ï¼Œä½†æ˜¯åœ¨ä¸€äº›ç‰¹æ®Šåœºåˆæ˜¯æœ‰ç”¨å¤„çš„(æ¯”å¦‚å¤šä¸ªå¹¶å‘éƒ½ä¾èµ–äºWaitGroupçš„å®ä¾‹çš„ç»“æŸä¿¡å·æ¥è¿›è¡Œä¸‹ä¸€ä¸ªaction)ï¼Œæ¼”ç¤ºä»£ç å¦‚ä¸‹ï¼š
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i &lt; 10; i++ {
    wg.Add(1)
    go func() {
      defer wg.Done()
â€‹    }()
  }
  time.Sleep(2 * time.Second)
  for j := 0; j &lt; 3; j++ {
    go func(i int) {
      // 3ä¸ªåœ°æ–¹è°ƒç”¨Wait()ï¼Œé€šè¿‡ç­‰å¾…jè®¡æ—¶å™¨ï¼Œæ¯ä¸ªWatiéƒ½ä¼šè¢«huå”¤é†’
      wg.Wait()
      fmt.Println(â€œwait done now â€œ, i)
    }(j)
  }
  time.Sleep(10 * time.Second)
  return
}
/*
è¾“å‡ºå¦‚ä¸‹ï¼Œæ•°å­—å‡ºç°çš„é¡ºåºéšæœº
wait done now  1
wait done now  0
wait done now  2
*/
å¤åˆ¶ä»£ç åŒæ—¶ï¼ŒWaitGroupé‡Œè¿˜å¯¹ä½¿ç”¨é€»è¾‘è¿›è¡Œäº†ä¸¥æ ¼çš„æ£€æŸ¥ï¼Œæ¯”å¦‚Wait()ä¸€æ—¦å¼€å§‹ä¸èƒ½Add().
ä¸‹é¢æ˜¯å¸¦æ³¨é‡Šçš„ä»£ç ï¼Œå»æ‰äº†ä¸å½±å“ä»£ç é€»è¾‘çš„traceéƒ¨åˆ†ï¼š
func (wg *WaitGroup) Add(delta int) {
    statep := wg.state()
    // æ›´æ–°statepï¼Œstatepå°†åœ¨waitå’Œaddä¸­é€šè¿‡åŸå­æ“ä½œä¸€èµ·ä½¿ç”¨
    state := atomic.AddUint64(statep, uint64(delta)Â«32)
    v := int32(stateÂ Â» 32)
    w := uint32(state)
        if v &lt; 0 {
        panic(â€œsync: negative WaitGroup counterâ€)
    }
    if w != 0 &amp;&amp; delta &gt; 0 &amp;&amp; v == int32(delta) {
        // waitä¸ç­‰äº0è¯´æ˜å·²ç»æ‰§è¡Œäº†Waitï¼Œæ­¤æ—¶ä¸å®¹è®¸Add
        panic(â€œsync: WaitGroup misuse: Add called concurrently with Waitâ€)
    }
    // æ­£å¸¸æƒ…å†µï¼ŒAddä¼šè®©vå¢åŠ ï¼ŒDoneä¼šè®©vå‡å°‘ï¼Œå¦‚æœæ²¡æœ‰å…¨éƒ¨Doneæ‰ï¼Œæ­¤å¤„væ€»æ˜¯ä¼šå¤§äº0çš„ï¼Œç›´åˆ°vä¸º0æ‰å¾€ä¸‹èµ°
    // è€Œwä»£è¡¨æ˜¯æœ‰å¤šå°‘ä¸ªgoruntineåœ¨ç­‰å¾…doneçš„ä¿¡å·ï¼Œwaitä¸­é€šè¿‡compareAndSwapå¯¹è¿™ä¸ªwè¿›è¡ŒåŠ 1
     if v &gt; 0 || w == 0 {
        return
    }
    // This goroutine has set counter to 0 when waiters &gt; 0.
    // Now there canâ€™t be concurrent mutations of state:
    // - Adds must not happen concurrently with Wait,
    // - Wait does not increment waiters if it sees counter == 0.
    // Still do a cheap sanity check to detect WaitGroup misuse.
    // å½“vä¸º0(Doneæ‰äº†æ‰€æœ‰)æˆ–è€…wä¸ä¸º0(å·²ç»å¼€å§‹ç­‰å¾…)æ‰ä¼šåˆ°è¿™é‡Œï¼Œä½†æ˜¯åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­åˆæœ‰ä¸€æ¬¡Addï¼Œå¯¼è‡´statepå˜åŒ–ï¼Œpanic
    if *statep != state {
        panic(â€œsync: WaitGroup misuse: Add called concurrently with Waitâ€)
    }
    // Reset waiters count to 0.
    // å°†statepæ¸…0ï¼Œåœ¨Waitä¸­é€šè¿‡è¿™ä¸ªå€¼æ¥ä¿æŠ¤ä¿¡å·é‡å‘å‡ºåè¿˜å¯¹è¿™ä¸ªWaitgroupè¿›è¡Œæ“ä½œ
    *statep = 0
    // å°†ä¿¡å·é‡å‘å‡ºï¼Œè§¦å‘waitç»“æŸ
    for ; w != 0; wâ€“ {
        runtime_Semrelease(&amp;wg.sema, false)
    }
}</p>

<p>// Done decrements the WaitGroup counter by one.
func (wg *WaitGroup) Done() {
    wg.Add(-1)
}</p>

<p>// Wait blocks until the WaitGroup counter is zero.
func (wg *WaitGroup) Wait() {
    statep := wg.state()
        for {
        state := atomic.LoadUint64(statep)
        v := int32(stateÂ Â» 32)
        w := uint32(state)
        if v == 0 {
            // Counter is 0, no need to wait.
            if race.Enabled {
                race.Enable()
                race.Acquire(unsafe.Pointer(wg))
            }
            return
        }
        // Increment waiters count.
        // å¦‚æœstatepå’Œstateç›¸ç­‰ï¼Œåˆ™å¢åŠ ç­‰å¾…è®¡æ•°ï¼ŒåŒæ—¶è¿›å…¥ifç­‰å¾…ä¿¡å·é‡
        // æ­¤å¤„åšCASï¼Œä¸»è¦æ˜¯é˜²æ­¢å¤šä¸ªgoroutineé‡Œè¿›è¡ŒWait()æ“ä½œï¼Œæ¯æœ‰ä¸€ä¸ªgoroutineè¿›è¡Œäº†waitï¼Œç­‰å¾…è®¡æ•°å°±åŠ 1
        // å¦‚æœè¿™é‡Œä¸ç›¸ç­‰ï¼Œè¯´æ˜statepï¼Œåœ¨ ä»è¯»å‡ºæ¥ åˆ° CASæ¯”è¾ƒ çš„è¿™ä¸ªæ—¶é—´åŒºé—´å†…ï¼Œè¢«åˆ«çš„goroutineæ”¹å†™äº†ï¼Œé‚£ä¹ˆä¸è¿›å…¥ifï¼Œå›å»å†è¯»ä¸€æ¬¡ï¼Œè¿™æ ·å†™é¿å…ç”¨é”ï¼Œæ›´é«˜æ•ˆäº›
        if atomic.CompareAndSwapUint64(statep, state, state+1) {
            if race.Enabled &amp;&amp; w == 0 {
                // Wait must be synchronized with the first Add.
                // Need to model this is as a write to race with the read in Add.
                // As a consequence, can do the write only for the first waiter,
                // otherwise concurrent Waits will race with each other.
                race.Write(unsafe.Pointer(&amp;wg.sema))
            }
            // ç­‰å¾…ä¿¡å·é‡
            runtime_Semacquire(&amp;wg.sema)
            // ä¿¡å·é‡æ¥äº†ï¼Œä»£è¡¨æ‰€æœ‰Addéƒ½å·²ç»Done
            if *statep != 0 {
                // èµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜åœ¨æ‰€æœ‰Addéƒ½å·²ç»Doneåï¼Œè§¦å‘ä¿¡å·é‡åï¼Œåˆè¢«æ‰§è¡Œäº†Add
                panic(â€œsync: WaitGroup is reused before previous Wait has returnedâ€)
            }
            return
        }
    }
}</p>
:ET