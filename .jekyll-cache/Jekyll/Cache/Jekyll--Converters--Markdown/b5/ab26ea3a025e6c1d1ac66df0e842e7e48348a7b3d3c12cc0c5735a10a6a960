I"ÔQ<p>åœ¨ç°ä»£çš„CPUä¸­ï¼Œä¸ºäº†æ€§èƒ½ä¼˜åŒ–ï¼ˆä¼˜åŒ–å‘ç”Ÿåœ¨CPUå’ŒComplierä¸¤ä¸ªé˜¶æ®µï¼‰ï¼Œä¼šå¯¹å†…å­˜çš„æ“ä½œï¼ˆloads and stores)é¡ºåºè¿›è¡Œé‡æ’åºï¼ˆreordering of memory operationsï¼‰ï¼Œè¿™æ ·å°±å¯¼è‡´äº†ä¹±åºæ‰§è¡Œ(out-of-order execution)
æ¢ä¸€å¥è¯ï¼Œä»£ç çš„ç¼–å†™é¡ºåº(program order)å’Œå®é™…å†…å­˜çš„è®¿é—®é¡ºåº(order of memory operations)ï¼Œä¸ä¸€å®šæ˜¯ä¸€è‡´çš„ã€‚
åœ¨å•çº¿ç¨‹çš„ç¯å¢ƒä¸‹ï¼Œä¹±åºæ‰§è¡Œ(out of order execution)å¹¶ä¸ä¼šå½±å“ç»“æœï¼Œå› ä¸ºå³ä¾¿æ–¹æ³•å†…çš„å†…å­˜è¯»å†™æ“ä½œæ˜¯out of order executionï¼Œä½†æ–¹æ³•ä¸æ–¹æ³•çš„è°ƒç”¨é¡ºåºæ˜¯ä¸€è‡´çš„ï¼Œå¯ä»¥ä¿è¯ç»“æœçš„æ­£ç¡®æ€§ã€‚
ä½†åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œå¤šä¸ªçº¿ç¨‹å…±äº«åŒä¸€å—å†…å­˜ï¼Œä¸”å¹¶å‘æ‰§è¡Œï¼Œé‚£ä¹ˆout of order executionå¯èƒ½ä¼šå½±å“ç¨‹åºçš„è¡Œä¸ºï¼Œäº§ç”Ÿæ— æ³•é¢„æœŸçš„ç»“æœã€‚
æ‰€ä»¥ï¼Œå¾ˆæ˜æ˜¾ï¼Œå¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œæˆ‘ä»¬è¦å»è§£å†³è¿™ç§å¯èƒ½äº§ç”Ÿâ€æ— æ³•é¢„æœŸâ€œç»“æœçš„æƒ…å†µã€‚
åœ¨å¼€å§‹ä¹‹å‰ï¼Œå…ˆä¸¾ä¸€ä¸ªä¾‹å­è¯´æ˜ï¼Œåœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œout of order executionï¼Œä¼šå¼•èµ·å“ªäº›é—®é¢˜ï¼Ÿ</p>

<p>int _answer;</p>

<p>bool _complete;</p>

<p>void A()</p>

<p>{</p>

<p>_answer = 123;</p>

<p>_complete = true;</p>

<p>}</p>

<p>void B()</p>

<p>{</p>

<p>if (_complete)</p>

<p>{</p>

<p>Console.WriteLine(_answer);</p>

<p>}</p>

<p>}</p>

<p>å¦‚æœæ–¹æ³•Aå’Œæ–¹æ³•Bï¼Œåœ¨ä¸åŒçš„çº¿ç¨‹ä¸Šå¹¶è¡Œï¼ŒBæ–¹æ³•è¾“å‡ºçš„ç»“æœ_answeræœ‰æ²¡æœ‰å¯èƒ½æ˜¯0ï¼Ÿ
ç­”æ¡ˆæ˜¯è‚¯å®šçš„ã€‚
out of order executionå¯ä»¥æ˜¯loadsï¼Œä¹Ÿå¯ä»¥æ˜¯storesï¼Œå³è¯»å’Œå†™å‡å¯ä»¥æ˜¯out of order execution.</p>

<p>Aå’ŒBä¸¤ä¸ªæ–¹æ³•å¹¶è¡Œï¼Œæ‰§è¡ŒAçš„æ—¶å€™ï¼Œ_answer=123;å’Œ_complete=true; å› ä¸º</p>

<p>out of order executionï¼Œå¯èƒ½_complete=trueä¼šå…ˆäº_answer=123;æ‰§è¡Œã€‚</p>

<p>è¿™æ ·ï¼ŒBæ–¹æ³•ï¼Œå°±æœ‰å¯èƒ½é€šè¿‡_competeä¸ºtrueçš„åˆ¤æ–­ï¼Œè€Œè¾“å‡ºè¿˜æœªåˆå§‹åŒ–çš„_answerï¼Œè¿™åœ¨Javaï¼ŒC#è¿™äº›è¯­è¨€ä¸­ä¼šè¾“å‡ºintçš„é»˜è®¤å€¼0ï¼Œåœ¨C/C++ä¸­ï¼Œæ²¡æœ‰é»˜è®¤å€¼ï¼Œåˆ™ä¼šè¾“å‡ºä¸å¯é¢„æœŸçš„ç»“æœã€‚</p>

<p>out of order executionåªæ˜¯åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œä¼šå¼•èµ·çš„é—®é¢˜ä¹‹ä¸€ã€‚</p>

<p>è¿˜æœ‰ä¸€ç§æƒ…å†µæ¥è‡ªäºCPUå’Œå†…å­˜ä¹‹é—´çš„é€šä¿¡ï¼ŒCPUçš„è¯»å†™é€Ÿåº¦è¦è¿œè¿œé«˜äºå†…å­˜ï¼Œå› ä¸ºè¿™ç§æ‚¬æ®Šçš„å·®å¼‚ï¼Œæ¯æ¬¡CPUè¯»å†™éƒ½è®¿é—®å†…å­˜çš„è¯ï¼Œæ•ˆç‡ä¼šå¾ˆæ…¢ï¼Œè¿™æ˜¯ä¸ç°å®çš„ï¼Œæ‰€ä»¥ï¼Œåœ¨CPUå’Œå†…å­˜ä¹‹é—´ï¼Œè¿˜æœ‰ä¸€å±‚ç¼“å­˜ï¼ˆé€Ÿåº¦æå¿«ï¼‰ï¼Œé€šè¿‡ç¼“å­˜(L1,L2,L3)æ¥æé«˜æ•°æ®çš„è¯»å†™æ•ˆç‡ã€‚</p>

<p>å½“CPUè¦è¯»å–ä¸€ä¸ªå˜é‡çš„å€¼æ—¶ï¼Œä¼šå…ˆä»ç¼“å­˜cacheä¸­å¯»æ‰¾ï¼Œå¦‚æœå­˜åœ¨ï¼Œåˆ™ç›´æ¥ä»cacheè·å–ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å‘ç”Ÿcache miss,å°±ä¼šå»ä¸»å­˜è¯»å–ï¼Œå†™å…¥çš„æ“ä½œä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œä¹Ÿè¦ç»ç”±ç¼“å­˜ï¼Œå¹¶ä¸æ˜¯æ¯æ¬¡éƒ½å°†æ–°çš„å€¼ï¼Œç«‹å³åˆ·æ–°åˆ°å†…å­˜ä¸­ã€‚</p>

<p>è¿™æ ·å°±ä¼šå¯¼è‡´åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œä½ æ— æ³•ä¿è¯æ–°çš„å€¼ï¼Œå¯ä»¥ç«‹å³è¢«å…¶å®ƒçš„çº¿ç¨‹çœ‹åˆ°ï¼Œå› ä¸ºçº¿ç¨‹ä¹‹é—´æ˜¯å¹¶è¡Œçš„ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä½•æœªåšä»»ä½•å¤„ç†çš„å•ä¾‹è®¾è®¡æ¨¡å¼ï¼Œå®ä¾‹ä¼šè¢«åˆ›å»ºå¤šæ¬¡çš„å¥‡æ€ªæƒ…å†µã€‚</p>

<p>æ‰€ä»¥ï¼Œå¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œå¼•å‡ºçš„ä¸¤ä¸ªé—®é¢˜ï¼š</p>

<p>1.ä¹±åºè®¿é—® out of order execution</p>

<p>2.å†…å­˜å¯è§æ€§ memory visibility
<!-- more -->
ä¸ºäº†è§£å†³å¤šçº¿ç¨‹ç¯å¢ƒçš„å‰¯ä½œç”¨ï¼Œæˆ‘ä»¬éœ€è¦æ·»åŠ Memory Barrierï¼ˆå†…å­˜æ …æ ï¼‰ï¼Œæ¥é¿å…CPUå’Œç¼–è¯‘å™¨è¿›è¡ŒæŒ‡ä»¤é‡æ’(reordering)ã€‚å…³é—­out of order executionï¼Œå¹¶ä¿è¯æ–°çš„æ•°æ®ï¼Œæ€»æ˜¯å¯ä»¥è¢«å…¶å®ƒçš„çº¿ç¨‹å¯è§ã€‚
åœ¨wikipediaä¸­ï¼ŒMemory Barrieråˆå«membar, memory fence or fence instruction.
ç†è§£barrieræˆ–æ˜¯fence,æœ‰åŠ©äºæˆ‘ä»¬æ›´å¥½çš„ç†è§£å®ƒçš„æ„å›¾ã€‚
barrierè¯‘ä¸ºéšœç¢ï¼Œfence è¯‘ä¸ºæ …æ ï¼Œå›´æ 
æ‰€ä»¥ï¼Œä»–å…·æœ‰â€é™å®šï¼Œçº¦æŸâ€çš„ä½œç”¨ã€‚
æˆ‘ä»¬å¯ä»¥æƒ³è±¡ä¸€ä¸‹ï¼Œåœ°é“è¿›ç«™æˆ–è€…åœ¨è·¯ä¸Šå¼€è½¦ï¼Œæˆ‘ä»¬å‡è®¾ä»Aç‚¹åˆ°è¾¾Bç‚¹ï¼Œæ€ä¹ˆåˆç†çš„åˆ©ç”¨â€ç³»ç»Ÿèµ„æºâ€œï¼Œå¯ä»¥è®©ç›®æ ‡æ›´å¿«çš„åˆ°è¾¾ç»ˆç‚¹?
å…¶å®åœ¨ä¸é™æµï¼Œä¸ç®¡æ§çš„æƒ…å†µä¸‹ï¼Œä½ ä¼šå‘ç°ï¼Œä¸€åˆ‡çš„è¿›è¡Œéƒ½æ˜¯â€ä¹±åºçš„ï¼Œæ— åºçš„â€œï¼Œå¼€è½¦æœ‰å¿«æœ‰æ…¢ï¼Œå¼€çš„å¿«çš„å¯ä»¥å¹¶çº¿è¶…è½¦ï¼Œæœ‰çš„å°±å¼€80è¿ˆï¼Œæœ‰çš„å¼€100è¿ˆï¼Œæœ‰çš„ç”šè‡³è¶…é€Ÿï¼Œåœ°é“è¿›ç«™ï¼Œæœ‰çš„äººä¸ç´§ä¸æ…¢ï¼Œä½ ç€æ€¥èµ¶æ—¶é—´ï¼Œä½ å¯ä»¥ä¸€è·¯å°è·‘ç€è¿›å»ï¼Œè¿™ç§ä¹±åºçš„ï¼Œæ— åºçš„ï¼Œå……åˆ†çš„åˆ©ç”¨äº†â€ç³»ç»Ÿèµ„æºâ€œï¼Œåœ¨æ€»ä½“ä¸Šï¼Œå°±å¯ä»¥æ›´å¿«çš„è¾¾åˆ°ç»ˆç‚¹ï¼Œä¹Ÿå°±æé«˜äº†æ•ˆç‡ã€‚
ç›¸åï¼Œå¦‚æœå¤§å®¶éƒ½æ’ç€é˜Ÿèµ°ï¼Œä¸€ä¸ªè·Ÿç€ä¸€ä¸ªï¼Œæµªè´¹äº†ç³»ç»Ÿçš„èµ„æºä¸è¯´ï¼Œé€Ÿåº¦ä¹Ÿä¼šå¤§æ‰“æŠ˜æ‰£ï¼Œä½†æœ‰çš„æ—¶å€™ï¼Œè¿™ç§â€é™æµï¼Œç®¡æ§â€œæ˜¯å¿…è¦çš„ï¼Œæ¯”å¦‚æˆ‘éœ€è¦æŒ‰ç€æˆ‘æƒ³è¦çš„é¡ºåºå»æ‰§è¡Œç­‰ç­‰ï¼Œè¿™ä¸ªä¸éš¾ç†è§£ï¼Œä»¥ç°ä»£çš„è®¡ç®—æœºæ€§èƒ½æ¥çœ‹ï¼Œè¿™ç§é™åˆ¶å¸¦æ¥çš„æ€§èƒ½å·®å¼‚å˜åŒ–å‡ ä¹æ˜¯æ— æ„ŸçŸ¥çš„</p>

<p>Memory Barrierå°±æ˜¯ä¸€æ¡CPUæŒ‡ä»¤ï¼Œä»–å¯ä»¥ç¡®ä¿æ“ä½œæ‰§è¡Œçš„é¡ºåºå’Œæ•°æ®çš„å¯è§æ€§ã€‚æˆ‘ä»¬åœ¨æŒ‡å®šçš„ä»£ç å¤„ï¼Œæ’å…¥Memory Barrierï¼ˆfence)
â€œç›¸å½“äºå‘Šè¯‰ CPU å’ŒComplierå…ˆäºè¿™ä¸ªå‘½ä»¤çš„å¿…é¡»â€å…ˆâ€œæ‰§è¡Œï¼Œåäºè¿™ä¸ªå‘½ä»¤çš„å¿…é¡»â€åâ€œæ‰§è¡Œã€‚
å†…å­˜å±éšœä¹Ÿä¼šå¼ºåˆ¶æ›´æ–°ä¸€æ¬¡ä¸åŒCPUçš„ç¼“å­˜ï¼Œä¼šå°†å±éšœå‰çš„å†™å…¥æ“ä½œï¼Œåˆ·åˆ°åˆ°ç¼“å­˜ä¸­ï¼Œè¿™æ ·è¯•å›¾è¯»å–è¯¥æ•°æ®çš„çº¿ç¨‹ï¼Œä¼šå¾—åˆ°æ–°å€¼ã€‚ç¡®ä¿äº†åŒæ­¥ã€‚â€</p>

<p>æ·»åŠ äº†Memory Barrierçš„ä»£ç ï¼š
int _answer;</p>

<p>bool _complete;</p>

<p>void A()</p>

<p>{</p>

<p>_answer = 123;</p>

<p>Thread.MemoryBarrier();  // å±éšœ 1</p>

<p>_complete = true;</p>

<p>Thread.MemoryBarrier();  // å±éšœ 2</p>

<p>}</p>

<p>void B()</p>

<p>{</p>

<p>Thread.MemoryBarrier();  // å±éšœ 3</p>

<p>if (_complete)</p>

<p>{</p>

<p>Thread.MemoryBarrier();    // å±éšœ 4</p>

<p>Console.WriteLine (_answer);</p>

<p>}</p>

<p>}</p>

<p>å±éšœ 1 å’Œ 4 å¯ä»¥ä½¿è¿™ä¸ªä¾‹å­ä¸ä¼šæ‰“å° â€œ 0 â€œã€‚å±éšœ 2 å’Œ 3 æä¾›äº†ä¸€ä¸ªâ€œæœ€æ–°ï¼ˆfreshnessï¼‰â€ä¿è¯ï¼šå®ƒä»¬ç¡®ä¿å¦‚æœBåœ¨Aåè¿è¡Œï¼Œè¯»å–_completeçš„å€¼ä¼šæ˜¯trueã€‚ï¼ˆä¹±åºè®¿é—®å’Œå†…å­˜ä¸å¯è§æ€§ï¼Œå‡å¾—åˆ°äº†è§£å†³ï¼‰</p>

<p>åœ¨å®é™…çš„åº”ç”¨è¿‡ç¨‹ä¸­å‘ç°ï¼ŒThread.MemoryBarrier()åœ¨ä½¿ç”¨èµ·æ¥è¿˜æ˜¯æ¯”è¾ƒç¹ççš„ï¼Œä¸å¤Ÿæ–¹ä¾¿ï¼Œé‚£ä¹ˆï¼Œæœ‰æ²¡æœ‰æ›´ä¸ºç®€å•çš„å®ç°ï¼Ÿ
ä½¿ç”¨lockä»£ç å—ï¼Œé”ä½éœ€è¦â€çº¦æŸâ€œçš„ä»£ç ã€‚lockéšå¼çš„æ‰§è¡Œäº†Memory Barrierï¼ˆfence)
lockå¯ä»¥ä¿è¯ï¼Œå½“å‰åªæœ‰ä¸€ä¸ªçº¿ç¨‹èƒ½å¤Ÿè¿›å…¥åˆ°ä»£ç å—ï¼Œå¹¶ä¸”ä»£ç å—ä¸­çš„ä¼šæŒ‰program orderçš„é¡ºåºæ‰§è¡Œï¼Œå¯¹å†…å­˜çš„Loads and storesæ“ä½œéƒ½ä¼šåŠæ—¶çš„è¿›è¡Œæ›´æ–°ï¼Œä¿è¯å§‹æ–°çš„å€¼å§‹ç»ˆéƒ½å¯ä»¥è¢«å…¶å®ƒçš„çº¿ç¨‹å¯è§ã€‚
Memory Barrier(lock)ä¼šå…³é—­CPUæˆ–ç¼–è¯‘å™¨æ‰€åšçš„æ€§èƒ½ä¼˜åŒ–ï¼Œå¦‚æœé¢‘ç¹çš„è°ƒç”¨ï¼Œä¼šæœ‰æ€§èƒ½æŸè€—ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆä¼šå‡ºç°double checked lockingå’ŒLazy Initialization ä¸¤ç§æ•ˆç‡æ›´é«˜çš„å®ç°æ–¹å¼ã€‚</p>

<p>æœ€è¿‘åœ¨çœ‹Tiny Modeæ–¹é¢çš„èµ„æ–™ï¼ŒTinyMode Scriptingæ˜¯åŸºäºECS Patternï¼Œè¿™äº›Scriptä¹‹é—´çš„æ‰§è¡Œé¡ºåºé»˜è®¤ä¹Ÿæ˜¯æ— åºçš„ï¼Œä½†å¦‚æœæŸäº›Scriptå¯ä»¥æŒ‰ç…§ä½ å¸Œæœ›çš„é¡ºåºæ‰§è¡Œï¼Œé‚£ä¹ˆä½ éœ€è¦è¿›è¡Œâ€çº¦æŸï¼Œé™å®šâ€œï¼Œè¿™é‡Œçš„æ¦‚å¿µå°±å«fenceï¼Œæ‰€ä»¥ï¼ŒTiny Mode fenceå’Œä¸Šé¢è®²åˆ°çš„Memory Barrierï¼Œæœ¬è´¨æ˜¯ä¸€æ ·çš„ã€‚</p>

<p>For performance gains modern CPUs often execute instructions out of order to make maximum use of the available silicon (including memory read/writes). Because the hardware enforces instructions integrity you never notice this in a single thread of execution. However for multiple threads or environments with volatile memory (memory mapped I/O for example) this can lead to unpredictable behavior.</p>

<p>A memory fence/barrier is a class of instructions that mean memory read/writes occur in the order you expect. For example a â€˜full fenceâ€™ means all read/writes before the fence are comitted before those after the fence.</p>

<p>Note memory fences are a hardware concept. In higher level languages we are used to dealing with mutexes and semaphores - these may well be implemented using memory fences at the low level and explicit use of memory barriers are not necessary. Use of memory barriers requires a careful study of the hardware architecture and more commonly found in device drivers than application code.</p>

<p>The CPU reordering is different from compiler optimisations - although the artefacts can be similar. You need to take separate measures to stop the compiler reordering your instructions if that may cause undesirable behaviour (e.g. use of the volatile keyword in C).</p>

<p>The most important one would be memory access reordering.</p>

<p>Absent memory fences or serializing instructions, the processor is free to reorder memory accesses. Some processor architectures have restrictions on how much they can reorder; Alpha is known for being the weakest (i.e., the one which can reorder the most).</p>

<p>A very good treatment of the subject can be found in the Linux kernel source documentation, at Documentation/memory-barriers.txt.</p>

<p>Most of the time, itâ€™s best to use locking primitives from your compiler or standard library; these are well tested, should have all the necessary memory barriers in place, and are probably quite optimized (optimizing locking primitives is tricky; even the experts can get them wrong sometimes).</p>

<p>https://stackoverflow.com/questions/286629/what-is-a-memory-fence</p>

<p>c++   c++11   atomic   memory-barriers   memory-model</p>

<p>æˆ‘å¯¹std::memory_order_acquireå’Œstd::memory_order_releaseçš„ç†è§£å¦‚ä¸‹ï¼š</p>

<p>è·å–æ„å‘³ç€è·å–å›´æ ä¹‹åå‡ºç°çš„å†…å­˜è®¿é—®ä¸èƒ½é‡æ–°æ’åºåˆ°å›´æ ä¹‹å‰ã€‚</p>

<p>é‡Šæ”¾æ„å‘³ç€åœ¨é‡Šæ”¾å›´æ ä¹‹å‰å‡ºç°çš„å†…å­˜è®¿é—®ä¸èƒ½åœ¨å›´æ ä¹‹åé‡æ–°æ’åºã€‚</p>

<p>æˆ‘ä¸æ˜ç™½ä¸ºä»€ä¹ˆç‰¹åˆ«æ˜¯å¯¹äºC ++ 11åŸå­åº“ï¼Œè·å–å›´æ ä¸åŠ è½½æ“ä½œç›¸å…³è”ï¼Œè€Œé‡Šæ”¾å›´æ ä¸å­˜å‚¨æ“ä½œç›¸å…³è”ã€‚</p>

<p>ä¸ºäº†æ¾„æ¸…ï¼ŒC ++ 11 <atomic>åº“å…è®¸æ‚¨ä»¥ä¸¤ç§æ–¹å¼æŒ‡å®šå†…å­˜æ …æ ï¼šè¦ä¹ˆå¯ä»¥å°†æ …æ æŒ‡å®šä¸ºåŸå­æ“ä½œçš„é¢å¤–å‚æ•°ï¼Œä¾‹å¦‚ï¼š</atomic></p>

<p>x.load(std::memory_order_acquire);
æˆ–è€…ä½ å¯ä»¥ä½¿ç”¨std::memory_order_relaxedå¹¶åˆ†åˆ«æŒ‡å®šå›´æ ï¼Œå¦‚ï¼š</p>

<p>x.load(std::memory_order_relaxed);
std::atomic_thread_fence(std::memory_order_acquire);
æˆ‘ä¸æ˜ç™½çš„æ˜¯ï¼Œé‰´äºä¸Šè¿°è·å–å’Œå‘å¸ƒçš„å®šä¹‰ï¼Œä¸ºä»€ä¹ˆC ++ 11ç‰¹åˆ«å°†è·å–ä¸åŠ è½½ç›¸å…³è”ï¼Œå¹¶ä¸å•†åº—ä¸€èµ· å‘å¸ƒ ï¼Ÿ æ˜¯çš„ï¼Œæˆ‘å·²ç»çœ‹è¿‡è®¸å¤šç¤ºä¾‹ï¼Œè¿™äº›ç¤ºä¾‹æ˜¾ç¤ºäº†å¦‚ä½•ä½¿ç”¨è·å–/åŠ è½½ä¸å‘å¸ƒ/å­˜å‚¨æ¥åœ¨çº¿ç¨‹ä¹‹é—´è¿›è¡ŒåŒæ­¥ï¼Œä½†ä¸€èˆ¬æ¥è¯´ä¼¼ä¹æ˜¯è·å–fencesï¼ˆé˜²æ­¢è¯­å¥åçš„å†…å­˜é‡æ–°æ’åºï¼‰å’Œå‘å¸ƒçš„æƒ³æ³•fencesï¼ˆåœ¨è¯­å¥ä¹‹å‰é˜²æ­¢å†…å­˜é‡æ–°æ’åºï¼‰ä¸åŠ è½½å’Œå­˜å‚¨çš„æƒ³æ³•æ­£äº¤ã€‚</p>

<p>é‚£ä¹ˆï¼Œä¸ºä»€ä¹ˆï¼Œä¾‹å¦‚ï¼Œç¼–è¯‘å™¨ä¸ä¼šè®©æˆ‘è¯´ï¼š</p>

<p>x.store(10, std::memory_order_acquire);
æˆ‘æ„è¯†åˆ°æˆ‘å¯ä»¥é€šè¿‡ä½¿ç”¨memory_order_relaxed ï¼Œç„¶åå•ç‹¬çš„atomic_thread_fence(memory_order_acquire)è¯­å¥æ¥å®Œæˆä¸Šè¿°æ“ä½œï¼Œä½†åŒæ ·ï¼Œä¸ºä»€ä¹ˆæˆ‘ä¸èƒ½ç›´æ¥ä½¿ç”¨storeä¸memory_order_acquire ï¼Ÿ</p>

<p>ä¸€ä¸ªå¯èƒ½çš„ç”¨ä¾‹å¯èƒ½æ˜¯ï¼Œå¦‚æœæˆ‘æƒ³ç¡®ä¿æŸäº›å­˜å‚¨ï¼ˆæ¯”å¦‚x = 10 ï¼‰ åœ¨æ‰§è¡Œå¯èƒ½å½±å“å…¶ä»–çº¿ç¨‹çš„å…¶ä»–è¯­å¥ä¹‹å‰å‘ç”Ÿã€‚</p>

<p>ä¸»è¦ç”¨C++11çš„atomicæˆ–atomic_thread_fenceï¼Œæ€§èƒ½ä¸Šå‡ ä¹ä¸€æ ·ï¼Œand makes life easierã€‚åœ¨X86ä¸Šå¯¹äºmemory_orderæ¥è¯´åªç”¨memory_order_relaxed å°±å¤Ÿäº†ï¼Œç›¸å½“äºcompiler fenceï¼›å¦‚æœéœ€è¦cpu fenceçš„è¯å°±ç”¨memory_order_seq_cstï¼Œä¸è¿‡æˆ‘ä»æ¥æ²¡ç”¨è¿‡memory_order_seq_cstã€‚åŸæ–‡è§£é‡Šäº†åŸå› ã€‚</p>

<p>åŸæ–‡ï¼š</p>

<p>åœ¨ç¼–å†™single writer lock-freeä»£ç çš„æ—¶å€™ï¼Œé€šå¸¸éœ€è¦æ‰‹åŠ¨ä½¿ç”¨memory fence/barrieræ¥ç¡®ä¿ä¿®æ”¹å¯¹å…¶ä»–coreå¯è§å¹¶é˜²æ­¢ä¹±åºï¼ˆå¯¹äºmultiple writerçš„æƒ…å†µä¸€èˆ¬éœ€è¦atomic RMWæ“ä½œï¼Œéšå«äº†memory fenceï¼Œä¸éœ€æ‰‹åŠ¨åŠ ï¼‰ã€‚ä¸€èˆ¬æ¥è¯´memory fenceåˆ†ä¸ºä¸¤å±‚ï¼šcompiler fenceå’ŒCPU fenceï¼Œå‰è€…åªåœ¨ç¼–è¯‘æœŸç”Ÿæ•ˆï¼Œç›®çš„æ˜¯é˜²æ­¢compilerç”Ÿæˆä¹±åºçš„å†…å­˜è®¿é—®æŒ‡ä»¤ï¼›åè€…é€šè¿‡æ’å…¥æˆ–ä¿®æ”¹ç‰¹å®šçš„CPUæŒ‡ä»¤ï¼Œåœ¨è¿è¡Œæ—¶é˜²æ­¢å†…å­˜è®¿é—®æŒ‡ä»¤ä¹±åºæ‰§è¡Œã€‚ä¸‹é¢åˆ†åˆ«è¯´ä¸‹åœ¨X86/GCCç¯å¢ƒä¸‹æˆ‘å¯¹è¿™ä¸¤ç§memory fenceç”¨æ³•çš„ä¸€äº›ç»éªŒã€‚</p>

<p>Compiler Fence
GCCçš„compiler fenceæœ‰ä¸€ä¸ªä¼—æ‰€å‘¨çŸ¥çš„å†™æ³•ï¼š</p>

<p>asm volatile(â€œâ€: : :â€memoryâ€)
é‚£ä¹ˆè¿™å¥è¯æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿå®ƒåªæ˜¯æ’å…¥äº†ä¸€ä¸ªç©ºæŒ‡ä»¤â€â€œï¼Œä»€ä¹ˆä¹Ÿæ²¡åšã€‚å…¶å®ä¸ç„¶ï¼Œè¿™å¥è¯çš„å…³é”®åœ¨æœ€åçš„â€memoryâ€ clobberï¼Œå®ƒå‘Šè¯‰ç¼–è¯‘å™¨ï¼šè¿™æ¡æŒ‡ä»¤ï¼ˆå…¶å®æ˜¯ç©ºçš„ï¼‰å¯èƒ½ä¼šè¯»å–ä»»ä½•å†…å­˜åœ°å€ï¼Œä¹Ÿå¯èƒ½ä¼šæ”¹å†™ä»»ä½•å†…å­˜åœ°å€ã€‚é‚£ä¹ˆç¼–è¯‘å™¨ä¼šå˜å¾—ä¿å®ˆèµ·æ¥ï¼Œå®ƒä¼šé˜²æ­¢è¿™æ¡fenceå‘½ä»¤ä¸Šæ–¹çš„å†…å­˜è®¿é—®æ“ä½œç§»åˆ°ä¸‹æ–¹ï¼ŒåŒæ—¶é˜²æ­¢ä¸‹æ–¹çš„æ“ä½œç§»åˆ°ä¸Šé¢ï¼Œä¹Ÿå°±æ˜¯é˜²æ­¢äº†ä¹±åºï¼Œæ˜¯æˆ‘ä»¬æƒ³è¦çš„ç»“æœã€‚</p>

<p>ä½†è¿™è¿˜æ²¡å®Œï¼Œè¿™æ¡å‘½ä»¤è¿˜æœ‰å¦å¤–ä¸€ä¸ªå‰¯ä½œç”¨ï¼šå®ƒä¼šè®©ç¼–è¯‘å™¨æŠŠæ‰€æœ‰ç¼“å­˜åœ¨å¯„å­˜å™¨ä¸­çš„å†…å­˜å˜é‡flushåˆ°å†…å­˜ä¸­ï¼Œç„¶åé‡æ–°ä»å†…å­˜ä¸­è¯»å–è¿™äº›å€¼ã€‚è¿™å¹¶ä¸ä¸€å®šæ˜¯æˆ‘ä»¬æƒ³è¦çš„ç»“æœï¼Œæ¯”å¦‚æœ‰äº›å˜é‡åªåœ¨å½“å‰çº¿ç¨‹ä¸­ä½¿ç”¨ï¼Œç•™åœ¨å¯„å­˜å™¨ä¸­å¾ˆå¥½ï¼Œå¤šäº†ä¸€å¯¹å†™/è¯»å†…å­˜æ“ä½œæ˜¯ä¸å¿…è¦çš„å¼€é”€ã€‚</p>

<p>é‚£ä¹ˆæœ‰æ²¡æœ‰åŠæ³•é¿å…è¿™ç§å‰¯ä½œç”¨å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥é€šè¿‡gccå†…è”æ±‡ç¼–å‘½ä»¤çš„inputå’Œoutputæ“ä½œç¬¦æ˜ç¡®æŒ‡å®šå“ªäº›å†…å­˜æ“ä½œä¸èƒ½ä¹±åºï¼Œå¦‚è¿™ä¸ªä¾‹å­ï¼š</p>

<p>WRITE(x)
asm volatile(â€œâ€: â€œ=mâ€(y) : â€œmâ€(x):) // memory fence
READ(y)
è¿™é‡Œå…ˆå¯¹å˜é‡xè¿›è¡Œå†™æ“ä½œï¼Œåå¯¹å˜é‡yè¿›è¡Œè¯»æ“ä½œï¼Œä¸­é—´çš„å†…è”æ±‡ç¼–å‘Šè¯‰ç¼–è¯‘å™¨æ’å…¥ä¸€æ¡æŒ‡ä»¤ï¼ˆå…¶å®æ˜¯ç©ºçš„ï¼‰ï¼Œå®ƒå¯èƒ½ä¼šè¯»xçš„å†…å­˜ï¼Œä¼šå†™yçš„å†…å­˜ï¼Œå› æ­¤ç¼–è¯‘å™¨ä¸ä¼šæŠŠè¿™ä¸¤ä¸ªæ“ä½œä¹±åºã€‚è¿™ç§æ˜ç¡®çš„memory fenceçš„å¥½å¤„æ˜¯ï¼šä½¿ç¼–è¯‘å™¨å°½é‡å°‘çš„å¯¹å…¶ä»–ä¸ç›¸å…³çš„å˜é‡é€ æˆå½±å“ï¼Œé¿å…äº†é¢å¤–å¼€é”€ã€‚</p>

<p>CPU Fence
X86å±äºstrong memory modelï¼Œè¿™æ„å‘³ç€åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹cpuä¼šä¿è¯å†…å­˜è®¿é—®æŒ‡ä»¤æœ‰åºæ‰§è¡Œã€‚å…·ä½“çš„è¯´ï¼Œå¦‚æœå¯¹å†…å­˜è¯»(Load)å’Œå†™(Store)æ“ä½œè¿›è¡Œä¸¤ä¸¤ç»„åˆï¼šLoadLoad, LoadStore, StoreLoad, StoreStoreï¼Œåªæœ‰StoreLoadç»„åˆå¯èƒ½ä¹±åºï¼Œè€Œä¸”Storeå’ŒLoadçš„å†…å­˜åœ°å€å¿…é¡»æ˜¯ä¸ä¸€æ ·çš„ã€‚åœ¨ä¸Šé¢çš„é˜Ÿåˆ—æ¨¡æ¿åº“çš„ä¾‹å­ä¸­ï¼Œç”±äºåªä½¿ç”¨äº†StoreStoreï¼ˆå¯¹åº”C++11çš„Release memory order)å’ŒLoadLoad(å¯¹åº”C++11çš„Acquire memory order)ï¼Œå› æ­¤ä¸éœ€è¦é¢å¤–çš„CPU fence</p>

<p>åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬è¢«å‘ŠçŸ¥æ¯”èµ·Thread.VolatileReadæ›´å–œæ¬¢Volatile.Readï¼Œå› ä¸ºåè€…æ•£å‘å…¨å›´æ ï¼Œè€Œå‰è€…ä»…æ•£å‘ç›¸å…³çš„åŠå›´æ ï¼ˆä¾‹å¦‚è·å–å›´æ ï¼‰;æ•ˆç‡æ›´é«˜ã€‚</p>

<p>However, in my understanding, Thread.VolatileRead actually offers something that Volatile.Read does not, because of the implementation of Thread.VolatileRead:</p>

<p>public static int VolatileRead(ref int address) {
  int num = address;
  Thread.MemoryBarrier();
  return num;
}
Because of the full memory barrier on the second line of the implementation, I believe that VolatileRead actually ensures that the value last written to address will be read. According to Wikipedia, â€œA full fence ensures that all load and store operations prior to the fence will have been committed prior to any loads and stores issued following the fence.â€.</p>

<p>Is my understanding correct? And therefore, does Thread.VolatileRead still offer something that Volatile.Read does not?</p>

<p>æœ€ä½³ç­”æ¡ˆ
æˆ‘å¯èƒ½è¿˜æ²¡æ¥å¾—åŠç©æ¸¸æˆï¼Œä½†æˆ‘è¿˜æ˜¯æƒ³æ’è¯ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å°±ä¸€äº›åŸºæœ¬å®šä¹‰è¾¾æˆå…±è¯†ã€‚</p>

<p>Acquisition-fenceï¼ˆè·å–æ …æ ï¼‰ï¼šä¸€ç§å†…å­˜å±éšœï¼Œä¸å…è®¸å…¶ä»–è¯»å–å’Œå†™å…¥åœ¨æ …æ ä¹‹å‰ç§»åŠ¨ã€‚
é‡Šæ”¾æ …æ ï¼šä¸€ç§å†…å­˜å±éšœï¼Œä¸å…è®¸å…¶ä»–è¯»å–å’Œå†™å…¥åœ¨ç¯±ç¬†åé¢ç§»åŠ¨ã€‚
æˆ‘å–œæ¬¢ä½¿ç”¨ç®­å¤´ç¬¦å·æ¥å¸®åŠ©è¯´æ˜å›´æ çš„ä½œç”¨ã€‚ â†‘ç®­å¤´è¡¨ç¤ºé‡Šæ”¾æ …æ ï¼Œè€Œâ†“ç®­å¤´è¡¨ç¤ºæ•è·æ …æ ã€‚å¯ä»¥å°†ç®­å¤´æƒ³åƒæˆæŒ‰ç®­å¤´æ–¹å‘æ¨åŠ¨å†…å­˜è®¿é—®ã€‚ä½†æ˜¯ï¼Œè¿™ä¸€ç‚¹å¾ˆé‡è¦ï¼Œå†…å­˜è®¿é—®å¯ä»¥è¶Šè¿‡å°¾å·´ã€‚é˜…è¯»ä¸Šé¢çš„å›´æ çš„å®šä¹‰ï¼Œå¹¶ç¡®ä¿¡ç®­å¤´ä»è§†è§‰ä¸Šä»£è¡¨è¿™äº›å®šä¹‰ã€‚</p>

<p>Using this notation let us analyze the examples from JaredParâ€™s answer starting with Volatile.Read. But, first let me make the point that Console.WriteLine probably produces a full-fence barrier unbeknownst to us. We should pretend for a moment that it does not to make the examples easier to follow. In fact, I will just omit the call entirely as it is unnecessary in the context of what we are trying to achieve.</p>

<p>// Example using Volatile.Read
x = 13;
var local = y; // Volatile.Read
â†“              // acquire-fence
z = 13;
So using the arrow notation we more easily see that the write to z cannot move up and before the read of y. Nor can the read of y move down and after the write of z because that would be effectively same as the other way around. In other words, it locks the relative ordering of y and z. However, the read of y and the write to x can be swapped as there is no arrow head preventing that movement. Likewise, the write to x can move past the tail of the arrow and even past the write to z. The specification technically allows for that..theoretically anyway. That means we have the following valid orderings.</p>

<h2 id="volatileread">Volatile.Read</h2>
<p>write x    |    read y     |    read y
read y     |    write x    |    write z
write z    |    write z    |    write x
Now let us move on to the example with Thread.VolatileRead. For the sake of the example I will inline the call to Thread.VolatileRead to make it easier to visualize.</p>

<p>// Example using Thread.VolatileRead
x = 13;
var local = y; // inside Thread.VolatileRead
â†‘              // Thread.MemoryBarrier / release-fence
â†“              // Thread.MemoryBarrier / acquire-fence
z = 13;
Look closely. There is no arrow (because there is no memory barrier) between the write to x and the read of y. That means these memory accesses are still free to move around relative to each other. However, the call to Thread.MemoryBarrier, which produces the additional release-fence, makes it appear as if the next memory access had volatile write semantics. This means the writes to x and z can no longer be swapped.</p>

<h2 id="threadvolatileread">Thread.VolatileRead</h2>
<p>write x    |    read y
read y     |    write x
write z    |    write z
å½“ç„¶ï¼Œæœ‰äººå£°ç§°Microsoftçš„CLIï¼ˆ.NET Frameworkï¼‰å’Œx86ç¡¬ä»¶çš„å®ç°å·²ç»ä¿è¯äº†æ‰€æœ‰å†™å…¥çš„é‡Šæ”¾èŒƒå›´è¯­ä¹‰ã€‚å› æ­¤ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¸¤ä¸ªè°ƒç”¨ä¹‹é—´å¯èƒ½æ²¡æœ‰ä»»ä½•åŒºåˆ«ã€‚åœ¨å…·æœ‰Monoçš„ARMå¤„ç†å™¨ä¸Šï¼Ÿåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæƒ…å†µå¯èƒ½ä¼šæœ‰æ‰€ä¸åŒã€‚</p>

<p>ç°åœ¨è®©æˆ‘ä»¬ç»§ç»­å¤„ç†æ‚¨çš„é—®é¢˜ã€‚</p>

<p>ç”±äºç¬¬äºŒè¡Œçš„å†…å­˜å·²æ»¡   å®æ–½ï¼Œæˆ‘ç›¸ä¿¡VolatileReadå®é™…ä¸Šå¯ä»¥ç¡®ä¿   ä¸Šæ¬¡å†™å…¥åœ°å€çš„å€¼å°†è¢«è¯»å–ã€‚æ˜¯æˆ‘çš„ç†è§£   æ­£ç¡®ï¼Ÿ
ä¸ï¼Œè¿™æ˜¯ä¸æ­£ç¡®çš„ï¼æ˜“å¤±æ€§è¯»å–ä¸â€œæ–°é²œè¯»å–â€ä¸åŒã€‚ä¸ºä»€ä¹ˆï¼Ÿè¿™æ˜¯å› ä¸ºå­˜å‚¨å±éšœä½äºè¯»å–æŒ‡ä»¤ä¹‹åã€‚è¿™æ„å‘³ç€å®é™…è¯»å–ä»ç„¶å¯ä»¥éšæ—¶é—´å‘ä¸Šæˆ–å‘åç§»åŠ¨ã€‚å¦ä¸€ä¸ªçº¿ç¨‹å¯ä»¥å†™å…¥è¯¥åœ°å€ï¼Œä½†æ˜¯å½“å‰çº¿ç¨‹å¯èƒ½å·²ç»å°†è¯»å–ç§»åŠ¨åˆ°å¦ä¸€ä¸ªçº¿ç¨‹æäº¤å®ƒä¹‹å‰çš„æ—¶é—´ç‚¹ã€‚</p>

<p>å› æ­¤ï¼Œè¿™å°±å¼•å‡ºäº†ä¸€ä¸ªé—®é¢˜ï¼šâ€œå¦‚æœçœ‹ä¼¼å¾ˆå°‘çš„ä¿è¯ï¼Œäººä»¬ä¸ºä»€ä¹ˆè¿˜è¦çƒ¦æ¼ä½¿ç”¨æ˜“å¤±æ€§è¯»å–å‘¢ï¼Ÿâ€ã€‚ç­”æ¡ˆæ˜¯ï¼Œå®ƒç»å¯¹ä¿è¯ä¸‹ä¸€ä¸ªè¯»å–æ¯”ä¹‹å‰çš„è¯»å–è¦æ–°ã€‚è¿™å°±æ˜¯å®ƒçš„ä»·å€¼ï¼è¿™å°±æ˜¯ä¸ºä»€ä¹ˆè®¸å¤šæ— é”ä»£ç ä¼šå¾ªç¯æ—‹è½¬ï¼Œç›´åˆ°é€»è¾‘å¯ä»¥ç¡®å®šæ“ä½œæˆåŠŸå®Œæˆä¸ºæ­¢ã€‚æ¢å¥è¯è¯´ï¼Œæ— é”ä»£ç é‡‡ç”¨äº†è¿™æ ·çš„æ¦‚å¿µï¼Œå³åœ¨å¤šæ¬¡è¯»å–çš„åºåˆ—ä¸­åæ¥çš„è¯»å–å°†è¿”å›è¾ƒæ–°çš„å€¼ï¼Œä½†æ˜¯è¯¥ä»£ç ä¸åº”å‡å®šä»»ä½•è¯»å–å¿…é¡»ä»£è¡¨æœ€æ–°çš„å€¼ã€‚</p>

<p>è€ƒè™‘ä¸€ä¸‹ã€‚æ— è®ºå¦‚ä½•ï¼Œè¯»å–è¿”å›æœ€æ–°å€¼æ„å‘³ç€ä»€ä¹ˆï¼Ÿåˆ°æ‚¨ä½¿ç”¨è¯¥å€¼æ—¶ï¼Œå®ƒå¯èƒ½ä¸å†æ˜¯æœ€æ–°çš„äº†ã€‚å¦ä¸€ä¸ªçº¿ç¨‹å¯èƒ½å·²ç»å°†ä¸åŒçš„å€¼å†™å…¥ç›¸åŒçš„åœ°å€ã€‚æ‚¨è¿˜èƒ½å°†å…¶ç§°ä¸ºæœ€æ–°å€¼å—ï¼Ÿ</p>

<p>ä½†æ˜¯ï¼Œåœ¨è€ƒè™‘äº†ä¸Šé¢è®¨è®ºçš„â€œæ–°é²œâ€é˜…è¯»ç”šè‡³æ„å‘³ç€ä»€ä¹ˆçš„è­¦å‘Šä¹‹åï¼Œæ‚¨ä»ç„¶æƒ³è¦æŸç§è¡Œä¸ºåƒâ€œæ–°é²œâ€é˜…è¯»ä¸€æ ·ï¼Œç„¶åéœ€è¦åœ¨é˜…è¯»ä¹‹å‰æ”¾ç½®ä¸€ä¸ªè·å–æ …æ ã€‚è¯·æ³¨æ„ï¼Œè¿™æ˜¾ç„¶ä¸æ˜“å¤±æ€§è¯»å–ä¸åŒï¼Œä½†æœ€å¥½ä¸å¼€å‘äººå‘˜å¯¹â€œæ–°é²œâ€å«ä¹‰çš„ç›´è§‰ç›¸åŒ¹é…ã€‚ç„¶è€Œï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæœ¯è¯­â€œæ–°é²œâ€ä¸æ˜¯ç»å¯¹çš„ã€‚ç›¸åï¼Œç›¸å¯¹äºå±éšœï¼Œè¯»å–æ˜¯â€œæ–°é²œçš„â€ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå®ƒä¸èƒ½æ—©äºæ‰§è¡Œå±éšœçš„æ—¶é—´ç‚¹ã€‚ä½†æ˜¯ï¼Œå¦‚ä¸Šæ‰€è¿°ï¼Œè¯¥å€¼å¯èƒ½æ— æ³•ä»£è¡¨æ‚¨åœ¨ä½¿ç”¨æˆ–åŸºäºè¯¥å€¼åšå‡ºå†³å®šæ—¶çš„æœ€æ–°å€¼ã€‚</p>

<p>atomic_thread_fenceçš„å›´æ ä½œç”¨åŸŸæ˜¯å¦å·²è¢«æŒ‡å®šä¸ºâ€œ {}â€çš„ä½œç”¨åŸŸå•å…ƒï¼Ÿ</p>

<p>ä¾‹å¦‚ï¼Œ
MainActivity C ++</p>

<p>//section A
if(A == 1)
{
   //section B
   atomic_thread_fence(..);
   //section C
}
//section D</p>

<p>å…³äºä¸Šè¿°ä»£ç ï¼Œæˆ‘æƒ³çŸ¥é“å›´æ æ˜¯å¦ä»…é€‚ç”¨äºBéƒ¨åˆ†å’ŒCéƒ¨åˆ†ï¼Œæˆ–è€…æ˜¯å¦ä¹Ÿé€‚ç”¨äºå…¶ä»–éƒ¨åˆ†ã€‚</p>

<p>æ …æ æ²¡æœ‰èŒƒå›´çš„æ¦‚å¿µã€‚å–è€Œä»£ä¹‹çš„æ˜¯ï¼Œå®ƒä»¬å…·æœ‰åœ¨æ …æ ä¹‹å‰çš„åŠ è½½/å­˜å‚¨å’Œåœ¨æ …æ ä¹‹åçš„åŠ è½½/å­˜å‚¨çš„æ¦‚å¿µï¼šåœ¨æ‚¨çš„ç¤ºä¾‹ä¸­ï¼Œä¹‹å‰çš„åŠ è½½/å­˜å‚¨åŒ…æ‹¬Bå’ŒAéƒ¨åˆ†ï¼ˆä»¥åŠä¹‹å‰ï¼‰çš„åŠ è½½/å­˜å‚¨ã€‚å›´æ ä¹‹åçš„è£…è½½å’Œå­˜æ”¾åŒ…æ‹¬Cå’ŒDéƒ¨åˆ†ï¼ˆåŠå…¶åï¼‰çš„è£…è½½å’Œå­˜æ”¾ã€‚</p>

<p>å¹¶ä¸”ï¼Œä»…å½“A == 1æ—¶ï¼Œå›´æ æ‰æœ‰æ•ˆï¼ˆå³ï¼Œä½äºæœªé‡‡ç”¨çš„åˆ†æ”¯ä¸­çš„å›´æ ä¸ä¼šæœ‰ä»»ä½•å‰¯ä½œç”¨ï¼‰ã€‚</p>
:ET