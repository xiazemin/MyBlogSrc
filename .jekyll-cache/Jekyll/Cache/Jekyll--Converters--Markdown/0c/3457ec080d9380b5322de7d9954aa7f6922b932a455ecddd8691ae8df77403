I"!<p>当redis中key数量越大，keys 命令执行越慢，而且最重要的会阻塞服务器，对单线程的redis来说，简直是灾难，终于找到了替代命令scan。<br />
SCAN cursor [MATCH pattern] [COUNT count]</p>

<p>SCAN 命令及其相关的 SSCAN 命令、 HSCAN 命令和 ZSCAN 命令都用于增量地迭代（incrementally iterate）一集元素（a collection of elements）：
<!-- more -->
SCAN 命令用于迭代当前数据库中的数据库键。</p>

<p>SSCAN 命令用于迭代集合键中的元素。</p>

<p>HSCAN 命令用于迭代哈希键中的键值对。</p>

<p>ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。</p>

<p>以上列出的四个命令都支持增量式迭代， 它们每次执行都只会返回少量元素， 所以这些命令可以用于生产环境， 而不会出现像 KEYS命令、 SMEMBERS 命令带来的问题 —— 当 KEYS 命令被用于处理一个大的数据库时， 又或者 SMEMBERS 命令被用于处理一个大的集合键时， 它们可能会阻塞服务器达数秒之久。</p>

<p>不过， 增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 （offer limited guarantees about the returned elements）。</p>

<p>因为 SCAN 、 SSCAN 、 HSCAN 和 ZSCAN 四个命令的工作方式都非常相似， 所以这个文档会一并介绍这四个命令， 但是要记住：</p>

<p>SSCAN 命令、 HSCAN 命令和 ZSCAN 命令的第一个参数总是一个数据库键。</p>

<p>而 SCAN 命令则不需要在第一个参数提供任何数据库键 —— 因为它迭代的是当前数据库中的所有数据库键。</p>

<p>scan 0 默认返回10条数据。</p>

<p>127.0.0.1:6379&gt; scan 0</p>

<p>1) “81920”
2)  1) “CMD:1000004739:4”
    2) “CMD:1000010475:2”
    3) “CMD:380071400001208:766”
    4) “CMD:1000006866:LIST”
    5) “CMD:380071400001208:20415”
    6) “CMD:380071400001231:21530”
    7) “CMD:380071400001208:21780”
    8) “CMD:7485630165:LIST”
    9) “CMD:1000001545:2”
   10) “CMD:380071400001231:4387”</p>

<p>可以用count 参数指定返回数据量：</p>

<p>127.0.0.1:6379&gt; scan 0 count 100</p>

<p>1) “104448”
2)   1) “CMD:1000004739:4”
     2) “CMD:1000010475:2”
     3) “CMD:380071400001208:766”
     4) “CMD:1000006866:LIST”
     5) “CMD:380071400001208:20415”
     6) “CMD:380071400001231:21530”
     7) “CMD:380071400001208:21780”
     8) “CMD:7485630165:LIST”
     9) “CMD:1000001545:2”
    10) “CMD:380071400001231:4387”
    ……
    94) “CMD:201610200062:6”
    95) “CMD:VF3748211006:3”
    96) “CMD:1000009121:4”
    97) “CMD:380071400001231:6563”
    98) “CMD:1000010252:ID”
    99) “CMD:1000005261:5”
   100) “SERVER:45568_0”</p>

<p>使用match 参数来匹配模式：</p>

<p>127.0.0.1:6379&gt; scan 0 match CMD* count 100</p>

<p>1) “104448”
2)  1) “CMD:1000004739:4”
    2) “CMD:1000010475:2”
    3) “CMD:380071400001208:766”
    4) “CMD:1000006866:LIST”
    5) “CMD:380071400001208:20415”
    6) “CMD:380071400001231:21530”
    7) “CMD:380071400001208:21780”
    8) “CMD:7485630165:LIST”
    9) “CMD:1000001545:2”
   10) “CMD:380071400001231:4387”
   ……
   86) “CMD:201610200062:6”
   87) “CMD:VF3748211006:3”
   88) “CMD:1000009121:4”
   89) “CMD:380071400001231:6563”
   90) “CMD:1000010252:ID”
   91) “CMD:1000005261:5”</p>

<p>最重要的是scan不会阻塞服务器，现网环境也可以用，真方便。</p>

<p>Redis的危险命令主要有以下几个</p>

<p>keys
查找所有符合给定模式pattern（正则表达式）的 key 。
时间复杂度为O(N)，N为数据库里面key的数量。
速度极快，在一百万的key数据库中查询时间大约是40毫秒。
redis&gt; MSET one 1 two 2 three 3 four 4
OK
redis&gt; KEYS <em>o</em>
1) “four”
2) “one”
3) “two”
redis&gt; KE
警告：不建议使用！！！</p>

<p>对 Redis 稍微有点使用经验的人都知道线上是不能执行 keys * 相关命令的，虽然其模糊匹配功能使用非常方便也很强大，在小数据量情况下使用没什么问题，数据量大会导致 Redis 锁住及 CPU 飙升，在生产环境建议禁用或者重命名！</p>

<p>血的教训：某公司工程师在生产环境中直接执行：key * wxdb … cf8* 命令，导致redis卡死锁住，CPU飙升，导致支付链路卡住，所有请求卡死在数据库中，导致数据库发生雪崩效应，发生了数据库宕机事件。 损失惨重！</p>

<p>flushdb
删除Redis中当前所在数据库中的所有记录，并且该命令是原子性的，不会终止执行，一旦执行，将不会执行失败。</p>

<p>flushall
删除Redis中所有数据库中的所有记录，并且该命令是原子性的，不会终止执行，一旦执行，将不会执行失败。</p>

<p>config 
客户端可修改 Redis 配置 </p>

<p> </p>

<p> 解决方案-命令禁用
在redis中修改配置文件redis.conf找到 SECURITY 区域，如下图</p>

<p>################################## SECURITY ###################################</p>

<h1 id="require-clients-to-issue-auth--before-processing-any-other">Require clients to issue AUTH <PASSWORD> before processing any other</PASSWORD></h1>
<h1 id="commands--this-might-be-useful-in-environments-in-which-you-do-not-trust">commands.  This might be useful in environments in which you do not trust</h1>
<h1 id="others-with-access-to-the-host-running-redis-server">others with access to the host running redis-server.</h1>
<p>#</p>
<h1 id="this-should-stay-commented-out-for-backward-compatibility-and-because-most">This should stay commented out for backward compatibility and because most</h1>
<h1 id="people-do-not-need-auth-eg-they-run-their-own-servers">people do not need auth (e.g. they run their own servers).</h1>
<p>#</p>
<h1 id="warning-since-redis-is-pretty-fast-an-outside-user-can-try-up-to">Warning: since Redis is pretty fast an outside user can try up to</h1>
<h1 id="150k-passwords-per-second-against-a-good-box-this-means-that-you-should">150k passwords per second against a good box. This means that you should</h1>
<h1 id="use-a-very-strong-password-otherwise-it-will-be-very-easy-to-break">use a very strong password otherwise it will be very easy to break.</h1>
<p>#</p>
<h1 id="requirepass-foobared">requirepass foobared</h1>

<h1 id="command-renaming">Command renaming.</h1>
<p>#</p>
<h1 id="it-is-possible-to-change-the-name-of-dangerous-commands-in-a-shared">It is possible to change the name of dangerous commands in a shared</h1>
<h1 id="environment-for-instance-the-config-command-may-be-renamed-into-something">environment. For instance the CONFIG command may be renamed into something</h1>
<h1 id="hard-to-guess-so-that-it-will-still-be-available-for-internal-use-tools">hard to guess so that it will still be available for internal-use tools</h1>
<h1 id="but-not-available-for-general-clients">but not available for general clients.</h1>
<p>#</p>
<h1 id="example">Example:</h1>
<p>#</p>
<h1 id="rename-command-config-b840fc02d524045429941cc15f59e41cb7be6c52">rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</h1>
<p>#</p>
<h1 id="it-is-also-possible-to-completely-kill-a-command-by-renaming-it-into">It is also possible to completely kill a command by renaming it into</h1>
<h1 id="an-empty-string">an empty string:</h1>
<p>#</p>
<h1 id="rename-command-config-">rename-command CONFIG “”</h1>
<p>#</p>
<h1 id="please-note-that-changing-the-name-of-commands-that-are-logged-into-the">Please note that changing the name of commands that are logged into the</h1>
<h1 id="aof-file-or-transmitted-to-slaves-may-cause-problems">AOF file or transmitted to slaves may cause problems.</h1>
<p>注意其中的rename-command ，修改即可完成命令禁用</p>

<p>禁用命令</p>

<p>rename-command KEYS     “”
rename-command FLUSHALL “”
rename-command FLUSHDB  “”
rename-command CONFIG   “”
重命名命令</p>

<p>rename-command KEYS     “XXXXX”
rename-command FLUSHALL “XXXXX”
rename-command FLUSHDB  “XXXXX”
rename-command CONFIG   “XXXXX”
这样可以定义新命令，然后在客户端就不会执行危险命令了</p>
:ET