I"÷ƒ<p>golang httpçš„handleæ¨¡å—ï¼ˆä¸€èˆ¬ä¹Ÿç§°ä¸ºé’©å­æ¨¡å—ï¼‰ï¼Œé€šè¿‡é«˜çº§è¯­è¨€çš„åŒ¿åå‡½æ•°å¾ˆå®¹æ˜“å®ç°è¿™ç§å†…åµŒåŠŸèƒ½çš„handle</p>

<p>æˆ‘ä»¬ä¸€èˆ¬è¿™æ ·ä½¿ç”¨golangçš„http HandleFuncæ¥ä¸ºhttpçš„serverç«¯åšç›¸åº”çš„å¤„ç†</p>

<p>/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong><em>/
        http.HandleFunc(â€œ/â€, xxx_FUN)
	err := http.ListenAndServe(â€œ:8080â€, nil)
	if err != nil {
		log.Fatal(â€œListenAndServe: â€œ, err)
	}
  /</em></strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>/
<!-- more -->
æºç ä»”ç»†çœ‹çœ‹http.HandleFuncçš„å®ç°</p>

<p>func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	DefaultServeMux.HandleFunc(pattern, handler)
}</p>

<p>// NewServeMux allocates and returns a new ServeMux.
var DefaultServeMux = NewServeMux()
func NewServeMux() *ServeMux { return &amp;ServeMux{m: make(map[string]muxEntry)} }</p>

<p>type ServeMux struct {
	mu    sync.RWMutex                   //ä¸€ä¸ªè¯»å†™é”
	m     map[string]muxEntry            //ä¸€ä¸ªpath(patterns)çš„æ˜ å°„map
	hosts bool                          // whether any patterns contain hostnames
}
å†æ¥çœ‹çœ‹ListenAndServeçš„å…·ä½“å®ç°</p>

<p>func ListenAndServe(addr string, handler Handler) error {
	server := &amp;Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}</p>

<p>func (srv <em>Server) ListenAndServe() error {
	addr := srv.Addr
	if addr == â€œâ€ {
		addr = â€œ:httpâ€
	}
	ln, err := net.Listen(â€œtcpâ€, addr)
	if err != nil {
		return err
	}
	return srv.Serve(tcpKeepAliveListener{ln.(</em>net.TCPListener)})
}</p>

<p>// Serve accepts incoming connections on the Listener l, creating a
// new service goroutine for each.  The service goroutines read requests and
// then call srv.Handler to reply to them.
func (srv *Server) Serve(l net.Listener) error {
	defer l.Close()
	var tempDelay time.Duration // how long to sleep on accept failure
	for {
		rw, e := l.Accept()
		if e != nil {
			if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() {
				if tempDelay == 0 {
					tempDelay = 5 * time.Millisecond
				} else {
					tempDelay *= 2
				}
				if max := 1 * time.Second; tempDelay &gt; max {
					tempDelay = max
				}
				srv.logf(â€œhttp: Accept error: %v; retrying in %vâ€, e, tempDelay)
				time.Sleep(tempDelay)
				continue
			}
			return e
		}
		tempDelay = 0
		c, err := srv.newConn(rw)
		if err != nil {
			continue
		}
		c.setState(c.rwc, StateNew) // before Serve can return
		go c.serve() //çœ‹æ¥è¿™ä¸ªc.serveæ˜¯å¤„ç†çš„å…¥å£
	}
}
çœ‹æ¥è¿™ä¸ªc.serveæ˜¯å¤„ç†çš„å…¥å£</p>

<p>// Serve a new connection.
func (c *conn) serve() {
	origConn := c.rwc // copy it before itâ€™s set nil on Close or Hijack
	defer func() {
		if err := recover(); err != nil {
			const size = 64 Â«Â 10
			buf := make([]byte, size)
			buf = buf[:runtime.Stack(buf, false)]
			c.server.logf(â€œhttp: panic serving %v: %v\n%sâ€, c.remoteAddr, err, buf)
		}
		if !c.hijacked() {
			c.close()
			c.setState(origConn, StateClosed)
		}
	}()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if tlsConn, ok := c.rwc.(*tls.Conn); ok {
	if d := c.server.ReadTimeout; d != 0 {
		c.rwc.SetReadDeadline(time.Now().Add(d))
	}
	if d := c.server.WriteTimeout; d != 0 {
		c.rwc.SetWriteDeadline(time.Now().Add(d))
	}
	if err := tlsConn.Handshake(); err != nil {
		c.server.logf("http: TLS handshake error from %s: %v", c.rwc.RemoteAddr(), err)
		return
	}
	c.tlsState = new(tls.ConnectionState)
	*c.tlsState = tlsConn.ConnectionState()
	if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {
		if fn := c.server.TLSNextProto[proto]; fn != nil {
			h := initNPNRequest{tlsConn, serverHandler{c.server}}
			fn(c.server, tlsConn, h)
		}
		return
	}
}

for {
	w, err := c.readRequest()
	if c.lr.N != c.server.initialLimitedReaderSize() {
		// If we read any bytes off the wire, we're active.
		c.setState(c.rwc, StateActive)
	}
	if err != nil {
		if err == errTooLarge {
			// Their HTTP client may or may not be
			// able to read this if we're
			// responding to them and hanging up
			// while they're still writing their
			// request.  Undefined behavior.
			io.WriteString(c.rwc, "HTTP/1.1 413 Request Entity Too Large\r\n\r\n")
			c.closeWriteAndWait()
			break
		} else if err == io.EOF {
			break // Don't reply
		} else if neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() {
			break // Don't reply
		}
		io.WriteString(c.rwc, "HTTP/1.1 400 Bad Request\r\n\r\n")
		break
	}

	// Expect 100 Continue support
	req := w.req
	if req.expectsContinue() {
		if req.ProtoAtLeast(1, 1) &amp;&amp; req.ContentLength != 0 {
			// Wrap the Body reader with one that replies on the connection
			req.Body = &amp;expectContinueReader{readCloser: req.Body, resp: w}
		}
		req.Header.Del("Expect")
	} else if req.Header.get("Expect") != "" {
		w.sendExpectationFailed()
		break
	}

	// HTTP cannot have multiple simultaneous active requests.[*]
	// Until the server replies to this request, it can't read another,
	// so we might as well run the handler in this goroutine.
	// [*] Not strictly true: HTTP pipelining.  We could let them all process
	// in parallel even if their responses need to be serialized.
	serverHandler{c.server}.ServeHTTP(w, w.req) //è¿™ä¸ªæ˜¯å…¥å£
	if c.hijacked() {
		return
	}
	w.finishRequest()
	if w.closeAfterReply {
		if w.requestBodyLimitHit {
			c.closeWriteAndWait()
		}
		break
	}
	c.setState(c.rwc, StateIdle)
} } Handlerå¤„ç†çš„å…¥å£å°±æ˜¯serverHandler{c.server}.ServerHTTP(w,w.req)ï¼Œæœ€ç»ˆåˆ°HandleFuncçš„æ‰§è¡Œ
</code></pre></div></div>

<p>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {
	if r.Method != â€œCONNECTâ€ {
		if p := cleanPath(r.URL.Path); p != r.URL.Path {
			_, pattern = mux.handler(r.Host, p) //æ¥ä¸‹æ¥å¤„ç†
			url := *r.URL
			url.Path = p
			return RedirectHandler(url.String(), StatusMovedPermanently), pattern
		}
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return mux.handler(r.Host, r.URL.Path) //æ¥ä¸‹æ¥å¤„ç† }
</code></pre></div></div>

<p>func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
	mux.mu.RLock()
	defer mux.mu.RUnlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Host-specific pattern takes precedence over generic ones
if mux.hosts {
	h, pattern = mux.match(host + path)
}
if h == nil {
	h, pattern = mux.match(path)
}
if h == nil {
	h, pattern = NotFoundHandler(), "" //å¦‚æœhandlerå¯¹åº”çš„åŒ¿åå‡½æ•°ä¸ºç©º,åˆ™è¿”å›é»˜è®¤çš„åŒ¿åå‡½æ•°
}
return }
</code></pre></div></div>

<p>// ServeHTTP dispatches the request to the handler whose
// pattern most closely matches the request URL.
func (mux <em>ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
	if r.RequestURI == â€œ</em>â€ {
		if r.ProtoAtLeast(1, 1) {                               <br />
			w.Header().Set(â€œConnectionâ€, â€œcloseâ€)
		}
		w.WriteHeader(StatusBadRequest)
		return
	}
	h, _ := mux.Handler(r) //æ¥ä¸‹æ¥å¤„ç†
	h.ServeHTTP(w, r) //æ¥ä¸‹æ¥å¤„ç†
}</p>

<p>//æ¥ä¸‹æ¥å°±åˆå§‹æ—¶å€™æ‰§è¡Œçš„æ“ä½œ
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	mux.Handle(pattern, HandlerFunc(handler))
}
func (mux *ServeMux) Handle(pattern string, handler Handler) {  //å¤„ç†pattern
	mux.mu.Lock()
	defer mux.mu.Unlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if pattern == "" {
	panic("http: invalid pattern " + pattern)
}
if handler == nil {
	panic("http: nil handler")
}
if mux.m[pattern].explicit {
	panic("http: multiple registrations for " + pattern)
}

mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern} //è®¾ç½®ServeMuxçš„map

if pattern[0] != '/' {
	mux.hosts = true
}

// Helpful behavior:
// If pattern is /tree/, insert an implicit permanent redirect for /tree.
// It can be overridden by an explicit registration.
n := len(pattern)
if n &gt; 0 &amp;&amp; pattern[n-1] == '/' &amp;&amp; !mux.m[pattern[0:n-1]].explicit {
	// If pattern contains a host name, strip it and use remaining
	// path for redirect.
	path := pattern
	if pattern[0] != '/' {
		// In pattern, at least the last character is a '/', so
		// strings.Index can't be -1.
		path = pattern[strings.Index(pattern, "/"):]
	}
	mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(path, StatusMovedPermanently), pattern: pattern}
} } æœ€åå†çœ‹çœ‹é€šè¿‡muxåŒ¹é…è·å–å¯¹åº”çš„mapçš„æ“ä½œï¼š
</code></pre></div></div>

<p>func (mux *ServeMux) match(path string) (h Handler, pattern string) {
	var n = 0
	for k, v := range mux.m {
		if !pathMatch(k, path) {   //åŒ¹é…
			continue
		}
		if h == nil || len(k) &gt; n {
			n = len(k)
			h = v.h
			pattern = v.pattern
		}
	}
	return
}</p>

<p>type Server struct {
    Addr              string        // è¦ç›‘å¬çš„ TCP åœ°å€
    Handler           Handler       // è°ƒç”¨çš„ handler, å¦‚æœä¸ºç©ºåˆ™ç”¨ http.DefaultServeMux
    TLSConfig         <em>tls.Config   // ç”¨äº ServeTLS å’Œ ListenAndServeTLS
    ReadTimeout       time.Duration // è¯»å–å®Œæ•´ request (åŒ…æ‹¬ body) çš„æœ€å¤§æ—¶é•¿ï¼Œå¯ä»¥å’Œ ReadHeaderTimeout åŒæ—¶ä½¿ç”¨
    ReadHeaderTimeout time.Duration // è¯»å– request headers çš„æœ€å¤§æ—¶é•¿
    WriteTimeout      time.Duration // å†™ response çš„æœ€å¤§æ—¶é•¿
    IdleTimeout       time.Duration // å½“ keepalive å¼€å¯æ—¶ç­‰å¾…ä¸‹ä¸ª request çš„æœ€å¤§æ—¶é•¿ï¼Œæ­¤å€¼ä¸ºç©ºæ—¶ä½¿ç”¨ ReadTimeout å€¼ä»£æ›¿ï¼ŒReadTimeout ä¹Ÿä¸ºç©ºä½¿ç”¨ ReadHeaderTimeout ä»£æ›¿
    MaxHeaderBytes    int           // è§£æ request headers é‡Œé”®å€¼å¯¹çš„æœ€å¤§å­—èŠ‚æ•° (åŒ…å«è¯·æ±‚è¡Œ)ï¼Œä¸é™åˆ¶ body. å¦‚æœä¸º 0, ä½¿ç”¨ DefaultMaxHeaderBytes ä»£æ›¿
    TLSNextProto      map[string]func(</em>Server, <em>tls.Conn, Handler) // å½“ â€˜åº”ç”¨å±‚åè®®åå•† (NPN/ALPN)â€™ æ—¶å‘ç”Ÿåè®®å‡çº§æ—¶ï¼ŒTLSNextProto éœ€è¦æŒ‡å®šå¯é€‰çš„ function å»æ¥ç®¡ TLS è¿æ¥
    ConnState         func(net.Conn, ConnState) // æŒ‡å®šä¸€ä¸ªå¯é€‰çš„é’©å­å‡½æ•°ï¼Œç”± client è¿æ¥çŠ¶æ€æ”¹å˜è§¦å‘
    ErrorLog          *log.Logger   // æŒ‡å®šä¸€ä¸ªå¯é€‰çš„ logger æ¥æ”¶é”™è¯¯æ—¥å¿—. å¦‚æœä¸ºç©ºåˆ™ç”± log åŒ…æ¥ç®¡
    disableKeepAlives int32         // åœ¨ SetKeepAlivesEnabled ä¸­è®¾ç½®ï¼Œä¸º 1 è¡¨ç¤ºå–æ¶ˆé•¿è¿æ¥ï¼Œä¸º 0 ä¿æŒé•¿è¿æ¥ (é»˜è®¤)
    inShutdown        int32         // éé›¶ä»£è¡¨ in Shutdown
    nextProtoOnce     sync.Once     // è®¾ç½® HTTP/2
    nextProtoErr      error         // http2.ConfigureServer çš„ç»“æœ
    mu                sync.Mutex
    listeners         map[net.Listener]struct{}
    activeConn        map[</em>conn]struct{}
    doneChan          chan struct{} // doneChan ä»£è¡¨ä»»åŠ¡ç»“æŸ
    onShutdown        []func()      // é€šè¿‡ RegisterOnShutdown æ³¨å†Œï¼Œåœ¨ Shutdown æ—¶è°ƒç”¨å½“ä¸­çš„é’©å­å‡½æ•°
}</p>

<p>// æ­¤æ¥å£ç”± ResponseWriters æ‰§è¡Œå»æ£€æµ‹è¿æ¥æ˜¯å¦å·²æ–­å¼€ï¼Œæ­¤æœºåˆ¶å…è®¸å®¢æˆ·ç«¯æ–­å¼€åæœåŠ¡ç«¯å–æ¶ˆä¸€ä¸ªé•¿è¿æ¥
type CloseNotifier interface {
    CloseNotify() &lt;-chan bool
}</p>

<p>// conn ä»£è¡¨æœåŠ¡ç«¯çš„ HTTP è¿æ¥
type conn struct {
    server     *Server
    cancelCtx  context.CancelFunc   // æ’¤é”€è¿æ¥å±‚çš„ contextï¼Œè¯»å†™å‡ºé”™æ—¶ä¼šè°ƒç”¨
    rwc        net.Conn             //
    remoteAddr string               // rwc.RemoteAddr().String()
    tlsState   *tls.ConnectionState // TLS è¿æ¥çŠ¶æ€ï¼Œnil ä»£è¡¨é TSL
    werr       error                // rwc å†™å…¥æ—¶çš„é¦–ä¸ªé”™è¯¯ (bufw å†™å…¥æ—¶)
    r          *connReader          // ä¸€ä¸ª *conn ä½¿ç”¨çš„ io.reader å°è£…ï¼Œå­˜æœ‰ bufr çš„è¯»å–å†…å®¹
    bufr       *bufio.Reader        // ä» r è¯»å–
    bufw       *bufio.Writer        // è¦å†™å…¥ checkConnErrorWriter{c} çš„ç¼“å†²
    lastMethod string
    curReq     atomic.Value // å­˜å…¥ *response (response ä¸­åŒ…å« request)
    curState   atomic.Value // å­˜å…¥ ConnState
    mu         sync.Mutex   // ä¿æŠ¤ hijackedv
    hijackedv  bool         // ä»£è¡¨è¿æ¥æ˜¯å¦å·²ç»è¢« hijacke
}</p>

<p>// ä¸€ä¸ª ctx å¸¦æœ‰ä¸€ä¸ªæˆªæ­¢æœŸé™ï¼Œä¸€ä¸ªå–æ¶ˆä¿¡å·ï¼Œæˆ–è€…å…¶ä»–ç»‘å®šå€¼
// å…¶å‡½æ•°å¯ä»¥è¢«å¤šä¸ª goroutines åŒæ—¶ä½¿ç”¨
// ä¸€ä¸ªè¯·æ±‚è¿‡æ¥æ—¶å¯èƒ½ä¼šæ¶‰åŠåˆ°å¤šä¸ª goroutinesï¼ŒCtx å¯ä»¥æ§åˆ¶å…³é—­ä¸ä¹‹ç›¸å…³è”å’Œæ´¾ç”Ÿå‡ºçš„å­ ctx ç›¸å…³è”çš„ goroutines
type Context interface {
    // Deadline æ–¹æ³•æ˜¯è·å–è®¾ç½®çš„æˆªæ­¢æ—¶é—´ï¼Œç¬¬ä¸€ä¸ªè¿”å›å€¼æ˜¯æˆªæ­¢æ—¶é—´ï¼Œåˆ°äº†è¿™ä¸ªæ—¶é—´ç‚¹ï¼ŒContext ä¼šè‡ªåŠ¨å‘èµ·å–æ¶ˆè¯·æ±‚ï¼›
    // ç¬¬äºŒä¸ªè¿”å›å€¼ ok==false æ—¶è¡¨ç¤ºæ²¡æœ‰è®¾ç½®æˆªæ­¢æ—¶é—´ï¼Œå¦‚æœéœ€è¦å–æ¶ˆçš„è¯ï¼Œéœ€è¦è°ƒç”¨ cancel å‡½æ•°è¿›è¡Œå–æ¶ˆï¼Œå–æ¶ˆæ“ä½œåŒ…æ‹¬æ´¾ç”Ÿå‡ºå»çš„å­ Ctx
    Deadline() (deadline time.Time, ok bool)
    // åœ¨ goroutine ä¸­ï¼Œå¦‚æœè¯¥æ–¹æ³•è¿”å›çš„ chan å¯ä»¥è¯»å–ï¼Œåˆ™æ„å‘³ç€ parent context å·²ç»å‘èµ·äº†å–æ¶ˆè¯·æ±‚ï¼Œ
    // æˆ‘ä»¬é€šè¿‡ Done æ–¹æ³•æ”¶åˆ°è¿™ä¸ªä¿¡å·åï¼Œå°±åº”è¯¥åšæ¸…ç†æ“ä½œï¼Œç„¶åé€€å‡º goroutineï¼Œé‡Šæ”¾èµ„æº
    Done() &lt;-chan struct{}
    // å¦‚æœ Done è¿˜æ²¡å…³é—­ï¼ŒErr è¿”å› nil
    // å¦‚æœ Done å·²ç»å…³é—­ï¼Œè¿”å›éç©º errï¼Œå‘ŠçŸ¥ Ctx å› ä½•å–æ¶ˆ
    Err() error
    Value(key interface{}) interface{} // é”®å€¼å¯¹å½¢å¼ï¼Œä¸ Ctx ç»‘å®šï¼Œå¯ä»¥ä¸ºç©º
}
ç›‘å¬å‡½æ•°
// Serve æ¥æ”¶ listener ä¸Šè¿‡æ¥çš„è¿æ¥ï¼Œå¹¶ä¸ºæ¯ä¸ªè¿æ¥åˆ›å»º service çº¿ç¨‹
// åœ¨ service çº¿ç¨‹ä¸­ä¼šè¯»å– request å¹¶è°ƒç”¨ srv.Handler è¿›è¡ŒæœåŠ¡
// handler å‚æ•°ä¸€èˆ¬ä¼  nil å°±è¡Œï¼Œä»£è¡¨ä½¿ç”¨çš„æ˜¯ DefaultServeMux
func Serve(l net.Listener, handler Handler) error { // HTTPS: ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error
    srv := &amp;Server{Handler: handler}
    return srv.Serve(l) // HTTPS: srv.ServeTLS(l, certFile, keyFile)
}</p>

<p>// func HelloServer(w http.ResponseWriter, req *http.Request) {
//     io.WriteString(w, â€œhello, world!\nâ€)
// }
//
// func main() {
//     http.HandleFunc(â€œ/helloâ€, HelloServer)
//     log.Fatal(http.ListenAndServe(â€œ:12345â€, nil))
// }
func ListenAndServe(addr string, handler Handler) error {
    server := &amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServe()
}</p>

<p>// err := http.ListenAndServeTLS(â€œ:10443â€, â€œcert.pemâ€, â€œkey.pemâ€, nil)
// HTTPS æ–¹å¼ï¼Œå¯ä»¥ä½¿ç”¨ crypto/tls ä¸­çš„ generate_cert.go ç”Ÿæˆ cert.pem å’Œ key.pem
func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error {
    server := &amp;Server{Addr: addr, Handler: handler}
    return server.ListenAndServeTLS(certFile, keyFile)
}</p>

<p>// ListenAndServe ç›‘å¬ srv.Addr åœ°å€ä¸Šçš„ tcp ç½‘ç»œï¼Œç„¶åè°ƒç”¨ Serve æœåŠ¡è¿æ¥ï¼Œè¿æ¥ä¼šè®¾ç½® keep-alives
// å¦‚æœ srv.Addr ä¸ºç©ºåˆ™ç”¨ â€œ:httpâ€ ä»£æ›¿
// ListenAndServe æ€»æ˜¯è¿”å›éç©º err
func (srv <em>Server) ListenAndServe() error {
    addr := srv.Addr
    if addr == â€œâ€ {
        addr = â€œ:httpâ€
    }
    ln, err := net.Listen(â€œtcpâ€, addr)
    if err != nil {
        return err
    }
    // HTTP:
    return srv.Serve(tcpKeepAliveListener{ln.(</em>net.TCPListener)})</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// HTTPS æ–¹å¼è°ƒç”¨ ListenAndServeTLS(certFile, keyFile string) error
// ä¸ ListenAndServe ç±»ä¼¼ï¼Œåªæ˜¯æœ€åè¦å…³é—­ ln å¹¶è¿”å› srv.ServeTLS
// defer ln.Close()
// return srv.ServeTLS(tcpKeepAliveListener{ln.(*net.TCPListener)}, certFile, keyFile) } server çš„æœåŠ¡å‡½æ•° func (srv *Server) ServeTLS(l net.Listener, certFile, keyFile string) error {
// åœ¨ srv.Serve ä¹‹å‰å°è¯•è®¾ç½® HTTP/2
// setupHTTP2_ServeTLS ä¸­è°ƒç”¨ onceSetNextProtoDefaults_Serveï¼Œåªæœ‰ srv.TLSNextProto ä¸º nil æ—¶æ‰å¯ä»¥è®¾ç½® HTTP/2
if err := srv.setupHTTP2_ServeTLS(); err != nil {
    return err
}

config := cloneTLSConfig(srv.TLSConfig)
if !strSliceContains(config.NextProtos, "http/1.1") { // strSliceContains åˆ¤æ–­æ˜¯å¦åŒ…å«å­—ç¬¦ä¸²
    config.NextProtos = append(config.NextProtos, "http/1.1")
}

configHasCert := len(config.Certificates) &gt; 0 || config.GetCertificate != nil
if !configHasCert || certFile != "" || keyFile != "" {
    var err error
    config.Certificates = make([]tls.Certificate, 1)
    config.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile) // LoadX509KeyPair è§£æè¯ä¹¦ï¼Œæ–‡ä»¶ä¸­å¿…é¡»å«æœ‰ PEM ç¼–ç æ•°æ®
    // PEM (Privacy Enhancement Message)ï¼Œå®šä¹‰è§ RFC1421ï¼Œæ˜¯ä¸€ç§åŸºäº base64 çš„ç¼–ç æ ¼å¼
    if err != nil {
        return err
    }
}

tlsListener := tls.NewListener(l, config)
return srv.Serve(tlsListener) }
</code></pre></div></div>

<p>// è‹¥å¯ç”¨ HTTP/2ï¼Œåœ¨è°ƒç”¨ Serve å‰éœ€è¦æ ¹æ® listenerâ€™s TLS Config åˆå§‹åŒ– srv.TLSConfig
// Serve æ€»æ˜¯è¿”å›éç©ºçš„ errï¼Œåœ¨ Shutdown æˆ– Close åè¿”å› ErrServerClosed
// Close æ˜¯ç«‹å³å…³é—­ Server å’Œä¸ä¹‹ç›¸å…³çš„ listeners å’Œ connectionsï¼Œè€Œ shutdown æ˜¯é€æ­¥å…³é—­ listeners å’Œé—²ç½®çš„ connectionsï¼Œä¸¤è€…ä¸ä¼šç®¡å·²è¢« hijack çš„è¿æ¥
func (srv *Server) Serve(l net.Listener) error {
    defer l.Close()
    if fn := testHookServerServe; fn != nil { // å¦‚æœé’©å­å‡½æ•° testHookServerServe éç©ºåˆ™è°ƒç”¨
        fn(srv, l)
    }
    var tempDelay time.Duration // accept å¤±è´¥æ—¶ sleep å¤šé•¿æ—¶é—´</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// setupHTTP2_Serve å’Œ setupHTTP2_ServeTLS ä¸¤è€…éƒ½æ˜¯è°ƒç”¨ onceSetNextProtoDefaults() å»å°è¯•è®¾ç½® HTTP/2
// åªæ˜¯è€ƒè™‘åˆ°å¤šå¹¶å‘æƒ…å†µä¸‹çš„ Serve è¯·æ±‚ï¼ŒsetupHTTP2_Serve é‡‡ç”¨äº†æ›´ä¿å®ˆçš„æ”¿ç­–å»è®¾ç½® HTTP/2
// setupHTTP2_Serve å…ˆè°ƒç”¨ shouldConfigureHTTP2ForServe åˆ¤æ–­æ˜¯å¦åº”è¯¥ä¸º Server.Serve è®¾ç½® HTTP/2
// shouldConfigureHTTP2ForServe ä¸­å¦‚æœ srv.TLSConfig ä¸º nil æˆ–è€… srv.TLSConfig.NextProtos åŒ…å« "h2" å­—æ ·è¿”å›çœŸï¼Œå¦åˆ™è¿”å›å‡ï¼Œ
if err := srv.setupHTTP2_Serve(); err != nil {
    return err
}

srv.trackListener(l, true) // å°† l æ·»åŠ è¿› server.listeners
defer srv.trackListener(l, false) // ç»“æŸååˆ å» l

baseCtx := context.Background() // baseContext ä¼šä¸€ç›´å­˜åœ¨ï¼Œä½†æ²¡æœ‰å€¼ä¹Ÿæ²¡æœ‰ deadlineï¼Œç”¨äºä¸»å‡½æ•°æˆ–è€…åˆå§‹åŒ–æˆ–è€…æµ‹è¯•æˆ–è€…é¡¶å±‚æ¥æ”¶è¯·æ±‚çš„ context
ctx := context.WithValue(baseCtx, ServerContextKey, srv)
// WithValue è¿”å› baseCtx çš„å‰¯æœ¬ï¼Œå‰¯æœ¬å†…çš„å€¼æ˜¯ä¸€ä¸ªé”®å€¼å¯¹ ServerContextKey - srv
// ServerContextKey = &amp;contextKey{"http-server"} ä¸å…¶ç»‘å®šçš„ value ç±»å‹ä¸º *Server
for {
    rw, e := l.Accept() // æ¥æ”¶åˆ°è¿æ¥
    if e != nil {
        select {
        case &lt;-srv.getDoneChan(): // server å·²å…³é—­
            return ErrServerClosed
        default:
        }
        if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() {
            if tempDelay == 0 {
                tempDelay = 5 * time.Millisecond
            } else {
                tempDelay *= 2
            }
            if max := 1 * time.Second; tempDelay &gt; max {
                tempDelay = max
            }
            srv.logf("http: Accept error: %v; retrying in %v", e, tempDelay)
            time.Sleep(tempDelay)
            continue
        }
        return e
    }
    tempDelay = 0
    c := srv.newConn(rw)
    // conn.setState æ ¹æ®ä¼ å…¥çš„çŠ¶æ€è°ƒç”¨ trackConn æ¥è®¾ç½® server.activeConn é›†åˆï¼Œå†æ”¹å˜å½“å‰ conn.curState
    // å¦‚æœ server è®¾ç½®äº† ConnState è¿™ä¸ªé’©å­å‡½æ•°ï¼Œå°±è°ƒç”¨
    c.setState(c.rwc, StateNew)
    go c.serve(ctx)
} } server.Serve æœ€åè°ƒç”¨ conn.serve åœ¨æ­¤å‡½æ•°ä¸­è°ƒç”¨ serverHandler{c.server}.ServeHTTP(w, w.req) è½¬å…¥è·¯ç”±æ¨¡å—
</code></pre></div></div>

<p>func (c *conn) serve(ctx context.Context) {
    c.remoteAddr = c.rwc.RemoteAddr().String()
    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())
    // LocalAddrContextKey = &amp;contextKey{â€œlocal-addrâ€} ä¸å…¶ç»‘å®šçš„ value ç±»å‹æ˜¯ net.Addr
    defer func() {
        if err := recover(); err != nil &amp;&amp; err != ErrAbortHandler {
            const size = 64 Â«Â 10 // 64 KB
            buf := make([]byte, size)
            buf = buf[:runtime.Stack(buf, false)]
            c.server.logf(â€œhttp: panic serving %v: %v\n%sâ€, c.remoteAddr, err, buf)
        }
        if !c.hijacked() { // å·²ç»è¢« hijack çš„è¿æ¥ä¸ç”¨ç®¡ç†ï¼Œç”± hijack çš„è°ƒç”¨è€…å¤„ç†
            c.close()
            c.setState(c.rwc, StateClosed)
        }
    }()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if tlsConn, ok := c.rwc.(*tls.Conn); ok { // HTTPS
    if d := c.server.ReadTimeout; d != 0 {
        c.rwc.SetReadDeadline(time.Now().Add(d))
    }
    if d := c.server.WriteTimeout; d != 0 {
        c.rwc.SetWriteDeadline(time.Now().Add(d))
    }
    if err := tlsConn.Handshake(); err != nil {
        c.server.logf("http: TLS handshake error from %s: %v", c.rwc.RemoteAddr(), err)
        return
    }
    c.tlsState = new(tls.ConnectionState)
    *c.tlsState = tlsConn.ConnectionState() // è·å–å½“å‰ TLS è¿æ¥çš„è¯¦ç»†ä¿¡æ¯
    // NegotiatedProtocol åå•†çš„åè®®ï¼ŒvalidNPN åˆ¤æ–­ proto æ˜¯å¦å±äº "", "http/1.1", "http/1.0" ä¹‹ä¸€ï¼Œä¸å±äºè¿”å›çœŸ
    if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {
        if fn := c.server.TLSNextProto[proto]; fn != nil {
            h := initNPNRequest{tlsConn, serverHandler{c.server}}
            fn(c.server, tlsConn, h) // å‘ç”Ÿåè®®åˆ‡æ¢æ—¶è§¦å‘é’©å­å‡½æ•°
        }
        return
    }
}

// HTTP/1.x following

ctx, cancelCtx := context.WithCancel(ctx)
// WithCancel è¿”å› &amp;c, func() { c.cancel(true, Canceled) }
// ctx.cancel close ctx.done å–æ¶ˆæ‰€æœ‰ ctx çš„ childrenï¼Œå¦‚æœç¬¬ä¸€ä¸ªå‚æ•°ä¸º trueï¼Œåˆ™æŠŠ ctx ä»å…¶ parent çš„ children åˆ—è¡¨åˆ å»
c.cancelCtx = cancelCtx
defer cancelCtx() // å…³é—­ ctxï¼Œä»¥åŠç›¸å…³ goroutines

c.r = &amp;connReader{conn: c}
c.bufr = newBufioReader(c.r)
c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&lt;&lt;10)

for {
    w, err := c.readRequest(ctx) // è¯»å– request è¿”å› response å’Œå¯èƒ½çš„ err
    if c.r.remain != c.server.initialReadLimitSize() { // remain ä»£è¡¨ io.reader å‰©ä½™ç©ºé—´ï¼ŒinitialReadLimitSize è¿”å› int64(srv.MaxHeaderBytes &gt; 0 ? srv.MaxHeaderBytes : DefaultMaxHeaderBytes) + 4096
        c.setState(c.rwc, StateActive) // StateActive ä»£è¡¨è¿æ¥å·²ç»ä» request è¯»åˆ°æ•°æ®
    }
    if err != nil {
        const errorHeaders = "\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n"

        if err == errTooLarge { // errors.New("http: request too large")
            const publicErr = "431 Request Header Fields Too Large"
            fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)
            c.closeWriteAndWait()
            // closewrite flush æ‰€æœ‰ç¼“å­˜çš„æ•°æ®å¹¶å‘é€ä¸€ä¸ª FIN åŒ…ï¼ˆå¦‚æœå®¢æˆ·ç«¯æ˜¯é€šè¿‡ TCP è¿æ¥çš„ï¼‰ï¼Œè¡¨ç¤ºæˆ‘ä»¬è¿™è¾¹å·²ç»“æŸï¼Œç„¶å sleep 500 ms
            return
        }
        if isCommonNetReadError(err) {
            // err æ˜¯å¦æ˜¯ io.EOF æˆ–è€…æ˜¯ç½‘ç»œè¶…æ—¶ (net.Error) æˆ–è€…æ˜¯è¯» request çš„ net.OpError ä¹‹ä¸€
            return
        }

        publicErr := "400 Bad Request"
        if v, ok := err.(badRequestError); ok {
            publicErr = publicErr + ": " + string(v)
        }

        fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)
        return
    }

    // request Header : Expect 100 Continue
    req := w.req
    if req.expectsContinue() {
        if req.ProtoAtLeast(1, 1) &amp;&amp; req.ContentLength != 0 {
            // after first '100 Continue' request, wrapper response with 'HTTP/1.1 100 Continue'
            req.Body = &amp;expectContinueReader{readCloser: req.Body, resp: w}
        }
    } else if req.Header.get("Expect") != "" {
        w.sendExpectationFailed() // response with status code 417 (Expectation Failed)
        return
    }

    c.curReq.Store(w)

    if requestBodyRemains(req.Body) { // ä¹‹åæ˜¯å¦è¿˜èƒ½ä» body è¯»å–åˆ°æ•°æ®ï¼Œtrue è¡¨ç¤ºèƒ½ç»§ç»­è¯» (æœªåˆ° io.EOF)
        registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead) // å½“ body è¯»åˆ° EOFï¼Œè°ƒç”¨ä¼ å…¥çš„ startBackgroundRead å‡½æ•°
    } else { // é•¿è¿æ¥ä¸‹ HTTP ç®¡çº¿åŒ–è¯·æ±‚æ—¶çš„å¤„ç†
        if w.conn.bufr.Buffered() &gt; 0 {
            // [HTTP pipelining](https://zh.wikipedia.org/wiki/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96)
            w.conn.r.closeNotifyFromPipelinedRequest() // closeNotify()
        }
        w.conn.r.startBackgroundRead()
    }

    serverHandler{c.server}.ServeHTTP(w, w.req) // server.Handler == nil -&gt; DefaultServeMux.ServeHTTP
    w.cancelCtx()
    if c.hijacked() {
        return
    }
    w.finishRequest()
    if !w.shouldReuseConnection() { // tcp è¿æ¥æ˜¯å¦å¯ä»¥ç»§ç»­ä½¿ç”¨
        if w.requestBodyLimitHit || w.closedRequestBodyEarly() {
            // requestBodyLimitHit åœ¨ requestTooLarge å‡½æ•°ä¸­è®¾ç½®ï¼Œå½“æ­¤å€¼ä¸ºçœŸï¼Œåœæ­¢è¯»å–åç»­çš„ request å’Œè¾“å…¥
            // closedRequestBodyEarly è¡¨ç¤ºè¿æ¥ä¹‹å‰æ˜¯å¦å·²å…³é—­
            c.closeWriteAndWait()
        }
        return
    }
    c.setState(c.rwc, StateIdle) // StateIdle è¡¨ç¤ºæ­¤è¿æ¥å·²å¤„ç†å®Œä¸€ä¸ª request å¹¶å¤„äº keep-alive çŠ¶æ€ï¼Œç­‰å¾…åç»­ request
    c.curReq.Store((*response)(nil))

    if !w.conn.server.doKeepAlives() { // doKeepAlives åˆ¤æ–­æ˜¯å¦æ»¡è¶³ disableKeepAlives == 0 &amp;&amp; inShutdown == 0 (å¤„äº keep-alive æ¨¡å¼ä¸”ä¸åœ¨ shutdown çŠ¶æ€)
        // We're in shutdown mode. We might've replied
        // to the user without "Connection: close" and
        // they might think they can send another
        // request, but such is life with HTTP/1.1.
        return
    }

    if d := c.server.idleTimeout(); d != 0 {
        c.rwc.SetReadDeadline(time.Now().Add(d))
        if _, err := c.bufr.Peek(4); err != nil {
            return
        }
    }
    // SetReadDeadline è®¾ç½®åç»­è¯»å»è°ƒç”¨çš„æˆªæ­¢æ—¶é—´ï¼Œå¦‚æœä¼ å…¥é›¶å€¼è¡¨ç¤ºä¸ä¼š timeout
    c.rwc.SetReadDeadline(time.Time{})
} } æµç¨‹ï¼š å½“ä¸€ä¸ªè¯·æ±‚ request è¿›æ¥çš„æ—¶å€™ï¼Œserver ä¼šä¾æ¬¡æ ¹æ® ServeMux.m ä¸­çš„ stringï¼ˆè·¯ç”±è¡¨è¾¾å¼ï¼‰æ¥ä¸€ä¸ªä¸€ä¸ªåŒ¹é…ï¼Œ å¦‚æœæ‰¾åˆ°äº†å¯ä»¥åŒ¹é…çš„ muxEntryï¼Œå°±å–å‡º muxEntry.hï¼Œè¿™æ˜¯ä¸ª handlerï¼Œ è°ƒç”¨ handler ä¸­çš„ ServeHTTPï¼ˆResponseWriter, *Requestï¼‰æ¥ç»„è£… Responseï¼Œå¹¶è¿”å›ã€‚
</code></pre></div></div>

<p>è·¯ç”±æ¥å£
// ResponseWriter æ¥å£ç”¨äº HTTP handler ç”Ÿæˆ response
// åœ¨ Handler.ServeHTTP è¿”å›åï¼ŒResponseWriter ä¸åº”è¯¥å†è¢«ä½¿ç”¨
type ResponseWriter interface {
    Header() Header             // Header() è¿”å› WriteHeader è¦å‘é€çš„ Header map é›†åˆ
    Write([]byte) (int, error)  // Write å†™å…¥å“åº”çš„ body
    WriteHeader(statusCode int) // è¿™ä¸ªæ–¹æ³•å‘é€ Response çš„ Header å’Œä¼ å…¥çš„ HTTP çŠ¶æ€ç 
}</p>

<p>// Flusher ç”± ResponseWriters æ‰§è¡Œå»å…è®¸ HTTP handler å°†ç¼“å­˜ä¸­çš„æ•°æ®æ¨ç»™å®¢æˆ·ç«¯, é»˜è®¤çš„ HTTP/1.x å’Œ HTTP/2 ResponseWriter æ”¯æŒ Flusherï¼Œ
// ä½†æ˜¯ ResponseWriter çš„å°è£…å¯èƒ½ä¼šä¸æ”¯æŒï¼ŒHandlers åœ¨è¿è¡Œæ—¶éœ€è¦æµ‹è¯•æ˜¯å¦æ”¯æŒæ­¤å‡½æ•°
// å³ä½¿ ResponseWriters æ”¯æŒ Flushï¼Œå¦‚æœå®¢æˆ·ç«¯ä½¿ç”¨äº† HTTP proxyï¼Œç›´åˆ°å“åº”ç»“æŸï¼Œç¼“å­˜çš„æ•°æ®ä¹Ÿæœ‰å¯èƒ½åˆ°è¾¾ä¸äº†å®¢æˆ·ç«¯
type Flusher interface {
    Flush()
}</p>

<p>// Hijacker æ¥å£ç”± ResponseWriters æ‰§è¡Œå»å…è®¸ HTTP handler æ¥ç®¡è¿æ¥
// é»˜è®¤çš„ ResponseWriter æ”¯æŒ HTTP/1.x è¿æ¥ä¸‹çš„ Hijackerï¼Œä½†æ˜¯ HTTP/2 è¿æ¥ä¸æ”¯æŒï¼ŒHTTP/2 å¤šè·¯å¤ç”¨ç­‰æƒ…å†µä¸é€‚åˆä½¿ç”¨ Hijack ã€‚
// ResponseWriter å°è£…ä¹Ÿå¯èƒ½ä¸æ”¯æŒ Hijacker. Handlers åœ¨è¿è¡Œæ—¶éœ€è¦æµ‹è¯•æ˜¯å¦æ”¯æŒæ­¤å‡½æ•°
type Hijacker interface {
    Hijack() (net.Conn, *bufio.ReadWriter, error)
}</p>

<p>// ServeMux ç±»å‹æ˜¯ HTTP è¯·æ±‚çš„è·¯ç”±è§„åˆ™è½¬æ¢å™¨ã€‚å®ƒä¼šå°†æ¯ä¸€ä¸ªæ¥æ”¶çš„è¯·æ±‚çš„ URL ä¸ä¸€ä¸ªæ³¨å†Œè·¯ç”±çš„åˆ—è¡¨è¿›è¡ŒåŒ¹é…ï¼Œå¹¶è°ƒç”¨å’Œ URL æœ€åŒ¹é…çš„ handler.
// åŒ¹é…åˆ°å¤šä¸ªæ—¶è¾ƒé•¿çš„æ¨¡å¼ä¼˜å…ˆäºè¾ƒçŸ­çš„æ¨¡å¼ï¼Œæ¨¡å¼ä¹Ÿå¯ä»¥ä¸»æœºåå¼€å§‹ï¼Œè¡¨ç¤ºåªåŒ¹é…è¯¥ä¸»æœºä¸Šçš„è·¯å¾„ï¼ŒæŒ‡å®šä¸»æœºçš„æ¨¡å¼ä¼˜å…ˆäºä¸€èˆ¬çš„æ¨¡å¼ï¼Œ
// ServeMux è¿˜ä¼šè§„èŒƒåŒ–è¯·æ±‚çš„ URL è·¯å¾„ï¼Œå°†ä»»ä½•åŒ…å« â€œ.â€ æˆ– â€œ..â€ å…ƒç´ çš„è¯·æ±‚é‡å®šå‘åˆ°ç­‰ä»·çš„æ²¡æœ‰è¿™ä¸¤ç§å…ƒç´ çš„ URL
type ServeMux struct {
    mu    sync.RWMutex // è¯»å†™é”
    m     map[string]muxEntry // è·¯ç”±è§„åˆ™ï¼Œä¸€ä¸ª string å¯¹åº”ä¸€ä¸ª mux å®ä½“ï¼Œè¿™é‡Œçš„ string å°±æ˜¯æ³¨å†Œçš„è·¯ç”±è¡¨è¾¾å¼
    hosts bool // æ˜¯å¦åœ¨ä»»æ„çš„è§„åˆ™ä¸­å¸¦æœ‰ host ä¿¡æ¯
}</p>

<p>type muxEntry struct {
    h        Handler // è¿™ä¸ªè·¯ç”±è¡¨è¾¾å¼å¯¹åº”å“ªä¸ª handler
    pattern  string  // å›ºå®šçš„ã€ç”±æ ¹å¼€å§‹çš„è·¯å¾„ï¼Œå¦‚ â€œ/favicon.icoâ€ï¼Œæˆ–ç”±æ ¹å¼€å§‹çš„å­æ ‘ï¼Œå¦‚ â€œ/images/â€ï¼Œä¹Ÿå¯ä»¥ä¸»æœºåå¼€å¤´
}</p>

<p>// ä¸€ä¸ª Handler å“åº”ä¸€ä¸ª HTTP è¯·æ±‚
// ServeHTTP åº”è¯¥å°†å›å¤çš„å¤´åŸŸå’Œæ•°æ®å†™å…¥ ResponseWriter æ¥å£ç„¶åè¿”å›ã€‚è¿”å›æ ‡å¿—ç€è¯¥è¯·æ±‚å·²ç»ç»“æŸï¼ŒHTTP æœåŠ¡ç«¯å¯ä»¥è½¬ç§»å‘è¯¥è¿æ¥ä¸Šçš„ä¸‹ä¸€ä¸ªè¯·æ±‚ã€‚
// åœ¨ ServeHTTP è°ƒç”¨ç»“æŸä¹‹åæˆ–è€…å¹¶å‘æ‰§è¡Œæ—¶ï¼Œä½¿ç”¨ ResponseWriter æˆ–è€…è¯»å–è¯·æ±‚ä½“æ˜¯ä¸å¯å–çš„
// handler åº”è¯¥ç¬¬ä¸€æ—¶é—´è¯»å–è¯·æ±‚ä½“å¹¶ä½œå‡ºåº”ç­”ï¼Œåœ¨å‘ ResponseWriter å†™å…¥æ•°æ®åå°±ä¸èƒ½è¯»å– request body äº†. åŒæ—¶ handler ä¸åº”è¯¥ä¿®æ”¹ä¼ å…¥çš„ request
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}</p>

<p>// HandlerFunc(f) æ˜¯ä¸€ä¸ªè°ƒç”¨ f çš„ handler
type HandlerFunc func(ResponseWriter, *Request)</p>

<p>// ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
è¯·æ±‚ - å“åº”å®ä¾‹
è¿™é‡Œå®ç°äº†ä¸€ä¸ª 404 not found å“åº”
func NotFound(w ResponseWriter, r *Request) { Error(w, â€œ404 page not foundâ€, StatusNotFound) } // å®šä¹‰ handler</p>

<p>func NotFoundHandler() Handler { return HandlerFunc(NotFound) }
server å¯¼å‡ºçš„æ³¨å†Œå‡½æ•°ä½¿ç”¨ DefaultServeMux ç›¸åº”æ–¹æ³•
func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }</p>

<p>func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    DefaultServeMux.HandleFunc(pattern, handler)
}</p>

<p>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    mux.Handle(pattern, HandlerFunc(handler))
}</p>

<p>func (mux *ServeMux) Handle(pattern string, handler Handler) {
    mux.mu.Lock()
    defer mux.mu.Unlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if pattern == "" {
    panic("http: invalid pattern")
}
if handler == nil {
    panic("http: nil handler")
}
if _, exist := mux.m[pattern]; exist {
    panic("http: multiple registrations for " + pattern)
}

if mux.m == nil {
    mux.m = make(map[string]muxEntry)
}
mux.m[pattern] = muxEntry{h: handler, pattern: pattern} // æ³¨å†ŒæˆåŠŸ

if pattern[0] != '/' {
    mux.hosts = true
} } ServeHTTP è°ƒç”¨ Handler() ç»™ request åˆ†æ´¾ä¸ request URL æœ€åŒ¹é…çš„ handler func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {
if r.RequestURI == "*" {
    if r.ProtoAtLeast(1, 1) { // ProtoAtLeast åˆ¤æ–­æ˜¯å¦å¤§äºç­‰äºåè®®æœ€ä½æ ‡å‡†ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ major ç‰ˆæœ¬å·ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ minor ç‰ˆæœ¬å·ï¼Œå³ http/1.1
        w.Header().Set("Connection", "close") // å°äºè¦æ±‚åˆ™åœ¨å“åº”å¤´è¿”å›å…³é—­ä¿¡æ¯
    }
    w.WriteHeader(StatusBadRequest) // çŠ¶æ€ç  400
    return
}
h, _ := mux.Handler(r)
h.ServeHTTP(w, r) // è°ƒç”¨å¯¹åº” handler çš„ ServeHTTPï¼Œå³æ‰§è¡Œæ³¨å†Œå¥½çš„ handler å‡½æ•°ï¼Œæ¯”å¦‚ NotFound å‡½æ•° } // Handler é€šè¿‡åˆ¤æ–­ r.Method, r.Host, and r.URL.Path è¿”å›ä¸ request å¯¹åº”çš„ handler // æ­¤å‡½æ•°æ€»ä¼šè¿”å›éç©ºçš„ handler. å¦‚æœ path ä¸ç¬¦åˆè§„èŒƒå½¢å¼ï¼Œè¿”å›çš„æ˜¯å†…éƒ¨ç”Ÿæˆçš„é‡å®šå‘åˆ°è§„èŒƒè·¯å¾„çš„ handler // å¦‚æœ host åŒ…å«ç«¯å£ï¼ŒåŒ¹é… handlers æ—¶ä¼šå¿½ç•¥ç«¯å£ã€‚ç¬¬äºŒä¸ªå‚æ•°è¿”å›å·²æ³¨å†Œçš„ä¸è¯·æ±‚åŒ¹é…çš„è·¯ç”± // å¦‚æœæ²¡æœ‰å·²æ³¨å†Œçš„ handler ä¸è¯·æ±‚åŒ¹é…, åˆ™è¿”å› ``page not found'' handler å’Œç©ºçš„ pattern func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {
if r.Method == "CONNECT" {
    // redirectToPathSlash åˆ¤æ–­ path æ˜¯å¦éœ€è¦è¿½åŠ  "/"ï¼Œå› ä¸ºå­˜åœ¨ "path + /" å·²æ³¨å†Œä½† "path"
    // æœ¬èº«æœªæ³¨å†Œçš„æƒ…å†µã€‚å¦‚æœéœ€è¦è¿½åŠ  "/"ï¼Œåˆ™è¿”å›è¿½åŠ çš„ url å’Œ true
    if u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {
        return RedirectHandler(u.String(), StatusMovedPermanently), u.Path
    }

    return mux.handler(r.Host, r.URL.Path)
}

host := stripHostPort(r.Host) // å»æ‰ ":&lt;port&gt;"
path := cleanPath(r.URL.Path) // è§„èŒƒ path æ ¼å¼ï¼Œæ¯”å¦‚ç¼ºå¤±å¤šä½™ '/'ã€å­˜åœ¨ç›¸å¯¹è·¯å¾„'.'ã€'..' ç­‰

if u, ok := mux.redirectToPathSlash(host, path, r.URL); ok {
    return RedirectHandler(u.String(), StatusMovedPermanently), u.Path
}

// ä¿®æ”¹ request çš„ä¸è§„èŒƒè·¯å¾„
if path != r.URL.Path {
    _, pattern = mux.handler(host, path)
    url := *r.URL
    url.Path = path
    return RedirectHandler(url.String(), StatusMovedPermanently), pattern
}

return mux.handler(host, r.URL.Path) }
</code></pre></div></div>

<p>// åœ¨ ServerMux.handler ä¸­å½“åŒ¹é…ä¸åˆ°æ³¨å†Œçš„è·¯ç”±æ—¶è¿”å› NotFoundHandler
func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {
    mux.mu.RLock()
    defer mux.mu.RUnlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if mux.hosts {
    h, pattern = mux.match(host + path) // match æ ¹æ®å®Œæ•´ URL ä¼˜å…ˆåŒ¹é… handler
}
if h == nil {
    h, pattern = mux.match(path) // å¦‚æœ URL åŒ¹é…ä¸åˆ°å†æ ¹æ®è·¯å¾„åŒ¹é…
}
if h == nil {
    h, pattern = NotFoundHandler(), ""
}
return }
</code></pre></div></div>
:ET