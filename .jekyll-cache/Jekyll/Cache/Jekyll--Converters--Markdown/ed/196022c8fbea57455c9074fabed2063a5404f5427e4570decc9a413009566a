I"š}<p>sync.Mapï¼Œè¯»å†™é”çš„é€‚ç”¨åœºæ™¯
å®ç°æ–¹å¼	åŸç†	é€‚ç”¨åœºæ™¯
map+Mutex	é€šè¿‡Mutexäº’æ–¥é”æ¥å®ç°å¤šä¸ªgoroutineå¯¹mapçš„ä¸²è¡ŒåŒ–è®¿é—®	è¯»å†™éƒ½éœ€è¦é€šè¿‡MutexåŠ é”å’Œé‡Šæ”¾é”ï¼Œé€‚ç”¨äºè¯»å†™æ¯”æ¥è¿‘çš„åœºæ™¯
map+RWMutex	é€šè¿‡RWMutexæ¥å®ç°å¯¹mapçš„è¯»å†™è¿›è¡Œè¯»å†™é”åˆ†ç¦»åŠ é”ï¼Œä»è€Œå®ç°è¯»çš„å¹¶å‘æ€§èƒ½æé«˜	åŒMutexç›¸æ¯”é€‚ç”¨äºè¯»å¤šå†™å°‘çš„åœºæ™¯
sync.Map	åº•å±‚é€šåˆ†ç¦»è¯»å†™mapå’ŒåŸå­æŒ‡ä»¤æ¥å®ç°è¯»çš„è¿‘ä¼¼æ— é”ï¼Œå¹¶é€šè¿‡å»¶è¿Ÿæ›´æ–°çš„æ–¹å¼æ¥ä¿è¯è¯»çš„æ— é”åŒ–	è¯»å¤šä¿®æ”¹å°‘ï¼Œå…ƒç´ å¢åŠ åˆ é™¤é¢‘ç‡ä¸é«˜çš„æƒ…å†µï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹æ›¿ä»£ä¸Šè¿°ä¸¤ç§å®ç°
<!-- more -->
https://blog.csdn.net/u010853261/article/details/103848666</p>

<p>golangæ”¯æŒmapå…³é”®å­—ï¼Œgolangçš„mapçš„è¯»å†™æ˜¯ç¼–è¯‘æˆruntimeçš„å‡½æ•°è°ƒç”¨ã€‚ä½†æ˜¯é»˜è®¤çš„mapæ˜¯éçº¿ç¨‹å®‰å…¨çš„ã€‚go 1.9 ç‰ˆæœ¬ä¸­æ”¯æŒäº† sync.Map ç”¨äºçº¿ç¨‹å®‰å…¨çš„mapã€‚
å…³äºgo mapçš„å®ç°å¯ä»¥å‚è€ƒï¼šGolang mapå®è·µä»¥åŠå®ç°åŸç†</p>

<p>æ”¯æŒå¹¶å‘çš„map
golangå†…ç½®çš„mapè¯»å†™æ“ä½œï¼Œå¾ˆå¤šéƒ½æ˜¯ç¼–è¯‘å™¨å¸®æˆ‘ä»¬è½¬æ¢æˆruntimeçš„å‡½æ•°è°ƒç”¨ï¼Œè€Œä¸”æ•´ä½“çš„è®¾è®¡æ¯”è¾ƒå°é—­ï¼Œæ²¡æœ‰ç•™ä¸‹æ‰©å±•çš„ç©ºé—´ã€‚</p>

<p>è¦æ”¯æŒçº¿ç¨‹å®‰å…¨çš„mapï¼Œä¸€ç§æ–¹å¼å°±æ˜¯åœ¨goå†…ç½®çš„mapä¸Šè¿›è¡Œå°è£…ã€‚æ¯”è¾ƒç®€å•çš„å°±æ˜¯ä½¿ç”¨syncæä¾›çš„é”æ¥å®ç°ï¼Œè¿™ç§æ˜¯æœ€ç®€å•çš„ï¼Œå…·ä½“æƒ…å†µè¿™é‡Œå°±ä¸è¯´äº†ã€‚</p>

<p>sync.Map
go 1.9 å®˜æ–¹æä¾›äº†sync.Map æ¥ä¼˜åŒ–çº¿ç¨‹å®‰å…¨çš„å¹¶å‘è¯»å†™çš„mapã€‚è¯¥å®ç°ä¹Ÿæ˜¯åŸºäºå†…ç½®mapå…³é”®å­—æ¥å®ç°çš„ã€‚</p>

<p>è¿™ä¸ªå®ç°ç±»ä¼¼äºä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„ map[interface{}]interface{} . è¿™ä¸ªmapçš„ä¼˜åŒ–ä¸»è¦é€‚ç”¨äº†ä»¥ä¸‹åœºæ™¯ï¼š</p>

<p>ï¼ˆ1ï¼‰ç»™å®škeyçš„é”®å€¼å¯¹åªå†™äº†ä¸€æ¬¡ï¼Œä½†æ˜¯è¯»äº†å¾ˆå¤šæ¬¡ï¼Œæ¯”å¦‚åœ¨åªå¢é•¿çš„ç¼“å­˜ä¸­ï¼›
ï¼ˆ2ï¼‰å½“å¤šä¸ªgoroutineè¯»å–ã€å†™å…¥å’Œè¦†ç›–çš„keyå€¼ä¸ç›¸äº¤æ—¶ã€‚</p>

<p>åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œä½¿ç”¨Mapå¯èƒ½æ¯”ä½¿ç”¨å•ç‹¬äº’æ–¥é”æˆ–RWMutexçš„Go Mapå¤§å¤§å‡å°‘é”äº‰ç”¨ã€‚</p>

<p>å¯¹äºå…¶ä½™æƒ…å†µæœ€å¥½è¿˜æ˜¯ä½¿ç”¨RWMutexä¿è¯çº¿ç¨‹å®‰å…¨ã€‚</p>

<p>æ•°æ®ç»“æ„
å…ˆçœ‹ä¸€ä¸‹åº•å±‚çš„æ•°æ®ç»“æ„ï¼š</p>

<p>// å°è£…çš„çº¿ç¨‹å®‰å…¨çš„map
type Map struct {
	// lock
	mu Mutex</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å®é™…æ˜¯readOnlyè¿™ä¸ªç»“æ„
// ä¸€ä¸ªåªè¯»çš„æ•°æ®ç»“æ„ï¼Œå› ä¸ºåªè¯»ï¼Œæ‰€ä»¥ä¸ä¼šæœ‰è¯»å†™å†²çªã€‚
// readOnlyåŒ…å«äº†mapçš„ä¸€éƒ¨åˆ†æ•°æ®ï¼Œç”¨äºå¹¶å‘å®‰å…¨çš„è®¿é—®ã€‚(å†—ä½™ï¼Œå†…å­˜æ¢æ€§èƒ½)
// è®¿é—®è¿™ä¸€éƒ¨åˆ†ä¸éœ€è¦é”ã€‚
read atomic.Value // readOnly

// dirtyæ•°æ®åŒ…å«å½“å‰çš„mapåŒ…å«çš„entries,å®ƒåŒ…å«æœ€æ–°çš„entries(åŒ…æ‹¬readä¸­æœªåˆ é™¤çš„æ•°æ®,è™½æœ‰å†—ä½™ï¼Œä½†æ˜¯æå‡dirtyå­—æ®µä¸ºreadçš„æ—¶å€™éå¸¸å¿«ï¼Œä¸ç”¨ä¸€ä¸ªä¸€ä¸ªçš„å¤åˆ¶ï¼Œè€Œæ˜¯ç›´æ¥å°†è¿™ä¸ªæ•°æ®ç»“æ„ä½œä¸ºreadå­—æ®µçš„ä¸€éƒ¨åˆ†),æœ‰äº›æ•°æ®è¿˜å¯èƒ½æ²¡æœ‰ç§»åŠ¨åˆ°readå­—æ®µä¸­ã€‚
// å¯¹äºdirtyçš„æ“ä½œéœ€è¦åŠ é”ï¼Œå› ä¸ºå¯¹å®ƒçš„æ“ä½œå¯èƒ½ä¼šæœ‰è¯»å†™ç«äº‰ã€‚
// å½“dirtyä¸ºç©ºçš„æ—¶å€™ï¼Œ æ¯”å¦‚åˆå§‹åŒ–æˆ–è€…åˆšæå‡å®Œï¼Œä¸‹ä¸€æ¬¡çš„å†™æ“ä½œä¼šå¤åˆ¶readå­—æ®µä¸­æœªåˆ é™¤çš„æ•°æ®åˆ°è¿™ä¸ªæ•°æ®ä¸­ã€‚
dirty map[interface{}]*entry

// å½“ä»Mapä¸­è¯»å–entryçš„æ—¶å€™ï¼Œå¦‚æœreadä¸­ä¸åŒ…å«è¿™ä¸ªentry,ä¼šå°è¯•ä»dirtyä¸­è¯»å–ï¼Œè¿™ä¸ªæ—¶å€™ä¼šå°†missesåŠ ä¸€ï¼Œ
// å½“missesç´¯ç§¯åˆ° dirtyçš„é•¿åº¦çš„æ—¶å€™ï¼Œ å°±ä¼šå°†dirtyæå‡ä¸ºread,é¿å…ä»dirtyä¸­misså¤ªå¤šæ¬¡ã€‚å› ä¸ºæ“ä½œdirtyéœ€è¦åŠ é”ã€‚
misses int }
</code></pre></div></div>

<p>// readOnly is an immutable struct stored atomically in the Map.read field.
type readOnly struct {
	m       map[interface{}]*entry
	// å¦‚æœMap.dirtyæœ‰äº›æ•°æ®ä¸åœ¨mä¸­ï¼Œè¿™ä¸ªå€¼ä¸ºtrue
	amended bool 
}</p>

<p>// An entry is a slot in the map corresponding to a particular key.
type entry struct {
	// *interface{}
	p unsafe.Pointer 
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
readOnly.amendedæŒ‡æ˜Map.dirtyä¸­æœ‰readOnly.mæœªåŒ…å«çš„æ•°æ®ï¼Œæ‰€ä»¥å¦‚æœä»Map.readæ‰¾ä¸åˆ°æ•°æ®çš„è¯ï¼Œè¿˜è¦è¿›ä¸€æ­¥åˆ°Map.dirtyä¸­æŸ¥æ‰¾ã€‚</p>

<p>è¿™é‡Œè™½ç„¶æœ‰å†—ä½™çš„ä¸¤ä»½mapæ•°æ®ï¼Œä½†æ˜¯Map.dirtyå’ŒreadOnly.mçš„valueéƒ½æ˜¯ä¸€ä¸ªæŒ‡é’ˆå˜é‡ *entryï¼Œæ‰€ä»¥æ•´ä½“å†…å­˜å ç”¨è¿˜å¥½ã€‚</p>

<p>sync.Map çš„kvéƒ½æ˜¯ interface{} ï¼Œentryé‡Œé¢çš„på®é™…æ˜¯ä¸€ä¸ª *interface{}ï¼Œä¹Ÿå°±æ˜¯entryå®é™…ä¿å­˜çš„æ˜¯æŒ‡å‘valueçš„æŒ‡é’ˆã€‚</p>

<p>è¿™é‡Œpæœ‰ä¸‰ä¸ªå€¼ï¼š</p>

<p>nil: entryå·²è¢«åˆ é™¤äº†ï¼Œå¹¶ä¸”m.dirtyä¸ºnil
expunged: entryå·²è¢«åˆ é™¤äº†ï¼Œå¹¶ä¸”m.dirtyä¸ä¸ºnilï¼Œè€Œä¸”è¿™ä¸ªentryä¸å­˜åœ¨äºm.dirtyä¸­
å…¶å®ƒï¼š entryæ˜¯ä¸€ä¸ªæ­£å¸¸çš„value
sync.Mapä¹Ÿæ˜¯åœ¨golangæä¾›çš„mapå…³é”®å­—ä¹‹ä¸Šå°è£…å®ç°çš„ã€‚</p>

<p>sync.Map æ•´ä½“çš„ä¼˜åŒ–å¯ä»¥æè¿°ä¸ºä»¥ä¸‹å‡ ç‚¹ï¼š</p>

<p>ç©ºé—´æ¢æ—¶é—´ã€‚ é€šè¿‡å†—ä½™çš„ä¸¤ä¸ªæ•°æ®ç»“æ„(readã€dirty),å®ç°åŠ é”å¯¹æ€§èƒ½çš„å½±å“ã€‚
mapåªä¿å­˜keyå’Œå¯¹åº”çš„valueçš„æŒ‡é’ˆï¼Œè¿™æ ·å¯ä»¥å¹¶å‘çš„è¯»å†™map, å®é™…æ›´æ–°æŒ‡å‘valueçš„æŒ‡é’ˆå†é€šè¿‡åŸºäºCASçš„æ— é”atomicã€‚
ä½¿ç”¨åªè¯»æ•°æ®(read)ï¼Œé¿å…è¯»å†™å†²çª
åŠ¨æ€è°ƒæ•´ï¼Œmissæ¬¡æ•°å¤šäº†ä¹‹åï¼Œå°†dirtyæ•°æ®æå‡ä¸ºreadã€‚
double-checkingã€‚
å»¶è¿Ÿåˆ é™¤ã€‚ åˆ é™¤ä¸€ä¸ªé”®å€¼åªæ˜¯æ‰“æ ‡è®°ï¼Œåªæœ‰åœ¨æå‡dirtyçš„æ—¶å€™æ‰æ¸…ç†åˆ é™¤çš„æ•°æ®ã€‚
ä¼˜å…ˆä»readè¯»å–ã€æ›´æ–°ã€åˆ é™¤ï¼Œå› ä¸ºå¯¹readçš„è¯»å–ä¸éœ€è¦é”ã€‚
Load
çº¿ç¨‹å®‰å…¨çš„åŠ è½½keyå¯¹åº”çš„valueï¼š</p>

<p>func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
	// 1.é¦–å…ˆä»m.readä¸­åŠ è½½åªè¯»çš„readOnly, ä»å®ƒçš„mapä¸­æŸ¥æ‰¾ï¼Œæ— é”ã€‚
	read, _ := m.read.Load().(readOnly)
	e, ok := read.m[key]
	// 2. å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå¹¶ä¸”m.dirtyä¸­æœ‰æ–°æ•°æ®ï¼Œéœ€è¦ä»m.dirtyæŸ¥æ‰¾ï¼Œè¿™ä¸ªæ—¶å€™éœ€è¦åŠ é”
	if !ok &amp;&amp; read.amended {
		m.mu.Lock()
		// double check
		read, _ = m.read.Load().(readOnly)
		e, ok = read.m[key]
		if !ok &amp;&amp; read.amended {
			// // ä»m.dirtyæŸ¥æ‰¾
			e, ok = m.dirty[key]
			// ä¸ç®¡m.dirtyä¸­å­˜ä¸å­˜åœ¨ï¼Œéƒ½å°†missesè®¡æ•°åŠ ä¸€
			// missLocked()ä¸­æ»¡è¶³æ¡ä»¶åå°±ä¼šæå‡m.dirty
			m.missLocked()
		}
		m.mu.Unlock()
	}
	if !ok {
		return nil, false
	}
	// åŸå­åŠ è½½ *entry æ‰€ä¿å­˜çš„valueã€‚
	return e.load()
}</p>

<p>func (m *Map) missLocked() {
	m.misses++
	if m.misses &lt; len(m.dirty) {
		return
	}
	m.read.Store(readOnly{m: m.dirty})
	m.dirty = nil
	m.misses = 0
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
æ•´ä½“pipelineå¦‚ä¸‹å›¾ï¼š</p>

<p>é¦–å…ˆè¦å¼ºè°ƒçš„æ˜¯ï¼Œé¦–å…ˆæ˜¯ä»readonlyé‡Œé¢è¯»ï¼Œè¯»ä¸åˆ°æ—¶å€™æ‰åŠ é”å» map.dirty é‡Œé¢å»è¯»ï¼Œå¹¶ä¸”åŠ é”ä¹‹åé¦–å…ˆæ˜¯è¿›è¡Œdouble check(ç†Ÿæ‚‰Javaçš„éƒ½çŸ¥é“double checkæ˜¯ä»€ä¹ˆ)ã€‚</p>

<p>double check ä¹‹åå³ä½¿ä¸å­˜åœ¨äºm.readä¸­ï¼Œç»è¿‡misså‡ æ¬¡ä¹‹åï¼Œm.dirtyä¼šè¢«æå‡ä¸ºm.readï¼Œåˆä¼šä»m.readä¸­æŸ¥æ‰¾ã€‚æ‰€ä»¥å¯¹äºæ›´æ–°ï¼å¢åŠ è¾ƒå°‘ï¼ŒåŠ è½½å­˜åœ¨çš„keyå¾ˆå¤šçš„case,æ€§èƒ½åŸºæœ¬å’Œæ— é”çš„mapç±»ä¼¼ã€‚</p>

<p>missLockedæ–¹æ³•ä¸­å¯èƒ½ä¼šå°†m.dirtyæå‡ï¼Œm,missesä¼šè®°å½•ä»readOnlyä¸­è·å–ä¸åˆ° *entry çš„æ¬¡æ•°ï¼Œä¹Ÿå°±æ˜¯missçš„æ¬¡æ•°ï¼Œå¦‚æœè¾¾åˆ°äº† len(m.dirty) å°±ä¼šåŸå­çš„æ›¿æ¢m.read.m ä¸º m.dirtyã€‚æå‡åm.dirtyã€m.missesé‡ç½®ï¼Œ å¹¶ä¸”m.read.amendedä¸ºfalseã€‚</p>

<p>Store
å®‰å…¨çš„æ›´æ–°ä¸€ä¸ªkeyå¯¹åº”çš„value:</p>

<p>// Store sets the value for a key.
func (m *Map) Store(key, value interface{}) {
	// 1. å¦‚æœm.readå­˜åœ¨è¿™ä¸ªé”®ï¼Œå¹¶ä¸”è¿™ä¸ªentryæ²¡æœ‰è¢«æ ‡è®°åˆ é™¤(expunged)ï¼Œé‚£ä¹ˆcasè‡ªæ—‹æ›´æ–°valueã€‚
	// å› ä¸ºm.dirtyä¹ŸæŒ‡å‘è¿™ä¸ªentry,æ‰€ä»¥m.dirtyä¹Ÿä¿æŒæœ€æ–°çš„entryã€‚
	read, _ := m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
		return
	}
	// 2. m.readä¸å­˜åœ¨æˆ–è€…å·²ç»è¢«æ ‡è®°åˆ é™¤
	m.mu.Lock()
	// double check
	read, _ = m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok {
		if e.unexpungeLocked() {//æ ‡è®°æˆæœªè¢«åˆ é™¤
			//m.dirtyä¸­ä¸å­˜åœ¨è¿™ä¸ªé”®ï¼Œæ‰€ä»¥åŠ å…¥m.dirty
			m.dirty[key] = e
		}
		e.storeLocked(&amp;value)
	// m.dirtyå­˜åœ¨è¿™ä¸ªé”®ï¼Œæ›´æ–°
	} else if e, ok := m.dirty[key]; ok {
		e.storeLocked(&amp;value)
	//æ–°é”®å€¼
	} else {
		//m.dirtyä¸­æ²¡æœ‰æ¯”m.readOnlyæ›´æ–°çš„æ•°æ®ï¼Œå¾€m.dirtyä¸­å¢åŠ ç¬¬ä¸€ä¸ªæ–°é”®
		if !read.amended {
			// ä»m.readä¸­å¤åˆ¶æœªåˆ é™¤çš„æ•°æ®
			// å¹¶æ ‡è®°m.readå·²ç»è½åäºm.dirty
			m.dirtyLocked()
			m.read.Store(readOnly{m: read.m, amended: true})
		}
		//å°†è¿™ä¸ªentryåŠ å…¥åˆ°m.dirtyä¸­
		m.dirty[key] = newEntry(value)
	}
	m.mu.Unlock()
}</p>

<p>// tryStore stores a value if the entry has not been expunged.
//
// If the entry is expunged, tryStore returns false and leaves the entry
// unchanged.
func (e *entry) tryStore(i *interface{}) bool {
	for {
		p := atomic.LoadPointer(&amp;e.p)
		if p == expunged {
			return false
		}
		if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) {
			return true
		}
	}
}</p>

<p>func (m *Map) dirtyLocked() {
	if m.dirty != nil {
		return
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read, _ := m.read.Load().(readOnly)
m.dirty = make(map[interface{}]*entry, len(read.m))
for k, e := range read.m {
	if !e.tryExpungeLocked() {
		m.dirty[k] = e
	}
} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 æ•´ä½“çš„pipelineå¯ä»¥ç”¨ä¸‹å›¾æ¥è§£é‡Šï¼š
</code></pre></div></div>

<p>ä½ å¯ä»¥çœ‹åˆ°ï¼Œä»¥ä¸Šæ“ä½œéƒ½æ˜¯å…ˆä»æ“ä½œm.readå¼€å§‹çš„ï¼Œä¸æ»¡è¶³æ¡ä»¶å†åŠ é”ï¼Œç„¶åæ“ä½œm.dirtyã€‚</p>

<p>å¯èƒ½ä¼šå‘ç”Ÿä¸¤ç§æ•°æ®è¿ç§»ï¼š</p>

<p>ä»m.dirtyåˆ°m.readçš„è¿ç§»ï¼Œè¿™ä¸ªè¿ç§»è¿‡ç¨‹å…¶å®æ˜¯æŒ‡é’ˆçš„çš„ä¿®æ”¹ï¼Œæ‰€ä»¥æ•ˆç‡é«˜ï¼›
ä»read mapåˆ°dirty mapçš„è¿ç§», è¿™ä¸ªè¿ç§»éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„mapæ¥å¤åˆ¶key-valueï¼Œæ‰€ä»¥æ•ˆç‡ä¼šä½ä¸€äº›
Storeå¯èƒ½ä¼šåœ¨æŸç§æƒ…å†µä¸‹ï¼ˆåœ¨åˆšåˆå§‹åŒ–å’Œå°†æ‰€æœ‰å…ƒç´ è¿ç§»åˆ°readä¸­åï¼Œdirtyé»˜è®¤éƒ½æ˜¯nilå…ƒç´ ï¼Œè€Œæ­¤æ—¶å¦‚æœæœ‰æ–°çš„å…ƒç´ å¢åŠ ï¼Œåˆ™éœ€è¦å…ˆå°†read mapä¸­çš„æ‰€æœ‰æœªåˆ é™¤æ•°æ®å…ˆè¿ç§»åˆ°dirtyä¸­ï¼‰ä»m.readä¸­å¤åˆ¶æ•°æ®åˆ°m.dirtyï¼Œå¦‚æœè¿™ä¸ªæ—¶å€™m.readä¸­æ•°æ®é‡éå¸¸å¤§ï¼Œå¯èƒ½ä¼šå½±å“æ€§èƒ½ã€‚</p>

<p>delete
åˆ é™¤ä¸€ä¸ªé”®å€¼å¯¹ï¼š</p>

<p>func (m *Map) Delete(key interface{}) {
	// 1. å¦‚æœä¸å­˜åœ¨äº m.readä¸­ï¼Œè€Œä¸” m.dirty å’Œ m.read æ•°æ®ä¸ä¸€è‡´ã€‚
	read, _ := m.read.Load().(readOnly)
	e, ok := read.m[key]
	if !ok &amp;&amp; read.amended {
		// åŠ é”ï¼Œdouble checkï¼Œ ç„¶ååˆ é™¤å¯¹åº”çš„keyã€‚
		m.mu.Lock()
		read, _ = m.read.Load().(readOnly)
		e, ok = read.m[key]
		if !ok &amp;&amp; read.amended {
			delete(m.dirty, key)
		}
		m.mu.Unlock()
	}
	if ok {
		e.delete()
	}
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
æ•´ä½“pipeline:</p>

<p>è¿™é‡Œä¼šåˆ é™¤ m.dirty å¯¹åº”çš„key-value, ä½†æ˜¯m.readä¸­çš„key-valueå…¶å®å¹¶æ²¡æœ‰åˆ é™¤ï¼Œåªæ˜¯è®¾ç½®äº†åˆ é™¤çš„æ ‡å¿—ä¸ºexpungedã€‚è¿™é‡Œçš„æƒ°æ€§åˆ é™¤é¿å…äº†é‡æ–°åˆ›å»º entry å®ä½“ï¼Œåªç”¨æ›´æ–°æŒ‡é’ˆå’ŒvalueæŒ‡é’ˆã€‚</p>

<p>func (e *entry) delete() (hadValue bool) {
	for {
		p := atomic.LoadPointer(&amp;e.p)
		if p == nil || p == expunged {
			return false
		}
		if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
			return true
		}
	}
}
1
2
3
4
5
6
7
8
9
10
11
Range
è¿™é‡Œsync.Mapæ˜¯å¯¹mapå…³é”®å­—çš„å°è£…ï¼Œè‚¯å®šæ— æ³•ä½¿ç”¨ç³»ç»Ÿæä¾›çš„ for range æ“ä½œã€‚æ‰€ä»¥è¿™é‡Œé‡‡ç”¨äº†ä¸€ä¸ªå›è°ƒçš„æ“ä½œï¼š</p>

<p>func (m *Map) Range(f func(key, value interface{}) bool) {
	// å¦‚æœm.dirtyä¸­æœ‰æ–°æ•°æ®ï¼Œåˆ™æå‡m.dirty,ç„¶ååœ¨éå†
	read, _ := m.read.Load().(readOnly)
	if read.amended {
		///æå‡m.dirty
		m.mu.Lock()
		read, _ = m.read.Load().(readOnly)
		if read.amended {
			read = readOnly{m: m.dirty}
			m.read.Store(read)
			m.dirty = nil
			m.misses = 0
		}
		m.mu.Unlock()
	}
	// éå†, for rangeæ˜¯å®‰å…¨çš„
	for k, e := range read.m {
		v, ok := e.load()
		if !ok {
			continue
		}
		if !f(k, v) {
			break
		}
	}
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
Rangeæ–¹æ³•è°ƒç”¨å‰å¯èƒ½ä¼šåšä¸€ä¸ªm.dirtyçš„æå‡ï¼Œä¸è¿‡æå‡m.dirtyä¸æ˜¯ä¸€ä¸ªè€—æ—¶çš„æ“ä½œã€‚</p>

<p>sync.Mapæ€»ç»“
sync.Mapçš„ä¼˜åŒ–ç­–ç•¥ç®€å•æ€»ç»“å¯ä»¥ç†è§£ä¸ºï¼š</p>

<p>æ— é”è¯»ä¸è¯»å†™åˆ†ç¦»ï¼›</p>

<p>å†™åŠ é”ä¸å»¶è¿Ÿæå‡ï¼›</p>

<p>æŒ‡é’ˆä¸æƒ°æ€§åˆ é™¤ï¼Œmapä¿å­˜çš„valueéƒ½æ˜¯æŒ‡é’ˆã€‚æƒ°æ€§åˆ é™¤ï¼Œå®é™…åˆ é™¤æ˜¯åœ¨ Storeæ—¶å€™å»check ç„¶ååˆ é™¤ã€‚
sync.Mapï¼Œè¯»å†™é”çš„é€‚ç”¨åœºæ™¯
å®ç°æ–¹å¼	åŸç†	é€‚ç”¨åœºæ™¯
map+Mutex	é€šè¿‡Mutexäº’æ–¥é”æ¥å®ç°å¤šä¸ªgoroutineå¯¹mapçš„ä¸²è¡ŒåŒ–è®¿é—®	è¯»å†™éƒ½éœ€è¦é€šè¿‡MutexåŠ é”å’Œé‡Šæ”¾é”ï¼Œé€‚ç”¨äºè¯»å†™æ¯”æ¥è¿‘çš„åœºæ™¯
map+RWMutex	é€šè¿‡RWMutexæ¥å®ç°å¯¹mapçš„è¯»å†™è¿›è¡Œè¯»å†™é”åˆ†ç¦»åŠ é”ï¼Œä»è€Œå®ç°è¯»çš„å¹¶å‘æ€§èƒ½æé«˜	åŒMutexç›¸æ¯”é€‚ç”¨äºè¯»å¤šå†™å°‘çš„åœºæ™¯
sync.Map	åº•å±‚é€šåˆ†ç¦»è¯»å†™mapå’ŒåŸå­æŒ‡ä»¤æ¥å®ç°è¯»çš„è¿‘ä¼¼æ— é”ï¼Œå¹¶é€šè¿‡å»¶è¿Ÿæ›´æ–°çš„æ–¹å¼æ¥ä¿è¯è¯»çš„æ— é”åŒ–	è¯»å¤šä¿®æ”¹å°‘ï¼Œå…ƒç´ å¢åŠ åˆ é™¤é¢‘ç‡ä¸é«˜çš„æƒ…å†µï¼Œåœ¨å¤§å¤šæ•°æƒ…å†µä¸‹æ›¿ä»£ä¸Šè¿°ä¸¤ç§å®ç°
æºç æä¾›åˆ†æèƒŒæ™¯ï¼Œå®é™…æƒ…å†µè¿˜æ˜¯è¦case by caseçš„æµ‹è¯•ã€‚</p>

<p>å‚è€ƒæ–‡çŒ®
å®˜æ–¹æºç ï¼šsrc/sync/map.go
Go 1.9 sync.Mapæ­ç§˜ https://colobu.com/2017/07/11/dive-into-sync-Map/</p>

<p>https://colobu.com/2017/07/11/dive-into-sync-Map/</p>

<p>https://www.cnblogs.com/shuiyuejiangnan/p/9722791.html</p>

<p>å¦‚ä¹‹å‰çš„æ–‡ç« å¯ä»¥çœ‹åˆ°ï¼Œgolangä¸­çš„mapæ˜¯ä¸æ”¯æŒå¹¶å‘æ“ä½œçš„ï¼Œgolangæ¨èç”¨æˆ·ç›´æ¥ç”¨è¯»å†™é”å¯¹mapè¿›è¡Œä¿æŠ¤ï¼Œä¹Ÿæœ‰ç¬¬ä¸‰æ–¹ç±»åº“ä½¿ç”¨åˆ†æ®µé”ã€‚åœ¨1.19ç‰ˆæœ¬ä¸­ï¼ŒgolangåŸºäºåŸæœ¬çš„mapï¼Œæ–°å¢äº†ä¸€ä¸ªæ”¯æŒå¹¶å‘æ“ä½œçš„mapï¼Œå«sync mapã€‚</p>

<p>ä¸‹é¢æˆ‘ä»¬å…ˆä»‹ç»ä¸€ä¸‹å®ƒçš„ç”¨æ³•ï¼Œç„¶ååœ¨ä»‹ç»åŸç†ï¼Œæœ€åè¯¦ç»†çœ‹çœ‹ä»£ç ã€‚</p>

<p>ç”¨æ³•
åŸºæœ¬apiæœ‰è¿™å‡ ä¸ª</p>

<p>Store å†™å…¥
Load è¯»å–ï¼Œè¿”å›å€¼æœ‰ä¸¤ä¸ªï¼Œç¬¬ä¸€ä¸ªæ˜¯valueï¼Œç¬¬äºŒä¸ªæ˜¯boolå˜é‡è¡¨ç¤ºkeyæ˜¯å¦å­˜åœ¨
Delete åˆ é™¤
LoadOrStore å­˜åœ¨å°±è¯»ï¼Œä¸å­˜åœ¨å°±å†™
Range éå†ï¼Œæ³¨æ„éå†çš„å¿«ç…§
sync mapåº•å±‚ä½¿ç”¨map[interface{}]* entryæ¥åšå­˜å‚¨ï¼Œæ‰€ä»¥æ— è®ºkeyè¿˜æ˜¯valueéƒ½æ˜¯æ”¯æŒå¤šç§æ•°æ®ç±»å‹ã€‚
ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š</p>

<p>package main</p>

<p>import (
    â€œfmtâ€
     â€œsyncâ€
)</p>

<p>type MySyncMap struct {
    sync.Map
}</p>

<p>func (m MySyncMap) Print(k interface{}) {
    value, ok := m.Load(k)
    fmt.Println(value, ok)
}</p>

<p>func main() {
        var syncMap MySyncMap</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    syncMap.Print("Key1")

    syncMap.Store("Key1", "Value1")
    syncMap.Print("Key1")

    syncMap.Store("Key2", "Value2")

    syncMap.Store("Key3", 2)
    syncMap.Print("Key3")

    syncMap.Store(4, 4)
    syncMap.Print(4)

    syncMap.Delete("Key1")
    syncMap.Print("Key1") } è¾“å‡ºï¼š
</code></pre></div></div>

<nil> false
Value1 true
2 true
4 true
<nil> false
è®¾è®¡åŸç†
å¸¸ç”¨æ–¹æ¡ˆæ¯”è¾ƒ
å¹¶å‘hashmapçš„æ–¹æ¡ˆæœ‰å¾ˆå¤šï¼Œä¸‹é¢ç®€å•æä¸€ä¸‹å‡ ç§ï¼Œç„¶åå†è®¨è®ºgolangå®ç°æ—¶çš„è€ƒè™‘ã€‚
ç¬¬ä¸€ç§æ˜¯æœ€ç®€å•çš„ï¼Œç›´æ¥åœ¨ä¸æ”¯æŒå¹¶å‘çš„hashmapä¸Šï¼Œä½¿ç”¨ä¸€ä¸ªè¯»å†™é”çš„ä¿æŠ¤ï¼Œè¿™ä¹Ÿæ˜¯golang sync mapè¿˜æ²¡å‡ºæ¥å‰ï¼Œå¤§å®¶å¸¸ç”¨çš„æ–¹æ³•ã€‚è¿™ç§æ–¹æ³•çš„ç¼ºç‚¹æ˜¯å†™ä¼šå µå¡è¯»ã€‚

ç¬¬äºŒç§æ˜¯æ•°æ®åº“å¸¸ç”¨çš„æ–¹æ³•ï¼Œåˆ†æ®µé”ï¼Œæ¯ä¸€ä¸ªè¯»å†™é”ä¿æŠ¤ä¸€æ®µåŒºé—´ï¼Œgolangçš„ç¬¬ä¸‰æ–¹åº“ä¹Ÿæœ‰äººæ˜¯è¿™ä¹ˆå®ç°çš„ã€‚javaçš„ConcurrentHashMapä¹Ÿæ˜¯è¿™ä¹ˆå®ç°çš„ã€‚å¹³å‡æƒ…å†µä¸‹è¿™æ ·çš„æ€§èƒ½è¿˜æŒºå¥½çš„ï¼Œä½†æ˜¯æç«¯æƒ…å†µä¸‹ï¼Œå¦‚æœæŸä¸ªåŒºé—´æœ‰çƒ­ç‚¹å†™ï¼Œé‚£ä¹ˆé‚£ä¸ªåŒºé—´çš„è¯»è¯·æ±‚ä¹Ÿä¼šå—åˆ°å½±å“ã€‚

ç¬¬ä¸‰ç§æ–¹æ³•æ˜¯æˆ‘ä»¬C++è‡ªå·±é€ è½®å­æ—¶ç»å¸¸ç”¨çš„ï¼Œä½¿ç”¨ä½¿ç”¨é“¾è¡¨æ³•è§£å†³å†²çªï¼Œç„¶åé“¾è¡¨ä½¿ç”¨CASå»è§£å†³å¹¶å‘ä¸‹å†²çªï¼Œè¿™æ ·è¯»å†™éƒ½æ˜¯æ— é”ï¼Œæˆ‘è§‰å¾—è¿™ç§æŒºå¥½çš„ï¼Œæ€§èƒ½éå¸¸é«˜ï¼Œä¸çŸ¥ä¸ºå•¥å…¶ä»–è¯­è¨€ä¸è¿™ä¹ˆå®ç°ã€‚

ç„¶ååœ¨ã€ŠAn overview of sync.Mapã€‹ä¸­æœ‰æåˆ°ï¼Œåœ¨cpuæ ¸æ•°å¾ˆå¤šçš„æƒ…å†µä¸‹ï¼Œå› ä¸ºcache contentionï¼Œreflect.Newã€sync.RWMutexã€atomic.AddUint32éƒ½ä¼šå¾ˆæ…¢ï¼Œgolangå›¢é˜Ÿä¸ºäº†é€‚åº”cpuæ ¸å¾ˆå¤šçš„æƒ…å†µï¼Œæ²¡æœ‰é‡‡ç”¨ä¸Šé¢çš„å‡ ç§å¸¸è§çš„æ–¹æ¡ˆã€‚

golang sync mapçš„ç›®æ ‡æ˜¯å®ç°é€‚åˆè¯»å¤šå†™å°‘çš„åœºæ™¯ã€å¹¶ä¸”è¦æ±‚ç¨³å®šæ€§å¾ˆå¥½ï¼Œä¸èƒ½å‡ºç°åƒåˆ†æ®µé”é‚£æ ·è¯»ç»å¸¸è¢«é˜»å¡çš„æƒ…å†µã€‚golang sync mapåŸºäºmapåšäº†ä¸€å±‚å°è£…ï¼Œåœ¨å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œä¸è¿‡å†™å…¥æ€§èƒ½æ¯”è¾ƒå·®ã€‚ä¸‹é¢æ¥è¯¦ç»†è¯´è¯´å®ç°ã€‚

å®ç°æ€è·¯
è¦è¯»å—åˆ°çš„å½±å“å°½é‡å°ï¼Œé‚£ä¹ˆæœ€å®¹æ˜“æƒ³åˆ°çš„æƒ³æ³•ï¼Œå°±æ˜¯è¯»å†™åˆ†ç¦»ã€‚golang sync mapä¹Ÿæ˜¯å—åˆ°è¿™ä¸ªæƒ³æ³•çš„å¯å‘ï¼ˆæˆ‘è‡ªè®¤ä¸ºï¼‰è®¾è®¡å‡ºæ¥çš„ã€‚ä½¿ç”¨äº†ä¸¤ä¸ªmapï¼Œä¸€ä¸ªå«readï¼Œä¸€ä¸ªå«dirtyï¼Œä¸¤ä¸ªmapå­˜å‚¨çš„éƒ½æ˜¯æŒ‡é’ˆï¼ŒæŒ‡å‘valueæ•°æ®æœ¬èº«ï¼Œæ‰€ä»¥ä¸¤ä¸ªmapæ˜¯å…±äº«valueæ•°æ®çš„ï¼Œæ›´æ–°valueå¯¹ä¸¤ä¸ªmapåŒæ—¶å¯è§ã€‚

dirtyå¯ä»¥è¿›è¡Œå¢åˆ æŸ¥ï¼Œå½“æ—¶éƒ½è¦è¿›è¡ŒåŠ äº’æ–¥é”ã€‚

readä¸­å­˜åœ¨çš„keyï¼Œå¯ä»¥æ— é”çš„è¯»ï¼Œå€ŸåŠ©CASè¿›è¡Œæ— é”çš„æ›´æ–°ã€åˆ é™¤æ“ä½œï¼Œä½†æ˜¯ä¸èƒ½æ–°å¢keyï¼Œç›¸å½“äºdirtyçš„ä¸€ä¸ªcacheï¼Œç”±äºvalueå…±äº«ï¼Œæ‰€ä»¥èƒ½é€šè¿‡readå¯¹å·²å­˜åœ¨çš„valueè¿›è¡Œæ›´æ–°ã€‚

readä¸èƒ½æ–°å¢keyï¼Œé‚£ä¹ˆæ•°æ®æ€ä¹ˆæ¥çš„å‘¢ï¼Ÿsync mapä¸­ä¼šè®°å½•miss cacheçš„æ¬¡æ•°ï¼Œå½“missæ¬¡æ•°å¤§äºç­‰äºdirtyå…ƒç´ ä¸ªæ•°æ—¶ï¼Œå°±ä¼šæŠŠdirtyå˜æˆreadï¼ŒåŸæ¥çš„dirtyæ¸…ç©ºã€‚

ä¸ºäº†æ–¹ä¾¿dirtyç›´æ¥å˜æˆreadï¼Œé‚£ä¹ˆå¾—ä¿è¯readä¸­å­˜åœ¨çš„æ•°æ®dirtyå¿…é¡»æœ‰ï¼Œæ‰€ä»¥åœ¨dirtyæ˜¯ç©ºçš„æ—¶å€™ï¼Œå¦‚æœè¦æ–°å¢ä¸€ä¸ªkeyï¼Œé‚£ä¹ˆä¼šæŠŠreadä¸­çš„å…ƒç´ å¤åˆ¶åˆ°dirtyä¸­ï¼Œç„¶åå†™å…¥æ–°keyã€‚

ç„¶ååˆ é™¤æ“ä½œä¹Ÿå¾ˆæœ‰æ„æ€ï¼Œä½¿ç”¨çš„æ˜¯å»¶è¿Ÿåˆ é™¤ï¼Œä¼˜å…ˆçœ‹readä¸­æ²¡æœ‰ï¼Œreadä¸­æœ‰ï¼Œå°±æŠŠreadä¸­çš„å¯¹åº”entryæŒ‡é’ˆä¸­çš„pç½®ä¸ºnilï¼Œä½œä¸ºä¸€ä¸ªæ ‡è®°ã€‚åœ¨readä¸­æ ‡è®°ä¸ºnilçš„ï¼Œåªæœ‰åœ¨dirtyæå‡ä¸ºreadæ—¶æ‰ä¼šè¢«å®é™…åˆ é™¤ã€‚

æºç 
ç»“æ„
// The zero Map is empty and ready for use. A Map must not be copied after first use.
type Map struct {
    mu Mutex

    // read contains the portion of the map's contents that are safe for
    // concurrent access (with or without mu held).
    //
    // The read field itself is always safe to load, but must only be stored with
    // mu held.
    //
    // Entries stored in read may be updated concurrently without mu, but updating
    // a previously-expunged entry requires that the entry be copied to the dirty
    // map and unexpunged with mu held.
    read atomic.Value // readOnly

    // dirty contains the portion of the map's contents that require mu to be
    // held. To ensure that the dirty map can be promoted to the read map quickly,
    // it also includes all of the non-expunged entries in the read map.
    //
    // Expunged entries are not stored in the dirty map. An expunged entry in the
    // clean map must be unexpunged and added to the dirty map before a new value
    // can be stored to it.
    //
    // If the dirty map is nil, the next write to the map will initialize it by
    // making a shallow copy of the clean map, omitting stale entries.
    dirty map[interface{}]*entry

    // misses counts the number of loads since the read map was last updated that
    // needed to lock mu to determine whether the key was present.
    //
    // Once enough misses have occurred to cover the cost of copying the dirty
    // map, the dirty map will be promoted to the read map (in the unamended
    // state) and the next store to the map will make a new dirty copy.
    misses int
}

//readçš„å®é™…ç»“æ„ä½“
// readOnly is an immutable struct stored atomically in the Map.read field.
type readOnly struct {
    m       map[interface{}]*entry
    amended bool // true if the dirty map contains some key not in m.
}

// expunged is an arbitrary pointer that marks entries which have been deleted
// from the dirty map.
var expunged = unsafe.Pointer(new(interface{}))

// An entry is a slot in the map corresponding to a particular key.
type entry struct {
    // p points to the interface{} value stored for the entry.
    //
    // If p == nil, the entry has been deleted and m.dirty == nil.
    //
    // If p == expunged, the entry has been deleted, m.dirty != nil, and the entry
    // is missing from m.dirty.
    //
    // Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty
    // != nil, in m.dirty[key].
    //
    // An entry can be deleted by atomic replacement with nil: when m.dirty is
    // next created, it will atomically replace nil with expunged and leave
    // m.dirty[key] unset.
    //
    // An entry's associated value can be updated by atomic replacement, provided
    // p != expunged. If p == expunged, an entry's associated value can be updated
    // only after first setting m.dirty[key] = e so that lookups using the dirty
    // map find the entry.
    p unsafe.Pointer // *interface{}
}

sync mapç»“æ„
muæ˜¯ç”¨æ¥ä¿æŠ¤dirtyçš„äº’æ–¥é”
missedæ˜¯è®°å½•æ²¡å‘½ä¸­readçš„æ¬¡æ•°

æ³¨æ„å¯¹äºentry.pï¼Œæœ‰ä¸¤ä¸ªç‰¹æ®Šå€¼ï¼Œä¸€ä¸ªæ˜¯nilï¼Œå¦ä¸€ä¸ªæ˜¯expungedã€‚nilä»£è¡¨çš„æ„æ€æ˜¯ï¼Œåœ¨readä¸­è¢«åˆ é™¤äº†ï¼Œä½†æ˜¯dirtyä¸­è¿˜åœ¨ï¼Œæ‰€ä»¥èƒ½ç›´æ¥æ›´æ–°å€¼(å¦‚æœdirty==nillçš„ç‰¹æ®Šæƒ…å†µ,ä¸‹æ¬¡å†™å…¥æ–°å€¼æ—¶ä¼šå¤åˆ¶)ï¼›expungedä»£è¡¨æ•°æ®åœ¨ditryä¸­å·²ç»è¢«åˆ é™¤äº†ï¼Œæ›´æ–°å€¼çš„æ—¶å€™è¦å…ˆæŠŠè¿™ä¸ªentryå¤åˆ¶åˆ°dirtyã€‚

Load è¯»å–

// Load returns the value stored in the map for a key, or nil if no
// value is present.
// The ok result indicates whether value was found in the map.
func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
    read, _ := m.read.Load().(readOnly)
    e, ok := read.m[key]
    if !ok &amp;&amp; read.amended {
        m.mu.Lock()
        // Avoid reporting a spurious miss if m.dirty got promoted while we were
        // blocked on m.mu. (If further loads of the same key will not miss, it's
        // not worth copying the dirty map for this key.)
        read, _ = m.read.Load().(readOnly)
        e, ok = read.m[key]
        if !ok &amp;&amp; read.amended {
            e, ok = m.dirty[key]
            // Regardless of whether the entry was present, record a miss: this key
            // will take the slow path until the dirty map is promoted to the read
            // map.
            m.missLocked()
        }
        m.mu.Unlock()
    }
    if !ok {
        return nil, false
    }
    return e.load()
}

func (e *entry) load() (value interface{}, ok bool) {
    p := atomic.LoadPointer(&amp;e.p)
    if p == nil || p == expunged {
        return nil, false
    }
    return *(*interface{})(p), true
}

func (m *Map) missLocked() {
    m.misses++
    if m.misses &lt; len(m.dirty) {
        return
    }
    m.read.Store(readOnly{m: m.dirty})
    m.dirty = nil
    m.misses = 0
}
è¯»å–æ—¶ï¼Œå…ˆå»readè¯»å–ï¼›å¦‚æœæ²¡æœ‰ï¼Œå°±åŠ é”ï¼Œç„¶åå»dirtyè¯»å–ï¼ŒåŒæ—¶è°ƒç”¨missLocked()ï¼Œå†è§£é”ã€‚åœ¨missLockedä¸­ï¼Œä¼šé€’å¢misseså˜é‡ï¼Œå¦‚æœmisses&gt;len(dirty)ï¼Œé‚£ä¹ˆæŠŠdirtyæå‡ä¸ºreadï¼Œæ¸…ç©ºåŸæ¥çš„dirtyã€‚

åœ¨ä»£ç ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¸€ä¸ªdouble checkï¼Œæ£€æŸ¥readæ²¡æœ‰ï¼Œä¸Šé”ï¼Œå†æ£€æŸ¥readä¸­æœ‰æ²¡æœ‰ï¼Œæ˜¯å› ä¸ºæœ‰å¯èƒ½åœ¨ç¬¬ä¸€æ¬¡æ£€æŸ¥ä¹‹åï¼Œä¸Šé”ä¹‹å‰çš„é—´éš™ï¼Œdirtyæå‡ä¸ºreadäº†ï¼Œè¿™æ—¶å¦‚æœä¸double checkï¼Œå¯èƒ½ä¼šå¯¼è‡´ä¸€ä¸ªå­˜åœ¨çš„keyå´è¿”å›ç»™è°ƒç”¨æ–¹è¯´ä¸å­˜åœ¨ã€‚ åœ¨ä¸‹é¢çš„å…¶ä»–æ“ä½œä¸­ï¼Œæˆ‘ä»¬ç»å¸¸ä¼šçœ‹åˆ°è¿™ä¸ªdouble checkã€‚

Store å†™å…¥
// Store sets the value for a key.
func (m *Map) Store(key, value interface{}) {
    read, _ := m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
        return
    }

    m.mu.Lock()
    read, _ = m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok {
        if e.unexpungeLocked() {
            // The entry was previously expunged, which implies that there is a
            // non-nil dirty map and this entry is not in it.
            m.dirty[key] = e
        }
        e.storeLocked(&amp;value)
    } else if e, ok := m.dirty[key]; ok {
        e.storeLocked(&amp;value)
    } else {
        if !read.amended {
            // We're adding the first new key to the dirty map.
            // Make sure it is allocated and mark the read-only map as incomplete.
            m.dirtyLocked()
            m.read.Store(readOnly{m: read.m, amended: true})
        }
        m.dirty[key] = newEntry(value)
    }
    m.mu.Unlock()
}

// tryStore stores a value if the entry has not been expunged.
//
// If the entry is expunged, tryStore returns false and leaves the entry
// unchanged.
func (e *entry) tryStore(i *interface{}) bool {
    p := atomic.LoadPointer(&amp;e.p)
    if p == expunged {
        return false
    }
    for {
        if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) {
            return true
        }
        p = atomic.LoadPointer(&amp;e.p)
        if p == expunged {
            return false
        }
    }
}

func (m *Map) dirtyLocked() {
    if m.dirty != nil {
        return
    }

    read, _ := m.read.Load().(readOnly)
    m.dirty = make(map[interface{}]*entry, len(read.m))
    for k, e := range read.m {
        if !e.tryExpungeLocked() {
            m.dirty[k] = e
        }
    }
}

func (e *entry) tryExpungeLocked() (isExpunged bool) {
    p := atomic.LoadPointer(&amp;e.p)
    for p == nil {
        if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
            return true
        }
        p = atomic.LoadPointer(&amp;e.p)
    }
    return p == expunged
}

// unexpungeLocked ensures that the entry is not marked as expunged.
//
// If the entry was previously expunged, it must be added to the dirty map
// before m.mu is unlocked.
func (e *entry) unexpungeLocked() (wasExpunged bool) {
    return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)
}
å†™å…¥çš„æ—¶å€™ï¼Œå…ˆçœ‹readä¸­èƒ½å¦æŸ¥åˆ°keyï¼Œåœ¨readä¸­å­˜åœ¨çš„è¯ï¼Œç›´æ¥é€šè¿‡readä¸­çš„entryæ¥æ›´æ–°å€¼ï¼›åœ¨readä¸­ä¸å­˜åœ¨ï¼Œé‚£ä¹ˆå°±ä¸Šé”ï¼Œç„¶ådouble checkã€‚è¿™é‡Œéœ€è¦ç•™æ„ï¼Œåˆ†å‡ ç§æƒ…å†µï¼š

double checkå‘ç°readä¸­å­˜åœ¨ï¼Œå¦‚æœæ˜¯expungedï¼Œé‚£ä¹ˆå°±å…ˆå°è¯•æŠŠexpungedæ›¿æ¢æˆnilï¼Œæœ€åå¦‚æœentry.p==expungedå°±å¤åˆ¶åˆ°dirtyä¸­ï¼Œå†å†™å…¥å€¼ï¼›å¦åˆ™ä¸ç”¨æ›¿æ¢ç›´æ¥å†™å…¥å€¼ã€‚
dirtyä¸­å­˜åœ¨ï¼Œç›´æ¥æ›´æ–°
dirtyä¸­ä¸å­˜åœ¨ï¼Œå¦‚æœæ­¤æ—¶dirtyä¸ºç©ºï¼Œé‚£ä¹ˆéœ€è¦å°†readå¤åˆ¶åˆ°dirtyä¸­ï¼Œæœ€åå†æŠŠæ–°å€¼å†™å…¥åˆ°dirtyä¸­ã€‚å¤åˆ¶çš„æ—¶å€™è°ƒç”¨çš„æ˜¯dirtyLocked()ï¼Œåœ¨å¤åˆ¶åˆ°dirtyçš„æ—¶å€™ï¼Œreadä¸­ä¸ºnilçš„å…ƒç´ ï¼Œä¼šæ›´æ–°ä¸ºexpungedï¼Œå¹¶ä¸”ä¸å¤åˆ¶åˆ°dirtyä¸­ã€‚
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œåœ¨æ›´æ–°readä¸­çš„æ•°æ®æ—¶ï¼Œä½¿ç”¨çš„æ˜¯tryStoreï¼Œé€šè¿‡CASæ¥è§£å†³å†²çªï¼Œåœ¨CASå‡ºç°å†²çªåï¼Œå¦‚æœå‘ç°æ•°æ®è¢«ç½®ä¸ºexpungï¼ŒtryStoreé‚£ä¹ˆå°±ä¸ä¼šå†™å…¥æ•°æ®ï¼Œè€Œæ˜¯ä¼šè¿”å›falseï¼Œåœ¨Storeæµç¨‹ä¸­ï¼Œå°±æ˜¯æ¥ç€å¾€ä¸‹èµ°ï¼Œåœ¨dirtyä¸­å†™å…¥ã€‚

å†çœ‹ä¸‹æƒ…å†µ1çš„æ—¶å€™ï¼Œä¸ºå•¥è¦é‚£ä¹ˆåšã€‚double checkçš„æ—¶å€™ï¼Œåœ¨readä¸­å­˜åœ¨ï¼Œé‚£ä¹ˆå°±æ˜¯è¯´åœ¨åŠ é”ä¹‹å‰ï¼Œæœ‰å¹¶å‘çº¿ç¨‹å…ˆå†™å…¥äº†keyï¼Œç„¶åç”±Loadè§¦å‘äº†dirtyæå‡ä¸ºreadï¼Œè¿™æ—¶dirtyå¯èƒ½ä¸ºç©ºï¼Œä¹Ÿå¯èƒ½ä¸ä¸ºç©ºï¼Œä½†æ— è®ºdirtyçŠ¶æ€å¦‚ä½•ï¼Œéƒ½æ˜¯å¯ä»¥ç›´æ¥æ›´æ–°entry.pã€‚å¦‚æœæ˜¯expungedçš„è¯ï¼Œé‚£ä¹ˆè¦å…ˆæ›¿æ¢æˆnilï¼Œå†å¤åˆ¶entryåˆ°dirtyä¸­ã€‚

ç–‘é—®ï¼šè¿™é‡Œä¸å¤ªæ‡‚ï¼Œä¸ºå•¥åœ¨readä¸­ç›´æ¥æ›´æ–°å°±ç”¨caså»æ›´æ–°ï¼Œè·‘åˆ°ä¸‹é¢çš„æµç¨‹ï¼Œå°±ç”¨åŸå­æ›´æ–°ï¼Œå¯æ˜¯å°½ç®¡ä¸Šäº†é”ï¼Œkeyåœ¨readä¸­å­˜åœ¨ï¼Œé‚£ä¹ˆå°±ä¼šå¹¶å‘å†™ï¼Œä¸ºå•¥å¯ä»¥ä¸ç”¨casæ›´æ–°ï¼Ÿï¼Ÿ

Delete åˆ é™¤
// Delete deletes the value for a key.
func (m *Map) Delete(key interface{}) {
    read, _ := m.read.Load().(readOnly)
    e, ok := read.m[key]
    if !ok &amp;&amp; read.amended {
        m.mu.Lock()
        read, _ = m.read.Load().(readOnly)
        e, ok = read.m[key]
        if !ok &amp;&amp; read.amended {
            delete(m.dirty, key)
        }
        m.mu.Unlock()
    }
    if ok {
        e.delete()
    }
}

func (e *entry) delete() (hadValue bool) {
    for {
        p := atomic.LoadPointer(&amp;e.p)
        if p == nil || p == expunged {
            return false
        }
        if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
            return true
        }
    }
}
åˆ é™¤å¾ˆç®€å•ï¼Œreadä¸­å­˜åœ¨ï¼Œå°±æŠŠreadä¸­çš„entry.pç½®ä¸ºnilï¼Œå¦‚æœåªåœ¨ditryä¸­å­˜åœ¨ï¼Œé‚£ä¹ˆå°±ç›´æ¥ä»dirtyä¸­åˆ æ‰å¯¹åº”çš„entryã€‚

https://studygolang.com/articles/16141


golang map è¯»å†™é”ä¸æ·±åº¦æ‹·è´çš„å‘

0X01

golangä¸­ï¼Œmapï¼ˆå­—å…¸ï¼‰æ— æ³•å¹¶å‘è¯»å†™

ç®€å•æ¥è¯´ï¼Œæ–°å»ºä¸‡æ¡çº¿ç¨‹å¯¹åŒä¸€ä¸ªmapåˆè¯»åˆå†™ï¼Œä¼šæŠ¥é”™ã€‚

ä¸ºæ­¤ï¼Œæœ€å¥½åŠ é”ï¼Œå…¶å®æ€§èƒ½å½±å“å¹¶ä¸æ˜æ˜¾ã€‚

type taskCache struct{
    sync.RWMutex
    data map[string] interface{}
}
 

 

0X02

golangä¸­ï¼Œmapï¼ˆå­—å…¸ï¼‰ä¸ºå¼•ç”¨æ‹·è´ã€‚

a = å­—å…¸ä¸€

b = a 

å®é™…ä¸Šæ˜¯ç›´æ¥å°†æŒ‡é’ˆä¼ ç»™äº†bã€‚

 

äºæ˜¯ï¼Œæœ‰ä¸€ä¸ªè¯»å–ï¼Œå†™çš„æ—¶å€™ç›´æ¥è¯»mapå¹¶è¿”å›

å¤åˆ¶ä»£ç 
func GetAllTasks() (result map[string]interface{}, err error) {
    // è·å¾—å½“å‰çš„æ‰€æœ‰ä»»åŠ¡
    DEMO.RLock()
    defer DEMO.RUnlock()
    return DEMO.data, err
}
å¤åˆ¶ä»£ç 
è€Œåœ¨çº¿ç¨‹ä¸­

// æ¥æ”¶åç›´æ¥æ‰“å°
fmt.Println(store.GetAllTasks())
ç»“æœå±…ç„¶æŠ¥é”™ï¼Œmapè¯»å†™å†²çªã€‚

 

äºæ˜¯ï¼Œæˆ‘è¿”å›å»ä¸€éä¸€éçœ‹ä»£ç ï¼Œè§‰å¾—è‡ªå·±çš„è¯»å†™é”å†™é”™äº†ã€‚

è°ƒå¼æŠ˜è…¾äº†åŠå¤©ï¼Œæœ€åå‘ç°ï¼Œåœ¨æ¥æ”¶åä¸ç”¨ fmt.Println æ‰“å°å°±ä¸ä¼šæŠ¥é”™ã€‚

è¿™å¾ˆä¸ç§‘å­¦ï¼Œç„¶ååœ¨æ¥æ”¶æ‰“å°å‰ååŠ ä¸Šè¯»é”ï¼Œä¸æŠ¥é”™äº†ã€‚

 

0X03

æ‰€ä»¥golangï¼ŒåŠ äº†è¯»å†™é”çš„æ—¶å€™ï¼Œè¦è¿”å›å…¨éƒ¨å€¼ï¼Œè¿˜ä¸èƒ½ç›´æ¥è¿”å›è¿™ä¸ªå­—å…¸ï¼Œå› ä¸ºç›´æ¥è¿”å›è¿™ä¸ªå­—å…¸ï¼Œè¿”å›äº†æŒ‡é’ˆï¼Œæ“ä½œçš„æ—¶å€™è¦ä¸è¿˜è¦åŠ è¯»å†™é”ï¼Œè¦ä¸å°±æŠ¥é”™ã€‚

è¿˜æ²¡æœ‰ç›´æ¥çš„å–åœ°å€çš„å€¼é‡æ–°ç»™å¦ä¸€ä¸ªå˜é‡çš„ä¸œè¥¿ï¼Œè‡ªå·±å†™ä¸ªéå†ï¼Œä¸€ä¸ªä¸€ä¸ªèµ‹å€¼å§ï¼Œè›‹ç–¼ï¼Œå‘è´§ï¼Œå‘äº†ä¸€æ™šä¸Š

var cache = make(map[string]interface{})
for k,v := range Demo.data{
    cache[k] = v
}

https://zhuanlan.zhihu.com/p/102385081?utm_source=qq

æ ¸å¿ƒæ€æƒ³æ˜¯ç”¨ç©ºé—´æ¢æ—¶é—´ï¼Œç”¨ä¸¤ä¸ªmapæ¥å­˜å‚¨æ•°æ®ï¼Œreadå’Œdirtyï¼Œreadæ”¯æŒåŸå­æ“ä½œï¼Œå¯ä»¥çœ‹ä½œæ˜¯dirty çš„cacheï¼Œdirtyæ˜¯æ›´åº•å±‚çš„æ•°æ®å­˜å‚¨å±‚
4ç§æ“ä½œï¼šè¯»keyã€å¢åŠ keyã€æ›´æ–°keyã€åˆ é™¤keyçš„åŸºæœ¬æµç¨‹
è¯»keyï¼šå…ˆåˆ°readä¸­è¯»å–ï¼Œå¦‚æœæœ‰åˆ™ç›´æ¥è¿”å›ç»“æœï¼Œå¦‚æœæ²¡æœ‰æˆ–è€…æ˜¯è¢«åˆ é™¤ï¼ˆæœ‰ç‰¹æ®Švalueå€¼å¯ä»¥åˆ¤æ–­ï¼‰ï¼Œåˆ™åˆ°dirtyåŠ é”ä¸­è¯»å–ï¼Œå¦‚æœæœ‰è¿”å›ç»“æœå¹¶æ›´æ–°missæ•°
å¢åŠ keyï¼šç›´æ¥å¢åŠ åˆ°dirtyä¸­
æ›´æ–°keyï¼šå…ˆåˆ°readä¸­çœ‹çœ‹æœ‰æ²¡æœ‰ï¼Œå¦‚æœæœ‰ç›´æ¥æ›´æ–°keyï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ°dirtyä¸­æ›´æ–°
åˆ é™¤keyï¼šå…ˆåˆ°readä¸­çœ‹çœ‹æœ‰æ²¡æœ‰ï¼Œå¦‚æœæœ‰åˆ™ç›´æ¥æ›´æ–°ä¸ºnilï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ°dirtyä¸­ç›´æ¥åˆ é™¤

readçš„æ›¿æ¢ï¼šå½“readå¤šæ¬¡éƒ½æ²¡æœ‰å‘½ä¸­æ•°æ®ï¼Œè¾¾åˆ°é˜ˆå€¼ï¼Œè¡¨ç¤ºè¿™ä¸ªcacheå‘½ä¸­ç‡å¤ªä½ï¼Œè¿™æ—¶ç›´æ¥å°†æ•´ä¸ªreadç”¨dirtyæ›¿æ¢æ‰ï¼Œç„¶ådirtyåˆé‡æ–°ç½®ä¸ºnilï¼Œä¸‹ä¸€æ¬¡å†æ·»åŠ ä¸€ä¸ªæ–°keyçš„æ—¶å€™ï¼Œä¼šè§¦å‘ä¸€æ¬¡readåˆ°dirtyçš„å¤åˆ¶ï¼Œè¿™æ ·äºŒè€…åˆä¿æŒäº†ä¸€è‡´ã€‚

è™½ç„¶readå’Œdirtyæœ‰å†—ä½™ï¼Œä½†è¿™äº›mapçš„valueæ•°æ®æ˜¯é€šè¿‡æŒ‡é’ˆæŒ‡å‘åŒä¸€ä¸ªæ•°æ®ï¼Œæ‰€ä»¥å°½ç®¡å®é™…çš„valueä¼šå¾ˆå¤§ï¼Œä½†æ˜¯å†—ä½™çš„ç©ºé—´å ç”¨è¿˜æ˜¯æœ‰é™çš„ã€‚

æ€»ç»“ï¼Œå¦‚æœå¯¹mapçš„è¯»æ“ä½œè¿œè¿œå¤šäºå†™æ“ä½œï¼ˆå†™æ“ä½œåŒ…æ‹¬æ–°å¢å’Œåˆ é™¤keyï¼‰ï¼Œé‚£ä¹ˆsync.Mapæ˜¯å¾ˆåˆé€‚ï¼Œèƒ½å¤Ÿå¤§å¤§æå‡æ€§èƒ½

syncmapæ˜¯golang1.5å¼•å…¥çš„çº¿ç¨‹å®‰å…¨çš„mapï¼Œä»¥ä¸‹æ˜¯æµ‹è¯•ç¨‹åºï¼Œç»“è®ºï¼š ä¸å»ºè®®ä½¿ç”¨sync.map, åŸå› ï¼š 1. æ€§èƒ½ä¸åŠåŠ é”çš„map, 2. å¯¹jsonä¸å‹å¥½

package main_test

import (
	"math/rand"
	"sync"
	"testing"
)

type WrapedMap struct {
	lck sync.Mutex
	m   map[int]int
}

var normalMap WrapedMap
var syncMap sync.Map

func TestMain(m *testing.M) {
	normalMap = WrapedMap{
		lck: sync.Mutex{},
		m:   make(map[int]int, 100000),
	}

	m.Run()
}

func BenchmarkLockMapWrite(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			a := rand.Intn(100) + 1
			b := rand.Intn(a)
			normalMap.lck.Lock()
			normalMap.m[a] = b
			normalMap.lck.Unlock()
		}
	})
}

func BenchmarkLockMapRead(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			a := rand.Intn(100) + 1
			normalMap.lck.Lock()
			_, _ = normalMap.m[a]
			normalMap.lck.Unlock()
		}
	})
}

func BenchmarkSyncMapWrite(b *testing.B) {

	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			a := rand.Intn(100) + 1
			b := rand.Intn(a)
			syncMap.Store(a, b)
		}
	})
}

func BenchmarkSyncMapRead(b *testing.B) {
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			a := rand.Intn(100) + 1
			syncMap.Load(a)
		}
	})
}

</nil></nil>
:ET