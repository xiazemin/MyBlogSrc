I"£‰<p>traitsï¼Œåˆè¢«å«åšç‰¹æ€§èƒå–æŠ€æœ¯ï¼Œè¯´å¾—ç®€å•ç‚¹å°±æ˜¯æå–â€œè¢«ä¼ è¿›çš„å¯¹è±¡â€å¯¹åº”çš„è¿”å›ç±»å‹ï¼Œè®©åŒä¸€ä¸ªæ¥å£å®ç°å¯¹åº”çš„åŠŸèƒ½ã€‚å› ä¸ºSTLçš„ç®—æ³•å’Œå®¹å™¨æ˜¯åˆ†ç¦»çš„ï¼Œä¸¤è€…é€šè¿‡è¿­ä»£å™¨é“¾æ¥ã€‚ç®—æ³•çš„å®ç°å¹¶ä¸çŸ¥é“è‡ªå·±è¢«ä¼ è¿›æ¥ä»€ä¹ˆã€‚èƒå–å™¨ç›¸å½“äºåœ¨æ¥å£å’Œå®ç°ä¹‹é—´åŠ ä¸€å±‚å°è£…ï¼Œæ¥éšè—ä¸€äº›ç»†èŠ‚å¹¶ååŠ©è°ƒç”¨åˆé€‚çš„æ–¹æ³•ï¼Œè¿™éœ€è¦ä¸€äº›æŠ€å·§ï¼ˆä¾‹å¦‚ï¼Œåç‰¹åŒ–ï¼‰ã€‚æœ€åé™„å¸¦ä¸€ä¸ªå°å°çš„ä¾‹å­ï¼Œåº”è¯¥èƒ½æ›´å¥½åœ°ç†è§£ ç‰¹æ€§èƒå–ã€‚</p>

<p>ã€€ã€€ä¸‹é¢å¤§éƒ¨åˆ†æ¥æºäºã€ŠSTLæºç å‰–æã€‹ï¼Œçœ‹åŸä¹¦èƒ½äº†è§£æ›´å¤šç»†èŠ‚ã€‚
<!-- more -->
è®©æˆ‘ä»¬ä¸€ç‚¹ç‚¹æŠ›å‡ºé—®é¢˜ï¼Œç„¶åä¸€ç‚¹ç‚¹æ·±å…¥ã€‚</p>

<p>ã€€ã€€1. é¦–å…ˆï¼Œåœ¨ç®—æ³•ä¸­è¿ç”¨è¿­ä»£å™¨æ—¶ï¼Œå¾ˆå¯èƒ½ä¼šç”¨åˆ°å…¶ç›¸åº”å‹åˆ«ï¼ˆè¿­ä»£å™¨æ‰€æŒ‡ä¹‹ç‰©çš„å‹åˆ«ï¼‰ã€‚å‡è®¾ç®—æ³•ä¸­æœ‰å¿…è¦å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œä»¥â€œè¿­ä»£å™¨æ‰€æŒ‡å¯¹è±¡çš„å‹åˆ«â€ä¸ºå‹åˆ«ï¼Œè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ</p>

<p>ã€€ã€€è§£å†³æ–¹æ³•æ˜¯ï¼šåˆ©ç”¨function templateçš„å‚æ•°æ¨å¯¼æœºåˆ¶ã€‚
ã€€ã€€template &lt;class I, class T&gt;
void func_impl(I iter, T t) {
        T tmp; // è¿™é‡Œå°±æ˜¯è¿­ä»£å™¨æ‰€æŒ‡ç‰©çš„ç±»å‹æ–°å»ºçš„å¯¹è±¡
        // â€¦ åŠŸèƒ½å®ç°
}</p>

<p>template <class I="">
inline
void func(I iter) {
        func_impl(iter, *iter); // ä¼ å…¥iterå’Œiteræ‰€æŒ‡çš„å€¼ï¼Œclassè‡ªåŠ¨æ¨å¯¼
}</class></p>

<p>int main() {
    int i;
    func(&amp;i);
}</p>

<p>è¿™é‡Œå·²ç»å¯ä»¥çœ‹å‡ºå°è£…çš„æ„æ€äº†ï¼Œæ²¡æœ‰ä¸€å±‚implçš„å°è£…çš„è¯ï¼Œæ¯æ¬¡ä½ éƒ½è¦æ˜¾å¼åœ°è¯´æ˜è¿­ä»£å™¨æŒ‡å‘å¯¹è±¡å‹åˆ«ï¼Œæ‰èƒ½æ–°å»ºtmpå˜é‡ã€‚åŠ ä¸€å±‚å°è£…æ˜¾å¾—æ¸…çˆ½å¾ˆå¤šã€‚</p>

<p>ã€€ã€€è¿­ä»£å™¨ç›¸åº”å‹åˆ«ä¸åªæ˜¯â€œè¿­ä»£å™¨æ‰€æŒ‡å¯¹è±¡çš„å‹åˆ«â€ä¸€ç§è€Œå·²ã€‚æ ¹æ®ç»éªŒï¼Œæœ€å¸¸ç”¨çš„ç›¸åº”å‹åˆ«æœ‰äº”ç§ï¼Œç„¶è€Œå¹¶éä»»ä½•æƒ…å†µä¸‹ä»»ä½•ä¸€ç§éƒ½å¯ä»¥åˆ©ç”¨ä¸Šè¿°çš„templateå‚æ•°æ¨å¯¼æœºåˆ¶æ¥å–å¾—ã€‚</p>

<p>ã€€ã€€å‡½æ•°çš„â€œtemplateå‚æ•°æ¨å¯¼æœºåˆ¶â€æ¨å¯¼çš„åªæ˜¯å‚æ•°ï¼Œæ— æ³•æ¨å¯¼å‡½æ•°çš„è¿”å›å€¼ç±»å‹ã€‚ä¸‡ä¸€éœ€è¦æ¨å¯¼å‡½æ•°çš„ä¼ å›å€¼ï¼Œå°±æ— èƒ½ä¸ºåŠ›äº†ã€‚</p>

<p>ã€€ã€€2.  å£°æ˜å†…åµŒå‹åˆ«ä¼¼ä¹æ˜¯ä¸ªå¥½ä¸»æ„ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç›´æ¥è·å–ã€‚</p>

<p>template <class T="">
struct MyIter {
    typedef T value_type; // å†…åµŒå‹åˆ«å£°æ˜
    // ...
};</class></p>

<p>template <class I="">
typename I::value_type
func(I ite) {
    return *ite;
}</class></p>

<p>// â€¦
MyIter<int> ite(new int(8));
cout &lt;&lt; func(ite);</int></p>

<p>çœ‹èµ·æ¥ä¸é”™ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯æ‰€æœ‰è¿­ä»£å™¨éƒ½æ˜¯class typeï¼ŒåŸç”ŸæŒ‡é’ˆå°±ä¸è¡Œï¼å¦‚æœä¸æ˜¯class typeï¼Œå°±æ— æ³•ä¸ºå®ƒå®šä¹‰å†…åµŒå‹åˆ«ã€‚</p>

<p>ã€€ã€€è¿™æ—¶å€™å°±éœ€è¦ åç‰¹åŒ– å‡ºç°ã€‚</p>

<p>ã€€ã€€3. åç‰¹åŒ–å°±æ˜¯åœ¨ç‰¹åŒ–çš„åŸºç¡€ä¸Šå†åŠ ä¸€ç‚¹é™åˆ¶ï¼Œä½†å®ƒè¿˜æ˜¯ç‰¹åŒ–çš„templateã€‚
ã€€ã€€template <class I="">
struct iterator_traits {
    typedef typename I::value_type value_type;
};</class></p>

<p>template <class I="">
struct iterator_traits&lt;T*&gt; {
    typedef T value_type;
};</class></p>

<p>template <class I="">12 typename iterator_traits<i>::value_type
func(I ite) {
    return *ite;
}</i></class></p>

<p>funcåœ¨è°ƒç”¨ I çš„æ—¶å€™ï¼Œé¦–å…ˆæŠŠ I ä¼ åˆ°èƒå–å™¨ä¸­ï¼Œç„¶åèƒå–å™¨å°±åŒ¹é…æœ€é€‚åˆçš„ value_typeã€‚ï¼ˆèƒå–å™¨ä¼šå…ˆåŒ¹é…æœ€ç‰¹åˆ«çš„ç‰ˆæœ¬ï¼‰è¿™æ ·å½“ä½ ä¼ è¿›ä¸€ä¸ªåŸç”ŸæŒ‡é’ˆçš„æ—¶å€™ï¼Œé¦–å…ˆåŒ¹é…çš„æ˜¯å¸¦&lt;T*&gt;çš„åç‰¹åŒ–ç‰ˆæœ¬ï¼Œè¿™æ · value_type å°±æ˜¯ Tï¼Œè€Œä¸æ˜¯æ²¡æœ‰äº‹å…ˆå£°æ˜çš„ I::value_typeã€‚è¿™æ ·è¿”å›å€¼å°±å¯ä»¥ä½¿ç”¨ typename iterator_traits<i>::value_type æ¥çŸ¥é“è¿”å›ç±»å‹ã€‚</i></p>

<p>https://www.cnblogs.com/mangoyuan/p/6446046.html</p>

<p>æœ¬è´¨å®šä¹‰ï¼šåŠ ä¸Šä¸€å±‚é—´æ¥æ€§ï¼Œæ¢æ¥ä»¥å®šçš„çµæ´»æ€§ã€‚</p>

<p>template <typename T=""> 
struct is_void
{ static const bool value = false; };</typename></p>

<p>template &lt;&gt; 
struct is_void<void>
{ static const bool value = true; };</void></p>

<p>æˆ‘ä»¬å¯ä»¥è¿™æ ·ä½¿ç”¨è¿™ä»½ä»£ç ï¼š</p>

<p>Is_void<false>::value è°ƒç”¨ç¬¬ä¸€ä»½ä»£ç ï¼Œä¹Ÿå°±æ˜¯è¯´åªè¦æˆ‘ä»¬ä¼ å…¥ä¸€ä¸ªå‚æ•°åƒä¸‹é¢è¿™æ ·ï¼š</false></p>

<p>Is_void<T>::valueï¼Œå…¶ä¸­Tå¯ä»¥ä¸ºä»»æ„ç±»å‹ï¼Œæˆ‘ä»¬å°±å¯ä»¥åˆ¤æ–­è¿™ä¸ªç±»å‹æ˜¯ä¸æ˜¯voidåœ¨ç¼–è¯‘æœŸã€‚</T></p>

<p>å®Œæ•´æµ‹è¯•ä»£ç å¦‚ä¸‹ï¼š</p>

<p>template <typename T=""> 
struct is_void
{ 
    static const bool value = false; 
};</typename></p>

<p>template &lt;&gt; 
struct is_void<void>
{ 
    static const bool value = true; 
};</void></p>

<p>int _tmain(int argc, _TCHAR* argv[])
{
    std::coutÂ«is_void<int>::value;</int></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>std::cout&lt;&lt;is_void&lt;void&gt;::value;
return 0; }
</code></pre></div></div>

<p>https://docs.scala-lang.org/tour/traits.html</p>

<p>https://pypi.org/project/traits/4.6.0/</p>

<p>iteratoræ¨¡å¼å®šä¹‰å¦‚ä¸‹ï¼šæä¾›ä¸€ç§æ–¹æ³•ï¼Œä½¿ä¹‹èƒ½å¤Ÿä¾åºå¯»è®¿æŸä¸ªèšåˆç‰©æ‰€å«çš„å„ä¸ªå…ƒç´ ï¼Œè€Œåˆæ— éœ€æš´éœ²è¯¥èšåˆç‰©çš„å†…éƒ¨è¡¨è¾¾å½¢å¼</p>

<p>å…¶ä¸­ï¼Œc++é‡Œé¢å„ä¸ªå®¹å™¨çš„iteratoræ‰®æ¼”ç€å°†æ•°æ®å®¹å™¨ä¸ç®—æ³•ç»“åˆèµ·æ¥çš„é‡è¦è§’è‰²</p>

<p>å°†èŒƒå‹ç®—æ³•(find, count, find_if)ç”¨äºæŸä¸ªå®¹å™¨ä¸­,æœ€é‡è¦çš„æ˜¯è¦ç»™ç®—æ³•æä¾›ä¸€ä¸ªè®¿é—®å®¹å™¨å…ƒç´ çš„å·¥å…·ï¼Œiteratorå°±æ‰®æ¼”ç€è¿™ä¸ªé‡è¦çš„è§’è‰²</p>

<p>æˆ‘ä»¬åœ¨ç®—æ³•ä¸­å¯èƒ½ä¼šå®šä¹‰ç®€å•çš„ä¸­é—´å˜é‡æˆ–è€…è®¾å®šç®—æ³•çš„è¿”å›å˜é‡ç±»å‹ï¼Œè¿™æ—¶å€™éœ€è¦çŸ¥é“è¿­ä»£å™¨æ‰€æŒ‡å…ƒç´ çš„ç±»å‹æ˜¯ä»€ä¹ˆï¼Œä½†æ˜¯ç”±äºæ²¡æœ‰typeofè¿™ç±»åˆ¤æ–­ç±»å‹çš„å‡½æ•°,æˆ‘ä»¬æ— æ³•ç›´æ¥è·å–ï¼Œé‚£è¯¥å¦‚ä½•æ˜¯å¥½ï¼Ÿ</p>

<p>ä¸è¦æ€¥ï¼Œé‚£é¦–å…ˆå…ˆä»‹ç»ä¸€ä¸‹iterator_tarit</p>

<p>iterator_trait
template<class _Tp="">
struct iterator_traits&lt;_Tp*&gt;
{
    typedef ptrdiff_t difference_type;
    typedef typename _Tp::value_type value_type;
    typedef typename _Tp::pointer pointer;
    typedef typename _Tp::reference reference;
    typedef typename _Tp::iterator_category iterator_category;
};
çœ‹åˆ°è¿™ä¸ªå¥‡å¥‡æ€ªæ€ªçš„ä¸œè¥¿ï¼Œæ˜¯ä¸æ˜¯æ„Ÿè§‰æ²¡ä»€ä¹ˆç”¨ï¼Œå—¯ï¼Œæ²¡å…³ç³»ï¼Œå…ˆè®°ç€</class></p>

<p>ä¸‹é¢ï¼Œå°†æ¥ç€ä¹‹å‰çš„è¯é¢˜ï¼Œæ¥çœ‹çœ‹å¦‚ä½•æå–å‡ºiteratoræ‰€æŒ‡å‘çš„å…ƒç´ ç±»å‹</p>

<p>value_type
ä¾‹å¦‚</p>

<p>ä½¿ç”¨typedef
æˆ‘ä»¬å¯ä»¥åœ¨è¿­ä»£å™¨ä¸­æ·»åŠ å…ƒç´ çš„ç±»å‹</p>

<p>template <class T="">
struct MyIter {
    typedef T value_type;
    T * ptr;
    MyIter(T * p = 0) : ptr (p) {};
    T&amp; operator* () const { return *ptr;}
};</class></p>

<p>template <class I="">
typename I::value_type //å–å‡ºè¿­ä»£å™¨ç±»ä¸­çš„ç±»å‹
//ç”¨ä»¥è®¾å®šè¿”å›å˜é‡ç±»å‹ï¼Œä½†æ˜¯å¦‚æœIæ˜¯æŒ‡é’ˆå°±ä¼šé”™è¯¯
get (I ite) {
    return *ite;
}
ä½†æ˜¯ï¼Œè¿™ä¸ªç‰ˆæœ¬å¹¶ä¸æ”¯æŒåŸç”ŸæŒ‡é’ˆï¼Œç„¶è€Œå°±è¿­ä»£å™¨çš„è¡Œä¸ºè€Œè¨€ï¼Œå°±æ˜¯é¢å‘å®¹å™¨çš„æŒ‡é’ˆï¼Œè€Œæ­£å¸¸çš„STLç®—æ³•ä¹Ÿæ˜¯æ”¯æŒåŸç”ŸæŒ‡é’ˆçš„ï¼Œå°±å¦‚åŒä¸‹é¢çš„findä¸€æ ·</class></p>

<p>æŒ‡é’ˆå’Œè¿­ä»£å™¨çš„ä½œç”¨æ— éå°±æ˜¯ä¸ºstlç®—æ³•æä¾›äº†ä¸€ä¸ªè¿ç®—èŒƒå›´ä»¥åŠå¯¹å®¹å™¨ï¼ˆæ— è®ºæ˜¯vectorï¼Œlistï¼Œäº¦æˆ–æ˜¯arrayï¼‰çš„è®¿é—®</p>

<p>int main() {
    int a[5] = {1,2,2,2,2};
    int *begin = a;
    int *end = a+5;
    int count = std::count(begin, end, 2); //ok!
    return 0;
}
æ‰€ä»¥å¯¹äºç¬¬ä¸€ä¸ªç‰ˆæœ¬ï¼Œæˆ‘ä»¬è¿˜è¦å¯¹æŒ‡é’ˆç±»å‹è¿›è¡Œæ¨¡ç‰ˆåç‰¹åŒ–</p>

<p>æå–ä»¥åŠåç‰¹åŒ–
å‰é¢ä¹Ÿæåˆ°äº†ï¼Œå¦‚æœç›´æ¥ä½¿ç”¨typename I::value_typeï¼Œç®—æ³•å°±æ— æ³•æ¥æ”¶åŸç”ŸæŒ‡é’ˆï¼Œå› ä¸ºåŸç”ŸæŒ‡é’ˆæ ¹æœ¬å°±æ²¡æœ‰value_typeè¿™ä¸ªå†…åµŒç±»å‹</p>

<p>å› æ­¤ï¼Œæˆ‘ä»¬è¿˜éœ€è¦åŠ å…¥ä¸€ä¸ªä¸­é—´å±‚å¯¹å…¶è¿›è¡Œåˆ¤æ–­ï¼Œçœ‹å®ƒæ˜¯ä¸æ˜¯åŸç”ŸæŒ‡é’ˆï¼Œæ³¨æ„ï¼Œè¿™å°±æ˜¯traitsæŠ€æ³•çš„å¦™å¤„æ‰€åœ¨</p>

<p>å¦‚æœæˆ‘ä»¬åªä½¿ç”¨ä¸Šé¢çš„åšæ³•ï¼Œä¹Ÿå°±æ˜¯å†…åµŒvalue_typeï¼Œé‚£ä¹ˆå¯¹äºæ²¡æœ‰value_typeçš„æŒ‡é’ˆï¼Œæˆ‘ä»¬åªèƒ½å¯¹å…¶è¿›è¡Œåç‰¹åŒ–ï¼Œè¿™ç§åç‰¹åŒ–æ˜¯é’ˆå¯¹å¯è°ƒç”¨å‡½æ•°getçš„åç‰¹åŒ–ï¼Œå‡å¦‚getæœ‰100è¡Œä»£ç ï¼Œé‚£ä¹ˆå°±ä¼šé€ æˆæå¤§çš„è§†è§‰æ±¡æŸ“</p>

<p>#include <iostream>
template <class T="">
struct MyIter {
    typedef T value_type;
    T * ptr;
    MyIter(T * p = 0) : ptr (p) {};
    T&amp; operator* () const { return *ptr;}
};</class></iostream></p>

<p>template <class I="">
typename I::value_type //å–å‡ºè¿­ä»£å™¨ç±»ä¸­çš„ç±»å‹
get (I ite) {
    std::cout &lt;&lt; "class version" &lt;&lt; std::endl;
    return *ite;
}</class></p>

<p>template <class I="">
I get(I* ite) {
    std::cout &lt;&lt; "pointer version" &lt;&lt; std::endl;
    return *ite;
}</class></p>

<p>template <class I="">
I get(const I* ite) {
    std::cout &lt;&lt; "const pointer version" &lt;&lt; std::endl;
    return *ite;
}</class></p>

<p>int main() {
    int i = 3;
    const int k = 3;
    MyIter<int> v(&amp;i);
    std::cout &lt;&lt; get(v) &lt;&lt; std::endl;
    std::cout &lt;&lt; get(&amp;i) &lt;&lt; std::endl;
    std::cout &lt;&lt; get(&amp;k) &lt;&lt; std::endl;
    return 0;
}
å°±å¦‚åŒä¸Šé¢è¿™ä¸ªå½¢å¼ï¼Œè®¾æƒ³å¾€getä¸­å¡«å……100è¡Œä»£ç ï¼Œç®€ç›´ä¸å¿ç›´è§†ï¼Œä½ å†çœ‹çœ‹ä¸‹é¢è¿™ä¸ªï¼Œç®€ç›´ä¼˜é›…ï¼</int></p>

<p>åˆ©ç”¨ä¸€ä¸ªä¸­é—´å±‚iterator_traitså›ºå®šäº†getçš„å½¢å¼ï¼Œä½¿å¾—é‡å¤çš„ä»£ç å¤§é‡å‡å°‘ï¼Œå”¯ä¸€è¦åšçš„å°±æ˜¯ç¨ç¨ç‰¹åŒ–ä¸€ä¸‹iterator_tartisä½¿å…¶æ”¯æŒpointerå’Œconst pointer:)</p>

<p>#include <iostream></iostream></p>

<p>template <class T="">
struct iterator_traits {
    typedef typename T::value_type value_type;
};</class></p>

<p>template <class T="">
struct iterator_traits&lt;T*&gt; {
    typedef T value_type;
};</class></p>

<p>template <class T="">
struct iterator_traits&lt;const T*&gt; {
    typedef T value_type;
};</class></p>

<p>template <class T="">
struct MyIter {
    typedef T value_type;
    T * ptr;
    MyIter(T * p = 0) : ptr (p) {};
    T&amp; operator* () const { return *ptr;}
};</class></p>

<p>template <class I="">
typename iterator_traits<i>::value_type
get (I ite) {
    std::cout &lt;&lt; "normal version" &lt;&lt; std::endl;
    return *ite;
}</i></class></p>

<p>int main() {
    int i = 3;
    const int k = 3;
    MyIter<int> v(&amp;i);
    std::cout &lt;&lt; get(v) &lt;&lt; std::endl;
    std::cout &lt;&lt; get(&amp;i) &lt;&lt; std::endl;
    std::cout &lt;&lt; get(&amp;k) &lt;&lt; std::endl;
    return 0;
}
é€šè¿‡å®šä¹‰å†…åµŒç±»å‹ï¼Œæˆ‘ä»¬è·å¾—äº†çŸ¥æ™“iteratoræ‰€æŒ‡å…ƒç´ ç±»å‹çš„æ–¹æ³•ï¼Œé€šè¿‡traitsæŠ€æ³•ï¼Œæˆ‘ä»¬å°†å‡½æ•°æ¨¡æ¿å¯¹äºåŸç”ŸæŒ‡é’ˆå’Œè‡ªå®šä¹‰iteratorçš„å®šä¹‰éƒ½ç»Ÿä¸€èµ·æ¥</int></p>

<p>è¿™å°±æ˜¯traitsæŠ€æ³•çš„å¦™å¤„æ‰€åœ¨</p>

<p>difference type
difference typeç”¨äºè¡¨ç¤ºä¸¤ä¸ªè¿­ä»£å™¨ä¹‹é—´çš„è·ç¦»çš„ä¸€ä¸ªç±»å‹,ä¹Ÿå¯ä»¥ç”¨æ¥è¡¨ç¤ºä¸€ä¸ªå®¹å™¨çš„æœ€å¤§çš„å®¹é‡ï¼Œå› ä¸ºå¯¹äºè¿ç»­ç©ºé—´çš„å®¹å™¨ï¼Œå¤´å°¾ä¹‹é—´çš„è·ç¦»å°±æ˜¯æœ€å¤§å®¹é‡</p>

<p>ä¾‹å¦‚count()å°±å¿…é¡»è¿”å›çš„ç±»å‹å°±æ˜¯è¿­ä»£å™¨çš„difference type</p>

<p>å¯¹äºSTLå®¹å™¨ç±»å‹ï¼Œä»¥åŠåŸç”ŸæŒ‡é’ˆï¼Œtraitsæœ‰å¦‚ä¸‹ä¸¤ä¸ªä¸åŒç‰ˆæœ¬</p>

<p>template<class I="">
struct iterator_traits {
...
    typedef typename I::difference_type difference_type;
}</class></p>

<p>//åŸç”ŸæŒ‡é’ˆ
template<class I="">
struct iterator_traits&lt;T*&gt; {
...
    typedef ptrdiff_t difference_type;
}</class></p>

<p>template<class I="">
struct iterator_traits&lt;const T*&gt; {
...
    typedef ptrdiff_t difference_type;
}
reference type
æ ‡ç¤ºäº†å¼•ç”¨ç±»å‹</class></p>

<p>pointer
æ ‡ç¤ºäº†æŒ‡é’ˆç±»å‹</p>

<p>æµ‹è¯•
ä»¥ä¸Šè¯´æ˜äº†è¿­ä»£å™¨å†…éƒ¨çš„å‡ ç§é‡è¦ç±»å‹</p>

<p>ä¸‹é¢å¯¹å…¶è¿›è¡Œä¸€ä¸ªæµ‹è¯•ï¼Œä»¥æ­¤äº§ç”Ÿä¸€ä¸ªæ›´ç›´è§‚çš„å°è±¡</p>

<p>#include <iostream>
#include <vector></vector></iostream></p>

<p>#define Test(x,z,y) std::coutÂ«std::is_same&lt;std::iterator_traits<x>::z,y&gt;::value&lt;&lt;std::endl</x></p>

<p>int main() {
#define IVec std::vector<int>::iterator
    Test(IVec,value_type,int); //true
    Test(IVec,difference_type,ptrdiff_t); //true
    Test(IVec,reference,int&amp;); //true
    Test(IVec,pointer,int*); //true</int></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return 0; } ä»ä¸Šé¢å¯ä»¥çœ‹å‡ºï¼Œä¸€ä¸ªvector&lt;int&gt;::iterator
</code></pre></div></div>

<p>value_type=int
difference_type=ptrdiff_t
reference=int&amp;
pointer=int*
æ€»ç»“
è¦ç‰¢è®°iteratoræ˜¯ä¸ºäº†è®¿é—®å®¹å™¨å†…çš„å…ƒç´ è€Œå­˜åœ¨çš„ï¼Œè€Œå®ƒå†…ç½®çš„ç±»å‹å°±æ˜¯èŒƒå‹ç®—æ³•ä¸å®¹å™¨è¿›è¡Œæ²Ÿé€šçš„é‡è¦å·¥å…·</p>

<p>è€Œæˆ‘ä»¬ä½¿ç”¨traitsæŠ€æ³•ä¸»è¦æ˜¯ä¸ºäº†è§£å†³åŸç”ŸæŒ‡é’ˆå’Œè‡ªå®šä¹‰iteratorä¹‹é—´çš„ä¸åŒæ‰€é€ æˆçš„ä»£ç å†—ä½™</p>

<p>type traits
type traitsçš„å‡ºç°å’ŒSTLå¯¹äºæ€§èƒ½çš„è¦æ±‚æœ‰ç€åƒä¸ä¸‡ç¼•çš„è”ç³»</p>

<p>è¯•æƒ³ï¼Œå¯¹äºvectorè¿™ç§å¤§å—åˆ†é…å†…å­˜ï¼Œç„¶åå¤§å—ææ„çš„å®¹å™¨ï¼Œå¦‚æœå®¹å™¨é‡Œé¢æ˜¯PODçš„è¯ï¼Œé‚£ä¹ˆåªè¦ç­‰å®ƒçš„ç”Ÿå‘½å‘¨æœŸç»“æŸå°±è¡Œäº†ï¼Œå¦‚æœæ˜¯éPODçš„è¯ï¼Œé‚£ä¹ˆå°±è¦åˆ¤æ–­æ˜¯å¦æ‹¥æœ‰no-traitsçš„ææ„å‡½æ•°</p>

<p>å¦‚æœæ˜¯è¿™æ ·çš„è¯ï¼Œåˆå›åˆ°äº†ä¹‹å‰value_typeçš„çª˜å¢ƒï¼Œå› æ­¤ï¼Œæˆ‘ä»¬åªéœ€è¦ä½¿ç”¨type_traitsï¼Œå¯¹PODè¿›è¡Œåç‰¹åŒ–ï¼Œé€šè¿‡ä¸¤ä¸ªç¥å¥‡çš„ç±»å‹è¿›è¡Œåˆ¤æ–­</p>

<p>struct _true_type{};//æ— æ„ä¹‰çš„ææ„å‡½æ•°<br />
struct _false_type{};//æœ‰æ„ä¹‰çš„ææ„å‡½æ•°<br />
è¿™æ ·å­å°±å¯ä»¥è®©è´Ÿè´£ææ„çš„æ¨¡å—è¿›è¡Œåˆ¤æ–­äº†</p>

<p>å…·ä½“çš„type_traitså¦‚ä¸‹æ‰€ç¤º</p>

<p>template<typename T="">  
struct type_traits  
{</typename></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef _false_type has_trivial_default_constructor;//é»˜è®¤æ„é€ å‡½æ•°æ˜¯å¦æœ‰æ„ä¹‰ï¼Ÿ  
typedef _false_type has_trivial_copy_constructor;//æ‹·è´æ„é€ å‡½æ•°æ˜¯å¦æœ‰æ„ä¹‰?  
typedef _false_type has_trivial_assgignment_constructor;//æ‹·è´èµ‹å€¼æ“ä½œæ˜¯å¦æœ‰æ„ä¹‰?  
typedef _false_type has_trivial_destructor;//ææ„å‡½æ•°æ˜¯å¦æœ‰æ„ä¹‰?  
/*PODæ„æŒ‡Plain Old Data,ä¹Ÿå°±æ˜¯æ ‡é‡å‹åˆ«æˆ–ä¼ ç»Ÿçš„C struct(ä¼ ç»Ÿçš„C structåªèƒ½ 
åŒ…å«æ•°æ®æˆå‘˜ï¼Œä¸èƒ½åŒ…å«å‡½æ•°æˆå‘˜ã€‚ä¹Ÿå°±æ˜¯æ‰€è°“çš„èšåˆç±»ã€‚PODå‹åˆ«å¿…ç„¶åŒ…å«æ— æ„ä¹‰ 
çš„ctor/dtor/copy/assignmentå‡½æ•°ã€‚ 
*/  
typedef _false_type is_POD_type;//æ˜¯å¦ä¸ºPlain Old Data?   };   æ€»ç»“ é€šè¿‡å¯¹type_traitsè¿›è¡Œç‰¹åŒ–ï¼Œæ ‡æ³¨è‡ªå·±ç±»ä¸­çš„æ„é€ ï¼Œæ‹·è´ç­‰è¡Œä¸ºæ˜¯å¦æ˜¯æœ‰æ„ä¹‰çš„ï¼Œå¯ä»¥å¤§å¤§æé«˜é€‚é…ç®—æ³•çš„æ•ˆç‡ï¼Œè¿™ä¹Ÿæ˜¯type traitså­˜åœ¨çš„æ„ä¹‰
</code></pre></div></div>

<p>template<typename T="">ä¸template<class T="">ä¸€èˆ¬æƒ…å†µä¸‹è¿™ä¸¤ä¸ªé€šç”¨ï¼Œä½†æœ‰ä¸€ä¸ªç‰¹ä¾‹ï¼Œå°±æ˜¯å½“ T æ˜¯ä¸€ä¸ªç±»ï¼Œè€Œè¿™ä¸ªç±»åˆæœ‰å­ç±»(å‡è®¾åä¸º innerClass) æ—¶ï¼Œåº”è¯¥ç”¨ template<typename>:
typename T::innerClass   myInnerObject;
è¿™é‡Œçš„ typename å‘Šè¯‰ç¼–è¯‘å™¨ï¼ŒT::innerClass æ˜¯ä¸€ä¸ªç±»ï¼Œç¨‹åºè¦å£°æ˜ä¸€ä¸ª T::innerClass ç±»çš„å¯¹è±¡ï¼Œè€Œä¸æ˜¯å£°æ˜ T çš„é™æ€æˆå‘˜ï¼Œè€Œ typename å¦‚æœæ¢æˆ class åˆ™è¯­æ³•é”™è¯¯ã€‚</typename></class></typename></p>

<p>traits -ã€‹ç‰¹æ€§èƒå–æœº</p>

<p>é€šè¿‡function template å‚æ•°æ¨å¯¼æœºåˆ¶ï¼Œå¯ä»¥æ˜¯å®ç°è¿­ä»£å™¨ç±»å‹çš„æ¨å¯¼ï¼Œç„¶åå¦‚æœéœ€è¦æ¨å¯¼è¿”å›å€¼ç±»å‹ï¼Œé‚£ä¹ˆå‚æ•°æ¨å¯¼æœºåˆ¶å°±ä¸å¯è¡Œäº†ï¼Œè¿™æ—¶å€™é€šè¿‡å†…åµŒç±»å‹å£°æ˜æ¨å¯¼è¿”å›å€¼ç±»å‹ã€‚æ‰€ä»¥å‡ºç°äº†traitsæœºåˆ¶ã€‚</p>

<p>STLå°†å®¹å™¨å’Œç®—æ³•åˆ†ç¦»ï¼Œç®—æ³•å®ç°çš„è¿‡ç¨‹ä¸­å¹¶ä¸çŸ¥é“è¿›æ¥çš„è¿­ä»£å™¨æ˜¯å“ªä¸ªå®¹å™¨çš„ï¼Œæ‰€ä»¥åŠ å…¥ä¸€å±‚traitså°è£…ï¼Œtraitsä¼šæ¦¨å–æ‰€æœ‰è¿›å…¥ç®—æ³•çš„è¿­ä»£å™¨çš„ç±»å‹ã€‚</p>

<p>æ‰€ä»¥è¯´traitså°±æ˜¯åœ¨æ¥å£å’Œå®ç°ä¸­é—´çš„ä¸€å±‚å°è£…ã€‚</p>

<p>æˆ‘ä»¬å¯ä»¥ç»§ç»­ é’ˆå¯¹ template å‚æ•°æ›´è¿›ä¸€æ­¥ï¼Œæ‰€è°“åç‰¹åŒ–ä¾¿æäº†å‡ºæ¥ï¼Œåç‰¹åŒ–å°±æ˜¯é’ˆå¯¹templateå‚æ•°æ›´è¿›ä¸€æ­¥çš„æ¡ä»¶é™åˆ¶æ‰€è®¾è®¡å‡ºæ¥çš„ç‰¹åŒ–ç‰ˆæœ¬ã€‚</p>

<p>template <class T="">
class C {...};            //è¿™ä¸ªæ³›åŒ–ç‰ˆæœ¬æ”¯æŒTä¸ºä»»ä½•ç±»å‹</class></p>

<p>template <class T="">
class C&lt;T*&gt; {...};        //è¿™ä¸ªæ³›åŒ–ç‰ˆæœ¬ä»…é€‚ç”¨äº"Tä¸ºåŸç”ŸæŒ‡é’ˆçš„æƒ…å†µ"
                          //Tä¸ºåŸç”ŸæŒ‡é’ˆä¾¿æ˜¯Tä¸ºä»»ä½•ç±»å‹çš„è¿›ä¸€æ­¥æ¡ä»¶é™åˆ¶
å‚è€ƒ STL æºç å‰–æè¿™æœ¬ä¹¦ï¼Œå®ç°å¦‚ä¸‹ä»£ç ï¼Œå¯¹traits æœºåˆ¶æœ‰äº†æ›´æ·±çš„ç†è§£ã€‚ï¼ˆå…¶å®å°±æ˜¯å¤šäº†ä¸€å±‚å°è£…ï¼Œå¾—åˆ°è¿­ä»£å™¨æ‰€æœ‰ç±»å‹ï¼‰</class></p>

<p>https://blog.csdn.net/weixin_42014622/article/details/81294978</p>

<p>Traitsä¸æ˜¯ä¸€ç§è¯­æ³•ç‰¹æ€§ï¼Œè€Œæ˜¯ä¸€ç§æ¨¡æ¿ç¼–ç¨‹æŠ€å·§ã€‚Traitsåœ¨C++æ ‡å‡†åº“ï¼Œå°¤å…¶æ˜¯STLä¸­ï¼Œæœ‰ç€ä¸å¯æ›¿ä»£çš„ä½œç”¨ã€‚</p>

<p>å¦‚ä½•åœ¨ç¼–è¯‘æœŸé—´åŒºåˆ†ç±»å‹</p>

<p>ä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸ªå®ä¾‹ï¼Œæœ‰å››ä¸ªç±»ï¼ŒFarmã€Workerã€Teacherå’ŒDoctorï¼Œæˆ‘ä»¬éœ€è¦åŒºåˆ†ä»–ä»¬æ˜¯è„‘åŠ›åŠ³åŠ¨è€…è¿˜æ˜¯ä½“åŠ›åŠ³åŠ¨è€…ã€‚ä»¥ä¾¿äºåšå‡ºä¸åŒçš„è¡ŒåŠ¨ã€‚</p>

<p>è¿™é‡Œçš„é—®é¢˜åœ¨äºï¼Œæˆ‘ä»¬éœ€è¦ä¸ºä¸¤ç§ç±»å‹æä¾›ä¸€ä¸ªç»Ÿä¸€çš„æ¥å£ï¼Œä½†æ˜¯å¯¹äºä¸åŒçš„ç±»å‹ï¼Œå¿…é¡»åšå‡ºä¸åŒçš„å®ç°ã€‚</p>

<p>æˆ‘ä»¬ä¸å¸Œæœ›å†™ä¸¤ä¸ªå‡½æ•°ï¼Œç„¶åè®©ç”¨æˆ·å»åŒºåˆ†ã€‚</p>

<p>äºæ˜¯æˆ‘ä»¬å€ŸåŠ©äº†å‡½æ•°é‡è½½ï¼Œåœ¨æ¯ä¸ªç±»çš„å†…éƒ¨å†…ç½®ä¸€ä¸ªwork_typeï¼Œç„¶åæ ¹æ®æ¯ä¸ªç±»çš„word_typeï¼Œå€ŸåŠ©å¼ºå¤§çš„å‡½æ•°é‡è½½æœºåˆ¶ï¼Œå®ç°äº†ç¼–è¯‘æœŸçš„ç±»å‹åŒºåˆ†ï¼Œä¹Ÿå°±æ˜¯ç¼–è¯‘æœŸå¤šæ€ã€‚</p>

<p>ä»£ç å¦‚ä¸‹ï¼š</p>

<p>å¤åˆ¶ä»£ç 
#include <iostream>
using namespace std;</iostream></p>

<p>//ä¸¤ä¸ªæ ‡ç­¾ç±»
struct brain_worker {}; //è„‘åŠ›åŠ³åŠ¨
struct physical_worker {}; //ä½“åŠ›åŠ³åŠ¨</p>

<p>class Worker
{
public:
    typedef physical_worker worker_type;
};</p>

<p>class Farmer
{
public:
    typedef physical_worker worker_type;
};</p>

<p>class Teacher
{
public:
    typedef brain_worker worker_type;
};</p>

<p>class Doctor
{
public:
    typedef brain_worker worker_type;
};</p>

<p>template <typename T="">
void __distinction(const T &amp;t, brain_worker)
{
    cout &lt;&lt; "è„‘åŠ›åŠ³åŠ¨è€…" &lt;&lt; endl;
}</typename></p>

<p>template <typename T="">
void __distinction(const T &amp;t, physical_worker)
{
    cout &lt;&lt; "ä½“åŠ›åŠ³åŠ¨è€…" &lt;&lt; endl;
}</typename></p>

<p>template <typename T="">
void distinction(const T &amp;t)
{
    typename T::worker_type _type; //ä¸ºäº†å®ç°é‡è½½
    __distinction(t, _type);
}</typename></p>

<p>int main(int argc, char const *argv[])
{
    Worker w;
    distinction(w);
    Farmer f;
    distinction(f);
    Teacher t;
    distinction(t);
    Doctor d;
    distinction(d);
    return 0;
}
å¤åˆ¶ä»£ç 
åœ¨distinctionå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬å…ˆä»ç±»å‹ä¸­æå–å‡ºworker_typeï¼Œç„¶åæ ¹æ®å®ƒçš„ç±»å‹ï¼Œé€‰å–ä¸åŒçš„å®ç°ã€‚</p>

<p>é—®é¢˜æ¥äº†ï¼Œå¦‚æœä¸åœ¨ç±»ä¸­å†…ç½®worker_typeï¼Œæˆ–è€…æœ‰çš„ç±»å·²ç»å†™å¥½äº†ï¼Œæ— æ³•æ›´æ”¹äº†ï¼Œé‚£ä¹ˆæ€ä¹ˆåŠï¼Ÿ</p>

<p>ä½¿ç”¨Traits</p>

<p>æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆæ˜¯ï¼Œå€ŸåŠ©ä¸€ç§å«åštraitsçš„æŠ€å·§ã€‚</p>

<p>æˆ‘ä»¬å†™ä¸€ä¸ªæ¨¡æ¿ç±»ï¼Œä½†æ˜¯ä¸æä¾›ä»»ä½•å®ç°ï¼š</p>

<p>//ç±»å‹traits 
template <typename T="">
class TypeTraits;
ç„¶åæˆ‘ä»¬ä¸ºæ¯ä¸ªç±»å‹æä¾›ä¸€ä¸ªæ¨¡æ¿ç‰¹åŒ–ï¼š</typename></p>

<p>å¤åˆ¶ä»£ç 
//ä¸ºæ¯ä¸ªç±»å‹æä¾›ä¸€ä¸ªç‰¹åŒ–ç‰ˆæœ¬
template &lt;&gt;
class TypeTraits<Worker>
{
public:
    typedef physical_worker worker_type;
};</Worker></p>

<p>template &lt;&gt;
class TypeTraits<Farmer>
{
public:
    typedef physical_worker worker_type;
};</Farmer></p>

<p>template &lt;&gt;
class TypeTraits<Teacher>
{
public:
    typedef brain_worker worker_type;
};</Teacher></p>

<p>template &lt;&gt;
class TypeTraits<Doctor>
{
public:
    typedef brain_worker worker_type;
};
å¤åˆ¶ä»£ç 
ç„¶ååœ¨distinctionå‡½æ•°ä¸­ï¼Œä¸å†æ˜¯ç›´æ¥å¯»æ‰¾å†…ç½®ç±»å‹ï¼Œè€Œæ˜¯é€šè¿‡traitsæŠ½å–å‡ºæ¥ã€‚</Doctor></p>

<p>å¤åˆ¶ä»£ç 
template <typename T="">
void distinction(const T &amp;t)
{
    //typename T::worker_type _type;
    typename TypeTraits<T>::worker_type _type;
    __distinction(t, _type);
}
å¤åˆ¶ä»£ç </T></typename></p>

<p>ä¸Šé¢ä¸¤ç§æ–¹å¼çš„æœ¬è´¨åŒºåˆ«åœ¨äºï¼Œç¬¬ä¸€ç§æ˜¯åœ¨classçš„å†…éƒ¨å†…ç½®typeï¼Œç¬¬äºŒç§åˆ™æ˜¯åœ¨ç±»çš„å¤–éƒ¨ï¼Œä½¿ç”¨æ¨¡æ¿ç‰¹åŒ–ï¼Œclassæœ¬èº«å¯¹äºtypeå¹¶ä¸çŸ¥æƒ…ã€‚</p>

<p>ä¸¤ç§æ–¹å¼ç»“åˆ</p>

<p>ä¸Šé¢æˆ‘ä»¬å®ç°äº†ç›®çš„ï¼Œç±»ä¸­æ²¡æœ‰work_typeæ—¶ï¼Œä¹Ÿå¯ä»¥æ­£å¸¸è¿è¡Œï¼Œä½†æ˜¯æ¨¡æ¿ç‰¹åŒ–ç›¸å¯¹äºå†…ç½®ç±»å‹ï¼Œè¿˜æ˜¯éº»çƒ¦äº†ä¸€äº›ã€‚</p>

<p>äºæ˜¯ï¼Œæˆ‘ä»¬ä»ç„¶ä½¿ç”¨å†…ç½®ç±»å‹ï¼Œä¹Ÿä»ç„¶ä½¿ç”¨traitsæŠ½å–work_typeï¼Œæ–¹æ³•å°±æ˜¯ä¸ºTypeTraitsæä¾›ä¸€ä¸ªé»˜è®¤å®ç°ï¼Œé»˜è®¤å»ä½¿ç”¨å†…ç½®ç±»å‹ï¼ŒæŠŠäºŒè€…ç»“åˆèµ·æ¥ã€‚</p>

<p>è¿™æ ·æˆ‘ä»¬å»ä½¿ç”¨TypeTraits<T>::worker_typeæ—¶ï¼Œæœ‰å†…ç½®ç±»å‹çš„å°±ä½¿ç”¨é»˜è®¤å®ç°ï¼Œæ— å†…ç½®ç±»å‹çš„å°±éœ€è¦æä¾›ç‰¹åŒ–ç‰ˆæœ¬ã€‚</T></p>

<p>å¤åˆ¶ä»£ç 
class Worker
{
public:
    typedef physical_worker worker_type;
};</p>

<p>class Farmer
{
public:
    typedef physical_worker worker_type;
};</p>

<p>class Teacher
{
public:
    typedef brain_worker worker_type;
};</p>

<p>class Doctor
{
public:
    typedef brain_worker worker_type;
};</p>

<p>//ç±»å‹traits 
template <typename T="">
class TypeTraits
{
public:
    typedef typename T::worker_type worker_type;
};
å¤åˆ¶ä»£ç 
OKï¼Œæˆ‘ä»¬ç°åœ¨æƒ³æ·»åŠ ä¸€ä¸ªæ–°çš„classï¼Œäºæ˜¯æˆ‘ä»¬æœ‰ä¸¤ç§é€‰æ‹©ï¼Œ</typename></p>

<p>ä¸€æ˜¯åœ¨classçš„å†…éƒ¨å†…ç½®work_typeï¼Œé€šè¿‡traitsçš„é»˜è®¤å®ç°å»æŠ½å–typeã€‚</p>

<p>ä¸€ç§æ˜¯ä¸å†…ç½®work_typeï¼Œè€Œæ˜¯é€šè¿‡æ¨¡æ¿çš„ç‰¹åŒ–ï¼Œæä¾›work_typeã€‚</p>

<p>ä¾‹å¦‚ï¼š</p>

<p>å¤åˆ¶ä»£ç 
class Staff
{
};</p>

<p>template &lt;&gt;
class TypeTraits<Staff>
{
public:
    typedef brain_worker worker_type;
};
å¤åˆ¶ä»£ç 
æµ‹è¯•ä»ç„¶æ­£å¸¸ï¼š</Staff></p>

<p>Staff s;
distinction(s);</p>

<p>è¿›ä¸€æ­¥ç®€åŒ–</p>

<p>è¿™é‡Œæˆ‘ä»¬è€ƒè™‘çš„æ˜¯å†…ç½®çš„æƒ…å½¢ã€‚å¯¹äºé‚£äº›è¦å†…ç½®typeçš„ç±»ï¼Œå¦‚æœtypeä¸ªæ•°è¿‡å¤šï¼Œç¨‹åºç¼–å†™å°±å®¹æ˜“å‡ºç°é—®é¢˜ï¼Œæˆ‘ä»¬è€ƒè™‘ä½¿ç”¨ç»§æ‰¿ï¼Œå…ˆå®šä¹‰ä¸€ä¸ªbaseç±»ï¼š</p>

<p>template <typename T="">
struct type_base
{
    typedef T worker_type;
};
æ‰€æœ‰çš„ç±»å‹ï¼Œé€šè¿‡publicç»§æ‰¿è¿™ä¸ªç±»å³å¯ï¼š</typename></p>

<p>å¤åˆ¶ä»£ç 
class Worker : public type_base<physical_worker>
{
};</physical_worker></p>

<p>class Farmer : public type_base<physical_worker>
{
};</physical_worker></p>

<p>class Teacher : public type_base<brain_worker>
{
};</brain_worker></p>

<p>class Doctor : public type_base<brain_worker>
{
};
å¤åˆ¶ä»£ç </brain_worker></p>

<p>çœ‹åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬åº”è¯¥æ˜ç™½ï¼Œtraitsç›¸å¯¹äºç®€å•å†…ç½®ç±»å‹çš„åšæ³•ï¼Œå¼ºå¤§ä¹‹å¤„åœ¨äºï¼šå¦‚æœä¸€ä¸ªç±»å‹æ— æ³•å†…ç½®typeï¼Œé‚£ä¹ˆå°±å¯ä»¥å€ŸåŠ©å‡½æ•°ç‰¹åŒ–ï¼Œä»è€Œå€ŸåŠ©äºtraitsã€‚è€Œå†…ç½®ç±»å‹ä»…ä»…ä½¿ç”¨äºclassç±»å‹ã€‚</p>

<p>ä»¥STLä¸­çš„è¿­ä»£å™¨ä¸ºä¾‹ï¼Œå¾ˆå¤šæƒ…å†µä¸‹æˆ‘ä»¬éœ€è¦è¾¨åˆ«è¿­ä»£å™¨çš„ç±»å‹ï¼Œ</p>

<p>ä¾‹å¦‚distanceå‡½æ•°è®¡ç®—ä¸¤ä¸ªè¿­ä»£å™¨çš„è·ç¦»ï¼Œæœ‰çš„è¿­ä»£å™¨å…·æœ‰éšæœºè®¿é—®èƒ½åŠ›ï¼Œå¦‚vectorï¼Œæœ‰çš„åˆ™ä¸èƒ½ï¼Œå¦‚listï¼Œæˆ‘ä»¬è®¡ç®—ä¸¤ä¸ªè¿­ä»£å™¨çš„è·ç¦»ï¼Œå°±éœ€è¦å…ˆåˆ¤æ–­è¿­ä»£å™¨èƒ½å¦ç›¸å‡ï¼Œå› ä¸ºåªæœ‰å…·å¤‡éšæœºè®¿é—®èƒ½åŠ›çš„è¿­ä»£å™¨æ‰å…·æœ‰è¿™ä¸ªèƒ½åŠ›ã€‚</p>

<p>æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å†…ç½®ç±»å‹æ¥è§£å†³ã€‚</p>

<p>å¯æ˜¯ï¼Œè®¸å¤šè¿­ä»£å™¨æ˜¯ä½¿ç”¨æŒ‡é’ˆå®ç°çš„ï¼ŒæŒ‡é’ˆä¸æ˜¯classï¼Œæ— æ³•å†…ç½®ç±»å‹ï¼Œäºæ˜¯ï¼ŒSTLé‡‡ç”¨äº†traitsæ¥è¾¨åˆ«è¿­ä»£å™¨çš„ç±»å‹ã€‚</p>

<p>æœ€åï¼Œæˆ‘ä»¬åº”è¯¥è®¤è¯†åˆ°ï¼Œtraitsçš„åŸºçŸ³æ˜¯æ¨¡æ¿ç‰¹åŒ–ã€‚</p>

<p>STLä¸­ï¼Œtraitsç¼–ç¨‹æŠ€æ³•å¾—åˆ°äº†å¾ˆå¤§çš„åº”ç”¨ï¼Œäº†è§£è¿™ä¸ªï¼Œæ‰èƒ½ä¸€çª¥STLå¥¥å¦™æ‰€åœ¨ã€‚</p>

<p>å…ˆå°†è‡ªå·±æ‰€ç†è§£çš„è®°å½•å¦‚ä¸‹ï¼š</p>

<p>TraitsæŠ€æœ¯å¯ä»¥ç”¨æ¥è·å¾—ä¸€ä¸ª ç±»å‹ çš„ç›¸å…³ä¿¡æ¯çš„ã€‚ é¦–å…ˆå‡å¦‚æœ‰ä»¥ä¸‹ä¸€ä¸ªæ³›å‹çš„è¿­ä»£å™¨ç±»ï¼Œå…¶ä¸­ç±»å‹å‚æ•° T ä¸ºè¿­ä»£å™¨æ‰€æŒ‡å‘çš„ç±»å‹ï¼š</p>

<p>template <typename T="">
class myIterator
{
 ...
};</typename></p>

<p>å½“æˆ‘ä»¬ä½¿ç”¨myIteratoræ—¶ï¼Œæ€æ ·æ‰èƒ½è·çŸ¥å®ƒæ‰€æŒ‡å‘çš„å…ƒç´ çš„ç±»å‹å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥ä¸ºè¿™ä¸ªç±»åŠ å…¥ä¸€ä¸ªå†…åµŒç±»å‹ï¼Œåƒè¿™æ ·ï¼š
template <typename T="">
class myIterator
{
      typedef  T value_type; 
...
};
è¿™æ ·å½“æˆ‘ä»¬ä½¿ç”¨myIteratorç±»å‹æ—¶ï¼Œå¯ä»¥é€šè¿‡ myIterator::value_typeæ¥è·å¾—ç›¸åº”çš„myIteratoræ‰€æŒ‡å‘çš„ç±»å‹ã€‚</typename></p>

<p>ç°åœ¨æˆ‘ä»¬æ¥è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œä½¿ç”¨è¿™ä¸ªä¿¡æ¯ã€‚
template <typename T="">
typename myIterator<T>::value_type Foo(myIterator<T> i)
{
 ...
}
è¿™é‡Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªå‡½æ•°Fooï¼Œå®ƒçš„è¿”å›ä¸ºä¸º  å‚æ•°i æ‰€æŒ‡å‘çš„ç±»å‹ï¼Œä¹Ÿå°±æ˜¯Tï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸ºä»€ä¹ˆè¿˜è¦å…´å¸ˆåŠ¨ä¼—çš„ä½¿ç”¨é‚£ä¸ªvalue_typeå‘¢ï¼Ÿ é‚£æ˜¯å› ä¸ºï¼Œå½“æˆ‘ä»¬å¸Œæœ›ä¿®æ”¹Fooå‡½æ•°ï¼Œä½¿å®ƒèƒ½å¤Ÿé€‚åº”æ‰€æœ‰ç±»å‹çš„è¿­ä»£å™¨æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼š
template <typename I=""> //è¿™é‡Œçš„Iå¯ä»¥æ˜¯ä»»æ„ç±»å‹çš„è¿­ä»£å™¨
typename I::value_type Foo(I i)
{
 ...
}
ç°åœ¨ï¼Œä»»æ„å®šä¹‰äº† value_typeå†…åµŒç±»å‹çš„è¿­ä»£å™¨éƒ½å¯ä»¥åšä¸ºFooçš„å‚æ•°äº†ï¼Œå¹¶ä¸”Fooçš„è¿”å›å€¼çš„ç±»å‹å°†ä¸ç›¸åº”è¿­ä»£å™¨æ‰€æŒ‡çš„å…ƒç´ çš„ç±»å‹ä¸€è‡´ã€‚è‡³æ­¤ä¸€åˆ‡é—®é¢˜ä¼¼ä¹éƒ½å·²è§£å†³ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰ä½¿ç”¨ä»»ä½•ç‰¹æ®Šçš„æŠ€æœ¯ã€‚ç„¶è€Œå½“è€ƒè™‘åˆ°ä»¥ä¸‹æƒ…å†µæ—¶ï¼Œæ–°çš„é—®é¢˜ä¾¿æ˜¾ç°å‡ºæ¥äº†ï¼š</typename></T></T></typename></p>

<p>åŸ ç”ŸæŒ‡é’ˆä¹Ÿå®Œå…¨å¯ä»¥åšä¸ºè¿­ä»£å™¨æ¥ä½¿ç”¨ï¼Œç„¶è€Œæˆ‘ä»¬æ˜¾ç„¶æ²¡æœ‰åŠæ³•ä¸ºåŸç”ŸæŒ‡é’ˆæ·»åŠ ä¸€ä¸ªvalue_typeçš„å†…åµŒç±»å‹ï¼Œå¦‚æ­¤ä¸€æ¥æˆ‘ä»¬çš„Foo()å‡½æ•°å°±ä¸èƒ½é€‚ç”¨åŸ ç”ŸæŒ‡é’ˆäº†ï¼Œè¿™ä¸èƒ½ä¸è¯´æ˜¯ä¸€å¤§ç¼ºæ†¾ã€‚é‚£ä¹ˆæœ‰ä»€ä¹ˆåŠæ³•å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜å‘¢ï¼Ÿ æ­¤æ—¶ä¾¿æ˜¯æˆ‘ä»¬çš„ä¸»è§’ï¼šç±»å‹ä¿¡æ¯æ¦¨å–æœº Traits ç™»åœºçš„æ—¶å€™äº†</p>

<p>â€¦.drum rollâ€¦â€¦</p>

<p>æˆ‘ä»¬å¯ä»¥ä¸ç›´æ¥ä½¿ç”¨myIteratorçš„value_typeï¼Œè€Œæ˜¯é€šè¿‡å¦ä¸€ä¸ªç±»æ¥æŠŠè¿™ä¸ªä¿¡æ¯æå–å‡ºæ¥ï¼š
template <typename T="">
class Traits
{
      typedef typename T::value_type value_type;
};
è¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ Traits<myIterator>::value_type æ¥è·å¾—myIteratorçš„value_typeï¼Œäºæ˜¯æˆ‘ä»¬æŠŠFooå‡½æ•°æ”¹å†™æˆï¼š
template <typename I=""> //è¿™é‡Œçš„Iå¯ä»¥æ˜¯ä»»æ„ç±»å‹çš„è¿­ä»£å™¨
typename Traits<i>::value_type Foo(I i)
{
 ...
}
ç„¶è€Œï¼Œå³ä½¿è¿™æ ·ï¼Œé‚£ä¸ªåŸç”ŸæŒ‡é’ˆçš„é—®é¢˜ä»ç„¶æ²¡æœ‰è§£å†³ï¼Œå› ä¸ºTraitç±»ä¸€æ ·æ²¡åŠæ³•è·å¾—åŸç”ŸæŒ‡é’ˆçš„ç›¸å…³ä¿¡æ¯ã€‚äºæ˜¯æˆ‘ä»¬ç¥­å‡ºC++çš„åˆä¸€ä»¶åˆ©å™¨--åç‰¹åŒ–(partial specialization)ï¼š
template <typename T="">
class Traits&lt;T*&gt; //æ³¨æ„ è¿™é‡Œé’ˆå¯¹åŸç”ŸæŒ‡é’ˆè¿›è¡Œäº†åç‰¹åŒ–
{
      typedef typename T value_type;
};
é€šè¿‡ä¸Šé¢è¿™ä¸ª Traitsçš„åç‰¹åŒ–ç‰ˆæœ¬ï¼Œæˆ‘ä»¬é™ˆè¿°äº†è¿™æ ·ä¸€ä¸ªäº‹å®ï¼šä¸€ä¸ª T* ç±»å‹çš„æŒ‡é’ˆæ‰€æŒ‡å‘çš„å…ƒç´ çš„ç±»å‹ä¸º Tã€‚</typename></i></typename></myIterator></typename></p>

<p>å¦‚æ­¤ä¸€æ¥ï¼Œæˆ‘ä»¬çš„ Fooå‡½æ•°å°±å®Œå…¨å¯ä»¥é€‚ç”¨äºåŸç”ŸæŒ‡é’ˆäº†ã€‚æ¯”å¦‚ï¼š
int * p;
â€¦.
int i = Foo(p);
Traitsä¼šè‡ªåŠ¨æ¨å¯¼å‡º p æ‰€æŒ‡å…ƒç´ çš„ç±»å‹ä¸º intï¼Œä»è€ŒFooæ­£ç¡®è¿”å›ã€‚</p>

<p>è¿‡ç¨‹ï¼šå†…åµŒå‹åˆ«-&gt;traiteç±»-&gt;æ¨¡æ¿åç‰¹åŒ–=&gt;å¯èƒå–åŸç”ŸæŒ‡é’ˆçš„value typeã€‚</p>

<p>traitsï¼Œåˆè¢«å«åšç‰¹æ€§èƒå–æŠ€æœ¯ï¼Œè¯´å¾—ç®€å•ç‚¹å°±æ˜¯æå–â€œè¢«ä¼ è¿›çš„å¯¹è±¡â€å¯¹åº”çš„è¿”å›ç±»å‹ï¼Œè®©åŒä¸€ä¸ªæ¥å£å®ç°å¯¹åº”çš„åŠŸèƒ½ã€‚å› ä¸ºSTLçš„ç®—æ³•å’Œå®¹å™¨æ˜¯åˆ†ç¦»çš„ï¼Œä¸¤è€…é€šè¿‡è¿­ä»£å™¨é“¾æ¥ã€‚ç®—æ³•çš„å®ç°å¹¶ä¸çŸ¥é“è‡ªå·±è¢«ä¼ è¿›æ¥ä»€ä¹ˆã€‚èƒå–å™¨ç›¸å½“äºåœ¨æ¥å£å’Œå®ç°ä¹‹é—´åŠ ä¸€å±‚å°è£…ï¼Œæ¥éšè—ä¸€äº›ç»†èŠ‚å¹¶ååŠ©è°ƒç”¨åˆé€‚çš„æ–¹æ³•ï¼Œè¿™éœ€è¦ä¸€äº›æŠ€å·§ï¼ˆä¾‹å¦‚ï¼Œåç‰¹åŒ–ï¼‰ã€‚æœ€åé™„å¸¦ä¸€ä¸ªå°å°çš„ä¾‹å­ï¼Œåº”è¯¥èƒ½æ›´å¥½åœ°ç†è§£ ç‰¹æ€§èƒå–ã€‚</p>

<p>ã€€ã€€ä¸‹é¢å¤§éƒ¨åˆ†æ¥æºäºã€ŠSTLæºç å‰–æã€‹ï¼Œçœ‹åŸä¹¦èƒ½äº†è§£æ›´å¤šç»†èŠ‚ã€‚</p>

<p>Traitsç¼–ç¨‹æŠ€æ³•
ã€€ã€€è®©æˆ‘ä»¬ä¸€ç‚¹ç‚¹æŠ›å‡ºé—®é¢˜ï¼Œç„¶åä¸€ç‚¹ç‚¹æ·±å…¥ã€‚</p>

<p>ã€€ã€€1. é¦–å…ˆï¼Œåœ¨ç®—æ³•ä¸­è¿ç”¨è¿­ä»£å™¨æ—¶ï¼Œå¾ˆå¯èƒ½ä¼šç”¨åˆ°å…¶ç›¸åº”å‹åˆ«ï¼ˆè¿­ä»£å™¨æ‰€æŒ‡ä¹‹ç‰©çš„å‹åˆ«ï¼‰ã€‚å‡è®¾ç®—æ³•ä¸­æœ‰å¿…è¦å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œä»¥â€œè¿­ä»£å™¨æ‰€æŒ‡å¯¹è±¡çš„å‹åˆ«â€ä¸ºå‹åˆ«ï¼Œè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ</p>

<p>ã€€ã€€è§£å†³æ–¹æ³•æ˜¯ï¼šåˆ©ç”¨function templateçš„å‚æ•°æ¨å¯¼æœºåˆ¶ã€‚</p>

<p>å¤åˆ¶ä»£ç 
 1 template &lt;class I, class T&gt;
 2 void func_impl(I iter, T t) {
 3         T tmp; // è¿™é‡Œå°±æ˜¯è¿­ä»£å™¨æ‰€æŒ‡ç‰©çš„ç±»å‹æ–°å»ºçš„å¯¹è±¡
 4         // â€¦ åŠŸèƒ½å®ç°
 5 }
 6 
 7 template <class I="">
 8 inline
 9 void func(I iter) {
10         func_impl(iter, *iter); // ä¼ å…¥iterå’Œiteræ‰€æŒ‡çš„å€¼ï¼Œclassè‡ªåŠ¨æ¨å¯¼
11 }
12 
13 int main() {
14     int i;
15     func(&amp;i);
16 }
å¤åˆ¶ä»£ç 
ã€€ã€€è¿™é‡Œå·²ç»å¯ä»¥çœ‹å‡ºå°è£…çš„æ„æ€äº†ï¼Œæ²¡æœ‰ä¸€å±‚implçš„å°è£…çš„è¯ï¼Œæ¯æ¬¡ä½ éƒ½è¦æ˜¾å¼åœ°è¯´æ˜è¿­ä»£å™¨æŒ‡å‘å¯¹è±¡å‹åˆ«ï¼Œæ‰èƒ½æ–°å»ºtmpå˜é‡ã€‚åŠ ä¸€å±‚å°è£…æ˜¾å¾—æ¸…çˆ½å¾ˆå¤šã€‚</class></p>

<p>ã€€ã€€è¿­ä»£å™¨ç›¸åº”å‹åˆ«ä¸åªæ˜¯â€œè¿­ä»£å™¨æ‰€æŒ‡å¯¹è±¡çš„å‹åˆ«â€ä¸€ç§è€Œå·²ã€‚æ ¹æ®ç»éªŒï¼Œæœ€å¸¸ç”¨çš„ç›¸åº”å‹åˆ«æœ‰äº”ç§ï¼Œç„¶è€Œå¹¶éä»»ä½•æƒ…å†µä¸‹ä»»ä½•ä¸€ç§éƒ½å¯ä»¥åˆ©ç”¨ä¸Šè¿°çš„templateå‚æ•°æ¨å¯¼æœºåˆ¶æ¥å–å¾—ã€‚</p>

<p>ã€€ã€€å‡½æ•°çš„â€œtemplateå‚æ•°æ¨å¯¼æœºåˆ¶â€æ¨å¯¼çš„åªæ˜¯å‚æ•°ï¼Œæ— æ³•æ¨å¯¼å‡½æ•°çš„è¿”å›å€¼ç±»å‹ã€‚ä¸‡ä¸€éœ€è¦æ¨å¯¼å‡½æ•°çš„ä¼ å›å€¼ï¼Œå°±æ— èƒ½ä¸ºåŠ›äº†ã€‚</p>

<p>ã€€ã€€2.  å£°æ˜å†…åµŒå‹åˆ«ä¼¼ä¹æ˜¯ä¸ªå¥½ä¸»æ„ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç›´æ¥è·å–ã€‚</p>

<p>å¤åˆ¶ä»£ç 
 1 template <class T="">
 2 struct MyIter {
 3     typedef T value_type; // å†…åµŒå‹åˆ«å£°æ˜
 4     // ...
 5 };
 6 
 7 template <class I="">
 8 typename I::value_type
 9 func(I ite) {
10     return *ite;
11 }
12 
13 // ...
14 MyIter<int> ite(new int(8));
15 cout &lt;&lt; func(ite);
å¤åˆ¶ä»£ç 
ã€€ã€€çœ‹èµ·æ¥ä¸é”™ï¼Œä½†æ˜¯å¹¶ä¸æ˜¯æ‰€æœ‰è¿­ä»£å™¨éƒ½æ˜¯class typeï¼ŒåŸç”ŸæŒ‡é’ˆå°±ä¸è¡Œï¼å¦‚æœä¸æ˜¯class typeï¼Œå°±æ— æ³•ä¸ºå®ƒå®šä¹‰å†…åµŒå‹åˆ«ã€‚</int></class></class></p>

<p>ã€€ã€€è¿™æ—¶å€™å°±éœ€è¦ åç‰¹åŒ– å‡ºç°ã€‚</p>

<p>ã€€ã€€3. åç‰¹åŒ–å°±æ˜¯åœ¨ç‰¹åŒ–çš„åŸºç¡€ä¸Šå†åŠ ä¸€ç‚¹é™åˆ¶ï¼Œä½†å®ƒè¿˜æ˜¯ç‰¹åŒ–çš„templateã€‚</p>

<p>å¤åˆ¶ä»£ç 
 1 template <class I="">
 2 struct iterator_traits {
 3     typedef typename I::value_type value_type;
 4 };
 5 
 6 template <class I="">
 7 struct iterator_traits&lt;T*&gt; {
 8     typedef T value_type;
 9 };
10 
11 template <class I="">12 typename iterator_traits<i>::value_type
13 func(I ite) {
14     return *ite;
15 }
å¤åˆ¶ä»£ç 
ã€€ã€€funcåœ¨è°ƒç”¨ I çš„æ—¶å€™ï¼Œé¦–å…ˆæŠŠ I ä¼ åˆ°èƒå–å™¨ä¸­ï¼Œç„¶åèƒå–å™¨å°±åŒ¹é…æœ€é€‚åˆçš„ value_typeã€‚ï¼ˆèƒå–å™¨ä¼šå…ˆåŒ¹é…æœ€ç‰¹åˆ«çš„ç‰ˆæœ¬ï¼‰è¿™æ ·å½“ä½ ä¼ è¿›ä¸€ä¸ªåŸç”ŸæŒ‡é’ˆçš„æ—¶å€™ï¼Œé¦–å…ˆåŒ¹é…çš„æ˜¯å¸¦&lt;T*&gt;çš„åç‰¹åŒ–ç‰ˆæœ¬ï¼Œè¿™æ · value_type å°±æ˜¯ Tï¼Œè€Œä¸æ˜¯æ²¡æœ‰äº‹å…ˆå£°æ˜çš„ I::value_typeã€‚è¿™æ ·è¿”å›å€¼å°±å¯ä»¥ä½¿ç”¨ typename iterator_traits<i>::value_type æ¥çŸ¥é“è¿”å›ç±»å‹ã€‚
ã€€ã€€https://www.cnblogs.com/mangoyuan/p/6446046.html
ã€€ã€€
ã€€ã€€
ã€€ã€€ä»‹ç»traitsçš„æ–‡ç« å¾ˆå¤šï¼Œä½†æ„Ÿè§‰å¤§éƒ¨åˆ†æ–‡ç« çš„è¯´æ˜éƒ½å¾ˆæ™¦æ¶©éš¾æ‡‚ï¼ŒæŠŠä¸€ä¸ªå¹¶ä¸å¾ˆå¤æ‚çš„C++æ¨¡æ¿çš„åº”ç”¨æè¿°çš„è¿‡äºå¤æ‚ã€‚å¿ä¸ä½æƒ³æŠŠè‡ªå·±çš„ç†è§£è·Ÿå¤§å®¶åˆ†äº«ä¸€ä¸‹ï¼Œæˆ–è®¸æˆ‘ä¹Ÿåªæ˜¯æŒæ¡äº†ä¸€ç‚¹traitsçš„çš®æ¯›è€Œå·²ï¼Œä½†ä¹Ÿå¸Œæœ›è¿™äº›çš®æ¯›èƒ½ç•¥å¾®æŠ“ä½ä½ çš„çœ¼çƒï¼Œå¸¦ç»™ä½ ä¸€äº›å¯å‘ã€‚</i></i></class></class></class></p>

<p>é¦–å…ˆï¼Œä»‹ç»traitså‰ï¼Œå›å‘³ä¸€ä¸‹C++çš„æ¨¡æ¿åŠåº”ç”¨ï¼Œå¦‚æœä½ è„‘æµ·é‡Œæµ®ç°å‡ºçš„åªæ˜¯ä¸ºå®ç°ä¸€äº›å‡½æ•°æˆ–ç±»çš„é‡ç”¨çš„ç®€å•æ¨¡æ¿åº”ç”¨ï¼Œé‚£æˆ‘è¦å‘Šè¯‰ä½ ï¼Œä½ outäº†ã€‚æœ€è¿‘åœ¨æ•´ç†ä¸€äº›æ¨¡æ¿çš„åº”ç”¨æ–¹å¼ï¼Œæœ‰æ—¶é—´çš„è¯ä¼šå†™å‡ºæ¥åˆ†äº«ç»™å¤§å®¶ï¼Œæœ¬æ–‡ä¸ä¼šå»è¯¦ç»†è®¨è®ºtraitsä»¥å¤–çš„æ¨¡æ¿çš„å„ç§é«˜çº§åº”ç”¨ã€‚
é‚£ä¹ˆï¼Œè¨€å½’æ­£ä¼ ï¼Œä»€ä¹ˆæ˜¯traitsï¼Ÿå…¶å®å®ƒå¹¶ä¸æ˜¯ä¸€ä¸ªæ–°çš„æ¦‚å¿µï¼Œä¸Šä¸ªä¸–çºª90å¹´ä»£ä¸­æœŸå°±å·²ç»è¢«æå‡ºï¼Œåªæ˜¯åˆ°äº†è¿™ä¸ªä¸–çºªæ‰åœ¨å„ä¸ªC++åº“ä¸­è¢«å¹¿æ³›ä½¿ç”¨ï¼Œè€Œæˆ‘ä¹Ÿæ˜¯åœ¨è¿™ä¸ªæ¦‚å¿µè¯ç”Ÿåå¤šå¹´åæ‰æ¥è§¦åˆ°å®ƒã€‚</p>

<p>C++ä¹‹çˆ¶Bjarne Stroustrupå¯¹traitsæœ‰å¦‚ä¸‹çš„æè¿°ï¼š
Think of a trait as a small object whose main purpose is to carry information used by another object or algorithm to determine â€œpolicyâ€ or â€œimplementation detailsâ€.</p>

<p>æˆ‘ä¸çŸ¥é“å®˜æ–¹æˆ–ä¸€äº›ä¹¦ä¸Šæ˜¯å¦‚ä½•å»è§£é‡Štraitsçš„ï¼Œæˆ‘çš„ç†è§£æ˜¯ï¼š
å½“å‡½æ•°ï¼Œç±»æˆ–è€…ä¸€äº›å°è£…çš„é€šç”¨ç®—æ³•ä¸­çš„æŸäº›éƒ¨åˆ†ä¼šå› ä¸ºæ•°æ®ç±»å‹ä¸åŒè€Œå¯¼è‡´å¤„ç†æˆ–é€»è¾‘ä¸åŒï¼ˆè€Œæˆ‘ä»¬åˆä¸å¸Œæœ›å› ä¸ºæ•°æ®ç±»å‹çš„å·®å¼‚è€Œä¿®æ”¹ç®—æ³•æœ¬èº«çš„å°è£…æ—¶ï¼‰ï¼Œtraitsä¼šæ˜¯ä¸€ç§å¾ˆå¥½çš„è§£å†³æ–¹æ¡ˆã€‚</p>

<p>æœ¬ä»¥ä¸ºèƒ½å¾ˆç®€å•çš„æè¿°å®ƒï¼Œè°çŸ¥é“è¿˜æ˜¯ç”¨äº†å¦‚æ­¤é•¿çš„å¥å­æ‰è¯´æ˜æ¸…æ¥šï¼Œç›¸å½“çš„æƒ­æ„§ã€‚å¤§å®¶åªè¦æœ‰ä¸ªå¤§æ¦‚çš„æ¦‚å¿µå°±okäº†ï¼Œç”šè‡³å³ä½¿å®Œå…¨æ²¡æ¦‚å¿µä¹Ÿæ²¡å…³ç³»ï¼Œä¸‹é¢ä¼šé€šè¿‡å®é™…ä»£ç æ¥è¯´æ˜ã€‚</p>

<p>å…ˆçœ‹è¿™æ ·ä¸€ä¸ªä¾‹å­ã€‚å¦‚æœæœ‰ä¸€ä¸ªæ¨¡æ¿ç±»Testï¼š</p>

<p>template <typename T="">
class Test {
     ......
};
å‡è®¾æœ‰è¿™æ ·çš„éœ€æ±‚ï¼Œç±»Testä¸­çš„æŸéƒ¨åˆ†å¤„ç†ä¼šéšç€ç±»å‹Tçš„ä¸åŒè€Œä¼šæœ‰æ‰€ä¸åŒï¼Œæ¯”å¦‚å¸Œæœ›åˆ¤æ–­Tæ˜¯å¦ä¸ºæŒ‡é’ˆç±»å‹ï¼Œå½“Tä¸ºæŒ‡é’ˆç±»å‹æ—¶çš„å¤„ç†æœ‰åˆ«äºéæŒ‡é’ˆç±»å‹ï¼Œæ€ä¹ˆåšï¼Ÿ
æ¨¡æ¿é‡Œå†åŠ ä¸ªå‚æ•°ï¼Œå¦‚ä¸‹ï¼š</typename></p>

<p>template &lt;typename T, bool isPointer&gt;
class Test {
     â€¦â€¦// can use isPointer to judge whether T is a pointer
};
ç„¶åç”¨æˆ·é€šè¿‡å¤šä¼ ä¸€ä¸ªæ¨¡æ¿ç±»å‹æ¥å‘Šè¯‰Testç±»å½“å‰Tæ˜¯å¦ä¸ºæŒ‡é’ˆã€‚(Test&lt;int*, true&gt;)
å¾ˆæŠ±æ­‰ï¼Œæ‰€æœ‰çš„æ­£å¸¸ç‚¹çš„ç”¨æˆ·éƒ½ä¼šæŠ±æ€¨è¿™æ ·çš„å°è£…ï¼Œå› ä¸ºç”¨æˆ·ä¸ç†è§£ä¸ºä»€ä¹ˆè¦è®©ä»–ä»¬å»å…³å¿ƒè‡ªå·±çš„æ¨¡æ¿ç±»å‹æ˜¯å¦ä¸ºæŒ‡é’ˆï¼Œæ—¢ç„¶æ˜¯Testç±»æœ¬èº«çš„é€»è¾‘ï¼Œä¸ºä»€ä¹ˆéº»çƒ¦ç”¨æˆ·å‘¢ï¼Ÿ
ç”±äºæˆ‘ä»¬å¾ˆéš¾å»é™åˆ¶ç”¨æˆ·åœ¨ä½¿ç”¨æ¨¡æ¿ç±»æ—¶æ˜¯ä½¿ç”¨æŒ‡é’ˆè¿˜æ˜¯åŸºæœ¬æ•°æ®ç±»å‹è¿˜æ˜¯è‡ªå®šä¹‰ç±»å‹ï¼Œè€Œç”¨å¸¸è§„æ–¹æ³•ä¹Ÿæ²¡æœ‰å¾ˆå¥½çš„æ–¹æ³•å»åˆ¤æ–­å½“å‰çš„Tçš„ç±»å‹ã€‚traitsæ€ä¹ˆåšå‘¢ï¼Ÿ
å®šä¹‰traitsç»“æ„ï¼š</p>

<p>template <typename T="">
struct TraitsHelper {
     static const bool isPointer = false;
};</typename></p>

<p>template <typename T="">
struct TraitsHelper&lt;T *&gt; {
     static const bool isPointer = true;
};
ä¹Ÿè®¸ä½ ä¼šå¾ˆå›°æƒ‘ï¼Œç»“æ„ä½“é‡Œå°±ä¸€ä¸ªé™æ€å¸¸é‡ï¼Œæ²¡æœ‰ä»»ä½•æ–¹æ³•å’Œæˆå‘˜å˜é‡ï¼Œæœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿè§£é‡Šä¸€ä¸‹ï¼Œç¬¬ä¸€ä¸ªç»“æ„ä½“çš„åŠŸèƒ½æ˜¯å®šä¹‰æ‰€æœ‰TraitsHelperä¸­isPointerçš„é»˜è®¤å€¼éƒ½æ˜¯falseï¼Œè€Œç¬¬äºŒä¸ªç»“æ„ä½“çš„åŠŸèƒ½æ˜¯å½“æ¨¡æ¿ç±»å‹Tä¸ºæŒ‡é’ˆæ—¶ï¼ŒisPointerçš„å€¼ä¸ºtrueã€‚ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥å¦‚ä¸‹æ¥åˆ¤æ–­å½“å‰ç±»å‹ï¼š
TraitsHelper<int>::isPointerå€¼ä¸ºfalseï¼Œ å¯ä»¥å¾—å‡ºå½“å‰ç±»å‹intéæŒ‡é’ˆç±»å‹
TraitsHelper&lt;int*&gt;::isPointerå€¼ä¸ºtrueï¼Œ å¯ä»¥å¾—å‡ºå½“å‰ç±»å‹int*ä¸ºæŒ‡é’ˆç±»å‹
ä¹Ÿè®¸çœ‹åˆ°è¿™é‡Œéƒ¨åˆ†äººä¼šè®¤ä¸ºæˆ‘ç®€ç›´æ˜¯åœ¨è¯´åºŸè¯ï¼Œè¯·å†è‡ªå·±å“å‘³ä¸‹ï¼Œè¿™æ ·æ˜¯å¦å°±å¯ä»¥åœ¨ä¸Šé¢Testç±»çš„å®šä¹‰ä¸­ç›´æ¥ä½¿ç”¨TraitsHelper<T>::isPointeræ¥åˆ¤æ–­å½“å‰Tçš„ç±»å‹äº†ã€‚</T></int></typename></p>

<p>if (TraitsHelper<T>::isPointer)
     ......
else
     ......
å†çœ‹ç¬¬äºŒä¸ªä¾‹å­ï¼š
è¿˜æ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»Testï¼š</T></p>

<p>template <typename T="">
class Test {
public:
     int Compute(int d);
private:
     T mData;
};
å®ƒæœ‰ä¸€ä¸ªComputeæ–¹æ³•æ¥åšä¸€äº›è®¡ç®—ï¼Œå…·æœ‰intå‹çš„å‚æ•°å¹¶è¿”å›intå‹çš„å€¼ã€‚
ç°åœ¨éœ€æ±‚å˜äº†ï¼Œéœ€è¦åœ¨Tä¸ºintç±»å‹æ—¶ï¼ŒComputeæ–¹æ³•çš„å‚æ•°ä¸ºintï¼Œè¿”å›ç±»å‹ä¹Ÿä¸ºintï¼Œå½“Tä¸ºfloatæ—¶ï¼ŒComputeæ–¹æ³•çš„å‚æ•°ä¸ºfloatï¼Œè¿”å›ç±»å‹ä¸ºintï¼Œè€Œå½“Tä¸ºå…¶ä»–ç±»å‹ï¼ŒComputeæ–¹æ³•çš„å‚æ•°ä¸ºTï¼Œè¿”å›ç±»å‹ä¹Ÿä¸ºTï¼Œæ€ä¹ˆåšå‘¢ï¼Ÿè¿˜æ˜¯ç”¨traitsçš„æ–¹å¼æ€è€ƒä¸‹ã€‚</typename></p>

<p>template <typename T="">
struct TraitsHelper {
     typedef T ret_type;
     typedef T par_type;
};</typename></p>

<p>template &lt;&gt;
struct TraitsHelper<int> {
     typedef int ret_type;
     typedef int par_type;
};</int></p>

<p>template &lt;&gt;
struct TraitsHelper<float> {
     typedef float ret_type;
     typedef int par_type;
};
ç„¶åæˆ‘ä»¬å†æŠŠTestç±»ä¹Ÿæ›´æ–°ä¸‹ï¼š</float></p>

<p>template <typename T="">
class Test {
public:
     TraitsHelper<T>::ret_type Compute(TraitsHelper<T>::par_type d);
private:
     T mData;
};
å¯è§ï¼Œæˆ‘ä»¬æŠŠå› ç±»å‹ä¸åŒè€Œå¼•èµ·çš„å˜åŒ–éš”ç¦»åœ¨äº†Testç±»ä»¥å¤–ï¼Œå¯¹ç”¨æˆ·è€Œè¨€å®Œå…¨ä¸éœ€è¦å»å…³å¿ƒè¿™äº›é€»è¾‘ï¼Œä»–ä»¬ç”šè‡³ä¸éœ€è¦çŸ¥é“æˆ‘ä»¬æ˜¯å¦ä½¿ç”¨äº†traitsæ¥è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚
åˆ°è¿™é‡Œï¼Œå†è®©æˆ‘ä»¬å›è¿‡æ¥å–å“å‘³ä¸‹å¼€å§‹æˆ‘è¯´çš„é‚£å¥è¯ï¼š
å½“å‡½æ•°ï¼Œç±»æˆ–è€…ä¸€äº›å°è£…çš„é€šç”¨ç®—æ³•ä¸­çš„æŸäº›éƒ¨åˆ†ä¼šå› ä¸ºæ•°æ®ç±»å‹ä¸åŒè€Œå¯¼è‡´å¤„ç†æˆ–é€»è¾‘ä¸åŒæ—¶ï¼Œtraitsä¼šæ˜¯ä¸€ç§å¾ˆå¥½çš„è§£å†³æ–¹æ¡ˆã€‚
ã€€ã€€</T></T></typename></p>

:ET