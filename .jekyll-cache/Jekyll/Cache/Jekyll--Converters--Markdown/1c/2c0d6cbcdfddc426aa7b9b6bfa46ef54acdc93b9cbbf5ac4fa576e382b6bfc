I"ü!<p>ä¸€ã€ç”± iter åŒ…å¼•å‘çš„ç–‘é—®
æœ€è¿‘åœ¨ GitHub ä¸Šå¶ç„¶å‘ç°äº† Brad Fitzpatrick çš„ iter åŒ…ï¼Œæ•´ä¸ªåŒ…åªæœ‰ ä¸€ä¸ªå‡½æ•°ï¼ˆä¸€è¡Œä»£ç ï¼‰ï¼š</p>

<p>func N(n int) []struct{} {
	return make([]struct{}, n)
}
ä½†å…¶ä¸­çš„ä¸€è¡Œæ³¨é‡Šä»¤äººè´¹è§£ï¼š</p>

<p>It does not cause any allocations.</p>

<ol>
  <li>ç©ºç»“æ„ä½“
æˆ‘ä»¬çŸ¥é“ï¼Œstruct{} æ˜¯ç©ºç»“æ„ä½“ï¼ˆempty structï¼‰ã€‚å…³äºç©ºç»“æ„ä½“ï¼ŒDave Cheney åœ¨ The empty struct ä¸­ä½œäº†å¾ˆå¥½åœ°é˜è¿°ï¼š</li>
</ol>

<p>ç©ºç»“æ„ä½“ä¸å ç”¨ç©ºé—´ï¼ˆThe empty struct consumes no storageï¼‰ã€‚
ç©ºç»“æ„ä½“çš„åˆ‡ç‰‡åªå ç”¨åˆ‡ç‰‡å¤´çš„ç©ºé—´ï¼ˆSlices of struct{}s consume only the space for their slice headerï¼‰ã€‚</p>
<ol>
  <li>Go åˆ‡ç‰‡
æŒ‰ç…§å®˜æ–¹åšå®¢ Go Slices: usage and internals çš„è¯´æ³•ï¼š</li>
</ol>

<p>A slice is a descriptor of an array segment. It consists of a pointer to the array, the length of the segment, and its capacity (the maximum length of the segment).</p>

<p>å› ä¸ºåˆ‡ç‰‡æ€»æ˜¯æŒ‡å‘ä¸€ä¸ªåº•å±‚æ•°ç»„çš„ï¼Œæ‰€ä»¥æ‰€è°“çš„ â€œåˆ‡ç‰‡å¤´â€ å…¶å®å°±æ˜¯åˆ‡ç‰‡æœ¬èº«ã€‚ä¸€ä¸ªåˆ‡ç‰‡åŒ…æ‹¬ï¼šæŒ‡å‘æ•°ç»„ç‰‡æ®µçš„æŒ‡é’ˆã€æ•°ç»„ç‰‡æ®µçš„é•¿åº¦å’Œæœ€å¤§é•¿åº¦ï¼Œæ€»å…± 3 ä¸ªå­—é•¿ï¼ˆåœ¨ 64 ä½æœºå™¨ä¸Šï¼Œå°±æ˜¯ 24 ä¸ªå­—èŠ‚ï¼‰ã€‚</p>

<ol>
  <li>ç–‘é—®
æŒ‰ç…§ä¸Šé¢çš„åˆ†æï¼Œåœ¨ 64 ä½æœºå™¨ä¸Šï¼Œä¸ç®¡ n æ˜¯å¤šå°‘ï¼Œmake([]struct{}, n) å¾—åˆ°çš„åˆ‡ç‰‡ä¸€å®šä¼šå ç”¨ 24 ä¸ªå­—èŠ‚ï¼Œreddit ä¸Šçš„è®¨è®º ä¹Ÿè¯å®äº†æˆ‘ä»¬çš„åˆ†æã€‚</li>
</ol>

<p>é‚£ä¸ºä»€ä¹ˆ Brad Fitzpatrick å£°ç§°å‡½æ•° N ä¸ä¼šå¼•å‘åˆ†é…å‘¢ï¼Ÿ</p>

<p>ä¸ºäº†è§£å†³è¿™ä¸ªç–‘æƒ‘ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå¼„æ¸…æ¥šä¸¤ä¸ªé—®é¢˜ï¼š</p>

<p>ä¸€ä¸ª Go å˜é‡å¯èƒ½ä¼šè¢«åˆ†é…åœ¨å“ªé‡Œï¼Ÿ
å¦‚ä½•ç¡®å®šä¸€ä¸ª Go å˜é‡æœ€ç»ˆä¼šè¢«åˆ†é…åœ¨å“ªé‡Œï¼Ÿ
<!-- more -->
äºŒã€Go å˜é‡å¯èƒ½çš„åˆ†é…ä½ç½®</p>
<ol>
  <li>è¿›ç¨‹çš„å†…å­˜å¸ƒå±€
åœ¨ Linux/x86-32 ç³»ç»Ÿä¸­ï¼Œåˆå§‹åŒ–çš„å…¨å±€å˜é‡æˆ–é™æ€å˜é‡ï¼Œä¼šè¢«åˆ†é…åœ¨ Data æ®µã€‚
æœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡æˆ–é™æ€å˜é‡ï¼Œä¼šè¢«åˆ†é…åœ¨ BSS æ®µã€‚
åœ¨å‡½æ•°ä¸­å®šä¹‰çš„å±€éƒ¨å˜é‡ï¼Œä¼šè¢«åˆ†é…åœ¨å †ï¼ˆHeap æ®µï¼‰æˆ–æ ˆï¼ˆStack æ®µï¼‰ã€‚
å®é™…ä¸Šï¼Œå¦‚æœè€ƒè™‘åˆ° ç¼–è¯‘å™¨ä¼˜åŒ–ï¼Œå±€éƒ¨å˜é‡è¿˜å¯èƒ½ä¼šè¢« åˆ†é…åœ¨å¯„å­˜å™¨ï¼Œæˆ–è€…ç›´æ¥è¢« ä¼˜åŒ–å»æ‰ã€‚</li>
  <li>Go å†…å­˜åˆ†é…
å¯¹äº Go è€Œè¨€ï¼Œæœ‰ä¸¤ä¸ªåœ°æ–¹å¯ä»¥ç”¨äºåˆ†é…ï¼š</li>
</ol>

<p>å †ï¼ˆheapï¼‰
ç”± GC è´Ÿè´£å›æ”¶ã€‚
å¯¹åº”äºè¿›ç¨‹åœ°å€ç©ºé—´çš„å †ã€‚
æ ˆï¼ˆstackï¼‰
ä¸æ¶‰åŠ GC æ“ä½œã€‚
æ¯ä¸ª goroutine éƒ½æœ‰è‡ªå·±çš„æ ˆï¼Œåˆå§‹æ—¶è¢«åˆ†é…åœ¨è¿›ç¨‹åœ°å€ç©ºé—´çš„æ ˆä¸Šï¼Œæ‰©å®¹æ—¶è¢«åˆ†é…åœ¨è¿›ç¨‹åœ°å€ç©ºé—´çš„å †ä¸Šã€‚
Go å˜é‡ä¸»è¦åˆ†ä¸ºä¸¤ç§ï¼š</p>

<p>å…¨å±€å˜é‡
ä¼šè¢« Go ç¼–è¯‘å™¨æ ‡è®°ä¸ºä¸€äº›ç‰¹æ®Šçš„ ç¬¦å·ç±»å‹ï¼Œåˆ†é…åœ¨å †ä¸Šè¿˜æ˜¯æ ˆä¸Šç›®å‰å°šä¸æ¸…æ¥šï¼Œä¸è¿‡ä¸æ˜¯æœ¬æ–‡è®¨è®ºçš„é‡ç‚¹ã€‚
å±€éƒ¨å˜é‡
æ‰€ä»¥ç»¼ä¸Šï¼Œå¯¹äºåœ¨å‡½æ•°ä¸­å®šä¹‰çš„ Go å±€éƒ¨å˜é‡ï¼šè¦ä¹ˆè¢«åˆ†é…åœ¨å †ä¸Šï¼Œè¦ä¹ˆè¢«åˆ†é…åœ¨æ ˆä¸Šã€‚</p>

<p>ä¸‰ã€ç¡®å®š Go å˜é‡æœ€ç»ˆçš„åˆ†é…ä½ç½®
è‡³æ­¤ï¼Œæˆ‘ä»¬è¿˜å‰©ä¸‹ä¸€ä¸ªé—®é¢˜ï¼šå¯¹äºä¸€ä¸ª Go å±€éƒ¨å˜é‡ï¼Œå¦‚ä½•ç¡®å®šå®ƒè¢«åˆ†é…åœ¨å †ä¸Šè¿˜æ˜¯æ ˆä¸Šï¼Ÿ</p>

<p>æŒ‰ç…§å®˜æ–¹ FAQ How do I know whether a variable is allocated on the heap or the stack? çš„è§£é‡Šï¼š</p>

<p>Go ç¼–è¯‘å™¨ä¼šå°½å¯èƒ½å°†å˜é‡åˆ†é…åœ¨æ ˆä¸Š
ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼ŒGo ç¼–è¯‘å™¨ä¼šå°†å˜é‡åˆ†é…åœ¨å †ä¸Š
å¦‚æœä¸€ä¸ªå˜é‡è¢«å–åœ°å€ï¼ˆhas its address takenï¼‰ï¼Œå¹¶ä¸”è¢«é€ƒé€¸åˆ†æï¼ˆescape analysisï¼‰è¯†åˆ«ä¸º â€œé€ƒé€¸åˆ°å †â€ï¼ˆescapes to heapï¼‰
å¦‚æœä¸€ä¸ªå˜é‡å¾ˆå¤§ï¼ˆvery largeï¼‰</p>
<ol>
  <li>é€ƒé€¸åˆ†æ
ä»¥ä½¿ç”¨ iter åŒ…çš„è¿™æ®µä»£ç ä¸ºä¾‹ï¼š</li>
</ol>

<p>package main</p>

<p>import â€œgithub.com/bradfitz/iterâ€</p>

<p>func main() {
        for range iter.N(4) {}
}
ä¸‹åˆ—æ¼”ç¤ºä¸­ï¼Œæˆ‘å°†ä½¿ç”¨ Go 1.11.4ï¼š</p>

<p>$ go version
go version go1.11.4 darwin/amd64
ä¸‹é¢æˆ‘ä»¬å¯¹è¿™æ®µä»£ç ä½œé€ƒé€¸åˆ†æï¼š</p>

<p>$ go build -gcflags=â€™-m -mâ€™ examples/go_mem/main.go</p>
<h1 id="command-line-arguments">command-line-arguments</h1>
<p>examples/go_mem/main.go:5:6: cannot inline main: unhandled op RANGE
examples/go_mem/main.go:6:30: inlining call to iter.N func(int) []struct {} { return make([]struct {}, iter.n) }
examples/go_mem/main.go:6:30: make([]struct {}, iter.n) escapes to heap
examples/go_mem/main.go:6:30: 	from make([]struct {}, iter.n) (non-constant size) at ./main.go:6:30
examples/go_mem/main.go:6:13: i declared and not used
æŒ‰ç…§å‰é¢çš„åˆ†æï¼Œä» â€œmake([]struct {}, iter.n) escapes to heapâ€ çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬æ¨æ–­ï¼šmake([]struct {}, iter.n) ä¼šè¢«åˆ†é…åœ¨å †ä¸Šã€‚</p>

<p>åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬æœ€åˆçš„ç–‘æƒ‘ä¼¼ä¹å·²ç»æœ‰äº†ç­”æ¡ˆï¼šmake([]struct {}, iter.n) ä¸€å®šä¼šå¼•å‘å †åˆ†é…ï¼Œé‚£æ˜¯ Brad Fitzpatrick çš„æ³¨é‡Šå†™é”™äº†å—ï¼Ÿ</p>

<ol>
  <li>å†…å­˜åˆ†é…å™¨è¿½è¸ª
é™¤äº†é€ƒé€¸åˆ†æï¼ŒGo è¿˜æä¾›äº†ä¸€ç§å«å†…å­˜åˆ†é…å™¨è¿½è¸ªï¼ˆMemory Allocator Traceï¼‰çš„æ–¹æ³•ï¼Œç”¨äºç»†ç²’åº¦åœ°åˆ†æç”±ç¨‹åºå¼•å‘çš„æ‰€æœ‰å †åˆ†é…ï¼ˆå’Œé‡Šæ”¾ï¼‰æ“ä½œï¼š</li>
</ol>

<p>$ GODEBUG=allocfreetrace=1 go run examples/go_mem/main.go 2&gt;&amp;1 | grep -C 10 examples/go_mem
å› ä¸ºè¿›è¡Œå†…å­˜åˆ†é…å™¨è¿½è¸ªæ—¶ï¼Œå¾ˆå¤šç”± runtime å¼•å‘çš„åˆ†é…ä¿¡æ¯ä¹Ÿä¼šè¢«æ‰“å°å‡ºæ¥ï¼Œæ‰€ä»¥æˆ‘ä»¬ç”¨ grep è¿›è¡Œè¿‡æ»¤ï¼Œåªæ˜¾ç¤ºç”±ç”¨æˆ·ä»£ç ï¼ˆuser codeï¼‰å¼•å‘çš„åˆ†é…ä¿¡æ¯ã€‚ç„¶è€Œè¿™é‡Œçš„è¾“å‡ºç»“æœä¸ºç©ºï¼Œè¡¨æ˜ make([]struct {}, iter.n) æ²¡æœ‰å¼•å‘ä»»ä½•å †åˆ†é…ã€‚</p>

<p>å†…å­˜åˆ†é…å™¨è¿½è¸ªçš„ç»“è®ºä¸é€ƒé€¸åˆ†æçš„ç»“è®ºæˆªç„¶ç›¸åï¼é‚£åˆ°åº•å“ªä¸ªç»“è®ºæ˜¯å¯¹çš„å‘¢ï¼Ÿ</p>

<ol>
  <li>æ±‡ç¼–åˆ†æ
é»”é©´æŠ€ç©·ä¹‹é™…ï¼ŒGoâ€™s Memory Allocator - Overview è¿™ç¯‡æ–‡ç« ç»™äº†æˆ‘æç¤ºï¼š</li>
</ol>

<p>So, we know that i is going to be allocated on the heap. But how does the runtime set that up? With the compilerâ€™s help! We can get an idea from reading the generated assembly.</p>

<p>å…³äº Go æ±‡ç¼–ï¼ˆassemblyï¼‰ï¼Œæ¨èå¤§å®¶é˜…è¯» Go internals, Chapter 1: Go assemblyã€‚</p>

<p>ä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹ç¤ºä¾‹ä»£ç å¯¹åº”çš„æ±‡ç¼–ï¼š</p>

<p>$ go tool compile -I $GOPATH/pkg/darwin_amd64 -S examples/go_mem/main.go
â€¦
0x001d 00029 (examples/go_mem/main.go:6)        LEAQ    type.struct {}(SB), AX
0x0024 00036 (examples/go_mem/main.go:6)        PCDATA  $2, $0
0x0024 00036 (examples/go_mem/main.go:6)        MOVQ    AX, (SP)
0x0028 00040 (examples/go_mem/main.go:6)        MOVQ    $4, 8(SP)
0x0031 00049 (examples/go_mem/main.go:6)        MOVQ    $4, 16(SP)
0x003a 00058 (examples/go_mem/main.go:6)        CALL    runtime.makeslice(SB)
â€¦
å¯ä»¥çœ‹åˆ°ï¼Œå…¶ä¸­æœ‰ä¸€å¤„å¯¹ runtime.makeslice(SB) çš„è°ƒç”¨ï¼Œæ˜¾ç„¶æ˜¯ç”± make([]struct{}, n) å¼•å‘çš„ã€‚</p>

<p>æŸ¥çœ‹ runtime.makeslice çš„æºç ï¼š</p>

<p>func makeslice(et <em>_type, len, cap int) slice {
	â€¦
	p := mallocgc(et.size</em>uintptr(cap), et, true)
	return slice{p, len, cap}
}
å…¶ä¸­ï¼Œmallocgc çš„æºç å¦‚ä¸‹ï¼š</p>

<p>func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
	â€¦
	if size == 0 {
		return unsafe.Pointer(&amp;zerobase)
	}
	â€¦
	if debug.allocfreetrace != 0 {
		tracealloc(x, size, typ)
	}
	â€¦
}
slice å¯¹åº”çš„ç»“æ„ä½“å¦‚ä¸‹ï¼š</p>

<p>type slice struct {
	array unsafe.Pointer
	len   int
	cap   int
}
ç»“åˆä¸Šè¿°å‡ æ®µæºç ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼š</p>

<p>makeslice å‡½æ•°ä¸­ï¼šslice ç»“æ„ä½“æ­£æ˜¯æˆ‘ä»¬åœ¨ç¬¬ä¸€èŠ‚æåˆ°çš„ Go åˆ‡ç‰‡ â€”â€” array æ˜¯æŒ‡å‘æ•°ç»„ç‰‡æ®µçš„æŒ‡é’ˆï¼Œlen æ˜¯æ•°ç»„ç‰‡æ®µçš„é•¿åº¦ï¼Œcap æ˜¯æ•°ç»„ç‰‡æ®µçš„æœ€å¤§é•¿åº¦ã€‚
makeslice å‡½æ•°ä¸­ï¼šarray çš„å€¼æ¥è‡ª pï¼Œè€Œ p åˆ™æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œå®ƒæŒ‡å‘ç”± mallocgc åˆ†é…å¾—åˆ°çš„åº•å±‚æ•°ç»„ã€‚
mallocgc å‡½æ•°ä¸­ï¼šå› ä¸ºç©ºç»“æ„ä½“çš„ size ä¸º 0ï¼Œæ‰€ä»¥ mallocgc å¹¶æ²¡æœ‰å®é™…è¿›è¡Œå †åˆ†é…ï¼›ç”±äºæ²¡æœ‰æ‰§è¡Œåˆ° tracealloc çš„åœ°æ–¹ï¼Œæ‰€ä»¥è¿›è¡Œå†…å­˜åˆ†é…å™¨è¿½è¸ªæ—¶ï¼Œä¸ä¼šé‡‡é›†åˆ°ç›¸å…³çš„åˆ†é…ä¿¡æ¯ã€‚
makeslice å‡½æ•°ä¸­ï¼šåˆ‡ç‰‡ slice æœ¬èº«æ˜¯ä»¥ç»“æ„ä½“çš„å½¢å¼è¿”å›çš„ï¼Œæ‰€ä»¥åªä¼šè¢«åˆ†é…åœ¨æ ˆä¸Šã€‚
å››ã€æ€»ç»“
ç»è¿‡ä¸€ç³»åˆ—çš„æ¢ç´¢å’Œåˆ†æï¼Œè‡³æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºä»¥ä¸‹ç»“è®ºï¼š</p>

<p>make([]struct{}, n) åªä¼šè¢«åˆ†é…åœ¨æ ˆä¸Šï¼Œè€Œä¸ä¼šè¢«åˆ†é…åœ¨å †ä¸Šã€‚
Brad Fitzpatrick çš„æ³¨é‡Šæ˜¯å¯¹çš„ï¼Œå¹¶ä¸”ä»–çš„æ„æ€æ˜¯ â€œä¸ä¼šå¼•å‘å †åˆ†é…â€ã€‚
é€ƒé€¸åˆ†æè¯†åˆ«å‡º escapes to heapï¼Œå¹¶ä¸ä¸€å®šå°±æ˜¯å †åˆ†é…ï¼Œä¹Ÿå¯èƒ½æ˜¯æ ˆåˆ†é…ã€‚
å†…å­˜åˆ†é…å™¨è¿½è¸ªæ—¶ï¼Œå¦‚æœé‡‡é›†ä¸åˆ°å †åˆ†é…ä¿¡æ¯ï¼Œé‚£ä¸€å®šåªæœ‰æ ˆåˆ†é…ã€‚
äº”ã€æ€è€ƒé¢˜
å¦‚æœæ¢æˆ make([]int, n)ï¼Œç»“æœè¿˜ä¼šæ˜¯æ ˆåˆ†é…å—ï¼Ÿ
å¦‚æœæ¢æˆ make([]int, 4) å‘¢ï¼Ÿ
é™¤äº†ç©ºç»“æ„ä½“ make([]struct{}, n) çš„ç‰¹ä¾‹ï¼Œè¿˜æœ‰å“ªäº› â€œè¢«é€ƒé€¸åˆ†æè¯†åˆ«ä¸º escapes to heapï¼Œä½†å…¶å®æ˜¯æ ˆåˆ†é…â€ çš„æ¡ˆä¾‹ï¼Ÿ
Go æ”¯æŒé—­åŒ…ï¼ˆclosureï¼‰ï¼Œé‚£ä¹ˆé—­åŒ…ä¸­çš„å˜é‡ï¼Œåˆæ˜¯åˆ†é…åœ¨å“ªé‡Œçš„ï¼Ÿï¼ˆWhere are variables in a closure stored - stack or heap? è¯´æ˜¯åˆ†é…åœ¨æ ˆä¸Šï¼Œå¯¹äº Go ä¹Ÿæ˜¯æˆç«‹çš„å—ï¼Ÿï¼‰</p>
:ET