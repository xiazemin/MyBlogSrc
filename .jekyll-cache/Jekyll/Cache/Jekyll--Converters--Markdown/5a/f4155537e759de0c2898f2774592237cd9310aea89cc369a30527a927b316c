I"§n<p>Go + MySQL + ES å®ç°ä¸€ä¸ª Tag API æœåŠ¡
Tag æ˜¯ä¸€ä¸ªå¾ˆå¸¸è§çš„åŠŸèƒ½ï¼Œè¿™ç¯‡æ–‡ç« å°†ä½¿ç”¨ Go + MySQL + ES å®ç°ä¸€ä¸ª 500 å¤šè¡Œçš„ tag API æœåŠ¡ï¼Œæ”¯æŒ åˆ›å»º/æœç´¢ æ ‡ç­¾ã€æ ‡ç­¾å…³è”åˆ°å®ä½“ å’Œ æŸ¥è¯¢å®ä½“æ‰€å…³è”çš„æ ‡ç­¾åˆ—è¡¨ã€‚
https://juejin.im/post/5ed9fdc051882543216f0b26
<!-- more --></p>

<p>MySQL
brew install mysql
å¤åˆ¶ä»£ç ES
è¿™é‡Œç›´æ¥é€šè¿‡ docker æ¥å¯åŠ¨ ES:
docker run -d â€“name elasticsearch -p 9200:9200 -p 9300:9300 -e â€œdiscovery.type=single-nodeâ€ elasticsearch
å¤åˆ¶ä»£ç å¯åŠ¨åå¯ä»¥é€šè¿‡ curl æ£€æŸ¥æ˜¯å¦å·²ç»å¯åŠ¨å’Œè·å–ç‰ˆæœ¬ä¿¡æ¯ï¼š
curl localhost:9200
{
  â€œnameâ€ : â€œ5059f2c85a1dâ€,
  â€œcluster_nameâ€ : â€œdocker-clusterâ€,
  â€œcluster_uuidâ€ : â€œT5EjufvlSdCcZXVDJFi2cAâ€,
  â€œversionâ€ : {
    â€œnumberâ€ : â€œ7.7.1â€,
    â€œbuild_flavorâ€ : â€œdefaultâ€,
    â€œbuild_typeâ€ : â€œdockerâ€,
    â€œbuild_hashâ€ : â€œad56dce891c901a492bb1ee393f12dfff473a423â€,
    â€œbuild_dateâ€ : â€œ2020-05-28T16:30:01.040088Zâ€,
    â€œbuild_snapshotâ€ : false,
    â€œlucene_versionâ€ : â€œ8.5.1â€,
    â€œminimum_wire_compatibility_versionâ€ : â€œ6.8.0â€,
    â€œminimum_index_compatibility_versionâ€ : â€œ6.0.0-beta1â€
  },
  â€œtaglineâ€ : â€œYou Know, for Searchâ€
}
å¤åˆ¶ä»£ç æ³¨æ„ä¸Šé¢çš„éƒ¨ç½²ä»…ç”¨äºå¼€å‘ç¯å¢ƒï¼Œå¦‚æœéœ€è¦åœ¨ç”Ÿäº§éƒ¨ç½²é€šè¿‡ docker éƒ¨ç½²ï¼Œè¯·å‚è€ƒå®˜æ–¹æ–‡æ¡£: Install Elasticsearch with Dockerã€‚
è®¾è®¡å­˜å‚¨ç»“æ„
å…ˆåœ¨ MySQL é‡Œé¢åˆ›å»ºä¸€ä¸ª test æ•°æ®åº“:
create database test;
use test;
å¤åˆ¶ä»£ç åˆ›å»º tag_tbl è¡¨:
CREATE TABLE <code class="language-plaintext highlighter-rouge">tag_tbl</code> (
  <code class="language-plaintext highlighter-rouge">id</code> int(11) NOT NULL AUTO_INCREMENT,
  <code class="language-plaintext highlighter-rouge">name</code> varchar(40) NOT NULL,
  <code class="language-plaintext highlighter-rouge">created_at</code> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (<code class="language-plaintext highlighter-rouge">id</code>),
  UNIQUE KEY <code class="language-plaintext highlighter-rouge">name</code> (<code class="language-plaintext highlighter-rouge">name</code>) USING HASH
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
å¤åˆ¶ä»£ç tag_tbl ç”¨äºå­˜å‚¨æ ‡ç­¾ï¼Œæ³¨æ„è¿™é‡Œç»™æˆ‘ä»¬ç»™ name å­—æ®µåŠ ä¸Šäº†ä¸€ä¸ªå”¯ä¸€é”®ï¼Œå¹¶ä½¿ç”¨ hash ä½œä¸ºç´¢å¼•æ–¹æ³•ï¼Œå…³äº hash ç´¢å¼•ï¼Œå¯ä»¥å‚è€ƒå®˜æ–¹æ–‡æ¡£ï¼šComparison of B-Tree and Hash Indexesã€‚
å†åˆ›å»º entity_tag_tbl ç”¨äºå­˜å‚¨å®ä½“å…³è”çš„ tag:
CREATE TABLE <code class="language-plaintext highlighter-rouge">entity_tag_tbl</code> (
  <code class="language-plaintext highlighter-rouge">id</code> int(10) unsigned NOT NULL AUTO_INCREMENT,
  <code class="language-plaintext highlighter-rouge">entity_id</code> int(10) unsigned NOT NULL,
  <code class="language-plaintext highlighter-rouge">tag_id</code> int(10) unsigned NOT NULL,
  <code class="language-plaintext highlighter-rouge">created_at</code> datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (<code class="language-plaintext highlighter-rouge">id</code>),
  UNIQUE KEY <code class="language-plaintext highlighter-rouge">entity_id</code> (<code class="language-plaintext highlighter-rouge">entity_id</code>,<code class="language-plaintext highlighter-rouge">tag_id</code>) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
å¤åˆ¶ä»£ç è®¾è®¡ API
åˆ›å»ºæ ‡ç­¾
Request:
POST /api/tag
{
    â€œnameâ€: â€œyour tag nameâ€
}
å¤åˆ¶ä»£ç Response:
{
    â€œtag_idâ€: 1
}
å¤åˆ¶ä»£ç æœç´¢æ ‡ç­¾
Request:
GET /api/tag/search
{
    â€œkeywordâ€: â€œcatâ€
}
å¤åˆ¶ä»£ç Response:
{
    â€œmatchsâ€: [
        {
            â€œtag_idâ€: 5,
            â€œnameâ€: â€œcatâ€
        },
        {
            â€œtag_idâ€: 6,
            â€œnameâ€: â€œcat picturesâ€
        }
    ]
}
å¤åˆ¶ä»£ç å…³è”æ ‡ç­¾åˆ°å®ä½“
Request:
POST /api/tag/link_entity
{
    â€œentity_idâ€: 1,
    â€œtag_idâ€: 3
}
å¤åˆ¶ä»£ç Response:
{
    â€œlink_idâ€: 1
}
å¤åˆ¶ä»£ç æŸ¥è¯¢å®ä½“å…³è”çš„æ ‡ç­¾åˆ—è¡¨
Request:
GET /api/tag/entity_tags
{
    â€œentity_idâ€: 1
}
å¤åˆ¶ä»£ç Response:
{
    â€œtagsâ€: [
        {
            â€œtag_idâ€: 3,
            â€œnameâ€: â€œç¾é£Ÿâ€
        }
    ]
}
å¤åˆ¶ä»£ç ç¼–ç å®ç°
åˆå§‹åŒ–ï¼š
mkdir tag-server
cd tag-server
go mod init github.com/3vilive/tag-server
å¤åˆ¶ä»£ç å®‰è£…å°†è¦ç”¨åˆ°ä¾èµ–é¡¹ï¼š
go get github.com/go-sql-driver/mysql github.com/jmoiron/sqlx github.com/gin-gonic/gin github.com/elastic/go-elasticsearch/v7
å¤åˆ¶ä»£ç åˆ›å»º cmd/api-server/main.go å¹¶ç¼–å†™è„šæ‰‹æ¶ä»£ç :
package main</p>

<p>import (
    â€œnet/httpâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/gin-gonic/gin" )
</code></pre></div></div>

<p>func OnNewTag(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
        â€œtag_idâ€: 0,
    })
}</p>

<p>func OnSearchTag(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
        â€œmatchesâ€: []struct{}{},
    })
}</p>

<p>func OnLinkEntity(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		â€œlink_idâ€: 0,
	})
}</p>

<p>func OnEntityTags(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{
		â€œtagsâ€: []struct{}{},
	})
	return
}</p>

<p>func main() {
    r := gin.Default()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r.POST("/api/tag", OnNewTag)
r.GET("/api/tag/search", OnSearchTag)
r.POST("/api/tag/link_entity", OnLinkEntity)
r.GET("/api/tag/entity_tags", OnEntityTags)

r.Run(":9800") } å¤åˆ¶ä»£ç å®ç°åˆ›å»ºæ ‡ç­¾çš„ API è¿æ¥æ•°æ®åº“ï¼š import "github.com/jmoiron/sqlx" import _ "github.com/go-sql-driver/mysql" // mysql driver
</code></pre></div></div>

<p>var (
    mysqlDB *sqlx.DB
)</p>

<p>func init() {
    mysqlDB = sqlx.MustOpen(â€œmysqlâ€, â€œtest:test@tcp(localhost:3306)/test?parseTime=True&amp;loc=Local&amp;multiStatements=true&amp;charset=utf8mb4â€)
}
å¤åˆ¶ä»£ç å®šä¹‰ Tag ç»“æ„ï¼š
type Tag struct {
    TagID int    <code class="language-plaintext highlighter-rouge">db:"id"</code>
    Name  string <code class="language-plaintext highlighter-rouge">db:"name"</code>
}
å¤åˆ¶ä»£ç ç¼–å†™åˆ›å»ºæ ‡ç­¾çš„é€»è¾‘ï¼š
// NewTagReqBody åˆ›å»ºæ ‡ç­¾çš„è¯·æ±‚ä½“
type NewTagReqBody struct {
    Name string <code class="language-plaintext highlighter-rouge">json:"name"</code>
}</p>

<p>// OnNewTag åˆ›å»ºæ ‡ç­¾
func OnNewTag(c *gin.Context) {
    var reqBody NewTagReqBody
    if bindErr := c.BindJSON(&amp;reqBody); bindErr != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            â€œstatusâ€:  http.StatusBadRequest,
            â€œmessageâ€: bindErr.Error(),
        })
        return
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// åˆ¤æ–­ä¼ å…¥çš„ tag åç§°æ˜¯å¦ä¸ºç©º
tagName := strings.TrimSpace(reqBody.Name)
if tagName == "" {
    c.JSON(http.StatusBadRequest, gin.H{
        "status":  http.StatusBadRequest,
        "message": "invalid name",
    })
    return
}

var queryTag Tag
queryErr := mysqlDB.Get(&amp;queryTag, "select id, name from tag_tbl where name = ?", tagName)
if queryErr == nil {
    // tag å·²ç»å­˜åœ¨
    c.JSON(http.StatusOK, gin.H{
        "tag_id": queryTag.TagID,
    })
    return
}

// æŸ¥è¯¢ mysql å‡ºç°é”™è¯¯
if queryErr != nil &amp;&amp; queryErr != sql.ErrNoRows {
    c.JSON(http.StatusInternalServerError, gin.H{
        "status":  http.StatusInternalServerError,
        "message": queryErr.Error(),
    })
    return
}

// tag ä¸å­˜åœ¨ï¼Œåˆ›å»º tag
result, execErr := mysqlDB.Exec("insert into tag_tbl (name) values (?) on duplicate key update created_at = now()", tagName)
if execErr != nil {
    c.JSON(http.StatusInternalServerError, gin.H{
        "status":  http.StatusInternalServerError,
        "message": execErr.Error(),
    })
    return
}

tagID, err := result.LastInsertId()
if err != nil {
    c.JSON(http.StatusInternalServerError, gin.H{
        "status":  http.StatusInternalServerError,
        "message": err.Error(),
    })
    return
}

c.JSON(http.StatusOK, gin.H{
    "tag_id": tagID,
}) } å¤åˆ¶ä»£ç å¯åŠ¨æµ‹è¯•ä¸€ä¸‹ï¼š go run cmd/api-server/main.go [GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.
</code></pre></div></div>

<p>[GIN-debug] [WARNING] Running in â€œdebugâ€ mode. Switch to â€œreleaseâ€ mode in production.</p>
<ul>
  <li>using env:   export GIN_MODE=release</li>
  <li>using code:  gin.SetMode(gin.ReleaseMode)</li>
</ul>

<p>[GIN-debug] POST   /api/tag                  â€“&gt; main.OnNewTag (3 handlers)
[GIN-debug] POST   /api/tag/search           â€“&gt; main.OnSearchTag (3 handlers)
[GIN-debug] Listening and serving HTTP on :9800
å¤åˆ¶ä»£ç åˆ›å»ºä¸€ä¸ªåä¸º test çš„æ ‡ç­¾:
curl â€“request POST <br />
  â€“url http://localhost:9800/api/tag <br />
  â€“header â€˜content-type: application/jsonâ€™ <br />
  â€“data â€˜{
    â€œnameâ€: â€œtestâ€
}â€™
å¤åˆ¶ä»£ç å“åº”ï¼š
{
  â€œtag_idâ€: 1
}
å¤åˆ¶ä»£ç å†åˆ›å»ºä¸€ä¸ªå«åš æµ‹è¯• çš„æ ‡ç­¾ï¼š
curl â€“request POST <br />
  â€“url http://localhost:9800/api/tag <br />
  â€“header â€˜content-type: application/jsonâ€™ <br />
  â€“data â€˜{
    â€œnameâ€: â€œæµ‹è¯•â€
}â€™
å¤åˆ¶ä»£ç å“åº”ï¼š
{
  â€œtag_idâ€: 2
}
å¤åˆ¶ä»£ç é‡æ–°è¿è¡Œä¸€éåˆ›å»º test æ ‡ç­¾çš„è¯·æ±‚ï¼š
curl â€“request POST <br />
  â€“url http://localhost:9800/api/tag <br />
  â€“header â€˜content-type: application/jsonâ€™ <br />
  â€“data â€˜{
    â€œnameâ€: â€œtestâ€
}â€™
å¤åˆ¶ä»£ç å“åº”ï¼š
{
  â€œtag_idâ€: 1
}
å¤åˆ¶ä»£ç æµ‹è¯•ç»“æœç¬¦åˆé¢„æœŸï¼Œå½“å‰å®Œæ•´æ–‡ä»¶å†…å®¹å¦‚ä¸‹ï¼š
package main</p>

<p>import (
    â€œdatabase/sqlâ€
    â€œnet/httpâ€
    â€œstringsâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/gin-gonic/gin"
"github.com/jmoiron/sqlx"

_ "github.com/go-sql-driver/mysql" // mysql driver )
</code></pre></div></div>

<p>var (
    mysqlDB *sqlx.DB
)</p>

<p>func init() {
    mysqlDB = sqlx.MustOpen(â€œmysqlâ€, â€œtest:test@tcp(localhost:3306)/test?parseTime=True&amp;loc=Local&amp;multiStatements=true&amp;charset=utf8mb4â€)
}</p>

<p>// Tag æ ‡ç­¾ç»“æ„å®šä¹‰
type Tag struct {
    TagID int    <code class="language-plaintext highlighter-rouge">db:"id"</code>
    Name  string <code class="language-plaintext highlighter-rouge">db:"name"</code>
}</p>

<p>// NewTagReqBody åˆ›å»ºæ ‡ç­¾çš„è¯·æ±‚ä½“
type NewTagReqBody struct {
    Name string <code class="language-plaintext highlighter-rouge">json:"name"</code>
}</p>

<p>// OnNewTag åˆ›å»ºæ ‡ç­¾
func OnNewTag(c *gin.Context) {
    var reqBody NewTagReqBody
    if bindErr := c.BindJSON(&amp;reqBody); bindErr != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            â€œstatusâ€:  http.StatusBadRequest,
            â€œmessageâ€: bindErr.Error(),
        })
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// åˆ¤æ–­ä¼ å…¥çš„ tag åç§°æ˜¯å¦ä¸ºç©º
tagName := strings.TrimSpace(reqBody.Name)
if tagName == "" {
    c.JSON(http.StatusBadRequest, gin.H{
        "status":  http.StatusBadRequest,
        "message": "invalid name",
    })
    return
}

var queryTag Tag
queryErr := mysqlDB.Get(&amp;queryTag, "select id, name from tag_tbl where name = ?", tagName)
if queryErr == nil {
    // tag å·²ç»å­˜åœ¨
    c.JSON(http.StatusOK, gin.H{
        "tag_id": queryTag.TagID,
    })
    return
}

// æŸ¥è¯¢ mysql å‡ºç°é”™è¯¯
if queryErr != nil &amp;&amp; queryErr != sql.ErrNoRows {
    c.JSON(http.StatusInternalServerError, gin.H{
        "status":  http.StatusInternalServerError,
        "message": queryErr.Error(),
    })
    return
}

// tag ä¸å­˜åœ¨ï¼Œåˆ›å»º tag
result, execErr := mysqlDB.Exec("insert into tag_tbl (name) values (?) on duplicate key update created_at = now()", tagName)
if execErr != nil {
    c.JSON(http.StatusInternalServerError, gin.H{
        "status":  http.StatusInternalServerError,
        "message": execErr.Error(),
    })
    return
}

tagID, err := result.LastInsertId()
if err != nil {
    c.JSON(http.StatusInternalServerError, gin.H{
        "status":  http.StatusInternalServerError,
        "message": err.Error(),
    })
    return
}

c.JSON(http.StatusOK, gin.H{
    "tag_id": tagID,
}) }
</code></pre></div></div>

<p>// OnSearchTag æœç´¢æ ‡ç­¾
func OnSearchTag(c *gin.Context) {
    c.JSON(http.StatusOK, gin.H{
        â€œmatchesâ€: []struct{}{},
    })
}</p>

<p>func main() {
    r := gin.Default()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>r.POST("/api/tag", OnNewTag)
r.POST("/api/tag/search", OnSearchTag)

r.Run(":9800") } å¤åˆ¶ä»£ç å®ç°æœç´¢æ ‡ç­¾çš„ API å¯¼å…¥ elasticsearch åŒ…ï¼š import (
...
elasticsearch7 "github.com/elastic/go-elasticsearch/v7" ) å¤åˆ¶ä»£ç å£°æ˜ esClient å˜é‡ï¼š var (
mysqlDB  *sqlx.DB
esClient *elasticsearch7.Client ) å¤åˆ¶ä»£ç åœ¨ init å‡½æ•°ä¸­åˆå§‹åŒ– esClientï¼š func init() {
// åˆå§‹åŒ– mysql
mysqlDB = sqlx.MustOpen("mysql", "test:test@tcp(localhost:3306)/test?parseTime=True&amp;loc=Local&amp;multiStatements=true&amp;charset=utf8mb4")

// åˆå§‹åŒ– ES
esConf := elasticsearch7.Config{
	Addresses: []string{"http://localhost:9200"},
}
es, err := elasticsearch7.NewClient(esConf)
if err != nil {
	panic(err)
}

res, err := es.Info()
if err != nil {
	panic(err)
}

if res.IsError() {
	panic(res.String())
}

esClient = es } å¤åˆ¶ä»£ç æŠŠæ ‡ç­¾æ·»åŠ è‡³ ES ç´¢å¼• ä¸ºäº†èƒ½åœ¨ ES ä¸Šæœåˆ°æ ‡ç­¾ï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ·»åŠ æ ‡ç­¾çš„æ—¶å€™ï¼ŒæŠŠæ ‡ç­¾æ·»åŠ è‡³ ES ç´¢å¼•ä¸­ã€‚ å…ˆä¿®æ”¹ Tag ç»“æ„ï¼Œå¢åŠ  JSON Tag, å¹¶æ·»åŠ è½¬æ¢æˆ JSON å­—ç¬¦ä¸²çš„æ–¹æ³•: // Tag æ ‡ç­¾ç»“æ„å®šä¹‰ type Tag struct {
TagID int    `db:"id" json:"tag_id"`
Name  string `db:"name" json:"name"` }
</code></pre></div></div>

<p>// MustToJSON å°†ç»“æ„è½¬æ¢æˆ JSON
func (t *Tag) MustToJSON() string {
	bs, err := json.Marshal(t)
	if err != nil {
		panic(err)
	}
	return string(bs)
}
å¤åˆ¶ä»£ç ç„¶åæ·»åŠ ä¸€ä¸ªä¸ŠæŠ¥ Tag åˆ° ES ç´¢å¼•çš„å‡½æ•°:
// ReportTagToES ä¸ŠæŠ¥ Tag åˆ° ES
func ReportTagToES(tag *Tag) {
	req := esapi.IndexRequest{
		Index:        â€œtestâ€,
		DocumentType: â€œtagâ€,
		DocumentID:   strconv.Itoa(tag.TagID),
		Body:         strings.NewReader(tag.MustToJSON()),
		Refresh:      â€œtrueâ€,
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resp, err := req.Do(context.Background(), esClient)
if err != nil {
	log.Printf("ESIndexRequestErr: %s", err.Error())
	return
}

defer resp.Body.Close()
if resp.IsError() {
	log.Printf("ESIndexRequestErr: %s", resp.String())
} else {
	log.Printf("ESIndexRequestOk: %s", resp.String())
} } å¤åˆ¶ä»£ç åœ¨ OnNewTag å‡½æ•°çš„åº•éƒ¨å¢åŠ ä¸ŠæŠ¥çš„é€»è¾‘ï¼š func OnNewTag(c *gin.Context) {

... 

tagID, err := result.LastInsertId()
if err != nil {
	c.JSON(http.StatusInternalServerError, gin.H{
		"status":  http.StatusInternalServerError,
		"message": err.Error(),
	})
	return
}

// æ·»åŠ åˆ° ES ç´¢å¼•
newTag := &amp;Tag{TagID: int(tagID), Name: tagName}
go ReportTagToES(newTag)

c.JSON(http.StatusOK, gin.H{
	"tag_id": tagID,
}) } å¤åˆ¶ä»£ç é‡æ–°å¯åŠ¨æœåŠ¡ï¼Œç„¶åæµ‹è¯•åˆ›å»º Tagï¼Œè§‚å¯Ÿæ—¥å¿—: 2020/06/05 11:29:11 ESIndexRequestOk: [201 Created] {"_index":"test","_type":"tag","_id":"4","_version":1,"result":"created","forced_refresh":true,"_shards":{"total":2,"successful":1,"failed":0},"_seq_no":3,"_primary_term":1} å¤åˆ¶ä»£ç å†è°ƒç”¨ ES çš„ API éªŒè¯ä¸€ä¸‹: curl -XGET "localhost:9200/test/tag/4"
</code></pre></div></div>

<p>{â€œ_indexâ€:â€testâ€,â€_typeâ€:â€tagâ€,â€_idâ€:â€4â€,â€_versionâ€:1,â€_seq_noâ€:3,â€_primary_termâ€:1,â€foundâ€:true,â€_sourceâ€:{â€œtag_idâ€:4,â€nameâ€:â€æµ‹è¯•æ‰‹æ®µâ€}}
å¤åˆ¶ä»£ç å®Œå–„æœç´¢é€»è¾‘
æ–°å¢ä¸€ä¸ª SearchTagReqBody ç»“æ„ï¼Œä½œä¸ºæœç´¢æ ‡ç­¾çš„è¯·æ±‚ä½“
type SearchTagReqBody struct {
	Keyword string <code class="language-plaintext highlighter-rouge">json:"keyword"</code>
}
å¤åˆ¶ä»£ç åœ¨ OnSearchTag å‡½æ•°é‡Œé¢å¢åŠ ä¸€äº›åŸºæœ¬çš„å‚æ•°æ ¡éªŒï¼š
func OnSearchTag(c *gin.Context) {
	var reqBody SearchTagReqBody
	if bindErr := c.BindJSON(&amp;reqBody); bindErr != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			â€œstatusâ€:  http.StatusBadRequest,
			â€œmessageâ€: bindErr.Error(),
		})
		return
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>searchKeyword := strings.TrimSpace(reqBody.Keyword)
if searchKeyword == "" {
	c.JSON(http.StatusBadRequest, gin.H{
		"status":  http.StatusBadRequest,
		"message": "invalid keyword",
	})
	return
}

c.JSON(http.StatusOK, gin.H{
	"matches": []struct{}{},
}) } å¤åˆ¶ä»£ç å¢åŠ ä¸€ä¸ª O ç»“æ„ä½œä¸º map[string]interface{} çš„åˆ«åï¼Œå¹¶ä¸”ä¸ºè¿™ä¸ªç»“æ„æ·»åŠ ä¸€ä¸ª MustToJSONBytesBuffer() *bytes.Buffer çš„æ–¹æ³•ï¼š type O map[string]interface{}
</code></pre></div></div>

<p>func (o *O) MustToJSONBytesBuffer() *bytes.Buffer {
	var buf bytes.Buffer
	if err := json.NewEncoder(&amp;buf).Encode(o); err != nil {
		panic(err)
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return &amp;buf } å¤åˆ¶ä»£ç å®šä¹‰è¿™ä¸ª O æ˜¯ä¸ºäº†ç­‰ä¼šæ„å»º ES æŸ¥è¯¢æä¾›ä¸€ç‚¹ä¾¿åˆ©ã€‚ å¢åŠ  SearchTagsFromES å‡½æ•°ï¼Œä» ES ä¸Šæœç´¢ Tagsï¼š func SearchTagsFromES(keyword string) ([]*Tag, error) {
// æ„å»ºæŸ¥è¯¢
query := O{
	"query": O{
		"match_phrase_prefix": O{
			"name":           keyword,
			"max_expansions": 50,
		},
	},
}
jsonBuf := query.MustToJSONBytesBuffer()

// å‘å‡ºæŸ¥è¯¢è¯·æ±‚
resp, err := esClient.Search(
	esClient.Search.WithContext(context.Background()),
	esClient.Search.WithIndex("test"),
	esClient.Search.WithBody(jsonBuf),
)
if err != nil {
	return nil, err
}
defer resp.Body.Close()

if resp.IsError() {
	return nil, errors.New(resp.Status())
}

js, err := simplejson.NewFromReader(resp.Body)
if err != nil {
	return nil, err
}

hitsJS := js.GetPath("hits", "hits")
hits, err := hitsJS.Array()
if err != nil {
	return nil, err
}

hitsLen := len(hits)
if hitsLen == 0 {
	return []*Tag{}, nil
}

tags := make([]*Tag, 0, len(hits))
for idx := 0; idx &lt; hitsLen; idx++ {
	sourceJS := hitsJS.GetIndex(idx).Get("_source")

	tagID, err := sourceJS.Get("tag_id").Int()
	if err != nil {
		return nil, err
	}

	tagName, err := sourceJS.Get("name").String()
	if err != nil {
		return nil, err
	}

	tagEntity := &amp;Tag{TagID: tagID, Name: tagName}
	tags = append(tags, tagEntity)
}

return tags, nil } å¤åˆ¶ä»£ç ä¿®æ”¹ OnSearchTag å‡½æ•°ï¼ŒåŠ å…¥æœç´¢çš„é€»è¾‘ï¼š func OnSearchTag(c *gin.Context) {
var reqBody SearchTagReqBody
if bindErr := c.BindJSON(&amp;reqBody); bindErr != nil {
	c.JSON(http.StatusBadRequest, gin.H{
		"status":  http.StatusBadRequest,
		"message": bindErr.Error(),
	})
	return
}

searchKeyword := strings.TrimSpace(reqBody.Keyword)
if searchKeyword == "" {
	c.JSON(http.StatusBadRequest, gin.H{
		"status":  http.StatusBadRequest,
		"message": "invalid keyword",
	})
	return
}

tags, err := SearchTagsFromES(reqBody.Keyword)
if err != nil {
	c.JSON(http.StatusInternalServerError, gin.H{
		"status":  http.StatusInternalServerError,
		"message": err.Error(),
	})
	return
}

c.JSON(http.StatusOK, gin.H{
	"matches": tags,
}) } å¤åˆ¶ä»£ç é‡æ–°å¯åŠ¨æœåŠ¡ï¼Œç„¶åæ·»åŠ ä¸€ä¸ªç¾é£Ÿæ ‡ç­¾ï¼Œç„¶åå†æœç´¢ï¼š curl --request GET \   --url http://localhost:9800/api/tag/search \   --header 'content-type: application/json' \   --data '{
"keyword": "ç¾é£Ÿ" }'
</code></pre></div></div>

<p>// response:</p>

<p>{
  â€œmatchesâ€: [
    {
      â€œtag_idâ€: 5,
      â€œnameâ€: â€œç¾é£Ÿâ€
    }
  ]
}
å¤åˆ¶ä»£ç æœç´¢ API æœ€ç»ˆæ•ˆæœ
å…ˆæ¸…ç©ºä¸€ä¸‹ MySQL çš„å†å²æ•°æ®ï¼Œä¹‹å‰æ·»åŠ æ ‡ç­¾çš„æ—¶å€™ï¼Œè¿˜æ²¡æœ‰æ·»åŠ åˆ° ES çš„ç´¢å¼•é‡Œé¢ï¼š
truncate tag_tbl;
å¤åˆ¶ä»£ç åŒæ—¶ä¹Ÿæ¸…ç†ä¸€ä¸‹ ES ç´¢å¼•ï¼š
curl -XDELETE â€œlocalhost:9200/testâ€
å¤åˆ¶ä»£ç æ¥ä¸‹æ¥æ·»åŠ ä¸€æ‰¹ Tag:
ç¾é£Ÿ
ç¾é£Ÿè¡—
ç¾é£ŸèŠ‚
ç¾é£ŸèŠ‚è¶£é—»
ç¾é£ŸèŠ‚ä¸‰å‰‘å®¢
ç¾é£Ÿå¤©å ‚
ç¾é£Ÿçš„è¯±æƒ‘
ç¾é£Ÿåœ¨ä¸­å›½
ç¾é£Ÿè¡—éƒ½æœ‰å•¥
å¤åˆ¶ä»£ç æœç´¢ â€œç¾é£Ÿâ€ï¼š
{
  â€œmatchesâ€: [
    {
      â€œtag_idâ€: 1,
      â€œnameâ€: â€œç¾é£Ÿâ€
    },
    {
      â€œtag_idâ€: 2,
      â€œnameâ€: â€œç¾é£Ÿè¡—â€
    },
    {
      â€œtag_idâ€: 3,
      â€œnameâ€: â€œç¾é£ŸèŠ‚â€
    },
    {
      â€œtag_idâ€: 6,
      â€œnameâ€: â€œç¾é£Ÿå¤©å ‚â€
    },
    {
      â€œtag_idâ€: 4,
      â€œnameâ€: â€œç¾é£ŸèŠ‚è¶£é—»â€
    },
    {
      â€œtag_idâ€: 7,
      â€œnameâ€: â€œç¾é£Ÿçš„è¯±æƒ‘â€
    },
    {
      â€œtag_idâ€: 8,
      â€œnameâ€: â€œç¾é£Ÿåœ¨ä¸­å›½â€
    },
    {
      â€œtag_idâ€: 5,
      â€œnameâ€: â€œç¾é£ŸèŠ‚ä¸‰å‰‘å®¢â€
    },
    {
      â€œtag_idâ€: 9,
      â€œnameâ€: â€œç¾é£Ÿè¡—éƒ½æœ‰å•¥â€
    }
  ]
}
å¤åˆ¶ä»£ç æœç´¢ â€œç¾é£Ÿè¡—â€ï¼š
{
  â€œmatchesâ€: [
    {
      â€œtag_idâ€: 2,
      â€œnameâ€: â€œç¾é£Ÿè¡—â€
    },
    {
      â€œtag_idâ€: 9,
      â€œnameâ€: â€œç¾é£Ÿè¡—éƒ½æœ‰å•¥â€
    }
  ]
}
å¤åˆ¶ä»£ç æœç´¢ â€œç¾é£ŸèŠ‚â€ï¼š
{
  â€œmatchesâ€: [
    {
      â€œtag_idâ€: 3,
      â€œnameâ€: â€œç¾é£ŸèŠ‚â€
    },
    {
      â€œtag_idâ€: 4,
      â€œnameâ€: â€œç¾é£ŸèŠ‚è¶£é—»â€
    },
    {
      â€œtag_idâ€: 5,
      â€œnameâ€: â€œç¾é£ŸèŠ‚ä¸‰å‰‘å®¢â€
    }
  ]
}
å¤åˆ¶ä»£ç å®ç°å…³è”æ ‡ç­¾åˆ°å®ä½“ API
å®šä¹‰å®ä½“å…³è” Tag çš„ç»“æ„ï¼š
type EntityTag struct {
	LinkID   int <code class="language-plaintext highlighter-rouge">db:"id" json:"-"</code>
	EntityID int <code class="language-plaintext highlighter-rouge">db:"entity_id" json:"entity_id"</code>
	TagID    int <code class="language-plaintext highlighter-rouge">db:"tag_id" json:"tag_id"</code>
}
å¤åˆ¶ä»£ç å®šä¹‰è¯·æ±‚ä½“:
type LinkEntityReqBody struct {
	EntityID int <code class="language-plaintext highlighter-rouge">json:"entity_id"</code>
	TagID    int <code class="language-plaintext highlighter-rouge">json:"tag_id"</code>
}
å¤åˆ¶ä»£ç å¼€å§‹ç¼–å†™ OnLinkEntity é‡Œé¢çš„é€»è¾‘ï¼Œé¦–å…ˆå…ˆåšåŸºæœ¬çš„å‚æ•°æ ¡éªŒï¼š
var reqBody LinkEntityReqBody
if bindErr := c.BindJSON(&amp;reqBody); bindErr != nil {
	c.JSON(http.StatusBadRequest, gin.H{
		â€œstatusâ€:  http.StatusBadRequest,
		â€œmessageâ€: bindErr.Error(),
	})
	return
}</p>

<p>if reqBody.EntityID == 0 || reqBody.TagID == 0 {
	c.JSON(http.StatusBadRequest, gin.H{
		â€œstatusâ€:  http.StatusBadRequest,
		â€œmessageâ€: â€œrequest params errorâ€,
	})
	return
}
å¤åˆ¶ä»£ç æŸ¥è¯¢æ˜¯å¦æ ‡ç­¾å·²ç»å…³è”è¿‡è¯¥å®ä½“ï¼Œå¦‚æœå·²ç»å…³è”è¿‡ï¼Œåˆ™ç›´æ¥è¿”å›ï¼š
var entityTag EntityTag
queryErr := mysqlDB.Get(
	&amp;entityTag,
	â€œselect id, entity_id, tag_id from entity_tag_tbl where entity_id = ? and tag_id = ?â€,
	reqBody.EntityID, reqBody.TagID,
)</p>

<p>if queryErr == nil {
	// å·²ç»å­˜åœ¨å…³è”
	c.JSON(http.StatusOK, gin.H{
		â€œlink_idâ€: entityTag.LinkID,
	})
	return
}</p>

<p>if queryErr != sql.ErrNoRows {
	// æŸ¥è¯¢é”™è¯¯
	c.JSON(http.StatusInternalServerError, gin.H{
		â€œstatusâ€:  http.StatusInternalServerError,
		â€œmessageâ€: queryErr.Error(),
	})
	return
}
å¤åˆ¶ä»£ç åˆ¤æ–­ä¸€ä¸‹ Tag æ˜¯å¦å­˜åœ¨ï¼š
var tag Tag
queryErr = mysqlDB.Get(
	&amp;tag,
	â€œselect id, name from tag_tbl where id = ?â€,
	reqBody.TagID,
)
if queryErr != nil {
	if queryErr != sql.ErrNoRows {
		// æŸ¥è¯¢é”™è¯¯
		c.JSON(http.StatusInternalServerError, gin.H{
			â€œstatusâ€:  http.StatusInternalServerError,
			â€œmessageâ€: queryErr.Error(),
		})
		return
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Tag ä¸å­˜åœ¨
c.JSON(http.StatusNotFound, gin.H{
	"status":  http.StatusNotFound,
	"message": "tag not found",
})
return } å¤åˆ¶ä»£ç è®°å½•å…³è”ä¿¡æ¯å¹¶è¿”å›å…³è” ID: execResult, execErr := mysqlDB.Exec(
"insert into entity_tag_tbl (entity_id, tag_id) values (?, ?) on duplicate key update created_at = now()",
reqBody.EntityID, reqBody.TagID, ) if execErr != nil {
// æ’å…¥å¤±è´¥
c.JSON(http.StatusInternalServerError, gin.H{
	"status":  http.StatusInternalServerError,
	"message": execErr.Error(),
})
return }
</code></pre></div></div>

<p>linkID, err := execResult.LastInsertId()
if err != nil {
	c.JSON(http.StatusInternalServerError, gin.H{
		â€œstatusâ€:  http.StatusInternalServerError,
		â€œmessageâ€: err.Error(),
	})
	return
}</p>

<p>c.JSON(http.StatusOK, gin.H{
	â€œlink_idâ€: int(linkID),
})
å¤åˆ¶ä»£ç é‡å¯æœåŠ¡ï¼Œåˆ›å»ºä¸€äº›å…³è”ï¼š
curl â€“request POST <br />
  â€“url http://localhost:9800/api/tag/link_entity <br />
  â€“header â€˜content-type: application/jsonâ€™ <br />
  â€“data â€˜{
	â€œentity_idâ€: 1,
	â€œtag_idâ€: 5
}â€™
å¤åˆ¶ä»£ç å¯ä»¥é€šè¿‡æ•°æ®åº“æ¥éªŒè¯ä¸€ä¸‹ï¼š
mysql&gt; select * from entity_tag_tbl;
+â€”-+â€”â€”â€”â€“+â€”â€”â€“+â€”â€”â€”â€”â€”â€”â€”+
| id | entity_id | tag_id | created_at          |
+â€”-+â€”â€”â€”â€“+â€”â€”â€“+â€”â€”â€”â€”â€”â€”â€”+
|  1 |         1 |      3 | 2020-06-05 15:03:00 |
|  2 |         1 |      1 | 2020-06-05 15:39:42 |
|  3 |         1 |      4 | 2020-06-05 15:39:47 |
|  4 |         1 |      2 | 2020-06-05 15:39:52 |
|  5 |         1 |      7 | 2020-06-05 15:55:59 |
|  6 |         1 |      5 | 2020-06-05 15:56:01 |
+â€”-+â€”â€”â€”â€“+â€”â€”â€“+â€”â€”â€”â€”â€”â€”â€”+
å¤åˆ¶ä»£ç å®ç°æŸ¥è¯¢å®ä½“å…³è”çš„æ ‡ç­¾åˆ—è¡¨ API
å®šä¹‰æŸ¥è¯¢å®ä½“å…³è”çš„æ ‡ç­¾åˆ—è¡¨çš„è¯·æ±‚ä½“:
type EntityTagReqBody struct {
	EntityID int <code class="language-plaintext highlighter-rouge">json:"entity_id"</code>
}
å¤åˆ¶ä»£ç ç¼–å†™ OnEntityTags é€»è¾‘ï¼Œå’Œä¹‹å‰ä¸€æ ·åšå‚æ•°æ ¡éªŒï¼š
var reqBody EntityTagReqBody
if bindErr := c.BindJSON(&amp;reqBody); bindErr != nil {
	c.JSON(http.StatusBadRequest, gin.H{
		â€œstatusâ€:  http.StatusBadRequest,
		â€œmessageâ€: bindErr.Error(),
	})
	return
}</p>

<p>if reqBody.EntityID == 0 {
	c.JSON(http.StatusBadRequest, gin.H{
		â€œstatusâ€:  http.StatusBadRequest,
		â€œmessageâ€: â€œrequest params errorâ€,
	})
	return
}
å¤åˆ¶ä»£ç æŸ¥è¯¢å‡ºå®ä½“å…³è”çš„æ ‡ç­¾ï¼š
entityTags := []*EntityTag{}
selectErr := mysqlDB.Select(&amp;entityTags, â€œselect id, entity_id, tag_id from entity_tag_tbl where entity_id = ? order by idâ€, reqBody.EntityID)
if selectErr != nil {
	c.JSON(http.StatusInternalServerError, gin.H{
		â€œstatusâ€:  http.StatusInternalServerError,
		â€œmessageâ€: selectErr.Error(),
	})
	return
}</p>

<p>if len(entityTags) == 0 {
	c.JSON(http.StatusOK, gin.H{
		â€œtagsâ€: []*Tag{},
	})
	return
}
å¤åˆ¶ä»£ç æŸ¥è¯¢å‡ºæ ‡ç­¾åˆ—è¡¨ï¼Œå¹¶è¿”å›ï¼š
tagIDs := make([]int, 0, len(entityTags))
tagIndex := make(map[int]int, len(entityTags))
for index, entityTag := range entityTags {
	tagIndex[entityTag.TagID] = index
	tagIDs = append(tagIDs, entityTag.TagID)
}</p>

<p>queryTags, args, err := sqlx.In(â€œselect id, name from tag_tbl where id in (?)â€, tagIDs)
if err != nil {
	c.JSON(http.StatusInternalServerError, gin.H{
		â€œstatusâ€:  http.StatusInternalServerError,
		â€œmessageâ€: err.Error(),
	})
	return
}</p>

<p>tags := []*Tag{}
selectErr = mysqlDB.Select(&amp;tags, queryTags, argsâ€¦)
if selectErr != nil {
	c.JSON(http.StatusInternalServerError, gin.H{
		â€œstatusâ€:  http.StatusInternalServerError,
		â€œmessageâ€: selectErr.Error(),
	})
	return
}</p>

<p>sort.Slice(tags, func(i, j int) bool {
	return tagIndex[tags[i].TagID] &lt; tagIndex[tags[j].TagID]
})</p>

<p>c.JSON(http.StatusOK, gin.H{
	â€œtagsâ€: tags,
})
å¤åˆ¶ä»£ç é‡å¯æœåŠ¡æµ‹è¯•ä¸€ä¸‹ï¼š
curl â€“request GET <br />
  â€“url http://localhost:9800/api/tag/entity_tags <br />
  â€“header â€˜content-type: application/jsonâ€™ <br />
  â€“data â€˜{
	â€œentity_idâ€: 1
}â€™</p>

<p>// response</p>

<p>{
  â€œtagsâ€: [
    {
      â€œtag_idâ€: 3,
      â€œnameâ€: â€œç¾é£ŸèŠ‚â€
    },
    {
      â€œtag_idâ€: 1,
      â€œnameâ€: â€œç¾é£Ÿâ€
    },
    {
      â€œtag_idâ€: 4,
      â€œnameâ€: â€œç¾é£ŸèŠ‚è¶£é—»â€
    },
    {
      â€œtag_idâ€: 2,
      â€œnameâ€: â€œç¾é£Ÿè¡—â€
    },
    {
      â€œtag_idâ€: 7,
      â€œnameâ€: â€œç¾é£Ÿçš„è¯±æƒ‘â€
    },
    {
      â€œtag_idâ€: 5,
      â€œnameâ€: â€œç¾é£ŸèŠ‚ä¸‰å‰‘å®¢â€
    }
  ]
}
å¤åˆ¶ä»£ç æœ€å
å®Œæ•´çš„ä»£ç å¯ä»¥åœ¨ Github ä¸Šæ‰¾åˆ°:
github.com/3vilive/buiâ€¦
å‚è€ƒèµ„æ–™ï¼š</p>

<p>Tags-Database-schemas
Tagsystems-performance-tests
Elasticsearch: æƒå¨æŒ‡å—</p>

<p>https://juejin.im/post/5ed9fdc051882543216f0b26</p>
:ET