I"ãZ<p>æœ¬æ–‡å†…å®¹ä¸»è¦åˆ†ä¸ºä¸‰éƒ¨åˆ†ï¼š</p>

<p>main goroutine çš„è°ƒåº¦è¿è¡Œ
é main goroutine çš„é€€å‡ºæµç¨‹
å·¥ä½œçº¿ç¨‹çš„æ‰§è¡Œæµç¨‹ä¸è°ƒåº¦å¾ªç¯ã€‚
main goroutine çš„è°ƒåº¦è¿è¡Œ#
runtimeÂ·rt0_goä¸­åœ¨è°ƒç”¨å®Œruntime.newprocåˆ›å»ºmain goroutineåï¼Œå°±è°ƒç”¨äº†runtime.mstartã€‚è®©æˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹è¿™ä¸ªå‡½æ•°ã€‚</p>

<p>mstart#
mstartæ²¡ä»€ä¹ˆå¤ªå¤šå·¥ä½œï¼Œç„¶åå°±è°ƒç”¨äº†mstart1ã€‚</p>

<p>Copy
func mstart() {
	<em>g</em> := getg()
        // åœ¨å¯åŠ¨é˜¶æ®µï¼Œ<em>g</em>.stackæ—©å°±å®Œæˆäº†åˆå§‹åŒ–ï¼Œæ‰€ä»¥osStackæ˜¯falseï¼Œä¸‹é¢è¢«çœç•¥çš„ä¹Ÿä¸ä¼šæ‰§è¡Œã€‚
	osStack := <em>g</em>.stack.lo == 0 
	â€¦â€¦
	<em>g</em>.stackguard0 = <em>g</em>.stack.lo + <em>StackGuard
	_g</em>.stackguard1 = <em>g</em>.stackguard0
	mstart1()
        â€¦â€¦
	mexit(osStack)
}
mstart1#
è°ƒç”¨saveä¿å­˜g0çš„çŠ¶æ€
å¤„ç†ä¿¡å·ç›¸å…³
è°ƒç”¨ schedule å¼€å§‹è°ƒåº¦
Copy
func mstart1() {
	<em>g</em> := getg()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if _g_ != _g_.m.g0 {
	throw("bad runtimeÂ·mstart")
}
save(getcallerpc(), getcallersp())	// ä¿å­˜è°ƒç”¨mstart1çš„å‡½æ•°ï¼ˆmstartï¼‰çš„ pc å’Œ spã€‚
asminit()				// ç©ºå‡½æ•°
minit()					// ä¿¡å·ç›¸å…³

if _g_.m == &amp;m0 {			// åˆå§‹åŒ–æ—¶ä¼šæ‰§è¡Œè¿™é‡Œï¼Œä¹Ÿæ˜¯ä¿¡å·ç›¸å…³
	mstartm0()
}

if fn := _g_.m.mstartfn; fn != nil {	// åˆå§‹åŒ–æ—¶ fn = nilï¼Œä¸ä¼šæ‰§è¡Œè¿™é‡Œ
	fn()
}

if _g_.m != &amp;m0 {			// ä¸æ˜¯m0çš„è¯ï¼Œæ²¡æœ‰pã€‚ç»‘å®šä¸€ä¸ªp
	acquirep(_g_.m.nextp.ptr())
	_g_.m.nextp = 0
}
schedule() } save(pc, sp uintptr) ä¿å­˜è°ƒåº¦ä¿¡æ¯# ä¿å­˜å½“å‰gï¼ˆåˆå§‹åŒ–æ—¶ä¸ºg0ï¼‰çš„çŠ¶æ€åˆ°schedå­—æ®µä¸­ã€‚
</code></pre></div></div>

<p>Copy
func save(pc, sp uintptr) {
	<em>g</em> := getg()
	<em>g</em>.sched.pc = pc
	<em>g</em>.sched.sp = sp
	<em>g</em>.sched.lr = 0
	<em>g</em>.sched.ret = 0
	<em>g</em>.sched.g = guintptr(unsafe.Pointer(<em>g</em>))
	if <em>g</em>.sched.ctxt != nil {
		badctxt()
	}
}
schedule å¼€å§‹è°ƒåº¦#
è°ƒç”¨globrunqgetã€runqgetã€findrunnableè·å–ä¸€ä¸ªå¯æ‰§è¡Œçš„g</p>

<p>Copy
func schedule() {
	<em>g</em> := getg()	// g0
        â€¦â€¦
	var gp *g	// åˆå§‹åŒ–æ—¶ï¼Œç»è¿‡ä¸‹é¢ä¸€ç³»åˆ—æŸ¥æ‰¾ï¼Œä¼šæ‰¾åˆ°main goroutineï¼Œå› ä¸ºç›®å‰ä¸ºæ­¢æ•´ä¸ªè¿è¡Œæ—¶åªæœ‰è¿™ä¸€ä¸ªgï¼ˆé™¤äº†g0ï¼‰ã€‚
	var inheritTime bool
        â€¦â€¦
	if gp == nil {
                // è¯¥pä¸Šæ¯è¿›è¡Œ61æ¬¡å°±ä»å…¨å±€é˜Ÿåˆ—ä¸­è·å–ä¸€ä¸ªg
		if <em>g</em>.m.p.ptr().schedtick%61 == 0 &amp;&amp; sched.runqsize &gt; 0 {
			lock(&amp;sched.lock)
			gp = globrunqget(<em>g</em>.m.p.ptr(), 1)
			unlock(&amp;sched.lock)
		}
	}
	if gp == nil {
                // ä»pçš„runqä¸­è·å–ä¸€ä¸ªg
		gp, inheritTime = runqget(<em>g</em>.m.p.ptr())
		// We can see gp != nil here even if the M is spinning,
		// if checkTimers added a local goroutine via goready.
	}
	if gp == nil {
                // å¯»æ‰¾å¯æ‰§è¡Œçš„gï¼Œä¼šå°è¯•ä»æœ¬åœ°ï¼Œå…¨å±€è¿è¡Œå¯¹åˆ—è·å–ï¼Œå¦‚æœæ²¡æœ‰ï¼Œä»å…¶ä»–pé‚£é‡Œå·å–ã€‚
		gp, inheritTime = findrunnable() // blocks until work is available
	}
	â€¦â€¦
	execute(gp, inheritTime)
}
executeï¼šå®‰æ’gåœ¨å½“å‰mä¸Šè¿è¡Œ#
è¢«è°ƒåº¦çš„ g ä¸ m ç›¸äº’ç»‘å®š
æ›´æ”¹gçš„çŠ¶æ€ä¸º <em>Grunning
è°ƒç”¨ gogo åˆ‡æ¢åˆ°è¢«è°ƒåº¦çš„gä¸Š
Copy
func execute(gp *g, inheritTime bool) {
	_g</em> := getg()	// g0</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_g_.m.curg = gp	// ä¸ä¸‹é¢ä¸€è¡Œæ˜¯ gp å’Œ m ç›¸äº’ç»‘å®šã€‚gp å…¶å®å°±æ˜¯ main goroutine
gp.m = _g_.m
casgstatus(gp, _Grunnable, _Grunning)	// æ›´æ”¹çŠ¶æ€
gp.waitsince = 0
gp.preempt = false
gp.stackguard0 = gp.stack.lo + _StackGuard
if !inheritTime {
	_g_.m.p.ptr().schedtick++
}
......
gogo(&amp;gp.sched) } gogo(buf *gobuf)# åœ¨æœ¬æ–¹æ³•ä¸‹é¢çš„è®²è§£ä¸­å°†ä½¿ç”¨newgä»£æŒ‡è¢«è°ƒåº¦çš„gã€‚
</code></pre></div></div>

<p>gogoå‡½æ•°æ˜¯ç”¨æ±‡ç¼–å®ç°çš„ã€‚å…¶ä½œç”¨æ˜¯ï¼šåŠ è½½newgçš„ä¸Šä¸‹æ–‡ï¼Œè·³è½¬åˆ°gobuf.pcæŒ‡å‘çš„å‡½æ•°ã€‚</p>

<p>Copy
// go/src/runtime/asm_amd64.s
TEXT runtimeÂ·gogo(SB), NOSPLIT, $16-8
	MOVQ	buf+0(FP), BX		// bx = &amp;gp.sched
	MOVQ	gobuf_g(BX), DX		// dx = gp.sched.g ï¼Œä¹Ÿå°±æ˜¯å­˜å‚¨çš„ newg æŒ‡é’ˆ
	MOVQ	0(DX), CX		// make sure g != nil
	get_tls(CX)
	MOVQ	DX, g(CX)		// newgæŒ‡é’ˆè®¾ç½®åˆ°tls
	MOVQ	gobuf_sp(BX), SP	// ä¸‹é¢å››æ¡æ˜¯åŠ è½½ä¸Šä¸‹æ–‡åˆ°cpuå¯„å­˜å™¨ã€‚
	MOVQ	gobuf_ret(BX), AX
	MOVQ	gobuf_ctxt(BX), DX
	MOVQ	gobuf_bp(BX), BP
	MOVQ	$0, gobuf_sp(BX)	// ä¸‹é¢å››æ¡æ˜¯æ¸…é›¶ï¼Œå‡å°‘gcçš„å·¥ä½œé‡ã€‚
	MOVQ	$0, gobuf_ret(BX)
	MOVQ	$0, gobuf_ctxt(BX)
	MOVQ	$0, gobuf_bp(BX)
	MOVQ	gobuf_pc(BX), BX	// gobuf.pc å­˜å‚¨çš„æ˜¯è¦æ‰§è¡Œçš„å‡½æ•°æŒ‡é’ˆï¼Œåˆå§‹åŒ–æ—¶æ­¤å‡½æ•°ä¸ºruntime.main
	JMP	BX			// è·³è½¬åˆ°è¦æ‰§è¡Œçš„å‡½æ•°
runtime.mainï¼šmainå‡½æ•°çš„æ‰§è¡Œ#
åœ¨ä¸Šé¢gogoæ‰§è¡Œæœ€åçš„JMPæŒ‡ä»¤ï¼Œå…¶å®å°±æ˜¯è·³è½¬åˆ°äº†runtime.mainã€‚</p>

<p>Copy
func main() {
	g := getg()		// è·å–å½“å‰gï¼Œå·²ç»ä¸æ˜¯g0äº†ï¼Œæˆ‘ä»¬æš‚ä¸”ç§°ä¸ºmaing</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if sys.PtrSize == 8 {	// 64ä½ç³»ç»Ÿï¼Œæ ˆæœ€å¤§ä¸º1GB
	maxstacksize = 1000000000
} else {
	maxstacksize = 250000000
}
mainStarted = true
    // å¯åŠ¨ç›‘æ§è¿›ç¨‹ï¼ŒæŠ¢å è°ƒåº¦å°±æ˜¯åœ¨è¿™é‡Œå®ç°çš„
if GOARCH != "wasm" { // no threads on wasm yet, so no sysmon
	systemstack(func() {
		newm(sysmon, nil)
	})
}
    ......
doInit(&amp;runtime_inittask)	// è°ƒç”¨runtimeçš„åˆå§‹åŒ–å‡½æ•°
    ......
runtimeInitTime = nanotime()	// è®°å½•ä¸–ç•Œå¼€å§‹æ—¶é—´
gcenable()			// å¼€å¯gc
......
doInit(&amp;main_inittask)		// è°ƒç”¨mainçš„åˆå§‹åŒ–å‡½æ•°
    ......
fn := main_main			// è°ƒç”¨main.mainï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬ç»å¸¸å†™hello worldçš„mainã€‚
fn()
    ......
exit(0)				// é€€å‡º } runtime.mainä¸»è¦åšäº†ä»¥ä¸‹çš„å·¥ä½œï¼š
</code></pre></div></div>

<p>å¯åŠ¨ç›‘æ§è¿›ç¨‹ã€‚
è°ƒç”¨runtimeçš„åˆå§‹åŒ–å‡½æ•°ã€‚
å¼€å¯gcã€‚
è°ƒç”¨mainçš„åˆå§‹åŒ–å‡½æ•°ã€‚
è°ƒç”¨main.mainï¼Œæ‰§è¡Œå®Œåé€€å‡ºã€‚
é main goroutine çš„é€€å‡ºæµç¨‹#
é¦–å…ˆæ˜ç¡®ä¸€ç‚¹ï¼Œæ— è®ºæ˜¯main goroutineè¿˜æ˜¯émain goroutineçš„éƒ½æ˜¯è°ƒç”¨newprocåˆ›å»ºçš„ï¼Œæ‰€ä»¥åœ¨è°ƒåº¦ä¸ŠåŸºæœ¬æ˜¯ä¸€è‡´çš„ã€‚</p>

<p>ä¹‹å‰çš„æ–‡ç« ä¸­è¯´è¿‡ï¼Œåœ¨gostartcallå‡½æ•°ä¸­ï¼Œä¼šå°†goroutineè¦æ‰§è¡Œçš„å‡½æ•°fnä¼ªé€ æˆæ˜¯è¢«goexitè°ƒç”¨çš„ã€‚ä½†æ˜¯ï¼Œå½“fnæ˜¯runtime.mainçš„æ—¶å€™æ˜¯æ²¡æœ‰ç”¨çš„ï¼Œå› ä¸ºåœ¨runtime.mainæœ«å°¾ä¼šè°ƒç”¨exit(0)é€€å‡ºç¨‹åºã€‚æ‰€ä»¥ï¼Œè¿™åªå¯¹émain goroutineèµ·ä½œç”¨ã€‚è®©æˆ‘ä»¬ç®€å•éªŒè¯ä¸€ä¸‹ã€‚</p>

<p>å…ˆç»™å‡ºä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š</p>

<p>Copy
package main</p>

<p>import â€œfmtâ€</p>

<p>func main() {
	ch := make(chan int)
	go foo(ch)
	fmt.Println(&lt;-ch)
}</p>

<p>func foo(ch chan int) {
	ch &lt;- 1
}
dlvè°ƒè¯•ä¸€æ³¢ï¼š</p>

<p>Copy
root@xiamin:~/study# dlv debug foo.go
(dlv) b main.foo // æ‰“ä¸ªæ–­ç‚¹
Breakpoint 1 set at 0x4ad86f for main.foo() ./foo.go:11
(dlv) c</p>
<blockquote>
  <p>main.foo() ./foo.go:11 (hits goroutine(6):1 total:1) (PC: 0x4ad86f)
     6:		ch := make(chan int)
     7:		go foo(ch)
     8:		fmt.Println(&lt;-ch)
     9:	}
    10:
=&gt;  11:	func foo(ch chan int) {
    12:		ch &lt;- 1
    13:	}
(dlv) bt // å¯ä»¥çœ‹åˆ°è°ƒç”¨æ ˆä¸­ç¡®å®å­˜åœ¨goexit
0  0x00000000004ad86f in main.foo
   at ./foo.go:11
1  0x0000000000463df1 in runtime.goexit
   at /root/go/src/runtime/asm_amd64.s:1373</p>
</blockquote>

<p>// æ­¤å¤„æ‰§è¡Œä¸‰æ¬¡ sï¼Œå¾—åˆ°ä»¥ä¸‹ç»“æœï¼Œç¡®å®æ˜¯å›åˆ°äº†goexitã€‚</p>

<blockquote>
  <p>runtime.goexit() /root/go/src/runtime/asm_amd64.s:1374 (PC: 0x463df1)
  1370:	// The top-most function running on a goroutine
  1371:	// returns to goexit+PCQuantum.
  1372:	TEXT runtimeÂ·goexit(SB),NOSPLIT,$0-0
  1373:		BYTE	$0x90	// NOP
=&gt;1374:		CALL	runtimeÂ·goexit1(SB)	// does not return
  1375:		// traceback from goexit1 must hit code range of goexit
  1376:		BYTE	$0x90	// NOP
æˆ‘ä»¬æš‚ä¸”å°†å…³è”fooçš„gç§°ä¹‹ä¸ºfoogï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬çœ‹ä¸€ä¸‹å®ƒçš„é€€å‡ºæµç¨‹ã€‚</p>
</blockquote>

<p>goexit#
Copy
TEXT runtimeÂ·goexit(SB),NOSPLIT,$0-0
	BYTE	$0x90	// NOP
	CALL	runtimeÂ·goexit1(SB)	// does not return
	// traceback from goexit1 must hit code range of goexit
	BYTE	$0x90	// NOP
goexit1#
Copy
func goexit1() {
	if raceenabled {
		racegoend()
	}
	if trace.enabled {
		traceGoEnd()
	}
	mcall(goexit0)
}
goexitå’Œgoexit1æ²¡ä»€ä¹ˆå¯è¯´çš„ï¼Œçœ‹ä¸€ä¸‹mcall</p>

<p>mcall(fn func(<em>g))#
mcallçš„å‚æ•°æ˜¯ä¸ªå‡½æ•°fnï¼Œè€Œfnæœ‰ä¸ªå‚æ•°æ˜¯</em>gï¼Œæ­¤å¤„fnæ˜¯goexit0ã€‚</p>

<p>mcallæ˜¯ç”±æ±‡ç¼–ç¼–å†™çš„ï¼š</p>

<p>Copy
TEXT runtimeÂ·mcall(SB), NOSPLIT, $0-8
	MOVQ	fn+0(FP), DI	// æ­¤å¤„ di å­˜å‚¨çš„æ˜¯ funcval ç»“æ„ä½“æŒ‡é’ˆï¼Œfuncval.fn æŒ‡å‘çš„æ˜¯ goexit0ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>get_tls(CX)
MOVQ	g(CX), AX	// æ­¤å¤„ ax ä¸­å­˜å‚¨çš„æ˜¯foog

    // ä¿å­˜foogçš„ä¸Šä¸‹æ–‡
MOVQ	0(SP), BX	// caller's PCã€‚mcallçš„è¿”å›åœ°å€ï¼Œæ­¤å¤„å°±æ˜¯ goexit1 è°ƒç”¨ mcall æ—¶çš„pc
MOVQ	BX, (g_sched+gobuf_pc)(AX)	// foog.sched.pc = caller's PC
LEAQ	fn+0(FP), BX			// caller's SPã€‚
MOVQ	BX, (g_sched+gobuf_sp)(AX)	// foog.sched.sp = caller's SP
MOVQ	AX, (g_sched+gobuf_g)(AX)	// foog.sched.g = foog
MOVQ	BP, (g_sched+gobuf_bp)(AX)	// foog.sched.bp = bp

    // åˆ‡æ¢åˆ°m.g0å’Œå®ƒçš„æ ˆï¼Œè°ƒç”¨fnã€‚
MOVQ	g(CX), BX			// æ­¤å¤„ bx ä¸­å­˜å‚¨çš„æ˜¯foog
MOVQ	g_m(BX), BX			// bx = foog.m
MOVQ	m_g0(BX), SI			// si = m.g0
CMPQ	SI, AX				// if g == m-&gt;g0 call badmcall
JNE	3(PC)				// ä¸Šé¢çš„ç»“æœä¸ç›¸ç­‰å°±è·³è½¬åˆ°ä¸‹é¢ç¬¬ä¸‰è¡Œã€‚
MOVQ	$runtimeÂ·badmcall(SB), AX
JMP	AX
MOVQ	SI, g(CX)			// g = m-&gt;g0ã€‚m.g0è®¾ç½®åˆ°tls
MOVQ	(g_sched+gobuf_sp)(SI), SP	// sp = m-&gt;g0-&gt;sched.spã€‚è®¾ç½®g0æ ˆ.
PUSHQ	AX				// fnçš„å‚æ•°å‹æ ˆï¼Œax = foog
MOVQ	DI, DX
MOVQ	0(DI), DI			// è¯»å– funcval ç»“æ„çš„ç¬¬ä¸€ä¸ªæˆå‘˜ï¼Œä¹Ÿå°±æ˜¯ funcval.fnï¼Œæ­¤å¤„æ˜¯goexit0ã€‚
CALL	DI				// è°ƒç”¨ goexit0(foog)ã€‚
POPQ	AX
MOVQ	$runtimeÂ·badmcall2(SB), AX
JMP	AX
RET åœ¨æ­¤åœºæ™¯ä¸‹ï¼Œmcallåšäº†ä»¥ä¸‹å·¥ä½œï¼šä¿å­˜foogçš„ä¸Šä¸‹æ–‡ã€‚åˆ‡æ¢åˆ°g0åŠå…¶æ ˆï¼Œè°ƒç”¨ä¼ å…¥çš„æ–¹æ³•ï¼Œå¹¶å°†foogä½œä¸ºå‚æ•°ã€‚
</code></pre></div></div>

<p>å¯ä»¥çœ‹åˆ°mcallä¸gogoçš„ä½œç”¨æ­£å¥½ç›¸åï¼š</p>

<p>gogoå®ç°äº†ä»g0åˆ‡æ¢åˆ°æŸä¸ªgoroutineï¼Œæ‰§è¡Œå…³è”å‡½æ•°ã€‚
mcallå®ç°äº†ä¿å­˜æŸä¸ªgoroutineï¼Œåˆ‡æ¢åˆ°g0åŠå…¶æ ˆï¼Œå¹¶è°ƒç”¨fnå‡½æ•°ï¼Œå…¶å‚æ•°å°±æ˜¯è¢«ä¿å­˜çš„goroutineæŒ‡é’ˆã€‚
goexit0#
Copy
func goexit0(gp *g) {
	<em>g</em> := getg()	// g0</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>casgstatus(gp, _Grunning, _Gdead)	// æ›´æ”¹gpçŠ¶æ€ä¸º_Gdead
if isSystemGoroutine(gp, false) {
	atomic.Xadd(&amp;sched.ngsys, -1)
}
    // ä¸‹é¢çš„ä¸€æ®µå°±æ˜¯æ¸…é›¶gpçš„å±æ€§
gp.m = nil
locked := gp.lockedm != 0
gp.lockedm = 0
_g_.m.lockedg = 0
gp.preemptStop = false
gp.paniconfault = false
gp._defer = nil // should be true already but just in case.
gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.
gp.writebuf = nil
gp.waitreason = 0
gp.param = nil
gp.labels = nil
gp.timer = nil
......
dropg()				// è§£ç»‘gpä¸å½“å‰mã€‚_g_.m.curg.m = nil ; _g_.m.curg = nil ã€‚
    ......
gfput(_g_.m.p.ptr(), gp)	// æ”¾å…¥ç©ºé—²åˆ—è¡¨ã€‚å¦‚æœæœ¬åœ°é˜Ÿåˆ—å¤ªå¤šï¼Œä¼šè½¬ç§»ä¸€éƒ¨åˆ†åˆ°å…¨å±€é˜Ÿåˆ—ã€‚
......
schedule()			// é‡æ–°è°ƒåº¦ } goexit0åšäº†ä»¥ä¸‹å·¥ä½œï¼š
</code></pre></div></div>

<p>å°†gpå±æ€§æ¸…é›¶ä¸mè§£ç»‘
gfput æ”¾å…¥ç©ºé—²åˆ—è¡¨
schedule é‡æ–°è°ƒåº¦
å·¥ä½œçº¿ç¨‹çš„æ‰§è¡Œæµç¨‹ä¸è°ƒåº¦å¾ªç¯#
ä»¥ä¸‹ç»™å‡ºä¸€ä¸ªå·¥ä½œçº¿ç¨‹çš„æ‰§è¡Œæµç¨‹ç®€å›¾ï¼š</p>

<p>å¯ä»¥çœ‹åˆ°å·¥ä½œçº¿ç¨‹çš„æ‰§è¡Œæ˜¯ä»mstartå¼€å§‹çš„ã€‚schedule-&gt;â€¦â€¦-&gt;goexit0-&gt;scheduleå½¢æˆäº†ä¸€ä¸ªè°ƒåº¦å¾ªç¯ã€‚</p>

<p>é«˜åº¦æ¦‚æ‹¬ä¸€ä¸‹æ‰§è¡Œæµç¨‹ä¸è°ƒåº¦å¾ªç¯ï¼š</p>

<p>mstartï¼šä¸»è¦æ˜¯è®¾ç½®g0.stackguard0ï¼Œg0.stackguard1ã€‚
mstart1ï¼šè°ƒç”¨saveä¿å­˜callerpcå’Œcallerpcåˆ°g0.schedã€‚ç„¶åè°ƒç”¨scheduleå¼€å§‹è°ƒåº¦å¾ªç¯ã€‚
scheduleï¼šè·å¾—ä¸€ä¸ªå¯æ‰§è¡Œçš„gã€‚ä¸‹é¢ç”¨gpä»£æŒ‡ã€‚
execute(gp <em>g, inheritTime bool)ï¼šç»‘å®šgpä¸å½“å‰mï¼ŒçŠ¶æ€æ”¹ä¸º_Grunningã€‚
gogo(buf *gobuf)ï¼šåŠ è½½gpçš„ä¸Šä¸‹æ–‡ï¼Œè·³è½¬åˆ°buf.pcæŒ‡å‘çš„å‡½æ•°ã€‚
æ‰§è¡Œbuf.pcæŒ‡å‘å‡½æ•°ã€‚
goexit-&gt;goexit1ï¼šè°ƒç”¨mcall(goexit0)ã€‚
mcall(fn func(</em>g))ï¼šä¿å­˜å½“å‰gï¼ˆä¹Ÿå°±æ˜¯gpï¼‰çš„ä¸Šä¸‹æ–‡ï¼›åˆ‡æ¢åˆ°g0åŠå…¶æ ˆï¼Œè°ƒç”¨fnï¼Œå‚æ•°ä¸ºgpã€‚
goexit0(gp *g)ï¼šæ¸…é›¶gpçš„å±æ€§ï¼ŒçŠ¶æ€_Grunningæ”¹ä¸º_Gdeadï¼›dropgè§£ç»‘må’Œgpï¼›gfputæ”¾å…¥é˜Ÿåˆ—ï¼›scheduleé‡æ–°è°ƒåº¦ã€‚
<!-- more -->
Linuxç³»ç»Ÿè°ƒç”¨#
æ¦‚å¿µï¼šç³»ç»Ÿè°ƒç”¨ä¸ºç”¨æˆ·æ€è¿›ç¨‹æä¾›äº†ç¡¬ä»¶çš„æŠ½è±¡æ¥å£ã€‚å¹¶ä¸”æ˜¯ç”¨æˆ·ç©ºé—´è®¿é—®å†…æ ¸çš„å”¯ä¸€æ‰‹æ®µï¼Œé™¤å¼‚å¸¸å’Œé™·å…¥å¤–ï¼Œå®ƒä»¬æ˜¯å†…æ ¸å”¯ä¸€çš„åˆæ³•å…¥å£ã€‚ä¿è¯ç³»ç»Ÿçš„å®‰å…¨å’Œç¨³å®šã€‚</p>

<p>è°ƒç”¨å·ï¼šåœ¨Linuxä¸­ï¼Œæ¯ä¸ªç³»ç»Ÿè°ƒç”¨è¢«èµ‹äºˆä¸€ä¸ªç‹¬ä¸€æ— äºŒçš„ç³»ç»Ÿè°ƒç”¨å·ã€‚å½“ç”¨æˆ·ç©ºé—´çš„è¿›ç¨‹æ‰§è¡Œä¸€ä¸ªç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œä¼šä½¿ç”¨è°ƒç”¨å·æŒ‡æ˜ç³»ç»Ÿè°ƒç”¨ã€‚</p>

<p>syscallæŒ‡ä»¤ï¼šå› ä¸ºç”¨æˆ·ä»£ç ç‰¹æƒçº§è¾ƒä½ï¼Œæ— æƒè®¿é—®éœ€è¦æœ€é«˜ç‰¹æƒçº§æ‰èƒ½è®¿é—®çš„å†…æ ¸åœ°å€ç©ºé—´çš„ä»£ç å’Œæ•°æ®ã€‚æ‰€ä»¥éœ€è¦ç‰¹æ®ŠæŒ‡ä»¤ï¼Œåœ¨golangä¸­æ˜¯syscallã€‚</p>

<p>å‚æ•°è®¾ç½®#
x86-64ä¸­é€šè¿‡syscallæŒ‡ä»¤æ‰§è¡Œç³»ç»Ÿè°ƒç”¨çš„å‚æ•°è®¾ç½®</p>

<p>raxå­˜æ”¾ç³»ç»Ÿè°ƒç”¨å·ï¼Œè°ƒç”¨è¿”å›å€¼ä¹Ÿä¼šæ”¾åœ¨raxä¸­
å½“ç³»ç»Ÿè°ƒç”¨å‚æ•°å°äºç­‰äº6ä¸ªæ—¶ï¼Œå‚æ•°åˆ™é¡»æŒ‰é¡ºåºæ”¾åˆ°å¯„å­˜å™¨ rdiï¼Œrsiï¼Œrdxï¼Œr10ï¼Œr8ï¼Œr9ä¸­ã€‚
å¦‚æœç³»ç»Ÿè°ƒç”¨çš„å‚æ•°æ•°é‡å¤§äº6ä¸ªï¼Œéœ€å°†å‚æ•°ä¿å­˜åœ¨ä¸€å—è¿ç»­çš„å†…å­˜ä¸­ï¼Œå¹¶å°†åœ°å€å­˜å…¥rbxä¸­ã€‚
Golangä¸­è°ƒç”¨ç³»ç»Ÿè°ƒç”¨#
ç»™ä¸ªç®€å•çš„ä¾‹å­ã€‚</p>

<p>Copy
package main</p>

<p>import (
	â€œfmtâ€
	â€œosâ€
)</p>

<p>func main() {
	f, _ := os.Open(â€œread.goâ€)
	buf := make([]byte, 1000)
	f.Read(buf)
	fmt.Printf(â€œ%sâ€, buf)
}
é€šè¿‡ IDE è·Ÿè¸ªå¾—åˆ°è°ƒç”¨è·¯å¾„ï¼š</p>

<p>Copy
os/file.goï¼š(<em>File).Read() -&gt; os/file_unix.goï¼š(</em>File).read() -&gt; internal/poll/fd_unix.goï¼š(*File).pfd.Read()</p>

<p>-&gt;syscall/syscall_unix.goï¼šRead() -&gt; syscall/zsyscall_linux_amd64.goï¼šread() -&gt; syscall/syscall_unix.goï¼šSyscall()</p>

<p>// syscall/zsyscall_linux_amd64.go
func read(fd int, p []byte) (n int, err error) {
        â€¦â€¦
	r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(_p0), uintptr(len(p)))
        â€¦â€¦
}
å¯ä»¥çœ‹åˆ° f.Read(buf) æœ€ç»ˆè°ƒç”¨äº† syscall/syscall_unix.go æ–‡ä»¶ä¸­çš„ Syscall å‡½æ•°ã€‚æˆ‘ä»¬å¿½ç•¥ä¸­é—´çš„å…·ä½“æ‰§è¡Œé€»è¾‘ã€‚</p>

<p>SYS_READ å®šä¹‰çš„æ˜¯ read çš„ç³»ç»Ÿè°ƒç”¨å·ï¼Œå®šä¹‰åœ¨ syscall/zsysnum_linux_amd64.goã€‚</p>

<p>Copy
package syscall</p>

<p>const (
	SYS_READ                   = 0
	SYS_WRITE                  = 1
	SYS_OPEN                   = 2
	SYS_CLOSE                  = 3
	SYS_STAT                   = 4
	SYS_FSTAT                  = 5
        â€¦â€¦
ï¼‰
Syscallç³»åˆ—å‡½æ•°#
è™½ç„¶åœ¨ä¸Šé¢çœ‹åˆ°äº† Syscall å‡½æ•°ï¼Œä½†æ‰§è¡Œç³»ç»Ÿè°ƒç”¨çš„é˜²æ­¢å¹¶ä¸çŸ¥é“å®ƒä¸€ä¸ªã€‚å®ƒä»¬çš„å®šä¹‰å¦‚ä¸‹ï¼š</p>

<p>Copy
// src/syscall/syscall_unix.go</p>

<p>func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)
func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)
func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)
func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)
Syscall ä¸ Syscall6 çš„åŒºåˆ«ï¼šåªæ˜¯å‚æ•°ä¸ªæ•°çš„ä¸åŒï¼Œå…¶ä»–éƒ½ç›¸åŒã€‚</p>

<p>Syscall ä¸ RawSyscall çš„åŒºåˆ«ï¼šSyscall å¼€å§‹ä¼šè°ƒç”¨ runtimeÂ·entersyscall ï¼Œç»“æŸæ—¶ä¼šè°ƒç”¨ runtimeÂ·exitsyscallï¼›è€Œ RawSyscall æ²¡æœ‰ã€‚è¿™æ„å‘³ç€ Syscall æ˜¯å—è°ƒåº¦å™¨æ§åˆ¶çš„ï¼ŒRawSyscallä¸å—ã€‚å› æ­¤ RawSyscall å¯èƒ½ä¼šé€ æˆé˜»å¡ã€‚</p>

<p>ä¸‹é¢æ¥çœ‹ä¸€ä¸‹æºä»£ç ï¼š</p>

<p>Copy
// src/syscall/asm_linux_amd64.s
// func Syscall(trap int64, a1, a2, a3 uintptr) (r1, r2, err uintptr);
// Trap # in AX, args in DI SI DX R10 R8 R9, return in AX DX
// Note that this differs from â€œstandardâ€ ABI convention, which
// would pass 4th arg in CX, not R10.</p>

<p>TEXT Â·Syscall(SB),NOSPLIT,$0-56
	CALL	runtimeÂ·entersyscall(SB)	// è¿›å…¥ç³»ç»Ÿè°ƒç”¨
        // å‡†å¤‡å‚æ•°ï¼Œæ‰§è¡Œç³»ç»Ÿè°ƒç”¨
	MOVQ	a1+8(FP), DI
	MOVQ	a2+16(FP), SI
	MOVQ	a3+24(FP), DX
	MOVQ	trap+0(FP), AX			// syscall entry
	SYSCALL
	CMPQ	AX, $0xfffffffffffff001		// å¯¹æ¯”è¿”å›ç»“æœ
	JLS	ok
	MOVQ	$-1, r1+32(FP)
	MOVQ	$0, r2+40(FP)
	NEGQ	AX
	MOVQ	AX, err+48(FP)
	CALL	runtimeÂ·exitsyscall(SB)		// é€€å‡ºç³»ç»Ÿè°ƒç”¨
	RET
ok:
	MOVQ	AX, r1+32(FP)
	MOVQ	DX, r2+40(FP)
	MOVQ	$0, err+48(FP)
	CALL	runtimeÂ·exitsyscall(SB)		// é€€å‡ºç³»ç»Ÿè°ƒç”¨
	RET</p>

<p>// func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)
TEXT Â·Syscall6(SB),NOSPLIT,$0-80
	CALL	runtimeÂ·entersyscall(SB)
	MOVQ	a1+8(FP), DI
	MOVQ	a2+16(FP), SI
	MOVQ	a3+24(FP), DX
	MOVQ	a4+32(FP), R10
	MOVQ	a5+40(FP), R8
	MOVQ	a6+48(FP), R9
	MOVQ	trap+0(FP), AX	// syscall entry
	SYSCALL
	CMPQ	AX, $0xfffffffffffff001
	JLS	ok6
	MOVQ	$-1, r1+56(FP)
	MOVQ	$0, r2+64(FP)
	NEGQ	AX
	MOVQ	AX, err+72(FP)
	CALL	runtimeÂ·exitsyscall(SB)
	RET
ok6:
	MOVQ	AX, r1+56(FP)
	MOVQ	DX, r2+64(FP)
	MOVQ	$0, err+72(FP)
	CALL	runtimeÂ·exitsyscall(SB)
	RET</p>

<p>// func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)
TEXT Â·RawSyscall(SB),NOSPLIT,$0-56
	MOVQ	a1+8(FP), DI
	MOVQ	a2+16(FP), SI
	MOVQ	a3+24(FP), DX
	MOVQ	trap+0(FP), AX	// syscall entry
	SYSCALL
	CMPQ	AX, $0xfffffffffffff001
	JLS	ok1
	MOVQ	$-1, r1+32(FP)
	MOVQ	$0, r2+40(FP)
	NEGQ	AX
	MOVQ	AX, err+48(FP)
	RET
ok1:
	MOVQ	AX, r1+32(FP)
	MOVQ	DX, r2+40(FP)
	MOVQ	$0, err+48(FP)
	RET</p>

<p>// func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)
TEXT Â·RawSyscall6(SB),NOSPLIT,$0-80
        â€¦â€¦
	RET
ç³»ç»Ÿè°ƒç”¨å‰å‡½æ•°ï¼ˆentersyscall -&gt; reentersyscallï¼‰#
åœ¨æ‰§è¡Œç³»ç»Ÿè°ƒç”¨å‰è°ƒç”¨ entersyscall å’Œ reentersyscallï¼Œreentersyscallçš„ä¸»è¦åŠŸèƒ½ï¼š</p>

<p>å› ä¸ºè¦å¼€å§‹ç³»ç»Ÿè°ƒç”¨ï¼Œæ‰€ä»¥å½“å‰Gå’Œå’ŒPçš„çŠ¶æ€åˆ†åˆ«å˜ä¸ºäº† _Gsyscall å’Œ _Psyscall
è€ŒPä¸ä¼šç­‰å¾…Mï¼Œæ‰€ä»¥På’ŒMç›¸äº’è§£ç»‘
ä½†æ˜¯Mä¼šä¿ç•™Påˆ° m.oldp ä¸­ï¼Œåœ¨ç³»ç»Ÿè°ƒç”¨ç»“æŸåå°è¯•ä¸Pé‡æ–°ç»‘å®šã€‚
æœ¬èŠ‚åŠåé¢ä¼šæ¶‰åŠåˆ°ä¸€äº›ä¹‹å‰åˆ†æè¿‡çš„å‡½æ•°ï¼Œè¿™é‡Œç»™å‡ºé“¾æ¥ï¼Œå°±ä¸é‡å¤åˆ†æäº†ã€‚</p>

<p>wirep
mcall
Copy
func entersyscall() {
	reentersyscall(getcallerpc(), getcallersp())
}
func reentersyscall(pc, sp uintptr) {
	<em>g</em> := getg()
	<em>g</em>.m.locks++
	<em>g</em>.stackguard0 = stackPreempt
	<em>g</em>.throwsplit = true</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Leave SP around for GC and traceback.
save(pc, sp)
_g_.syscallsp = sp
_g_.syscallpc = pc
casgstatus(_g_, _Grunning, _Gsyscall)	// å½“å‰gçš„çŠ¶æ€ç”± _Grunning æ”¹ä¸º _Gsyscall
......
_g_.m.syscalltick = _g_.m.p.ptr().syscalltick
_g_.sysblocktraced = true
_g_.m.mcache = nil
pp := _g_.m.p.ptr()
pp.m = 0				// å½“å‰ p è§£ç»‘ m
_g_.m.oldp.set(pp)			// å°†å½“å‰ p èµ‹å€¼ç»™ m.oldpã€‚ä¼šåœ¨ exitsyscall ä¸­ç”¨åˆ°ã€‚
_g_.m.p = 0				// å½“å‰ m è§£ç»‘ p
atomic.Store(&amp;pp.status, _Psyscall)	// å°†å½“å‰ p çš„çŠ¶æ€æ”¹ä¸º _Psyscall
    ......
_g_.m.locks-- }
</code></pre></div></div>

<p>ç³»ç»Ÿè°ƒç”¨é€€å‡ºåå‡½æ•°ï¼ˆexitsyscallï¼‰#
ä¸»è¦åŠŸèƒ½æ˜¯ï¼š</p>

<p>å…ˆå°è¯•ç»‘å®šoldpï¼Œå¦‚æœä¸å…è®¸ï¼Œåˆ™ç»‘å®šä»»æ„ç©ºé—²P
æœªèƒ½ç»‘å®šPï¼Œåˆ™è§£ç»‘Gå’ŒMï¼›ç¡çœ å·¥ä½œçº¿ç¨‹ï¼›é‡æ–°è°ƒåº¦ã€‚
Copy
func exitsyscall() {
	<em>g</em> := getg()
        â€¦â€¦
	<em>g</em>.waitsince = 0
	oldp := <em>g</em>.m.oldp.ptr()	// reentersyscall å‡½æ•°ä¸­å­˜å‚¨çš„P
	<em>g</em>.m.oldp = 0
	if exitsyscallfast(oldp) {	// å°è¯•ç»™å½“å‰Mç»‘å®šä¸ªPï¼Œä¸‹æœ‰åˆ†æã€‚ç»‘å®šæˆåŠŸåæ‰§è¡Œ if ä¸­çš„è¯­å¥ã€‚
		<em>g</em>.m.p.ptr().syscalltick++
		casgstatus(<em>g</em>, <em>Gsyscall, _Grunning) // æ›´æ”¹Gçš„çŠ¶æ€
		_g</em>.syscallsp = 0
		<em>g</em>.m.locksâ€“
		if <em>g</em>.preempt {
			<em>g</em>.stackguard0 = stackPreempt
		} else {
			<em>g</em>.stackguard0 = <em>g</em>.stack.lo + <em>StackGuard
		}
		_g</em>.throwsplit = false
		return
	}
	â€¦â€¦
	mcall(exitsyscall0)	// ä¸‹æœ‰åˆ†æ
	â€¦â€¦
}
å°è¯•ä¸ºå½“å‰Mç»‘å®šPï¼ˆexitsyscallfastï¼‰#
è¯¥å‡½æ•°çš„ä¸»è¦ç›®çš„æ˜¯å°è¯•ä¸ºå½“å‰Mç»‘å®šä¸€ä¸ªPï¼Œåˆ†ä¸ºä¸¤ç§æƒ…å†µã€‚</p>

<p>ç¬¬ä¸€ï¼šå¦‚æœoldpï¼ˆä¹Ÿå°±æ˜¯å½“å‰Mçš„å…ƒé…ï¼‰å­˜åœ¨ï¼Œå¹¶ä¸”çŠ¶æ€å¯ä»¥ä» _Psyscall å˜æ›´åˆ° _Pidleï¼Œåˆ™æ­¤Pä¸Mç›¸äº’ç»‘å®šï¼Œè¿”å›trueã€‚</p>

<p>ç¬¬äºŒï¼šoldpæ¡ä»¶ä¸å…è®¸ï¼Œåˆ™å°è¯•è·å–ä»»ä½•ç©ºé—²çš„På¹¶ä¸å½“å‰Mç»‘å®šã€‚å…·ä½“å®ç°æ˜¯ï¼šexitsyscallfast_pidle è°ƒç”¨ pidlegetï¼Œä¸ä¸ºnilï¼Œåˆ™è°ƒç”¨ acquirepã€‚</p>

<p>Copy
func exitsyscallfast(oldp *p) bool {
	<em>g</em> := getg()
	// å°è¯•ä¸oldpç»‘å®š
	if oldp != nil &amp;&amp; oldp.status == <em>Psyscall &amp;&amp; atomic.Cas(&amp;oldp.status, _Psyscall, _Pidle) {
		// Thereâ€™s a cpu for us, so we can run.
		wirep(oldp)
		exitsyscallfast_reacquired()
		return true
	}
	// å°è¯•è·å–ä»»ä½•ç©ºé—²çš„P
	if sched.pidle != 0 {
		var ok bool
		systemstack(func() {
			ok = exitsyscallfast_pidle()
                         â€¦â€¦
		})
		if ok {
			return true
		}
	}
	return false
}
Mè§£ç»‘Gï¼Œé‡æ–°è°ƒåº¦ï¼ˆmcall(exitsyscall0)ï¼‰#
Copy
func exitsyscall0(gp *g) {
	_g</em> := getg()	// g0
	casgstatus(gp, <em>Gsyscall, _Grunnable)
	dropg()	// è§£ç»‘ gp ä¸ M
	lock(&amp;sched.lock)
	var _p</em> *p
	if schedEnabled(<em>g</em>) {
		<em>p</em> = pidleget()
	}
	if <em>p</em> == nil {
		globrunqput(gp)	// æœªè·å–åˆ°ç©ºé—²Pï¼Œå°†gpæ”¾å…¥sched.runq
	} else if atomic.Load(&amp;sched.sysmonwait) != 0 {
		atomic.Store(&amp;sched.sysmonwait, 0)
		notewakeup(&amp;sched.sysmonnote)
	}
	unlock(&amp;sched.lock)
	if <em>p</em> != nil {
		acquirep(<em>p</em>)
		execute(gp, false) // æœ‰Pï¼Œä¸å½“å‰Mç»‘å®šï¼Œæ‰§è¡Œgpï¼Œè¿›å…¥è°ƒåº¦å¾ªç¯ã€‚
	}
	if <em>g</em>.m.lockedg != 0 {
		// Wait until another thread schedules gp and so m again.
		stoplockedm()
		execute(gp, false) // Never returns.
	}
	stopm()		// æ²¡æœ‰æ–°å·¥ä½œä¹‹å‰åœæ­¢Mçš„æ‰§è¡Œã€‚ç¡çœ å·¥ä½œçº¿ç¨‹ã€‚åœ¨è·å¾—På¹¶ä¸”å”¤é†’ä¹‹åä¼šç»§ç»­æ‰§è¡Œ
	schedule()	// èƒ½èµ°åˆ°è¿™é‡Œè¯´æ˜Mä»¥è·å¾—Pï¼Œå¹¶ä¸”è¢«å”¤é†’ï¼Œå¯ä»¥å¯»æ‰¾ä¸€ä¸ªGï¼Œç»§ç»­è°ƒåº¦äº†ã€‚
}
exitsyscall0 -&gt; stopm#
ä¸»è¦å†…å®¹æ˜¯å°† M æ”¾å› sched.midleï¼Œå¹¶é€šè¿‡futexç³»ç»Ÿè°ƒç”¨æŒ‚èµ·çº¿ç¨‹ã€‚</p>

<p>Copy
func stopm() {
	<em>g</em> := getg()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if _g_.m.locks != 0 {
	throw("stopm holding locks")
}
if _g_.m.p != 0 {
	throw("stopm holding p")
}
if _g_.m.spinning {
	throw("stopm spinning")
}

lock(&amp;sched.lock)
mput(_g_.m)		// M æ”¾å› sched.midle
unlock(&amp;sched.lock)
notesleep(&amp;_g_.m.park)	// notesleep-&gt;futexsleep-&gt;runtime.futex-&gt;futexç³»ç»Ÿè°ƒç”¨ã€‚
noteclear(&amp;_g_.m.park)
acquirep(_g_.m.nextp.ptr())
_g_.m.nextp = 0 } æ€»ç»“# åœ¨ç³»ç»Ÿè°ƒç”¨ä¹‹å‰è°ƒç”¨ï¼šentersyscallã€‚
</code></pre></div></div>

<p>æ›´æ”¹På’ŒGçš„çŠ¶æ€ä¸º_Psyscallå’Œ_Gsyscall
è§£ç»‘På’ŒM
å°†På­˜å…¥m.oldp
åœ¨ç³»ç»Ÿè°ƒç”¨ä¹‹åè°ƒç”¨ï¼šexitsyscallã€‚</p>

<p>exitsyscallfastï¼šå°è¯•ä¸ºå½“å‰Mç»‘å®šä¸€ä¸ªPï¼ŒæˆåŠŸäº†ä¼šreturné€€å‡ºexitsyscallã€‚</p>

<p>å¦‚æœoldpç¬¦åˆæ¡ä»¶åˆ™wirep
å¦åˆ™å°è¯•è·å–ä»»ä½•ç©ºé—²çš„På¹¶ä¸å½“å‰Mç»‘å®š
exitsyscall0ï¼šè¿›å…¥è°ƒåº¦å¾ªç¯</p>

<p>æ›´æ”¹gpçŠ¶æ€ä¸º_Grunnable
dropgè§£ç»‘gpå’ŒM
å°è¯•è·å–pï¼Œè·å–åˆ°åˆ™acquirepç»‘å®šPå’ŒMï¼›executeè¿›å…¥è°ƒåº¦å¾ªç¯ã€‚
æœªè·å–åˆ°åˆ™globrunqputå°†gpæ”¾å…¥sched.runqï¼›stopmå°†Mæ”¾å…¥sched.midleã€æŒ‚èµ·å·¥ä½œçº¿ç¨‹ï¼›æ­¤Mè¢«å”¤é†’åscheduleè¿›å…¥è°ƒåº¦å¾ªç¯ã€‚
https://www.cnblogs.com/flhs/p/12709962.html
https://www.cnblogs.com/flhs/p/12682881.html</p>
:ET