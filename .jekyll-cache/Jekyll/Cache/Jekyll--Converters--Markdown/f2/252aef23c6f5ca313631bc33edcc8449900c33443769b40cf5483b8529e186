I"ˆz<p>https://github.com/tidwall/evio
https://github.com/Allenxuxu/eviop/
https://github.com/Allenxuxu/gev
<!-- more -->
æœ€è¿‘ç¿»äº† evio çš„æºç ï¼Œå‘ç°ä¸€äº›é—®é¢˜ï¼Œä¸»è¦é›†ä¸­åœ¨ linux å¹³å° epoll ä¸Šå’Œè¯»å†™çš„å¤„ç†ã€‚</p>

<p>ç”¨æ¥å”¤é†’ epoll çš„ eventfd å†™å…¥æ•°æ®æ²¡æœ‰è¯»å‡º
listen çš„ fd æ³¨å†Œåˆ°æ‰€æœ‰äº‹ä»¶å¾ªç¯ï¼Œepoll çš„æƒŠç¾¤é—®é¢˜
loopWrite åœ¨å†…æ ¸ç¼“å†²åŒºæ»¡ï¼Œæ— æ³•ä¸€æ¬¡å†™å…¥æ—¶ï¼Œå‡ºç°å†™å…¥æ•°æ®ä¸¢å¤±
eventfd çš„ä½¿ç”¨é—®é¢˜
åœ¨ internal/internal_linux.go ä¸­å°è£…äº† epoll çš„ä½¿ç”¨ API ã€‚</p>

<p>// Poll â€¦
type Poll struct {
	fd    int // epoll fd
	wfd   int // wake fd
	notes noteQueue
}
1
2
3
4
5
6
åœ¨ OpenPoll æ—¶ï¼Œä¼šåˆ›å»ºä¸€ä¸ª eventfd å¹¶å°† fd èµ‹å€¼ç»™ Poll çš„ wfd æˆå‘˜ï¼Œ å¹¶ä¸”æ³¨å†Œåˆ° epoll ç›‘å¬å¯è¯»äº‹ä»¶ã€‚</p>

<p>å½“éœ€è¦å”¤é†’å½“å‰ epoll æ—¶ï¼Œæä¾›äº† Trigger æ–¹æ³•</p>

<p>// Trigger â€¦
func (p *Poll) Trigger(note interface{}) error {
	p.notes.Add(note)
	_, err := syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1})
	return err
}
1
2
3
4
5
6
è¿™æ˜¯å¾€åˆšåˆšæåˆ°çš„ eventfd ä¸­å†™å…¥å…«å­—èŠ‚æ•°æ®ï¼Œæ­¤æ—¶ epol lä¼šè¢«å”¤é†’ epoll_wait å‡½æ•°è¿”å›ã€‚ ä½†æ˜¯ï¼Œevio å¹¶æ²¡æœ‰å»æŠŠ 8 ä¸ªå­—èŠ‚çš„æ•°æ®è¯»å–å‡ºæ¥ï¼Œå†…æ ¸ç¼“å†²åŒºä¼šä¸æ–­ç§¯å‹ï¼Œå¹¶ä¸” evio ä½¿ç”¨çš„æ˜¯ epoll çš„LTæ¨¡å¼ï¼ˆé»˜è®¤æ¨¡å¼ï¼‰ï¼Œåªè¦ç¼“å†²åŒºä¸­æœ‰æ•°æ®ï¼Œepoll å°±ä¼šä¸æ–­å”¤é†’ã€‚è¿™åº”è¯¥ç®—æ˜¯ä¸€ä¸ª bug å§ã€‚</p>

<p>listen çš„ fd æ³¨å†Œåˆ°æ‰€æœ‰äº‹ä»¶å¾ªç¯ï¼Œepoll çš„æƒŠç¾¤é—®é¢˜
evio å¯ä»¥æŒ‡å®šå¯åŠ¨å¤šä¸ªäº‹ä»¶å¾ªç¯ã€‚evio å°† listen fd æ³¨å†Œåˆ°æ¯ä¸€ä¸ªäº‹ä»¶å¾ªç¯ä¸­ï¼ˆepollï¼‰ç›‘å¬å¯è¯»äº‹ä»¶ï¼Œæ‰€ä»¥å½“ä¸€ä¸ªè¿æ¥åˆ°æ¥æ—¶ï¼Œæ‰€æœ‰çš„äº‹ä»¶å¾ªç¯éƒ½ä¼šå”¤é†’ã€‚</p>

<p>// create loops locally and bind the listeners.
	for i := 0; i &lt; numLoops; i++ {
		l := &amp;loop{
			idx:     i,
			poll:    internal.OpenPoll(),
			packet:  make([]byte, 0xFFFF),
			fdconns: make(map[int]*conn),
		}
		for _, ln := range listeners {
			l.poll.AddRead(ln.fd)
		}
		s.loops = append(s.loops, l)
	}
	// start loops in background
	s.wg.Add(len(s.loops))
	for _, l := range s.loops {
		go loopRun(s, l)
	}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
è¿™å¹¶ä¸æ˜¯ä¸€ä¸ª bug ï¼Œå› ä¸ºæœ€ç»ˆåªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥acceptè°ƒç”¨è¿”å›æˆåŠŸï¼Œå…¶ä»–çº¿ç¨‹ï¼ˆåç¨‹ï¼‰çš„acceptå‡½æ•°è°ƒç”¨è¿”å›EAGAINé”™è¯¯ ï¼Œä½œè€…ä¹Ÿåšå‡ºäº†å¤„ç†ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nfd, sa, err := syscall.Accept(fd)
if err != nil {
	if err == syscall.EAGAIN {
		return nil
	}
	return err
} 1 2 3 4 5 6 7 å¹¶ä¸”ä½œè€…è¿˜åˆ©ç”¨æ¯ä¸ªäº‹ä»¶å¾ªç¯éƒ½ä¼šè¢«å”¤é†’ï¼Œæ¥åšå®¢æˆ·ç«¯è¿æ¥çš„è´Ÿè½½å‡è¡¡ç­–ç•¥ã€‚
</code></pre></div></div>

<p>LeastConnections : å½“å­˜åœ¨å…¶ä»–äº‹ä»¶å¾ªç¯çš„æ³¨å†Œçš„å®¢æˆ·ç«¯è¿æ¥æ•°æ¯”å½“å‰äº‹ä»¶å¾ªç¯çš„è¿æ¥æ•°å°‘çš„æ—¶å€™ï¼Œç›´æ¥ return nil ã€‚å½“æœ‰ä¸¤ä¸ªæœ€ä¸‹è¿æ¥æ•°ç›¸åŒçš„æ—¶å€™ï¼Œä¹Ÿæ²¡å…³ç³»ï¼Œå› ä¸º accept ä¼šä¿è¯åªæœ‰ä¸€ä¸ªå¯ä»¥æˆåŠŸã€‚</p>

<p>RoundRobinï¼š åŸç†ä¹Ÿæ˜¯ä¸€æ ·ï¼Œæ¯ä¸ªäº‹ä»¶å¾ªç¯éƒ½ä¼šå»åˆ¤æ–­ int(atomic.LoadUintptr(&amp;s.accepted)) % len(s.loops) ï¼Œè½®åˆ°è‡ªå·±äº†ï¼Œæ‰ç»§ç»­æ‰§è¡Œï¼Œå¦åˆ™ return nil ã€‚</p>

<p>if ln.fd == fd {
	if len(s.loops) &gt; 1 {
		switch s.balance {
		case LeastConnections:
			n := atomic.LoadInt32(&amp;l.count)
			for _, lp := range s.loops {
				if lp.idx != l.idx {
					if atomic.LoadInt32(&amp;lp.count) &lt; n {
						return nil // do not accept
					}
				}
			}
		case RoundRobin:
			idx := int(atomic.LoadUintptr(&amp;s.accepted)) % len(s.loops)
			if idx != l.idx {
				return nil // do not accept
			}
			atomic.AddUintptr(&amp;s.accepted, 1)
		}
	}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
è¿™æ ·çš„åšæ³•æ²¡æœ‰é—®é¢˜ï¼Œä½†æ˜¯ä¸ªäººè§‰å¾— muduo çš„åšæ³•ä¼¼ä¹æ›´å¥½ã€‚</p>

<p>loopWrite åœ¨å†…æ ¸ç¼“å†²åŒºæ»¡ï¼Œæ— æ³•ä¸€æ¬¡å†™å…¥æ—¶ï¼Œå‡ºç°å†™å…¥æ•°æ®ä¸¢å¤±
func loopWrite(s *server, l *loop, c *conn) error {
	if s.events.PreWrite != nil {
		s.events.PreWrite()
	}
	n, err := syscall.Write(c.fd, c.out)
	if err != nil {
		if err == syscall.EAGAIN {
			return nil
		}
		return loopCloseConn(s, l, c, err)
	}
	if n == len(c.out) {
		c.out = nil
	} else {
		c.out = c.out[n:]
	}
	if len(c.out) == 0 &amp;&amp; c.action == None {
		l.poll.ModRead(c.fd)
	}
	return nil
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
å½“å†…æ ¸ç¼“å†²åŒºæ»¡æ—¶ï¼Œ syscall.Write(c.fd, c.out) ä¼šæ— æ³•å…¨éƒ¨å†™å…¥ï¼Œå¯ä»¥é€šè¿‡è¿”å›å€¼å¾—åˆ°å·²ç»å†™å…¥çš„ä¸ªæ•°ã€‚</p>

<p>if n == len(c.out) {
	c.out = nil
} else {
	c.out = c.out[n:]
}
1
2
3
4
5
ä½œè€…ä¹Ÿåšå‡ºäº†å¤„ç†ï¼Œåˆ¤æ–­äº† è¿”å›å€¼ n ä¸æ˜¯ c.out é•¿åº¦çš„æƒ…å†µï¼Œc.out = c.out[n:] ã€‚</p>

<p>ä½†æ˜¯ä½œè€…å¹¶æ²¡æœ‰å»æ³¨å†Œ epoll å¯å†™äº‹ä»¶å•Šã€‚</p>

<p>åœ¨å½“å‰æ–‡ä»¶æœç´¢ ModReadWrite ï¼Œæ³¨å†Œå¯è¯»å¯å†™çš„äº‹ä»¶ï¼Œå…±æœ‰ä¸¤å¤„ã€‚ä¸€æ¬¡æ˜¯ loopWake å‡½æ•°ï¼Œä¸€æ¬¡æ˜¯åœ¨ loopRead å‡½æ•°ã€‚ä¼šä¸ä¼šä½œè€…åœ¨ loopRead æ–¹æ³•ä¸­äº†åšäº†å¤„ç†ï¼Œè§„é¿äº†æ²¡æœ‰æ³¨å†Œå¯å†™äº‹ä»¶è¿™ç§æƒ…å†µå‘¢ï¼Ÿ</p>

<p>æˆ‘ä»¬çœ‹ä¸‹ loopRead</p>

<p>func loopRead(s *server, l *loop, c *conn) error {
	var in []byte
	n, err := syscall.Read(c.fd, l.packet)
	if n == 0 || err != nil {
		if err == syscall.EAGAIN {
			return nil
		}
		return loopCloseConn(s, l, c, err)
	}
	in = l.packet[:n]
	if !c.reuse {
		in = append([]byte{}, inâ€¦)
	}
	if s.events.Data != nil {
		out, action := s.events.Data(c, in)
		c.action = action
		if len(out) &gt; 0 {
			c.out = append([]byte{}, outâ€¦)
		}
	}
	if len(c.out) != 0 || c.action != None {
		l.poll.ModReadWrite(c.fd)
	}
	return nil
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
æœç„¶ï¼Œä½œè€…åšäº†å¤„ç†ï¼ å½“ s.events.Data(c, in) å‡½æ•°è¿”å›ï¼Œå¦‚æœ c.out æœ‰æ•°æ®ï¼Œå°±æ³¨å†Œå¯è¯»å¯å†™äº‹ä»¶ã€‚</p>

<p>æ‰€ä»¥ï¼Œæ‰§è¡Œçš„æµç¨‹æ˜¯ï¼š</p>

<p>å®¢æˆ·ç«¯æœ‰æ•°æ®åˆ°æ¥ï¼ŒloopRead å‡½æ•°æ‰§è¡Œ
è°ƒç”¨å®¢æˆ·æ³¨å†Œçš„å›è°ƒå‡½æ•° events.Data å‡½æ•°ï¼Œå®¢æˆ·å°†éœ€è¦çš„å†™å…¥ç»™å®¢æˆ·ç«¯çš„æ•°æ®è¿”å›ï¼Œevio å°†éœ€è¦å†™ç»™å®¢æˆ·ç«¯æ•°æ®å­˜åˆ° c.out , ç„¶åç›‘å¬å¯è¯»å¯å†™äº‹ä»¶
eopll å¯å†™äº‹ä»¶å”¤é†’ï¼Œæ‰§è¡Œ loopWrite ç›´æ¥ write æ•°æ®ã€‚ å¦‚æœå†™å®Œå°±é‡æ–°æ³¨å†Œï¼Œåªæ³¨å†Œå¯è¯»äº‹ä»¶ï¼›å¦‚æœæ²¡å†™å®Œï¼Œå°±ä¸é‡æ–°æ³¨å†Œï¼Œè¿˜æ˜¯å¯è¯»å¯å†™äº‹ä»¶éƒ½ç›‘å¬
å½“ç¼“å†²åŒºæœ‰ç©ºé—´äº†æ—¶ï¼Œepoll åˆä¼šå”¤é†’ç»§ç»­ loopWrite ã€‚</p>

<p>ä¼¼ä¹æ²¡é—®é¢˜ï¼Œä½†æ˜¯ä»”ç»†æƒ³ä¸€æƒ³ï¼Œä¼šä¸ä¼šæœ‰è¿™ç§æƒ…å†µå‘¢ï¼š</p>

<p>å†…æ ¸çš„ç¼“å†²åŒºæ»¡äº†ï¼Œç¬¬ä¸€æ¬¡æ²¡å†™å®Œï¼Œç­‰å¾…ç¼“å†²åŒºå¯å†™ã€‚æ­¤æ—¶å®¢æˆ·ç«¯åˆæ¥äº†æ•°æ®ï¼Œç»§ç»­æ‰§è¡Œ loopRead ã€‚è°ƒç”¨ç”¨æˆ·å›è°ƒå‡½æ•°ï¼Œåˆæœ‰è¦å†™å…¥çš„æ•°æ®ã€‚è¿™æ˜¯æ¥çœ‹çœ‹å¤„ç†é€»è¾‘</p>

<p>if s.events.Data != nil {
	out, action := s.events.Data(c, in)
	c.action = action
	if len(out) &gt; 0 {
		c.out = append([]byte{}, outâ€¦)
	}
}
1
2
3
4
5
6
7
c.out = append([]byte{}, outâ€¦) è¿™é‡Œï¼Œä¹‹å‰æ²¡å†™å®Œå­˜åœ¨ c.out é‡Œçš„æ•°æ®ç›´æ¥è¢«æ¸…ç©ºäº†å•Šã€‚è¿™æ ·è¦å†™å…¥çš„æ•°æ®å°±ä¸¢å¤±äº†ä¸€éƒ¨åˆ†å•Šã€‚</p>

<p>æ€è€ƒ
evio é€Ÿåº¦éå¸¸å¿«ï¼Œä½†æ˜¯ç¿»äº†æºç ï¼Œå‘ç° evio å¹¶æ²¡æœ‰åˆ»æ„å»å‡å°‘ epoll çš„å”¤é†’æ¬¡æ•°ï¼Œç›¸å evio åˆ©ç”¨ epoll çš„å¤šæ¬¡å”¤é†’å»åšæ“ä½œã€‚</p>

<p>æ¯”å¦‚ï¼Œè°ƒç”¨å®¢æˆ·å›è°ƒåï¼Œå¹¶æ²¡æœ‰ç›´æ¥å¤„ç† action çš„çŠ¶æ€ï¼Œåè€Œæ˜¯å…ˆæŠŠ action å­˜èµ·æ¥ï¼Œå¢åŠ æ³¨å†Œ fd çš„å¯å†™äº‹ä»¶ï¼Œè®©epoll å†å”¤é†’ï¼Œåœ¨ loopAction ä¸­å†æ¥å¤„ç† actionã€‚å…ˆä¸è¯´è¿™æ ·ä¼šä¸ä¼šæœ‰é—®é¢˜ï¼Œè¿™æ ·è®© epoll é¢‘ç¹å”¤é†’ä¼¼ä¹ä¸å¦¥ã€‚</p>

<p>evio çš„å¤„ç† read å’Œ write çš„æ–¹å¼ï¼Œä¹Ÿå¯¼è‡´å¤šæ¬¡çš„å†…å­˜æ‹·è´ï¼Œæ¢ç§æ–¹å¼ï¼Œæ€§èƒ½è¿˜å¯ä»¥å†æ¬¡æå‡ã€‚evio åœ¨ linux ç¯å¢ƒï¼ˆepollï¼‰ä¸‹ï¼Œå•å…ƒæµ‹è¯•å› ä¸º ç”¨æ¥å”¤é†’ epoll çš„ eventfd å†™å…¥æ•°æ®æ²¡æœ‰è¯»å‡º è¿™ä¸ªbug ï¼Œå•å…ƒæµ‹è¯•å¹¶ä¸èƒ½é€šè¿‡ã€‚</p>

<p>evio éå¸¸è½»é‡ï¼Œè¿™ä¹Ÿè¯´æ˜å®ƒéå¸¸ç®€å•ï¼Œä½¿ç”¨èµ·æ¥è¿˜æ˜¯éå¸¸ä¸æ–¹ä¾¿ï¼Œå¹¶ä¸”å¯¹äº epoll çš„å¤„ç†è¿˜æœ‰å¾ˆå¤šå¯ä»¥ä¼˜åŒ–çš„åœ°æ–¹ã€‚è€Œä¸”ï¼Œä½œè€…ä¼¼ä¹å¾ˆå¿™ã€‚ã€‚ã€‚ PRä¹Ÿä¸ç†ï¼ŒIssues ä¹Ÿä¸ç†ã€‚æ‰€ä»¥å†³å®šè‡ªå·±æ’¸ä¸€ä¸ªäº†ï¼Œæ›´å¥½ç”¨ï¼Œæ›´å¿«é€Ÿï¼ševiop ã€‚</p>

<p>æ¨èåº“
gev ä¸€ä¸ªè½»é‡ã€å¿«é€Ÿçš„åŸºäº Reactor æ¨¡å¼çš„éé˜»å¡ TCP ç½‘ç»œåº“ã€‚</p>

<p>åŸç†
evio æ˜¯ Reactor æ¨¡å¼çš„ç®€å•å®ç°ã€‚Reactor æœ¬è´¨å°±æ˜¯â€œnon-blocking IO + IO multiplexingâ€ï¼Œé€šè¿‡éé˜»å¡ IO+ IO å¤šè·¯å¤ç”¨æ¥å¤„ç†å¹¶å‘ã€‚ç¨‹åºè¿è¡Œä¸€ä¸ªæˆ–è€…å¤šä¸ªäº‹ä»¶å¾ªç¯ï¼Œé€šè¿‡åœ¨äº‹ä»¶å¾ªç¯ä¸­æ³¨å†Œå›è°ƒçš„æ–¹å¼å®ç°ä¸šåŠ¡é€»è¾‘ã€‚</p>

<p>evio å°†æ‰€æœ‰æ–‡ä»¶æè¿°ç¬¦è®¾ä¸ºéé˜»å¡ï¼Œå¹¶æ³¨å†Œåˆ°äº‹ä»¶å¾ªç¯ï¼ˆ epoll / kqueue ï¼‰ä¸­ã€‚ç›¸è¾ƒäºä¼ ç»Ÿçš„ per thread per connection çš„å¤„ç†æ–¹æ³•ï¼Œçº¿ç¨‹ä½¿ç”¨æ›´å°‘ï¼Œçº¿ç¨‹èµ„æºåˆ©ç”¨ç‡æ›´é«˜ã€‚</p>

<p>evio éœ€è¦åœ¨æœåŠ¡å¯åŠ¨å‰ï¼Œæ³¨å†Œå›è°ƒå‡½æ•°ï¼Œå½“äº‹ä»¶å¾ªç¯ä¸­æœ‰äº‹ä»¶åˆ°æ¥æ—¶ï¼Œä¼šè°ƒç”¨å›è°ƒå‡½æ•°å¤„ç†ã€‚</p>

<p>ä½¿ç”¨ç¤ºä¾‹
å…ˆä»ä¸€ä¸ªç®€å•çš„ echo server çš„ä¾‹å­æ¥äº†è§£ evio ã€‚</p>

<p>package main</p>

<p>import (
	â€œflagâ€
	â€œfmtâ€
	â€œlogâ€
	â€œstringsâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/tidwall/evio" )
</code></pre></div></div>

<p>func main() {
	var port int
	var loops int
	var udp bool
	var trace bool
	var reuseport bool
	var stdlib bool</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flag.IntVar(&amp;port, "port", 5000, "server port")
flag.BoolVar(&amp;udp, "udp", false, "listen on udp")
flag.BoolVar(&amp;reuseport, "reuseport", false, "reuseport (SO_REUSEPORT)")
flag.BoolVar(&amp;trace, "trace", false, "print packets to console")
flag.IntVar(&amp;loops, "loops", 0, "num loops")
flag.BoolVar(&amp;stdlib, "stdlib", false, "use stdlib")
flag.Parse()

var events evio.Events
events.NumLoops = loops
events.Serving = func(srv evio.Server) (action evio.Action) {
	log.Printf("echo server started on port %d (loops: %d)", port, srv.NumLoops)
	if reuseport {
		log.Printf("reuseport")
	}
	if stdlib {
		log.Printf("stdlib")
	}
	return
}
events.Data = func(c evio.Conn, in []byte) (out []byte, action evio.Action) {
	if trace {
		log.Printf("%s", strings.TrimSpace(string(in)))
	}
	out = in
	return
}
scheme := "tcp"
if udp {
	scheme = "udp"
}
if stdlib {
	scheme += "-net"
}
log.Fatal(evio.Serve(events, fmt.Sprintf("%s://:%d?reuseport=%t", scheme, port, reuseport))) }
</code></pre></div></div>

<p>ä¸Šé¢çš„ä¾‹å­ä¸»è¦å°±æ˜¯æ³¨å†Œäº†ä¸¤ä¸ªå›è°ƒå‡½æ•°ï¼š events.Serving å’Œ events.Data ã€‚</p>

<p>å½“ server å¯åŠ¨æ—¶ï¼Œä¼šæ¥æ‰§è¡Œæ³¨å†Œçš„ events.Serving å›è°ƒå‡½æ•°ï¼›
å½“æœ‰æ•°æ®åˆ°æ¥æ—¶ï¼Œæ‰§è¡Œ events.Data å›è°ƒå‡½æ•°ã€‚</p>

<p>ç¨‹åºæœ€åè°ƒç”¨ evio.Serve æ–¹æ³•å¼€å¯äº‹ä»¶å¾ªç¯ï¼Œç¨‹åºåœ¨æ­¤å¤„ä¸æ–­å¾ªç¯æ£€æµ‹æ˜¯å¦æœ‰äº‹ä»¶å‘ç”Ÿå¹¶å¤„ç†ï¼ˆæœ‰æ•°æ®åˆ°æ¥ï¼Œæœ‰æ•°æ®è¦å‘é€â€¦)ã€‚</p>

<p>evio éƒ½æ˜¯é€šè¿‡å›è°ƒå‡½æ•°æ¥æ‰§è¡Œä¸šåŠ¡é€»è¾‘çš„ã€‚ å½“å®¢æˆ·ç«¯æœ‰æ•°æ®å‘é€è¿‡æ¥æ—¶ï¼Œè°ƒç”¨ç”¨æˆ·æ³¨å†Œçš„ events.Data å‡½æ•°ã€‚</p>

<p>éœ€è¦å‘é€æ•°æ®ç»™å®¢æˆ·ç«¯æ—¶ï¼Œåªå¯ä»¥é€šè¿‡æ³¨å†Œçš„å›è°ƒå‡½æ•°çš„è¿”å›å€¼æ¥è¿”å›ï¼Œevio æ¡†æ¶æ¥è´Ÿè´£å‘é€ï¼ˆæœ‰ bugï¼‰ã€‚</p>

<p>å›è°ƒå‡½æ•°çš„è¿”å›å€¼ä¸»è¦æœ‰ä¸¤ä¸ª out []byte, action evio.Action , out å°±æ˜¯éœ€è¦å‘é€ç»™å®¢æˆ·ç«¯çš„ï¼Œ Action å°±æ˜¯è¿”å›ä¸€äº›çŠ¶æ€ï¼Œç”¨æ¥å…³é—­è¿æ¥ï¼Œæˆ–è€…æœåŠ¡å™¨é€€å‡ºå•¥çš„æ“ä½œã€‚ä¸»è¦çŠ¶æ€å¦‚ä¸‹ï¼š</p>

<p>const (
	// None indicates that no action should occur following an event.
	None Action = iota
	// Detach detaches a connection. Not available for UDP connections.
	Detach
	// Close closes the connection.
	Close
	// Shutdown shutdowns the server.
	Shutdown
)
evio çš„äº‹ä»¶å¾ªç¯
evio.Serve
æˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹ evio.Serve æ–¹æ³•çš„å®ç°</p>

<p>func Serve(events Events, addr â€¦string) error {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var lns []*listener
defer func() {
	// è¿™ä¸ªå‡½æ•°å¦‚æœæ¨å‡ºï¼Œéœ€è¦å…³é—­æ‰€æœ‰ listener
	for _, ln := range lns {
		ln.close()
	}
}()
var stdlib bool
// å¯ä»¥é€‰æ‹©ä½¿ç”¨ stdlibï¼ˆstdlib ä¸»è¦æ˜¯ä¸ºäº†æ”¯æŒ é *unix å¹³å°ï¼‰
for _, addr := range addr {
	// ç”Ÿæˆ listener
	var ln listener
	var stdlibt bool
	ln.network, ln.addr, ln.opts, stdlibt = parseAddr(addr)
	if stdlibt {
		stdlib = true
	}
	if ln.network == "unix" {
		os.RemoveAll(ln.addr)
	}
	var err error
	if ln.network == "udp" {
		if ln.opts.reusePort {
			ln.pconn, err = reuseportListenPacket(ln.network, ln.addr)
		} else {
			ln.pconn, err = net.ListenPacket(ln.network, ln.addr)
		}
	} else {
		if ln.opts.reusePort {
			ln.ln, err = reuseportListen(ln.network, ln.addr)
		} else {
			ln.ln, err = net.Listen(ln.network, ln.addr)
		}
	}
	if err != nil {
		return err
	}
	if ln.pconn != nil {
		ln.lnaddr = ln.pconn.LocalAddr()
	} else {
		ln.lnaddr = ln.ln.Addr()
	}
	if !stdlib {
		if err := ln.system(); err != nil {
			return err
		}
	}
	lns = append(lns, &amp;ln)
}
if stdlib {
	return stdserve(events, lns)
	// ä½¿ç”¨ std net åº“ å¯åŠ¨server
}
return serve(events, lns)
// ä½¿ç”¨ epoll or kqueue å¯åŠ¨server }
</code></pre></div></div>

<p>ä» Serve å‡½æ•°ç­¾åä¸­å¯ä»¥çœ‹å‡º evio æ˜¯æ”¯æŒç»‘å®šå¤šåœ°å€ç›‘å¬çš„</p>

<p>func Serve(events Events, addr â€¦string) error
ä½¿ç”¨æ–¹å¼å¦‚ä¸‹ï¼š</p>

<p>evio.Serve(events, â€œtcp://localhost:5000â€, â€œtcp://192.168.0.10:5001â€)
ç°åœ¨æˆ‘ä»¬çœ‹çœ‹ evio çš„æ ¸å¿ƒéƒ¨åˆ†ï¼š serve(events, lns)
ï¼Œè¿™é‡Œä¼šå¯åŠ¨ evio çš„ sever ã€‚</p>

<p>func serve(events Events, listeners []*listener) error {
	numLoops := events.NumLoops // ç¡®å®šå¯åŠ¨çš„äº‹ä»¶å¾ªç¯æ•°é‡
	if numLoops &lt;= 0 {
		if numLoops == 0 {
			numLoops = 1
		} else {
			numLoops = runtime.NumCPU()
		}
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s := &amp;server{}
s.events = events
s.lns = listeners
s.cond = sync.NewCond(&amp;sync.Mutex{})
s.balance = events.LoadBalance
s.tch = make(chan time.Duration)

//println("-- server starting")
if s.events.Serving != nil { // å¦‚æœæ³¨å†Œäº†å›è°ƒå‡½æ•°ï¼Œå°±æ‰§è¡Œ
	var svr Server
	svr.NumLoops = numLoops
	svr.Addrs = make([]net.Addr, len(listeners))
	for i, ln := range listeners {
		svr.Addrs[i] = ln.lnaddr
	}
	action := s.events.Serving(svr)
	switch action {
	case None:
	case Shutdown:
		return nil
	}
}

defer func() { // server é€€å‡ºåçš„æ¸…ç†å·¥ä½œ
	// wait on a signal for shutdown
	s.waitForShutdown()

	// notify all loops to close by closing all listeners
	for _, l := range s.loops {
		l.poll.Trigger(errClosing)
	}

	// wait on all loops to complete reading events
	s.wg.Wait()

	// close loops and all outstanding connections
	for _, l := range s.loops {
		for _, c := range l.fdconns {
			loopCloseConn(s, l, c, nil)
		}
		l.poll.Close()
	}
	//println("-- server stopped")
}()

// create loops locally and bind the listeners.
for i := 0; i &lt; numLoops; i++ {
	l := &amp;loop{
		idx:     i,
		poll:    internal.OpenPoll(),
		packet:  make([]byte, 0xFFFF), // event loop çš„ read ç¼“å†²åŒº
		fdconns: make(map[int]*conn),
	}
	for _, ln := range listeners {
		l.poll.AddRead(ln.fd) // å°† fd æ³¨å†Œåˆ° epoll ä¸­å¹¶ç›‘å¬å¯è¯»äº‹ä»¶
	}
	s.loops = append(s.loops, l)
}
// start loops in background
s.wg.Add(len(s.loops))
for _, l := range s.loops { // å¯åŠ¨æ‰€æœ‰çš„ event loop
	go loopRun(s, l)
}
return nil }
</code></pre></div></div>

<p>serve ä¸»è¦åšè¿™äº›äº‹ï¼š</p>

<p>æ ¹æ®é…ç½®å¯åŠ¨æŒ‡å®šæ•°é‡çš„ event loopï¼Œå¦‚æœä¼ å…¥é…ç½®çš„ loop æ•°é‡ä¸º 0 åˆ™è®¾ç½®å¯åŠ¨ä¸€ä¸ªäº‹ä»¶å¾ªç¯ï¼Œå¦‚æœä¼ å…¥é…ç½®å°äº 0 åˆ™è®¾ç½®ä¸ºè¿è¡Œå¹³å°çš„ CPU æ ¸å¿ƒæ•°é‡
å¦‚æœè®¾ç½®äº†å›è°ƒå‡½æ•° events.Serving ï¼Œè¿è¡Œå®ƒ
æŒ‰ç…§æŒ‡å®š event loop æ•°é‡ï¼Œåˆ›å»º epoll å¥æŸ„ç”Ÿæˆ loop ï¼Œå¹¶å°†æ‰€æœ‰çš„ listener æ³¨å†Œåˆ° epoll ç›‘å¬å¯è¯»äº‹ä»¶ï¼ˆæœ‰å®¢æˆ·ç«¯è¿æ¥ï¼‰
å¯åŠ¨æ‰€æœ‰äº‹ä»¶å¾ªç¯(ä¸€ä¸ªäº‹ä»¶å¾ªç¯ä¸€ä¸ª goroutine)
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œevio å°†æ‰€æœ‰çš„ listener çš„ fd åœ¨æ¯ä¸€ä¸ªäº‹ä»¶å¾ªç¯çš„ epoll ä¸­éƒ½æ³¨å†Œäº†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæœ‰ä¸‰ä¸ªäº‹ä»¶å¾ªç¯ï¼Œä¸€ä¸ª listener ï¼Œé‚£ä¹ˆè¿™ä¸ª listener çš„ fd ä¼šæ³¨å†Œåˆ°ä¸‰ä¸ª epoll ä¸­ã€‚è¿™å°±ä¼šå‡ºç° epoll çš„æƒŠç¾¤ç°è±¡ï¼Œæ„Ÿå…´è¶£çš„å¯ä»¥è‡ªå·±æœç´¢äº†è§£ä¸‹ã€‚</p>

<p>evio å½“ä¸€ä¸ªæ–°è¿æ¥åˆ°æ¥æ—¶ï¼Œæ‰€æœ‰çš„äº‹ä»¶å¾ªç¯éƒ½ä¼šå”¤é†’ï¼Œä½†æ˜¯æœ€ç»ˆåªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥ accept è°ƒç”¨è¿”å›æˆåŠŸï¼Œå…¶ä»–çº¿ç¨‹ï¼ˆåç¨‹ï¼‰çš„ accept å‡½æ•°è°ƒç”¨è¿”å› EAGAIN é”™è¯¯ ã€‚</p>

<p>loopRun
ä¸‹é¢æˆ‘ä»¬çœ‹çœ‹ loopRun çš„å†…éƒ¨å®ç°</p>

<p>func loopRun(s *server, l *loop) {
	defer func() {
		//fmt.Println(â€œâ€“ loop stopped â€“â€, l.idx)
		s.signalShutdown()
		s.wg.Done()
	}()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if l.idx == 0 &amp;&amp; s.events.Tick != nil {
	go loopTicker(s, l)
}

//fmt.Println("-- loop started --", l.idx)
l.poll.Wait(func(fd int, note interface{}) error {
	if fd == 0 {
		return loopNote(s, l, note)
	}
	c := l.fdconns[fd]
	switch {
	case c == nil:
		return loopAccept(s, l, fd)
	case !c.opened:
		return loopOpened(s, l, c)
	case len(c.out) &gt; 0:
		return loopWrite(s, l, c)
	case c.action != None:
		return loopAction(s, l, c)
	default:
		return loopRead(s, l, c)
	}
}) }
</code></pre></div></div>

<p>l.poll.Wait ä¼ å…¥ä¸€ä¸ªå›è°ƒå‡½æ•°ä½œä¸ºå‚æ•°ï¼Œå½“ epoll æ”¶åˆ°äº‹ä»¶é€šçŸ¥æ—¶ï¼Œä¼šæ‰§è¡Œè¿™ä¸ªå›è°ƒå‡½æ•°ã€‚</p>

<p>åœ¨è¿™ä¸ªå‡½æ•°ä¸­æ¥å—å®¢æˆ·ç«¯è¿æ¥ï¼Œè¯»å–å®¢æˆ·ç«¯æ•°æ®ï¼Œè°ƒç”¨å®¢æˆ·å›è°ƒå‡½æ•°å¤„ç†ä¸šåŠ¡é€»è¾‘â€¦</p>

<p>æˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹ poll.Wait çš„å†…éƒ¨å®ç°ï¼Œå†çœ‹çœ‹ loopAcceptï¼ŒloopOpenedï¼ŒloopWrite ç­‰å‡½æ•°ã€‚
loopRun æ–¹æ³•ä¸­æœ€é‡è¦çš„å°±æ˜¯ poll.Wait ï¼Œæˆ‘ä»¬çœ‹çœ‹ Linux ä¸‹ epoll çš„å®ç°</p>

<p>func (p *Poll) Wait(iter func(fd int, note interface{}) error) error {
	events := make([]syscall.EpollEvent, 64)
	for {
		n, err := syscall.EpollWait(p.fd, events, -1)
		if err != nil &amp;&amp; err != syscall.EINTR {
			return err
		}
		if err := p.notes.ForEach(func(note interface{}) error {
			return iter(0, note)
		}); err != nil {
			return err
		}
		for i := 0; i &lt; n; i++ {
			if fd := int(events[i].Fd); fd != p.wfd {
				if err := iter(fd, nil); err != nil {
					return err
				}
			} else {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		}
	}
} } è¿™ä¸ªå‡½æ•°ä¸­æ˜¯ä¸€ä¸ªæ­»å¾ªç¯ï¼Œç¨‹åºä¼šé˜»å¡åœ¨æ­¤å¤„ç­‰å¾… epoll çš„â€é€šçŸ¥â€œï¼Œç„¶åå¤„ç†å°±ç»ªçš„ fd ï¼ˆè¯»å–/å‘é€æ•°æ®ã€æ‰§è¡Œç”¨æˆ·æ³¨å†Œçš„å›è°ƒå‡½æ•°ï¼‰ã€‚
</code></pre></div></div>

<p>å½“æœ‰ fd å°±ç»ªçš„æ—¶å€™ï¼Œsyscall.EpollWait å‡½æ•°è¿”å›ï¼Œå¹¶ä¸”å°†å°±ç»ªçš„ fd é€šè¿‡ events ä¼ å‡ºï¼Œè¿”å›å€¼ n ä¸ºå°±ç»ª fd çš„ä¸ªæ•°ã€‚</p>

<p>ç„¶åå¾ªç¯é€ä¸ªéå†å°±ç»ªçš„ fdï¼Œè°ƒç”¨å›è°ƒå‡½æ•°å¤„ç†ã€‚</p>

<p>for i := 0; i &lt; n; i++ {
	if fd := int(events[i].Fd); fd != p.wfd {
		if err := iter(fd, nil); err != nil {
			return err
		}
	} else {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>} } evio çš„äº‹ä»¶å¤„ç†
</code></pre></div></div>

<p>l.poll.Wait(func(fd int, note interface{}) error {
	if fd == 0 {
		return loopNote(s, l, note)
	}
	c := l.fdconns[fd]
	switch {
	case c == nil:
		return loopAccept(s, l, fd)
	case !c.opened:
		return loopOpened(s, l, c)
	case len(c.out) &gt; 0:
		return loopWrite(s, l, c)
	case c.action != None:
		return loopAction(s, l, c)
	default:
		return loopRead(s, l, c)
	}
})
å½“ epoll æ£€æµ‹åˆ°æœ‰å°±ç»ªçš„ fd æ—¶ï¼Œä¼šé€ä¸ªè°ƒç”¨ä¸Šé¢çš„å›è°ƒå‡½æ•°ï¼Œevio çš„ä¸»è¦é€»è¾‘ä¹Ÿåœ¨è¿™é‡Œã€‚</p>

<p>å½“ fd == 0 æ—¶ï¼Œä¼šæ‰§è¡Œ loopNote å‡½æ•°ã€‚loopNote ä¸»è¦æ˜¯ç”¨æ¥å¤„ç†ä¸€äº›é fd å°±ç»ªçš„äº‹ä»¶ï¼Œæ¯”å¦‚å®šæ—¶ä»»åŠ¡ã€å¼ºåˆ¶é€€å‡ºç­‰ã€‚å½“ç„¶ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“ fd ä¸º 0 æ˜¯æ ‡å‡†è¾“å…¥ï¼Œæ‰€ä»¥æ­¤å¤„å¹¶ä¸æ˜¯çœŸçš„å»å¤„ç† fd ä¸º 0 çš„æ–‡ä»¶æè¿°ç¬¦ï¼ˆæ³¨å†Œåˆ° epoll çš„æ–‡ä»¶æè¿° &gt;= 3ï¼‰ã€‚ä½œè€…çŸ¥é“ epoll è¿”å›çš„å°±ç»ª fd ä¸­ä¸ä¼šæœ‰ä¸º 0 çš„æƒ…å†µï¼Œæ‰€ä»¥æ­¤å¤„ fd ä¸º 0ï¼Œæ˜¯ä½œè€…è°ƒç”¨æ—¶ä¼ å…¥ï¼Œç”¨æ¥è¡¨ç¤ºä¸€ç§ç‰¹æ®Šçš„å”¤é†’åœºæ™¯ã€‚</p>

<p>func (p *Poll) Wait(iter func(fd int, note interface{}) error) error {
â€¦
	p.changes = p.changes[:0]
		if err := p.notes.ForEach(func(note interface{}) error {
			return iter(0, note)
â€¦
æˆ‘ä»¬è·³åˆ°è°ƒç”¨å®ƒçš„åœ°æ–¹ï¼Œå¯ä»¥çœ‹åˆ°åªæœ‰åœ¨ p.notes.ForEach è¿™ä¸ªå‡½æ•°ä¸­æ³¨å†Œçš„å›è°ƒå‡½æ•°ä¸­æ‰ä¼šä¼ å…¥ fd ä¸º 0 æ¥æ‰§è¡Œ iter å›è°ƒå‡½æ•°ã€‚</p>

<p>notes noteQueue</p>

<p>noteQueue çš„å®ç°åœ¨ internal ç›®å½•ä¸­çš„ notequeue.go , æ˜¯ä¸€ä¸ªæ— é”é˜Ÿåˆ—ã€‚æˆ‘ä»¬ä¸è¯¦ç»†åˆ†æï¼Œåªçœ‹ä¸‹ ForEach è¿™ä¸ªæ–¹æ³•ï¼š</p>

<p>func (q *noteQueue) ForEach(iter func(note interface{}) error) error {
	q.mu.Lock()
	if len(q.notes) == 0 {
		q.mu.Unlock()
		return nil
	}
	notes := q.notes
	q.notes = nil
	q.mu.Unlock()
	for _, note := range notes {
		if err := iter(note); err != nil { // æ‰§è¡Œå›è°ƒå‡½æ•°
			return err
		}
	}
	return nil
}</p>

<p>å½“é˜Ÿåˆ—ä¸­æœ‰æ•°æ®æ—¶ï¼Œ ä¼šæ‰§è¡Œå›è°ƒå‡½æ•°ï¼Œå³</p>

<p>func(note interface{}) error {
	return iter(0, note)
}
ä»ä¸Šé¢çš„åˆ†æä¸­å¯ä»¥æˆ‘ä»¬å·²ç»çŸ¥é“ä¸ºä»€ä¹ˆä¼šæœ‰ fd ä¸º 0 ï¼Œä¸‹é¢æˆ‘ä»¬çœ‹ä¸‹ loopNote åšä»€ä¹ˆã€‚</p>

<p>loopNote
func loopNote(s *server, l *loop, note interface{}) error {
	var err error
	switch v := note.(type) {
	case time.Duration:
		delay, action := s.events.Tick()
		switch action {
		case None:
		case Shutdown:
			err = errClosing
		}
		s.tch &lt;- delay
	case error: // shutdown
		err = v
	case *conn:
		// Wake called for connection
		if l.fdconns[v.fd] != v {
			return nil // ignore stale wakes
		}
		return loopWake(s, l, v)
	}
	return err
}
ä¼ å…¥çš„ note æ˜¯ interface{} ï¼Œé¦–å…ˆå¯¹ note è¿›è¡Œç±»å‹åˆ¤æ–­ã€‚</p>

<p>å½“ note æ˜¯ time.Duration æ—¶ï¼Œè°ƒç”¨å›è°ƒå‡½æ•° events.Tick() ï¼Œè¿™æ˜¯ evio æä¾›çš„å®šæ—¶ä»»åŠ¡æ¥å£ã€‚</p>

<p>åœ¨ loopRun å‡½æ•°ä¸­ï¼Œå¦‚æœè®¾ç½®äº†å®šæ—¶å›è°ƒå‡½æ•°ï¼Œä¼šå¯åŠ¨ä¸€ä¸ªåç¨‹æ¥æ¥è¿è¡Œ loopTicker</p>

<p>if l.idx == 0 &amp;&amp; s.events.Tick != nil {
	go loopTicker(s, l)
}
loopTicker å®ç°å¦‚ä¸‹ï¼Œå¯ä»¥çœ‹å‡ºä¼šå®šæ—¶å»è§¦å‘ l.poll.Triggerï¼Œå¹¶ä¸”ä¼ å…¥ time.Duration(0)</p>

<p>func loopTicker(s *server, l *loop) {
	for {
		if err := l.poll.Trigger(time.Duration(0)); err != nil {
			break
		}
		time.Sleep(&lt;-s.tch)
	}
}
æˆ‘ä»¬è·³åˆ° poll.Trigger çš„ Linux ä¸‹çš„å®ç°ï¼Œå¯ä»¥å‘ç° evio åœ¨æ­¤å¤„ p.notes.Add(note) ï¼Œä¹Ÿå°±æ˜¯ time.Duration(0)</p>

<p>func (p *Poll) Trigger(note interface{}) error {
	p.notes.Add(note)
	_, err := syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1})
	return err
}
poll.Trigger è¿™ä¸ªå‡½æ•°ä¸ä»…ä»…æ˜¯åœ¨ p.notes é‡Œå¢åŠ äº†ä¸€ä¸ª noteï¼Œè¿˜å”¤é†’äº†äº‹ä»¶å¾ªç¯ã€‚</p>

<p>å½“ epoll ä¸­æ³¨å†Œ fd éƒ½æ²¡æœ‰å°±ç»ªäº‹ä»¶æ—¶ï¼Œçº¿ç¨‹ä¼šæŒ‚èµ·ï¼Œepoll çš„ wait æ–¹æ³•ä¼šå¤„äºé˜»å¡çŠ¶æ€ã€‚evio ä½¿ç”¨
Linux æä¾›çš„ eventfd æ¥å®ç°äº‹ä»¶å¾ªç¯çš„å”¤é†’ï¼Œä¹Ÿå°±æ˜¯ä»£ç ä¸Šä¸­çš„ syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1}) ,å¾€ p.wfd è¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦ä¸­å†™å…¥äº† 8 ä¸ªå­—èŠ‚çš„æ•°æ®ã€‚</p>

<p>p.wfd æ˜¯ä¸€ä¸ª eventfd , æ˜¯ Poll ç»“æ„ä½“çš„æˆå‘˜ï¼Œåœ¨ OpenPoll æ—¶èµ‹å€¼ï¼Œå³æ‰“å¼€ä¸€ä¸ª eventfd ä»£ç å¦‚ä¸‹ï¼š</p>

<p>type Poll struct {
	fd    int // epoll fd
	wfd   int // wake fd
	notes noteQueue
}</p>

<p>func OpenPoll() *Poll {
	l := new(Poll)
	p, err := syscall.EpollCreate1(0)
	if err != nil {
		panic(err)
	}
	l.fd = p
	r0, _, e0 := syscall.Syscall(syscall.SYS_EVENTFD2, 0, 0, 0)
	if e0 != 0 {
		syscall.Close(p)
		panic(err)
	}
	l.wfd = int(r0)
	l.AddRead(l.wfd)
	return l
}
syscall.Syscall(syscall.SYS_EVENTFD2, 0, 0, 0) åˆ›å»ºäº†ä¸€ä¸ª eventfd ï¼Œç„¶åå°†è¿™ä¸ª eventfd æ³¨å†Œåˆ°äº† epoll ç›‘å¬å¯è¯»äº‹ä»¶ã€‚å½“ syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1}) æ—¶å€™ï¼Œepoll å°±ä¼šå”¤é†’ã€‚</p>

<p>ä½†æ˜¯ï¼Œæˆ‘ç¿»äº†å¥½ä¹…ï¼Œä¹Ÿæ²¡æœ‰æ‰¾åˆ° evio åœ¨å“ªé‡Œè¯»å– eventfd å†™å…¥çš„ 8 ä¸ªå­—èŠ‚ï¼ˆepollï¼‰ã€‚è¿™æ˜¯ä¸€ä¸ª bugï¼Œæ‰€ä»¥åœ¨ Linux æœºå™¨ä¸Šï¼Œè¿™æ˜¯ä¸èƒ½ç”¨çš„ã€‚</p>

<p>è¿™ä¸ª bug ä¼šé€ æˆ epoll ä¸æ–­å”¤é†’ï¼ŒCPU è¢«é•¿æœŸå ç”¨</p>

<p>å½“æˆ‘ä»¬æ³¨å†Œäº† evio çš„å®šæ—¶ä»»åŠ¡ Tick å›è°ƒå‡½æ•°ï¼Œç¨‹åºå¯åŠ¨åä¼šå¾€ eventfd é‡Œå†™å…¥ 8 ä¸ªå­—èŠ‚æ•°æ®ï¼Œä½†æ˜¯ evio å¹¶æ²¡æœ‰è¯»å–ï¼Œå¹¶ä¸” evio ä½¿ç”¨çš„æ˜¯ epoll çš„é»˜è®¤æ¨¡å¼ LTï¼Œå³åªè¦å¯è¯»ç¼“å†²åŒºé‡Œè¿˜æœ‰æ•°æ®ï¼Œepoll ä¼šä¸€ç›´ä¸æ–­å”¤é†’ï¼Œè¿™æ˜¯ä¸€ä¸ªä¸¥é‡çš„ bugï¼Œä½œè€…åº”è¯¥æ²¡æœ‰åœ¨ Linux ç¯å¢ƒä¸‹ä¸¥æ ¼æµ‹è¯•è¿‡ã€‚</p>

<p>æˆ‘ä»¬æŠ›å¼€è¿™ä¸ª bugï¼Œ ç»§ç»­æ¥çœ‹ note ä¸º error ç±»å‹çš„æƒ…å†µã€‚åœ¨ serve å‡½æ•°ä¸­ï¼Œå½“å‡½æ•°é€€å‡ºæ—¶ï¼Œé€šè¿‡ l.poll.Trigger(errClosing) æ¥é€šçŸ¥æ¯ä¸ªäº‹ä»¶å¾ªç¯é€€å‡ºã€‚</p>

<p>func  serve(events Events, listeners []*listener) error {
â€¦</p>

<p>defer func() {
	// wait on a signal for shutdown
	s.waitForShutdown()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// notify all loops to close by closing all listeners
for _, l := range s.loops {
	l.poll.Trigger(errClosing)
}

// wait on all loops to complete reading events
s.wg.Wait()

// close loops and all outstanding connections
for _, l := range s.loops {
	for _, c := range l.fdconns {
		loopCloseConn(s, l, c, nil)
	}
	l.poll.Close()
}
//println("-- server stopped") }()
</code></pre></div></div>

<p>â€¦
å½“ note ä¸º *conn è¿™ç§æƒ…å†µï¼Œæ˜¯ç”¨æ¥æä¾›ç»™ä½¿ç”¨è€…ä¸»åŠ¨å”¤é†’å½“å‰äº‹ä»¶å¾ªç¯</p>

<p>func (c <em>conn) Wake() {
	if c.loop != nil {
		c.loop.poll.Trigger(c)
	}
}
loopAccept
c := l.fdconns[fd]
	switch {
	case c == nil:
		return loopAccept(s, l, fd)
type loop struct {
	idx     int            // loop index in the server loops list
	poll    *internal.Poll // epoll or kqueue
	packet  []byte         // read packet buffer
	fdconns map[int]</em>conn  // loop connections fd -&gt; conn
	count   int32          // connection count
}</p>

<p>fdconns æ˜¯ç”¨æ¥å­˜å‚¨å·²è¿æ¥çš„ TCP connection ä¿¡æ¯ï¼Œkey ä¸º fdï¼Œ value ä¸º *conn ã€‚</p>

<p>å½“ epoll å”¤é†’æ—¶ï¼Œå¦‚æœ fd ä¸åœ¨å½“å‰äº‹ä»¶å¾ªç¯çš„è¿æ¥ï¼Œé‚£å°±è¯´æ˜å®ƒæ˜¯æ–°è¿æ¥ï¼Œåˆ™æ‰§è¡Œ loopAccept ã€‚</p>

<p>func loopAccept(s *server, l *loop, fd int) error {
	for i, ln := range s.lns {
		if ln.fd == fd {
			if len(s.loops) &gt; 1 {
				switch s.balance {
				case LeastConnections:
					n := atomic.LoadInt32(&amp;l.count)
					for _, lp := range s.loops {
						if lp.idx != l.idx {
							if atomic.LoadInt32(&amp;lp.count) &lt; n {
								return nil // do not accept
							}
						}
					}
				case RoundRobin:
					idx := int(atomic.LoadUintptr(&amp;s.accepted)) % len(s.loops)
					if idx != l.idx {
						return nil // do not accept
					}
					atomic.AddUintptr(&amp;s.accepted, 1)
				}
			}
			if ln.pconn != nil {
				return loopUDPRead(s, l, i, fd)
			}
			nfd, sa, err := syscall.Accept(fd)
			if err != nil {
				if err == syscall.EAGAIN {
					return nil
				}
				return err
			}
			if err := syscall.SetNonblock(nfd, true); err != nil {
				return err
			}
			c := &amp;conn{fd: nfd, sa: sa, lnidx: i, loop: l}
			l.fdconns[c.fd] = c
			l.poll.AddReadWrite(c.fd)
			atomic.AddInt32(&amp;l.count, 1)
			break
		}
	}
	return nil
}</p>

<p>å› ä¸º evio æ”¯æŒå¤šåœ°å€ç›‘å¬ï¼Œæ‰€ä»¥ä¼šå­˜åœ¨å¤šä¸ª listener ï¼Œä¹Ÿå°±æ˜¯ s.lns ã€‚</p>

<p>ç¬¬ä¸€æ­¥ï¼Œå…ˆéå†æ‰€æœ‰çš„ listener çœ‹çœ‹å½“å‰ epoll ä¸­å°±ç»ªçš„ fd æ˜¯å“ªä¸€ä¸ª listener ï¼Œç„¶åæ‰§è¡Œå®¢æˆ·ç«¯çš„è´Ÿè½½ç­–ç•¥ï¼Œå†³å®šæ–°çš„å®¢æˆ·ç«¯è¿æ¥æ”¾åœ¨å“ªä¸€ä¸ªäº‹ä»¶å¾ªç¯ä¸­ã€‚</p>

<p>è¿™é‡Œå…³äºå®¢æˆ·ç«¯çš„è´Ÿè½½ç­–ç•¥ï¼Œevio åˆ©ç”¨äº† epoll çš„æƒŠç¾¤æ•ˆæœï¼Œæ‰€æœ‰çš„äº‹ä»¶å¾ªç¯éƒ½ä¼šå”¤é†’è¿›å…¥ loopAcceptï¼Œä¸ç¬¦åˆè´Ÿè½½ç­–ç•¥ç›´æ¥ return nilã€‚ å…³äºè¿™è¾¹çš„æ›´å¤šç»†èŠ‚ï¼Œå¯ä»¥çœ‹æˆ‘çš„å¦ä¸€ç¯‡æ–‡ç«  ã€Golang ç½‘ç»œåº“ evio ä¸€äº›é—®é¢˜/bug å’Œæ€è€ƒã€‘ã€‚</p>

<p>æ¥ä¸‹æ¥å°±æ˜¯å¸¸è§„æ“ä½œäº†ï¼Œ syscall.Accept(fd) æ¥å—è¿æ¥ï¼Œç„¶å  syscall.SetNonblock(nfd, true) è®¾ç½®æˆéé˜»å¡æ¨¡å¼ï¼Œ l.poll.AddReadWrite(c.fd) æœ€ååŠ å…¥äº‹ä»¶å¾ªç¯ï¼Œæ³¨å†Œå¯è¯»å¯å†™äº‹ä»¶ã€‚</p>

<p>loopOpened
func loopOpened(s <em>server, l *loop, c *conn) error {
	c.opened = true
	c.addrIndex = c.lnidx
	c.localAddr = s.lns[c.lnidx].lnaddr
	c.remoteAddr = internal.SockaddrToAddr(c.sa)
	if s.events.Opened != nil {
		out, opts, action := s.events.Opened(c)
		if len(out) &gt; 0 {
			c.out = append([]byte{}, outâ€¦)
		}
		c.action = action
		c.reuse = opts.ReuseInputBuffer
		if opts.TCPKeepAlive &gt; 0 {
			if _, ok := s.lns[c.lnidx].ln.(</em>net.TCPListener); ok {
				internal.SetKeepAlive(c.fd, int(opts.TCPKeepAlive/time.Second))
			}
		}
	}
	if len(c.out) == 0 &amp;&amp; c.action == None {
		l.poll.ModRead(c.fd)
	}
	return nil
}
loopOpened æ˜¯åœ¨ loopAccept æ‰§è¡Œå®Œæˆåï¼Œepoll ä¼šç«‹é©¬å†æ¬¡å”¤é†’ç„¶åæ‰§è¡Œçš„ã€‚</p>

<p>å› ä¸ºåœ¨ loopAccept ä¸­æœ€åå°†æ–°çš„å®¢æˆ·ç«¯è¿æ¥åŠ å…¥ epoll ç®¡ç†æ—¶æ³¨å†Œçš„æ˜¯å¯è¯»å¯å†™äº‹ä»¶ï¼Œå½“å‰çš„å†…æ ¸å†™ç¼“å†²åŒºè‚¯å®šæ˜¯ä¸ºç©ºçš„ï¼Œæ‰€ä»¥ epoll ä¼šå†æ¬¡å”¤é†’ã€‚</p>

<p>â€¦
case !c.opened:
	return loopOpened(s, l, c)
â€¦
å”¤é†’åä¼šæ‰§è¡Œåˆ°è¿™ä¸ª case case !c.opened:ï¼Œå› ä¸ºåœ¨ loopAccept ä¸­å¹¶æ²¡æœ‰å»è®¾ç½®è¿™ä¸ªå€¼ã€‚</p>

<p>loopOpened å†…éƒ¨çš„æ“ä½œï¼Œä¸»è¦å°±æ˜¯è®¾ç½®ä¸€ä¸‹ conn çš„å±æ€§ï¼Œç„¶åè°ƒç”¨å®¢æˆ·æ³¨å†Œçš„å›è°ƒå‡½æ•° events.Opened ã€‚</p>

<p>å¦‚æœåœ¨å›è°ƒå‡½æ•°ä¸­ï¼Œæ²¡æœ‰ç»™å®¢æˆ·ç«¯å‘é€æ•°æ®ï¼Œåˆ™éœ€è¦é‡æ–°æ³¨å†Œï¼Œåªæ³¨å†Œå¯è¯»äº‹ä»¶ï¼Œä¸ç„¶ epoll ä¼šä¸€ç›´å”¤é†’ï¼ˆå¯å†™äº‹ä»¶ï¼‰ã€‚</p>

<p>loopAction
func loopAction(s *server, l *loop, c *conn) error {
	switch c.action {
	default:
		c.action = None
	case Close:
		return loopCloseConn(s, l, c, nil)
	case Shutdown:
		return errClosing
	case Detach:
		return loopDetachConn(s, l, c, nil)
	}
	if len(c.out) == 0 &amp;&amp; c.action == None {
		l.poll.ModRead(c.fd)
	}
	return nil
}
case c.action != None:
	return loopAction(s, l, c)
loopAction ä¼šåœ¨ case c.action != None: çš„æƒ…å†µä¸‹æ‰§è¡Œï¼Œ c.action æ˜¯æ‰§è¡Œå®Œç”¨æˆ·å›è°ƒå‡½æ•°åä¼šè¢«èµ‹å€¼çš„çŠ¶æ€ã€‚</p>

<p>åœ¨ä¼šæœ‰ action çš„ loopXXX ä¸­éƒ½ä¼šæœ‰å¦‚ä¸‹ç±»ä¼¼æ“ä½œã€‚</p>

<p>if len(c.out) != 0 || c.action != None {
	l.poll.ModReadWrite(c.fd)
}
ä¹Ÿå°±æ˜¯è¯´ loopAction ä¾èµ–äº epoll è¢«å¯å†™äº‹ä»¶å†æ¬¡å”¤é†’æ¥æ‰§è¡Œï¼Œè¿™æ ·ä¼šä¸ä¼šæœ‰é—®é¢˜å‘¢ï¼Ÿ å†…æ ¸ç¼“å†²åŒºæ»¡äº†ï¼Ÿï¼Ÿ</p>

<p>loopAction å†…éƒ¨çš„ä¸»è¦æ“ä½œå°±æ˜¯æ ¹æ® action åšä¸€äº›å¤„ç†ï¼Œå…³é—­è¿æ¥ç­‰ç­‰ã€‚</p>

<p>loopRead å’Œ loopWrite
loopRead å’Œ loopWrite ä¸»è¦å°±æ˜¯è°ƒç”¨ç³»ç»Ÿè°ƒç”¨è¯»å–å’Œå‘é€æ•°æ®ï¼Œå¹¶ä¸”è°ƒç”¨ç”¨æˆ·å›è°ƒå‡½æ•°ï¼Œæ ¹æ®å›è°ƒå‡½æ•°è¿”å›å€¼æ¥é‡æ–°æ³¨å†Œ epoll çš„å¯è¯»å¯å†™äº‹ä»¶ã€‚</p>

<p>func loopRead(s *server, l *loop, c *conn) error {
	var in []byte
	n, err := syscall.Read(c.fd, l.packet)
	if n == 0 || err != nil {
		if err == syscall.EAGAIN {
			return nil
		}
		return loopCloseConn(s, l, c, err)
	}
	in = l.packet[:n]
	if !c.reuse {
		in = append([]byte{}, inâ€¦)
	}
	if s.events.Data != nil {
		out, action := s.events.Data(c, in)
		c.action = action
		if len(out) &gt; 0 {
			c.out = append([]byte{}, outâ€¦)
		}
	}
	if len(c.out) != 0 || c.action != None {
		l.poll.ModReadWrite(c.fd)
	}
	return nil
}
è°ƒç”¨ n, err := syscall.Read(c.fd, l.packet) è¯»å–å†…æ ¸ç¼“å†²åŒºçš„æ•°æ®ï¼Œå¦‚æœè¿”å›å‡ºé”™ err == syscall.EAGAIN æ„æ€æ˜¯å†è¯•ä¸€æ¬¡ï¼Œç›´æ¥è¿”å›ã€‚</p>

<p>å¦‚æœ n == 0 æˆ–è€… err é”™è¯¯ä¸ä¸º syscall.EAGAIN ï¼Œåˆ™è¯´æ˜å¯¹æ–¹å…³é—­äº†è¿æ¥æˆ–æ˜¯å…¶ä»–é”™è¯¯ï¼Œç›´æ¥ loopCloseConn ã€‚</p>

<p>ç„¶åè°ƒç”¨ç”¨æˆ·å›è°ƒå‡½æ•° s.events.Data ï¼Œæ ¹æ®è¿”å›å€¼åšç›¸åº”æ“ä½œã€‚c.action = action</p>

<p>å¦‚æœ out é‡Œæœ‰æ•°æ®ï¼Œåˆ™èµ‹ç»™ c.out , å¹¶ä¸”æ³¨å†Œå¯è¯»å¯å†™äº‹ä»¶ã€‚</p>

<p>å¦‚æœ c.action != None ï¼ŒåŒæ ·éœ€è¦æ³¨å†Œå¯è¯»å¯å†™äº‹ä»¶ï¼ŒåŸå› ä¸Šé¢å·²ç»è¯´è¿‡äº†ã€‚</p>

<p>loopWrite æ“ä½œä¹Ÿå¤§åŒå°å¼‚ï¼Œå°±ä¸ç»†è¯´äº†ã€‚</p>

<p>ä½†æ˜¯å…¶å®å…³äº loopWrite å’Œ loopRead çš„å¤„ç†æ˜¯ä¼šæœ‰ bug çš„</p>
:ET