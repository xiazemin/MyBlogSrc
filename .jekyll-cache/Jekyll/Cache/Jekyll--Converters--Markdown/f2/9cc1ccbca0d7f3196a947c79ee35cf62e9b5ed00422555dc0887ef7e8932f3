I"íd<p>https://blog.csdn.net/RA681t58CJxsgCkJ31/article/details/104471078/
https://gocn.vip/topics/9899
Go æä¾›äº†åŠŸèƒ½å®Œå¤‡çš„æ ‡å‡†ç½‘ç»œåº“ï¼šnetåŒ…ï¼ŒnetåŒ…çš„å®ç°ç›¸å½“ä¹‹å…¨é¢ï¼Œhttp\tcp\udp å‡æœ‰å®ç°ä¸”å¯¹ç”¨æˆ·æä¾›äº†ç®€å•å‹å¥½çš„ä½¿ç”¨æ¥å£ã€‚åœ¨ Linux ç³»ç»Ÿä¸Š Go ä½¿ç”¨äº† epoll æ¥å®ç° net åŒ…çš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œæœ¬æ–‡ä»ç”¨æˆ·æ¥å£å±‚å…¥æ‰‹ï¼Œåˆ†æ Go åœ¨ Linux å¹³å°ä¸Šçš„ epoll ä½¿ç”¨ï¼Œæ–‡ä¸­è‹¥æœ‰ä¸å½“ä¹‹å¤„è¯·æŒ‡å‡ºã€‚</p>

<p>å¯¹äºæœåŠ¡ç«¯ç¨‹åºè€Œè¨€ï¼Œä¸»è¦æµç¨‹æ˜¯ Listen-&gt;Accept-&gt;Send/Writeï¼Œå®¢æˆ·ç«¯ä¸»è¦æµç¨‹ Connect-&gt;Send/Writeï¼Œæœ¬æ–‡ä»¥è¿™ä¸¤ä¸ªæµç¨‹æ·±å…¥åˆ†ænetåŒ…åœ¨ Go ä¸­æ˜¯å¦‚ä½•å®ç°çš„ã€‚
<!-- more -->
Listen
ç›‘å¬æ–¹æ³•æ˜¯åœ¨ ListenConfig ç»“æ„ä¸­çš„ Listen æ–¹æ³•å®ç°çš„ (net/dial.go)ï¼š</p>

<p>func (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error) {
    addrs, err := DefaultResolver.resolveAddrList(ctx, â€œlistenâ€, network, address, nil)
    // â€¦
    switch la := la.(type) {
    case *TCPAddr:
        l, err = sl.listenTCP(ctx, la)
    case *UnixAddr:
        l, err = sl.listenUnix(ctx, la)
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return l, nil } åœ¨Listenå‡½æ•°å®ç°ä¸­ï¼Œä¸¤ä¸ªå…³é”®æµç¨‹æ˜¯DefaultResolver.resolveAddrListå’ŒlistenTCPã€‚
</code></pre></div></div>

<p>DefaultResolver.resolveAddrListæ˜¯æ ¹æ®åè®®åç§°å’Œåœ°å€å–å¾— Internet åè®®æ—åœ°å€åˆ—è¡¨ï¼Œç”±äºresolveAddrListçš„ä»£ç æ¯”è¾ƒå›ºå®šï¼Œåœ¨æ­¤ä¸åšè¯¦ç»†è§£é‡Šï¼Œæ„Ÿå…´è¶£çš„ç«¥é‹å¯ä»¥å»ç¿»é˜…ã€‚</p>

<p>listenTCPå’ŒlistenUnixä»åœ°å€åˆ—è¡¨ä¸­å–å¾—æ»¡è¶³æ¡ä»¶çš„åœ°å€è¿›è¡Œå®é™…ç›‘å¬æ“ä½œ, å…·ä½“æ ¹æ®ä¼ å…¥çš„åè®®æ—æ¥ç¡®å®šã€‚æ¥ä¸‹æ¥çœ‹çœ‹listenTCPçš„ä»£ç  (net/tcpsock_posix.go)ï¼š</p>

<p>func (sl <em>sysListener) listenTCP(ctx context.Context, laddr *TCPAddr) (</em>TCPListener, error) {
    fd, err := internetSocket(ctx, sl.network, laddr, nil, syscall.SOCK_STREAM, 0, â€œlistenâ€, sl.ListenConfig.Control)
    if err != nil {
        return nil, err
    }
    return &amp;TCPListener{fd: fd, lc: sl.ListenConfig}, nil
}
åˆ›å»ºç›‘å¬ socket fd æ˜¯åœ¨ internetSocket ä¸­è¿›è¡Œçš„ï¼Œè€Œ socket fs æ˜¯é€šè¿‡ socket å‡½æ•°åˆ›å»ºçš„ (net/sock_posix.go)ï¼š</p>

<p>func socket(ctx context.Context, net string, family, sotype, proto int, ipv6only bool, laddr, raddr sockaddr, ctrlFn func(string, string, syscall.RawConn) error) (fd *netFD, err error) {
    // è°ƒç”¨å„å¹³å°å¯¹åº”çš„socket apiåˆ›å»ºsocket
    s, err := sysSocket(family, sotype, proto)
    if err != nil {
        return nil, err
    }
    // è®¾ç½®socketé€‰é¡¹
    if err = setDefaultSockopts(s, family, sotype, ipv6only); err != nil {
        poll.CloseFunc(s)
        return nil, err
    }
    // åˆ›å»ºfd
    if fd, err = newFD(s, family, sotype, net); err != nil {
        poll.CloseFunc(s)
        return nil, err
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ç›‘å¬
if laddr != nil &amp;&amp; raddr == nil {
    switch sotype {
    case syscall.SOCK_STREAM, syscall.SOCK_SEQPACKET:
        // TCP
        if err := fd.listenStream(laddr, listenerBacklog(), ctrlFn); err != nil {
            fd.Close()
            return nil, err
        }
        return fd, nil
    case syscall.SOCK_DGRAM:
        // UDP
        if err := fd.listenDatagram(laddr, ctrlFn); err != nil {
            fd.Close()
            return nil, err
        }
        return fd, nil
    }
}
// å‘èµ·è¿æ¥ï¼Œélisten socketä¼šèµ°åˆ°è¿™é‡Œæ¥
if err := fd.dial(ctx, laddr, raddr, ctrlFn); err != nil {
    fd.Close()
    return nil, err
}
return fd, nil } socketå‡½æ•°ä¸»è¦æµç¨‹ï¼šæ–°å»º socket--&gt;è®¾ç½® socket option--&gt;åˆ›å»º fd--&gt;è¿›å…¥ç›‘å¬é€»è¾‘ã€‚sysSocketæ ¹æ®å¹³å°æœ‰ä¸åŒå®ç°ï¼Œwindows å®ç°åœ¨socket_windows.goä¸­ï¼Œlinux å®ç°åˆ™åœ¨sock_cloexec.goä¸­ï¼Œæœ¬æ–‡é‡ç‚¹åˆ†æåœ¨ linux å¹³å°ä¸Šçš„å®ç° (net/sock_cloexec.go):
</code></pre></div></div>

<p>func sysSocket(family, sotype, proto int) (int, error) {
    // ç³»ç»Ÿsocketå‡½æ•°
    s, err := socketFunc(family, sotype|syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC, proto)
    switch err {
    case nil:
        return s, nil
    default:
        return -1, os.NewSyscallError(â€œsocketâ€, err)
    case syscall.EPROTONOSUPPORT, syscall.EINVAL:
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// linuxå†…æ ¸ç‰ˆæœ¬ä½äº2.6.27æ—¶ï¼Œä»£ç ä¼šèµ°åˆ°è¿™é‡Œï¼Œä¸‹é¢çš„å†…å®¹ä¸»è¦æ˜¯é˜²æ­¢åœ¨forkæ—¶å€™å¯¼è‡´æè¿°ç¬¦æ³„éœ²
// å®é™…ä¸Šæ‰‹åŠ¨å®ç°ç®€æ˜“ç‰ˆSOCK_CLOEXEC
syscall.ForkLock.RLock()
// do other things... } socketFuncåˆ›å»ºäº† socketï¼Œé€šçŸ¥å°† socket è®¾ç½®éé˜»å¡ï¼ˆSOCK_NONBLOCKï¼‰ä»¥åŠ fork æ—¶å…³é—­ï¼ˆSOCK_CLOEXECï¼‰ï¼Œè¿™ä¸¤ä¸ªæ ‡å¿—æ˜¯åœ¨ linux å†…æ ¸ç‰ˆæœ¬ 2.6.27 ä¹‹åæ·»åŠ ï¼Œåœ¨æ­¤ä¹‹å‰çš„ç‰ˆæœ¬ä»£ç å°†ä¼šèµ°åˆ°syscall.ForkLock.RLock()ï¼Œä¸»è¦æ˜¯ä¸ºäº†é˜²æ­¢åœ¨ fork æ—¶å¯¼è‡´æ–‡ä»¶æè¿°ç¬¦æ³„éœ²ã€‚
</code></pre></div></div>

<p>å½“ socket åˆ›å»ºä¹‹åè¿›å…¥æ–°å»º fd æµç¨‹ï¼Œåœ¨ Go çš„åŒ…è£…å±‚é¢ï¼Œfd å‡ä»¥netFDç»“æ„è¡¨ç¤ºï¼Œè¯¥æ¥å£æè¿°åŸå§‹ socket çš„åœ°å€ä¿¡æ¯ã€åè®®ç±»å‹ã€åè®®æ—ä»¥åŠ optionï¼ŒnetFDåœ¨æ•´ä¸ªåŒ…è£…ç»“æ„ä¸­å±…äºç”¨æˆ·æ¥å£çš„ä¸‹ä¸€å±‚ã€‚æœ€åè¿›å…¥ç›‘å¬é€»è¾‘ï¼Œé€»è¾‘èµ°å‘åŒºåˆ† TCP å’Œ UDPï¼Œè€Œç›‘å¬é€»è¾‘æ¯”è¾ƒç®€å•ï¼Œå³è°ƒç”¨ç³»ç»Ÿ bind å’Œ listen æ¥å£ (net/sock_posix.go)ï¼š</p>

<p>func (fd *netFD) listenStream(laddr sockaddr, backlog int, ctrlFn func(string, string, syscall.RawConn) error) error {
    // â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if ctrlFn != nil {
    c, err := newRawConn(fd)
    if err != nil {
        return err
    }
    if err := ctrlFn(fd.ctrlNetwork(), laddr.String(), c); err != nil {
        return err
    }
}
if err = syscall.Bind(fd.pfd.Sysfd, lsa); err != nil {
    return os.NewSyscallError("bind", err)
}
if err = listenFunc(fd.pfd.Sysfd, backlog); err != nil {
    return os.NewSyscallError("listen", err)
}
if err = fd.init(); err != nil {
    return err
}
lsa, _ = syscall.Getsockname(fd.pfd.Sysfd)
fd.setAddr(fd.addrFunc()(lsa), nil)
return nil } listenStreamä¸»è¦åšäº†ä»¥ä¸‹å‡ ä»¶äº‹ï¼š
</code></pre></div></div>

<p>æ£€æŸ¥æœªå®Œæˆè¿æ¥å’Œå·²å®Œæˆè¿æ¥ä¸¤ä¸ªé˜Ÿåˆ—æ˜¯å¦è¶…å‡ºç³»ç»Ÿé¢„è®¾ã€‚</p>

<p>è°ƒç”¨ socket bind æ¥å£ã€‚</p>

<p>è°ƒç”¨ socket listen æ¥å£ã€‚</p>

<p>åˆå§‹åŒ– fdã€‚</p>

<p>è°ƒç”¨ socket getsockname æ¥å£ã€‚</p>

<p>ä»¥ä¸Šæµç¨‹å’Œæ—¥å¸¸å†™ socket ä»£ç æµç¨‹å¹¶æ— å¤ªå¤§å·®å¼‚ï¼Œå”¯æœ‰ç¬¬ 4 æµç¨‹ä¸åŒï¼Œç¬¬ 4 æµç¨‹æ˜¯ä¸åº•å±‚çš„netpolläº¤äº’ã€‚</p>

<p>Linux å¹³å°ä¸Šï¼Œç³»ç»Ÿæä¾›äº†äº”ç§ IO æ¨¡å‹ï¼šé˜»å¡ IOã€éé˜»å¡ IOã€IO å¤šè·¯å¤ç”¨ã€ä¿¡å·é©±åŠ¨ IO å’Œå¼‚æ­¥ IOï¼Œå¯¹åº”åˆ°å†…æ ¸å±‚é¢æä¾›çš„ç”¨æˆ·æ¥å£å³ selectã€poll å’Œ epollã€‚Go net åŒ…æ˜¯åŸºäº epoll è¿›è¡Œå°è£…çš„ï¼ŒåŸºæœ¬æ¨¡å‹ç»“åˆäº† epoll å’Œ Go è¯­è¨€çš„ä¼˜åŠ¿ï¼šepoll+goroutineï¼Œè¿™æ ·è¾¾åˆ°å¼‚æ­¥ä¸”é«˜å¹¶å‘ã€‚</p>

<p>å›åˆ°æºä»£ç ä¸Šï¼Œfd.init()å®Œæˆç½‘ç»œè½®è¯¢å™¨åˆå§‹åŒ–æ“ä½œï¼Œå¼€å§‹ä¸æ›´åº•å±‚çš„å°è£…æ‰“äº¤é“ï¼Œæœ€åº•å±‚çš„å°è£…æ˜¯ epoll è°ƒç”¨ (runtime/netpoll_epoll.go)ï¼š</p>

<p>func netpollinit() {
    epfd = epollcreate1(_EPOLL_CLOEXEC)
    if epfd &gt;= 0 {
        return
    }
    epfd = epollcreate(1024)
    if epfd &gt;= 0 {
        closeonexec(epfd)
        return
    }
    println(â€œruntime: epollcreate failed withâ€, -epfd)
    throw(â€œruntime: netpollinit failedâ€)
}
epollcreateåˆ›å»ºäº† epoll handle å¹¶è®¾ç½®ä¸ºCLOEXECå±æ€§ï¼Œæ­¤å¤„æ˜¯ epoll handle çš„åˆ›å»ºï¼Œnetpollinitä¹‹åè°ƒç”¨ (runtime/netpoll_epoll.go)ï¼š</p>

<p>func netpollopen(fd uintptr, pd *pollDesc) int32 {
    var ev epollevent
    // å¯è¯»ï¼Œå¯å†™ï¼Œå¯¹ç«¯æ–­å¼€ï¼Œè¾¹ç¼˜è§¦å‘
    ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET
    // å­˜æ”¾user dataï¼Œåé¢è¯»å†™å‡ä¼šç”¨åˆ°pollDesc
    *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd
    // æ³¨å†Œepolläº‹ä»¶
    return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;ev)
}
ç”±ä¸Šå¯è§ï¼Œè°ƒç”¨epoll_ctlå®Œæˆ epoll ç›‘å¬äº‹ä»¶æ³¨å†Œï¼Œ_EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLETä¸ºæ‰€å…³å¿ƒäº‹ä»¶ï¼Œå…·ä½“å«ä¹‰å¯ä»¥æŸ¥çœ‹ epoll æ‰‹å†Œã€‚</p>

<p>Accept
ListenæˆåŠŸä¹‹åè¿”å›TCPListenerå¯¹è±¡ï¼Œæ‰‹åŠ¨è°ƒç”¨Acceptè¿›å…¥ç›‘å¬çŠ¶æ€ï¼Œæœ€ç»ˆä¼šèµ°åˆ°ä¸ epoll äº¤äº’æµç¨‹ï¼š TCPListener.Acceptâ€“&gt;TCPListener.acceptâ€“&gt;netFD.acceptâ€“&gt;FD.Accept</p>

<p>ä»è¿™é‡Œå¼€å§‹ï¼Œè¿›å…¥åˆ°ä¸pollDescäº¤äº’çš„åœ°æ–¹ (internal/poll/fd_unix.go)ï¼š</p>

<p>func (fd *FD) Accept() (int, syscall.Sockaddr, string, error) {
    if err := fd.readLock(); err != nil {
        return -1, nil, â€œâ€, err
    }
    defer fd.readUnlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if err := fd.pd.prepareRead(fd.isFile); err != nil {
    return -1, nil, "", err
}
for {
    s, rsa, errcall, err := accept(fd.Sysfd)
    if err == nil {
        return s, rsa, "", err
    }
    switch err {
    case syscall.EAGAIN:
        if fd.pd.pollable() {
            if err = fd.pd.waitRead(fd.isFile); err == nil {
                continue
            }
        }
    case syscall.ECONNABORTED:
        continue
    }
    return -1, nil, errcall, err
} } fd.pd.prepareReadæ£€æŸ¥å½“å‰ fd æ˜¯å¦å…è®¸ acceptï¼Œå®é™…ä¸Šæ˜¯æ£€æŸ¥æ›´åº•å±‚çš„pollDescæ˜¯å¦å¯è¯»ã€‚æ£€æŸ¥å®Œæ¯•ä¹‹åï¼Œå°è¯•è°ƒç”¨acceptè·å–å·²è¿æ¥çš„ socketï¼Œæ³¨æ„æ­¤ä»£ç åœ¨ for å¾ªç¯å†…ï¼Œè¯´æ˜Acceptæ˜¯é˜»å¡çš„ï¼Œç›´åˆ°æœ‰è¿æ¥è¿›æ¥ï¼›å½“é‡åˆ°EAGINå’ŒECONNABORTEDé”™è¯¯ä¼šé‡è¯•ï¼Œå…¶ä»–é”™è¯¯éƒ½æŠ›ç»™æ›´ä¸Šå±‚ã€‚
</code></pre></div></div>

<p>fd.pd.waitReadé˜»å¡ç­‰å¾…fdæ˜¯å¦å¯è¯»ï¼Œå³æ˜¯å¦æœ‰æ–°è¿æ¥è¿›æ¥ï¼Œæœ€ç»ˆè¿›å…¥åˆ°runtime.poll_runtime_pollWaité‡Œ (runtime/netpoll.go)ï¼Œåœ¨è§£é‡Špoll_runtime_pollWaitä»£ç ä¹‹å‰ï¼Œå…ˆæ¥çœ‹çœ‹æœ€é‡è¦çš„ç»“æ„ï¼š</p>

<p>type pollDesc struct {
    // â€¦
    rg      uintptr
    wg      uintptr
    // â€¦
}</p>

<p>const (
    pdReady uintptr = 1
    pdWait  uintptr = 2
)
pollDescæ˜¯ä¸ epoll äº¤äº’æœ€é‡è¦çš„ç»“æ„ä¹‹ä¸€ï¼Œå¯ä»¥ç†è§£ä¸ºä¸ epoll ä¹‹é—´çš„æ¡¥æ¢ï¼Œå…¶ä¸­rgå’Œwgä¸ºçŠ¶æ€ä¿¡å·é‡ï¼Œå¯èƒ½çš„å€¼ä¸ºpdReadyã€pdWaitã€ç­‰å¾…æ–‡ä»¶æè¿°ç¬¦å¯è¯»æˆ–è€…å¯å†™çš„ goroutine åœ°å€ä»¥åŠnilï¼ˆ0ï¼‰ã€‚</p>

<p>å¯èƒ½å‡ºç°çš„æƒ…å†µï¼š</p>

<p>å½“å€¼ä¸º pdRead æ—¶ï¼Œä»£è¡¨ç½‘ç»œ IO å°±ç»ªï¼Œå¤„ç†å®Œä¹‹ååº”è¯¥è®¾ç½®ä¸º nilã€‚</p>

<p>å½“å€¼ä¸º pdWait æ—¶ï¼Œå³ç­‰å¾…è¢«æŒ‚èµ·ï¼ˆç°åœ¨å¹¶æœªè¢«æŒ‚èµ·ï¼‰ã€‚åé¢å¯èƒ½å‡ºç°çš„æƒ…å†µæ˜¯ï¼š</p>

<p>goroutine è¢«æŒ‚èµ·å¹¶è®¾ç½®ä¸º goroutine çš„åœ°å€ï¼›</p>

<p>æ”¶åˆ°äº† IO é€šçŸ¥å°±ç»ªï¼›</p>

<p>è¶…æ—¶æˆ–è€…è¢«å…³é—­è®¾ç½®ä¸º nilã€‚</p>

<p>æ¥ä¸‹æ¥çœ‹çœ‹poll_runtime_pollWaitä»£ç ï¼š</p>

<p>func poll_runtime_pollWait(pd *pollDesc, mode int) int {
    // â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for !netpollblock(pd, int32(mode), false) {
    err = netpollcheckerr(pd, int32(mode))
    if err != 0 {
        return err
    }
}
return 0 }
</code></pre></div></div>

<p>func netpollblock(pd *pollDesc, mode int32, waitio bool) bool {
    gpp := &amp;pd.rg
    if mode == â€˜wâ€™ {
        gpp = &amp;pd.wg
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
    // (1)
    old := *gpp
    if old == pdReady {
        *gpp = 0
        return true
    }
    if old != 0 {
        throw("runtime: double wait")
    }
    // (2)
    if atomic.Casuintptr(gpp, 0, pdWait) {
        break
    }
}
 
 
// (3)
if waitio || netpollcheckerr(pd, mode) == 0 {
    gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5)
}
 
 
// (4)
old := atomic.Xchguintptr(gpp, 0)
if old &gt; pdWait {
    throw("runtime: corrupted polldesc")
}
return old == pdReady } poll_runtime_pollWaitç­‰å¾… fd å¯è¯»ï¼Œè¿™é‡Œæœ€é‡è¦çš„é€»è¾‘åœ¨netpollblockå‡½æ•°é‡Œå®Œæˆï¼ˆæ ¹æ®ä»£ç ä¸­æ³¨é‡Šåºå·ä¾æ¬¡è§£é‡Šï¼‰: 
</code></pre></div></div>

<p>(1) æ ¹æ®modeè·å–å¯¹åº”çš„ä¿¡å·é‡åœ°å€ gppï¼Œåˆ¤æ–­å½“å‰æ˜¯å¦pdReadyã€‚</p>

<p>(2) è¿™æ®µä»£ç çš„é€»è¾‘æ˜¯å½“gppçš„å€¼å¦‚æœç­‰äº 0 æ—¶ï¼Œå°†gppçš„å€¼æ›´æ›¿ä¸ºpdWaitï¼Œè¯¥æ“ä½œå±äºåŸå­æ“ä½œä¸”å†…éƒ¨å®ç°äº†è‡ªæ—‹é”ã€‚</p>

<p>(3) å½“å€¼ä¸ºpdWaitä¹‹åï¼Œé˜²æ­¢æ­¤æ—¶å¯èƒ½ä¼šæœ‰å…¶ä»–çš„å¹¶å‘æ“ä½œä¿®æ”¹ pd é‡Œçš„å†…å®¹ï¼Œæ‰€ä»¥éœ€è¦å†æ¬¡æ£€æŸ¥é”™è¯¯çŠ¶æ€ã€‚goparkå°†å½“å‰ goroutine ç½®äºç­‰å¾…çŠ¶æ€å¹¶ç­‰å¾…ä¸‹ä¸€æ¬¡çš„è°ƒåº¦ï¼Œä½†goparkä»æœ‰å¯èƒ½å› ä¸ºè¶…æ—¶æˆ–è€…å…³é—­ä¼šç«‹å³è¿”å›ï¼Œç”±äºgoparkæ¶‰åŠåˆ° goroutine è°ƒåº¦ï¼Œåœ¨æ­¤ä¸åšèµ˜è¿°ã€‚</p>

<p>(4) é€šè¿‡åŸå­æ“ä½œå°†gppçš„å€¼è®¾ç½®ä¸º 0ï¼Œè¿”å›ä¿®æ”¹å‰çš„å€¼å¹¶åˆ¤æ–­æ˜¯å¦pdReadyã€‚</p>

<p>è‡³æ­¤ï¼ŒFD.Acceptç»“æŸè¿”å›ï¼Œä¹‹åçš„æ“ä½œä¸å‰é¢Listenç±»ä¼¼ï¼Œåˆ›å»º netFDã€åˆå§‹åŒ– netFDã€åˆ›å»º TCPConn å¯¹è±¡ã€‚</p>

<p>å°ç»“
é€šè¿‡ä¸Šé¢æµç¨‹åŒ–çš„è·Ÿè¸ªï¼Œå‘ç°netFDã€FDã€pollDescåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­å æ®éå¸¸é‡è¦çš„ä½ç½®ï¼Œå°ç»“å†…å®¹å°†ä¼šç€é‡åˆ†æè¿™å‡ ä¸ªç»“æ„ï¼Œç›®çš„åœ¨äºè§£æ„å°è£…å±‚æ¬¡ã€‚</p>

<p>netFD
netFDåŒ…å«åœ¨connç»“æ„ä¸­ï¼Œè€ŒconnåˆåŒ…å«åœ¨TCPConnç»“æ„ä¸­ï¼Œç”±æ­¤å¯è§netFDå¤„äºç”¨æˆ·æ¥å£å±‚ä¸‹é¢ã€‚</p>

<p>type netFD struct {
    pfd poll.FD</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>family      int
sotype      int
isConnected bool
net         string
laddr       Addr
raddr       Addr } netFDæ¯”è¾ƒç®€å•ï¼Œåªæœ‰ä¸€äº›åŸºæœ¬çš„ socket ä¿¡æ¯ï¼Œpfdæ˜¯å…¶ä¸‹ä¸€å±‚ï¼Œç”¨æˆ·å±‚æ¥å£çš„è°ƒç”¨ä¼šè¿›å…¥åˆ°pfdä¸­ã€‚
</code></pre></div></div>

<p>FD
type FD struct {
    // è¯»å†™é”
    fdmu fdMutex
    // ç³»ç»Ÿæ–‡ä»¶æè¿°ç¬¦
    Sysfd int
    // I/O poller.
    pd pollDesc
    // ç”¨äºåœ¨ä¸€æ¬¡å‡½æ•°è°ƒç”¨ä¸­è¯»ã€å†™å¤šä¸ªéè¿ç»­ç¼“å†²åŒºï¼Œè¿™é‡Œä¸»è¦æ˜¯å†™
    iovecs *[]syscall.Iovec
    // å…³é—­æ–‡ä»¶æ—¶çš„ä¿¡å·é‡
    csema uint32
    // å¦‚æœæ­¤æ–‡ä»¶å·²è®¾ç½®ä¸ºé˜»æ­¢æ¨¡å¼ï¼Œåˆ™ä¸ºéé›¶å€¼
    isBlocking uint32
    // TCPæˆ–UDP
    IsStream bool
    // è¯»å–åˆ°0å­—èŠ‚æ—¶æ˜¯å¦ä¸ºé”™è¯¯ï¼Œå¯¹äºåŸºäºæ¶ˆæ¯çš„åŸºç¡€socketè€Œè¨€ä¸ºfalse
    ZeroReadIsEOF bool
    // æ˜¯å¦ç³»ç»Ÿä¸­çœŸå®æ–‡ä»¶è¿˜æ˜¯socketè¿æ¥
    isFile bool
}
FDæ˜¯ Go ä¸­é€šç”¨çš„æ–‡ä»¶æè¿°ç¬¦ç±»å‹ï¼Œnet åŒ…å’Œ os åŒ…ç”¨FDæ¥è¡¨ç¤ºç½‘ç»œè¿æ¥æˆ–è€…æ–‡ä»¶ï¼ŒFDæä¾›äº†ç”¨æˆ·æ¥å£å±‚åˆ° runtime ä¹‹é—´é€»è¾‘å¤„ç†ã€‚æ­¤å¤„çš„ pollDesc æ˜¯poll.pollDescè€Œéruntime.pollDesc, poll.pollDescåœ¨internal/poll/fd_poll_runtime.goä¸­å®ç°äº†ä¸ runtime äº¤äº’çš„æ¥å£ã€‚</p>

<p>runtime.pollDesc
type pollDesc struct {
    // å­˜æ”¾pollDescï¼Œå…¨å±€
    link *pollDesc</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// lockä¿æŠ¤pollOpen, pollSetDeadline, pollUnblock and deadlineimplç­‰å¹¶å‘æ“ä½œ
// ä»¥ä¸Šæ“ä½œåŒ…æ‹¬äº†seqã€rtå’Œwtå˜é‡ï¼Œfdåœ¨pollDescç”Ÿå‘½å‘¨æœŸå†…æ’å®šï¼Œå…¶ä»–å˜é‡å‡ä»¥æ— é”æ–¹å¼
lock    mutex
fd      uintptr
// å…³é—­æ ‡è®°ï¼Œä¸€èˆ¬ä¸»åŠ¨å…³é—­æˆ–è€…è¶…æ—¶
closing bool
// æ˜¯å¦æ ‡è®°äº‹ä»¶æ‰«æé”™è¯¯
everr   bool    
user    uint32 
// fdè¢«é‡ç”¨æˆ–è€…è¯»è®¡æ—¶å™¨è¢«é‡ç½®
rseq    uintptr 
// è¯»ä¿¡å·é‡ï¼Œå€¼å¯èƒ½ä¸ºpdReadã€pdWaitã€goroutineåœ°å€æˆ–nil(0)
rg      uintptr 
// è¯»çš„ç­‰å¾…è¿‡æœŸæ—¶é—´
rt      timer   
rd      int64   
// fdè¢«é‡ç”¨æˆ–è€…å†™è®¡æ—¶å™¨è¢«é‡ç½®
wseq    uintptr
/// å†™ä¿¡å·é‡ï¼Œå€¼å¯èƒ½ä¸ºpdReadã€pdWaitã€goroutineåœ°å€æˆ–nil(0)
wg      uintptr
// å†™çš„ç­‰å¾…è¿‡æœŸæ—¶é—´
wt      timer  
wd      int64    } pollDescæ˜¯æŠ½è±¡å®ç°ï¼Œå®ƒå°† epollã€kqueueã€iocp ç­‰æ–¹å¼æŠ½è±¡ç»Ÿä¸€ï¼Œè§„å®šäº†å„ä¸ªå¹³å°å®ç°çš„æ¥å£è§„èŒƒï¼Œå³netpollã€‚
</code></pre></div></div>

<p>ç°åœ¨æˆ‘ä»¬å¤§è‡´æ¸…æ¥šäº† epoll åœ¨ Go ä¸­çš„å°è£…ç»“æ„ï¼šnetFDå°†æ¥å£é€»è¾‘è½¬å‘åˆ°FDï¼ŒFDæä¾›äº†ç”¨æˆ·æ¥å£å±‚åˆ° runtime ä¹‹é—´çš„é€»è¾‘å¤„ç†ï¼Œä¸”FDæ˜¯é€šç”¨æŠ½è±¡é€»è¾‘ï¼Œé€‚ç”¨äºæ–‡ä»¶å’Œç½‘ç»œè¿æ¥ï¼›poll.pollDescæŠ½è±¡äº†ä¸ runtime äº¤äº’çš„æ¥å£å’Œé€»è¾‘ï¼Œè€Œ epoll çš„é€»è¾‘åˆ™è¢«æ‹†åˆ†åˆ°runtime/netpoll.goå’Œruntime/netpoll_epoll.goä¸­ï¼Œæ•´ä¸ªç»“æ„æ¸æ¸å¼ï¼Œåˆ†å·¥è´£ä»»æ˜ç¡®ï¼Œå¤§è‡´å±‚æ¬¡ç»“æ„å¦‚ä¸‹ï¼š</p>

<p>æœ‰äº†ä¸Šé¢çš„å±‚æ¬¡ç»“æ„å›¾åŸºç¡€ï¼ŒReadå’ŒWriteçš„æµç¨‹å°±æ¯”è¾ƒç®€å•äº†ï¼ŒReadçš„è°ƒç”¨é“¾ï¼šconn.Readâ€“&gt;netFD.Readâ€“&gt;FD.Readï¼ŒWriteè°ƒç”¨é“¾ç±»ä¼¼ï¼ŒReadå’ŒWriteçš„åº•å±‚å®ç°åœ¨internal/poll/fd_unix.goæ–‡ä»¶ä¸­ï¼Œæœ‰å…´è¶£å¯ä»¥ç¿»é˜…ã€‚</p>

<p>poll
runtime/netpoll.goæ˜¯ poll çš„æŠ½è±¡ï¼Œå®ƒè§„èŒƒ poll å±‚å’Œ runtime å±‚ä¹‹é—´çš„äº¤äº’æ¥å£ã€‚</p>

<p>poll_runtime_pollServerInit
func poll_runtime_pollServerInit() {
    netpollinit()
    atomic.Store(&amp;netpollInited, 1)
}
poll åˆå§‹åŒ–ï¼Œåˆå§‹åŒ–ç½‘ç»œè½®è¯¢å™¨ã€‚</p>

<p>poll_runtime_isPollServerDescriptor
åˆ¤æ–­ç»™å®šçš„ fd æ˜¯å¦æ˜¯å½“å‰ epoll ä¸­ä½¿ç”¨çš„ fdã€‚</p>

<p>poll_runtime_pollOpen
func poll_runtime_pollOpen(fd uintptr) (*pollDesc, int) {
    pd := pollcache.alloc()
    // â€¦
    var errno int32
    errno = netpollopen(fd, pd)
    return pd, int(errno)
}
å¼€å¯ç½‘ç»œè½®è¯¢å™¨ã€‚pollcache.alloc()ä»pollcacheåˆ›å»ºpollDescï¼ŒpollDescåœ¨pollcacheä¸­ä»¥é“¾è¡¨çš„æ–¹å¼å­˜å‚¨ã€‚å°†pollDescå’Œ fd ç»‘å®šèµ·æ¥ï¼Œnetpollopenå°†åœ¨ä¸‹é¢è§£é‡Šã€‚</p>

<p>poll_runtime_pollClose
å…³é—­æŸä¸ªè¿æ¥ï¼Œéœ€å½“å‰è¿æ¥æ— è¯»å†™è¡Œä¸ºã€‚</p>

<p>poll_runtime_pollReset
é‡ç½®æŸä¸ªè¿æ¥ï¼Œå³é‡ç½®pollDescã€‚</p>

<p>poll_runtime_pollWait
å°±åœ°ç­‰å¾…è¯»ä¿¡å·æˆ–è€…å†™ä¿¡å·ï¼Œè¯¥å‡½æ•°åœ¨å‰ä¸€ç¯‡æ–‡ç« è¯¦è§£è¿‡ã€‚</p>

<p>poll_runtime_pollSetDeadline
è®¾ç½®åˆ°æœŸæ—¶é—´ã€‚ç½‘ç»œè¯·æ±‚è¿‡ç¨‹ä¸­å­˜åœ¨å¾ˆé«˜çš„ä¸ç¡®å®šæ€§ï¼Œå¤§éƒ¨åˆ†æƒ…å†µæˆ‘ä»¬éœ€è¦æœ‰åˆ°æœŸæ—¶é—´æ¥æ ‡è®°æŸä¸ªæ“ä½œå·²æˆªæ­¢ã€‚</p>

<p>func poll_runtime_pollSetDeadline(pd *pollDesc, d int64, mode int) {
    // å¹¶å‘è®¿é—®åŠ é”
    lock(&amp;pd.lock)
    if pd.closing {
        unlock(&amp;pd.lock)
        return
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rd0, wd0 := pd.rd, pd.wd
combo0 := rd0 &gt; 0 &amp;&amp; rd0 == wd0

// è®¡ç®—è¿‡æœŸæ—¶é—´ç‚¹
if d &gt; 0 {
    d += nanotime()
    if d &lt;= 0 {
        d = 1&lt;&lt;63 - 1
    }
}
// å°†è¿‡æœŸæ—¶é—´æ ¹æ®modeå­˜åˆ°rdå’Œwdä¸Š
if mode == 'r' || mode == 'r'+'w' {
    pd.rd = d
}
if mode == 'w' || mode == 'r'+'w' {
    pd.wd = d
}
combo := pd.rd &gt; 0 &amp;&amp; pd.rd == pd.wd
// timerå›è°ƒå‡½æ•°
rtf := netpollReadDeadline
if combo {
    rtf = netpollDeadline
}
// è¯»timer
if pd.rt.f == nil {
    if pd.rd &gt; 0 {
        pd.rt.f = rtf
        pd.rt.when = pd.rd
        // seqçš„ä½œç”¨å°±æ˜¯åœ¨timeråˆ°æœŸçš„æ—¶å€™ï¼Œå’ŒåŸpollDesc.rseqæ¯”è¾ƒï¼Œ
        // å¦‚æœä¸åŒï¼Œåˆ™é‡ç”¨æè¿°ç¬¦æˆ–é‡ç½®è®¡æ—¶å™¨
        pd.rt.arg = pd
        pd.rt.seq = pd.rseq
        addtimer(&amp;pd.rt)
    }
} else if pd.rd != rd0 || combo != combo0 {
    // é‡ç½®å½“å‰æ­£åœ¨è¿›è¡Œä¸­çš„è®¡æ—¶å™¨
    pd.rseq++
    if pd.rd &gt; 0 {  // ä¿®æ”¹è®¡æ—¶å™¨
        modtimer(&amp;pd.rt, pd.rd, 0, rtf, pd, pd.rseq)
    } else {    // åˆ é™¤è®¡æ—¶å™¨
        deltimer(&amp;pd.rt)
        pd.rt.f = nil
    }
}
// å†™è®¡æ—¶å™¨
// ...

// è·å–æ­£åœ¨è¿›è¡ŒIOæ“ä½œçš„è¯»goroutineåœ°å€æˆ–å†™goroutineåœ°å€
var rg, wg *g
if pd.rd &lt; 0 || pd.wd &lt; 0 {
    // å†…å­˜æ“ä½œ
    atomic.StorepNoWB(noescape(unsafe.Pointer(&amp;wg)), nil) 
    // è·å–å·²è¢«é˜»å¡çš„goroutineåœ°å€
    if pd.rd &lt; 0 {
        rg = netpollunblock(pd, 'r', false)
    }
    if pd.wd &lt; 0 {
        wg = netpollunblock(pd, 'w', false)
    }
}
unlock(&amp;pd.lock)
// å”¤é†’å¯¹åº”çš„goroutine
if rg != nil {
    netpollgoready(rg, 3)
}
if wg != nil {
    netpollgoready(wg, 3)
} } è¿˜æœ‰å¦å¤–ä¸€ä¸ªç±»ä¼¼å®ç°æ¥å£netpolldeadlineimplï¼Œå®é™…ä¸Šå¤§å¤šæ•°æƒ…å†µä¸‹éƒ½æ˜¯è°ƒç”¨netpollDeadlineï¼ŒnetpollReadDeadlineï¼ŒnetpollWriteDeadlineå®Œæˆã€‚
</code></pre></div></div>

<p>netpollready
func netpollready(toRun *gList, pd *pollDesc, mode int32) {
    var rg, wg *g
    if mode == â€˜râ€™ || mode == â€˜râ€™+â€™wâ€™ {
        rg = netpollunblock(pd, â€˜râ€™, true)
    }
    if mode == â€˜wâ€™ || mode == â€˜râ€™+â€™wâ€™ {
        wg = netpollunblock(pd, â€˜wâ€™, true)
    }
    if rg != nil {
        toRun.push(rg)
    }
    if wg != nil {
        toRun.push(wg)
    }
}
netpollreadyæ˜¯ epoll ä¸ŠæŠ¥äº‹ä»¶çš„æ¥å£ï¼Œé€šè¿‡ mode å–åˆ°å½“å‰è¯»å†™ goroutine åœ°å€å°†ä¹‹æ¨é€åˆ°å³å°†æ‰§è¡Œé˜Ÿåˆ—ã€‚</p>

<p>netpollunblock
// ioreadyä¸ºfalseè¡¨ç¤ºæ­¤æ¬¡è°ƒç”¨å¹¶éåº•å±‚epolläº‹ä»¶ä¸ŠæŠ¥
func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g {
    gpp := &amp;pd.rg
    if mode == â€˜wâ€™ {
        gpp = &amp;pd.wg
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
    // (1)
    old := *gpp
    if old == pdReady {
        return nil
    }
    // (2)
    if old == 0 &amp;&amp; !ioready {
        // Only set READY for ioready. runtime_pollWait
        // will check for timeout/cancel before waiting.
        return nil
    }
    var new uintptr
    if ioready {
        new = pdReady
    }
    // (3)
    if atomic.Casuintptr(gpp, old, new) {
        if old == pdReady || old == pdWait {
            old = 0
        }
        return (*g)(unsafe.Pointer(old))
    }
} } netpollunblockå°è¯•è·å–åœ¨netpollblockä¸­è¢«goparkçš„ goroutineï¼Œé€šè¿‡æŠ½è±¡æ•°æ®ç»“æ„gè¿”å›ã€‚ ï¼ˆ1ï¼‰ old == pdReadyå³å·²å”¤é†’ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨é‚ç›´æ¥è¿”å›nilã€‚ ï¼ˆ2ï¼‰ åˆå§‹åŒ–çŠ¶æ€æ—¶å€™ï¼Œå½“å‰æ—¢æ²¡ Ready çš„ goroutine ä¹Ÿæ²¡æœ‰ Wait çš„ goroutine ä¹Ÿç›´æ¥è¿”å›nilã€‚ ï¼ˆ3ï¼‰ é€šè¿‡åŸå­æ“ä½œé‡ç½®å¹¶æ‹¿åˆ°å½“å‰æ­£åœ¨è¢«goparkçš„ goroutine åœ°å€ï¼ŒæŠ½è±¡æ•°æ®ç»“æ„gè¿”å›ã€‚
</code></pre></div></div>

<p>runtime-epoll
epoll åœ¨ runtime ä¸­çš„éƒ¨åˆ†åœ¨runtime/netpoll_epoll.goæ–‡ä»¶ä¸­å®ç°ã€‚ä¸Šæ–‡ä¸­æ¶‰åŠåˆ°ä¸¤ä¸ªå‡½æ•°ï¼šnetpollinitï¼Œnetpollopenï¼Œå®é™…ä¸Šæ˜¯è°ƒç”¨åˆ°äº† epoll ä¸­ã€‚</p>

<p>netpollinit
func netpollinit() {
    epfd = epollcreate1(_EPOLL_CLOEXEC)
    if epfd &gt;= 0 {
        return
    }
    epfd = epollcreate(1024)
    if epfd &gt;= 0 {
        closeonexec(epfd)
        return
    }
    println(â€œruntime: epollcreate failed withâ€, -epfd)
    throw(â€œruntime: netpollinit failedâ€)
}
é¦–å…ˆè°ƒç”¨ epoll_create1 åˆ›å»º epoll handleï¼Œè‹¥epoll_create1å¤±è´¥å†è°ƒç”¨epoll_createã€‚</p>

<p>netpollopen
func netpollopen(fd uintptr, pd *pollDesc) int32 {
    var ev epollevent
    ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET
    *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd
    return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;ev)
}
epoll äº‹ä»¶æ³¨å†Œï¼Œæ³¨å†Œè¿™ä¸ª epoll é‡Œå…³å¿ƒçš„äº‹ä»¶ï¼Œå¹¶å°† user data è®¾ç½®ä¸ºruntime.pollDescï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆ netpoll ç³»åˆ—å‡½æ•°å‡ä»¥pollDescä¸ºå‚æ•°ã€‚</p>

<p>netpollclose
func netpollclose(fd uintptr) int32 {
    var ev epollevent
    return -epollctl(epfd, _EPOLL_CTL_DEL, int32(fd), &amp;ev)
}
ä» epoll ä¸­å‰”é™¤æŸä¸ªä¸å†å…³å¿ƒçš„ fdï¼Œåº”ç”¨äºä¸»åŠ¨å…³é—­æˆ–è¶…æ—¶å…³é—­ã€‚</p>

<p>netpoll
netpollä¸­è°ƒç”¨äº† epoll ä¸­ç¬¬ä¸‰ä¸ª APIï¼šepoll_waitã€‚</p>

<p>func netpoll(block bool) gList {
    if epfd == -1 {
        return gList{}
    }
    waitms := int32(-1)
    if !block {
        waitms = 0
    }
    var events [128]epollevent
retry:
    // (1)
    n := epollwait(epfd, &amp;events[0], int32(len(events)), waitms)
    if n &lt; 0 {
        if n != -_EINTR {
            println(â€œruntime: epollwait on fdâ€, epfd, â€œfailed withâ€, -n)
            throw(â€œruntime: netpoll failedâ€)
        }
        goto retry
    }
    // (2)
    var toRun gList
    for i := int32(0); i &lt; n; i++ {
        ev := &amp;events[i]
        if ev.events == 0 {
            continue
        }
        var mode int32
        // é€šè¿‡netpollopenæ³¨å†Œçš„epollå…³å¿ƒäº‹ä»¶ç¡®å®šæ˜¯å¦è¯»å†™äº‹ä»¶
        if ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {
            mode += â€˜râ€™
        }
        if ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {
            mode += â€˜wâ€™
        }
        if mode != 0 {
            // ç”±netpollopenå¯çŸ¥ï¼Œæ­¤å¤„çš„&amp;ev.dataæ˜¯pollDesc
            pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))
            pd.everr = false
            if ev.events == _EPOLLERR {
                pd.everr = true
            }
            // å”¤é†’goroutine
            netpollready(&amp;toRun, pd, mode)
        }
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if block &amp;&amp; toRun.empty() {
    goto retry
}
// è¿”å›å¯ä»¥æ‰§è¡Œäº‹ä»¶çš„goroutineåœ°å€é›†åˆ
return toRun } ï¼ˆ1ï¼‰ è°ƒç”¨epoll_waitè·å–äº‹ä»¶ï¼Œå½“æ¬¡æœ€å¤šè·å– 128 ä¸ª epoll äº‹ä»¶ã€‚ ï¼ˆ2ï¼‰ æ ¹æ®äº‹ä»¶ç±»å‹å”¤é†’è¯»å†™ goroutineã€‚
</code></pre></div></div>

<p>ä»æ•´ä¸ªæµç¨‹ä¸Šæ¥çœ‹ï¼Œåˆ†åˆ«è°ƒç”¨äº† epoll ä¸­çš„ä¸‰ä¸ª APIï¼šepoll_createï¼Œepoll_ctlä»¥åŠepoll_waitï¼Œé€šè¿‡å±‚çº§åŒ–çš„å°è£…ä½¿ç”¨ epoll å®Œæˆ IO å¤šè·¯å¤ç”¨ã€‚è¿™é‡Œå¾ˆå¤šäººå¯èƒ½ä¼šå¥½å¥‡ï¼Œnetpollæ˜¯åœ¨å“ªé‡Œè°ƒç”¨çš„ï¼Ÿ</p>

<p>å®é™…ä¸Šnetpollæ˜¯åœ¨runtime.proc.goè¢«åº•å±‚å¤šå¤„è°ƒç”¨ï¼Œä»¥ Go1.13 ä¸ºä¾‹ï¼Œruntime.proc.goä¸­æœ‰å››å¤„è°ƒç”¨netpollï¼Œåˆ†åˆ«æ˜¯ï¼š
func startTheWorldWithSema(emitTraceEvent bool) int64
func findrunnable() (gp *g, inheritTime bool)
func pollWork() bool
func sysmon()
ä»¥ä¸Šå‡æ¶‰åŠåˆ°åº•å±‚è½®è¯¢å™¨å’Œè°ƒåº¦å™¨ã€‚</p>

<p>å°ç»“
é€šè¿‡å‰é¢çš„å†…å®¹ï¼Œæˆ‘ä»¬æ¸…æ¥šäº† epoll åœ¨ Go ä¸­æ˜¯å¦‚ä½•å°è£…çš„ï¼Œå¯¹ç”¨æˆ·æ¥å£å±‚ç®€åŒ–äº†Listenã€Acceptã€Readã€Writeç­‰æ¥å£ï¼Œç®€å•å‹å¥½çš„æ¥å£ç»™ç”¨æˆ·å±‚çš„é€»è¾‘ä»£ç æä¾›ç›¸å½“å¤§çš„ä¾¿åˆ©ã€‚</p>

<p>è€Œä» net åŒ…çš„æ•´ä½“å®ç°æ¥çœ‹ï¼Œå¯¹äºç”¨æˆ·è€Œè¨€ï¼šnet çš„å®ç°æ˜¯åŸºäº epoll çš„ nonblock æ¨¡å¼çš„ä¸€äº›åˆ— fd æ“ä½œã€‚ç½‘ç»œæ“ä½œæœª Ready æ—¶åˆ‡æ¢ goroutineï¼ŒReady åç­‰å¾…è°ƒåº¦çš„ goroutine åŠ å…¥è¿è¡Œé˜Ÿåˆ—ï¼Œå®ç°äº†ç½‘ç»œæ“ä½œæ—¢ä¸é˜»å¡åˆæ˜¯åŒæ­¥æ‰§è¡Œï¼Œè¿™ä¹Ÿå°±æ˜¯å‰ä¸€ç¯‡æ–‡ç« æ‰€è¯´çš„ epoll+goroutine</p>
:ET