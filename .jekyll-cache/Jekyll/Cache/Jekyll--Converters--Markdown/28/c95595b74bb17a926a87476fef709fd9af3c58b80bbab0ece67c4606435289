I"¥1<p>å¯¹äºMixin(æ··åˆ)ã€Traitï¼ˆç‰¹æ€§ï¼‰è¿™ä¸¤ä¸ªé¢å‘å¯¹è±¡ç‰¹æ€§ï¼Œæ€»æ˜¯è®©äººè§‰å¾—è¯´ä¸æ¸…é“ä¸æ˜çš„æ„Ÿè§‰ï¼Œå…¶å®ä¼—å¤šè®¾è®¡è¯­è¨€é‡Œï¼Œè¿™é‡Œé¢çš„ä¸€äº›æ¦‚å¿µä¹Ÿæ˜¯ç›¸äº’å‚æ‚çš„ï¼Œå¹¶ä¸æ˜¯åˆé‚£ä¹ˆä¸€ä¸ªä¸¥æ ¼çš„å®šä¹‰æˆ–ç•Œé™è¯´å“ªç§ä¸€å®šæ˜¯Mixinï¼Œæˆ–è€…å“ªç§ä¸€å®šæ˜¯Traitã€‚è¿™ä¸¤ç§è¯­è¨€è®¾æ–½çš„æå‡ºï¼Œå®ƒçš„æœ¬è´¨å®é™…ä¸Šéƒ½æ˜¯è§£å†³ä»£ç å¤ç”¨çš„é—®é¢˜ã€‚</p>

<p>The developers of the Java language were well-versed in C++ and other languages that include multiple inheritance, whereby classes can inherit from an arbitrary number of parents. One of the problems with multiple inheritance is that itâ€™s impossible to determine which parent inherited functionality is derived from. This problem is called the diamond problem (see Resources). The diamond problem and other complexities that are inherent in multiple inheritance inspired the Java language designers to opt for single inheritance plus interfaces.</p>

<p>Interfaces define semantics but not behavior. They work well for defining method signatures and data abstractions, and all of the Java.next languages support Java interfaces with no essential changes. However, some cross-cutting concerns donâ€™t fit into a single-inheritance-plus-interfaces model.</p>

<p>åœ¨Java ä¸­ï¼Œä¸€ä¸ªç±»å¯ä»¥å®ç°ä»»æ„æ•°é‡çš„æ¥å£ã€‚è¿™ä¸ªæ¨¡å‹åœ¨å£°æ˜ä¸€ä¸ªç±»å®ç°å¤šä¸ªæŠ½è±¡çš„æ—¶å€™éå¸¸æœ‰ç”¨ã€‚ä¸å¹¸çš„æ˜¯ï¼Œå®ƒä¹Ÿæœ‰ä¸€ä¸ªä¸»è¦ç¼ºç‚¹ã€‚å¯¹äºè®¸å¤šæ¥å£ï¼Œå¤§å¤šæ•°åŠŸèƒ½éƒ½å¯ä»¥ç”¨å¯¹äºæ‰€æœ‰ä½¿ç”¨è¿™ä¸ªæ¥å£çš„ç±»éƒ½æœ‰æ•ˆçš„â€œæ ·æ¿â€ä»£ç æ¥å®ç°ã€‚Java æ²¡æœ‰æä¾›ä¸€ä¸ªå†…ç½®æœºåˆ¶æ¥å®šä¹‰å’Œä½¿ç”¨è¿™äº›å¯é‡ç”¨ä»£ç ã€‚ç›¸åçš„ï¼ŒJava ç¨‹åºå‘˜å¿…é¡»ä½¿ç”¨ä¸€ä¸ªç‰¹åˆ«çš„è½¬æ¢æ¥é‡ç”¨ä¸€ä¸ªå·²çŸ¥æ¥å£çš„å®ç°ã€‚åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œç¨‹åºå‘˜å¿…é¡»å¤åˆ¶ç²˜è´´åŒæ ·çš„ä»£ç åˆ°ä¸åŒçš„ç±»ä¸­å»ã€‚</p>

<p>æœ¬äººè®¤ä¸ºè¿™ä¸¤ä¸ªçš„æ¶µä¹‰æ ¹æ®è¯­è¨€ä¸åŒï¼Œè€Œè§£é‡Šæœ‰æ‰€ä¸åŒã€‚ä½†æ˜¯å®ƒä»¬çš„ç›®çš„éƒ½æ˜¯ä½œä¸ºå•ç»§æ‰¿ä¸è¶³çš„ä¸€ç§è¡¥å……ï¼Œæˆ–è€…æ˜¯å˜ç›¸åœ°å®ç°å¤šç»§æ‰¿ã€‚å®é™…ä¸ŠJavaçš„æ¥å£ä¹Ÿæ˜¯å˜ç›¸çš„å®ç°å¤šç»§æ‰¿ï¼Œä½†æ˜¯javaçš„æ¥å£åªæ˜¯å®šä¹‰signatureï¼Œæ²¡æœ‰å®ç°ä½“ã€‚åœ¨æŸç§æ„ä¹‰ä¸ŠMixinå’ŒTraitè¿™ä¸¤è€…æœ‰ç‚¹ç±»ä¼¼äºæŠ½è±¡ç±»ï¼Œæˆ–è€…æ˜¯æœ‰éƒ¨åˆ†æˆ–å…¨éƒ¨å®ç°ä½“çš„Interfaceï¼Œä½†æ˜¯åœ¨å…·ä½“è¯­è¨€ä¸­ï¼Œæœ‰è¡¨ç°å‡ºä¸ä¸€æ ·çš„ç”¨æ³•ã€‚æ€»ä½“ä¸Šï¼Œç¬”è€…è®¤ä¸ºæ²¡æœ‰ç‰¹åˆ«å›ºå®šçš„æˆ–è€…æ˜¯ä¸¥æ ¼çš„åŒºåˆ«ã€‚Mixinå’ŒTraitè¿™ä¸¤è€…éƒ½ä¸èƒ½ç”Ÿæˆå®ä¾‹ï¼Œå¦åˆ™å°±è·Ÿclassæ²¡ä»€ä¹ˆåŒºåˆ«äº†ã€‚
<!-- more -->
Scala trait
class Person ; //å®éªŒç”¨çš„ç©ºç±»</p>

<p>trait TTeacher extends Person {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def teach //è™šæ–¹æ³•ï¼Œæ²¡æœ‰å®ç°  
</code></pre></div></div>

<p>}<br />
trait TPianoPlayer extends Person {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def playPiano = {println("Iâ€™m playing piano. ")} //å®æ–¹æ³•ï¼Œå·²å®ç°  
</code></pre></div></div>

<p>}<br />
class PianoplayingTeacher extends Person with TTeacher with TPianoPlayer {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def teach = {println("Iâ€™m teaching students. ")} //å®šä¹‰è™šæ–¹æ³•çš„å®ç°  
</code></pre></div></div>

<p>}</p>

<p>PHP traits
  // the template
trait TSingleton {
  private static $_instance = null;</p>

<p>public static function getInstance() {
    if (null === self::$_instance)
    {
      self::$_instance = new self();
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return self::$_instance;   } } class FrontController {   use TSingleton; } // can also be used in already extended classes class WebSite extends SomeClass {   use TSingleton; }
</code></pre></div></div>

<p>Ruby mixin
module Foo
  def bar
    puts â€œfooâ€;
  end
end</p>

<p>ç„¶åæˆ‘ä»¬æŠŠè¿™ä¸ªæ¨¡å—æ··å…¥åˆ°å¯¹è±¡ä¸­å»ï¼š
class Demo
  include Foo
end</p>

<p>å¦‚ä¸Šç¼–ç åï¼Œæ¨¡å—ä¸­çš„å®ä¾‹æ–¹æ³•å°±ä¼šè¢«æ··å…¥åˆ°å¯¹è±¡ä¸­ï¼š
d=Demo.new
d.bar</p>

<p>åŒºåˆ«ï¼š
1ï¼‰Mixinå¯èƒ½æ›´å¤šçš„æ˜¯æŒ‡åŠ¨æ€è¯­è¨€ï¼Œå®ƒæ˜¯åœ¨æ‰§è¡Œåˆ°æŸä¸ªç‚¹çš„æ—¶å€™ï¼Œå°†ä»£ç æ’å…¥åˆ°å…¶ä¸­æ¥è¾¾åˆ°ä»£ç å¤ç”¨çš„æ•ˆæœã€‚Traitæ›´å¤šçš„æ˜¯ç¼–è¯‘è¿‡ç¨‹ä¸­ï¼Œé€šè¿‡ä¸€äº›é™æ€æ‰‹æ®µèµ‹å€¼ä»£ç åˆ°ç±»ä¸­ä½¿å¾—å…¶æ‹¥æœ‰Traitä¸­çš„ä¸€äº›åŠŸèƒ½ä»¥è¾¾åˆ°ä»£ç å¤ç”¨çš„ç›®çš„ï¼›
2ï¼‰â€œMixins may contain state, (traditional) traits donâ€™t.â€è¿™ä¸ªåŒºåˆ«æ¯”è¾ƒå¼±ï¼Œäº‹å®ä¸ŠScalaä¸­Traitå·²ç»å¯ä»¥ä¿å­˜çŠ¶æ€äº†ï¼ˆæˆå‘˜å˜é‡ï¼‰ï¼›
3ï¼‰â€œMixins use â€œimplicit conflict resolutionâ€, traits use â€œexplicit conflict resolutionâ€â€ã€‚è¿™ä¸ªåŒºåˆ«å¯èƒ½æ˜¯ä¸ªæ˜æ˜¾çš„åŒºåˆ«ï¼›ä½†æ˜¯å¦‚æœæŸä¸ªè¯­è¨€å®ƒå¯ä»¥è®©Trait implicit resolveï¼Œé‚£ä¹Ÿæ²¡ä»€ä¹ˆå¤§ä¸äº†ã€‚
4ï¼‰â€œMixins depends on linearization, traits are flattened.â€è¿™ä¸ªåŒºåˆ«å¯èƒ½æœ‰ã€‚è‡³å°‘Scalaé‡Œé¢è²Œä¼¼Traitæ˜¯Flattenedå¤„ç†çš„ï¼Œè·ŸJavaåµŒå¥—ç±»å·®ä¸å¤š</p>

<p>ç¨‹åºè®¾è®¡ä¸­ï¼Œæ˜¯è¯¥ç”¨ç±»è¿˜æ˜¯Mixin&amp;Trait</p>

<p>å½“æˆ‘ä»¬è€ƒè™‘æ˜¯å¦ä¸€ä¸ªâ€œæ¦‚å¿µâ€åº”è¯¥æˆä¸ºä¸€ä¸ªTrait æˆ–è€…ä¸€ä¸ªç±»çš„æ—¶å€™ï¼Œè®°ä½ä½œä¸ºæ··å…¥çš„Trait å¯¹äºâ€œé™„å±â€è¡Œä¸ºæ¥è¯´æœ€æœ‰æ„ä¹‰ã€‚å¦‚æœä½ å‘ç°æŸä¸€ä¸ªTrait ç»å¸¸ä½œä¸ºå…¶å®ƒç±»çš„çˆ¶ç±»æ¥ç”¨ï¼Œå¯¼è‡´å­ç±»ä¼šæœ‰åƒçˆ¶Trait é‚£æ ·çš„è¡Œä¸ºï¼Œé‚£ä¹ˆè€ƒè™‘æŠŠå®ƒå®šä¹‰ä¸ºä¸€ä¸ªç±»å§ï¼Œè®©è¿™æ®µé€»è¾‘å…³ç³»æ›´åŠ æ¸…æ™°</p>

<p>å¯¹äºMixin(æ··åˆ)ã€Traitï¼ˆç‰¹æ€§ï¼‰è¿™ä¸¤ä¸ªé¢å‘å¯¹è±¡ç‰¹æ€§ï¼Œæ€»æ˜¯è®©äººè§‰å¾—è¯´ä¸æ¸…é“ä¸æ˜çš„æ„Ÿè§‰ï¼Œå…¶å®ä¼—å¤šè®¾è®¡è¯­è¨€é‡Œï¼Œè¿™é‡Œé¢çš„ä¸€äº›æ¦‚å¿µä¹Ÿæ˜¯ç›¸äº’å‚æ‚çš„ï¼Œå¹¶ä¸æ˜¯åˆé‚£ä¹ˆä¸€ä¸ªä¸¥æ ¼çš„å®šä¹‰æˆ–ç•Œé™è¯´å“ªç§ä¸€å®šæ˜¯Mixinï¼Œæˆ–è€…å“ªç§ä¸€å®šæ˜¯Traitã€‚è¿™ä¸¤ç§è¯­è¨€è®¾æ–½çš„æå‡ºï¼Œå®ƒçš„æœ¬è´¨å®é™…ä¸Šéƒ½æ˜¯è§£å†³ä»£ç å¤ç”¨çš„é—®é¢˜ã€‚</p>

<p>The developers of the Java language were well-versed in C++ and other languages that include multiple inheritance, whereby classes can inherit from an arbitrary number of parents. One of the problems with multiple inheritance is that itâ€™s impossible to determine which parent inherited functionality is derived from. This problem is called the diamond problem (see Resources). The diamond problem and other complexities that are inherent in multiple inheritance inspired the Java language designers to opt for single inheritance plus interfaces.</p>

<p>Interfaces define semantics but not behavior. They work well for defining method signatures and data abstractions, and all of the Java.next languages support Java interfaces with no essential changes. However, some cross-cutting concerns donâ€™t fit into a single-inheritance-plus-interfaces model.</p>

<p>åœ¨Java ä¸­ï¼Œä¸€ä¸ªç±»å¯ä»¥å®ç°ä»»æ„æ•°é‡çš„æ¥å£ã€‚è¿™ä¸ªæ¨¡å‹åœ¨å£°æ˜ä¸€ä¸ªç±»å®ç°å¤šä¸ªæŠ½è±¡çš„æ—¶å€™éå¸¸æœ‰ç”¨ã€‚ä¸å¹¸çš„æ˜¯ï¼Œå®ƒä¹Ÿæœ‰ä¸€ä¸ªä¸»è¦ç¼ºç‚¹ã€‚å¯¹äºè®¸å¤šæ¥å£ï¼Œå¤§å¤šæ•°åŠŸèƒ½éƒ½å¯ä»¥ç”¨å¯¹äºæ‰€æœ‰ä½¿ç”¨è¿™ä¸ªæ¥å£çš„ç±»éƒ½æœ‰æ•ˆçš„â€œæ ·æ¿â€ä»£ç æ¥å®ç°ã€‚Java æ²¡æœ‰æä¾›ä¸€ä¸ªå†…ç½®æœºåˆ¶æ¥å®šä¹‰å’Œä½¿ç”¨è¿™äº›å¯é‡ç”¨ä»£ç ã€‚ç›¸åçš„ï¼ŒJava ç¨‹åºå‘˜å¿…é¡»ä½¿ç”¨ä¸€ä¸ªç‰¹åˆ«çš„è½¬æ¢æ¥é‡ç”¨ä¸€ä¸ªå·²çŸ¥æ¥å£çš„å®ç°ã€‚åœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œç¨‹åºå‘˜å¿…é¡»å¤åˆ¶ç²˜è´´åŒæ ·çš„ä»£ç åˆ°ä¸åŒçš„ç±»ä¸­å»ã€‚</p>

<p>ç°åœ¨æ’åé å‰çš„é¢å‘å¯¹è±¡çš„ç¼–ç¨‹è¯­è¨€ä¸­ï¼ŒJavaã€C#ç­‰éƒ½æ˜¯ä»¥å•ç»§æ‰¿+æ¥å£æ¥å®ç°é¢å‘å¯¹è±¡ï¼Œä½†æ˜¯è¿™åœ¨ä¸€å®šç¨‹åºäº†ç¨€é‡Šäº†ç»§æ‰¿çš„åŠ›é‡ï¼Œ å› ä¸ºåœ¨ä¸šå†…æ¨èä»¥ç»„åˆçš„æ–¹å¼ä½¿ç”¨ç±»ã€‚è¿™åœ¨ä¸€äº›å¸¸è§çš„è®¾è®¡æ¨¡å¼ä¸­æœ‰æ˜æ˜¾çš„ä½“ç°ï¼Œæƒ³æƒ³åœ¨GOFçš„23ä¸ªè®¾è®¡æ¨¡å¼ä¸­æœ‰å¤šå°‘ä¸ªæ˜¯ä½¿ç”¨äº†ç»§æ‰¿çš„å‘¢ï¼Ÿ å¤§å¤šæ•°æ˜¯ä»¥æ¥å£+ç»„åˆçš„æ–¹å¼å®ç°ã€‚å…¶å®ä½œä¸ºä¸€ä¸ªç±»æ¥è¯´ï¼Œå®ƒä¹Ÿæ¯”è¾ƒéš¾åšï¼Œå³è¦èƒ½ä»£ç å¤ç”¨ï¼Œåˆå¾—è¢«å®ä¾‹åŒ–ï¼Œåå‘è°å‘¢ï¼Ÿ è¿™ä¸ªæ—¶å€™Mixinå¯èƒ½å°±æœ‰ä¸€äº›ç”¨æ­¦ä¹‹åœ°äº†ã€‚</p>

<p>Mixinæœ€æ—©èµ·æºäºä¸€ä¸ªLispï¼ŒMixiné¼“åŠ±ä»£ç é‡ç”¨ï¼ŒMixinå¯ä»¥å®ç°è¿è¡Œæ—¶çš„æ–¹æ³•ç»‘å®šï¼Œè™½ç„¶ç±»çš„å±æ€§å’Œå®ä¾‹å‚æ•°ä»ç„¶æ˜¯åœ¨ç¼–è¯‘æ—¶å®šä¹‰ã€‚ åœ¨é¢å‘å¯¹è±¡ç¼–ç¨‹è¯­è¨€ï¼ŒMixinæ˜¯ä¸€ä¸ªæä¾›äº†ä¸€äº›è¢«ç”¨äºç»§æ‰¿æˆ–åœ¨å­ç±»ä¸­é‡ç”¨çš„åŠŸèƒ½çš„ç±»ï¼Œå®ƒç±»ä¼¼äºä¸€ç§å¤šç»§æ‰¿ï¼Œ ä½†æ˜¯å®é™…ä¸Šå®ƒæ˜¯ä¸€ç§ä¸­å°ç²’åº¦çš„ä»£ç å¤ç”¨å•å…ƒï¼Œè€Œä¸ç›´æ¥ç”¨äºå®ä¾‹åŒ–ã€‚ è™½ç„¶è¿™ä¸æ˜¯ä¸€ç§ä¸“ä¸šçš„æ–¹å¼è¿›è¡ŒåŠŸèƒ½å¤ç”¨ï¼Œè¿™åœ¨å®ç°å¤šç»§æ‰¿çš„åŒæ—¶ï¼Œåœ¨ä¸€å®šç¨‹åºä¸Šé¿å…äº†å¤šç»§æ‰¿çš„æ˜æ˜¾é—®é¢˜ã€‚</p>

<p>PHPå’ŒJavaç±»ä¼¼ï¼Œä¹Ÿæ˜¯å•ç»§æ‰¿+æ¥å£ã€‚ æˆ‘ä»¬çŸ¥é“ï¼Œä¸€ä¸ªç±»å¯ä»¥å®ç°ä»»æ„æ•°é‡çš„æ¥å£ï¼Œè¿™å¯¹ä¸€ä¸ªç±»éœ€è¦å®ç°å¤šä¸ªæŠ½è±¡çš„æ—¶å€™éå¸¸æœ‰ç”¨ã€‚ ç„¶è€Œï¼Œå¯¹äºè¦å®ç°äº†å¤šä¸ªæ¥å£çš„ç±»ï¼Œæ¯ä¸ªç±»éƒ½éœ€è¦å®ç°è¿™äº›æ¥å£ï¼Œè€Œå¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œè¿™äº›æ¥å£éƒ½æ˜¯å¯ä»¥å…±ç”¨çš„ã€‚ PHPå¹¶æ²¡æœ‰æä¾›å†…ç½®æœºåˆ¶æ¥å®šä¹‰å’Œä½¿ç”¨è¿™äº›å¯é‡ç”¨ä»£ç ï¼Œè™½ç„¶æˆ‘ä»¬å¯ä»¥å¯¹ä¸€åœ°äº›æ¥å£ä½¿ç”¨ä¸€ä¸ªæŠ½è±¡ç±»æ¥å…±ç”¨ä»£ç ï¼Œä½†æ˜¯å¦‚æœè¿™äº›ç±»å¿…é¡»ç»§æ‰¿å¦ä¸€ä¸ªæŠ½è±¡ç±»å‘¢ï¼Ÿ å°±ç®—æ˜¯å¯ä»¥é€šè¿‡æŠ½è±¡ç±»çš„å¤šæ¬¡ç»§æ‰¿å®ç°ä»£ç çš„å…±ç”¨ï¼Œä½†æ˜¯æ•´ä¸ªç»§æ‰¿ä½“ç³»å°†ä¼šå˜å¾—éå¸¸å¤æ‚ï¼Œå¦‚æœä¸èƒ½å®ç°é‡ç”¨ï¼Œé‚£ä¹ˆå¯èƒ½æˆ‘ä»¬åªå¾—CTRL + C å’Œ CTRL + Väº†ã€‚ å¤§å¤šæ•°çš„æƒ…å†µä¸‹æˆ‘ä»¬å…¶å®åªæ˜¯éœ€è¦é‡ç”¨ä¸€äº›ä»£ç è€Œå·²ã€‚</p>

<p>è™½ç„¶PHPåœ¨ä¹‹å‰æ²¡æœ‰æä¾›å®Œå–„çš„è§£å†³æ–¹æ¡ˆï¼Œä½†åœ¨æ–°å‘å¸ƒPHP5.4ä¸­ï¼Œå‡ºç°äº†ä¸€ä¸ªå…³é”®å­—traitã€‚ é€šè¿‡è¿™ä¸ªå…³é”®å­—æˆ‘ä»¬å¯ä»¥å®šä¹‰æŠ½è±¡ä¸ºä¸€ä¸ªTrait</p>

<p>https://wiki.php.net/rfc/traits</p>

<p>https://stackoverflow.com/questions/925609/mixins-vs-traits</p>

<p>Mixins may contain state, (traditional) traits donâ€™t.
Mixins use â€œimplicit conflict resolutionâ€, traits use â€œexplicit conflict resolutionâ€
Mixins depends on linearization, traits are flattened.</p>

<p>http://stephane.ducasse.free.fr/Presentations/2009-TraitsAtSC.pdf</p>

<p>ad 1. In mixins you can define instance variables. Traits do not allow this. The state must be provided by composing class (=class using the traits)</p>

<p>ad 2. There may be the name conflict. Two mixins (MA and MB) or traits (TA and TB) define method with the same definition foo():void.</p>

<p>Mixin MA {
    foo():void {
        print â€˜helloâ€™
    }
}</p>

<p>Mixin MB {
    foo():void {
        print â€˜byeâ€™
    }
}</p>

<p>Trait TA {
    foo():void {
        print â€˜helloâ€™
    }
}</p>

<p>Trait TB {
    foo():void {
        print â€˜byeâ€™
    }
}
In mixins the conflicts in composing class C mixins MA, MB are resolved implicitly.</p>

<p>Class C mixins MA, MB {
    bar():void {
        foo();
    }
}
This will call foo():void from MA</p>

<p>On the other hand while using Traits, composing class has to resolve conflicts.</p>

<p>Class C mixins TA, TB {
    bar():void {
        foo();
    }
}
This code will raise conflict (two definitions of foo():void).</p>

<p>ad 3. The semantics of a method does not depend of whether it is defined in a trait or in a class that uses the trait.</p>

<p>In other words, it does not matter wheter the class consists of the Traits or the Traits code is â€œcopy - pastedâ€ into the class.</p>

<p>ä½œè€…ï¼šåˆ˜ç¼™
é“¾æ¥ï¼šhttps://www.zhihu.com/question/49094001/answer/124322283
æ¥æºï¼šçŸ¥ä¹
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚</p>

<p>å¦‚æœæˆ‘ä»¬æœ‰ä¸¤ä¸ªç±»ï¼šclass A {
    public f();
    public g();
    private int a;
    private int b;
};</p>

<p>class B {
    public h();
    private int x;
};åœ¨ç»„åˆè¿™ä¸¤ä¸ªç±»çš„æ‰€æœ‰æ–¹æ³•ä¸­ï¼Œä¸€ä¸ªæç«¯æ˜¯ä»…ä»…æŠŠä¸¤ä¸ªç±»çš„å¯¹è±¡ç»„åˆèµ·æ¥ï¼Œå¹¶ä¸”ç»™ä¸¤ä¸ªç±»çš„å…¬å¼€æ–¹æ³•éƒ½ä½œè½¬å‘ï¼šclass AplusB {
    public f() { a.f(); }
    public g() { a.g(); }
    public h() { b.h(); }
    private A a;
    private B b;
};ç‰¹ç‚¹æ˜¯ï¼šå®Œå…¨ä¸ç ´åå°è£…ï¼ˆä¸éœ€è¦äº†è§£Aå’ŒBçš„å®ç°ï¼‰ã€‚åªéœ€è¦è§£å†³Aå’ŒBå…¬å¼€æ–¹æ³•çš„åå­—å†²çªã€‚å¦ä¸€ä¸ªæç«¯æ˜¯æŠŠä¸¤ä¸ªç±»çš„å®ç°æ‹·è´ç²˜è´´åœ¨ä¸€èµ·ï¼šclass AplusB {
    public f();
    public g();
    public h();
    private int a;
    private int b;
    private int x;
};
ç‰¹ç‚¹æ˜¯ï¼šå’Œç»§æ‰¿ä¸€æ ·ï¼Œæœ€å¤§é™åº¦åœ°ç ´åäº†å°è£…ï¼ˆä¸¤ä¸ªç±»å¿…é¡»äº†è§£å¯¹æ–¹çš„å®ç°æ‰èƒ½ååŒå·¥ä½œï¼‰éœ€è¦è§£å†³æ‰€æœ‰å¯èƒ½çš„åå­—å†²çªï¼ˆæ–¹æ³•ã€å±æ€§ï¼‰å¤šç»§æ‰¿ã€traitsã€mixinç­‰ç­‰ï¼Œå…¶å®éƒ½æ˜¯åœ¨è¿™ä¸¤ä¸ªæç«¯ä¹‹é—´ï¼Œå¹¶ä¸”é€‰æ‹©ä¸åŒçš„åå­—å†²çªè§£å†³ç­–ç•¥ï¼Œä»…æ­¤è€Œå·²ã€‚å®ƒä»¬æ²¡æœ‰ç»å¯¹çš„ä¼˜åŠ£ä¹‹åˆ†ï¼Œåˆ†åˆ«é€‚ç”¨äºä¸åŒçš„åœºæ™¯ã€‚åå‘å‰è€…çš„ï¼Œéœ€ç»„åˆçš„ä¸¤ä¸ªç±»å¯ä»¥ç‹¬ç«‹è®¾è®¡è€Œä¸è€ƒè™‘é…åˆï¼Œå„è‡ªçš„å†…éƒ¨å®ç°å¯ä»¥éšæ„ä¿®æ”¹è€Œä¸å½±å“ç»„åˆçš„ç»“æœï¼Œé€‚ç”¨èŒƒå›´å¹¿ï¼›åå‘åè€…çš„ï¼Œéœ€ç»„åˆçš„ä¸¤ä¸ªç±»å†…éƒ¨å®ç°éœ€è¦ä¸¥æ ¼é…åˆï¼Œç»“æœç²¾å·§è„†å¼±ï¼Œä½†è¡¨è¾¾èƒ½åŠ›å¼ºï¼Œåšå¥½äº†èƒ½å‘æŒ¥å‡º1+1&gt;2çš„æ•ˆæœï¼Œé€‚ç”¨äºå±€éƒ¨ã€å°‘æ•°äººå‚ä¸çš„åœºæ™¯ã€‚</p>
:ET