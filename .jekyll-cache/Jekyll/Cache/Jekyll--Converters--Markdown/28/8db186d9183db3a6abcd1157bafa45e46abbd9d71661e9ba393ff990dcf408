I"Üv<p>ç»å…¸å¹³æ»‘å‡çº§æ–¹æ¡ˆ</p>

<p>æœåŠ¡å™¨å¼€å‘è¿ç»´ä¸­ï¼Œå¹³æ»‘å‡çº§æ˜¯ä¸€ä¸ªè€ç”Ÿå¸¸è°ˆçš„è¯é¢˜ã€‚æ‹¿ä¸€ä¸ªhttp serveræ¥è¯´ï¼Œæœ€å¸¸è§çš„æ–¹æ¡ˆå°±æ˜¯åœ¨http serverå‰é¢åŠ æŒ‚ä¸€ä¸ªlvsè´Ÿè½½ï¼Œé€šè¿‡å¥åº·æ£€æŸ¥æ¥å£å†³å®šè´Ÿè½½çš„å¯¼å…¥ä¸æ‘˜é™¤ã€‚å…·ä½“æ¥è¯´å°±æ˜¯http server æä¾›ä¸€ä¸ª/status æ¥å£ï¼ŒæœåŠ¡å™¨è¿”å›ä¸€ä¸ªstatusæ–‡ä»¶ï¼Œå†…å®¹ä¸ºokï¼Œlvsè´Ÿè½½å®šæ—¶è®¿é—®è¿™ä¸ªæ¥å£ï¼Œåˆ¤æ–­æœåŠ¡å¥åº·çŠ¶å†µå†³å®šå¯¼å…¥æµé‡å’Œåˆ‡æ–­æµé‡ã€‚ä¸€èˆ¬éƒ½ä¼šå®šä¸€äº›ç­–ç•¥ï¼Œæ¯”å¦‚ï¼šè®¿é—®é—´éš”5ç§’ï¼Œå¥åº·é˜ˆå€¼2ï¼Œå¼‚å¸¸é˜ˆå€¼2ä¹‹ç±»çš„ã€‚æ„æ€å°±æ˜¯æ¯éš”5ç§’è®¿é—®ä¸€æ¬¡/statusæ¥å£ï¼Œ2æ¬¡æˆåŠŸåï¼Œç¡®è®¤æœåŠ¡æ­£å¸¸ï¼Œå¼€å§‹å¯¼å…¥æµé‡ï¼Œ2æ¬¡å¤±è´¥ç¡®è®¤æœåŠ¡å¼‚å¸¸åˆ‡æ–­æµé‡ã€‚å½“æœåŠ¡å‡çº§æ—¶ï¼Œä¿®æ”¹statusæ–‡ä»¶å†…å®¹ä¸ºoffï¼Œç­‰å¾…lvså¥åº·æ£€æŸ¥ç¡®è®¤æœåŠ¡ä¸ºå¼‚å¸¸çŠ¶æ€æ—¶ä¸»åŠ¨åˆ‡æ–­æµé‡ï¼Œæ­¤æ—¶è¿›è¡ŒæœåŠ¡å™¨çš„å‡çº§æ“ä½œï¼ŒæœåŠ¡é‡å¯å®Œæ¯•åï¼Œå°†statusæ–‡ä»¶å†…å®¹ä¿®æ”¹å›okï¼Œç­‰å¾…lvså¥åº·æ£€æŸ¥ç¡®è®¤æœåŠ¡æ­£å¸¸åå¯¼å…¥æµé‡ï¼Œä»¥æ­¤æ­¥éª¤é€æ­¥å®Œæˆå‰©ä½™çš„æœºå™¨çš„å‘å¸ƒæ“ä½œã€‚å°†ä»¥ä¸Šæ­¥éª¤å®Œå–„æˆè„šæœ¬ï¼Œæ‹†åˆ†ä¸ºpreï¼ˆé¢„å‡çº§ï¼Œokä¿®æ”¹ä¸ºoffï¼‰ã€postï¼ˆå‘å¸ƒä»£ç ï¼Œé‡å¯æœåŠ¡ï¼‰ã€checkï¼ˆæœåŠ¡æ£€æŸ¥ï¼‰ã€onlineï¼ˆä¸Šçº¿ï¼Œoffä¿®æ”¹ä¸ºokï¼‰å‡ ä¸ªåŠ¨ä½œï¼Œä¸ä»£ç å‘å¸ƒå¹³å°ç»“åˆåŸºæœ¬å°±å®ç°äº†ä¸€èˆ¬æœåŠ¡çš„è‡ªåŠ¨åŒ–å‘ç‰ˆç®¡ç†ã€‚360å†…éƒ¨çš„ä»£ç å‘å¸ƒå¹³å°Furionå°±æ˜¯åŸºäºæ­¤åŸç†å·¥ä½œçš„ã€‚</p>

<p>ç»å…¸å¹³æ»‘å‡çº§æ–¹æ¡ˆçš„é—®é¢˜</p>

<p>ä¸€èˆ¬çš„webæœåŠ¡ä½¿ç”¨ä¸Šè¿°å¹³æ»‘å‡çº§æ–¹æ¡ˆï¼ŒåŸºæœ¬ä¸Šå·²ç»å¤Ÿç”¨äº†ã€‚é‚£è¿™ä¸ªæ–¹æ¡ˆè¿˜æœ‰ä»€ä¹ˆé—®é¢˜å—ï¼Ÿå¹æ¯›æ±‚ç–µçš„è®²ï¼Œè¿˜æ˜¯æœ‰çš„ã€‚</p>

<p>å‘å¸ƒè¿‡ç¨‹ä¸­ï¼Œæ­£åœ¨å‘å¸ƒçš„æœºå™¨è¢«æ‘˜é™¤ï¼Œå…¶ä»–æœºå™¨æ‰¿å‹å¢å¤§ã€‚</p>

<p>å‘å¸ƒè¿‡ç¨‹ä»ç„¶èŠ±è´¹ä¸€äº›æ—¶é—´ï¼ŒæŒ‰ç…§ä¸Šè¿°ç­–ç•¥æŒ‡å®šçš„å‚æ•°ï¼Œå‘å¸ƒä¸€æ¬¡è‡³å°‘éœ€è¦20ç§’ï¼Œå½“ç„¶æˆ‘ä»¬å¯ä»¥è°ƒæ•´å‚æ•°ï¼Œä½†æ˜¯è¦é¢ä¸´æµªè´¹èµ„æºæˆ–è€…ç½‘ç»œæŠ–åŠ¨è¯¯åˆ¤å¯¼è‡´åˆ‡æ–­æµé‡çš„é—®é¢˜ã€‚</p>

<p>åˆ‡æ–­æµé‡ç¬é—´ä¼šå¯¼è‡´æœªå®Œæˆè¯·æ±‚è¿”å›ä¸å®Œæ•´ã€‚</p>

<p>è¿™äº›é—®é¢˜ä¸€èˆ¬æ¥è¯´éƒ½ä¸ç®—å¤§é—®é¢˜ï¼ŒæœåŠ¡å™¨èµ„æºåšå¥½å†—ä½™å°±å¤Ÿäº†ï¼Œä½†æ˜¯å½“æœåŠ¡å™¨æ•°é‡å¾ˆå¤§ï¼ŒæœåŠ¡å™¨QPSå¾ˆé«˜çš„æƒ…å†µï¼Œå°é—®é¢˜ä¹Ÿä¼šå˜å¤§é—®é¢˜ã€‚æ‰€æœ‰å¯»æ±‚å®Œç¾æ— ç¼é‡å¯çš„æ–¹æ¡ˆå°±æ˜¯è§£å†³é—®é¢˜çš„å…³é”®äº†ã€‚
https://mp.weixin.qq.com/s?__biz=MzU4ODgyMDI0Mg==&amp;mid=2247487071&amp;idx=1&amp;sn=c0098f0ea50f6b1fc5c94ea9e68e8bfb
<!-- more -->
ä¼˜é›…é‡å¯</p>

<p>golangè¯­è¨€httpæœåŠ¡çš„ä¼˜é›…é‡å¯å¼€æºåº“ä¹Ÿæœ‰ä¸€äº›ï¼Œæˆ‘ä»¬é€‰æ‹©Facebookå¼€æºçš„åº“è¿›è¡Œç ”ç©¶ã€‚ä»£ç åœ°å€https://github.com/facebookarchive/grace.gitã€‚ç½‘ä¸Šçš„å¼€æºåº“çš„å®ç°æˆ–ç®€å•æˆ–å¤æ‚ï¼Œå…¶å®åŸç†éƒ½å·®ä¸å¤šï¼Œæ‰§è¡Œä¼˜é›…é‡å¯çš„è¿‡ç¨‹åŸºæœ¬å¦‚ä¸‹ï¼š</p>

<p>å‘å¸ƒæ–°çš„binæ–‡ä»¶å»è¦†ç›–è€çš„binæ–‡ä»¶</p>

<p>å‘é€ä¸€ä¸ªä¿¡å·é‡ï¼Œå‘Šè¯‰æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹ï¼Œè¿›è¡Œé‡å¯</p>

<p>æ­£åœ¨è¿è¡Œçš„è¿›ç¨‹æ”¶åˆ°ä¿¡å·åï¼Œä¼šä»¥å­è¿›ç¨‹çš„æ–¹å¼å¯åŠ¨æ–°çš„binæ–‡ä»¶</p>

<p>æ–°è¿›ç¨‹æ¥å—æ–°è¯·æ±‚ï¼Œå¹¶å¤„ç†</p>

<p>è€è¿›ç¨‹ä¸å†æ¥å—è¯·æ±‚ï¼Œä½†æ˜¯è¦ç­‰æ­£åœ¨å¤„ç†çš„è¯·æ±‚å¤„ç†å®Œæˆï¼Œæ‰€æœ‰åœ¨å¤„ç†çš„è¯·æ±‚å¤„ç†å®Œä¹‹åï¼Œä¾¿è‡ªåŠ¨é€€å‡º
å…¶å®æˆ‘æ€»ç»“äº†ä¸€ä¸‹ï¼Œå°±ä¸¤ä¸ªå…³é”®ç‚¹ï¼Œä¸€ä¸ªæ˜¯å­è¿›ç¨‹ç»§æ‰¿ç«¯å£ç›‘å¬å¯åŠ¨ï¼Œæ¥å—æ–°è¯·æ±‚å¤„ç†ï¼›å¦ä¸€ä¸ªæ˜¯çˆ¶è¿›ç¨‹ä¼˜é›…å…³é—­ã€‚é€šè¿‡ä»¥ä¸Šä¸¤ä¸ªæ­¥éª¤åŸºæœ¬ä¸Šå°±å®ç°äº†æœåŠ¡çš„æ— ç¼é‡å¯ï¼Œå‘å¸ƒè¿‡ç¨‹ä¸­æµé‡æ— æŸï¼Œå‘å¸ƒæ¶ˆè€—æ—¶é—´ç†è®ºä¸Šæœ€å¤§ä¹Ÿå°±æ˜¯ä¸€ä¸ªè¯·æ±‚çš„è¶…æ—¶æ—¶é—´ï¼Œå›æ»šæœåŠ¡ä¹Ÿå¾ˆç®€å•ï¼Œå°†æ—§ç‰ˆæœ¬æœåŠ¡é‡å‘ä¸€æ¬¡å°±å¥½äº†ã€‚</p>

<p>æºç åˆ†æ</p>

<p>1</p>

<p>ä½¿ç”¨æ–¹æ³•</p>

<p>ç¤ºä¾‹ä½¿ç”¨äº†æµè¡Œçš„httpåº“ ginï¼Œæˆ‘ä»¬ä¸€èˆ¬ç”¨æ³•å¦‚ä¸‹</p>

<p>func main
()</p>

<p>{</p>

<p>engine 
:=
 gin
.
New
()</p>

<p>engine
.
Use
(
httpserver
.
NewAccessLogger
(),
 gin
.
Recovery
())</p>

<p>controller
.
Regist
(
engine
)</p>

<p>srv 
:=</p>

<p>&amp;
http
.
Server
{</p>

<p>Addr
:</p>

<p>â€œ:80â€
,</p>

<p>Handler
:
      engine
,</p>

<p>ReadTimeout
:</p>

<p>30</p>

<p>*
 time
.
Second
,</p>

<p>WriteTimeout
:</p>

<p>30</p>

<p>*
 time
.
Second
,</p>

<p>}</p>

<p>monitor
.
Init
()</p>

<p>srvMonitor 
:=</p>

<p>&amp;
http
.
Server
{</p>

<p>Addr
:</p>

<p>â€œ:9900â€
,</p>

<p>Handler
:</p>

<p>nil
,</p>

<p>ReadTimeout
:</p>

<p>30</p>

<p>*
 time
.
Second
,</p>

<p>WriteTimeout
:</p>

<p>30</p>

<p>*
 time
.
Second
,</p>

<p>}</p>

<p>grace
.
Serve
(
srv
,
 srvMonitor
)</p>

<p>}</p>

<p>grace.Serveå‡½æ•°å‚æ•°æ˜¯ä¸€ä¸ªåˆ‡ç‰‡ï¼Œå¯ä»¥å¤„ç†å¤šä¸ªserverçš„ç«¯å£ç›‘å¬ç»§æ‰¿ä¸ä¼˜é›…å…³é—­ã€‚æ­¤å¤–è¿˜æä¾›äº†å…³é—­å‰çš„hookï¼Œä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š</p>

<p>gracehttp
.
ServeWithOptions
([]*
http
.
Server
{
srv
,
 srvMonitor
},
 gracehttp
.
PreStartProcess
(
func
()
 error 
{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    logger . Info ( "do PreStartProcess\n" )
</code></pre></div></div>

<p>return</p>

<p>nil</p>

<p>}))</p>

<p>åœ¨è°ƒç ”ä¸­æˆ‘å‘ç°é¡¹ç›®ä¸Šæœ‰é”™è¯¯çš„ä½¿ç”¨æ–¹æ³•ï¼Œå¦‚ä¸‹ï¼š</p>

<p>func startHttp
()</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>engine  :=  gin . New ()

engine . Use ( httpserver . NewAccessLogger (),  gin . Recovery ())

controller . Regist ( engine )

srv  :=
</code></pre></div></div>

<p>&amp;
http
.
Server
{</p>

<p>Addr
:</p>

<p>â€œ:80â€
,</p>

<p>Handler
:
      engine
,</p>

<p>ReadTimeout
:</p>

<p>30</p>

<p>*
 time
.
Second
,</p>

<p>WriteTimeout
:</p>

<p>30</p>

<p>*
 time
.
Second
,</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitor . Init ()

srvMonitor  :=
</code></pre></div></div>

<p>&amp;
http
.
Server
{</p>

<p>Addr
:</p>

<p>â€œ:9900â€
,</p>

<p>Handler
:</p>

<p>nil
,</p>

<p>ReadTimeout
:</p>

<p>30</p>

<p>*
 time
.
Second
,</p>

<p>WriteTimeout
:</p>

<p>30</p>

<p>*
 time
.
Second
,</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grace . Serve ( srv ,  srvMonitor )
</code></pre></div></div>

<p>}</p>

<p>func main
()</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go startHttp ()
</code></pre></div></div>

<p>//æ³¨å†Œä¿¡å·</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go signalHandler ()
</code></pre></div></div>

<p>&lt;-
quiet</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logger . Info ( "Close Server" )
</code></pre></div></div>

<p>}</p>

<p>func signalHandler
()</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c  :=  make ( chan os . Signal )

signal . Notify ( c ,  syscall . SIGHUP ,  syscall . SIGINT ,  syscall . SIGTERM ,  syscall . SIGKILL ,  syscall . SIGQUIT )

s  :=
</code></pre></div></div>

<p>&lt;-
c</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logger . Info ( "get siginal  siginal=%v" ,  s )

quiet  &lt;-
</code></pre></div></div>

<p>1</p>

<p>}</p>

<p>è¿™é‡Œä¸ºä»€ä¹ˆå‡ºé”™äº†å‘¢ï¼Œæ˜¯å› ä¸ºä»–å°†grace.Serve(srv,srvMonitor) æ”¾åœ¨goroutineé‡Œé¢äº†ï¼Œå¹¶ä¸”è‡ªå·±åˆç›‘å¬äº†ä¸€éä¿¡å·ï¼Œè¿™æ ·ä¼šå¯¼è‡´æ—§è¿›ç¨‹ä¼˜é›…å…³é—­å‰ï¼Œçˆ¶è¿›ç¨‹å·²ç»å·²ç»é€€å‡ºäº†ï¼Œä¼˜é›…å…³é—­å°±å¤±æ•ˆäº†ã€‚</p>

<p>2</p>

<p>å…³é”®ä»£ç </p>

<p>æˆ‘ä»¬æŒ‰ç…§ç¨‹åºå¯åŠ¨çš„é¡ºåºé€»è¾‘æ¥è®²ï¼Œå¤§ä½“å¦‚ä¸‹ï¼š</p>

<p>æ‰§è¡Œå¯åŠ¨ç«¯å£ç›‘å¬ï¼ŒæŒ‚è½½serverï¼Œåˆ¤æ–­å½“å‰è¿›ç¨‹å¦‚æœæ˜¯å­è¿›ç¨‹å°±å‘çˆ¶è¿›ç¨‹å‘é€SIGTERMä¿¡å·ã€‚</p>

<p>goroutine æ‰§è¡Œwg.Add å’Œwg.Wait() ï¼Œç­‰å¾…æ‰€æœ‰æŒ‚è½½çš„serveråœæ­¢å·¥ä½œåæ‰§è¡Œé€€å‡ºè¿›ç¨‹ã€‚</p>

<p>goroutine æ‰§è¡Œ signalHandlerï¼Œç­‰å¾…SIGTERMå’ŒSIGUSR2ä¿¡å·ã€‚æ”¶åˆ°SIGTERMä¿¡å·æ‰§è¡Œæ¯ä¸ªserverçš„ä¼˜é›…å…³é—­ï¼Œå…³é—­å®Œåæ‰§è¡Œwg.Done()ï¼Œwgå…¨éƒ¨Doneä¹‹ååœ¨2ä¸­æ‰§è¡Œäº†é€€å‡ºè¿›ç¨‹æ“ä½œï¼›æ”¶åˆ°SIGUSR2ä¿¡å·æ—¶ï¼Œæ‰§è¡Œå¯åŠ¨å­è¿›ç¨‹æ“ä½œã€‚</p>

<p>å­è¿›ç¨‹å¯åŠ¨æ‰§è¡Œ1ï¼Œä¼šå‘çˆ¶è¿›ç¨‹å‘é€SIGTERMä¿¡å·ï¼Œçˆ¶è¿›ç¨‹æ”¶åˆ°SIGTERMä¿¡å·æ‰§è¡Œ3ï¼Œè¿›è¡Œä¼˜é›…å…³é—­æ“ä½œã€‚</p>

<p>æ€»ç»“èµ·æ¥å°±æ˜¯æ‰§è¡Œå¯åŠ¨é‡å¯æ—¶ï¼Œæ‰§è¡Œshellå‘½ä»¤ï¼š</p>

<p>pgrep 
(ä½ çš„é¡¹ç›®å)</p>

<p>|
xargs kill 
-
SIGUSR2</p>

<p>#(æ³¨æ„ï¼šè¦ä½¿ç”¨bash)ã€‚</p>

<p>ä½ çš„é¡¹ç›®ä¼šå¯åŠ¨å­è¿›ç¨‹ï¼Œå¹¶ç»§æ‰¿çˆ¶è¿›ç¨‹ç›‘å¬çš„ç«¯å£ï¼Œå¯åŠ¨æˆåŠŸåå†å‘çˆ¶è¿›ç¨‹å‘é€SIGTERMä¿¡å·ï¼Œ æ—§è¿›ç¨‹æ‰§è¡Œä¼˜é›…å…³é—­ã€‚æˆ‘ä»¬çœ‹å…³é”®çš„struct</p>

<p>// gracehttp/http.go</p>

<p>type app 
struct</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>servers          []* http . Server

http             * httpdown . HTTP

net              * gracenet . Net

listeners        [] net . Listener

sds              [] httpdown . Server

preStartProcess func ()  error

errors          chan error
</code></pre></div></div>

<p>}</p>

<p>// httpdown/httpdown.go</p>

<p>type HTTP 
struct</p>

<p>{</p>

<p>// StopTimeout is the duration before we begin force closing connections.</p>

<p>// Defaults to 1 minute.</p>

<p>StopTimeout
 time
.
Duration</p>

<p>// KillTimeout is the duration before which we completely give up and abort</p>

<p>// even though we still have connected clients. This is useful when a large</p>

<p>// number of client connections exist and closing them can take a long time.</p>

<p>// Note, this is in addition to the StopTimeout. Defaults to 1 minute.</p>

<p>KillTimeout
 time
.
Duration</p>

<p>// Stats is optional. If provided, it will be used to record various metrics.</p>

<p>Stats
 stats
.
Client</p>

<p>// Clock allows for testing timing related functionality. Do not specify this</p>

<p>// in production code.</p>

<p>Clock
 clock
.
Clock</p>

<p>}</p>

<p>// gracenet/net.go</p>

<p>type 
Net</p>

<p>struct</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inherited    [] net . Listener

active       [] net . Listener

mutex       sync . Mutex

inheritOnce sync . Once
</code></pre></div></div>

<p>// used in tests to override the default behavior of starting from fd 3.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fdStart  int
</code></pre></div></div>

<p>}</p>

<p>æˆ‘ä»¬çŸ¥é“å‡½æ•°è°ƒç”¨æ˜¯ä»grace.Serve(srv, srvMonitor)å¼€å§‹çš„,Serveå‡½æ•°ä¼šnewä¸€ä¸ªappï¼Œä¸€è·¯æ‰§è¡Œä¸‹å»å…³é”®å‡½æ•°å¦‚ä¸‹ï¼ša.run()ã€a.listen()ã€a.serve()ã€ a.wait()ã€a.signalHandler()ã€ a.term()ã€a.net.StartProcess()ã€‚</p>

<p>a.run() å¤§ä½“é€»è¾‘å¦‚ä¸‹ï¼š</p>

<p>var</p>

<p>(</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>didInherit  =  os . Getenv ( "LISTEN_FDS" )
</code></pre></div></div>

<p>!=</p>

<p>â€â€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ppid        =  os . Getppid ()
</code></pre></div></div>

<p>)</p>

<p>func 
(
a 
*
app
)
 run
()
 error 
{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a . listen ()

a . serve ()
</code></pre></div></div>

<p>if
 didInherit 
&amp;&amp;
 ppid 
!=</p>

<p>1</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>syscall . Kill ( ppid ,  syscall . SIGTERM )
</code></pre></div></div>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>waitdone  :=  make ( chan  struct {})

go func ()
</code></pre></div></div>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defer close ( waitdone )

a . wait ()
</code></pre></div></div>

<p>}()</p>

<p>select</p>

<p>{</p>

<p>case
 err 
:=</p>

<p>&lt;-
a
.
errors
:</p>

<p>â€¦</p>

<p>case</p>

<p>&lt;-
waitdone
:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    logger . Printf ( "Exiting pid %d." ,  os . Getpid ())
</code></pre></div></div>

<p>return</p>

<p>nil</p>

<p>}</p>

<p>}</p>

<p>å¯åŠ¨ç›‘å¬ã€æŒ‚è½½serverï¼Œé€šè¿‡ç¯å¢ƒå˜é‡LISTEN_FDSåˆ¤æ–­å½“å‰è¿›ç¨‹æ˜¯å¦ä¸ºå­è¿›ç¨‹ï¼Œå¦‚æœæ˜¯å°±å‘é€ä¿¡å·æ€çˆ¶è¿›ç¨‹ã€‚goroutineä¸­æ‰§è¡Œwait()å‡½æ•°ç­‰å¾…ä¼˜é›…å…³é—­æˆ–è€…å¹³æ»‘å¯åŠ¨å­è¿›ç¨‹ã€‚</p>

<p>a.listen() å…³é”®é€»è¾‘å¦‚ä¸‹ï¼š</p>

<p>func 
(
a 
*
app
)
 listen
()
 error 
{</p>

<p>for
 _
,
 s 
:=
 range a
.
servers 
{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    l ,  err  :=  a . net . Listen ( "tcp" ,  s . Addr )
</code></pre></div></div>

<p>â€¦â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a . listeners  =  append ( a . listeners ,  l )
</code></pre></div></div>

<p>}</p>

<p>return</p>

<p>nil</p>

<p>}</p>

<p>è¿™é‡Œçœ‹å‡ºapp struct ä¸­listenersç”¨æ¥å­˜å‚¨ç›‘å¬çš„net.Listenerçš„æ•°ç»„ ï¼Œnetå°±æ˜¯Netï¼Œå°è£…äº†net.ListenTCPç­‰é€»è¾‘ï¼ˆè¿™é‡Œæˆ‘åªå…³æ³¨äº†TCPé€»è¾‘ï¼‰ï¼Œinherited å’Œ active ä¸¤ä¸ªæ•°ç»„åˆ†åˆ«ç”¨æ¥å­˜å‚¨ç»§æ‰¿è‡ªçˆ¶è¿›ç¨‹çš„net.Listener å’Œ å¯åŠ¨çš„net.Listenerï¼Œè¿™å—çˆ¶è¿›ç¨‹å¯åŠ¨ï¼Œå³é¦–æ¬¡å¯åŠ¨æ—¶é€»è¾‘å¾ˆç®€å•ï¼Œç•¥è¿‡ï¼Œå­è¿›ç¨‹å¯åŠ¨ï¼Œå³éé¦–æ¬¡å¯åŠ¨åœ¨ä»‹ç»a.net.StartProccessæ—¶ç»†è®²ã€‚</p>

<p>a.serve() å…³é”®é€»è¾‘å¦‚ä¸‹ï¼š</p>

<p>func 
(
a 
*
app
)
 serve
()</p>

<p>{</p>

<p>for
 i
,
 s 
:=
 range a
.
servers 
{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a . sds  =  append ( a . sds ,  a . http . Serve ( s ,  a . listeners [ i ]))
</code></pre></div></div>

<p>}</p>

<p>}</p>

<p>è¿™é‡Œæ¶‰åŠäº†app structé‡Œé¢çš„ä¸¤ä¸ªå­—æ®µï¼Œhttpå’Œsdsã€‚httpå³ HTTP structï¼Œ è¿™é‡Œé¢å°è£…äº†http serverä¼˜é›…å…³é—­ç›¸å…³çš„é€»è¾‘ï¼Œå…·ä½“çš„ç»†èŠ‚å¾ˆç¹çï¼Œæˆ‘ç”¨ä¸€ä¸ªç®€å•çš„æ¨¡å‹æ¥è¯´æ˜ä¸€ä¸‹å§ã€‚a.http.Serve(srv,l) å‡½æ•°å°è£…æ‰§è¡Œäº†srv.Serve(l)ï¼Œå³æŒ‚è½½srvï¼Œ å¹¶è¿”å›äº†ä¸€ä¸ªhttpdown.serverçš„å®ä¾‹ï¼Œ è¿™ä¸ªå®ä¾‹å®ç°äº†httpdown.Server æ¥å£ï¼Œå¦‚ä¸‹ï¼š</p>

<p>// httpdown/httpdown.go</p>

<p>type 
Server</p>

<p>interface</p>

<p>{</p>

<p>// Wait waits for the serving loop to finish. This will happen when Stop is</p>

<p>// called, at which point it returns no error, or if there is an error in the</p>

<p>// serving loop. You must call Wait after calling Serve or ListenAndServe.</p>

<p>Wait
()
 error</p>

<p>// Stop stops the listener. It will block until all connections have been</p>

<p>// closed.</p>

<p>Stop
()
 error</p>

<p>}</p>

<p>ç²¾ç®€åå®ç°çš„æ¨¡å‹å¦‚ä¸‹ï¼š</p>

<p>func 
(
s 
*
server
)
 serve
()</p>

<p>{</p>

<p>// å³å‰é¢æåˆ°çš„ srv.Serve(l)ï¼Œè¢«å°è£…çš„æŒ‚è½½srvçš„ä»£ç </p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s . serveErr  &lt;-  s . server . Serve ( s . listener )

close ( s . serveDone )

close ( s . serveErr )
</code></pre></div></div>

<p>}</p>

<p>func 
(
s 
*
server
)</p>

<p>Wait
()
 error 
{</p>

<p>if
 err 
:=</p>

<p>&lt;-
s
.
serveErr
;</p>

<p>!
isUseOfClosedError
(
err
)</p>

<p>{</p>

<p>return
 err</p>

<p>}</p>

<p>return</p>

<p>nil</p>

<p>}</p>

<p>func 
(
s 
*
server
)</p>

<p>Stop
()
 error 
{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s . stopOnce . Do ( func ()
</code></pre></div></div>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    closeErr  :=  s . listener . Close ()
</code></pre></div></div>

<p>&lt;-
s
.
serveDone</p>

<p>â€¦â€¦</p>

<p>// ç­‰å¾…è¿æ¥å…³é—­æˆ–è€…è¶…æ—¶åå¼ºæ€è¿æ¥ç­‰å¤æ‚é€»è¾‘</p>

<p>â€¦â€¦</p>

<p>if
 closeErr 
!=</p>

<p>nil</p>

<p>&amp;&amp;</p>

<p>!
isUseOfClosedError
(
closeErr
)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        s . stopErr  =  closeErr
</code></pre></div></div>

<p>}</p>

<p>})</p>

<p>return
 s
.
stopErr</p>

<p>}</p>

<p>s.serveErr &lt;- s.server.Serve(s.listener) å¯åŠ¨æˆåŠŸåä¼šåœ¨è¿™é‡ŒæŒ‚ä½ï¼Œå¤±è´¥ç›´æ¥è¿”å›é”™è¯¯ï¼ŒWait() å‡½æ•°æä¾›ç»™a.wait()è°ƒç”¨ï¼Œæ­£å¸¸æƒ…å†µä¹Ÿæ˜¯æŒ‚ä½ï¼Œç­‰Stop() é‡Œé¢ closeErr := s.listener.Close() æ‰§è¡Œåè¿”å›ã€‚è¿™å—çš„é€»è¾‘è¦ç»“åˆ a.wait()ã€ a.signalHandler()ã€ a.term() ä¸€èµ·æ¥åˆ†æ</p>

<p>a.wait() å’Œ a.term() çš„ä»£ç </p>

<p>func 
(
a 
*
app
)
 wait
()</p>

<p>{</p>

<p>var
 wg sync
.
WaitGroup</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wg . Add ( len ( a . sds )
</code></pre></div></div>

<p>*</p>

<p>2
)</p>

<p>// Wait &amp; Stop</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go a . signalHandler (&amp; wg )
</code></pre></div></div>

<p>for
 _
,
 s 
:=
 range a
.
sds 
{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    go func ( s httpdown . Server )
</code></pre></div></div>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        defer wg . Done ()
</code></pre></div></div>

<p>if
 err 
:=
 s
.
Wait
();
 err 
!=</p>

<p>nil</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            a . errors  &lt;-  err
</code></pre></div></div>

<p>}</p>

<p>}(
s
)</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wg . Wait ()
</code></pre></div></div>

<p>}</p>

<p>func 
(
a 
*
app
)
 term
(
wg 
*
sync
.
WaitGroup
)</p>

<p>{</p>

<p>for
 _
,
 s 
:=
 range a
.
sds 
{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    go func ( s httpdown . Server )
</code></pre></div></div>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        defer wg . Done ()
</code></pre></div></div>

<p>if
 err 
:=
 s
.
Stop
();
 err 
!=</p>

<p>nil</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            a . errors  &lt;-  err
</code></pre></div></div>

<p>}</p>

<p>}(
s
)</p>

<p>}</p>

<p>}</p>

<p>a.run() å‡½æ•°é‡Œé¢ä¼šgoroutine æ‰§è¡Œ a.wait()ï¼Œå®ƒä¼šgoroutineæ‰§è¡Œä¿¡å·å¤„ç† a.signalHandler() å‡½æ•°ï¼Œåˆ›å»ºä¸€ä¸ªWaitGroup ç­‰å¾…æ‰€æœ‰çš„httpdown.serveræ‰§è¡Œs.Wait()å‡½æ•°è¿”å›ã€‚a.signalHandler() å‡½æ•°åŸºæœ¬ä¸Šé€»è¾‘å°±æ˜¯ç›‘å¬signal.Notifyä¿¡å·ï¼Œæ”¶åˆ°SIGTERMä¿¡å·æ‰§è¡Œa.term() ï¼Œæ”¶åˆ°SIGUSR2ä¿¡å·æ‰§è¡Œa.net.StartProcess()ã€‚a.term() å‡½æ•°å°±æ˜¯éå†æ‰§è¡Œæ‰€æœ‰httpdown.serverçš„s.Stop()ï¼Œè¿›è¡Œä¼˜é›…å…³é—­ï¼Œç»“åˆä¸Šé¢çš„ä»£ç æ¥çœ‹ï¼Œæ¯ä¸€ä¸ªs.Stop() ä¼šå¯¼è‡´s.Wait() è¿”å›ï¼Œå³æ‰§è¡Œäº†ä¸¤æ¬¡wg.Done()ï¼Œ æ‰€æœ‰httpdown.server ä¼˜é›…å…³é—­åå¯¼è‡´a.wait()è¿”å›ï¼Œè¿›è€Œwaitdoneå…³é—­ï¼Œ è¿›ç¨‹æœ€åé€€å‡ºã€‚ä¸‹é¢æ˜¯a.signalHandler()å‡½æ•°çš„ä»£ç </p>

<p>func 
(
a 
*
app
)
 signalHandler
(
wg 
*
sync
.
WaitGroup
)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ch  :=  make ( chan os . Signal ,
</code></pre></div></div>

<p>10
)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signal . Notify ( ch ,  syscall . SIGINT ,  syscall . SIGTERM ,  syscall . SIGUSR2 )
</code></pre></div></div>

<p>for</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sig  :=
</code></pre></div></div>

<p>&lt;-
ch</p>

<p>switch
 sig 
{</p>

<p>case
 syscall
.
SIGINT
,
 syscall
.
SIGTERM
:</p>

<p>// this ensures a subsequent INT/TERM will trigger standard go behaviour of</p>

<p>// terminating.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        signal . Stop ( ch )

        a . term ( wg )
</code></pre></div></div>

<p>return</p>

<p>case
 syscall
.
SIGUSR2
:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        err  :=  a . preStartProcess ()
</code></pre></div></div>

<p>if
 err 
!=</p>

<p>nil</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            a . errors  &lt;-  err
</code></pre></div></div>

<p>}</p>

<p>// we only return here if thereâ€™s an error, otherwise the new process</p>

<p>// will send us a TERM when itâ€™s ready to trigger the actual shutdown.</p>

<p>if
 _
,
 err 
:=
 a
.
net
.
StartProcess
();
 err 
!=</p>

<p>nil</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            a . errors  &lt;-  err
</code></pre></div></div>

<p>}</p>

<p>}</p>

<p>}</p>

<p>}</p>

<p>a.net.StartProcess() å‡½æ•°æ˜¯å¯åŠ¨å­è¿›ç¨‹çš„é€»è¾‘ï¼Œè¿™é‡Œéœ€è¦è¯¦ç»†ä»‹ç»ä¸€ä¸‹</p>

<p>const</p>

<p>(</p>

<p>// Used to indicate a graceful restart in the new process.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>envCountKey        =
</code></pre></div></div>

<p>â€œLISTEN_FDSâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>envCountKeyPrefix  =  envCountKey  +
</code></pre></div></div>

<p>â€=â€</p>

<p>)</p>

<p>type filer 
interface</p>

<p>{</p>

<p>File
()</p>

<p>(*
os
.
File
,
 error
)</p>

<p>}</p>

<p>func 
(
n 
*
Net
)</p>

<p>StartProcess
()</p>

<p>(
int
,
 error
)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>listeners ,  err  :=  n . activeListeners ()
</code></pre></div></div>

<p>if
 err 
!=</p>

<p>nil</p>

<p>{</p>

<p>return</p>

<p>0
,
 err</p>

<p>}</p>

<p>// Extract the fds from the listeners.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>files  :=  make ([]* os . File ,  len ( listeners ))
</code></pre></div></div>

<p>for
 i
,
 l 
:=
 range listeners 
{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    files [ i ],  err  =  l .( filer ). File ()
</code></pre></div></div>

<p>if
 err 
!=</p>

<p>nil</p>

<p>{</p>

<p>return</p>

<p>0
,
 err</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    defer files [ i ]. Close ()
</code></pre></div></div>

<p>}</p>

<p>// Use the original binary location. This works with symlinks such that if</p>

<p>// the file it points to has been changed we will use the updated symlink.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>argv0 ,  err  :=
</code></pre></div></div>

<p>exec
.
LookPath
(
os
.
Args
[
0
])</p>

<p>if
 err 
!=</p>

<p>nil</p>

<p>{</p>

<p>return</p>

<p>0
,
 err</p>

<p>}</p>

<p>// Pass on the environment and replace the old count key with the new one.</p>

<p>var
 env 
[]
string</p>

<p>for
 _
,
 v 
:=
 range os
.
Environ
()</p>

<p>{</p>

<p>if</p>

<p>!
strings
.
HasPrefix
(
v
,
 envCountKeyPrefix
)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        env  =  append ( env ,  v )
</code></pre></div></div>

<p>}</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>env  =  append ( env ,  fmt . Sprintf ( "%s%d" ,  envCountKeyPrefix ,  len ( listeners )))



allFiles  :=  append ([]* os . File { os . Stdin ,  os . Stdout ,  os . Stderr },  files ...)

process ,  err  :=  os . StartProcess ( argv0 ,  os . Args ,
</code></pre></div></div>

<p>&amp;
os
.
ProcAttr
{</p>

<p>Dir
:
   originalWD
,</p>

<p>Env
:
   env
,</p>

<p>Files
:
 allFiles
,</p>

<p>})</p>

<p>if
 err 
!=</p>

<p>nil</p>

<p>{</p>

<p>return</p>

<p>0
,
 err</p>

<p>}</p>

<p>return
 process
.
Pid
,</p>

<p>nil</p>

<p>}</p>

<p>n.activeListeners()è¿”å› n.activeä¸­çš„net.Listener æ•°ç»„çš„å‰¯æœ¬ï¼Œfilesæ˜¯ä»ä¸­æå–å‡ºçš„fdåˆ—è¡¨ã€‚æ³¨æ„allFilesåœ¨fileså‰é¢æ‹¼æ¥äº†3ä¸ªæ ‡å‡†è¾“å…¥è¾“å‡ºï¼Œè®°ä½è¿™ä¸ªæ•°å­—ã€‚env ä¸­ä¿®æ”¹äº†ç¯å¢ƒå˜é‡LISTEN_FDSç­‰äºlistenerçš„æ•°é‡ã€‚è¿™é‡Œçš„å¯åŠ¨å­è¿›ç¨‹çš„æ–¹æ³•æ˜¯os.StartProcess()ï¼Œæˆ‘çœ‹äº†å…¶ä»–çš„å¼€æºåº“éƒ½ç”¨syscall.ForkExec</p>

<p>fork
,
 err 
:=
 syscall
.
ForkExec
(
os
.
Args
[
0
],
 os
.
Args
,</p>

<p>&amp;
os
.
ProcAttr
{</p>

<p>Dir
:
   originalWD
,</p>

<p>Env
:
   env
,</p>

<p>Files
:
 allFiles
,</p>

<p>})</p>

<p>ä¸¤ç§çš„åŒºåˆ«åç»­è¿˜æœ‰å¾…ç ”ç©¶ã€‚è¿˜è®°å¾—å‰é¢æ²¡æœ‰å±•å¼€çš„Netä¸­çš„inherited å’Œ activeä¹ˆï¼Œè¿™é‡Œæˆ‘ä»¬ç»†è®²ä¸€ä¸‹ã€‚</p>

<p>func 
(
n 
*
Net
)</p>

<p>Listen
(
nett
,
 laddr 
string
)</p>

<p>(
net
.
Listener
,
 error
)</p>

<p>{</p>

<p>â€¦â€¦</p>

<p>// ä»…å…³æ³¨tcpé€»è¾‘</p>

<p>return
 n
.
ListenTCP
(
nett
,
 addr
)</p>

<p>}</p>

<p>func 
(
n 
*
Net
)</p>

<p>ListenTCP
(
nett 
string
,
 laddr 
*
net
.
TCPAddr
)</p>

<p>(*
net
.
TCPListener
,
 error
)</p>

<p>{</p>

<p>if
 err 
:=
 n
.
inherit
();
 err 
!=</p>

<p>nil</p>

<p>{</p>

<p>return</p>

<p>nil
,
 err</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n . mutex . Lock ()

defer n . mutex . Unlock ()
</code></pre></div></div>

<p>// look for an inherited listener</p>

<p>for
 i
,
 l 
:=
 range n
.
inherited 
{</p>

<p>if
 l 
==</p>

<p>nil</p>

<p>{</p>

<p>// we nil used inherited listeners</p>

<p>continue</p>

<p>}</p>

<p>if
 isSameAddr
(
l
.
Addr
(),
 laddr
)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        n . inherited [ i ]
</code></pre></div></div>

<p>=</p>

<p>nil</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        n . active  =  append ( n . active ,  l )
</code></pre></div></div>

<p>return
 l
.(*
net
.
TCPListener
),</p>

<p>nil</p>

<p>}</p>

<p>}</p>

<p>// make a fresh listener</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l ,  err  :=  net . ListenTCP ( nett ,  laddr )
</code></pre></div></div>

<p>if
 err 
!=</p>

<p>nil</p>

<p>{</p>

<p>return</p>

<p>nil
,
 err</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n . active  =  append ( n . active ,  l )
</code></pre></div></div>

<p>return
 l
,</p>

<p>nil</p>

<p>}</p>

<p>func 
(
n 
*
Net
)
 inherit
()
 error 
{</p>

<p>var
 retErr error</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n . inheritOnce . Do ( func ()
</code></pre></div></div>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    n . mutex . Lock ()

    defer n . mutex . Unlock ()

    countStr  :=  os . Getenv ( envCountKey )
</code></pre></div></div>

<p>if
 countStr 
==</p>

<p>â€â€</p>

<p>{</p>

<p>return</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    count ,  err  :=  strconv . Atoi ( countStr )
</code></pre></div></div>

<p>// In tests this may be overridden.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    fdStart  :=  n . fdStart
</code></pre></div></div>

<p>if
 fdStart 
==</p>

<p>0</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        fdStart  =
</code></pre></div></div>

<p>3</p>

<p>}</p>

<p>for
 i 
:=
 fdStart
;
 i 
&lt;
 fdStart
+
count
;
 i
++</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        file  :=  os . NewFile ( uintptr ( i ),
</code></pre></div></div>

<p>â€œlistenerâ€
)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        l ,  err  :=  net . FileListener ( file )
</code></pre></div></div>

<p>if
 err 
!=</p>

<p>nil</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            file . Close ()

            retErr  =  fmt . Errorf ( "error inheriting socket fd %d: %s" ,  i ,  err )
</code></pre></div></div>

<p>return</p>

<p>}</p>

<p>if
 err 
:=
 file
.
Close
();
 err 
!=</p>

<p>nil</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            retErr  =  fmt . Errorf ( "error closing inherited socket fd %d: %s" ,  i ,  err )
</code></pre></div></div>

<p>return</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        n . inherited  =  append ( n . inherited ,  l )
</code></pre></div></div>

<p>}</p>

<p>})</p>

<p>return
 retErr</p>

<p>}</p>

<p>è¿™é‡ŒListenTCP å…ˆæ‰§è¡Œinherit() å°†ç»§æ‰¿æ¥çš„net.Listener ä¿å­˜åœ¨n.inheritedé‡Œé¢ï¼Œå¯åŠ¨æ—¶åˆ¤æ–­æ˜¯å¦æ˜¯ç»§æ‰¿çš„listenerï¼Œæ²¡æœ‰æ‰ make a fresh listenerå‘¢ï¼Œè¿™é‡Œçš„fdStart åˆå§‹å€¼è®¾ç½®ä¸º3ï¼Œå°±æ˜¯å‰é¢æåˆ°çš„é‚£ä¸ªæ•°å­—3 ï¼ˆä¸‰ä¸ªæ ‡å‡†è¾“å…¥è¾“å‡ºå äº†3ä½ï¼‰ã€‚</p>

<p>æ€»ç»“èµ·æ¥å¯åŠ¨å­è¿›ç¨‹æµç¨‹å¦‚ä¸‹ï¼š</p>

<p>1ã€æå–listenerçš„fdï¼Œä¿®æ”¹LISTENFDSç¯å¢ƒå˜é‡ä¸ºlistenerçš„æ•°é‡ï¼Œos.StartProcesså¯åŠ¨å­è¿›ç¨‹.</p>

<p>files
[
i
],
 err 
=
 l
.(
filer
).
File
()</p>

<p>2ã€å­è¿›ç¨‹å¯åŠ¨æ‰§è¡Œa.net.Listen()æ—¶ï¼Œæ ¹æ®ç¯å¢ƒå˜é‡LISTENFDSå’ŒfdStart å˜é‡å–å‡ºlistener</p>

<p>file 
:=
 os
.
NewFile
(
uintptr
(
i
),</p>

<p>â€œlistenerâ€
)</p>

<p>l
,
 err 
:=
 net
.
FileListener
(
file
)</p>

<p>file
.
Close
()</p>

<p>æ ¹æ®fdåˆ›å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œé€šè¿‡æ–‡ä»¶æ‹¿åˆ°listenerçš„å‰¯æœ¬ï¼Œç„¶åå…³é—­æ–‡ä»¶ã€‚æœ€ç»ˆa.net.Listen()çš„é€»è¾‘æ˜¯å¦‚æœæ˜¯ç»§æ‰¿ç«¯å£å°±è¿”å›ä¸€ä¸ªlistenerå‰¯æœ¬ï¼Œå¦‚æœä¸æ˜¯å°±å¯åŠ¨ä¸€ä¸ªæ–°çš„listenerã€‚3ã€åç»­æ‰§è¡Œa.serve() æŒ‚è½½serverï¼Œç„¶åé€šçŸ¥çˆ¶è¿›ç¨‹ä¼˜é›…å…³é—­ç­‰é€»è¾‘ã€‚</p>
:ET