I"‚6<p>å†™è¿™ä¸ªç³»åˆ—çš„ç›®çš„ä¸æ˜¯ä¸ºäº†åˆ—å‡º Golang ç¼–ç¨‹è¯­è¨€çš„è°ƒè¯•å™¨çš„æ‰€æœ‰ç‰¹æ€§ã€‚å¦‚æœä½ æƒ³çœ‹è¿™äº›å†…å®¹ï¼Œå¯ä»¥çœ‹ä¸‹ Delveã€‚åœ¨è¿™ç¯‡æ–‡ç« é‡Œæˆ‘ä»¬è¯•ç€å»æ¢ç´¢ä¸‹è°ƒè¯•å™¨é€šå¸¸æ˜¯æ€æ ·å·¥ä½œçš„ï¼Œæ€ä¹ˆåœ¨ Linux ä¸Šå®Œæˆä¸€ä¸ªåŸºæœ¬çš„è°ƒè¯•ï¼ŒLinux ä¸Šæ¯”è¾ƒå…³å¿ƒ Golang çš„åŠŸèƒ½ï¼Œæ¯”å¦‚ goroutine ã€‚</p>

<p>åˆ›å»ºè°ƒè¯•å™¨æ²¡é‚£ä¹ˆç®€å•ã€‚å°±è¿™ä¸€ä¸ªè¯é¢˜æˆ‘ä»¬å•ç‹¬å†™ä¸€ç¯‡æ–‡ç« ä¹Ÿè®²ä¸å®Œã€‚ç›¸åï¼Œæœ¬ç¯‡åšæ–‡æ˜¯ä¸ªå¼€å§‹ï¼Œè¿™ä¸ªç³»åˆ—çš„æœ€ç»ˆç›®æ ‡æ˜¯æ‰¾åˆ°è§£å†³æ–¹æ¡ˆæ¥å¤„ç†æœ€å¸¸è§çš„åœºæ™¯ã€‚æœŸé—´æˆ‘ä»¬ä¼šè®¨è®ºç±»ä¼¼ ELF, DWARF çš„è¯é¢˜ï¼Œè¿˜ä¼šæ¥è§¦åˆ°ä¸€äº›æ¶æ„ç›¸å…³çš„é—®é¢˜ã€‚
<!-- more -->
ç¯å¢ƒ
æ•´ä¸ªç³»åˆ—æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬éƒ½ä¼šä½¿ç”¨ Docker æ¥è·å–åŸºäº Debian Jessie çš„å¯å¤åˆ¶çš„ playgroundã€‚æˆ‘ä½¿ç”¨çš„æ˜¯ x86-64ï¼Œè¿™å¯ä»¥åœ¨ä¸€å®šç¨‹åº¦ä¸Šè®©æˆ‘ä»¬åœ¨åšä¸€äº›åº•å±‚è®¨è®ºçš„æ—¶å€™èµ·ç‚¹ä½œç”¨ã€‚é¡¹ç›®ç»“æ„å¦‚ä¸‹ï¼š</p>

<blockquote>
  <p>tree
.
â”œâ”€â”€ Dockerfile
â””â”€â”€ src
    â””â”€â”€ github.com
        â””â”€â”€ mlowicki
            â”œâ”€â”€ debugger
            â”‚   â””â”€â”€ debugger.go
            â””â”€â”€ hello
                â””â”€â”€ hello.go
æˆ‘ä»¬é©¬ä¸Šè¦ç”¨åˆ°çš„è°ƒè¯•å™¨çš„ä¸»è¦æ–‡ä»¶å°±æ˜¯ debugger.goï¼Œhello.go æ–‡ä»¶åŒ…å«æˆ‘ä»¬æ•´ä¸ªæµç¨‹ä¸­è°ƒè¯•çš„ sample ç¨‹åºæºä»£ç ã€‚ç°åœ¨ä½ å†™æœ€ç®€å•çš„å†…å®¹å°±å¯ä»¥ï¼š</p>
</blockquote>

<p>package main
func main() {
}
æˆ‘ä»¬å…ˆå†™ä¸€ä¸ªéå¸¸ç®€å•çš„ Dockerfileï¼š</p>

<p>FROM golang:1.8.1
RUN apt-get update &amp;&amp; apt-get install -y tree
ä¸ºäº†ç¼–è¯‘ Docker é•œåƒï¼Œåˆ°ï¼ˆDockerfile æ‰€åœ¨çš„ï¼‰æœ€å¤–å±‚ç›®å½•ï¼Œè¿è¡Œï¼š</p>

<blockquote>
  <p>docker build -t godebugger .
ç»™å®¹å™¨åŠ é€Ÿï¼Œæ‰§è¡Œï¼š</p>
</blockquote>

<blockquote>
  <p>docker run â€“rm -it -v â€œ$PWDâ€/src:/go/src â€“security-opt seccomp=unconfined godebugger
è¿™é‡Œ æœ‰å®‰å…¨è¿ç®—æ¨¡å¼ï¼ˆseccompï¼‰çš„ç›¸å…³æè¿°ã€‚ç°åœ¨å‰©ä¸‹çš„æ˜¯åœ¨å®¹å™¨é‡Œç¼–è¯‘è¿™è¿™ä¸¤ä¸ªç¨‹åºã€‚ç¬¬ä¸€ä¸ªå¯ä»¥è¿™æ ·åšï¼š</p>
</blockquote>

<blockquote>
  <p>go install â€“gcflags=â€-N -lâ€ github.com/mlowicki/hello
æ ‡è¯† â€“gcflag ç”¨äºç¦æ­¢ å†…è”å‡½æ•° ï¼ˆ-lï¼‰ï¼Œç¼–è¯‘ä¼˜åŒ–ï¼ˆ-Nï¼‰å¯ä»¥è®©è°ƒè¯•æ›´å®¹æ˜“ã€‚è°ƒè¯•å™¨å¦‚ä¸‹åšç¼–è¯‘ï¼š</p>
</blockquote>

<blockquote>
  <p>go install github.com/mlowicki/debugger
åœ¨å®¹å™¨çš„ç¯å¢ƒå˜é‡ PATH ä¸­åŒ…å« /go/bin ï¼Œè¿™æ ·ä¸ç”¨ä½¿ç”¨å®Œæ•´è·¯å¾„å°±å¯ä»¥è¿è¡Œä»»ä½•åˆšç¼–è¯‘å¥½çš„ç¨‹åºï¼Œä¸è®ºæ˜¯ hello è¿˜æ˜¯ debuggerã€‚</p>
</blockquote>

<p>ç¬¬ä¸€æ­¥
æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªä»»åŠ¡å¾ˆç®€å•ã€‚åœ¨æ‰§è¡Œä»»ä½•æŒ‡ä»¤ä¹‹å‰åœæ­¢ç¨‹åºï¼Œç„¶åå†è¿è¡Œèµ·æ¥ï¼Œç›´åˆ°ç¨‹åºåœæ­¢ï¼ˆä¸ç®¡æ˜¯è‡ªåŠ¨åœæ­¢è¿˜æ˜¯å‡ºç°é”™è¯¯åœæ­¢ï¼‰ã€‚å¤§å¤šæ•°è°ƒè¯•å™¨ä½ éƒ½å¯ä»¥è¿™æ ·å¼€å§‹ä½¿ç”¨ã€‚è®¾å®šä¸€äº›è·Ÿè¸ªç‚¹ï¼ˆæ–­ç‚¹ï¼‰ï¼Œç„¶åæ‰§è¡Œç±»ä¼¼ continue çš„æŒ‡ä»¤çœŸæ­£çš„è·‘èµ·æ¥ï¼Œç›´åˆ°åœåœ¨ä½ è¦åœçš„åœ°æ–¹ã€‚æˆ‘ä»¬çœ‹çœ‹ Delve æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼š</p>

<blockquote>
  <p>cat hello.go
package main
import â€œfmtâ€
func f() int {
    var n int
    n = 1
    n = 2
    return n
}
func main() {
    fmt.Println(f())
}
dlv debug
break Type â€˜helpâ€™ for list of commands.
(dlv) break main.f
Breakpoint 1 set at 0x1087050 for main.f() ./hello.go:5
(dlv) continue
main.f() ./hello.go:5 (hits goroutine(1):1 total:1) (PC: 0x1087050)
     1: package main
     2:
     3: import â€œfmtâ€
     4:
=&gt;   5: func f() int {
     6:     var n int
     7:     n = 1
     8:     n = 2
     9:     return n
    10: }
(dlv) next
main.f() ./hello.go:6 (PC: 0x1087067)
     1: package main
     2:
     3: import â€œfmtâ€
     4:
     5: func f() int {
=&gt;   6:     var n int
     7:     n = 1
     8:     n = 2
     9:     return n
    10: }
    11:
(dlv) print n
842350461344
(dlv) next
main.f() ./hello.go:7 (PC: 0x108706f)
     2:
     3: import â€œfmtâ€
     4:
     5: func f() int {
     6:     var n int
=&gt;   7:     n = 1
     8:     n = 2
     9:     return n
    10: }
    11:
    12: func main() {
(dlv) print n
0
(dlv) next
main.f() ./hello.go:8 (PC: 0x1087077)
     3: import â€œfmtâ€
     4:
     5: func f() int {
     6:     var n int
     7:     n = 1
=&gt;   8:     n = 2
     9:     return n
    10: }
    11:
    12: func main() {
    13:     fmt.Println(f())
(dlv) print n
1
è®©æˆ‘ä»¬çœ‹çœ‹æˆ‘ä»¬è‡ªå·±æ€ä¹ˆå®ç°ã€‚</p>
</blockquote>

<p>ç¬¬ä¸€æ­¥æ˜¯éœ€è¦ç»™è¿›ç¨‹ï¼ˆæˆ‘ä»¬çš„è°ƒè¯•å™¨ï¼‰æ‰¾ä¸€ä¸ªæœºåˆ¶ï¼Œå»æ§åˆ¶å…¶ä»–è¿›ç¨‹ï¼ˆæˆ‘ä»¬è¦è°ƒè¯•çš„è¿›ç¨‹ï¼‰ã€‚å¹¸å¥½åœ¨ Linux ä¸Šæˆ‘ä»¬æœ‰è¿™ä¸ªâ€“ ptraceã€‚è¿™è¿˜ä¸ç®—ã€‚Golang çš„ syscall åŒ…æä¾›äº†ä¸€ä¸ªç±»ä¼¼ PtraceCont çš„æ¥å£ï¼Œå¯ä»¥é‡å¯è¢«è·Ÿè¸ªçš„è¿›ç¨‹ã€‚å› æ­¤è¿™é‡ŒåŒ…å«äº†ç¬¬äºŒéƒ¨åˆ†å†…å®¹ï¼Œä½†æ˜¯ä¸ºäº†æœ‰æœºä¼šåœ¨ç¨‹åºå¼€å§‹æ‰§è¡Œä¹‹å‰è®¾ç½®æ–­ç‚¹æˆ‘ä»¬è¿˜å¾—åšç‚¹å…¶ä»–çš„ã€‚åˆ›å»ºæ–°è¿›ç¨‹çš„æ—¶å€™æˆ‘ä»¬å¯ä»¥é€šè¿‡è®¾ç½®å±æ€§â€“ SysProcAttr æŒ‡å®šè¿›ç¨‹è¡Œä¸ºã€‚å…¶ä¸­ä¸€ä¸ªæ˜¯ Ptrace å¯ä»¥è·Ÿè¸ªè¿›ç¨‹ï¼Œç„¶åè¿›ç¨‹ä¼šåœæ­¢å¹¶åœ¨å¼€å¯ä¹‹å‰ç»™çˆ¶è¿›ç¨‹å‘é€ SIGSTOP signalã€‚æˆ‘ä»¬æŠŠåˆšæ‰å­¦åˆ°çš„å†…å®¹æ•´ç†æˆä¸€ä¸ªå·¥ä½œæµç¨‹â€¦</p>

<blockquote>
  <p>cat src/github.com/mlowicki/hello/hello.go
package main
import â€œfmtâ€
func main() {
    fmt.Println(â€œhello worldâ€)
}
cat src/github.com/mlowicki/debugger/debugger.go
package main
import (
    â€œflagâ€
    â€œlogâ€
    â€œosâ€
    â€œos/execâ€
    â€œsyscallâ€
)
func main() {
    flag.Parse()
    input := flag.Arg(0)
    cmd := exec.Command(input)
    cmd.Args = []string{input}
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    cmd.SysProcAttr = &amp;syscall.SysProcAttr{Ptrace: true}
    err := cmd.Start()
    if err != nil {
        log.Fatal(err)
    }
    err = cmd.Wait()
    log.Printf(â€œState: %v\nâ€, err)
    log.Println(â€œRestartingâ€¦â€)
    err = syscall.PtraceCont(cmd.Process.Pid, 0)
    if err != nil {
        log.Panic(err)
    }
    var ws syscall.WaitStatus
    _, err = syscall.Wait4(cmd.Process.Pid, &amp;ws, syscall.WALL, nil)
    if err != nil {
        log.Fatal(err)
    }
    log.Printf(â€œExited: %v\nâ€, ws.Exited())
    log.Printf(â€œExit status: %v\nâ€, ws.ExitStatus())
}
go install -gcflags=â€-N -lâ€ github.com/mlowicki/hello
go install github.com/mlowicki/debugger
debugger /go/bin/hello
2017/05/05 20:09:38 State: stop signal: trace/breakpoint trap
2017/05/05 20:09:38 Restartingâ€¦
hello world
2017/05/05 20:09:38 Exited: true
2017/05/05 20:09:38 Exit status: 0
ç¬¬ä¸€ç‰ˆçš„è°ƒè¯•å™¨å®ç°æ–¹å¼å¾ˆç®€å•ã€‚å¯åŠ¨äº†ä¸€ä¸ªè¢«è·Ÿè¸ªçš„è¿›ç¨‹ï¼Œç„¶åè¿›ç¨‹åœ¨æ‰§è¡Œç¬¬ä¸€æ¡æŒ‡ä»¤å‰åœæ­¢ï¼Œå¹¶å‘çˆ¶è¿›ç¨‹å‘é€äº†ä¸€ä¸ª signalã€‚çˆ¶è¿›ç¨‹ç­‰å¾…è¿™ä¸ª signalï¼Œæ‰“å‡ºæ—¥å¿— log.Printf(â€œState: %v\nâ€, err)ã€‚ä¹‹åç¨‹åºé‡å¯ï¼Œçˆ¶è¿›ç¨‹ç­‰å¾…å…¶ç»ˆæ­¢ã€‚è¿™ç§æ–¹å¼å¯ä»¥è®©æˆ‘ä»¬æœ‰æœºä¼šæå‰è®¾ç½®æ–­ç‚¹ï¼Œå¯åŠ¨ç¨‹åºï¼Œç­‰ä¸€ä¼šåˆ°è¾¾æŒ‡å®šè·Ÿè¸ªç‚¹ï¼Œçœ‹çœ‹ç±»ä¼¼å †æ ˆæˆ–æ³¨å†Œè¡¨é‡Œçš„å½“å‰å€¼ï¼Œæ£€æŸ¥ä¸‹è¿›ç¨‹çŠ¶æ€ã€‚</p>
</blockquote>

<p>æˆ‘ä»¬é¦–å…ˆä»‹ç»äº†å¼€å‘ç¯å¢ƒå¹¶ä¸”å®ç°äº†ä¸€ä¸ªç®€å•çš„è°ƒè¯•å™¨ï¼ˆtracerï¼‰ï¼Œå®ƒå¯ä»¥ä½¿å­è¿›ç¨‹ï¼ˆtraceeï¼‰åœ¨æœ€å¼€å§‹å¤„åœæ­¢è¿è¡Œï¼Œç„¶åç»§ç»­æ‰§è¡Œï¼Œå¹¶æ˜¾ç¤ºå®ƒçš„æ ‡å‡†è¾“å‡ºã€‚ç°åœ¨æ˜¯æ‰©å±•è¿™ä¸ªç¨‹åºçš„æ—¶å€™äº†ã€‚</p>

<p>é€šå¸¸ï¼Œè°ƒè¯•å™¨å…è®¸å•æ­¥æ‰§è¡Œè¢«è°ƒè¯•çš„ä»£ç ï¼Œè¿™ä¸ªå¯ä»¥é€šè¿‡ ptrace çš„ PTRACE_SINGLESTEP å‘½ä»¤å®ç°ï¼Œå®ƒå‘Šè¯‰ traceeã€€æ‰§è¡Œå®Œä¸€æ¡æŒ‡ä»¤ååœæ­¢è¿è¡Œã€‚</p>

<p>package main</p>

<p>import (
    â€œflagâ€
    â€œlogâ€
    â€œosâ€
    â€œos/execâ€
    â€œsyscallâ€
)</p>

<p>func main() {
    flag.Parse()
    input := flag.Arg(0)
    cmd := exec.Command(input)
    cmd.Args = []string{input}
    cmd.Stdout = os.Stdout
    cmd.Stderr = os.Stderr
    cmd.SysProcAttr = &amp;syscall.SysProcAttr{Ptrace: true}
    err := cmd.Start()
    if err != nil {
        log.Fatal(err)
    }
    err = cmd.Wait()
    log.Printf(â€œState: %v\nâ€, err)
    wpid := cmd.Process.Pid
    pgid, err := syscall.Getpgid(cmd.Process.Pid)
    if err != nil {
        log.Panic(err)
    }
    err = syscall.PtraceSetOptions(cmd.Process.Pid, syscall.PTRACE_O_TRACECLONE)
    if err != nil {
        log.Fatal(err)
    }
    err = syscall.PtraceSingleStep(wpid)
    if err != nil {
        log.Fatal(err)
    }
    steps := 1</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
    var ws syscall.WaitStatus
    wpid, err = syscall.Wait4(-1*pgid, &amp;ws, syscall.WALL, nil)
    if wpid == -1 {
        log.Fatal(err)
    }
    if wpid == cmd.Process.Pid &amp;&amp; ws.Exited() {
        break
    }
    if !ws.Exited() {
        err := syscall.PtraceSingleStep(wpid)
        if err != nil {
            log.Fatal(err)
        }
        steps += 1
    }
}
log.Printf("Steps: %d\n", steps) } æ„å»ºå¹¶è¿è¡Œè¿™ä¸ªæ®µä»£ç ï¼Œè¾“å‡ºåº”è¯¥åƒä¸‹é¢è¿™æ ·ï¼ˆæ¯æ¬¡è°ƒç”¨æ˜¾ç¤ºçš„æ­¥æ•°å¯èƒ½ä¸ä¸€æ ·ï¼‰
</code></pre></div></div>

<blockquote>
  <p>go install -gcflags=â€-N -lâ€ github.com/mlowicki/hello
go install github.com/mlowicki/debugger
debugger /go/bin/hello
2017/06/09 19:54:42 State: stop signal: trace/breakpoint trap
hello world
2017/06/09 19:54:49 Steps: 297583
ç¨‹åºçš„å‰åŠéƒ¨åˆ†å’Œä¸Šä¸€ç¯‡æ–‡ç« é‡Œçš„ä¸€æ ·ï¼Œæ–°åŠ çš„åœ°æ–¹æ˜¯å¯¹ syscall.PtraceSingleStep çš„è°ƒç”¨ï¼Œå®ƒä½¿è¢«è°ƒè¯•çš„ç¨‹åºï¼ˆåœ¨è¿™é‡Œæ˜¯ hello )æ‰§è¡Œå®Œä¸€æ¡æŒ‡ä»¤ååœæ­¢ã€‚</p>
</blockquote>

<p>PTRACE_O_TRACECLONE é€‰é¡¹ä¹Ÿè¢«è®¾å®šäº†</p>

<p>PTRACE_O_TRACECLONE (since Linux 2.5.46) Stop the tracee at the next clone(2) and automatically start tracing the newly cloned processâ€¦</p>

<p>(http://man7.org/linux/man-pages/man2/ptrace.2.html)</p>

<p>ç”±äºæˆ‘ä»¬çš„è°ƒè¯•å™¨çŸ¥é“æ–°çº¿ç¨‹ä»€ä¹ˆæ—¶é—´å¼€å§‹å¹¶ä¸”å¯ä»¥è·³è¿‡å®ƒï¼Œæ‰€ä»¥æœ€åæ˜¾ç¤ºçš„æ­¥æ•°æ˜¯é€šè¿‡æ‰€æœ‰è¿›ç¨‹æ‰§è¡Œçš„æŒ‡ä»¤æ€»æ•°</p>

<p>è¢«æ‰§è¡Œçš„æŒ‡ä»¤æ•°é‡å¯èƒ½ç›¸å½“å¤šï¼Œä½†æ˜¯é‡Œé¢åŒ…å«äº† Go è¿è¡Œæ—¶ä¸­å…¶å®ƒä¸€äº›åˆå§‹åŒ–ä»£ç ï¼ˆæœ‰ C è¯­è¨€å¼€å§‹ç»éªŒçš„äººåº”è¯¥äº†è§£ libc çš„åˆå§‹åŒ–è¿‡ç¨‹ï¼‰ã€‚æˆ‘ä»¬å¯ä»¥å†™ä¸€ä¸ªéå¸¸ç®€å•çš„ç¨‹åºæ¥éªŒè¯æˆ‘ä»¬çš„è°ƒè¯•å™¨å·¥ä½œæ˜¯æ­£å¸¸çš„ã€‚è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ±‡ç¼–æ–‡ä»¶ src/github.com/mlowicki/hello/hello.asm:</p>

<p>section .data
    msg db â€œhello, world!â€, 0xA
    len equ $ â€” msg
section .text
    global _start
_start:
    mov rax, 1 ; write syscall (https://linux.die.net/man/2/write)
    mov rdi, 1 ; stdout
    mov rsi, msg
    mov rdx, len
    ; Passing parameters to <code class="language-plaintext highlighter-rouge">syscall</code> instruction described in
    ; https://en.wikibooks.org/wiki/X86_Assembly/Interfacing_with_Linux#syscall
    syscall
    mov rax, 60 ; exit syscall (https://linux.die.net/man/2/exit)
    mov rdi, 0 ; exit code
    syscall
åœ¨å®¹å™¨ä¸­æ„å»ºæˆ‘ä»¬çš„ â€œhello worldâ€ ç¨‹åºï¼Œçœ‹ä¸€ä¸‹æ‰§è¡Œäº†å¤šå°‘æ¡æŒ‡ä»¤</p>

<blockquote>
  <p>pwd
/go
apt-get install nasm
nasm -f elf64 -o hello.o src/github.com/mlowicki/hello/hello.asm &amp;&amp; ld -o hello hello.o
./hello
hello, world!
debugger ./hello
2017/06/17 17:58:43 State: stop signal: trace/breakpoint trap
hello, world!
2017/06/17 17:58:43 Steps: 8
è¾“å‡ºç»“æœå¾ˆå¥½ï¼Œæ­£å¥½ç­‰äº hello.asm ä¸­æŒ‡ä»¤çš„æ•°é‡</p>
</blockquote>

<p>åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“æ€æ ·è®©ç¨‹åºåœ¨ä¸€å¼€å§‹åœæ­¢ï¼Œå¦‚ä½•ä¸€æ­¥ä¸€æ­¥çš„æ‰§è¡Œä»£ç å¹¶æŸ¥çœ‹ è¿›ç¨‹/çº¿ç¨‹ çš„çŠ¶æ€ï¼Œç°åœ¨æ˜¯åœ¨éœ€è¦çš„åœ°æ–¹è®¾ç½®æ–­ç‚¹ï¼Œç›‘è§†åƒå˜é‡å€¼è¿™æ ·çš„è¿›ç¨‹çŠ¶æ€çš„æ—¶å€™äº†ã€‚</p>

<p>è®©æˆ‘ä»¬ä»ä¸€ä¸ªç®€å•çš„ä¾‹å­å¼€å§‹ï¼Œhello.go ä¸­æœ‰ä¸€ä¸ª main å‡½æ•°</p>

<p>package main</p>

<p>import â€œfmtâ€</p>

<p>func main() {
    fmt.Println(â€œhello worldâ€)
}
æ€æ ·åœ¨è¿™ä¸ªå‡½æ•°çš„ä¸€å¼€å§‹è®¾ç½®æ–­ç‚¹å‘¢ï¼Ÿæˆ‘ä»¬çš„ç¨‹åºç»è¿‡ç¼–è¯‘é“¾æ¥åï¼Œæœ€ç»ˆç”Ÿæˆçš„æ˜¯ä¸€ç³»åˆ—æœºå™¨æŒ‡ä»¤ã€‚æ€æ ·åœ¨åªåŒ…å«äº†ä¸€äº›äºŒè¿›åˆ¶ä»£ç ï¼ˆåªæœ‰ CPU èƒ½ç†è§£çš„æ ¼å¼ï¼‰çš„æºæ–‡ä»¶é‡Œè¡¨ç¤ºæˆ‘ä»¬è¦è®¾ç½®ä¸€ä¸ªæ–­ç‚¹å‘¢ï¼Ÿ</p>

<p>lineTable
Golang å†…ç½®æœ‰ä¸€äº›åŠŸèƒ½ï¼Œå¯ä»¥è®¿é—®ç¼–è¯‘ç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶ä¸­çš„è°ƒè¯•ä¿¡æ¯ã€‚ ç»´æŠ¤ æŒ‡ä»¤è®¡æ•°å™¨ ( PC ) å’Œç¨‹åºä»£ç è¡Œçš„æ˜ å°„å…³ç³»çš„ç»“æ„å«åšè¡Œè¡¨ï¼Œè®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªä¾‹å­æ¥çœ‹ä¸€ä¸‹</p>

<p>package main</p>

<p>import (
    â€œdebug/elfâ€
    â€œdebug/gosymâ€
    â€œflagâ€
    â€œlogâ€
)</p>

<p>func main() {
    flag.Parse()
    path := flag.Arg(0)
    exe, err := elf.Open(path)
    if err != nil {
        log.Fatal(err)
    }
    var pclndat []byte
    if sec := exe.Section(â€œ.gopclntabâ€); sec != nil {
        pclndat, err = sec.Data()
        if err != nil {
            log.Fatalf(â€œCannot read .gopclntab section: %vâ€, err)
        }
    }
    sec := exe.Section(â€œ.gosymtabâ€)
    symTabRaw, err := sec.Data()
    pcln := gosym.NewLineTable(pclndat, exe.Section(â€œ.textâ€).Addr)
    symTab, err := gosym.NewTable(symTabRaw, pcln)
    if err != nil {
        log.Fatal(â€œCannot create symbol table: %vâ€, err)
    }
    sym := symTab.LookupFunc(â€œmain.mainâ€)
    filename, lineno, _ := symTab.PCToLine(sym.Entry)
    log.Printf(â€œfilename: %v\nâ€, filename)
    log.Printf(â€œlineno: %v\nâ€, lineno)
}
å¦‚æœä¼ é€’ç»™ä¸Šé¢ç¨‹åºçš„æ–‡ä»¶ä¸­åŒ…å«ä»¥ä¸‹ä»£ç </p>

<p>package main</p>

<p>import â€œfmtâ€</p>

<p>func main() {
    fmt.Println(â€œhello worldâ€)
}
é‚£ä¹ˆè¾“å‡ºåº”è¯¥æ˜¯è¿™æ ·çš„</p>

<blockquote>
  <p>go install github.com/mlowicki/linetable
go install â€” gcflags=â€-N -lâ€ github.com/mlowicki/hello
linetable /go/bin/hello
2017/06/30 18:47:38 filename: /go/src/github.com/mlowicki/hello/hello.go
2017/06/30 18:47:38 lineno: 5
ELF æ˜¯ Executable and Linkable Format çš„ç¼©å†™ï¼Œæ˜¯ä¸€ç§å¯æ‰§è¡Œæ–‡ä»¶çš„æ ¼å¼</p>
</blockquote>

<blockquote>
  <p>apt-get install file
file /go/bin/hello
/go/bin/hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped
ELF ä¸­åŒ…å«è®¸å¤šæ®µï¼Œæˆ‘ä»¬ç”¨åˆ°äº†å…¶ä¸­ä¸‰ä¸ªï¼š.textã€.gopclntab å’Œ .gosymtabã€‚ç¬¬ä¸€ä¸ªåŒ…å«äº†æœºå™¨æŒ‡ä»¤ï¼Œç¬¬äºŒä¸ªå®ç°äº†æŒ‡ä»¤è®¡æ•°å™¨åˆ°æºç è¡Œçš„æ˜ å°„ï¼Œæœ€åä¸€ä¸ªæ˜¯ä¸€ä¸ªç¬¦å·è¡¨</p>
</blockquote>

<p>https://medium.com/golangspec/making-debugger-in-golang-part-i
https://medium.com/golangspec/making-debugger-in-golang-part-ii</p>
:ET