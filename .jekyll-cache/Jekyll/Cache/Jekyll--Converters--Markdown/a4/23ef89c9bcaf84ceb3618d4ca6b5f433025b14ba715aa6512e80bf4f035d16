I"‘<p>ç”¨(*interface{})(nil)ä¼ é€’å‚æ•°ç±»å‹
type injector struct {     <br />
  values map[reflect.Type]reflect.Value     <br />
  parent Injector
}</p>

<p>æ’‡å¼€ parentä¸çœ‹ï¼Œvaluesæ˜¯ä¸€ä¸ªæ˜ å°„è¡¨ï¼Œç”¨äºä¿å­˜æ³¨å…¥çš„å‚æ•°ï¼Œå®ƒæ˜¯ä¸€ä¸ªç”¨reflect.Typeå½“é”®ã€reflect.Valueä¸ºå€¼çš„mapã€‚
<!-- more -->
njectoræ˜¯æ³¨å…¥æ¥å£å£°æ˜çš„ç»„åˆï¼Œæˆ‘ä»¬å…ˆå…³æ³¨TypeMapperè¿™ä¸ªæ¥å£ï¼Œä»æºç å¯ä»¥å¾—çŸ¥Mapå’ŒMapToæ˜¯ç”¨æ¥æ˜ å°„æ•°æ®ç±»å‹å’Œæ•°æ®åˆ°values map[reflect.Type]reflect.Valueçš„æ–¹æ³•ã€‚
Mapæ–¹æ³•ç›¸å¯¹æ¥è¯´æ¯”è¾ƒç®€å•ï¼Œåˆ©ç”¨åå°„è·å–å¯¹è±¡çš„typeã€‚
func (i *injector) Map(val interface{}) TypeMapper {
    i.values[reflect.TypeOf(val)] = reflect.ValueOf(val)
    return i
}</p>

<p>ç°åœ¨æˆ‘ä»¬å…ˆå‡è®¾å‚æ•°ä¸­æœ‰å¤šä¸ªstringæ—¶ï¼Œvalues map[reflect.Type]reflect.Valueè¿™ä¸ªmapåªä¼šä¿å­˜æœ€åä¸€ä¸ªstringçš„æ˜ å°„ï¼Œé‚£æˆ‘ä»¬è¯¥å¦‚ä½•å¤„ç†æ‰èƒ½å®Œæ•´çš„ä¿å­˜æ‰€æœ‰çš„stringå‚æ•°å‘¢ï¼Ÿ
è€ƒè™‘interfaceç±»å‹åœ¨åº•å±‚çš„å®ç°(type,data)ï¼Œinjectåº“å®ç°äº†ä¸€ä¸ªä»interfaceæŒ‡é’ˆä¸­è·å–ç±»å‹çš„å‡½æ•°InterfaceOfï¼Œè€ŒMapToåˆ™åˆ©ç”¨InterfaceOfæ¥è·å–ä¼ å…¥çš„æ•°æ®ç±»å‹ã€‚
func InterfaceOf(value interface{}) reflect.Type {     <br />
  t := reflect.TypeOf(value)</p>

<p>for t.Kind() == reflect.Ptr {            <br />
    t = t.Elem()     <br />
  }</p>

<p>if t.Kind() != reflect.Interface {            <br />
    panic(â€œCalled inject.InterfaceOf with a value that is not a pointer to an interface. (*MyInterface)(nil)â€)     <br />
  }     <br />
  return t
}</p>

<p>func (i *injector) MapTo(val interface{}, ifacePtr interface{}) TypeMapper {
    i.values[InterfaceOf(ifacePtr)] = reflect.ValueOf(val)
    return i
}</p>

<p>package main</p>

<p>import ( 
  â€œfmtâ€ 
  â€œgithub.com/codegangsta/injectâ€
)</p>

<p>type SpecialString interface{}</p>

<p>func main() { <br />
  fmt.Println(inject.InterfaceOf((<em>interface{})(nil)))    <br />
  fmt.Println(inject.InterfaceOf((</em>SpecialString)(nil)))
}</p>

<p>è¾“å‡º
interface {}
main.SpecialString</p>

<p>çœ‹åˆ°äº†å—ï¼ŸæŒ‡å‘æ¥å£çš„ç©ºæŒ‡é’ˆï¼Œè™½ç„¶dataæ˜¯nilï¼Œä½†æ˜¯æˆ‘ä»¬åªè¦å®ƒçš„typeã€‚åˆ†æ­¥è§£é‡Šä¸€ä¸‹ï¼š
//ä»¥(<em>SpecialString)(nil)ä¸ºä¾‹
t := reflect.TypeOf(value) //tæ˜¯</em>main.SpecialStringï¼Œt.Kind()æ˜¯ptr,t.Elem()æ˜¯main.SpecialString
for t.Kind() == reflect.Ptr { //å¾ªç¯åˆ¤æ–­ï¼Œä¹Ÿè®¸æ˜¯æŒ‡å‘æŒ‡é’ˆçš„æŒ‡é’ˆ
  t = t.Elem() //Elem returns a typeâ€™s element type.
}
if t.Kind() != reflect.Interface {
  â€¦ //å¦‚æœä¸æ˜¯Interfaceç±»å‹ï¼ŒæŠ¥panic
}
return t //è¿”å›(*SpecialString)(nil)çš„å…ƒç´ åŸå§‹ç±»å‹</p>

<p>interface{}æ˜¯ä»€ä¹ˆï¼Œåœ¨goé‡Œé¢interface{}å°±æ˜¯ä¸‡èƒ½çš„Anyã€‚injectåˆ©ç”¨äº†(*interface{})(nil)æºå¸¦æ•°æ®ç±»å‹çš„ç‰¹ç‚¹ï¼Œåªç”¨ä¸€ä¸ªç©ºæŒ‡é’ˆå°±æå®šäº†æ•°æ®ç±»å‹çš„ä¼ è¾“ï¼Œè€Œä¸”æ‰©å±•äº†åŒç±»å‹æ•°æ®çš„ç»‘å®šã€‚
è®©æˆ‘ä»¬åˆ°martini.goå»çœ‹çœ‹è¿™ä¸ªæ³¨å…¥æ˜¯æ€ä¹ˆç”¨çš„å§ã€‚
// Martini represents the top level web application. inject.Injector methods can be invoked to map services on a global level.
type Martini struct {     <br />
  inject.Injector     <br />
  handlers []Handler     <br />
  action   Handler     <br />
  logger   *log.Logger
}</p>

<p>// New creates a bare bones Martini instance. Use this method if you want to have full control over the middleware that is used.
func New() *Martini {     <br />
  m := &amp;Martini{Injector: inject.New(), action: func() {}, logger: log.New(os.Stdout, â€œ[martini] â€œ, 0)}     <br />
  m.Map(m.logger)     <br />
  m.Map(defaultReturnHandler())     <br />
  return m
}</p>

<p>func (m <em>Martini) createContext(res http.ResponseWriter, req *http.Request) *context {
    c := &amp;context{inject.New(), m.handlers, m.action, NewResponseWriter(res), 0}
    c.SetParent(m)
    c.MapTo(c, (</em>Context)(nil))
    c.MapTo(c.rw, (*http.ResponseWriter)(nil))
    c.Map(req)
    return c
}</p>

<p>è‡ªå®šä¹‰çš„Martiniç»“æ„ä½“åŒ…å«äº†inject.Injectoræ¥å£ï¼Œæ‰€ä»¥å¯ä»¥å¾ˆæ–¹ä¾¿çš„æ³¨å…¥loggerã€‚åç»­Invokeä¸­é—´ä»¶çš„æ—¶å€™ï¼Œè‡ªç„¶å°±å¯ä»¥é€šè¿‡Injectorçš„Getæ–¹æ³•è·å–loggerå¯¹è±¡ã€‚contextåˆ™ä½¿ç”¨äº†MapToæ–¹æ³•æ³¨å…¥äº†Contextå’Œhttp.ResponseWriterè¿™ä¸¤ä¸ªæ¥å£ç±»å‹ã€‚</p>

<p>func (inj *injector) Invoke(f interface{}) ([]reflect.Value, error) {
    t := reflect.TypeOf(f)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var in = make([]reflect.Value, t.NumIn()) //Panic if t is not kind of Func
for i := 0; i &lt; t.NumIn(); i++ {
    argType := t.In(i)
    val := inj.Get(argType)
    if !val.IsValid() {
        return nil, fmt.Errorf("Value not found for type %v", argType)
    }

    in[i] = val
}

return reflect.ValueOf(f).Call(in), nil }
</code></pre></div></div>

<p>å…¶å®æ²¡æœ‰å¤ªå¤šæœ‰æŠ€æœ¯å«é‡çš„ä¸œè¥¿ï¼Œåªè¦æŠŠåå°„åƒé€äº†ï¼Œå†å¼„æ¸…æ¥šå‰æ–‡ä¸­Mapå’ŒMapToå­˜å‚¨çš„ç±»å‹æ•°æ®æ˜ å°„mapï¼Œé‚£ä¹ˆgoçš„ä¾èµ–æ³¨å…¥å°±è¿™ä¹ˆèµ¤è£¸è£¸çš„å±•ç°åœ¨ä½ çœ¼å‰ã€‚
å°†å‡½æ•°çš„å€¼ä»ç©ºæ¥å£ä¸­åå°„å‡ºæ¥ï¼Œç„¶åä½¿ç”¨reflect.Callæ¥ä¼ é€’å‚æ•°å¹¶è°ƒç”¨å®ƒã€‚å‚æ•°ä¸ªæ•°ä»t.NumIn()è·å–ï¼Œå¾ªç¯éå†å‚æ•°ç±»å‹ï¼Œå†é€šè¿‡Getæ–¹æ³•ä»values map[reflect.Type]reflect.Valueè·å–å¯¹åº”ç±»å‹çš„æ•°æ®ã€‚
func (i *injector) Get(t reflect.Type) reflect.Value {
    val := i.values[t]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if val.IsValid() {
    return val
}

// no concrete types found, try to find implementors
// if t is an interface
if t.Kind() == reflect.Interface {
    for k, v := range i.values {
        if k.Implements(t) {
            val = v
            break
        }
    }
}

// Still no type found, try to look it up on the parent
if !val.IsValid() &amp;&amp; i.parent != nil {
    val = i.parent.Get(t)
}

return val
</code></pre></div></div>

<p>}</p>
:ET