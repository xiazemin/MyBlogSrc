I"<p>GoConvey是一款针对Golang的测试框架，可以管理和运行测试用例，同时提供了丰富的断言函数，并支持很多 Web 界面特性。
Golang虽然自带了单元测试功能，并且在GoConvey框架诞生之前也出现了许多第三方测试框架，但没有一个测试框架像GoConvey一样能够让程序员如此简洁优雅的编写测试代码。
安装
在命令行运行下面的命令：
go get github.com/smartystreets/goconvey</p>

<p>运行时间较长，运行完后你会发现：</p>

<p>在$GOPATH/src目录下新增了github.com子目录，该子目录里包含了GoConvey框架的库代码
在$GOPATH/bin目录下新增了GoConvey框架的可执行程序goconvey
<!-- more -->
import (
    “testing”
    . “github.com/smartystreets/goconvey/convey”
)</p>

<p>func TestStringSliceEqual(t *testing.T) {
    Convey(“TestStringSliceEqual should return true when a != nil  &amp;&amp; b != nil”, t, func() {
        a := []string{“hello”, “goconvey”}
        b := []string{“hello”, “goconvey”}
        So(StringSliceEqual(a, b), ShouldBeTrue)
    })
}</p>

<p>由于GoConvey框架兼容Golang原生的单元测试，所以可以使用go test -v来运行测试。
打开命令行，进入$GOPATH/src/infra/alg目录下，运行go test -v</p>

<p>import goconvey包时，前面加点号”.”，以减少冗余的代码。凡是在测试代码中看到Convey和So两个方法，肯定是convey包的，不要在产品代码中定义相同的函数名
测试函数的名字必须以Test开头，而且参数类型必须为<em>testing.T
每个测试用例必须使用Convey函数包裹起来，它的第一个参数为string类型的测试描述，第二个参数为测试函数的入参（类型为</em>testing.T），第三个参数为不接收任何参数也不返回任何值的函数（习惯使用闭包）
Convey函数的第三个参数闭包的实现中通过So函数完成断言判断，它的第一个参数为实际值，第二个参数为断言函数变量，第三个参数或者没有（当第二个参数为类ShouldBeTrue形式的函数变量）或者有（当第二个函数为类ShouldEqual形式的函数变量）</p>

<p>GoConvey不仅支持在命令行进行自动化编译测试，而且还支持在 Web 界面进行自动化编译测试。想要使用GoConvey的 Web 界面特性，需要在测试文件所在目录下执行goconvey：</p>

<p>$GOPATH/bin/goconvey</p>

<p>在 Web 界面中:</p>

<p>可以设置界面主题
查看完整的测试结果
使用浏览器提醒等实用功能
自动检测代码变动并编译测试
半自动化书写测试用例
查看测试覆盖率
临时屏蔽某个包的编译测试</p>

<p>Skip
针对想忽略但又不想删掉或注释掉某些断言操作，GoConvey提供了Convey/So的Skip方法：</p>

<p>SkipConvey函数表明相应的闭包函数将不被执行
SkipSo函数表明相应的断言将不被执行</p>

<p>当存在SkipConvey或SkipSo时，测试日志中会显式打上”skipped”形式的标记：</p>

<p>当测试代码中存在SkipConvey时，相应闭包函数中不管是否为SkipSo，都将被忽略，测试日志中对应的符号仅为一个”⚠”
当测试代码Convey语句中存在SkipSo时，测试日志中每个So对应一个”✔”或”✘”，每个SkipSo对应一个”⚠”，按实际顺序排列
不管存在SkipConvey还是SkipSo时，测试日志中都有字符串”{n} total assertions (one or more sections skipped)”，其中{n}表示测试中实际已运行的断言语句数</p>

<p>定制断言函数
我们先看一下So的函数原型：
func So(actual interface{}, assert assertion, expected …interface{})</p>

<p>第二个参数为assertion，它的原型为：
type assertion func(actual interface{}, expected …interface{}) string</p>

<p>当assertion的返回值为”“时表示断言成功，否则表示失败，GoConvey框架中的相关代码为：
const (
    success                = “”
    needExactValues        = “This assertion requires exactly %d comparison values (you provided %d).”
    needNonEmptyCollection = “This assertion requires at least 1 comparison value (you provided 0).”
)</p>

<p>我们简单实现一个assertion函数：
func ShouldSummerBeComming(actual interface{}, expected …interface{}) string {
    if actual == “summer” &amp;&amp; expected[0] == “comming” {
        return “”
    } else {
        return “summer is not comming!”
    }
}</p>

<p>我们仍然在slice_test文件中写一个简单测试：
func TestSummer(t *testing.T) {
    Convey(“TestSummer”, t, func() {
        So(“summer”, ShouldSummerBeComming, “comming”)
        So(“winter”, ShouldSummerBeComming, “comming”)
    })
}</p>

<p>根据ShouldSummerBeComming的实现，Convey语句中第一个So将断言成功，第二个So将断言失败。</p>

<p>GoConvey 是个相当不错的 Go 测试工具，支持 go test。可直接在终端窗口和浏览器上使用。</p>

<p>特点：</p>

<p>直接与 go test 集成
巨大的回归测试套件
可读性强的色彩控制台输出
完全自动化的 Web UI
测试代码生成器
桌面提醒（可选）
自动在终端中运行自动测试脚本
可立即在 Sublime Text 中打开测试问题对应的代码行 (some assembly required)</p>

:ET