I"Cï<p>runtime.MemStatsè¿™ä¸ªç»“æ„ä½“åŒ…å«çš„å­—æ®µæ¯”è¾ƒå¤šï¼Œä½†æ˜¯å¤§å¤šéƒ½å¾ˆæœ‰ç”¨ï¼š
1ã€Alloc uint64 //golangè¯­è¨€æ¡†æ¶å †ç©ºé—´åˆ†é…çš„å­—èŠ‚æ•°
2ã€TotalAlloc uint64 //ä»æœåŠ¡å¼€å§‹è¿è¡Œè‡³ä»Šåˆ†é…å™¨ä¸ºåˆ†é…çš„å †ç©ºé—´æ€» å’Œï¼Œåªæœ‰å¢åŠ ï¼Œé‡Šæ”¾çš„æ—¶å€™ä¸å‡å°‘
3ã€Sys uint64 //æœåŠ¡ç°åœ¨ç³»ç»Ÿä½¿ç”¨çš„å†…å­˜
4ã€Lookups uint64 //è¢«runtimeç›‘è§†çš„æŒ‡é’ˆæ•°
5ã€Mallocs uint64 //æœåŠ¡malloc heap objectsçš„æ¬¡æ•°
6ã€Frees uint64 //æœåŠ¡å›æ”¶çš„heap objectsçš„æ¬¡æ•°
7ã€HeapAlloc uint64 //æœåŠ¡åˆ†é…çš„å †å†…å­˜å­—èŠ‚æ•°
8ã€HeapSys uint64 //ç³»ç»Ÿåˆ†é…çš„ä½œä¸ºè¿è¡Œæ ˆçš„å†…å­˜
9ã€HeapIdle uint64 //ç”³è¯·ä½†æ˜¯æœªåˆ†é…çš„å †å†…å­˜æˆ–è€…å›æ”¶äº†çš„å †å†…å­˜ï¼ˆç©ºé—²ï¼‰å­—èŠ‚æ•°
10ã€HeapInuse uint64 //æ­£åœ¨ä½¿ç”¨çš„å †å†…å­˜å­—èŠ‚æ•°
10ã€HeapReleased uint64 //è¿”å›ç»™OSçš„å †å†…å­˜ï¼Œç±»ä¼¼C/C++ä¸­çš„freeã€‚
11ã€HeapObjects uint64 //å †å†…å­˜å—ç”³è¯·çš„é‡
12ã€StackInuse uint64 //æ­£åœ¨ä½¿ç”¨çš„æ ˆå­—èŠ‚æ•°
13ã€StackSys uint64 //ç³»ç»Ÿåˆ†é…çš„ä½œä¸ºè¿è¡Œæ ˆçš„å†…å­˜
14ã€MSpanInuse uint64 //ç”¨äºæµ‹è¯•ç”¨çš„ç»“æ„ä½“ä½¿ç”¨çš„å­—èŠ‚æ•°
15ã€MSpanSys uint64 //ç³»ç»Ÿä¸ºæµ‹è¯•ç”¨çš„ç»“æ„ä½“åˆ†é…çš„å­—èŠ‚æ•°
16ã€MCacheInuse uint64 //mcacheç»“æ„ä½“ç”³è¯·çš„å­—èŠ‚æ•°(ä¸ä¼šè¢«è§†ä¸ºåƒåœ¾å›æ”¶)
17ã€MCacheSys uint64 //æ“ä½œç³»ç»Ÿç”³è¯·çš„å †ç©ºé—´ç”¨äºmcacheçš„å­—èŠ‚æ•°
18ã€BuckHashSys uint64 //ç”¨äºå‰–ææ¡¶æ•£åˆ—è¡¨çš„å †ç©ºé—´
19ã€GCSys uint64 //åƒåœ¾å›æ”¶æ ‡è®°å…ƒä¿¡æ¯ä½¿ç”¨çš„å†…å­˜
20ã€OtherSys uint64 //golangç³»ç»Ÿæ¶æ„å ç”¨çš„é¢å¤–ç©ºé—´
21ã€NextGC uint64 //åƒåœ¾å›æ”¶å™¨æ£€è§†çš„å†…å­˜å¤§å°
22ã€LastGC uint64 // åƒåœ¾å›æ”¶å™¨æœ€åä¸€æ¬¡æ‰§è¡Œæ—¶é—´ã€‚
23ã€PauseTotalNs uint64 // åƒåœ¾å›æ”¶æˆ–è€…å…¶ä»–ä¿¡æ¯æ”¶é›†å¯¼è‡´æœåŠ¡æš‚åœçš„æ¬¡æ•°ã€‚
24ã€PauseNs [256]uint64 //ä¸€ä¸ªå¾ªç¯é˜Ÿåˆ—ï¼Œè®°å½•æœ€è¿‘åƒåœ¾å›æ”¶ç³»ç»Ÿä¸­æ–­çš„æ—¶é—´
25ã€PauseEnd [256]uint64 //ä¸€ä¸ªå¾ªç¯é˜Ÿåˆ—ï¼Œè®°å½•æœ€è¿‘åƒåœ¾å›æ”¶ç³»ç»Ÿä¸­æ–­çš„æ—¶é—´å¼€å§‹ç‚¹ã€‚
26ã€NumForcedGC uint32 //æœåŠ¡è°ƒç”¨runtime.GC()å¼ºåˆ¶ä½¿ç”¨åƒåœ¾å›æ”¶çš„æ¬¡æ•°ã€‚
27ã€GCCPUFraction float64 //åƒåœ¾å›æ”¶å ç”¨æœåŠ¡CPUå·¥ä½œçš„æ—¶é—´æ€»å’Œã€‚å¦‚æœæœ‰100ä¸ªgoroutineï¼Œåƒåœ¾å›æ”¶çš„æ—¶é—´ä¸º1S,é‚£ä¹ˆå°±å ç”¨äº†100Sã€‚
28ã€BySize //å†…å­˜åˆ†é…å™¨ä½¿ç”¨æƒ…å†µ
<!-- more -->
ç”¨Golangè¿™æ ·å¸¦GCçš„è¯­è¨€ç¼–å†™é•¿æœŸè¿è¡Œçš„ç½‘ç»œæœåŠ¡æœ‰ä¸€ä¸ªå¾ˆå¤§çš„æŒ‘æˆ˜ï¼Œé‚£å°±æ˜¯å†…å­˜ç®¡ç†ã€‚</p>

<p>ä¸ºäº†ç†è§£Golangçš„å†…å­˜ç®¡ç†æœ‰å¿…è¦å¯¹run-timeæºç è¿›è¡Œæ·±æŒ–ã€‚æœ‰ä¸¤ä¸ªè¿›ç¨‹åŒºåˆ†åº”ç”¨ç¨‹åºä¸å†ä½¿ç”¨çš„å†…å­˜ï¼Œå½“å®ƒä»¬çœ‹èµ·æ¥ä¸ä¼šå†ä½¿ç”¨ï¼Œå°±æŠŠå®ƒä»¬å½’è¿˜åˆ°æ“ä½œç³»ç»Ÿï¼ˆåœ¨Golangæºç é‡Œç§°ä¸ºscavenging ï¼‰ã€‚</p>

<p>è¿™é‡Œæœ‰ä¸€ä¸ªç®€å•çš„ç¨‹åºåˆ¶é€ äº†å¤§é‡çš„åƒåœ¾ï¼ˆgarbageï¼‰ï¼Œæ¯ç§’é’Ÿåˆ›å»ºä¸€ä¸ª 5,000,000 åˆ° 10,000,000 bytes çš„æ•°ç»„ã€‚ç¨‹åºç»´æŒäº†20ä¸ªè¿™æ ·çš„æ•°ç»„ï¼Œå…¶ä»–çš„åˆ™è¢«ä¸¢å¼ƒã€‚ç¨‹åºè¿™æ ·è®¾è®¡æ˜¯ä¸ºäº†æ¨¡æ‹Ÿä¸€ç§éå¸¸å¸¸è§çš„æƒ…å†µï¼šéšç€æ—¶é—´çš„æ¨ç§»ï¼Œç¨‹åºä¸­çš„ä¸åŒéƒ¨åˆ†ç”³è¯·äº†å†…å­˜ï¼Œæœ‰ä¸€äº›è¢«ä¿ç•™ï¼Œä½†å¤§éƒ¨åˆ†ä¸å†é‡å¤ä½¿ç”¨ã€‚åœ¨Goè¯­è¨€ç½‘ç»œç¼–ç¨‹ä¸­ï¼Œç”¨goroutines æ¥å¤„ç†ç½‘ç»œè¿æ¥å’Œç½‘ç»œè¯·æ±‚æ—¶ï¼ˆnetwork connections or requestsï¼‰ï¼Œé€šå¸¸goroutineséƒ½ä¼šç”³è¯·ä¸€å—å†…å­˜ï¼ˆæ¯”å¦‚sliceæ¥å­˜å‚¨æ”¶åˆ°çš„æ•°æ®ï¼‰ç„¶åå°±ä¸å†ä½¿ç”¨å®ƒä»¬äº†ã€‚éšç€æ—¶é—´çš„æ¨ç§»ï¼Œä¼šæœ‰å¤§é‡çš„å†…å­˜è¢«ç½‘ç»œè¿æ¥ï¼ˆnetwork connectionsï¼‰ä½¿ç”¨ï¼Œè¿æ¥ç´¯ç§¯çš„åƒåœ¾come and goneã€‚</p>

<p>package main</p>

<p>import (<br />
    â€œfmtâ€ 
    â€œmath/randâ€ 
    â€œruntimeâ€ 
    â€œtimeâ€
)</p>

<p>func makeBuffer() []byte {<br />
    return make([]byte, rand.Intn(5000000)+5000000)<br />
}</p>

<p>func main() {<br />
    pool := make([][]byte, 20)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var m runtime.MemStats  
makes := 0  
for {  
    b := makeBuffer()
    makes += 1
    i := rand.Intn(len(pool))
    pool[i] = b
 
    time.Sleep(time.Second)
 
    bytes := 0
 
    for i := 0; i &lt; len(pool); i++ {
        if pool[i] != nil {
            bytes += len(pool[i])
        }
    }
 
    runtime.ReadMemStats(&amp;m)
    fmt.Printf("%d,%d,%d,%d,%d,%d\n", m.HeapSys, bytes, m.HeapAlloc,
        m.HeapIdle, m.HeapReleased, makes)
} } ç¨‹åºä½¿ç”¨ runtime.ReadMemStatså‡½æ•°æ¥è·å–å †çš„ä½¿ç”¨ä¿¡æ¯ã€‚å®ƒæ‰“å°äº†å››ä¸ªå€¼ï¼Œ
</code></pre></div></div>

<p>HeapSysï¼šç¨‹åºå‘åº”ç”¨ç¨‹åºç”³è¯·çš„å†…å­˜</p>

<p>HeapAllocï¼šå †ä¸Šç›®å‰åˆ†é…çš„å†…å­˜</p>

<p>HeapIdleï¼šå †ä¸Šç›®å‰æ²¡æœ‰ä½¿ç”¨çš„å†…å­˜</p>

<p>HeapReleasedï¼šå›æ”¶åˆ°æ“ä½œç³»ç»Ÿçš„å†…å­˜</p>

<p>GCåœ¨Golangä¸­è¿è¡Œçš„å¾ˆé¢‘ç¹ï¼ˆå‚è§GOGCç¯å¢ƒå˜é‡ï¼ˆGOGC environment variable ï¼‰æ¥ç†è§£æ€æ ·æ§åˆ¶åƒåœ¾å›æ”¶æ“ä½œï¼‰ï¼Œå› æ­¤åœ¨è¿è¡Œä¸­ç”±äºä¸€äº›å†…å­˜è¢«æ ‡è®°ä¸ºâ€æœªä½¿ç”¨â€œï¼Œå †ä¸Šçš„å†…å­˜å¤§å°ä¼šå‘ç”Ÿå˜åŒ–ï¼šè¿™ä¼šå¯¼è‡´HeapAllocå’ŒHeapIdleå‘ç”Ÿå˜åŒ–ã€‚Golangä¸­çš„scavenger ä¼šé‡Šæ”¾é‚£äº›è¶…è¿‡5åˆ†é’Ÿä»ç„¶æ²¡æœ‰å†ä½¿ç”¨çš„å†…å­˜ï¼Œå› æ­¤HeapReleasedä¸ä¼šç»å¸¸å˜åŒ–</p>

<p>ä¸‹é¢è¿™å¼ å›¾æ˜¯ä¸Šé¢çš„ç¨‹åºè¿è¡Œäº†10åˆ†é’Ÿä»¥åçš„æƒ…å†µï¼š</p>

<p>(åœ¨è¿™å¼ å’Œåç»­çš„å›¾ä¸­ï¼Œå·¦è½´ä»¥æ˜¯ä»¥byteä¸ºå•ä½çš„å†…å­˜å¤§å°ï¼Œå³è½´æ˜¯ç¨‹åºæ‰§è¡Œæ¬¡æ•°)</p>

<p>çº¢çº¿å±•ç¤ºäº†poolä¸­byte buffersçš„æ•°é‡ã€‚20ä¸ª buffers å¾ˆå¿«è¾¾åˆ°150,000,000 bytesã€‚æœ€ä¸Šæ–¹çš„è“è‰²çº¿è¡¨ç¤ºç¨‹åºä»æ“ä½œç³»ç»Ÿç”³è¯·çš„å†…å­˜ã€‚ç¨³å®šåœ¨375,000,000 bytesã€‚å› æ­¤ç¨‹åºç”³è¯·äº†2.5å€å®ƒæ‰€éœ€çš„ç©ºé—´ï¼</p>

<p>å½“GCå‘ç”Ÿæ—¶ï¼ŒHeapIdleå’ŒHeapAllocå‘ç”Ÿè·³å˜ã€‚æ©˜è‰²çš„çº¿æ˜¯makeBuffer()å‘é€çš„æ¬¡æ•°ã€‚</p>

<p>è¿™ç§è¿‡åº¦çš„å†…å­˜ç”³è¯·æ˜¯æœ‰GCçš„ç¨‹åºçš„é€šç—…ï¼Œå‚è§è¿™ç¯‡paper</p>

<p>Quantifying the Performance of Garbage Collection vs. Explicit Memory Management</p>

<p>ç¨‹åºä¸æ–­æ‰§è¡Œï¼Œidle memoryï¼ˆå³HeapIdleï¼‰ä¼šè¢«é‡ç”¨ï¼Œä½†å¾ˆå°‘å½’è¿˜åˆ°æ“ä½œç³»ç»Ÿã€‚</p>

<p>è§£å†³æ­¤é—®é¢˜çš„ä¸€ä¸ªåŠæ³•æ˜¯åœ¨ç¨‹åºä¸­æ‰‹åŠ¨è¿›è¡Œå†…å­˜ç®¡ç†ã€‚ä¾‹å¦‚ï¼Œ</p>

<p>ç¨‹åºå¯ä»¥è¿™æ ·é‡å†™ï¼š
package main</p>

<p>import (
    â€œfmtâ€
    â€œmath/randâ€
    â€œruntimeâ€
    â€œtimeâ€
)</p>

<p>func makeBuffer() []byte {
    return make([]byte, rand.Intn(5000000)+5000000)
}</p>

<p>func main() {
    pool := make([][]byte, 20)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>buffer := make(chan []byte, 5)
 
var m runtime.MemStats
makes := 0
for {
    var b []byte
    select {
    case b = &lt;-buffer:
    default:
        makes += 1
        b = makeBuffer()
    }
 
    i := rand.Intn(len(pool))
    if pool[i] != nil {
        select {
        case buffer &lt;- pool[i]:
            pool[i] = nil
        default:
        }
    }
 
    pool[i] = b
 
    time.Sleep(time.Second)
 
    bytes := 0
    for i := 0; i &lt; len(pool); i++ {
        if pool[i] != nil {
            bytes += len(pool[i])
        }
    }
 
    runtime.ReadMemStats(&amp;m)
    fmt.Printf("%d,%d,%d,%d,%d,%d\n", m.HeapSys, bytes, m.HeapAlloc,
        m.HeapIdle, m.HeapReleased, makes)
} } ä¸‹é¢è¿™å¼ å›¾æ˜¯ä¸Šé¢çš„ç¨‹åºè¿è¡Œäº†10åˆ†é’Ÿä»¥åçš„æƒ…å†µï¼š
</code></pre></div></div>

<p>è¿™å¼ å›¾å±•ç¤ºäº†å®Œå…¨ä¸åŒçš„æƒ…å†µã€‚å®é™…ä½¿ç”¨çš„bufferå‡ ä¹ç­‰äºä»æ“ä½œç³»ç»Ÿä¸­ç”³è¯·çš„å†…å­˜ã€‚åŒæ—¶GCå‡ ä¹æ²¡æœ‰å·¥ä½œå¯åšã€‚å †ä¸Šåªæœ‰å¾ˆå°‘çš„HeapIdleæœ€ç»ˆéœ€è¦å½’è¿˜åˆ°æ“ä½œç³»ç»Ÿã€‚</p>

<p>è¿™æ®µç¨‹åºä¸­å†…å­˜å›æ”¶æœºåˆ¶çš„å…³é”®æ“ä½œå°±æ˜¯ä¸€ä¸ªç¼“å†²çš„channel â€”â€”bufferï¼Œåœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œbufferæ˜¯ä¸€ä¸ªå¯ä»¥å­˜å‚¨5ä¸ª[]byte sliceçš„å®¹å™¨ã€‚å½“ç¨‹åºéœ€è¦ç©ºé—´æ—¶ï¼Œé¦–å…ˆä¼šä½¿ç”¨selectä»bufferä¸­è¯»å–ï¼š</p>

<p>select {</p>

<p>case b = &lt;- buffer:</p>

<p>default :</p>

<p>makes += 1</p>

<p>b = makeBuffer()</p>

<p>}</p>

<p>è¿™æ°¸è¿œä¸ä¼šé˜»å¡å› ä¸ºå¦‚æœchannelä¸­æœ‰æ•°æ®ï¼Œå°±ä¼šè¢«è¯»å‡ºï¼Œå¦‚æœchannelæ˜¯ç©ºçš„ï¼ˆæ„å‘³ç€æ¥æ”¶ä¼šé˜»å¡ï¼‰ï¼Œåˆ™ä¼šåˆ›å»ºä¸€ä¸ªã€‚</p>

<p>ä½¿ç”¨ç±»ä¼¼çš„éé˜»å¡æœºåˆ¶å°†sliceå›æ”¶åˆ°bufferï¼š</p>

<p>select {</p>

<p>case buffer &lt;- pool[i]:</p>

<p>pool[i] = nil</p>

<p>default:</p>

<p>}</p>

<p>å¦‚æœbuffer è¿™ä¸ªchannelæ»¡äº†ï¼Œåˆ™ä»¥ä¸Šçš„å†™å…¥è¿‡ç¨‹ä¼šé˜»å¡ï¼Œè¿™ç§æƒ…å†µä¸‹defaultè§¦å‘ã€‚è¿™ç§ç®€å•çš„æœºåˆ¶å¯ä»¥ç”¨äºå®‰å…¨çš„åˆ›å»ºä¸€ä¸ªå…±äº«æ± ï¼Œç”šè‡³å¯é€šè¿‡channelä¼ é€’å®ç°å¤šä¸ªgoroutinesä¹‹é—´çš„å®Œç¾ã€å®‰å…¨å…±äº«ã€‚</p>

<p>åœ¨æˆ‘ä»¬çš„å®é™…é¡¹ç›®ä¸­è¿ç”¨äº†ç›¸ä¼¼çš„æŠ€æœ¯ï¼Œå®é™…ä½¿ç”¨ä¸­ï¼ˆç®€å•ç‰ˆæœ¬ï¼‰çš„å›æ”¶å™¨ï¼ˆrecycler ï¼‰å±•ç¤ºåœ¨ä¸‹é¢ï¼Œæœ‰ä¸€ä¸ªgoroutine å¤„ç†buffersçš„æ„é€ å¹¶åœ¨å¤šä¸ªgoroutineä¹‹é—´å…±äº«ã€‚get(è·å–ä¸€ä¸ªæ–°buffer)å’Œgive(å›æ”¶ä¸€ä¸ªbufferåˆ°pool)è¿™ä¸¤ä¸ªchannelè¢«æ‰€æœ‰goroutinesä½¿ç”¨ã€‚</p>

<p>å›æ”¶å™¨å¯¹æ”¶å›çš„bufferä¿æŒè¿æ¥ï¼Œå¹¶å®šæœŸçš„ä¸¢å¼ƒé‚£äº›è¿‡äºé™ˆæ—§å¯èƒ½ä¸ä¼šå†ä½¿ç”¨çš„bufferï¼ˆåœ¨ç¤ºä¾‹ä»£ç ä¸­è¿™ä¸ªå‘¨æœŸæ˜¯ä¸€åˆ†é’Ÿï¼‰ã€‚è¿™è®©ç¨‹åºå¯ä»¥è‡ªåŠ¨åº”å¯¹çˆ†å‘æ€§çš„bufferséœ€æ±‚ã€‚</p>

<p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
package main</p>

<p>import (
    â€œcontainer/listâ€
    â€œfmtâ€
    â€œmath/randâ€
    â€œruntimeâ€
    â€œtimeâ€
)</p>

<p>var makes int
var frees int</p>

<p>func makeBuffer() []byte {
    makes += 1
    return make([]byte, rand.Intn(5000000)+5000000)
}</p>

<p>type queued struct {
    when time.Time
    slice []byte
}</p>

<p>func makeRecycler() (get, give chan []byte) {
    get = make(chan []byte)
    give = make(chan []byte)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go func() {
    q := new(list.List)
    for {
        if q.Len() == 0 {
            q.PushFront(queued{when: time.Now(), slice: makeBuffer()})
        }
 
        e := q.Front()
 
        timeout := time.NewTimer(time.Minute)
        select {
        case b := &lt;-give:
            timeout.Stop()
            q.PushFront(queued{when: time.Now(), slice: b})
 
       case get &lt;- e.Value.(queued).slice:
           timeout.Stop()
           q.Remove(e)
 
       case &lt;-timeout.C:
           e := q.Front()
           for e != nil {
               n := e.Next()
               if time.Since(e.Value.(queued).when) &gt; time.Minute {
                   q.Remove(e)
                   e.Value = nil
               }
               e = n
           }
       }
   }
 
}()
 
return }
</code></pre></div></div>

<p>func main() {
    pool := make([][]byte, 20)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>get, give := makeRecycler()
 
var m runtime.MemStats
for {
    b := &lt;-get
    i := rand.Intn(len(pool))
    if pool[i] != nil {
        give &lt;- pool[i]
    }
 
    pool[i] = b
 
    time.Sleep(time.Second)
 
    bytes := 0
    for i := 0; i &lt; len(pool); i++ {
        if pool[i] != nil {
            bytes += len(pool[i])
        }
    }
 
    runtime.ReadMemStats(&amp;m)
    fmt.Printf("%d,%d,%d,%d,%d,%d,%d\n", m.HeapSys, bytes, m.HeapAlloc
         m.HeapIdle, m.HeapReleased, makes, frees)
} } æ‰§è¡Œç¨‹åº10åˆ†é’Ÿï¼Œå›¾åƒä¼šç±»ä¼¼äºç¬¬äºŒå¹…ï¼š
</code></pre></div></div>

<p>è¿™äº›æŠ€æœ¯å¯ä»¥ç”¨äºç¨‹åºå‘˜çŸ¥é“æŸäº›å†…å­˜å¯ä»¥è¢«é‡ç”¨ï¼Œè€Œä¸ç”¨å€ŸåŠ©äºGCï¼Œå¯ä»¥æ˜¾è‘—çš„å‡å°‘ç¨‹åºçš„å†…å­˜ä½¿ç”¨ï¼ŒåŒæ—¶å¯ä»¥ä½¿ç”¨åœ¨å…¶ä»–æ•°æ®ç±»å‹è€Œä¸ä»…æ˜¯[]byte sliceï¼Œä»»æ„ç±»å‹çš„Go typeï¼ˆç”¨æˆ·å®šä¹‰çš„æˆ–è®¸ä¸è¡Œï¼ˆuser-defined or notï¼‰ï¼‰éƒ½å¯ä»¥ç”¨ç±»ä¼¼çš„æ‰‹æ®µå›æ”¶ã€‚</p>

<p>ä»¥linuxæœåŠ¡ä¸ºä¾‹å­ï¼Œæ­£å¸¸æƒ…å†µä¸‹ï¼Œè¦è·å–æœåŠ¡å†…å­˜ä¿¡æ¯å¯ä»¥é€šè¿‡ç›¸å…³çš„å‘½ä»¤ï¼Œä¾‹å¦‚topã€psç­‰å‘½ä»¤ã€‚è¿™äº›ç›‘æ§å†…å­˜ä½¿ç”¨æƒ…å†µçš„æ–¹æ³•ï¼Œä¸€èˆ¬éœ€è¦ç¼–å†™è„šæœ¬ï¼Œæ‰§è¡Œè„šæœ¬åå°†æ‰§è¡Œç»“æœå‘é€ç»™å¯¹åº”çš„ç›‘æ§æœåŠ¡ï¼Œä»è€Œè¾¾åˆ°ç›‘æ§çš„æ•ˆæœã€‚ä½†æ˜¯golangè‡ªå¸¦çš„åŒ…å´æœ‰ä¸€ä¸ªruntimeåŒ…ï¼Œå¯ä»¥è½»æ¾è·å–æœåŠ¡è¿è¡Œæ—¶å€™çš„å„ç§åŒ…æ‹¬å†…å­˜ä½¿ç”¨æƒ…å†µçš„ä¿¡æ¯ã€‚
ä½¿ç”¨linuxå‘½ä»¤ï¼Œä¸€èˆ¬æƒ…å†µä¸‹åªèƒ½çœ‹æœåŠ¡ä½¿ç”¨äº†å¤šå°‘å†…å­˜ã€‚ä½†æ˜¯æœåŠ¡å†…å­˜å…·ä½“çš„ä½¿ç”¨æƒ…å†µç¼ºæ— æ³•è·å–ã€‚golangçš„runtimeåŒ…å¯ä»¥åšåˆ°è·å–æœåŠ¡æ€»å…±ä½¿ç”¨ä¸»æœºå¤šå°‘å†…å­˜ï¼Œä¹Ÿå¯ä»¥è·å–æœåŠ¡å·²ç»ç”³è¯·äº†å¤šå°‘å†…å­˜ï¼Œä»¥åŠå†…å­˜çš„åˆ†å¸ƒã€‚ä¸ªäººè§‰å¾—golangçš„runtimeåŒ…åŠŸèƒ½å¾ˆå¼ºå¤§ï¼Œå¯ä»¥è·å–å¾ˆå¤šæœåŠ¡è¿è¡Œä¿¡æ¯ï¼Œåç»­è¦ä»”ç»†å­¦ä¹ ã€‚è¿™é‡Œå…ˆé‡ç‚¹æ¥çœ‹ä¸‹è·Ÿå†…å­˜ç›¸å…³çš„æ¥å£ï¼Œæœ¬åšå®¢æ˜¯åŸºäºGO1.9 windows64ç‰ˆæœ¬çš„ä»£ç å’Œè¿è¡Œç¯å¢ƒè¿›è¡Œåˆ†æã€‚
runtimeä¸­å’Œå†…å­˜ä½¿ç”¨æƒ…å†µç›¸å…³çš„ç»“æ„ä½“ä¸ºruntime.MemStatsï¼Œè¿™ä¸ªç»“æ„å®šä¹‰äº†golangè¿è¡Œè¿‡ç¨‹ä¸­æ‰€æœ‰å†…å­˜ç›¸å…³çš„ä¿¡æ¯ï¼Œåœ¨æºä»£ç ä¸­å®šä¹‰å¦‚ä¸‹ï¼š</p>

<p>// A MemStats records statistics about the memory allocator. è®°å½•å†…å­˜åˆ†é…å™¨çš„ä¿¡æ¯
type MemStats struct {
    // General statistics.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Alloc is bytes of allocated heap objects.
// å †ç©ºé—´åˆ†é…çš„å­—èŠ‚æ•°
// This is the same as HeapAlloc (see below).
Alloc uint64

// TotalAlloc is cumulative bytes allocated for heap objects.
//
// TotalAlloc increases as heap objects are allocated, but
// unlike Alloc and HeapAlloc, it does not decrease when
// objects are freed. ä»æœåŠ¡å¼€å§‹è¿è¡Œè‡³ä»Šåˆ†é…å™¨ä¸ºåˆ†é…çš„å †ç©ºé—´æ€»å’Œ
TotalAlloc uint64

// Sys is the total bytes of memory obtained from the OS.
//
// Sys is the sum of the XSys fields below. Sys measures the
// virtual address space reserved by the Go runtime for the
// heap, stacks, and other internal data structures. It's
// likely that not all of the virtual address space is backed
// by physical memory at any given moment, though in general
// it all was at some point. æœåŠ¡ç°åœ¨ä½¿ç”¨çš„å†…å­˜
Sys uint64

// Lookups is the number of pointer lookups performed by the
// runtime.
//
// This is primarily useful for debugging runtime internals. è¢«runtimeç›‘è§†çš„æŒ‡é’ˆæ•°
Lookups uint64

// Mallocs is the cumulative count of heap objects allocated. æœåŠ¡mallocçš„æ¬¡æ•°
// The number of live objects is Mallocs - Frees.
Mallocs uint64

// Frees is the cumulative count of heap objects freed. æœåŠ¡å›æ”¶çš„heap objects
Frees uint64

// Heap memory statistics.
//
// Interpreting the heap statistics requires some knowledge of
// how Go organizes memory. Go divides the virtual address
// space of the heap into "spans", which are contiguous
// regions of memory 8K or larger. A span may be in one of
// three states:
//
// An "idle" span contains no objects or other data. The
// physical memory backing an idle span can be released back
// to the OS (but the virtual address space never is), or it
// can be converted into an "in use" or "stack" span.
//
// An "in use" span contains at least one heap object and may
// have free space available to allocate more heap objects.
//
// A "stack" span is used for goroutine stacks. Stack spans
// are not considered part of the heap. A span can change
// between heap and stack memory; it is never used for both
// simultaneously.

// HeapAlloc is bytes of allocated heap objects.
//
// "Allocated" heap objects include all reachable objects, as
// well as unreachable objects that the garbage collector has
// not yet freed. Specifically, HeapAlloc increases as heap
// objects are allocated and decreases as the heap is swept
// and unreachable objects are freed. Sweeping occurs
// incrementally between GC cycles, so these two processes
// occur simultaneously, and as a result HeapAlloc tends to
// change smoothly (in contrast with the sawtooth that is
// typical of stop-the-world garbage collectors).
//æœåŠ¡åˆ†é…çš„å †å†…å­˜
HeapAlloc uint64

// HeapSys is bytes of heap memory obtained from the OS.
//
// HeapSys measures the amount of virtual address space
// reserved for the heap. This includes virtual address space
// that has been reserved but not yet used, which consumes no
// physical memory, but tends to be small, as well as virtual
// address space for which the physical memory has been
// returned to the OS after it became unused (see HeapReleased
// for a measure of the latter).
//
// HeapSys estimates the largest size the heap has had.
//ç³»ç»Ÿåˆ†é…çš„å †å†…å­˜
HeapSys uint64

// HeapIdle is bytes in idle (unused) spans.
//
// Idle spans have no objects in them. These spans could be
// (and may already have been) returned to the OS, or they can
// be reused for heap allocations, or they can be reused as
// stack memory.
//
// HeapIdle minus HeapReleased estimates the amount of memory
// that could be returned to the OS, but is being retained by
// the runtime so it can grow the heap without requesting more
// memory from the OS. If this difference is significantly
// larger than the heap size, it indicates there was a recent
// transient spike in live heap size.
//ç”³è¯·ä½†æ˜¯ä¸ºåˆ†é…çš„å †å†…å­˜ï¼Œï¼ˆæˆ–è€…å›æ”¶äº†çš„å †å†…å­˜ï¼‰
HeapIdle uint64

// HeapInuse is bytes in in-use spans.
//
// In-use spans have at least one object in them. These spans
// can only be used for other objects of roughly the same
// size.
//
// HeapInuse minus HeapAlloc esimates the amount of memory
// that has been dedicated to particular size classes, but is
// not currently being used. This is an upper bound on
// fragmentation, but in general this memory can be reused
// efficiently.
//æ­£åœ¨ä½¿ç”¨çš„å †å†…å­˜
HeapInuse uint64

// HeapReleased is bytes of physical memory returned to the OS.
//
// This counts heap memory from idle spans that was returned
// to the OS and has not yet been reacquired for the heap.
//è¿”å›ç»™OSçš„å †å†…å­˜ï¼Œç±»ä¼¼C/C++ä¸­çš„freeã€‚
HeapReleased uint64

// HeapObjects is the number of allocated heap objects.
//
// Like HeapAlloc, this increases as objects are allocated and
// decreases as the heap is swept and unreachable objects are
// freed.
//å †å†…å­˜å—ç”³è¯·çš„é‡
HeapObjects uint64

// Stack memory statistics.
//
// Stacks are not considered part of the heap, but the runtime
// can reuse a span of heap memory for stack memory, and
// vice-versa.

// StackInuse is bytes in stack spans.
//
// In-use stack spans have at least one stack in them. These
// spans can only be used for other stacks of the same size.
//
// There is no StackIdle because unused stack spans are
// returned to the heap (and hence counted toward HeapIdle).
//æ­£åœ¨ä½¿ç”¨çš„æ ˆ
StackInuse uint64

// StackSys is bytes of stack memory obtained from the OS.
//
// StackSys is StackInuse, plus any memory obtained directly
// from the OS for OS thread stacks (which should be minimal).
//ç³»ç»Ÿåˆ†é…çš„ä½œä¸ºè¿è¡Œæ ˆçš„å†…å­˜
StackSys uint64

// Off-heap memory statistics.
//
// The following statistics measure runtime-internal
// structures that are not allocated from heap memory (usually
// because they are part of implementing the heap). Unlike
// heap or stack memory, any memory allocated to these
// structures is dedicated to these structures.
//
// These are primarily useful for debugging runtime memory
// overheads.

// MSpanInuse is bytes of allocated mspan structures. ç”¨äºæµ‹è¯•ç”¨çš„ç»“æ„ä½“ä½¿ç”¨çš„å­—èŠ‚æ•°
MSpanInuse uint64

// MSpanSys is bytes of memory obtained from the OS for mspan
// structures. ç³»ç»Ÿä¸ºæµ‹è¯•ç”¨çš„ç»“æ„ä½“åˆ†é…çš„å­—èŠ‚æ•°
MSpanSys uint64

// MCacheInuse is bytes of allocated mcache structures. mcacheç»“æ„ä½“ç”³è¯·çš„å­—èŠ‚æ•°
MCacheInuse uint64

// MCacheSys is bytes of memory obtained from the OS for
// mcache structures. æ“ä½œç³»ç»Ÿç”³è¯·çš„å †ç©ºé—´ç”¨äºmcacheçš„é‡
MCacheSys uint64

// BuckHashSys is bytes of memory in profiling bucket hash tables.ç”¨äºå‰–ææ¡¶æ•£åˆ—è¡¨çš„å †ç©ºé—´
BuckHashSys uint64

// GCSys is bytes of memory in garbage collection metadata. åƒåœ¾å›æ”¶æ ‡è®°å…ƒä¿¡æ¯ä½¿ç”¨çš„å†…å­˜
GCSys uint64

// OtherSys is bytes of memory in miscellaneous off-heap
// runtime allocations.  golangç³»ç»Ÿæ¶æ„å ç”¨çš„é¢å¤–ç©ºé—´
OtherSys uint64

// Garbage collector statistics.

// NextGC is the target heap size of the next GC cycle.
//
// The garbage collector's goal is to keep HeapAlloc â‰¤ NextGC.
// At the end of each GC cycle, the target for the next cycle
// is computed based on the amount of reachable data and the
// value of GOGC. åƒåœ¾å›æ”¶å™¨æ£€è§†çš„å†…å­˜å¤§å°
NextGC uint64

// LastGC is the time the last garbage collection finished, as
// nanoseconds since 1970 (the UNIX epoch).
// åƒåœ¾å›æ”¶å™¨æœ€åä¸€æ¬¡æ‰§è¡Œæ—¶é—´ã€‚
LastGC uint64

// PauseTotalNs is the cumulative nanoseconds in GC
// stop-the-world pauses since the program started.
//
// During a stop-the-world pause, all goroutines are paused
// and only the garbage collector can run. 
// åƒåœ¾å›æ”¶æˆ–è€…å…¶ä»–ä¿¡æ¯æ”¶é›†å¯¼è‡´æœåŠ¡æš‚åœçš„æ¬¡æ•°ã€‚
PauseTotalNs uint64

// PauseNs is a circular buffer of recent GC stop-the-world
// pause times in nanoseconds.
//
// The most recent pause is at PauseNs[(NumGC+255)%256]. In
// general, PauseNs[N%256] records the time paused in the most
// recent N%256th GC cycle. There may be multiple pauses per
// GC cycle; this is the sum of all pauses during a cycle. ä¸€ä¸ªå¾ªç¯é˜Ÿåˆ—ï¼Œè®°å½•æœ€è¿‘åƒåœ¾å›æ”¶ç³»ç»Ÿä¸­æ–­çš„æ—¶é—´
PauseNs [256]uint64

// PauseEnd is a circular buffer of recent GC pause end times,
// as nanoseconds since 1970 (the UNIX epoch).
//
// This buffer is filled the same way as PauseNs. There may be
// multiple pauses per GC cycle; this records the end of the
// last pause in a cycle. ä¸€ä¸ªå¾ªç¯é˜Ÿåˆ—ï¼Œè®°å½•æœ€è¿‘åƒåœ¾å›æ”¶ç³»ç»Ÿä¸­æ–­çš„æ—¶é—´å¼€å§‹ç‚¹ã€‚
PauseEnd [256]uint64

// NumGC is the number of completed GC cycles.
//åƒåœ¾å›æ”¶çš„å†…å­˜å¤§å°
NumGC uint32

// NumForcedGC is the number of GC cycles that were forced by
// the application calling the GC function.
//æœåŠ¡è°ƒç”¨runtime.GC()å¼ºåˆ¶ä½¿ç”¨åƒåœ¾å›æ”¶çš„æ¬¡æ•°ã€‚
NumForcedGC uint32

// GCCPUFraction is the fraction of this program's available
// CPU time used by the GC since the program started.
//
// GCCPUFraction is expressed as a number between 0 and 1,
// where 0 means GC has consumed none of this program's CPU. A
// program's available CPU time is defined as the integral of
// GOMAXPROCS since the program started. That is, if
// GOMAXPROCS is 2 and a program has been running for 10
// seconds, its "available CPU" is 20 seconds. GCCPUFraction
// does not include CPU time used for write barrier activity.
//
// This is the same as the fraction of CPU reported by
// GODEBUG=gctrace=1.
//åƒåœ¾å›æ”¶å ç”¨æœåŠ¡CPUå·¥ä½œçš„æ—¶é—´æ€»å’Œã€‚å¦‚æœæœ‰100ä¸ªgoroutineï¼Œåƒåœ¾å›æ”¶çš„æ—¶é—´ä¸º1S,é‚£ä¹ˆä¹…å ç”¨äº†100S
GCCPUFraction float64

// EnableGC indicates that GC is enabled. It is always true,
// even if GOGC=off.
//æ˜¯å¦å¯ç”¨GC
EnableGC bool

// DebugGC is currently unused.
DebugGC bool

// BySize reports per-size class allocation statistics.
//
// BySize[N] gives statistics for allocations of size S where
// BySize[N-1].Size &lt; S â‰¤ BySize[N].Size.
//
// This does not report allocations larger than BySize[60].Size.
//å†…å­˜åˆ†é…å™¨ä½¿ç”¨æƒ…å†µ
BySize [61]struct {
    // Size is the maximum byte size of an object in this
    // size class.
    Size uint32

    // Mallocs is the cumulative count of heap objects
    // allocated in this size class. The cumulative bytes
    // of allocation is Size*Mallocs. The number of live
    // objects in this size class is Mallocs - Frees.
    Mallocs uint64

    // Frees is the cumulative count of heap objects freed
    // in this size class.
    Frees uint64
} } runtime.MemStatsè¿™ä¸ªç»“æ„ä½“åŒ…å«çš„å­—æ®µæ¯”è¾ƒå¤šï¼Œä½†æ˜¯å¤§å¤šéƒ½å¾ˆæœ‰ç”¨ï¼Œå»æ‰é‚£äº›æ³¨é‡Šæ¥çœ‹å„ä¸ªå±æ€§ï¼Œä¼šå‘ç°å„ä¸ªå±æ€§éƒ½æ˜¯å¾ˆæœ‰ä»·å€¼çš„ï¼š 1ã€Alloc uint64 //golangè¯­è¨€æ¡†æ¶å †ç©ºé—´åˆ†é…çš„å­—èŠ‚æ•° 2ã€TotalAlloc uint64 //ä»æœåŠ¡å¼€å§‹è¿è¡Œè‡³ä»Šåˆ†é…å™¨ä¸ºåˆ†é…çš„å †ç©ºé—´æ€» å’Œï¼Œåªæœ‰å¢åŠ ï¼Œé‡Šæ”¾çš„æ—¶å€™ä¸å‡å°‘ 3ã€Sys uint64 //æœåŠ¡ç°åœ¨ç³»ç»Ÿä½¿ç”¨çš„å†…å­˜ 4ã€Lookups uint64 //è¢«runtimeç›‘è§†çš„æŒ‡é’ˆæ•° 5ã€Mallocs uint64 //æœåŠ¡mallocçš„æ¬¡æ•° 6ã€Frees uint64 //æœåŠ¡å›æ”¶çš„heap objectsçš„å­—èŠ‚æ•° 7ã€HeapAlloc uint64 //æœåŠ¡åˆ†é…çš„å †å†…å­˜å­—èŠ‚æ•° 8ã€HeapSys uint64 //ç³»ç»Ÿåˆ†é…çš„ä½œä¸ºè¿è¡Œæ ˆçš„å†…å­˜ 9ã€HeapIdle uint64 //ç”³è¯·ä½†æ˜¯æœªåˆ†é…çš„å †å†…å­˜æˆ–è€…å›æ”¶äº†çš„å †å†…å­˜ï¼ˆç©ºé—²ï¼‰å­—èŠ‚æ•° 10ã€HeapInuse uint64 //æ­£åœ¨ä½¿ç”¨çš„å †å†…å­˜å­—èŠ‚æ•° 10ã€HeapReleased uint64 //è¿”å›ç»™OSçš„å †å†…å­˜ï¼Œç±»ä¼¼C/C++ä¸­çš„freeã€‚ 11ã€HeapObjects uint64 //å †å†…å­˜å—ç”³è¯·çš„é‡ 12ã€StackInuse uint64 //æ­£åœ¨ä½¿ç”¨çš„æ ˆå­—èŠ‚æ•° 13ã€StackSys uint64 //ç³»ç»Ÿåˆ†é…çš„ä½œä¸ºè¿è¡Œæ ˆçš„å†…å­˜ 14ã€MSpanInuse uint64 //ç”¨äºæµ‹è¯•ç”¨çš„ç»“æ„ä½“ä½¿ç”¨çš„å­—èŠ‚æ•° 15ã€MSpanSys uint64 //ç³»ç»Ÿä¸ºæµ‹è¯•ç”¨çš„ç»“æ„ä½“åˆ†é…çš„å­—èŠ‚æ•° 16ã€MCacheInuse uint64 //mcacheç»“æ„ä½“ç”³è¯·çš„å­—èŠ‚æ•°(ä¸ä¼šè¢«è§†ä¸ºåƒåœ¾å›æ”¶) 17ã€MCacheSys uint64 //æ“ä½œç³»ç»Ÿç”³è¯·çš„å †ç©ºé—´ç”¨äºmcacheçš„å­—èŠ‚æ•° 18ã€BuckHashSys uint64 //ç”¨äºå‰–ææ¡¶æ•£åˆ—è¡¨çš„å †ç©ºé—´ 19ã€GCSys uint64 //åƒåœ¾å›æ”¶æ ‡è®°å…ƒä¿¡æ¯ä½¿ç”¨çš„å†…å­˜ 20ã€OtherSys uint64 //golangç³»ç»Ÿæ¶æ„å ç”¨çš„é¢å¤–ç©ºé—´ 21ã€NextGC uint64 //åƒåœ¾å›æ”¶å™¨æ£€è§†çš„å†…å­˜å¤§å° 22ã€LastGC uint64 // åƒåœ¾å›æ”¶å™¨æœ€åä¸€æ¬¡æ‰§è¡Œæ—¶é—´ã€‚ 23ã€PauseTotalNs uint64 // åƒåœ¾å›æ”¶æˆ–è€…å…¶ä»–ä¿¡æ¯æ”¶é›†å¯¼è‡´æœåŠ¡æš‚åœçš„æ¬¡æ•°ã€‚ 24ã€PauseNs [256]uint64 //ä¸€ä¸ªå¾ªç¯é˜Ÿåˆ—ï¼Œè®°å½•æœ€è¿‘åƒåœ¾å›æ”¶ç³»ç»Ÿä¸­æ–­çš„æ—¶é—´ 25ã€PauseEnd [256]uint64 //ä¸€ä¸ªå¾ªç¯é˜Ÿåˆ—ï¼Œè®°å½•æœ€è¿‘åƒåœ¾å›æ”¶ç³»ç»Ÿä¸­æ–­çš„æ—¶é—´å¼€å§‹ç‚¹ã€‚ 26ã€NumForcedGC uint32 //æœåŠ¡è°ƒç”¨runtime.GC()å¼ºåˆ¶ä½¿ç”¨åƒåœ¾å›æ”¶çš„æ¬¡æ•°ã€‚ 27ã€GCCPUFraction float64 //åƒåœ¾å›æ”¶å ç”¨æœåŠ¡CPUå·¥ä½œçš„æ—¶é—´æ€»å’Œã€‚å¦‚æœæœ‰100ä¸ªgoroutineï¼Œåƒåœ¾å›æ”¶çš„æ—¶é—´ä¸º1S,é‚£ä¹ˆä¹…å ç”¨äº†100Sã€‚ 28ã€BySize //å†…å­˜åˆ†é…å™¨ä½¿ç”¨æƒ…å†µ ä»¥ä¸Šæ˜¯æˆ‘ä¸ªäººå¯¹runtime.MemStatså„ä¸ªå±æ€§çš„ç†è§£ï¼Œæœ‰ç†è§£é”™çš„åœ°æ–¹è¿˜è¯·å‘è¡¨è¯„è®ºæˆ–è€…è”ç³»ä¸‹æˆ‘å…±åŒæ¢è®¨ä¸€ä¸‹ã€‚
</code></pre></div></div>

<p>ä»runtime.MemStatsçš„å±æ€§å¯ä»¥çœ‹åˆ°ï¼Œgolangä¸­çš„runtimeåŒ…å…¶å®æ˜¯ä¸€ä¸ªå¸¦æœ‰ä¸€ç‚¹ç»´æŠ¤æ€§è´¨çš„åŠŸèƒ½åŒ…ã€‚å¼€å‘è€…å¯ä»¥è·å–å¤§é‡golangæœåŠ¡è¿è¡Œæ—¶çš„ä¿¡æ¯ï¼ŒæŸ¥çœ‹runtime.MenStatsçš„æ–¹æ³•ä¹Ÿå¾ˆç®€å•ã€‚ç›´æ¥è°ƒç”¨runtime.ReadMemStatsæ–¹æ³•å³å¯è·å–è°ƒç”¨ç‚¹æœåŠ¡è¿è¡Œä¿¡æ¯ã€‚ä¸€ä¸‹æ˜¯æˆ‘æµ‹è¯•è¿‡ç¨‹ä¸­è·å–åˆ°çš„runtime.MenStatsï¼Œå†…å®¹å¦‚ä¸‹ï¼š</p>

<p>memstat: {
Alloc:69257680 //golangè¯­è¨€æ¡†æ¶å †ç©ºé—´åˆ†é…çš„å­—èŠ‚æ•° å¤§æ¦‚68M
TotalAlloc:79489528 //ä»æœåŠ¡å¼€å§‹è¿è¡Œè‡³ä»Šåˆ†é…å™¨ä¸ºåˆ†é…çš„å †ç©ºé—´æ€» å’Œï¼Œåªæœ‰å¢åŠ ï¼Œé‡Šæ”¾çš„æ—¶å€™ä¸å‡å°‘ã€‚å¤§çº¦79M
Sys:1345724664 //æœåŠ¡ç°åœ¨ç³»ç»Ÿä½¿ç”¨çš„å†…å­˜, å¤§çº¦1345M
Lookups:3 //è¢«runtimeç›‘è§†çš„æŒ‡é’ˆæ•°
Mallocs:307494 //æœåŠ¡mallocçš„æ¬¡æ•°
Frees:9105  //æœåŠ¡å›æ”¶çš„heap objectsçš„å­—èŠ‚æ•° freeæ¬¡æ•°
HeapAlloc:69257680 //golangè¯­è¨€æ¡†æ¶å †ç©ºé—´åˆ†é…çš„å­—èŠ‚æ•° å¤§æ¦‚68M
HeapSys:71434240  //ç³»ç»Ÿåˆ†é…çš„å †å†…å­˜ å¤§æ¦‚71M
HeapIdle:974848 //ç”³è¯·ä½†æ˜¯æœªåˆ†é…çš„å †å†…å­˜æˆ–è€…å›æ”¶äº†çš„å †å†…å­˜ï¼ˆç©ºé—²ï¼‰å­—èŠ‚æ•° å¤§æ¦‚1M
HeapInuse:70459392 //æ­£åœ¨ä½¿ç”¨çš„å †å†…å­˜å­—èŠ‚æ•° å¤§æ¦‚70M
HeapReleased:0 //è¿”å›ç»™OSçš„å †å†…å­˜ï¼Œ
HeapObjects:298389  //å †å†…å­˜å—ç”³è¯·çš„é‡
StackInuse:1220804608 //æ­£åœ¨ä½¿ç”¨çš„æ ˆå­—èŠ‚æ•° çº¦1220M
StackSys:1220804608 //ç³»ç»Ÿåˆ†é…çš„ä½œä¸ºè¿è¡Œæ ˆçš„å†…å­˜ çº¦1220M
MSpanInuse:6924360  //ç”¨äºæµ‹è¯•ç”¨çš„ç»“æ„ä½“ä½¿ç”¨çš„å­—èŠ‚æ•° ä¸å—GCæ§åˆ¶ï¼Œ çº¦7M
MSpanSys:6979584 //ç³»ç»Ÿä¸ºæµ‹è¯•ç”¨çš„ç»“æ„ä½“åˆ†é…çš„å­—èŠ‚æ•° çº¦7M
MCacheInuse:6816 //mcacheç»“æ„ä½“ç”³è¯·çš„å­—èŠ‚æ•°(ä¸ä¼šè¢«è§†ä¸ºåƒåœ¾å›æ”¶) çº¦6K
MCacheSys:16384 //æ“ä½œç³»ç»Ÿç”³è¯·çš„å †ç©ºé—´ç”¨äºmcacheçš„å­—èŠ‚æ•°,çº¦16K
BuckHashSys:1468496 //ç”¨äºå‰–ææ¡¶æ•£åˆ—è¡¨çš„å †ç©ºé—´ çº¦14K
GCSys:40984576 //åƒåœ¾å›æ”¶æ ‡è®°å…ƒä¿¡æ¯ä½¿ç”¨çš„å†…å­˜ çº¦40M
OtherSys:4036776 //golangç³»ç»Ÿæ¶æ„å ç”¨çš„é¢å¤–ç©ºé—´ çº¦4M
NextGC:135394784  //åƒåœ¾å›æ”¶å™¨æ£€è§†çš„å†…å­˜å¤§å° çº¦135M
LastGC:1506577064496115700 //æœ€åä¸€æ¬¡GCçš„æ—¶é—´æˆ³
PauseTotalNs:1834800 //ç³»ç»Ÿæš‚åœçš„æ—¶é—´ï¼Œå¤§çº¦1.8æ¯«ç§’
PauseNs:[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 833700 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 131600 0 69500 299900 500100 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] //æœ€è¿‘åƒåœ¾å›æ”¶æ¶ˆè€—æƒ…å†µ
PauseEnd:[1506576868237062600 1506576873250702600 1506576878266318900 1506576883290562700 1506576888313706000 1506576893339216000 1506576898380539200 1506576903430807600 1506576908483751100 1506576913540053700 1506576918589605600 1506576923651466900 1506576928716329900 1506576933785270400 1506576938872682700 1506576943987556700 1506576949080171300 1506576954205844600 1506576959319027700 1506576964454667000 1506576969604832300 1506576974795338100 1506576979945880300 1506576985117374500 1506576990330379400 1506576995548568900 1506577000766977100 1506577005980367800 1506577011190038400 1506577016427160200 1506577021671897800 1506577026958806600 1506577032285905300 1506577037561334600 1506577042926588300 1506577048190473200 1506577053579177600 1506577059147393600 1506577064496115700 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0] //åƒåœ¾å›æ”¶è°ƒç”¨çš„æ—¶é—´ç‚¹
NumGC:39 //åƒåœ¾å›æ”¶è°ƒç”¨æ¬¡æ•°
NumForcedGC:39 
GCCPUFraction:-1.325626798158314e-06 //è°ƒç”¨GCæ¶ˆè€—çš„æ€§èƒ½
EnableGC:true 
DebugGC:false 
BySize:[
{Size:0 Mallocs:0 Frees:0} 
{Size:8 Mallocs:45 Frees:41} 
{Size:16 Mallocs:4316 Frees:4273} 
{Size:32 Mallocs:118 Frees:58} 
{Size:48 Mallocs:192 Frees:1} 
{Size:64 Mallocs:149078 Frees:52} 
{Size:80 Mallocs:6 Frees:1} 
{Size:96 Mallocs:4 Frees:0} 
{Size:112 Mallocs:1 Frees:1} 
{Size:128 Mallocs:41 Frees:41} 
{Size:144 Mallocs:0 Frees:0} 
{Size:160 Mallocs:1 Frees:1} 
{Size:176 Mallocs:0 Frees:0} 
{Size:192 Mallocs:50 Frees:50} 
{Size:208 Mallocs:2 Frees:0} 
{Size:224 Mallocs:0 Frees:0} 
{Size:240 Mallocs:0 Frees:0} 
{Size:256 Mallocs:48 Frees:41} 
{Size:288 Mallocs:0 Frees:0} 
{Size:320 Mallocs:1 Frees:0} 
{Size:352 Mallocs:0 Frees:0} 
{Size:384 Mallocs:149024 Frees:0} 
{Size:416 Mallocs:1 Frees:0} 
{Size:448 Mallocs:0 Frees:0} 
{Size:480 Mallocs:3 Frees:0} 
{Size:512 Mallocs:80 Frees:80} 
{Size:576 Mallocs:0 Frees:0} 
{Size:640 Mallocs:0 Frees:0} 
{Size:704 Mallocs:0 Frees:0} 
{Size:768 Mallocs:0 Frees:0} 
{Size:896 Mallocs:7 Frees:0} 
{Size:1024 Mallocs:41 Frees:41} 
{Size:1152 Mallocs:1 Frees:0} 
{Size:1280 Mallocs:8 Frees:8} 
{Size:1408 Mallocs:0 Frees:0} 
{Size:1536 Mallocs:0 Frees:0} 
{Size:1792 Mallocs:10 Frees:8} 
{Size:2048 Mallocs:33 Frees:33} 
{Size:2304 Mallocs:8 Frees:8} 
{Size:2688 Mallocs:31 Frees:31} 
{Size:3072 Mallocs:8 Frees:8} 
{Size:3200 Mallocs:0 Frees:0} 
{Size:3456 Mallocs:31 Frees:31} 
{Size:4096 Mallocs:10 Frees:10} 
{Size:4864 Mallocs:35 Frees:31} 
{Size:5376 Mallocs:0 Frees:0} 
{Size:6144 Mallocs:39 Frees:39} 
{Size:6528 Mallocs:0 Frees:0} 
{Size:6784 Mallocs:0 Frees:0} 
{Size:6912 Mallocs:0 Frees:0} 
{Size:8192 Mallocs:3 Frees:2} 
{Size:9472 Mallocs:0 Frees:0} 
{Size:9728 Mallocs:0 Frees:0} 
{Size:10240 Mallocs:2 Frees:2} 
{Size:10880 Mallocs:0 Frees:0} 
{Size:12288 Mallocs:0 Frees:0} 
{Size:13568 Mallocs:2 Frees:2} 
{Size:14336 Mallocs:1 Frees:0} 
{Size:16384 Mallocs:0 Frees:0} 
{Size:18432 Mallocs:2 Frees:2} 
{Size:19072 Mallocs:0 Frees:0}
] //å…·ä½“å†…å­˜åˆ†é…æƒ…å†µ 
}
åœ¨windowsä¸‹æˆ‘ä»¬èƒ½çœ‹åˆ°çš„åªæœ‰cpuå ç”¨ç‡å’Œå†…å­˜ä½¿ç”¨çš„å¤§å°ï¼Œå…¶æˆªå›¾å¦‚ä¸‹ï¼š</p>

<p>ä»ä¸Šé¢ä¸€ä¸ªå®é™…çš„ä¾‹å­å¯ä»¥çœ‹å‡ºä½¿ç”¨golangçš„runtime.MemStatsç¡®å®æ˜¯å¯ä»¥è·å–å¤§é‡golangæœåŠ¡çš„è¿è¡Œä¿¡æ¯ã€‚ä½†æ˜¯æˆ‘è¿™è¾¹æ²¡æœ‰æµ‹è¯•è°ƒç”¨CGOçš„æƒ…å†µï¼Œåç»­æµ‹è¯•ä¸€ä¸‹ç„¶åè¡¥å……ä¸€ä¸‹ã€‚æµ‹è¯•ç»“æœå‘ç°runtime.MemStats.Sysæ˜¯å‡†ç¡®çš„ï¼Œè€Œä¸”è¿˜èƒ½è·å–å…¶ä»–å…·ä½“çš„å†…å­˜åˆ†é…åŠåƒåœ¾å›æ”¶ç›¸å…³ç­‰ä¿¡æ¯ã€‚ä»è·å–çš„ä¿¡æ¯æ¥çœ‹ï¼ŒæœåŠ¡ä½¿ç”¨çš„å †ç©ºé—´å¾ˆå°‘ï¼Œä½†æ˜¯ä½¿ç”¨åˆ°çš„æ ˆç¡®é«˜è¾¾1220Mã€‚è¯¥æœåŠ¡æ˜¯è¿™æ ·çš„ï¼Œä¸€ç›´åˆ›å»ºgoroutineï¼Œç„¶åè®©goroutineæ— é™å¾ªç¯ç¡çœ 1ç§’é’Ÿã€‚å†è·å–åˆ°runtime.MemStatsä¿¡æ¯é™„è¿‘å‘ç°æœ‰è·å–å½“å‰goroutineæ•°é‡çš„ä¿¡æ¯ã€‚æ—¥å¿—æ‰“å°å†…å®¹å¦‚ä¸‹ï¼š</p>

<p>goroutine number is:  150001
1
è®¡ç®—ä¸€ä¸‹ï¼š150000 * 8K = 1200Mã€‚è¿™ä¸ªå’Œruntime.MemStatsè·å–åˆ°çš„æ ˆå¤§å°éå¸¸æ¥è¿‘ã€‚
ä»ä¸Šé¢ä»‹ç»å¯ä»¥çœ‹åˆ°ï¼ŒgolangæœåŠ¡å¯ä»¥é€šè¿‡runtime.ReadMemStatsæ–¹æ³•è·å–æœåŠ¡è¿è¡ŒæœŸé—´å†…å­˜ä½¿ç”¨æƒ…å†µå’Œåƒåœ¾å›æ”¶ç­‰ç›¸å…³ä¿¡æ¯ï¼Œæ¯”èµ·å„ç§å†…å­˜ç›‘æ§å·¥å…·è¦è¯¦ç»†å¾ˆå¤šï¼Œè€Œä¸”æ˜¯ä»¥golangçš„æ–¹å¼è·å–å†…å­˜æ•°æ®ã€‚å› ä¸ºåœ¨golangä¸­ï¼Œæˆ‘ä»¬åªè·å–å†…å­˜ä½¿ç”¨æ€»é‡å’Œå¢é•¿è¶‹åŠ¿å¾€å¾€å¯ä»¥ç¡®å®šçš„äº‹æƒ…å¾ˆå°‘ï¼Œä½†æ˜¯ç”±runtime.MemStatsè·å–åˆ°çš„ä¿¡æ¯ç¡®æ˜¯éå¸¸æœ‰ä»·å€¼çš„ã€‚åœ¨æœåŠ¡åå°å¼€å‘è¿‡ç¨‹ä¸­ï¼Œæœ‰ä¸€ä¸ªéå¸¸é‡è¦çš„è¯å°±æ˜¯â€œæ— ç›‘æ§ï¼Œä¸æœåŠ¡â€ï¼Œè¿™æ˜¯æœåŠ¡åå°å¼€å‘çš„åŸºæœ¬ã€‚æ— è®ºæ˜¯æ¶æ„çš„æ¼”è¿›æ–¹å‘å’ŒæœåŠ¡å¯é æ€§æ§åˆ¶ï¼Œä»¥åŠéƒ¨åˆ†æ€§èƒ½ä¼˜åŒ–çš„æ•°æ®æ¥æºéƒ½éœ€è¦ä»¥ç›‘æ§æ•°æ®ä½œä¸ºå‚è€ƒã€‚è€Œgolangå†…å­˜ä¿¡æ¯çš„ç›‘æ§ä¸ªäººè§‰å¾—å¿…é¡»é€šè¿‡å¯¹åº”æ—¶åˆ»runtime.MemStatsçš„ä¸ºæ ‡å‡†ã€‚å½“ç„¶ä½¿ç”¨runtime.ReadMemStatsä¼šçŸ­æš‚çš„æš‚åœæœåŠ¡ä¸­çš„æ‰€æœ‰goroutineï¼Œç„¶åæ”¶é›†è°ƒç”¨æ—¶åˆ»çš„MemStatsã€‚ä»æºä»£ç æ¥çœ‹ï¼Œæš‚åœæ‰€æœ‰goroutineçš„æ—¶é—´ä»…ä»…æ˜¯ä½¿ç”¨memcopyæ‹·è´ä¸€ä¸ªMemStatsçš„æ—¶é—´ã€‚ä»£ç å¦‚ä¸‹ï¼š</p>

<p>func ReadMemStats(m *MemStats) {
    stopTheWorld(â€œread mem statsâ€)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>systemstack(func() {
    readmemstats_m(m)
})

startTheWorld() }
</code></pre></div></div>

<p>func readmemstats_m(stats *MemStats) {
    updatememstats()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// The size of the trailing by_size array differs between
// mstats and MemStats. NumSizeClasses was changed, but we
// cannot change MemStats because of backward compatibility.
memmove(unsafe.Pointer(stats), unsafe.Pointer(&amp;memstats), sizeof_C_MStats)

// memstats.stacks_sys is only memory mapped directly for OS stacks.
// Add in heap-allocated stack memory for user consumption.
stats.StackSys += stats.StackInuse } ä»GO1.9æºä»£ç å’Œå®é™…ç”Ÿäº§ç¯å¢ƒæµ‹è¯•æƒ…å†µçœ‹ï¼Œä¸ªäººçš„è§‚ç‚¹æ˜¯ï¼Œå³ä½¿åœ¨ä¸šåŠ¡é«˜å³°æ—¶æœŸï¼Œä¸åº”è¯¥å°†runtime.ReadMemStatsä½œä¸ºæ€§èƒ½ä¼˜åŒ–çš„ä¼˜åŒ–ç‚¹ã€‚å› ä¸ºåœ¨åœ¨ä¸šåŠ¡é«˜å³°æ—¶æ®µè·å–åˆ°çš„æœåŠ¡çŠ¶æ€ä¿¡æ¯å¾€å¾€æ˜¯æœ€æœ‰ç”¨çš„
</code></pre></div></div>

<p>https://prometheus.io/</p>

<p>å¦‚ä½•åˆ©ç”¨golangè‡ªå¸¦çš„profileå·¥å…·è¿›è¡Œåº”ç”¨ç¨‹åºçš„æ€§èƒ½è°ƒä¼˜ï¼Œå‰ä¸€æ®µæ—¶é—´æˆ‘åšçš„æ—¥å¿—åˆ†æç³»ç»Ÿåœ¨çº¿ä¸Šé‡åˆ°äº†ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯åˆ†ä»»åŠ¡çš„ç³»ç»Ÿdownæœºäº†ï¼Œæ—¥å¿—å¤„ç†å»¶è¿Ÿäº†10å‡ ä¸ªå°æ—¶ï¼Œè¿™ä¸ªæ—¶å€™ä»»åŠ¡åˆ†å‘ç³»ç»Ÿé‡å¯ä¹‹åå¼€å§‹åˆ†å‘ä»»åŠ¡ï¼Œä½†æ˜¯ä¸€ä¸‹å­å°±æ‰¿å—äº†åå‡ ä¸ªå¹¶å‘ä»»åŠ¡ï¼Œå¯¼è‡´å†…å­˜æ¶ˆè€—è¿‡å¿«ï¼Œç›´æ¥åƒæ‰äº†16Gçš„å†…å­˜ï¼Œè¿™å¯æ€¥åäº†æˆ‘å•Šã€‚æ‰€ä»¥èµ¶ç´§å¼€å§‹åšæ€§èƒ½ä¼˜åŒ–ã€‚</p>

<p>æ€§èƒ½ä¼˜åŒ–æˆ‘ä¸»è¦ä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢è¿›è¡Œäº†æµ‹è¯•å’Œè°ƒä¼˜ï¼š</p>

<p>CPU Profiling
Mem Profiling
GC &amp; HEAP
æˆ‘é‡‡ç”¨äº†å¦‚ä¸‹çš„profileå·¥å…·ä»£ç ï¼š</p>

<p>package main</p>

<p>import (</p>

<p>â€œfmtâ€</p>

<p>â€œlogâ€</p>

<p>â€œosâ€</p>

<p>â€œruntimeâ€</p>

<p>â€œruntime/debugâ€</p>

<p>â€œruntime/pprofâ€</p>

<p>â€œstrconvâ€</p>

<p>â€œsync/atomicâ€</p>

<p>â€œsyscallâ€</p>

<p>â€œtimeâ€</p>

<p>)</p>

<p>var heapProfileCounter int32</p>

<p>var startTime = time.Now()</p>

<p>var pid int</p>

<p>func init() {</p>

<p>pid = os.Getpid()</p>

<p>}</p>

<p>func StartCPUProfile() {</p>

<p>f, err := os.Create(â€œcpu-â€œ + strconv.Itoa(pid) + â€œ.pprofâ€)</p>

<p>if err != nil {</p>

<p>log.Fatal(err)</p>

<p>}</p>

<p>pprof.StartCPUProfile(f)</p>

<p>}</p>

<p>func StopCPUProfile() {</p>

<p>pprof.StopCPUProfile()</p>

<p>}</p>

<p>func StartBlockProfile(rate int) {</p>

<p>runtime.SetBlockProfileRate(rate)</p>

<p>}</p>

<p>func StopBlockProfile() {</p>

<p>filename := â€œblock-â€œ + strconv.Itoa(pid) + â€œ.pprofâ€</p>

<p>f, err := os.Create(filename)</p>

<p>if err != nil {</p>

<p>log.Fatal(err)</p>

<p>}</p>

<p>if err = pprof.Lookup(â€œblockâ€).WriteTo(f, 0); err != nil {</p>

<p>log.Fatalf(â€œ canâ€™t write %s: %sâ€, filename, err)</p>

<p>}</p>

<p>f.Close()</p>

<p>}</p>

<p>func SetMemProfileRate(rate int) {</p>

<p>runtime.MemProfileRate = rate</p>

<p>}</p>

<p>func GC() {</p>

<p>runtime.GC()</p>

<p>}</p>

<p>func DumpHeap() {</p>

<p>filename := â€œheap-â€œ + strconv.Itoa(pid) + â€œ-â€œ + strconv.Itoa(int(atomic.AddInt32(&amp;heapProfileCounter, 1))) + â€œ.pprofâ€</p>

<p>f, err := os.Create(filename)</p>

<p>if err != nil {</p>

<p>fmt.Fprintf(os.Stderr, â€œtesting: %sâ€, err)</p>

<p>return</p>

<p>}</p>

<p>if err = pprof.WriteHeapProfile(f); err != nil {</p>

<p>fmt.Fprintf(os.Stderr, â€œtesting: canâ€™t write %s: %sâ€, filename, err)</p>

<p>}</p>

<p>f.Close()</p>

<p>}</p>

<p>func showSystemStat(interval time.Duration, count int) {</p>

<p>usage1 := &amp;syscall.Rusage{}</p>

<p>var lastUtime int64</p>

<p>var lastStime int64</p>

<p>counter := 0</p>

<p>for {</p>

<p>//http://man7.org/linux/man-pages/man3/vtimes.3.html</p>

<p>syscall.Getrusage(syscall.RUSAGE_SELF, usage1)</p>

<p>utime := usage1.Utime.Sec*1000000000 + usage1.Utime.Usec</p>

<p>stime := usage1.Stime.Sec*1000000000 + usage1.Stime.Usec</p>

<p>userCPUUtil := float64(utime-lastUtime) * 100 / float64(interval)</p>

<p>sysCPUUtil := float64(stime-lastStime) * 100 / float64(interval)</p>

<p>memUtil := usage1.Maxrss * 1024</p>

<p>lastUtime = utime</p>

<p>lastStime = stime</p>

<p>if counter &gt; 0 {</p>

<p>fmt.Printf(â€œcpu: %3.2f%% us  %3.2f%% sy, mem:%s \nâ€, userCPUUtil, sysCPUUtil, toH(uint64(memUtil)))</p>

<p>}</p>

<p>counter += 1</p>

<p>if count &gt;= 1 &amp;&amp; count &lt; counter {</p>

<p>return</p>

<p>}</p>

<p>time.Sleep(interval)</p>

<p>}</p>

<p>}</p>

<p>func ShowSystemStat(seconds int) {</p>

<p>go func() {</p>

<p>interval := time.Duration(seconds) * time.Second</p>

<p>showSystemStat(interval, 0)</p>

<p>}()</p>

<p>}</p>

<p>func PrintSystemStats() {</p>

<p>interval := time.Duration(1) * time.Second</p>

<p>showSystemStat(interval, 1)</p>

<p>}</p>

<p>func ShowGCStat() {</p>

<p>go func() {</p>

<p>var numGC int64</p>

<p>interval := time.Duration(100) * time.Millisecond</p>

<p>gcstats := &amp;debug.GCStats{PauseQuantiles: make([]time.Duration, 100)}</p>

<p>memStats := &amp;runtime.MemStats{}</p>

<p>for {</p>

<p>debug.ReadGCStats(gcstats)</p>

<p>if gcstats.NumGC &gt; numGC {</p>

<p>runtime.ReadMemStats(memStats)</p>

<p>printGC(memStats, gcstats)</p>

<p>numGC = gcstats.NumGC</p>

<p>}</p>

<p>time.Sleep(interval)</p>

<p>}</p>

<p>}()</p>

<p>}</p>

<p>func PrintGCSummary() {</p>

<p>memStats := &amp;runtime.MemStats{}</p>

<p>runtime.ReadMemStats(memStats)</p>

<p>gcstats := &amp;debug.GCStats{PauseQuantiles: make([]time.Duration, 100)}</p>

<p>debug.ReadGCStats(gcstats)</p>

<p>printGC(memStats, gcstats)</p>

<p>}</p>

<p>func printGC(memStats *runtime.MemStats, gcstats *debug.GCStats) {</p>

<p>if gcstats.NumGC &gt; 0 {</p>

<p>lastPause := gcstats.Pause[0]</p>

<p>elapsed := time.Now().Sub(startTime)</p>

<p>overhead := float64(gcstats.PauseTotal) / float64(elapsed) * 100</p>

<p>allocatedRate := float64(memStats.TotalAlloc) / elapsed.Seconds()</p>

<p>fmt.Printf(â€œNumGC:%d Pause:%s Pause(Avg):%s Overhead:%3.2f%% Alloc:%s Sys:%s Alloc(Rate):%s/s Histogram:%s %s %s \nâ€,</p>

<p>gcstats.NumGC,</p>

<p>toS(lastPause),</p>

<p>toS(avg(gcstats.Pause)),</p>

<p>overhead,</p>

<p>toH(memStats.Alloc),</p>

<p>toH(memStats.Sys),</p>

<p>toH(uint64(allocatedRate)),</p>

<p>toS(gcstats.PauseQuantiles[94]),</p>

<p>toS(gcstats.PauseQuantiles[98]),</p>

<p>toS(gcstats.PauseQuantiles[99]))</p>

<p>} else {</p>

<p>// while GC has disabled</p>

<p>elapsed := time.Now().Sub(startTime)</p>

<p>allocatedRate := float64(memStats.TotalAlloc) / elapsed.Seconds()</p>

<p>fmt.Printf(â€œAlloc:%s Sys:%s Alloc(Rate):%s/s\nâ€,</p>

<p>toH(memStats.Alloc),</p>

<p>toH(memStats.Sys),</p>

<p>toH(uint64(allocatedRate)))</p>

<p>}</p>

<p>}</p>

<p>func avg(items []time.Duration) time.Duration {</p>

<p>var sum time.Duration</p>

<p>for _, item := range items {</p>

<p>sum += item</p>

<p>}</p>

<p>return time.Duration(int64(sum) / int64(len(items)))</p>

<p>}</p>

<p>// human readable format</p>

<p>func toH(bytes uint64) string {</p>

<p>switch {</p>

<p>case bytes &lt; 1024:</p>

<p>return fmt.Sprintf(â€œï¿½â€, bytes)</p>

<p>case bytes &lt; 1024*1024:</p>

<p>return fmt.Sprintf(â€œ%.2fKâ€, float64(bytes)/1024)</p>

<p>case bytes &lt; 1024<em>1024</em>1024:</p>

<p>return fmt.Sprintf(â€œ%.2fMâ€, float64(bytes)/1024/1024)</p>

<p>default:</p>

<p>return fmt.Sprintf(â€œ%.2fGâ€, float64(bytes)/1024/1024/1024)</p>

<p>}</p>

<p>}</p>

<p>// short string format</p>

<p>func toS(d time.Duration) string {</p>

<p>u := uint64(d)</p>

<p>if u &lt; uint64(time.Second) {</p>

<p>switch {</p>

<p>case u == 0:</p>

<p>return â€œ0â€</p>

<p>case u &lt; uint64(time.Microsecond):</p>

<p>return fmt.Sprintf(â€œ%.2fnsâ€, float64(u))</p>

<p>case u &lt; uint64(time.Millisecond):</p>

<p>return fmt.Sprintf(â€œ%.2fusâ€, float64(u)/1000)</p>

<p>default:</p>

<p>return fmt.Sprintf(â€œ%.2fmsâ€, float64(u)/1000/1000)</p>

<p>}</p>

<p>} else {</p>

<p>switch {</p>

<p>case u &lt; uint64(time.Minute):</p>

<p>return fmt.Sprintf(â€œ%.2fsâ€, float64(u)/1000/1000/1000)</p>

<p>case u &lt; uint64(time.Hour):</p>

<p>return fmt.Sprintf(â€œ%.2fmâ€, float64(u)/1000/1000/1000/60)</p>

<p>default:</p>

<p>return fmt.Sprintf(â€œ%.2fhâ€, float64(u)/1000/1000/1000/60/60)</p>

<p>}</p>

<p>}
}</p>

<p>runtime åŒ… æä¾›äº†è¿è¡Œæ—¶ä¸ç³»ç»Ÿçš„äº¤äº’,æ¯”å¦‚æ§åˆ¶åç¨‹å‡½æ•°ï¼Œè§¦å‘åƒåœ¾ç«‹å³å›æ”¶ç­‰ç­‰åº•å±‚æ“ä½œ,ä¸‹é¢æˆ‘ä»¬å°±è¿è¡Œæ—¶èƒ½åšçš„æ‰€æœ‰äº‹æƒ…é€ä¸ªè¿›è¡Œè¯´æ˜ä¸ä»£ç æ¼”ç¤º</p>

<p>1.è·å–GOROOTç¯å¢ƒå˜é‡
2.è·å–GOçš„ç‰ˆæœ¬å·
3.è·å–æœ¬æœºCPUä¸ªæ•°
4.è®¾ç½®æœ€å¤§å¯åŒæ—¶æ‰§è¡Œçš„æœ€å¤§CPUæ•°
5.è®¾ç½®cup profile è®°å½•çš„é€Ÿå½•
6.æŸ¥çœ‹cup profile ä¸‹ä¸€æ¬¡å †æ ˆè·Ÿè¸ªæ•°æ®
7.ç«‹å³æ‰§è¡Œä¸€æ¬¡åƒåœ¾å›æ”¶
8.ç»™å˜é‡ç»‘å®šæ–¹æ³•,å½“åƒåœ¾å›æ”¶çš„æ—¶å€™è¿›è¡Œç›‘å¬
9.æŸ¥çœ‹å†…å­˜ç”³è¯·å’Œåˆ†é…ç»Ÿè®¡ä¿¡æ¯
10.æŸ¥çœ‹ç¨‹åºæ­£åœ¨ä½¿ç”¨çš„å­—èŠ‚æ•°
11.æŸ¥çœ‹ç¨‹åºæ­£åœ¨ä½¿ç”¨çš„å¯¹è±¡æ•°
12.è·å–è°ƒç”¨å †æ ˆåˆ—è¡¨
13.è·å–å†…å­˜profileè®°å½•å†å²
14.æ‰§è¡Œä¸€ä¸ªæ–­ç‚¹
15.è·å–ç¨‹åºè°ƒç”¨goåç¨‹çš„æ ˆè¸ªè¿¹å†å²
16.è·å–å½“å‰å‡½æ•°æˆ–è€…ä¸Šå±‚å‡½æ•°çš„æ ‡è¯†å·ã€æ–‡ä»¶åã€è°ƒç”¨æ–¹æ³•åœ¨å½“å‰æ–‡ä»¶ä¸­çš„è¡Œå·
17.è·å–ä¸å½“å‰å †æ ˆè®°å½•ç›¸å…³é“¾çš„è°ƒç”¨æ ˆè¸ªè¿¹
18.è·å–ä¸€ä¸ªæ ‡è¯†è°ƒç”¨æ ˆæ ‡è¯†ç¬¦pcå¯¹åº”çš„è°ƒç”¨æ ˆ
19.è·å–è°ƒç”¨æ ˆæ‰€è°ƒç”¨çš„å‡½æ•°çš„åå­—
20.è·å–è°ƒç”¨æ ˆæ‰€è°ƒç”¨çš„å‡½æ•°çš„æ‰€åœ¨çš„æºæ–‡ä»¶åå’Œè¡Œå·
21.è·å–è¯¥è°ƒç”¨æ ˆçš„è°ƒç”¨æ ˆæ ‡è¯†ç¬¦
22.è·å–å½“å‰è¿›ç¨‹æ‰§è¡Œçš„cgoè°ƒç”¨æ¬¡æ•°
23.è·å–å½“å‰å­˜åœ¨çš„goåç¨‹æ•°
24.ç»ˆæ­¢æ‰å½“å‰çš„goåç¨‹
25.è®©å…¶ä»–goåç¨‹ä¼˜å…ˆæ‰§è¡Œ,ç­‰å…¶ä»–åç¨‹æ‰§è¡Œå®Œå,åœ¨æ‰§è¡Œå½“å‰çš„åç¨‹
26.è·å–æ´»è·ƒçš„goåç¨‹çš„å †æ ˆprofileä»¥åŠè®°å½•ä¸ªæ•°
27.å°†è°ƒç”¨çš„goåç¨‹ç»‘å®šåˆ°å½“å‰æ‰€åœ¨çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼Œå…¶å®ƒgoåç¨‹ä¸èƒ½è¿›å…¥è¯¥çº¿ç¨‹
28.è§£é™¤goåç¨‹ä¸æ“ä½œç³»ç»Ÿçº¿ç¨‹çš„ç»‘å®šå…³ç³»
29.è·å–çº¿ç¨‹åˆ›å»ºprofileä¸­çš„è®°å½•ä¸ªæ•°
30.æ§åˆ¶é˜»å¡profileè®°å½•goåç¨‹é˜»å¡äº‹ä»¶çš„é‡‡æ ·ç‡
31.è¿”å›å½“å‰é˜»å¡profileä¸­çš„è®°å½•ä¸ªæ•°
1.è·å–GOROOTç¯å¢ƒå˜é‡
func GOROOT() string
GOROOTè¿”å›Goçš„æ ¹ç›®å½•ã€‚å¦‚æœå­˜åœ¨GOROOTç¯å¢ƒå˜é‡ï¼Œè¿”å›è¯¥å˜é‡çš„å€¼ï¼›å¦åˆ™ï¼Œè¿”å›åˆ›å»ºGoæ—¶çš„æ ¹ç›®å½•</p>

<p>package main
import (
    â€œfmtâ€
  â€œruntimeâ€
)
func main() {
fmt.Println(runtime.GOROOT())
}
image.png
2.è·å–GOçš„ç‰ˆæœ¬å·
func Version() string
è¿”å›Goçš„ç‰ˆæœ¬å­—ç¬¦ä¸²ã€‚å®ƒè¦ä¹ˆæ˜¯é€’äº¤çš„hashå’Œåˆ›å»ºæ—¶çš„æ—¥æœŸï¼›è¦ä¹ˆæ˜¯å‘è¡Œæ ‡ç­¾å¦‚â€go1.3â€</p>

<p>package main</p>

<p>import (
    â€œfmtâ€
  â€œruntimeâ€
)</p>

<p>func main() {
fmt.Println(runtime.Version())
}
image.png
3.è·å–æœ¬æœºCPUä¸ªæ•°
func NumCPU() int
NumCPUè¿”å›æœ¬åœ°æœºå™¨çš„é€»è¾‘CPUä¸ªæ•°</p>

<p>package main</p>

<p>import (
  â€œfmtâ€
  â€œruntimeâ€
)</p>

<p>func main() {
fmt.Println(runtime.NumCPU())
}
image.png
4.è®¾ç½®æœ€å¤§å¯åŒæ—¶æ‰§è¡Œçš„æœ€å¤§CPUæ•°
func GOMAXPROCS(n int) int</p>

<p>GOMAXPROCSè®¾ç½®å¯åŒæ—¶æ‰§è¡Œçš„æœ€å¤§CPUæ•°ï¼Œå¹¶è¿”å›å…ˆå‰çš„è®¾ç½®ã€‚ è‹¥ n &lt; 1ï¼Œå®ƒå°±ä¸ä¼šæ›´æ”¹å½“å‰è®¾ç½®ã€‚æœ¬åœ°æœºå™¨çš„é€»è¾‘CPUæ•°å¯é€šè¿‡ NumCPU æŸ¥è¯¢ã€‚æœ¬å‡½æ•°åœ¨è°ƒåº¦ç¨‹åºä¼˜åŒ–åä¼šå»æ‰</p>

<p>ä½¿ç”¨é»˜è®¤çš„cupæ•°é‡ æˆ‘çš„ç”µè„‘æ˜¯4æ ¸çš„</p>

<p>package main</p>

<p>import (
  â€œfmtâ€
  â€œtimeâ€
  )
func main() {</p>

<p>//runtime.GOMAXPROCS(1)
    startTime := time.Now()
    var s1 chan  int64 = make(chan int64)
    var s2 chan  int64 = make(chan int64)
    var s3 chan  int64 = make(chan int64)
    var s4 chan  int64 = make(chan int64)
    go calc(s1)
    go calc(s2)
    go calc(s3)
    go calc(s4)
    &lt;-s1
    &lt;-s2
    &lt;-s3
    &lt;-s4
    endTime := time.Now()
    fmt.Println(endTime.Sub(startTime))</p>

<p>}
func calc(s  chan int64) {
   var count int64 = 0
  for i := 0 ;i &lt; 1000000000;i++ {
    count += int64(i)
  }
  s &lt;- count
}
image.png
ä¸‹é¢æˆ‘ä»¬å°†cupæ•°é‡è®¾ç½®æˆ1</p>

<p>package main
import (
  â€œfmtâ€
  â€œtimeâ€
  â€œruntimeâ€
)</p>

<p>func main() {
   runtime.GOMAXPROCS(1)
    startTime := time.Now()
    var s1 chan  int64 = make(chan int64)
    var s2 chan  int64 = make(chan int64)
    var s3 chan  int64 = make(chan int64)
    var s4 chan  int64 = make(chan int64)
    go calc(s1)
    go calc(s2)
    go calc(s3)
    go calc(s4)
    &lt;-s1
    &lt;-s2
    &lt;-s3
    &lt;-s4
    endTime := time.Now()
    fmt.Println(endTime.Sub(startTime))</p>

<p>}
func calc(s  chan int64) {
   var count int64 = 0
  for i := 0 ;i &lt; 1000000000;i++ {
    count += int64(i)
  }
  s &lt;- count
}
image.png</p>

<p>å¾ˆæ˜æ˜¾é€Ÿåº¦æ…¢äº†å¾ˆå¤š</p>

<p>5.è®¾ç½®cup profile è®°å½•çš„é€Ÿå½•
func SetCPUProfileRate(hz int)
SetCPUProfileRateè®¾ç½®CPU profileè®°å½•çš„é€Ÿç‡ä¸ºå¹³å‡æ¯ç§’hzæ¬¡ã€‚å¦‚æœhz&lt;=0ï¼ŒSetCPUProfileRateä¼šå…³é—­profileçš„è®°å½•ã€‚å¦‚æœè®°å½•å™¨åœ¨æ‰§è¡Œï¼Œè¯¥é€Ÿç‡å¿…é¡»åœ¨å…³é—­ä¹‹åæ‰èƒ½ä¿®æ”¹ã€‚</p>

<p>ç»å¤§å¤šæ•°ä½¿ç”¨è€…åº”ä½¿ç”¨runtime/pprofåŒ…æˆ–testingåŒ…çš„-test.cpuprofileé€‰é¡¹è€Œéç›´æ¥ä½¿ç”¨SetCPUProfileRate</p>

<p>6.æŸ¥çœ‹cup profile ä¸‹ä¸€æ¬¡å †æ ˆè·Ÿè¸ªæ•°æ®
func CPUProfile() []byte
ç›®å‰å·²åºŸå¼ƒ</p>

<p>7.ç«‹å³æ‰§è¡Œä¸€æ¬¡åƒåœ¾å›æ”¶
func GC()
GCæ‰§è¡Œä¸€æ¬¡åƒåœ¾å›æ”¶</p>

<p>çœ‹ä¸€ä¸‹ä»£ç </p>

<p>package main</p>

<p>import (
   â€œruntimeâ€
  â€œtimeâ€
)
type Student struct {
  name string</p>

<p>}
func main() {
  var i *Student = new(Student)
  runtime.SetFinalizer(i, func(i interface{}) {
   println(â€œåƒåœ¾å›æ”¶äº†â€)
  })
  runtime.GC()
  time.Sleep(time.Second)
}
image.png
æˆ‘ä»¬åˆ›å»ºäº†ä¸€ä¸ªæŒ‡é’ˆç±»å‹çš„å˜é‡Student å½“æˆ‘ä»¬è°ƒç”¨runtime.GCçš„æ—¶å€™,å†…å­˜ç«‹å³ä¼šå›æ”¶ï¼Œä½ å¯ä»¥æŠŠruntime.GC()å±è”½æ‰,ç¨‹åºå°±ä¸åœ¨æ‰§è¡Œäº†</p>

<p>8.ç»™å˜é‡ç»‘å®šæ–¹æ³•,å½“åƒåœ¾å›æ”¶çš„æ—¶å€™è¿›è¡Œç›‘å¬
func SetFinalizer(x, f interface{})</p>

<p>æ³¨æ„xå¿…é¡»æ˜¯æŒ‡é’ˆç±»å‹,f å‡½æ•°çš„å‚æ•°ä¸€å®šè¦å’Œxä¿æŒä¸€è‡´,æˆ–è€…å†™interface{},ä¸ç„¶ç¨‹åºä¼šæŠ¥é”™</p>

<p>ç¤ºä¾‹å¦‚ä¸‹</p>

<p>package main</p>

<p>import (
   â€œruntimeâ€
  â€œtimeâ€
)
type Student struct {
  name string</p>

<p>}
func main() {
  var i *Student = new(Student)
  runtime.SetFinalizer(i, func(i *Student) {
   println(â€œåƒåœ¾å›æ”¶äº†â€)
  })
  runtime.GC()
  time.Sleep(time.Second)
}
image.png
9.æŸ¥çœ‹å†…å­˜ç”³è¯·å’Œåˆ†é…ç»Ÿè®¡ä¿¡æ¯
func ReadMemStats(m *MemStats)
æˆ‘ä»¬å¯ä»¥è·å¾—ä¸‹é¢çš„ä¿¡æ¯</p>

<p>type MemStats struct {
    // ä¸€èˆ¬ç»Ÿè®¡
    Alloc      uint64 // å·²ç”³è¯·ä¸”ä»åœ¨ä½¿ç”¨çš„å­—èŠ‚æ•°
    TotalAlloc uint64 // å·²ç”³è¯·çš„æ€»å­—èŠ‚æ•°ï¼ˆå·²é‡Šæ”¾çš„éƒ¨åˆ†ä¹Ÿç®—åœ¨å†…ï¼‰
    Sys        uint64 // ä»ç³»ç»Ÿä¸­è·å–çš„å­—èŠ‚æ•°ï¼ˆä¸‹é¢XxxSysä¹‹å’Œï¼‰
    Lookups    uint64 // æŒ‡é’ˆæŸ¥æ‰¾çš„æ¬¡æ•°
    Mallocs    uint64 // ç”³è¯·å†…å­˜çš„æ¬¡æ•°
    Frees      uint64 // é‡Šæ”¾å†…å­˜çš„æ¬¡æ•°
    // ä¸»åˆ†é…å †ç»Ÿè®¡
    HeapAlloc    uint64 // å·²ç”³è¯·ä¸”ä»åœ¨ä½¿ç”¨çš„å­—èŠ‚æ•°
    HeapSys      uint64 // ä»ç³»ç»Ÿä¸­è·å–çš„å­—èŠ‚æ•°
    HeapIdle     uint64 // é—²ç½®spanä¸­çš„å­—èŠ‚æ•°
    HeapInuse    uint64 // éé—²ç½®spanä¸­çš„å­—èŠ‚æ•°
    HeapReleased uint64 // é‡Šæ”¾åˆ°ç³»ç»Ÿçš„å­—èŠ‚æ•°
    HeapObjects  uint64 // å·²åˆ†é…å¯¹è±¡çš„æ€»ä¸ªæ•°
    // Lä½å±‚æ¬¡ã€å¤§å°å›ºå®šçš„ç»“æ„ä½“åˆ†é…å™¨ç»Ÿè®¡ï¼ŒInuseä¸ºæ­£åœ¨ä½¿ç”¨çš„å­—èŠ‚æ•°ï¼ŒSysä¸ºä»ç³»ç»Ÿè·å–çš„å­—èŠ‚æ•°
    StackInuse  uint64 // å¼•å¯¼ç¨‹åºçš„å †æ ˆ
    StackSys    uint64
    MSpanInuse  uint64 // mspanç»“æ„ä½“
    MSpanSys    uint64
    MCacheInuse uint64 // mcacheç»“æ„ä½“
    MCacheSys   uint64
    BuckHashSys uint64 // profileæ¡¶æ•£åˆ—è¡¨
    GCSys       uint64 // GCå…ƒæ•°æ®
    OtherSys    uint64 // å…¶ä»–ç³»ç»Ÿç”³è¯·
    // åƒåœ¾æ”¶é›†å™¨ç»Ÿè®¡
    NextGC       uint64 // ä¼šåœ¨HeapAllocå­—æ®µåˆ°è¾¾è¯¥å€¼ï¼ˆå­—èŠ‚æ•°ï¼‰æ—¶è¿è¡Œä¸‹æ¬¡GC
    LastGC       uint64 // ä¸Šæ¬¡è¿è¡Œçš„ç»å¯¹æ—¶é—´ï¼ˆçº³ç§’ï¼‰
    PauseTotalNs uint64
    PauseNs      [256]uint64 // è¿‘æœŸGCæš‚åœæ—¶é—´çš„å¾ªç¯ç¼“å†²ï¼Œæœ€è¿‘ä¸€æ¬¡åœ¨[(NumGC+255)%256]
    NumGC        uint32
    EnableGC     bool
    DebugGC      bool
    // æ¯æ¬¡ç”³è¯·çš„å­—èŠ‚æ•°çš„ç»Ÿè®¡ï¼Œ61æ˜¯Cä»£ç ä¸­çš„å°ºå¯¸åˆ†çº§æ•°
    BySize [61]struct {
        Size    uint32
        Mallocs uint64
        Frees   uint64
    }
}
package main</p>

<p>import (
   â€œruntimeâ€
  â€œtimeâ€
  â€œfmtâ€
)
type Student struct {
  name string</p>

<p>}
func main() {
  var list = make([]*Student,0)
  for i:=0;i &lt;100000 ;i++ {
    var s *Student = new(Student)
    list = append(list, s)
  }
  memStatus := runtime.MemStats{}
  runtime.ReadMemStats(&amp;memStatus)
  fmt.Printf(â€œç”³è¯·çš„å†…å­˜:%d\nâ€,memStatus.Mallocs)
  fmt.Printf(â€œé‡Šæ”¾çš„å†…å­˜æ¬¡æ•°:%d\nâ€,memStatus.Frees)
  time.Sleep(time.Second)
}</p>

<p>image.png
10.æŸ¥çœ‹ç¨‹åºæ­£åœ¨ä½¿ç”¨çš„å­—èŠ‚æ•°
func (r *MemProfileRecord) InUseBytes() int64
InUseBytesè¿”å›æ­£åœ¨ä½¿ç”¨çš„å­—èŠ‚æ•°ï¼ˆAllocBytes â€“ FreeBytesï¼‰</p>

<p>11.æŸ¥çœ‹ç¨‹åºæ­£åœ¨ä½¿ç”¨çš„å¯¹è±¡æ•°
func (r *MemProfileRecord) InUseObjects() int64
InUseObjectsè¿”å›æ­£åœ¨ä½¿ç”¨çš„å¯¹è±¡æ•°ï¼ˆAllocObjects - FreeObjectsï¼‰</p>

<p>12.è·å–è°ƒç”¨å †æ ˆåˆ—è¡¨
func (r *MemProfileRecord) Stack() []uintptr
Stackè¿”å›å…³è”è‡³æ­¤è®°å½•çš„è°ƒç”¨æ ˆè¸ªè¿¹ï¼Œå³r.Stack0çš„å‰ç¼€ã€‚</p>

<p>13.è·å–å†…å­˜profileè®°å½•å†å²
func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)
MemProfileè¿”å›å½“å‰å†…å­˜profileä¸­çš„è®°å½•æ•°nã€‚è‹¥len(p)&gt;=nï¼ŒMemProfileä¼šå°†æ­¤åˆ†ææŠ¥å‘Šå¤åˆ¶åˆ°pä¸­å¹¶è¿”å›(n, true)ï¼›å¦‚æœlen(p)&lt;nï¼ŒMemProfileåˆ™ä¸ä¼šæ›´æ”¹pï¼Œè€Œåªè¿”å›(n, false)ã€‚</p>

<p>å¦‚æœinuseZeroä¸ºçœŸï¼Œè¯¥profileå°±ä¼šåŒ…å«æ— æ•ˆåˆ†é…è®°å½•ï¼ˆå…¶ä¸­r.AllocBytes&gt;0ï¼Œè€Œr.AllocBytes==r.FreeBytesã€‚è¿™äº›å†…å­˜éƒ½æ˜¯è¢«ç”³è¯·ååˆé‡Šæ”¾å›è¿è¡Œæ—¶ç¯å¢ƒçš„ï¼‰ã€‚</p>

<p>å¤§å¤šæ•°è°ƒç”¨è€…åº”å½“ä½¿ç”¨runtime/pprofåŒ…æˆ–testingåŒ…çš„-test.memprofileæ ‡è®°ï¼Œè€Œéç›´æ¥è°ƒç”¨MemProfile</p>

<p>14.æ‰§è¡Œä¸€ä¸ªæ–­ç‚¹
func Breakpoint()</p>

<p>runtime.Breakpoint()
image.png
15.è·å–ç¨‹åºè°ƒç”¨goåç¨‹çš„æ ˆè¸ªè¿¹å†å²
func Stack(buf []byte, all bool) int
Stackå°†è°ƒç”¨å…¶çš„goç¨‹çš„è°ƒç”¨æ ˆè¸ªè¿¹æ ¼å¼åŒ–åå†™å…¥åˆ°bufä¸­å¹¶è¿”å›å†™å…¥çš„å­—èŠ‚æ•°ã€‚è‹¥allä¸ºtrueï¼Œå‡½æ•°ä¼šåœ¨å†™å…¥å½“å‰goç¨‹çš„è¸ªè¿¹ä¿¡æ¯åï¼Œå°†å…¶å®ƒæ‰€æœ‰goç¨‹çš„è°ƒç”¨æ ˆè¸ªè¿¹éƒ½æ ¼å¼åŒ–å†™å…¥åˆ°bufä¸­ã€‚</p>

<p>package main</p>

<p>import (
     â€œtimeâ€
  â€œruntimeâ€
  â€œfmtâ€
)</p>

<p>func main() {
  go showRecord()
  time.Sleep(time.Second)
  buf := make([]byte,10000)
  runtime.Stack(buf,true)
  fmt.Println(string(buf))
}</p>

<p>func showRecord(){
 tiker := time.Tick(time.Second)
 for t := range  tiker {
   fmt.Println(t)
 }
}
image.png
æˆ‘ä»¬åœ¨è°ƒç”¨Stackæ–¹æ³•å,é¦–å…ˆæ ¼å¼åŒ–å½“å‰goåç¨‹çš„ä¿¡æ¯ï¼Œç„¶åæŠŠå…¶ä»–æ­£åœ¨è¿è¡Œçš„goåç¨‹ä¹Ÿæ ¼å¼åŒ–åå†™å…¥bufä¸­</p>

<p>16.è·å–å½“å‰å‡½æ•°æˆ–è€…ä¸Šå±‚å‡½æ•°çš„æ ‡è¯†å·ã€æ–‡ä»¶åã€è°ƒç”¨æ–¹æ³•åœ¨å½“å‰æ–‡ä»¶ä¸­çš„è¡Œå·
func Caller(skip int) (pc uintptr, file string, line int, ok bool)</p>

<p>package main
import (
  â€œruntimeâ€
  â€œfmtâ€
)</p>

<p>func main() {
  pc,file,line,ok := runtime.Caller(0)
  fmt.Println(pc)
  fmt.Println(file)
  fmt.Println(line)
  fmt.Println(ok)
}
image.png
pc = 17380971 ä¸æ˜¯mainå‡½æ•°è‡ªå·±çš„æ ‡è¯† runtime.Caller æ–¹æ³•çš„æ ‡è¯†,line = 13 æ ‡è¯†å®ƒåœ¨mainæ–¹æ³•ä¸­çš„ç¬¬13è¡Œè¢«è°ƒç”¨</p>

<p>package main</p>

<p>import (
  â€œruntimeâ€
  â€œfmtâ€
)</p>

<p>func main() {
  pc,<em>,line,</em> := runtime.Caller(1)
  fmt.Printf(â€œmainå‡½æ•°çš„pc:%d\nâ€,pc)
  fmt.Printf(â€œmainå‡½æ•°è¢«è°ƒç”¨çš„è¡Œæ•°:%d\nâ€,line)
  show()
}
func show(){
  pc,<em>,line,</em> := runtime.Caller(1)
  fmt.Printf(â€œshowå‡½æ•°çš„pc:%d\nâ€,pc)
  fmt.Printf(â€œshowå‡½æ•°è¢«è°ƒç”¨çš„è¡Œæ•°:%d\nâ€,line)
  // è¿™ä¸ªæ˜¯mainå‡½æ•°çš„æ ˆ
  pc,<em>,line,</em> = runtime.Caller(2)
  fmt.Printf(â€œshowçš„ä¸Šå±‚å‡½æ•°çš„pc:%d\nâ€,pc)
  fmt.Printf(â€œshowçš„ä¸Šå±‚å‡½æ•°è¢«è°ƒç”¨çš„è¡Œæ•°:%d\nâ€,line)
  pc,<em>,</em>,_ = runtime.Caller(3)
  fmt.Println(pc)
  pc,<em>,</em>,_ = runtime.Caller(4)
  fmt.Println(pc)
}
image.png</p>

<p>é€šè¿‡ä¸Šé¢çš„ä¾‹å­æˆ‘æ¼”ç¤ºäº†å¦‚ä½•è¿½è¸ªä¸€ä¸ªæ–¹æ³•è¢«è°ƒç”¨çš„é¡ºåº,ä»¥åŠæ‰€æœ‰ç›¸å…³å‡½æ•°çš„ä¿¡æ¯</p>

<p>17.è·å–ä¸å½“å‰å †æ ˆè®°å½•ç›¸å…³é“¾çš„è°ƒç”¨æ ˆè¸ªè¿¹
func Callers(skip int, pc []uintptr) int</p>

<p>å‡½æ•°æŠŠå½“å‰goç¨‹è°ƒç”¨æ ˆä¸Šçš„è°ƒç”¨æ ˆæ ‡è¯†ç¬¦å¡«å…¥åˆ‡ç‰‡pcä¸­ï¼Œè¿”å›å†™å…¥åˆ°pcä¸­çš„é¡¹æ•°ã€‚å®å‚skipä¸ºå¼€å§‹åœ¨pcä¸­è®°å½•ä¹‹å‰æ‰€è¦è·³è¿‡çš„æ ˆå¸§æ•°ï¼Œ0è¡¨ç¤ºCallersè‡ªèº«çš„è°ƒç”¨æ ˆï¼Œ1è¡¨ç¤ºCallersæ‰€åœ¨çš„è°ƒç”¨æ ˆã€‚è¿”å›å†™å…¥pçš„é¡¹æ•°</p>

<p>package main</p>

<p>import (
  â€œruntimeâ€
  â€œfmtâ€
)</p>

<p>func main() {
  pcs := make([]uintptr,10)
  i := runtime.Callers(1,pcs)
  fmt.Println(pcs[:i])
}
image.png</p>

<p>æˆ‘ä»¬è·å¾—äº†ä¸‰ä¸ªpc å…¶ä¸­æœ‰ä¸€ä¸ªæ˜¯mainæ–¹æ³•è‡ªèº«çš„</p>

<p>18.è·å–ä¸€ä¸ªæ ‡è¯†è°ƒç”¨æ ˆæ ‡è¯†ç¬¦pcå¯¹åº”çš„è°ƒç”¨æ ˆ
func FuncForPC(pc uintptr) *Func</p>

<p>package main</p>

<p>import (
  â€œruntimeâ€
  )</p>

<p>func main() {</p>

<p>pcs := make([]uintptr,10)
  i := runtime.Callers(1,pcs)
  for _,pc := range pcs[:i]{
    println(runtime.FuncForPC(pc))
  }
}
image.png
æˆ‘ä»¬çŸ¥é“è¿™ä¸ªè°ƒç”¨æ ˆæœ‰ä»€ä¹ˆç”¨å‘¢?è¯·ç»§ç»­ä¸‹æƒ³çœ‹</p>

<p>19.è·å–è°ƒç”¨æ ˆæ‰€è°ƒç”¨çš„å‡½æ•°çš„åå­—
func (f *Func) Name() string</p>

<p>package main</p>

<p>import (
  â€œruntimeâ€
  )</p>

<p>func main() {</p>

<p>pcs := make([]uintptr,10)
  i := runtime.Callers(1,pcs)
  for _,pc := range pcs[:i]{
    funcPC := runtime.FuncForPC(pc)
    println(funcPC.Name())
  }
}
image.png
20.è·å–è°ƒç”¨æ ˆæ‰€è°ƒç”¨çš„å‡½æ•°çš„æ‰€åœ¨çš„æºæ–‡ä»¶åå’Œè¡Œå·
func (f *Func) FileLine(pc uintptr) (file string, line int)</p>

<p>package main
import (
  â€œruntimeâ€
  )</p>

<p>func main() {
  pcs := make([]uintptr,10)
  i := runtime.Callers(1,pcs)
  for _,pc := range pcs[:i]{
    funcPC := runtime.FuncForPC(pc)
    file,line := funcPC.FileLine(pc)
    println(funcPC.Name(),file,line)
  }
}
image.png
21.è·å–è¯¥è°ƒç”¨æ ˆçš„è°ƒç”¨æ ˆæ ‡è¯†ç¬¦
func (f *Func) Entry() uintptr</p>

<p>package main</p>

<p>import (
  â€œruntimeâ€
  )</p>

<p>func main() {
  pcs := make([]uintptr,10)
  i := runtime.Callers(1,pcs)
  for _,pc := range pcs[:i]{
    funcPC := runtime.FuncForPC(pc)
    println(funcPC.Entry())
  }
}
image.png
22.è·å–å½“å‰è¿›ç¨‹æ‰§è¡Œçš„cgoè°ƒç”¨æ¬¡æ•°
func NumCgoCall() int64
è·å–å½“å‰è¿›ç¨‹è°ƒç”¨cæ–¹æ³•çš„æ¬¡æ•°
`</p>

<p>package main</p>

<p>import (
  â€œruntimeâ€
  )
/*
#include <stdio.h>
*/
import "C"</stdio.h></p>

<p>func main() {
 println(runtime.NumCgoCall())
}
image.png</p>

<p>æ³¨æ„æˆ‘ä»¬æ²¡æœ‰è°ƒç”¨cçš„æ–¹æ³•ä¸ºä»€ä¹ˆæ˜¯1å‘¢ï¼Ÿå› ä¸ºimport cæ˜¯,ä¼šè°ƒç”¨äº†cåŒ…ä¸­çš„initæ–¹æ³•
ä¸‹é¢æˆ‘ä»¬çœ‹ä¸€ä¸ªå®Œæ•´ä¾‹å­</p>

<p>import (
  â€œruntimeâ€
  )
/*
#include <stdio.h>
// è‡ªå®šä¹‰ä¸€ä¸ªcè¯­è¨€çš„æ–¹æ³•
static void myPrint(const char* msg) {
  printf("myPrint: %s", msg);
}
*/
import "C"</stdio.h></p>

<p>func main() {
  // è°ƒç”¨cæ–¹æ³•
  C.myPrint(C.CString(â€œHello,C\nâ€))
  println(runtime.NumCgoCall())
}
image.png
23.è·å–å½“å‰å­˜åœ¨çš„goåç¨‹æ•°
func NumGoroutine() int</p>

<p>package main</p>

<p>import â€œruntimeâ€</p>

<p>func main() {
 go print()
 print()
 println(runtime.NumGoroutine())
}
func print(){</p>

<p>}
image.png
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¾“å‡ºçš„æ˜¯2 è¡¨ç¤ºå­˜åœ¨2ä¸ªgoåç¨‹ ä¸€ä¸ªæ˜¯main.go å¦å¤–ä¸€ä¸ªæ˜¯go print()</p>

<p>24.ç»ˆæ­¢æ‰å½“å‰çš„goåç¨‹
func Goexit()</p>

<p>package main
import (
  â€œruntimeâ€
    â€œfmtâ€
)</p>

<p>func main() {
 print()  // 1
 fmt.Println(â€œç»§ç»­æ‰§è¡Œâ€)
}
func print(){
  fmt.Println(â€œå‡†å¤‡ç»“æŸgoåç¨‹â€)
  runtime.Goexit()
  defer fmt.Println(â€œç»“æŸäº†â€)
}
image.png
Goexitç»ˆæ­¢è°ƒç”¨å®ƒçš„goåç¨‹,å…¶ä»–åç¨‹ä¸å—å½±å“,Goexitä¼šåœ¨ç»ˆæ­¢è¯¥goåç¨‹å‰æ‰§è¡Œæ‰€æœ‰çš„deferå‡½æ•°ï¼Œå‰ææ˜¯deferå¿…é¡»åœ¨å®ƒå‰é¢å®šä¹‰,å¦‚æœåœ¨main goåç¨‹è°ƒç”¨æœ¬æ–¹æ³•,ä¼šç»ˆæ­¢è¯¥goåç¨‹,ä½†ä¸ä¼šè®©mainè¿”å›,å› ä¸ºmainå‡½æ•°æ²¡æœ‰è¿”å›,ç¨‹åºä¼šç»§ç»­æ‰§è¡Œå…¶ä»–goåç¨‹,å½“å…¶ä»–goåç¨‹æ‰§è¡Œå®Œæ¯•å,ç¨‹åºå°±ä¼šå´©æºƒ</p>

<p>25.è®©å…¶ä»–goåç¨‹ä¼˜å…ˆæ‰§è¡Œ,ç­‰å…¶ä»–åç¨‹æ‰§è¡Œå®Œå,åœ¨æ‰§è¡Œå½“å‰çš„åç¨‹
func Gosched()</p>

<p>æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸ªç¤ºä¾‹</p>

<p>package main
import (
  â€œfmtâ€
  )</p>

<p>func main() {
  go print()  // 1
  fmt.Println(â€œç»§ç»­æ‰§è¡Œâ€)
}
func print(){
  fmt.Println(â€œæ‰§è¡Œæ‰“å°æ–¹æ³•â€)
}
image.png
æˆ‘ä»¬åœ¨1å¤„è°ƒç”¨äº†go printæ–¹æ³•,ä½†æ˜¯è¿˜æœªæ‰§è¡Œ mainå‡½æ•°å°±æ‰§è¡Œå®Œæ¯•äº†,å› ä¸ºä¸¤ä¸ªåç¨‹æ˜¯å¹¶å‘çš„</p>

<p>é‚£ä¹ˆæˆ‘ä»¬åº”è¯¥æ€ä¹ˆæ‰èƒ½è®©æ¯ä¸ªåç¨‹éƒ½èƒ½å¤Ÿæ‰§è¡Œå®Œæ¯•å‘¢?æ–¹æ³•æœ‰å¾ˆå¤šç§,ä¸è¿‡å°±é’ˆå¯¹è¿™ä¸ªçŸ¥è¯†ç‚¹,æˆ‘ä»¬å°±ä½¿ç”¨ runtime.Gosched()æ¥è§£å†³</p>

<p>package main
import (
  â€œfmtâ€
  â€œruntimeâ€
)</p>

<p>func main() {
  go print()  // 1
  runtime.Gosched()
  fmt.Println(â€œç»§ç»­æ‰§è¡Œâ€)
}
func print(){
  fmt.Println(â€œæ‰§è¡Œæ‰“å°æ–¹æ³•â€)
}
image.png
26.è·å–æ´»è·ƒçš„goåç¨‹çš„å †æ ˆprofileä»¥åŠè®°å½•ä¸ªæ•°
func GoroutineProfile(p []StackRecord) (n int, ok bool)</p>

<p>27.å°†è°ƒç”¨çš„goåç¨‹ç»‘å®šåˆ°å½“å‰æ‰€åœ¨çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹ï¼Œå…¶å®ƒgoåç¨‹ä¸èƒ½è¿›å…¥è¯¥çº¿ç¨‹
func LockOSThread()
å°†è°ƒç”¨çš„goç¨‹ç»‘å®šåˆ°å®ƒå½“å‰æ‰€åœ¨çš„æ“ä½œç³»ç»Ÿçº¿ç¨‹ã€‚é™¤éè°ƒç”¨çš„goç¨‹é€€å‡ºæˆ–è°ƒç”¨UnlockOSThreadï¼Œå¦åˆ™å®ƒå°†æ€»æ˜¯åœ¨è¯¥çº¿ç¨‹ä¸­æ‰§è¡Œï¼Œè€Œå…¶å®ƒgoç¨‹åˆ™ä¸èƒ½è¿›å…¥è¯¥çº¿ç¨‹</p>

<p>æˆ‘ä»¬çœ‹ä¸‹é¢ä¸€ä¸ªä¾‹å­</p>

<p>package main
import (
  â€œfmtâ€
  â€œruntimeâ€
  â€œtimeâ€
)</p>

<p>func main() {
  go calcSum1()
  go calcSum2()
  time.Sleep(time.Second*100)
}</p>

<p>func calcSum1(){
  runtime.LockOSThread()
  start := time.Now()
  count := 0
  for i := 0; i &lt; 10000000000 ; i++  {
    count += i
  }
  end := time.Now()
  fmt.Println(â€œcalcSum1è€—æ—¶â€)
  fmt.Println(end.Sub(start))
  defer runtime.UnlockOSThread()
}</p>

<p>func calcSum2(){
  start := time.Now()
  count := 0
  for i := 0; i &lt; 10000000000 ; i++  {
    count += i
  }
  end := time.Now()
  fmt.Println(â€œcalcSum2è€—æ—¶â€)
  fmt.Println(end.Sub(start))
}
image.png
æµ‹è¯•é€Ÿåº¦æ²¡æœ‰å¤šå¤§çš„å·®åˆ«,å¦‚æœæœ‰éœ€è¦åç¨‹,ä½†æ˜¯æœ‰ä¸€é¡¹é‡è¦çš„åŠŸèƒ½éœ€è¦å ä¸€ä¸ªæ ¸ï¼Œå°±éœ€è¦</p>

<p>28.è§£é™¤goåç¨‹ä¸æ“ä½œç³»ç»Ÿçº¿ç¨‹çš„ç»‘å®šå…³ç³»
func UnlockOSThread()
å°†è°ƒç”¨çš„goç¨‹è§£é™¤å’Œå®ƒç»‘å®šçš„æ“ä½œç³»ç»Ÿçº¿ç¨‹ã€‚è‹¥è°ƒç”¨çš„goç¨‹æœªè°ƒç”¨LockOSThreadï¼ŒUnlockOSThreadä¸åšæ“ä½œ</p>

<p>29.è·å–çº¿ç¨‹åˆ›å»ºprofileä¸­çš„è®°å½•ä¸ªæ•°
func ThreadCreateProfile(p []StackRecord) (n int, ok bool)
è¿”å›çº¿ç¨‹åˆ›å»ºprofileä¸­çš„è®°å½•ä¸ªæ•°ã€‚å¦‚æœlen(p)&gt;=nï¼Œæœ¬å‡½æ•°å°±ä¼šå°†profileä¸­çš„è®°å½•å¤åˆ¶åˆ°pä¸­å¹¶è¿”å›(n, true)ã€‚è‹¥len(p)&lt;nï¼Œåˆ™ä¸ä¼šæ›´æ”¹pï¼Œè€Œåªè¿”å›(n, false)ã€‚</p>

<p>ç»å¤§å¤šæ•°ä½¿ç”¨è€…åº”å½“ä½¿ç”¨runtime/pprofåŒ…ï¼Œè€Œéç›´æ¥è°ƒç”¨ThreadCreateProfileã€‚</p>

<p>30.æ§åˆ¶é˜»å¡profileè®°å½•goåç¨‹é˜»å¡äº‹ä»¶çš„é‡‡æ ·ç‡
func SetBlockProfileRate(rate int)</p>

<p>SetBlockProfileRateæ§åˆ¶é˜»å¡profileè®°å½•goç¨‹é˜»å¡äº‹ä»¶çš„é‡‡æ ·é¢‘ç‡ã€‚å¯¹äºä¸€ä¸ªé˜»å¡äº‹ä»¶ï¼Œå¹³å‡æ¯é˜»å¡rateçº³ç§’ï¼Œé˜»å¡profileè®°å½•å™¨å°±é‡‡é›†ä¸€ä»½æ ·æœ¬ã€‚</p>

<p>è¦åœ¨profileä¸­åŒ…æ‹¬æ¯ä¸€ä¸ªé˜»å¡äº‹ä»¶ï¼Œéœ€ä¼ å…¥rate=1ï¼›è¦å®Œå…¨å…³é—­é˜»å¡profileçš„è®°å½•ï¼Œéœ€ä¼ å…¥rate&lt;=0ã€‚</p>

<p>31.è¿”å›å½“å‰é˜»å¡profileä¸­çš„è®°å½•ä¸ªæ•°
func BlockProfile(p []BlockProfileRecord) (n int, ok bool)</p>

<p>BlockProfileè¿”å›å½“å‰é˜»å¡profileä¸­çš„è®°å½•ä¸ªæ•°ã€‚å¦‚æœlen(p)&gt;=nï¼Œæœ¬å‡½æ•°å°±ä¼šå°†æ­¤profileä¸­çš„è®°å½•å¤åˆ¶åˆ°pä¸­å¹¶è¿”å›(n, true)ã€‚å¦‚æœlen(p)&lt;nï¼Œæœ¬å‡½æ•°åˆ™ä¸ä¼šä¿®æ”¹pï¼Œè€Œåªè¿”å›(n, false)ã€‚</p>

<p>ç»å¤§å¤šæ•°ä½¿ç”¨è€…åº”å½“ä½¿ç”¨runtime/pprofåŒ…æˆ–testingåŒ…çš„-test.blockprofileæ ‡è®°ï¼Œ è€Œéç›´æ¥è°ƒç”¨ BlockProfile</p>
:ET