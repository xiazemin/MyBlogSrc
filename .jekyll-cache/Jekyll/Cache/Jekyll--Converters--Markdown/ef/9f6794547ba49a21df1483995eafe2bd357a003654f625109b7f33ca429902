I"†u<p>1,åå°„ä¸­è°ƒç”¨ å‡½æ•°
æ—¢ç„¶å‡½æ•°å¯ä»¥åƒæ™®é€šçš„ç±»å‹å˜é‡ä¸€æ ·å¯ä»¥çš„è¯ï¼Œé‚£ä¹ˆåœ¨åå°„æœºåˆ¶ä¸­å°±å’Œä¸åŒçš„å˜é‡æ˜¯ä¸€æ ·çš„ï¼Œåœ¨åå°„ä¸­ å‡½æ•° å’Œ æ–¹æ³• çš„ç±»å‹ï¼ˆTypeï¼‰éƒ½æ˜¯ reflect.Funcï¼Œå¦‚æœè¦è°ƒç”¨å‡½æ•°çš„è¯ï¼Œå¯ä»¥é€šè¿‡ Value çš„ Call() æ–¹æ³•
Value çš„ Call() æ–¹æ³•çš„å‚æ•°æ˜¯ä¸€ä¸ª Value çš„ sliceï¼Œå¯¹åº”çš„åå°„å‡½æ•°ç±»å‹çš„å‚æ•°ï¼Œè¿”å›å€¼ä¹Ÿæ˜¯ä¸€ä¸ª Value çš„ sliceï¼ŒåŒæ ·å¯¹åº”åå°„å‡½æ•°ç±»å‹çš„è¿”å›å€¼ã€‚é€šè¿‡è¿™ä¸ªä¾‹å­ï¼Œç›¸ä¿¡ä½ ä¸€çœ‹å°±æ˜ç™½äº†ï¼š
func prints(i int) string {
    fmt.Println(â€œi =â€, i)
    return strconv.Itoa(i)
}</p>

<p>func main() {
    fv := reflect.ValueOf(prints)
    params := make([]reflect.Value, 1)                 // å‚æ•°
    params[0] = reflect.ValueOf(20)                    // å‚æ•°è®¾ç½®ä¸º20
    rs := fv.Call(params)                              // rsä½œä¸ºç»“æœæ¥å—å‡½æ•°çš„è¿”å›å€¼
    fmt.Println(â€œresult:â€, rs[0].Interface().(string)) // å½“ç„¶ä¹Ÿå¯ä»¥ç›´æ¥æ˜¯ rs[0].Interface()
2,åå°„ä¸­è°ƒç”¨ æ–¹æ³•
å‡½æ•°å’Œæ–¹æ³•å¯ä»¥è¯´å…¶å®æœ¬è´¨ä¸Šæ˜¯ç›¸åŒçš„ï¼Œåªä¸è¿‡æ–¹æ³•ä¸ä¸€ä¸ªâ€œå¯¹è±¡â€è¿›è¡Œäº†â€œç»‘å®šâ€ï¼Œæ–¹æ³•æ˜¯â€œå¯¹è±¡â€çš„ä¸€ç§è¡Œä¸ºï¼Œè¿™ç§è¡Œä¸ºæ˜¯å¯¹äºè¿™ä¸ªâ€œå¯¹è±¡â€çš„ä¸€ç³»åˆ—æ“ä½œï¼Œä¾‹å¦‚ä¿®æ”¹â€œå¯¹è±¡â€çš„æŸä¸ªå±æ€§
Method å’Œ MethodByName çš„API,
ype MyType struct {
    i    int
    name string
}</p>

<p>func (mt *MyType) SetI(i int) {
    mt.i = i
}</p>

<p>func (mt *MyType) SetName(name string) {
    mt.name = name
}</p>

<p>func (mt *MyType) String() string {
    return fmt.Sprintf(â€œ%pâ€, mt) + â€œâ€“name:â€ + mt.name + â€œ i:â€ + strconv.Itoa(mt.i)
}
func main() {
    myType := &amp;MyType{22, â€œgolangâ€}
    //fmt.Println(myType)     // å°±æ˜¯æ£€æŸ¥ä¸€ä¸‹myTypeå¯¹è±¡å†…å®¹
    //println(â€œâ€”â€”â€”â€”â€”â€)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mtV := reflect.ValueOf(&amp;myType).Elem()
// ä¹Ÿå¯ä»¥ä½¿ç”¨
//mtV := reflect.ValueOf(myType)
 
 
fmt.Println("Before:", mtV.MethodByName("String").Call(nil)[0])
 
params := make([]reflect.Value, 1)
params[0] = reflect.ValueOf(18)
mtV.MethodByName("SetI").Call(params)
 
params[0] = reflect.ValueOf("reflection test")
mtV.MethodByName("SetName").Call(params)
 
fmt.Println("After:", mtV.MethodByName("String").Call(nil)[0]) } mtV := reflect.ValueOf(&amp;myType).Elem() fmt.Println("Before:",mtV.Method(2).Call(nil)[0]) params = make([]reflect.Value,1) params[0] = reflect.ValueOf(18) mtV.Method(0).Call(params) params[0] = reflect.ValueOf("reflection test") mtV.Method(1).Call(params) fmt.Println("After:",mtV.Method(2).Call(nil)[0]) &lt;!-- more --&gt; martiniçš„æ•´ä¸ªæ¡†æ¶çš„åå°åŠ¨åŠ›éƒ½æ˜¯æ¥è‡ªinjectè¿™ä¸ªåŒ…ï¼Œå®ƒå…¶å®æ˜¯ç‹¬ç«‹äºæ¡†æ¶çš„ä¸€ä¸ªåŠŸèƒ½åŒ…ï¼Œé‡Œé¢ä¸»è¦æ˜¯è¿ç”¨äº†åå°„çš„æŠ€æœ¯æ¥å®Œæˆæ‰€éœ€è¦çš„åŠŸèƒ½ã€‚æˆ‘è‡ªå·±åœ¨å­¦ä¹ æˆ–è€…æ¥è§¦ä¸€æ®µæ–°ä»£ç æˆ–è€…çŸ¥è¯†ç‚¹çš„æ—¶å€™éƒ½ä¼šå…ˆç›´æ¥æ‰¾sampleè¿è¡Œçœ‹è·‘çš„ç»“æœï¼Œæ‰€ä»¥ä¸‹é¢å…ˆçœ‹ä¸€æ®µä»£ç åŠæ‰§è¡Œç»“æœ&lt;ä»£ç 1&gt;ï¼š
</code></pre></div></div>

<p>package main</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import (
    "fmt"
    "github.com/codegangsta/inject"
    "log"
    "reflect"
)

func do(i int) int {
    fmt.Println(i)
    return 23
}

func main() {
    in := inject.New()
    in.Map(12)
    val, err := in.Invoke(do)
    if err != nil {
        log.Fatal("è°ƒç”¨å‡ºé”™:" + err.Error())
        return
    }
    for _, v := range val {
        if v.Kind() == reflect.Int {
            fmt.Println(v.Int())
        }
    }
}
</code></pre></div></div>

<p>è¾“å‡ºç»“æœä¸º:  <code class="language-plaintext highlighter-rouge">12
            23</code>
ä¸‹é¢æ ¹æ®ä¸Šé¢çš„ä»£ç æ¥ä¸€æ­¥æ­¥åˆ†æä¸‹injectçš„æ‰§è¡Œè¿‡ç¨‹ä¸åŸç†ã€‚</p>

<p>ä»£ç ç»“æ„
æœ‰ä¸€ä¸ªinjectç»“æ„</p>

<p>type injector struct {
        values map[reflect.Type]reflect.Value
        parent Injector
    }
valuesæ˜¯ç”¨æ¥å­˜å‚¨æ¯ä¸€ä¸ª<type-value>é”®å€¼å¯¹çš„ï¼Œæ¯ä¸€ä¸ªç±»å‹åªå¯¹åº”äºä¸€ä¸ªå€¼ï¼Œå› ä¸ºè¦æ˜¯æœ‰ä¸¤ä¸ªå€¼çš„ç±»å‹ç›¸åŒçš„è¯ï¼Œé‚£ä¹ˆåé¢ä¸€ä¸ªå€¼å°†ä¼šæŠŠå‰é¢çš„ä¸€ä¸ªå€¼è¦†ç›–æ‰ã€‚parentè¿™ä¸ªå­—æ®µå­˜å‚¨äº†æ­¤èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ã€‚</type-value></p>

<p>ä»£ç 1ä¸­ï¼Œin := inject.New()å°±æ˜¯åˆ›å»ºäº†ä¸€ä¸ªinjectç»“æ„ï¼Œå¹¶è¿”å›ã€‚ä»£ç å°±æ˜¯</p>

<p>// New returns a new Injector.
    func New() Injector {
        return &amp;injector{
            values: make(map[reflect.Type]reflect.Value),
        }
    }
ä¸‹é¢æ˜¯in.Map(12)è¿™æ¡è¯­å¥ï¼Œé¡¾åæ€ä¹‰å°±æ˜¯å°†12è¿™ä¸ªæ•°å€¼è¿›è¡Œæ˜ å°„ï¼Œåœ¨injectä¸­å”¯ä¸€å¯ä»¥å­˜å‚¨æ˜ å°„çš„å°±åªæœ‰valuesäº†ï¼Œé‚£ä¹ˆå®ƒå½“ç„¶å°±åº”è¯¥å­˜å‚¨åˆ°valuesé‡Œé¢ã€‚ä»£ç å¦‚ä¸‹ï¼š</p>

<p>// Maps the concrete value of val to its dynamic type using reflect.TypeOf,
    // It returns the TypeMapper registered in.
    func (i *injector) Map(val interface{}) TypeMapper {
        i.values[reflect.TypeOf(val)] = reflect.ValueOf(val)
        return i
    }
è¿”å›çš„è¿™ä¸ªTypeMapperæ˜¯ä¸€ä¸ªæ¥å£</p>

<p>// TypeMapper represents an interface for mapping interface{} values based on type.
    type TypeMapper interface {
        // Maps the interface{} value based on its immediate type from reflect.TypeOf.
        Map(interface{}) TypeMapper
        // Maps the interface{} value based on the pointer of an Interface provided.
        // This is really only useful for mapping a value as an interface, as interfaces
        // cannot at this time be referenced directly without a pointer.
        MapTo(interface{}, interface{}) TypeMapper
        // Provides a possibility to directly insert a mapping based on type and value.
        // This makes it possible to directly map type arguments not possible to instantiate
        // with reflect like unidirectional channels.
        Set(reflect.Type, reflect.Value) TypeMapper
        // Returns the Value that is mapped to the current type. Returns a zeroed Value if
        // the Type has not been mapped.
        Get(reflect.Type) reflect.Value
    }
ä¸‹é¢æˆ‘ä»¬ä¼šçœ‹åˆ°å…¶å®injectè¿™ä¸ªç»“æ„å®ç°äº†TypeMapperè¿™ä¸ªæ¥å£ã€‚æ‰€ä»¥è¿”å›å€¼æˆ‘ä»¬ä¹Ÿå¯ä»¥ç†è§£ä¸ºinjectè¿™ä¸ªç»“æ„æœ¬èº«ã€‚æ˜¯å¦éœ€è¦è¿™ä¸ªè¿”å›å€¼æ ¹æ®æƒ…å†µè€Œå®šï¼Œå¤§å¤šæ•°æ—¶å€™éƒ½ä¸éœ€è¦(ä½†æ˜¯ä¸ç®¡ä½ è¦ä¸è¦ï¼Œå®ƒéƒ½ç»™ä½ è¿”å›äº†^_^)ã€‚</p>

<p>ä¸‹é¢å›åˆ°Mapè¿™ä¸ªæ–¹æ³•ï¼Œå®ƒä½¿ç”¨äº†reflectè¿™ä¸ªåå°„åŒ…ï¼Œè¿™æ ·å°±å¯ä»¥å°†éœ€è¦æ˜ å°„çš„12è¿™ä¸ªå€¼å­˜å‚¨åˆ°äº†valuesä¸­äº†ï¼Œå…³äºreflectè¿™ä¸ªåŒ…çš„ç”¨æ³•å¯ä»¥æŸ¥çœ‹å®˜æ–¹çš„æ–‡æ¡£ã€‚</p>

<p>æ—¢ç„¶å‡½æ•°çš„å‚æ•°å·²ç»æ˜ å°„å®Œæˆäº†ï¼Œé‚£ä¹ˆä¹…å¯ä»¥æ‰§è¡Œè°ƒç”¨æ“ä½œäº†ã€‚in.Invoke(do)å°±æ˜¯è°ƒç”¨doæ–¹æ³•ï¼Œæ‰€ä»¥Mapè¿™ä¸ªæ–¹æ³•å…¶å®æ˜¯ä¸ºäº†å°†æ‰€è¦è°ƒç”¨çš„å‡½æ•°çš„å‚æ•°äº‹å…ˆå­˜å‚¨åˆ°inè¿™ä¸ªå®ä¾‹ä¸­æœåŠ¡çš„ï¼Œå¯èƒ½çœ‹åˆ°è¿™é‡Œå¤§å®¶å°±ä¼šæƒ³ï¼Œä¸Šé¢TypeMapperæ¥å£ä¸­ä¸æ˜¯è¿˜æœ‰ä¸€ä¸ªMapToå—ï¼Œé•¿çš„è·ŸMapè¿™ä¹ˆåƒæ˜¯å¹²å˜›çš„ï¼Œå—¯ï¼Œå½“ç„¶ä¸æ˜¯è€å¸…ç”¨çš„ï¼Œæœ€å¼€å§‹çš„æ—¶å€™ï¼Œä»‹ç»injectè¿™ä¸ªç»“æ„çš„æ—¶å€™è¯´ï¼Œvaluesæ˜¯ä¸ªmapç±»å‹çš„ï¼Œæ¯ä¸€ä¸ªç±»å‹åªèƒ½å¯¹åº”ä¸€ä¸ªå”¯ä¸€çš„å€¼ï¼Œé‚£ä¹ˆä¸‹é¢é—®é¢˜æ¥äº†ï¼šæˆ‘ä»¬å‡½æ•°çš„å‚æ•°ç±»å‹ä¸å¯èƒ½éƒ½ä¸ä¸€æ ·å§ã€‚doå‡½æ•°åªæœ‰ä¸€ä¸ªå‚æ•°ï¼Œå¯æˆ‘ä»¬è¦æ˜¯å†åŠ ä¸€ä¸ªåŒæ ·æ˜¯intç±»å‹çš„å‚æ•°å‘¢ï¼Œå²‚ä¸æ˜¯è¦æŠŠä¹‹å‰çš„å‚æ•°å€¼ç»™è¦†ç›–æ‰äº†ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜å¼•å…¥äº†MapToè¿™ä¸ªæ–¹æ³•ï¼Œå®Œæˆçš„åŠŸèƒ½å’ŒMapæ˜¯ä¸€æ ·çš„ï¼Œåªæ˜¯å¤šäº†ä¸€ä¸ªå‚æ•°ã€‚goè¯­è¨€ä¸­æˆ‘ä»¬å¯ä»¥åŸºäºä¸€ä¸ªå·²æœ‰ç±»å‹å»ºç«‹ä¸€ä¸ªæ–°ç±»å‹ï¼Œtype myInt interface{},é‚£ä¹ˆmyIntå°±æ˜¯åŸºäºinterface{}çš„è‡ªå»ºçš„ç±»å‹äº†ï¼Œinterface{}è¿™ä¸ªå°±ç›¸å½“äºpythonæˆ–è€… javaä¸­çš„Objectï¼ŒC/C++ä¸­çš„void*ã€‚æ—¢ç„¶ä¸èƒ½ä¸¤ä¸ªéƒ½å«intï¼Œé‚£ä¹ˆæˆ‘å°±æ¢ä¸€ä¸ªåå­—æ”¹å«myIntå¥½äº†ï¼Œè¿™ä¸‹å°±ä¸ä¼šå†²çªäº†ã€‚åŒæ ·ï¼Œè¦æ˜¯è¿˜æœ‰ä¸€ä¸ªintå‹çš„å‚æ•°ï¼Œé‚£å°±å†å®šä¹‰ä¸€ä¸ªmyInt2ç­‰ç­‰ï¼Œæ€»ä¹‹ä¸è·Ÿä½ ä¸€ä¸ªæ ·å°±å¥½äº†ã€‚ ä¾‹å¦‚ï¼šæœ¬æ¥æ˜¯do(i,j int),é‚£ä¹ˆç°åœ¨å°±å˜æˆäº†do(i int,j myInt)è¿™ä¸ªæ ·å­äº†ã€‚</p>

<p>å›åˆ°Invokeè¿™ä¸ªæ–¹æ³•ï¼Œçœ‹çœ‹è¿™ä¸ªæ–¹æ³•æ˜¯æ€ä¹ˆæ‰§è¡Œçš„ï¼š</p>

<p>// Invoke attempts to call the interface{} provided as a function,
    // providing dependencies for function arguments based on Type.
    // Returns a slice of reflect.Value representing the returned values of the function.
    // Returns an error if the injection fails.
    // It panics if f is not a function
    func (inj *injector) Invoke(f interface{}) ([]reflect.Value, error) {
        t := reflect.TypeOf(f)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    var in = make([]reflect.Value, t.NumIn()) //Panic if t is not kind of Func
    for i := 0; i &lt; t.NumIn(); i++ {
        argType := t.In(i)
        val := inj.Get(argType)
        if !val.IsValid() {
            return nil, fmt.Errorf("Value not found for type %v", argType)
        }

        in[i] = val
    }

    return reflect.ValueOf(f).Call(in), nil
} var in = make([]reflect.Value, t.NumIn())è¿™æ¡è¯­å¥åˆ›å»ºäº†ä¸€ä¸ªinå˜é‡ï¼Œè¿™ä¸ªå˜é‡çš„ä½œç”¨å°±æ˜¯ç”¨æ¥å­˜å‚¨è¢«è°ƒç”¨çš„å‡½æ•°çš„å‚æ•°å€¼çš„ã€‚t.NumIn()è¿™ä¸ªæ–¹æ³•å½“tçš„ç±»å‹ä¸æ˜¯å‡½æ•°çš„æ—¶å€™ä¼šç›´æ¥panicï¼Œæ­£å¸¸è¿”å›çš„æ˜¯fè¿™ä¸ªå‡½æ•°çš„å‚æ•°çš„ä¸ªæ•°ï¼Œå¯ä»¥å‚çœ‹å®˜æ–¹çš„æ–‡æ¡£ã€‚
</code></pre></div></div>

<p>æ—¢ç„¶æ˜¯è°ƒç”¨ï¼Œé‚£ä¹ˆè‚¯å®šæ˜¯éœ€è¦å‚æ•°çš„ï¼Œè€Œå‚æ•°ä¹‹å‰åˆå·²ç»å­˜å‚¨åˆ°äº†valuesä¸­ï¼Œæ‰€ä»¥ç°åœ¨åªéœ€è¦åˆ°valuesä¸­æŠŠå‚æ•°å–å‡ºæ¥å°±OKäº†ã€‚ç”±äºvaluesæ˜¯ä¸€ä¸ª<type-value>é”®å€¼å¯¹ï¼Œæ‰€ä»¥æƒ³è¦è·å–å€¼é¦–å…ˆå¾—çŸ¥é“è¿™ä¸ªå€¼çš„ç±»å‹ï¼Œt.In(i)å°±æ˜¯è·å–å‚æ•°çš„ç±»å‹ï¼Œiæ˜¯ä¸€ä¸ªç´¢å¼•ï¼Œè¡¨ç¤ºç¬¬å‡ ä¸ªå‚æ•°(ä»0å¼€å§‹)ï¼Œåœ¨è·å–ç±»å‹ä¹‹åï¼Œå°±å¯ä»¥åˆ°valuesä¸­å–å€¼äº†ï¼Œä»£ç ä¸­å–å€¼ä½¿ç”¨äº†Getè¿™ä¸ªæ–¹æ³•ï¼Œä¸‹é¢æ˜¯Getæ–¹æ³•çš„ä»£ç ï¼Œä¹Ÿå¾ˆç®€å•</type-value></p>

<p>func (i *injector) Get(t reflect.Type) reflect.Value {
        val := i.values[t]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if val.IsValid() {
        return val
    }

    // no concrete types found, try to find implementors
    // if t is an interface
    if t.Kind() == reflect.Interface {
        for k, v := range i.values {
            if k.Implements(t) {
                val = v
                break
            }
        }
    }

    // Still no type found, try to look it up on the parent
    if !val.IsValid() &amp;&amp; i.parent != nil {
        val = i.parent.Get(t)
    }

    return val

} é¦–å…ˆæ ¹æ®ç±»å‹tä»valuesä¸­å–å€¼ï¼Œå–å€¼å½“ç„¶æœ‰å–å¤±è´¥çš„ï¼Œæ‰€ä»¥æ¥ä¸‹å»å°±åˆ¤æ–­ä¸€ä¸ªè¿™ä¸ªå€¼æ˜¯å¦æ˜¯å¯ç”¨çš„ï¼ŒisValid()ï¼Œè¦æ˜¯å¯ç”¨çš„å°±ç›´æ¥è¿”å›è¿™ä¸ªå€¼ï¼Œå¦åˆ™å°±è¯´æ˜valuesä¸­ä¸å­˜åœ¨è¿™ä¸ªç±»å‹tå¯¹åº”çš„å€¼ï¼Œé‚£æ¥ä¸‹å»Getä¼šæŸ¥çœ‹ç±»å‹tæ˜¯å¦å®ç°äº†valuesä¸­æŸæ¥å£ç±»å‹ï¼Œå¦‚æœç¡®å®è¿™æ ·ï¼Œé‚£ä¹ˆå°±è¿”å›è¿™ä¸ªæ¥å£ç±»å‹æ‰€å¯¹åº”çš„å€¼ã€‚å¦‚æœè¿˜æ‰¾ä¸åˆ°ï¼Œé‚£ä¹ˆGetè¿˜ä¼šå°½æœ€åçš„åŠªåŠ›è¯·æ±‚è€çˆ¸ï¼Œçœ‹çœ‹ä»–é‚£é‡Œæ˜¯å¦æœ‰è¿™ä¸ªç±»å‹æˆ–è€…ç›¸å…³æ¥å£(ä»£ç ä¹Ÿæ‹¼çˆ¹å•Š?)ã€‚
</code></pre></div></div>

<p>å‡è®¾ä¸€åˆ‡é¡ºåˆ©ï¼Œé‚£ä¹ˆç°åœ¨inè¿™ä¸ªå˜é‡å·²ç»å­˜å‚¨äº†è¢«è°ƒç”¨å‡½æ•°çš„æ‰€æœ‰å‚æ•°å€¼äº†ï¼Œä¸‡äº‹ä¿±å¤‡ï¼Œåªæ¬ Callï¼Œé‚£å°±Callï¼ŒCallæ–¹æ³•çš„å‚æ•°å°±æ˜¯å­˜å‚¨æœ‰è¢«è°ƒç”¨å‡½æ•°çš„å‚æ•°åˆ‡ç‰‡inï¼Œè¿”å›å€¼ä¸ºè¢«è°ƒç”¨å‡½æ•°fçš„è¿”å›å€¼ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯è™½ç„¶å®ƒçš„è¿”å›å€¼æ˜¯fçš„è¿”å›å€¼ï¼Œä½†æ˜¯å®ƒæ˜¯ä¸€ä¸ª[]reflect.Valueåˆ‡ç‰‡,ä½¿ç”¨çš„æ—¶å€™è‡ªå·±æ ¹æ®ç›¸å…³æ–¹æ³•è¿›è¡Œç±»å‹è½¬æ¢ã€‚</p>

<p>é™¤äº†ä¸Šé¢æåˆ°çš„æ–¹æ³•ä¹‹å¤–ï¼Œinjectæºç ä¸­è¿˜æœ‰ä¸€ä¸ªå¾ˆå¸…æ°”çš„æ–¹æ³•ï¼ŒApply</p>

<p>package main</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import (
    "fmt"
    "github.com/codegangsta/inject"
)

type MyApp struct {
    Name string `inject`
    Age  int    `inject`
}

func main() {
    app := MyApp{}
    in := inject.New()
    in.Map("zhengk")
    in.Map(25)
    in.Apply(&amp;app)
    fmt.Println(app.Name)
    fmt.Println(app.Age)
} è¿è¡Œç»“æœä¸º: zhengk 25
</code></pre></div></div>

<p>è¿˜æœ‰ä¸€ä¸ªå°±æ˜¯ä¸ºæ‹¼çˆ¹ä½¿ç”¨çš„æ‰¾çˆ¹å‡½æ•°SetParent,åŠŸèƒ½ï¼šç»™å½“å‰injectå®ä¾‹è®¾ç½®ä¸€ä¸ªçˆ¶äº²ï¼Œåœ¨Getæ–¹æ³•é‡Œé¢ä¹Ÿè§è¿‡å®ƒçš„ä½¿ç”¨åœºæ™¯ã€‚ç»™ä¸€ä¸ªç®€å•çš„ä¾‹å­å§</p>

<p>package main</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import (
    "fmt"
    "github.com/codegangsta/inject"
)

func do(i int, j myInt, name string) {
    fmt.Println(i, j, name)
}

type myInt interface{}

func main() {
    inP := inject.New()
    inP.Map("zhengk")
    inChild := inject.New()
    inChild.Map(25)
    inChild.MapTo(12, (*myInt)(nil))
    inChild.SetParent(inP)
    inChild.Invoke(do)
} è¿è¡Œç»“æœä¸º:25 12 zhengk package inject
</code></pre></div></div>

<p>import (
    â€œfmtâ€
    â€œreflectâ€
)</p>

<p>// å®ç°å›è°ƒå‡½æ•°å‚æ•°å€¼çš„æ³¨å…¥ï¼Œé€šè§‚martiniæ¡†æ¶ï¼ŒInjectorå°±æ˜¯ç”¨äºå­˜å‚¨ä¸­é—´ä»¶å‡½æ•°ä»¥åŠç”¨æˆ·è‡ªå®šä¹‰å‡½æ•°å›è°ƒæ—¶çš„å‚æ•°
type Injector interface {
    Applicator // ç»“æ„ä½“å„ä¸ªå­—æ®µèµ‹å€¼
    Invoker     // é€šè¿‡åå°„å®ç°å‡½æ•°è°ƒç”¨çš„æ¥å£
    TypeMapper  // ç±»å‹æ˜ å°„æ¥å£ï¼ŒTypeMapper çš„åŠŸèƒ½ä¸ç³»ç»Ÿè®¾è®¡åˆè¡·æœ‰å…³ç³»å§ï¼Œmapperæ ¹æ®ç±»å‹ä¸ºé”®å€¼keyï¼ŒåŒä¸€ç±»å‹åªæœ‰ä¸€ä¸ªvalueä¸ä¹‹å¯¹åº”
    SetParent(Injector)
}</p>

<p>// ä¸ºç»“æ„ä½“ç±»å‹çš„å„ä¸ªå­—æ®µè¿›è¡ŒåŠ¨æ€èµ‹å€¼
type Applicator interface {
    // ä¸ºç»“æ„ä½“å®šä¹‰ä¸­ï¼Œå¸¦æœ‰â€™injectâ€™æ ‡ç­¾çš„å­—æ®µè¿›è¡Œèµ‹å€¼
    Apply(interface{}) error
}</p>

<p>// é€šè¿‡åå°„çš„æ–¹å¼å®ç°å‡½æ•°è°ƒç”¨
type Invoker interface {
    // å‚æ•°ç±»å‹ä¸ºå‡½æ•°ç±»å‹ï¼Œä½¿ç”¨åå°„è·å–å‡½æ•°å‚æ•°ç±»å‹ï¼Œæ ¹æ®å„ä¸ªå‚æ•°ç±»å‹è·å–å¯¹åº”çš„å€¼ï¼Œå¹¶è°ƒç”¨è¯¥å‡½æ•°
    Invoke(interface{}) ([]reflect.Value, error)
}</p>

<p>// å‚æ•°å€¼ä¸ç±»å‹çš„æ˜ å°„æ¥å£
type TypeMapper interface {
    // å…·ä½“ç±»å‹çš„æ˜ å°„,æ ¹æ®å€¼çš„å…·ä½“ç±»å‹ç›´æ¥å»ºç«‹æ˜ å°„
    Map(interface{}) TypeMapper
    // â€™æ³›å‹â€˜ä¸å…·ä½“ç±»å‹ä¹‹é—´çš„æ˜ å°„ï¼Œç¬¬äºŒä¸ªå‚æ•°å¿…é¡»æ˜¯æ³›å‹çš„æŒ‡é’ˆç±»å‹
    // å› ä¸ºè¿™é‡Œåªéœ€è¦è·å¾—æ³›å‹çš„ç±»å‹ï¼Œåªæœ‰æ³›å‹çš„æŒ‡é’ˆä»£ä»·æœ€å°äº†ï¼Œå› ä¸ºåªéœ€è¦ç”¨åˆ°å®ƒçš„typeéƒ¨åˆ†
    // è¿™é‡Œéœ€è¦ç†è§£interface{}çš„å…·ä½“å®ç°
    MapTo(interface{}, interface{}) TypeMapper
    Set(reflect.Type, reflect.Value) TypeMapper
    Get(reflect.Type) reflect.Value // æ ¹æ®ç±»å‹æŸ¥æ‰¾å€¼
}</p>

<p>//è¿™é‡Œç±»ä¼¼äºå°†æ‰€æœ‰çš„golangç±»å‹åˆ†ä¸ºä¸¤ç§å¤§çš„ç±»å‹ï¼šæ³›å‹ interface{}ä¸å…·ä½“ç±»å‹concrete type
type injector struct {
    values map[reflect.Type]reflect.Value // å­˜å‚¨ä¸Šè¿°è¿‡ç¨‹ä¸­ç»“æ„ä½“å­—æ®µçš„å€¼ï¼Œä»¥åŠå‡½æ•°è°ƒç”¨å‚æ•°çš„å€¼
    parent Injector //
}</p>

<p>// æŸ¥è¯¢ value çš„æ¥å£ç±»å‹, é€‚ç”¨äºinterface{}ç±»å‹çš„æ˜ å°„, å¦‚æœvalueä¸æ˜¯æŒ‡é’ˆç±»å‹å°†ä¼šè¿”å›å¼‚å¸¸
// è¿™ä¸ªæ¥å£åªæ˜¯ç”¨åœ¨æ³›å‹æ˜ å°„ï¼Œå› æ­¤åªéœ€è¦ä»value(interface{})ä¸­è·å–typeéƒ¨åˆ†
func InterfaceOf(value interface{}) reflect.Type {
    t := reflect.TypeOf(value) // è·å–typeçš„å€¼</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for t.Kind() == reflect.Ptr { // å¦‚æœæ˜¯æŒ‡é’ˆï¼Œç»§ç»­æŸ¥æŒ‡é’ˆçš„æŒ‡å‘
    t = t.Elem() // æŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ 
}
 
if t.Kind() != reflect.Interface { // æœ€åè‚¯å®šæ˜¯æŒ‡å‘interface äº†ï¼Œå¦‚æœä¸æ˜¯ï¼Œè¯´æ˜ä¼ å…¥çš„å‚æ•°æœ‰é—®é¢˜
    panic("Called inject.InterfaceOf with a value that is not a pointer to an interface. (*MyInterface)(nil)")
}
 
return t }
</code></pre></div></div>

<p>// New returns a new Injector.
//åˆ›å»ºä¸€ä¸ªæ³¨å…¥å·¥å…·ï¼Œæä¾›æ•°æ®å­˜å‚¨ä¸æŸ¥è¯¢ï¼Œå…¶ä»–åŠŸèƒ½ä¸»è¦è¿˜æ˜¯ä¾èµ–äºåå°„åº“çš„å®ç°
func New() Injector {
    return &amp;injector{
        values: make(map[reflect.Type]reflect.Value),
    }
}</p>

<p>// å‚æ•°ç±»å‹ä¸ºå‡½æ•°funcï¼Œä½¿ç”¨åå°„æ¥å£å®Œæˆå‡½æ•°çš„è°ƒç”¨
func (inj *injector) Invoke(f interface{}) ([]reflect.Value, error) {
    t := reflect.TypeOf(f) //è·å–fçš„ç±»å‹éƒ¨åˆ†ï¼Œè¿™é‡Œä¸ºå‡½æ•°ç±»å‹</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var in = make([]reflect.Value, t.NumIn()) //Panic if t is not kind of Func // åˆ›å»ºå­˜å‚¨å‚æ•°çš„ç©ºé—´
for i := 0; i &lt; t.NumIn(); i++ {
    argType := t.In(i)
    val := inj.Get(argType) // æ ¹æ®å‚æ•°ç±»å‹è·å–å‚æ•°çš„å€¼,ä»è¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡ºåŒä¸€ç§ç±»å‹ï¼Œåªæœ‰ä¸€ä¸ªå€¼
    if !val.IsValid() {
        return nil, fmt.Errorf("Value not found for type %v", argType)
    }
 
    in[i] = val
}
 
// åå°„ç±»å‹çš„å‡½æ•°è°ƒç”¨ï¼Œå–å‡ºfä¸­çš„æ•°æ®éƒ¨åˆ†ï¼Œå³å®ä¾‹å€¼å‡½æ•°
return reflect.ValueOf(f).Call(in), nil // å‡½æ•°è°ƒç”¨ }
</code></pre></div></div>

<p>// ä¸ºç»“æ„ä½“èµ‹å€¼çš„å…·ä½“å®ç°
func (inj *injector) Apply(val interface{}) error {
    v := reflect.ValueOf(val)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for v.Kind() == reflect.Ptr {
    v = v.Elem()
}
 
if v.Kind() != reflect.Struct {
    return nil // Should not panic here ?
}
 
t := v.Type() // è·å–ç»“æ„ä½“çš„ç±»å‹
 
for i := 0; i &lt; v.NumField(); i++ { // è·å–å­—æ®µçš„æ•°é‡
    f := v.Field(i)
    structField := t.Field(i)
    // å¸¦æœ‰'inject'æ ‡ç­¾çš„æ‰å¯èƒ½è¢«èµ‹å€¼
    if f.CanSet() &amp;&amp; (structField.Tag == "inject" || structField.Tag.Get("inject") != "") {
        ft := f.Type()
        v := inj.Get(ft)
        if !v.IsValid() {
            return fmt.Errorf("Value not found for type %v", ft)
        }
 
        f.Set(v)
    }
 
}
 
return nil }
</code></pre></div></div>

<p>// å…·ä½“ç±»å‹å‚æ•°ï¼Œç±»å‹ä¸å€¼çš„æ˜ å°„
func (i *injector) Map(val interface{}) TypeMapper {
    //ç±»å‹ä¸å€¼çš„æ˜ å°„
    i.values[reflect.TypeOf(val)] = reflect.ValueOf(val)
    return i
}</p>

<p>// æ³›å‹ç±»å‹çš„æ˜ å°„
func (i *injector) MapTo(val interface{}, ifacePtr interface{}) TypeMapper {
    //éœ€è¦å…ˆè·å–æ³›å‹æŒ‡é’ˆæŒ‡å‘çš„å…·ä½“æ³›å‹ç±»å‹
    i.values[InterfaceOf(ifacePtr)] = reflect.ValueOf(val)
    return i
}</p>

<p>func (i *injector) Set(typ reflect.Type, val reflect.Value) TypeMapper {
    i.values[typ] = val
    return i
}</p>

<p>//  æ ¹æ®ç±»å‹æŸ¥æ‰¾å€¼
func (i *injector) Get(t reflect.Type) reflect.Value {
    val := i.values[t] // å…ˆè¿›è¡Œç®€å•ç±»å‹çš„æŸ¥è¯¢</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if val.IsValid() {
    return val
}
 
// no concrete types found, try to find implementors
// if t is an interface
if t.Kind() == reflect.Interface { // t ä¸º interface ç±»å‹
    for k, v := range i.values {  // è¿­ä»£æŸ¥è¯¢
        if k.Implements(t) {    // å¯¹äºæ¯ä¸€ä¸ªç±»å‹ï¼Œçœ‹æ˜¯å¦å®ç°äº†tæ¥å£
            val = v
            break
        }
    }
}
// æ‰¾ä¸åˆ°ï¼Œå°±å»çˆ¶äº²èŠ‚ç‚¹æ‰¾
// Still no type found, try to look it up on the parent
if !val.IsValid() &amp;&amp; i.parent != nil {
    val = i.parent.Get(t)
}
 
return val
</code></pre></div></div>

<p>}</p>

<p>func (i *injector) SetParent(parent Injector) {
    i.parent = parent
}</p>

<p>ä¾èµ–æ³¨å…¥(Dependency Injection)å’Œæ§åˆ¶åè½¬(Inversion of Control)æ˜¯åŒä¸€ä¸ªæ¦‚å¿µã€‚åœ¨ä¼ ç»Ÿçš„ç¨‹åºè®¾è®¡è¿‡ç¨‹ä¸­ï¼Œè°ƒç”¨è€…æ˜¯è‡ªå·±æ¥å†³å®šä½¿ç”¨å“ªäº›è¢«è°ƒç”¨è€…å®ç°çš„ã€‚ä½†æ˜¯åœ¨ä¾èµ–æ³¨å…¥æ¨¡å¼ä¸­ï¼Œåˆ›å»ºè¢«è°ƒç”¨è€…çš„å·¥ä½œä¸å†ç”±è°ƒç”¨è€…æ¥å®Œæˆï¼Œå› æ­¤ç§°ä¸ºæ§åˆ¶åè½¬ï¼›åˆ›å»ºè¢«è°ƒç”¨è€…å®ä¾‹çš„å·¥ä½œé€šå¸¸ç”±æ³¨å…¥å™¨æ¥å®Œæˆï¼Œç„¶åæ³¨å…¥è°ƒç”¨è€…ï¼Œå› æ­¤ä¹Ÿç§°ä¸ºä¾èµ–æ³¨å…¥ã€‚</p>

<p>inject æ˜¯ä¾èµ–æ³¨å…¥çš„golangå®ç°ï¼Œä½œè€…æ˜¯ codegangsta ã€‚å®ƒèƒ½åœ¨è¿è¡Œæ—¶æ³¨å…¥å‚æ•°ï¼Œè°ƒç”¨æ–¹æ³•ã€‚æ˜¯Martiniæ¡†æ¶çš„åŸºç¡€æ ¸å¿ƒã€‚</p>

<p>æˆ‘å¯¹ä¾èµ–æ³¨å…¥æå–äº†ä»¥ä¸‹2ç‚¹æ€§è´¨ï¼š</p>

<p>ç”±æ³¨å…¥å™¨æ³¨å…¥å±æ€§ã€‚</p>

<p>ç”±æ³¨å…¥å™¨åˆ›å»ºè¢«è°ƒç”¨è€…å®ä¾‹ã€‚</p>

<p>åœ¨injectä¸­ï¼Œè¢«è°ƒç”¨è€…ä¸ºfuncï¼Œå› æ­¤æ³¨å…¥å±æ€§ä¹Ÿå³å¯¹funcæ³¨å…¥å®å‚(å½“ç„¶injectä¹Ÿå¯ä»¥æ³¨å…¥structï¼Œè¿™æ ·çš„è¯æ³¨å…¥çš„å±æ€§å°±æ˜¯structä¸­çš„å·²æ·»åŠ tagä¸º<code class="language-plaintext highlighter-rouge">inject</code>çš„å¯¼å‡ºå­—æ®µ)ã€‚</p>

<p>å®šä¹‰äº†å‡½æ•°Sayå¹¶åœ¨mainæ–¹æ³•ä¸­æ‰‹åŠ¨è°ƒç”¨ã€‚è¿™æ ·æ€»æ˜¯å¯è¡Œçš„ï¼Œä½†æ˜¯æœ‰æ—¶å€™æˆ‘ä»¬ä¸å¾—ä¸é¢å¯¹è¿™æ ·ä¸€ç§æƒ…å†µï¼šæ¯”å¦‚åœ¨webå¼€å‘ä¸­ï¼Œæˆ‘ä»¬æ³¨å†Œè·¯ç”±ï¼ŒæœåŠ¡å™¨æ¥å—è¯·æ±‚ï¼Œç„¶åæ ¹æ®request pathè°ƒç”¨ç›¸åº”çš„handlerã€‚è¿™ä¸ªhandlerå¿…ç„¶ä¸æ˜¯ç”±æˆ‘ä»¬æ‰‹åŠ¨æ¥è°ƒç”¨çš„ï¼Œè€Œæ˜¯ç”±æœåŠ¡å™¨ç«¯æ ¹æ®è·¯ç”±åŒ¹é…æ¥æŸ¥æ‰¾å¯¹åº”çš„handlerå¹¶è‡ªåŠ¨è°ƒç”¨ã€‚</p>

<p>injectåŒ…åªæœ‰2ä¸ªæ–‡ä»¶ï¼Œä¸€ä¸ªæ˜¯inject.goæ–‡ä»¶ï¼Œè¿˜æœ‰ä¸€ä¸ªæ˜¯inject_test.goï¼Œä½†æˆ‘ä»¬åªå…³æ³¨inject.goæ–‡ä»¶ã€‚</p>

<p>inject.goçŸ­å°ç²¾æ‚ï¼ŒåŒ…æ‹¬æ³¨é‡Šå’Œç©ºè¡Œæ‰157è¡Œã€‚å®šä¹‰äº†4ä¸ªæ¥å£ï¼ŒåŒ…æ‹¬ä¸€ä¸ªçˆ¶æ¥å£å’Œä¸‰ä¸ªå­æ¥å£ï¼Œæ¥ä¸‹æ¥æ‚¨å°±ä¼šçŸ¥é“è¿™æ ·å®šä¹‰çš„å¥½å¤„äº†ã€‚</p>

<p>ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘æŠŠæ‰€æœ‰çš„æ³¨é‡Šéƒ½å»æ‰äº†ï¼š</p>

<p>type Injector interface {
	Applicator
	Invoker
	TypeMapper
	SetParent(Injector)
}</p>

<p>type Applicator interface {
	Apply(interface{}) error
}</p>

<p>type Invoker interface {
	Invoke(interface{}) ([]reflect.Value, error)
}</p>

<p>type TypeMapper interface {
	Map(interface{}) TypeMapper
	MapTo(interface{}, interface{}) TypeMapper
	Get(reflect.Type) reflect.Value
}
æ¥å£Injectoræ˜¯æ¥å£Applicatorã€æ¥å£Invokerã€æ¥å£TypeMapperçš„çˆ¶æ¥å£ï¼Œæ‰€ä»¥å®ç°äº†Injectoræ¥å£çš„ç±»å‹ï¼Œä¹Ÿå¿…ç„¶å®ç°äº†Applicatoræ¥å£ã€Invokeræ¥å£å’ŒTypeMapperæ¥å£ã€‚</p>

<p>Applicatoræ¥å£åªè§„å®šäº†Applyæˆå‘˜ï¼Œå®ƒç”¨äºæ³¨å…¥structã€‚</p>

<p>Invokeræ¥å£åªè§„å®šäº†Invokeæˆå‘˜ï¼Œå®ƒç”¨äºæ‰§è¡Œè¢«è°ƒç”¨è€…ã€‚</p>

<p>TypeMapperæ¥å£è§„å®šäº†ä¸‰ä¸ªæˆå‘˜ï¼ŒMapå’ŒMapToéƒ½ç”¨äºæ³¨å…¥å‚æ•°ï¼Œä½†å®ƒä»¬æœ‰ä¸åŒçš„ç”¨æ³•ã€‚Getç”¨äºè°ƒç”¨æ—¶è·å–è¢«æ³¨å…¥çš„å‚æ•°ã€‚</p>

<p>å¦å¤–Injectorè¿˜è§„å®šäº†SetParentè¡Œä¸ºï¼Œå®ƒç”¨äºè®¾ç½®çˆ¶Injectorï¼Œå…¶å®å®ƒç›¸å½“äºæŸ¥æ‰¾ç»§æ‰¿ã€‚ä¹Ÿå³é€šè¿‡Getæ–¹æ³•åœ¨è·å–è¢«æ³¨å…¥å‚æ•°æ—¶ä¼šä¸€ç›´è¿½æº¯åˆ°parentï¼Œè¿™æ˜¯ä¸ªé€’å½’è¿‡ç¨‹ï¼Œç›´åˆ°æŸ¥æ‰¾åˆ°å‚æ•°æˆ–ä¸ºnilç»ˆæ­¢ã€‚</p>

<p>type injector struct {
	values map[reflect.Type]reflect.Value
	parent Injector
}</p>

<p>func InterfaceOf(value interface{}) reflect.Type {
	t := reflect.TypeOf(value)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for t.Kind() == reflect.Ptr {
	t = t.Elem()
}

if t.Kind() != reflect.Interface {
	panic("Called inject.InterfaceOf with a value that is not a pointer to an interface. (*MyInterface)(nil)")
}

return t }
</code></pre></div></div>

<p>func New() Injector {
	return &amp;injector{
		values: make(map[reflect.Type]reflect.Value),
	}
}
injectoræ˜¯injectåŒ…ä¸­å”¯ä¸€å®šä¹‰çš„structï¼Œæ‰€æœ‰çš„æ“ä½œéƒ½æ˜¯åŸºäºinjector structæ¥è¿›è¡Œçš„ã€‚å®ƒæœ‰ä¸¤ä¸ªæˆå‘˜valueså’Œparentã€‚valuesç”¨äºä¿å­˜æ³¨å…¥çš„å‚æ•°ï¼Œå®ƒæ˜¯ä¸€ä¸ªç”¨reflect.Typeå½“é”®ã€reflect.Valueä¸ºå€¼çš„mapï¼Œè¿™ä¸ªå¾ˆé‡è¦ï¼Œç†è§£è¿™ç‚¹å°†æœ‰åŠ©äºç†è§£Mapå’ŒMapToã€‚Newæ–¹æ³•ç”¨äºåˆå§‹åŒ–injector structï¼Œå¹¶è¿”å›ä¸€ä¸ªæŒ‡å‘injector structçš„æŒ‡é’ˆã€‚ä½†æ˜¯è¯·æ³¨æ„è¿™ä¸ªè¿”å›å€¼è¢«Injectoræ¥å£åŒ…è£…äº†ã€‚</p>

<p>InterfaceOfæ–¹æ³•è™½ç„¶åªæœ‰å‡ å¥å®ç°ä»£ç ï¼Œä½†å®ƒæ˜¯Injectorçš„æ ¸å¿ƒã€‚InterfaceOfæ–¹æ³•çš„å‚æ•°å¿…é¡»æ˜¯ä¸€ä¸ªæ¥å£ç±»å‹çš„æŒ‡é’ˆï¼Œå¦‚æœä¸æ˜¯åˆ™å¼•å‘panicã€‚InterfaceOfæ–¹æ³•çš„è¿”å›ç±»å‹æ˜¯reflect.Typeï¼Œæ‚¨åº”è¯¥è¿˜è®°å¾—injectorçš„æˆå‘˜valueså°±æ˜¯ä¸€ä¸ªreflect.Typeç±»å‹å½“é”®çš„mapã€‚è¿™ä¸ªæ–¹æ³•çš„ä½œç”¨å…¶å®åªæ˜¯è·å–å‚æ•°çš„ç±»å‹ï¼Œè€Œä¸å…³å¿ƒå®ƒçš„å€¼ã€‚</p>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œgithub.com/codegangsta/injectâ€
)</p>

<p>type SpecialString interface{}</p>

<p>func main() {
	fmt.Println(inject.InterfaceOf((<em>interface{})(nil)))
	fmt.Println(inject.InterfaceOf((</em>SpecialString)(nil)))
}
$ cd $GOPATH/src/injector_test
$ go build
$ ./injector_test
interface {}
main.SpecialString
ä¸Šé¢çš„è¾“å‡ºä¸€ç‚¹ä¹Ÿä¸å¥‡æ€ªã€‚InterfaceOfæ–¹æ³•å°±æ˜¯ç”¨æ¥å¾—åˆ°å‚æ•°ç±»å‹ï¼Œè€Œä¸å…³å¿ƒå®ƒå…·ä½“å­˜å‚¨çš„æ˜¯ä»€ä¹ˆå€¼ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªSpecialStringæ¥å£ã€‚æˆ‘ä»¬åœ¨ä¹‹å‰çš„ä»£ç ä¹Ÿæœ‰å®šä¹‰SpecialStringæ¥å£ï¼Œç”¨åœ¨Sayæ–¹æ³•çš„å‚æ•°å£°æ˜ä¸­ï¼Œä¹‹åæ‚¨å°±ä¼šçŸ¥é“ä¸ºä»€ä¹ˆè¦è¿™ä¹ˆåšã€‚å½“ç„¶æ‚¨ä¸ä¸€å®šéå¾—å‘½åä¸ºSpecialStringã€‚</p>

<p>func (i *injector) Map(val interface{}) TypeMapper {
	i.values[reflect.TypeOf(val)] = reflect.ValueOf(val)
	return i
}</p>

<p>func (i *injector) MapTo(val interface{}, ifacePtr interface{}) TypeMapper {
	i.values[InterfaceOf(ifacePtr)] = reflect.ValueOf(val)
	return i
}</p>

<p>func (i *injector) Get(t reflect.Type) reflect.Value {
	val := i.values[t]
	if !val.IsValid() &amp;&amp; i.parent != nil {
		val = i.parent.Get(t)
	}
	return val
}</p>

<p>func (i *injector) SetParent(parent Injector) {
	i.parent = parent
}
Mapå’ŒMapToæ–¹æ³•éƒ½ç”¨äºæ³¨å…¥å‚æ•°ï¼Œä¿å­˜äºinjectorçš„æˆå‘˜valuesä¸­ã€‚è¿™ä¸¤ä¸ªæ–¹æ³•çš„åŠŸèƒ½å®Œå…¨ç›¸åŒï¼Œå”¯ä¸€çš„åŒºåˆ«å°±æ˜¯Mapæ–¹æ³•ç”¨å‚æ•°å€¼æœ¬èº«çš„ç±»å‹å½“é”®ï¼Œè€ŒMapToæ–¹æ³•æœ‰ä¸€ä¸ªé¢å¤–çš„å‚æ•°å¯ä»¥æŒ‡å®šç‰¹å®šçš„ç±»å‹å½“é”®ã€‚ä½†æ˜¯MapToæ–¹æ³•çš„ç¬¬äºŒä¸ªå‚æ•°ifacePtrå¿…é¡»æ˜¯æ¥å£æŒ‡é’ˆç±»å‹ï¼Œå› ä¸ºæœ€ç»ˆifacePträ¼šä½œä¸ºInterfaceOfæ–¹æ³•çš„å‚æ•°ã€‚</p>

<p>ä¸ºä»€ä¹ˆéœ€è¦æœ‰MapToæ–¹æ³•ï¼Ÿå› ä¸ºæ³¨å…¥çš„å‚æ•°æ˜¯å­˜å‚¨åœ¨ä¸€ä¸ªä»¥ç±»å‹ä¸ºé”®çš„mapä¸­ï¼Œå¯æƒ³è€ŒçŸ¥ï¼Œå½“ä¸€ä¸ªå‡½æ•°ä¸­æœ‰ä¸€ä¸ªä»¥ä¸Šçš„å‚æ•°çš„ç±»å‹æ˜¯ä¸€æ ·æ—¶ï¼Œåæ‰§è¡ŒMapè¿›è¡Œæ³¨å…¥çš„å‚æ•°å°†ä¼šè¦†ç›–å‰ä¸€ä¸ªé€šè¿‡Mapæ³¨å…¥çš„å‚æ•°ã€‚</p>

<p>SetParentæ–¹æ³•ç”¨äºç»™æŸä¸ªInjectoræŒ‡å®šçˆ¶Injectorã€‚Getæ–¹æ³•é€šè¿‡reflect.Typeä»injectorçš„valuesæˆå‘˜ä¸­å–å‡ºå¯¹åº”çš„å€¼ï¼Œå®ƒå¯èƒ½ä¼šæ£€æŸ¥æ˜¯å¦è®¾ç½®äº†parentï¼Œç›´åˆ°æ‰¾åˆ°æˆ–è¿”å›æ— æ•ˆçš„å€¼ï¼Œæœ€åGetæ–¹æ³•çš„è¿”å›å€¼ä¼šç»è¿‡IsValidæ–¹æ³•çš„æ ¡éªŒã€‚ä¸¾ä¸ªä¾‹å­æ¥åŠ æ·±ç†è§£ï¼š</p>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œgithub.com/codegangsta/injectâ€
	â€œreflectâ€
)</p>

<p>type SpecialString interface{}</p>

<p>func main() {
	inj := inject.New()
	inj.Map(â€œé™ˆä¸€å›â€)
	inj.MapTo(â€œç”·â€, (<em>SpecialString)(nil))
	inj.Map(20)
	fmt.Println(â€œstring is valid?â€, inj.Get(reflect.TypeOf(â€œå§“é™ˆåä¸€å›â€)).IsValid())
	fmt.Println(â€œSpecialString is valid?â€, inj.Get(inject.InterfaceOf((</em>SpecialString)(nil))).IsValid())
	fmt.Println(â€œint is valid?â€, inj.Get(reflect.TypeOf(18)).IsValid())
	fmt.Println(â€œ[]byte is valid?â€, inj.Get(reflect.TypeOf([]byte(â€œGolangâ€))).IsValid())
	inj2 := inject.New()
	inj2.Map([]byte(â€œtestâ€))
	inj.SetParent(inj2)
	fmt.Println(â€œ[]byte is valid?â€, inj.Get(reflect.TypeOf([]byte(â€œGolangâ€))).IsValid())
}
$ cd $GOPATH/src/injector_test
$ go build
$ ./injector_test
string is valid? true
SpecialString is valid? true
int is valid? true
[]byte is valid? false
[]byte is valid? true
é€šè¿‡ä»¥ä¸Šä¾‹å­åº”è¯¥çŸ¥é“SetParentæ˜¯ä»€ä¹ˆæ ·çš„è¡Œä¸ºã€‚æ˜¯ä¸æ˜¯å¾ˆåƒé¢å‘å¯¹è±¡ä¸­çš„æŸ¥æ‰¾é“¾ï¼Ÿ</p>

<p>func (inj *injector) Invoke(f interface{}) ([]reflect.Value, error) {
	t := reflect.TypeOf(f)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var in = make([]reflect.Value, t.NumIn()) //Panic if t is not kind of Func
for i := 0; i &lt; t.NumIn(); i++ {
	argType := t.In(i)
	val := inj.Get(argType)
	if !val.IsValid() {
		return nil, fmt.Errorf("Value not found for type %v", argType)
	}

	in[i] = val
}

return reflect.ValueOf(f).Call(in), nil } Invokeæ–¹æ³•ç”¨äºåŠ¨æ€æ‰§è¡Œå‡½æ•°ï¼Œå½“ç„¶æ‰§è¡Œå‰å¯ä»¥é€šè¿‡Mapæˆ–MapToæ¥æ³¨å…¥å‚æ•°ï¼Œå› ä¸ºé€šè¿‡Invokeæ‰§è¡Œçš„å‡½æ•°ä¼šå–å‡ºå·²æ³¨å…¥çš„å‚æ•°ï¼Œç„¶åé€šè¿‡reflectåŒ…ä¸­çš„Callæ–¹æ³•æ¥è°ƒç”¨ã€‚Invokeæ¥æ”¶çš„å‚æ•°fæ˜¯ä¸€ä¸ªæ¥å£ç±»å‹ï¼Œä½†æ˜¯fçš„åº•å±‚ç±»å‹å¿…é¡»ä¸ºfuncï¼Œå¦åˆ™ä¼španicã€‚
</code></pre></div></div>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œgithub.com/codegangsta/injectâ€
)</p>

<p>type SpecialString interface{}</p>

<p>func Say(name string, gender SpecialString, age int) {
	fmt.Printf(â€œMy name is %s, gender is %s, age is %d!\nâ€, name, gender, age)
}</p>

<p>func main() {
	inj := inject.New()
	inj.Map(â€œé™ˆä¸€å›â€)
	inj.MapTo(â€œç”·â€, (*SpecialString)(nil))
	inj2 := inject.New()
	inj2.Map(20)
	inj.SetParent(inj2)
	inj.Invoke(Say)
}
ä¸Šé¢çš„ä¾‹å­å¦‚æœæ²¡æœ‰å®šä¹‰SpecialStringæ¥å£ä½œä¸ºgenderå‚æ•°çš„ç±»å‹ï¼Œè€ŒæŠŠnameå’Œgenderéƒ½å®šä¹‰ä¸ºstringç±»å‹ï¼Œé‚£ä¹ˆgenderä¼šè¦†ç›–nameçš„å€¼ã€‚å¦‚æœæ‚¨è¿˜æ²¡æœ‰æ˜ç™½ï¼Œå»ºè®®æ‚¨æŠŠè¿™ç¯‡æ–‡ç« ä»å¤´åˆ°å°¾å†çœ‹å‡ éã€‚</p>

<p>func (inj *injector) Apply(val interface{}) error {
	v := reflect.ValueOf(val)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for v.Kind() == reflect.Ptr {
	v = v.Elem()
}

if v.Kind() != reflect.Struct {
	return nil
}

t := v.Type()

for i := 0; i &lt; v.NumField(); i++ {
	f := v.Field(i)
	structField := t.Field(i)
	if f.CanSet() &amp;&amp; structField.Tag == "inject" {
		ft := f.Type()
		v := inj.Get(ft)
		if !v.IsValid() {
			return fmt.Errorf("Value not found for type %v", ft)
		}

		f.Set(v)
	}

}

return nil } Applyæ–¹æ³•æ˜¯ç”¨äºå¯¹structçš„å­—æ®µè¿›è¡Œæ³¨å…¥ï¼Œå‚æ•°ä¸ºæŒ‡å‘åº•å±‚ç±»å‹ä¸ºç»“æ„ä½“çš„æŒ‡é’ˆã€‚å¯æ³¨å…¥çš„å‰ææ˜¯ï¼šå­—æ®µå¿…é¡»æ˜¯å¯¼å‡ºçš„(ä¹Ÿå³å­—æ®µåä»¥å¤§å†™å­—æ¯å¼€å¤´)ï¼Œå¹¶ä¸”æ­¤å­—æ®µçš„tagè®¾ç½®ä¸º`inject`ã€‚ä»¥ä¾‹å­æ¥è¯´æ˜ï¼š
</code></pre></div></div>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œgithub.com/codegangsta/injectâ€
)</p>

<p>type SpecialString interface{}
type TestStruct struct {
	Name   string <code class="language-plaintext highlighter-rouge">inject</code>
	Nick   []byte
	Gender SpecialString <code class="language-plaintext highlighter-rouge">inject</code>
	uid    int           <code class="language-plaintext highlighter-rouge">inject</code>
	Age    int           <code class="language-plaintext highlighter-rouge">inject</code>
}</p>

<p>func main() {
	s := TestStruct{}
	inj := inject.New()
	inj.Map(â€œé™ˆä¸€å›â€)
	inj.MapTo(â€œç”·â€, (*SpecialString)(nil))
	inj2 := inject.New()
	inj2.Map(20)
	inj.SetParent(inj2)
	inj.Apply(&amp;s)
	fmt.Println(â€œs.Name =â€, s.Name)
	fmt.Println(â€œs.Gender =â€, s.Gender)
	fmt.Println(â€œs.Age =â€, s.Age)
}
$ cd $GOPATH/src/injector_test
$ go build
$ ./injector_test
s.Name = é™ˆä¸€å›
s.Gender = ç”·
s.Age = 20</p>
:ET