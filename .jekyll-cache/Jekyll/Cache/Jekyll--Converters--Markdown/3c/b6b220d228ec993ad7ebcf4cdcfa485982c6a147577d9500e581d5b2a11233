I"ÜI<p>Condç”¨äºåœ¨å¹¶å‘ç¯å¢ƒä¸‹routineçš„ç­‰å¾…å’Œé€šçŸ¥</p>

<p>//åˆ›å»ºCond
cond := sync.NewCond(new(sync.Mutex))
//ç­‰å¾…å”¤é†’
cond.L.Lock()
cond.Wait()
//å”¤é†’ä¸€ä¸ª
cond.Signal()
//å”¤é†’æ‰€æœ‰
cond.Broadcast()</p>

<p>ç»“æ„ä½“å®šä¹‰
type Cond struct {
    noCopy noCopy //ä¸å…è®¸å¤åˆ¶,ä¸€ä¸ªç»“æ„ä½“,æœ‰ä¸€ä¸ªLock()æ–¹æ³•,åµŒå…¥åˆ«çš„ç»“æ„ä½“ä¸­,è¡¨ç¤ºä¸å…è®¸å¤åˆ¶
    L Locker    //é”
    notify  notifyList  //é€šçŸ¥åˆ—è¡¨,è°ƒç”¨Wait()æ–¹æ³•çš„routineä¼šè¢«æ”¾å…¥listä¸­,æ¯æ¬¡å”¤é†’,ä»è¿™é‡Œå–å‡º
    checker copyChecker //å¤åˆ¶æ£€æŸ¥,æ£€æŸ¥condå®ä¾‹æ˜¯å¦è¢«å¤åˆ¶
}</p>

<p>noCopyï¼šnoCopyå¯¹è±¡ï¼Œæ‹¥æœ‰ä¸€ä¸ªLockæ–¹æ³•ï¼Œä½¿å¾—Condå¯¹è±¡åœ¨è¿›è¡Œgo vetæ‰«æçš„æ—¶å€™ï¼Œèƒ½å¤Ÿè¢«æ£€æµ‹åˆ°æ˜¯å¦è¢«å¤åˆ¶ã€‚
/*
package: sync
fileï¼š cond.go
line: 94
*/
type noCopy struct{}</p>

<p>func (*noCopy) Lock() {}
<!-- more -->
â€˜æ„é€ â€™æ–¹æ³•
// NewCond returns a new Cond with Locker l.
//é€šè¿‡ä¸€ä¸ªLockerå®ä¾‹åˆå§‹åŒ–,ä¼ å‚æ•°çš„æ—¶å€™å¿…é¡»æ˜¯å¼•ç”¨æˆ–æŒ‡é’ˆ,æ¯”å¦‚&amp;sync.Mutex{}æˆ–new(sync.Mutex)
//ä¸ç„¶ä¼šæŠ¥å¼‚å¸¸:cannot use lock (type sync.Mutex) as type sync.Locker in argument to sync.NewCond:
//sync.Mutex does not implement sync.Locker (Lock method has pointer receiver)
func NewCond(l Locker) *Cond {
    return &amp;Cond{L: l}
}
å¸¸ç”¨æ–¹æ³• 
Wait
//è°ƒç”¨æ­¤æ–¹æ³•ä¼šå°†æ­¤routineåŠ å…¥é€šçŸ¥åˆ—è¡¨,å¹¶ç­‰å¾…è·å–é€šçŸ¥,è°ƒç”¨æ­¤æ–¹æ³•å¿…é¡»å…ˆLock,ä¸ç„¶æ–¹æ³•é‡Œä¼šè°ƒç”¨Unlock(),æŠ¥é”™.
func (c *Cond) Wait() {
    c.checker.check()   //æ£€æŸ¥æ˜¯å¦è¢«å¤åˆ¶
    t := runtime_notifyListAdd(&amp;c.notify) //åŠ å…¥é€šçŸ¥åˆ—è¡¨
    c.L.Unlock() // é‡Šæ”¾é”
    runtime_notifyListWait(&amp;c.notify, t) //ç­‰å¾…é€šçŸ¥
    c.L.Lock() //è¢«é€šçŸ¥äº†,è·å–é”,ç»§ç»­è¿è¡Œ
}
Signal
//å”¤é†’åœ¨Waitçš„routineä¸­çš„ä¸€ä¸ª
    func (c *Cond) Signal() {
    c.checker.check() //æ£€æŸ¥æ˜¯å¦è¢«å¤åˆ¶
    runtime_notifyListNotifyOne(&amp;c.notify) //é€šçŸ¥ç­‰å¾…åˆ—è¡¨ä¸­çš„ä¸€ä¸ª
}
Broadcast
//å”¤é†’æ‰€æœ‰ç­‰å¾…çš„
func (c *Cond) Broadcast() {
    c.checker.check()
    runtime_notifyListNotifyAll(&amp;c.notify)
}</p>

<p>æ¡ä»¶å˜é‡sync.Condæœ¬è´¨ä¸Šæ˜¯ä¸€äº›æ­£åœ¨ç­‰å¾…æŸä¸ªæ¡ä»¶çš„çº¿ç¨‹çš„åŒæ­¥æœºåˆ¶ã€‚</p>

<p>sync.Cond ä¸»è¦å®ç°ä¸€ä¸ªæ¡ä»¶å˜é‡ï¼Œå‡å¦‚ goroutine A æ‰§è¡Œå‰éœ€è¦ç­‰å¾…å¦å¤–çš„goroutine B çš„é€šçŸ¥ï¼Œé‚£è¾¹å¤„äºç­‰å¾…çš„goroutine A ä¼šä¿å­˜åœ¨ä¸€ä¸ªé€šçŸ¥åˆ—è¡¨ï¼Œä¹Ÿå°±æ˜¯è¯´éœ€è¦æŸç§å˜é‡çŠ¶æ€çš„goroutine A å°†ä¼šç­‰å¾…/Waitåœ¨é‚£é‡Œï¼Œå½“æŸä¸ªæ—¶åˆ»çŠ¶æ€æ”¹å˜æ—¶è´Ÿè´£é€šçŸ¥çš„goroutine B é€šè¿‡å¯¹æ¡ä»¶å˜é‡é€šçŸ¥çš„æ–¹å¼ï¼ˆBroadcastï¼ŒSignalï¼‰æ¥é€šçŸ¥å¤„äºç­‰å¾…æ¡ä»¶å˜é‡çš„goroutine A, è¿™æ ·ä¾¿å¯é¦–å…ˆä¸€ç§â€œæ¶ˆæ¯é€šçŸ¥â€çš„åŒæ­¥æœºåˆ¶ã€‚</p>

<p>ä»¥goçš„httpå¤„ç†ä¸ºä¾‹ï¼Œåœ¨Goçš„æºç ä¸­httpæ¨¡å—serveréƒ¨åˆ†æºç ä¸­æ‰€ç¤ºï¼Œå½“éœ€è¦å¤„ç†ä¸€ä¸ªæ–°çš„è¿æ¥çš„æ—¶å€™ï¼Œè‹¥è¿æ¥connæ˜¯å®ç°è‡ª<em>tls.Connçš„æƒ…å†µä¸‹ï¼Œä¼šè¿›è¡Œç›¸å…³çš„å®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯çš„â€œæ¡æ‰‹â€å¤„ç†Handshake()ï¼Œ å…¥å£ä»£ç å¦‚ä¸‹
if tlsConn, ok := c.rwc.(</em>tls.Conn); ok {
  if d := c.server.ReadTimeout; d != 0 {
   c.rwc.SetReadDeadline(time.Now().Add(d))
  }
  if d := c.server.WriteTimeout; d != 0 {
   c.rwc.SetWriteDeadline(time.Now().Add(d))
  }
  if err := tlsConn.Handshake(); err != nil {
   c.server.logf(â€œhttp: TLS handshake error from %s: %vâ€, c.rwc.RemoteAddr(), err)
   return
  }
  c.tlsState = new(tls.ConnectionState)
  *c.tlsState = tlsConn.ConnectionState()
  if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {
   if fn := c.server.TLSNextProto[proto]; fn != nil {
    h := initNPNRequest{tlsConn, serverHandler{c.server}}
    fn(c.server, tlsConn, h)
   }
   return
  }</p>

<p>å…¶ä¸­çš„Handshakeå‡½æ•°ä»£ç é€šè¿‡ä½¿ç”¨æ¡ä»¶å˜é‡çš„æ–¹å¼æ¥å¤„ç†æ–°è¿æ¥æ¡æ‰‹è°ƒç”¨çš„åŒæ­¥é—®é¢˜ï¼š
func (c *Conn) Handshake() error {
 c.handshakeMutex.Lock()
 defer c.handshakeMutex.Unlock()</p>

<p>for {
  if err := c.handshakeErr; err != nil {
   return err
  }
  if c.handshakeComplete {
   return nil
  }
  if c.handshakeCond == nil {
   break
  }</p>

<p>c.handshakeCond.Wait()
 }</p>

<p>c.handshakeCond = sync.NewCond(&amp;c.handshakeMutex)
 c.handshakeMutex.Unlock()</p>

<p>c.in.Lock()
 defer c.in.Unlock()</p>

<p>c.handshakeMutex.Lock()</p>

<p>if c.handshakeErr != nil || c.handshakeComplete {
  panic(â€œhandshake should not have been able to complete after handshakeCond was setâ€)
 }</p>

<p>if c.isClient {
  c.handshakeErr = c.clientHandshake()
 } else {
  c.handshakeErr = c.serverHandshake()
 }
 if c.handshakeErr == nil {
  c.handshakes++
 } else {
  c.flush()
 }</p>

<p>if c.handshakeErr == nil &amp;&amp; !c.handshakeComplete {
  panic(â€œhandshake should have had a result.â€)
 }</p>

<p>c.handshakeCond.Broadcast()
 c.handshakeCond = nil</p>

<p>å½“ä½¿ç”¨sync.Condçš„æ—¶å€™æœ‰ä¸¤ç‚¹ç§»åŠ¨è¦æ³¨æ„çš„ï¼š</p>

<p>ä¸€å®šè¦åœ¨è°ƒç”¨cond.Waitæ–¹æ³•å‰ï¼Œé”å®šä¸ä¹‹å…³è”çš„è¯»å†™é”
ä¸€å®šä¸è¦å¿˜è®°åœ¨cond.Waitåï¼Œè‹¥æ•°æ®å·²ç»å¤„ç†å®Œæ¯•ï¼Œåœ¨è¿”å›å‰è¦å¯¹ä¸ä¹‹å…³è”çš„è¯»å†™é”è¿›è¡Œè§£é”ã€‚</p>

<p>å¦‚æœä¸é‡Šæ”¾é”ï¼Œ å…¶å®ƒæ”¶åˆ°ä¿¡å·çš„gouroutineå°†é˜»å¡æ— æ³•ç»§ç»­æ‰§è¡Œã€‚</p>

<p>ä¸¤ä¸ªè¦ç‚¹
Condä¸èƒ½è¢«å¤åˆ¶ï¼šCondåœ¨å†…éƒ¨æŒæœ‰ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—ï¼Œè¿™ä¸ªé˜Ÿåˆ—ç»´æŠ¤æ‰€æœ‰ç­‰å¾…åœ¨è¿™ä¸ªCondçš„goroutineã€‚å› æ­¤è‹¥è¿™ä¸ªCondå…è®¸å€¼ä¼ é€’ï¼Œåˆ™è¿™ä¸ªé˜Ÿåˆ—åœ¨å€¼ä¼ é€’çš„è¿‡ç¨‹ä¸­ä¼šè¿›è¡Œå¤åˆ¶ï¼Œå¯¼è‡´åœ¨å”¤é†’goroutineçš„æ—¶å€™å‡ºç°é”™è¯¯ã€‚
é¡ºåºå”¤é†’ï¼š notifyListå¯¹è±¡æŒæœ‰ä¸¤ä¸ªæ— é™è‡ªå¢çš„å­—æ®µwaitå’Œnotifyï¼Œwaitå­—æ®µåœ¨æœ‰æ–°çš„goroutineç­‰å¾…çš„æ—¶å€™åŠ 1ï¼Œnotifyå­—æ®µåœ¨æœ‰æ–°çš„å”¤é†’ä¿¡å·çš„æ—¶å€™åŠ 1ã€‚åœ¨æœ‰æ–°çš„goroutineåŠ å…¥é˜Ÿåˆ—çš„æ—¶å€™ï¼Œä¼šå°†å½“å‰waitèµ‹å€¼ç»™goroutineçš„ticketï¼Œå”¤é†’çš„æ—¶å€™ä¼šå”¤é†’ticketç­‰äºnotifyçš„gourineã€‚å¦å¤–ï¼Œå½“wait==notifyæ—¶è¡¨ç¤ºæ²¡æœ‰goroutineéœ€è¦è¢«å”¤é†’ï¼Œwait&gt;notifyæ—¶è¡¨ç¤ºæœ‰goroutineéœ€è¦è¢«å”¤é†’ï¼Œwaityæ’å¤§äºç­‰äºnotify
// Condå®ç°äº†ä¸€ä¸ªæ¡ä»¶å˜é‡ï¼Œä¸€ä¸ªç­‰å¾…æˆ–å®£å¸ƒäº‹ä»¶å‘ç”Ÿçš„goroutinesçš„é›†åˆç‚¹ã€‚
//
// æ¯ä¸ªCondéƒ½æœ‰ä¸€ä¸ªç›¸å…³çš„Locker Lï¼ˆé€šå¸¸æ˜¯* Mutexæˆ–* RWMutexï¼‰ã€‚
type Cond struct {
    // ä¸å…è®¸å¤åˆ¶,ä¸€ä¸ªç»“æ„ä½“,æœ‰ä¸€ä¸ªLock()æ–¹æ³•,åµŒå…¥åˆ«çš„ç»“æ„ä½“ä¸­,è¡¨ç¤ºä¸å…è®¸å¤åˆ¶
    // noCopyå¯¹è±¡ï¼Œæ‹¥æœ‰ä¸€ä¸ªLockæ–¹æ³•ï¼Œä½¿å¾—Condå¯¹è±¡åœ¨è¿›è¡Œgo vetæ‰«æçš„æ—¶å€™ï¼Œèƒ½å¤Ÿè¢«æ£€æµ‹åˆ°æ˜¯å¦è¢«å¤åˆ¶
    noCopy noCopy</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// é”çš„å…·ä½“å®ç°ï¼Œé€šå¸¸ä¸º mutex æˆ–è€…rwmutex
L Locker
 
// é€šçŸ¥åˆ—è¡¨,è°ƒç”¨Wait()æ–¹æ³•çš„goroutineä¼šè¢«æ”¾å…¥listä¸­,æ¯æ¬¡å”¤é†’,ä»è¿™é‡Œå–å‡º
// notifyListå¯¹è±¡ï¼Œç»´æŠ¤ç­‰å¾…å”¤é†’çš„goroutineé˜Ÿåˆ—,ä½¿ç”¨é“¾è¡¨å®ç°
// åœ¨ sync åŒ…ä¸­è¢«å®ç°ï¼Œ src/sync/runtime.go
notify  notifyList
 
// å¤åˆ¶æ£€æŸ¥,æ£€æŸ¥condå®ä¾‹æ˜¯å¦è¢«å¤åˆ¶
// copyCheckerå¯¹è±¡ï¼Œå®é™…ä¸Šæ˜¯uintptrå¯¹è±¡ï¼Œä¿å­˜è‡ªèº«å¯¹è±¡åœ°å€
checker copyChecker
</code></pre></div></div>

<p>}</p>

<p>// NewCondæ–¹æ³•ä¼ å…¥ä¸€ä¸ªå®ç°äº†Lockeræ¥å£çš„å¯¹è±¡ï¼Œè¿”å›ä¸€ä¸ªæ–°çš„Condå¯¹è±¡æŒ‡é’ˆï¼Œ
// ä¿è¯åœ¨å¤šgoroutineä½¿ç”¨condçš„æ—¶å€™ï¼ŒæŒæœ‰çš„æ˜¯åŒä¸€ä¸ªå®ä¾‹
func NewCond(l Locker) *Cond {
    return &amp;Cond{L: l}
}</p>

<p>// ç­‰å¾…åŸå­è§£é”c.Lå¹¶æš‚åœæ‰§è¡Œè°ƒç”¨goroutineã€‚
// ç¨åæ¢å¤æ‰§è¡Œåï¼ŒWaitä¼šåœ¨è¿”å›ä¹‹å‰é”å®šc.L.
// ä¸å…¶ä»–ç³»ç»Ÿä¸åŒï¼Œé™¤éè¢«å¹¿æ’­æˆ–ä¿¡å·å”¤é†’ï¼Œå¦åˆ™ç­‰å¾…æ— æ³•è¿”å›ã€‚</p>

<p>// å› ä¸ºç­‰å¾…ç¬¬ä¸€æ¬¡æ¢å¤æ—¶c.Læ²¡æœ‰è¢«é”å®šï¼Œ
// æ‰€ä»¥å½“Waitè¿”å›æ—¶ï¼Œè°ƒç”¨è€…é€šå¸¸ä¸èƒ½è®¤ä¸ºæ¡ä»¶ä¸ºçœŸã€‚
// ç›¸åï¼Œè°ƒç”¨è€…åº”è¯¥å¾ªç¯ç­‰å¾…ï¼š</p>

<p>//    c.L.Lock()
//    for !condition() {
//        c.Wait()
//    }
//    â€¦ make use of condition â€¦
//    c.L.Unlock()
//</p>

<p>// è°ƒç”¨æ­¤æ–¹æ³•ä¼šå°†æ­¤routineåŠ å…¥é€šçŸ¥åˆ—è¡¨,å¹¶ç­‰å¾…è·å–é€šçŸ¥,è°ƒç”¨æ­¤æ–¹æ³•å¿…é¡»å…ˆLock,ä¸ç„¶æ–¹æ³•é‡Œä¼šè°ƒç”¨Unlock(),æŠ¥é”™
//
func (c *Cond) Wait() {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// æ£€æŸ¥æ˜¯å¦è¢«å¤åˆ¶; å¦‚æœæ˜¯å°±panic
// checkæ£€æŸ¥ï¼Œä¿è¯condåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åæ²¡æœ‰è¢«å¤åˆ¶
c.checker.check()
// å°†å½“å‰goroutineåŠ å…¥ç­‰å¾…é˜Ÿåˆ—, è¯¥æ–¹æ³•åœ¨ runtime åŒ…çš„ notifyListAdd å‡½æ•°ä¸­å®ç°
// src/runtime/sema.go
t := runtime_notifyListAdd(&amp;c.notify)
// é‡Šæ”¾é”,
// å› æ­¤åœ¨è°ƒç”¨Waitæ–¹æ³•å‰ï¼Œå¿…é¡»ä¿è¯è·å–åˆ°äº†condçš„é”ï¼Œå¦åˆ™ä¼šæŠ¥é”™
c.L.Unlock()
 
// ç­‰å¾…é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰çš„goroutineæ‰§è¡Œç­‰å¾…å”¤é†’æ“ä½œ
// å°†å½“å‰goroutineæŒ‚èµ·ï¼Œç­‰å¾…å”¤é†’ä¿¡å·
// è¯¥æ–¹æ³•åœ¨ runtime åŒ…çš„ notifyListWait å‡½æ•°ä¸­å®ç°
// src/runtime/sema.go
runtime_notifyListWait(&amp;c.notify, t)
// è¢«é€šçŸ¥äº†,è·å–é”,ç»§ç»­è¿è¡Œ
c.L.Lock() }
</code></pre></div></div>

<p>//
// å”¤é†’å•ä¸ª ç­‰å¾…çš„ goroutine
func (c *Cond) Signal() {
    // æ£€æŸ¥cæ˜¯å¦æ˜¯è¢«å¤åˆ¶çš„ï¼Œå¦‚æœæ˜¯å°±panic
    // ä¿è¯condåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åæ²¡æœ‰è¢«å¤åˆ¶
    c.checker.check()
    // é€šçŸ¥ç­‰å¾…åˆ—è¡¨ä¸­çš„ä¸€ä¸ª
    // é¡ºåºå”¤é†’ä¸€ä¸ªç­‰å¾…çš„gorountine
    // åœ¨runtime åŒ…çš„ notifyListNotifyOne å‡½æ•°ä¸­è¢«å®ç°
    // src/runtime/sema.go
    runtime_notifyListNotifyOne(&amp;c.notify)
}</p>

<p>// å”¤é†’ç­‰å¾…é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰goroutineã€‚
func (c *Cond) Broadcast() {
    // æ£€æŸ¥cæ˜¯å¦æ˜¯è¢«å¤åˆ¶çš„ï¼Œå¦‚æœæ˜¯å°±panic
    // ä¿è¯condåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åæ²¡æœ‰è¢«å¤åˆ¶
    c.checker.check()
    // å”¤é†’ç­‰å¾…é˜Ÿåˆ—ä¸­æ‰€æœ‰çš„goroutine
    // æœ‰runtime åŒ…çš„ notifyListNotifyAll å‡½æ•°å®ç°
    // src\runtime\sema.go
    runtime_notifyListNotifyAll(&amp;c.notify)
}</p>

<p>// copyCheckerä¿æŒæŒ‡å‘è‡ªèº«çš„æŒ‡é’ˆä»¥æ£€æµ‹å¯¹è±¡å¤åˆ¶ã€‚
type copyChecker uintptr</p>

<p>// æ£€æŸ¥cæ˜¯å¦è¢«å¤åˆ¶ï¼Œå¦‚æœæ˜¯åˆ™panic
/**
checkæ–¹æ³•åœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨çš„æ—¶å€™ï¼Œä¼šå°†checkerå¯¹è±¡åœ°å€èµ‹å€¼ç»™checkerï¼Œä¹Ÿå°±æ˜¯å°†è‡ªèº«å†…å­˜åœ°å€èµ‹å€¼ç»™è‡ªèº«
 <em>/
func (c *copyChecker) check() {
    /**
    å› ä¸º copyCheckerçš„åº•å±‚ç±»å‹ä¸º uintptr
    é‚£ä¹ˆ è¿™é‡Œçš„ *cå…¶å®å°±æ˜¯ copyCheckerç±»å‹æœ¬èº«ï¼Œç„¶åå¼ºè½¬æˆuintptr
    å’Œæ‹¿ç€ c ä¹Ÿå°±æ˜¯copyCheckerçš„æŒ‡é’ˆå»æ±‚ uintptrï¼Œç†è®ºä¸Šè¦æƒ³ç­‰
    å³ï¼šå†…å­˜åœ°å€ä¸ºä¸€æ ·ï¼Œåˆ™è¡¨ç¤ºæ²¡æœ‰è¢«å¤åˆ¶
     */
     // ä¸‹è¿°åšæ³•æ˜¯ï¼š
     // å…¶å® copyCheckerä¸­å­˜å‚¨çš„å¯¹è±¡åœ°å€å°±æ˜¯ copyChecker å¯¹è±¡è‡ªèº«çš„åœ°å€
     // å…ˆæŠŠ copyChecker å¤„å­˜å‚¨çš„å¯¹è±¡åœ°å€å’Œè‡ªå·±é€šè¿‡ unsafe.Pointeræ±‚å‡ºæ¥çš„å¯¹è±¡åœ°å€ä½œæ¯”è¾ƒï¼Œ
     // å¦‚æœå‘ç°ä¸ç›¸ç­‰ï¼Œé‚£ä¹ˆå°±å°è¯•çš„æ›¿æ¢ï¼Œç”±äºä½¿ç”¨çš„ oldæ˜¯0ï¼Œ
     // åˆ™è¡¨ç¤ºcè¿˜æ²¡æœ‰å¼€è¾Ÿå†…å­˜ç©ºé—´ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåªæœ‰æ˜¯é¦–æ¬¡å¼€è¾Ÿåœ°å€æ‰ä¼šæ›¿æ¢æˆåŠŸ
     // å¦‚æœæ›¿æ¢ä¸æˆåŠŸï¼Œåˆ™è¡¨ç¤º copyCheckerå‡ºæ‰€å­˜å‚¨çš„åœ°å€å’Œ unsafeè®¡ç®—å‡ºæ¥çš„ä¸ä¸€è‡´
     // åˆ™è¡¨ç¤ºå¯¹è±¡æ˜¯è¢«å¤åˆ¶äº†
    if uintptr(</em>c) != uintptr(unsafe.Pointer(c)) &amp;&amp;
        !atomic.CompareAndSwapUintptr((<em>uintptr)(c), 0, uintptr(unsafe.Pointer(c))) &amp;&amp;
        uintptr(</em>c) != uintptr(unsafe.Pointer(c)) {
        panic(â€œsync.Cond is copiedâ€)
    }
}</p>

<p>// noCopyå¯ä»¥åµŒå…¥åˆ°ç»“æ„ä¸­ï¼Œåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åä¸å¾—å¤åˆ¶ã€‚
//
// è¯¦ç»†ä»‹ç»è¯·æŸ¥çœ‹ï¼š https://github.com/golang/go/issues/8005#issuecomment-190753527
type noCopy struct{}</p>

<p>// Lock is a no-op used by -copylocks checker from <code class="language-plaintext highlighter-rouge">go vet</code>.
// Lock æ˜¯æœ‰ go vet å‘½ä»¤æ¥åˆ¤æ–­æ˜¯å¦æœ‰ copy çš„æ£€æŸ¥çš„
func (*noCopy) Lock() {}</p>

<p>// sync/runtime.go
// ä½¿ç”¨é“¾è¡¨å®ç°
type notifyList struct {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wait   uint32       // ç­‰å¾…æ•°
notify uint32       // å”¤é†’æ•°
lock   uintptr      // ä¿¡å·é”
// ä½¿ç”¨é“¾è¡¨å®ç°
head   unsafe.Pointer   // é˜Ÿåˆ—çš„å½“å‰å¤´
tail   unsafe.Pointer   // é˜Ÿåˆ—çš„å½“å‰å°¾ }
</code></pre></div></div>

<p>Lï¼šå®ç°äº†Lockeræ¥å£çš„é”å¯¹è±¡ï¼Œé€šå¸¸ä½¿ç”¨Mutexæˆ–RWMutexã€‚
/*
package: sync
fileï¼š mutex.go
line: 31
*/
type Locker interface {
     Lock()
     Unlock()
}</p>

<p>notifyï¼šnotifyListå¯¹è±¡ï¼Œç»´æŠ¤ç­‰å¾…å”¤é†’çš„goroutineé˜Ÿåˆ—,ä½¿ç”¨é“¾è¡¨å®ç°ã€‚
/*
package: sync
fileï¼š runtime.go
line: 29  <br />
*/
type notifyList struct {
     wait   uint32
     notify uint32
     lock   uintptr
     head   unsafe.Pointer
     tail   unsafe.Pointer
}</p>

<p>checkerï¼šcopyCheckerå¯¹è±¡ï¼Œå®é™…ä¸Šæ˜¯uintptrå¯¹è±¡ï¼Œä¿å­˜è‡ªèº«å¯¹è±¡åœ°å€ã€‚
/*
package: sync
fileï¼š cond.go
line: 79  <br />
*/  <br />
type copyChecker uintptr</p>

<p>func (c <em>copyChecker) check() {
     if uintptr(</em>c) != uintptr(unsafe.Pointer(c)) &amp;&amp;
            !atomic.CompareAndSwapUintptr((<em>uintptr)(c), 0, uintptr(unsafe.Pointer(c))) &amp;&amp;
            uintptr(</em>c) != uintptr(unsafe.Pointer(c)) {
            panic(â€œsync.Cond is copiedâ€)
     }
}</p>

<p>æ£€æŸ¥å½“å‰checkerçš„åœ°å€æ˜¯å¦ç­‰äºä¿å­˜åœ¨checkerä¸­çš„åœ°å€
å¯¹checkerè¿›è¡ŒåŸå­CASæ“ä½œï¼Œå°†checkerå½“å‰åœ°å€èµ‹å€¼ç»™ä¸ºç©ºçš„checker
é‡å¤æ“ä½œ1ï¼Œé˜²æ­¢åœ¨è¿›è¡Œ1å’Œ2çš„æ—¶å€™ï¼Œæœ‰å…¶ä»–gorountineå¹¶å‘çš„ä¿®æ”¹äº†checkerå€¼
è‹¥1ã€2ã€3éƒ½ä¸æ»¡è¶³ï¼Œåˆ™è¡¨ç¤ºå½“å‰condæ˜¯å¤åˆ¶çš„ï¼ŒæŠ›å‡ºpanic</p>

<p>checkæ–¹æ³•åœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨çš„æ—¶å€™ï¼Œä¼šå°†checkerå¯¹è±¡åœ°å€èµ‹å€¼ç»™checkerï¼Œä¹Ÿå°±æ˜¯å°†è‡ªèº«å†…å­˜åœ°å€èµ‹å€¼ç»™è‡ªèº«ã€‚
å†æ¬¡è°ƒç”¨checkeræ–¹æ³•çš„æ—¶å€™ï¼Œä¼šå°†å½“å‰checkeråœ°å€çš„å€¼ä¸ä¿å­˜çš„checkeråœ°å€å€¼è¿›è¡Œæ¯”è¾ƒï¼Œè‹¥ä¸ç›¸åŒåˆ™è¡¨ç¤ºå½“å‰checkerçš„åœ°å€ä¸æ˜¯ç¬¬ä¸€æ¬¡è°ƒç”¨checkæ–¹æ³•æ—¶å€™çš„åœ°å€ï¼Œå³condå¯¹è±¡è¢«å¤åˆ¶äº†ï¼Œcheckerè¢«é‡æ–°åˆ†é…äº†å†…å­˜åœ°å€ã€‚</p>

<p>æ–¹æ³•
NwoCond
/*
package: sync
fileï¼š cond.go
line: 32  <br />
*/  <br />
func NewCond(l Locker) *Cond {
    return &amp;Cond{L: l}
}</p>

<p>NewCondæ–¹æ³•ä¼ å…¥ä¸€ä¸ªå®ç°äº†Lockeræ¥å£çš„å¯¹è±¡ï¼Œè¿”å›ä¸€ä¸ªæ–°çš„Condå¯¹è±¡æŒ‡é’ˆï¼Œä¿è¯åœ¨å¤šgoroutineä½¿ç”¨condçš„æ—¶å€™ï¼ŒæŒæœ‰çš„æ˜¯åŒä¸€ä¸ªå®ä¾‹ã€‚
Wait
/*
package: sync
fileï¼š cond.go
line: 52  <br />
*/
func (c *Cond) Wait() {
    c.checker.check() //step 1
    t := runtime_notifyListAdd(&amp;c.notify) //step 2
    c.L.Unlock() //step 3
    runtime_notifyListWait(&amp;c.notify, t) //step 4
    c.L.Lock() //step 5
}</p>

<p>checkæ£€æŸ¥ï¼Œä¿è¯condåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åæ²¡æœ‰è¢«å¤åˆ¶
å°†notifyé˜Ÿåˆ—çš„ç­‰å¾…æ•°åŠ 1,å¹¶å°†ä¹‹å‰çš„ç­‰å¾…æ•°è¿”å›
 /*
 package: runtime
 fileï¼š sema.go
 line: 476<br />
 */
 func notifyListAdd(l *notifyList) uint32 {
     return atomic.Xadd(&amp;l.wait, 1) - 1
 }</p>

<p>é‡Šæ”¾é”ï¼Œå› æ­¤åœ¨è°ƒç”¨Waitæ–¹æ³•å‰ï¼Œå¿…é¡»ä¿è¯è·å–åˆ°äº†condçš„é”ï¼Œå¦åˆ™ä¼šæŠ¥é”™
å°†å½“å‰goroutineæŒ‚èµ·ï¼Œç­‰å¾…å”¤é†’ä¿¡å·
/*
package: runtime
fileï¼š sema.go
line: 485<br />
*/
func notifyListWait(l *notifyList, t uint32) {
   lock(&amp;l.lock) //step a</p>

<p>if less(t, l.notify) { //step b
       unlock(&amp;l.lock)
       return
   }</p>

<p>s := acquireSudog() //step c
   s.g = getg()
   s.ticket = t
   s.releasetime = 0
   t0 := int64(0)
   if blockprofilerate &gt; 0 {
       t0 = cputicks()
       s.releasetime = -1
   }
   if l.tail == nil { //step d
       l.head = s
   } else {
       l.tail.next = s
   }
   l.tail = s
   goparkunlock(&amp;l.lock, â€œsemacquireâ€, traceEvGoBlockCond, 3) //step e
   if t0 != 0 {
       blockevent(s.releasetime-t0, 2)
   }
   releaseSudog(s)
}</p>

<p>a. é”å®šnotifyé˜Ÿåˆ—
b. å¦‚æœnotifé˜Ÿåˆ—çš„ç­‰å¾…æ•°å°äºå”¤é†’æ•° è¡¨ç¤ºå½“å‰goroutineä¸éœ€è¦å†è¿›è¡Œç­‰å¾…ï¼Œåˆ™è§£é”notifyé˜Ÿåˆ—ï¼Œç›´æ¥è¿”å›
c. è·å–å½“å‰goroutineï¼Œè®¾ç½®ç›¸å…³å‚æ•°ï¼Œå°†å½“å‰ç­‰å¾…æ•°èµ‹å€¼ç»™ticket
d. å°†å½“å‰goroutineåŠ å…¥åˆ°notifyé˜Ÿåˆ—ä¸­
e. å°†å½“å‰goroutineæŒ‚èµ·ï¼Œç­‰å¾…å”¤é†’ä¿¡å·</p>

<p>gorountineè¢«å”¤é†’ï¼Œé‡æ–°è·å–é”</p>

<p>Signal
/*
package: sync
fileï¼š cond.go
line: 64<br />
*/
func (c *Cond) Signal() {
    c.checker.check() //step 1
    runtime_notifyListNotifyOne(&amp;c.notify) //step 2
}</p>

<p>checkæ£€æŸ¥ï¼Œä¿è¯condåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åæ²¡æœ‰è¢«å¤åˆ¶</p>

<p>é¡ºåºå”¤é†’ä¸€ä¸ªç­‰å¾…çš„gorountine
/*
package: runtime
fileï¼š sema.go
line: 485<br />
*/
func notifyListNotifyOne(l *notifyList) {</p>

<p>if atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) { //step a
        return
   }</p>

<p>lock(&amp;l.lock) //step b</p>

<p>t := l.notify
   if t == atomic.Load(&amp;l.wait) {
        unlock(&amp;l.lock)
        return
   }</p>

<p>atomic.Store(&amp;l.notify, t+1)</p>

<p>for p, s := (*sudog)(nil), l.head; s != nil; p, s = s, s.next { //step c
        if s.ticket == t {
           n := s.next
           if p != nil {
               p.next = n
           } else {
               l.head = n
           }
           if n == nil {
               l.tail = p
           }
           unlock(&amp;l.lock)
           s.next = nil
           readyWithTime(s, 4)
           return
       }
   }
   unlock(&amp;l.lock)
}</p>

<p>a. å¦‚æœnotifyé˜Ÿåˆ—çš„ç­‰å¾…æ•°ç­‰äºå”¤é†’æ•°ï¼Œè¡¨ç¤ºæ²¡æœ‰æ–°çš„goroutineåœ¨ç­‰å¾…é˜Ÿåˆ—ä¸Šï¼Œä¸éœ€è¦å”¤é†’ä»»ä½•goroutine
b. é”å®šnotifyé˜Ÿåˆ—ï¼Œå¯¹é˜Ÿåˆ—è¿›è¡ŒåŒæ£€æŸ¥ï¼ŒæŸ¥çœ‹æ˜¯å¦æœ‰æ–°çš„goroutineéœ€è¦è¢«å”¤é†’ï¼Œè‹¥æ— åˆ™å°†å”¤é†’æ•°åŠ 1
c. éå†ç­‰å¾…å”¤é†’çš„goroutineé˜Ÿåˆ—ï¼Œå”¤é†’ticketç­‰äºå”¤é†’æ•°çš„goroutineï¼Œå³é¡ºåºå”¤é†’ä¸€ä¸ªæœ€å…ˆåŠ å…¥ç­‰å¾…é˜Ÿåˆ—çš„goroutine</p>

<p>Broadcast
/*
package: sync
fileï¼š cond.go
line: 73<br />
*/
func (c *Cond) Broadcast() {
    c.checker.check()
    runtime_notifyListNotifyAll(&amp;c.notify)
}</p>

<p>checkæ£€æŸ¥ï¼Œä¿è¯condåœ¨ç¬¬ä¸€æ¬¡ä½¿ç”¨åæ²¡æœ‰è¢«å¤åˆ¶</p>

<p>å”¤é†’æ‰€æœ‰gorountine
/*
package: runtime
fileï¼š sema.go
line: 485<br />
*/
func notifyListNotifyAll(l *notifyList) {</p>

<p>if atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) { //step a
       return
   }</p>

<p>lock(&amp;l.lock) //step b
   s := l.head
   l.head = nil
   l.tail = nil</p>

<p>atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))
   unlock(&amp;l.lock)</p>

<p>for s != nil { //step c
       next := s.next
       s.next = nil
       readyWithTime(s, 4)
       s = next
   }
}</p>

<p>a. å¦‚æœnotifyé˜Ÿåˆ—çš„ç­‰å¾…æ•°ç­‰äºå”¤é†’æ•°ï¼Œè¡¨ç¤ºæ²¡æœ‰æ–°çš„goroutineåœ¨ç­‰å¾…é˜Ÿåˆ—ä¸Šï¼Œä¸éœ€è¦å”¤é†’ä»»ä½•goroutine
b. é”å®šnotifyé˜Ÿåˆ—ï¼Œæ¸…ç©ºç­‰å¾…å”¤é†’é˜Ÿåˆ—ï¼Œå°†ç­‰å¾…æ•°èµ‹å€¼ç»™å”¤é†’æ•°
c. éå†ç­‰å¾…å”¤é†’çš„gorountineé˜Ÿåˆ—ï¼Œå°†æ‰€æœ‰goroutineå”¤é†’</p>

<p>æ€»ç»“</p>

<p>Condä¸èƒ½è¢«å¤åˆ¶ï¼šCondåœ¨å†…éƒ¨æŒæœ‰ä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—ï¼Œè¿™ä¸ªé˜Ÿåˆ—ç»´æŠ¤æ‰€æœ‰ç­‰å¾…åœ¨è¿™ä¸ªCondçš„goroutineã€‚å› æ­¤è‹¥è¿™ä¸ªCondå…è®¸å€¼ä¼ é€’ï¼Œåˆ™è¿™ä¸ªé˜Ÿåˆ—åœ¨å€¼ä¼ é€’çš„è¿‡ç¨‹ä¸­ä¼šè¿›è¡Œå¤åˆ¶ï¼Œå¯¼è‡´åœ¨å”¤é†’goroutineçš„æ—¶å€™å‡ºç°é”™è¯¯ã€‚
é¡ºåºå”¤é†’ï¼š notifyListå¯¹è±¡æŒæœ‰ä¸¤ä¸ªæ— é™è‡ªå¢çš„å­—æ®µwaitå’Œnotifyï¼Œwaitå­—æ®µåœ¨æœ‰æ–°çš„goroutineç­‰å¾…çš„æ—¶å€™åŠ 1ï¼Œnotifyå­—æ®µåœ¨æœ‰æ–°çš„å”¤é†’ä¿¡å·çš„æ—¶å€™åŠ 1ã€‚åœ¨æœ‰æ–°çš„goroutineåŠ å…¥é˜Ÿåˆ—çš„æ—¶å€™ï¼Œä¼šå°†å½“å‰waitèµ‹å€¼ç»™goroutineçš„ticketï¼Œå”¤é†’çš„æ—¶å€™ä¼šå”¤é†’ticketç­‰äºnotifyçš„gourineã€‚å¦å¤–ï¼Œå½“wait==notifyæ—¶è¡¨ç¤ºæ²¡æœ‰goroutineéœ€è¦è¢«å”¤é†’ï¼Œwait&gt;notifyæ—¶è¡¨ç¤ºæœ‰goroutineéœ€è¦è¢«å”¤é†’ï¼Œwaityæ’å¤§äºç­‰äºnotifyã€‚</p>
:ET