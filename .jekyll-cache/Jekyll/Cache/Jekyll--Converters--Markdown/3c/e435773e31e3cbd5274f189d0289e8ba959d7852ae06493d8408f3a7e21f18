I"ù<p>è¿‡æ—©åœ°éƒ¨ç½²è¿™ç§è¡Œä¸ºéå¸¸ç²—é²ï¼Œå°¤å…¶æ˜¯åœ¨éƒ¨ç½²æ—¶è¿˜è¦ä¸­æ–­ç”¨æˆ·è¯·æ±‚çš„æƒ…å†µä¸‹æ›´æ˜¯å¦‚æ­¤ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬åœ¨Betableæ„å»ºçš„GoæœåŠ¡è¦åœ¨ä¸ä¸­æ–­ä»»ä½•ç”¨æˆ·è¯·æ±‚çš„æƒ…å†µä¸‹ä¼˜é›…åœ°ä¸­æ­¢æœåŠ¡ã€‚å…¶åŸºæœ¬æ€æƒ³å°±æ˜¯åœæ­¢ä¾¦å¬ï¼ˆllisteningï¼‰ï¼Œå‡å®šä¼šæœ‰ä¸€ä¸ªæ–°çš„è¿›ç¨‹æ¥æ¥ç®¡è¿™äº›ä¾¦å¬ï¼Œè®©æ‰€æœ‰å·²ç»å»ºç«‹èµ·æ¥çš„è¿æ¥åœ¨æœ€ç»ˆåœæ­¢æœåŠ¡å‰ç»§ç»­å¤„ç†è¿›è¡Œä¸­çš„è¯·æ±‚ã€‚é¡ºä¾¿è¯´ä¸€å¥ï¼Œæˆ‘ä»¬é‡‡ç”¨äº†goagainï¼Œä»è€Œå¯ä»¥ç”šè‡³åœ¨ä¸åœæ­¢ä¾¦å¬çš„æƒ…å†µä¸‹é‡å¯æœåŠ¡ï¼Œä½†è¿™ä¸ªè¯é¢˜è¶…å‡ºäº†æœ¬æ–‡çš„è®¨è®ºèŒƒå›´ã€‚</p>

<p>main.mainåšäº†å››ä»¶äº‹æƒ…ï¼šä¾¦å¬ã€ç”Ÿæˆä¸€ä¸ªServiceå¹¶å°†å…¶å‘é€åˆ°åå°ï¼ˆbackgroundï¼‰æ‰§è¡Œã€é˜»å¡ç›´åˆ°æ”¶åˆ°ç›¸åº”çš„ä¿¡å·ï¼ˆsignalï¼‰ã€ ç„¶åä¼˜é›…çš„åœæ­¢æœåŠ¡ã€‚ä¾¦å¬ä»¥åŠä¿¡å·å¤„ç†å®Œå…¨å‡ºè‡ªäºæ ‡å‡†åº“çš„ä¸€èˆ¬å¥—è·¯ï¼Œåªæœ‰ä¸€ç‚¹ä»¤æˆ‘ååˆ†æ¼ç«ï¼Œå°±æ˜¯ï¼Œä¸ä»…éœ€è¦ä½¿ç”¨anet.Listeneræˆ–è€…net.Conntoè°ƒç”¨SetDeadlineï¼Œç«Ÿç„¶è¿˜éœ€è¦<em>net.TCPListeneræˆ–è€…</em>net.TCPConnandã€‚</p>

<p>service.Serve(listener)ç”¨æ¥æ¥å—è¿æ¥è¯·æ±‚å¹¶åœ¨å®ƒè‡ªå·±çš„goroutineä¹‹å†…å¤„ç†å®ƒæ‰€æ¥å—çš„æ¯ä¸ªè¿æ¥è¯·æ±‚ã€‚ç”±äºå®ƒè®¾ç½®äº†ä¸€ä¸ªæˆªè‡³æ—¶é—´ï¼Œæ‰€ä»¥listener.AcceptTCP()ä¸ä¼šæ°¸ä¹…æ€§åœ°å¤„äºé˜»å¡çŠ¶æ€ï¼Œè€Œä¸”å®ƒè¿˜ä¼šåœ¨ä¸‹ä¸€è½®å¾ªç¯æ—¶æ£€æŸ¥å®ƒæ˜¯å¦åº”è¯¥åœæ­¢ä¾¦å¬ã€‚</p>

<p>service.serve(conn)è¿›è¡Œè¯»å†™æ“ä½œï¼Œè€Œä¸”åŒæ ·çš„ï¼Œå®ƒä¹Ÿå…·æœ‰ä¸€ä¸ªæˆªè‡³æ—¶é—´ã€‚ç”±äºå®ƒè®¾ç½®äº†æˆªè‡³æ—¶é—´ï¼Œæ‰€ä»¥conn.Read(buf)ä¸ä¼šæ°¸ä¹…æ€§åœ°å¤„äºé˜»å¡çŠ¶æ€ï¼Œè€Œä¸”åœ¨å†™å…¥å“åº”æ•°æ®å’Œè¯»å–ä¸‹ä¸€ä¸ªè¯·æ±‚ä¹‹é—´æˆ–è€…è¶…è¿‡äº†conn.Read(buf)æˆªè‡³æ—¶é—´åï¼Œæ£€æŸ¥å®ƒæ˜¯å¦åº”è¯¥å…³é—­è¯¥è¿æ¥ã€‚</p>

<p>å› ä¸ºä¸ä¼šæœ‰åˆ«çš„ä¸œè¥¿å‘é€åˆ°serviceçš„channelä¸­ï¼Œåªæœ‰åœ¨service.Stop()å…³é—­è¯¥channelåæ‰ä¼šå‘è¯¥channelä¸­å‘é€ä¸€ä¸ªå€¼ï¼Œæ‰€ä»¥ï¼Œåªè¦ä»serviceçš„channelä¸­æ¥æ”¶åˆ°ä¸€ä¸ªå€¼ï¼Œå„ä¸ªgoroutineå°±ä¼šå†³å®šå…³é—­ç›¸å…³çš„è¿æ¥å’Œä¾¦å¬å™¨ï¼ˆlistenerï¼‰ã€‚</p>

<p>éš¾é¢˜çš„æœ€åä¸€ä¸ªéƒ¨åˆ†æ˜¯é€šè¿‡è°ƒç”¨æ ‡å‡†åº“sync.WaitGroupå®ç°ç­‰å¾…æ‰€æœ‰çš„goroutineç»“æŸæ‰§è¡Œã€‚
<!-- more -->
package main</p>

<p>import (
	â€œlogâ€
	â€œnetâ€
	â€œosâ€
	â€œos/signalâ€
	â€œsyncâ€
	â€œsyscallâ€
	â€œtimeâ€
)</p>

<p>// An uninteresting service.
type Service struct {
	ch        chan bool
	waitGroup *sync.WaitGroup
}</p>

<p>// Make a new Service.
func NewService() *Service {
	return &amp;Service{
		ch:        make(chan bool),
		waitGroup: &amp;sync.WaitGroup{},
	}
}</p>

<p>// Accept connections and spawn a goroutine to serve each one.  Stop listening
// if anything is received on the serviceâ€™s channel.
func (s <em>Service) Serve(listener *net.TCPListener) {
	s.waitGroup.Add(1)
	defer s.waitGroup.Done()
	for {
		select {
		case &lt;-s.ch:
			log.Println(â€œstopping listening onâ€, listener.Addr())
			listener.Close()
			return
		default:
		}
		listener.SetDeadline(time.Now().Add(1e9))
		conn, err := listener.AcceptTCP()
		if nil != err {
			if opErr, ok := err.(</em>net.OpError); ok &amp;&amp; opErr.Timeout() {
				continue
			}
			log.Println(err)
		}
		log.Println(conn.RemoteAddr(), â€œconnectedâ€)
		go s.serve(conn)
	}
}</p>

<p>// Stop the service by closing the serviceâ€™s channel.  Block until the service
// is really stopped.
func (s *Service) Stop() {
	close(s.ch)
	s.waitGroup.Wait()
}</p>

<p>// Serve a connection by reading and writing what was read.  Thatâ€™s right, this
// is an echo service.  Stop reading and writing if anything is received on the
// serviceâ€™s channel but only after writing what was read.
func (s <em>Service) serve(conn *net.TCPConn) {
	defer conn.Close()
	s.waitGroup.Add(1)
	defer s.waitGroup.Done()
	for {
		select {
		case &lt;-s.ch:
			log.Println(â€œdisconnectingâ€, conn.RemoteAddr())
			return
		default:
		}
		conn.SetDeadline(time.Now().Add(1e9))
		buf := make([]byte, 4096)
		if _, err := conn.Read(buf); nil != err {
			if opErr, ok := err.(</em>net.OpError); ok &amp;&amp; opErr.Timeout() {
				continue
			}
			log.Println(err)
			return
		}
		if _, err := conn.Write(buf); nil != err {
			log.Println(err)
			return
		}
	}
}</p>

<p>func main() {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Listen on 127.0.0.1:48879.  That's my favorite port number because in
// hex 48879 is 0xBEEF.
laddr, err := net.ResolveTCPAddr("tcp", "127.0.0.1:48879")
if nil != err {
	log.Fatalln(err)
}
listener, err := net.ListenTCP("tcp", laddr)
if nil != err {
	log.Fatalln(err)
}
log.Println("listening on", listener.Addr())

// Make a new service and send it into the background.
service := NewService()
go service.Serve(listener)

// Handle SIGINT and SIGTERM.
ch := make(chan os.Signal)
signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
log.Println(&lt;-ch)

// Stop the service gracefully.
service.Stop()
</code></pre></div></div>

<p>}</p>
:ET