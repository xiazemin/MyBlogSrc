I"ïK<p>Golangçš„ç»“æ„ä½“å¯ä»¥å¢åŠ ç±»ä¼¼äºJavaé‡Œé¢@JsonProperty(â€œidâ€)æ³¨é‡Šã€‚åœ¨ç»“æ„ä½“é‡Œé¢é€šè¿‡åå¼•å·åŒ…å«çš„å­—ç¬¦ä¸²è¢«ç§°ä¸ºTagã€‚</p>

<p>type Cyeam struct {
	Url   string <code class="language-plaintext highlighter-rouge">json:"url"</code>
	Other string <code class="language-plaintext highlighter-rouge">json:"-"</code>
}
åœ¨Tagé‡ŒåŠ å…¥å¯¹jsonçš„Tagçš„å®šä¹‰ï¼Œå°±å¯ä»¥å®ç°å¯¹è¾“å‡ºçš„æ ¼å¼æ§åˆ¶ã€‚è€Œä¸”ï¼Œå¦‚æœjsonå­—æ®µçš„Tagå®šä¹‰ä¸º-çš„è¯ï¼Œä¸ä¼šè¢«è§£æã€‚</p>

<p>è¿™ä¹ˆå¼ºå¤§çš„åŠŸèƒ½ï¼Œå€ŸåŠ©reflectåŒ…ï¼Œå®ç°èµ·æ¥ä¹Ÿä¸éš¾ã€‚</p>

<p>c := Cyeam{Url: â€œblog.cyeam.comâ€, Other: â€œâ€¦â€}
var t reflect.Type
t = reflect.TypeOf(c)
var v reflect.Value
v = reflect.ValueOf(c)
json := â€œ{â€œ
for i := 0; i &lt; t.NumField(); i++ {
	if t.Field(i).Tag.Get(â€œjsonâ€) != â€œ-â€œ {
		json += â€œ"â€ + t.Field(i).Tag.Get(â€œjsonâ€) + â€œ":"â€ + v.FieldByName(t.Field(i).Name).String() + â€œ"â€
	}
}
json += â€œ}â€
fmt.Println(json)</p>

<p>{â€œurlâ€:â€blog.cyeam.comâ€}
å¯¹äºæ¯ä¸€ä¸ªå¯¹è±¡ï¼Œéƒ½èƒ½å¤Ÿå¾—åˆ°å®ƒçš„ç±»å‹Typeä»¥åŠå€¼Valueã€‚t.NumField()æ–¹æ³•èƒ½å¤Ÿå¾—åˆ°ç»“æ„ä½“å†…åŒ…å«å€¼çš„æ•°ç›®ï¼Œt.Field(i)èƒ½å¤Ÿå¾—åˆ°ç´¢å¼•å€¼å¤„å˜é‡çš„å€¼Valueã€‚é€šè¿‡è¿™ä¸¤ä¸ªæ–¹æ³•ï¼Œå°±èƒ½å¤Ÿå¯¹ç»“æ„ä½“å˜é‡è¿›è¡Œéå†ã€‚t.Field(i).Tag.Get(â€œjsonâ€)å¯ä»¥è·å–å½“å‰å­—æ®µçš„Tagï¼Œå¹¶ä¸”ä»ä¸­è·å–jsonçš„Tagå€¼ã€‚å¦‚æ­¤ä¸€æ¥ï¼Œå°±èƒ½å¤Ÿå®Œæˆç»“æ„ä½“çš„éå†å’Œæœ€åJSONæµçš„æ‹¼æ¥ç”Ÿæˆã€‚
<!-- more -->
ç›´æ¥æ¥ä¸ªencoding/jsonåŒ…é‡Œçš„func Marshal(v interface{}) ([]byte, error)å’Œfunc Unmarshal(data []byte, v interface{}) errorå°±èƒ½å¯¹Jsonè¿›è¡Œç¼–è§£ç äº†ã€‚å…·ä½“çš„æ–‡ä»¶å°±æ˜¯é‡‡ç”¨åå°„çš„æ–¹æ³•</p>

<p>å¦‚ä¸‹çš„mapéœ€è¦å¤§å®¶æ˜¯å¦‚ä½•è§£æçš„ï¼Ÿ</p>

<p>{â€œ10000000000â€:10000000000,â€111â€:1}
å¦‚æœç›´æ¥å®šä¹‰ä¸€ä¸ªmapæ¥è§£æï¼Œå®šä¹‰æˆmap[string]int64ï¼Œæˆ‘ä»¬æ˜¯è‚¯å®šå¯ä»¥è§£ææˆåŠŸçš„ï¼Œè§£æçš„æ—¶å€™ä¼šå°†æ•°æ®è½¬æ¢ä¸ºæˆ‘ä»¬éœ€è¦çš„æ•°æ®ç±»å‹ã€‚é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼šå¦‚æœæŠŠç±»å‹å®šä¹‰æˆmap[string]interface{}ä¼šæ˜¯å¦‚ä½•è§£æçš„å‘¢ï¼Ÿ</p>

<p>æˆ‘ä¸€ç›´æ˜¯ç”¨æ˜¾ç¤ºå®šä¹‰çš„æ¥è§£æï¼Œä¹Ÿå°±æ˜¯map[string]int64ï¼Œå½“æˆ‘ç”¨map[string]interface{}è§£æçš„æ—¶å€™ï¼Œæˆ‘å°±æƒ³å½“ç„¶çš„è®¤ä¸ºï¼Œinterface{}é‡Œé¢å­˜çš„æ˜¯int64çš„æ•°æ®ã€‚åæ¥è°ƒè¯•äº†ä¸€é€šï¼Œæœ€åæ‰å‘ç°æ˜¯æœ¬æœ«å€’ç½®äº†ã€‚</p>

<p>Jsonæ•°æ®å…¶å®å°±æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œé‡Œé¢æŒ‰ç…§ä¸€å®šçš„æ ¼å¼ä¿å­˜æˆ‘ä»¬çš„æ•°æ®ã€‚Jsonæ”¯æŒçš„æ•°æ®ç±»å‹ä¸Golangè¯­è¨€çš„å…³ç³»å¦‚ä¸‹ï¼š</p>

<p>bool, for JSON booleans
float64, for JSON numbers
string, for JSON strings
[]interface{}, for JSON arrays
map[string]interface{}, for JSON objects
nil for JSON null
æˆ‘ä»¬å¯ä»¥æ³¨æ„åˆ°ï¼ŒJsonæ ¼å¼çš„æ•°å­—å’ŒGolangè¯­è¨€é‡Œé¢çš„float64æ˜¯ç›¸å…³è”çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé»˜è®¤æƒ…å†µä¸‹æ•°å­—ç±»å‹å°†ä¼šè½¬æ¢æˆfloat64ç±»å‹ã€‚å¦‚æœæˆ‘ä»¬æ˜¾ç¤ºçš„æŒ‡å‡ºäº†æ•°å­—ç±»å‹ï¼Œæ¯”å¦‚int64ï¼Œä»–ä¼šå°†æ•°å­—å†è½¬æˆint64ã€‚</p>

<p>æˆ‘ä»¬çœ‹ä¸€ä¸‹æºç ï¼Œencoding/json/decode.go func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool)</p>

<p>unc (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool) {
	â€¦
	switch c := item[0]; c {
		case â€˜nâ€™: // null
		â€¦
		case â€˜tâ€™, â€˜fâ€™: // true, false
		â€¦
		case â€˜â€â€™: // string
		â€¦
		default: // number
		if c != â€˜-â€˜ &amp;&amp; (c &lt; â€˜0â€™ || c &gt; â€˜9â€™) {
			if fromQuoted {
				d.error(fmt.Errorf(â€œjson: invalid use of ,string struct tag, trying to unmarshal %q into %vâ€, item, v.Type()))
			} else {
				d.error(errPhase)
			}
		}
		s := string(item)
		switch v.Kind() {
		default:
			if v.Kind() == reflect.String &amp;&amp; v.Type() == numberType {
				v.SetString(s)
				break
			}
			if fromQuoted {
				d.error(fmt.Errorf(â€œjson: invalid use of ,string struct tag, trying to unmarshal %q into %vâ€, item, v.Type()))
			} else {
				d.error(&amp;UnmarshalTypeError{â€œnumberâ€, v.Type(), int64(d.off)})
			}
		case reflect.Interface:
			n, err := d.convertNumber(s)
			if err != nil {
				d.saveError(err)
				break
			}
			if v.NumMethod() != 0 {
				d.saveError(&amp;UnmarshalTypeError{â€œnumberâ€, v.Type(), int64(d.off)})
				break
			}
			v.Set(reflect.ValueOf(n))</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		n, err := strconv.ParseInt(s, 10, 64)
		if err != nil || v.OverflowInt(n) {
			d.saveError(&amp;UnmarshalTypeError{"number " + s, v.Type(), int64(d.off)})
			break
		}
		v.SetInt(n)

	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
		n, err := strconv.ParseUint(s, 10, 64)
		if err != nil || v.OverflowUint(n) {
			d.saveError(&amp;UnmarshalTypeError{"number " + s, v.Type(), int64(d.off)})
			break
		}
		v.SetUint(n)

	case reflect.Float32, reflect.Float64:
		n, err := strconv.ParseFloat(s, v.Type().Bits())
		if err != nil || v.OverflowFloat(n) {
			d.saveError(&amp;UnmarshalTypeError{"number " + s, v.Type(), int64(d.off)})
			break
		}
		v.SetFloat(n)
	}
} }
</code></pre></div></div>

<p>func (d *decodeState) convertNumber(s string) (interface{}, error) {
	if d.useNumber {
		return Number(s), nil
	}
	f, err := strconv.ParseFloat(s, 64)
	if err != nil {
		return nil, &amp;UnmarshalTypeError{â€œnumber â€œ + s, reflect.TypeOf(0.0), int64(d.off)}
	}
	return f, nil
}
å¯ä»¥çœ‹å‡ºæ¥ï¼ŒJsonè§£æå®ç°çš„æ—¶å€™é€šè¿‡åå°„æ¥åˆ¤æ–­è¦ç”Ÿæˆçš„å…·ä½“çš„ç±»å‹ã€‚å¦‚æœæ˜¯interface{}ç±»å‹ï¼Œé€šè¿‡converNumberæ–¹æ³•è½¬æˆfloat64ï¼ˆé‡Œé¢æ˜¯é€šè¿‡strconv.ParseFloatå®ç°ï¼‰ï¼Œå¦‚æœç±»å‹æ˜¯æ•´å½¢ç›¸å…³ï¼Œé€šè¿‡strconv.ParseIntæ–¹æ³•è½¬æ¢ã€‚æ— ç¬¦å·æ•´å½¢æ˜¯é€šè¿‡strconv.ParseUintå®ç°ã€‚</p>

<p>{â€œbodyâ€:â€{"sn":"aaaa\\/bbbb"}â€}
ç”¨json.Unmarshalæ¥è§£æçš„è¯ï¼Œæ˜¾ç„¶è¦æ˜ å°„åˆ°è¿™æ ·çš„structé‡Œï¼š</p>

<p>Copy
    rawStr := `
{â€œbodyâ€:â€{"sn":"aaaa\\/bbbb"}â€}
`
    data := struct {
        Body string <code class="language-plaintext highlighter-rouge">json:"body"</code>
    }{}
    json.Unmarshal([]byte(rawStr), &amp;data)
è¿™æ ·çš„è¯ æˆ‘å¾—å†å®šä¹‰ä¸€ä¸ªstructï¼Œç„¶åæŠŠbodyçš„stringè§£æå‡ºæ¥ï¼š</p>

<p>Copy
    body := struct {
        Sn string
    }{}
    json.Unmarshal([]byte(data.Body), &amp;body)
èƒ½ä¸èƒ½ä¸€æ¬¡åˆ°ä½ å®šä¹‰å¥½ç»“æ„ä½“ä¸€æ¬¡è§£æåˆ°ä½å‘¢ï¼Ÿ</p>

<p>å› ä¸ºä¹‹å‰æœ‰é€šè¿‡å®ç°encoding.TextMarshaleræ¥å£æ¥å®Œæˆç»“æ„ä½“é‡Œstringå­—æ®µçš„è‡ªå®šä¹‰marshalerï¼Œæ‰€ä»¥ç†æ‰€å½“ç„¶åœ°æƒ³åˆ°å®ç°encoding.TextUnmarshaleræ¥å£æ¥å®Œæˆè‡ªå®šä¹‰çš„unmarshal</p>

<p>Copy
type dataEx struct {
    Body bodyEx
}</p>

<p>type bodyEx struct {
    Sn string
}</p>

<p>func (p *bodyEx) UnmarshalText(text []byte) error {
    return nil
}</p>

<p>func marshalEx(rawStr string) {
    data := &amp;dataEx{}
    err := json.Unmarshal([]byte(rawStr), data)
    if err != nil {
        panic(err)
    }
}
å…ˆæµ‹è¯•ä¸‹ï¼Œåœ¨unmarshaltextæ–¹æ³•ä¸Šæ‰“ä¸Šæ–­ç‚¹ï¼Œæœç„¶åœä½äº†ã€‚</p>

<p>å®ç°unmarshaltextï¼Œå¦‚æœç›´æ¥ç”¨dataExç»“æ„ä½“å»æ¥æ”¶ï¼Œæ˜¯è§£æä¸äº†çš„ï¼Œå› ä¸ºjsonè§£æå™¨åœ¨æ‰«æåˆ°bodyå­—æ®µçš„valueçš„æ—¶å€™ æ˜¯å½“åš jsonçš„stringå¤„ç†çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨UnmarshalTextæ–¹æ³•é‡Œæ‹¿åˆ°çš„å°±æ˜¯é‚£æ®µå­—ç¬¦ä¸²ï¼Œå› æ­¤åªè¦å°†è¿™æ®µå­—ç¬¦ä¸²å†è§£æåˆ°bodyExé‡Œå°±å¥½äº†:
æœ¬æ¥é¢„æƒ³çš„æ˜¯è¿™æ ·å°±okäº†ï¼š</p>

<p>Copy
func (p *bodyEx) UnmarshalText(text []byte) error {
    return json.Unmarshal(text, p)
}
å®é™…è¿è¡Œå‘ç°æŠ¥é”™:</p>

<p>Copy
json: cannot unmarshal object into Go struct field dataEx.Body of type *main.bodyEx
å®é™…ä¸Š è¿™æ®µjsonè§£æåˆ°è¿™æ ·çš„ç»“æ„ä½“ä¸Šåº”è¯¥æ˜¯æ²¡é—®é¢˜çš„ï¼Œç°åœ¨æŠ¥é”™ åªèƒ½è¯´æ˜¯å› ä¸ºæ‰©å±•äº†UnmarshalTextæ–¹æ³•å¯¼è‡´çš„ã€‚å› æ­¤æš‚æ—¶è¿™æ ·å¤„ç†ï¼š</p>

<p>Copy
type dataEx struct {
    Body bodyEx
}</p>

<p>type bodyEx struct {
    Sn string
}
type bodyEx2 bodyEx</p>

<p>func (p *bodyEx) UnmarshalText(text []byte) error {
    t := bodyEx2{}
    err := json.Unmarshal(text, &amp;t)
    if err != nil {
        return err
    }
    *p = bodyEx(t)
    return nil
}
è‡³æ­¤ï¼Œè§£å†³äº†jsoné‡Œè¢«è½¬ä¹‰çš„jsonå­—ç¬¦ä¸²ä¸€æ¬¡è§£æåˆ°ç»“æ„ä½“é‡Œçš„é—®é¢˜ã€‚</p>

<p>å› ä¸ºä¸Šé¢ä½¿ç”¨bodyEx2è¿™æ ·çš„å¤„ç†åªæ˜¯è‡ªå·±çš„çŒœæµ‹å’Œå°è¯•ï¼Œæˆ‘æƒ³çœ‹çœ‹åˆ°åº•ä¸ºå•¥å®ç°äº†UnmarshalTextåå°±ä¸èƒ½è§£æäº†ã€‚å› æ­¤ç¿»çœ‹json.Encode()æºç </p>

<p>scanner#
è¦å®ç°å¯¹jsonå­—ç¬¦ä¸²çš„è§£æï¼Œå®é™…ä¸Šå°±æ˜¯å¯¹è¿™æ®µå­—ç¬¦ä¸²è¿›è¡Œè¯æ³•åˆ†æï¼Œè§£æå‡ºjsoné‡Œçš„ objã€numberã€arrayã€keyã€valueç­‰
jsonåŒ…é‡Œæœ‰ä¸€ä¸ªscannerï¼Œå®ƒå°±æ˜¯ä¸€ä¸ªçŠ¶æ€æœº:</p>

<p>Copy
// A scanner is a JSON scanning state machine.
// Callers call scan.reset() and then pass bytes in one at a time
// by calling scan.step(&amp;scan, c) for each byte.
// The return value, referred to as an opcode, tells the
// caller about significant parsing events like beginning
// and ending literals, objects, and arrays, so that the
// caller can follow along if it wishes.
// The return value scanEnd indicates that a single top-level
// JSON value has been completed, <em>before</em> the byte that
// just got passed in.  (The indication must be delayed in order
// to recognize the end of numbers: is 123 a whole value or
// the beginning of 12345e+6?).
scannerçš„ç»“æ„å¦‚ä¸‹:</p>

<p>Copy
type scanner struct {
    // step æ˜¯éå†ç”¨çš„å‡½æ•°ï¼Œå®ƒä¼šéšç€çŠ¶æ€çš„ä¸åŒè¢«èµ‹äºˆä¸åŒçš„å®ç°æ–¹æ³•
    step func(*scanner, byte) int
    // Reached end of top-level value.
    endTop bool
    // Stack of what weâ€™re in the middle of - array values, object keys, object values.
    parseState []int
    // Error that happened, if any.
    err error
    // total bytes consumed, updated by decoder.Decode
    bytes int64
}
ç®€å•çœ‹ä¸€ä¸‹stateBeginValueçŠ¶æ€å‡½æ•°</p>

<p>Copy</p>

<p>// stateBeginValue æ˜¯å¼€å§‹è¯»å–çš„çŠ¶æ€
func stateBeginValue(s *scanner, c byte) int {
    if c &lt;= â€˜ â€˜ &amp;&amp; isSpace(c) {
        return scanSkipSpace
    }
    switch c {
    case â€˜{â€˜:
        s.step = stateBeginStringOrEmpty
        s.pushParseState(parseObjectKey)
        return scanBeginObject
    case â€˜[â€™:
        s.step = stateBeginValueOrEmpty
        s.pushParseState(parseArrayValue)
        return scanBeginArray
    case â€˜â€â€™:
        s.step = stateInString
        return scanBeginLiteral
    case â€˜-â€˜:
        s.step = stateNeg
        return scanBeginLiteral
    case â€˜0â€™: // beginning of 0.123
        s.step = state0
        return scanBeginLiteral
    case â€˜tâ€™: // beginning of true
        s.step = stateT
        return scanBeginLiteral
    case â€˜fâ€™: // beginning of false
        s.step = stateF
        return scanBeginLiteral
    case â€˜nâ€™: // beginning of null
        s.step = stateN
        return scanBeginLiteral
    }
    if â€˜1â€™ &lt;= c &amp;&amp; c &lt;= â€˜9â€™ { // beginning of 1234.5
        s.step = state1
        return scanBeginLiteral
    }
    return s.error(c, â€œlooking for beginning of valueâ€)
}
ä¸€æ®µæ­£å¸¸çš„jsonï¼Œå¼€å§‹è¯»å–çš„æ—¶å€™(è·³è¿‡ç©ºæ ¼å)ï¼Œå¦‚æœè¯»åˆ°â€™{â€˜nameå°±æ„å‘³ç€æ˜¯ä¸€ä¸ªobjï¼Œå¦‚æœé‡åˆ°â€™[â€˜å°±æ„å‘³ç€æ˜¯ä¸€ä¸ªarrayï¼Œå¦‚æœé‡åˆ°å…¶ä»–çš„ï¼Œéƒ½ä¼šè¿”å›scanBeginLiteralæ ‡è®°ï¼Œè€Œè¿™ä¸ªæ ‡è®°å°±å†³å®šç€unmarshalçš„æ—¶å€™å¦‚ä½•æ˜ å°„åˆ°å¯¹åº”çš„ç»“æ„ä½“é‡Œã€‚
åœ¨decodeStateçš„literalStoreæ–¹æ³•é‡Œï¼Œæœ‰å„ç§å¤„ç†:</p>

<p>Copy</p>

<p>// literalStore decodes a literal stored in item into v.
//
// fromQuoted indicates whether this literal came from unwrapping a
// string from the â€œ,stringâ€ struct tag option. this is used only to
// produce more helpful error messages.
func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool) error {
    // Check for unmarshaler.
    if len(item) == 0 {
        //Empty string given
        d.saveError(fmt.Errorf(â€œjson: invalid use of ,string struct tag, trying to unmarshal %q into %vâ€, item, v.Type()))
        return nil
    }
    isNull := item[0] == â€˜nâ€™ // null
    u, ut, pv := indirect(v, isNull)
    if u != nil {
        return u.UnmarshalJSON(item)
    }
    if ut != nil {
        if item[0] != â€˜â€â€™ {
            if fromQuoted {
                d.saveError(fmt.Errorf(â€œjson: invalid use of ,string struct tag, trying to unmarshal %q into %vâ€, item, v.Type()))
                return nil
            }
            val := â€œnumberâ€
            switch item[0] {
            case â€˜nâ€™:
                val = â€œnullâ€
            case â€˜tâ€™, â€˜fâ€™:
                val = â€œboolâ€
            }
            d.saveError(&amp;UnmarshalTypeError{Value: val, Type: v.Type(), Offset: int64(d.readIndex())})
            return nil
        }
        s, ok := unquoteBytes(item)
        if !ok {
            if fromQuoted {
                return fmt.Errorf(â€œjson: invalid use of ,string struct tag, trying to unmarshal %q into %vâ€, item, v.Type())
            }
            panic(phasePanicMsg)
        }
        return ut.UnmarshalText(s)
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v = pv

switch c := item[0]; c {
case 'n': // null
    // The main parser checks that only true and false can reach here,
    // but if this was a quoted string input, it could be anything.
    if fromQuoted &amp;&amp; string(item) != "null" {
        d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
        break
    }
    switch v.Kind() {
    case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:
        v.Set(reflect.Zero(v.Type()))
        // otherwise, ignore null for primitives/string
    }
case 't', 'f': // true, false
    value := item[0] == 't'
    // The main parser checks that only true and false can reach here,
    // but if this was a quoted string input, it could be anything.
    if fromQuoted &amp;&amp; string(item) != "true" &amp;&amp; string(item) != "false" {
        d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
        break
    }
    switch v.Kind() {
    default:
        if fromQuoted {
            d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
        } else {
            d.saveError(&amp;UnmarshalTypeError{Value: "bool", Type: v.Type(), Offset: int64(d.readIndex())})
        }
    case reflect.Bool:
        v.SetBool(value)
    case reflect.Interface:
        if v.NumMethod() == 0 {
            v.Set(reflect.ValueOf(value))
        } else {
            d.saveError(&amp;UnmarshalTypeError{Value: "bool", Type: v.Type(), Offset: int64(d.readIndex())})
        }
    }

case '"': // string
    s, ok := unquoteBytes(item)
    if !ok {
        if fromQuoted {
            return fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type())
        }
        panic(phasePanicMsg)
    }
    switch v.Kind() {
    default:
        d.saveError(&amp;UnmarshalTypeError{Value: "string", Type: v.Type(), Offset: int64(d.readIndex())})
    case reflect.Slice:
        if v.Type().Elem().Kind() != reflect.Uint8 {
            d.saveError(&amp;UnmarshalTypeError{Value: "string", Type: v.Type(), Offset: int64(d.readIndex())})
            break
        }
        b := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
        n, err := base64.StdEncoding.Decode(b, s)
        if err != nil {
            d.saveError(err)
            break
        }
        v.SetBytes(b[:n])
    case reflect.String:
        v.SetString(string(s))
    case reflect.Interface:
        if v.NumMethod() == 0 {
            v.Set(reflect.ValueOf(string(s)))
        } else {
            d.saveError(&amp;UnmarshalTypeError{Value: "string", Type: v.Type(), Offset: int64(d.readIndex())})
        }
    }

default: // number
    if c != '-' &amp;&amp; (c &lt; '0' || c &gt; '9') {
        if fromQuoted {
            return fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type())
        }
        panic(phasePanicMsg)
    }
    s := string(item)
    switch v.Kind() {
    default:
        if v.Kind() == reflect.String &amp;&amp; v.Type() == numberType {
            v.SetString(s)
            if !isValidNumber(s) {
                return fmt.Errorf("json: invalid number literal, trying to unmarshal %q into Number", item)
            }
            break
        }
        if fromQuoted {
            return fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type())
        }
        d.saveError(&amp;UnmarshalTypeError{Value: "number", Type: v.Type(), Offset: int64(d.readIndex())})
    case reflect.Interface:
        n, err := d.convertNumber(s)
        if err != nil {
            d.saveError(err)
            break
        }
        if v.NumMethod() != 0 {
            d.saveError(&amp;UnmarshalTypeError{Value: "number", Type: v.Type(), Offset: int64(d.readIndex())})
            break
        }
        v.Set(reflect.ValueOf(n))

    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        n, err := strconv.ParseInt(s, 10, 64)
        if err != nil || v.OverflowInt(n) {
            d.saveError(&amp;UnmarshalTypeError{Value: "number " + s, Type: v.Type(), Offset: int64(d.readIndex())})
            break
        }
        v.SetInt(n)

    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
        n, err := strconv.ParseUint(s, 10, 64)
        if err != nil || v.OverflowUint(n) {
            d.saveError(&amp;UnmarshalTypeError{Value: "number " + s, Type: v.Type(), Offset: int64(d.readIndex())})
            break
        }
        v.SetUint(n)

    case reflect.Float32, reflect.Float64:
        n, err := strconv.ParseFloat(s, v.Type().Bits())
        if err != nil || v.OverflowFloat(n) {
            d.saveError(&amp;UnmarshalTypeError{Value: "number " + s, Type: v.Type(), Offset: int64(d.readIndex())})
            break
        }
        v.SetFloat(n)
    }
}
return nil } å®ƒä¼šå…ˆåˆ¤æ–­ å½“å‰è¦æ˜ å°„çš„å¯¹è±¡æ˜¯å¦å®ç°äº† json.Unmarshaleræ¥å£å’Œencoding.TextUnmarshaleræ¥å£ï¼Œå¦‚æœå®ç°äº†å‰è€…ï¼Œåˆ™ç›´æ¥è°ƒç”¨å‰è€…çš„æ–¹æ³•ï¼Œå¦åˆ™ï¼Œå¦‚æœå®ç°äº†åè€…ï¼Œåˆ™é’ˆå¯¹å¼•å·å¼€å¤´çš„(quotedjson)ï¼Œä¼šè°ƒç”¨å…¶UnmarshalTextæ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬ä¹‹å‰å®ç°çš„è‡ªå®šä¹‰æ–¹æ³•ã€‚
</code></pre></div></div>

<p>è¿™é‡Œçœ‹åˆ°äº†ä¸ºä»€ä¹ˆæˆ‘ä»¬å¯ä»¥æ‰©å±•ï¼Œé‚£ä¸ºå•¥å¼€å§‹æˆ‘ä»¬ç›´æ¥æŠŠå­—ç¬¦ä¸²unmarshalåˆ°å®ç°äº†UnmarshalTextçš„å¯¹è±¡ä¸Šä¼šæŠ¥é”™å‘¢ï¼Ÿ</p>

<p>æˆ‘ä»¬åœ¨è‡ªå®šä¹‰æ–¹æ³•é‡Œè¿›è¡Œunmarshalçš„æ—¶å€™ï¼Œè¿™æ—¶å€™è¦è§£æçš„jsonæ˜¯ä¸€æ®µæ­£å¸¸çš„jsonï¼Œè€Œéquotedjsonäº†ï¼Œå› æ­¤èµ°çš„æ˜¯decodeStateçš„objectæ–¹æ³•:</p>

<p>Copy
// object consumes an object from d.data[d.off-1:], decoding into v.
// The first byte (â€˜{â€˜) of the object has been read already.
func (d *decodeState) object(v reflect.Value) error {
    // Check for unmarshaler.
    u, ut, pv := indirect(v, false)
    if u != nil {
        start := d.readIndex()
        d.skip()
        return u.UnmarshalJSON(d.data[start:d.off])
    }
    if ut != nil {
        d.saveError(&amp;UnmarshalTypeError{Value: â€œobjectâ€, Type: v.Type(), Offset: int64(d.off)})
        d.skip()
        return nil
    }
    â€¦//ç•¥å»ä¸€å †
}
ä¸Šé¢å¯ä»¥çœ‹å‡ºï¼Œé’ˆå¯¹objçš„æƒ…å†µï¼Œè‹¥æ˜¯å®ç°äº†encoding.TextUnmarshaleræ¥å£ï¼Œåˆ™ç›´æ¥è¿”å›é”™è¯¯äº†ã€‚</p>
:ET