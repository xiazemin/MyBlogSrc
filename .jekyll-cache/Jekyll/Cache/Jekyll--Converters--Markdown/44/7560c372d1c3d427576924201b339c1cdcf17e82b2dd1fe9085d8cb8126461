I"”<p>Goroutine Scheduler Overview
Goroutine æ˜¯ Golang ä¸–ç•Œé‡Œçš„ Lightweight Thread ã€‚</p>

<p>Golang åœ¨è¯­è¨€å±‚é¢æ”¯æŒå¤šçº¿ç¨‹ï¼Œä»£ç å¯ä»¥é€šè¿‡ go å…³é”®å­—æ¥å¯åŠ¨ Goroutine ï¼Œè°ƒç”¨è€…ä¸éœ€è¦å…³å¿ƒè°ƒç”¨æ ˆçš„å¤§å°ï¼Œå‡½æ•°ä¸Šä¸‹æ–‡ç­‰ç­‰ä¿¡æ¯å°±å¯ä»¥å®Œæˆå¹¶å‘æˆ–è€…å¹¶è¡Œæ“ä½œï¼ŒåŠ å¿«äº†æˆ‘ä»¬çš„å¼€å‘é€Ÿåº¦ã€‚
åˆ†æ Goroutine è°ƒåº¦æœ‰åˆ©äºäº†è§£å’Œåˆ†æ go binary çš„å·¥ä½œçŠ¶å†µï¼Œæ‰€ä»¥æ¥ä¸‹æ¥çš„å†…å®¹å°†åˆ†æ runtime ä¸­å…³äº Goroutine è°ƒåº¦çš„é€»è¾‘ã€‚</p>

<p>ä»¥ä¸‹å†…å®¹æ¶‰åŠåˆ°çš„ä»£ç æ˜¯åŸºäº go1.9rc2 ç‰ˆæœ¬ã€‚</p>

<ol>
  <li>
    <p>Scheduler Structure
æ•´ä¸ªè°ƒåº¦æ¨¡å‹ç”± Goroutine/Processor/Machine ä»¥åŠå…¨å±€è°ƒåº¦ä¿¡æ¯ sched ç»„æˆã€‚</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            Global Runnable Queue

                   runqueue
         ----------------------------
          | G_10 | G_11 | G_12 | ...
         ----------------------------

                                 P_0 Local Runnable Queue
         +-----+      +-----+       ---------------
         | M_3 | ---- | P_0 |  &lt;===  | G_8 | G_9 |
         +-----+      +-----+       ---------------
                         |
                      +-----+
                      | G_3 |  Running
                      +-----+

                                 P_1 Local Runnable Queue
         +-----+      +-----+       ---------------
         | M_4 | ---- | P_1 |  &lt;===  | G_6 | G_7 |
         +-----+      +-----+       ---------------
                         |
                      +-----+
                      | G_5 |  Running
                      +-----+ &lt;!-- more --&gt; 1.1 Goroutine Goroutine æ˜¯ Golang ä¸–ç•Œé‡Œçš„ çº¿ç¨‹ ï¼ŒåŒæ ·ä¹Ÿæ˜¯å¯è°ƒåº¦çš„å•å…ƒã€‚
</code></pre></div>    </div>
  </li>
</ol>

<p>// src/runtime/runtime2.go
type g struct {
        â€¦.
        m       *m
        sched gobuf
        goid   int64
        â€¦.
}</p>

<p>type gobuf struct {
        sp   uintptr
        pc   uintptr
        â€¦.
}
runtime ä¸º Goroutine å¼•å…¥äº†ç±»ä¼¼ PID çš„å±æ€§ goid ï¼Œä½¿å¾—æ¯ä¸€ä¸ª Goroutine éƒ½æœ‰å…¨å±€å”¯ä¸€çš„ goid æ ‡è¯†ã€‚
ä¸è¿‡å®˜æ–¹å¹¶æ²¡æœ‰æä¾›æ¥å£èƒ½ ç›´æ¥ è®¿é—®å½“å‰ Goroutine çš„ goidï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬å¯ä»¥é€šè¿‡ æ±‡ç¼– æˆ–è€… å–å·§ çš„æ–¹å¼å¾—åˆ° goidï¼Œæœ‰äº›ç¬¬ä¸‰æ–¹ package ä¼šåˆ©ç”¨ goid åšä¸€äº›æœ‰è¶£çš„äº‹æƒ…ï¼Œæ¯”å¦‚ Goroutine local storage ï¼Œåé¢ä¼šä»‹ç» runtime æ˜¯å¦‚ä½•ç”Ÿæˆå”¯ä¸€çš„ goid ã€‚</p>

<p>åœ¨è°ƒåº¦è¿‡ç¨‹ä¸­ï¼Œruntime éœ€è¦ Goroutine é‡Šæ”¾å½“å‰çš„è®¡ç®—èµ„æºï¼Œä¸ºäº†ä¿è¯ä¸‹æ¬¡èƒ½æ¢å¤ç°åœºï¼Œæ‰§è¡Œçš„ä¸Šä¸‹æ–‡ç°åœºï¼ˆæŒ‡ä»¤åœ°å€ å’Œ Stack Pointer ç­‰ï¼‰å°†ä¼šå­˜å‚¨åœ¨ gobuf è¿™ä¸ªæ•°æ®ç»“æ„ä¸­ã€‚</p>

<p>æ•´ä½“æ¥è¯´ï¼ŒGoroutine ä»…ä»£è¡¨ä»»åŠ¡çš„å†…å®¹ä»¥åŠä¸Šä¸‹æ–‡ï¼Œå¹¶ä¸æ˜¯å…·ä½“çš„æ‰§è¡Œå•å…ƒã€‚</p>

<p>1.2 Machine
Machine æ˜¯ OS Threadï¼Œå®ƒè´Ÿè´£æ‰§è¡Œ Goroutineã€‚</p>

<p>// src/runtime/runtime2.go</p>

<p>type m struct {
        â€¦.
        g0      *g     // goroutine with scheduling stack
        curg    *g     // current running goroutine</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    tls     [6]uintptr // thread-local storage (for x86 extern register)
    p       puintptr // attached p for executing go code (nil if not executing go code)
    .... }
</code></pre></div></div>

<p>runtime åœ¨åšè°ƒåº¦å·¥ä½œæˆ–è€…å’Œå½“å‰ Goroutine æ— å…³çš„ä»»åŠ¡æ—¶ï¼ŒGolang ä¼šåˆ‡æ¢è°ƒç”¨æ ˆæ¥è¿›è¡Œç›¸å…³çš„ä»»åŠ¡ï¼Œå°±å¥½åƒ Linux çš„è¿›ç¨‹è¿›å…¥ç³»ç»Ÿè°ƒç”¨æ—¶ä¼šåˆ‡æ¢åˆ°å†…æ ¸æ€çš„è°ƒç”¨æ ˆä¸€æ ·ï¼Œè¿™ä¹ˆåšä¹Ÿæ˜¯ä¸ºäº†é¿å…å½±å“åˆ°è°ƒåº¦ä»¥åŠåƒåœ¾å›æ”¶çš„æ‰«æã€‚</p>

<p>Machine ä¸€èˆ¬ä¼šè°ƒç”¨ systemstack å‡½æ•° æ¥åˆ‡æ¢è°ƒç”¨æ ˆã€‚
ä»åå­—å¯ä»¥çœ‹å‡ºï¼ŒGolang å¯¹å¤–éƒ¨ go code çš„è°ƒç”¨æ ˆç§°ä¹‹ä¸º user stack ï¼Œè€Œå°†è¿è¡Œæ ¸å¿ƒ runtime éƒ¨åˆ†ä»£ç çš„è°ƒç”¨æ ˆç§°ä¹‹ä¸º system stackã€‚
Machine éœ€è¦ç»´æŠ¤è¿™ä¸¤ä¸ªè°ƒç”¨æ ˆçš„ä¸Šä¸‹æ–‡ï¼Œæ‰€ä»¥ m ä¸­ g0 ç”¨æ¥ä»£è¡¨ runtime å†…éƒ¨é€»è¾‘ï¼Œè€Œ curg åˆ™æ˜¯æˆ‘ä»¬å¹³æ—¶å†™çš„ä»£ç ï¼Œæ›´å¤šè¯¦æƒ…å¯ä»¥å…³æ³¨ src/runtime/HACKING.md.</p>

<p>å› ä¸ºè°ƒç”¨æ ˆå¯ä»¥æ¥å›åœ°åˆ‡æ¢ï¼ŒMachine éœ€è¦çŸ¥é“å½“å‰è¿è¡Œçš„è°ƒç”¨æ ˆä¿¡æ¯ï¼Œæ‰€ä»¥ Golang ä¼šåˆ©ç”¨ Thread Local Storage æˆ–è€…æŒ‡å®šå¯„å­˜å™¨æ¥å­˜å‚¨å½“å‰è¿è¡Œçš„ gã€‚
settls æ±‡ç¼–ä»£ç ä¼šå°† g çš„åœ°å€æ”¾åˆ° m.tls ä¸­ï¼Œè¿™æ · Machine å°±å¯ä»¥é€šè¿‡ getg å–å‡ºå½“å‰è¿è¡Œçš„ Goroutineã€‚</p>

<p>ä¸åŒå¹³å° settls çš„è¡Œä¸ºæœ‰ä¸€å®šå·®åˆ«ã€‚</p>

<p>// src/runtime/sys_linux_amd64.s</p>

<p>// set tls base to DI
TEXT runtimeÂ·settls(SB),NOSPLIT,$32
#ifdef GOOS_android
        // Same as in sys_darwin_386.s:/ugliness, different constant.
        // DI currently holds m-&gt;tls, which must be fs:0x1d0.
        // See cgo/gcc_android_amd64.c for the derivation of the constant.
        SUBQ    $0x1d0, DI  // In android, the tls baseÂ·
#else
        ADDQ    $8, DI  // ELF wants to use -8(FS)
#endif
        MOVQ    DI, SI
        MOVQ    $0x1002, DI     // ARCH_SET_FS
        MOVQ    $158, AX        // arch_prctl
        SYSCALL
        CMPQ    AX, $0xfffffffffffff001
        JLS     2(PC)
        MOVL    $0xf1, 0xf1  // crash
        RET</p>

<p>// src/runtime/stubs.go</p>

<p>// getg returns the pointer to the current g.
// The compiler rewrites calls to this function into instructions
// that fetch the g directly (from TLS or from the dedicated register).
func getg() *g</p>

<p>// src/runtime/go_tls.h</p>

<p>#ifdef GOARCH_amd64
#define get_tls(r)      MOVQ TLS, r
#define g(r)    0(r)(TLS*1)
#endif
ä½†æ˜¯ Machine æƒ³è¦æ‰§è¡Œä¸€ä¸ª Goroutineï¼Œå¿…é¡»è¦ç»‘å®š Processorã€‚</p>

<p>runtime å†…éƒ¨æœ‰äº›å‡½æ•°æ‰§è¡Œæ—¶ä¼šç›´æ¥ç»‘å®š Machineï¼Œå¹¶ä¸éœ€è¦ Processorï¼Œæ¯”å¦‚ sysmon ã€‚</p>

<p>1.3 Processor
Processor å¯ä»¥ç†è§£æˆå¤„ç†å™¨ï¼Œå®ƒä¼šç»´æŠ¤ç€æœ¬åœ° Goroutine é˜Ÿåˆ— runq ï¼Œå¹¶åœ¨æ–°çš„ Goroutine å…¥é˜Ÿåˆ—æ—¶åˆ†é…å”¯ä¸€çš„ goidã€‚</p>

<p>type p struct {
        â€¦
        m           muintptr   // back-link to associated m (nil if idle)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // Cache of goroutine ids, amortizes accesses to runtimeÂ·sched.goidgen.
    goidcache    uint64
    goidcacheend uint64

    // Queue of runnable goroutines. Accessed without lock.
    runqhead uint32
    runqtail uint32
    runq     [256]guintptr
    ... } Processor çš„æ•°ç›®ä»£è¡¨ç€ runtime èƒ½åŒæ—¶å¤„ç† Goroutine çš„æ•°ç›®ï¼ŒGOMAXPROCS ç¯å¢ƒå˜é‡æ˜¯ç”¨æ¥æŒ‡å®š Processor çš„æ•°ç›®ï¼Œé»˜è®¤çŠ¶æ€ä¼šæ˜¯ CPU çš„ä¸ªæ•°ã€‚
</code></pre></div></div>

<p>ä¹Ÿæ­£æ˜¯å› ä¸º Processor çš„å­˜åœ¨ï¼Œruntime å¹¶ä¸éœ€è¦åšä¸€ä¸ªé›†ä¸­å¼çš„ Goroutine è°ƒåº¦ï¼Œæ¯ä¸€ä¸ª Machine éƒ½ä¼šåœ¨ Processor æœ¬åœ°é˜Ÿåˆ—ã€Global Runnable Queue æˆ–è€…å…¶ä»– Processor é˜Ÿåˆ—ä¸­æ‰¾ Goroutine æ‰§è¡Œï¼Œå‡å°‘å…¨å±€é”å¯¹æ€§èƒ½çš„å½±å“ï¼Œåé¢ä¼šå¯¹æ­¤å±•å¼€è¯´æ˜ã€‚</p>

<p>1.4 å…¨å±€è°ƒåº¦ä¿¡æ¯ sched
å…¨å±€è°ƒåº¦ä¿¡æ¯ sched ä¼šè®°å½•å½“å‰ Global Runnable Queueã€å½“å‰ç©ºé—²çš„ Machine å’Œç©ºé—² Processor çš„æ•°ç›®ç­‰ç­‰ã€‚</p>

<p>åé¢è¯´æ˜è¿™ goidgen å’Œ nmspinning ä¸¤ä¸ªå­—æ®µçš„ä½œç”¨ã€‚</p>

<p>// src/runtime/runtime2.go</p>

<p>var (
        â€¦
        sched      schedt
        â€¦
)</p>

<p>type schedt struct {
        // accessed atomically. keep at top to ensure alignment on 32-bit systems.
        goidgen  uint64</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    lock mutex

    midle        muintptr // idle m's waiting for work
    nmidle       int32    // number of idle m's waiting for work
    maxmcount    int32    // maximum number of m's allowed (or die)

    pidle      puintptr // idle p's
    npidle     uint32
    nmspinning uint32 // See "Worker thread parking/unparking" comment in proc.go.

    // Global runnable queue.
    runqhead guintptr
    runqtail guintptr
    runqsize int32
    .... } 2. Create a Goroutine ä¸‹é¢é‚£æ®µä»£ç éå¸¸ç®€å•ï¼Œåœ¨ main å‡½æ•°ä¸­äº§ç”Ÿ Goroutine å»æ‰§è¡Œ do() è¿™ä¸ªå‡½æ•°ã€‚
</code></pre></div></div>

<p>âœ  main cat -n main.go
     1  package main
     2
     3  func do() {
     4          // nothing
     5  }
     6
     7  func main() {
     8          go do()
     9  }
æˆ‘ä»¬ç¼–è¯‘ä¸Šè¿°ä»£ç å¹¶åæ±‡ç¼–çœ‹çœ‹ go å…³é”®å­—éƒ½åšäº†ä»€ä¹ˆã€‚
å¯ä»¥çœ‹åˆ°æºä»£ç çš„ç¬¬ 8 è¡Œ go do() ç¼–è¯‘å®Œä¹‹åä¼šå˜æˆ runtime.newproc æ–¹æ³•ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹ runtime.newproc éƒ½åšäº†äº›ä»€ä¹ˆã€‚</p>

<p>âœ  main uname -m -s
Linux x86_64
âœ  main go build
âœ  main go tool objdump -s â€œmain.mainâ€ main
TEXT main.main(SB) /root/workspace/main/main.go
  main.go:7             0x450a60                64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX
  main.go:7             0x450a69                483b6110                CMPQ 0x10(CX), SP
  main.go:7             0x450a6d                7630                    JBE 0x450a9f
  main.go:7             0x450a6f                4883ec18                SUBQ $0x18, SP
  main.go:7             0x450a73                48896c2410              MOVQ BP, 0x10(SP)
  main.go:7             0x450a78                488d6c2410              LEAQ 0x10(SP), BP
  main.go:8             0x450a7d                c7042400000000          MOVL $0x0, 0(SP)
  main.go:8             0x450a84                488d05e5190200          LEAQ 0x219e5(IP), AX
  main.go:8             0x450a8b                4889442408              MOVQ AX, 0x8(SP)
  main.go:8             0x450a90                e88bb4fdff              CALL runtime.newproc(SB)  &lt;==== Iâ€™m here.
  main.go:9             0x450a95                488b6c2410              MOVQ 0x10(SP), BP
  main.go:9             0x450a9a                4883c418                ADDQ $0x18, SP
  main.go:9             0x450a9e                c3                      RET
  main.go:7             0x450a9f                e88c7dffff              CALL runtime.morestack_noctxt(SB)
  main.go:7             0x450aa4                ebba                    JMP main.main(SB)
2.1 åˆ›å»º do() çš„æ‰§è¡Œä¸Šä¸‹æ–‡
å¹³æ—¶å†™ä»£ç çš„æ—¶å€™ä¼šå‘ç°ï¼ŒGoroutine æ‰§è¡Œå®Œæ¯•ä¹‹åä¾¿æ¶ˆå¤±äº†ã€‚é‚£ä¹ˆ do() è¿™ä¸ªå‡½æ•°æ‰§è¡Œå®Œæ¯•ä¹‹åè¿”å›åˆ°å“ªäº†å‘¢ï¼Ÿ</p>

<p>âœ  main go tool objdump -s â€œmain.doâ€ main
TEXT main.do(SB) /root/workspace/main/main.go
  main.go:5             0x450a50                c3                      RET
æ ¹æ® Intel 64 IA 32 å¼€å‘æŒ‡å—ä¸Š Chaptor 6.3 CALLING PROCEDURES USING CALL AND RET çš„è¯´æ˜ï¼ŒRET ä¼šå°†æ ˆé¡¶çš„æŒ‡ä»¤åœ°å€å¼¹å‡ºåˆ° IP å¯„å­˜å™¨ä¸Šï¼Œç„¶åç»§ç»­æ‰§è¡Œ IP å¯„å­˜å™¨ä¸Šçš„æŒ‡ä»¤ã€‚
ä¸ºäº†ä¿è¯ Machine æ‰§è¡Œå®Œ Goroutine ä¹‹åï¼Œèƒ½å¤Ÿæ­£å¸¸åœ°å®Œæˆä¸€äº›æ¸…ç†å·¥ä½œï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ„å»º Goroutine çš„æ‰§è¡Œä¸Šä¸‹æ–‡æ—¶æŒ‡å®š RET çš„å…·ä½“åœ°å€ã€‚</p>

<p>ä¸‹é¢çš„ä»£ç æ®µä¼šå°†å‡†å¤‡å¥½çš„è°ƒç”¨æ ˆå†…å­˜ä¿å­˜åˆ° newg.sched ä¸­ï¼Œå…¶ä¸­ gostartcallfn å‡½æ•°ä¼šæŠŠ do() å‡½æ•°æ·»åŠ åˆ° newg.sched.pc ï¼Œå¹¶å°† goexit å‡½æ•°åœ°å€æ¨å…¥æ ˆé¡¶ newg.sched.spã€‚
æ‰€ä»¥ Goroutine æ‰§è¡Œå®Œæ¯•ä¹‹åï¼ŒMachine ä¼šè·³åˆ° goexit å‡½æ•°ä¸­åšä¸€äº›æ¸…ç†å·¥ä½œã€‚</p>

<p>// src/runtime/proc.go @ func newproc1</p>

<p>if narg &gt; 0 {
        memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg)
        â€¦.
}</p>

<p>newg.sched.sp = sp
newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function
newg.sched.g = guintptr(unsafe.Pointer(newg))
gostartcallfn(&amp;newg.sched, fn)
newg.gopc = callerpc
newg.startpc = fn.fn</p>

<p>æƒ³äº†è§£ Intel æŒ‡ä»¤çš„æ›´å¤šç»†èŠ‚ï¼Œè¯·æŸ¥çœ‹ IntelÂ® 64 and IA-32 Architectures Developerâ€™s Manual: Vol. 1ã€‚</p>

<p>2.2 å…¨å±€å”¯ä¸€çš„ goid
é™¤äº†åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡ä»¥å¤–ï¼Œruntime è¿˜ä¼šä¸º Goroutine æŒ‡å®šä¸€ä¸ªå…¨å±€å”¯ä¸€çš„ idã€‚</p>

<p>// src/runtime/proc.go</p>

<p>const (
        // Number of goroutine ids to grab from sched.goidgen to local per-P cache at once.
        // 16 seems to provide enough amortization, but other than that itâ€™s mostly arbitrary number.
        _GoidCacheBatch = 16
)</p>

<p>// src/runtime/proc.go @ func newproc1</p>

<p>if <em>p</em>.goidcache == <em>p</em>.goidcacheend {
        // Sched.goidgen is the last allocated id,
        // this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
        // At startup sched.goidgen=0, so main goroutine receives goid=1.
        <em>p</em>.goidcache = atomic.Xadd64(&amp;sched.goidgen, <em>GoidCacheBatch)
        _p</em>.goidcache -= <em>GoidCacheBatch - 1
        _p</em>.goidcacheend = <em>p</em>.goidcache + <em>GoidCacheBatch
}
newg.goid = int64(_p</em>.goidcache)
<em>p</em>.goidcache++</p>

<p>å…¨å±€è°ƒåº¦ä¿¡æ¯ sched.goidgen æ˜¯ä¸“é—¨ç”¨æ¥åšå‘å·å™¨ï¼ŒProcessor æ¯æ¬¡å¯ä»¥ä»å‘å·å™¨é‚£æ‹¿èµ° _GoidCacheBatch ä¸ªå·ï¼Œç„¶åå†…éƒ¨é‡‡ç”¨è‡ªå¢çš„æ–¹å¼æ¥å‘å·ï¼Œè¿™æ ·å°±ä¿è¯äº†æ¯ä¸€ä¸ª Goroutine éƒ½å¯ä»¥æ‹¥æœ‰å…¨å±€å”¯ä¸€çš„ goidã€‚</p>

<p>ä»å…¨å±€è°ƒåº¦ä¿¡æ¯é‚£é‡Œå–å·çš„æ—¶å€™ç”¨åŸå­æ“ä½œæ¥ä¿è¯å¹¶å‘æ“ä½œçš„æ­£ç¡®æ€§ï¼Œè€Œå†…éƒ¨å‘å·æ—¶å´é‡‡ç”¨éåŸå­æ“ä½œï¼Œè¿™æ˜¯å› ä¸ºä¸€ä¸ª Processor åªèƒ½è¢«ä¸€ä¸ª Machine ç»‘å®šä¸Šï¼Œæ‰€ä»¥è¿™é‡Œ <em>p</em>.goidcache è‡ªå¢ä¸éœ€è¦è¦åŸå­æ“ä½œä¹Ÿèƒ½ä¿è¯å®ƒçš„æ­£ç¡®æ€§ã€‚</p>

<p>2.3 Local vs Global Runnable Queue
å½“ Goroutine åˆ›å»ºå®Œæ¯•ä¹‹åï¼Œå®ƒæ˜¯æ”¾åœ¨å½“å‰ Processor çš„ Local Runnable Queue è¿˜æ˜¯å…¨å±€é˜Ÿåˆ—é‡Œï¼Ÿ</p>

<p>runqput è¿™ä¸ªå‡½æ•°ä¼šå°è¯•æŠŠ newg æ”¾åˆ°æœ¬åœ°é˜Ÿåˆ—ä¸Šï¼Œå¦‚æœæœ¬åœ°é˜Ÿåˆ—æ»¡äº†ï¼Œå®ƒä¼šå°†æœ¬åœ°é˜Ÿåˆ—çš„å‰åŠéƒ¨åˆ†å’Œ newg è¿ç§»åˆ°å…¨å±€é˜Ÿåˆ—ä¸­ã€‚å‰©ä¸‹çš„äº‹æƒ…å°±ç­‰å¾… Machine è‡ªå·±å»æ‹¿ä»»åŠ¡äº†ã€‚</p>

<p>// src/runtime/proc.go @ func newproc1</p>

<p>runqput(<em>p</em>, newg, true)
2.4 å°ç»“
çœ‹åˆ°è¿™é‡Œï¼Œä¸€èˆ¬éƒ½ä¼šæœ‰ä»¥ä¸‹å‡ ä¸ªç–‘é—®ï¼š</p>

<p>main å‡½æ•°æ˜¯ä¸æ˜¯ä¹Ÿæ˜¯ä¸€ä¸ª Goroutine ï¼Ÿ
Machine æ€ä¹ˆå»å– Goroutine æ¥æ‰§è¡Œ?
goexit åšå®Œæ¸…ç†å·¥ä½œä¹‹åå°±è®© Machine é€€å‡ºå—ï¼Ÿè¿˜æ˜¯ç»§ç»­ä½¿ç”¨è¿™ä¸ª Machine?
é‚£ä¹ˆå°±ç»§ç»­å¾€ä¸‹è¯»å§~</p>

<ol>
  <li>main is a Goroutine
æˆ‘ä»¬å†™çš„ main å‡½æ•°åœ¨ç¨‹åºå¯åŠ¨æ—¶ï¼ŒåŒæ ·ä¼šä»¥ Goroutine èº«ä»½è¢« Machine æ‰§è¡Œï¼Œä¸‹é¢ä¼šæŸ¥çœ‹ go binary å¯åŠ¨æ—¶éƒ½åšäº†ä»€ä¹ˆã€‚</li>
</ol>

<p>âœ  main uname -m -s
Linux x86_64
âœ  main go build â€“gcflags â€œ-N -lâ€
âœ  main gdb main
(gdb) info file
Symbols from â€œ/root/workspace/main/mainâ€.
Local exec file:
        `/root/workspace/main/mainâ€™, file type elf64-x86-64.
        Entry point: 0x44bb80
        0x0000000000401000 - 0x0000000000450b13 is .text
        0x0000000000451000 - 0x000000000047a6bc is .rodata
        0x000000000047a7e0 - 0x000000000047afd4 is .typelink
        0x000000000047afd8 - 0x000000000047afe0 is .itablink
        0x000000000047afe0 - 0x000000000047afe0 is .gosymtab
        0x000000000047afe0 - 0x00000000004a96c8 is .gopclntab
        0x00000000004aa000 - 0x00000000004aaa38 is .noptrdata
        0x00000000004aaa40 - 0x00000000004ab5b8 is .data
        0x00000000004ab5c0 - 0x00000000004c97e8 is .bss
        0x00000000004c9800 - 0x00000000004cbe18 is .noptrbss
        0x0000000000400fc8 - 0x0000000000401000 is .note.go.buildid
(gdb) info symbol 0x44bb80
_rt0_amd64_linux in section .text</p>

<p>å…¥å£å‡½æ•°æ˜¯ _rt0_amd64_linuxï¼Œéœ€è¦è¯´æ˜çš„æ˜¯ï¼Œä¸åŒå¹³å°çš„å…¥å£å‡½æ•°åç§°ä¼šæœ‰æ‰€ä¸åŒï¼Œå…¨å±€æœç´¢è¯¥æ–¹æ³•ä¹‹åï¼Œå‘ç°è¯¥æ–¹æ³•ä¼šè°ƒç”¨ runtime.rt0_go æ±‡ç¼–ã€‚</p>

<p>çœå»äº†å¤§é‡å’Œç¡¬ä»¶ç›¸å…³çš„ç»†èŠ‚åï¼Œrt0_go åšäº†å¤§é‡çš„åˆå§‹åŒ–å·¥ä½œï¼Œruntime.args è¯»å–å‘½ä»¤è¡Œå‚æ•°ã€runtime.osinit è¯»å– CPU æ•°ç›®ï¼Œruntime.schedinit åˆå§‹åŒ– Processor æ•°ç›®ï¼Œæœ€å¤§çš„ Machine æ•°ç›®ç­‰ç­‰ã€‚</p>

<p>é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜çœ‹åˆ°äº†ä¸¤ä¸ªå¥‡æ€ªçš„ g0 å’Œ m0 å˜é‡ã€‚m0 Machine ä»£è¡¨ç€å½“å‰åˆå§‹åŒ–çº¿ç¨‹ï¼Œè€Œ g0 ä»£è¡¨ç€åˆå§‹åŒ–çº¿ç¨‹ m0 çš„ system stackï¼Œä¼¼ä¹è¿˜ç¼ºä¸€ä¸ª p0 ï¼Ÿ
å®é™…ä¸Šæ‰€æœ‰çš„ Processor éƒ½ä¼šæ”¾åˆ° allp é‡Œã€‚runtime.schedinit ä¼šåœ¨è°ƒç”¨ procresize æ—¶ä¸º m0 åˆ†é…ä¸Š allp[0] ã€‚æ‰€ä»¥åˆ°ç›®å‰ä¸ºæ­¢ï¼Œåˆå§‹åŒ–çº¿ç¨‹è¿è¡Œæ¨¡å¼æ˜¯ç¬¦åˆä¸Šæ–‡æåˆ°çš„ G/P/M æ¨¡å‹çš„ã€‚</p>

<p>å¤§é‡çš„åˆå§‹åŒ–å·¥ä½œåšå®Œä¹‹åï¼Œä¼šè°ƒç”¨ runtime.newproc ä¸º mainPC æ–¹æ³•ç”Ÿæˆä¸€ä¸ª Goroutineã€‚
è™½ç„¶ mainPC å¹¶ä¸æ˜¯æˆ‘ä»¬å¹³æ—¶å†™çš„é‚£ä¸ª main å‡½æ•°ï¼Œä½†æ˜¯å®ƒä¼šè°ƒç”¨æˆ‘ä»¬å†™çš„ main å‡½æ•°ï¼Œæ‰€ä»¥ main å‡½æ•°æ˜¯ä¼šä»¥ Goroutine çš„å½¢å¼è¿è¡Œã€‚</p>

<p>æœ‰äº† Goroutine ä¹‹åï¼Œé‚£ä¹ˆ Machine æ€ä¹ˆæ‰§è¡Œå‘¢ï¼Ÿ</p>

<p>// src/runtime/asm_amd64.s</p>

<p>TEXT runtimeÂ·rt0_go(SB),NOSPLIT,$0
         â€¦</p>

<p>// set the per-goroutine and per-mach â€œregistersâ€
        // save m-&gt;g0 = g0
        MOVQ    CX, m_g0(AX)
        // save m0 to g0-&gt;m
        MOVQ    AX, g_m(CX)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ...
    CALL    runtimeÂ·args(SB)
    CALL    runtimeÂ·osinit(SB)
    CALL    runtimeÂ·schedinit(SB)

    // create a new goroutine to start program
    MOVQ    $runtimeÂ·mainPC(SB), AX        // entry
    PUSHQ   AX
    PUSHQ   $0      // arg size
    CALL    runtimeÂ·newproc(SB)

    ...
    // start this M
    CALL    runtimeÂ·mstart(SB)  &lt;=== I'm here!

    MOVL    $0xf1, 0xf1  // crash
    RET 4. Machine â€” Work Stealing åœ¨ä¸Šä¸€èŠ‚æŸ¥çœ‹ rt0_go æ±‡ç¼–ä»£ç çš„æ—¶å€™ï¼Œå‘ç°æœ€åä¸€æ®µä»£ç  CALL runtime.mstart(SB) æ˜¯ç”¨æ¥å¯åŠ¨ Machineã€‚
</code></pre></div></div>

<p>å› ä¸ºåœ¨ Golang çš„ä¸–ç•Œé‡Œï¼Œä»»åŠ¡çš„æ‰§è¡Œéœ€è¦ Machine æœ¬èº«è‡ªå·±å»è·å–ã€‚
æ¯ä¸ª Machine è¿è¡Œå‰éƒ½ä¼šç»‘å®šä¸€ä¸ª Processorï¼ŒMachine ä¼šé€æ­¥æ¶ˆè€—å®Œå½“å‰ Processor é˜Ÿåˆ—ã€‚
ä¸ºäº†é˜²æ­¢æŸäº› Machine æ²¡æœ‰äº‹æƒ…å¯åšï¼ŒæŸäº› Machine å¿™æ­»ï¼Œæ‰€ä»¥ runtime ä¼šåšäº†ä¸¤ä»¶äº‹ï¼š</p>

<p>å½“å‰ Processor é˜Ÿåˆ—å·²æ»¡ï¼ŒMachine ä¼šå°†æœ¬åœ°é˜Ÿåˆ—çš„éƒ¨åˆ† Goroutine è¿ç§»åˆ° Global Runnable Queue ä¸­;
Machine ç»‘å®šçš„ Processor æ²¡æœ‰å¯æ‰§è¡Œçš„ Goroutine æ—¶ï¼Œå®ƒä¼šå» Global Runnable Queueã€Net Network å’Œå…¶ä»– Processor çš„é˜Ÿåˆ—ä¸­æŠ¢ä»»åŠ¡ã€‚
è¿™ç§è°ƒåº¦æ¨¡å¼å«åš Work Stealingã€‚</p>

<p>4.1 å¦‚ä½•æ‰§è¡Œ Goroutineï¼Ÿ
// src/runtime/proc.go</p>

<p>func mstart() {
        â€¦
        } else if <em>g</em>.m != &amp;m0 {
                acquirep(<em>g</em>.m.nextp.ptr()) // ç»‘å®š Processor
                <em>g</em>.m.nextp = 0
        }
        schedule()
}</p>

<p>mstart() =&gt; schedule() =&gt; execute() =&gt; xxx() =&gt; goexit()
runtime.mstart å‡½æ•°ä¼šè°ƒç”¨ schedule å‡½æ•°å»å¯»æ‰¾å¯æ‰§è¡Œçš„ Goroutineï¼ŒæŸ¥æ‰¾é¡ºåºå¤§è‡´æ˜¯:</p>

<p>Local Runnable Queue
Global Runnable Queue
Net Network
Other Processorâ€™s Runnable Queue
éœ€æ‰¾å¯æ‰§è¡Œçš„ Goroutine çš„é€»è¾‘éƒ½åœ¨ findrunnable é‡Œã€‚</p>

<p>æ‰¾åˆ°ä»»ä½•ä¸€ä¸ªå¯æ‰§è¡Œçš„ Goroutine ä¹‹åï¼Œä¼šè°ƒç”¨ execute å»åˆ‡æ¢åˆ° g.sched ç›¸åº”çš„è°ƒç”¨æ ˆï¼Œè¿™æ · Machine å°±ä¼šæ‰§è¡Œæˆ‘ä»¬ä»£ç é‡Œåˆ›å»º Goroutineã€‚</p>

<p>æ‰§è¡Œå®Œæ¯•ä¹‹åä¼š RET åˆ° goexit, goexit ä¼šè°ƒç”¨ goexit0 è¿›è¡Œæ¸…ç†å·¥ä½œï¼Œ
ç„¶åå†è¿›å…¥ schedule æ¨¡å¼ã€‚å¦‚æœè¿™ä¸ªæ—¶å€™é‡Šæ”¾äº†å½“å‰ Machineï¼Œé‚£ä¹ˆæ¯æ¬¡æ‰§è¡Œ Goroutine éƒ½è¦åˆ›å»ºæ–°çš„ OS-Threadï¼Œè¿™æ ·çš„ä»£ä»·ç•¥å¤§ã€‚
æ‰€ä»¥ Machine ä¼šä¸æ–­åœ°æ‹¿ä»»åŠ¡æ‰§è¡Œï¼Œç›´åˆ°æ²¡æœ‰ä»»åŠ¡ã€‚
å½“ Machine æ²¡æœ‰å¯æ‰§è¡Œçš„ä»»åŠ¡æ—¶ï¼Œå®ƒä¼šåœ¨ findrunnable ä¸­è°ƒç”¨ stopm è¿›å…¥ä¼‘çœ çŠ¶æ€ã€‚</p>

<p>é‚£ä¹ˆè°æ¥æ¿€æ´»è¿™äº›ä¼‘çœ çŠ¶æ€çš„ Machine ï¼Ÿ</p>

<p>4.2 Wake Up
å¸¸è§çš„æ¿€æ´»æ—¶æœºå°±æ˜¯æ–°çš„ Goroutine åˆ›å»ºå‡ºæ¥çš„æ—¶å€™ã€‚æˆ‘ä»¬å›å¤´çœ‹çœ‹ runtime.newproc è¿”å›å‰éƒ½åšäº†ä»€ä¹ˆã€‚</p>

<p>// src/runtime/proc.go @ func newproc1</p>

<p>if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 &amp;&amp; runtimeInitTime != 0 {
        wakep()
}
å½“ Machine æ‰¾ä¸åˆ°å¯æ‰§è¡Œçš„ Goroutine æ—¶ï¼Œä½†æ˜¯è¿˜åœ¨åŠªåŠ›åœ°å¯»æ‰¾å¯æ‰§è¡Œçš„ Goroutineï¼Œè¿™æ®µæ—¶é—´å®ƒå±äº spinning çš„çŠ¶æ€ã€‚
å®ƒå®åœ¨æ˜¯æ‰¾ä¸åˆ°äº†ï¼Œå®ƒæ‰å›é‡Šæ”¾å½“å‰ Processor è¿›å…¥ä¼‘çœ çŠ¶æ€ã€‚</p>

<p>atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 æŒ‡çš„æ˜¯æœ‰ç©ºé—²çš„ Processor è€Œæ²¡æœ‰ spinning çŠ¶æ€çš„ Machineã€‚
è¿™ä¸ªæ—¶å€™å¯èƒ½æ˜¯æœ‰ä¼‘çœ çŠ¶æ€çš„ Machineï¼Œå¯èƒ½æ˜¯ç¨‹åºåˆšå¯åŠ¨çš„æ—¶å€™å¹¶æ²¡æœ‰è¶³å¤Ÿçš„ Machineã€‚å½“é‡åˆ°è¿™ç§æƒ…å†µï¼Œå½“å‰ Machine ä¼šæ‰§è¡Œ wakepï¼Œè®©ç¨‹åºèƒ½å¿«é€Ÿåœ°æ¶ˆåŒ– Goroutineã€‚</p>

<p>åœ¨åˆå§‹åŒ–è¿‡ç¨‹ä¸­ï¼Œä¸º runtime.main å‡½æ•°åˆ›å»ºçš„ç¬¬ä¸€ä¸ª Goroutine å¹¶ä¸éœ€è¦è°ƒç”¨ wakepï¼Œæ‰€ä»¥åœ¨è¯¥åˆ¤æ–­æ¡ä»¶é‡Œ runtimeInitTime != 0 ä¼šå¤±è´¥ã€‚
runtimeInitTime ä¼šåœ¨ runtime.main å‡½æ•°ä¸­è¢«èµ‹å€¼ï¼Œè¡¨æ˜æ­£å¼å¼€å§‹æ‰§è¡Œä»»åŠ¡å•¦ã€‚</p>

<p>wakep é¦–å…ˆä¼šæŸ¥çœ‹æœ‰æ²¡æœ‰ç©ºé—²çš„ Machineï¼Œå¦‚æœæ‰¾åˆ°è€Œä¸”çŠ¶æ€åˆç†ï¼Œé‚£ä¹ˆå°±ä¼šæ¿€æ´»å®ƒã€‚å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œé‚£ä¹ˆä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ spinning Machineã€‚</p>

<p>åœ¨ Golang ä¸–ç•Œé‡Œï¼Œæ–°åˆ›å»ºçš„ Machine å¯ä»¥è®¤ä¸ºå®ƒå±äº spinningï¼Œå› ä¸ºåˆ›å»º OS-Thread æœ‰ä¸€å®šä»£ä»·ï¼Œä¸€æ—¦åˆ›å»ºå‡ºæ¥äº†å®ƒå°±è¦å»å¹²æ´»ã€‚
é™¤æ­¤ä¹‹å¤–ï¼ŒGolang åˆ›å»ºæ–°çš„çº¿ç¨‹å¹¶ä¸ä¼šç›´æ¥äº¤ä»˜ä»»åŠ¡ç»™å®ƒï¼Œè€Œæ˜¯è®©å®ƒè°ƒç”¨ runtime.mstart æ–¹æ³•è‡ªå·±å»æ‰¾æ´»åšã€‚</p>

<p>// src/runtime/proc.go</p>

<p>func wakep() {
        // be conservative about spinning threads
        if !atomic.Cas(&amp;sched.nmspinning, 0, 1) {
                return
        }
        startm(nil, true)
}</p>

<p>func mspinning() {
        // startmâ€™s caller incremented nmspinning. Set the new Mâ€™s spinning.
        getg().m.spinning = true
}</p>

<p>func startm(<em>p</em> *p, spinning bool) {
        lock(&amp;sched.lock)
        if <em>p</em> == nil {
                <em>p</em> = pidleget()
                if <em>p</em> == nil {
                        unlock(&amp;sched.lock)
                        if spinning {
                                // The caller incremented nmspinning, but there are no idle Ps,
                                // so itâ€™s okay to just undo the increment and give up.
                                if int32(atomic.Xadd(&amp;sched.nmspinning, -1)) &lt; 0 {
                                        throw(â€œstartm: negative nmspinningâ€)
                                }
                        }
                        return
                }
        }
        mp := mget()
        unlock(&amp;sched.lock)
        if mp == nil {
                var fn func()
                if spinning {
                        // The caller incremented nmspinning, so set m.spinning in the new M.
                        fn = mspinning
                }
                newm(fn, <em>p</em>)
                return
        }
        â€¦
        mp.spinning = spinning
        mp.nextp.set(<em>p</em>)
        notewakeup(&amp;mp.park)
}</p>

<p>åœ¨ Linux å¹³å°ä¸Šï¼Œnewm ä¼šè°ƒç”¨ newosproc æ¥äº§ç”Ÿæ–°çš„ OS-Threadã€‚</p>

<ol>
  <li>Preemptive
Machine ä¼šåœ¨å…¨å±€èŒƒå›´å†…æŸ¥æ‰¾ Goroutine æ¥æ‰§è¡Œï¼Œä¼¼ä¹è¿˜ç¼ºå°‘è§’è‰²å»é€šçŸ¥ Machine é‡Šæ”¾å½“å‰ Goroutineï¼Œæ€»ä¸èƒ½æ‰§è¡Œå®Œæ¯•å†åˆ‡æ¢å§ã€‚
æˆ‘ä»¬çŸ¥é“æ“ä½œç³»ç»Ÿä¼šæ ¹æ®æ—¶é’Ÿå‘¨æœŸæ€§åœ°è§¦å‘ç³»ç»Ÿä¸­æ–­æ¥è¿›è¡Œè°ƒåº¦ï¼ŒGolang æ˜¯ç”¨æˆ·æ€çš„çº¿ç¨‹è°ƒåº¦ï¼Œé‚£å®ƒæ€ä¹ˆé€šçŸ¥ Machine å‘¢ï¼Ÿ</li>
</ol>

<p>å›å¿†ä¸Šæ–‡, æåˆ°äº†æœ‰äº› Machine æ‰§è¡Œä»»åŠ¡å‰å®ƒå¹¶ä¸éœ€è¦ç»‘å®š Processorï¼Œå®ƒä»¬éƒ½åšä»€ä¹ˆä»»åŠ¡å‘¢ï¼Ÿ</p>

<p>// src/runtime/proc.go</p>

<p>func main() {
        â€¦
        systemstack(func() {
                newm(sysmon, nil)
        })
        â€¦
}</p>

<p>åœ¨ runtime.main å‡½æ•°ä¸­ä¼šå¯åŠ¨æ–°çš„ OS-Thread å»æ‰§è¡Œ sysmon å‡½æ•°ã€‚
è¯¥å‡½æ•°ä¼šä»¥ä¸€ä¸ªä¸Šå¸è§†è§’å»æŸ¥çœ‹ Goroutine/Machine/Processor çš„è¿è¡Œæƒ…å†µï¼Œå¹¶ä¼šè°ƒç”¨ retake å»è®© Machine é‡Šæ”¾æ­£åœ¨è¿è¡Œçš„ Goroutineã€‚</p>

<p>// src/runtime/proc.go</p>

<p>// forcePreemptNS is the time slice given to a G before it is
// preempted.
const forcePreemptNS = 10 * 1000 * 1000 // 10ms</p>

<p>func retake(now int64) uint32 {
        for i := int32(0); i &lt; gomaxprocs; i++ {
                <em>p</em> := allp[i]
                if <em>p</em> == nil {
                        continue
                }
                pd := &amp;<em>p</em>.sysmontick
                s := <em>p</em>.status</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            ...
            } else if s == _Prunning {
                    // Preempt G if it's running for too long.
                    t := int64(_p_.schedtick)
                    if int64(pd.schedtick) != t {
                            pd.schedtick = uint32(t)
                            pd.schedwhen = now
                            continue
                    }
                    if pd.schedwhen+forcePreemptNS &gt; now {
                            continue
                    }
                    preemptone(_p_)
            }
    }
    ... }
</code></pre></div></div>

<p>Processor åœ¨ Machine ä¸Šæ‰§è¡Œæ—¶é—´è¶…è¿‡ 10msï¼ŒMachine ä¼šç»™è°ƒç”¨ preemptone
ç»™å½“å‰ Goroutine åŠ ä¸Šæ ‡è®°ï¼š</p>

<p>// src/runtime/proc.go</p>

<p>func preemptone(<em>p</em> *p) bool {
        â€¦
        gp.preempt = true</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // Every call in a go routine checks for stack overflow by
    // comparing the current stack pointer to gp-&gt;stackguard0.
    // Setting gp-&gt;stackguard0 to StackPreempt folds
    // preemption into the normal stack overflow check.
    gp.stackguard0 = stackPreempt }
</code></pre></div></div>

<p>å¯ä»¥çœ‹åˆ°å®ƒå¹¶ä¸æ˜¯ç›´æ¥å‘ä¿¡å·ç»™ Machine è®©å®ƒç«‹å³é‡Šæ”¾ï¼Œè€Œæ˜¯è®© Goroutine è‡ªå·±é‡Šæ”¾ï¼Œé‚£å®ƒä»€ä¹ˆæ—¶å€™ä¼šé‡Šæ”¾ï¼Ÿ</p>

<p>Golang åˆ›å»ºæ–°çš„ Goroutine æ—¶ï¼Œéƒ½ä¼šåˆ†é…æœ‰é™çš„è°ƒç”¨æ ˆç©ºé—´ï¼ŒæŒ‰éœ€è¿›è¡Œæ‹“å±•æˆ–è€…æ”¶ç¼©ã€‚
æ‰€ä»¥åœ¨æ‰§è¡Œä¸‹ä¸€ä¸ªå‡½æ•°æ—¶ï¼Œå®ƒä¼šæ£€æŸ¥è°ƒç”¨æ ˆæ˜¯å¦æº¢å‡ºã€‚</p>

<p>âœ  main go tool objdump -s â€œmain.mainâ€ main
TEXT main.main(SB) /root/workspace/main/main.go
  main.go:7             0x450a60                64488b0c25f8ffffff      MOVQ FS:0xfffffff8, CX
  main.go:7             0x450a69                483b6110                CMPQ 0x10(CX), SP
  main.go:7             0x450a6d                7630                    JBE 0x450a9f    &lt;= Iâ€™m here!!
  main.go:7             0x450a6f                4883ec18                SUBQ $0x18, SP
  main.go:7             0x450a73                48896c2410              MOVQ BP, 0x10(SP)
  main.go:7             0x450a78                488d6c2410              LEAQ 0x10(SP), BP
  main.go:8             0x450a7d                c7042400000000          MOVL $0x0, 0(SP)
  main.go:8             0x450a84                488d05e5190200          LEAQ 0x219e5(IP), AX
  main.go:8             0x450a8b                4889442408              MOVQ AX, 0x8(SP)
  main.go:8             0x450a90                e88bb4fdff              CALL runtime.newproc(SB)
  main.go:9             0x450a95                488b6c2410              MOVQ 0x10(SP), BP
  main.go:9             0x450a9a                4883c418                ADDQ $0x18, SP
  main.go:9             0x450a9e                c3                      RET
  main.go:7             0x450a9f                e88c7dffff              CALL runtime.morestack_noctxt(SB)
  main.go:7             0x450aa4                ebba                    JMP main.main(SB)</p>

<p>gp.stackguard0 = stackPreempt è®¾ç½®ä¼šè®©æ£€æŸ¥å¤±è´¥ï¼Œè¿›å…¥ runtime.morestack_noctxt å‡½æ•°ã€‚
å®ƒå‘ç°æ˜¯å› ä¸º runtime.retake é€ æˆï¼ŒMachine ä¼šä¿å­˜å½“å‰ Goroutine çš„æ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œé‡æ–°è¿›å…¥ runtime.scheduleã€‚</p>

<p>ä½ å¯èƒ½ä¼šé—®ï¼Œå¦‚æœè¿™ä¸ª Goroutine é‡Œé¢æ²¡æœ‰å‡½æ•°è°ƒç”¨æ€ä¹ˆåŠï¼Ÿè¯·æŸ¥çœ‹è¿™ä¸ª issues/11462ã€‚</p>

<p>ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œè¿™æ ·çš„å‡½æ•°ä¸æ˜¯æ­»å¾ªç¯ï¼Œå°±æ˜¯å¾ˆå¿«å°±é€€å‡ºäº†ï¼Œå®é™…å¼€å‘ä¸­è¿™ç§çš„ç±»å‹å‡½æ•°ä¸ä¼šå¤ªå¤šã€‚</p>

<ol>
  <li>å…³äºçº¿ç¨‹æ•°ç›®
Processor çš„æ•°ç›®å†³å®š go binary èƒ½åŒæ—¶å¤„ç†å¤šå°‘ Goroutine çš„èƒ½åŠ›ï¼Œæ„Ÿè§‰ Machine çš„æ•°ç›®åº”è¯¥ä¸ä¼šå¤ªå¤šã€‚</li>
</ol>

<p>âœ  scheduler cat -n main.go
     1  package main
     2
     3  import (
     4          â€œlogâ€
     5          â€œnet/httpâ€
     6          â€œsyscallâ€
     7  )
     8
     9  func main() {
    10          http.HandleFunc(â€œ/sleepâ€, func(w http.ResponseWriter, r *http.Request) {
    11                  tspec := syscall.NsecToTimespec(1000 * 1000 * 1000)
    12                  if err := syscall.Nanosleep(&amp;tspec, &amp;tspec); err != nil {
    13                          panic(err)
    14                  }
    15          })
    16
    17          http.HandleFunc(â€œ/echoâ€, func(w http.ResponseWriter, r *http.Request) {
    18                  w.Write([]byte(â€œhelloâ€))
    19          })
    20
    21          log.Fatal(http.ListenAndServe(â€œ:8080â€, nil))
    22  }</p>

<p>Golang æä¾›äº† GODEBUG ç¯å¢ƒå˜é‡æ¥è§‚å¯Ÿå½“å‰ Goroutine/Processor/Machine çš„çŠ¶æ€ã€‚</p>

<p>âœ  scheduler go build
âœ  scheduler GODEBUG=schedtrace=2000 ./scheduler
SCHED 0ms: gomaxprocs=4 idleprocs=1 threads=6 spinningthreads=1 idlethreads=0 runqueue=0 [0 0 0 0]
SCHED 2008ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 4016ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]</p>

<p>GODEBUG=schedtrace=2000 ä¼šå¼€å¯ schedtrace æ¨¡å¼ï¼Œå®ƒä¼šè®© sysmon ä¸­è°ƒç”¨ schedtraceã€‚</p>

<p>// src/runtime/proc.go</p>

<p>func schedtrace(detailed bool) {
        â€¦
        print(â€œSCHED â€œ, (now-starttime)/1e6, â€œms: gomaxprocs=â€, gomaxprocs, â€œ idleprocs=â€, sched.npidle, â€œ threads=â€, sched.mcount, â€œ spinningthreads=â€, sched.nmspinning, â€œ idlethreads=â€, sched.nmidle, â€œ runqueue=â€, sched.runqsize)
        â€¦
}</p>

<p>gomaxprocs:      å½“å‰ Processor çš„æ•°ç›®
idleprocs:       ç©ºé—² Processor çš„æ•°ç›®
threads:         å…±åˆ›å»ºäº†å¤šå°‘ä¸ª Machine
spinningthreads: spinning çŠ¶æ€çš„ Machine
nmidle:          ä¼‘çœ çŠ¶æ€çš„ Machine æ•°ç›®
runqueue:        Global Runnable Queue é˜Ÿåˆ—é•¿åº¦
[x, y, z..]:     æ¯ä¸ª Processor çš„ Local Runnable Queue é˜Ÿåˆ—é•¿åº¦</p>

<p>ä¸‹é¢æˆ‘ä»¬ä¼šé€šè¿‡ wrk å¯¹ sleep å’Œ echo è¿™ä¸¤ä¸ª endpoint è¿›è¡Œå‹åŠ›æµ‹è¯•ï¼Œå¹¶å…³æ³¨ Machine çš„æ•°ç›®å˜åŒ–ã€‚</p>

<p>âœ  scheduler GODEBUG=schedtrace=2000 ./scheduler &gt; echo_result 2&gt;&amp;1 &amp;
[1] 6015
âœ  scheduler wrk -t12 -c400 -d30s http://localhost:8080/echo
Running 30s test @ http://localhost:8080/echo
  12 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    51.15ms  104.96ms   1.31s    89.35%
    Req/Sec     4.97k     4.48k   20.53k    74.84%
  1780311 requests in 30.08s, 205.44MB read
Requests/sec:  59178.76
Transfer/sec:      6.83MB
âœ  scheduler head -n 20 echo_result
SCHED 0ms: gomaxprocs=4 idleprocs=1 threads=6 spinningthreads=2 idlethreads=0 runqueue=0 [0 0 0 0]
SCHED 2000ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 4005ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 6008ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 8014ms: gomaxprocs=4 idleprocs=0 threads=12 spinningthreads=0 idlethreads=6 runqueue=195 [20 53 6 32]
SCHED 10018ms: gomaxprocs=4 idleprocs=0 threads=12 spinningthreads=0 idlethreads=6 runqueue=272 [65 16 5 37]
SCHED 12021ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=218 [97 5 52 7]
SCHED 14028ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=41 [2 1 25 3]
SCHED 16029ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=178 [10 31 45 38]
SCHED 18033ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=144 [15 92 47 0]
SCHED 20034ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=195 [1 7 4 41]
SCHED 22035ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=159 [88 14 41 5]
SCHED 24038ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=231 [47 19 53 41]
SCHED 26046ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=6 [1 0 1 10]
SCHED 28049ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=133 [61 13 97 53]
SCHED 30049ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=220 [13 49 29 28]
SCHED 32058ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=138 [40 93 63 50]
SCHED 34062ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=266 [51 9 38 31]
SCHED 36068ms: gomaxprocs=4 idleprocs=0 threads=13 spinningthreads=0 idlethreads=7 runqueue=189 [1 3 46 14]
SCHED 38084ms: gomaxprocs=4 idleprocs=4 threads=13 spinningthreads=0 idlethreads=10 runqueue=0 [0 0 0 0]</p>

<p>æµ‹è¯• localhost:8080/echo 30s ä¹‹åï¼Œå‘ç°å½“å‰çº¿ç¨‹æ•°ç›®ä¸º 13ã€‚æ¥ä¸‹æ¥å†çœ‹çœ‹ localhost:8080/sleep çš„æƒ…å†µã€‚</p>

<p>âœ  scheduler GODEBUG=schedtrace=1000 ./scheduler &gt; sleep_result 2&gt;&amp;1 &amp;
[1] 8284
âœ  scheduler wrk -t12 -c400 -d30s http://localhost:8080/sleep
Running 30s test @ http://localhost:8080/sleep
  12 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     1.01s    13.52ms   1.20s    86.57%
    Req/Sec    83.06     89.44   320.00     79.12%
  11370 requests in 30.10s, 1.26MB read
Requests/sec:    377.71
Transfer/sec:     42.79KB
âœ  scheduler cat sleep_result
SCHED 0ms: gomaxprocs=4 idleprocs=1 threads=6 spinningthreads=2 idlethreads=0 runqueue=0 [0 0 0 0]
SCHED 1000ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 2011ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 3013ms: gomaxprocs=4 idleprocs=4 threads=282 spinningthreads=0 idlethreads=1 runqueue=0 [0 0 0 0]
SCHED 4020ms: gomaxprocs=4 idleprocs=4 threads=400 spinningthreads=0 idlethreads=1 runqueue=0 [0 0 0 0]
SCHED 5028ms: gomaxprocs=4 idleprocs=4 threads=401 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0]
SCHED 6037ms: gomaxprocs=4 idleprocs=4 threads=401 spinningthreads=0 idlethreads=2 runqueue=0 [0 0 0 0]
SCHED 7038ms: gomaxprocs=4 idleprocs=4 threads=402 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 8039ms: gomaxprocs=4 idleprocs=4 threads=402 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 9046ms: gomaxprocs=4 idleprocs=4 threads=402 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 10049ms: gomaxprocs=4 idleprocs=4 threads=402 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 11056ms: gomaxprocs=4 idleprocs=4 threads=402 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 12058ms: gomaxprocs=4 idleprocs=4 threads=402 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 13058ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 14062ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 15064ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 16066ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 17068ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 18072ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 19083ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 20084ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 21086ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 22088ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 23096ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 24100ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 25100ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 26100ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 27103ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 28110ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=4 runqueue=0 [0 0 0 0]
SCHED 33131ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=396 runqueue=0 [0 0 0 0]
SCHED 34137ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=400 runqueue=0 [0 0 0 0]
SCHED 35140ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=400 runqueue=0 [0 0 0 0]
SCHED 36150ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=400 runqueue=0 [0 0 0 0]
SCHED 37155ms: gomaxprocs=4 idleprocs=4 threads=403 spinningthreads=0 idlethreads=400 runqueue=0 [0 0 0 0]</p>

<p>å‹åŠ›æµ‹è¯•å®Œæ¯•ä¹‹åï¼Œåˆ›å»ºçš„çº¿ç¨‹æ˜æ˜¾æ¯” localhost:8080/echo å¤šä¸å°‘ã€‚åœ¨å‹æµ‹è¿‡ç¨‹ä¸­é‡‡ç”¨ gdb attach + thread apply all bt æŸ¥çœ‹è¿™äº›çº¿ç¨‹éƒ½åœ¨åšä»€ä¹ˆ:</p>

<p>â€¦
Thread 152 (Thread 0x7f4744fb1700 (LWP 27863)):
#0  syscall.Syscall () at /usr/local/go/src/syscall/asm_linux_amd64.s:27
#1  0x000000000047151f in syscall.Nanosleep (time=0xc42119ac90,
#2  0x000000000060f042 in main.main.func1 (w=â€¦, r=0xc4218d8900)
#3  0x00000000005e8974 in net/http.HandlerFunc.ServeHTTP (f=
#4  0x00000000005ea020 in net/http.(<em>ServeMux).ServeHTTP (
#5  0x00000000005eafa4 in net/http.serverHandler.ServeHTTP (sh=â€¦, rw=â€¦,
#6  0x00000000005e7a5d in net/http.(</em>conn).serve (c=0xc420263360, ctx=â€¦)
#7  0x0000000000458e31 in runtime.goexit ()
#8  0x000000c420263360 in ?? ()
#9  0x00000000007cf100 in crypto/elliptic.p224ZeroModP63 ()
#10 0x000000c421180ec0 in ?? ()
#11 0x0000000000000000 in ?? ()
Thread 151 (Thread 0x7f47457b2700 (LWP 27862)):
#0  syscall.Syscall () at /usr/local/go/src/syscall/asm_linux_amd64.s:27
#1  0x000000000047151f in syscall.Nanosleep (time=0xc4206bcc90,
#2  0x000000000060f042 in main.main.func1 (w=â€¦, r=0xc4218cd300)
#3  0x00000000005e8974 in net/http.HandlerFunc.ServeHTTP (f=
#4  0x00000000005ea020 in net/http.(<em>ServeMux).ServeHTTP (
#5  0x00000000005eafa4 in net/http.serverHandler.ServeHTTP (sh=â€¦, rw=â€¦,
#6  0x00000000005e7a5d in net/http.(</em>conn).serve (c=0xc42048afa0, ctx=â€¦)
#7  0x0000000000458e31 in runtime.goexit ()
#8  0x000000c42048afa0 in ?? ()
#9  0x00000000007cf100 in crypto/elliptic.p224ZeroModP63 ()
#10 0x000000c4204fd080 in ?? ()
#11 0x0000000000000000 in ?? ()
â€¦
Red Hat ç³»åˆ—çš„æœºå™¨å¯ä»¥ç›´æ¥ä½¿ç”¨ pstack å» Dump å½“å‰ä¸»è¿›ç¨‹å†…éƒ¨çš„è°ƒç”¨æ ˆæƒ…å†µï¼Œå¯æƒœ Ubuntu 64 Bit æ²¡æœ‰è¿™æ ·çš„åŒ…ï¼Œåªèƒ½è‡ªå·±å†™ä¸€ä¸ªè„šæœ¬å»è°ƒç”¨ gdb æ¥ Dumpã€‚</p>

<p>æˆªå–ä¸¤ä¸ªçº¿ç¨‹çš„è°ƒç”¨æ ˆä¿¡æ¯ï¼Œå‘ç°å®ƒä»¬éƒ½åœ¨ä¼‘çœ çŠ¶æ€ï¼Œå‡ ä¹éƒ½å¡åœ¨ /usr/local/go/src/syscall/asm_linux_amd64.s ä¸Šã€‚å¦‚æœéƒ½é˜»å¡äº†ï¼Œé‚£ä¹ˆå®ƒæ˜¯æ€ä¹ˆå¤„ç†æ–°æ¥çš„è¯·æ±‚ï¼Ÿ</p>

<p>// src/syscall/asm_linux_amd64.s</p>

<p>TEXT    Â·Syscall(SB),NOSPLIT,$0-56
        CALL    runtimeÂ·entersyscall(SB)
        MOVQ    a1+8(FP), DI
        MOVQ    a2+16(FP), SI
        MOVQ    a3+24(FP), DX
        MOVQ    $0, R10
        MOVQ    $0, R8
        MOVQ    $0, R9
        MOVQ    trap+0(FP), AX  // syscall entry
        SYSCALL
        CMPQ    AX, $0xfffffffffffff001
        JLS     ok
        MOVQ    $-1, r1+32(FP)
        MOVQ    $0, r2+40(FP)
        NEGQ    AX
        MOVQ    AX, err+48(FP)
        CALL    runtimeÂ·exitsyscall(SB)
        RET
ok:
        MOVQ    AX, r1+32(FP)
        MOVQ    DX, r2+40(FP)
        MOVQ    $0, err+48(FP)
        CALL    runtimeÂ·exitsyscall(SB)
        RET</p>

<p>Syscall ä¼šè°ƒç”¨ runtime.entersyscall ä¼šå°†å½“å‰ Processor çš„çŠ¶æ€è®¾ç½®ä¸º _Psyscallã€‚
å½“è¿›å…¥ç³»ç»Ÿè°ƒç”¨æ—¶é—´è¿‡é•¿æ—¶ï¼Œretake å‡½æ•°åœ¨è¿™äº› _Psyscall Processor çš„çŠ¶æ€æ”¹ä¸º _Pidleï¼Œé˜²æ­¢é•¿æ—¶é—´åœ°å ç”¨ Processor å¯¼è‡´æ•´ä½“ä¸å·¥ä½œã€‚</p>

<p>è¿›å…¥ç©ºé—²çŠ¶æ€çš„ Processor å¯èƒ½ä¼šè¢« wakep å‡½æ•°åˆ›å»ºå‡ºæ¥çš„æ–°è¿›ç¨‹ç»‘å®šä¸Šï¼Œç„¶è€Œæ–°çš„ Goroutine å¯èƒ½è¿˜ä¼šé™·å…¥é•¿æ—¶é—´çš„ç³»ç»Ÿè°ƒç”¨ï¼Œè¿™ä¸€æ¥å°±è¿›å…¥æ¶æ€§å¾ªç¯ï¼Œå¯¼è‡´ go binary åˆ›å»ºå‡ºå¤§é‡çš„çº¿ç¨‹ã€‚</p>

<p>å½“ç„¶ï¼ŒGolang ä¼šé™åˆ¶è¿™ä¸ªçº¿ç¨‹æ•°ç›®ã€‚</p>

<p>// src/runtime/proc.go</p>

<p>func checkmcount() {
        // sched lock is held
        if sched.mcount &gt; sched.maxmcount {
                print(â€œruntime: program exceeds â€œ, sched.maxmcount, â€œ-thread limit\nâ€)
                throw(â€œthread exhaustionâ€)
        }
}</p>

<p>å½“ Machine ä»å†…æ ¸æ€å›æ¥ä¹‹åï¼Œä¼šè¿›å…¥ runtime.exitsyscallã€‚
å¦‚æœæ‰§è¡Œæ—¶é—´å¾ˆçŸ­ï¼Œå®ƒä¼šå°è¯•åœ°å¤ºå›ä¹‹å‰çš„ Processor ï¼›æˆ–è€…æ˜¯å°è¯•ç»‘å®šç©ºé—²çš„ Processorï¼Œä¸€æ—¦ç»‘å®šä¸Šäº† Processor ï¼Œå®ƒä¾¿ä¼šç»§ç»­è¿è¡Œå½“å‰çš„ Goroutineã€‚
å¦‚æœéƒ½å¤±è´¥äº†ï¼ŒMachine å› ä¸ºæ²¡æœ‰å¯ç»‘å®šçš„ Processor è€Œå°†å½“å‰çš„ Goroutine æ”¾å›åˆ°å…¨å±€é˜Ÿåˆ—ä¸­ï¼Œå°†è‡ªå·±è¿›å…¥ä¼‘çœ çŠ¶æ€ï¼Œç­‰å¾…å…¶ä»– Machine æ¥å”¤é†’ã€‚</p>

<p>ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œgo binary ä¸ä¼šåˆ›å»ºç‰¹åˆ«å¤šçš„çº¿ç¨‹ï¼Œä½†æ˜¯ä¸Šçº¿çš„ä»£ç è¿˜æ˜¯éœ€è¦åšä¸€ä¸‹å‹æµ‹ï¼Œäº†è§£ä¸€ä¸‹ä»£ç çš„å®é™…æƒ…å†µã€‚
ä¸€æ—¦çœŸçš„åˆ›å»ºå¤§é‡çš„çº¿ç¨‹äº†ï¼ŒGolang ç›®å‰çš„ç‰ˆæœ¬æ˜¯ä¸ä¼šå›æ”¶è¿™äº›ç©ºé—²çš„çº¿ç¨‹ã€‚
ä¸è¿‡å¥½åœ¨ Go10/Go11 ä¼šæ”¹è¿›è¿™ä¸€ç¼ºç‚¹ï¼Œè¯¦æƒ…è¯·æŸ¥çœ‹ issues/14592ã€‚</p>

<ol>
  <li>æ€»ç»“
æœ¬æ–‡ç²—ç²’åº¦åœ°ä»‹ç»äº† Golang Goroutine Scheduler çš„å·¥ä½œæµç¨‹ï¼Œå¹¶æ²¡æœ‰æ¶‰åŠåˆ°åƒåœ¾å›æ”¶ï¼ŒNetpoll ä»¥åŠ Channel Send/Receive å¯¹è°ƒåº¦çš„å½±å“ï¼Œå¸Œæœ›èƒ½è®©è¯»è€…æœ‰ä¸ªå¤§ä½“çš„è®¤è¯†ã€‚</li>
</ol>

<p>runtime.mstart å†…éƒ¨çš„ç»†èŠ‚å¾ˆå¤šï¼Œè€Œä¸”å¾ˆå¤šå¹¶å‘æ“ä½œéƒ½å»ºç«‹åœ¨æ— é”çš„åŸºç¡€ä¸Šï¼Œè¿™æ ·èƒ½å‡å°‘é”å¯¹æ€§èƒ½çš„å½±å“ï¼Œæ„Ÿå…´è¶£çš„æœ‹å‹å¯ä»¥æ ¹æ®ä¸Šæ–‡æåˆ°çš„å‡½æ•°ä¸€æ­¥ä¸€æ­¥åœ°æŸ¥çœ‹ï¼Œåº”è¯¥ä¼šæœ‰ä¸å°‘çš„æ”¶è·ã€‚</p>

<ol>
  <li>Reference
Rob Pikeâ€™s 2012 Concurrency is not Parallelism
A Quick Guide to Goâ€™s Assembler
Scalable Go Scheduler Design Doc
Debugging performance issues in Go programs</li>
</ol>

<p>å‰ä¸€ç« æˆ‘ä»¬è¯¦ç»†åˆ†æäº†è°ƒåº¦å™¨çš„è°ƒåº¦ç­–ç•¥ï¼Œå³è°ƒåº¦å™¨å¦‚ä½•é€‰å–ä¸‹ä¸€ä¸ªè¿›å…¥è¿è¡Œçš„goroutineï¼Œä½†æˆ‘ä»¬è¿˜ä¸æ¸…æ¥šä»€ä¹ˆæ—¶å€™ä»¥åŠä»€ä¹ˆæƒ…å†µä¸‹ä¼šå‘ç”Ÿè°ƒåº¦ï¼Œä»è¿™ä¸€ç« å¼€å§‹æˆ‘ä»¬å°±æ¥è®¨è®ºè¿™ä¸ªé—®é¢˜ã€‚</p>

<p>æ€»ä½“è¯´æ¥ï¼Œgoè¯­è¨€çš„è°ƒåº¦å™¨ä¼šåœ¨ä»¥ä¸‹ä¸‰ç§æƒ…å†µä¸‹å¯¹goroutineè¿›è¡Œè°ƒåº¦ï¼š</p>

<p>goroutineæ‰§è¡ŒæŸä¸ªæ“ä½œå› æ¡ä»¶ä¸æ»¡è¶³éœ€è¦ç­‰å¾…è€Œå‘ç”Ÿçš„è°ƒåº¦ï¼›</p>

<p>goroutineä¸»åŠ¨è°ƒç”¨Gosched()å‡½æ•°è®©å‡ºCPUè€Œå‘ç”Ÿçš„è°ƒåº¦ï¼›</p>

<p>goroutineè¿è¡Œæ—¶é—´å¤ªé•¿æˆ–é•¿æ—¶é—´å¤„äºç³»ç»Ÿè°ƒç”¨ä¹‹ä¸­è€Œè¢«è°ƒåº¦å™¨å‰¥å¤ºè¿è¡Œæƒè€Œå‘ç”Ÿçš„è°ƒåº¦ã€‚</p>

<p>æœ¬ç« ä¸»è¦åˆ†ææˆ‘ä»¬ç§°ä¹‹ä¸ºè¢«åŠ¨è°ƒåº¦çš„ç¬¬1ç§è°ƒåº¦ï¼Œå‰©ä¸‹çš„ä¸¤ç§è°ƒåº¦å°†åœ¨åé¢ä¸¤ç« åˆ†åˆ«è¿›è¡Œè®¨è®ºã€‚</p>

<p>Demoä¾‹å­</p>

<p>æˆ‘ä»¬ä»¥ä¸€ä¸ªdemoç¨‹åºä¸ºä¾‹æ¥åˆ†æå› é˜»å¡è€Œå‘ç”Ÿçš„è¢«åŠ¨è°ƒåº¦ã€‚</p>

<p>package main</p>

<p>func start(c chan int) {
    c&lt;-100
}</p>

<p>func main() {
    c:=make(chan int)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go start(c)

&lt;-c }  è¯¥ç¨‹åºå¯åŠ¨æ—¶ï¼Œmain goroutineé¦–å…ˆä¼šåˆ›å»ºä¸€ä¸ªæ— ç¼“å­˜çš„channelï¼Œç„¶åå¯åŠ¨ä¸€ä¸ªgoroutine(ä¸ºäº†æ–¹ä¾¿è®¨è®ºæˆ‘ä»¬ç§°å®ƒä¸ºg2)å‘channelå‘é€æ•°æ®ï¼Œè€Œmainè‡ªå·±åˆ™å»è¯»å–è¿™ä¸ªchannelã€‚
</code></pre></div></div>

<p>è¿™ä¸¤ä¸ªgoroutineè¯»å†™channelæ—¶ä¸€å®šä¼šå‘ç”Ÿä¸€æ¬¡é˜»å¡ï¼Œä¸æ˜¯main goroutineè¯»å–channelæ—¶å‘ç”Ÿé˜»å¡å°±æ˜¯g2å†™å…¥channelæ—¶å‘ç”Ÿé˜»å¡ã€‚</p>

<p>åˆ›å»ºg2 goroutine</p>

<p>é¦–å…ˆç”¨gdbåæ±‡ç¼–ä¸€ä¸‹mainå‡½æ•°ï¼Œçœ‹çœ‹æ±‡ç¼–ä»£ç ã€‚</p>

<p>0x44f4d0&lt;+0&gt;: mov   %fs:0xfffffffffffffff8,%rcx
0x44f4d9&lt;+9&gt;: cmp   0x10(%rcx),%rsp
0x44f4dd&lt;+13&gt;: jbe   0x44f549 &lt;main.main+121&gt;
0x44f4df&lt;+15&gt;: sub   $0x28,%rsp
0x44f4e3&lt;+19&gt;: mov   %rbp,0x20(%rsp)
0x44f4e8&lt;+24&gt;: lea   0x20(%rsp),%rbp
0x44f4ed&lt;+29&gt;: lea   0xb36c(%rip),%rax     <br />
0x44f4f4&lt;+36&gt;: mov   %rax,(%rsp)
0x44f4f8&lt;+40&gt;: movq   $0x0,0x8(%rsp)
0x44f501&lt;+49&gt;: callq    0x404330 <runtime.makechan>  #åˆ›å»ºchannel
0x44f506&lt;+54&gt;: mov   0x10(%rsp),%rax
0x44f50b&lt;+59&gt;: mov   %rax,0x18(%rsp)
0x44f510&lt;+64&gt;: movl   $0x8,(%rsp)
0x44f517&lt;+71&gt;: lea   0x240f2(%rip),%rcx       
0x44f51e&lt;+78&gt;: mov   %rcx,0x8(%rsp)
0x44f523&lt;+83&gt;: callq   0x42c1b0 <runtime.newproc> #åˆ›å»ºgoroutine
0x44f528&lt;+88&gt;: mov   0x18(%rsp),%rax
0x44f52d&lt;+93&gt;: mov   %rax,(%rsp)
0x44f531&lt;+97&gt;: movq   $0x0,0x8(%rsp)
0x44f53a&lt;+106&gt;: callq   0x405080 <runtime.chanrecv1> #ä»channelè¯»å–æ•°æ®
0x44f53f&lt;+111&gt;: mov   0x20(%rsp),%rbp
0x44f544&lt;+116&gt;: add   $0x28,%rsp
0x44f548&lt;+120&gt;: retq   
0x44f549&lt;+121&gt;: callq 0x447390 <runtime.morestack_noctxt>
0x44f54e&lt;+126&gt;: jmp   0x44f4d0 <main.main>
ä»mainå‡½æ•°çš„æ±‡ç¼–ä»£ç æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œåˆ›å»ºgoroutineçš„goå…³é”®å­—è¢«ç¼–è¯‘å™¨ç¿»è¯‘æˆäº†å¯¹runtime.newprocå‡½æ•°çš„è°ƒç”¨ï¼Œç¬¬äºŒç« æˆ‘ä»¬å¯¹è¿™ä¸ªå‡½æ•°çš„ä¸»è¦æµç¨‹åšè¿‡è¯¦ç»†åˆ†æï¼Œè¿™é‡Œç®€å•çš„å›é¡¾ä¸€ä¸‹ï¼š</main.main></runtime.morestack_noctxt></runtime.chanrecv1></runtime.newproc></runtime.makechan></p>

<p>åˆ‡æ¢åˆ°g0æ ˆï¼›</p>

<p>åˆ†é…gç»“æ„ä½“å¯¹è±¡ï¼›</p>

<p>åˆå§‹åŒ–gå¯¹åº”çš„æ ˆä¿¡æ¯ï¼Œå¹¶æŠŠå‚æ•°æ‹·è´åˆ°æ–°gçš„æ ˆä¸Šï¼›</p>

<p>è®¾ç½®å¥½gçš„schedæˆå‘˜ï¼Œè¯¥æˆå‘˜åŒ…æ‹¬è°ƒåº¦gæ—¶æ‰€å¿…é¡»pc, sp, bpç­‰è°ƒåº¦ä¿¡æ¯ï¼›</p>

<p>è°ƒç”¨runqputå‡½æ•°æŠŠgæ”¾å…¥è¿è¡Œé˜Ÿåˆ—ï¼›</p>

<p>è¿”å›</p>

<p>å› ä¸ºå½“æ—¶æˆ‘ä»¬çš„ä¸»è¦ç›®æ ‡æ˜¯è°ƒåº¦å™¨çš„åˆå§‹åŒ–éƒ¨åˆ†ï¼Œæ‰€ä»¥å¹¶æ²¡æœ‰è¯¦ç»†åˆ†æä¸Šè¿°æµç¨‹ä¸­çš„ç¬¬5æ­¥ï¼Œä¹Ÿå°±æ˜¯runqputæ˜¯å¦‚ä½•æŠŠgoroutineæ”¾å…¥è¿è¡Œé˜Ÿåˆ—çš„ï¼Œç°åœ¨å°±å›å¤´åˆ†æä¸€ä¸‹è¿™ä¸ªè¿‡ç¨‹ï¼Œä¸‹é¢æˆ‘ä»¬ç›´æ¥ä»runqputå‡½æ•°å¼€å§‹ã€‚</p>

<p>é€šè¿‡runqputå‡½æ•°æŠŠgoroutineæŒ‚å…¥è¿è¡Œé˜Ÿåˆ—</p>

<p>runtime/proc.go : 4746</p>

<p>// runqput tries to put g on the local runnable queue.
// If next is false, runqput adds g to the tail of the runnable queue.
// If next is true, runqput puts g in the <em>p</em>.runnext slot.
// If the run queue is full, runnext puts g on the global queue.
// Executed only by the owner P.
func runqput(<em>p</em> *p, gp *g, next bool)   {
    if randomizeScheduler &amp;&amp; next &amp;&amp; fastrand() % 2 == 0  {
        next = false
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if next  {
    //æŠŠgpæ”¾åœ¨_p_.runnextæˆå‘˜é‡Œï¼Œ
    //runnextæˆå‘˜ä¸­çš„goroutineä¼šè¢«ä¼˜å…ˆè°ƒåº¦èµ·æ¥è¿è¡Œ
retryNext:
    oldnext := _p_.runnext
    if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp)))  {
         //æœ‰å…¶å®ƒçº¿ç¨‹åœ¨æ“ä½œrunnextæˆå‘˜ï¼Œéœ€è¦é‡è¯•
        goto retryNext
    }
    if oldnext == 0  { //åŸæœ¬runnextä¸ºnilï¼Œæ‰€ä»¥æ²¡ä»»ä½•äº‹æƒ…å¯åšäº†ï¼Œç›´æ¥è¿”å›
        return
    }
    // Kick the old runnext out to the regular run queue.
    gp = oldnext.ptr() //åŸæœ¬å­˜æ”¾åœ¨runnextçš„gpéœ€è¦æ”¾å…¥runqçš„å°¾éƒ¨
}
</code></pre></div></div>

<p>retry:
    //å¯èƒ½æœ‰å…¶å®ƒçº¿ç¨‹æ­£åœ¨å¹¶å‘ä¿®æ”¹runqheadæˆå‘˜ï¼Œæ‰€ä»¥éœ€è¦è·Ÿå…¶å®ƒçº¿ç¨‹åŒæ­¥
    h := atomic.LoadAcq(&amp;<em>p</em>.runqhead) // load-acquire, synchronize with consumers
    t := <em>p</em>.runqtail
    if t - h &lt; uint32(len(<em>p</em>.runq))  { //åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦æ»¡äº†
        //é˜Ÿåˆ—è¿˜æ²¡æœ‰æ»¡ï¼Œå¯ä»¥æ”¾å…¥
        <em>p</em>.runq[t % uint32(len(<em>p</em>.runq))].set(gp)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // store-release, makes it available for consumption
    //è™½ç„¶æ²¡æœ‰å…¶å®ƒçº¿ç¨‹å¹¶å‘ä¿®æ”¹è¿™ä¸ªrunqtailï¼Œä½†å…¶å®ƒçº¿ç¨‹ä¼šå¹¶å‘è¯»å–è¯¥å€¼ä»¥åŠpçš„runqæˆå‘˜
    //è¿™é‡Œä½¿ç”¨StoreRelæ˜¯ä¸ºäº†ï¼š
    //1ï¼ŒåŸå­å†™å…¥runqtail
    //2ï¼Œé˜²æ­¢ç¼–è¯‘å™¨å’ŒCPUä¹±åºï¼Œä¿è¯ä¸Šä¸€è¡Œä»£ç å¯¹runqçš„ä¿®æ”¹å‘ç”Ÿåœ¨ä¿®æ”¹runqtailä¹‹å‰
    //3ï¼Œå¯è§è¡Œå±éšœï¼Œä¿è¯å½“å‰çº¿ç¨‹å¯¹è¿è¡Œé˜Ÿåˆ—çš„ä¿®æ”¹å¯¹å…¶å®ƒçº¿ç¨‹ç«‹é©¬å¯è§
    atomic.StoreRel(&amp;_p_.runqtail, t + 1)
    return
}
//pçš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—å·²æ»¡ï¼Œéœ€è¦æ”¾å…¥å…¨å±€è¿è¡Œé˜Ÿåˆ—
if runqputslow(_p_, gp, h, t) {
    return
}
// the queue is not full, now the put above must succeed
goto retry } runqputå‡½æ•°æµç¨‹å¾ˆæ¸…æ™°ï¼Œå®ƒé¦–å…ˆå°è¯•æŠŠgpæ”¾å…¥_p_çš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—ï¼Œå¦‚æœæœ¬åœ°é˜Ÿåˆ—æ»¡äº†ï¼Œåˆ™é€šè¿‡runqputslowå‡½æ•°æŠŠgpæ”¾å…¥å…¨å±€è¿è¡Œé˜Ÿåˆ—ã€‚
</code></pre></div></div>

<p>runtime/proc.go : 4784</p>

<p>// Put g and a batch of work from local runnable queue on global queue.
// Executed only by the owner P.
func runqputslow(<em>p</em> <em>p, gp *g, h, t uint32) bool  {
    var batch [len(_p_.runq) / 2 + 1]</em>g  //gpåŠ ä¸Š_p_æœ¬åœ°é˜Ÿåˆ—çš„ä¸€åŠ</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// First, grab a batch from local queue.
n := t - h
n = n / 2
if n != uint32(len(_p_.runq) / 2)  {
    throw("runqputslow: queue is not full")
}
for i := uint32(0); i &lt; n; i++ { //å–å‡ºpæœ¬åœ°é˜Ÿåˆ—çš„ä¸€åŠ
    batch[i] = _p_.runq[(h+i) % uint32(len(_p_.runq))].ptr()
}
if !atomic.CasRel(&amp;_p_.runqhead, h, h + n)  { // cas-release, commits consume
    //å¦‚æœcasæ“ä½œå¤±è´¥ï¼Œè¯´æ˜å·²ç»æœ‰å…¶å®ƒå·¥ä½œçº¿ç¨‹ä»_p_çš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—å·èµ°äº†ä¸€äº›goroutineï¼Œæ‰€ä»¥ç›´æ¥è¿”å›
    return false
}
batch[n] = gp

if randomizeScheduler {
    for i := uint32(1); i &lt;= n; i++ {
        j := fastrandn(i + 1)
        batch[i], batch[j] = batch[j], batch[i]
    }
}

// Link the goroutines.
//å…¨å±€è¿è¡Œé˜Ÿåˆ—æ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œè¿™é‡Œé¦–å…ˆæŠŠæ‰€æœ‰éœ€è¦æ”¾å…¥å…¨å±€è¿è¡Œé˜Ÿåˆ—çš„gé“¾æ¥èµ·æ¥ï¼Œ
//å‡å°‘åé¢å¯¹å…¨å±€é“¾è¡¨çš„é”ä½æ—¶é—´ï¼Œä»è€Œé™ä½é”å†²çª
for i := uint32(0); i &lt; n; i++  {
    batch[i].schedlink.set(batch[i+1])
}
var q gQueue
q.head.set(batch[0])
q.tail.set(batch[n])

// Now put the batch on global queue.
lock(&amp;sched.lock)
globrunqputbatch(&amp;q, int32(n+1))
unlock(&amp;sched.lock)
return true } runqputslowå‡½æ•°é¦–å…ˆä½¿ç”¨é“¾è¡¨æŠŠä»_p_çš„æœ¬åœ°é˜Ÿåˆ—ä¸­å–å‡ºçš„ä¸€åŠè¿åŒgpä¸€èµ·ä¸²è”èµ·æ¥ï¼Œç„¶ååœ¨åŠ é”æˆåŠŸä¹‹åé€šè¿‡globrunqputbatchå‡½æ•°æŠŠè¯¥é“¾è¡¨é“¾å…¥å…¨å±€è¿è¡Œé˜Ÿåˆ—ï¼ˆå…¨å±€è¿è¡Œé˜Ÿåˆ—æ˜¯ä½¿ç”¨é“¾è¡¨å®ç°çš„ï¼‰ã€‚å€¼çš„ä¸€æçš„æ˜¯runqputslowå‡½æ•°å¹¶æ²¡æœ‰ä¸€å¼€å§‹å°±æŠŠå…¨å±€è¿è¡Œé˜Ÿåˆ—é”ä½ï¼Œè€Œæ˜¯ç­‰æ‰€æœ‰çš„å‡†å¤‡å·¥ä½œåšå®Œä¹‹åæ‰é”ä½å…¨å±€è¿è¡Œé˜Ÿåˆ—ï¼Œè¿™æ˜¯å¹¶å‘ç¼–ç¨‹åŠ é”çš„åŸºæœ¬åŸåˆ™ï¼Œéœ€è¦å°½é‡å‡å°é”çš„ç²’åº¦ï¼Œé™ä½é”å†²çªçš„æ¦‚ç‡ã€‚
</code></pre></div></div>

<p>åˆ†æå®Œrunqputå‡½æ•°æ˜¯å¦‚ä½•æŠŠgoroutineæ”¾å…¥è¿è¡Œé˜Ÿåˆ—ä¹‹åï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬ç»§ç»­åˆ†æmain goroutineå› è¯»å–channelè€Œå‘ç”Ÿçš„é˜»å¡æµç¨‹ã€‚</p>

<p>å› è¯»å–channelé˜»å¡è€Œå‘ç”Ÿçš„è¢«åŠ¨è°ƒåº¦</p>

<p>ä»ä»£ç é€»è¾‘çš„è§’åº¦æ¥è¯´ï¼Œæˆ‘ä»¬ä¸èƒ½ç¡®å®šmain goroutineå’Œæ–°åˆ›å»ºå‡ºæ¥çš„g2è°å…ˆè¿è¡Œï¼Œä½†å¯¹äºæˆ‘ä»¬åˆ†ææ¥è¯´æˆ‘ä»¬å¯ä»¥å‡å®šæŸä¸ªgoroutineå…ˆè¿è¡Œï¼Œå› ä¸ºä¸ç®¡è°å…ˆè¿è¡Œï¼Œéƒ½ä¼šé˜»å¡åœ¨channelçš„è¯»æˆ–åˆ™å†™ä¸Šï¼Œæ‰€ä»¥è¿™é‡Œæˆ‘ä»¬å‡è®¾mainåˆ›å»ºå¥½g2åé¦–å…ˆé˜»å¡åœ¨äº†å¯¹channelçš„è¯»æ“ä½œä¸Šã€‚ä¸‹é¢æˆ‘ä»¬çœ‹çœ‹è¯»å–channelçš„è¿‡ç¨‹ã€‚</p>

<p>ä»å‰é¢çš„åæ±‡ç¼–ä»£ç æˆ‘ä»¬çŸ¥é“è¯»å–channelæ˜¯é€šè¿‡è°ƒç”¨runtime.chanrecv1å‡½æ•°æ¥å®Œæˆçš„ï¼Œæˆ‘ä»¬å°±ä»å®ƒå¼€å§‹åˆ†æï¼Œä¸è¿‡åœ¨åˆ†æè¿‡ç¨‹ä¸­æˆ‘ä»¬ä¸ä¼šæŠŠç²¾åŠ›æ”¾åœ¨å¯¹channelçš„æ“ä½œä¸Šï¼Œè€Œæ˜¯åˆ†æè¿™ä¸ªè¿‡ç¨‹ä¸­è·Ÿè°ƒåº¦æœ‰å…³çš„ç»†èŠ‚ã€‚</p>

<p>runtime/chan.go : 403</p>

<p>// entry points for &lt;- c from compiled code
//go:nosplit
func chanrecv1(c *hchan, elem unsafe.Pointer) {
    chanrecv(c, elem, true)
}</p>

<p>// runtime/chan.go : 415
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
    â€¦â€¦
    //çœç•¥éƒ¨åˆ†çš„ä»£ç é€»è¾‘ä¸»è¦åœ¨åˆ¤æ–­è¯»å–æ“ä½œæ˜¯å¦å¯ä»¥ç«‹å³å®Œæˆï¼Œå¦‚æœä¸èƒ½ç«‹å³å®Œæˆ
    //å°±éœ€è¦æŠŠgæŒ‚åœ¨channel cçš„è¯»å–é˜Ÿåˆ—ä¸Šï¼Œç„¶åè°ƒç”¨goparkunlockå‡½æ•°é˜»å¡æ­¤goroutine
    goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, 3)
    â€¦â€¦
}
chanrecv1ç›´æ¥è°ƒç”¨chanrecvå‡½æ•°å®ç°è¯»å–æ“ä½œï¼Œchanrecvé¦–å…ˆä¼šåˆ¤æ–­channelæ˜¯å¦æœ‰æ•°æ®å¯è¯»ï¼Œå¦‚æœæœ‰æ•°æ®åˆ™ç›´æ¥è¯»å–å¹¶è¿”å›ï¼Œä½†å¦‚æœæ²¡æœ‰æ•°æ®ï¼Œåˆ™éœ€è¦æŠŠå½“å‰goroutineæŒ‚å…¥channelçš„è¯»å–é˜Ÿåˆ—ä¹‹ä¸­å¹¶è°ƒç”¨goparkunlockå‡½æ•°é˜»å¡è¯¥goroutine.</p>

<p>runtime/proc.go : 304</p>

<p>// Puts the current goroutine into a waiting state and unlocks the lock.
// The goroutine can be made runnable again by calling goready(gp).
func goparkunlock(lock*mutex, reasonwaitReason, traceEvbyte, traceskipint) {
    gopark(parkunlock_c, unsafe.Pointer(lock), reason, traceEv, traceskip)
}</p>

<p>// runtime/proc.go : 276
// Puts the current goroutine into a waiting state and calls unlockf.
// If unlockf returns false, the goroutine is resumed.
// unlockf must not access this Gâ€™s stack, as it may be moved between
// the call to gopark and the call to unlockf.
// Reason explains why the goroutine has been parked.
// It is displayed in stack traces and heap dumps.
// Reasons should be unique and descriptive.
// Do not re-use reasons, add new ones.
func gopark(unlockffunc(*g, unsafe.Pointer) bool, lockunsafe.Pointer, reason    waitReason, traceEvbyte, traceskipint) {
    â€¦â€¦
    // canâ€™t do anything that might move the G between Ms here.
    mcall(park_m) //åˆ‡æ¢åˆ°g0æ ˆæ‰§è¡Œpark_må‡½æ•°
}
goparkunlockå‡½æ•°ç›´æ¥è°ƒç”¨goparkå‡½æ•°ï¼Œgoparkåˆ™è°ƒç”¨mcallä»å½“å‰main goroutineåˆ‡æ¢åˆ°g0å»æ‰§è¡Œpark_må‡½æ•°ï¼ˆmcallå‰é¢æˆ‘ä»¬åˆ†æè¿‡ï¼Œå…¶ä¸»è¦ä½œç”¨å°±æ˜¯ä¿å­˜å½“å‰goroutineçš„ç°åœºï¼Œç„¶ååˆ‡æ¢åˆ°g0æ ˆå»è°ƒç”¨ä½œä¸ºå‚æ•°ä¼ é€’ç»™å®ƒçš„å‡½æ•°ï¼‰</p>

<p>runtime/proc.go : 2581</p>

<p>// park continuation on g0.
func park_m(gp*g) {
    <em>g</em> := getg()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if trace.enabled {
    traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)
}

casgstatus(gp, _Grunning, _Gwaiting)
dropg()  //è§£é™¤gå’Œmä¹‹é—´çš„å…³ç³»

......
   
schedule() } park_mé¦–å…ˆæŠŠå½“å‰goroutineçš„çŠ¶æ€è®¾ç½®ä¸º_Gwaitingï¼ˆå› ä¸ºå®ƒæ­£åœ¨ç­‰å¾…å…¶å®ƒgoroutineå¾€channelé‡Œé¢å†™æ•°æ®ï¼‰ï¼Œç„¶åè°ƒç”¨dropgå‡½æ•°è§£é™¤gå’Œmä¹‹é—´çš„å…³ç³»ï¼Œæœ€åé€šè¿‡è°ƒç”¨scheduleå‡½æ•°è¿›å…¥è°ƒåº¦å¾ªç¯ï¼Œscheduleå‡½æ•°æˆ‘ä»¬ä¹Ÿè¯¦ç»†åˆ†æè¿‡ï¼Œå®ƒé¦–å…ˆä¼šä»è¿è¡Œé˜Ÿåˆ—ä¸­æŒ‘é€‰å‡ºä¸€ä¸ªgoroutineï¼Œç„¶åè°ƒç”¨gogoå‡½æ•°åˆ‡æ¢åˆ°è¢«æŒ‘é€‰å‡ºæ¥çš„goroutineå»è¿è¡Œã€‚å› ä¸ºmain goroutineåœ¨è¯»å–channelè¢«é˜»å¡ä¹‹å‰å·²ç»æŠŠåˆ›å»ºå¥½çš„g2æ”¾å…¥äº†è¿è¡Œé˜Ÿåˆ—ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œscheduleä¼šæŠŠg2è°ƒåº¦èµ·æ¥è¿è¡Œï¼Œè¿™é‡Œå®Œæˆäº†ä¸€æ¬¡ä»main goroutineåˆ°g2è°ƒåº¦ï¼ˆæˆ‘ä»¬å‡è®¾åªæœ‰ä¸€ä¸ªå·¥ä½œçº¿ç¨‹åœ¨è¿›è¡Œè°ƒåº¦ï¼‰ã€‚
</code></pre></div></div>

<p>å”¤é†’é˜»å¡åœ¨channelä¸Šçš„goroutine</p>

<p>g2 goroutineçš„å…¥å£æ˜¯startå‡½æ•°ï¼Œä¸‹é¢æˆ‘ä»¬å°±ä»è¯¥å‡½æ•°å¼€å§‹åˆ†æg2å†™channelçš„æµç¨‹ï¼Œçœ‹å®ƒå¦‚ä½•å”¤é†’æ­£åœ¨ç­‰å¾…ç€è¯»å–channelçš„main goroutineã€‚è¿˜æ˜¯å…ˆæ¥åæ±‡ç¼–ä¸€ä¸‹startå‡½æ•°çš„ä»£ç ï¼š</p>

<p>0x44f480&lt;+0&gt;:mov   %fs:0xfffffffffffffff8,%rcx
0x44f489&lt;+9&gt;:cmp   0x10(%rcx),%rsp
0x44f48d&lt;+13&gt;:jbe   0x44f4c1 &lt;main.start+65&gt;
0x44f48f&lt;+15&gt;:sub   $0x18,%rsp
0x44f493&lt;+19&gt;:mov   %rbp,0x10(%rsp)
0x44f498&lt;+24&gt;:lea   0x10(%rsp),%rbp
0x44f49d&lt;+29&gt;:mov   0x20(%rsp),%rax
0x44f4a2&lt;+34&gt;:mov   %rax,(%rsp)
0x44f4a6&lt;+38&gt;:lea   0x2d71b(%rip),%rax     <br />
0x44f4ad&lt;+45&gt;:mov   %rax,0x8(%rsp)
0x44f4b2&lt;+50&gt;:callq   0x404560 <runtime.chansend1> #å†™channel
0x44f4b7&lt;+55&gt;:mov   0x10(%rsp),%rbp
0x44f4bc&lt;+60&gt;:add   $0x18,%rsp
0x44f4c0&lt;+64&gt;:retq   
0x44f4c1&lt;+65&gt;:callq    0x447390 <runtime.morestack_noctxt>
0x44f4c6&lt;+70&gt;:jmp   0x44f480 <main.start>
å¯ä»¥çœ‹åˆ°ï¼Œç¼–è¯‘å™¨æŠŠå¯¹channelçš„å‘é€æ“ä½œç¿»è¯‘æˆäº†å¯¹runtime.chansend1å‡½æ•°çš„è°ƒç”¨</main.start></runtime.morestack_noctxt></runtime.chansend1></p>

<p>runtime/chan.go : 124</p>

<p>/ entry point for c &lt;- x from compiled code
//go:nosplit
func chansend1(c *hchan, elem unsafe.Pointer) {
    chansend(c, elem, true, getcallerpc())
}</p>

<p>// runtime/chan.go : 142
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
    â€¦â€¦
    if sg := c.recvq.dequeue(); sg != nil {
        // Found a waiting receiver. We pass the value we want to send
        // directly to the receiver, bypassing the channel buffer (if any).
        //å¯ä»¥ç›´æ¥å‘é€æ•°æ®ç»™sg
        send(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)
        return true
    }
    â€¦â€¦
}</p>

<p>// runtime/chan.go : 269
func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {
    â€¦â€¦
    goready(gp, skip+1)
}</p>

<p>// runtime/proc.go : 310
func goready(gp *g, traceskip int) {
    systemstack(func() {
        ready(gp, traceskip, true)
    })
}
channelå‘é€å’Œè¯»å–çš„æµç¨‹ç±»ä¼¼ï¼Œå¦‚æœèƒ½å¤Ÿç«‹å³å‘é€åˆ™ç«‹å³å‘é€å¹¶è¿”å›ï¼Œå¦‚æœä¸èƒ½ç«‹å³å‘é€åˆ™éœ€è¦é˜»å¡ï¼Œåœ¨æˆ‘ä»¬è¿™ä¸ªåœºæ™¯ä¸­ï¼Œå› ä¸ºmain goroutineæ­¤æ—¶æ­¤åˆ»æ­£æŒ‚åœ¨channelçš„è¯»å–é˜Ÿåˆ—ä¸Šç­‰å¾…æ•°æ®ï¼Œæ‰€ä»¥è¿™é‡Œç›´æ¥è°ƒç”¨sendå‡½æ•°å‘é€ç»™main goroutineï¼Œsendå‡½æ•°åˆ™è°ƒç”¨goreadyå‡½æ•°åˆ‡æ¢åˆ°g0æ ˆå¹¶è°ƒç”¨readyå‡½æ•°æ¥å”¤é†’sgå¯¹åº”çš„goroutineï¼Œå³æ­£åœ¨ç­‰å¾…è¯»channelçš„main goroutineã€‚</p>

<p>runtime/proc.go : 639</p>

<p>// Mark gp ready to run.
func ready(gp *g, traceskip int, next bool) {
    â€¦â€¦
    // Mark runnable.
    <em>g</em> := getg()
    â€¦â€¦
    // status is Gwaiting or Gscanwaiting, make Grunnable and put on runq
    casgstatus(gp, <em>Gwaiting, _Grunnable)
    runqput(_g</em>.m.p.ptr(), gp, next) //æ”¾å…¥è¿è¡Œé˜Ÿåˆ—
    if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 {
        //æœ‰ç©ºé—²çš„pè€Œä¸”æ²¡æœ‰æ­£åœ¨å·å–goroutineçš„å·¥ä½œçº¿ç¨‹ï¼Œåˆ™éœ€è¦å”¤é†’på‡ºæ¥å·¥ä½œ
        wakep()
    }
    â€¦â€¦
}
readyå‡½æ•°é¦–å…ˆæŠŠéœ€è¦å”¤é†’çš„goroutineçš„çŠ¶æ€è®¾ç½®ä¸º_Grunnableï¼Œç„¶åæŠŠå…¶æ”¾å…¥è¿è¡Œé˜Ÿåˆ—ä¹‹ä¸­ç­‰å¾…è°ƒåº¦å™¨çš„è°ƒåº¦ã€‚</p>

<p>å¯¹äºæœ¬ç« æˆ‘ä»¬åˆ†æçš„åœºæ™¯ï¼Œæ‰§è¡Œåˆ°è¿™é‡Œmain goroutineå·²ç»è¢«æ”¾å…¥äº†è¿è¡Œé˜Ÿåˆ—ï¼Œä½†è¿˜æœªè¢«è°ƒåº¦èµ·æ¥è¿è¡Œï¼Œè€Œg2 goroutineåœ¨å‘channelå†™å®Œæ•°æ®ä¹‹åå°±ä»è¿™é‡Œçš„readyå‡½æ•°è¿”å›å¹¶é€€å‡ºäº†ï¼Œä»ç¬¬äºŒç« æˆ‘ä»¬å¯¹goroutineçš„é€€å‡ºæµç¨‹çš„åˆ†æå¯ä»¥å¾—çŸ¥ï¼Œåœ¨g2çš„é€€å‡ºè¿‡ç¨‹ä¸­å°†ä¼šåœ¨goexit0å‡½æ•°ä¸­è°ƒç”¨scheduleå‡½æ•°è¿›å…¥ä¸‹ä¸€è½®è°ƒåº¦ï¼Œä»è€ŒæŠŠåˆšåˆšæ”¾å…¥è¿è¡Œé˜Ÿåˆ—çš„main goroutineè°ƒåº¦èµ·æ¥è¿è¡Œã€‚</p>

<p>åœ¨ä¸Šé¢åˆ†æreadyå‡½æ•°æ—¶æˆ‘ä»¬ç•¥è¿‡äº†ä¸€ç§æƒ…å†µï¼šå¦‚æœå½“å‰æœ‰ç©ºé—²çš„pè€Œä¸”æ²¡æœ‰å·¥ä½œçº¿ç¨‹æ­£åœ¨å°è¯•ä»å„ä¸ªå·¥ä½œçº¿ç¨‹çš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—å·å–goroutineçš„è¯ï¼ˆæ²¡æœ‰å¤„äºspinningçŠ¶æ€çš„å·¥ä½œçº¿ç¨‹ï¼‰ï¼Œé‚£ä¹ˆå°±éœ€è¦é€šè¿‡wakepå‡½æ•°æŠŠç©ºé—²çš„på”¤é†’èµ·æ¥å·¥ä½œã€‚ä¸ºäº†ä¸è®©ç¯‡å¹…è¿‡é•¿ï¼Œä¸‹ä¸€èŠ‚æˆ‘ä»¬å†æ¥åˆ†æwakepå¦‚ä½•å»å”¤é†’å’Œåˆ›å»ºæ–°çš„å·¥ä½œçº¿ç¨‹</p>

<p>ä½œè€…ï¼šçŸ¥ä¹ç”¨æˆ·
é“¾æ¥ï¼šhttps://www.zhihu.com/question/20862617/answer/27964865
æ¥æºï¼šçŸ¥ä¹
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚</p>

<p>Go runtimeçš„è°ƒåº¦å™¨ï¼šåœ¨äº†è§£Goçš„è¿è¡Œæ—¶çš„schedulerä¹‹å‰ï¼Œéœ€è¦å…ˆäº†è§£ä¸ºä»€ä¹ˆéœ€è¦å®ƒï¼Œå› ä¸ºæˆ‘ä»¬å¯èƒ½ä¼šæƒ³ï¼ŒOSå†…æ ¸ä¸æ˜¯å·²ç»æœ‰ä¸€ä¸ªçº¿ç¨‹scheduleräº†å˜›ï¼Ÿç†Ÿæ‚‰POSIX APIçš„äººéƒ½çŸ¥é“ï¼ŒPOSIXçš„æ–¹æ¡ˆåœ¨å¾ˆå¤§ç¨‹åº¦ä¸Šæ˜¯å¯¹Unix processè¿›åœºæ¨¡å‹çš„ä¸€ä¸ªé€»è¾‘æè¿°å’Œæ‰©å±•ï¼Œä¸¤è€…æœ‰å¾ˆå¤šç›¸ä¼¼çš„åœ°æ–¹ã€‚ Threadæœ‰è‡ªå·±çš„ä¿¡å·æ©ç ï¼ŒCPU affinityç­‰ã€‚ä½†æ˜¯å¾ˆå¤šç‰¹å¾å¯¹äºGoç¨‹åºæ¥è¯´éƒ½æ˜¯ç´¯èµ˜ã€‚ å°¤å…¶æ˜¯contextä¸Šä¸‹æ–‡åˆ‡æ¢çš„è€—æ—¶ã€‚å¦ä¸€ä¸ªåŸå› æ˜¯Goçš„åƒåœ¾å›æ”¶éœ€è¦æ‰€æœ‰çš„goroutineåœæ­¢ï¼Œä½¿å¾—å†…å­˜åœ¨ä¸€ä¸ªä¸€è‡´çš„çŠ¶æ€ã€‚åƒåœ¾å›æ”¶çš„æ—¶é—´ç‚¹æ˜¯ä¸ç¡®å®šçš„ï¼Œå¦‚æœä¾é OSè‡ªèº«çš„scheduleræ¥è°ƒåº¦ï¼Œé‚£ä¹ˆä¼šæœ‰å¤§é‡çš„çº¿ç¨‹éœ€è¦åœæ­¢å·¥ä½œã€‚ å•ç‹¬çš„å¼€å‘ä¸€ä¸ªGOå¾—è°ƒåº¦å™¨ï¼Œå¯ä»¥æ˜¯å…¶çŸ¥é“åœ¨ä»€ä¹ˆæ—¶å€™å†…å­˜çŠ¶æ€æ˜¯ä¸€è‡´çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå½“å¼€å§‹åƒåœ¾å›æ”¶æ—¶ï¼Œè¿è¡Œæ—¶åªéœ€è¦ä¸ºå½“æ—¶æ­£åœ¨CPUæ ¸ä¸Šè¿è¡Œçš„é‚£ä¸ªçº¿ç¨‹ç­‰å¾…å³å¯ï¼Œè€Œä¸æ˜¯ç­‰å¾…æ‰€æœ‰çš„çº¿ç¨‹ã€‚ç”¨æˆ·ç©ºé—´çº¿ç¨‹å’Œå†…æ ¸ç©ºé—´çº¿ç¨‹ä¹‹é—´çš„æ˜ å°„å…³ç³»æœ‰ï¼šN:1,1:1å’ŒM:NN:1æ˜¯è¯´ï¼Œå¤šä¸ªï¼ˆNï¼‰ç”¨æˆ·çº¿ç¨‹å§‹ç»ˆåœ¨ä¸€ä¸ªå†…æ ¸çº¿ç¨‹ä¸Šè·‘ï¼Œcontextä¸Šä¸‹æ–‡åˆ‡æ¢ç¡®å®å¾ˆå¿«ï¼Œä½†æ˜¯æ— æ³•çœŸæ­£çš„åˆ©ç”¨å¤šæ ¸ã€‚1ï¼š1æ˜¯è¯´ï¼Œä¸€ä¸ªç”¨æˆ·çº¿ç¨‹å°±åªåœ¨ä¸€ä¸ªå†…æ ¸çº¿ç¨‹ä¸Šè·‘ï¼Œè¿™æ—¶å¯ä»¥åˆ©ç”¨å¤šæ ¸ï¼Œä½†æ˜¯ä¸Šä¸‹æ–‡switchå¾ˆæ…¢ã€‚M:Næ˜¯è¯´ï¼Œ å¤šä¸ªgoroutineåœ¨å¤šä¸ªå†…æ ¸çº¿ç¨‹ä¸Šè·‘ï¼Œè¿™ä¸ªçœ‹ä¼¼å¯ä»¥é›†é½ä¸Šé¢ä¸¤è€…çš„ä¼˜åŠ¿ï¼Œä½†æ˜¯æ— ç–‘å¢åŠ äº†è°ƒåº¦çš„éš¾åº¦ã€‚<img src="https://pic2.zhimg.com/50/2f5c6ef32827fb4fc63c60f4f5314610_hd.jpg" data-rawwidth="391" data-rawheight="103" class="content_image" width="391" />Goçš„è°ƒåº¦å™¨å†…éƒ¨æœ‰ä¸‰ä¸ªé‡è¦çš„ç»“æ„ï¼šMï¼ŒPï¼ŒSM:ä»£è¡¨çœŸæ­£çš„å†…æ ¸OSçº¿ç¨‹ï¼Œå’ŒPOSIXé‡Œçš„threadå·®ä¸å¤šï¼ŒçœŸæ­£å¹²æ´»çš„äººG:ä»£è¡¨ä¸€ä¸ªgoroutineï¼Œå®ƒæœ‰è‡ªå·±çš„æ ˆï¼Œinstruction pointerå’Œå…¶ä»–ä¿¡æ¯ï¼ˆæ­£åœ¨ç­‰å¾…çš„channelç­‰ç­‰ï¼‰ï¼Œç”¨äºè°ƒåº¦ã€‚P:ä»£è¡¨è°ƒåº¦çš„ä¸Šä¸‹æ–‡ï¼Œå¯ä»¥æŠŠå®ƒçœ‹åšä¸€ä¸ªå±€éƒ¨çš„è°ƒåº¦å™¨ï¼Œä½¿goä»£ç åœ¨ä¸€ä¸ªçº¿ç¨‹ä¸Šè·‘ï¼Œå®ƒæ˜¯å®ç°ä»N:1åˆ°N:Mæ˜ å°„çš„å…³é”®ã€‚<img src="https://pic3.zhimg.com/50/67f09d490f69eec14c1824d939938e14_hd.jpg" data-rawwidth="400" data-rawheight="391" class="content_image" width="400" />å›¾ä¸­çœ‹ï¼Œæœ‰2ä¸ªç‰©ç†çº¿ç¨‹Mï¼Œæ¯ä¸€ä¸ªMéƒ½æ‹¥æœ‰ä¸€ä¸ªcontextï¼ˆPï¼‰ï¼Œæ¯ä¸€ä¸ªä¹Ÿéƒ½æœ‰ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„goroutineã€‚Pçš„æ•°é‡å¯ä»¥é€šè¿‡GOMAXPROCS()æ¥è®¾ç½®ï¼Œå®ƒå…¶å®ä¹Ÿå°±ä»£è¡¨äº†çœŸæ­£çš„å¹¶å‘åº¦ï¼Œå³æœ‰å¤šå°‘ä¸ªgoroutineå¯ä»¥åŒæ—¶è¿è¡Œã€‚å›¾ä¸­ç°è‰²çš„é‚£äº›goroutineå¹¶æ²¡æœ‰è¿è¡Œï¼Œè€Œæ˜¯å‡ºäºreadyçš„å°±ç»ªæ€ï¼Œæ­£åœ¨ç­‰å¾…è¢«è°ƒåº¦ã€‚Pç»´æŠ¤ç€è¿™ä¸ªé˜Ÿåˆ—ï¼ˆç§°ä¹‹ä¸ºrunqueueï¼‰ï¼ŒGoè¯­è¨€é‡Œï¼Œå¯åŠ¨ä¸€ä¸ªgoroutineå¾ˆå®¹æ˜“ï¼šgo function å°±è¡Œï¼Œæ‰€ä»¥æ¯æœ‰ä¸€ä¸ªgoè¯­å¥è¢«æ‰§è¡Œï¼Œrunqueueé˜Ÿåˆ—å°±åœ¨å…¶æœ«å°¾åŠ å…¥ä¸€ä¸ªgoroutineï¼Œåœ¨ä¸‹ä¸€ä¸ªè°ƒåº¦ç‚¹ï¼Œå°±ä»runqueueä¸­å–å‡ºï¼ˆå¦‚ä½•å†³å®šå–å“ªä¸ªgoroutineï¼Ÿï¼‰ä¸€ä¸ªgoroutineæ‰§è¡Œã€‚ä¸ºä½•è¦ç»´æŠ¤å¤šä¸ªä¸Šä¸‹æ–‡Pï¼Ÿå› ä¸ºå½“ä¸€ä¸ªOSçº¿ç¨‹è¢«é˜»å¡æ—¶ï¼ŒPå¯ä»¥è½¬è€ŒæŠ•å¥”å¦ä¸€ä¸ªOSçº¿ç¨‹ï¼å›¾ä¸­çœ‹åˆ°ï¼Œå½“ä¸€ä¸ªOSçº¿ç¨‹M0é™·å…¥é˜»å¡æ—¶ï¼ŒPè½¬è€Œåœ¨OSçº¿ç¨‹M1ä¸Šè¿è¡Œã€‚è°ƒåº¦å™¨ä¿è¯æœ‰è¶³å¤Ÿçš„çº¿ç¨‹æ¥è¿è¡Œæ‰€ä»¥çš„context Pã€‚<img src="https://pic4.zhimg.com/50/f1125f3027ebb2bd5183cf8c9ce4b3f2_hd.jpg" data-rawwidth="550" data-rawheight="400" class="origin_image zh-lightbox-thumb" width="550" data-original="https://pic4.zhimg.com/f1125f3027ebb2bd5183cf8c9ce4b3f2_r.jpg" />å›¾ä¸­çš„M1å¯èƒ½æ˜¯è¢«åˆ›å»ºï¼Œæˆ–è€…ä»çº¿ç¨‹ç¼“å­˜ä¸­å–å‡ºã€‚å½“MOè¿”å›æ—¶ï¼Œå®ƒå¿…é¡»å°è¯•å–å¾—ä¸€ä¸ªcontext Pæ¥è¿è¡Œgoroutineï¼Œä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå®ƒä¼šä»å…¶ä»–çš„OSçº¿ç¨‹é‚£é‡Œstealå·ä¸€ä¸ªcontextè¿‡æ¥ï¼Œå¦‚æœæ²¡æœ‰å·åˆ°çš„è¯ï¼Œå®ƒå°±æŠŠgoroutineæ”¾åœ¨ä¸€ä¸ªglobal runqueueé‡Œï¼Œç„¶åè‡ªå·±å°±å»ç¡å¤§è§‰äº†ï¼ˆæ”¾å…¥çº¿ç¨‹ç¼“å­˜é‡Œï¼‰ã€‚Contextsä»¬ä¹Ÿä¼šå‘¨æœŸæ€§çš„æ£€æŸ¥global runqueueï¼Œå¦åˆ™global runqueueä¸Šçš„goroutineæ°¸è¿œæ— æ³•æ‰§è¡Œã€‚<img src="https://pic3.zhimg.com/50/31f04bb69d72b72777568063742741cd_hd.jpg" data-rawwidth="550" data-rawheight="400" class="origin_image zh-lightbox-thumb" width="550" data-original="https://pic3.zhimg.com/31f04bb69d72b72777568063742741cd_r.jpg" />å¦ä¸€ç§æƒ…å†µæ˜¯Pæ‰€åˆ†é…çš„ä»»åŠ¡Gå¾ˆå¿«å°±æ‰§è¡Œå®Œäº†ï¼ˆåˆ†é…ä¸å‡ï¼‰ï¼Œè¿™å°±å¯¼è‡´äº†ä¸€ä¸ªä¸Šä¸‹æ–‡Pé—²ç€æ²¡äº‹å„¿å¹²è€Œç³»ç»Ÿå´ä»»ç„¶å¿™ç¢Œã€‚ä½†æ˜¯å¦‚æœglobal runqueueæ²¡æœ‰ä»»åŠ¡Gäº†ï¼Œé‚£ä¹ˆPå°±ä¸å¾—ä¸ä»å…¶ä»–çš„ä¸Šä¸‹æ–‡Pé‚£é‡Œæ‹¿ä¸€äº›Gæ¥æ‰§è¡Œã€‚ä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æœä¸Šä¸‹æ–‡Pä»å…¶ä»–çš„ä¸Šä¸‹æ–‡Pé‚£é‡Œè¦å·ä¸€ä¸ªä»»åŠ¡çš„è¯ï¼Œä¸€èˆ¬å°±â€˜å·â€™run queueçš„ä¸€åŠï¼Œè¿™å°±ç¡®ä¿äº†æ¯ä¸ªOSçº¿ç¨‹éƒ½èƒ½å……åˆ†çš„ä½¿ç”¨ã€‚</p>

<p>ä½œè€…ï¼šçŸ¥ä¹ç”¨æˆ·
é“¾æ¥ï¼šhttps://www.zhihu.com/question/20862617/answer/18582460
æ¥æºï¼šçŸ¥ä¹
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚</p>

<p>ã€Šgoä¸­çš„è°ƒåº¦åˆ†æã€‹ã€ŠgoroutineèƒŒåçš„ç³»ç»ŸçŸ¥è¯†ã€‹è¿˜æœ‰ä¸€ä¸ªæ˜¯Columbia Universityçš„ä¸‰ä¸ªå®¶ä¼™å‘è¡¨çš„ä¸€ç¯‡paper,ã€ŠAnalysis of the Go runtime schedulerã€‹ æœ€åè¿˜æœ‰Golangæ ¸å¿ƒæˆå‘˜å†™ä¸€ä¸ªGoroutine Schedulerçš„è®¾è®¡ã€‚ã€Š Scalable Go Scheduler Design Docã€‹ä»¥åŠå¯¹å…¶è¯¦ç»†è§£é‡Šçš„ã€ŠThe Go schedulerã€‹Goroutines are part of making concurrency easy to use. The idea, which has been around for a while, is to multiplex independently executing functionsâ€”coroutinesâ€”onto a set of threads. When a coroutine blocks, such as by calling a blocking system call, the run-time automatically moves other coroutines on the same operating system thread to a different, runnable thread so they wonâ€™t be blocked. The programmer sees none of this, which is the point. The result, which we call goroutines, can be very cheap: unless they spend a lot of time in long-running system calls, they cost little more than the memory for the stack, which is just a few kilobytes.To make the stacks small, Goâ€™s run-time uses segmented stacks. A newly minted goroutine is given a few kilobytes, which is almost always enough. When it isnâ€™t, the run-time allocates (and frees) extension segments automatically. The overhead averages about three cheap instructions per function call. It is practical to create hundreds of thousands of goroutines in the same address space. If goroutines were just threads, system resources would run out at a much smaller number.â€”â€”â€”â€”â€”â€“ æˆ‘æ˜¯åˆ†å‰²çº¿â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”-æˆ‘å¯¹goroutineçš„ç†è§£ç±»ä¼¼äºC/C++ä¸‹å¸¸ç”¨çš„çº¿ç¨‹æ± æŠ€æœ¯ã€‚ä½†æ˜¯goroutineè¦åœ¨è¿™åŸºç¡€ä¸Šå¤§å¤§çš„å‰è¿›äº†å¥½å¤šã€‚é¦–å…ˆ,goå…³é”®å­—æå¤§çš„ç®€åŒ–äº†C/C++ä¸‹å¾€çº¿ç¨‹æ± æŠ•é€’ä»»åŠ¡çš„æ“ä½œã€‚è™½ç„¶C++11å¼•å…¥äº†lambdaï¼Œä½†æ˜¯å› ä¸ºæ²¡æœ‰GCçš„ç¼˜æ•…ç”¨èµ·æ¥è¿˜æ˜¯ç¨å¾®è›‹ç–¼çš„ã€‚å…¶æ¬¡å°±æ˜¯goroutineçš„è°ƒåº¦å™¨è§£å†³äº†ä¸€èˆ¬çº¿ç¨‹æ± å¸¸è§çš„é—®é¢˜ï¼Œå°±æ˜¯é‡åˆ°é˜»å¡æˆ–è€…åŒæ­¥åŠ¨ä½œæ—¶ï¼Œæ€ä¹ˆè®©çº¿ç¨‹æ± æ›´å®¹æ˜“æ‰©å±•ï¼Œä¸ä¼šå› ä¸ºå…¶ä¸­ä¸€ä¸ªä»»åŠ¡çš„é˜»å¡æˆ–è€…åŒæ­¥ç‹¬å çº¿ç¨‹ï¼Œç”šè‡³æ€ä¹ˆé¿å…ç”±æ­¤é—®é¢˜å¸¦æ¥çš„æ­»é”ã€‚è€Œåœ¨C/C++è¯­è¨€é‡Œï¼Œæƒ³åšåˆ°è¿™ç‚¹éå¸¸çš„å›°éš¾ï¼Œæ²¡æœ‰ç±»ä¼¼Golangçš„runtimeï¼Œåšèµ·æ¥ä¼šéå¸¸ç—›è‹¦ã€‚ Golangåœ¨è¿™ç‚¹ä¸Šåšçš„ä¹Ÿæ˜¯éå¸¸çš„æ¼‚äº®ã€‚å‘èµ·çš„åŒæ­¥æˆ–è€…channelåŠ¨ä½œï¼Œå“ªæ€•ç½‘ç»œæ“ä½œï¼Œéƒ½ä¼šæŠŠè‡ªèº«goroutineåˆ‡æ¢å‡ºå»ï¼Œè®©ä¸‹ä¸€ä¸ªé¢„å¤‡å¥½çš„goroutineå»è¿è¡Œã€‚è€Œä¸”Golangå…¶æœ¬èº«è¿˜åœ¨æ­¤åŸºç¡€ä¸Šå¾ˆå®¹æ˜“çš„åšåˆ°å¯¹çº¿ç¨‹æ± çš„æ‰©å±•ï¼Œæ ¹æ®ç¨‹åºè¡Œä¸ºè‡ªåŠ¨æ‰©å±•æˆ–è€…æ”¶ç¼©çº¿ç¨‹ï¼Œå°½å¯èƒ½çš„è®©çº¿ç¨‹ä¿æŒåœ¨ä¸€ä¸ªåˆé€‚çš„æ•°ç›®ã€‚</p>

<p>https://www.zhihu.com/question/20862617?sort=created
http://www.cs.columbia.edu/~aho/cs6998/reports/12-12-11_DeshpandeSponslerWeiss_GO.pdf</p>

<p>http://www.sizeofvoid.net/goroutine-under-the-hood/</p>

<p>http://bbs.mygolang.com/thread-163-1-1.html
http://www.imooc.com/article/291974?block_id=tuijian_wz
https://blog.csdn.net/NNnora/article/details/80944719
https://www.jianshu.com/p/69704cdf6674
https://www.cnblogs.com/abozhang/p/10825342.html
https://zhuanlan.zhihu.com/p/65738076
https://blog.csdn.net/qq_25504271/article/details/81000217
https://www.cnblogs.com/maji233/p/11044913.html</p>

<p>https://www.bookstack.cn/read/qcrao-Go-Questions/goroutine%20%E8%B0%83%E5%BA%A6%E5%99%A8-g0%20%E6%A0%88%E4%BD%95%E7%94%A8%E6%88%B7%E6%A0%88%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2.md
https://www.jianshu.com/p/be04990895c7
https://studygolang.com/articles/10115</p>

<p>https://www.cnblogs.com/wdliu/p/9272220.html
https://www.zhihu.com/question/20862617/answer/27964865
https://blog.csdn.net/xclyfe/article/details/50563048
https://segmentfault.com/a/1190000019172554</p>
:ET