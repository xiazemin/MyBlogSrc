I"x<p>https://studygolang.com/articles/28553?fr=sidebar</p>

<p>ä¸åŒç¡¬ä»¶å¹³å°ä½¿ç”¨çš„æ±‡ç¼–æ–‡ä»¶ä¸åŒï¼Œæœ¬æ–‡åˆ†æçš„å‡½æ•°mcall, systemstack, asmcgocallæ˜¯åŸºäºasm_arm64.sæ±‡ç¼–æ–‡ä»¶ã€‚
ä¸ç”¨æ“ä½œç³»ç»Ÿå¹³å°ä½¿ç”¨çš„ç³»ç»Ÿè°ƒç”¨ä¸åŒï¼Œæœ¬æ–‡åˆ†æçš„å‡½æ•°syscallæ˜¯åŸºäºasm_linux_arm64.sæ±‡ç¼–æ–‡ä»¶ã€‚</p>

<p>CPUçš„ä¸Šä¸‹æ–‡
è¿™äº›å‡½æ•°çš„æœ¬è´¨éƒ½æ˜¯ä¸ºäº†åˆ‡æ¢goroutineï¼Œgoroutineåˆ‡æ¢æ—¶éœ€è¦åˆ‡æ¢CPUæ‰§è¡Œçš„ä¸Šä¸‹æ–‡ï¼Œä¸»è¦æœ‰2ä¸ªå¯„å­˜å™¨çš„å€¼SPï¼ˆå½“å‰çº¿ç¨‹ä½¿ç”¨çš„æ ˆçš„æ ˆé¡¶åœ°å€ï¼‰ï¼ŒPCï¼ˆä¸‹ä¸€ä¸ªè¦æ‰§è¡Œçš„æŒ‡ä»¤çš„åœ°å€ï¼‰ã€‚</p>

<p>mcallå‡½æ•°
mcallå‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼Œmcallä¼ å…¥çš„æ˜¯å‡½æ•°æŒ‡é’ˆï¼Œä¼ å…¥å‡½æ•°çš„ç±»å‹å¦‚ä¸‹ï¼Œåªæœ‰ä¸€ä¸ªå‚æ•°goroutineçš„æŒ‡é’ˆï¼Œæ— è¿”å›å€¼ã€‚</p>

<p>func mcall(fn func(*g)
mcallå‡½æ•°çš„ä½œç”¨æ˜¯åœ¨ç³»ç»Ÿæ ˆä¸­æ‰§è¡Œè°ƒåº¦ä»£ç ï¼Œå¹¶ä¸”è°ƒåº¦ä»£ç ä¸ä¼šè¿”å›ï¼Œå°†åœ¨è¿è¡Œè¿‡ç¨‹ä¸­åˆä¸€æ¬¡æ‰§è¡Œmcallã€‚mcallçš„æµç¨‹æ˜¯ä¿å­˜å½“å‰çš„gçš„ä¸Šä¸‹æ–‡ï¼Œåˆ‡æ¢åˆ°g0çš„ä¸Šä¸‹æ–‡ï¼Œä¼ å…¥å‡½æ•°å‚æ•°ï¼Œè·³è½¬åˆ°å‡½æ•°ä»£ç æ‰§è¡Œã€‚</p>

<p>// void mcall(fn func(*g))
// Switch to m-&gt;g0â€™s stack, call fn(g).
// Fn must never return. It should gogo(&amp;g-&gt;sched)
// to keep running g.
TEXT runtimeÂ·mcall(SB), NOSPLIT|NOFRAME, $0-8
    // Save caller state in g-&gt;sched
    //æ­¤æ—¶çº¿ç¨‹å½“å‰çš„sp pc bpç­‰ä¸Šä¸‹æ–‡éƒ½å­˜åœ¨å¯„å­˜å™¨ä¸­ éœ€è¦å°†å¯„å­˜å™¨çš„å€¼å†™å›g ä¸‹é¢å°±æ˜¯å†™å›gçš„è¿‡ç¨‹
    MOVD    RSP, R0  // R0 = RSP
    MOVD    R0, (g_sched+gobuf_sp)(g)  // g_sp = RO ä¿å­˜spå¯„å­˜å™¨çš„å€¼
    MOVD    R29, (g_sched+gobuf_bp)(g) // g_bp = R29 (R29ä¿å­˜bpå€¼)
    MOVD    LR, (g_sched+gobuf_pc)(g)  // g_pc = LR (LRä¿å­˜pcå€¼)
    MOVD    $0, (g_sched+gobuf_lr)(g)  // g_lr = 0
    MOVD    g, (g_sched+gobuf_g)(g)    // ???</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Switch to m-&gt;g0 &amp; its stack, call fn.
// å°†å½“å‰çš„gåˆ‡ä¸ºg0
MOVD    g, R3  // R3 = g (gè¡¨ç¤ºå½“å‰è°ƒç”¨mcallæ—¶çš„goutine)
MOVD    g_m(g), R8 // R8 = g.m (R8è¡¨ç¤ºgç»‘å®šçš„m å³å½“å‰çš„m)
MOVD    m_g0(R8), g // g = m.g0 (å°†å½“å‰gåˆ‡æ¢ä¸ºg0)
BL  runtimeÂ·save_g(SB) // ???
CMP g, R3 // g == g0  R3 == è°ƒç”¨mcallçš„g å¿…ä¸ç›¸ç­‰
BNE 2(PC) // å¦‚æœä¸æƒ³ç­‰åˆ™æ­£å¸¸æ‰§è¡Œ
B   runtimeÂ·badmcall(SB) // ç›¸ç­‰åˆ™è¯´æ˜æœ‰bug è°ƒç”¨badmcall
// fnæ˜¯è¦è°ƒç”¨çš„å‡½æ•° å†™å…¥å¯„å­˜å™¨
MOVD    fn+0(FP), R26           // context R26å­˜çš„æ˜¯fnçš„pc
MOVD    0(R26), R4          // code pointer R4ä¹Ÿæ˜¯fnçš„pcå€¼
MOVD    (g_sched+gobuf_sp)(g), R0  // g0çš„ spå€¼èµ‹ç»™å¯„å­˜å™¨
MOVD    R0, RSP // sp = m-&gt;g0-&gt;sched.sp
MOVD    (g_sched+gobuf_bp)(g), R29 // g0çš„bpå€¼èµ‹ç»™å¯¹åº”çš„å¯„å­˜å™¨
MOVD    R3, -8(RSP) // R3åœ¨ä¹‹å‰è¢«èµ‹å€¼ä¸ºè°ƒç”¨mcallçš„g ç°åœ¨å†™å…¥g0çš„æ ˆä¸­ ä½œä¸ºfnçš„å‡½æ•°å‚æ•°
MOVD    $0, -16(RSP) // æ­¤å¤„çš„ç©ºå€¼ä¸å¤ªç†è§£ åªæœ‰ä¸€ä¸ªå‚æ•°ä¸”æ— è¿”å›å€¼ ä¸ºä½•è¦åœ¨æ ˆä¸­é¢„ç•™8å­—èŠ‚
SUB $16, RSP // å¯¹æ ˆè¿›è¡Œåç§»16byteï¼ˆä¸Šé¢g $0 å„å 8byteï¼‰
BL  (R4) // R4æ­¤æ—¶æ˜¯fnçš„pcå€¼ è·³åˆ°è¯¥ PCæ‰§è¡Œfn
B   runtimeÂ·badmcall2(SB) // è¯¥å‡½æ•°æ°¸è¿œä¸ä¼šè¿”å› å› æ­¤è¿™ä¸€æ­¥ç†è®ºä¸Šæ°¸è¿œæ‰§è¡Œä¸åˆ° å¸¸è§çš„è°ƒç”¨mcallæ‰§è¡Œçš„å‡½æ•°æœ‰ï¼š
</code></pre></div></div>

<p>mcall(gosched_m)
mcall(park_m)
mcall(goexit0)
mcall(exitsyscall0)
mcall(preemptPark)
mcall(gopreempt_m)
<!-- more -->
systemstackå‡½æ•°
systemstackå‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼Œä¼ å…¥çš„å‡½æ•°æ— å‚æ•°ï¼Œæ— è¿”å›å€¼ã€‚</p>

<p>func systemstack(fn func())
systemstackå‡½æ•°çš„ä½œç”¨æ˜¯åœ¨ç³»ç»Ÿæ ˆä¸­æ‰§è¡Œåªèƒ½ç”±g0(æˆ–gsignal?)æ‰§è¡Œçš„è°ƒåº¦ä»£ç ï¼Œå’Œmcallä¸åŒçš„æ˜¯ï¼Œåœ¨æ‰§è¡Œå®Œè°ƒåº¦ä»£ç åä¼šåˆ‡å›åˆ°ç°åœ¨æ­£åœ¨æ‰§è¡Œçš„ä»£ç ã€‚
è¯¥éƒ¨åˆ†çš„æºç æ³¨é‡Šæœ‰åªæœ‰ä¸ªå¤§æ¦‚çš„æµç¨‹çš„ç†è§£ï¼Œè®¸å¤šç»†èŠ‚æ¨æ•²ä¸å‡ºæ¥ã€‚ä¸»è¦æµç¨‹æ˜¯å…ˆåˆ¤æ–­å½“å‰è¿è¡Œçš„gæ˜¯å¦ä¸ºg0æˆ–è€…gsignalï¼Œå¦‚æœæ˜¯åˆ™ç›´æ¥è¿è¡Œï¼Œä¸æ˜¯åˆ™å…ˆåˆ‡æ¢åˆ°g0ï¼Œæ‰§è¡Œå®Œå‡½æ•°ååˆ‡æ¢ä¸ºgè¿”å›è°ƒç”¨å¤„ã€‚</p>

<p>// systemstack_switch is a dummy routine that systemstack leaves at the bottom
// of the G stack. We need to distinguish the routine that
// lives at the bottom of the G stack from the one that lives
// at the top of the system stack because the one at the top of
// the system stack terminates the stack walk (see topofstack()).
TEXT runtimeÂ·systemstack_switch(SB), NOSPLIT, $0-0
    UNDEF
    BL  (LR)    // make sure this function is not leaf
    RET</p>

<p>// func systemstack(fn func())
TEXT runtimeÂ·systemstack(SB), NOSPLIT, $0-8
    MOVD    fn+0(FP), R3    // R3 = fn
    MOVD    R3, R26     // context R26 = R3 = fn
    MOVD    g_m(g), R4  // R4 = m</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MOVD    m_gsignal(R4), R5   // R5 = m.gsignal
CMP g, R5  // m.gsignalæ˜¯æœ‰æƒé™æ‰§è¡Œfnçš„g
BEQ noswitch // å¦‚æœç›¸ç­‰è¯´æ˜å·²ç»æ˜¯m.gsignaleäº† åˆ™ä¸éœ€è¦åˆ‡æ¢

MOVD    m_g0(R4), R5    // R5 = g0
CMP g, R5  // å¦‚æœå½“å‰çš„gå·²ç»æ˜¯g0 åˆ™è¯´æ˜ä¸ç”¨åˆ‡æ¢
BEQ noswitch

MOVD    m_curg(R4), R6 // R6 = m.curg
CMP g, R6 // m.curg == g
BEQ switch

// Bad: g is not gsignal, not g0, not curg. What is it?
// Hide call from linker nosplit analysis.
MOVD    $runtimeÂ·badsystemstack(SB), R3
BL  (R3)
B   runtimeÂ·abort(SB)
</code></pre></div></div>

<p>switch:
    // save our state in g-&gt;sched. Pretend to
    // be systemstack_switch if the G stack is scanned.
    MOVD    $runtimeÂ·systemstack_switch(SB), R6
    ADD $8, R6  // get past prologue
    // ä»¥ä¸‹æ˜¯å¸¸è§„çš„ä¿å­˜å½“å‰gçš„ä¸Šä¸‹æ–‡
    MOVD    R6, (g_sched+gobuf_pc)(g)
    MOVD    RSP, R0
    MOVD    R0, (g_sched+gobuf_sp)(g)
    MOVD    R29, (g_sched+gobuf_bp)(g)
    MOVD    $0, (g_sched+gobuf_lr)(g)
    MOVD    g, (g_sched+gobuf_g)(g)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// switch to g0
MOVD    R5, g  // g = R5 = g0
BL  runtimeÂ·save_g(SB)
MOVD    (g_sched+gobuf_sp)(g), R3 // R3 = sp
// make it look like mstart called systemstack on g0, to stop traceback
SUB $16, R3  // spåœ°å€ å†…å­˜å¯¹é½
AND $~15, R3
MOVD    $runtimeÂ·mstart(SB), R4
MOVD    R4, 0(R3)
MOVD    R3, RSP
MOVD    (g_sched+gobuf_bp)(g), R29 // R29 = g0.gobuf.bp

// call target function
MOVD    0(R26), R3  // code pointer
BL  (R3)

// switch back to g
MOVD    g_m(g), R3
MOVD    m_curg(R3), g
BL  runtimeÂ·save_g(SB)
MOVD    (g_sched+gobuf_sp)(g), R0
MOVD    R0, RSP
MOVD    (g_sched+gobuf_bp)(g), R29
MOVD    $0, (g_sched+gobuf_sp)(g)
MOVD    $0, (g_sched+gobuf_bp)(g)
RET
</code></pre></div></div>

<p>noswitch:
    // already on m stack, just call directly
    // Using a tail call here cleans up tracebacks since we wonâ€™t stop
    // at an intermediate systemstack.
    MOVD    0(R26), R3  // code pointer  R3 = R26 = fn
    MOVD.P  16(RSP), R30    // restore LR  R30 = RSP + 16(systemstackè°ƒç”¨å®Œæˆåä¸‹æ¡æŒ‡ä»¤çš„PCå€¼ï¼Ÿ)
    SUB $8, RSP, R29    // restore FP  R29 = RSP - 8 è¡¨ç¤ºæ ˆçš„
    B   (R3)
asmcgocallå‡½æ•°
asmcgocallå‡½æ•°å®šä¹‰å¦‚ä¸‹ï¼Œä¼ å…¥çš„å‚æ•°æœ‰2ä¸ªä¸ºå‡½æ•°æŒ‡é’ˆå’Œå‚æ•°æŒ‡é’ˆï¼Œè¿”å›å‚æ•°ä¸ºint32ã€‚</p>

<p>func asmcgocall(fn, arg unsafe.Pointer) int32
asmcgocallå‡½æ•°çš„ä½œç”¨æ˜¯æ‰§è¡Œcgoä»£ç ï¼Œè¯¥éƒ¨åˆ†ä»£ç åªèƒ½åœ¨g0(æˆ–gsignal, osthread)çš„æ ˆæ‰§è¡Œï¼Œå› æ­¤æµç¨‹æ˜¯å…ˆåˆ¤æ–­å½“å‰çš„æ ˆæ˜¯å¦è¦åˆ‡æ¢ï¼Œå¦‚æœæ— éœ€åˆ‡æ¢åˆ™ç›´æ¥æ‰§è¡Œnosaveç„¶åè¿”å›ï¼Œå¦åˆ™å…ˆä¿å­˜å½“å‰gçš„ä¸Šä¸‹æ–‡ï¼Œç„¶ååˆ‡æ¢åˆ°g0ï¼Œæ‰§è¡Œå®Œcgoä»£ç ååˆ‡å›gï¼Œç„¶åè¿”å›ã€‚</p>

<p>// func asmcgocall(fn, arg unsafe.Pointer) int32
// Call fn(arg) on the scheduler stack,
// aligned appropriately for the gcc ABI.
// See cgocall.go for more details.
TEXT Â·asmcgocall(SB),NOSPLIT,$0-20
    MOVD    fn+0(FP), R1  // R1 = fn
    MOVD    arg+8(FP), R0  // R2 = arg</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MOVD    RSP, R2     // save original stack pointer
CBZ g, nosave  // å¦‚æœgä¸ºnil åˆ™è·³è½¬åˆ° nosaveã€‚ g == nilæ˜¯å¦è¯´æ˜å½“å‰æ˜¯osthreadï¼Ÿ
MOVD    g, R4  // R4 = g

// Figure out if we need to switch to m-&gt;g0 stack.
// We get called to create new OS threads too, and those
// come in on the m-&gt;g0 stack already.
MOVD    g_m(g), R8 // R8 = g.m
MOVD    m_gsignal(R8), R3 // R3 = g.m.gsignal
CMP R3, g  // å¦‚æœg == g.m.signal jump nosave
BEQ nosave
MOVD    m_g0(R8), R3 // å¦‚æœg== m.g0 jump nosave
CMP R3, g
BEQ nosave

// Switch to system stack.
// save gçš„ä¸Šä¸‹æ–‡
MOVD    R0, R9  // gosave&lt;&gt; and save_g might clobber R0
BL  gosave&lt;&gt;(SB)
MOVD    R3, g
BL  runtimeÂ·save_g(SB)
MOVD    (g_sched+gobuf_sp)(g), R0
MOVD    R0, RSP
MOVD    (g_sched+gobuf_bp)(g), R29
MOVD    R9, R0

// Now on a scheduling stack (a pthread-created stack).
// Save room for two of our pointers /*, plus 32 bytes of callee
// save area that lives on the caller stack. */
MOVD    RSP, R13
SUB $16, R13
MOVD    R13, RSP  // RSP = RSP - 16
MOVD    R4, 0(RSP)  // save old g on stack  RSP.0 = R4 = oldg
MOVD    (g_stack+stack_hi)(R4), R4 // R4 = old.g.stack.hi
SUB R2, R4  // R4 = oldg.stack.hi - old_RSP
MOVD    R4, 8(RSP)  // save depth in old g stack (can't just save SP, as stack might be copied during a callback)
BL  (R1) // R1 = fn
MOVD    R0, R9 // R9 = R0 = errno?

// Restore g, stack pointer. R0 is errno, so don't touch it
MOVD    0(RSP), g  // g = RSP.0 = oldg
BL  runtimeÂ·save_g(SB)
MOVD    (g_stack+stack_hi)(g), R5 // R5 = g.stack.hi
MOVD    8(RSP), R6 // R6 = RSP + 8 = oldg.stack.hi - old_RSP
SUB R6, R5 // R5 = R5 - R6 = old_RSP
MOVD    R9, R0 // R0 = R9 = errno
MOVD    R5, RSP // RSP = R5 = old_RSP

MOVW    R0, ret+16(FP) // ret = R0 = errno
RET
</code></pre></div></div>

<p>nosave:
    // Running on a system stack, perhaps even without a g.
    // Having no g can happen during thread creation or thread teardown
    // (see needm/dropm on Solaris, for example).
    // This code is like the above sequence but without saving/restoring g
    // and without worrying about the stack moving out from under us
    // (because weâ€™re on a system stack, not a goroutine stack).
    // The above code could be used directly if already on a system stack,
    // but then the only path through this code would be a rare case on Solaris.
    // Using this code for all â€œalready on system stackâ€ calls exercises it more,
    // which should help keep it correct.
    MOVD    RSP, R13 
    SUB $16, R13<br />
    MOVD    R13, RSP // RSP = RSP - 16
    MOVD    $0, R4 // R4 = 0
    MOVD    R4, 0(RSP)  // Where above code stores g, in case someone looks during debugging.
    MOVD    R2, 8(RSP)  // Save original stack pointer.  RSP + 8 = old_R2
    BL  (R1)
    // Restore stack pointer.
    MOVD    8(RSP), R2  // R2 = RSP + 8 = old_R2
    MOVD    R2, RSP // RSP = old_R2 = old_RSP
    MOVD    R0, ret+16(FP) // ret = R0 = errno
    RET
syscallå‡½æ•°
Syscallå‡½æ•°çš„å®šä¹‰å¦‚ä¸‹ï¼Œä¼ å…¥4ä¸ªå‚æ•°ï¼Œè¿”å›3ä¸ªå‚æ•°ã€‚</p>

<p>func syscall(fn, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)
syscallå‡½æ•°çš„ä½œç”¨æ˜¯ä¼ å…¥ç³»ç»Ÿè°ƒç”¨çš„åœ°å€å’Œå‚æ•°ï¼Œæ‰§è¡Œå®Œæˆåè¿”å›ã€‚æµç¨‹ä¸»è¦æ˜¯ç³»ç»Ÿè°ƒç”¨å‰æ‰§è¡Œentersyscallï¼Œè®¾ç½®g pçš„çŠ¶æ€ï¼Œç„¶åå…¥å‚ï¼Œæ‰§è¡Œåï¼Œå†™è¿”å›å€¼ç„¶åæ‰§è¡Œexitsyscallè®¾ç½®g pçš„çŠ¶æ€ã€‚
entersyscallå’Œexitsyscallåœ¨gçš„è°ƒç”¨ä¸­ç»†è®²ã€‚</p>

<p>// func Syscall(trap int64, a1, a2, a3 uintptr) (r1, r2, err uintptr);
// Trap # in AX, args in DI SI DX R10 R8 R9, return in AX DX
// Note that this differs from â€œstandardâ€ ABI convention, which
// would pass 4th arg in CX, not R10.</p>

<p>// 4ä¸ªå…¥å‚ï¼šPC param1 param2 param3
TEXT Â·Syscall(SB),NOSPLIT,$0-56
    // è°ƒç”¨entersyscall åˆ¤æ–­æ˜¯æ‰§è¡Œæ¡ä»¶æ˜¯å¦æ»¡è¶³ è®°å½•è°ƒåº¦ä¿¡æ¯ åˆ‡æ¢g pçš„çŠ¶æ€
    CALL    runtimeÂ·entersyscall(SB)
    // å°†å‚æ•°å­˜å…¥å¯„å­˜å™¨ä¸­
    MOVQ    a1+8(FP), DI
    MOVQ    a2+16(FP), SI
    MOVQ    a3+24(FP), DX
    MOVQ    trap+0(FP), AX  // syscall entry
    SYSCALL
    CMPQ    AX, $0xfffffffffffff001
    JLS ok
    // æ‰§è¡Œå¤±è´¥æ—¶ å†™è¿”å›å€¼
    MOVQ    $-1, r1+32(FP)
    MOVQ    $0, r2+40(FP)
    NEGQ    AX
    MOVQ    AX, err+48(FP)
    // è°ƒç”¨exitsyscall è®°å½•è°ƒåº¦ä¿¡æ¯
    CALL    runtimeÂ·exitsyscall(SB)
    RET
ok:
    // æ‰§è¡ŒæˆåŠŸæ—¶ å†™è¿”å›å€¼
    MOVQ    AX, r1+32(FP)
    MOVQ    DX, r2+40(FP)
    MOVQ    $0, err+48(FP)
    CALL    runtimeÂ·exitsyscall(SB)
    RET
é™¤äº†Syscalè¿˜æœ‰Syscall6ï¼ˆé™¤fnè¿˜æœ‰6ä¸ªå‚æ•°ï¼‰å¯¹åº”æœ‰6ä¸ªå‚æ•°çš„ç³»ç»Ÿè°ƒç”¨ã€‚å®ç°å¤§åŒå°å¼‚ï¼Œè¿™é‡Œä¸åˆ†æã€‚</p>

<p>æ€»ç»“ä¸æ€è€ƒ
1.æ±‡ç¼–å‡½æ•°çš„ä½œç”¨ã€‚ä¸ºä»€ä¹ˆgolangä¸€å®šè¦å¼•å…¥æ±‡ç¼–å‡½æ•°å‘¢ï¼Ÿå› ä¸ºCPUæ‰§è¡Œæ—¶çš„ä¸Šä¸‹æ–‡æ˜¯å¯„å­˜å™¨ï¼Œåªæœ‰æ±‡ç¼–è¯­è¨€æ‰èƒ½æ“ä½œå¯„å­˜å™¨ã€‚
2.CPUçš„ä¸Šä¸‹æ–‡å’Œg.sched(gobuf)ç»“æ„ä½“ä¸­çš„å­—æ®µä¸€ä¸€å¯¹åº”ï¼Œåªæœ‰10ä¸ªä»¥å†…çš„å­—æ®µï¼Œå› æ­¤åˆ‡æ¢ä¸Šä¸‹æ–‡æ•ˆç‡éå¸¸çš„é«˜ã€‚
3.é™¤äº†golangï¼Œå…¶å®ƒåœ¨ç”¨çš„è¯­è¨€æ˜¯å¦è¦æœ‰ç±»ä¼¼çš„æ±‡ç¼–æ¥å®ç°è¯­è¨€å’Œæ“ä½œç³»ç»Ÿä¹‹é—´çš„äº¤äº’ï¼Ÿ</p>

<p>æœ€å
é™¤äº†mcallå‡½æ•°ï¼Œå…¶å®ƒå‡½æ•°åœ¨å…·ä½“æ‰§è¡Œç»†èŠ‚ä¸Šç†è§£ä¸å¤Ÿæ·±ï¼Œåé¢åŠ å¼ºæ±‡ç¼–ç›¸å…³çš„çŸ¥è¯†åå†æŠŠè¿™ä¸ªå‘å¡«ä¸Šã€‚</p>

<p>https://studygolang.com/articles/28553?fr=sidebar</p>

<p>golangé‡Œé¢ç”¨æˆ·æ€è¿›è¡Œç³»ç»Ÿè°ƒç”¨æ—¶å€™çš„ä¸€äº›åŸç†ï¼Œä¸»è¦å…³æ³¨ç‚¹å°†ä¼šæ”¾åœ¨system callä¸schedulerä¹‹é—´çš„å…³è”ã€‚</p>

<p>https://blog.csdn.net/u010853261/article/details/88312904</p>

<p>1.å…¥å£
ç³»ç»Ÿè°ƒç”¨çš„å…¥å£æ ¹æ®ä¸åŒç³»ç»Ÿæœ‰ä¸åŒå®ç°ï¼Œå¯¹äºAMD64, Linuxç¯å¢ƒæ˜¯ï¼šsyscall/asm_linux_amd64.s</p>

<p>å‡½æ•°å£°æ˜å¦‚ä¸‹ï¼š</p>

<p>func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno)</p>

<p>func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)</p>

<p>func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno)</p>

<p>func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)</p>

<p>è¿™äº›å‡½æ•°çš„å®ç°éƒ½æ˜¯æ±‡ç¼–ï¼ŒæŒ‰ç…§ linux çš„ syscall è°ƒç”¨è§„èŒƒï¼Œæˆ‘ä»¬åªè¦åœ¨æ±‡ç¼–ä¸­æŠŠå‚æ•°ä¾æ¬¡ä¼ å…¥å¯„å­˜å™¨ï¼Œå¹¶è°ƒç”¨ SYSCALL æŒ‡ä»¤å³å¯è¿›å…¥å†…æ ¸å¤„ç†é€»è¾‘ï¼Œç³»ç»Ÿè°ƒç”¨æ‰§è¡Œå®Œæ¯•ä¹‹åï¼Œè¿”å›å€¼æ”¾åœ¨ RAX ä¸­:</p>

<p>Syscall å’Œ Syscall6 çš„åŒºåˆ«åªæœ‰ä¼ å…¥å‚æ•°ä¸ä¸€æ ·, å…·ä½“æºç ä¸å®ç°è¯·çœ‹golangçš„å¼€æºæºç ã€‚</p>

<p>è¿™é‡Œåªåˆ—å‡ºSyscallå’ŒRawSyscallçš„æºç ï¼š</p>

<p>//Syscall
TEXT Â·Syscall(SB),NOSPLIT,$0-56
	CALL	runtimeÂ·entersyscall(SB)
	MOVQ	a1+8(FP), DI
	MOVQ	a2+16(FP), SI
	MOVQ	a3+24(FP), DX
	MOVQ	$0, R10
	MOVQ	$0, R8
	MOVQ	$0, R9
	MOVQ	trap+0(FP), AX	// syscall entry
	SYSCALL
	CMPQ	AX, $0xfffffffffffff001
	JLS	ok
	MOVQ	$-1, r1+32(FP)
	MOVQ	$0, r2+40(FP)
	NEGQ	AX
	MOVQ	AX, err+48(FP)
	CALL	runtimeÂ·exitsyscall(SB)
	RET
ok:
	MOVQ	AX, r1+32(FP)
	MOVQ	DX, r2+40(FP)
	MOVQ	$0, err+48(FP)
	CALL	runtimeÂ·exitsyscall(SB)
	RET</p>

<p>//RawSyscall
TEXT Â·RawSyscall(SB),NOSPLIT,$0-56
	MOVQ	a1+8(FP), DI
	MOVQ	a2+16(FP), SI
	MOVQ	a3+24(FP), DX
	MOVQ	$0, R10
	MOVQ	$0, R8
	MOVQ	$0, R9
	MOVQ	trap+0(FP), AX	// syscall entry
	SYSCALL
	CMPQ	AX, $0xfffffffffffff001
	JLS	ok1
	MOVQ	$-1, r1+32(FP)
	MOVQ	$0, r2+40(FP)
	NEGQ	AX
	MOVQ	AX, err+48(FP)
	RET
ok1:
	MOVQ	AX, r1+32(FP)
	MOVQ	DX, r2+40(FP)
	MOVQ	$0, err+48(FP)
	RET</p>

<p>Syscallå’ŒRawSyscallçš„å®ç°æ¯”è¾ƒå…¸å‹ï¼Œå¯ä»¥çœ‹åˆ°è¿™ä¸¤ä¸ªå®ç°æœ€ä¸»è¦çš„åŒºåˆ«åœ¨äºï¼š
Syscallåœ¨è¿›å…¥ç³»ç»Ÿè°ƒç”¨çš„æ—¶å€™ï¼Œè°ƒç”¨äº†runtimeÂ·entersyscall(SB)å‡½æ•°ï¼Œåœ¨ç»“æŸç³»ç»Ÿè°ƒç”¨çš„æ—¶å€™è°ƒç”¨äº†runtimeÂ·exitsyscall(SB)ã€‚åšåˆ°è¿›å…¥å’Œé€€å‡ºsyscallçš„æ—¶å€™é€šçŸ¥runtimeã€‚</p>

<p>è¿™ä¸¤ä¸ªå‡½æ•°runtimeÂ·entersyscallå’ŒruntimeÂ·exitsyscallçš„å®ç°åœ¨proc.goæ–‡ä»¶é‡Œé¢ã€‚å…¶å®åœ¨runtimeÂ·entersyscallå‡½æ•°é‡Œé¢ï¼Œé€šçŸ¥ç³»ç»Ÿè°ƒç”¨æ—¶å€™ï¼Œæ˜¯ä¼šå°†gçš„Mçš„Pè§£ç»‘ï¼ŒPå¯ä»¥å»ç»§ç»­è·å–Mæ‰§è¡Œå…¶ä½™çš„gï¼Œè¿™æ ·æå‡æ•ˆç‡ã€‚</p>

<p>æ‰€ä»¥å¦‚æœç”¨æˆ·ä»£ç ä½¿ç”¨äº† RawSyscall æ¥åšä¸€äº›é˜»å¡çš„ç³»ç»Ÿè°ƒç”¨ï¼Œæ˜¯æœ‰å¯èƒ½é˜»å¡å…¶å®ƒçš„ g çš„ã€‚RawSyscall åªæ˜¯ä¸ºäº†åœ¨æ‰§è¡Œé‚£äº›ä¸€å®šä¸ä¼šé˜»å¡çš„ç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œèƒ½èŠ‚çœä¸¤æ¬¡å¯¹ runtime çš„å‡½æ•°è°ƒç”¨æ¶ˆè€—ã€‚</p>

<p>runtimeÂ·entersyscallå’ŒruntimeÂ·exitsyscallè¿™ä¸¤ä¸ªå‡½æ•°ä¹Ÿæ˜¯ä¸scheduleräº¤äº’çš„åœ°æ–¹ï¼Œåé¢ä¼šå¯¹æºç è¿›è¡Œåˆ†æã€‚</p>

<p>2.ç³»ç»Ÿè°ƒç”¨ç®¡ç†
ç³»ç»Ÿè°ƒç”¨çš„å®šä¹‰æ–‡ä»¶: /syscall/syscall_linux.go</p>

<p>å¯ä»¥æŠŠç³»ç»Ÿè°ƒç”¨åˆ†ä¸ºä¸‰ç±»:</p>

<p>é˜»å¡ç³»ç»Ÿè°ƒç”¨
éé˜»å¡ç³»ç»Ÿè°ƒç”¨éé˜»å¡ç³»ç»Ÿè°ƒç”¨
wrapped ç³»ç»Ÿè°ƒç”¨
é˜»å¡ç³»ç»Ÿè°ƒç”¨ä¼šå®šä¹‰æˆä¸‹é¢è¿™æ ·çš„å½¢å¼:</p>

<p>//sys   Madvise(b []byte, advice int) (err error)
1
éé˜»å¡ç³»ç»Ÿè°ƒç”¨:</p>

<p>//sysnb    EpollCreate(size int) (fd int, err error)
1
ç„¶åï¼Œæ ¹æ®è¿™äº›æ³¨é‡Šï¼Œmksyscall.pl è„šæœ¬ä¼šç”Ÿæˆå¯¹åº”çš„å¹³å°çš„å…·ä½“å®ç°ã€‚mksyscall.pl æ˜¯ä¸€æ®µ perl è„šæœ¬ï¼Œæ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥è‡ªè¡ŒæŸ¥çœ‹ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ã€‚</p>

<p>çœ‹çœ‹é˜»å¡å’Œéé˜»å¡çš„ç³»ç»Ÿè°ƒç”¨çš„ç”Ÿæˆç»“æœ:</p>

<p>func Madvise(b []byte, advice int) (err error) {
    var _p0 unsafe.Pointer
    if len(b) &gt; 0 {
        _p0 = unsafe.Pointer(&amp;b[0])
    } else {
        _p0 = unsafe.Pointer(&amp;_zero)
    }
    _, _, e1 := Syscall(SYS_MADVISE, uintptr(_p0), uintptr(len(b)), uintptr(advice))
    if e1 != 0 {
        err = errnoErr(e1)
    }
    return
}</p>

<p>func EpollCreate(size int) (fd int, err error) {
    r0, _, e1 := RawSyscall(SYS_EPOLL_CREATE, uintptr(size), 0, 0)
    fd = int(r0)
    if e1 != 0 {
        err = errnoErr(e1)
    }
    return
}</p>

<p>æ ‡è®°ä¸º sys(é˜»å¡)çš„ç³»ç»Ÿè°ƒç”¨ä½¿ç”¨çš„æ˜¯ Syscall æˆ–è€… Syscall6ï¼Œæ ‡è®°ä¸º sysnb(éé˜»å¡) çš„ç³»ç»Ÿè°ƒç”¨ä½¿ç”¨çš„æ˜¯ RawSyscall æˆ– RawSyscall6ã€‚</p>

<p>wrapped çš„ç³»ç»Ÿè°ƒç”¨æ˜¯æ€ä¹ˆä¸€å›äº‹å‘¢ï¼Ÿ</p>

<p>func Rename(oldpath string, newpath string) (err error) {
    return Renameat(_AT_FDCWD, oldpath, _AT_FDCWD, newpath)
}</p>

<p>å¯èƒ½æ˜¯è§‰å¾—ç³»ç»Ÿè°ƒç”¨çš„åå­—ä¸å¤ªå¥½ï¼Œæˆ–è€…å‚æ•°å¤ªå¤šï¼Œæˆ‘ä»¬å°±ç®€å•åŒ…è£…ä¸€ä¸‹ã€‚æ²¡å•¥ç‰¹åˆ«çš„ã€‚</p>

<p>3.runtime ä¸­çš„ SYSCALL
é™¤äº†ä¸Šé¢æåˆ°çš„é˜»å¡éé˜»å¡å’Œ wrapped syscallï¼Œruntime ä¸­è¿˜å®šä¹‰äº†ä¸€äº› low-level çš„ syscallï¼Œè¿™äº›æ˜¯ä¸æš´éœ²ç»™ç”¨æˆ·ç¨‹åºçš„ã€‚</p>

<p>æä¾›ç»™ç”¨æˆ·çš„ syscall åº“ï¼Œåœ¨ä½¿ç”¨æ—¶ï¼Œä¼šä½¿ goroutine å’Œ p åˆ†åˆ«è¿›å…¥ Gsyscall å’Œ Psyscall çŠ¶æ€ã€‚ä½† runtime è‡ªå·±å°è£…çš„è¿™äº› syscall æ— è®ºæ˜¯å¦é˜»å¡ï¼Œéƒ½ä¸ä¼šè°ƒç”¨ entersyscall å’Œ exitsyscallã€‚ è™½è¯´æ˜¯ â€œlow-levelâ€ çš„ syscallï¼Œ ä¸è¿‡å’Œæš´éœ²ç»™ç”¨æˆ·çš„ syscall æœ¬è´¨æ˜¯ä¸€æ ·çš„ã€‚è¿™äº›ä»£ç åœ¨ runtime/sys_linux_amd64.s ä¸­ï¼Œä¸¾ä¸ªå…·ä½“çš„ä¾‹å­:</p>

<p>TEXT runtimeÂ·write(SB),NOSPLIT,$0-28
    MOVQ    fd+0(FP), DI
    MOVQ    p+8(FP), SI
    MOVL    n+16(FP), DX
    MOVL    $SYS_write, AX
    SYSCALL
    CMPQ    AX, $0xfffffffffffff001
    JLS    2(PC)
    MOVL    $-1, AX
    MOVL    AX, ret+24(FP)
    RET</p>

<p>TEXT runtimeÂ·read(SB),NOSPLIT,$0-28
    MOVL    fd+0(FP), DI
    MOVQ    p+8(FP), SI
    MOVL    n+16(FP), DX
    MOVL    $SYS_read, AX
    SYSCALL
    CMPQ    AX, $0xfffffffffffff001
    JLS    2(PC)
    MOVL    $-1, AX
    MOVL    AX, ret+24(FP)
    RET</p>

<p>è¿™äº› syscall ç†è®ºä¸Šéƒ½æ˜¯ä¸ä¼šåœ¨æ‰§è¡ŒæœŸé—´è¢«è°ƒåº¦å™¨å‰¥ç¦»æ‰ p çš„ï¼Œæ‰€ä»¥æ‰§è¡ŒæˆåŠŸä¹‹å goroutine ä¼šç»§ç»­æ‰§è¡Œï¼Œè€Œä¸åƒç”¨æˆ·çš„ goroutine ä¸€æ ·ï¼Œè‹¥è¢«å‰¥ç¦» p ä¼šè¿›å…¥ç­‰å¾…é˜Ÿåˆ—ã€‚</p>

<p>4.ç”¨æˆ·ä»£ç çš„ç³»ç»Ÿè°ƒç”¨å’Œè°ƒåº¦äº¤äº’
æ—¢ç„¶è¦å’Œè°ƒåº¦äº¤äº’ï¼Œé‚£å°±è¦å‹å¥½åœ°é€šçŸ¥æˆ‘è¦ syscall äº†: entersyscallï¼Œæˆ‘å®Œäº‹äº†: exitsyscallã€‚</p>

<p>æ‰€ä»¥è¿™é‡Œçš„äº¤äº’æŒ‡çš„æ˜¯ç”¨æˆ·ä»£ç ä½¿ç”¨ syscall åº“æ—¶å’Œè°ƒåº¦å™¨çš„äº¤äº’ã€‚runtime é‡Œçš„ syscall ä¸èµ°è¿™å¥—æµç¨‹ã€‚</p>

<p>entersyscallå’Œexitsyscallçš„pipeline
                      +â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€“+
                      |runtime.entersyscall()                               |
                      |1) save() goroutine Save on site                     |
user code             |2) casgstatus(<em>g</em>, <em>Grunning, _Gsyscall)             |
 syscall   â€”â€”â€”-&gt;|3) atomic.Store(&amp;_g</em>.m.p.ptr().status, _Psyscall)    |
                      |                                                     |
                      |a) the M is blocking;                                |
                      |b) the status of P is _Psyscall, So the P can be     |
                      |schedule to execute other goroutine                  |
                      +â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€“+</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                         +--------------------------+                    
 user code               |runtime.exitsyscall()     |                      syscall finished ----------&gt;|1) disable preemption     |                    
                         |                          |                    
                         +--+--------------------+--+                    
                            |                    |                                       
                            |                    |                           
                            |                    |                       
                            v                    v                       
                    try to re-acquire   try to get any other             
                        the last P             idle P                    
                            |                    |                       
                            |                    |                       
                            |                    |                       
                  success---+--------------------+-----+                 
                      |                                |                 
                      |                              fail                
                      |                                |                 
                      v                                |                 
           +---------------------+          +----------+------&gt;------+   
           |there is a P to run G|          |not get P               |   
           |runtime.exexute(G)   |          |1.put G into global tail|   
           |schedule loop        |          |2.idel this M           |   
           |                     |          |                        |   
           +---------------------+          +------------------------+   
</code></pre></div></div>

<p>entersyscall
ç›´æ¥çœ‹æºç ï¼š</p>

<p>// ç”¨æˆ·ä»£ç ä½¿ç”¨ syscall åº“æ—¶å’Œè°ƒåº¦å™¨çš„äº¤äº’ï¼›
// runtimeæœ¬èº«çš„syscallä¸èµ°è¿™ä¸€å¥—æµç¨‹
// Standard syscall entry used by the go syscall library and normal cgo calls.
//go:nosplit
func entersyscall() {
	reentersyscall(getcallerpc(), getcallersp())
}</p>

<p>//go:nosplit
func reentersyscall(pc, sp uintptr) {
	<em>g</em> := getg()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// éœ€è¦ç¦æ­¢ g çš„æŠ¢å 
_g_.m.locks++

// entersyscall ä¸­ä¸èƒ½è°ƒç”¨ä»»ä½•ä¼šå¯¼è‡´æ ˆå¢é•¿/åˆ†è£‚çš„å‡½æ•°
// (See details in comment above.)
// Catch calls that might, by replacing the stack guard with something that
// will trip any stack check and leaving a flag to tell newstack to die.
_g_.stackguard0 = stackPreempt
_g_.throwsplit = true

// Leave SP around for GC and traceback.
//ä¿å­˜ç°åœºï¼Œåœ¨ syscall ä¹‹åä¼šä¾æ®è¿™äº›æ•°æ®æ¢å¤ç°åœº
save(pc, sp)
_g_.syscallsp = sp
_g_.syscallpc = pc
casgstatus(_g_, _Grunning, _Gsyscall)
if _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp {
	systemstack(func() {
		print("entersyscall inconsistent ", hex(_g_.syscallsp), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")
		throw("entersyscall")
	})
}

if trace.enabled {
	systemstack(traceGoSysCall)
	// systemstack itself clobbers g.sched.{pc,sp} and we might
	// need them later when the G is genuinely blocked in a
	// syscall
	save(pc, sp)
}

if atomic.Load(&amp;sched.sysmonwait) != 0 {
	systemstack(entersyscall_sysmon)
	save(pc, sp)
}

if _g_.m.p.ptr().runSafePointFn != 0 {
	// runSafePointFn may stack split if run on this stack
	systemstack(runSafePointFn)
	save(pc, sp)
}

_g_.m.syscalltick = _g_.m.p.ptr().syscalltick
_g_.sysblocktraced = true
_g_.m.mcache = nil
// è§£ç»‘Pä¸Mçš„å…³ç³»
_g_.m.p.ptr().m = 0
atomic.Store(&amp;_g_.m.p.ptr().status, _Psyscall)
if sched.gcwaiting != 0 {
	systemstack(entersyscall_gcwait)
	save(pc, sp)
}

_g_.m.locks-- }
</code></pre></div></div>

<p>ä¸»è¦æµç¨‹å¦‚ä¸‹ï¼š</p>

<p>è®¾ç½®_g_.m.locks++ï¼Œç¦æ­¢gè¢«å¼ºå 
è®¾ç½®_g_.stackguard0 = stackPreemptï¼Œç¦æ­¢è°ƒç”¨ä»»ä½•ä¼šå¯¼è‡´æ ˆå¢é•¿/åˆ†è£‚çš„å‡½æ•°
ä¿å­˜ç°åœºï¼Œåœ¨ syscall ä¹‹åä¼šä¾æ®è¿™äº›æ•°æ®æ¢å¤ç°åœº
æ›´æ–°Gçš„çŠ¶æ€ä¸º_Gsyscall
é‡Šæ”¾å±€éƒ¨è°ƒåº¦å™¨Pï¼šè§£ç»‘Pä¸Mçš„å…³ç³»ï¼›
æ›´æ–°PçŠ¶æ€ä¸º_Psyscall
g.m.locksâ€“è§£é™¤ç¦æ­¢å¼ºå ã€‚
å¯ä»¥çœ‹åˆ°ï¼Œè¿›å…¥ syscall çš„ G æ˜¯é“å®šä¸ä¼šè¢«æŠ¢å çš„ã€‚</p>

<p>æ­¤å¤–è¿›å…¥ç³»ç»Ÿè°ƒç”¨çš„goroutineä¼šé˜»å¡ï¼Œå¯¼è‡´å†…æ ¸Mä¼šé˜»å¡ã€‚æ­¤æ—¶Pä¼šè¢«å‰¥ç¦»æ‰ï¼Œæ‰€ä»¥På¯ä»¥ç»§ç»­å»è·å–å…¶ä½™çš„ç©ºé—²Mæ‰§è¡Œå…¶ä½™çš„goroutineã€‚</p>

<p>exitsyscall
ç›´æ¥çœ‹æºç </p>

<p>// g å·²ç»é€€å‡ºäº† syscall
// éœ€è¦å‡†å¤‡è®© g åœ¨ cpu ä¸Šé‡æ–°è¿è¡Œ
// ä¸èƒ½æœ‰ write barrierï¼Œå› ä¸º P å¯èƒ½å·²ç»è¢«å·èµ°äº†
//go:nosplit
//go:nowritebarrierrec
func exitsyscall() {
	<em>g</em> := getg()
	// ç¦æ­¢å¼ºå 
	<em>g</em>.m.locks++ // see comment in entersyscall
	if getcallersp() &gt; <em>g</em>.syscallsp {
		throw(â€œexitsyscall: syscall frame is no longer validâ€)
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_g_.waitsince = 0
oldp := _g_.m.p.ptr()
if exitsyscallfast() {
	if _g_.m.mcache == nil {
		throw("lost mcache")
	}
	if trace.enabled {
		if oldp != _g_.m.p.ptr() || _g_.m.syscalltick != _g_.m.p.ptr().syscalltick {
			systemstack(traceGoStart)
		}
	}
	// There's a cpu for us, so we can run.
	_g_.m.p.ptr().syscalltick++
	// We need to cas the status and scan before resuming...
	casgstatus(_g_, _Gsyscall, _Grunning)

	// Garbage collector isn't running (since we are),
	// so okay to clear syscallsp.
	_g_.syscallsp = 0
	_g_.m.locks--
	if _g_.preempt {
		// restore the preemption request in case we've cleared it in newstack
		_g_.stackguard0 = stackPreempt
	} else {
		// otherwise restore the real _StackGuard, we've spoiled it in entersyscall/entersyscallblock
		_g_.stackguard0 = _g_.stack.lo + _StackGuard
	}
	_g_.throwsplit = false
	return
}

_g_.sysexitticks = 0
if trace.enabled {
	// Wait till traceGoSysBlock event is emitted.
	// This ensures consistency of the trace (the goroutine is started after it is blocked).
	for oldp != nil &amp;&amp; oldp.syscalltick == _g_.m.syscalltick {
		osyield()
	}
	// We can't trace syscall exit right now because we don't have a P.
	// Tracing code can invoke write barriers that cannot run without a P.
	// So instead we remember the syscall exit time and emit the event
	// in execute when we have a P.
	_g_.sysexitticks = cputicks()
}

_g_.m.locks--

// Call the scheduler.
mcall(exitsyscall0)

if _g_.m.mcache == nil {
	throw("lost mcache")
}

// Scheduler returned, so we're allowed to run now.
// Delete the syscallsp information that we left for
// the garbage collector during the system call.
// Must wait until now because until gosched returns
// we don't know for sure that the garbage collector
// is not running.
_g_.syscallsp = 0
_g_.m.p.ptr().syscalltick++
_g_.throwsplit = false }
</code></pre></div></div>

<p>//exitsyscallfast
//go:nosplit
func exitsyscallfast() bool {
	<em>g</em> := getg()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Freezetheworld sets stopwait but does not retake P's.
if sched.stopwait == freezeStopWait {
	_g_.m.mcache = nil
	_g_.m.p = 0
	return false
}

// Try to re-acquire the last P.
if _g_.m.p != 0 &amp;&amp; _g_.m.p.ptr().status == _Psyscall &amp;&amp; atomic.Cas(&amp;_g_.m.p.ptr().status, _Psyscall, _Prunning) {
	// There's a cpu for us, so we can run.
	exitsyscallfast_reacquired()
	return true
}

// Try to get any other idle P.
oldp := _g_.m.p.ptr()
_g_.m.mcache = nil
_g_.m.p = 0
if sched.pidle != 0 {
	var ok bool
	systemstack(func() {
		ok = exitsyscallfast_pidle()
		if ok &amp;&amp; trace.enabled {
			if oldp != nil {
				// Wait till traceGoSysBlock event is emitted.
				// This ensures consistency of the trace (the goroutine is started after it is blocked).
				for oldp.syscalltick == _g_.m.syscalltick {
					osyield()
				}
			}
			traceGoSysExit(0)
		}
	})
	if ok {
		return true
	}
}
return false }
</code></pre></div></div>

<p>// exitsyscall0
// exitsyscall slow path on g0.
// Failed to acquire P, enqueue gp as runnable.
//
//go:nowritebarrierrec
func exitsyscall0(gp *g) {
	<em>g</em> := getg()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>casgstatus(gp, _Gsyscall, _Grunnable)
dropg()
lock(&amp;sched.lock)
_p_ := pidleget()
if _p_ == nil {
	globrunqput(gp)
} else if atomic.Load(&amp;sched.sysmonwait) != 0 {
	atomic.Store(&amp;sched.sysmonwait, 0)
	notewakeup(&amp;sched.sysmonnote)
}
unlock(&amp;sched.lock)
if _p_ != nil {
	acquirep(_p_)
	execute(gp, false) // Never returns.
}
if _g_.m.lockedg != 0 {
	// Wait until another thread schedules gp and so m again.
	stoplockedm()
	execute(gp, false) // Never returns.
}
stopm()
schedule() // Never returns. }
</code></pre></div></div>

<p>ä¸»è¦çš„pipelineå¦‚ä¸‹ï¼š</p>

<p>è®¾ç½® g.m.locks++ ç¦æ­¢å¼ºå 
è°ƒç”¨ exitsyscallfast() å¿«é€Ÿé€€å‡ºç³»ç»Ÿè°ƒç”¨
2.1. Try to re-acquire the last Pï¼Œå¦‚æœæˆåŠŸå°±ç›´æ¥æ¥return;
2.2. Try to get any other idle P from allIdleP list;
2.3. æ²¡æœ‰è·å–åˆ°ç©ºé—²çš„P
å¦‚æœå¿«é€Ÿè·å–åˆ°äº†Pï¼š
3.1. æ›´æ–°G çš„çŠ¶æ€æ˜¯_Grunning
3.2. ä¸Gç»‘å®šçš„Mä¼šåœ¨é€€å‡ºç³»ç»Ÿè°ƒç”¨ä¹‹åç»§ç»­æ‰§è¡Œ
æ²¡æœ‰è·å–åˆ°ç©ºé—²çš„Pï¼š
4.1. è°ƒç”¨mcall()å‡½æ•°åˆ‡æ¢åˆ°g0çš„æ ˆç©ºé—´ï¼›
4.2. è°ƒç”¨exitsyscall0å‡½æ•°ï¼š
4.2.1. æ›´æ–°G çš„çŠ¶æ€æ˜¯_Grunning
4.2.2. è°ƒç”¨dropg()ï¼šè§£é™¤å½“å‰gä¸Mçš„ç»‘å®šå…³ç³»ï¼›
4.2.3. è°ƒç”¨globrunqputå°†Gæ’å…¥global queueçš„é˜Ÿå°¾ï¼Œ
4.2.4. è°ƒç”¨stopm()é‡Šæ”¾Mï¼Œå°†MåŠ å…¥å…¨å±€çš„idel Måˆ—è¡¨ï¼Œè¿™ä¸ªè°ƒç”¨ä¼šé˜»å¡ï¼ŒçŸ¥é“è·å–åˆ°å¯ç”¨çš„Pã€‚
4.2.5. å¦‚æœ4.2.4ä¸­é˜»å¡ç»“æŸï¼ŒMè·å–åˆ°äº†å¯ç”¨çš„Pï¼Œä¼šè°ƒç”¨schedule()å‡½æ•°ï¼Œæ‰§è¡Œä¸€æ¬¡æ–°çš„è°ƒåº¦ã€‚
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè°ƒç”¨ exitsyscall0 æ—¶ï¼Œä¼šåˆ‡æ¢åˆ° g0 æ ˆã€‚</p>

<p>entersyscallblock
ç”¨æˆ·ä»£ç è¿›è¡Œç³»ç»Ÿè°ƒç”¨æ—¶å€™ï¼ŒçŸ¥é“è‡ªå·±ä¼š blockï¼Œç›´æ¥å°±æŠŠ p äº¤å‡ºæ¥äº†ã€‚</p>

<p>ä»£ç å®ç°å’Œ entersyscall ä¸€æ ·ï¼Œå°±æ˜¯ä¼šç›´æ¥æŠŠ P ç»™äº¤å‡ºå»ï¼Œå› ä¸ºçŸ¥é“è‡ªå·±æ˜¯ä¼šé˜»å¡çš„ã€‚</p>

<p>// å’Œ entersyscall ä¸€æ ·ï¼Œå°±æ˜¯ä¼šç›´æ¥æŠŠ P ç»™äº¤å‡ºå»ï¼Œå› ä¸ºçŸ¥é“è‡ªå·±æ˜¯ä¼šé˜»å¡çš„
//go:nosplit
func entersyscallblock(dummy int32) {
    <em>g</em> := getg()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_g_.m.locks++ // see comment in entersyscall
_g_.throwsplit = true
_g_.stackguard0 = stackPreempt // see comment in entersyscall
_g_.m.syscalltick = _g_.m.p.ptr().syscalltick
_g_.sysblocktraced = true
_g_.m.p.ptr().syscalltick++

// Leave SP around for GC and traceback.
pc := getcallerpc()
sp := getcallersp(unsafe.Pointer(&amp;dummy))
save(pc, sp)
_g_.syscallsp = _g_.sched.sp
_g_.syscallpc = _g_.sched.pc
if _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp {
    sp1 := sp
    sp2 := _g_.sched.sp
    sp3 := _g_.syscallsp
    systemstack(func() {
        print("entersyscallblock inconsistent ", hex(sp1), " ", hex(sp2), " ", hex(sp3), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")
        throw("entersyscallblock")
    })
}
casgstatus(_g_, _Grunning, _Gsyscall)
if _g_.syscallsp &lt; _g_.stack.lo || _g_.stack.hi &lt; _g_.syscallsp {
    systemstack(func() {
        print("entersyscallblock inconsistent ", hex(sp), " ", hex(_g_.sched.sp), " ", hex(_g_.syscallsp), " [", hex(_g_.stack.lo), ",", hex(_g_.stack.hi), "]\n")
        throw("entersyscallblock")
    })
}

// ç›´æ¥è°ƒç”¨ entersyscallblock_handoff æŠŠ p äº¤å‡ºæ¥äº†
systemstack(entersyscallblock_handoff)

// Resave for traceback during blocked call.
save(getcallerpc(), getcallersp(unsafe.Pointer(&amp;dummy)))

_g_.m.locks-- }
</code></pre></div></div>

<p>è¿™ä¸ªå‡½æ•°åªæœ‰ä¸€ä¸ªè°ƒç”¨æ–¹ notesleepgï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ã€‚</p>

<p>func entersyscallblock_handoff() {
    handoffp(releasep())
}</p>

<ol>
  <li>æ€»ç»“
æä¾›ç»™ç”¨æˆ·ä½¿ç”¨çš„ç³»ç»Ÿè°ƒç”¨ï¼ŒåŸºæœ¬éƒ½ä¼šé€šçŸ¥ runtimeï¼Œä»¥ entersyscallï¼Œexitsyscall çš„å½¢å¼æ¥å‘Šè¯‰ runtimeï¼Œåœ¨è¿™ä¸ª syscall é˜»å¡çš„æ—¶å€™ï¼Œç”± runtime åˆ¤æ–­æ˜¯å¦æŠŠ P è…¾å‡ºæ¥ç»™å…¶å®ƒçš„ M ç”¨ã€‚è§£ç»‘å®šæŒ‡çš„æ˜¯æŠŠ M å’Œ P ä¹‹é—´è§£ç»‘ï¼Œå¦‚æœç»‘å®šè¢«è§£é™¤ï¼Œåœ¨ syscall è¿”å›æ—¶ï¼Œè¿™ä¸ª g ä¼šè¢«æ”¾å…¥å…¨å±€æ‰§è¡Œé˜Ÿåˆ— global runq ä¸­ã€‚</li>
</ol>

<p>åŒæ—¶ runtime åˆä¿ç•™äº†è‡ªå·±çš„ç‰¹æƒï¼Œåœ¨æ‰§è¡Œè‡ªå·±çš„é€»è¾‘çš„æ—¶å€™ï¼Œæˆ‘çš„ P ä¸ä¼šè¢«è°ƒèµ°ï¼Œè¿™æ ·ä¿è¯äº†åœ¨ Go è‡ªå·±â€œåº•å±‚â€ä½¿ç”¨çš„è¿™äº› syscall è¿”å›ä¹‹åéƒ½èƒ½è¢«ç«‹åˆ»å¤„ç†ã€‚</p>

<p>æ‰€ä»¥åŒæ ·æ˜¯ epollwaitï¼Œruntime ç”¨çš„æ˜¯ä¸èƒ½è¢«åˆ«äººæ‰“æ–­çš„ï¼Œä½ ç”¨çš„ syscall.EpollWait é‚£æ˜¾ç„¶æ˜¯æ²¡æœ‰è¿™ç§ç‰¹æƒçš„ã€‚
https://blog.csdn.net/u010853261/article/details/88312904</p>
:ET