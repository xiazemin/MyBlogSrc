I"<p>Go的类方法中，分为值接收者方法和指针接收者方法
指针类型，能够调用值和指针接收者方法，反之不行；值实现接口类型，能够被值和指针调用；反之不行；
函数返回值（没有值向指针隐式转换）和实现接口的时候需要注意；
<!-- more -->
值方法和指针方法</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>我们来看看值方法的声明。
</code></pre></div></div>

<p>type Dog struct {
}</p>

<p>func (d Dog) Bark() {
    fmt.Println(“dog”)
}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>上面代码中，方法Bark的接收者是值类型，那么这就是一个值接收者的方法。

下面再看看指针接收者的方法。
</code></pre></div></div>

<p>type Cat struct {
}</p>

<p>func (c *Cat) Bark() {
    fmt.Println(“cat”)
}
类的方法集合</p>

<p>这个在Go文档里有定义：</p>

<p>对于类型T，它的方法集合是所有接收者为T的方法。</p>

<p>对于类型<em>T，它的方法集合是所有接收者为</em>T和T的方法。</p>

<p>Values	Method Sets
T	(t T)
*T	(t T) and (t *T)</p>

<p>方法的调用者</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>指针*T接收者方法：只有指针类型*T才能调用，但其实值T类型也能调用，为什么呢？因为当使用值调用t.Call()时，Go会转换成(&amp;t).Call()，也就是说最后调用的还是接收者为指针*T的方法。

但要注意t是要能取地址才能这么调用，比如下面这种情况就不行：
</code></pre></div></div>

<p>func getUser() User {
    return User{}
}</p>

<p>…</p>

<p>getUser().SayWat()
// 编译错误：
// cannot call pointer method on aUser()
// cannot take the address of aUser()
    值T接收者方法：指针类型*T和值T类型都能调用。</p>

<p>Methods Receivers	Values
(t T)	T and <em>T
(t *T)	*T
    使用接收者为</em>T的方法实现一个接口，那么只有那个类型的指针*T实现了对应的接口。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>如果使用接收者为T的方法实现一个接口，那么这个类型的值T和指针*T都实现了对应的接口。
</code></pre></div></div>

<p>声明建议</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在给类声明方法时，方法接收者的类型要统一，最好不要同时声明接收者为值和指针的方法，这样容易混淆而不清楚到底实现了哪些接口。

下面我们来看看哪种类型适合声明接收者为值或指针的方法。
</code></pre></div></div>

<p>指针接收者方法</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>下面这2种情况请务必声明指针接收者方法：

1. 方法中需要对接收者进行修改的。

2. 类中包含sync.Mutex或类似锁的变量，因为它们不允许值拷贝。



下面这2种情况也建议声明指针接收者方法：

1. 类成员很多的，或者大数组，使用指针接收者效率更高。

2. 如果拿不准，那也声明接收者为指针的方法吧。
</code></pre></div></div>

<p>值接收者方法</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>下面这些情况建议使用值接收者方法：

1. 类型为map，func，channel。

2. 一些基本的类型，如int，string。



3. 一些小数组，或小结构体并且不需要修改接收者的。
</code></pre></div></div>

<p>题目解析</p>

<p>type Animal interface {
    Bark()
}</p>

<p>type Dog struct {
}</p>

<p>func (d Dog) Bark() {
    fmt.Println(“dog”)
}</p>

<p>type Cat struct {
}</p>

<p>func (c *Cat) Bark() {
    fmt.Println(“cat”)
}</p>

<p>func Bark(a Animal) {
    a.Bark()
}</p>

<p>func getDog() Dog {
    return Dog{}
}</p>

<p>func getCat() Cat {
    return Cat{}
}</p>

<p>func main() {
    dp := &amp;Dog{}
    d := Dog{}
    dp.Bark() // (1) 通过
    d.Bark()  // (2) 通过
    Bark(dp)
    // (3) 通过，上面说了类型<em>Dog的方法集合包含接收者为</em>Dog和Dog的方法
    Bark(d)   // (4) 通过</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cp := &amp;Cat{}
c := Cat{}
cp.Bark() // (5) 通过
c.Bark()  // (6) 通过
Bark(cp)  // (7) 通过
Bark(c)
// (8) 编译错误，值类型Cat的方法集合只包含接收者为Cat的方法
// 所以T并没有实现Animal接口

getDog().Bark() // (9) 通过
getCat().Bark()
// (10) 编译错误，
// 上面说了，getCat()是不可地址的
// 所以不能调用接收者为*Cat的方法 } 总结 1. 理清类型的方法集合。 2. 理清接收者方法的调用范围。 
</code></pre></div></div>
:ET