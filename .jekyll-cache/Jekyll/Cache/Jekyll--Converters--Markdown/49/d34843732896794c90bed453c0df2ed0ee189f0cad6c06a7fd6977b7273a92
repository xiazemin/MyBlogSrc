I"<p>程序其实就是一堆需要按照顺序一个接一个执行的机器指令。为此，操作系统使用了一个线程的概念。线程的工作就是按顺序执行分配给它的指令集，直到没有指令可以执行了为止。
你运行的每一个程序都会创建一个进程，并且每一个进程都会有一个初始线程。线程拥有创建更多线程的能力。这些不同的线程都是独立运行的，调度策略都是在线程这一级别上的，而不是进程级别（或者说调度的最小单元是线程而不是进程）。线程是可以并发执行的（轮流使用同一个核），或并行（每个线程互不干扰的同时在不同的核上跑）。线程还维护这他们自己状态，好保证安全、隔离、独立的执行自己的指令。
系统调度器负责保证当有线程可以执行时，CPU 是不能处于空闲状态的。它还必须创建一个所有线程同时都在运行的假象。在创造这个假象的过程中，调度器需要优先运行优先级更高的线程。但是低优先级的线程又不能被饿死（就是一直不被运行）。调度器还需要通过快速、明智的决策尽可能的最小化调度延迟。
https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html
https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html
<!-- more -->
执行指令
Program counter(PC)，有时候也被叫做指令指针(instruction pointer, 简称IP)，线程用它来跟踪下一个要执行的指令。在大多数处理器中，PC 指向的是下一个指令，而不是当前指令。
如果你曾经看过 Go 程序的 stack trace，你可能注意到了每行的最后都有一个 16 进制数字。比如 +0x39和0x72。
goroutine 1 [running]:
   main.example(0xc000042748, 0x2, 0x4, 0x106abae, 0x5, 0xa)
       stack_trace/example1/example1.go:13 +0x39                 &lt;- LOOK HERE
   main.main()
       stack_trace/example1/example1.go:8 +0x72                  &lt;- LOOK HERE</p>
:ET