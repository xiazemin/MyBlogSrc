I"¯/<p>https://github.com/wangzhione/libiop
ä¸€ä¸ªcè¯­è¨€å¼€å‘çš„è·¨å¹³å°ç½‘ç»œIOåº“</p>

<p>åŠŸèƒ½ç‰¹æ€§ï¼š</p>

<p>1ï¼šc/c++ api, åº•å±‚æ”¯æŒepoll,select,pollç­‰ioæ¨¡å‹</p>

<p>2ï¼šå¼‚æ­¥äº‹ä»¶æ¨¡å‹</p>

<p>3ï¼šä»»åŠ¡æ± æ¨¡å‹ï¼Œè·¨å¹³å°çº¿ç¨‹æ¥å£</p>

<p>4ï¼šè·¨å¹³å°(Linux/windows)</p>

<p>5:æ—¥å¿—æœåŠ¡</p>

<p>6ï¼šç¨³å®šï¼Œæ”¯æŒ7*24å°æ—¶æ— é—´æ–­è¿è¡Œï¼Œè‡ªåŠ¨å¤„ç†å¼‚å¸¸çŠ¶æ€</p>

<p>7ï¼šé«˜å¹¶å‘ä¸å¿«é€Ÿå“åº”</p>

<p>8ï¼šAPIç®€æ´ï¼Œ å­¦ä¹ æˆæœ¬åº•
<!-- more -->
iop_def.h, è¿™é‡Œé¢å®šä¹‰äº†å¸¸ç”¨çš„æ•°æ®ç»“æ„</p>

<p>tag_iop_base_t ä¸»è¦ç”¨äºç®¡ç†æ‰€æœ‰äº‹ä»¶ï¼Œæ¯ä¸ªäº‹ä»¶æ˜¯ä¸€ä¸ªiop_t,</p>

<p>maxioè¡¨ç¤ºæœ€å¤§çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œ</p>

<p>free_list_head è¡¨ç¤ºå¯ç”¨çš„ç©ºé—²åˆ—è¡¨å¤´éƒ¨idï¼Œä¸€èˆ¬ç”¨iops + free_list_head</p>

<p>å–å‡ºiop_t çš„å…ƒç´ </p>

<p>åŒç†free_list_tailï¼Œæœ€åä¸€ä¸ªå¯ç”¨iop,</p>

<p>iop_op_t æ˜¯å°è£…äº†å‡ ä¸ªå‡½æ•°æŒ‡é’ˆçš„ç»“æ„ä½“,</p>

<p>åŒ…æ‹¬ç½‘ç»œæ¨¡å‹çš„åå­—ï¼Œäº‹ä»¶çš„æ·»åŠ ï¼Œäº‹ä»¶çš„åˆ é™¤ï¼Œäº‹ä»¶çš„æ›´æ”¹ï¼Œäº‹ä»¶çš„æ´¾å‘</p>

<p>å‰©ä¸‹çš„å¦‚æ³¨é‡Šæ‰€ç¤º</p>

<p>struct tag_iop_base_t
{
    iop_t <em>iops;        /</em>æ‰€æœ‰iop<em>/
    int maxio;            /</em>æœ€å¤§å¹¶å‘ioæ•°,åŒ…æ‹¬å®šæ—¶å™¨åœ¨å†…<em>/
    int maxbuf;            /</em>å•ä¸ªå‘é€æˆ–æ¥æ”¶ç¼“å­˜çš„æœ€å¤§å€¼<em>/
    int free_list_head;    /</em>å¯ç”¨iopåˆ—è¡¨<em>/
    int free_list_tail; /</em>æœ€åä¸€ä¸ªå¯ç”¨iop<em>/
    int io_list_head;    /</em>å·²ç”¨ioç±»å‹çš„iopåˆ—è¡¨<em>/
    int timer_list_head;    /</em>å·²ç”¨timerç±»å‹çš„iopåˆ—è¡¨<em>/
    int connect_list_head;  /</em>å¼‚æ­¥è¿æ¥çš„iopåˆ—è¡¨<em>/
    volatile int exit_flag;    /</em>é€€å‡ºæ ‡å¿—*/</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int dispatch_interval;        /*é«˜åº¦çš„é—´éš”æ—¶é—´*/
iop_op_t op_imp;           /*äº‹ä»¶æ¨¡å‹çš„å†…éƒ¨å®ç°*/
void *model_data;         /*äº‹ä»¶æ¨¡å‹ç‰¹å®šçš„æ•°æ®*/

iop_time_t cur_time;        /*å½“å‰è°ƒåº¦æ—¶é—´*/
iop_time_t last_time;        /*ä¸Šæ¬¡è°ƒåº¦æ—¶é—´*/
iop_time_t last_keepalive_time; /*ä¸Šæ¬¡æ£€æŸ¥keepaliveçš„æ—¶é—´*/

_list_node_t * tcp_protocol_list_head;    /*use for advance tcp server model.*/ };
</code></pre></div></div>

<p>çœ‹ä¸€ä¸‹iop_tç»“æ„ä½“ï¼Œidæ˜¯ä»0å¼€å§‹åˆ°nçš„æ•°,è¿™ä¸ªæ˜¯åœ¨tag_iop_base_t ä¸­åˆå§‹åŒ–é˜Ÿåˆ—æ—¶åšçš„ï¼Œ</p>

<p>io_handle_tæ˜¯è¿™ä¸ªç»“æ„å­˜å‚¨çš„socket id, iop_typeåˆ†ä¸‰ç§0è¡¨ç¤ºé‡Šæ”¾ï¼Œ1è¡¨ç¤ºioè¯»å†™ï¼Œ2è¡¨ç¤º</p>

<p>å®šæ—¶å™¨äº‹ä»¶ï¼Œ iop_event_cbè¡¨ç¤ºäº‹ä»¶å›è°ƒå‡½æ•°æŒ‡é’ˆï¼Œæ¯ä¸€ä¸ªiop_tç»‘å®šäº†ä¸åŒçš„å›è°ƒå‡½æ•°ï¼Œ</p>

<p>æ¯”å¦‚acceptï¼Œæ¯”å¦‚readï¼Œæ¯”å¦‚writeï¼Œä½†æ˜¯è¿™äº›å›è°ƒå‡½æ•°è¦å°è£…æˆiop_event_cbç±»å‹ï¼Œ</p>

<p>dbuf_t æ˜¯ä½œè€…å°è£…çš„ä¸€ä¸ªç®¡ç†å‘é€å’Œæ¥å—æ•°æ®çš„ç»“æ„</p>

<p>/*
<em>tag_iop_t:iopç»“æ„ï¼Œæ¯ä¸€ä¸ªiopå¯¹è±¡éƒ½ä¼šå¯¹åº”ä¸€ä¸ªtag_iop_tç»“æ„
*/
struct tag_iop_t
{
    int id;                    /</em>å¯¹åº”çš„id<em>/
    io_handle_t handle;        /</em>å…³è”çš„å¥æŸ„<em>/
    int iop_type;            /</em>å¯¹è±¡ç±»å‹ï¼š0ï¼šfree,1:io,2:timer<em>/
    int prev;                /</em>ä¸Šä¸€ä¸ªå¯¹è±¡<em>/
    int next;                /</em>ä¸‹ä¸€ä¸ªå¯¹è±¡<em>/
    unsigned int events;                /</em>å…³æ³¨çš„äº‹ä»¶<em>/
    int timeout;            /</em>è¶…æ—¶å€¼<em>/
    iop_event_cb evcb;        /</em>äº‹ä»¶å›è°ƒ<em>/
    void *arg;                /</em>ç”¨æˆ·æŒ‡å®šçš„å‚æ•°,ç”±ç”¨æˆ·è´Ÿè´£é‡Šæ”¾èµ„æº<em>/
    void *sys_arg;            /</em>ç³»ç»ŸæŒ‡å®šçš„å‚æ•°ï¼Œç³»ç»Ÿè‡ªåŠ¨é‡Šæ”¾èµ„æº<em>/
    /</em>ä»¥ä¸‹å­—æ®µå¯¹å®šæ—¶å™¨æ— ç”¨<em>/
    dbuf_t *sbuf;        /</em>å‘é€ç¼“å­˜åŒº<em>/
    dbuf_t *rbuf;        /</em>æ¥æ”¶ç¼“å­˜åŒº<em>/
    iop_time_t last_dispatch_time;    /</em>ä¸Šæ¬¡è°ƒåº¦çš„æ—¶é—´*/
};</p>

<p>iop_event_cb å®šä¹‰å¦‚ä¸‹</p>

<p>/<em>äº‹ä»¶å›è°ƒå‡½æ•°,è¿”å›-1ä»£è¡¨è¦åˆ é™¤å¯¹è±¡,è¿”å›0ä»£è¡¨æ­£å¸¸</em>/
typedef int (*iop_event_cb)(iop_base_t *,int,unsigned int,void *);</p>

<p>dbuf_tç»“æ„å¦‚ä¸‹</p>

<p>struct tag_dbuf
{
    unsigned int capacity;
    unsigned int size;
    void *data;
};
è‡³äºdbuf_tå¦‚ä½•å¼€è¾Ÿç©ºé—´é‡Šæ”¾ç©ºé—´ï¼Œè¯»å†™åç§»çš„éƒ½ä¸åšèµ˜è¿°</p>

<p>iop_base_tä¸­iop_op_t ç»“æ„å¾ˆé‡è¦ï¼Œæ˜¯äº‹ä»¶è°ƒåº¦çš„æ ¸å¿ƒ</p>

<p>ç»“æ„å¦‚ä¸‹</p>

<p>struct tag_iop_op_t
{
    const char <em>name;                               //æ¨¡å‹åç§°
    void (</em>base_free)(iop_base_t <em>);        //èµ„æºé‡Šæ”¾çš„æ¥å£
    int (</em>base_dispatch)(iop_base_t <em>, int);  //æ¨¡å‹è°ƒåº¦æ¥å£
    //æ·»åŠ äº‹ä»¶
    int (</em>base_add)(iop_base_t <em>, int, io_handle_t, unsigned int);
    //åˆ é™¤äº‹ä»¶
    int (</em>base_del)(iop_base_t <em>, int,io_handle_t);
    //ä¿®æ”¹äº‹ä»¶
    int (</em>base_mod)(iop_base_t *, int, io_handle_t, unsigned int);
};
å› ä¸ºå¯¹åº”ä¸åŒçš„å¹³å°ï¼Œæˆ‘ä»¬è¦åº”ç”¨ä¸åŒçš„ç½‘ç»œæ¨¡å‹ï¼Œæ¯”å¦‚epoll,select,iocpç­‰ç­‰ã€‚</p>

<p>ä½†æ˜¯å¯¹äºå¼‚æ­¥é€šä¿¡IOæˆ‘ä»¬é‡‡å–äº‹ä»¶å›è°ƒæœºåˆ¶ï¼Œä¹Ÿå°±æ˜¯è¯´æå‰ç»‘å®šå¥½è¯»äº‹ä»¶ï¼Œå†™äº‹ä»¶ç­‰ï¼Œ</p>

<p>åœ¨å¾ªç¯ä¸­è°ƒç”¨base_dispatchå‡½æ•°æŒ‡é’ˆï¼Œå°±å¯ä»¥å®ç°å¯¹äºä¸åŒæ¨¡å‹çš„æ´¾å‘ã€‚</p>

<p>ä¸Šé¢å°±æ˜¯libiopæ¨¡å‹çš„åŸºæœ¬ç»“æ„å’Œæ¡†æ¶</p>

<p>æˆ‘ä»¬çœ‹ä¸‹epollæ¨¡å‹çš„å°è£…</p>

<p>tag_epoll_data æ˜¯å°è£…çš„epollåŸºæœ¬ç»“æ„ï¼Œ</p>

<p>è¿™ä¸ªç»“æ„å­˜åœ¨iop_base_tçš„model_dataé‡Œ</p>

<p>struct tag_epoll_data {
    struct epoll_event *events; //ç›‘å¬çš„epoll_events é˜Ÿåˆ—
    int nevents; //epoll_events äº‹ä»¶å¤§å°
    int epfd; //epoll_create äº§ç”Ÿçš„epollè¡¨å¥æŸ„
};
ä¸¤ä¸ªå‡½æ•°ï¼Œiop_tåº”ç”¨å±‚çš„è¯»å†™å®</p>

<p>EV_TYPE_READå’Œ
EV_TYPE_WRITE
epollçš„è¯»å†™å®
EPOLLINå’ŒEPOLLOUTäº’ç›¸è½¬æ¢
static uint32_t to_epoll_events(uint32_t what)
{
    uint32_t events=0;
    if(what &amp; EV_TYPE_READ)  <br />
    {
        events = EPOLLIN;
    }
    if(what &amp; EV_TYPE_WRITE)  <br />
    {
        events |= EPOLLOUT;
    }
    return events;
}</p>

<p>static uint32_t from_epoll_events(uint32_t events)
{
    uint32_t what=0;
    if(events &amp; (EPOLLHUP|EPOLLERR))
    {
        what = EV_TYPE_READ | EV_TYPE_WRITE;
    }
    else
    {
        if(events &amp; EPOLLIN){what |= EV_TYPE_READ;}
        if(events &amp; EPOLLOUT){what |= EV_TYPE_WRITE;}
    }
    return what;          <br />
}</p>

<p>åˆå§‹åŒ–epollç»“æ„å’Œæ•°æ®</p>

<p>int iop_init_epoll(void *iop_base, int maxev)
{
    iop_base_t *base = (iop_base_t *)iop_base;
    //iop_base  äº‹ ä»¶ æ“ä½œç»“æ„ä½“</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//iop_base_tä¸­op_impå–å‡ºæ¨¡å‹æŠ½è±¡çš„ç»“æ„ä½“
iop_op_t *iop_op = &amp;(base-&gt;op_imp);
//å¼€è¾Ÿepoll_dataç©ºé—´
iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(malloc(sizeof(iop_epoll_data_t)));
if(!iop_data)
{
    return -1;
}
//ç›‘å¬çš„é˜Ÿåˆ—å¤§å°ä¸ºmaxev
iop_data-&gt;nevents = maxev;
//ä¸ºepll_dataé‡Œç›‘å¬äº‹ä»¶é˜Ÿåˆ—å¼€è¾Ÿè¿ç»­ç©ºé—´
iop_data-&gt;events = (struct epoll_event *)(malloc(sizeof(struct epoll_event) * maxev));
if(!iop_data)
{
    free(iop_data);
    return -1;
}

//æ¨¡å‹å†…éƒ¨å®ç°ï¼Œä¸åŒæ¨¡å‹ä¸åŒçš„å‡½æ•°æŒ‡é’ˆå’Œåå­—
iop_op-&gt;name = "epoll";
iop_op-&gt;base_free = epoll_free;
iop_op-&gt;base_dispatch = epoll_dispatch;
iop_op-&gt;base_add = epoll_add;
iop_op-&gt;base_del = epoll_del;
iop_op-&gt;base_mod = epoll_mod;

//1024 is not the max events limit.
//åˆ›å»ºepollè¡¨å¥æŸ„
int epfd = epoll_create(1024);
if(epfd &lt; 0)
{
    free(iop_data-&gt;events);
    free(iop_data);
    free(iop_op);
    return -1;
}
iop_data-&gt;epfd = epfd;


//iop_epoll_data_tç±»å‹çš„æ•°æ®å­˜åœ¨baseçš„model_dataé‡Œ
//æ–¹ä¾¿å›è°ƒ
base-&gt;model_data = iop_data;

return 0; }
</code></pre></div></div>

<p>å¯¹åº”çš„é‡Šæ”¾epollå¼€è¾Ÿçš„ç©ºé—´å’Œæ•°æ®</p>

<p>//epoll é‡Šæ”¾
static void epoll_free(iop_base_t *base)
{
    //model_dataé‡Œå­˜æ”¾äº†epollæ•°æ®çš„æŒ‡é’ˆ
    iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(base-&gt;model_data);
    if(!iop_data){return;}
    //é‡Šæ”¾eventsé˜Ÿåˆ—
    if(iop_data-&gt;events)
    {
        free(iop_data-&gt;events);
    }
    //å…³é—­iop_data-&gt;epfd
    if(iop_data-&gt;epfd &gt;= 0)
    {
        close(iop_data-&gt;epfd);
    }
    free(iop_data);
    base-&gt;model_data = (void *)0;
}</p>

<p>epoll æ·»åŠ äº‹ä»¶</p>

<p>//epollæ·»åŠ äº‹ä»¶
//base ä¸ºiop_baseå›ä¼ æŒ‡é’ˆ
//idä¸ºiopçš„id
//io_handle_t ä¸ºsocket
//events ä¸ºäº‹ä»¶ç±»å‹ï¼ˆEV_TYPE_READæˆ–è€…EV_TYPE_WRITEï¼‰
static int epoll_add(iop_base_t *base, int id, io_handle_t handle, unsigned int events)
{
    iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(base-&gt;model_data);
    struct epoll_event ev;
    ev.data.u32 = id; 
    //è½¬æ¢ä¸ºEPOLLINæˆ–è€…EPOLLOUT
    ev.events = to_epoll_events(events);
    //iop_set_nonblock(handle);
    return epoll_ctl(iop_data-&gt;epfd, EPOLL_CTL_ADD, (int)handle, &amp;ev);              <br />
}</p>

<p>epollåˆ é™¤äº‹ä»¶</p>

<p>//epollåˆ é™¤äº‹ä»¶
//base ä¸ºiop_baseå›ä¼ æŒ‡é’ˆ
//idä¸ºiopçš„id
//io_handle_t ä¸ºsocket
static int epoll_del(iop_base_t *base, int id,io_handle_t handle)
{
    iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(base-&gt;model_data);
    struct epoll_event ev;
    ev.data.u32 = id;<br />
    ev.events = 0;
    //evå›ä¼ è¿›å»ï¼Œåˆ é™¤epoll_eventsä¸­socketä¸ºhandleçš„æ³¨å†Œäº‹ä»¶
    return epoll_ctl(iop_data-&gt;epfd, EPOLL_CTL_DEL, (int)handle, &amp;ev);              <br />
}</p>

<p>epolläº‹ä»¶æ›´æ”¹</p>

<p>//epoll æ¨¡å¼æ›´æ”¹(è¯»å†™æ›´æ”¹)
static int epoll_mod(iop_base_t *base, int id, io_handle_t handle, unsigned int events)
{
    iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(base-&gt;model_data);
    struct epoll_event ev;
    ev.data.u32 = id;<br />
    ev.events = to_epoll_events(events);
    return epoll_ctl(iop_data-&gt;epfd, EPOLL_CTL_MOD, (int)handle, &amp;ev);              <br />
}</p>

<p>epolläº‹ä»¶æ´¾å‘</p>

<p>//epoll äº‹ä»¶æ´¾å‘
static int epoll_dispatch(iop_base_t * base, int timeout)
{
    int i;
    int id = 0;
    iop_t *iop = NULL;
    //iop_baseä¸­å–å‡ºæ¨¡å‹æ•°æ®
    iop_epoll_data_t *iop_data = (iop_epoll_data_t *)(base-&gt;model_data);
    int n = 0;
    do{
        n = epoll_wait(iop_data-&gt;epfd, iop_data-&gt;events, iop_data-&gt;nevents, timeout);  <br />
    }while((n &lt; 0) &amp;&amp; (errno == EINTR));
    base-&gt;cur_time = time(NULL);
    for(i = 0; i &lt; n; i++)
    {
        //å–å‡ºiopçš„id
        id = (int)((iop_data-&gt;events)[i].data.u32);
        if(id &gt;= 0 &amp;&amp; id &lt; base-&gt;maxio)
        {
            iop = (base-&gt;iops)+id;
            //è¿™ä¸ªå®æ˜¯è°ƒç”¨ç»‘å®šåœ¨iopçš„äº‹ä»¶å›è°ƒå‡½æ•°ï¼ˆaccept,read,writeç­‰ï¼‰
            IOP_CB(base,iop,from_epoll_events(iop_data-&gt;events[i].events));
        }
    }
    return n;
}
ä»¥ä¸Šå°±æ˜¯libiopäº‹ä»¶é©±åŠ¨çš„æ ¸å¿ƒç»“æ„å’Œè®¾è®¡ï¼Œåšä¸ªç®€å•çš„æ€»ç»“ï¼Œå¦‚æœæˆ‘ä»¬è¦è®¾è®¡ä¸€ä¸ªå¤šè·¯å¤ç”¨çš„äº‹ä»¶é©±åŠ¨</p>

<p>åŸºæœ¬ç»“æ„æ˜¯è¿™æ ·çš„</p>

<p>//eventEleæ˜¯åº”ç”¨å±‚ç®¡ç†çš„æœ€å°å•å…ƒ</p>

<p>int (<em>WRAFuc  )(eventLoop</em> eventLoopP, int id, int mask, â€¦);</p>

<p>//maskä¸ºåº”ç”¨å±‚è‡ªå·±å®šä¹‰çš„è¯»å†™æ ‡è®°</p>

<p>struct eventEle</p>

<p>{</p>

<p>int socket; //å…³è”çš„socket</p>

<p>WRAFuc  mPfunc;  //è¯»å†™æ¥å—ç­‰åŠŸèƒ½å›è°ƒçš„å‡½æ•°</p>

<p>//è¯»å†™ç¼“å†²åŒºå¯è‡ªå·±å°è£…</p>

<p>char  readBuf[];   //è¯»ç¼“å†²åŒº</p>

<p>char writeBuff[];  //å†™ç¼“å†²åŒº</p>

<p>};</p>

<p>//äº‹ä»¶è½®è¯¢çš„åŸºæœ¬ç»“æ„</p>

<p>struct eventLoop</p>

<p>{</p>

<p>eventEle * eventList;</p>

<p>int maxfd;</p>

<p>int lastActiveTime;</p>

<p>iop_op_t op_imp;    /<em>äº‹ä»¶æ¨¡å‹çš„å†…éƒ¨å®ç°</em>/</p>

<p>void * model_data;  /<em>void æŒ‡é’ˆæŒ‡å‘å¼€è¾Ÿçš„ä¸åŒæ¨¡å‹çš„æ•°æ®</em>/</p>

<p>};</p>

<p>ä¸åŒæ¨¡å‹çš„æ“ä½œè¿›è¡Œå°è£…æˆä¸€ä¸ªç»“æ„ä½“ï¼Œ</p>

<p>ç»“æ„ä½“é‡Œé¢æœ‰æ·»åŠ ï¼Œåˆ é™¤ï¼Œæ›´æ”¹ï¼Œæ´¾å‘ï¼Œé‡Šæ”¾çš„å‡½æ•°æŒ‡é’ˆ</p>

<p>struct tag_iop_op_t
{
const char <em>name; //æ¨¡å‹åç§°
void (</em>base_free)(iop_base_t <em>); //èµ„æºé‡Šæ”¾çš„æ¥å£
int (</em>base_dispatch)(iop_base_t <em>, int); //æ¨¡å‹è°ƒåº¦æ¥å£
//æ·»åŠ äº‹ä»¶
int (</em>base_add)(iop_base_t <em>, int, io_handle_t, unsigned int);
//åˆ é™¤äº‹ä»¶
int (</em>base_del)(iop_base_t <em>, int,io_handle_t);
//ä¿®æ”¹äº‹ä»¶
int (</em>base_mod)(iop_base_t *, int, io_handle_t, unsigned int);
};
è¿™å°±æ˜¯è®¾è®¡ä¸€ä¸ªåŸºæœ¬çš„äº‹ä»¶é©±åŠ¨ç½‘ç»œåº“çš„åŸºæœ¬æ€è·¯ï¼Œ</p>
:ET