I"Ò	<p>type Hijacker interface {
	Hijack() (net.Conn, *bufio.ReadWriter, error)
}
//è¿”å›è¿æ¥æ¥å£net.Connå’ŒReadWriter,bufioè¯»å†™çš„
// Hijack lets the caller take over the connection. â€”â€“ç¿»è¯‘Hijackè®©è°ƒç”¨è€…ç®¡ç†è¿æ¥</p>

<p>// After a call to Hijack(), the HTTP server library</p>

<p>// will not do anything else with the connection.</p>

<p>// It becomes the callerâ€™s responsibility to manage</p>

<p>// and close the connection.</p>

<p>â€”â€”â€”â€”ç¿»è¯‘è°ƒç”¨Hijackåï¼ŒHTTPçš„serverä¸ä¼šå¯¹è¿æ¥åšå¤šä½™çš„å¤„ç†è®©ç”¨æˆ·è‡ªå·±ç®¡ç†å’Œå…³é—­è¿æ¥
<!-- more -->
å†çœ‹ä¸€ä¸‹dockerä¸­å¯¹hijackçš„ä½¿ç”¨
         dial, err := cli.dial()  //è®¾ç½®TCP keepAliveåšé•¿è¿æ¥
	// When we set up a TCP connection for hijack, there could be long periods
	// of inactivity (a long running command with no output) that in certain
	// network setups may cause ECONNTIMEOUT, leaving the client in an unknown
	// state. Setting TCP KeepAlive on the socket connection will prohibit
	// ECONNTIMEOUT unless the socket connection truly is broken
	if tcpConn, ok := dial.(*net.TCPConn); ok {
		tcpConn.SetKeepAlive(true)
		tcpConn.SetKeepAlivePeriod(30 * time.Second)
	}
	if err != nil {
		if strings.Contains(err.Error(), â€œconnection refusedâ€) {
return fmt.Errorf(â€œCannot connect to the Docker daemon. Is â€˜docker daemonâ€™ running on this host?â€)
		}
		return err
	}
	clientconn := httputil.NewClientConn(dial, nil) 
	defer clientconn.Close()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Server hijacks the connection, error 'connection closed' expected
clientconn.Do(req)

rwc, br := clientconn.Hijack() 
//æ¸…ç†æ‰buffer è¿™æ­¥éå¸¸é‡è¦,è¿”å›è¿™ä¸ªä¸¤ä¸ªå‚æ•°å°±æ˜¯ç»™ç”¨æˆ·è‡ªå·±ç®¡ç†è¿æ¥å’Œæ•°æ®å¤„ç†
defer rwc.Close()
</code></pre></div></div>

<p>å†çœ‹çœ‹clientconn.Hijackçš„å®ç°ï¼š</p>

<p>func (cc <em>ClientConn) Hijack() (c net.Conn, r *bufio.Reader) {
	cc.lk.Lock()
	defer cc.lk.Unlock()
	c = cc.c
	r = cc.r
	cc.c = nil
	cc.r = nil
	return
}
//å°±æ˜¯åœ¨NewClientConnæ—¶å€™ä¿å­˜çš„net.Connå’Œbufio.Reader
func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn {
	if r == nil {
		r = bufio.NewReader(c)
	}
	return &amp;ClientConn{
		c:        c,
		r:        r,
		pipereq:  make(map[</em>http.Request]uint),
		writeReq: (*http.Request).Write,
	}
}
æ€»ç»“ï¼šhijackå°±æ˜¯ä¸ç”¨é‡æ–°å»ºç«‹è¿æ¥æˆ–è€…é‡æ–°æ„é€ ClientConnè®¾ç½®net.Connå’Œbufioï¼Œç„¶åä¸æ–­å¤ç”¨net.Connå’Œbufioï¼Œè‡ªå·±ç®¡ç†</p>
:ET