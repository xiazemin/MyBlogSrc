I"­z<p>package sync_code</p>

<p>import (
	â€œfmtâ€
	â€œsync/atomicâ€
)</p>

<p>// Mutex æ˜¯ä¸€ä¸ªäº’æ–¥é”
// mutex çš„é›¶å€¼æ˜¯æœªä¸Šé”çŠ¶æ€
//
// ä¸€ä¸ª Mutex åˆ›å»ºå ä¸èƒ½è¢«æ‹·è´
type Mutex struct {
	state int32 // |ç¬¬32ä½|ç¬¬31ä½|â€¦â€¦|ç¬¬3ä½ è¡¨ç¤ºæ˜¯å¦é¥¥é¥¿| ç¬¬2ä½ è¡¨ç¤ºé”æ˜¯å¦å¤„äºå”¤é†’|ç¬¬1ä½ è¡¨ç¤ºæ˜¯å¦ä¸ºé”å®šçŠ¶æ€| åé¢3ä½æ˜¯ç‰¹æ®Šçš„ï¼Œå‰é¢çš„32ä½å‡3ä½è¡¨ç¤ºç­‰å¾…é˜Ÿåˆ—çš„å¤§å°
	sema  uint32
}</p>

<p>const (
	mutexLocked = 1 Â«Â iota // mutex is locked é”å®šçŠ¶æ€  001
	mutexWoken  // å”¤é†’çŠ¶æ€ ç»§æ‰¿è¡¨è¾¾å¼1 Â«Â iota 010
	mutexStarving // é¥¥é¥¿çŠ¶æ€ 1 Â«Â iota 100
	mutexWaiterShift = iota // ç§»ä½ä»¥å¾—åˆ°ç­‰å¾…é˜Ÿåˆ—å¤§å°</p>

<p>// äº’æ–¥ä½“å¯ä»¥å¤„äºä¸¤ç§æ“ä½œæ¨¡å¼ï¼šæ­£å¸¸å’Œé¥¥é¥¿ã€‚
// åœ¨æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œç­‰å¾…è€…æŒ‰ç…§FIFOé¡ºåºæ’é˜Ÿï¼Œä½†æ˜¯ä¸€ä¸ªé†’æ¥çš„ç­‰å¾…è€…ä¸æ‹¥æœ‰äº’æ–¥é”å¹¶ä¸æ‰€æœ‰æƒä¸Šçš„æ–°åˆ°è¾¾çš„goroutineç«äº‰ã€‚
// æ–°åˆ°çš„goroutinesæœ‰ä¸€ä¸ªä¼˜åŠ¿ - å®ƒä»¬å·²ç»åœ¨CPUä¸Šè¿è¡Œï¼Œå¹¶ä¸”å¯èƒ½æœ‰å¾ˆå¤šï¼Œæ‰€ä»¥ä¸€ä¸ªé†’æ¥çš„ç­‰å¾…è€…æœ‰å¾ˆå¤§çš„å¤±è´¥æœºä¼šã€‚
// åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒåœ¨ç­‰å¾…é˜Ÿåˆ—çš„å‰é¢æ’é˜Ÿã€‚
// å¦‚æœç­‰å¾…è€…æ— æ³•è·å–äº’æ–¥é”è¶…è¿‡1æ¯«ç§’ï¼Œå®ƒä¼šå°†äº’æ–¥é”åˆ‡æ¢åˆ°é¥¥é¥¿æ¨¡å¼ã€‚
// åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œäº’æ–¥é”çš„æ‰€æœ‰æƒç›´æ¥ä»è§£é”goroutineä¼ é€’åˆ°é˜Ÿåˆ—å‰é¢çš„ç­‰å¾…è€…ã€‚
// æ–°åˆ°çš„goroutineså³ä½¿å®ƒä¼¼ä¹è¢«è§£é”ä¹Ÿä¸ä¼šå°è¯•è·å–äº’æ–¥é”ï¼Œå¹¶ä¸”ä¸ä¼šå°è¯•æ—‹è½¬ã€‚
// ç›¸åï¼Œä»–ä»¬å°†è‡ªå·±æ’é˜Ÿç­‰å¾…é˜Ÿåˆ—çš„å°¾éƒ¨ã€‚
// å¦‚æœç­‰å¾…è€…æ”¶åˆ°äº’æ–¥é”çš„æ‰€æœ‰æƒï¼Œå¹¶ä¸”çœ‹åˆ°
// ï¼ˆ1ï¼‰å®ƒæ˜¯é˜Ÿåˆ—ä¸­çš„æœ€åä¸€ä¸ªç­‰å¾…è€…ï¼Œæˆ–è€…ï¼ˆ2ï¼‰å®ƒç­‰å¾…çš„æ—¶é—´å°‘äº1æ¯«ç§’ï¼Œå®ƒä¼šå°†äº’æ–¥é”åˆ‡æ¢å›æ­£å¸¸æ“ä½œæ¨¡å¼ã€‚
// æ­£å¸¸æ¨¡å¼å…·æœ‰ç›¸å½“å¥½çš„æ€§èƒ½ï¼Œå› ä¸ºå³ä½¿å­˜åœ¨é˜»å¡çš„ç­‰å¾…è€…ï¼Œgoroutineä¹Ÿå¯ä»¥è¿ç»­å¤šæ¬¡è·å–äº’æ–¥é”ã€‚
// é¥¥é¥¿æ¨¡å¼å¯¹äºé˜²æ­¢å°¾éƒ¨æ½œä¼çš„æƒ…å†µå¾ˆé‡è¦ã€‚
	starvationThresholdNs = 1e6
)</p>

<p>func init() {
	fmt.Printf(â€œmutexLocked      %03b\nâ€,mutexLocked)
	fmt.Printf(â€œmutexWoken       %03b\nâ€,mutexWoken)
	fmt.Printf(â€œmutexStarving    %03b\nâ€,mutexStarving)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("mutexWaiterShift %d\n",mutexWaiterShift)


fmt.Printf("answer1      %03b\n",mutexLocked|mutexStarving)
fmt.Printf("answer2      %032b\n",1&lt;&lt;mutexWaiterShift)
fmt.Printf("answer2      %032b\n",int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)) }
</code></pre></div></div>

<p>// Lock locks m.
// å¦‚æœé”å·²è¢«ä½¿ç”¨ï¼Œåˆ™è°ƒç”¨çš„goroutine å°†é˜»å¡ï¼Œç›´åˆ°äº’æ–¥é”å¯ç”¨ã€‚
func (m *Mutex) Lock() {
	// å¿«é€Ÿè·¯å¾„ï¼šæŠ“å–è§£é”çš„Mutexã€‚
	// æ­¤æ—¶è¯´æ˜é”ä¸ºç©ºé—²çŠ¶æ€
	if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
		return
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var waitStartTime int64 // å¼€å§‹ç­‰å¾…çš„æ—¶é—´
starving := false // åç¨‹è‡ªå·±æ˜¯å¦ä¸ºé¥¥é¥¿
awoke := false // æ˜¯å¦è¢«å”¤é†’
iter := 0 // è¿­ä»£æ¬¡æ•°
old := m.state
for {
	// ä¸è¦åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹è‡ªæ—‹ï¼Œæ‰€æœ‰æƒäº¤ç»™ç­‰å¾…è€…ã€‚
	// æ‰€ä»¥æ— è®ºå¦‚ä½•æˆ‘ä»¬éƒ½æ— æ³•è·å¾—äº’æ–¥é”ã€‚
	// old çš„çŠ¶æ€ æ˜¯ é”å®š ä¸” ä¸ä¸ºé¥¥é¥¿
	// åŒæ—¶ å½“å‰æ¡ä»¶å…·å¤‡è‡ªæ—‹æ¡ä»¶ã€‚ 001 | 010 old&amp;011 001
	if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
		// ä¸»åŠ¨æ—‹è½¬å¾ˆæœ‰æ„ä¹‰ã€‚
		// å°è¯•è®¾ç½®mutexWokenæ ‡å¿—ã€‚
		// ä»¥é˜²æ­¢Unlockæ—¶å”¤é†’å…¶ä»–é˜»å¡çš„goroutineã€‚
		// å½“å‰åç¨‹å¤„äºæœªé†’çŠ¶æ€ ä¸” mutexä¹Ÿå¤„äºæœªå”¤é†’çŠ¶æ€ ä¸”ç­‰å¾…é˜Ÿåˆ—æœ‰ç­‰å¾…åç¨‹
		// å°è¯•å°†è‡ªå·±å˜æˆé‚£ä¸ªå”¤é†’ç€çš„åç¨‹

		// å°è¯•å°†mutexçš„çŠ¶æ€è®¾ä¸ºå”¤é†’ è‹¥æˆç«‹ åˆ™å°†å½“å‰åç¨‹è®¾ç½®ä¸ºå”¤é†’çŠ¶æ€(awokeå˜é‡)

		// old&gt;&gt;mutexWaiterShift  å–å½“å‰ç­‰å¾…æ•°é‡
		if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
			atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
			awoke = true
		}
		// è°ƒç”¨ä¸€å®šæ•°é‡çš„pauseæŒ‡ä»¤ cpuä¸ä¼šæ‰§è¡Œä»»ä½•æ“ä½œ ä½†æ˜¯æ¶ˆè€—cpuæ—¶é—´
		runtime_doSpin()
		iter++
		old = m.state
		continue
	}

	// ä»¥ä¸‹ä»£ç  è¯•å›¾ä¿®æ”¹é”çŠ¶æ€
	//é”å®šä¸”é¥¥é¥¿ï¼›ä¸é”å®šä¸”é¥¥é¥¿ï¼›ä¸é”å®šä¸”ä¸é¥¥é¥¿


	new := old

	// ä¸è¦è¯•å›¾è·å¾—é¥¥é¥¿çš„äº’æ–¥é‡ï¼Œæ–°åˆ°çš„goroutineså¿…é¡»æ’é˜Ÿ


	if old&amp;mutexStarving == 0 {
		// éé¥¥é¥¿åˆ™ new è®¾ä¸ºé”å®šçŠ¶æ€
		new |= mutexLocked
	}
	// è‹¥æ—§çŠ¶æ€å¤„äºé”å®šæˆ–è€…é¥¥é¥¿
	if old&amp;(mutexLocked|mutexStarving) != 0 {
		new += 1 &lt;&lt; mutexWaiterShift  // æ–°çŠ¶æ€æ’é˜Ÿæ•°é‡åŠ ä¸€
	}
	// å½“å‰çš„goroutineå°†äº’æ–¥é”åˆ‡æ¢åˆ°é¥¥é¥¿æ¨¡å¼ã€‚
	// ä½†æ˜¯å¦‚æœäº’æ–¥é”å½“å‰å·²è§£é”ï¼Œè¯·ä¸è¦è¿›è¡Œåˆ‡æ¢ã€‚
	// Unlockæ—¶æœŸæœ›é¥¥é¥¿çŠ¶æ€çš„mutex æ˜¯æœ‰ç­‰å¾…è€…çš„ï¼Œåœ¨æ­¤æƒ…å†µä¸‹ä¸ä¼šè¿™æ ·ã€‚

	// oldå¤„äºé”å®šçŠ¶æ€
	if starving &amp;&amp; old&amp;mutexLocked != 0 {
		new |= mutexStarving
	}
	if awoke {
		new &amp;^= mutexWoken // æ–°çŠ¶æ€è®¾ç½®ä¸ºéå”¤é†’çŠ¶æ€
	}
	// å°è¯•è®¾ç½®æˆä¸ºæ–°çŠ¶æ€
	if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
		// éé”éé¥¥é¥¿
		if old&amp;(mutexLocked|mutexStarving) == 0 {
			break // locked the mutex with CAS
		}
		//  å¦‚æœå¼€å§‹ç­‰å¾…æ—¶é—´ä¸ä¸º0  åˆ™è¡¨ç¤º å·²ç»åœ¨ç­‰å¾…é˜Ÿåˆ—ä¸­
		queueLifo := waitStartTime != 0
		if waitStartTime == 0 {
			waitStartTime = runtime_nanotime()
		}
		// è·å–ä¿¡å·é‡ æœ‰å¯èƒ½é™·å…¥é˜»å¡ç­‰å¾…
		runtime_SemacquireMutex(&amp;m.sema, queueLifo)
		// é†’æ¥åˆ¤æ–­å½“å‰åç¨‹æ˜¯å¦ä¸ºé¥¥é¥¿
		starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
		old = m.state
		// å½“å‰é”çŠ¶æ€ä¸ºé¥¥é¥¿ è¯´æ˜ å½“å‰åç¨‹å·²ç»æ‹¥æœ‰äº†è·å–é”çš„èµ„æ ¼
		if old&amp;mutexStarving != 0 {
			// ç­‰å¾…é˜Ÿåˆ—æ•°é‡å‡1 åŒæ—¶ è®¾ä¸ºé”å®šçŠ¶æ€
			delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)
			// è‹¥ å½“å‰åç¨‹æœ¬èº« ä¸å¤„äºé¥¥é¥¿çŠ¶æ€ æˆ– ç­‰å¾…é˜Ÿåˆ—ä¸­æ²¡åˆ«äºº åˆ™å°†é”ç½®ä¸ºéé¥¥é¥¿çŠ¶æ€
			if !starving || old&gt;&gt;mutexWaiterShift == 1 {
				// Exit starvation mode.
				// Critical to do it here and consider wait time.
				// Starvation mode is so inefficient, that two goroutines
				// can go lock-step infinitely once they switch mutex
				// to starvation mode.
				delta -= mutexStarving
			}
			atomic.AddInt32(&amp;m.state, delta)
			break
		}
		// ç»§ç»­è‡ªæ—‹
		awoke = true
		iter = 0
	} else {
		old = m.state
	}
} }
</code></pre></div></div>

<p>// Unlock unlocks m.
func (m *Mutex) Unlock() {
	// Fast path: drop lock bit.
	new := atomic.AddInt32(&amp;m.state, -mutexLocked)
	if (new+mutexLocked)&amp;mutexLocked == 0 {
		throw(â€œsync: unlock of unlocked mutexâ€)
	}
	if new&amp;mutexStarving == 0 {
		old := new
		for {
			// å¦‚æœæ²¡æœ‰ç­‰å¾…è€…æˆ–è€…goroutineå·²ç»è¢«å”¤é†’æˆ–æŠ“ä½é”ï¼Œä¸éœ€è¦å«é†’ä»»ä½•äººã€‚
			// åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰æƒç›´æ¥ä»è§£é”goroutineä¼ é€’ç»™ä¸‹ä¸€ä¸ªç­‰å¾…è€…ã€‚
			// æˆ‘ä»¬ä¸æ˜¯è¿™ä¸ªé“¾æ¡çš„ä¸€éƒ¨åˆ†ï¼Œå› ä¸ºå½“æˆ‘ä»¬è§£é”ä¸Šé¢çš„äº’æ–¥é”æ—¶ï¼Œæˆ‘ä»¬æ²¡æœ‰è§‚å¯Ÿåˆ°mutexStarvingã€‚ æ‰€ä»¥ä¸‹è½¦å§ã€‚
			if oldÂ»mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
				return
			}
			// æŠ“ä½æƒåˆ©å”¤é†’æŸäººã€‚
			new = (old - 1Â«mutexWaiterShift) | mutexWoken
			if atomic.CompareAndSwapInt32(&amp;m.state, old, new) { //è®¾ç½®æˆå”¤é†’
				runtime_Semrelease(&amp;m.sema, false)//é‡Šæ”¾ä¸€ä¸ªä¿¡å·é‡
				return
			}
			old = m.state
		}
	} else {
		// é¥¥é¥¿æ¨¡å¼ï¼šå°†äº’æ–¥é”æƒé™ç§»äº¤ç»™ä¸‹ä¸€ä¸ªæœåŠ¡å‘˜ã€‚
		// æ³¨æ„ï¼šæœªè®¾ç½®mutexLockedï¼ŒæœåŠ¡å‘˜å°†åœ¨å”¤é†’åè®¾ç½®å®ƒã€‚
		// ä½†æ˜¯å¦‚æœè®¾ç½®äº†mutexStarvingï¼Œä»ç„¶è®¤ä¸ºäº’æ–¥é”æ˜¯é”å®šçš„ï¼Œ
		// æ‰€ä»¥æ–°æ¥çš„goroutinesä¸ä¼šè·å¾—å®ƒã€‚
		runtime_Semrelease(&amp;m.sema, true) //é‡Šæ”¾ä¸€ä¸ªä¿¡å·ï¼Œåˆ«äººå¯ä»¥ç”¨äº†
	}
}
<!-- more -->
golang çš„åŠ é”ä¼šè‡ªæ—‹ï¼Œ4æ¬¡è‡ªæ—‹æ²¡æ‹¿åˆ°é”åå†å°†åç¨‹ä¼‘çœ ï¼Œè¿™æ ·å¯ä»¥å‡å°‘åˆ‡æ¢æˆæœ¬ã€‚è¿™é‡Œå…³åˆ¤æ–­æ¡ä»¶æ˜¯è‡ªæ—‹æ¬¡æ•°ï¼Œcpuæ ¸æ•°ï¼Œp çš„æ•°é‡ï¼š
func sync_runtime_canSpin(i int) bool {
	if i &gt;= active_spin || ncpu &lt;= 1 || gomaxprocs &lt;= int32(sched.npidle+sched.nmspinning)+1 {
		return false
	}
	if p := getg().m.p.ptr(); !runqempty(p) {
		return false
	}
	return true
}
Â  Â  æœ€åæ˜¯åˆ©ç”¨ä¿¡å·é‡æŒ‚èµ·å’Œå”¤é†’åç¨‹ï¼Œæ ¸å¿ƒå‡½æ•°æ˜¯</p>

<p>runtime_SemacquireMutex(&amp;m.sema)
runtime_Semrelease(&amp;m.sema)
Â  Â  è·å–ä¿¡å·æ—¶ï¼Œå½“s &gt; 0 ,å°†sâ€“,å¦‚æœs ä¸ºè´Ÿæ•°ï¼Œä¼šå°†å½“å‰g æ”¾å…¥é˜»å¡é˜Ÿåˆ—ï¼ŒæŒ‚èµ·ç›´åˆ°s&gt;0ã€‚</p>

<p>æœ€æœ´ç´ çš„å®ç°äº’æ–¥é”ï¼Œæ‹¿åˆ°é”è¿”å›ï¼Œæ‹¿ä¸åˆ°å°±å°†å½“å‰ goroutine ä¼‘çœ 
å¢åŠ äº†è‡ªæ—‹ spinlock çš„é€»è¾‘ï¼Œä¹Ÿå°±æ˜¯è¯´å¤§éƒ¨ä»½ Mutex é”ä½æ—¶é—´å¦‚æœå¾ˆçŸ­ï¼Œé‚£ä¹ˆè‡ªæ—‹å¯ä»¥å‡å°æ— è°“çš„ runtime è°ƒåº¦ã€‚æ¨èçœ‹å®˜æ–¹ spin commit
è¿›åŒ–æˆäº†å…¬å¹³é”ï¼Œè€ç‰ˆæœ¬ä¸­å½“å‰æŠ¢é”ä¸­çš„ goroutine å¤§æ¦‚ç‡æ¯”ä¼‘çœ çš„ä¼˜å…ˆæ‹¿åˆ°é”ï¼Œä¼šäº§ç”Ÿ latency é•¿å°¾ã€‚æ–°ç‰ˆæœ¬ä¸­è¶…è¿‡ä¸€å®šæ—¶é—´æ²¡æ‹¿åˆ°é”ï¼Œè¿™ä¸ªä¼˜å…ˆçº§ä¼šåè½¬ï¼Œå°½å¯èƒ½å‡å°é•¿å°¾ã€‚æ¨èå¤§å®¶çœ‹ #issue 13086ï¼Œè¿™é‡Œé¢åæ˜ äº†é—®é¢˜ï¼Œå¦å¤–çœ‹ commit, é‡Œé¢æœ‰å¾ˆè¯¦ç»†çš„æµ‹è¯•æ•°æ®ï¼Œå€¼å¾—å­¦ä¹ </p>

<p>é‚£ä¹ˆå…·ä½“æ€ä¹ˆå®ç°å‘¢ï¼Ÿåˆ†åˆ«ä»¥ 1.3, 1.7, 1.12 ä¸‰ä¸ªç‰ˆæœ¬æºç ä¸ºä¾‹
Mutex ç»“æ„ä½“åŠå¸¸ç”¨å˜é‡
type Mutex struct {
    state int32
    sema  uint32
}
// 1.3 ä¸ 1.7 è€çš„å®ç°å…±ç”¨çš„å¸¸é‡
const (
    mutexLocked = 1 Â«Â iota // mutex is locked
    mutexWoken
    mutexWaiterShift = iota
)
// 1.12 å…¬å¹³é”ä½¿ç”¨çš„å¸¸é‡
const (
    mutexLocked = 1 Â«Â iota // mutex is locked
    mutexWoken
    mutexStarving
    mutexWaiterShift = iota
    starvationThresholdNs = 1e6
)</p>

<p>ä»ä¸­å¯ä»¥çœ‹åˆ°ï¼ŒMutex æœ‰ä¸¤ä¸ªå˜é‡ï¼š</p>

<p>state 4 å­—èŠ‚ int, å…¶ä¸­ä½å‡ ä½ç”¨äºåšæ ‡è®°ï¼Œé«˜ä½åœ°å€ç©ºé—´ç”¨äºè®¡æ•°ï¼Œè¡¨ç¤ºæœ‰å¤šå°‘ä¸ª goroutine æ­£åœ¨ç­‰å¾…è€Œå¤„äºä¼‘çœ ä¸­ã€‚
sema æ˜¯ä¸€ä¸ªäº’æ–¥çš„ä¿¡å·é‡ï¼Œåˆå§‹é»˜è®¤å€¼æ˜¯ 0ï¼Œç”¨äºå°† goroutine park ä¼‘çœ æˆ–æ˜¯å”¤é†’ã€‚sema acquire æ—¶å¦‚æœ sema å¤§äº 0ï¼Œé‚£ä¹ˆå‡ä¸€è¿”å›ï¼Œå¦åˆ™ä¼‘çœ ç­‰å¾…ã€‚sema release å°† sema åŠ ä¸€ï¼Œç„¶åå”¤é†’ç­‰å¾…é˜Ÿåˆ—çš„ç¬¬ä¸€ä¸ª goroutine</p>

<p>é»˜è®¤ç›´æ¥ä½¿ç”¨ sync.Mutex æˆ–æ˜¯åµŒå…¥åˆ°ç»“æ„ä½“ä¸­ï¼Œstate é›¶å€¼ä»£è¡¨æœªä¸Šé”ï¼Œsema é›¶å€¼ä¹Ÿæ˜¯æœ‰æ„ä¹‰çš„ï¼Œå‚è€ƒä¸‹é¢æºç åŠ é”ä¸è§£é”é€»è¾‘ï¼Œç¨æƒ³ä¸‹å°±ä¼šæ˜ç™½çš„ã€‚å¦å¤–å‚è€ƒå¤§èƒ¡å­ dave çš„å…³äºé›¶å€¼çš„æ–‡ç« 
æœ´ç´ äº’æ–¥é”
æœ´ç´ æ˜¯ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿå°±æ˜¯èƒ½ç”¨ï¼Œç²—ç³™â€¦
ä¸Šé”
// Lock locks m.
// If the lock is already in use, the calling goroutine
// blocks until the mutex is available.
func (m *Mutex) Lock() {
    // Fast path: grab unlocked mutex. å¿«é€Ÿä¸Šé”ï¼Œå½“å‰ state ä¸º 0ï¼Œè¯´æ˜æ²¡äººé”ã€‚CAS ä¸Šé”åç›´æ¥è¿”å›
    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
        if raceenabled {
            raceAcquire(unsafe.Pointer(m))
        }
        return
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>awoke := false // è¢«å”¤é†’æ ‡è®°ï¼Œå¦‚æœæ˜¯è¢«åˆ«çš„ goroutine å”¤é†’çš„é‚£ä¹ˆåé¢ä¼šç½® true
for {
    old := m.state // è€çš„ m.state å€¼
    new := old | mutexLocked // æ–°å€¼è¦ç½® mutexLocked ä½ä¸º 1
    if old&amp;mutexLocked != 0 { // å¦‚æœ old mutexLocked ä½ä¸ä¸º 0ï¼Œé‚£è¯´æ˜æœ‰äººå·±ç»é”ä¸Šäº†ï¼Œé‚£ä¹ˆå°† state å˜é‡çš„ waiter è®¡æ•°éƒ¨åˆ† +1
        new = old + 1&lt;&lt;mutexWaiterShift
    }
    if awoke {
        // The goroutine has been woken from sleep,
        // so we need to reset the flag in either case. å¦‚æœèµ°åˆ°è¿™é‡Œ awoke ä¸º true, è¯´æ˜æ˜¯è¢«å”¤é†’çš„ï¼Œé‚£ä¹ˆæ¸…é™¤è¿™ä¸ª mutexWoken ä½ï¼Œç½®ä¸º 0
        new &amp;^= mutexWoken
    }
    // CAS æ›´æ–°ï¼Œå¦‚æœ m.state ä¸ç­‰äº oldï¼Œè¯´æ˜æœ‰äººä¹Ÿåœ¨æŠ¢é”ï¼Œé‚£ä¹ˆ for å¾ªç¯å‘èµ·æ–°çš„ä¸€è½®ç«äº‰ã€‚
    if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
        if old&amp;mutexLocked == 0 { // å¦‚æœ old mutexLocked ä½ä¸º 1ï¼Œè¯´æ˜å½“å‰ CAS æ˜¯ä¸ºäº†æ›´æ–° waiter è®¡æ•°ã€‚å¦‚æœä¸º 0ï¼Œè¯´æ˜æ˜¯æŠ¢é”æˆåŠŸï¼Œé‚£ä¹ˆç›´æ¥ break é€€å‡ºã€‚
            break
        }
        runtime_Semacquire(&amp;m.sema) // æ­¤æ—¶å¦‚æœ sema &lt;= 0 é‚£ä¹ˆé˜»å¡åœ¨è¿™é‡Œç­‰å¾…å”¤é†’ï¼Œä¹Ÿå°±æ˜¯ park ä½ã€‚èµ°åˆ°è¿™é‡Œéƒ½æ˜¯è¦ä¼‘çœ äº†ã€‚
        awoke = true  // æœ‰äººé‡Šæ”¾äº†é”ï¼Œç„¶åå½“å‰ goroutine è¢« runtime å”¤é†’äº†ï¼Œè®¾ç½® awoke true
    }
}

if raceenabled {
    raceAcquire(unsafe.Pointer(m))
} }
</code></pre></div></div>

<p>ä¸Šé”é€»è¾‘å…¶å®ä¹Ÿä¸éš¾ï¼Œè¿™é‡Œé¢æ›´æ”¹è®¡æ•°éƒ½æ˜¯ç”¨ CAS</p>

<p>fast path å¿«é€Ÿä¸Šé”ï¼Œå¦‚æœå½“å‰ state == 0, è‚¯å®šæ˜¯æ²¡äººä¸Šé”ï¼Œä¹Ÿæ²¡äººç­‰å¾…ï¼ŒCAS æ›´æ–°åç›´æ¥é€€å‡ºå¥½äº†
å½“å‰å¦‚æœæœ‰äººé”ä½äº†ï¼Œé‚£ä¹ˆæ›´æ–° m.state å€¼çš„ waiter è®¡æ•°éƒ¨ä»½ï¼Œç„¶å runtime_Semacquire å°†è‡ªå·±ä¼‘çœ ï¼Œç­‰å¾…è¢«å”¤é†’</p>

<p>runtime_Semacquire å‡½æ•°è¿”å›è¯´æ˜é”é‡Šæ”¾äº†ï¼Œæœ‰äººå°†è‡ªå·±å”¤é†’äº†ï¼Œé‚£ä¹ˆè®¾ç½®  awokeï¼Œå¤§å¾ªç¯å‘èµ·æ–°çš„ä¸€è½®ç«äº‰ã€‚
æ–°çš„ç«äº‰åˆ°æœ€åï¼Œcas æ›´æ–°äº† new å€¼ï¼Œæ­¤æ—¶ old å€¼ mutexLocked ä½è‚¯å®šä¸º 0ï¼Œè·å–é”æˆåŠŸï¼Œbreak é€€å‡ºå³å¯ã€‚</p>

<p>è§£é”
// Unlock unlocks m.
// It is a run-time error if m is not locked on entry to Unlock.
//
// A locked Mutex is not associated with a particular goroutine.
// It is allowed for one goroutine to lock a Mutex and then
// arrange for another goroutine to unlock it.
func (m *Mutex) Unlock() {
    if raceenabled {
        _ = m.state
        raceRelease(unsafe.Pointer(m))
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Fast path: drop lock bit. å¿«é€Ÿå°† state çš„ mutexLocked ä½æ¸… 0ï¼Œç„¶å new è¿”å›æ›´æ–°åçš„å€¼ï¼Œæ³¨æ„æ­¤ add å®Œæˆåï¼Œå¾ˆæœ‰å¯èƒ½æ–°çš„ goroutine æŠ¢é”ï¼Œå¹¶ä¸Šé”æˆåŠŸ
new := atomic.AddInt32(&amp;m.state, -mutexLocked)
if (new+mutexLocked)&amp;mutexLocked == 0 { // å¦‚æœé‡Šæ”¾äº†ä¸€ä¸ªå·±ç»é‡Šæ”¾çš„é”ï¼Œç›´æ¥ panic
    panic("sync: unlock of unlocked mutex")
}

old := new
for {// å¦‚æœ state å˜é‡çš„ waiter è®¡æ•°ä¸º 0 è¯´æ˜æ²¡äººç­‰å¾…é”ï¼Œç›´æ¥ return å°±å¥½ï¼ŒåŒæ—¶å¦‚æœ old å€¼çš„ mutexLocked|mutexWoken ä»»ä¸€ç½® 1ï¼Œè¯´æ˜è¦ä¹ˆæœ‰äººå·±ç»æŠ¢ä¸Šäº†é”ï¼Œè¦ä¹ˆè¯´æ˜å·±ç»æœ‰è¢«å”¤é†’çš„ goroutine å»æŠ¢é”äº†ï¼Œæ²¡å¿…è¦å»åšé€šçŸ¥æ“ä½œ
    // If there are no waiters or a goroutine has already
    // been woken or grabbed the lock, no need to wake anyone.
    if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken) != 0 {
        return
    }
    // Grab the right to wake someone. å°† waiter è®¡æ•°ä½å‡ä¸€ï¼Œå¹¶è®¾ç½® awoken ä½
    new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
    if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
        runtime_Semrelease(&amp;m.sema) // cas æˆåŠŸåï¼Œå†åš sema release æ“ä½œï¼Œå”¤é†’ä¼‘çœ çš„ goroutine
        return
    }
    old = m.state
} }
</code></pre></div></div>

<p>è§£é”é€»è¾‘ä¹Ÿä¸éš¾ï¼Œæ³¨æ„ä¸€ä¸ª goroutine å¯ä»¥é‡Šæ”¾åˆ«çš„ goroutine ä¸Šçš„é”</p>

<p>åŸå­æ“ä½œ, m.state - mutexLocked, å¦‚æœä¹‹å (new+mutexLocked)&amp;mutexLocked è¯´æ˜é‡Šæ”¾äº†ä¸€ä¸ªæ²¡ä¸Šé”çš„ Mutexï¼Œç›´æ¥ panic
æ¥ä¸‹æ¥ä¸ºä»€ä¹ˆæ˜¯  for å¾ªç¯å‘¢ï¼ŸåŸå› åœ¨äºï¼Œç¬¬ä¸€æ­¥åŸå­æ“ä½œåï¼Œå¾ˆå¯èƒ½æœ‰ç¬¬ä¸‰æ–¹åˆšå¥½è·å¾—é”äº†ï¼Œé‚£ä¹ˆ for é‡Œé¢çš„ CAS è‚¯å®šä¼šå¤±è´¥
å¿«é€Ÿåˆ¤æ–­ï¼Œå¦‚æœ waiter è®¡æ•°ä¸º 0ï¼Œè¯´æ˜æ²¡æœ‰ä¼‘çœ çš„ goroutineï¼Œä¸ç”¨å”¤é†’ã€‚å¦‚æœ old&amp;(mutexLocked|mutexWoken) != 0 è¯´æ˜è¦ä¹ˆæœ‰äººè·å¾—äº†é”ï¼Œè¦ä¹ˆå·±ç»æœ‰ woken çš„ goroutine äº†ï¼Œä¹Ÿä¸ç”¨å»å”¤é†’ã€‚æ³¨æ„è¿™é‡Œï¼ŒmutexLocked æ˜¯ for å¾ªç¯å†æ¬¡åˆ¤æ–­æ—¶æ‰æœ‰çš„ï¼Œ old å€¼æ˜¯å¾ªç¯åº•éƒ¨é‡æ–°åˆè·å–å¾—
ç„¶å CAS æ›´æ–°æˆ new å€¼ï¼Œè®¾ç½® woken æ ‡è®°ä½ï¼Œå¹¶å°†ç­‰å¾… waiter è®¡æ•°å‡ä¸€ã€‚æœ€å runtime_Semrelease çœŸæ­£çš„å”¤é†’ç­‰å¾… goroutine</p>

<p>æœ´ç´ é”çš„é—®é¢˜
å› è·å– sema ä¼‘çœ çš„ goroutine ä¼šä»¥ä¸€ä¸ª FIFO çš„é“¾è¡¨å½¢å¼ä¿å­˜ï¼Œå¦‚æœå”¤é†’æ—¶å¯ä»¥ä¼˜å…ˆæ‹¿åˆ°é”ã€‚ä½†æ˜¯çœ‹ä»£ç çš„é€»è¾‘ï¼Œå¤„äºä¼‘çœ ä¸­çš„ goroutine ä¼˜å…ˆçº§ä½äºå½“å‰æ´»è·ƒçš„ã€‚Unlock è§£é”çš„é¡ºé—´ï¼Œæœ€æ–°æ´»è·ƒçš„ goroutine æ˜¯ä¼šæŠ¢åˆ°é”çš„ã€‚å¦å¤–æœ‰æ—¶é”æ—¶é—´å¾ˆçŸ­ï¼Œå¦‚æœæ²¡æœ‰è‡ªæ—‹ spin çš„é€»è¾‘ï¼Œæ‰€æœ‰ goroutine éƒ½è¦ä¼‘çœ  park, å¾’å¢ runtime è°ƒåº¦çš„å¼€é”€ã€‚
è‡ªæ—‹ spin çš„ä¼˜åŒ–
åæ¥ä¼˜åŒ–æ—¶å¢åŠ äº† spin é€»è¾‘ï¼Œè‡ªæ—‹åªå­˜åœ¨ Lock é˜¶æ®µï¼Œä»£ç ä»¥ go 1.7 ä¸ºä¾‹
// Lock locks m.
// If the lock is already in use, the calling goroutine
// blocks until the mutex is available.
func (m *Mutex) Lock() {
    // Fast path: grab unlocked mutex.
    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
        if race.Enabled {
            race.Acquire(unsafe.Pointer(m))
        }
        return
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>awoke := false
iter := 0
for {
    old := m.state
    new := old | mutexLocked
    if old&amp;mutexLocked != 0 { // å¦‚æœå½“å‰å·±ç»é”äº†ï¼Œé‚£ä¹ˆåˆ¤æ–­æ˜¯å¦å¯ä»¥è‡ªæ—‹
        if runtime_canSpin(iter) {
            // Active spinning makes sense.
            // Try to set mutexWoken flag to inform Unlock
            // to not wake other blocked goroutines.
            if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
                atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                awoke = true
            }
            runtime_doSpin()
            iter++
            continue
        }
        new = old + 1&lt;&lt;mutexWaiterShift
    }
    if awoke {
        // The goroutine has been woken from sleep,
        // so we need to reset the flag in either case.
        if new&amp;mutexWoken == 0 {
            panic("sync: inconsistent mutex state")
        }
        new &amp;^= mutexWoken
    }
    if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
        if old&amp;mutexLocked == 0 {
            break
        }
        runtime_Semacquire(&amp;m.sema)
        awoke = true
        iter = 0
    }
}

if race.Enabled {
    race.Acquire(unsafe.Pointer(m))
} }
</code></pre></div></div>

<p>å¯ä»¥çœ‹åˆ°ï¼Œfor å¾ªç¯å¼€å§‹å¢åŠ äº† spin åˆ¤æ–­é€»è¾‘ã€‚</p>

<p>å¦‚æœ runtime åˆ¤æ–­å…è®¸è‡ªæ—‹ï¼Œé‚£ä¹ˆèµ° if é€»è¾‘ï¼Œå¦åˆ™èµ°åŸæœ‰çš„ Lock é€»è¾‘
å¦‚æœå½“å‰ m.state æœªè®¾ç½® woken æ ‡è®°ï¼Œå¹¶ä¸”ç­‰å¾… waiter è®¡æ•°å¤§äº 0ï¼Œè¯´æ˜æœ‰äººåœ¨ç­‰å¾…ï¼Œé‚£ä¹ˆ CAS æ›´æ–° m.state ç½®ä½ mutexWoken
æ‰§è¡Œ runtime_doSpin é€»è¾‘ï¼ŒåŒæ—¶ iter++ è¡¨ç¤ºè‡ªæ—‹æ¬¡æ•°</p>

<p>const (
    mutex_unlocked = 0
    mutex_locked   = 1
    mutex_sleeping = 2</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>active_spin     = 4
active_spin_cnt = 30
passive_spin    = 1 ) // Active spinning for sync.Mutex. //go:linkname sync_runtime_canSpin sync.runtime_canSpin //go:nosplit func sync_runtime_canSpin(i int) bool {
// sync.Mutex is cooperative, so we are conservative with spinning.
// Spin only few times and only if running on a multicore machine and
// GOMAXPROCS&gt;1 and there is at least one other running P and local runq is empty.
// As opposed to runtime mutex we don't do passive spinning here,
// because there can be work on global runq on on other Ps.
if i &gt;= active_spin || ncpu &lt;= 1 || gomaxprocs &lt;= int32(sched.npidle+sched.nmspinning)+1 {
    return false
}
if p := getg().m.p.ptr(); !runqempty(p) {
    return false
}
return true }
</code></pre></div></div>

<p>åˆ¤æ–­ runtime_canSpin æ˜¯å¦å…è®¸è‡ªæ—‹é€»è¾‘ä¹Ÿç®€å•ï¼Œä¹Ÿæ¯”è¾ƒä¸¥æ ¼</p>

<p>iter ä¸å¤§å°æœ€å¤§çš„ active_spin æ¬¡æ•°ï¼Œé»˜è®¤æ˜¯ 4
å½“å‰æœºå™¨æ˜¯å¤šæ ¸ï¼Œå¹¶ä¸” GOMAXPROCS &gt; 1ï¼Œè¿™ä¸ªå¾ˆå¥½ç†è§£ï¼Œå¹¶å‘ä¸º 1 è‡ªæ—‹ä¹Ÿæ²¡æ„ä¹‰
æœ€åä¸€ä¸ªå°±æ˜¯å½“å‰ P çš„æœ¬åœ° runq é˜Ÿåˆ—ä¸ºç©ºï¼Œå¦‚æœæœ‰å¾…è¿è¡Œçš„ Gï¼Œé‚£ä¹ˆä¹Ÿä¸å…è®¸è‡ªæ—‹</p>

<p>func sync_runtime_doSpin() {
    procyield(active_spin_cnt)
}</p>

<p>TEXT runtimeÂ·procyield(SB),NOSPLIT,$0-0
    MOVL    cycles+0(FP), AX
again:
    PAUSE
    SUBL    $1, AX
    JNZ again
    RET</p>

<p>è‡ªæ—‹ä»£ç æ¶‰åŠæ±‡ç¼–äº†ï¼Œåœ¨ amd64 å¹³å°è°ƒç”¨ PAUSEï¼Œå¾ªç¯ active_spin_cnt 30 æ¬¡ã€‚
å…¬å¹³é”çš„å®ç°é€»è¾‘
    // Mutex fairness.
    //
    // Mutex can be in 2 modes of operations: normal and starvation.
    // In normal mode waiters are queued in FIFO order, but a woken up waiter
    // does not own the mutex and competes with new arriving goroutines over
    // the ownership. New arriving goroutines have an advantage â€“ they are
    // already running on CPU and there can be lots of them, so a woken up
    // waiter has good chances of losing. In such case it is queued at front
    // of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,
    // it switches mutex to the starvation mode.
    //
    // In starvation mode ownership of the mutex is directly handed off from
    // the unlocking goroutine to the waiter at the front of the queue.
    // New arriving goroutines donâ€™t try to acquire the mutex even if it appears
    // to be unlocked, and donâ€™t try to spin. Instead they queue themselves at
    // the tail of the wait queue.
    //
    // If a waiter receives ownership of the mutex and sees that either
    // (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,
    // it switches mutex back to normal operation mode.
    //
    // Normal mode has considerably better performance as a goroutine can acquire
    // a mutex several times in a row even if there are blocked waiters.
    // Starvation mode is important to prevent pathological cases of tail latency.</p>

<p>ä»£ç ä»¥ go1.12 ä¸ºä¾‹ï¼Œå¯ä»¥çœ‹åˆ°æ³¨é‡Šå…³äºå…¬å¹³é”çš„å®ç°åˆè¡·å’Œé€»è¾‘ã€‚è¶Šæ˜¯åŸºç¡€ç»„ä»¶æ›´æ–°è¶Šä¸¥æ ¼ï¼ŒèƒŒåè‚¯å®šæœ‰ç›¸å…³æµ‹è¯•æ•°æ®ã€‚</p>

<p>Mutex ä¸¤ç§å·¥ä½œæ¨¡å¼ï¼Œnormal æ­£å¸¸æ¨¡å¼ï¼Œstarvation é¥¥é¥¿æ¨¡å¼ã€‚normal æƒ…å†µä¸‹é”çš„é€»è¾‘ä¸è€ç‰ˆç›¸ä¼¼ï¼Œä¼‘çœ çš„ goroutine ä»¥ FIFO é“¾è¡¨å½¢å¼ä¿å­˜åœ¨ sudog ä¸­ï¼Œè¢«å”¤é†’çš„ goroutine ä¸æ–°åˆ°æ¥æ´»è·ƒçš„ goroutine ç«è§£ï¼Œä½†æ˜¯å¾ˆå¯èƒ½ä¼šå¤±è´¥ã€‚å¦‚æœä¸€ä¸ª goroutine ç­‰å¾…è¶…è¿‡ 1msï¼Œé‚£ä¹ˆ Mutex è¿›å…¥é¥¥é¥¿æ¨¡å¼
é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œè§£é”åï¼Œé”ç›´æ¥äº¤ç»™ waiter FIFO é“¾è¡¨çš„ç¬¬ä¸€ä¸ªï¼Œæ–°æ¥çš„æ´»è·ƒ goroutine ä¸å‚ä¸ç«äº‰ï¼Œå¹¶æ”¾åˆ° FIFO é˜Ÿå°¾
å¦‚æœå½“å‰è·å¾—é”çš„ goroutine æ˜¯ FIFO é˜Ÿå°¾ï¼Œæˆ–æ˜¯ç­‰å¾…æ—¶é•¿å°äº 1msï¼Œé‚£ä¹ˆé€€å‡ºé¥¥é¥¿æ¨¡å¼
normal æ¨¡å¼ä¸‹æ€§èƒ½æ˜¯æ¯”è¾ƒå¥½çš„ï¼Œä½†æ˜¯ starvation æ¨¡å¼èƒ½å‡å°é•¿å°¾ latency</p>

<p>å…¬å¹³é”ä¸Šé”é€»è¾‘
// Lock locks m.
// If the lock is already in use, the calling goroutine
// blocks until the mutex is available.
func (m *Mutex) Lock() {
    // Fast path: grab unlocked mutex. å¿«é€Ÿä¸Šé”é€»è¾‘
    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
        if race.Enabled {
            race.Acquire(unsafe.Pointer(m))
        }
        return
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var waitStartTime int64 // waitStartTime ç”¨äºåˆ¤æ–­æ˜¯å¦éœ€è¦è¿›å…¥é¥¥é¥¿æ¨¡å¼
starving := false // é¥¥é¥¿æ ‡è®°
awoke := false // æ˜¯å¦è¢«å”¤é†’
iter := 0 // spin å¾ªç¯æ¬¡æ•°
old := m.state
for {
    // Don't spin in starvation mode, ownership is handed off to waiters
    // so we won't be able to acquire the mutex anyway. é¥¥é¥¿æ¨¡å¼ä¸‹ä¸è¿›è¡Œè‡ªæ—‹ï¼Œç›´æ¥è¿›å…¥é˜»å¡é˜Ÿåˆ—
    if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
        // Active spinning makes sense.
        // Try to set mutexWoken flag to inform Unlock
        // to not wake other blocked goroutines.
        if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
            atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
            awoke = true
        }
        runtime_doSpin()
        iter++
        old = m.state
        continue
    }
    new := old
    // Don't try to acquire starving mutex, new arriving goroutines must queue.
    if old&amp;mutexStarving == 0 { // åªæœ‰æ­¤æ—¶ä¸æ˜¯é¥¥é¥¿æ¨¡å¼æ—¶ï¼Œæ‰è®¾ç½® mutexLockedï¼Œä¹Ÿå°±æ˜¯è¯´é¥¥é¥¿æ¨¡å¼ä¸‹çš„æ´»è·ƒ goroutine ç›´æ¥æ’é˜Ÿå»
        new |= mutexLocked
    }
    if old&amp;(mutexLocked|mutexStarving) != 0 { // å¤„äºå·±ç»ä¸Šé”æˆ–æ˜¯é¥¥é¥¿æ—¶ï¼Œwaiter è®¡æ•° + 1
        new += 1 &lt;&lt; mutexWaiterShift
    }
    // The current goroutine switches mutex to starvation mode.
    // But if the mutex is currently unlocked, don't do the switch.
    // Unlock expects that starving mutex has waiters, which will not
    // be true in this case. å¦‚æœå½“å‰å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œå¹¶ä¸”å·±ç»ä¸Šé”äº†ï¼ŒmutexStarving ç½® 1ï¼Œæ¥ä¸‹æ¥ CAS ä¼šç”¨åˆ°
    if starving &amp;&amp; old&amp;mutexLocked != 0 {
        new |= mutexStarving
    }
    if awoke { // å¦‚æœå½“å‰ goroutine æ˜¯è¢«å”¤é†’çš„ï¼Œç„¶åæ¸… mutexWoken ä½
        // The goroutine has been woken from sleep,
        // so we need to reset the flag in either case.
        if new&amp;mutexWoken == 0 {
            throw("sync: inconsistent mutex state")
        }
        new &amp;^= mutexWoken
    }
    if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
        if old&amp;(mutexLocked|mutexStarving) == 0 { // å¦‚æœ old æ²¡æœ‰ä¸Šé”å¹¶ä¸”ä¹Ÿä¸æ˜¯é¥¥é¥¿æ¨¡å¼ï¼Œä¸Šé”æˆåŠŸç›´æ¥é€€å‡º
            break // locked the mutex with CAS
        }
        // If we were already waiting before, queue at the front of the queue.
        queueLifo := waitStartTime != 0 // ç¬¬ä¸€æ¬¡ queueLifo è‚¯å®šæ˜¯ false
        if waitStartTime == 0 {
            waitStartTime = runtime_nanotime() 
        }
        runtime_SemacquireMutex(&amp;m.sema, queueLifo) // park åœ¨è¿™é‡Œï¼Œå¦‚æœ queueLifo ä¸ºçœŸï¼Œé‚£ä¹ˆæ‰”åˆ°é˜Ÿå¤´ï¼Œä¹Ÿå°±æ˜¯ LIFO
  // èµ°åˆ°è¿™é‡Œï¼Œè¯´æ˜è¢«å…¶å®ƒ goroutine å”¤é†’äº†ï¼Œç»§ç»­æŠ¢é”æ—¶å…ˆåˆ¤æ–­æ˜¯å¦éœ€è¦è¿›å…¥ starving
        starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs // è¶…è¿‡ 1ms å°±è¿›å…¥é¥¥é¥¿æ¨¡å¼
        old = m.state
        if old&amp;mutexStarving != 0 { // å¦‚æœåŸæ¥å°±æ˜¯é¥¥é¥¿æ¨¡å¼çš„è¯ï¼Œèµ° if é€»è¾‘
            // If this goroutine was woken and mutex is in starvation mode,
            // ownership was handed off to us but mutex is in somewhat
            // inconsistent state: mutexLocked is not set and we are still
            // accounted as waiter. Fix that.
            if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {
                throw("sync: inconsistent mutex state")
            }
    // æ­¤æ—¶é¥¥é¥¿æ¨¡å¼ä¸‹è¢«å”¤é†’ï¼Œé‚£ä¹ˆä¸€å®šèƒ½ä¸Šé”æˆåŠŸã€‚å› ä¸º Unlock ä¿è¯é¥¥é¥¿æ¨¡å¼ä¸‹åªå”¤é†’ park çŠ¶æ€çš„ goroutine
            delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift) // waiter è®¡æ•° -1
            if !starving || old&gt;&gt;mutexWaiterShift == 1 { // å¦‚æœæ˜¯é¥¥é¥¿æ¨¡å¼ä¸‹å¹¶ä¸”è‡ªå·±æ˜¯æœ€åä¸€ä¸ª waiter ï¼Œé‚£ä¹ˆæ¸…é™¤ mutexStarving æ ‡è®°
                // Exit starvation mode.
                // Critical to do it here and consider wait time.
                // Starvation mode is so inefficient, that two goroutines
                // can go lock-step infinitely once they switch mutex
                // to starvation mode.
                delta -= mutexStarving
            }
            atomic.AddInt32(&amp;m.state, delta) // æ›´æ–°ï¼ŒæŠ¢é”æˆåŠŸåé€€å‡º
            break
        }
        awoke = true // èµ°åˆ°è¿™é‡Œï¼Œä¸æ˜¯é¥¥é¥¿æ¨¡å¼ï¼Œé‡æ–°å‘èµ·æŠ¢é”ç«äº‰
        iter = 0
    } else {
        old = m.state // CAS å¤±è´¥ï¼Œé‡æ–°å‘èµ·ç«äº‰
    }
}

if race.Enabled {
    race.Acquire(unsafe.Pointer(m))
} }
</code></pre></div></div>

<p>æ•´ä½“æ¥è®²ï¼Œå…¬å¹³é”ä¸Šé”é€»è¾‘å¤æ‚äº†ä¸å°‘ï¼Œè¾¹ç•Œç‚¹è¦è€ƒæ»¤çš„æ¯”è¾ƒå¤š</p>

<p>åŒæ ·çš„ fast path å¿«é€Ÿä¸Šé”é€»è¾‘ï¼ŒåŸæ¥ m.state ä¸º 0ï¼Œé”å°±å®Œäº‹äº†
è¿›å…¥ for å¾ªç¯ï¼Œä¹Ÿè¦èµ°è‡ªæ—‹é€»è¾‘ï¼Œä½†æ˜¯å¤šäº†ä¸€ä¸ªåˆ¤æ–­ï¼Œå¦‚æœå½“å‰å¤„äºé¥¥é¥¿æ¨¡å¼ç¦æ­¢è‡ªæ—‹ï¼Œæ ¹æ®å®ç°åŸç†ï¼Œæ­¤æ—¶æ´»è·ƒçš„ goroutine è¦ç›´æ¥è¿›å…¥ park çš„é˜Ÿåˆ—
è‡ªæ—‹åé¢çš„ä»£ç æœ‰å››ç§æƒ…å†µï¼šé¥¥é¥¿æŠ¢é”æˆåŠŸï¼Œé¥¥é¥¿æŠ¢é”å¤±è´¥ï¼Œæ­£å¸¸æŠ¢é”æˆå†ï¼Œæ­£å¸¸æŠ¢é”å¤±è´¥ã€‚ä¸Šé”å¤±è´¥çš„æœ€åéƒ½è¦ waiter è®¡æ•°åŠ ä¸€åï¼Œæ›´æ–° CAS
å¦‚æœ CAS å¤±è´¥ï¼Œé‚£ä¹ˆé‡æ–°å‘èµ·ç«äº‰å°±å¥½
å¦‚æœ CAS æˆåŠŸï¼Œæ­¤æ—¶è¦åˆ¤æ–­å¤„äºä½•ç§æƒ…å†µï¼Œå¦‚æœ old æ²¡ä¸Šé”ä¹Ÿå¤„äº normal æ¨¡å¼ï¼ŒæŠ¢é”æˆå†é€€å‡º
å¦‚æœ CAS æˆåŠŸï¼Œä½†æ˜¯å·±ç»æœ‰äººä¸Šé”äº†ï¼Œé‚£ä¹ˆè¦æ ¹æ® queueLifo æ¥åˆ¤æ–­æ˜¯æ‰”åˆ° park é˜Ÿé¦–è¿˜æ˜¯é˜Ÿå°¾ï¼Œæ­¤æ—¶å½“å‰ goroutine park åœ¨è¿™é‡Œï¼Œç­‰å¾…è¢«å”¤é†’</p>

<p>runtime_SemacquireMutex è¢«å”¤é†’äº†æœ‰ä¸¤ç§æƒ…å†µï¼Œåˆ¤æ–­æ˜¯å¦è¦è¿›å…¥é¥¥é¥¿æ¨¡å¼ï¼Œå¦‚æœè€çš„ old å°±æ˜¯é¥¥é¥¿çš„ï¼Œé‚£ä¹ˆè‡ªå·±ä¸€å®šæ˜¯å”¯ä¸€è¢«å”¤é†’ï¼Œä¸€å®šèƒ½æŠ¢åˆ°é”çš„ï¼Œwaiter å‡ä¸€ï¼Œå¦‚æœè‡ªå·±æ˜¯æœ€åä¸€ä¸ª waiter æˆ–æ˜¯é¥¥é¥¿æ—¶é—´å°äº starvationThresholdNs é‚£ä¹ˆæ¸…é™¤ mutexStarving æ ‡è®°ä½åé€€å‡º
å¦‚æœè€çš„ä¸æ˜¯é¥¥é¥¿æ¨¡å¼ï¼Œé‚£ä¹ˆ awoke ç½® trueï¼Œé‡æ–°ç«äº‰</p>

<p>å…¬å¹³é”è§£é”é€»è¾‘
// Unlock unlocks m.
// It is a run-time error if m is not locked on entry to Unlock.
//
// A locked Mutex is not associated with a particular goroutine.
// It is allowed for one goroutine to lock a Mutex and then
// arrange for another goroutine to unlock it.
func (m *Mutex) Unlock() {
    if race.Enabled {
        _ = m.state
        race.Release(unsafe.Pointer(m))
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Fast path: drop lock bit. å’ŒåŸæœ‰é€»è¾‘ä¸€æ ·ï¼Œå…ˆå‡å» mutexLockedï¼Œå¹¶åˆ¤æ–­æ˜¯å¦è§£é”äº†æœªä¸Šé”çš„ Mutex, ç›´æ¥ panic
new := atomic.AddInt32(&amp;m.state, -mutexLocked)
if (new+mutexLocked)&amp;mutexLocked == 0 {
    throw("sync: unlock of unlocked mutex")
}
if new&amp;mutexStarving == 0 { // æŸ¥çœ‹ mutexStarving æ ‡è®°ä½ï¼Œå¦‚æœ 0 èµ°è€é€»è¾‘ï¼Œå¦åˆ™èµ° starvation åˆ†æ”¯
    old := new
    for {
        // If there are no waiters or a goroutine has already
        // been woken or grabbed the lock, no need to wake anyone.
        // In starvation mode ownership is directly handed off from unlocking
        // goroutine to the next waiter. We are not part of this chain,
        // since we did not observe mutexStarving when we unlocked the mutex above.
        // So get off the way.
        if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
            return
        }
        // Grab the right to wake someone.
        new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
        if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            runtime_Semrelease(&amp;m.sema, false)
            return
        }
        old = m.state
    }
} else {
    // Starving mode: handoff mutex ownership to the next waiter.
    // Note: mutexLocked is not set, the waiter will set it after wakeup.
    // But mutex is still considered locked if mutexStarving is set,
    // so new coming goroutines won't acquire it.
    runtime_Semrelease(&amp;m.sema, true) // ç›´æ¥ runtime_Semrelease å”¤é†’ç­‰å¾…çš„ goroutine
} }
</code></pre></div></div>

<p>åŸå­æ“ä½œï¼Œå°† m.state å‡å» mutexLockedï¼Œç„¶ååˆ¤æ–­æ˜¯å¦é‡Šæ”¾äº†æœªä¸Šé”çš„ Mutexï¼Œç›´æ¥ panic
æ ¹æ® m.state çš„ mutexStarving åˆ¤æ–­å½“å‰å¤„äºä½•ç§æ¨¡å¼ï¼Œ0 èµ° normal åˆ†æ”¯ï¼Œ1 èµ° starvation åˆ†æ”¯
starvation æ¨¡å¼ä¸‹ï¼Œç›´æ¥ runtime_Semrelease åšä¿¡å·é‡ UP æ“ä½œï¼Œå”¤é†’ FIFO é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ª goroutine
noarmal æ¨¡å¼ç±»ä¼¼åŸæœ‰é€»è¾‘ï¼Œå”¯ä¸€ä¸åŒçš„æ˜¯å¤šäº†ä¸€ä¸ª  mutexStarving ä½åˆ¤æ–­é€»è¾‘</p>
:ET