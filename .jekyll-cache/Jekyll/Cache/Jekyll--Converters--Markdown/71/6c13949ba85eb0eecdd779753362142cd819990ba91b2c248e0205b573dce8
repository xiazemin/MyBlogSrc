I"G<!-- more -->
<p>众所周知，bash是一款极其强大的shell，提供了强大的交互与编程功能。这样的一款shell中自然不会缺少“函数”这个元素来帮助程序进行模块化的高效开发与管理。于是产生了由于其特殊的特性，bash拥有了fork炸弹。Jaromil在2002年设计了最为精简的一个fork炸弹的实现。</p>

<p>所谓fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，fork炸弹并不需要有特别的权限即可对系统造成破坏。fork炸弹实质是一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个简单的程序迅速耗尽系统里面的所有资源。现在来看看Jaromil设计的最简单的fork炸弹:</p>

<table>
  <tbody>
    <tr>
      <td>:() { :</td>
      <td>:&amp; };:</td>
    </tr>
  </tbody>
</table>

<p>或者</p>

<table>
  <tbody>
    <tr>
      <td>.() { .</td>
      <td>.&amp; };.</td>
    </tr>
  </tbody>
</table>

<p>一行看似无法理解的只有13个字符的命令，即可占用掉所有系统的资源。其实，这行命令如果这样写成bash script就不难理解了：</p>

<dl>
  <dt>:()</dt>
  <dt>{</dt>
  <dd>|: &amp;
}
;
:</dd>
</dl>

<ul>
  <li>第 1 行说明下面要定义一个函数，函数名为小数点，没有可选参数。</li>
  <li>第 2 行表示函数体开始。</li>
  <li>第 3 行是函数体真正要做的事情，首先它递归调用本函数，然后利用管道调用一个新进程（它要做的事情也是递归调用本函数），并将其放到后台执行。</li>
  <li>第 4 行表示函数体结束。</li>
  <li>第 5 行并不会执行什么操作，在命令行中用来分隔两个命令用。从总体来看，它表明这段程序包含两个部分，首先定义了一个函数，然后调用这个函数。</li>
  <li>第 6 行表示调用本函数。</li>
</ul>

<p>冒号”:”其实是函数名，这个bash脚本就是在不断的执行该函数，然后不断fork出新的进程。</p>

<p>对于函数名，大家可能会有所疑惑，小数点也能做函数名使用吗？毕竟小数点是 shell 的一个内嵌命令，用来在当前 shell 环境中读取指定 文件，并运行其中的命令。实际上的确可以，这取决于bash对命令的解释顺序。</p>

<p>默认情况下，bash处于非POSIX模式，此时对命令的解释顺序如下：</p>

<ul>
  <li>关键字，例如 if、for 等。</li>
  <li>别名。别名不能与关键字相同，但是可以为关键字定义别名，例如 end=fi。</li>
  <li>特 殊内嵌命令，例如 break、continue 等。POSIX 定义的特殊内嵌命令包括：.（小数点）、:（冒号）、break、continue、 eval、exec、exit、export、readonly、 return、set、shift、times、trap 和 unset。 bash 又增加了一个特殊的内嵌命令 source。</li>
  <li>函数。如果处于非 POSIX 模式，bash 会优先匹配函数，然后再匹配内嵌命令。</li>
  <li>非特殊内嵌命令，例如 cd、test 等。</li>
  <li>脚本和可执行程序。在 PATH 环境变量指定的目录中进行搜索，返回第一个匹配项。
由 于默认情况下，bash 处于非 POSIX 模式，因此fork炸弹中的小数点会优先当成一个函数进行匹配。(注：使用小数点代替其中的冒号，也能起到完全相同的效果。)</li>
</ul>

<p>要使用POSIX模式来运行bash脚本，可以使用以下三种方法：</p>

<ul>
  <li>使用 –posix 选项启动 bash。</li>
  <li>在运行bash之后，执行 set -o posix 命令。</li>
  <li>使用 /bin/sh 。</li>
</ul>

:ET