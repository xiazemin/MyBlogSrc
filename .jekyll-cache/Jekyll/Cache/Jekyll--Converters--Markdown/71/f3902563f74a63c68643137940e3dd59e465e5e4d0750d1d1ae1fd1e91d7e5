I"½N<p>è®¸å¤šè‡ªåŠ¨åŒ–ä»£ç ç”Ÿæˆå·¥å…·éƒ½ç¦»ä¸å¼€è¯­æ³•æ ‘åˆ†æï¼Œä¾‹å¦‚goimportï¼Œgomockï¼Œwireç­‰é¡¹ç›®éƒ½ç¦»ä¸å¼€è¯­æ³•æ ‘åˆ†æã€‚åŸºäºè¯­æ³•æ ‘åˆ†æï¼Œå¯ä»¥å®ç°è®¸å¤šæœ‰è¶£å®ç”¨çš„å·¥å…·ã€‚
<!-- more -->
è®¸å¤šè‡ªåŠ¨åŒ–ä»£ç ç”Ÿæˆå·¥å…·éƒ½ç¦»ä¸å¼€è¯­æ³•æ ‘åˆ†æï¼Œä¾‹å¦‚goimportï¼Œgomockï¼Œwireç­‰é¡¹ç›®éƒ½ç¦»ä¸å¼€è¯­æ³•æ ‘åˆ†æã€‚åŸºäºè¯­æ³•æ ‘åˆ†æï¼Œå¯ä»¥å®ç°è®¸å¤šæœ‰è¶£å®ç”¨çš„å·¥å…·ã€‚æœ¬ç¯‡å°†ç»“åˆç¤ºä¾‹ï¼Œå±•ç¤ºå¦‚ä½•åŸºäºastæ ‡å‡†åŒ…æ“ä½œè¯­æ³•æ ‘ã€‚
æœ¬ç¯‡ä¸­çš„ä»£ç çš„å®Œæ•´ç¤ºä¾‹å¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ï¼šast-example
Quick Start
é¦–å…ˆæˆ‘ä»¬çœ‹ä¸‹è¯­æ³•æ ‘é•¿ä»€ä¹ˆæ ·å­ï¼Œä»¥ä¸‹ä»£ç å°†æ‰“å°./demo.goæ–‡ä»¶çš„è¯­æ³•æ ‘ï¼š
package main</p>

<p>import (
	â€œgo/astâ€
	â€œgo/parserâ€
	â€œgo/tokenâ€
	â€œlogâ€
	â€œpath/filepathâ€
)</p>

<p>func main() {
	fset := token.NewFileSet()
	// è¿™é‡Œå–ç»å¯¹è·¯å¾„ï¼Œæ–¹ä¾¿æ‰“å°å‡ºæ¥çš„è¯­æ³•æ ‘å¯ä»¥è½¬è·³åˆ°ç¼–è¾‘å™¨
	path, _ := filepath.Abs(â€œ./demo.goâ€)
	f, err := parser.ParseFile(fset, path, nil, parser.AllErrors)
	if err != nil {
		log.Println(err)
		return
	}
	// æ‰“å°è¯­æ³•æ ‘
	ast.Print(fset, f)
}</p>

<p>å¤åˆ¶ä»£ç 
demo.go:</p>

<p>package main</p>

<p>import (
	â€œcontextâ€
)</p>

<p>// Foo ç»“æ„ä½“
type Foo struct {
	i int
}</p>

<p>// Bar æ¥å£
type Bar interface {
	Do(ctx context.Context) error
}</p>

<p>// mainæ–¹æ³•
func main() {
    a := 1
}
å¤åˆ¶ä»£ç demo.goæ–‡ä»¶å·²å°½é‡ç®€åŒ–ï¼Œä½†å…¶è¯­æ³•æ ‘çš„è¾“å‡ºå†…å®¹ä¾æ—§ååˆ†åºå¤§ã€‚æˆ‘ä»¬æˆªå–éƒ¨åˆ†æ¥åšä¸€äº›ç®€è¦çš„è¯´æ˜ã€‚
é¦–å…ˆæ˜¯æ–‡ä»¶æ‰€å±çš„åŒ…åï¼Œå’Œå…¶å£°æ˜åœ¨æ–‡ä»¶ä¸­çš„ä½ç½®ï¼š
 0  <em>ast.File {
     1  .  Package: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:1:1
     2  .  Name: *ast.Ident {
     3  .  .  NamePos: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:1:9
     4  .  .  Name: â€œmainâ€
     5  .  }
     â€¦
å¤åˆ¶ä»£ç ç´§æ¥ç€æ˜¯Declsï¼Œä¹Ÿå°±æ˜¯Declarationsï¼Œå…¶åŒ…å«äº†å£°æ˜çš„ä¸€äº›å˜é‡ï¼Œæ–¹æ³•ï¼Œæ¥å£ç­‰ï¼š
â€¦
     6  .  Decls: []ast.Decl (len = 4) {
     7  .  .  0: *ast.GenDecl {
     8  .  .  .  TokPos: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:3:1
     9  .  .  .  Tok: import
    10  .  .  .  Lparen: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:3:8
    11  .  .  .  Specs: []ast.Spec (len = 1) {
    12  .  .  .  .  0: *ast.ImportSpec {
    13  .  .  .  .  .  Path: *ast.BasicLit {
    14  .  .  .  .  .  .  ValuePos: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:4:2
    15  .  .  .  .  .  .  Kind: STRING
    16  .  .  .  .  .  .  Value: â€œ"context"â€
    17  .  .  .  .  .  }
    18  .  .  .  .  .  EndPos: -
    19  .  .  .  .  }
    20  .  .  .  }
    21  .  .  .  Rparen: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:5:1
    22  .  .  }
 â€¦.
å¤åˆ¶ä»£ç å¯ä»¥çœ‹åˆ°è¯¥è¯­æ³•æ ‘åŒ…å«äº†4æ¡Declè®°å½•ï¼Œæˆ‘ä»¬å–ç¬¬ä¸€æ¡è®°å½•ä¸ºä¾‹ï¼Œè¯¥è®°å½•ä¸º</em>ast.GenDeclç±»å‹ã€‚ä¸éš¾çœ‹å‡ºè¿™æ¡è®°å½•å¯¹åº”çš„æ˜¯æˆ‘ä»¬çš„importä»£ç æ®µã€‚å§‹ä½ç½®(TokPos)ï¼Œå·¦å³æ‹¬å·çš„ä½ç½®(Lparen,Rparen)ï¼Œå’Œimportçš„åŒ…ï¼ˆSpecsï¼‰ç­‰ä¿¡æ¯éƒ½èƒ½ä»è¯­æ³•æ ‘ä¸­å¾—åˆ°ã€‚
è¯­æ³•æ ‘çš„æ‰“å°ä¿¡æ¥è‡ªast.Fileç»“æ„ä½“ï¼š</p>

<p>$GOROOT/src/go/ast/ast.go</p>

<p>// è¯¥ç»“æ„ä½“ä½äºæ ‡å‡†åŒ… go/ast/ast.go ä¸­ï¼Œæœ‰å…´è¶£å¯ä»¥è½¬è·³åˆ°æºç é˜…è¯»æ›´è¯¦å°½çš„æ³¨é‡Š
type File struct {
	Doc        <em>CommentGroup   // associated documentation; or nil
	Package    token.Pos       // position of â€œpackageâ€ keyword
	Name       *Ident          // package name
	Decls      []Decl          // top-level declarations; or nil
	Scope      *Scope          // package scope (this file only)
	Imports    []</em>ImportSpec   // imports in this file
	Unresolved []<em>Ident        // unresolved identifiers in this file
	Comments   []</em>CommentGroup // list of all comments in the source file
}
å¤åˆ¶ä»£ç ç»“åˆæ³¨é‡Šå’Œå­—æ®µåæˆ‘ä»¬å¤§æ¦‚çŸ¥é“æ¯ä¸ªå­—æ®µçš„å«ä¹‰ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬è¯¦ç»†æ¢³ç†ä¸€ä¸‹è¯­æ³•æ ‘çš„ç»„æˆç»“æ„ã€‚
NodeèŠ‚ç‚¹
æ•´ä¸ªè¯­æ³•æ ‘ç”±ä¸åŒçš„nodeç»„æˆï¼Œä»æºç æ³¨é‡Šä¸­å¯ä»¥å¾—çŸ¥ä¸»è¦æœ‰å¦‚ä¸‹ä¸‰ç§nodeï¼š</p>

<p>There are 3 main classes of nodes: Expressions and type nodes, statement nodes, and declaration nodes.</p>

<p>åœ¨Goçš„Language Specificationä¸­å¯ä»¥æ‰¾åˆ°è¿™äº›èŠ‚ç‚¹ç±»å‹è¯¦ç»†è§„èŒƒå’Œè¯´æ˜ï¼Œæœ‰å…´è¶£çš„å°ä¼™ä¼´å¯ä»¥æ·±å…¥ç ”ç©¶ä¸€ä¸‹ï¼Œåœ¨æ­¤ä¸åšå±•å¼€ã€‚</p>

<p>ä½†å®é™…åœ¨ä»£ç ï¼Œå‡ºç°äº†ç¬¬å››ç§nodeï¼šSpec Nodeï¼Œæ¯ç§nodeéƒ½æœ‰ä¸“é—¨çš„æ¥å£å®šä¹‰ï¼š</p>

<p>$GOROOT/src/go/ast/ast.go</p>

<p>â€¦
// All node types implement the Node interface.
type Node interface {
	Pos() token.Pos // position of first character belonging to the node
	End() token.Pos // position of first character immediately after the node
}</p>

<p>// All expression nodes implement the Expr interface.
type Expr interface {
	Node
	exprNode()
}</p>

<p>// All statement nodes implement the Stmt interface.
type Stmt interface {
	Node
	stmtNode()
}</p>

<p>// All declaration nodes implement the Decl interface.
type Decl interface {
	Node
	declNode()
}
â€¦</p>

<p>// A Spec node represents a single (non-parenthesized) import,
// constant, type, or variable declaration.
//
type (
	// The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.
	Spec interface {
		Node
		specNode()
	}
â€¦.
)
å¤åˆ¶ä»£ç å¯ä»¥çœ‹åˆ°æ‰€æœ‰çš„nodeéƒ½ç»§æ‰¿Nodeæ¥å£ï¼Œè®°å½•äº†nodeçš„å¼€å§‹å’Œç»“æŸä½ç½®ã€‚è¿˜è®°å¾—Quick Startç¤ºä¾‹ä¸­çš„Declså—ï¼Ÿå®ƒæ­£æ˜¯declaration nodesã€‚é™¤å»ä¸Šè¿°å››ç§ä½¿ç”¨æ¥å£è¿›è¡Œåˆ†ç±»çš„nodeï¼Œè¿˜æœ‰äº›nodeæ²¡æœ‰å†é¢å¤–å®šä¹‰æ¥å£ç»†åˆ†ç±»åˆ«ï¼Œä»…å®ç°äº†Nodeæ¥å£ï¼Œä¸ºäº†æ–¹ä¾¿æè¿°ï¼Œåœ¨æœ¬ç¯‡ä¸­æˆ‘æŠŠè¿™äº›èŠ‚ç‚¹ç§°ä¸ºcommon nodeã€‚
$GOROOT/src/go/ast/ast.goåˆ—ä¸¾äº†æ‰€æœ‰æ‰€æœ‰èŠ‚ç‚¹çš„å®ç°ï¼Œæˆ‘ä»¬ä»ä¸­æŒ‘é€‰å‡ ä¸ªä½œä¸ºä¾‹å­ï¼Œæ„Ÿå—ä¸€ä¸‹å®ƒä»¬çš„åŒºåˆ«ã€‚
Expression and Type
å…ˆæ¥çœ‹expression nodeã€‚</p>

<p>$GOROOT/src/go/ast/ast.go</p>

<p>â€¦
	// An Ident node represents an identifier.
	Ident struct {
		NamePos token.Pos // identifier position
		Name    string    // identifier name
		Obj     *Object   // denoted object; or nil
	}
â€¦
å¤åˆ¶ä»£ç Indentï¼ˆidentifierï¼‰è¡¨ç¤ºä¸€ä¸ªæ ‡è¯†ç¬¦ï¼Œæ¯”å¦‚Quick Startç¤ºä¾‹ä¸­è¡¨ç¤ºåŒ…åçš„Nameå­—æ®µå°±æ˜¯ä¸€ä¸ªexpression nodeï¼š
 0  *ast.File {
     1  .  Package: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:1:1
     2  .  Name: *ast.Ident { &lt;â€”-
     3  .  .  NamePos: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:1:9
     4  .  .  Name: â€œmainâ€
     5  .  }
     â€¦
å¤åˆ¶ä»£ç æ¥ä¸‹æ¥æ˜¯type nodeã€‚</p>

<p>$GOROOT/src/go/ast/ast.go</p>

<p>â€¦
	// A StructType node represents a struct type.
	StructType struct {
		Struct     token.Pos  // position of â€œstructâ€ keyword
		Fields     *FieldList // list of field declarations
		Incomplete bool       // true if (source) fields are missing in the Fields list
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Pointer types are represented via StarExpr nodes.

// A FuncType node represents a function type.
FuncType struct {
	Func    token.Pos  // position of "func" keyword (token.NoPos if there is no "func")
	Params  *FieldList // (incoming) parameters; non-nil
	Results *FieldList // (outgoing) results; or nil
}

// An InterfaceType node represents an interface type.
InterfaceType struct {
	Interface  token.Pos  // position of "interface" keyword
	Methods    *FieldList // list of methods
	Incomplete bool       // true if (source) methods are missing in the Methods list
} ... å¤åˆ¶ä»£ç type nodeå¾ˆå¥½ç†è§£ï¼Œå®ƒåŒ…å«ä¸€äº›å¤åˆç±»å‹ï¼Œä¾‹å¦‚åœ¨Quick Startä¸­å‡ºç°çš„StructType,FuncTypeå’ŒInterfaceTypeã€‚ Statement èµ‹å€¼è¯­å¥ï¼Œæ§åˆ¶è¯­å¥ï¼ˆifï¼Œelse,forï¼Œselect...ï¼‰ç­‰å‡å±äºstatement nodeã€‚
</code></pre></div></div>

<p>$GOROOT/src/go/ast/ast.go</p>

<p>â€¦
	// An AssignStmt node represents an assignment or
	// a short variable declaration.
	//
	AssignStmt struct {
		Lhs    []Expr
		TokPos token.Pos   // position of Tok
		Tok    token.Token // assignment token, DEFINE
		Rhs    []Expr
	}
â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// An IfStmt node represents an if statement.
IfStmt struct {
	If   token.Pos // position of "if" keyword
	Init Stmt      // initialization statement; or nil
	Cond Expr      // condition
	Body *BlockStmt
	Else Stmt // else branch; or nil
} ... å¤åˆ¶ä»£ç ä¾‹å¦‚Quick Startä¸­ï¼Œæˆ‘ä»¬åœ¨mainå‡½æ•°ä¸­å¯¹å˜é‡aèµ‹å€¼çš„ç¨‹åºç‰‡æ®µå°±å±äºAssignStmt: ...  174  .  .  .  Body: *ast.BlockStmt {    175  .  .  .  .  Lbrace: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:18:13    176  .  .  .  .  List: []ast.Stmt (len = 1) {    177  .  .  .  .  .  0: *ast.AssignStmt { &lt;--- è¿™é‡Œ    178  .  .  .  .  .  .  Lhs: []ast.Expr (len = 1) {    179  .  .  .  .  .  .  .  0: *ast.Ident {    180  .  .  .  .  .  .  .  .  NamePos: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:19:2    181  .  .  .  .  .  .  .  .  Name: "a" ... å¤åˆ¶ä»£ç Spec Node Spec nodeåªæœ‰3ç§ï¼Œåˆ†åˆ«æ˜¯ImportSpecï¼ŒValueSpecå’ŒTypeSpecï¼š
</code></pre></div></div>

<p>$GOROOT/src/go/ast/ast.go</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// An ImportSpec node represents a single package import.
ImportSpec struct {
	Doc     *CommentGroup // associated documentation; or nil
	Name    *Ident        // local package name (including "."); or nil
	Path    *BasicLit     // import path
	Comment *CommentGroup // line comments; or nil
	EndPos  token.Pos     // end of spec (overrides Path.Pos if nonzero)
}

// A ValueSpec node represents a constant or variable declaration
// (ConstSpec or VarSpec production).
//
ValueSpec struct {
	Doc     *CommentGroup // associated documentation; or nil
	Names   []*Ident      // value names (len(Names) &gt; 0)
	Type    Expr          // value type; or nil
	Values  []Expr        // initial values; or nil
	Comment *CommentGroup // line comments; or nil
}

// A TypeSpec node represents a type declaration (TypeSpec production).
TypeSpec struct {
	Doc     *CommentGroup // associated documentation; or nil
	Name    *Ident        // type name
	Assign  token.Pos     // position of '=', if any
	Type    Expr          // *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes
	Comment *CommentGroup // line comments; or nil
} å¤åˆ¶ä»£ç ImportSpecè¡¨ç¤ºä¸€ä¸ªå•ç‹¬çš„importï¼ŒValueSpecè¡¨ç¤ºä¸€ä¸ªå¸¸é‡æˆ–å˜é‡çš„å£°æ˜ï¼ŒTypeSpecåˆ™è¡¨ç¤ºä¸€ä¸ªtypeå£°æ˜ã€‚ä¾‹å¦‚ åœ¨Quick Startç¤ºä¾‹ä¸­ï¼Œå‡ºç°äº†ImportSpecå’ŒTypeSpec import (
"context" // &lt;--- è¿™é‡Œæ˜¯ä¸€ä¸ªImportSpec node )
</code></pre></div></div>

<p>// Foo ç»“æ„ä½“
type Foo struct { // &lt;â€” è¿™é‡Œæ˜¯ä¸€ä¸ªTypeSpec node
	i int
}
å¤åˆ¶ä»£ç åœ¨è¯­æ³•æ ‘çš„æ‰“å°ç»“æœä¸­å¯ä»¥çœ‹åˆ°å¯¹åº”çš„è¾“å‡ºï¼Œå°ä¼™ä¼´ä»¬å¯è‡ªè¡ŒæŸ¥æ‰¾ã€‚
Declaration Node
Declaration nodeä¹Ÿåªæœ‰ä¸‰ç§ï¼š</p>

<p>$GOROOT/src/go/ast/ast.go</p>

<p>â€¦
type (
	// A BadDecl node is a placeholder for declarations containing
	// syntax errors for which no correct declaration nodes can be
	// created.
	//
	BadDecl struct {
		From, To token.Pos // position range of bad declaration
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// A GenDecl node (generic declaration node) represents an import,
// constant, type or variable declaration. A valid Lparen position
// (Lparen.IsValid()) indicates a parenthesized declaration.
//
// Relationship between Tok value and Specs element type:
//
//	token.IMPORT  *ImportSpec
//	token.CONST   *ValueSpec
//	token.TYPE    *TypeSpec
//	token.VAR     *ValueSpec
//
GenDecl struct {
	Doc    *CommentGroup // associated documentation; or nil
	TokPos token.Pos     // position of Tok
	Tok    token.Token   // IMPORT, CONST, TYPE, VAR
	Lparen token.Pos     // position of '(', if any
	Specs  []Spec
	Rparen token.Pos // position of ')', if any
}

// A FuncDecl node represents a function declaration.
FuncDecl struct {
	Doc  *CommentGroup // associated documentation; or nil
	Recv *FieldList    // receiver (methods); or nil (functions)
	Name *Ident        // function/method name
	Type *FuncType     // function signature: parameters, results, and position of "func" keyword
	Body *BlockStmt    // function body; or nil for external (non-Go) function
} ) ... å¤åˆ¶ä»£ç BadDeclè¡¨ç¤ºä¸€ä¸ªæœ‰è¯­æ³•é”™è¯¯çš„èŠ‚ç‚¹ï¼› GenDeclç”¨äºè¡¨ç¤ºimport, constï¼Œtypeæˆ–å˜é‡å£°æ˜ï¼›FunDeclç”¨äºè¡¨ç¤ºå‡½æ•°å£°æ˜ã€‚ GenDeclå’ŒFunDeclåœ¨Quick Startä¾‹å­ä¸­å‡æœ‰å‡ºç°ï¼Œå°ä¼™ä¼´ä»¬å¯è‡ªè¡ŒæŸ¥æ‰¾ã€‚ Common Node é™¤å»ä¸Šè¿°å››ç§ç±»åˆ«åˆ’åˆ†çš„node,è¿˜æœ‰ä¸€äº›nodeä¸å±äºä¸Šé¢å››ç§ç±»åˆ«ï¼š
</code></pre></div></div>

<p>$GOROOT/src/go/ast/ast.go</p>

<p>// Comment æ³¨é‡ŠèŠ‚ç‚¹ï¼Œä»£è¡¨å•è¡Œçš„ //-æ ¼å¼ æˆ– /*-æ ¼å¼çš„æ³¨é‡Š.
type Comment struct {
    â€¦
}
â€¦
// CommentGroup æ³¨é‡Šå—èŠ‚ç‚¹ï¼ŒåŒ…å«å¤šä¸ªè¿ç»­çš„Comment
type CommentGroup struct {
    â€¦
}</p>

<p>// Field å­—æ®µèŠ‚ç‚¹, å¯ä»¥ä»£è¡¨ç»“æ„ä½“å®šä¹‰ä¸­çš„å­—æ®µï¼Œæ¥å£å®šä¹‰ä¸­çš„æ–¹æ³•åˆ—è¡¨ï¼Œå‡½æ•°å‰é¢ä¸­çš„å…¥å‚å’Œè¿”å›å€¼å­—æ®µ
type Field struct {
    â€¦
}
â€¦
// FieldList åŒ…å«å¤šä¸ªField
type FieldList struct {
    â€¦
}</p>

<p>// File è¡¨ç¤ºä¸€ä¸ªæ–‡ä»¶èŠ‚ç‚¹
type File struct {
	â€¦
}</p>

<p>// Package è¡¨ç¤ºä¸€ä¸ªåŒ…èŠ‚ç‚¹
type Package struct {
    â€¦
}
å¤åˆ¶ä»£ç Quick Startç¤ºä¾‹åŒ…å«äº†ä¸Šé¢åˆ—ä¸¾çš„æ‰€æœ‰nodeï¼Œå°ä¼™ä¼´ä»¬å¯ä»¥è‡ªè¡ŒæŸ¥æ‰¾ã€‚æ›´ä¸ºè¯¦ç»†çš„æ³¨é‡Šå’Œå…·ä½“çš„ç»“æ„ä½“å­—æ®µè¯·æŸ¥é˜…æºç ã€‚
æ‰€æœ‰çš„èŠ‚ç‚¹ç±»å‹å¤§è‡´åˆ—ä¸¾å®Œæ¯•ï¼Œå…¶ä¸­è¿˜æœ‰è®¸å¤šå…·ä½“çš„èŠ‚ç‚¹ç±»å‹æœªèƒ½ä¸€ä¸€åˆ—ä¸¾ï¼Œä½†åŸºæœ¬ä¸Šéƒ½æ˜¯å¤§åŒå°å¼‚ï¼Œæºç æ³¨é‡Šä¹Ÿæ¯”è¾ƒæ¸…æ™°ï¼Œç­‰ç”¨åˆ°çš„æ—¶å€™å†ç»†çœ‹ä¹Ÿä¸è¿Ÿã€‚ç°åœ¨æˆ‘ä»¬å¯¹æ•´ä¸ªè¯­æ³•æ ‘çš„æ„é€ æœ‰äº†åŸºæœ¬çš„äº†è§£ï¼Œæ¥ä¸‹æ¥é€šè¿‡å‡ ä¸ªç¤ºä¾‹æ¥æ¼”ç¤ºå…·ä½“ç”¨æ³•ã€‚
ç¤ºä¾‹
ä¸ºæ–‡ä»¶ä¸­æ‰€æœ‰æ¥å£æ–¹æ³•æ·»åŠ contextå‚æ•°
å®ç°è¿™ä¸ªåŠŸèƒ½æˆ‘ä»¬éœ€è¦å››æ­¥ï¼š</p>

<p>éå†æ•´ä¸ªè¯­æ³•æ ‘
åˆ¤æ–­æ˜¯å¦å·²ç»importcontextåŒ…ï¼Œå¦‚æœæ²¡æœ‰åˆ™import
éå†æ‰€æœ‰çš„æ¥å£æ–¹æ³•ï¼Œåˆ¤æ–­æ–¹æ³•åˆ—è¡¨ä¸­æ˜¯å¦æœ‰context.Contextç±»å‹çš„å…¥å‚ï¼Œå¦‚æœæ²¡æœ‰æˆ‘ä»¬å°†å…¶æ·»åŠ åˆ°æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°
å°†ä¿®æ”¹è¿‡åçš„è¯­æ³•æ ‘è½¬æ¢æˆGoä»£ç å¹¶è¾“å‡º</p>

<p>éå†è¯­æ³•æ ‘
è¯­æ³•æ ‘å±‚çº§è¾ƒæ·±ï¼ŒåµŒå¥—å…³ç³»å¤æ‚ï¼Œå¦‚æœä¸èƒ½å®Œå…¨æŒæ¡nodeä¹‹é—´çš„å…³ç³»å’ŒåµŒå¥—è§„åˆ™ï¼Œæˆ‘ä»¬å¾ˆéš¾è‡ªå·±å†™å‡ºæ­£ç¡®çš„éå†æ–¹æ³•ã€‚ä¸è¿‡å¥½åœ¨aståŒ…å·²ç»ä¸ºæˆ‘ä»¬æä¾›äº†éå†æ–¹æ³•ï¼š</p>

<p>$GOROOT/src/go/ast/ast.go</p>

<p>func Walk(v Visitor, node Node) 
å¤åˆ¶ä»£ç type Visitor interface {
	Visit(node Node) (w Visitor)
}
å¤åˆ¶ä»£ç Walkæ–¹æ³•ä¼šæŒ‰ç…§æ·±åº¦ä¼˜å…ˆæœç´¢æ–¹æ³•ï¼ˆdepth-first orderï¼‰éå†æ•´ä¸ªè¯­æ³•æ ‘ï¼Œæˆ‘ä»¬åªéœ€æŒ‰ç…§æˆ‘ä»¬çš„ä¸šåŠ¡éœ€è¦ï¼Œå®ç°Visitoræ¥å£å³å¯ã€‚
Walkæ¯éå†ä¸€ä¸ªèŠ‚ç‚¹å°±ä¼šè°ƒç”¨Visitor.Visitæ–¹æ³•ï¼Œä¼ å…¥å½“å‰èŠ‚ç‚¹ã€‚å¦‚æœVisitè¿”å›nilï¼Œåˆ™åœæ­¢éå†å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ã€‚æœ¬ç¤ºä¾‹çš„Visitorå®ç°å¦‚ä¸‹ï¼š
// Visitor
type Visitor struct {
}
func (v <em>Visitor) Visit(node ast.Node) ast.Visitor {
	switch node.(type) {
	case *ast.GenDecl:
		genDecl := node.(</em>ast.GenDecl)
		// æŸ¥æ‰¾æœ‰æ²¡æœ‰import contextåŒ…
		// Noticeï¼šæ²¡æœ‰è€ƒè™‘æ²¡æœ‰importä»»ä½•åŒ…çš„æƒ…å†µ
		if genDecl.Tok == token.IMPORT {
			v.addImport(genDecl)
			// ä¸éœ€è¦å†éå†å­æ ‘
			return nil
		}
	case <em>ast.InterfaceType:
		// éå†æ‰€æœ‰çš„æ¥å£ç±»å‹
		iface := node.(</em>ast.InterfaceType)
		addContext(iface)
		// ä¸éœ€è¦å†éå†å­æ ‘
		return nil
	}
	return v
}
å¤åˆ¶ä»£ç æ·»åŠ import
// addImport å¼•å…¥contextåŒ…
func (v <em>Visitor) addImport(genDecl *ast.GenDecl) {
	// æ˜¯å¦å·²ç»import
	hasImported := false
	for _, v := range genDecl.Specs {
		imptSpec := v.(</em>ast.ImportSpec)
		// å¦‚æœå·²ç»åŒ…å«â€contextâ€
		if imptSpec.Path.Value == strconv.Quote(â€œcontextâ€) {
			hasImported = true
		}
	}
	// å¦‚æœæ²¡æœ‰import contextï¼Œåˆ™import
	if !hasImported {
		genDecl.Specs = append(genDecl.Specs, &amp;ast.ImportSpec{
			Path: &amp;ast.BasicLit{
				Kind:  token.STRING,
				Value: strconv.Quote(â€œcontextâ€),
			},
		})
	}
}</p>

<p>å¤åˆ¶ä»£ç ä¸ºæ¥å£æ–¹æ³•æ·»åŠ å‚æ•°
// addContext æ·»åŠ contextå‚æ•°
func addContext(iface <em>ast.InterfaceType) {
	// æ¥å£æ–¹æ³•ä¸ä¸ºç©ºæ—¶ï¼Œéå†æ¥å£æ–¹æ³•
	if iface.Methods != nil || iface.Methods.List != nil {
		for _, v := range iface.Methods.List {
			ft := v.Type.(</em>ast.FuncType)
			hasContext := false
			// åˆ¤æ–­å‚æ•°ä¸­æ˜¯å¦åŒ…å«context.Contextç±»å‹
			for _, v := range ft.Params.List {
				if expr, ok := v.Type.(<em>ast.SelectorExpr); ok {
					if ident, ok := expr.X.(</em>ast.Ident); ok {
						if ident.Name == â€œcontextâ€ {
							hasContext = true
						}
					}
				}
			}
			// ä¸ºæ²¡æœ‰contextå‚æ•°çš„æ–¹æ³•æ·»åŠ contextå‚æ•°
			if !hasContext {
				ctxField := &amp;ast.Field{
					Names: []<em>ast.Ident{
						ast.NewIdent(â€œctxâ€),
					},
					// Notice: æ²¡æœ‰è€ƒè™‘importåˆ«åçš„æƒ…å†µ
					Type: &amp;ast.SelectorExpr{
						X:   ast.NewIdent(â€œcontextâ€),
						Sel: ast.NewIdent(â€œContextâ€),
					},
				}
				list := []</em>ast.Field{
					ctxField,
				}
				ft.Params.List = append(list, ft.Params.Listâ€¦)
			}
		}
	}
}
å¤åˆ¶ä»£ç å°†è¯­æ³•æ ‘è½¬æ¢æˆGoä»£ç 
formatåŒ…ä¸ºæˆ‘ä»¬æä¾›äº†è½¬æ¢å‡½æ•°ï¼Œformat.Nodeä¼šå°†è¯­æ³•æ ‘æŒ‰ç…§gofmtçš„æ ¼å¼è¾“å‡ºï¼š
â€¦
	var output []byte
	buffer := bytes.NewBuffer(output)
	err = format.Node(buffer, fset, f)
	if err != nil {
		log.Fatal(err)
	}
	// è¾“å‡ºGoä»£ç 
	fmt.Println(buffer.String())
â€¦
å¤åˆ¶ä»£ç è¾“å‡ºç»“æœå¦‚ä¸‹ï¼š
package main</p>

<p>import (
        â€œcontextâ€
)</p>

<p>type Foo interface {
        FooA(ctx context.Context, i int)
        FooB(ctx context.Context, j int)
        FooC(ctx context.Context)
}</p>

<p>type Bar interface {
        BarA(ctx context.Context, i int)
        BarB(ctx context.Context)
        BarC(ctx context.Context)
}
å¤åˆ¶ä»£ç å¯ä»¥çœ‹åˆ°æˆ‘ä»¬æ‰€æœ‰çš„æ¥å£æ–¹çš„ç¬¬ä¸€ä¸ªå‚æ•°éƒ½å˜æˆäº†context.Contextã€‚å»ºè®®å°†ç¤ºä¾‹ä¸­çš„è¯­æ³•æ ‘å…ˆæ‰“å°å‡ºæ¥ï¼Œå†å¯¹ç…§ç€ä»£ç çœ‹ï¼Œæ–¹ä¾¿ç†è§£ã€‚
ä¸€äº›å‘ä¸ä¸è¶³
è‡³æ­¤æˆ‘ä»¬å·²ç»å®Œæˆäº†è¯­æ³•æ ‘çš„è§£æï¼Œéå†ï¼Œä¿®æ”¹ä»¥åŠè¾“å‡ºã€‚ä½†ç»†å¿ƒçš„å°ä¼™ä¼´å¯èƒ½å·²ç»å‘ç°ï¼šç¤ºä¾‹ä¸­çš„æ–‡ä»¶å¹¶æ²¡æœ‰å‡ºç°ä¸€è¡Œæ³¨é‡Šã€‚è¿™çš„ç¡®æ˜¯æœ‰æ„ä¸ºä¹‹ï¼Œå¦‚æœæˆ‘ä»¬åŠ ä¸Šæ³¨é‡Šï¼Œä¼šå‘ç°æœ€ç»ˆç”Ÿæˆæ–‡ä»¶çš„æ³¨é‡Šå°±åƒè¿·é€”çš„ç¾”ç¾Šï¼Œå®Œå…¨æ‰¾ä¸åˆ°è‡ªå·±çš„ä½ç½®ã€‚æ¯”å¦‚è¿™æ ·ï¼š
//ä¿®æ”¹å‰
type Foo interface {
	FooA(i int)
	// FooB
	FooB(j int)
	FooC(ctx context.Context)
}</p>

<p>// ä¿®æ”¹å
type Foo interface {
    FooA(ctx context.
            // FooB
            Context, i int)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FooB(ctx context.Context, j int)
FooC(ctx context.Context) } å¤åˆ¶ä»£ç å¯¼è‡´è¿™ç§ç°è±¡çš„åŸå› åœ¨äºï¼šaståŒ…ç”Ÿæˆçš„è¯­æ³•æ ‘ä¸­çš„æ³¨é‡Šæ˜¯"free-floating"çš„ã€‚è¿˜è®°å¾—æ¯ä¸ªnodeéƒ½æœ‰Pos()å’ŒEnd()æ–¹æ³•æ¥æ ‡è¯†å…¶ä½ç½®å—ï¼Ÿå¯¹äºéæ³¨é‡ŠèŠ‚ç‚¹ï¼Œè¯­æ³•æ ‘èƒ½å¤Ÿæ­£ç¡®çš„è°ƒæ•´ä»–ä»¬çš„ä½ç½®ï¼Œä½†å´ä¸èƒ½è‡ªåŠ¨è°ƒæ•´æ³¨é‡ŠèŠ‚ç‚¹çš„ä½ç½®ã€‚å¦‚æœæˆ‘ä»¬æƒ³è¦è®©æ³¨é‡Šå‡ºç°åœ¨æ­£ç¡®çš„ä½ç½®ä¸Šï¼Œæˆ‘ä»¬å¿…é¡»æ‰‹åŠ¨è®¾ç½®èŠ‚ç‚¹Poså’ŒEndã€‚æºç æ³¨é‡Šä¸­æåˆ°äº†è¿™ä¸ªé—®é¢˜ï¼š
</code></pre></div></div>

<p>Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: Except for Doc and Comment comments directly associated with nodes, the remaining comments are â€œfree-floatingâ€ (see also issues #18593, #20744).</p>

<p>issueä¸­æœ‰å…·ä½“çš„è®¨è®ºï¼Œå®˜æ–¹æ‰¿è®¤è¿™æ˜¯ä¸€ä¸ªè®¾è®¡ç¼ºé™·ï¼Œä½†è¿˜æ˜¯è¿Ÿè¿Ÿæœªèƒ½æ”¹è¿›ã€‚å…¶ä¸­æœ‰ä½è¿«ä¸åŠå¾…çš„å°å“¥æä¾›äº†è‡ªå·±çš„æ–¹æ¡ˆï¼š</p>

<p>github.com/dave/dst</p>

<p>å¦‚æœå®åœ¨æ˜¯è¦å¯¹æœ‰æ³¨é‡Šçš„è¯­æ³•æ ‘è¿›è¡Œä¿®æ”¹ï¼Œå¯ä»¥å°è¯•ä¸€ä¸‹ã€‚
è™½ç„¶è¯­æ³•æ ‘çš„ç¡®å­˜åœ¨ä¿®æ”¹å›°éš¾é—®é¢˜ï¼Œä½†å…¶è¿˜æ˜¯èƒ½æ»¡è¶³å¤§éƒ¨åˆ†åŸºäºè¯­æ³•æ ‘åˆ†æçš„ä»£ç ç”Ÿæˆå·¥ä½œäº†(gomock,wireç­‰ç­‰)ã€‚</p>
:ET