I"°B<p>golangä¸­çš„æ¥å£åˆ†ä¸ºå¸¦æ–¹æ³•çš„æ¥å£å’Œç©ºæ¥å£ã€‚ å¸¦æ–¹æ³•çš„æ¥å£åœ¨åº•å±‚ç”¨ifaceè¡¨ç¤ºï¼Œç©ºæ¥å£çš„åº•å±‚åˆ™æ˜¯efaceè¡¨ç¤ºã€‚
<!-- more -->
//runtime/runtime2.go</p>

<p>//éç©ºæ¥å£
type iface struct {
	tab  *itab
	data unsafe.Pointer
}
type itab struct {
	inter  *interfacetype
	_type  *_type
	link   *itab
	hash   uint32 // copy of _type.hash. Used for type switches.
	bad    bool   // type does not implement interface
	inhash bool   // has this itab been added to hash?
	unused [2]byte
	fun    [1]uintptr // variable sized
}</p>

<p>//<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong></p>

<p>//ç©ºæ¥å£
type eface struct {
	_type *_type
	data  unsafe.Pointer
}</p>

<p>//========================
//è¿™ä¸¤ä¸ªæ¥å£å…±åŒçš„å­—æ®µ_type
//========================</p>

<p>//runtime/type.go
type _type struct {
	size       uintptr
	ptrdata    uintptr // size of memory prefix holding all pointers
	hash       uint32
	tflag      tflag
	align      uint8
	fieldalign uint8
	kind       uint8
	alg        *typeAlg
	// gcdata stores the GC type data for the garbage collector.
	// If the KindGCProg bit is set in kind, gcdata is a GC program.
	// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
	gcdata    *byte
	str       nameOff
	ptrToThis typeOff
}
//_typeè¿™ä¸ªç»“æ„ä½“æ˜¯golangå®šä¹‰æ•°æ®ç±»å‹è¦ç”¨çš„ï¼Œè®²åˆ°åå°„æ–‡ç« çš„æ—¶å€™åœ¨å…·ä½“è®²è§£è¿™ä¸ª_typeã€‚
å¤åˆ¶ä»£ç 1.iface
1.1 å˜é‡ç±»å‹æ˜¯å¦‚ä½•è½¬æ¢æˆæ¥å£ç±»å‹çš„ï¼Ÿ
çœ‹ä¸‹æ–¹ä»£ç :
package main
type Person interface {
   run()
}</p>

<p>type xitehip struct {
   age uint8
}
func (o xitehip)run() {
}</p>

<p>func main()  {
   var xh Person = xitehip{age:18}
   xh.run()
}</p>

<p>å¤åˆ¶ä»£ç xhå˜é‡æ˜¯Personæ¥å£ç±»å‹ï¼Œé‚£xitehipçš„structç±»å‹æ˜¯å¦‚ä½•è½¬æ¢æˆæ¥å£ç±»å‹çš„å‘¢ï¼Ÿ
çœ‹ä¸€ä¸‹ç”Ÿæˆçš„æ±‡ç¼–ä»£ç ï¼š
0x001d 00029 (main.go:13)	PCDATA	$2, $0
0x001d 00029 (main.go:13)	PCDATA	$0, $0
0x001d 00029 (main.go:13)	MOVB	$0, â€œâ€..autotmp_1+39(SP)
0x0022 00034 (main.go:13)	MOVB	$18, â€œâ€..autotmp_1+39(SP)
0x0027 00039 (main.go:13)	PCDATA	$2, $1
0x0027 00039 (main.go:13)	LEAQ	go.itab.â€â€œ.xitehip,â€â€œ.Person(SB), AX
0x002e 00046 (main.go:13)	PCDATA	$2, $0
0x002e 00046 (main.go:13)	MOVQ	AX, (SP)
0x0032 00050 (main.go:13)	PCDATA	$2, $1
0x0032 00050 (main.go:13)	LEAQ	â€œâ€..autotmp_1+39(SP), AX
0x0037 00055 (main.go:13)	PCDATA	$2, $0
0x0037 00055 (main.go:13)	MOVQ	AX, 8(SP)
0x003c 00060 (main.go:13)	CALL	runtime.convT2Inoptr(SB)
0x0041 00065 (main.go:13)	MOVQ	16(SP), AX
0x0046 00070 (main.go:13)	PCDATA	$2, $2
0x0046 00070 (main.go:13)	MOVQ	24(SP), CX
å¤åˆ¶ä»£ç ä»æ±‡ç¼–å‘ç°æœ‰ä¸ªè½¬æ¢å‡½æ•°ï¼š
runtime.convT2Inoptr(SB)
æˆ‘ä»¬å»çœ‹ä¸€ä¸‹è¿™ä¸ªå‡½æ•°çš„å®ç°ï¼š
func convT2Inoptr(tab *itab, elem unsafe.Pointer) (i iface) {
        t := tab._type
        if raceenabled {
                raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2Inoptr))
        }
        if msanenabled {
                msanread(elem, t.size)
        }
        x := mallocgc(t.size, t, false)//ä¸ºelemç”³è¯·å†…å­˜
        memmove(x, elem, t.size)//å°†elemæ‰€æŒ‡å‘çš„æ•°æ®èµ‹å€¼åˆ°æ–°çš„å†…å­˜ä¸­
        i.tab = tab //è®¾ç½®ifaceçš„tab
        i.data = x //è®¾ç½®ifaceçš„data
        return
}
å¤åˆ¶ä»£ç ä»ä»¥ä¸Šå®ç°æˆ‘ä»¬å‘ç°ç¼–è¯‘å™¨ç”Ÿæˆçš„structåŸå§‹æ•°æ®ä¼šå¤åˆ¶ä¸€ä»½ï¼Œç„¶åå°†æ–°çš„æ•°æ®åœ°å€èµ‹å€¼ç»™iface.dataä»è€Œç”Ÿæˆäº†å®Œæ•´çš„ifaceï¼Œè¿™æ ·å¦‚ä¸‹åŸå§‹ä»£ç ä¸­çš„xhå°±è½¬æ¢æˆäº†Personæ¥å£ç±»å‹ã€‚
var xh Person = xitehip{age:18}
ç”¨gdbå®é™…è¿è¡Œçœ‹ä¸€ä¸‹</p>

<p>convT2Inoptrå‡½æ•°ä¼ è¿›æ¥çš„å‚æ•°æ˜¯*itabå’Œæºç ä¸­çš„ *xitehipã€‚itabçš„ç±»å‹åŸå‹å’Œå†…å­˜ä¸­çš„æ•°æ®å‘ç°itabç¡®å®æ˜¯runtimeä¸­æºç é‡Œçš„å­—æ®µã€‚æ€»å…±å äº†32ä¸ªå­—èŠ‚ã€‚ï¼ˆ[4]uint8 ä¸å å­—èŠ‚ï¼‰</p>

<p>æ˜¯elemçš„æ•°æ®ä»–æ˜¯ä¸ªåä¸ºxitehipçš„ç»“æ„ä½“ç±»å‹é‡Œé¢å­˜æ”¾çš„æ˜¯age=18ã€‚ å†…å­˜ä¸­çš„0x12æ­£å¥½æ˜¯age=18ã€‚æ³¨æ„æ­¤æ—¶çš„åœ°å€æ˜¯:0xc000032777ã€‚</p>

<p>xhå˜é‡çš„æ•°æ®ç±»å‹å’Œå…¶ä¸­dataå­—æ®µçš„æ•°æ®ã€‚å‘ç°xhç¡®å®æ˜¯ifaceç±»å‹äº†ä¸”xh.dataçš„åœ°å€ä¸æ˜¯ä¸Šé¢æåˆ°çš„0xc000032777 è€Œæ˜¯0xc000014098ï¼Œè¯æ˜æ˜¯å¤åˆ¶äº†ä¸€ä»½xitehipç±»å‹çš„structã€‚</p>

<p>1.2 æŒ‡é’ˆå˜é‡ç±»å‹æ˜¯å¦‚ä½•è½¬æ¢æˆæ¥å£ç±»å‹çš„å‘¢ï¼Ÿ
è¿˜æ˜¯ä¸Šé¢çš„ä¾‹å­åªæ˜¯å°†
var xh Person = xitehip{age:18}
å¤åˆ¶ä»£ç æ¢æˆäº†
var xh Person = &amp;xitehip{age:18}
å¤åˆ¶ä»£ç é‚£æŒ‡é’ˆç±»å‹çš„å˜é‡æ˜¯å¦‚ä½•è½¬æ¢æˆæ¥å£ç±»å‹çš„å‘¢ï¼Ÿ
è§ä¸‹æ–¹æ±‡ç¼–ä»£ç ï¼š
0x001d 00029 (main.go:13)	PCDATA	$2, $1
0x001d 00029 (main.go:13)	PCDATA	$0, $0
0x001d 00029 (main.go:13)	LEAQ	type.â€â€œ.xitehip(SB), AX
0x0024 00036 (main.go:13)	PCDATA	$2, $0
0x0024 00036 (main.go:13)	MOVQ	AX, (SP)
0x0028 00040 (main.go:13)	CALL	runtime.newobject(SB)
0x002d 00045 (main.go:13)	PCDATA	$2, $1
0x002d 00045 (main.go:13)	MOVQ	8(SP), AX
0x0032 00050 (main.go:13)	MOVB	$18, (AX)
å¤åˆ¶ä»£ç å‘ç°äº†è¿™ä¸ªå‡½æ•°ï¼š
runtime.newobject(SB)
å¤åˆ¶ä»£ç å»çœ‹ä¸€ä¸‹å…·ä½“å®ç°ï¼š
// implementation of new builtin
// compiler (both frontend and SSA backend) knows the signature
// of this function
func newobject(typ *_type) unsafe.Pointer {
        return mallocgc(typ.size, typ, true)
}
å¤åˆ¶ä»£ç ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆäº†ifaceå¹¶å°†&amp;xitehip{age:18}åˆ›å»ºçš„å¯¹è±¡çš„åœ°å€ï¼ˆé€šè¿‡newobjectï¼‰èµ‹å€¼ç»™iface.dataã€‚å°±æ˜¯xitehipè¿™ä¸ªç»“æ„ä½“æ²¡æœ‰è¢«å¤åˆ¶ã€‚
ç”¨gdbçœ‹ä¸€ä¸‹</p>

<p>1.3 é‚£xhæ˜¯å¦‚ä½•æ‰¾åˆ°runæ–¹æ³•çš„å‘¢ï¼Ÿ
1.4 æ¥å£è°ƒç”¨è§„åˆ™
æŠŠä¸Šé¢çš„ä¾‹å­æ·»åŠ ä¸€ä¸ªeat()æ¥å£æ–¹æ³•å¹¶å®ç°å®ƒï¼ˆæ³¨æ„è¿™ä¸ªæ¥å£æ–¹æ³•çš„å®ç°çš„æ¥å—è€…æ˜¯æŒ‡é’ˆï¼‰ã€‚
package main
type Person interface {
	run()
	eat(string)
}
type xitehip struct {
	age uint8
}
func (o xitehip)run() { // //æ¥æ”¶æ–¹oæ˜¯å€¼
}
func (o *xitehip)eat(food string) { //æ¥æ”¶æ–¹oæ˜¯æŒ‡é’ˆ
}
func main()  {
	var xh Person = &amp;xitehip{age:18} //xhæ˜¯æŒ‡é’ˆ
	xh.eat(â€œma la xiao long xia!â€)
	xh.run()
}
å¤åˆ¶ä»£ç è¿™ä¸ªä¾‹å­çš„xhå˜é‡çš„å®é™…ç±»å‹æ˜¯ä¸ªæŒ‡é’ˆï¼Œé‚£å®ƒæ˜¯å¦‚ä½•è°ƒç”¨éæŒ‡é’ˆæ–¹æ³•runçš„å‘¢ï¼Ÿ
ç»§ç»­gdbè·Ÿè¸ªä¸€ä¸‹</p>

<p>ç›´æ¥è·Ÿè¸ªxh.tab.funçš„å†…å­˜æ•°æ®å‘ç°eatæ–¹æ³•ç¡®å®åœ¨0x44f940ã€‚ä¸Šé¢å·²ç»è¯´äº†funè¿™ä¸ªæ•°ç»„å¤§å°åªä¸º1é‚£runæ–¹æ³•åº”è¯¥åœ¨eatçš„åé¢ï¼Œä½†æ˜¯gdbæ²¡æœ‰æç¤ºå“ªä¸ªåœ°æ–¹æ˜¯runçš„èµ·å§‹ä½ç½®ã€‚ä¸ºäº†éªŒè¯runå°±åœ¨eatçš„åé¢ï¼Œæˆ‘ç›´æ¥å¾€ä¸‹debugçœ‹eatçš„å…¥å£åœ°å€åœ¨å“ªé‡Œ</p>

<p>æ€»ç»“ï¼ŒæŒ‡é’ˆç±»å‹çš„å¯¹è±¡è°ƒç”¨éæŒ‡é’ˆç±»å‹çš„æ¥æ”¶æ–¹çš„æ–¹æ³•ï¼Œç¼–è¯‘å™¨è‡ªåŠ¨å°†æ¥æ”¶æ–¹è½¬æ¢ä¸ºæŒ‡é’ˆç±»å‹ï¼›è°ƒç”¨æ–¹é€šè¿‡xh.tab.funè¿™ä¸ªæ•°ç»„æ‰¾åˆ°å¯¹åº”çš„æ–¹æ³•æŒ‡ä»¤åˆ—è¡¨ã€‚
é‚£xhæ˜¯å€¼ç±»å‹çš„æ¥å£ï¼Œè€Œæ¥å£å®ç°çš„æ–¹æ³•çš„æ¥æ”¶æ–¹æ˜¯æŒ‡é’ˆç±»å‹ï¼Œé‚£è°ƒç”¨æ–¹å¯ä»¥è°ƒç”¨è¿™ä¸ªæŒ‡é’ˆæ–¹æ³•å—ï¼Œç­”æ¡ˆæ˜¯ä¸ä»…ä¸èƒ½è¿ç¼–è¯‘éƒ½ç¼–è¯‘ä¸è¿‡å»ï¼Œ</p>

<p>è§ä¸‹è¡¨æ€»ç»“ï¼š</p>

<p>è°ƒç”¨æ–¹
æ¥æ”¶æ–¹
èƒ½å¦ç¼–è¯‘</p>

<p>å€¼
å€¼
true</p>

<p>å€¼
æŒ‡é’ˆ
false</p>

<p>æŒ‡é’ˆ
å€¼
true</p>

<p>æŒ‡é’ˆ
æŒ‡é’ˆ
true</p>

<p>æŒ‡é’ˆ
æŒ‡é’ˆå’Œå€¼
true</p>

<p>å€¼
æŒ‡é’ˆå’Œå€¼
false</p>

<p>ä»ä¸Šè¡¨å¯ä»¥å¾—å‡ºå¦‚ä¸‹ç»“è®ºï¼š</p>

<p>è°ƒç”¨æ–¹æ˜¯å€¼æ—¶ï¼Œåªè¦æ¥æ”¶æ–¹æœ‰æŒ‡é’ˆæ–¹æ³•é‚£ç¼–è¯‘å™¨ä¸å…è®¸é€šè¿‡ç¼–è¯‘ã€‚</p>

<p>2 eface
ç©ºæ¥å£ç›¸å¯¹äºéç©ºæ¥å£æ²¡æœ‰äº†æ–¹æ³•åˆ—è¡¨ã€‚
type eface struct {
	_type *_type
	data  unsafe.Pointer
}
å¤åˆ¶ä»£ç ç¬¬ä¸€ä¸ªå±æ€§ç”±itabæ¢æˆäº†_type,è¿™ä¸ªç»“æ„ä½“æ˜¯golangä¸­çš„å˜é‡ç±»å‹çš„åŸºç¡€ï¼Œæ‰€ä»¥ç©ºæ¥å£å¯ä»¥æŒ‡å®šä»»æ„å˜é‡ç±»å‹ã€‚
2.1 ç¤ºä¾‹ï¼š
cpackage main</p>

<p>import â€œfmtâ€</p>

<p>type xitehip struct {
}
func main()  {
	var a interface{} = xitehip{}
	var b interface{} = &amp;xitehip{}
	fmt.Println(a)
	fmt.Println(b)
}
å¤åˆ¶ä»£ç gdbè·Ÿä¸€ä¸‹</p>

<p>2.2æ–­è¨€
åˆ¤æ–­å˜é‡æ•°æ®ç±»å‹
   s, ok := i.(TypeName)
    if ok {
        fmt.Println(s)
    }
å¤åˆ¶ä»£ç å¦‚æœæ²¡æœ‰okçš„è¯ç±»å‹ä¸æ­£ç¡®çš„è¯ä¼šå¼•èµ·panicã€‚
ä¹Ÿå¯ä»¥ç”¨switchå½¢å¼ï¼š
    switch v := v.(type) {
      case TypeName:
    â€¦
    }
å¤åˆ¶ä»£ç 3 æ£€æŸ¥æ¥å£
3.1 åˆ©ç”¨ç¼–è¯‘å™¨æ£€æŸ¥æ¥å£å®ç°
var _ InterfaceName = (*TypeName)(nil)
3.2 nilå’Œnil interface
3.2.1 nil
func main() {
    var i interface{}
    if i == nil {
        println(â€œThe interface is nil.â€œ)
    }
}
(gdb) info locals;
i = {_type = 0x0, data = 0x0}
å¤åˆ¶ä»£ç 3.2.2 å¦‚æœæ¥å£å†…éƒ¨dataå€¼ä¸ºnilï¼Œä½†tabä¸ä¸ºç©ºæ—¶ï¼Œæ­¤æ—¶æ¥å£ä¸ºnil interfaceã€‚
// go:noinline
func main() {
    var o *int = nil
    var i interface{} = o</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if i == nil {
    println("Nil")
}
println(i) }
</code></pre></div></div>

<p>(gdb) info locals;
i = {_type = 0x21432f8 &lt;type.*+36723&gt;, data = 0x0}
o = 0x0
å¤åˆ¶ä»£ç 3.2.3 åˆ©ç”¨åå°„æ£€æŸ¥
  v := reflect.ValueOf(a)
    if v.Isvalid() {
        println(v.IsNil()) // true, This is nil interface
}</p>

<p>ç±»å‹æ–¹æ³• reflect.TypeOf(interface{})
ç¤ºä¾‹1ä»£ç å¦‚ä¸‹å›¾ï¼š</p>

<p>è¾“å‡ºI
å˜é‡xçš„ç±»å‹æ˜¯Iï¼Œé‚£å°†xä¼ å…¥TypeOf()å‡½æ•°ä¹‹å Name()å‡½æ•°æ˜¯å¦‚ä½•è·å–åˆ°å˜é‡xçš„ç±»å‹ä¿¡æ¯çš„å‘¢ï¼Ÿ
æ¥ä¸‹æ¥æˆ‘ä»¬ä¸€æ­¥ä¸€æ­¥åˆ†æï¼Œç¬¬12è¡Œä»£ç çš„Name()å‡½æ•°æ˜¯å¦‚ä½•è·å–åˆ°ç±»å‹Içš„ã€‚
çœ‹ä¸€ä¸‹TypeOf(interface)å‡½æ•°çš„å®ç°ï¼š
func TypeOf(i interface{}) Type {
	eface := <em>(</em>emptyInterface)(unsafe.Pointer(&amp;i))
	return toType(eface.typ)
}
å¤åˆ¶ä»£ç æˆ‘ä»¬å‘ç°TypeOfçš„å‚æ•°æ˜¯æ¥å£ç±»å‹ï¼Œå°±æ˜¯è¯´å˜é‡xçš„å‰¯æœ¬è¢«åŒ…è£…æˆäº†runtime/runtime2.goä¸­å®šä¹‰çš„efaceï¼ˆç©ºæ¥å£ï¼‰ã€‚ç„¶åå°†efaceå¼ºåˆ¶è½¬æ¢æˆäº†emptyInterface,å¦‚ä¸‹æ˜¯reflectå’ŒruntimeåŒ…ä¸‹å®šä¹‰ä¸¤ä¸ªç©ºæ¥å£ï¼š
//reflect/type.go
type emptyInterface struct {
	typ  *rtype
	word unsafe.Pointer
}</p>

<p>//runtime/runtime2.go
type eface struct {
	_type *_type
	data  unsafe.Pointer
}
å¤åˆ¶ä»£ç å‘ç°å’ŒruntimeåŒ…ä¸­çš„ç©ºæ¥å£å¾ˆåƒï¼ŒemptyInterface.word,runtime.efaceå­—æ®µç±»å‹æ˜¯ç›¸åŒçš„ã€‚é‚£å°±çœ‹çœ‹rtypeå’Œ_typeæ˜¯å¦ç›¸åŒå‘¢ï¼Ÿ
//reflect/type.go
type rtype struct {
	size       uintptr
	ptrdata    uintptr  // number of bytes in the type that can contain pointers
	hash       uint32   // hash of type; avoids computation in hash tables
	tflag      tflag    // extra type information flags
	align      uint8    // alignment of variable with this type
	fieldAlign uint8    // alignment of struct field with this type
	kind       uint8    // enumeration for C
	alg        *typeAlg // algorithm table
	gcdata     *byte    // garbage collection data
	str        nameOff  // string form
	ptrToThis  typeOff  // type for pointer to this type, may be zero
}</p>

<p>//runtime/type.go
type _type struct {
	size       uintptr
	ptrdata    uintptr // size of memory prefix holding all pointers
	hash       uint32
	tflag      tflag
	align      uint8
	fieldalign uint8
	kind       uint8
	alg        <em>typeAlg
	// gcdata stores the GC type data for the garbage collector.
	// If the KindGCProg bit is set in kind, gcdata is a GC program.
	// Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
	gcdata    *byte
	str       nameOff
	ptrToThis typeOff
}
å¤åˆ¶ä»£ç å®Œå…¨ä¸€æ ·æ‰€ä»¥å°±å¯ä»¥æ¯«æ— é¡¾è™‘è½¬æ¢äº†ã€‚
ä¹Ÿå°±æ˜¯è¯´emptyInterface.rtypeç»“æ„ä½“é‡Œå·²ç»æœ‰xçš„ç±»å‹ä¿¡æ¯äº†ã€‚æ¥ä¸‹æ¥ç»§ç»­çœ‹Name()å‡½æ•°æ˜¯å¦‚ä½•è·å–åˆ°ç±»å‹çš„å­—ç¬¦ä¸²ä¿¡æ¯çš„ï¼š
Type(interface{})å‡½æ•°é‡Œæœ‰ä¸ªtoType()å‡½æ•°ï¼Œå»çœ‹ä¸€ä¸‹ï¼š
//reflect/type.go
func toType(t *rtype) Type {
	if t == nil {
		return nil
	}
	return t
}
å¤åˆ¶ä»£ç ä¸Šé¢ä»£ç æ˜¯å°†</em>rtypeç›´æ¥è½¬æ¢æˆäº†Typeç±»å‹äº†ï¼Œé‚£Typeç±»å‹æ˜¯å•¥?
//reflect/type.go
type Type interface {
â€¦â€¦
    Name() string
â€¦â€¦
}
å¤åˆ¶ä»£ç å…¶å®Typeæ˜¯ä¸ªæ¥å£ç±»å‹ã€‚
é‚£<em>rtypeè‚¯å®šå®ç°äº†æ­¤æ¥å£ä¸­çš„æ–¹æ³•,å…¶ä¸­å°±åŒ…æ‹¬Name()æ–¹æ³•ã€‚æ‰¾åˆ°äº†Name()çš„å®ç°å‡½æ•°å¦‚ä¸‹ã€‚å¦‚æœä¸å…ˆçœ‹Name()çš„å®ç°,å…¶å®ä¹Ÿèƒ½çŒœåˆ°ï¼šå°±æ˜¯ä»</em>rtypeç±»å‹ä¸­å®šä½æ•°æ®è·å–æ•°æ®å¹¶è¿”å›ç»™è°ƒç”¨è€…çš„è¿‡ç¨‹ï¼Œå› ä¸º<em>rtypeé‡Œé¢æœ‰åŒ…å«å€¼å˜é‡ç±»å‹ç­‰ä¿¡æ¯ã€‚
func (t *rtype) Name() string {
	if t.tflag&amp;tflagNamed == 0 {
		return â€œâ€
	}
	s := t.String()
	i := len(s) - 1
	for i &gt;= 0 {
		if s[i] == â€˜.â€™ {
			break
		}
		iâ€“
	}
	return s[i+1:]
}
å¤åˆ¶ä»£ç é‡ç‚¹çœ‹ä¸€ä¸‹t.String()
func (t *rtype) String() string {
	s := t.nameOff(t.str).name()
	if t.tflag&amp;tflagExtraStar != 0 {
		return s[1:]
	}
	return s
}
å¤åˆ¶ä»£ç å†é‡ç‚¹çœ‹ä¸€ä¸‹nameOff()ï¼š
func (t *rtype) nameOff(off nameOff) name {
	return name{(</em>byte)(resolveNameOff(unsafe.Pointer(t), int32(off)))}
}
å¤åˆ¶ä»£ç ä»åå­—å¯ä»¥çŒœæµ‹å‡ºOffæ˜¯Offsetçš„ç¼©å†™ï¼ˆè¿™ä¸ªå‡½æ•°é‡Œé¢çš„å…·ä½“é€»è¾‘å°±æ¢ç©¶äº†ï¼‰è¿›è¡Œåç§»ä»è€Œå¾—åˆ°å¯¹åº”å†…å­˜åœ°å€çš„å€¼ã€‚
String()å‡½æ•°ä¸­çš„name()å‡½æ•°å¦‚ä¸‹ï¼š</p>

<p>func (n name) name() (s string) {
	if n.bytes == nil {
		return
	}
	b := (*[4]byte)(unsafe.Pointer(n.bytes))</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hdr := (*stringHeader)(unsafe.Pointer(&amp;s))
hdr.Data = unsafe.Pointer(&amp;b[3])
hdr.Len = int(b[1])&lt;&lt;8 | int(b[2])
return s } å¤åˆ¶ä»£ç name()å‡½æ•°çš„é€»è¾‘æ˜¯æ ¹æ®nameOff()è¿”å›çš„*byte(å°±æ˜¯ç±»å‹ä¿¡æ¯çš„é¦–åœ°å€)è®¡ç®—å‡ºå­—ç¬¦ä¸²çš„Dataå’ŒLenä½ç½®ï¼Œç„¶åé€šè¿‡è¿”å›å€¼&amp;såŒ…è£…å‡ºstringHeaderï¼ˆå­—ç¬¦ä¸²åŸå‹ï¼‰å¹¶å°†Dataï¼ŒLenèµ‹å€¼ç»™å­—ç¬¦ä¸²åŸå‹ï¼Œä»è€Œå°†è¿”å›å€¼sèµ‹å€¼ã€‚
</code></pre></div></div>

<p>æ€»ç»“ ï¼š
æ™®é€šçš„å˜é‡  =&gt; åå°„ä¸­Typeç±»å‹ =&gt; è·å–å˜é‡ç±»å‹ä¿¡æ¯ ã€‚</p>

<p>1ï¼Œå˜é‡å‰¯æœ¬åŒ…è£…æˆç©ºæ¥å£runtime.efaceã€‚
2ï¼Œå°†runtime.efaceè½¬æ¢æˆreflat.emptyInterface(ç»“æ„éƒ½ä¸€æ ·)ã€‚
3ï¼Œå°†<em>emptyInterface.rtype è½¬æ¢æˆ reflect.Typeæ¥å£ç±»å‹ï¼ˆåŒ…è£…æˆruntime.ifaceç»“æ„ä½“ç±»å‹ï¼‰ã€‚
4ï¼Œæ¥å£ç±»å‹å˜é‡æ ¹æ®runtime.iface.tab.funæ‰¾åˆ°reflat.Name()å‡½æ•°ã€‚
5ï¼Œreflect.Name()æ ¹æ®</em>rtypeç»“æ„ä½“str(nameoffç±»å‹)æ‰¾åˆ°åç§»é‡ã€‚
6ï¼Œæ ¹æ®åç§»é‡å’ŒåŸºåœ°å€(åŸºåœ°å€æ²¡æœ‰åœ¨*rtypeä¸­ï¼Œè¿™å—å…ˆç•¥è¿‡)ã€‚æ‰¾åˆ°ç±»å‹å†…å­˜å—ã€‚
7ï¼ŒåŒ…è£…æˆstringHeaderç±»å‹è¿”å›ç»™è°ƒç”¨è€…ã€‚
å…¶å®æ ¸å¿ƒå°±æ˜¯å°†runtimeåŒ…ä¸­çš„efaceç»“æ„ä½“æ•°æ®å¤åˆ¶åˆ°reflectåŒ…ä¸­çš„emptyInterfaceä¸­ç„¶ååœ¨ä»é‡Œé¢è·å–ç›¸åº”çš„å€¼ç±»å‹ä¿¡æ¯ã€‚
refact.Typeæ¥å£é‡Œé¢çš„å…¶ä»–æ–¹æ³•å°±ä¸åœ¨åœ¨è¿™é‡Œè¯´äº†ï¼Œæ ¸å¿ƒæ€æƒ³å°±æ˜¯å›´ç»•reflat.emptyInterfaceä¸­çš„æ•°æ®è¿›è¡ŒæŸ¥æ‰¾ç­‰æ“ä½œã€‚
2 å€¼æ–¹æ³• reflect.ValueOf(interface{})
package main
import (
	â€œreflectâ€
	â€œfmtâ€
)
func main() {
	var a = 3
	v := reflect.ValueOf(a)
	i := v.Interface()
	z := i.(int)
	fmt.Println(z)
}
å¤åˆ¶ä»£ç çœ‹ä¸€ä¸‹reflect.ValueOf()å®ç°ï¼š
func ValueOf(i interface{}) Value {
	â€¦.
	return unpackEface(i)
}
å¤åˆ¶ä»£ç è¿”å›å€¼æ˜¯Valueç±»å‹ï¼š
type Value struct {
	typ *rtype
	ptr unsafe.Pointer
	flag //å…ˆå¿½ç•¥
}
å¤åˆ¶ä»£ç Valueæ˜¯ä¸ªç»“æ„ä½“ç±»å‹ï¼ŒåŒ…å«ç€å€¼å˜é‡çš„ç±»å‹å’Œæ•°æ®æŒ‡é’ˆã€‚</p>

<p>func unpackEface(i interface{}) Value {
	e := (*emptyInterface)(unsafe.Pointer(&amp;i))</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>t := e.typ
if t == nil {
	return Value{}
}
f := flag(t.Kind())
if ifaceIndir(t) {
	f |= flagIndir
}
return Value{t, e.word, f} } å¤åˆ¶ä»£ç å…·ä½“å®ç°æ˜¯åœ¨unpackEface(interface{})ä¸­ï¼š
e := (*emptyInterface)(unsafe.Pointer(&amp;i)) å¤åˆ¶ä»£ç å’Œä¸Šé¢ä¸€æ ·ä»*runtime.efaceè½¬æ¢æˆ*reflect.emptyInterfaceäº†ã€‚ æœ€ååŒ…è£…æˆValueï¼š
return Value{t, e.word, f} å¤åˆ¶ä»£ç ç»§ç»­çœ‹ä¸€ä¸‹ç¤ºä¾‹ä»£ç ï¼š
i := v.Interface() å¤åˆ¶ä»£ç çš„å®ç°ï¼š func (v Value) Interface() (i interface{}) {
return valueInterface(v, true) }
</code></pre></div></div>

<p>func valueInterface(v Value, safe bool) interface{} {
	â€¦â€¦
	return packEface(v)
}</p>

<p>func packEface(v Value) interface{} {
	t := v.typ
	var i interface{}
	e := (<em>emptyInterface)(unsafe.Pointer(&amp;i))
	switch {
	case ifaceIndir(t):
		if v.flag&amp;flagIndir == 0 {
			panic(â€œbad indirâ€)
		}
               //å°†å€¼çš„æ•°æ®ä¿¡æ¯æŒ‡é’ˆèµ‹å€¼ç»™ptr
		ptr := v.ptr
		if v.flag&amp;flagAddr != 0 {
			c := unsafe_New(t)
			typedmemmove(t, c, ptr)
			ptr = c
		}
                //ä¸ºç©ºæ¥å£èµ‹å€¼
		e.word = ptr 
	case v.flag&amp;flagIndir != 0:
		e.word = *(</em>unsafe.Pointer)(v.ptr)
	default:
		e.word = v.ptr
	}
        //ä¸ºç©ºæ¥å£èµ‹å€¼
	e.typ = t
	return i
}
å¤åˆ¶ä»£ç æœ€ç»ˆè°ƒç”¨äº†packEface()å‡½æ•°ï¼Œä»å‡½æ•°åå­—é¢æ„æ€ç†è§£æ˜¯æ‰“åŒ…æˆç©ºæ¥å£ã€‚
é€»è¾‘æ˜¯ï¼šä»value.typä¿¡æ¯åŒ…è£…å‡ºreflect.emptyInterfaceç»“æ„ä½“ä¿¡æ¯ï¼Œç„¶åå°†reflect.efaceå†™å…¥iå˜é‡ä¸­ï¼Œåˆå› ä¸ºiæ˜¯interface{}ç±»å‹ï¼Œç¼–è¯‘å™¨åˆä¼šå°†iè½¬æ¢æˆruntime.efaceç±»å‹ã€‚
z := i.(int)
å¤åˆ¶ä»£ç æ ¹æ®å­—é¢é‡intç¼–è¯‘å™¨ä¼šä»runtime.eface._typeä¸­æŸ¥æ‰¾intçš„å€¼æ˜¯å¦åŒ¹é…ï¼Œå¦‚æœä¸åŒ¹é…panicï¼ŒåŒ¹é…içš„å€¼èµ‹å€¼ç»™zã€‚</p>

<p>æ€»ç»“ï¼šä»å€¼å˜é‡ =&gt; valueåå°„å˜é‡ =&gt; æ¥å£å˜é‡ï¼š</p>

<p>1ï¼ŒåŒ…è£…æˆvalueç±»å‹ã€‚
2ï¼Œä»valueç±»å‹ä¸­è·å–rtypeåŒ…è£…æˆreflect.emptyInterfaceç±»å‹ã€‚
3ï¼Œreflect.efaceç¼–è¯‘å™¨è½¬æ¢æˆruntime.efaceç±»å‹ã€‚
4ï¼Œæ ¹æ®ç¨‹åºz :=i(int) ä»runtime.eface._typeä¸­æŸ¥æ‰¾æ˜¯å¦åŒ¹é…ã€‚
5ï¼ŒåŒ¹é…å°†å€¼èµ‹å€¼ç»™å˜é‡zã€‚
æ€»ç»“ï¼šValueåå°„ç±»å‹è½¬interface{}ç±»å‹æ ¸å¿ƒè¿˜æ˜¯reflet.emptyInterfaceä¸runtime.efaceçš„ç›¸äº’è½¬æ¢ã€‚</p>
:ET