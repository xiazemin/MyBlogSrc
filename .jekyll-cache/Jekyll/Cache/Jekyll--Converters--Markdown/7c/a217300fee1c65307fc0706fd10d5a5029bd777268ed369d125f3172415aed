I"îP<p>https://gocn.vip/topics/9921
Go 1.13 ç‰ˆæœ¬ä¸­æœ‰å‡ ä¸ªæ¯”è¾ƒå¤§çš„ä¿®æ”¹ï¼Œå…¶ä¸­ä¹‹ä¸€æ˜¯sync.Poolä¿®æ”¹äº†éƒ¨åˆ†å®ç°ï¼Œå‡å°æŸäº›æç«¯æƒ…å†µä¸‹çš„æ€§èƒ½å¼€é”€ã€‚æ–‡ä¸­å†…å®¹æ¥æºäºç¬”è€…è¯»å®Œ sync.Pool æºä»£ç çš„æ€è€ƒå’Œæ€»ç»“ï¼Œå†…å®¹ä»¥ Go 1.13 ä¸­çš„å®ç°ä¸ºå‡†ï¼Œå°‘é‡å†…å®¹æ¶‰åŠåˆ° Go 1.13 ä¹‹å‰ï¼Œå¦‚æœ‰è¯¯åŒºè¯·è¯»è€…å¤šå¤šæŒ‡æ•™ã€‚</p>

<p>æ¦‚å¿µ
åœ¨æœ¬æ–‡å†…å®¹å¼€å§‹ä¹‹å‰éœ€è¦ç†è§£å‡ ä¸ªåœ¨ Go runtime ä¸­çš„æ¦‚å¿µï¼Œä»¥ä¾¿äºæ›´å¥½çš„ç†è§£sync.Poolä¸­ä¸€äº›å®ç°ã€‚
<!-- more -->
goroutine æŠ¢å 
Go ä¸­è°ƒåº¦å™¨æ˜¯ GMP æ¨¡å‹ï¼Œç®€å•ç†è§£ G å°±æ˜¯ goroutineï¼›M å¯ä»¥ç±»æ¯”å†…æ ¸çº¿ç¨‹ï¼Œæ˜¯æ‰§è¡Œ G çš„åœ°æ–¹ï¼›P æ˜¯è°ƒåº¦ G ä»¥åŠä¸º G çš„æ‰§è¡Œå‡†å¤‡æ‰€éœ€èµ„æºã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼ŒP çš„æ•°é‡ CPU çš„å¯ç”¨æ ¸å¿ƒæ•°ï¼Œä¹Ÿå¯ç”±runtime.GOMAXPROCSæŒ‡å®šã€‚æœ¬æ–‡çš„é‡ç‚¹å¹¶é goroutine è°ƒåº¦å™¨ï¼Œåœ¨æ­¤ä¸åšè¯¦ç»†è§£é‡Šï¼Œæ„Ÿå…´è¶£å¯ä»¥ç¿»é˜…å»¶ä¼¸é˜…è¯»çš„æ–‡ç« ã€‚</p>

<p>Go æœ‰è¿™æ ·çš„è°ƒåº¦è§„åˆ™ï¼šæŸä¸ª G ä¸èƒ½ä¸€ç›´å ç”¨ Mï¼Œåœ¨æŸä¸ªæ—¶åˆ»çš„æ—¶å€™ï¼Œruntimeï¼ˆå‚è§sysmonï¼‰ä¼šåˆ¤æ–­å½“å‰ M æ˜¯å¦å¯ä»¥è¢«æŠ¢å ï¼Œå³ M ä¸Šæ­£åœ¨æ‰§è¡Œçš„ G è®©å‡ºã€‚P åœ¨åˆç†çš„æ—¶åˆ»å°† G è°ƒåº¦åˆ°åˆç†çš„ M ä¸Šæ‰§è¡Œï¼Œåœ¨ runtime é‡Œé¢ï¼Œæ¯ä¸ª P ç»´æŠ¤ä¸€ä¸ªæœ¬åœ°å­˜æ”¾å¾…æ‰§è¡Œ G çš„é˜Ÿåˆ— localqï¼ŒåŒæ—¶è¿˜å­˜åœ¨ä¸€ä¸ªå…¨å±€çš„å¾…æ‰§è¡Œ G çš„é˜Ÿåˆ— globalqï¼›è°ƒåº¦å°±æ˜¯ P ä» localq æˆ– globalq ä¸­å–å‡º G åˆ°å¯¹åº”çš„ M ä¸Šæ‰§è¡Œï¼Œæ‰€è°“æŠ¢å ï¼Œruntime å°† G æŠ¢å ç§»å‡ºè¿è¡ŒçŠ¶æ€ï¼Œæ‹·è´ G çš„æ‰§è¡Œæ ˆæ”¾å…¥å¾…æ‰§è¡Œé˜Ÿåˆ—ä¸­ï¼Œå¯èƒ½æ˜¯æŸä¸ª P çš„ localqï¼Œä¹Ÿå¯èƒ½æ˜¯ globalqï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡è°ƒåº¦ï¼Œå› æ­¤å½“è¢«æŠ¢å çš„ G é‡å›å¾…æ‰§è¡Œé˜Ÿåˆ—æ—¶æœ‰å¯èƒ½æ­¤æ—¶çš„ P ä¸å‰ä¸€æ¬¡è¿è¡Œçš„ P å¹¶éåŒä¸€ä¸ªã€‚</p>

<p>æ‰€è°“ç¦æ­¢æŠ¢å ï¼Œå³å½“å‰æ‰§è¡Œ G ä¸å…è®¸è¢«æŠ¢å è°ƒåº¦ï¼Œç›´åˆ°ç¦æ­¢æŠ¢å æ ‡è®°è§£é™¤ã€‚Go runtime å®ç°äº† G çš„ç¦æ­¢æŠ¢å ä¸è§£é™¤ç¦æ­¢æŠ¢å ã€‚</p>

<p>func runtime_procPin() int
ç¦æ­¢æŠ¢å ï¼Œæ ‡è®°å½“å‰ G åœ¨ M ä¸Šä¸ä¼šè¢«æŠ¢å ï¼Œå¹¶è¿”å›å½“å‰æ‰€åœ¨ P çš„ IDã€‚</p>

<p>func runtime_procUnpin()
è§£é™¤ G çš„ç¦æ­¢æŠ¢å çŠ¶æ€ï¼Œä¹‹å G å¯è¢«æŠ¢å ã€‚</p>

<p>æ•°æ®ç»“æ„
poolDequeue
type poolDequeue struct {
    headTail uint64
    vals []eface
}</p>

<p>type eface struct {
    typ, val unsafe.Pointer
}
poolDequeueè¢«å®ç°ä¸ºå•ç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…çš„å›ºå®šå¤§å°çš„æ— é” Ring å¼é˜Ÿåˆ—ã€‚ç”Ÿäº§è€…å¯ä»¥ä» head æ’å…¥ head åˆ é™¤ï¼Œè€Œæ¶ˆè´¹è€…ä»…å¯ä» tail åˆ é™¤ã€‚headTailæŒ‡å‘äº†é˜Ÿåˆ—çš„å¤´å’Œå°¾ï¼Œé€šè¿‡ä½è¿ç®—å°† head å’Œ tail ä½ç½®å­˜å…¥headTailå˜é‡ä¸­ã€‚</p>

<p>func (d *poolDequeue) pushHead(val interface{}) bool {
    ptrs := atomic.LoadUint64(&amp;d.headTail)
    head, tail := d.unpack(ptrs)
    // Ringå¼é˜Ÿåˆ—ï¼Œå¤´å°¾ç›¸ç­‰åˆ™é˜Ÿåˆ—å·²æ»¡
    if (tail+uint32(len(d.vals)))&amp;(1Â«dequeueBits-1) == head {
        return false
    }
    slot := &amp;d.vals[head&amp;uint32(len(d.vals)-1)]
    // åŸå­æ“ä½œæ‹¿åˆ°slot.typ
    typ := atomic.LoadPointer(&amp;slot.typ)
    if typ != nil {
        return false
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if val == nil {
    val = dequeueNil(nil)
}
// slotå ä½ï¼Œå°†valå­˜å…¥valsä¸­
*(*interface{})(unsafe.Pointer(slot)) = val
// æ›´æ”¹é˜Ÿåˆ—æŒ‡å‘å¤´
atomic.AddUint64(&amp;d.headTail, 1&lt;&lt;dequeueBits)
return true } åœ¨å¤´å…¥æ—¶ï¼Œå…ˆåˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦å·²æ»¡ï¼Œåˆ¤æ–­æ¡ä»¶ï¼šhead == tail ä»é˜Ÿåˆ—ä¸­å–åˆ° head ä½ç½®çš„slotï¼Œæ ¹æ®slot.typåˆ¤æ–­å½“å‰ slot æ˜¯å¦å·²è¢«å­˜æ”¾æ•°æ®ï¼Œæ³¨æ„è¿™é‡Œä½¿ç”¨äº†atomic.LoadPointerå–ä»£é”æ“ä½œã€‚ å°†valèµ‹å€¼ç»™slotï¼Œè¿™é‡Œå®ç°çš„æ¯”è¾ƒå·§å¦™ï¼Œslotæ˜¯efaceç±»å‹ï¼Œå°†slotè½¬ä¸ºinterface{}ç±»å‹ï¼Œè¿™æ ·valèƒ½ä»¥interface{}èµ‹å€¼ç»™slotè®©slot.typå’Œslot.valæŒ‡å‘å…¶å†…å­˜å—ï¼Œè¿™æ ·slot.typå’Œslot.valå‡ä¸ä¸ºç©ºï¼Œè¿™ä¹Ÿå°±æ˜¯ç¬¬ 2 ç‚¹æ¡ä»¶åˆ¤æ–­çš„æ¥ç”±ã€‚æ’å…¥æˆåŠŸå head åŠ  1ï¼ŒæŒ‡å‘é˜Ÿå¤´çš„å‰ä¸€ä¸ªç©ºä½ï¼Œç”±äºæ’å…¥åˆ é™¤éƒ½æ¶‰åŠåˆ°å¯¹headTailçš„ä¿®æ”¹ï¼Œæ­¤å¤„ä½¿ç”¨åŸå­æ“ä½œå–ä»£é”ã€‚ func (d *poolDequeue) popHead() (interface{}, bool) {
var slot *eface
for {
    ptrs := atomic.LoadUint64(&amp;d.headTail)
    head, tail := d.unpack(ptrs)
    // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
    if tail == head {
        return nil, false
    }

    // headä½ç½®æ˜¯é˜Ÿå¤´çš„å‰ä¸€ä¸ªä½ç½®ï¼Œæ‰€ä»¥æ­¤å¤„è¦å…ˆé€€ä¸€ä½
    head--
    ptrs2 := d.pack(head, tail)
    if atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) {
        slot = &amp;d.vals[head&amp;uint32(len(d.vals)-1)]
        break
    }
}

// å–å‡ºval
val := *(*interface{})(unsafe.Pointer(slot))
if val == dequeueNil(nil) {
    val = nil
}

// é‡ç½®slotï¼Œtypå’Œvalå‡ä¸ºnil
*slot = eface{}
return val, true } popHeadçš„ä»£ç æ¯”è¾ƒç®€å•ï¼Œæµç¨‹ä¸Šæ— éå°±æ˜¯åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ç©ºï¼Œæ‹¿å‡ºslotè½¬æ¢ä¸ºinterface{}ç„¶åé‡ç½®slotã€‚popHeadä¸pushHeadæœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„ï¼Œåœ¨popHeadä¸­ï¼Œæ˜¯å…ˆä¿®æ”¹äº†headTailï¼Œç„¶åå†å–slotï¼Œè€Œåœ¨pushHeadä¸­æ˜¯å…ˆæ’å…¥æ•°æ®ï¼Œç„¶åå†ä¿®æ”¹headTailï¼Œè‡³äºä¸ºä»€ä¹ˆè¿™é‡Œå…ˆç•™ä¸€ä¸ªç–‘é—®ï¼Œåé¢å°†ä¼šè¯¦ç»†è§£é‡Šã€‚
</code></pre></div></div>

<p>func (d *poolDequeue) popTail() (interface{}, bool) {
    var slot *eface
    for {
        ptrs := atomic.LoadUint64(&amp;d.headTail)
        head, tail := d.unpack(ptrs)
        // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ç©º
        if tail == head {
            return nil, false
        }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ptrs2 := d.pack(head, tail+1)
    if atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) {
        slot = &amp;d.vals[tail&amp;uint32(len(d.vals)-1)]
        break
    }
}
// å–å‡ºval
val := *(*interface{})(unsafe.Pointer(slot))
if val == dequeueNil(nil) {
    val = nil
}

// é‡ç½®slot.typ
slot.val = nil
atomic.StorePointer(&amp;slot.typ, nil)
return val, true } popTailçš„ä»£ç ç±»ä¼¼popHeadï¼Œåªæ˜¯åˆ é™¤å¯¹è±¡ä»é˜Ÿé¦–å˜æˆé˜Ÿå°¾ï¼Œæ³¨æ„ç»“å°¾éƒ¨åˆ†ä»£ç ï¼Œä½¿ç”¨äº†atomic.StorePointerå–ä»£é”æ“ä½œã€‚
</code></pre></div></div>

<p>poolChain
poolDequeueè¢«å®ç°ä¸º Ring å¼é˜Ÿåˆ—ï¼Œè€ŒpoolChainåˆ™æ˜¯åŸºäºpoolDequeueå®ç°ä¸ºåŒå‘é“¾è¡¨ã€‚</p>

<p>type poolChain struct {
    head *poolChainElt
    tail *poolChainElt
}</p>

<p>type poolChainElt struct {
    poolDequeue
    next, prev *poolChainElt
}
åŒç†ï¼ŒpoolChainä¹Ÿå®ç°äº†pushHeadï¼ŒpopHeadå’ŒpopTailã€‚</p>

<p>func (c *poolChain) pushHead(val interface{}) {
    d := c.head
    if d == nil {
        // poolDequeueåˆå§‹é•¿åº¦ä¸º8
        const initSize = 8 
        d = new(poolChainElt)
        d.vals = make([]eface, initSize)
        c.head = d
        storePoolChainElt(&amp;c.tail, d)
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if d.pushHead(val) {
    return
}
// å‰ä¸€ä¸ªpoolDequeueé•¿åº¦çš„2å€
newSize := len(d.vals) * 2
if newSize &gt;= dequeueLimit {
    newSize = dequeueLimit
}
// é¦–å°¾ç›¸è¿ï¼Œæ„æˆé“¾è¡¨
d2 := &amp;poolChainElt{prev: d}
d2.vals = make([]eface, newSize)
c.head = d2
storePoolChainElt(&amp;d.next, d2)
d2.pushHead(val) } åˆ°è¿™é‡Œå¤§æ¦‚å°±æ˜ç™½äº†ï¼ŒpoolDequeueæ˜¯åœ¨poolChainçš„pushHeadä¸­åˆ›å»ºçš„ï¼Œä¸”æ¯æ¬¡åˆ›å»ºçš„é•¿åº¦éƒ½æ˜¯å‰ä¸€ä¸ªpoolDequeueé•¿åº¦çš„ 2 å€ï¼Œåˆå§‹é•¿åº¦ä¸º 8ã€‚
</code></pre></div></div>

<p>func (c *poolChain) popHead() (interface{}, bool) {
    d := c.head
    for d != nil {
        if val, ok := d.popHead(); ok {
            return val, ok
        }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    d = loadPoolChainElt(&amp;d.prev)
}
return nil, false } popHeadä»¥é˜Ÿé¦–å‘é˜Ÿå°¾ä¸ºæ–¹å‘éå†é“¾è¡¨ï¼Œå¯¹æ¯ä¸ªpoolDequeueæ‰§è¡ŒpopHeadå°è¯•å–å‡ºå­˜æ”¾çš„å¯¹è±¡ã€‚
</code></pre></div></div>

<p>func (c *poolChain) popTail() (interface{}, bool) {
    d := loadPoolChainElt(&amp;c.tail)
    if d == nil {
        return nil, false
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
    d2 := loadPoolChainElt(&amp;d.next)
    if val, ok := d.popTail(); ok {
        return val, ok
    }

    if d2 == nil {
        return nil, false
    }

    if atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) {
        storePoolChainElt(&amp;d2.prev, nil)
    }
    d = d2
} } popTailä»¥é˜Ÿå°¾å‘é˜Ÿé˜Ÿé¦–ä¸ºæ–¹å‘éå†é“¾è¡¨ï¼Œå¯¹æ¯ä¸ªpoolDequeueæ‰§è¡ŒpopTailå°è¯•ä»å°¾éƒ¨å–å‡ºå­˜æ”¾çš„å¯¹è±¡ã€‚
</code></pre></div></div>

<p>å®è§‚ä¸Šæ¥çœ‹ï¼ŒpoolChainçš„ç»“æ„å¦‚ä¸‹å›¾ï¼š</p>

<p>Pool çš„æºä»£ç å®ç°
poolChainä¸º sync.Pool çš„åº•å±‚æ•°æ®ç»“æ„ï¼Œæ¥ä¸‹æ¥ä¸€è§ˆ Pool çš„å®ç°ã€‚</p>

<p>type Pool struct {
    // â€¦
    // æ¯ä¸ªPçš„æœ¬åœ°é˜Ÿåˆ—ï¼Œå®é™…ç±»å‹ä¸º[P]poolLocal
    local     unsafe.Pointer
    // [P]poolLocalçš„å¤§å°ï¼Œ&lt;= P
    localSize uintptr</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>victim     unsafe.Pointer
victimSize uintptr        

// è‡ªå®šä¹‰çš„å¯¹è±¡åˆ›å»ºå›è°ƒï¼Œå½“poolä¸­æ— å¯ç”¨å¯¹è±¡æ—¶ä¼šè°ƒç”¨æ­¤å‡½æ•°
New func() interface{} } type poolLocalInternal struct {
// æ¯ä¸ªPçš„ç§æœ‰å…±äº«ï¼Œä½¿ç”¨æ—¶æ— éœ€åŠ é”
private interface{}
// å¯¹è±¡åˆ—è¡¨ï¼Œæœ¬åœ°På¯ä»¥pushHead/popHeadï¼Œå…¶ä»–Pä»…èƒ½popTail
shared  poolChain }
</code></pre></div></div>

<p>type poolLocal struct {
    poolLocalInternal
    // ä¼ªå…±äº«ï¼Œä»…å ä½ç”¨ï¼Œé˜²æ­¢åœ¨cache lineä¸Šåˆ†é…å¤šä¸ªpoolLocalInternal
    pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte
}
æ¥ä¸‹æ¥çœ‹çœ‹ Pool çš„å…·ä½“å®ç°ã€‚</p>

<p>Pool.Get
func (p <em>Pool) pin() (</em>poolLocal, int) {
    pid := runtime_procPin()
    s := atomic.LoadUintptr(&amp;p.localSize)
    l := p.local                        <br />
    if uintptr(pid) &lt; s {
        return indexLocal(l, pid), pid
    }
    return p.pinSlow()
}
piné¦–å…ˆæ ‡è®°äº†å½“å‰ G ç¦æ­¢æŠ¢å ï¼Œåœ¨runtime_procUnpinä¹‹å‰ï¼Œå½“å‰ G å’Œ P ä¸ä¼šè¢«æŠ¢å ã€‚æ­¤å¤„ä¹‹æ‰€ä»¥æ ‡è®°ç¦æ­¢æŠ¢å æ˜¯å› ä¸ºä¸‹æ–‡ä¸­æœ‰ä½¿ç”¨åˆ° P IDï¼Œå¦‚æœè¢«æŠ¢å äº†ï¼Œæœ‰å¯èƒ½æ¥ä¸‹é‡Œä½¿ç”¨çš„ P ID ä¸æ‰€ç»‘å®šçš„ P å¹¶éåŒä¸€ä¸ªã€‚</p>

<p>åœ¨è·å¾— P ID ä¹‹åï¼Œå½“ P ID å°äºp.localæ•°ç»„é•¿åº¦æ—¶åœ¨p.localæ•°ç»„é‡Œæ‰¾åˆ° P å¯¹åº”çš„poolLocalå¯¹è±¡ï¼Œå¦åˆ™è¿›å…¥pinSlowå‡½æ•°åˆ›å»ºæ–°çš„poolLocalã€‚</p>

<p>func (p <em>Pool) pinSlow() (</em>poolLocal, int) {
    runtime_procUnpin()
    allPoolsMu.Lock()
    defer allPoolsMu.Unlock()
    pid := runtime_procPin()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s := p.localSize
l := p.local
if uintptr(pid) &lt; s {
    return indexLocal(l, pid), pid
}
if p.local == nil {
    allPools = append(allPools, p)
}
// å½“å‰Pçš„æ•°é‡
size := runtime.GOMAXPROCS(0)
local := make([]poolLocal, size)
atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[0])) 
atomic.StoreUintptr(&amp;p.localSize, uintptr(size))         
return &amp;local[pid], pid } pinSlowçš„å®ç°æ¯”è¾ƒç®€å•ï¼Œå³å½“å‰ P ID åœ¨ Pool ä¸­æ²¡æœ‰å¯¹åº”çš„poolLocalå¯¹è±¡æ—¶ï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„poolLocalå¯¹è±¡ï¼Œæ—§çš„poolLocalå°†ä¼šè¿›å…¥ GCã€‚ä»”ç»†è§‚å¯ŸpinSlowå‡½æ•°å‘ç°å…ˆæ‰§è¡Œäº†runtime_procUnpinï¼Œéšåæœ‰æ‰§è¡Œäº†runtime_procPinï¼Œåè€…çš„ç›®çš„åœ¨äºè·å–æœ€æ–°çš„ P IDï¼Œè¿™é‡Œçš„æ„å›¾æœ‰ç‚¹éš¾ä»¥ç†è§£ï¼Œåœ¨ä»”ç»†é˜…è¯»å’Œç†è§£ä¹‹åï¼Œå‘ç°ç›®çš„åœ¨äºå°½é‡å‡å°‘[]poolLocalçš„åˆ›å»ºæ¬¡æ•°ï¼Œå› ä¸ºpinSlowä¹‹å‰å’ŒpinSlowé‡Œé¢å¯èƒ½ä¼šå› ä¸ºè§£é™¤ç¦æ­¢æŠ¢å è€Œå¯¼è‡´ç»‘å®šçš„ P ä¸ä¸€è‡´ï¼Œä¸‡ä¸€æ–°ç»‘å®šçš„ P é‡Œå­˜åœ¨å¯ç”¨çš„poolLocalå‘¢ã€‚
</code></pre></div></div>

<p>func (p *Pool) Get() interface{} {
    // â€¦
    l, pid := p.pin()
    x := l.private
    l.private = nil
    if x == nil {
        x, _ = l.shared.popHead()
        if x == nil {
            x = p.getSlow(pid)
        }
    }
    // è§£é™¤ç¦æ­¢æŠ¢å 
    runtime_procUnpin()
    // â€¦
    if x == nil &amp;&amp; p.New != nil {
        x = p.New()
    }
    return x
}
æ ¹æ®å½“å‰ P å–å¾—å¯¹åº”çš„poolLocalå’Œ P IDã€‚
è‹¥å½“å‰poolLocal.privateä¸ä¸ºç©ºï¼Œåˆ™è¡¨ç¤ºå¯å¤ç”¨æ­¤å¯¹è±¡ï¼›è‹¥ä¸ºç©ºï¼Œåˆ™åœ¨poolLocal.sharedé˜Ÿåˆ—ä¸­è·å–å¯¹è±¡ã€‚
è‹¥poolLocal.sharedæ— å¯ç”¨å¯¹è±¡ï¼Œåˆ™è¿›å…¥getSlowè·å–å¯¹è±¡ã€‚
è‹¥æœªèƒ½ä»å…¶ä»– P æˆåŠŸçªƒå–å¯¹è±¡ï¼Œåˆ™è°ƒç”¨è‡ªå®šä¹‰çš„å¯¹è±¡åˆ›å»ºå‡½æ•°ï¼Œå¦‚æœè¯¥å‡½æ•°ä¸ä¸ºnilã€‚</p>

<p>func (p *Pool) getSlow(pid int) interface{} {
size := atomic.LoadUintptr(&amp;p.localSize) 
locals := p.local                      <br />
// ä»å…¶ä»–Pä¸­çªƒå–å¯¹è±¡
for i := 0; i &lt; int(size); i++ {
    l := indexLocal(locals, (pid+i+1)%int(size))
    if x, _ := l.shared.popTail(); x != nil {
        return x
    }
}</p>

<p>// å°è¯•ä»victim cacheä¸­å–å¯¹è±¡
size = atomic.LoadUintptr(&amp;p.victimSize)
if uintptr(pid) &gt;= size {
    return nil
}
locals = p.victim
l := indexLocal(locals, pid)
if x := l.private; x != nil {
    l.private = nil
    return x
}
for i := 0; i &lt; int(size); i++ {
    l := indexLocal(locals, (pid+i)%int(size))
    if x, _ := l.shared.popTail(); x != nil {
        return x
    }
}</p>

<p>// æ¸…ç©ºvictim cache
atomic.StoreUintptr(&amp;p.victimSize, 0)
return nil
}
è¿›å…¥getSlowçš„å‰ææ˜¯å½“å‰ P æœ¬åœ°æ— å¯ç”¨å¯¹è±¡ï¼Œäºæ˜¯è½¬å¤´å»å…¶ä»– P çš„é‡Œçªƒå–å¯¹è±¡ï¼ŒgetSlowå°±æ˜¯åšè¿™ä»¶äº‹æƒ…ã€‚</p>

<p>éå†Pool.localä¸­çš„å…¶ä»– Pï¼Œç¡®è®¤å…¶ä»– P çš„sharedé‡Œæ˜¯å¦æœ‰å¯ç”¨å¯¹è±¡ï¼Œå¦‚æœæœ‰ï¼Œåˆ™ä»é“¾å°¾å–å‡ºã€‚</p>

<p>å¦‚æœå…¶ä»– P ä¸­ä¹Ÿæ²¡æœ‰å¯ç”¨å¯¹è±¡ï¼Œåˆ™å°è¯•ä» victim cache ä¸­å–å¯ç”¨å¯¹è±¡ï¼Œè‡³äº victim cache æœ¬æ–‡ä¸‹åŠéƒ¨åˆ†å°†ä¼šåšè¯¦ç»†è§£é‡Šã€‚</p>

<p>çºµè§‚æ•´ä¸ª Get è¿‡ç¨‹ä¼šå‘ç°ï¼Œä»å½“å‰ P çš„poolLocalä¸­å–å¯¹è±¡æ—¶ä½¿ç”¨çš„æ—¶popHeadï¼Œè€Œä»å…¶ä»– P çš„poolLocalä¸­çªƒå–å¯¹è±¡æ—¶ä½¿ç”¨çš„æ—¶popTailï¼Œå†å›åˆ°ä¸Šæ–‡ä¸­å¯¹poolChainçš„å®šä¹‰ï¼Œå¯ä»¥çŸ¥é“ï¼Œå½“å‰ P å¯¹æœ¬åœ° poolLocal æ˜¯ç”Ÿäº§è€…ï¼Œå¯¹å…¶ä»– P çš„ poolLocal è€Œè¨€æ˜¯æ¶ˆè´¹è€…ã€‚</p>

<p>å†æ¬¡å›åˆ°poolDequeueå’ŒpoolChainä¸Šã€‚æˆ‘ä»¬çŸ¥é“æŸä¸€æ—¶åˆ» P åªä¼šè°ƒåº¦ä¸€ä¸ª Gï¼Œé‚£ä¹ˆå¯¹äºç”Ÿäº§è€…è€Œè¨€ï¼Œè°ƒç”¨pushHeadå’ŒpopHeadå¹¶ä¸éœ€è¦åŠ é”ï¼Œå› ä¸ºå½“å‰ P æ“ä½œçš„æ˜¯æœ¬åœ°poolLocalï¼›å½“æ¶ˆè´¹è€…æ˜¯å…¶ä»– Pï¼Œåœ¨è¿›è¡ŒpopTailæ“ä½œæ—¶ï¼Œåˆ™ä¼šå¯¹pushHeadä»¥åŠpopHeadå½¢æˆç«äº‰å…³ç³»ï¼Œå¯¹è¿™ç§é—®é¢˜ï¼ŒpoolDequeueçš„å®ç°ç›´æŒ‡è¦å®³ã€‚</p>

<p>é¦–å…ˆæ³¨æ„efaceè¿™ä¸ªç»“æ„ï¼Œè‹¥æ’å…¥æˆåŠŸefaceä¸‹çš„ä¸¤ä¸ªå­—æ®µä¼šæŒ‡å‘è¦ç¼“å­˜å¯¹è±¡çš„å†…å­˜åœ°å€ï¼Œåœ¨pushHeadä¸­ä½¿ç”¨äº†åŸå­æ“ä½œåˆ¤æ–­typå­—æ®µæ˜¯å¦ä¸ºnilï¼Œå­˜åœ¨è¿™æ ·ä¸€ç§å¯èƒ½æ€§ï¼špushHeadæ‰€å–åˆ°çš„slotæ­£åœ¨popTailé‡Œå‡†å¤‡é‡ç½®ï¼Œè¿™ç§æƒ…å†µä¸‹pushHeadä¼šç›´æ¥è¿”å›å¤±è´¥ã€‚</p>

<p>å›åˆ°ç«äº‰é—®é¢˜ä¸Šï¼ŒpushHeadçš„æµç¨‹å¯ä»¥ç®€åŒ–ä¸ºå…ˆå–slotï¼Œå†åˆ¤æ–­æ˜¯å¦å¯æ’å…¥æœ€åä¿®æ”¹headTailï¼Œè€ŒpopTailçš„æµç¨‹å¯ä»¥ç®€åŒ–ä¸ºå…ˆä¿®æ”¹headTailå†å–slotç„¶åé‡ç½®slotï¼ŒpushHeadä¿®æ”¹ head ä½ç½®ï¼ŒpopTailä¿®æ”¹ tail ä½ç½®ï¼Œæ‰€ä»¥å¯¹äºheadTailå­—æ®µä½¿ç”¨åŸå­æ“ä½œé¿å…å³å¯è¯»å†™å†²çªã€‚</p>

<p>ç–‘é—®æ˜¯ä¸ºä½•popTailä¸­éœ€è¦å…ˆä¿®æ”¹headTailå‘¢ï¼Œå› ä¸ºå­˜åœ¨å…¶ä»– P éƒ½ä¼šåˆ°å½“å‰ P ä¸Šçªƒå–å¯¹è±¡ï¼Œå½“å¤šä¸ª P éƒ½è°ƒç”¨æœ¬åœ° P çš„popTailæ—¶ï¼Œç«äº‰ç°è±¡å°±ä¼šæ›´åŠ æ˜æ˜¾ï¼Œæ‰€ä»¥æ­¤æ—¶åº”å°½æ—©ä¿®æ”¹headTailï¼Œä¸€æ—¦æŸä¸ª P çªƒå–åˆ°äº†å…¶ä»– P å°±æ— æ³•å†çªƒå–æ­¤å¯¹è±¡ã€‚</p>

<p>Pool.Put
func (p *Pool) Put(x interface{}) {
    if x == nil {
        return
    }
    // â€¦
    l, _ := p.pin()
    if l.private == nil {
        l.private = x
        x = nil
    }
    if x != nil {
        l.shared.pushHead(x)
    }
    runtime_procUnpin()
    // â€¦
}
Putçš„å®ç°æ¯”è¾ƒç®€å•ï¼Œä¼˜å…ˆå°†å¯¹è±¡å­˜å…¥privateï¼Œè‹¥privateå·²å­˜åœ¨åˆ™æ”¾å…¥ shared é“¾è¡¨ä¸­ï¼Œpinä¸­ä¼šæ ‡è®°ç¦æ­¢æŠ¢å ï¼Œå› æ­¤éœ€è¦åœ¨pinç»“æŸä»¥åŠ Put é€»è¾‘ç»“æŸåå–æ¶ˆç¦æ­¢æŠ¢å ã€‚</p>

<p>Victim Cache
Victim Cache æœ¬æ˜¯è®¡ç®—æœºæ¶æ„é‡Œé¢çš„ä¸€ä¸ªæ¦‚å¿µï¼Œæ˜¯ CPU ç¡¬ä»¶å¤„ç†ç¼“å­˜çš„ä¸€ç§æŠ€æœ¯ï¼Œsync.Poolå¼•å…¥çš„æ„å›¾åœ¨äºé™ä½ GC å‹åŠ›åŒæ—¶æé«˜å‘½ä¸­ç‡ï¼Œæœ¬æ–‡å¹¶ä¸éœ€è¦è¯¦è§£ Victim Cache çš„åŸç†ï¼Œåˆ†æsync.Poolå³å¯æ˜ç™½å…¶æ„å›¾ã€‚å¯¹äº Pool è€Œè¨€æœ‰ä¸€ç‚¹éœ€è¦æ˜ç™½ï¼Œè¿™ä¸ª Pool å¹¶éæ˜¯æ— é™åˆ¶æ‰©å±•çš„ï¼Œå¦åˆ™ä¼šå¼•èµ·å†…å­˜æº¢å‡ºã€‚å‡ ä¹æ‰€æœ‰çš„æ± æŠ€æœ¯ä¸­ï¼Œéƒ½ä¼šåœ¨æŸä¸ªæ—¶åˆ»æ¸…ç©ºæˆ–æ¸…é™¤éƒ¨åˆ†ç¼“å­˜å¯¹è±¡ï¼Œé‚£ä¹ˆåœ¨ Go ä¸­ä½•æ—¶æ¸…ç†æœªä½¿ç”¨çš„å¯¹è±¡å‘¢ï¼Ÿ</p>

<p>åœ¨ Pool.Get å‡½æ•°ä¸­ï¼Œå–ä¸åˆ°å¯¹è±¡æ—¶ä¼šå°è¯•ä»p.victimä¸­å–ï¼Œç”¨å®Œåæ”¾å›å½“å‰ P çš„æœ¬åœ°é˜Ÿåˆ—ï¼Œè€Œp.vcitimæ˜¯ä»€ä¹ˆè¢«åˆ›å»ºçš„å‘¢ï¼Ÿæ˜¯åœ¨poolCleanupå‡½æ•°ä¸­ï¼Œè¯¥å‡½æ•°ä¼šåœ¨ GC æ—¶è¢«è°ƒç”¨åˆ°ï¼Œåœ¨initå‡½æ•°é‡Œæ³¨å†Œã€‚</p>

<p>func poolCleanup() {
    // 1
    for _, p := range oldPools {
        p.victim = nil
        p.victimSize = 0
    }
    // 2
    for _, p := range allPools {
        p.victim = p.local
        p.victimSize = p.localSize
        p.local = nil
        p.localSize = 0
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>oldPools, allPools = allPools, nil } poolCleanupä¼šåœ¨ STW é˜¶æ®µè¢«è°ƒç”¨ï¼Œå‡½æ•°å®ç°è™½ç„¶çœ‹èµ·æ¥ç®€å•ï¼Œä½†å…¶æ„å›¾è¾ƒä¸ºå¤æ‚ï¼Œé‚£ä¹ˆè¯¥å¦‚ä½•è§£é‡Šå‘¢ï¼Ÿ
</code></pre></div></div>

<p>å°è¯•æ¨¡æ‹Ÿä¸€ä¸‹å®é™…æƒ…å†µï¼š</p>

<p>åˆå§‹çŠ¶æ€ä¸‹ï¼ŒoldPoolså’ŒallPoolså‡ä¸ºnil
ç¬¬ 1 æ¬¡è°ƒç”¨ Getï¼Œç”±äºp.localä¸ºnilï¼Œå°†ä¼šåœ¨pinSlowä¸­åˆ›å»ºp.localï¼Œç„¶åå°†pæ”¾å…¥allPoolsï¼Œæ­¤æ—¶allPoolsé•¿åº¦ä¸º 1ï¼ŒoldPoolsä¸ºnil
å¯¹è±¡ä½¿ç”¨å®Œæ¯•ï¼Œç¬¬ 1 æ¬¡è°ƒç”¨ Put æ”¾å›å¯¹è±¡
ç¬¬ 1 æ¬¡ GC STW é˜¶æ®µï¼ŒallPoolsä¸­æ‰€æœ‰p.localå°†å€¼èµ‹å€¼ç»™victimå¹¶ç½®ä¸ºnilï¼Œæœ€åallPoolsä¸ºnilï¼ŒoldPoolsé•¿åº¦ä¸º 1
ç¬¬ 2 æ¬¡è°ƒç”¨ Getï¼Œç”±äºp.localä¸ºnilï¼Œæ­¤æ—¶ä¼šä»p.victimé‡Œé¢å°è¯•å–å¯¹è±¡
å¯¹è±¡ä½¿ç”¨å®Œæ¯•ï¼Œç¬¬ 2 æ¬¡è°ƒç”¨ Put æ”¾å›å¯¹è±¡ï¼Œä½†ç”±äºp.localä¸ºnilï¼Œé‡æ–°åˆ›å»ºp.localï¼Œå¹¶å°†å¯¹è±¡æ”¾å›ï¼Œæ­¤æ—¶allPoolsé•¿åº¦ä¸º 1ï¼ŒoldPoolsé•¿åº¦ä¸º 1
ç¬¬ 2 æ¬¡ GC STW é˜¶æ®µï¼ŒoldPoolsä¸­æ‰€æœ‰p.victimç½®nilï¼Œå‰ä¸€æ¬¡çš„ cache åœ¨æœ¬æ¬¡ GC æ—¶è¢«å›æ”¶ï¼ŒallPoolsæ‰€æœ‰p.localå°†å€¼èµ‹å€¼ç»™victimå¹¶ç½®ä¸ºnilï¼Œæœ€åallPoolsä¸º nilï¼ŒoldPoolsé•¿åº¦ä¸º 1
å†æ¥çœ‹çœ‹ Go 1.13 ä»¥å‰poolCleanupçš„å®ç°ï¼š
func poolCleanup() {
    for i, p := range allPools {
        allPools[i] = nil
        for i := 0; i &lt; int(p.localSize); i++ {
            l := indexLocal(p.local, i)
            l.private = nil
            for j := range l.shared {
                l.shared[j] = nil
            }
            l.shared = nil
        }
        p.local = nil
        p.localSize = 0
    }
    allPools = []*Pool{}
}
Go 1.13 ä»¥å‰poolCleanupçš„å®ç°ç®€å•ç²—æš´ï¼Œæ¯æ¬¡ GC STW é˜¶æ®µéå†allPoolsï¼Œæ¸…ç©ºp.localã€poolLocal.sharedã€‚</p>

<p>é€šè¿‡ä¸¤è€…çš„å¯¹æ¯”å‘ç°ï¼Œæ–°ç‰ˆçš„å®ç°ç›¸æ¯” Go 1.13 ä¹‹å‰ï¼ŒGC çš„ç²’åº¦æ‹‰å¤§äº†ï¼Œç”±äºå®é™…å›æ”¶çš„æ—¶é—´çº¿æ‹‰é•¿ï¼Œå•ä½æ—¶é—´å†… GC çš„å¼€é”€å‡å°ã€‚</p>

<p>ç”±æ­¤åŸºæœ¬æ˜ç™½p.victimçš„ä½œç”¨ï¼Œå®ƒçš„å®šä½æ˜¯æ¬¡çº§ç¼“å­˜ï¼ŒGC æ—¶å°†å¯¹è±¡æ”¾å…¥å…¶ä¸­ï¼Œä¸‹ä¸€æ¬¡ GC æ¥ä¸´ä¹‹å‰å¦‚æœæœ‰ Get è°ƒç”¨åˆ™ä¼šä»p.victimä¸­å–ï¼Œç›´åˆ°å†ä¸€æ¬¡ GC æ¥ä¸´åšå›æ”¶ï¼ŒåŒæ—¶ç”±äºä»p.victimä¸­å–å‡ºå¯¹è±¡ä½¿ç”¨å®Œæ¯•ä¹‹åå¹¶æœªæ”¾å›p.victimä¸­ï¼Œåœ¨ä¸€å®šç¨‹åº¦ä¹Ÿå‡å°äº†ä¸‹ä¸€æ¬¡ GC çš„å¼€é”€ã€‚åŸæ¥ 1 æ¬¡ GC çš„å¼€é”€è¢«æ‹‰é•¿åˆ° 2 æ¬¡ä¸”ä¼šæœ‰ä¸€å®šç¨‹åº¦çš„å¼€é”€å‡å°ï¼Œè¿™å°±æ˜¯p.victimå¼•å…¥çš„æ„å›¾ã€‚</p>

<p>å…³äº Victim Cache æ›´å¤šçš„ä¿¡æ¯å¯ä»¥åœ¨å»¶ä¼¸é˜…è¯»ä¸­æ‰¾åˆ°ã€‚</p>

<p>sync.Pool çš„è®¾è®¡ç†å¿µ
æ— é”
æ— é”ç¼–ç¨‹æ˜¯å¾ˆå¤šç¼–ç¨‹è¯­è¨€é‡Œé€ƒç¦»ä¸äº†çš„è¯é¢˜ã€‚sync.Poolçš„æ— é”æ˜¯åœ¨poolDequeueå’ŒpoolChainå±‚é¢å®ç°çš„ã€‚</p>

<p>æ“ä½œå¯¹è±¡éš”ç¦»
çºµè§‚æ•´ä¸ªsync.Poolçš„å®ç°ï¼Œæ˜ç¡®äº†ç”Ÿäº§è€…ï¼ˆæœ¬åœ° Pï¼‰è®¿é—® headï¼Œæ¶ˆè´¹è€…ï¼ˆå…¶ä»– Pï¼‰è®¿é—® tailï¼Œä» P çš„è§’åº¦åˆ‡å…¥æ“ä½œæ–¹å‘ï¼Œå®ç°äº†ç›®æ ‡æ“ä½œå¯¹è±¡å±‚é¢çš„ â€œè§£è€¦â€ï¼Œå¤§éƒ¨åˆ†æ—¶å€™ä¸¤è€…çš„æ“ä½œäº’ä¸å½±å“ã€‚å›¾æ–‡ç¤ºæ„å¦‚ä¸‹ï¼š</p>

<p>åŸå­æ“ä½œä»£æ›¿é”
poolDequeueå¯¹ä¸€äº›å…³é”®å˜é‡é‡‡ç”¨äº† CAS æ“ä½œï¼Œæ¯”å¦‚poolDequeue.headTailï¼Œæ—¢å¯å®Œæ•´ä¿è¯å¹¶å‘åˆèƒ½é™ä½ç›¸æ¯”é”è€Œè¨€çš„å¼€é”€ã€‚</p>

<p>è¡Œä¸ºéš”ç¦»â€”â€”é“¾è¡¨
è¿™ç‚¹ä¸ â€œæ“ä½œå¯¹è±¡éš”ç¦»â€ æ˜¯ç›¸è¾…ç›¸æˆçš„ï¼Œä¸€æ—¦è®¾è®¡ç›®æ ‡ä¸ºå°½é‡å‡å°‘å¯¹åŒä¸€å¯¹è±¡çš„æ“ä½œé”ï¼Œå°±éœ€è¦å¯¹è¡Œä¸ºè¿›è¡Œéš”ç¦»ï¼Œé“¾è¡¨èƒ½å¾ˆå¥½çš„æ»¡è¶³è¿™ä¸ªè®¾è®¡ç›®æ ‡ï¼šç‰¹å®šçš„ P è®¿é—®ç‰¹å®šçš„ä½ç½®ã€‚ä»æ•´ä¸ªè¿‡ç¨‹æ¥çœ‹ï¼Œé“¾è¡¨æ˜¯å‡å°‘é”çš„é«˜æ•ˆæ•°æ®ç»“æ„ã€‚</p>

<p>Victim Cache é™ä½ GC å¼€é”€
GC çš„å¼€é”€å·²ç»è¶³å¤Ÿè¶³å¤Ÿå°äº†ï¼Œä½†ä»ä¸å¯é¿å…ã€‚å¯¹äºsync.Poolè€Œè¨€ï¼Œé¿å…æç«¯æƒ…å†µ GC çš„å¼€é”€ä¹Ÿæ˜¯é‡ç‚¹ä¹‹ä¸€ï¼Œæ‰€ä»¥ Go 1.13 çš„sync.Poolå¼•å…¥äº† Victim Cache æœºåˆ¶ï¼Œæœ‰æ•ˆæ‹‰é•¿çœŸæ­£å›æ”¶çš„æ—¶é—´çº¿ï¼Œä»è€Œå‡å°å•æ¬¡ GC çš„å¼€é”€ã€‚</p>

<p>å»¶ä¼¸é˜…è¯»
High Performance Cache Architecture Using Victim Cache
Go: Understand the Design of Sync.Pool
ä¹Ÿè°ˆ Goroutine è°ƒåº¦å™¨
Goroutine è°ƒåº¦å®ä¾‹ç®€è¦åˆ†æ</p>

<p>https://gocn.vip/topics/9921</p>
:ET