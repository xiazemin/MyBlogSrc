I"¼<p>Linuxçš„ç”¨Cåº“çš„éƒ½æ˜¯glibcï¼Œæœ‰ä¸€ä¸ªå«libc.so.6çš„æ–‡ä»¶ï¼Œè¿™æ˜¯å‡ ä¹æ‰€æœ‰Linuxä¸‹å‘½ä»¤çš„åŠ¨æ€é“¾æ¥ä¸­ï¼Œå…¶ä¸­æœ‰æ ‡å‡†Cçš„å„ç§å‡½æ•°ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼Œlinuxæ‰€ç¼–è¯‘çš„ç¨‹åºä¸­å¯¹æ ‡å‡†Cå‡½æ•°çš„é“¾æ¥ï¼Œéƒ½æ˜¯é€šè¿‡åŠ¨æ€é“¾æ¥æ–¹å¼æ¥é“¾æ¥libc.so.6è¿™ä¸ªå‡½æ•°åº“çš„ã€‚è¿™ä¹Ÿæ„å‘³ç€æˆ‘ä»¬åœ¨é€šè¿‡æˆ‘ä»¬æ³¨å…¥çš„.soæ¥å®ç°å‡½æ•°è¦†ç›–åŠ«æŒä¹‹åéœ€è¦ä»libc.so.6ä¸­å–å¾—åŸæœ¬çš„æ­£å¸¸å‡½æ•°ï¼Œè®©ç¨‹åºç»§ç»­æ­£å¸¸æ‰§è¡Œ
<!-- more -->
#include <stdio.h>
#include <string.h></string.h></stdio.h></p>

<p>int main(int argc, char *argv[])
{
  if( strcmp(argv[1], â€œtestâ€) )
  {
    printf(â€œIncorrect password\nâ€);
  }
  else
  {
    printf(â€œCorrect password\nâ€);
  }
  return 0;
}</p>

<p>ç”¨äºåŠ«æŒå‡½æ•°çš„.soä»£ç hook.c</p>

<p>#include <stdio.h>
#include <string.h>
#include <dlfcn.h>
/*
hookçš„ç›®æ ‡æ˜¯strcmpï¼Œæ‰€ä»¥typedefäº†ä¸€ä¸ªSTRCMPå‡½æ•°æŒ‡é’ˆ
hookçš„ç›®çš„æ˜¯è¦æ§åˆ¶å‡½æ•°è¡Œä¸ºï¼Œä»åŸåº“libc.so.6ä¸­æ‹¿åˆ°strcmpæŒ‡é’ˆï¼Œä¿å­˜æˆold_strcmpä»¥å¤‡è°ƒç”¨
*/
typedef int(*STRCMP)(const char*, const char*);</dlfcn.h></string.h></stdio.h></p>

<p>int strcmp(const char *s1, const char *s2)
{
  static void *handle = NULL;
  static STRCMP old_strcmp = NULL;</p>

<p>if( !handle )
  {
    handle = dlopen(â€œlibc.so.6â€, RTLD_LAZY);
    old_strcmp = (STRCMP)dlsym(handle, â€œstrcmpâ€);
  }
  printf(â€œoops!!! hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;\nâ€, s1, s2);
  return old_strcmp(s1, s2);
}
ç¼–è¯‘ï¼š</p>

<p>gcc -o test main.c
gcc -fPIC -shared -o hook.so hook.c -ldl
è¿è¡Œ:</p>

<p>LD_PRELOAD=./hook.so ./test 123</p>

<p>The Mac OS X operating system has a similar capability using its dylib (dynamically linked/loaded libraries) format which is handled through Mac OS Xâ€™s dynamic linker - dyld. Instead of using the LD_PRELOAD environment variable, Mac OS X uses the following in a Terminal window:</p>

<p>set env DYLD_INSERT_LIBRARIES /usr/lib/libMallocDebug.dylib</p>

<p>https://blog.csdn.net/lionzl/article/details/51372011</p>

<p>æœ‰æ—¶å€™æˆ‘ä»¬åˆ†æ/é€†å‘ELFæ–‡ä»¶æ—¶ï¼Œå¯èƒ½æƒ³ç›´æ¥è¿è¡ŒELFçœ‹çœ‹æ•ˆæœï¼ŒåŒæ—¶åˆæƒ³æ•è·ELFæ–‡ä»¶ç”¨äº†å“ªäº›å­—ç¬¦ä¸²ã€å›è¿åœ°å€&amp;ç«¯å£ã€æ“ä½œäº†å“ªäº›æ–‡ä»¶ç­‰ç­‰ç‰¹å¾ä¿¡æ¯ã€‚è¿™æ—¶æˆ‘ä»¬å¯ä»¥å·§å¦™çš„å€Ÿç”¨LD_PRELOADï¼Œæ¥å®ç°ä¸€ç§ç®€æ˜“çš„hook libcåº“å‡½æ•°æ–¹æ¡ˆæ¥æ‰“å°æˆ‘ä»¬æƒ³è¦çš„ç‰¹å¾ä¿¡æ¯ã€‚</p>

<p>å½“ç„¶æˆ‘ä»¬è¿˜å¯ä»¥ç”¨APK/ELFæ²™ç®±ã€HOOKç­‰æ–¹å¼æ•è·æ›´åŠ è¯¦ç»†çš„ä¿¡æ¯ï¼Œæˆ‘ä»¬è¿™é‡Œä¸è®¨è®ºï¼Œåªå°±LD_PRELOADæ¥ç®€å•ä»‹ç»ã€‚</p>

<p>äºŒã€LD_PRELOADä»‹ç»
å®ƒå…è®¸ä½ å®šä¹‰åœ¨ç¨‹åºè¿è¡Œå‰ä¼˜å…ˆåŠ è½½çš„åŠ¨æ€é“¾æ¥åº“ï¼Œç”¨äºæœ‰é€‰æ‹©æ€§çš„è½½å…¥ä¸åŒåŠ¨æ€é“¾æ¥åº“ä¸­çš„ç›¸åŒå‡½æ•°ã€‚ä½¿ç”¨è¿™ä¸ªç¯å¢ƒå˜é‡ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨ä¸»ç¨‹åºå’Œå…¶åŠ¨æ€é“¾æ¥åº“çš„ä¸­é—´åŠ è½½åˆ«çš„åŠ¨æ€é“¾æ¥åº“ï¼Œç”šè‡³è¦†ç›–æ­£å¸¸çš„å‡½æ•°åº“ï¼ˆé‡å†™ï¼‰</p>

<p>ä¸‰ã€ç®€æ˜“æ–¹æ¡ˆ
1ï¼šåˆå§‹åŒ–</p>

<p>åœ¨åˆå§‹åŒ–é˜¶æ®µï¼Œä¸»è¦å·¥ä½œï¼šè·å–åŸå§‹ç›®æ ‡å‡½æ•°åœ°å€ã€è·å–é…ç½®æ–‡ä»¶ä¿¡æ¯ç­‰ã€‚è®¾ç½®_main()ä¸ºæ„é€ å‡½æ•°ï¼Œä¼˜äºå…¶å®ƒå‡½æ•°ä¹‹å‰æ‰§è¡Œ</p>

<p>// .init
<strong>attribute</strong>((constructor))
void _main()
{
    init();
}
æ¥ç€ï¼Œç”¨dlsymè·å–ç›®æ ‡libcå‡½æ•°åŸå§‹åœ°å€ã€‚</p>

<p>typedef int (*PFN_connect)(int, const struct sockaddr *, socklen_t);</p>

<p>#define ADDFUNC( FUNCTYPE, SYMBOL ) (FUNCTYPE)getFuncAddr(SYMBOL)</p>

<p>void <em>LibcHelper::getFuncAddr( const char</em>  symbol ) 
{
    if ( symbol == NULL ) {
        return NULL;
    }
    void * handle = dlsym( libcHandle, symbol );
    if ( handle == NULL ) {
        LOGPRINT( â€œ[-]dlsym fail: â€œ, â€œ.sâ€, symbol );
    }
    return handle;
}</p>

<p>int LibcHelper::init()
{
    libcHandle = dlopen( â€œ/system/lib/libc.soâ€, RTLD_NOW|RTLD_GLOBAL );
    if ( !libcHandle ) {
        LOGPRINT( â€œLoad libc fail.â€);
        return -1;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pfnConnect = ADDFUNC(PFN_connect, "connect" );              
return 0; } 2ï¼šå®ç°hookå‡½æ•°
</code></pre></div></div>

<p>è¿™æ˜¯hookå‡½æ•°çš„ä¸»ä½“éƒ¨åˆ†ï¼Œå®ç°ä¸€ä¸ªè·Ÿlibcå¯¼å‡ºå‡½æ•°ä¸€è‡´çš„å‡½æ•°ã€‚</p>

<p>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {
    LOGFUNC();
    // è·å–åŸconnectåœ°å€
    PFN_connect org_connect = LibcHelper::getInstance().getConnect();
    if ( org_connect != NULL ) {
        // å…ˆè°ƒç”¨åŸconnectå‡½æ•°
        int ret = org_connect( sockfd, addr, addrlen );
        struct sockaddr_in *addr_in = (struct sockaddr_in *)addr;
        std::ostringstream s;
        if ( addr_in-&gt;sin_family == 1 ) {
            struct sockaddr_un *sun = (struct sockaddr_un *)addr;
            s Â«Â â€œunix://â€ Â«Â sun-&gt;sun_path;
        }
        else {
            s Â«Â â€œip://â€ Â«Â inet_ntoa(addr_in-&gt;sin_addr) Â«Â â€:â€ Â«Â ntohs(addr_in-&gt;sin_port);
        }
        // è¿‡æ»¤æ— æ•ˆç›®æ ‡ï¼Œåªå¯¹ç‰¹å®šè¿›ç¨‹è¾“å‡ºæ—¥å¿—
        if ( CheckUtils::checkShowInfo() ) {
            // è®°å½•åˆ°æ—¥å¿—æ–‡ä»¶ä¸­
            LOGPRINT( â€œconnectâ€,
                â€œsockfdâ€, sockfd,
                â€œaddrâ€, addr,
                â€œaddrlenâ€, addrlen,
                ret );
        }
        return ret;
    }
    LOGPRINT( â€œconnect failâ€);
    return -1;
}
3ï¼šæµ‹è¯•</p>

<p>è®¾ç½®LD_PRELOADç¯å¢ƒå˜é‡çš„å€¼ä¸ºæˆ‘ä»¬çš„soæ–‡ä»¶</p>

<p>adb push libcc.so /data/local/tmp
export LD_PRELOAD=/data/local/tmp/libcc.so
1
2
åœ¨è¿™ä¸ªshellä¸­æ‰§è¡Œç›®æ ‡ELFæ–‡ä»¶ï¼ŒæŸ¥çœ‹æ—¥å¿—æ–‡ä»¶å³å¯è·å–è¯¦ç»†ä¿¡æ¯</p>

<p>å››ã€é—®é¢˜
1ï¼šè¿™ç§æ–¹æ³•æš‚æ—¶ä¸èƒ½ç›´æ¥é€‚ç”¨äºé™æ€ç¼–è¯‘çš„ELFæ–‡ä»¶</p>

<p>ä¸€ä¸ªideaï¼šå‚è€ƒIDAè¯†åˆ«é™æ€å‡½æ•°çš„æ–¹å¼ ä¸çŸ¥æ˜¯å¦å¯è¡Œï¼Ÿ
2ï¼šåƒåœ¾ä¿¡æ¯å¤ªå¤šï¼Œéœ€è¦è¿‡æ»¤</p>

<p>åªå¯¹ç‰¹å®šçš„è¿›ç¨‹ï¼ˆprocess nameï¼‰ã€è·¯å¾„ç­‰æ‰è¾“å‡ºåˆ°æ—¥å¿—æ–‡ä»¶</p>
:ET