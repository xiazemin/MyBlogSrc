I"•3<p>https://github.com/codegangsta/inject
ä¾èµ–æ³¨å…¥æ˜¯ä¸€ä¸ªä¸šç•Œæ ‡å‡†æŠ€æœ¯ï¼Œç”¨äºè§£å†³å¤æ‚åº”ç”¨çŠ¶æ€ä¸‹æ¨¡å—ä¹‹é—´ä¾èµ–çš„é—®é¢˜ã€‚æœ‰äº†ä¾èµ–æ³¨å…¥ï¼Œä¸éœ€è¦å†å†™å¾ˆå¤šæŒ‰ç…§ä¾èµ–é¡ºåºè€Œç¼–å†™çš„åˆå§‹åŒ–ä»£ç ã€‚åœ¨æ²¡æœ‰ä½¿ç”¨ä¾èµ–æ³¨å…¥çš„å‰æä¸‹ï¼Œåœ¨å‡çº§é‡æ„ä¸€ä¸ªæ¨¡å—çš„æ—¶å€™æ˜¯ç›¸å½“ç—›è‹¦çš„ï¼Œå› ä¸ºè¿™æ„å‘³ç€éœ€è¦åœ¨é¡¹ç›®ä¾èµ–å›¾é‡Œé¢æŠŠæ‰€æœ‰è¯¥æ¨¡å—æ¶‰åŠçš„ä¸€æ•´å¥—ä¾èµ–å…³ç³»é‡æ–°æ„å»ºã€‚ç®€è€Œè¨€ä¹‹ï¼Œä¾èµ–æ³¨å…¥ä¸»è¦ç›®çš„åªæœ‰ä¸€ä¸ªï¼šæ—¨åœ¨ç®€åŒ–åˆå§‹åŒ–ä»£ç çš„ç®¡ç†ã€‚</p>

<p>goè¯­è¨€ç¤¾åŒºæœ‰å¾ˆå¤šä¾èµ–æ³¨å…¥çš„æ¡†æ¶ï¼Œå¯ä»¥åˆ†ä¸ºä¸¤ä¸ªç±»åˆ«ï¼š</p>

<p>ä¾èµ–åå°„å®ç°çš„è¿è¡Œæ—¶ä¾èµ–æ³¨å…¥</p>

<p>ä½¿ç”¨ä»£ç ç”Ÿæˆå®ç°çš„ä¾èµ–æ³¨å…¥</p>

<p>ä¾èµ–åå°„å®ç°çš„è¿è¡Œæ—¶ä¾èµ–æ³¨å…¥
è¿è¡Œæ—¶ä¾èµ–æ³¨å…¥ç›®å‰ä½¿ç”¨æ¯”è¾ƒå¹¿æ³›çš„ä¸»è¦æœ‰ï¼šfacebook injectã€uber digã€‚
https://github.com/facebookarchive/inject
https://github.com/uber-go/dig
<!-- more -->
ä¾èµ–æ³¨å…¥(Dependency Injection)å’Œæ§åˆ¶åè½¬(Inversion of Control)æ˜¯åŒä¸€ä¸ªæ¦‚å¿µã€‚åœ¨ä¼ ç»Ÿçš„ç¨‹åºè®¾è®¡è¿‡ç¨‹ä¸­ï¼Œè°ƒç”¨è€…æ˜¯è‡ªå·±æ¥å†³å®šä½¿ç”¨å“ªäº›è¢«è°ƒç”¨è€…å®ç°çš„ã€‚ä½†æ˜¯åœ¨ä¾èµ–æ³¨å…¥æ¨¡å¼ä¸­ï¼Œåˆ›å»ºè¢«è°ƒç”¨è€…çš„å·¥ä½œä¸å†ç”±è°ƒç”¨è€…æ¥å®Œæˆï¼Œå› æ­¤ç§°ä¸ºæ§åˆ¶åè½¬ï¼›åˆ›å»ºè¢«è°ƒç”¨è€…å®ä¾‹çš„å·¥ä½œé€šå¸¸ç”±æ³¨å…¥å™¨æ¥å®Œæˆï¼Œç„¶åæ³¨å…¥è°ƒç”¨è€…ï¼Œå› æ­¤ä¹Ÿç§°ä¸ºä¾èµ–æ³¨å…¥ã€‚</p>

<p>inject æ˜¯ä¾èµ–æ³¨å…¥çš„golangå®ç°ï¼Œä½œè€…æ˜¯ codegangsta ã€‚å®ƒèƒ½åœ¨è¿è¡Œæ—¶æ³¨å…¥å‚æ•°ï¼Œè°ƒç”¨æ–¹æ³•ã€‚æ˜¯Martiniæ¡†æ¶çš„åŸºç¡€æ ¸å¿ƒã€‚</p>

<p>æˆ‘å¯¹ä¾èµ–æ³¨å…¥æå–äº†ä»¥ä¸‹2ç‚¹æ€§è´¨ï¼š</p>

<p>ç”±æ³¨å…¥å™¨æ³¨å…¥å±æ€§ã€‚</p>

<p>ç”±æ³¨å…¥å™¨åˆ›å»ºè¢«è°ƒç”¨è€…å®ä¾‹ã€‚</p>

<p>åœ¨injectä¸­ï¼Œè¢«è°ƒç”¨è€…ä¸ºfuncï¼Œå› æ­¤æ³¨å…¥å±æ€§ä¹Ÿå³å¯¹funcæ³¨å…¥å®å‚(å½“ç„¶injectä¹Ÿå¯ä»¥æ³¨å…¥structï¼Œè¿™æ ·çš„è¯æ³¨å…¥çš„å±æ€§å°±æ˜¯structä¸­çš„å·²æ·»åŠ tagä¸º<code class="language-plaintext highlighter-rouge">inject</code>çš„å¯¼å‡ºå­—æ®µ)ã€‚æˆ‘ä»¬æ¥çœ‹ä¸‹æ™®é€šçš„å‡½æ•°è°ƒç”¨ï¼š</p>

<p>package main</p>

<p>import (
	â€œfmtâ€
)</p>

<p>func Say(name, gender string, age int) {
	fmt.Printf(â€œMy name is %s, gender is %s, age is %d!\nâ€, name, gender, age)
}</p>

<p>func main() {
	Say(â€œé™ˆä¸€å›â€, â€œç”·â€, 20)
}
ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œå®šä¹‰äº†å‡½æ•°Sayå¹¶åœ¨mainæ–¹æ³•ä¸­æ‰‹åŠ¨è°ƒç”¨ã€‚è¿™æ ·æ€»æ˜¯å¯è¡Œçš„ï¼Œä½†æ˜¯æœ‰æ—¶å€™æˆ‘ä»¬ä¸å¾—ä¸é¢å¯¹è¿™æ ·ä¸€ç§æƒ…å†µï¼šæ¯”å¦‚åœ¨webå¼€å‘ä¸­ï¼Œæˆ‘ä»¬æ³¨å†Œè·¯ç”±ï¼ŒæœåŠ¡å™¨æ¥å—è¯·æ±‚ï¼Œç„¶åæ ¹æ®request pathè°ƒç”¨ç›¸åº”çš„handlerã€‚è¿™ä¸ªhandlerå¿…ç„¶ä¸æ˜¯ç”±æˆ‘ä»¬æ‰‹åŠ¨æ¥è°ƒç”¨çš„ï¼Œè€Œæ˜¯ç”±æœåŠ¡å™¨ç«¯æ ¹æ®è·¯ç”±åŒ¹é…æ¥æŸ¥æ‰¾å¯¹åº”çš„handlerå¹¶è‡ªåŠ¨è°ƒç”¨ã€‚</p>

<p>æ˜¯æ—¶å€™å¼•å…¥injectäº†ï¼Œå°è¯•ç”¨injectæ”¹å†™ä¸Šé¢çš„ä»£ç ï¼š</p>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œgithub.com/codegangsta/injectâ€
)</p>

<p>type SpecialString interface{}</p>

<p>func Say(name string, gender SpecialString, age int) {
	fmt.Printf(â€œMy name is %s, gender is %s, age is %d!\nâ€, name, gender, age)
}</p>

<p>func main() {
	inj := inject.New()
	inj.Map(â€œé™ˆä¸€å›â€)
	inj.MapTo(â€œç”·â€, (*SpecialString)(nil))
	inj.Map(20)
	inj.Invoke(Say)
}
$ cd $GOPATH/src/injector_test
$ go build
$ ./injector_test
My name is é™ˆä¸€å›, gender is ç”·, age is 20!
çœ‹ä¸æ‡‚ï¼Ÿæ²¡å…³ç³»ï¼Œå› ä¸ºæˆ‘ä»¬å¯¹äºinjectè¿˜æ²¡æœ‰è¶³å¤Ÿçš„çŸ¥è¯†å‚¨å¤‡ï¼Œä¸€åˆ‡ä»åˆ†æinjectçš„æºç å¼€å§‹ã€‚</p>

<p>injectåŒ…åªæœ‰2ä¸ªæ–‡ä»¶ï¼Œä¸€ä¸ªæ˜¯inject.goæ–‡ä»¶ï¼Œè¿˜æœ‰ä¸€ä¸ªæ˜¯inject_test.goï¼Œä½†æˆ‘ä»¬åªå…³æ³¨inject.goæ–‡ä»¶ã€‚</p>

<p>inject.goçŸ­å°ç²¾æ‚ï¼ŒåŒ…æ‹¬æ³¨é‡Šå’Œç©ºè¡Œæ‰157è¡Œã€‚å®šä¹‰äº†4ä¸ªæ¥å£ï¼ŒåŒ…æ‹¬ä¸€ä¸ªçˆ¶æ¥å£å’Œä¸‰ä¸ªå­æ¥å£ï¼Œæ¥ä¸‹æ¥æ‚¨å°±ä¼šçŸ¥é“è¿™æ ·å®šä¹‰çš„å¥½å¤„äº†ã€‚</p>

<p>ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘æŠŠæ‰€æœ‰çš„æ³¨é‡Šéƒ½å»æ‰äº†ï¼š</p>

<p>type Injector interface {
	Applicator
	Invoker
	TypeMapper
	SetParent(Injector)
}</p>

<p>type Applicator interface {
	Apply(interface{}) error
}</p>

<p>type Invoker interface {
	Invoke(interface{}) ([]reflect.Value, error)
}</p>

<p>type TypeMapper interface {
	Map(interface{}) TypeMapper
	MapTo(interface{}, interface{}) TypeMapper
	Get(reflect.Type) reflect.Value
}
æ¥å£Injectoræ˜¯æ¥å£Applicatorã€æ¥å£Invokerã€æ¥å£TypeMapperçš„çˆ¶æ¥å£ï¼Œæ‰€ä»¥å®ç°äº†Injectoræ¥å£çš„ç±»å‹ï¼Œä¹Ÿå¿…ç„¶å®ç°äº†Applicatoræ¥å£ã€Invokeræ¥å£å’ŒTypeMapperæ¥å£ã€‚</p>

<p>Applicatoræ¥å£åªè§„å®šäº†Applyæˆå‘˜ï¼Œå®ƒç”¨äºæ³¨å…¥structã€‚</p>

<p>Invokeræ¥å£åªè§„å®šäº†Invokeæˆå‘˜ï¼Œå®ƒç”¨äºæ‰§è¡Œè¢«è°ƒç”¨è€…ã€‚</p>

<p>TypeMapperæ¥å£è§„å®šäº†ä¸‰ä¸ªæˆå‘˜ï¼ŒMapå’ŒMapToéƒ½ç”¨äºæ³¨å…¥å‚æ•°ï¼Œä½†å®ƒä»¬æœ‰ä¸åŒçš„ç”¨æ³•ã€‚Getç”¨äºè°ƒç”¨æ—¶è·å–è¢«æ³¨å…¥çš„å‚æ•°ã€‚</p>

<p>å¦å¤–Injectorè¿˜è§„å®šäº†SetParentè¡Œä¸ºï¼Œå®ƒç”¨äºè®¾ç½®çˆ¶Injectorï¼Œå…¶å®å®ƒç›¸å½“äºæŸ¥æ‰¾ç»§æ‰¿ã€‚ä¹Ÿå³é€šè¿‡Getæ–¹æ³•åœ¨è·å–è¢«æ³¨å…¥å‚æ•°æ—¶ä¼šä¸€ç›´è¿½æº¯åˆ°parentï¼Œè¿™æ˜¯ä¸ªé€’å½’è¿‡ç¨‹ï¼Œç›´åˆ°æŸ¥æ‰¾åˆ°å‚æ•°æˆ–ä¸ºnilç»ˆæ­¢ã€‚</p>

<p>type injector struct {
	values map[reflect.Type]reflect.Value
	parent Injector
}</p>

<p>func InterfaceOf(value interface{}) reflect.Type {
	t := reflect.TypeOf(value)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for t.Kind() == reflect.Ptr {
	t = t.Elem()
}

if t.Kind() != reflect.Interface {
	panic("Called inject.InterfaceOf with a value that is not a pointer to an interface. (*MyInterface)(nil)")
}

return t }
</code></pre></div></div>

<p>func New() Injector {
	return &amp;injector{
		values: make(map[reflect.Type]reflect.Value),
	}
}
injectoræ˜¯injectåŒ…ä¸­å”¯ä¸€å®šä¹‰çš„structï¼Œæ‰€æœ‰çš„æ“ä½œéƒ½æ˜¯åŸºäºinjector structæ¥è¿›è¡Œçš„ã€‚å®ƒæœ‰ä¸¤ä¸ªæˆå‘˜valueså’Œparentã€‚valuesç”¨äºä¿å­˜æ³¨å…¥çš„å‚æ•°ï¼Œå®ƒæ˜¯ä¸€ä¸ªç”¨reflect.Typeå½“é”®ã€reflect.Valueä¸ºå€¼çš„mapï¼Œè¿™ä¸ªå¾ˆé‡è¦ï¼Œç†è§£è¿™ç‚¹å°†æœ‰åŠ©äºç†è§£Mapå’ŒMapToã€‚Newæ–¹æ³•ç”¨äºåˆå§‹åŒ–injector structï¼Œå¹¶è¿”å›ä¸€ä¸ªæŒ‡å‘injector structçš„æŒ‡é’ˆã€‚ä½†æ˜¯è¯·æ³¨æ„è¿™ä¸ªè¿”å›å€¼è¢«Injectoræ¥å£åŒ…è£…äº†ã€‚</p>

<p>InterfaceOfæ–¹æ³•è™½ç„¶åªæœ‰å‡ å¥å®ç°ä»£ç ï¼Œä½†å®ƒæ˜¯Injectorçš„æ ¸å¿ƒã€‚InterfaceOfæ–¹æ³•çš„å‚æ•°å¿…é¡»æ˜¯ä¸€ä¸ªæ¥å£ç±»å‹çš„æŒ‡é’ˆï¼Œå¦‚æœä¸æ˜¯åˆ™å¼•å‘panicã€‚InterfaceOfæ–¹æ³•çš„è¿”å›ç±»å‹æ˜¯reflect.Typeï¼Œæ‚¨åº”è¯¥è¿˜è®°å¾—injectorçš„æˆå‘˜valueså°±æ˜¯ä¸€ä¸ªreflect.Typeç±»å‹å½“é”®çš„mapã€‚è¿™ä¸ªæ–¹æ³•çš„ä½œç”¨å…¶å®åªæ˜¯è·å–å‚æ•°çš„ç±»å‹ï¼Œè€Œä¸å…³å¿ƒå®ƒçš„å€¼ã€‚æˆ‘ä¹‹å‰æœ‰ç¯‡æ–‡ç« ä»‹ç»è¿‡(*interface{})(nil)ï¼Œæ„Ÿå…´è¶£çš„æœ‹å‹å¯ä»¥å»çœ‹çœ‹ï¼šgolang: è¯¦è§£interfaceå’Œnil ã€‚</p>

<p>ä¸ºäº†åŠ æ·±ç†è§£ï¼Œæ¥ä¸¾ä¸ªä¾‹å­ï¼š</p>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œgithub.com/codegangsta/injectâ€
)</p>

<p>type SpecialString interface{}</p>

<p>func main() {
	fmt.Println(inject.InterfaceOf((<em>interface{})(nil)))
	fmt.Println(inject.InterfaceOf((</em>SpecialString)(nil)))
}
$ cd $GOPATH/src/injector_test
$ go build
$ ./injector_test
interface {}
main.SpecialString
ä¸Šé¢çš„è¾“å‡ºä¸€ç‚¹ä¹Ÿä¸å¥‡æ€ªã€‚InterfaceOfæ–¹æ³•å°±æ˜¯ç”¨æ¥å¾—åˆ°å‚æ•°ç±»å‹ï¼Œè€Œä¸å…³å¿ƒå®ƒå…·ä½“å­˜å‚¨çš„æ˜¯ä»€ä¹ˆå€¼ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œæˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªSpecialStringæ¥å£ã€‚æˆ‘ä»¬åœ¨ä¹‹å‰çš„ä»£ç ä¹Ÿæœ‰å®šä¹‰SpecialStringæ¥å£ï¼Œç”¨åœ¨Sayæ–¹æ³•çš„å‚æ•°å£°æ˜ä¸­ï¼Œä¹‹åæ‚¨å°±ä¼šçŸ¥é“ä¸ºä»€ä¹ˆè¦è¿™ä¹ˆåšã€‚å½“ç„¶æ‚¨ä¸ä¸€å®šéå¾—å‘½åä¸ºSpecialStringã€‚</p>

<p>func (i *injector) Map(val interface{}) TypeMapper {
	i.values[reflect.TypeOf(val)] = reflect.ValueOf(val)
	return i
}</p>

<p>func (i *injector) MapTo(val interface{}, ifacePtr interface{}) TypeMapper {
	i.values[InterfaceOf(ifacePtr)] = reflect.ValueOf(val)
	return i
}</p>

<p>func (i *injector) Get(t reflect.Type) reflect.Value {
	val := i.values[t]
	if !val.IsValid() &amp;&amp; i.parent != nil {
		val = i.parent.Get(t)
	}
	return val
}</p>

<p>func (i *injector) SetParent(parent Injector) {
	i.parent = parent
}
Mapå’ŒMapToæ–¹æ³•éƒ½ç”¨äºæ³¨å…¥å‚æ•°ï¼Œä¿å­˜äºinjectorçš„æˆå‘˜valuesä¸­ã€‚è¿™ä¸¤ä¸ªæ–¹æ³•çš„åŠŸèƒ½å®Œå…¨ç›¸åŒï¼Œå”¯ä¸€çš„åŒºåˆ«å°±æ˜¯Mapæ–¹æ³•ç”¨å‚æ•°å€¼æœ¬èº«çš„ç±»å‹å½“é”®ï¼Œè€ŒMapToæ–¹æ³•æœ‰ä¸€ä¸ªé¢å¤–çš„å‚æ•°å¯ä»¥æŒ‡å®šç‰¹å®šçš„ç±»å‹å½“é”®ã€‚ä½†æ˜¯MapToæ–¹æ³•çš„ç¬¬äºŒä¸ªå‚æ•°ifacePtrå¿…é¡»æ˜¯æ¥å£æŒ‡é’ˆç±»å‹ï¼Œå› ä¸ºæœ€ç»ˆifacePträ¼šä½œä¸ºInterfaceOfæ–¹æ³•çš„å‚æ•°ã€‚</p>

<p>ä¸ºä»€ä¹ˆéœ€è¦æœ‰MapToæ–¹æ³•ï¼Ÿå› ä¸ºæ³¨å…¥çš„å‚æ•°æ˜¯å­˜å‚¨åœ¨ä¸€ä¸ªä»¥ç±»å‹ä¸ºé”®çš„mapä¸­ï¼Œå¯æƒ³è€ŒçŸ¥ï¼Œå½“ä¸€ä¸ªå‡½æ•°ä¸­æœ‰ä¸€ä¸ªä»¥ä¸Šçš„å‚æ•°çš„ç±»å‹æ˜¯ä¸€æ ·æ—¶ï¼Œåæ‰§è¡ŒMapè¿›è¡Œæ³¨å…¥çš„å‚æ•°å°†ä¼šè¦†ç›–å‰ä¸€ä¸ªé€šè¿‡Mapæ³¨å…¥çš„å‚æ•°ã€‚</p>

<p>SetParentæ–¹æ³•ç”¨äºç»™æŸä¸ªInjectoræŒ‡å®šçˆ¶Injectorã€‚Getæ–¹æ³•é€šè¿‡reflect.Typeä»injectorçš„valuesæˆå‘˜ä¸­å–å‡ºå¯¹åº”çš„å€¼ï¼Œå®ƒå¯èƒ½ä¼šæ£€æŸ¥æ˜¯å¦è®¾ç½®äº†parentï¼Œç›´åˆ°æ‰¾åˆ°æˆ–è¿”å›æ— æ•ˆçš„å€¼ï¼Œæœ€åGetæ–¹æ³•çš„è¿”å›å€¼ä¼šç»è¿‡IsValidæ–¹æ³•çš„æ ¡éªŒã€‚ä¸¾ä¸ªä¾‹å­æ¥åŠ æ·±ç†è§£ï¼š</p>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œgithub.com/codegangsta/injectâ€
	â€œreflectâ€
)</p>

<p>type SpecialString interface{}</p>

<p>func main() {
	inj := inject.New()
	inj.Map(â€œé™ˆä¸€å›â€)
	inj.MapTo(â€œç”·â€, (<em>SpecialString)(nil))
	inj.Map(20)
	fmt.Println(â€œstring is valid?â€, inj.Get(reflect.TypeOf(â€œå§“é™ˆåä¸€å›â€)).IsValid())
	fmt.Println(â€œSpecialString is valid?â€, inj.Get(inject.InterfaceOf((</em>SpecialString)(nil))).IsValid())
	fmt.Println(â€œint is valid?â€, inj.Get(reflect.TypeOf(18)).IsValid())
	fmt.Println(â€œ[]byte is valid?â€, inj.Get(reflect.TypeOf([]byte(â€œGolangâ€))).IsValid())
	inj2 := inject.New()
	inj2.Map([]byte(â€œtestâ€))
	inj.SetParent(inj2)
	fmt.Println(â€œ[]byte is valid?â€, inj.Get(reflect.TypeOf([]byte(â€œGolangâ€))).IsValid())
}
$ cd $GOPATH/src/injector_test
$ go build
$ ./injector_test
string is valid? true
SpecialString is valid? true
int is valid? true
[]byte is valid? false
[]byte is valid? true
é€šè¿‡ä»¥ä¸Šä¾‹å­åº”è¯¥çŸ¥é“SetParentæ˜¯ä»€ä¹ˆæ ·çš„è¡Œä¸ºã€‚æ˜¯ä¸æ˜¯å¾ˆåƒé¢å‘å¯¹è±¡ä¸­çš„æŸ¥æ‰¾é“¾ï¼Ÿ</p>

<p>func (inj *injector) Invoke(f interface{}) ([]reflect.Value, error) {
	t := reflect.TypeOf(f)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var in = make([]reflect.Value, t.NumIn()) //Panic if t is not kind of Func
for i := 0; i &lt; t.NumIn(); i++ {
	argType := t.In(i)
	val := inj.Get(argType)
	if !val.IsValid() {
		return nil, fmt.Errorf("Value not found for type %v", argType)
	}

	in[i] = val
}

return reflect.ValueOf(f).Call(in), nil } Invokeæ–¹æ³•ç”¨äºåŠ¨æ€æ‰§è¡Œå‡½æ•°ï¼Œå½“ç„¶æ‰§è¡Œå‰å¯ä»¥é€šè¿‡Mapæˆ–MapToæ¥æ³¨å…¥å‚æ•°ï¼Œå› ä¸ºé€šè¿‡Invokeæ‰§è¡Œçš„å‡½æ•°ä¼šå–å‡ºå·²æ³¨å…¥çš„å‚æ•°ï¼Œç„¶åé€šè¿‡reflectåŒ…ä¸­çš„Callæ–¹æ³•æ¥è°ƒç”¨ã€‚Invokeæ¥æ”¶çš„å‚æ•°fæ˜¯ä¸€ä¸ªæ¥å£ç±»å‹ï¼Œä½†æ˜¯fçš„åº•å±‚ç±»å‹å¿…é¡»ä¸ºfuncï¼Œå¦åˆ™ä¼španicã€‚
</code></pre></div></div>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œgithub.com/codegangsta/injectâ€
)</p>

<p>type SpecialString interface{}</p>

<p>func Say(name string, gender SpecialString, age int) {
	fmt.Printf(â€œMy name is %s, gender is %s, age is %d!\nâ€, name, gender, age)
}</p>

<p>func main() {
	inj := inject.New()
	inj.Map(â€œé™ˆä¸€å›â€)
	inj.MapTo(â€œç”·â€, (*SpecialString)(nil))
	inj2 := inject.New()
	inj2.Map(20)
	inj.SetParent(inj2)
	inj.Invoke(Say)
}
ä¸Šé¢çš„ä¾‹å­å¦‚æœæ²¡æœ‰å®šä¹‰SpecialStringæ¥å£ä½œä¸ºgenderå‚æ•°çš„ç±»å‹ï¼Œè€ŒæŠŠnameå’Œgenderéƒ½å®šä¹‰ä¸ºstringç±»å‹ï¼Œé‚£ä¹ˆgenderä¼šè¦†ç›–nameçš„å€¼ã€‚å¦‚æœæ‚¨è¿˜æ²¡æœ‰æ˜ç™½ï¼Œå»ºè®®æ‚¨æŠŠè¿™ç¯‡æ–‡ç« ä»å¤´åˆ°å°¾å†çœ‹å‡ éã€‚</p>

<p>func (inj *injector) Apply(val interface{}) error {
	v := reflect.ValueOf(val)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for v.Kind() == reflect.Ptr {
	v = v.Elem()
}

if v.Kind() != reflect.Struct {
	return nil
}

t := v.Type()

for i := 0; i &lt; v.NumField(); i++ {
	f := v.Field(i)
	structField := t.Field(i)
	if f.CanSet() &amp;&amp; structField.Tag == "inject" {
		ft := f.Type()
		v := inj.Get(ft)
		if !v.IsValid() {
			return fmt.Errorf("Value not found for type %v", ft)
		}

		f.Set(v)
	}

}

return nil } Applyæ–¹æ³•æ˜¯ç”¨äºå¯¹structçš„å­—æ®µè¿›è¡Œæ³¨å…¥ï¼Œå‚æ•°ä¸ºæŒ‡å‘åº•å±‚ç±»å‹ä¸ºç»“æ„ä½“çš„æŒ‡é’ˆã€‚å¯æ³¨å…¥çš„å‰ææ˜¯ï¼šå­—æ®µå¿…é¡»æ˜¯å¯¼å‡ºçš„(ä¹Ÿå³å­—æ®µåä»¥å¤§å†™å­—æ¯å¼€å¤´)ï¼Œå¹¶ä¸”æ­¤å­—æ®µçš„tagè®¾ç½®ä¸º`inject`ã€‚ä»¥ä¾‹å­æ¥è¯´æ˜ï¼š
</code></pre></div></div>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œgithub.com/codegangsta/injectâ€
)</p>

<p>type SpecialString interface{}
type TestStruct struct {
	Name   string <code class="language-plaintext highlighter-rouge">inject</code>
	Nick   []byte
	Gender SpecialString <code class="language-plaintext highlighter-rouge">inject</code>
	uid    int           <code class="language-plaintext highlighter-rouge">inject</code>
	Age    int           <code class="language-plaintext highlighter-rouge">inject</code>
}</p>

<p>func main() {
	s := TestStruct{}
	inj := inject.New()
	inj.Map(â€œé™ˆä¸€å›â€)
	inj.MapTo(â€œç”·â€, (*SpecialString)(nil))
	inj2 := inject.New()
	inj2.Map(20)
	inj.SetParent(inj2)
	inj.Apply(&amp;s)
	fmt.Println(â€œs.Name =â€, s.Name)
	fmt.Println(â€œs.Gender =â€, s.Gender)
	fmt.Println(â€œs.Age =â€, s.Age)
}
$ cd $GOPATH/src/injector_test
$ go build
$ ./injector_test
s.Name = é™ˆä¸€å›
s.Gender = ç”·
s.Age = 20</p>
:ET