I"'<p>You need to loop over each of the elements in the slice and test. Equality for slices is not defined. However, there is a bytes.Equal function if you are comparing values of type []byte.</p>

<p>func testEq(a, b []Type) bool {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// If one is nil, the other must also be nil.
if (a == nil) != (b == nil) { 
    return false; 
}

if len(a) != len(b) {
    return false
}

for i := range a {
    if a[i] != b[i] {
        return false
    }
}

return true }
</code></pre></div></div>

<!-- more -->
<p>åœ¨ Golang ä¸­ sliceã€mapã€channel éƒ½æ˜¯å¼•ç”¨ç±»å‹ï¼Œå› ä¸ºæ˜¯å¼•ç”¨ç±»å‹ï¼Œæ‰€ä»¥ slice å’Œ map ä¸èƒ½ä½¿ç”¨ == è¿›è¡Œæ¯”è¾ƒè¿™é‡Œè¿˜èƒ½ç†è§£ï¼Œå¯æ˜¯ä¸ºä»€ä¹ˆ channel å¯ä»¥ç”¨ == è¿›è¡Œæ¯”è¾ƒå‘¢ï¼Ÿï¼Ÿ</p>

<p>å¦‚ä¸‹ä»£ç </p>

<p>package main</p>

<p>import â€œfmtâ€
import _ â€œreflectâ€</p>

<p>func main() {
    ch1 := make(chan int)
    ch2 := make(chan int)
    fmt.Println(ch1 == ch2)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s1 := []int{1,2}
s2 := []int{2,1}
fmt.Println(s1 == s2)

m1 := make(map[int]int)
m2 := make(map[int]int)
fmt.Println(m1 == m2) } è¾“å‡ºç»“æœä¸º
</code></pre></div></div>

<h1 id="command-line-arguments">command-line-arguments</h1>
<p>./gotest.go:13:20: invalid operation: s1 == s2 (slice can only be compared to nil)
./gotest.go:17:20: invalid operation: m1 == m2 (map can only be compared to nil)
ä»£ç ä¸­ï¼Œslice å’Œ map ä½¿ç”¨ == è¿›è¡Œæ¯”è¾ƒéƒ½æŠ¥é”™äº†ï¼Œä¸ºä»€ä¹ˆ channel æ²¡æœ‰å‘¢ï¼Ÿï¼Ÿï¼Ÿ</p>

<p>C++çš„æ€ç»´çœ‹ï¼Œå¤§æ¦‚æ˜¯ channel å®ç°äº†å¯¹==çš„é‡è½½ï¼Œè€Œ slice å’Œ map æ²¡å®ç°</p>

<p>go çš„ = æ“ä½œï¼Œå°±æ˜¯ç®€å•çš„å†…å­˜æ¯”è¾ƒ</p>

<p>slice çš„å†…å­˜ä¸è¿ç»­ï¼Œslice header å’Œ data åˆ†å¼€æ”¾çš„ï¼Œæ‰€ä»¥ä¸èƒ½æ¯”è¾ƒ</p>

<p>map çš„å†…å­˜ä¸è¿ç»­ï¼Œbucket æ˜¯åˆ†å¼€æ”¾çš„ï¼Œæ‰€ä»¥ä¸èƒ½æ¯”è¾ƒ</p>

<p>chan çš„å†…å­˜æ˜¯è¿ç»­çš„ï¼Œå°±ä¸€ä¸ªå¯¹è±¡ï¼Œæ‰€ä»¥å¯ä»¥æ¯”è¾ƒ</p>

<p>åœ¨ Go ä¸­ï¼Œslice/map/function å€¼ä¸èƒ½æ¯”è¾ƒçš„åŸå› æ˜¯ç¨‹åºå‘˜è¿™äº›å€¼çš„æ¯”è¾ƒè§„åˆ™æœ‰ç€ä¸åŒçš„çœ‹æ³•ï¼Œæ‰€ä»¥å¹²è„†ç¦æ­¢è¿™äº›å€¼çš„æ¯”è¾ƒï¼Œä»¥é˜²æ­¢å¼•èµ·å›°æƒ‘ã€‚</p>

<p>æ¯”å¦‚ï¼Œå¯¹äº mapï¼Œæœ‰äº›äººè®¤ä¸ºä¸¤ä¸ªå¼•ç”¨ç€åŒä¸€ä¸ªåº•å±‚å“ˆå¸Œè¡¨çš„ maps ç›¸ç­‰ï¼Œæœ‰çš„äººåˆ™è®¤ä¸ºè¿™æ ·ä¸¤è€…ä¸­å­˜å‚¨çš„é”®å€¼å¯¹å®Œå…¨ä¸€è‡´ï¼Œåˆ™ä¸¤è€…ç›¸åŒã€‚å¯¹äºè¿™ç¬¬äºŒç§ç†è§£ï¼Œå¾ˆéš¾å¤„ç†å«æœ‰ NaN é”®å€¼çš„ mapsã€‚</p>

<p>å¯¹äº sliceï¼Œæœ‰äº›äººè®¤ä¸ºä¸¤è€…çš„é•¿åº¦å’Œåº•å±‚å…ƒç´ æŒ‡é’ˆç›¸åŒåˆ™ç›¸ç­‰ï¼Œæœ‰äº›äººè®¤ä¸ºä¸¤è€…çš„é•¿åº¦ /å®¹é‡å’Œåº•å±‚å…ƒç´ æŒ‡é’ˆå¿…é¡»éƒ½ç›¸ç­‰ï¼Œæœ‰äº›äººè®¤ä¸ºåº•å±‚å…ƒç´ æŒ‡é’ˆä¸å¿…ç›¸ç­‰ï¼Œåªè¦å®ƒä»¬å¯¹åº”çš„å…ƒç´ ä¸€ä¸€ç›¸ç­‰å³å¯ã€‚</p>

<p>å› ä¸º Go ä¸­çš„å‡½æ•°å‡å¯ä»¥çœ‹ä½œé—­åŒ…ï¼Œè¿™å¯¼è‡´äº†å¾ˆå¤šäººå¯¹å‡½æ•°ç›¸ç­‰æœ‰ä¸åŒçš„ç†è§£ã€‚æœ‰äº›äººè®¤ä¸ºä¸¤ä¸ªå‡½æ•°çš„åº•å±‚æŒ‡é’ˆç›¸ç­‰å³ç›¸ç­‰ï¼Œæœ‰äº›äººè®¤ä¸ºä¸¤è€…å†…éƒ¨çš„ä»£ç å®ç°ç›¸ç­‰å³ç›¸ç­‰ï¼Œæœ‰äº›äººè®¤ä¸ºä¸¤ä¸ªå‡½æ•°åœ¨ç›¸åŒçš„è¾“å…¥ä¸‹å¿…é¡»æ€»æ˜¯äº§ç”Ÿç›¸åŒçš„è¾“å‡ºæ‰ç›¸ç­‰ã€‚</p>

<p>å› ä¸ºè¿™äº›çœ‹æ³•ä¸Šçš„åˆ†æ­§ï¼ŒGo å¹²è„†ç¦æ­¢ slice/map/function å€¼çš„æ¯”è¾ƒã€‚</p>

<p>https://gfw.go101.org/article/value-conversions-assignments-and-comparisons.html#comparison-implementation</p>

<p>nil æ ‡è¯†ç¬¦æ˜¯ä¸èƒ½æ¯”è¾ƒçš„</p>

<p>package main</p>

<p>import â€œfmtâ€</p>

<p>func main() {
    fmt.Println(nil == nil)
}</p>

<p>.\nil.go:6:18: invalid operation: nil == nil (operator == not defined on nil)</p>

<p>func main() {
	b := []int{}
	var c []int
	fmt.Println(nil == nil)
	fmt.Println(b == nil, b, c == nil, c)
	fmt.Println(b == c)
}</p>

<p>./compile8.go:8:18: invalid operation: nil == nil (operator == not defined on nil)
false [] true [] //nilè¡¨ç¤ºæ˜¯éåˆå§‹åŒ–å¯¹è±¡ï¼Œå†…å­˜åœ°å€éƒ½æ˜¯0ï¼Œ åˆå§‹åŒ–åæ˜¯emptyå¯¹è±¡è¿™ä¸ªæ—¶å€™ä¸æ˜¯nil
./compile8.go:10:16: invalid operation: b == c (slice can only be compared to nil)</p>

<p>nil ä¸æ˜¯å…³é”®å­—æˆ–ä¿ç•™å­—
nil å¹¶ä¸æ˜¯Goè¯­è¨€çš„å…³é”®å­—æˆ–è€…ä¿ç•™å­—ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªåç§°ä¸º nil çš„å˜é‡ï¼Œæ¯”å¦‚ä¸‹é¢è¿™æ ·ï¼š</p>

<p>var nil = errors.New(â€œmy godâ€)</p>

<p>è™½ç„¶ä¸Šé¢çš„å£°æ˜è¯­å¥å¯ä»¥é€šè¿‡ç¼–è¯‘ï¼Œä½†æ˜¯å¹¶ä¸æå€¡è¿™ä¹ˆåšã€‚</p>

<p>ä¸åŒç±»å‹ nil çš„æŒ‡é’ˆæ˜¯ä¸€æ ·çš„
å¤åˆ¶ä»£ç 
package main</p>

<p>import â€œfmtâ€</p>

<p>func main() {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//fmt.Println(nil == nil)

var arr []int
var num *int
var string *string
fmt.Printf("%p\n", arr)
fmt.Printf("%p\n", num)
fmt.Printf("%p\n", string)
</code></pre></div></div>

<p>}
å¤åˆ¶ä»£ç 
0x0
0x0
0x0
é€šè¿‡è¿è¡Œç»“æœå¯ä»¥çœ‹å‡º arr ã€numã€ string çš„æŒ‡é’ˆéƒ½æ˜¯ 0x0ã€‚</p>

<p>ä¸åŒç±»å‹çš„ nil æ˜¯ä¸èƒ½æ¯”è¾ƒçš„
å¤åˆ¶ä»£ç 
package main</p>

<p>import â€œfmtâ€</p>

<p>func main() {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var arr []int
var num *int
var string *string
fmt.Printf("%p\n", arr)
fmt.Printf("%p\n", num)
fmt.Println(arr == num)
</code></pre></div></div>

<p>}
å¤åˆ¶ä»£ç 
.\nil.go:14:18: invalid operation: arr == num (mismatched types []int and *int)
ä¸¤ä¸ªç›¸åŒç±»å‹çš„ nil å€¼ä¹Ÿå¯èƒ½æ— æ³•æ¯”è¾ƒ
åœ¨Goè¯­è¨€ä¸­ mapã€slice å’Œ function ç±»å‹çš„ nil å€¼ä¸èƒ½æ¯”è¾ƒï¼Œæ¯”è¾ƒä¸¤ä¸ªæ— æ³•æ¯”è¾ƒç±»å‹çš„å€¼æ˜¯éæ³•çš„ï¼Œä¸‹é¢çš„è¯­å¥æ— æ³•ç¼–è¯‘ã€‚</p>

<p>var s1 []int
    var s2 []int
    fmt.Printf(â€œ\nâ€, s1 == s2)
.\nil.go:16:22: invalid operation: s1 == s2 (slice can only be compared to nil)
nil æ˜¯ mapã€sliceã€pointerã€channelã€funcã€interface çš„é›¶å€¼
å¤åˆ¶ä»£ç 
package main</p>

<p>import â€œfmtâ€</p>

<p>func main() {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var m map[int]string
var ptr *int32
var c chan int32
var slice []int32
var f func()
var i interface{}

fmt.Printf("%#v \n", m)
fmt.Printf("%#v \n", ptr)
fmt.Printf("%#v \n", c)
fmt.Printf("%#v \n", slice)
fmt.Printf("%#v \n", f)
fmt.Printf("%#v \n", i) } å¤åˆ¶ä»£ç  å¤åˆ¶ä»£ç  map[int]string(nil) (*int32)(nil) (chan int32)(nil) []int32(nil) (func())(nil)
</code></pre></div></div>
<nil>
å¤åˆ¶ä»£ç 
é›¶å€¼æ˜¯Goè¯­è¨€ä¸­å˜é‡åœ¨å£°æ˜ä¹‹åä½†æ˜¯æœªåˆå§‹åŒ–è¢«èµ‹äºˆçš„è¯¥ç±»å‹çš„ä¸€ä¸ªé»˜è®¤å€¼ã€‚

ä¸åŒç±»å‹çš„ nil å€¼å ç”¨çš„å†…å­˜å¤§å°å¯èƒ½æ˜¯ä¸ä¸€æ ·çš„
ä¸€ä¸ªç±»å‹çš„æ‰€æœ‰çš„å€¼çš„å†…å­˜å¸ƒå±€éƒ½æ˜¯ä¸€æ ·çš„ï¼Œnil ä¹Ÿä¸ä¾‹å¤–ï¼Œnil çš„å¤§å°ä¸åŒç±»å‹ä¸­çš„é nil ç±»å‹çš„å¤§å°æ˜¯ä¸€æ ·çš„ã€‚ä½†æ˜¯ä¸åŒç±»å‹çš„ nil å€¼çš„å¤§å°å¯èƒ½ä¸åŒã€‚

å¤åˆ¶ä»£ç 
package main

import (
    "fmt"
    "unsafe"
)

func main() {

    // var arr []int
    // var num *int
    // var string *string
    // fmt.Printf("%p\n", arr)
    // fmt.Printf("%p\n", num)
    // fmt.Println(arr == num)

    // var s1 []int
    // var s2 []int
    // fmt.Printf("\n", s1 == s2)

    var m map[int]string
    var ptr *int32
    var c chan int32
    var slice []int32
    var f func()
    var i interface{}

    fmt.Printf("%#v \n", m)
    fmt.Printf("%#v \n", ptr)
    fmt.Printf("%#v \n", c)
    fmt.Printf("%#v \n", slice)
    fmt.Printf("%#v \n", f)
    fmt.Printf("%#v \n", i)

    fmt.Println(unsafe.Sizeof(m))
    fmt.Println(unsafe.Sizeof(ptr))
    fmt.Println(unsafe.Sizeof(c))
    fmt.Println(unsafe.Sizeof(slice))
    fmt.Println(unsafe.Sizeof(f))
    fmt.Println(unsafe.Sizeof(i))
}
å¤åˆ¶ä»£ç 
å¤åˆ¶ä»£ç 
map[int]string(nil)
(*int32)(nil)
(chan int32)(nil)
[]int32(nil)
(func())(nil)
<nil>
8
8
8
24
8
16
å¤åˆ¶ä»£ç 
å…·ä½“çš„å¤§å°å–å†³äºç¼–è¯‘å™¨å’Œæ¶æ„ï¼Œä¸Šé¢æ‰“å°çš„ç»“æœæ˜¯åœ¨ 64 ä½æ¶æ„å’Œæ ‡å‡†ç¼–è¯‘å™¨ä¸‹å®Œæˆçš„ï¼Œå¯¹åº” 32 ä½çš„æ¶æ„çš„ï¼Œæ‰“å°çš„å¤§å°å°†å‡åŠ

https://www.cnblogs.com/personblog/p/12260345.html


ä¹‹å‰åœ¨å­¦ä¹ C/C++æ—¶ï¼Œæˆ‘ä»¬çŸ¥é“æœ‰NULL
åœ¨Cä¸­NULLæ˜¯ä¸€ä¸ªï¼ˆvoid*ï¼‰çš„æŒ‡é’ˆï¼Œå…¶å®šä¹‰å¦‚ä¸‹ï¼š

#define NULL    ((void *)0)
1
è€Œåœ¨C++ä¸­ï¼ŒNULLç›´æ¥å¯ä»¥å’Œ0åˆ’ç­‰å·ï¼Œå®šä¹‰ï¼š

/* Define NULL pointer value */
#ifndef NULL
    #ifdef __cplusplus
        #define NULL    0
    #else  /* __cplusplus */
        #define NULL    ((void *)0)
    #endif  /* __cplusplus */
#endif  /* NULL */
1
2
3
4
5
6
7
8
å› ä¸ºC++æ”¯æŒé‡è½½ï¼Œè‹¥å°†NULLç»§ç»­å®šä¹‰ä¸ºvoid*ç±»å‹ï¼Œç¼–è¯‘å™¨æ— æ³•åˆ¤æ–­è¯¥è°ƒå“ªä¸ªå‡½æ•°ï¼Œå› æ­¤é™å®šNULLä¸º0ï¼Œä½†æ˜¯C++ä¸­çš„ç©ºæŒ‡é’ˆè¯¥æ€ä¹ˆåŠï¼ŒC++åˆå¼•å…¥äº†nullptræ¥è¡¨ç¤ºç©ºæŒ‡é’ˆï¼Œå®ƒå¯ä»¥è¢«è½¬æ¢æˆä»»æ„ç±»å‹çš„æŒ‡é’ˆç±»å‹å’Œboolç±»å‹ï¼Œä½†æ˜¯ä¸èƒ½è½¬intç±»å‹ã€‚

NULLä¸ä½†å¯ä»¥è¡¨ç¤º0ï¼Œè¿˜èƒ½è¡¨ç¤º â€˜\0â€™ ,ä»–ä»¬å‡ ä¸ªçš„å€¼éƒ½æ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯0ã€‚

ä»Šå¤©æˆ‘ä»¬ä¸»è¦æ¥èŠèŠgolangä¸­çš„nilã€‚
å¯¹Golangæœ‰æ‰€äº†è§£çš„äººä¸€å®šä¼šçŸ¥é“nilï¼Œåœ¨goä»£ç ä¸­ï¼Œnilç®€ç›´æ— å¤„ä¸åœ¨ã€‚
æˆ‘ä»¬ç”¨çš„æœ€å¤šçš„å¯èƒ½å°±æ˜¯å¯¹errçš„åˆ¤æ–­ï¼Œå¦‚ä¸‹ï¼š

a , err := math.atoi ( s )
if err != nil {
	return err
}
1
2
3
4
æˆ‘ä»¬å¸¸å¸¸å°†errå’Œnilè¿›è¡Œæ¯”è¾ƒï¼Œå½“err==nilæ—¶ï¼Œè¯´æ˜æœªå‡ºç°é”™è¯¯ï¼Œè€Œä¸ç›¸ç­‰æ—¶è¯´æ˜å‡½æ•°å‡ºé”™ï¼Œéœ€è¦å¤„ç†ã€‚
è¿™é‡Œçš„nilç›¸å½“äºé›¶å€¼ï¼Œå½“æˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ªå˜é‡ï¼Œä½†æ˜¯æœªå°†å…¶åˆå§‹åŒ–ï¼Œé‚£ä¹ˆç³»ç»Ÿä¼šè‡ªåŠ¨ä¸ºä»–èµ‹ä¸€ä¸ªé›¶å€¼ï¼Œä¸åŒç±»å‹çš„é›¶å€¼åˆ†åˆ«å¦‚ä¸‹ï¼š

int	0
bool	false
string	â€œâ€
pointer	nil
map	nil
slice	nil
channel	nil
function	nil
interface	nil
goæ–‡æ¡£ä¸­ï¼Œnilæ˜¯ä¸€ä¸ªé¢„å®šä¹‰çš„æ ‡è¯†ç¬¦ï¼Œä»£è¡¨å¾ˆå¤šç±»å‹çš„zero valueï¼Œå®ƒçš„å®šä¹‰ï¼š

type Type int
var nil Type
1
2
çœ‹åˆ°è¿™é‡Œ æˆ‘ä»¬å‘ç°è¿™ä¸ªnilå®ƒæ˜¯ä¸€ä¸ªå˜é‡ï¼Œå¯ä»¥äººä¸ºæ”¹å˜çš„
ä¸åŒç±»å‹nilçš„å†…å­˜åœ°å€å§‹ç»ˆæ˜¯ç›¸åŒçš„ ï¼Œéƒ½æ˜¯0x00

ä¸ºnilçš„sliceå®ƒçš„len()å’Œcap() éƒ½æ˜¯0ï¼Œé€šè¿‡ç´¢å¼•è®¿é—®æ—¶ä¼španicï¼Œä½†æ˜¯å¯ä»¥ä½¿ç”¨appendè¿›è¡Œæ‰©å®¹ã€‚
å¯¹äºnilæŒ‡é’ˆï¼Œæˆ‘ä»¬ä¸èƒ½è®¿é—®æŒ‡é’ˆæŒ‡å‘çš„å€¼ï¼ŒåŒæ ·ä¸èƒ½è°ƒç”¨æŒ‡é’ˆå¯¹è±¡çš„æ–¹æ³•ï¼Œå¦åˆ™ä¼španicï¼Œä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡æŒ‡é’ˆæ¥æ”¶å™¨æ¥è§£å†³ï¼Œåœ¨å‡½æ•°é‡Œé¢è¿›è¡Œåˆ¤æ–­å³å¯ã€‚
å¯¹äºnilçš„mapï¼Œæˆ‘ä»¬æŠŠå®ƒå½“ä½œä¸€ä¸ªåªè¯»çš„æŒ‡é’ˆã€‚
å¯¹äºnilçš„channelï¼Œå…³é—­ä¸€ä¸ªnilçš„channelä¼šå¯¼è‡´ç¨‹åºpanicã€‚
interfaceæœ‰ä¸€äº›ç‰¹æ®Šï¼Œå®ƒçš„åº•å±‚ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼Œåˆ†åˆ«æ˜¯ç±»å‹å’Œå€¼ï¼Œåªæœ‰å½“ç±»å‹å’Œå€¼éƒ½ä¸ºnilæ—¶ï¼Œinterfaceæ‰ä¸ºnil

</nil></nil>
:ET