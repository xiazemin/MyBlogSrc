I"ö<p>åœ¨æ¯ä¸ªè¿›ç¨‹é€€å‡ºçš„æ—¶å€™,å†…æ ¸é‡Šæ”¾è¯¥è¿›ç¨‹æ‰€æœ‰çš„èµ„æº,åŒ…æ‹¬æ‰“å¼€çš„æ–‡ä»¶,å ç”¨çš„å†…å­˜ç­‰ã€‚ ä½†æ˜¯ä»ç„¶ä¸ºå…¶ä¿ç•™ä¸€å®šçš„ä¿¡æ¯(åŒ…æ‹¬è¿›ç¨‹å·the process ID,é€€å‡ºçŠ¶æ€the termination status of the process,è¿è¡Œæ—¶é—´the amount of CPU time taken by the processç­‰)ã€‚ç›´åˆ°çˆ¶è¿›ç¨‹é€šè¿‡wait / waitpidæ¥å–æ—¶æ‰é‡Šæ”¾ã€‚
<!-- more -->
package main</p>

<p>import (
    â€œfmtâ€
    â€œlogâ€
    â€œos/execâ€
    â€œencoding/jsonâ€
)</p>

<p>func main() {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd := exec.Command("echo", "-n", `{"Name": "Bob", "Age": 32}`)
stdout, err := cmd.StdoutPipe()
if err != nil {
    log.Fatal(err)
}
if err := cmd.Start(); err != nil {
    log.Fatal(err)
}
var person struct {
    Name string
    Age  int
}
if err := json.NewDecoder(stdout).Decode(&amp;person); err != nil {
    log.Fatal(err)
}
if err := cmd.Wait(); err != nil {
    log.Fatal(err)
}
fmt.Printf("%s is %d years old\n", person.Name, person.Age)
</code></pre></div></div>

<p>}
è¾“å‡ºç»“æœï¼š
Bob is 32 years old
åˆ†æï¼š
cmd.Start ä¸ cmd.Wait å¿…é¡»ä¸€èµ·ä½¿ç”¨ã€‚
cmd.Start ä¸ç”¨ç­‰å‘½ä»¤æ‰§è¡Œå®Œæˆï¼Œå°±ç»“æŸ
cmd.Wait ç­‰å¾…å‘½ä»¤ç»“æŸ</p>

<p>GO exec.command.Wait æ‰§è¡Œåå°ç¨‹åº,åœ¨é‡å®šå‘è¾“å‡ºæ—¶å¡ä½
åœ¨GOä¸Šå‘ç°ä»¥ä¸‹ç°è±¡</p>

<p>c := exec.Command(â€œshâ€, â€œ-câ€, â€œsleep 100 &amp;â€)
var b bytes.Buffer
c.Stdout = &amp;b</p>

<p>if e := c.Start(); nil != e {
    fmt.Printf(â€œERROR: %v\nâ€, e)
}
if e := c.Wait(); nil != e {
    fmt.Printf(â€œERROR: %v\nâ€, e)
}
è¿™ä¸ªä»£ç ä¼šä¸€ç›´ç­‰åˆ°sleep 100å®Œæˆåæ‰é€€å‡º, ä¸å¸¸è¯†ä¸ç¬¦.</p>

<p>ä½†å»æ‰Stdouté‡å®šå‘å, ä»£ç å°±ä¸ä¼šç­‰å¾…å¡ä½</p>

<p>c := exec.Command(â€œshâ€, â€œ-câ€, â€œsleep 100 &amp;â€)
if e := c.Start(); nil != e {
    fmt.Printf(â€œERROR: %v\nâ€, e)
}
if e := c.Wait(); nil != e {
    fmt.Printf(â€œERROR: %v\nâ€, e)
}
åœ¨è¿è¡Œæ—¶æ‰“å‡ºstacktrace, å†ç¿»ç¿»GOçš„æºä»£ç , å‘ç°GOå¡åœ¨ä»¥ä¸‹ä»£ç </p>

<p>func (c *Cmd) Wait() error {
    â€¦
    state, err := c.Process.Wait()
    â€¦
    var copyError error
    for _ = range c.goroutine {
        if err := &lt;-c.errch; err != nil &amp;&amp; copyError == nil {
            copyError = err
        }
    }
    â€¦
}
å¯ä»¥çœ‹åˆ°Wait()åœ¨ç­‰å¾…Processç»“æŸå, è¿˜ç­‰å¾…äº†æ‰€æœ‰c.goroutineçš„c.errchä¿¡å·. å‚çœ‹ä»¥ä¸‹ä»£ç :</p>

<p>func (c *Cmd) stdout() (f *os.File, err error) {
    return c.writerDescriptor(c.Stdout)
}</p>

<p>func (c *Cmd) writerDescriptor(w io.Writer) (f *os.File, err error) {
    â€¦
    c.goroutine = append(c.goroutine, func() error {
        _, err := io.Copy(w, pr)
        return err
    })
    â€¦
}
é‡å®šå‘stdoutæ—¶, ä¼šæ·»åŠ ä¸€ä¸ªç›‘å¬ä»»åŠ¡åˆ°goroutine (stderrä¹Ÿæ˜¯åŒç†)</p>

<p>ç»“è®ºæ˜¯ç”±äºå°†sleep 100æ”¾åˆ°åå°æ‰§è¡Œ, å…¶è¿›ç¨‹stdoutå¹¶æ²¡æœ‰å…³é—­, io.Copy()ä¸ä¼šè¿”å›, æ‰€ä»¥ä¼šå¡ä½</p>

<p>ä¸´æ—¶çš„è§£å†³æ–¹æ³•å°±æ˜¯å°†åå°è¿›ç¨‹çš„stdoutå’Œstderré‡å®šå‘å‡ºå», ä»¥ä¸‹ä»£ç ä¸ä¼šå¡ä½:</p>

<p>c := exec.Command(â€œshâ€, â€œ-câ€, â€œsleep 100 &gt;/dev/null 2&gt;/dev/null &amp;â€)
var b bytes.Buffer
c.Stdout = &amp;b</p>

<p>if e := c.Start(); nil != e {
    fmt.Printf(â€œERROR: %v\nâ€, e)
}
if e := c.Wait(); nil != e {
    fmt.Printf(â€œERROR: %v\nâ€, e)
}</p>
:ET