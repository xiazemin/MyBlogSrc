I"÷3<p>æˆ‘ä»¬éƒ½çŸ¥é“mapæ˜¯æ— åºçš„ï¼Œæ¯æ¬¡å–å‡ºkey/valueçš„é¡ºåºéƒ½å¯èƒ½ä¸ä¸€è‡´ï¼Œä½†mapè½¬jsonçš„é¡ºåºæ˜¯ä¸æ˜¯ä¹Ÿæ˜¯æ— åºçš„å—ï¼Ÿå°½ç®¡jsonä¸­çš„å‚æ•°é¡ºåºå¤§éƒ¨åˆ†æƒ…å†µä¸‹å¯¹ä½¿ç”¨æ²¡æœ‰å½±å“ï¼Œæˆ‘ä»¬ä¸å¦¨çœ‹çœ‹æºç ä¸­æ€ä¹ˆå¤„ç†çš„ã€‚</p>

<p>å…ˆè¯´ç»“è®ºï¼š</p>

<p>mapè½¬jsonæ˜¯æœ‰åºçš„ï¼ŒæŒ‰ç…§ASCIIç å‡åºæ’åˆ—keyã€‚
<!-- more -->
æº¯æº
æºç ä½äºencoding/json/encode.goä¸­</p>

<p>type mapEncoder struct {
   elemEnc encoderFunc
}</p>

<p>func (me mapEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
   if v.IsNil() {//ä¸ºnilæ—¶ï¼Œè¿”å›null
      e.WriteString(â€œnullâ€)
      return
   }
   e.WriteByte(â€˜{â€˜)</p>

<p>// Extract and sort the keys.
   keys := v.MapKeys()//è·å–mapä¸­çš„æ‰€æœ‰keys
   sv := make([]reflectWithString, len(keys))
   for i, v := range keys {
      sv[i].v = v
      if err := sv[i].resolve(); err != nil {//å¤„ç†keyï¼Œå°¤å…¶æ˜¯éstringï¼ˆint/uintï¼‰ç±»å‹çš„keyè½¬string
         e.error(&amp;MarshalerError{v.Type(), err})
      }
   }
   //æ’åºï¼Œå‡åºï¼Œç›´æ¥æ¯”è¾ƒå­—ç¬¦ä¸²
   sort.Slice(sv, func(i, j int) bool { return sv[i].s &lt; sv[j].s })</p>

<p>for i, kv := range sv {
      if i &gt; 0 {
         e.WriteByte(â€˜,â€™)
      }
      e.string(kv.s, opts.escapeHTML)
      e.WriteByte(â€˜:â€™)
      me.elemEnc(e, v.MapIndex(kv.v), opts)
   }
   e.WriteByte(â€˜}â€™)
}</p>

<p>func newMapEncoder(t reflect.Type) encoderFunc {
   switch t.Key().Kind() {
   case reflect.String,
      reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
      reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
   default:
      if !t.Key().Implements(textMarshalerType) {
         return unsupportedTypeEncoder
      }
   }
   me := mapEncoder{typeEncoder(t.Elem())}
   return me.encode
}</p>

<p>{
    â€œfooâ€: â€œHello, World!â€,
    â€œbarâ€: {
        â€œbâ€: {
            â€œgoâ€: â€œ1â€
        },
        â€œaâ€: {
            â€œgoâ€: â€œ2â€
        },
        â€œcâ€: {
            â€œgoâ€: â€œ3â€
        }
    }
}
æœ‰å¦‚ä¸Šä¸€æ®µ JSONï¼Œåœ¨ç¨‹åºä¸­éœ€è¦å°†å…¶è½¬ä¸ºä¸€ä¸ªç»“æ„ä½“ä»¥æ–¹ä¾¿è¯»å–é‡Œè¾¹çš„æ•°æ®ï¼Œstruct çš„å®šä¹‰å¤§æ¦‚å¦‚ä¸‹ï¼š</p>

<p>type Foobar struct {
    Foo  string <code class="language-plaintext highlighter-rouge">json:"foo"</code>
    Bar map[string]struct {
        Go string <code class="language-plaintext highlighter-rouge">json:"go"</code>
    } <code class="language-plaintext highlighter-rouge">json:"bar"</code>
}
ç°åœ¨æœ‰è¿™ä¹ˆä¸¤ä¸ªéœ€æ±‚ï¼š</p>

<p>æŒ‰é¡ºåºè¾“å‡º bar.aã€bar.bã€bar.c
æŒ‰é¡ºåºè¾“å‡º bar.bã€bar.aã€bar.c
å¦‚æœæ˜¯ç”¨ Java çš„å°ä¼™ä¼´ï¼Œè‚¯å®šå·²ç»æƒ³åˆ° SortedMapï¼ˆç”¨çš„æ¯”è¾ƒå¤šæ˜¯ TreeMapï¼‰å’Œ LinkedHashMap äº†ï¼Œå‰è€…æ˜¯å¯ä»¥æŒ‰ key è¿›è¡Œæ’åºçš„ï¼Œåè€…åˆ™å¯ä»¥ä¿æŒé”®å€¼å¯¹çš„æ’å…¥é¡ºåºï¼Œè€Œè¿™ä¸¤è€…éƒ½æ˜¯ JDK è‡ªå¸¦çš„ï¼Œä»»ä½•ä¸€ä¸ª Javaer åº”è¯¥éƒ½ä½¿ç”¨è¿‡ã€‚</p>

<p>ä½†æ˜¯åœ¨ Go è¯­è¨€çš„ â€œç®€çº¦è®¾è®¡â€ é¢å‰ï¼Œè¿™äº›éƒ½æ˜¯ä¸å­˜åœ¨çš„ â€”â€”Go åªæä¾›äº†æœ€åŸºç¡€çš„ hash mapã€‚</p>

<p>å¹¶ä¸”ï¼Œåœ¨å€ŸåŠ© range å…³é”®å­—å¯¹ Go çš„ map è¿›è¡Œéå†è®¿é—®çš„æ—¶å€™ï¼Œä¼šå¯¹ map çš„ key çš„é¡ºåºåšéšæœºåŒ–å¤„ç†ï¼Œä¹Ÿå°±æ˜¯è¯´å³ä½¿æ˜¯åŒä¸€ä¸ª map åœ¨åŒä¸€ä¸ªç¨‹åºé‡Œè¿›è¡Œä¸¤æ¬¡ç›¸åŒçš„éå†ï¼Œå‰åä¸¤è½®è®¿é—® key çš„é¡ºåºä¹Ÿæ˜¯éšæœºåŒ–çš„ã€‚(å¯ä»¥åœ¨è¿™é‡ŒéªŒè¯ï¼šhttps://play.golang.org/p/s3Mj4gNfi4g )</p>

<p>åœ¨ Go çš„å®˜æ–¹ blog çš„æ–‡ç«  Go maps in action ä¹Ÿç¡®å®šäº†è¯¥ç°è±¡ç¡®å®å­˜åœ¨ï¼Œå¹¶ä¸”æ˜¯æœ‰æ„è€Œä¸ºä¹‹ï¼Œ</p>

<p>When iterating over a map with a range loop, the iteration order is not specified and is not guaranteed to be the same from one iteration to the next. Since the release of Go 1.0, the runtime has randomized map iteration order.</p>

<p>é‚£ä¹ˆåœ¨ Go é‡Œè¾¹å®ç°ä»¥ä¸Šéœ€æ±‚å°±å¾—ç»•äº›è·¯äº†ã€‚</p>

<p>å®ç°ç±»ä¼¼ SortedMap çš„éå†
SortedMap ä¸»è¦æ˜¯å¯¹ key æ’åºï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¾¿å¯å°† map çš„ key å…¨éƒ¨æ‹¿å‡ºæ¥ï¼Œæ”¾åˆ°ä¸€ä¸ªæ•°ç»„ä¸­ï¼Œç„¶åå¯¹è¿™ä¸ªæ•°ç»„æ’åºåå¯¹æœ‰åºæ•°ç»„éå†ï¼Œå†é—´æ¥å– map é‡Œçš„å€¼å°±è¡Œäº†ã€‚</p>

<p>package main</p>

<p>import (
    â€œfmtâ€
    â€œsortâ€
)</p>

<p>func main() {
    m := make(map[string]string)
    m[â€œbâ€] = â€œ2â€
    m[â€œaâ€] = â€œ1â€
    m[â€œcâ€] = â€œ3â€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>keys := make([]string, 0, len(m))
for k, _ := range m {
    keys = append(keys, k)
}

sort.Strings(keys)

for _, k := range keys {
    fmt.Printf("Key:%+v, Value:%+v\n", k, m[k])
} } https://play.golang.org/p/vzpwizlRYUO
</code></pre></div></div>

<p>è¾“å‡ºï¼š</p>

<p>Key:a, Value:1
Key:b, Value:2
Key:c, Value:3
ä¸è¿‡æ¯æ¬¡éƒ½è¦è¿™ä¹ˆå†™æœ‰äº›éº»çƒ¦ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶å°è£…æˆä¸€ä¸ªæ–¹æ³•</p>

<p>func sortedMap(m map[string]interface{}, f func(k string, v interface{})) {
    var keys []string
    for k := range m {
        keys = append(keys, k)
    }
    sort.Strings(keys)
    for _, k := range keys {
        f(k, m[k])
    }
}
ç„¶åè¿™æ ·è°ƒç”¨</p>

<p>func main() {
    m := make(map[string]interface{})
    m[â€œbâ€] = â€œ2â€
    m[â€œaâ€] = â€œ1â€
    m[â€œcâ€] = â€œ3â€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sortedMap(m, func(k string, v interface{}) {
    val := v.(string)
    fmt.Printf("Key:%+v, Value:%+v\n", k, val)
}) } ä¸è¿‡é—æ†¾çš„æ˜¯ï¼Œå› ä¸º Go ä¸æ”¯æŒæ³›å‹ï¼Œæ‰€ä»¥è¯¥æ–¹æ³•å¹¶ä¸æ˜¯å¾ˆé€šç”¨ï¼ˆå½“ key ä¸ä¸º string çš„æ—¶å€™ï¼‰ï¼Œä½†ç»ˆç©¶ç®—æ˜¯ä¸€ä¸ªè§£å†³åŠæ³•ã€‚
</code></pre></div></div>

<p>å®ç°ç±»ä¼¼ LinkedHashMap
ç›¸æ¯”äºä¸Šè¾¹æŒ‰ key æ’åºæ¥è®²ï¼Œåœ¨ Go ä¸­å®ç° LinkedHashMap è¦å›°éš¾å¾—å¤šï¼Œè¦è‡ªå·±å†™ä¸€å¥—æ•°æ®ç»“æ„ã€‚</p>

<p>ä¹‹å‰æœ‰äººè¯•å›¾ç»™ Go æ ‡å‡†åº“æäº¤è¿‡ç›¸å…³çš„ä»£ç ï¼Œä½†æ˜¯è¢«æ‹’ç»äº†ï¼ˆ(æ²®ä¸§è„¸) è¯¦æƒ…å¯è§ 7930: encoding/json: Optionally preserve the key order of JSON objects ï¼‰ï¼Œä¸è¿‡åœ¨ GitHub ä¸Šè¿˜æ˜¯èƒ½æ‰¾åˆ°ç›¸å…³çš„ä»£ç çš„ï¼šgo-ordered-jsonï¼Œæˆ‘ä»¬å°±å¯ä»¥ç”¨ä½¿ç”¨è¿™ä¸ªåº“æ¥å®Œæˆã€‚</p>

<p>æ­£å¦‚è¯¥é¡¹ç›®çš„ ReadMe ä¸­æ‰€è¯´ï¼Œä½ åº”è¯¥å°½å¯èƒ½é¿å…ä½¿ç”¨è¯¥åº“</p>

<p>If you can, you should avoid using this package.</p>

<p>ä½†æ˜¯å¯¹æˆ‘æ¥è¯´ï¼Œæˆ‘æ²¡æœ‰æ›´å¥½çš„æ–¹æ¡ˆï¼ˆç¬¬ä¸‰æ–¹ API è¿”å›çš„ JSON ä¸­å°±æ˜¯ç”¨ map æ¥ä¿æŒé¡ºåºçš„ï¼‰ï¼Œé‚£ä¹ˆæˆ‘ä¹Ÿåªå¥½å¥½å¥½çš„ enjoy it äº†ã€‚</p>

<p>package main</p>

<p>import (
    â€œfmtâ€
    â€œgithub.com/virtuald/go-ordered-jsonâ€
)</p>

<p>func main() {
    jsonString := <code class="language-plaintext highlighter-rouge">{
    "b": "2",
    "a": "1",
    "c": "3"
}</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>oo := json.OrderedObject{}
err := json.Unmarshal([]byte(jsonString), &amp;oo)
if err != nil {
    panic(err)
}
fmt.Printf("%+v", oo) } è¾“å‡ºç»“æœï¼š
</code></pre></div></div>

<p>[{Key:b Value:2} {Key:a Value:1} {Key:c Value:3}]
å¯ä»¥çœ‹å‡º json.OrderedObject å†…éƒ¨å…¶å®æ˜¯æŠŠ map å¤„ç†æˆäº† sliceã€‚</p>

<p>ä½†æ˜¯æ³¨æ„äº†ï¼šjson.OrderedObject åªå¤„ç†é¡¶å±‚çš„è¿™ä¸ª mapï¼Œå¦‚æœåµŒå¥—æœ‰ map çš„è¯ï¼Œä¸‹å±‚çš„ map è¿˜æ˜¯æ— åºçš„ã€‚</p>

<p>ï¼ˆä½ å¯èƒ½ä¼šæ€€ç–‘æ˜¯ä¸æ˜¯å› ä¸ºç”¨äº† fmt.Printf å¯¼è‡´æ‰“å°å‡ºæ¥çš„é¡ºåºå˜äº†ï¼Œä½ å¯ä»¥è‡ªå·±éå†è¯•ä¸€ä¸‹å“¦ï½ï¼‰</p>

<p>ç°åœ¨æ¥çœ‹çœ‹æœ¬æ–‡å¼€å¤´çš„é‚£ä¸ª JSON çš„ä¾‹å­</p>

<p>{
    â€œfooâ€: â€œHello, World!â€,
    â€œbarâ€: {
        â€œbâ€: {
            â€œgoâ€: â€œ1â€
        },
        â€œaâ€: {
            â€œgoâ€: â€œ2â€
        },
        â€œcâ€: {
            â€œgoâ€: â€œ3â€
        }
    }
}
å¦‚æœæˆ‘æŠŠä¸Šè¾¹ä»£ç ä¸­çš„ jsonString æ¢æˆä¸Šè¾¹çš„è¿™ä¸ª JSONï¼Œé‚£ä¹ˆè¾“å‡ºçš„å°±ä¼šæ˜¯</p>

<p>[{Key:foo Value:Hello, World!} {Key:bar Value:map[a:map[go:2] b:map[go:1] c:map[go:3]]}]
å¯ä»¥çœ‹å‡ºå®ƒåªä¿è¯äº†æœ€å¤–å±‚ foo å’Œ bar çš„é¡ºåºï¼Œ è€Œå¯¹äº bar å¯¹åº”çš„è¿™ä¸ª mapï¼Œæ˜¯æŒ‰ a,b,c çš„é¡ºåºæ¥ï¼Œå¹¶ä¸æ˜¯æˆ‘ä»¬æœŸæœ›ä¸­çš„ b,a,cã€‚</p>

<p>ä¸è¿‡è¿™ä¸ªé—®é¢˜ä¹Ÿæ˜¯æœ‰è§£çš„ï¼Œæˆ‘ä»¬å…ˆåˆ›å»ºä¸€ä¸ª structï¼ˆå’Œæ–‡ç« å¼€å¤´æåˆ°é‚£ä¸ª struct æœ‰ç‚¹åƒï¼‰ï¼Œé‡ç‚¹å°±æ˜¯ Bar çš„ç±»å‹è¿™é‡Œæ˜¯ json.OrderedObject</p>

<p>type Foobar struct {
    Foo string             <code class="language-plaintext highlighter-rouge">json:"foo"</code>
    Bar json.OrderedObject <code class="language-plaintext highlighter-rouge">json:"bar"</code>
}
ç„¶åå’±ä»¬æ¥å¼€å§‹å§</p>

<p>package main</p>

<p>import (
    â€œfmtâ€
    â€œgithub.com/virtuald/go-ordered-jsonâ€
)</p>

<p>func main() {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jsonString := `{
"foo": "Hello, World!",
"bar": {
    "b": {
        "go": "1"
    },
    "a": {
        "go": "2"
    },
    "c": {
        "go": "3"
    }
} }`

foobar := Foobar{}
err := json.Unmarshal([]byte(jsonString), &amp;foobar)
if err != nil {
    panic(err)
}

for _, value := range foobar.Bar {
    m := value.Value.(map[string]interface{})
    for k, v := range m {
        fmt.Printf("%+v.%+v=%+v\n", value.Key, k, v)
    }
}
</code></pre></div></div>

<p>}
è¾“å‡ºç»“æœï¼š</p>

<p>b.go=1
a.go=2
c.go=3
æˆåŠŸäº†æ˜¯ä¸æ˜¯ï¼Ÿï¼æ­¤å¤„åº”è¯¥æœ‰æŒå£°ï½</p>

<p>å½“ç„¶ï¼Œæ˜¯çŒ®ç»™ virtuald/go-ordered-json çš„ï½</p>

<p>encoding/json
æœ‰æ—¶é—´äº†å¯ä»¥ç ”ç©¶ä¸€ä¸‹ encoding/json åº“ï¼Œå®ƒçš„æ„ä¹‰ç›¸å¯¹å…¶ä»–è¯­è¨€æ¥è¯´åœ¨ Go ä¸­å°¤å…¶é‡è¦ â€”â€” å®ƒè¿˜æ‰®æ¼”ç€ struct è½¬æ¢å™¨çš„è§’è‰²ã€‚</p>

<p>å¦å¤–åœ¨ç”¨å®ƒå¯¹ map è¿›è¡Œ encode çš„æ—¶å€™ï¼ˆå°±æ˜¯ json.Marshal å’¯ï¼‰ï¼Œè¿˜æ˜¯æŒºæœ‰æ„æ€çš„ï¼Œå¤§å®¶çŒœçŒœä¸‹è¾¹è¿™æ®µä»£ç ï¼Œrange å’Œ json éƒ¨åˆ†åˆ†åˆ«æ˜¯ä»€ä¹ˆæ ·çš„ç»“æœï¼Ÿå¤šè¿è¡Œå‡ æ¬¡å‘¢ï¼Ÿ</p>

<p>package main</p>

<p>import (
	â€œencoding/jsonâ€
	â€œfmtâ€
)</p>

<p>func main() {
	jsonString := <code class="language-plaintext highlighter-rouge">{
	"foo": {
		"b": "1",
		"a": "2",
		"c": "3"
	}
}</code>
	o := make(map[string]map[string]string)
	err := json.Unmarshal([]byte(jsonString), &amp;o)
	if err != nil {
		panic(err)
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println("range:")
for _, m := range o {
	for k, v := range m {
		fmt.Printf("%s, %s\n", k, v)
	}
}

bytes, err := json.Marshal(o)
if err != nil {
	panic(err)
}

fmt.Println("")
fmt.Println("json:")
fmt.Printf("%s\n", bytes) } æœ‰å…´è¶£çš„æœ‹å‹ç‚¹å‡»ä¸‹è¾¹çš„ Go Playground è‡ªå·±è¯•è¯•
</code></pre></div></div>

<p>https://play.golang.org/p/JcTWRlYjQ5j</p>

<p>https://github.com/virtuald/go-ordered-json</p>

<p>https://github.com/google/gson
LinkedHashMapæœ¬èº«æ˜¯æœ‰åºçš„ï¼Œä½¿ç”¨JDKè‡ªå¸¦çš„åºåˆ—åŒ–ä»£ç æˆ–è€…fastJsonä»£ç åºåˆ—åŒ–åï¼Œå­—ç¬¦ä¸²å¹¶éæŒ‰ç…§æ’å…¥é¡ºåºè¾“å‡º</p>

<p>Map&lt;String,String&gt; linkedMap=new LinkedHashMap&lt;String,String&gt;();
linked2.put(â€œbâ€,â€2â€);
linked2.put(â€œaâ€,â€1â€);
linked2.put(â€œcâ€,â€3â€);
String jsonStr=JSON.toJSONString(linkedMap);
è¾“å‡ºjsonSträ¸º{â€œaâ€:â€1â€,â€bâ€:â€2â€,â€câ€:â€3â€}
è§£å†³åŠæ³•ï¼š
ä½¿ç”¨Gson(com.google.gson)åºåˆ—åŒ–
Map&lt;String,String&gt; linkedMap=new LinkedHashMap&lt;String,String&gt;();
linked2.put(â€œbâ€,â€2â€);
linked2.put(â€œaâ€,â€1â€);
linked2.put(â€œcâ€,â€3â€);
Gson gson = new GsonBuilder().enableComplexMapKeySerialization().create();
String jsonStr=gson.toJson(linked2);
System.out.println(jsonStr);
è¾“å‡ºjsonSträ¸º{â€œbâ€:â€2â€,â€aâ€:â€1â€,â€câ€:â€3â€}</p>

<p>fastjsonï¼ˆ1.2.15ï¼‰éœ€è¦å°†å‰ç«¯å¤šå±‚åµŒå¥—jsonè½¬æ¢ä¸ºmapï¼Œç”±äºmapçš„æ— åºæ€§ï¼Œæƒ³äº†å¾ˆå¤šåŠæ³•ï¼Œæœ€ç»ˆæ‰¾åˆ°ä½¿ç”¨ Map m= JSONArray.parseObject(json, LinkedHashMap&lt;String,String&gt;.class); æ¥è½¬æ¢ï¼Œé—®é¢˜æ¥äº†ï¼Œç¬¬ä¸€å±‚é¡ºåºæ˜¯å¯¹çš„ï¼Œä½†æ˜¯ç¬¬äºŒå±‚æ’åºå±…ç„¶å‡ºé—®é¢˜äº†ï¼Œç›®å‰ä»…ä»…åªæ˜¯éœ€è¦è½¬æ¢æˆString ä»–å±…ç„¶æŠŠStringéƒ½ç»™è‡ªåŠ¨æ’åºäº†ï¼Œåæ¥ç½‘ä¸ŠæŸ¥äº†å¾ˆå¤šèµ„æ–™å‘ç°è¿˜å¯ä»¥é‡‡ç”¨ä¸€ç§æ–¹å¼ï¼š</p>

<p>Javaä»£ç </p>

<p>æ”¶è—ä»£ç </p>

<p>JSONObject jsonObj = new JSONObject(true);<br />
Map m= jsonObj.parseObject(json, LinkedHashMap.class);<br />
 ä½†æ˜¯è¾“å‡ºé—®é¢˜è¿˜æ˜¯å­˜åœ¨ç¬¬äºŒå±‚ä»¥åæ’åºæ··ä¹±ï¼Œå¦‚ä¸‹ï¼š</p>

<p>ä¼ å…¥Jsonï¼š
{â€œt1â€:â€â€,â€t3â€:â€â€,â€t2â€:{â€œa1â€:â€â€,â€a3â€:â€â€,â€a2â€:â€â€}}</p>

<p>è¾“å‡ºï¼š</p>

<p>{t1=, t3=, t2={â€œa1â€:â€â€,â€a2â€:â€â€,â€a3â€:â€â€}}</p>

<p>æ— å¥ˆï¼Œè·Ÿè¸ªfastjsonæºç ï¼ŒèŠ±äº†2å°æ—¶åœ¨com.alibaba.fastjson.parser.DefaultJSONParser ç±»ä¸­475è¡Œå‘ç°</p>

<p>Javaä»£ç </p>

<p>æ”¶è—ä»£ç </p>

<p>else if (ch == â€˜{â€˜) { // å‡å°‘åµŒå¥—ï¼Œå…¼å®¹android<br />
                   lexer.nextToken();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>               final boolean parentIsArray = fieldName != null &amp;&amp; fieldName.getClass() == Integer.class;  
  
               &lt;span style="color: #ff0000;"&gt;&lt;strong&gt;JSONObject input = new JSONObject(lexer.isEnabled(Feature.OrderedField)&lt;/strong&gt;&lt;/span&gt;);  
</code></pre></div></div>

<p>å±…ç„¶è¿™é‡Œé¢åˆ¤æ–­äº†Feature.OrderedField</p>

<p>æœæ–­çŸ¥é“äº†è§£å†³åŠæ³•ï¼š</p>

<p>HashMap m=  JSON.parseObject(json,LinkedHashMap.class,Feature.OrderedField);</p>

<p>æå®šï¼Œè¾“å‡ºç»“æœï¼š</p>

<p>{t1=, t3=, t2={â€œa1â€:â€â€,â€a3â€:â€â€,â€a2â€:â€â€}}</p>

<p>https://github.com/iancoleman/orderedmap</p>
:ET