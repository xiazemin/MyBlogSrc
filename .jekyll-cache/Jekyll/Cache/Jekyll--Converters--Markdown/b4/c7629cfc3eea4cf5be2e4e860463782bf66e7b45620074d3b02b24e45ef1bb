I"<p>二分图：简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集   和  ，使得每一条边都分别连接 中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。
最大匹配：一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。
完美匹配：如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。
交替路：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替
<img src="https://xiazemin.github.io/MyBlog/img/cross_road.png" />
增广路：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。
增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。
<!-- more -->
我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。在给出匈牙利算法 DFS 和 BFS 版本的代码之前，先讲一下匈牙利树。
匈牙利树一般由 BFS 构造（类似于 BFS 树）。从一个未匹配点出发运行 BFS（唯一的限制是，必须走交替路），直到不能再扩展为止。
// 由于时间紧凑，代码摘自http://dsqiu.iteye.com/blog/1689505
#define maxn 10//表示x集合和y集合中顶点的最大个数！<br />
int nx,ny;//x集合和y集合中顶点的个数<br />
int edge[maxn][maxn];//edge[i][j]为1表示ij可以匹配<br />
int cx[maxn],cy[maxn];//用来记录x集合中匹配的y元素是哪个！<br />
int visited[maxn];//用来记录该顶点是否被访问过！<br />
int path(int u)
{<br />
    int v;<br />
    for(v=0;v&lt;ny;v++)<br />
    {<br />
        if(edge[u][v]&amp;&amp;!visited[v])<br />
        {<br />
            visited[v]=1;<br />
           if(cy[v]==-1||path(cy[v]))//如果y集合中的v元素没有匹配或者是v已经匹配，但是从cy[v]中能够找到一条增广路<br />
            {<br />
                cx[u]=v; //找到增广路，修改匹配M<br />
                cy[v]=u;<br />
                return 1;<br />
            }<br />
        }<br />
    }<br />
    return 0;<br />
}<br />
int maxmatch()<br />
{<br />
    int res=0;<br />
    memset(cx,0xff,sizeof(cx));//初始值为-1表示两个集合中都没有匹配的元素！<br />
    memset(cy,0xff,sizeof(cy));<br />
    for(int i=0;i&lt;=nx;i++)<br />
    {<br />
        if(cx[i]==-1)   //还没被匹配，执行内部代码<br />
        {<br />
            memset(visited,0,sizeof(visitited));  //重置标记为为访问<br />
            res+=path(i);   //以 i 为起点开始查找增广路，返回true ，匹配数+1<br />
        }<br />
    }<br />
    return res;<br />
}</p>
:ET