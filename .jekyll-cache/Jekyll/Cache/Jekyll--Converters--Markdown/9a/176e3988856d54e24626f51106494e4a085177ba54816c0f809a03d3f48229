I"ş*<p>https://blog.csdn.net/u010853261/article/details/84790392
https://blog.csdn.net/u010853261/article/details/84901386</p>

<!-- more -->
<ol>
  <li>
    <p>ç¯å¢ƒ
è¦åˆ†æruntimeç›¸å…³å†…éƒ¨æœºåˆ¶ï¼Œé¦–å…ˆä»ç³»ç»Ÿå¯åŠ¨å¼€å§‹ã€‚é¦–å…ˆå‡†å¤‡åˆ†æç¯å¢ƒï¼šgolangã€OSã€gdb</p>
  </li>
  <li>
    <p>å¼•å¯¼ç¨‹åºå®è§‚æµç¨‹
åœ¨goä»£ç é‡Œé¢ï¼Œç”¨æˆ·é€»è¾‘ä»main.main()å¼€å§‹ï¼Œé‚£ä¹ˆruntimeå¦‚ä½•å¯åŠ¨ï¼Ÿæ€ä¹ˆåˆå§‹åŒ–ï¼Ÿåˆå§‹åŒ–åšäº†å“ªäº›å·¥ä½œå‘¢ï¼Ÿ</p>
  </li>
</ol>

<p>è¿™é‡Œæˆ‘ä»¬ä»å‡½æ•°è¿è¡Œçš„èµ·ç‚¹å¼€å§‹åˆ†æã€‚æˆ‘ä»¬å…ˆç¼–å†™ä¸€ä¸ªæœ€ç®€å•çš„goä»£ç ï¼š</p>

<p>package main</p>

<p>import â€œfmtâ€</p>

<p>func main() {
	fmt.Println(â€œhello,golangâ€)
}
1
2
3
4
5
6
7
è¿™æ˜¯æœ€ç®€å•çš„ä¸€ä¸ªæºç ç‰ˆæœ¬äº†ï¼Œç„¶åç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Œä½¿ç”¨GDBåŠ¨æ€æŸ¥çœ‹å³å¯ã€‚</p>

<p>$go build -o test2
$gdb test2
1
2
å…ˆç”¨go buildç¼–è¯‘å¯æ‰§è¡Œæ–‡ä»¶ï¼Œç„¶åç”¨GDBå‘½ä»¤gdb test2è¿›å…¥è°ƒè¯•åˆ†ææºç ç•Œé¢ã€‚</p>

<p>ä½¿ç”¨gdbå‘½ä»¤å¯ä»¥è·å–åˆ°ç³»ç»Ÿçš„Entry Pointç„¶åæ‰¾åˆ°å‡½æ•°å…¥å£ã€‚å‘ç°æ˜¯åœ¨</p>

<p>(gdb) info symbol 0x1051fd0
_rt0_amd64_darwin in section .text
1
2
åœ¨rt0_darwin_amd64.sé‡Œé¢ï¼š</p>

<p>TEXT _rt0_amd64_darwin(SB),NOSPLIT,$-8
	JMP	_rt0_amd64(SB)
1
2
ç„¶ååœ¨ï¼šasm_amd64.sé‡Œé¢å‘ç°äº†_rt0_amd64ä»£ç æ®µï¼Œå¦‚ä¸‹ï¼š</p>

<p>TEXT _rt0_amd64(SB),NOSPLIT,$-8
	MOVQ	0(SP), DI	// argc
	LEAQ	8(SP), SI	// argv
	JMP	runtimeÂ·rt0_go(SB)
1
2
3
4
æœ€åè°ƒç”¨äº†runtime.runtimeÂ·rt0_goï¼Œç³»ç»Ÿåˆå§‹åŒ–ä¸»è¦é€»è¾‘ä¹Ÿæ˜¯åœ¨è¿™ä¸ªåœ°æ–¹(å·²åˆ å‡ä¸é‡è¦é€»è¾‘)ï¼›
å…·ä½“çš„æºç è§ asm_amd64.s</p>

<p>TEXT runtimeÂ·rt0_go(SB),NOSPLIT,$0
	â€¦â€¦
	CALL	runtimeÂ·args(SB)
	CALL	runtimeÂ·osinit(SB)
	CALL	runtimeÂ·schedinit(SB)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// create a new goroutine to start program
MOVQ	$runtimeÂ·mainPC(SB), AX		// entry
PUSHQ	AX
PUSHQ	$0			// arg size
CALL	runtimeÂ·newproc(SB)
POPQ	AX
POPQ	AX

// start this M
CALL	runtimeÂ·mstart(SB)

CALL	runtimeÂ·abort(SB)	// mstart should never return
RET

// Prevent dead-code elimination of debugCallV1, which is
// intended to be called by debuggers.
MOVQ	$runtimeÂ·debugCallV1(SB), AX
RET
</code></pre></div></div>

<p>åœ¨å®Œæˆå‘½ä»¤è¡Œåˆå§‹åŒ–ã€OSåˆå§‹åŒ–ã€è°ƒåº¦å™¨åˆå§‹åŒ–ä¹‹åã€‚ä½¿ç”¨newprocåˆ›å»ºä¸€ä¸ªgoroutineæ”¾å…¥å¾…è¿è¡Œé˜Ÿåˆ—ã€‚ç„¶åmstartè®©ä¸»çº¿ç¨‹è¿›å…¥ä»»åŠ¡è°ƒåº¦æ¨¡å¼ï¼Œä»é˜Ÿåˆ—æå‡ºmain goroutineå¹¶æ‰§è¡Œã€‚</p>

<p>bootstrap overview</p>

<ol>
  <li>åˆå§‹åŒ–æµç¨‹
åˆå§‹åŒ–çš„æµç¨‹é‡Œé¢ï¼Œå‘½ä»¤è¡Œåˆå§‹åŒ–å’ŒOSåˆå§‹åŒ–ä¸è°ƒåº¦å™¨çš„æœºåˆ¶å…³ç³»ä¸å¤§ï¼Œè¿™é‡Œå°±ä¸åšä¸»è¦è®²è§£ï¼Œè¿™é‡Œä¸»è¦å…³å¿ƒè°ƒåº¦å™¨çš„åˆå§‹åŒ–ï¼Œåˆå§‹åŒ–å‡½æ•°schedinit()åœ¨runtime/proc.go è¿™ä¸ªæºç é‡Œé¢ã€‚</li>
</ol>

<p>3.1 schedule init
åˆå§‹åŒ–çš„ä»£ç åœ¨proc.goé‡Œé¢çš„schedule_initå‡½æ•°ï¼Œæºç å¦‚ä¸‹(åªä¿ç•™æ ¸å¿ƒæµç¨‹ä»£ç )ï¼š</p>

<p>// The bootstrap sequence is:
//
//	call osinit
//	call schedinit
//	make &amp; queue new G
//	call runtimeÂ·mstart
//
// The new G calls runtimeÂ·main.
func schedinit() {
	// Mæœ€å¤§æ•°é‡é™åˆ¶
	sched.maxmcount = 10000</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å†…å­˜ç›¸å…³åˆå§‹åŒ–
stackinit()
mallocinit()
// mç›¸å…³åˆå§‹åŒ–
mcommoninit(_g_.m)
// å‘½ä»¤å‚æ•°å’Œç¯å¢ƒåˆå§‹åŒ–
goargs()
goenvs()
// GC åˆå§‹åŒ–
gcinit()
// è®¾ç½®GOMAXPROCS
procs := ncpu
if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok &amp;&amp; n &gt; 0 {
	procs = n
}
if procresize(procs) != nil {
	throw("unknown runnable goroutine during bootstrap")
} }
</code></pre></div></div>

<p>è°ƒåº¦å™¨çš„åˆå§‹åŒ–ä¸»è¦ç›¸å…³å†…å®¹ä¸Šé¢æ³¨é‡Šéƒ½æè¿°çš„æ¯”è¾ƒæ¸…æ¥šäº†ï¼Œä¸»è¦æ˜¯åˆå§‹åŒ–æ ˆç©ºé—´åˆ†é…å™¨, GC, æŒ‰cpuæ ¸å¿ƒæ•°é‡æˆ–GOMAXPROCSçš„å€¼ç”ŸæˆPç­‰ã€‚</p>

<p>ç‰¹åˆ«è¦ä¸»è¦çš„æ˜¯ç”ŸæˆPçš„æ“ä½œåœ¨procresizeå‡½æ•°é‡Œé¢ï¼Œå¦‚æœåœ¨runtimeéœ€è¦æ›´æ”¹Pçš„æ•°é‡ä¹Ÿæ˜¯è°ƒç”¨è¿™ä¸ªå‡½æ•°ã€‚è¿™ä¸ªå‡½æ•°ä¸»è¦é€»è¾‘å¦‚ä¸‹æºç ï¼š</p>

<p>// Returns list of Ps with local work, they need to be scheduled by the caller.
func procresize(nprocs int32) <em>p {
	// Grow allp if necessary.
	if nprocs &gt; int32(len(allp)) {
		// Synchronize with retake, which could be running
		// concurrently since it doesnâ€™t run on a P.
		lock(&amp;allpLock)
		if nprocs &lt;= int32(cap(allp)) {
			allp = allp[:nprocs]
		} else {
			nallp := make([]</em>p, nprocs)
			// Copy everything up to allpâ€™s cap so we
			// never lose old allocated Ps.
			copy(nallp, allp[:cap(allp)])
			allp = nallp
		}
		unlock(&amp;allpLock)
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// initialize new P's
for i := int32(0); i &lt; nprocs; i++ {
	pp := allp[i]
	if pp == nil {
		pp = new(p)
		pp.id = i
		pp.status = _Pgcstop
		pp.sudogcache = pp.sudogbuf[:0]
		for i := range pp.deferpool {
			pp.deferpool[i] = pp.deferpoolbuf[i][:0]
		}
		pp.wbBuf.reset()
		atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))
	}
	if pp.mcache == nil {
		if old == 0 &amp;&amp; i == 0 {
			if getg().m.mcache == nil {
				throw("missing mcache?")
			}
			pp.mcache = getg().m.mcache // bootstrap
		} else {
			pp.mcache = allocmcache()
		}
	}
}

// free unused P's
for i := nprocs; i &lt; old; i++ {
	p := allp[i]
	// move all runnable goroutines to the global queue
	for p.runqhead != p.runqtail {
		// pop from tail of local queue
		p.runqtail--
		gp := p.runq[p.runqtail%uint32(len(p.runq))].ptr()
		// push onto head of global queue
		globrunqputhead(gp)
	}
	if p.runnext != 0 {
		globrunqputhead(p.runnext.ptr())
		p.runnext = 0
	}
	// if there's a background worker, make it runnable and put
	// it on the global queue so it can clean itself up
	if gp := p.gcBgMarkWorker.ptr(); gp != nil {
		casgstatus(gp, _Gwaiting, _Grunnable)
		if trace.enabled {
			traceGoUnpark(gp, 0)
		}
		globrunqput(gp)
		// This assignment doesn't race because the
		// world is stopped.
		p.gcBgMarkWorker.set(nil)
	}
	// Flush p's write barrier buffer.
	if gcphase != _GCoff {
		wbBufFlush1(p)
		p.gcw.dispose()
	}
	for i := range p.sudogbuf {
		p.sudogbuf[i] = nil
	}
	p.sudogcache = p.sudogbuf[:0]
	for i := range p.deferpool {
		for j := range p.deferpoolbuf[i] {
			p.deferpoolbuf[i][j] = nil
		}
		p.deferpool[i] = p.deferpoolbuf[i][:0]
	}
	freemcache(p.mcache)
	p.mcache = nil
	gfpurge(p)
	traceProcFree(p)
	if raceenabled {
		raceprocdestroy(p.racectx)
		p.racectx = 0
	}
	p.gcAssistTime = 0
	p.status = _Pdead
	// can't free P itself because it can be referenced by an M in syscall
}

// Trim allp.
if int32(len(allp)) != nprocs {
	lock(&amp;allpLock)
	allp = allp[:nprocs]
	unlock(&amp;allpLock)
}

_g_ := getg()
if _g_.m.p != 0 &amp;&amp; _g_.m.p.ptr().id &lt; nprocs {
	// continue to use the current P
	_g_.m.p.ptr().status = _Prunning
} else {
	// release the current P and acquire allp[0]
	if _g_.m.p != 0 {
		_g_.m.p.ptr().m = 0
	}
	_g_.m.p = 0
	_g_.m.mcache = nil
	p := allp[0]
	p.m = 0
	p.status = _Pidle
	acquirep(p)
}
var runnablePs *p
for i := nprocs - 1; i &gt;= 0; i-- {
	p := allp[i]
	if _g_.m.p.ptr() == p {
		continue
	}
	p.status = _Pidle
	if runqempty(p) {
		pidleput(p)
	} else {
		p.m.set(mget())
		p.link.set(runnablePs)
		runnablePs = p
	}
}
stealOrder.reset(uint32(nprocs))
var int32p *int32 = &amp;gomaxprocs // make compiler check that gomaxprocs is an int32
atomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs))
return runnablePs }
</code></pre></div></div>

<p>ä¸»è¦é€»è¾‘å¦‚ä¸‹ï¼š</p>

<p>å¦‚æœæ–°çš„GOMAXPROCSçš„å€¼å¤§äºå·²æœ‰çš„å…¨å±€å˜é‡é‡Œé¢Pçš„æ•°é‡ï¼Œé‚£ä¹ˆéœ€è¦æ‰©å®¹
åŠ é”allpLockç„¶åé‡æ–°ç”Ÿæˆæ–°çš„GOMAXPROCSæ•°é‡çš„Pæ•°ç»„ï¼Œå¹¶å°†åŸæ¥å·²æœ‰çš„Pæ•°ç»„copyè¿‡æ¥ï¼Œé‡æ–°æ„é€ Pæ•°ç»„ä¹‹åé‡Šæ”¾allpLocké”
åˆå§‹åŒ–å¹¶newæ–°çš„P(GOMAXPROCSæ•°é‡å¤§äºold Pæ•°é‡)
å¦‚æœGOMAXPROCSå°äºold Pæ•°é‡ï¼Œé‚£ä¹ˆæ—§çš„Péœ€è¦freeæ‰ï¼Œfreeæ—¶å€™æ¶‰åŠåˆ°ä¸€äº›PæŒæœ‰ç›¸å…³èµ„æºçš„é‡Šæ”¾å’Œè½¬ç§»
move all runnable goroutines to the global queue(contain local queue and p.runnext)
if thereâ€™s a background worker, make it runnable and put it on the global queue so it can clean itself up
release related cache
mark P state Pdead
é‡æ–°èµ‹å€¼runtime.allp
å¦‚æœå½“å‰gçš„Pä»ç„¶æœ‰æ•ˆï¼Œé‚£ä¹ˆç»§ç»­ä½¿ç”¨å½“å‰Pï¼Œå¦‚æœå½“å‰gçš„På·²ç»è¢«releaseï¼Œé‚£ä¹ˆé€‰æ‹©runtime.allp[0]ä½œä¸ºå½“å‰gçš„æ–°Pã€‚
æ›´æ–°runtime.allpçš„çŠ¶æ€æœºä¸ºPidle
å½“æˆ‘ä»¬æ›´æ–°GOMAXPROCSæ•°é‡æ—¶å€™ï¼Œè°ƒåº¦å™¨ä¼šè¢«åŠ ä¸Šå…¨å±€é”ï¼Œä¹Ÿä¼šå‡ºå‘Stop the Worldã€‚æ‰€ä»¥é™¤äº†ç³»ç»Ÿå¯åŠ¨æ—¶å€™è°ƒç”¨å¤–ï¼Œä¸å»ºè®®åœ¨å…¶ä½™åœ°æ–¹è§¦å‘è¿™ä¸ªå‡½æ•°ï¼Œååˆ†å½±å“æ€§èƒ½ã€‚</p>

<p>3.2 runtime.main
å®Œæˆæ ¸å¿ƒåˆå§‹åŒ–ä¹‹ååˆ›å»ºå¹¶æ‰§è¡Œmain goroutineï¼Œå…¶å®ä¹Ÿå°±æ˜¯runtime.mainå‡½æ•°ã€‚</p>

<p>æœ‰ä¸€ä¸ªæ¦‚å¿µéœ€è¦åŒºåˆ†æ¸…æ¥šï¼Œå‰é¢æè¿°çš„åˆå§‹åŒ–å±äºå†…æ ¸å±‚é¢çš„åˆå§‹åŒ–ï¼Œè¿˜æœ‰ä¸€ç§åˆå§‹åŒ–å±äºç”¨æˆ·å±‚é¢é€»è¾‘åˆå§‹åŒ–ï¼ŒåŒ…æ‹¬runtimeåŒ…ã€æ ‡å‡†åº“ã€ç”¨æˆ·ã€ç¬¬ä¸‰æ–¹åŒ…åˆå§‹åŒ–å‡½æ•°ã€‚é€»è¾‘å±‚é¢çš„åˆå§‹åŒ–å¯èƒ½å…³ç³»åˆ°å¾ˆå¤šçš„åŒæ­¥å…³ç³»ï¼Œä»£ç ä¾èµ–ç­‰ç­‰ã€‚</p>

<p>å‡½æ•°çš„æ ¸å¿ƒä»£ç å¦‚ä¸‹ï¼šproc.go#main</p>

<p>// The main goroutine.
func main() {
	// Max stack size is 1 GB on 64-bit, 250 MB on 32-bit.
	if sys.PtrSize == 8 {
		maxstacksize = 1000000000
	} else {
		maxstacksize = 250000000
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Allow newproc to start new Ms.
mainStarted = true

// å¯åŠ¨åå°ç›‘æ§çº¿ç¨‹
if GOARCH != "wasm" { // no threads on wasm yet, so no sysmon
	systemstack(func() {
		newm(sysmon, nil)
	})
}
// runtimeåŒ…é‡Œé¢çš„åˆå§‹åŒ–å‡½æ•°
runtime_init() // must be before defer

// Record when the world started. Must be after runtime_init
// because nanotime on some platforms depends on startNano.
runtimeInitTime = nanotime()
//å¯åŠ¨GC
gcenable()
//æ‰§è¡Œç”¨æˆ·ã€æ ‡å‡†åº“ï¼Œä¸‰æ–¹åŒ…é‡Œé¢çš„åˆå§‹åŒ–å‡½æ•°
fn := main_init // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime
fn()
// å¦‚æœæ˜¯åº“æ–¹å¼å°±ä¸æ‰§è¡Œç”¨æˆ·å…¥å£å‡½æ•°
if isarchive || islibrary {
	// A program compiled with -buildmode=c-archive or c-shared
	// has a main, but it is not executed.
	return
}
//æ‰§è¡Œç”¨æˆ·å…¥å£å‡½æ•°
fn = main_main // make an indirect call, as the linker doesn't know the address of the main package when laying down the runtime
fn()
// é€€å‡ºè¿›ç¨‹
exit(0)
for {
	var x *int32
	*x = 0
} }
</code></pre></div></div>

<p>æœ‰å‡ ä¸ªéœ€è¦æ³¨æ„çš„ç‚¹ï¼š
1ï¼‰goroutineçš„æ ˆæœ€å¤§å€¼æ˜¯1G(64ä½ç³»ç»Ÿ)
2ï¼‰ä¼šå¯åŠ¨ä¸€ä¸ªåå°ç›‘æ§çº¿ç¨‹ï¼Œè¿™ä¸ªç›‘æ§çº¿ç¨‹ä¹Ÿæ˜¯å®ŒæˆæŠ¢å å¼è°ƒåº¦çš„åœ°æ–¹
3ï¼‰ç›®æ ‡æ˜¯runtime.initã€main.initã€ä»¥åŠmain.mainè¿™ä¸ªå…¥å£å‡½æ•°</p>

<p>runtime.initå‡½æ•°å’Œmain.initç”±ç¼–è¯‘å™¨ç¼–è¯‘ç”Ÿæˆï¼Œè´Ÿè´£è°ƒç”¨æ‰€æœ‰çš„åˆå§‹åŒ–å‡½æ•°ã€‚</p>

<p>runtime.initå‡½æ•°ä»…ä»…è´Ÿè´£runtimeåŒ…ï¼Œ
main.initå‡½æ•°è´Ÿè´£ç”¨æˆ·ã€æ ‡å‡†åº“å’Œç¬¬ä¸‰æ–¹æ‰€æœ‰initå‡½æ•°ï¼Œ
æ‰€æœ‰åˆå§‹åŒ–éƒ½åœ¨main goroutineä¸­å®Œæˆ
å…¨éƒ¨åˆå§‹åŒ–å®Œæˆå†æ‰§è¡Œmain.mainå‡½æ•°ã€‚</p>
:ET