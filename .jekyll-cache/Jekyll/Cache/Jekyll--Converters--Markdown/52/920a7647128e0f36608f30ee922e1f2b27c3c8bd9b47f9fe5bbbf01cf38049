I"¢Ğ<p>åœ¨ä¼˜åŒ–acè‡ªåŠ¨æœºæ—¶å‘ç°åœ¨åŒ¹é…è¿‡ç¨‹ä¸­æœ‰å¤§é‡æ—¶é—´æ¶ˆè€—åœ¨GCé‡Œé¢ï¼Œé€šè¿‡pprofå‘ç°matchè¿‡ç¨‹æœ‰å¾ˆå¤šçš„ä¸´æ—¶å˜é‡é€ƒé€¸åˆ°heapé‡Œï¼Œå¢åŠ äº†å¾ˆå¤šçš„GCå‹åŠ›ï¼Œç®€è¦è®°å½•ä¸‹é—®é¢˜å®šä½çš„è¿‡ç¨‹ã€‚</p>

<p>é—®é¢˜å®šä½</p>

<p>é¦–å…ˆéœ€è¦åœ¨æµ‹è¯•ç¨‹åºæ·»åŠ ç”Ÿæˆpprofæ•°æ®çš„ä»£ç æ®µã€‚</p>

<p>f, err := os.Create(â€œbenchmark.profâ€)
  if err != nil {
  	log.Fatal(err)
  }
  defer f.Close()
  pprof.StartCPUProfile(f)
  defer pprof.StopCPUProfile()</p>

<p>go func() {
  	http.ListenAndServe(â€œ:8787â€, http.DefaultServeMux)
  }()</p>

<p>â€¦
  // ç­‰å¾…ä¸€æ®µæ—¶é—´åšé—®é¢˜åˆ†æ
  fmt.Println(â€œnCTL+C exit http pprofâ€)
  time.Sleep(15 * time.Minute)
æŸ¥çœ‹å„å‡½æ•°è°ƒç”¨ç”³è¯·çš„å†…å­˜å¯¹è±¡å¤§å°ã€‚</p>

<p>go tool pprof -alloc_space -svg http://localhost:8787/debug/pprof/heap &gt; ~/Desktop/go_heap.svg
image</p>

<p>æˆ‘ä»¬å‘ç°matchOfç”³è¯·äº†å¤§é‡çš„å†…å­˜ï¼Œäºæ˜¯æ€€ç–‘matchOfå¯èƒ½å­˜åœ¨å˜é‡é€ƒé€¸ï¼Œä½¿ç”¨-gcflags -mé‡æ–°ç”Ÿæˆæµ‹è¯•ç¨‹åºå‘ç°ç¡®å®å­˜åœ¨MatchTokenä¸´æ—¶å˜é‡é€ƒé€¸åˆ°heapã€‚</p>

<table>
  <tbody>
    <tr>
      <td>go build -gcflags -m</td>
      <td>grep escape</td>
    </tr>
  </tbody>
</table>

<p>../acmatcher.go:165: &amp;MatchToken literal escapes to heap
  ../acmatcher.go:165: &amp;MatchToken literal escapes to heap
â€‹</p>

<p>é—®é¢˜ä¿®å¤</p>

<p>ä½¿ç”¨interface{}å®ç°çš„æ³›å‹fixedbufå­˜åœ¨å˜é‡é€ƒé€¸æƒ…å†µï¼Œç›´æ¥ä½¿ç”¨sliceåšå›ºå®šçš„buf.</p>

<p>// FixedBuffer fixed reuse buffer for zero alloc
  type FixedBuffer struct {
  	b   interface{}
  	idx int
  	cap int
  	op  iBufferOP
  }</p>

<p>type iBufferOP interface {
  	assign(fb *FixedBuffer, val interface{})
  	init(fb *FixedBuffer, n int)
  }</p>

<p>func (fb *FixedBuffer) push(t interface{}) {
  	if fb.idx &gt;= fb.cap {
  		panic(â€œERROR buffer overflowâ€)
  	}
  	fb.op.assign(fb, t)
  	fb.idx++
  }</p>

<p>func (fb *FixedBuffer) reset() {
  	fb.idx = 0
  }</p>

<p>func NewFixedBuffer(n int, op iBufferOP) *FixedBuffer {
  	fb := &amp;FixedBuffer{
  		// b:   make([]interface{}, n),
  		idx: 0,
  		cap: n,
  		op:  op,
  	}
  	fb.op.init(fb, n)
  	return fb
  }
ä¼˜åŒ–åï¼Œå‡½æ•°è°ƒç”¨å®Œå…¨ZeroAllocï¼Œè¾¾åˆ°äº†ä½¿ç”¨fixedbufferçš„é¢„æœŸ.</p>

<p>type mbuf struct {
  	token  []MatchToken
  	at     []matchAt
  	ti, ai int
  }</p>

<p>func (mb *mbuf) reset() {
  	mb.ai, mb.ti = 0, 0
  }</p>

<p>func (mb *mbuf) addToken(mt MatchToken) {
  	if mb.ti &gt;= TokenBufferSize {
  		panic(â€œERROR buffer overflowâ€)
  	}
  	mb.token[mb.ti] = mt
  	mb.ti++
  }</p>

<p>func (mb *mbuf) addAt(mt matchAt) {
  	if mb.ai &gt;= MatchBufferSize {
  		panic(â€œERROR buffer overflowâ€)
  	}
  	mb.at[mb.ai] = mt
  	mb.ai++
  }
é—®é¢˜åŸå› </p>

<p>é¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸‹é¢è¿™ä¸ªå˜é‡é€ƒé€¸ç¤ºä¾‹</p>

<p>func main() {
	lc := 1
	s := make([]interface{}, lc)
	s[0] = lc
}</p>

<p>func main2() {
	lc := 1
	s := make([]*int, lc)
	s[0] = &amp;lc
}</p>

<p>go run -gcflags=â€™-m -mâ€™ sample2.go
./sample2.go:5: make([]interface {}, lc) escapes to heap
./sample2.go:6: lc escapes to heap
makeä»å †ç”³è¯·ï¼Œè¿™ç‚¹æ— å¯åšéï¼Œæˆ‘ä»¬æŠŠinterface{}æ”¹ä¸ºintç±»å‹å</p>

<p>func main() {
	lc := 1
	s := make([]int, lc)
	s[0] = lc
}</p>

<p>go run -gcflags=â€™-m -mâ€™ sample2.go
./sample2.go:5: make([]interface {}, lc) escapes to heap
makeå¾—åˆ°çš„sliceæ˜¯åœ¨å †ç”³è¯·çš„ï¼Œç”Ÿå‘½å‘¨æœŸæ¯”å‡½æ•°æ›´é•¿ï¼Œå½“sliceé‡Œä¸ºå¼•ç”¨æ—¶å˜é‡ä¼šè½¬ç§»åˆ°å †ï¼Œè€Œinterface{}èƒ½æ¥æ”¶ä»»æ„ç±»å‹ï¼Œåœ¨åšé€ƒé€¸åˆ†ææ—¶ï¼Œä¿å®ˆçš„è®¤ä¸ºè¾“å…¥çš„å€¼å¯èƒ½æ˜¯å¼•ç”¨ï¼Œæ‰€ä»¥æŠŠå˜é‡ç§»åˆ°å †é‡Œå»äº†ã€‚stackoverflowç›¸å…³èµ„æ–™ï¼š</p>

<p>make for a slice returns a slice descriptor struct (pointer to underlying array, length, and capacity) and allocates an underlying slice element array. The underlying array is generally allocated on the heap: make([]<em>int, lc) escapes to heap from make([]</em>int, lc).</p>

<p>s[0] = &amp;v stores a reference to the variable v (&amp;v) in the underlying array on the heap: &amp;v escapes to heap from s[0] (slice-element-equals), moved to heap: v. The reference remains on the heap, after the function ends and its stack is reclaimed, until the underlying array is garbage collected.</p>

<p>If the make slice capacity is a small (compile time) constant, make([]*int, 1) in your example, the underlying array may be allocated on the stack. However, escape analysis does not take this into account.</p>

<p>https://www.dazhuanlan.com/2020/03/09/5e65cb2d01af6/
<!-- more -->
package main</p>

<p>import (
    â€œfmtâ€
)</p>

<p>func main(){
    s := []byte(â€œâ€)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s1 := append(s, 'a')
s2 := append(s, 'b')

// å¦‚æœæœ‰æ­¤è¡Œï¼Œæ‰“å°çš„ç»“æœæ˜¯ a bï¼Œå¦åˆ™æ‰“å°çš„ç»“æœæ˜¯b b
// fmt.Println(s1, "===", s2)
fmt.Println(string(s1), string(s2)) }
</code></pre></div></div>

<p>è¯¡å¼‚çš„ç°è±¡ï¼šå¦‚æœæœ‰è¡Œ 14 çš„ä»£ç ï¼Œåˆ™è¡Œ 15 æ‰“å°çš„ç»“æœä¸º a bï¼Œ å¦åˆ™æ‰“å°çš„ç»“æœä¸ºb b ï¼Œæœ¬æ–‡åˆ†æçš„goç‰ˆæœ¬ï¼š</p>

<p>$ go version
go version go1.9.2 darwin/amd64
åˆæ­¥åˆ†æ
é¦–å…ˆæˆ‘ä»¬åˆ†æåœ¨æ²¡æœ‰è¡Œ14çš„æƒ…å†µä¸‹ï¼Œä¸ºä»€ä¹ˆæ‰“å°çš„ç»“æœæ˜¯ b bï¼Œè¿™ä¸ªé—®é¢˜ç›¸å¯¹æ¯”è¾ƒç®€å•ï¼Œåªè¦ç†Ÿæ‚‰ slice çš„å®ç°åŸç†ï¼Œç®€å•åˆ†æä¸€ä¸‹ append çš„å®ç°åŸç†å³å¯å¾—å‡ºç»“è®ºã€‚</p>

<p>slice ç»“æ„åˆ†æ
å¦‚æœç†Ÿæ‚‰ slice çš„åŸç†å¯ä»¥è·³è¿‡è¯¥ç« èŠ‚ã€‚</p>

<p>é¦–å…ˆå¯¹äº slice ç»“æ„è¿›è¡Œä¸€ä¸ªç®€å•çš„äº†è§£ ç»“æ„å®šä¹‰ sliceå¯¹åº”çš„runtime åŒ…çš„ç›¸å…³æºç å‚è§ï¼š https://golang.org/src/runtime/slice.go</p>

<p>type slice struct {
    array unsafe.Pointer
    len   int
    cap   int
}</p>

<p>var slice []int å®šä¹‰çš„å˜é‡å†…éƒ¨ç»“æ„å¦‚ä¸‹ï¼š</p>

<p>slice.array = nil
slice.len = 0
slice.cap = 0
å¦‚æœæˆ‘ä»¬å£°æ˜äº†ä¸€ä¸‹å˜é‡ slice := []int{} æˆ– slice := make([]int, 0) çš„å†…éƒ¨ç»“æ„å¦‚ä¸‹ï¼š</p>

<p>slice.array = 0xxxxxxxx  // åˆ†é…äº†åœ°å€
slice.len = 0
slice.cap = 18208800
å¦‚æœä½¿ç”¨ make([]byte, 5) å®šä¹‰çš„è¯ï¼Œç»“æ„å¦‚ä¸‹å›¾ï¼š</p>

<p>å¦‚æœä½¿ç”¨ s := s[2:4]ï¼Œåˆ™ç»“æ„å¦‚ä¸‹å›¾ï¼š</p>

<p>é€šè¿‡åˆ†æ slice çš„åå°„de å®ç°ï¼šGo Slices: usage and internalsï¼Œä¹Ÿèƒ½å¤Ÿåœ¨ç¨‹åºä¸­è¿›è¡Œåˆ†æã€‚slice åå°„ä¸­å¯¹åº”çš„ç»“æ„ä½“</p>

<p>// slice å¯¹åº”çš„ç»“æ„ä½“
type SliceHeader struct {
        Data uintptr
        Len  int
        Cap  int
}</p>

<p>// string å¯¹åº”ç»“æ„ä½“
type StringHeader struct {
        Data uintptr
        Len  int
}
ä¸‹é¢çš„å‡½æ•°å¯ä»¥ç›´æ¥è·å– slice çš„åº•å±‚æŒ‡é’ˆï¼š</p>

<p>func bytePointer(b []byte) unsafe.Pointer {
   // slice çš„æŒ‡é’ˆæœ¬è´¨æ˜¯<em>reflect.SliceHeader
  p := (</em>reflect.SliceHeader)(unsafe.Pointer(&amp;b))
  return unsafe.Pointer(p.Data)
}
append åŸç†å®ç°
Append çš„å®ç°ä¼ªä»£ç ï¼Œä»£ç é»˜è®¤å·²ç»æ”¯æŒäº† slice ä¸º nil çš„æƒ…å†µ</p>

<p>func Append(slice, data []byte) []byte {
    l := len(slice)
    if l + len(data) &gt; cap(slice) {  // reallocate
        // Allocate double whatâ€™s needed, for future growth.
        newSlice := make([]byte, (l+len(data))*2)
        // The copy function is predeclared and works for any slice type.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    copy(slice[l:], data)
    return slice
}
append å‡½æ•°åŸå‹å¦‚ä¸‹ï¼Œå…¶ä¸­ T ä¸ºé€šç”¨ç±»å‹ã€‚</p>

<p>func append(s []T, x â€¦T) []T
å±•å¼€åˆ†æ
ä¸ºäº†æ–¹ä¾¿ç¨‹åºåˆ†æçš„ï¼Œæˆ‘ä»¬åœ¨ç¨‹åºä¸­æ·»åŠ æ‰“å°ä¿¡æ¯ï¼Œä»£ç å’Œç»“æœå¦‚ä¸‹ï¼š</p>

<p>package main</p>

<p>import (
    â€œfmtâ€
)</p>

<p>func main() {
    s := []byte(â€œâ€)
    println(s) // æ·»åŠ ç”¨äºæ‰“å°ä¿¡æ¯, println() print() ä¸ºgoå†…ç½®å‡½æ•°ï¼Œç›´æ¥è¾“å‡ºåˆ° stderr æ— ç¼“å­˜</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s1 := append(s, 'a')
s2 := append(s, 'b')

// fmt.Println(s1, "===", s2)
fmt.Println(string(s1), string(s2)) }
</code></pre></div></div>

<p>è¿è¡Œç¨‹åºç»“æœå¦‚ä¸‹ï¼š</p>

<p>$ go run q.go
[0/32]0xc420045ef8
b b
ç»“æœè¿è¡Œå s := []byte(â€œâ€) åˆå§‹åŒ–ä»¥åç»“æ„å†…éƒ¨å¦‚ä¸‹ï¼š</p>

<p>s.len = 0 
s.cap = 32
s.ptr = 0xc420045ef8
æˆ‘ä»¬åˆ†æä»¥ä¸‹ä¸¤è¡Œä»£ç è°ƒç”¨ä¼šå‘ç”Ÿä»€ä¹ˆï¼š</p>

<p>s1 := append(s, â€˜aâ€™)
s2 := append(s, â€˜bâ€™)
s1 := append(s, â€˜aâ€™) ä»£ç è°ƒç”¨åˆ†æï¼š</p>

<p>// slice = s  data = <code class="language-plaintext highlighter-rouge">a</code>   slice.len = 0 slice.cap = 32    <br />
func Append(slice, data []byte) []byte {
    l := len(slice) // l = 0</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// l = 0 len(data) = 1  cap(slice) = 32   1 + 1 &gt; 32 false
if l + len(data) &gt; cap(slice) { 
    newSlice := make([]byte, (l+len(data))*2)
    copy(newSlice, slice)
    slice = newSlice
}
// l = 0 len(data) = 1
slice = slice[0:l+len(data)] // slice = slice[0:1]
copy(slice[l:], data)  // è°ƒç”¨å˜æˆï¼š copy(slice[0:], 'a') 
return slice // ç”±äºæœªæ¶‰åŠåˆ°é‡åˆ†é…ï¼Œå› æ­¤è¿”å›çš„è¿˜æ˜¯åŸæ¥çš„ slice å¯¹è±¡ } s2 := append(s, 'b') çš„åˆ†æå®Œå…¨ä¸€æ ·ã€‚
</code></pre></div></div>

<p>ç®€åŒ– apend å‡½æ•°çš„å¤„ç†è·¯å¾„ï¼Œåœ¨æ²¡æœ‰è¿›è¡Œ slice é‡æ–°åˆ†é…å†…å­˜æƒ…å†µä¸‹ï¼Œç›´æ¥è¿›è¡Œå±•å¼€åˆ†æï¼š</p>

<p>s1 := append(s, â€˜aâ€™)
s2 := append(s, â€˜bâ€™)
ç­‰ä»·äº</p>

<p>s1 := copy(s[0:], â€˜aâ€™)
s2 := copy(s[0:], â€˜bâ€™) // ç›´æ¥è¦†ç›–äº†ä¸Šçš„èµ‹å€¼
åŸºäºä¸Šè¿°åˆ†æï¼Œèƒ½å¤Ÿå¾ˆå¥½åœ°è§£é‡Šä»£ç è¾“å‡ºb bçš„æƒ…å†µã€‚ä½†æ˜¯å¦‚ä½•é¿å…å‡ºç°è¿™ç§ç±»å‹çš„æƒ…å†µå‘¢ï¼Ÿé—®é¢˜å‡ºç°åœ¨è¿™æ¡è¯­å¥ä¸Š</p>

<p>s := []byte(â€œâ€)
è¯­å¥æ‰§è¡Œå s.len = 0 s.cap = 32ï¼Œå¯¼è‡´äº† append çš„å·¥ä½œä¸èƒ½å¤Ÿæ­£å¸¸å·¥ä½œï¼Œé‚£ä¹ˆæ­£å¸¸å¦‚ä½•ä½¿ç”¨ï¼Ÿåªè¦å°† s.len = s.cap = 0 åˆ™ä¼šå¯¼è‡´ slice åœ¨ append ä¸­é‡æ–°è¿›è¡Œåˆ†é…åˆ™å¯ä»¥é¿å…è¿™ç§æƒ…å†µçš„å‘ç”Ÿã€‚</p>

<p>æ­£ç¡®çš„å†™æ³•åº”è¯¥ä¸ºï¼š</p>

<p>func main() {
    // Notice []byte(â€œâ€) -&gt;  []byte{}    æˆ–è€…  var s []byte
    s := []byte{}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s1 := append(s, 'a')
s2 := append(s, 'b')

// fmt.Println(s1, "===", s2)
fmt.Println(string(s1), string(s2)) } ç”±æ­¤ä¹Ÿå¯ä»¥çœ‹å‡ºä¸€ä¸ªè‰¯å¥½çš„ç¼–ç¨‹ä¹ æƒ¯æ˜¯å¯ä»¥è§„é¿å¾ˆå¤šè«åå…¶å¦™çš„é—®é¢˜æ’æŸ¥ã€‚
</code></pre></div></div>

<p>æ·±å…¥åˆ†æ
é‚£ä¹ˆæ—¢ç„¶ bug å‡ºç°åœ¨äº† s := []byte(â€œâ€œ)è¿™å¥è¯ä¸­ï¼Œé‚£ä¹ˆè¿™æ¡è¯­å¥ä¸ºä»€ä¹ˆä¼šå¯¼è‡´ s.cap = 32 å‘¢ï¼Ÿè¿™æ¡è¯­å¥èƒŒåéšè—çš„é€»è¾‘æ˜¯ä»€ä¹ˆå‘¢?</p>

<p>s := []byte(â€œâ€) ç­‰ä»·äºä»¥ä¸‹ä»£ç ï¼š</p>

<p>// åˆå§‹åŒ–å­—ç¬¦ä¸²
str := â€œâ€</p>

<p>// å°†å­—ç¬¦ä¸²è½¬æ¢æˆ []byte
s := []byte(str)
åœ¨goè¯­è¨€ä¸­ s := []byte(str) çš„åº•å±‚å…¶å®æ˜¯è°ƒç”¨äº† stringtoslicebyte å®ç°çš„ï¼Œè¯¥å‡½æ•°ä½äº go çš„ runtimeåŒ…ä¸­ã€‚</p>

<p>const tmpStringBufSize = 32</p>

<p>type tmpBuf [tmpStringBufSize]byte</p>

<p>func stringtoslicebyte(buf *tmpBuf, s string) []byte {
    var b []byte
    // å¦‚æœå­—ç¬¦ä¸² s çš„é•¿åº¦å†…éƒ¨é•¿åº¦ä¸è¶…è¿‡ 32ï¼Œ é‚£ä¹ˆå°±ç›´æ¥åˆ†é…ä¸€ä¸ª 32 ç›´æ¥çš„å¤§å°
    if buf != nil &amp;&amp; len(s) &lt;= len(buf) { 
        *buf = tmpBuf{}
        b = buf[:len(s)]
    } else {
        b = rawbyteslice(len(s))
    }
    copy(b, s)
    return b
}
å¦‚æœå­—ç¬¦ä¸²çš„å¤§å°æ²¡æœ‰è¶…è¿‡ 32 é•¿åº¦çš„å¤§å°ï¼Œåˆ™é»˜è®¤åˆ†é…ä¸€ä¸ª 32 é•¿åº¦çš„ bufï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ä»¬ä¸Šé¢åˆ†æ s.cap = 32 çš„ç”±æ¥ã€‚</p>

<p>åˆ°æ­¤ä¸ºæ­¢ï¼Œæˆ‘ä»¬ä»ç„¶æ²¡æœ‰åˆ†æé—®é¢˜ä¸­ fmt.Println(s1, â€œ===â€, s2) è¿™å¥æ‰“å°æ³¨é‡Šæ‰å°±èƒ½å¤Ÿæ­£å¸¸å·¥ä½œçš„åŸå› ï¼Ÿé‚£ä¹ˆæœ€ç»ˆåˆ°åº•æ˜¯ä»€ä¹ˆæ ·çš„æƒ…å†µå‘¢ï¼Ÿ</p>

<p>æœ€ç»ˆåˆ†æ
æœ€åæˆ‘ä»¬æ¥å¯ç”¨é­”æ³•çš„å¼€å…³ fmt.Println(s1, â€œ===â€, s2), æ¥è¿›è¡Œæœ€åè°œåº•çš„æ­æ™“ï¼š</p>

<p>package main</p>

<p>import (
    â€œfmtâ€
)</p>

<p>func main() {
    s := []byte(â€œâ€)
    println(s) // æ·»åŠ ç”¨äºæ‰“å°ä¿¡æ¯</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s1 := append(s, 'a')
s2 := append(s, 'b')

fmt.Println(s1, "===", s2)
fmt.Println(string(s1), string(s2)) } $ go run q.go [0/0]0x115b820   # éœ€è¦æ³¨æ„ s.len = 0 s.cap = 0 [97] === [98]    # å–æ¶ˆäº†æ‰“å°çš„æ³¨é‡Š a b              # æ‰“å°ä¸€åˆ‡æ­£å¸¸ $ go run -gcflags '-S -S' q.go ....
0x0032 00050 (q.go:8)   MOVQ    $0, (SP)
0x003a 00058 (q.go:8)   MOVQ    $0, 8(SP)
0x0043 00067 (q.go:8)   MOVQ    $0, 16(SP)
0x004c 00076 (q.go:8)   PCDATA  $0, $0
0x004c 00076 (q.go:8)   CALL    runtime.stringtoslicebyte(SB)
0x0051 00081 (q.go:8)   MOVQ    32(SP), AX
0x0056 00086 (q.go:8)   MOVQ    AX, "".s.len+96(SP)
0x005b 00091 (q.go:8)   MOVQ    40(SP), CX
0x0060 00096 (q.go:8)   MOVQ    CX, "".s.cap+104(SP)
0x0065 00101 (q.go:8)   MOVQ    24(SP), DX
0x006a 00106 (q.go:8)   MOVQ    DX, "".s.ptr+136(SP)
</code></pre></div></div>

<p>â€¦.
é€šè¿‡åˆ†æå‘ç°åº•å±‚è°ƒç”¨çš„ä»ç„¶æ˜¯ runtime.stringtoslicebyte(), ä½†æ˜¯è¡Œä¸ºå´å‘ç”Ÿäº†å˜åŒ– s.len = s.cap = 0ï¼Œå¾ˆæ˜¾ç„¶ç”±äº fmt.Println(s1, â€œ===â€, s2) è¡Œçš„å‡ºç°å¯¼è‡´äº† s := []byte(â€œâ€œ)å†…å­˜åˆ†é…çš„æƒ…å†µå‘ç”Ÿäº†å˜åŒ–ã€‚</p>

<p>æˆ‘ä»¬å¯ä»¥é€šè¿‡ go build æä¾›çš„å†…å­˜åˆ†é…å·¥å…·è¿›è¡Œåˆ†æï¼š</p>

<p>$ go build -gcflags â€œ-m -mâ€ q.go</p>
<h1 id="command-line-arguments">command-line-arguments</h1>
<p>./q.go:7:6: cannot inline main: non-leaf function
./q.go:14:13: s1 escapes to heap
./q.go:14:13:   from â€¦ argument (arg to â€¦) at ./q.go:14:13
./q.go:14:13:   from *(â€¦ argument) (indirection) at ./q.go:14:13
./q.go:14:13:   from â€¦ argument (passed to call[argument content escapes]) at ./q.go:14:13
./q.go:8:13: ([]byte)(â€œâ€) escapes to heap
./q.go:8:13:    from s (assigned) at ./q.go:8:4
./q.go:8:13:    from s1 (assigned) at ./q.go:11:5
./q.go:8:13:    from s1 (interface-converted) at ./q.go:14:13
./q.go:8:13:    from â€¦ argument (arg to â€¦) at ./q.go:14:13
./q.go:8:13:    from *(â€¦ argument) (indirection) at ./q.go:14:13
./q.go:8:13:    from â€¦ argument (passed to call[argument content escapes]) at ./q.go:14:13</p>

<p>ä»¥ä¸Šè¾“å‡ºä¸­çš„ s1 escapes to heap å’Œ ([]byte)(â€œâ€) escapes to heap è¡¨æ˜ï¼Œç”±äº fmt.Println(s1, â€œ===â€, s2) ä»£ç çš„å¼•å…¥å¯¼è‡´äº†å˜é‡åˆ†é…æ¨¡å‹çš„å˜åŒ–ã€‚ç®€å•ç‚¹è®²å°±æ˜¯ä»æ ˆä¸­é€ƒé€¸åˆ°äº†å †ä¸Šã€‚å†…å­˜é€ƒé€¸çš„åˆ†ææˆ‘ä»¬ä¼šåœ¨åé¢çš„ç« èŠ‚è¯¦ç»†ä»‹ç»ã€‚é—®é¢˜åˆ°æ­¤ï¼Œå¤§æ¦‚çš„æ€è·¯å·²ç»æœ‰äº†ï¼Œä½†æ˜¯æˆ‘ä»¬å¦‚ä½•é€šè¿‡ä»£ç å±‚é¢è¿›è¡ŒéªŒè¯å‘¢? é€šè¿‡æœç´¢ go æºç å®ç°è°ƒç”¨çš„å‡½æ•° runtime.stringtoslicebyte çš„åœ°æ–¹è¿›è¡Œå…¥æ‰‹ã€‚é€šè¿‡æœç´¢å‘ç°è°ƒç”¨çš„æ–‡ä»¶åœ¨ cmd/compile/internal/gc/walk.go</p>

<p>å…³äº stringåˆ°[]byte åˆ†æè°ƒç”¨çš„ä»£ç å¦‚ä¸‹</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case OSTRARRAYBYTE:
    a := nodnil()  // åˆ†é…åˆ°å †ä¸Šçš„çš„é»˜è®¤è¡Œä¸º

    if n.Esc == EscNone {
        // Create temporary buffer for slice on stack.
        t := types.NewArray(types.Types[TUINT8], tmpstringbufsize)

        a = nod(OADDR, temp(t), nil)  // åˆ†é…åœ¨æ ˆä¸Šï¼Œå¤§å°ä¸º32
    }

    n = mkcall("stringtoslicebyte", n.Type, init, a, conv(n.Left, types.Types[TSTRING])) OSTRARRAYBYTE å®šä¹‰
</code></pre></div></div>

<p>OSTRARRAYBYTE    // Type(Left) (Type is []byte, Left is a string)
ä¸Šè¿°ä»£ç ä¸­çš„ n.Esc == EscNone æ¡ä»¶åˆ†æåˆ™è¡¨æ˜äº†å‘ç”Ÿå†…å­˜é€ƒé€¸å’Œä¸å‘ç”Ÿå†…å­˜é€ƒé€¸çš„æƒ…å†µä¸‹ï¼Œåˆå§‹åŒ–çš„æ–¹å¼æ˜¯ä¸åŒçš„ã€‚ EscNone çš„å®šä¹‰ï¼š</p>

<p>EscNone           // Does not escape to heap, result, or parameters.
é€šè¿‡ä»¥ä¸Šåˆ†æï¼Œæˆ‘ä»¬æ€»ç®—æ‰¾åˆ°äº†é­”æ³•çš„æœ€ç»ˆè°œåº•ã€‚ ä»¥ä¸Šåˆ†æçš„goè¯­è¨€ç‰ˆæœ¬åŸºäº 1.9.2ï¼Œä¸åŒçš„goè¯­è¨€çš„å†…å­˜åˆ†é…æœºåˆ¶å¯èƒ½ä¸åŒï¼Œå…·ä½“å¯ä»¥å‚è§æˆ‘åŒäº‹æ›´åŠ è¯¦ç»†çš„åˆ†æ Goä¸­stringè½¬[]byteçš„é™·é˜±.md</p>

<p>Go å†…å­˜ç®¡ç†
Go è¯­è¨€èƒ½å¤Ÿè‡ªåŠ¨è¿›è¡Œå†…å­˜ç®¡ç†ï¼Œé¿å…äº† C è¯­è¨€ä¸­çš„å†…å­˜è‡ªå·±ç®¡ç†çš„éº»çƒ¦ï¼Œä½†æ˜¯åŒæ—¶å¯¹äºä»£ç çš„å†…å­˜ç®¡ç†å’Œå›æ”¶ç»†èŠ‚è¿›è¡Œäº†å°è£…ï¼Œä¹Ÿæ½œåœ¨å¢åŠ äº†ç³»ç»Ÿè°ƒè¯•å’Œä¼˜åŒ–çš„éš¾åº¦ã€‚åŒæ—¶ï¼Œå†…å­˜è‡ªåŠ¨ç®¡ç†ä¹Ÿæ˜¯ä¸€é¡¹éå¸¸å›°éš¾çš„äº‹æƒ…ï¼Œæ¯”å¦‚å‡½æ•°çš„å¤šå±‚è°ƒç”¨ã€é—­åŒ…è°ƒç”¨ã€ç»“æ„ä½“æˆ–è€…ç®¡é“çš„å¤šæ¬¡èµ‹å€¼ã€åˆ‡ç‰‡å’ŒMAPã€CGOè°ƒç”¨ç­‰å¤šç§æƒ…å†µç»¼åˆä¸‹ï¼Œå¾€å¾€ä¼šå¯¼è‡´è‡ªåŠ¨ç®¡ç†ä¼˜åŒ–æœºåˆ¶å¤±æ•ˆï¼Œé€€åŒ–æˆåŸå§‹çš„ç®¡ç†çŠ¶æ€ï¼›go ä¸­çš„å†…å­˜å›æ”¶ï¼ˆGCï¼‰ç­–ç•¥ä¹Ÿåœ¨ä¸æ–­åœ°ä¼˜åŒ–è¿‡ç¨‹ã€‚Golang ä»ç¬¬ä¸€ä¸ªç‰ˆæœ¬ä»¥æ¥ï¼ŒGC ä¸€ç›´æ˜¯å¤§å®¶è¯Ÿç—…æœ€å¤šçš„ï¼Œä½†æ˜¯æ¯ä¸€ä¸ªç‰ˆæœ¬çš„å‘å¸ƒåŸºæœ¬éƒ½ä¼´éšç€ GC çš„æ”¹è¿›ã€‚ä¸‹é¢åˆ—å‡ºä¸€äº›æ¯”è¾ƒé‡è¦çš„æ”¹åŠ¨ã€‚</p>

<p>v1.1 STW
v1.3 Mark STW, Sweep å¹¶è¡Œ
v1.5 ä¸‰è‰²æ ‡è®°æ³•
v1.8 hybrid write barrier
é¢„çƒ­åŸºç¡€çŸ¥è¯†ï¼šHow do I know whether a variable is allocated on the heap or the stack?</p>

<p>é€ƒé€¸åˆ†æ-Escape Analysis
æ›´æ·±å…¥å’Œç»†è‡´çš„äº†è§£å»ºè®®é˜…è¯» William Kennedy çš„ 4 ç¯‡ Post</p>

<p>go æ²¡æœ‰åƒ C è¯­è¨€é‚£æ ·æä¾›ç²¾ç¡®çš„å †ä¸æ ˆåˆ†é…æ§åˆ¶ï¼Œç”±äºæä¾›äº†å†…å­˜è‡ªåŠ¨ç®¡ç†çš„åŠŸèƒ½ï¼Œå¾ˆå¤§ç¨‹åº¦ä¸Šæ¨¡ç³Šäº†å †ä¸æ ˆçš„ç•Œé™ã€‚ä¾‹å¦‚ä»¥ä¸‹ä»£ç ï¼š</p>

<p>package main</p>

<p>func main() {
    str := GetString()
    _ = str
}</p>

<p>func GetString() *string {
    var s string
    s = â€œhelloâ€
    return &amp;s
}
è¡Œ 10 ä¸­çš„å˜é‡ s = â€œhelloâ€ å°½ç®¡å£°æ˜åœ¨äº† GetString() å‡½æ•°å†…ï¼Œä½†æ˜¯åœ¨ main å‡½æ•°ä¸­å´ä»ç„¶èƒ½å¤Ÿè®¿é—®åˆ°è¿”å›çš„å˜é‡ï¼›è¿™ç§åœ¨å‡½æ•°å†…å®šä¹‰çš„å±€éƒ¨å˜é‡ï¼Œèƒ½å¤Ÿçªç ´è‡ªèº«çš„èŒƒå›´è¢«å¤–éƒ¨è®¿é—®çš„è¡Œä¸ºç§°ä½œé€ƒé€¸ï¼Œä¹Ÿå³é€šè¿‡é€ƒé€¸å°†å˜é‡åˆ†é…åˆ°å †ä¸Šï¼Œèƒ½å¤Ÿè·¨è¾¹ç•Œè¿›è¡Œæ•°æ®å…±äº«ã€‚</p>

<p>Escape Analysis æŠ€æœ¯å°±æ˜¯ä¸ºè¯¥åœºæ™¯è€Œå­˜åœ¨çš„ï¼›é€šè¿‡ Escape Analysis æŠ€æœ¯ï¼Œç¼–è¯‘å™¨ä¼šåœ¨ç¼–è¯‘é˜¶æ®µå¯¹ä»£ç åšäº†åˆ†æï¼Œå½“å‘ç°å½“å‰ä½œç”¨åŸŸçš„å˜é‡æ²¡æœ‰è·¨å‡ºå‡½æ•°èŒƒå›´ï¼Œåˆ™ä¼šè‡ªåŠ¨åˆ†é…åœ¨ stack ä¸Šï¼Œåä¹‹åˆ™åˆ†é…åœ¨ heap ä¸Šã€‚ go çš„å†…å­˜å›æ”¶é’ˆå¯¹çš„ä¹Ÿæ˜¯å †ä¸Šçš„å¯¹è±¡ã€‚go è¯­è¨€ä¸­ Escape Analysisè¿˜æœªçœ‹åˆ°å®˜æ–¹ spec çš„æ–‡æ¡£ï¼Œå› æ­¤å¾ˆå¤šç‰¹æ€§éœ€è¦è¿›è¡Œä»£ç å°è¯•å’Œåˆ†ææ‰èƒ½å¾—å‡ºç»“è®ºï¼Œè€Œä¸” go Escape Analysis çš„å®ç°è¿˜å­˜åœ¨å¾ˆå¤šä¸å®Œå–„çš„åœ°æ–¹ã€‚</p>

<p>stack allocation is cheap and heap allocation is expensive.</p>

<p>Go è¯­è¨€é€ƒé€¸åˆ†æå®ç°
æ›´å¤šå†…å­˜å»ºè®®é˜…è¯» Allocation efficiency in high-performance Go services</p>

<p>2.go</p>

<p>package main</p>

<p>import â€œfmtâ€</p>

<p>func main() {
        x := 42
        fmt.Println(x)
}
go build å·¥å…·ä¸­çš„ flag -gcflags â€˜-mâ€™ å¯ä»¥ç”¨æ¥åˆ†æå†…å­˜é€ƒé€¸çš„æƒ…å†µæ±‡æ€»ï¼Œæœ€å¤šå¯ä»¥æä¾› 4 ä¸ª â€œ-mâ€, m è¶Šå¤šåˆ™è¡¨ç¤ºåˆ†æçš„ç¨‹åº¦è¶Šè¯¦ç»†ï¼Œä¸€èˆ¬æƒ…å†µä¸‹æˆ‘ä»¬å¯ä»¥é‡‡ç”¨ä¸¤ä¸ª m åˆ†æã€‚</p>

<p>$ go build -gcflags â€˜-m -lâ€™ 2.go</p>
<h1 id="command-line-arguments-1">command-line-arguments</h1>
<p>./2.go:7:13: x escapes to heap
./2.go:7:13: main â€¦ argument does not escape</p>

<h1 id="-l-disable-inline-ä¹Ÿå¯ä»¥è°ƒç”¨çš„å‡½æ•°å‰æ·»åŠ æ³¨é‡Š">-l disable inlineï¼Œ ä¹Ÿå¯ä»¥è°ƒç”¨çš„å‡½æ•°å‰æ·»åŠ æ³¨é‡Š</h1>
<p>$ go build -gcflags â€˜-m -m -lâ€™ 2.go</p>
<h1 id="command-line-arguments-2">command-line-arguments</h1>
<p>./2.go:7:13: x escapes to heap
./2.go:7:13:    from â€¦ argument (arg to â€¦) at ./2.go:7:13
./2.go:7:13:    from *(â€¦ argument) (indirection) at ./2.go:7:13
./2.go:7:13:    from â€¦ argument (passed to call[argument content escapes]) at ./2.go:7:13
./2.go:7:13: main â€¦ argument does not escape
ä¸Šä¾‹ä¸­çš„ x escapes to heap åˆ™è¡¨æ˜äº†å˜é‡ x å˜é‡é€ƒé€¸åˆ°äº†å †ï¼ˆheapï¼‰ä¸Šã€‚å…¶ä¸­ -l è¡¨ç¤ºä¸å¯ç”¨ inline æ¨¡å¼è°ƒç”¨ï¼Œå¦åˆ™ä¼šä½¿å¾—åˆ†ææ›´åŠ å¤æ‚ï¼Œä¹Ÿå¯ä»¥åœ¨å‡½æ•°ä¸Šæ–¹æ·»åŠ æ³¨é‡Š //go:noinlineç¦æ­¢å‡½æ•° inlineè°ƒç”¨ã€‚è‡³äºè°ƒç”¨ fmt.Println()ä¸ºä»€ä¹ˆä¼šå¯¼è‡´ x escapes to heapï¼Œå¯ä»¥å‚è€ƒ Issue #19720 å’Œ Issue #8618ï¼Œå¯¹äºä¸Šè¿° fmt.Println() çš„è¡Œä¸ºæˆ‘ä»¬å¯ä»¥é€šè¿‡ä»¥ä¸‹ä»£ç è¿›è¡Œç®€å•æ¨¡æ‹Ÿæµ‹è¯•ï¼Œæ•ˆæœåŸºæœ¬ä¸€æ ·ï¼š</p>

<p>package main</p>

<p>type pp struct {
    arg interface{}
}</p>

<p>func MyPrintln(a â€¦interface{}) {
    Fprintln(aâ€¦)
}</p>

<p>func Fprintln(a â€¦interface{}) (n int, err error) {
    pp := new(pp)
    pp.arg = a  // æ­¤å¤„å¯¼è‡´äº†å†…å­˜çš„é€ƒé€¸
    return
}</p>

<p>func main() {
    x := 42
    MyPrintln(x)
}
å†…å­˜é€ƒé€¸åˆ†æç»“æœå¦‚ä¸‹ï¼š</p>

<p>$ go build -gcflags â€˜-m -m -lâ€™ 3.go</p>
<h1 id="command-line-arguments-3">command-line-arguments</h1>
<p>./3.go:13:9: a escapes to heap
./3.go:13:9:    from pp.arg (star-dot-equals) at ./3.go:13:9
./3.go:11:45: leaking param: a
./3.go:11:45:   from a (interface-converted) at ./3.go:13:9
./3.go:11:45:   from pp.arg (star-dot-equals) at ./3.go:13:9
./3.go:12:11: Fprintln new(pp) does not escape
./3.go:7:21: leaking param: a
./3.go:7:21:    from a (passed to call[argument escapes]) at ./3.go:8:10
./3.go:19:11: â€¦ argument escapes to heap
./3.go:19:11:   from â€¦ argument (passed to call[argument escapes]) at ./3.go:19:11
./3.go:19:11: x escapes to heap
./3.go:19:11:   from â€¦ argument (arg to â€¦) at ./3.go:19:11
./3.go:19:11:   from â€¦ argument (passed to call[argument escapes]) at ./3.go:19:11
é€ƒé€¸çš„å¸¸è§æƒ…å†µåˆ†æå‚è§ï¼š http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html</p>

<p>ä¸»è¦åŸå› å¦‚ä¸‹ï¼šå˜é‡ x è™½ä¸º int ç±»å‹ï¼Œä½†æ˜¯åœ¨ä¼ é€’ç»™å‡½æ•° MyPrintlnå‡½æ•°ä¸­è¢«è½¬æ¢æˆ interface{} ç±»å‹ï¼Œå› ä¸º interface{} ç±»å‹ä¸­åŒ…å«æŒ‡å‘æ•°æ®çš„åœ°å€ï¼Œå› æ­¤ x åœ¨ä¼ é€’åˆ°å‡½æ•° MyPrintlnè¿‡ç¨‹ä¸­è¿›è¡Œäº†ä¸€ä¸ªå†…å­˜é‡æ–°åˆ†é…çš„è¿‡ç¨‹ï¼Œç”±äº pp.arg = a ç»“æ„ä½“ä¸­çš„å­—æ®µèµ‹å€¼çš„å¼•ç”¨ï¼Œå¯¼è‡´äº†åç»­å˜é‡çš„é€ƒé€¸åˆ°äº†å †ä¸Šã€‚å¦‚æœå°†ä¸Šè¿° pp.arg = a æ³¨é‡Šæ‰ï¼Œåˆ™ä¸ä¼šå‡ºç°å†…å­˜é€ƒé€¸çš„æƒ…å†µã€‚</p>

<p>å¯¼è‡´å†…å­˜é€ƒé€¸çš„æƒ…å†µæ¯”è¾ƒå¤šï¼Œæœ‰äº›å¯èƒ½è¿˜æ˜¯å®˜æ–¹æœªèƒ½å¤Ÿå®ç°ç²¾ç¡®çš„åˆ†æé€ƒé€¸æƒ…å†µçš„ bugï¼Œç®€å•ä¸€ç‚¹æ¥è®²å°±æ˜¯å¦‚æœå˜é‡çš„ä½œç”¨åŸŸä¸ä¼šæ‰©å¤§å¹¶ä¸”å…¶è¡Œä¸ºæˆ–è€…å¤§å°èƒ½å¤Ÿåœ¨ç¼–è¯‘çš„æ—¶å€™ç¡®å®šï¼Œä¸€èˆ¬æƒ…å†µä¸‹éƒ½æ˜¯åˆ†é…åˆ°æ ˆä¸Šï¼Œå¦åˆ™å°±å¯èƒ½å‘ç”Ÿå†…å­˜é€ƒé€¸åˆ†é…åˆ°å †ä¸Šã€‚</p>

<p>ç®€å•æ€»ç»“ä¸€ä¸‹æœ‰ä»¥ä¸‹å‡ ç±»æƒ…å†µï¼š</p>

<p>å‘é€æŒ‡é’ˆçš„æŒ‡é’ˆæˆ–å€¼åŒ…å«äº†æŒ‡é’ˆåˆ° channel ä¸­ï¼Œç”±äºåœ¨ç¼–è¯‘é˜¶æ®µæ— æ³•ç¡®å®šå…¶ä½œç”¨åŸŸä¸ä¼ é€’çš„è·¯å¾„ï¼Œæ‰€ä»¥ä¸€èˆ¬éƒ½ä¼šé€ƒé€¸åˆ°å †ä¸Šåˆ†é…ã€‚
slices ä¸­çš„å€¼æ˜¯æŒ‡é’ˆçš„æŒ‡é’ˆæˆ–åŒ…å«æŒ‡é’ˆå­—æ®µã€‚ä¸€ä¸ªä¾‹å­æ˜¯ç±»ä¼¼[] *string çš„ç±»å‹ã€‚è¿™æ€»æ˜¯å¯¼è‡´ slice çš„é€ƒé€¸ã€‚å³ä½¿åˆ‡ç‰‡çš„åº•å±‚å­˜å‚¨æ•°ç»„ä»å¯èƒ½ä½äºå †æ ˆä¸Šï¼Œæ•°æ®çš„å¼•ç”¨ä¹Ÿä¼šè½¬ç§»åˆ°å †ä¸­ã€‚</p>

<p>slice ç”±äº append æ“ä½œè¶…å‡ºå…¶å®¹é‡ï¼Œå› æ­¤ä¼šå¯¼è‡´ slice é‡æ–°åˆ†é…ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œç”±äºåœ¨ç¼–è¯‘æ—¶ slice çš„åˆå§‹å¤§å°çš„å·²çŸ¥æƒ…å†µä¸‹ï¼Œå°†ä¼šåœ¨æ ˆä¸Šåˆ†é…ã€‚å¦‚æœ slice çš„åº•å±‚å­˜å‚¨å¿…é¡»åŸºäºä»…åœ¨è¿è¡Œæ—¶æ•°æ®è¿›è¡Œæ‰©å±•ï¼Œåˆ™å®ƒå°†åˆ†é…åœ¨å †ä¸Šã€‚</p>

<p>è°ƒç”¨æ¥å£ç±»å‹çš„æ–¹æ³•ã€‚æ¥å£ç±»å‹çš„æ–¹æ³•è°ƒç”¨æ˜¯åŠ¨æ€è°ƒåº¦ - å®é™…ä½¿ç”¨çš„å…·ä½“å®ç°åªèƒ½åœ¨è¿è¡Œæ—¶ç¡®å®šã€‚è€ƒè™‘ä¸€ä¸ªæ¥å£ç±»å‹ä¸º io.Reader çš„å˜é‡ rã€‚å¯¹ r.Read(b) çš„è°ƒç”¨å°†å¯¼è‡´ r çš„å€¼å’Œå­—èŠ‚ç‰‡bçš„åç»­è½¬ä¹‰å¹¶å› æ­¤åˆ†é…åˆ°å †ä¸Šã€‚ å‚è€ƒ http://npat-efault.github.io/programming/2016/10/10/escape-analysis-and-interfaces.html</p>

<p>å°½ç®¡èƒ½å¤Ÿç¬¦åˆåˆ†é…åˆ°æ ˆçš„åœºæ™¯ï¼Œä½†æ˜¯å…¶å¤§å°ä¸èƒ½å¤Ÿåœ¨åœ¨ç¼–è¯‘æ—¶å€™ç¡®å®šçš„æƒ…å†µï¼Œä¹Ÿä¼šåˆ†é…åˆ°å †ä¸Š</p>

<p>å…³äºæŒ‡é’ˆ
å…³äºæŒ‡é’ˆçš„ä½¿ç”¨å¤šæ•°æƒ…å†µä¸‹æˆ‘ä»¬ä¼šå—ä¸€ä¸ªå‰æå½±å“ï¼šâ€œæŒ‡é’ˆä¼ é€’è¿‡ç¨‹ä¸æ¶‰åŠåˆ°åº•å±‚æ•°æ®æ‹·è´ï¼Œå› æ­¤æ•ˆç‡æ›´é«˜â€ï¼Œè€Œä¸”ä¸€èˆ¬æƒ…å†µä¸‹ä¹Ÿçš„ç¡®æ˜¯å¦‚æ­¤ã€‚</p>

<p>ä½†æ˜¯ç”±äºæŒ‡é’ˆçš„è®¿é—®æ˜¯é—´æ¥å¯»å€ï¼Œä¹Ÿå°±æ˜¯è¯´è®¿é—®åˆ°äº†æŒ‡é’ˆä¿å­˜çš„åœ°å€åï¼Œè¿˜éœ€è¦æ ¹æ®ä¿å­˜çš„åœ°å€å†è¿›è¡Œä¸€æ¬¡è®¿é—®ï¼Œæ‰èƒ½è·å–åˆ°æŒ‡é’ˆæ‰€æŒ‡å‘çš„æ•°æ®ï¼Œå¦å¤–ä¸€ç§æƒ…å†µå¯¹äºæŒ‡é’ˆåœ¨ä½¿ç”¨çš„æ—¶å€™è¿˜éœ€è¦è¿›è¡Œ nil æƒ…å†µçš„åˆ¤æ–­ï¼Œä»¥é˜²æ­¢ panic çš„å‘ç”Ÿï¼Œæ›´é‡è¦çš„æ˜¯æŒ‡é’ˆæ‰€æŒ‡å‘çš„åœ°å€å¤šæ•°æ˜¯ä¿å­˜åœ¨å †ä¸Šï¼Œåœ¨æ¶‰åŠåˆ°å†…å­˜æ”¶å›çš„æƒ…å†µä¸‹ï¼ŒæŒ‡é’ˆçš„å­˜åœ¨å¯èƒ½ä¼šè®©ç¨‹åºçš„æ€§èƒ½å¤§æ‰“æŠ˜æ‰£ã€‚é™¤æ­¤ä¹‹å¤–ç”±äºæŒ‡é’ˆçš„é—´æ¥è®¿é—®ï¼Œè¿˜ä¼šå¯¼è‡´ç¼“å­˜çš„ä¼˜åŒ–å¤±æ•ˆï¼Œå¯ä»¥å‚è€ƒ Locality of referenceï¼Œå½“å‰åœ¨ç¼“å­˜ä¸­æ‹·è´å°‘é‡æ•°æ®ä¸æŒ‡é’ˆçš„è®¿é—®ç›¸æ¯”ï¼Œæ€§èƒ½ä¸ŠåŸºæœ¬ä¸Šå¯ä»¥ç­‰åŒã€‚</p>

<p>ç»¼ä¸Šæ‰€è¿°ï¼ŒæŒ‡é’ˆçš„ä½¿ç”¨ä¹Ÿä¸æ˜¯æ²¡æœ‰ä»£ä»·çš„ï¼Œéœ€è¦åˆç†è¿›è¡Œä½¿ç”¨ã€‚</p>

<p>â€œthe garbage collector will skip regions of memory that it can prove will contain no pointersâ€</p>

<p>ç®€å•ç‚¹è®²ï¼Œå¦‚æœåœ¨å †ä¸Šåˆ†é…çš„ç»“æ„ä¸­æŒ‡é’ˆæ¯”è¾ƒå°‘ï¼Œå›æ”¶çš„æœºåˆ¶ä¼šæ¯”è¾ƒç®€å•ï¼Œåº”è¯¥ä¼šæå‡å›æ”¶çš„æ•ˆç‡ï¼Œéœ€è¦é€šè¿‡äº†è§£ go å›æ”¶ç®—æ³•è¿›è¡Œç›¸å…³æµ‹è¯• ã€‚ TODO</p>

<p>å…³äºæ¥å£è½¬æ¢
æ¥å£å®ç°å‚è§ï¼š Go Data Structures: Interfaces Go interfaces: static vs dynamic binding</p>

<p>ä¸Šå›¾å±•ç¤ºäº†ä¸€ä¸ª Binary å¯¹è±¡è½¬æ¢æˆä¸€ä¸ª Stringer æ¥å£åçš„æ•°æ®ç»“æ„ã€‚æ£€æŸ¥ç±»å‹æ˜¯å¦åŒ¹é… s.tab-&gt;type å³å¯ã€‚</p>

<p>go è¯­è¨€ä¸­çš„ interface æ¥å£ï¼Œåœ¨ç¼–è¯‘æ—¶å€™çš„æ—¶å€™ä¼šè¿›è¡Œéšå¼è½¬æ¢çš„é™æ€æ£€æŸ¥ï¼Œä½†æ˜¯æ˜¾ç¤ºçš„ interface åˆ° interface çš„è½¬æ¢å¯ä»¥åœ¨è¿è¡Œæ—¶æŸ¥è¯¢æ–¹æ³•é›†ï¼ŒåŠ¨æ€æ£€æµ‹æ¯”å¦‚ï¼š</p>

<p>type Stringer interface {
    String() string
}</p>

<p>if v, ok := any.(Stringer); ok {
        return v.String()
 }
å…³äº Itab ç»“æ„çš„è®¡ç®—ï¼Œç”±äºï¼ˆinterfaceã€typeï¼‰å¯¹çš„ä¸ç¡®å®šæ€§ï¼Œgo ç¼–è¯‘å™¨æˆ–è€…é“¾æ¥å™¨ä¸å¯èƒ½åœ¨ç¼–è¯‘çš„æ—¶å€™è®¡ç®—ä¸¤è€…çš„å¯¹åº”å…³ç³»ï¼Œè€Œä¸”å³ä½¿èƒ½å¤Ÿè®¡ç®—å‡ºæ¥ä¹Ÿå¯èƒ½æ˜¯ç»å¤§å¤šæ•°çš„å¯¹åº”å…³ç³»åœ¨å®é™…ä¸­ä¸é€‚ç”¨ï¼›å› æ­¤ go ç¼–è¯‘å™¨ä¼šåœ¨ç¼–è¯‘çš„è¿‡ç¨‹ä¸­å¯¹äº interface å’Œ type ä¸­çš„æ–¹æ³•ç”Ÿæˆä¸€ä¸ªç›¸å…³çš„æè¿°ç»“æ„ï¼Œåˆ†åˆ«è®°å½• interface å’Œ type å„è‡ªå¯¹åº”çš„æ–¹æ³•é›†åˆï¼Œgo è¯­è¨€ä¼šåœ¨ type å®é™…çš„åŠ¨æ€è½¬æ¢æˆ interface è¿‡ç¨‹ä¸­ï¼Œå°† interafce ä¸­å®šä¹‰çš„æ–¹æ³•åœ¨ type ä¸­ä¸€ä¸€è¿›è¡Œå¯¹æ¯”æŸ¥æ‰¾ï¼Œå¹¶å®Œå–„ Itab ç»“æ„ï¼Œå¹¶å°† Itab ç»“æ„è¿›è¡Œç¼“å­˜æå‡æ€§èƒ½ã€‚</p>

<p>ç»¼ä¸Šæ‰€è¿°ï¼Œgo ä¸­çš„æ¥å£ç±»å‹çš„æ–¹æ³•è°ƒç”¨æ˜¯åŠ¨æ€è°ƒåº¦ï¼Œå› æ­¤ä¸èƒ½å¤Ÿåœ¨ç¼–è¯‘é˜¶æ®µç¡®å®šï¼Œæ‰€æœ‰ç±»å‹ç»“æ„è½¬æ¢æˆæ¥å£çš„è¿‡ç¨‹ä¼šæ¶‰åŠåˆ°å†…å­˜é€ƒé€¸çš„æƒ…å†µå‘ç”Ÿã€‚å¦‚æœå¯¹äºæ€§èƒ½è¦æ±‚æ¯”è¾ƒé«˜ä¸”è®¿é—®é¢‘æ¬¡æ¯”è¾ƒé«˜çš„å‡½æ•°è°ƒç”¨ï¼Œåº”è¯¥å°½é‡é¿å…ä½¿ç”¨æ¥å£ç±»å‹ã€‚</p>

<p>ä»¥ä¸‹æ ·ä¾‹å‚è€ƒï¼šhttp://npat-efault.github.io/programming/2016/10/10/escape-analysis-and-interfaces.html</p>

<p>package main</p>

<p>// go build -gcflags â€˜-m -m -lâ€™ 5.go</p>

<p>type S struct {
    s1 int
}</p>

<p>func (s *S) M1(i int) { s.s1 = i }</p>

<p>type I interface {
    M1(int)
}</p>

<p>func main() {
    var s1 S // this escapes
    var s2 S // this does not</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(&amp;s1)
f2(&amp;s2) }
</code></pre></div></div>

<p>func f1(s I)  { s.M1(42) }
func f2(s *S) { s.M1(42) }
é€ƒé€¸åˆ†æç¡®è®¤ï¼š</p>

<p>go build -gcflags â€˜-m -m -lâ€™ 5.go</p>
<h1 id="command-line-arguments-4">command-line-arguments</h1>
<p>./5.go:9:18: (*S).M1 s does not escape
./5.go:23:11: leaking param: s
./5.go:23:11:   from s.M1(42) (receiver in indirect call) at ./5.go:23:21
./5.go:24:12: f2 s does not escape
./5.go:19:5: &amp;s1 escapes to heap
./5.go:19:5:    from &amp;s1 (passed to call[argument escapes]) at ./5.go:19:4
./5.go:19:5: &amp;s1 escapes to heap
./5.go:19:5:    from &amp;s1 (interface-converted) at ./5.go:19:5
./5.go:19:5:    from &amp;s1 (passed to call[argument escapes]) at ./5.go:19:4
./5.go:16:6: moved to heap: s1
./5.go:20:5: main &amp;s2 does not escape</p>
<autogenerated>:1:0: leaking param: .this
<autogenerated>:1:0:    from .this.M1(.anon0) (receiver in indirect call) at <autogenerated>:1:0
æ€§èƒ½æµ‹è¯•åˆ†æï¼š

package main_test

import "testing"

// go test -bench . --benchmem -gcflags "-N -l" 5_test.go

type S struct {
    s1 int
}

func (s *S) M1(i int) {
    s.s1 = i
}

type I interface {
    M1(int)
}

func f1(s I)  { s.M1(86) }
func f2(s *S) { s.M1(86) }

func BenchmarkTestInterface(b *testing.B) {
    var s1 S
    for i := 0; i &lt; b.N; i++ {
        f1(&amp;s1)
    }
}

func BenchmarkTestNoInterface(b *testing.B) {
    var s2 S
    for i := 0; i &lt; b.N; i++ {
        f2(&amp;s2)
    }
}
ç¦æ­¢ä½¿ç”¨ inline æ–¹å¼çš„å‡½æ•°è°ƒç”¨æ€§èƒ½æŠ¥å‘Šï¼š

# ç¦æ­¢ä½¿ç”¨ inline
$ go test -bench . --benchmem -gcflags "-N -l" 5_test.go
goos: darwin
goarch: amd64
BenchmarkTestInterface-8        300000000            4.50 ns/op        0 B/op          0 allocs/op
BenchmarkTestNoInterface-8      500000000            3.80 ns/op        0 B/op          0 allocs/op
PASS
ok      command-line-arguments  4.094s

å¯ç”¨äº† inline æ–¹å¼çš„å‡½æ•°è°ƒç”¨æ€§èƒ½æŠ¥å‘Šï¼š

# å¦‚æœå¯ç”¨äº† inlineï¼Œæ€§èƒ½å·®åˆ«éå¸¸æ˜æ˜¾
$ go test -bench . --benchmem  5_test.go
goos: darwin
goarch: amd64
BenchmarkTestInterface-8        500000000            3.45 ns/op        0 B/op          0 allocs/op
BenchmarkTestNoInterface-8      2000000000           0.29 ns/op        0 B/op          0 allocs/op
PASS
ok      command-line-arguments  2.685s

å…³äºåˆ‡ç‰‡
ç”±äºåˆ‡ç‰‡ä¸€èˆ¬éƒ½æ˜¯ä½¿ç”¨åœ¨å‡½æ•°ä¼ é€’çš„åœºæ™¯ä¸‹ï¼Œè€Œä¸”åˆ‡ç‰‡åœ¨ append çš„æ—¶å€™å¯èƒ½ä¼šæ¶‰åŠåˆ°é‡æ–°åˆ†é…å†…å­˜ï¼Œå¦‚æœåˆ‡ç‰‡åœ¨ç¼–è¯‘æœŸé—´çš„å¤§å°ä¸èƒ½å¤Ÿç¡®è®¤æˆ–è€…å¤§å°è¶…å‡ºæ ˆçš„é™åˆ¶ï¼Œå¤šæ•°æƒ…å†µä¸‹éƒ½ä¼šåˆ†é…åˆ°å †ä¸Šã€‚

å¤§å°éªŒè¯
package main

func main() {
    s := make([]byte, 1, 1*1024)
    _ = s
}
$ go build -gcflags "-m -m" slice_esc.go
# command-line-arguments
./slice_esc.go:3:6: can inline main as: func() { s := make([]byte, 1, 1 * 1024); _ = s }
./slice_esc.go:4:11: main make([]byte, 1, 1 * 1024) does not escape
å¦‚æœ slice å¤§å°è¶…è¿‡ 64kï¼Œåˆ™ä¼šåˆ†é…åˆ°å †ä¸Š ï¼ˆgo 1.9.2)

package main

func main() {
    s := make([]byte, 1, 64*1024) // 64k
    _ = s
}
$ go build -gcflags "-m -m" slice_esc.go
# command-line-arguments
./slice_esc.go:3:6: can inline main as: func() { s := make([]byte, 1, 64 * 1024); _ = s }
./slice_esc.go:4:11: make([]byte, 1, 64 * 1024) escapes to heap
./slice_esc.go:4:11:    from make([]byte, 1, 64 * 1024) (too large for stack) at ./slice_esc.go:4:11

æŒ‡é’ˆç±»å‹åˆ‡ç‰‡éªŒè¯
package main

func main() {
    s := make([]*string, 1, 100)
    str := "hello"
    s = append(s, &amp;str)
    _ = s
}
$ go build -gcflags "-m -m -l" slice_esc.go
# command-line-arguments
./slice_esc.go:6:16: &amp;str escapes to heap
./slice_esc.go:6:16:    from append(s, &amp;str) (appended to slice) at ./slice_esc.go:6:12
./slice_esc.go:5:9: moved to heap: str
./slice_esc.go:4:11: main make([]*string, 1, 100) does not escape

å¯¹äºä¿å­˜åœ¨ []*string ä¸­çš„å­—ç¬¦ä¸²éƒ½ä¼šç›´æ¥åœ¨å †ä¸Šåˆ†é…ã€‚

package main

import "math/rand"

func main() {
    randSize := rand.Int()
    s := make([]*string, 0, randSize)
    str := "hello"
    s = append(s, &amp;str)
    _ = s
}
$ go build -gcflags "-m -m -l" slice_esc.go
# command-line-arguments
./slice_esc.go:7:11: make([]*string, 0, randSize) escapes to heap
./slice_esc.go:7:11:    from make([]*string, 0, randSize) (too large for stack) at ./slice_esc.go:7:11
./slice_esc.go:9:16: &amp;str escapes to heap
./slice_esc.go:9:16:    from append(s, &amp;str) (appended to slice) at ./slice_esc.go:9:12
./slice_esc.go:8:9: moved to heap: str
ç”±äº s := make([]*string, 0, randSize) å¤§å°ä¸èƒ½ç¼–è¯‘ç¡®å®šï¼Œæ‰€ä»¥ä¼šé€ƒé€¸åˆ°å †ä¸Šã€‚

å‚è€ƒ
Golang å†…å­˜é€ƒé€¸åˆ†æ
æ·±å…¥è§£æ Go ä¸­ Slice åº•å±‚å®ç° ***
ä»¥Cè§†è§’æ¥ç†è§£Goå†…å­˜é€ƒé€¸
golang stringå’Œ[]byteçš„å¯¹æ¯”
Go Slices: usage and internals
Where is append() implementation?
SliceTricks ***
Variadic func changes []byte(s) cap #24972
spec: clarify that conversions to slices don't guarantee slice capacity? #24163
Golang escape analysis ***
Go Escape Analysis Flaws
Escape Analysis for Java
Language Mechanics On Escape Analysis ä¸­æ–‡ ä¸­æ–‡2
Allocation efficiency in high-performance Go services ***
Profiling Go Programs
https://github.com/mushroomsir/blog/blob/master/Go%E4%B8%ADstring%E8%BD%AC%5B%5Dbyte%E7%9A%84%E9%99%B7%E9%98%B1.md
the-go-programming-language-report
https://golang.org/doc/faq
å¹´ç»ˆç›˜ç‚¹ï¼2017å¹´è¶…æœ‰ä»·å€¼çš„Golangæ–‡ç« 
Golang åƒåœ¾å›æ”¶å‰–æ
æ·±å…¥Golangä¹‹åƒåœ¾å›æ”¶

https://www.do1618.com/archives/1328/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/

ä¸‹é¢è¿™æ®µç¨‹åºä¼šè¾“å‡ºä»€ä¹ˆï¼Ÿ

package main
import "fmt"
func f(s []string, level int) {
        if level &gt; 5 {
               return
        }
        s = append(s, fmt.Sprint(level))
        f(s, level+1)
        fmt.Println("level:", level, "slice:", s)
}

func main() {
        f(nil, 0)
}
å…¶è¾“å‡ºä¸ºï¼š

level: 5 slice: [0 1 2 3 4 5]
level: 4 slice: [0 1 2 3 4]
level: 3 slice: [0 1 2 3]
level: 2 slice: [0 1 2]
level: 1 slice: [0 1]
level: 0 slice: [0]
å¦‚æœå¯¹è¾“å‡ºç»“æœæœ‰ä¸€äº›ç–‘æƒ‘,ä½ éœ€è¦äº†è§£è¿™ç¯‡æ–‡ç« çš„å†…å®¹

å¦‚æœä½ çŸ¥é“äº†ç»“æœ,ä½ ä»ç„¶éœ€è¦äº†è§£è¿™ç¯‡æ–‡ç« çš„å†…å®¹,å› ä¸ºæœ¬æ–‡å®Œæ•´ä»‹ç»äº†

åˆ‡ç‰‡çš„å…¸å‹ç”¨æ³•

åˆ‡ç‰‡çš„é™·é˜±

åˆ‡ç‰‡çš„é€ƒé€¸åˆ†æ

åˆ‡ç‰‡çš„æ‰©å®¹

åˆ‡ç‰‡åœ¨ç¼–è¯‘ä¸è¿è¡Œæ—¶çš„ç ”ç©¶

å¦‚æœä½ å•¥éƒ½çŸ¥é“äº†,è¯·ç›´æ¥æ»‘åŠ¨æœ€ä¸‹æ–¹,åŒå‡»666.

åˆ‡ç‰‡åŸºæœ¬æ“ä½œ
åˆ‡ç‰‡æ˜¯æŸç§ç¨‹åº¦ä¸Šå’Œå…¶ä»–è¯­è¨€(ä¾‹å¦‚Cè¯­è¨€)ä¸­çš„æ•°ç»„åœ¨ä½¿ç”¨ä¸­æœ‰è®¸å¤šç›¸ä¼¼ä¹‹å¤„,ä½†æ˜¯goè¯­è¨€ä¸­çš„åˆ‡ç‰‡æœ‰è®¸å¤šç‹¬ç‰¹ä¹‹å¤„

Sliceï¼ˆåˆ‡ç‰‡ï¼‰ä»£è¡¨å˜é•¿çš„åºåˆ—ï¼Œåºåˆ—ä¸­æ¯ä¸ªå…ƒç´ éƒ½æœ‰ç›¸åŒçš„ç±»å‹ã€‚

ä¸€ä¸ªsliceç±»å‹ä¸€èˆ¬å†™ä½œ[]Tï¼Œå…¶ä¸­Tä»£è¡¨sliceä¸­å…ƒç´ çš„ç±»å‹ï¼›sliceçš„è¯­æ³•å’Œæ•°ç»„å¾ˆåƒï¼Œä½†æ˜¯æ²¡æœ‰å›ºå®šé•¿åº¦ã€‚

æ•°ç»„å’Œsliceä¹‹é—´æœ‰ç€ç´§å¯†çš„è”ç³»ã€‚ä¸€ä¸ªsliceæ˜¯ä¸€ä¸ªè½»é‡çº§çš„æ•°æ®ç»“æ„ï¼Œæä¾›äº†è®¿é—®æ•°ç»„å­åºåˆ—ï¼ˆæˆ–è€…å…¨éƒ¨ï¼‰å…ƒç´ çš„åŠŸèƒ½ã€‚ä¸€ä¸ªsliceåœ¨è¿è¡Œæ—¶ç”±ä¸‰ä¸ªéƒ¨åˆ†æ„æˆï¼šæŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡ã€‚

type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}
æŒ‡é’ˆæŒ‡å‘ç¬¬ä¸€ä¸ªsliceå…ƒç´ å¯¹åº”çš„åº•å±‚æ•°ç»„å…ƒç´ çš„åœ°å€

é•¿åº¦å¯¹åº”sliceä¸­å…ƒç´ çš„æ•°ç›®ï¼›é•¿åº¦ä¸èƒ½è¶…è¿‡å®¹é‡

å®¹é‡ä¸€èˆ¬æ˜¯ä»sliceçš„å¼€å§‹ä½ç½®åˆ°åº•å±‚æ•°æ®çš„ç»“å°¾ä½ç½®çš„é•¿åº¦

åˆ‡ç‰‡çš„å£°æ˜
//åˆ‡ç‰‡çš„å£°æ˜1  //nil
var slice1 []int

//åˆ‡ç‰‡çš„å£°æ˜2
var slice2 []int = make([]int,5)
var slice3 []int = make([]int,5,7)
numbers:= []int{1,2,3,4,5,6,7,8}
åˆ‡ç‰‡çš„æˆªå–
numbers:= []int{1,2,3,4,5,6,7,8}
//ä»ä¸‹æ ‡1ä¸€ç›´åˆ°ä¸‹æ ‡4ï¼Œä½†æ˜¯ä¸åŒ…æ‹¬ä¸‹æ ‡4
numbers1 :=numbers[1:4]
//ä»ä¸‹æ ‡0ä¸€ç›´åˆ°ä¸‹æ ‡3ï¼Œä½†æ˜¯ä¸åŒ…æ‹¬ä¸‹æ ‡3
numbers2 :=numbers[:3]
//ä»ä¸‹æ ‡3ä¸€ç›´åˆ°ç»“æŸ
numbers3 :=numbers[3:]
åˆ‡ç‰‡çš„é•¿åº¦ä¸å®¹é‡
å†…ç½®çš„lenå’Œcapå‡½æ•°åˆ†åˆ«è¿”å›sliceçš„é•¿åº¦å’Œå®¹é‡

    slice6 := make([]int,0)
    fmt.Printf("len=%d,cap=%d,slice=%v\n",len(slice4),cap(slice4),slice4)
åˆ‡ç‰‡ä¸æ•°ç»„çš„æ‹·è´å¯¹æ¯”
æ•°ç»„çš„æ‹·è´æ˜¯å‰¯æœ¬æ‹·è´ã€‚å¯¹äºå‰¯æœ¬çš„æ”¹å˜ä¸ä¼šå½±å“åˆ°åŸæ¥çš„æ•°ç»„

ä½†æ˜¯ï¼Œåˆ‡ç‰‡çš„æ‹·è´å¾ˆç‰¹æ®Šï¼Œåˆ‡ç‰‡çš„æ‹·è´åªæ˜¯å¯¹äºè¿è¡Œæ—¶åˆ‡ç‰‡ç»“æ„ä½“çš„æ‹·è´,åˆ‡ç‰‡çš„å‰¯æœ¬ä»ç„¶æŒ‡å‘äº†ç›¸åŒçš„æ•°ç»„ã€‚æ‰€ä»¥ï¼Œå¯¹äºå‰¯æœ¬çš„ä¿®æ”¹ä¼šå½±å“åˆ°åŸæ¥çš„åˆ‡ç‰‡ã€‚

ä¸‹é¢ç”¨ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥è¯´æ˜

    //æ•°ç»„æ˜¯å€¼ç±»å‹
    a := [4]int{1, 2, 3, 4}

    //åˆ‡ç‰‡æ˜¯å¼•ç”¨ç±»å‹
    b := []int{100, 200, 300}

    c := a
    d := b

    c[1] = 200
    d[0] = 1
    //output: c[1 200 3 4] a[1 2 3 4]
    fmt.Println("a=", a, "c=", c)
    //output: d[1 200 300]  b[1 200 300]
    fmt.Println("b=", b, "d=", d)
åˆ‡ç‰‡è¿½åŠ å…ƒç´ ï¼šappend
numbers := make([]int, 0, 20)


//appendä¸€ä¸ªå…ƒç´ 
numbers = append(numbers, 0)

//appendå¤šä¸ªå…ƒç´ 
numbers = append(numbers, 1, 2, 3, 4, 5, 6, 7)


//appendæ·»åŠ åˆ‡ç‰‡
s1 := []int{100, 200, 300, 400, 500, 600, 700}
numbers = append(numbers, s1...)

//now:[0 1 2 3 4 5 6 7 100 200 300 400 500 600 700]
ç»å…¸æ¡ˆä¾‹: åˆ‡ç‰‡åˆ é™¤
//    åˆ é™¤ç¬¬ä¸€ä¸ªå…ƒç´ 
numbers = numbers[1:]

// åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ 
numbers = numbers[:len(numbers)-1]

// åˆ é™¤ä¸­é—´ä¸€ä¸ªå…ƒç´ 
a := int(len(numbers) / 2)
numbers = append(numbers[:a], numbers[a+1:]...)
ç»å…¸æ¡ˆä¾‹ï¼šåˆ‡ç‰‡åè½¬
// reverse reverses a slice of ints in place.
func reverse(s []int) {
    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 {
        s[i], s[j] = s[j], s[i]
    }
}
åˆ‡ç‰‡åœ¨ç¼–è¯‘æ—¶çš„ç‰¹æ€§
ç¼–è¯‘æ—¶æ–°å»ºä¸€ä¸ªåˆ‡ç‰‡,åˆ‡ç‰‡å†…å…ƒç´ çš„ç±»å‹æ˜¯åœ¨ç¼–è¯‘æœŸé—´ç¡®å®šçš„

func NewSlice(elem *Type) *Type {
    if t := elem.Cache.slice; t != nil {
        if t.Elem() != elem {
            Fatalf("elem mismatch")
        }
        return t
    }

    t := New(TSLICE)
    t.Extra = Slice{Elem: elem}
    elem.Cache.slice = t
    return t
}
åˆ‡ç‰‡çš„ç±»å‹

// Slice contains Type fields specific to slice types.
type Slice struct {
    Elem *Type // element type
}
ç¼–è¯‘æ—¶ï¼šå­—é¢é‡åˆå§‹åŒ–
å½“æˆ‘ä»¬ä½¿ç”¨å­—é¢é‡ []int{1, 2, 3} åˆ›å»ºæ–°çš„åˆ‡ç‰‡æ—¶ï¼Œä¼šåˆ›å»ºä¸€ä¸ªarrayæ•°ç»„([3]int{1,2,3})å­˜å‚¨äºé™æ€åŒºä¸­ã€‚åŒæ—¶ä¼šåˆ›å»ºä¸€ä¸ªå˜é‡ã€‚

æ ¸å¿ƒé€»è¾‘ä½äºslicelitå‡½æ•°

// go/src/cmd/compile/internal/gc/sinit.go
func slicelit(ctxt initContext, n *Node, var_ *Node, init *Nodes)
å…¶æŠ½è±¡çš„è¿‡ç¨‹å¦‚ä¸‹:

var vstat [3]int
vstat[0] = 1
vstat[1] = 2
vstat[2] = 3
var vauto *[3]int = new([3]int)
*vauto = vstat
slice := vauto[:]
æºç ä¸­çš„æ³¨é‡Šå¦‚ä¸‹ï¼š

// recipe for var = []t{...}
// 1. make a static array
//    var vstat [...]t
// 2. assign (data statements) the constant part
//    vstat = constpart{}
// 3. make an auto pointer to array and allocate heap to it
//    var vauto *[...]t = new([...]t)
// 4. copy the static array to the auto array
//    *vauto = vstat
// 5. for each dynamic part assign to the array
//    vauto[i] = dynamic part
// 6. assign slice of allocated heap to var
//    var = vauto[:]
ç¼–è¯‘æ—¶ï¼šmake åˆå§‹åŒ–
ä¾‹å¦‚make([]int,3,4)

ä½¿ç”¨make å…³é”®å­—,åœ¨typecheck1ç±»å‹æ£€æŸ¥é˜¶æ®µ,èŠ‚ç‚¹Nodeçš„opæ“ä½œå˜ä¸ºOMAKESLICE,å¹¶ä¸”å·¦èŠ‚ç‚¹å­˜å‚¨é•¿åº¦3, å³èŠ‚ç‚¹å­˜å‚¨å®¹é‡4

func typecheck1(n *Node, top int) (res *Node) {
switch t.Etype {
case TSLICE:
    if i &gt;= len(args) {
        yyerror("missing len argument to make(%v)", t)
        n.Type = nil
        return n
    }

    l = args[i]
    i++
    l = typecheck(l, ctxExpr)
    var r *Node
    if i &lt; len(args) {
        r = args[i]
        i++
        r = typecheck(r, ctxExpr)
    }

    if l.Type == nil || (r != nil &amp;&amp; r.Type == nil) {
        n.Type = nil
        return n
    }
    if !checkmake(t, "len", l) || r != nil &amp;&amp; !checkmake(t, "cap", r) {
        n.Type = nil
        return n
    }
    n.Left = l
    n.Right = r
    n.Op = OMAKESLICE
ä¸‹é¢æ¥åˆ†æä¸€ä¸‹ç¼–è¯‘æ—¶å†…å­˜çš„é€ƒé€¸é—®é¢˜,å¦‚æœmakeåˆå§‹åŒ–äº†ä¸€ä¸ªå¤ªå¤§çš„åˆ‡ç‰‡ï¼Œè¿™ä¸ªç©ºé—´ä¼šé€ƒé€¸åˆ°å †ä¸­,ç”±è¿è¡Œæ—¶åˆ†é…ã€‚å¦‚æœä¸€ä¸ªç©ºé—´æ¯”è¾ƒå°,ä¼šåœ¨æ ˆä¸­åˆ†é…ã€‚

æ­¤ä¸´ç•Œå€¼å€¼å®šä¹‰åœ¨/usr/local/go/src/cmd/compile/internal/gcï¼Œå¯ä»¥è¢«flag smallframesæ›´æ–°,é»˜è®¤ä¸º64KBã€‚

æ‰€ä»¥make([]int64,1023) ä¸make([]int64,1024)çš„æ•ˆæœæ˜¯æˆªç„¶ä¸åŒçš„ï¼Œè¿™æ˜¯ä¸æ˜¯å‹å€’éª†é©¼çš„æœ€åä¸€æ ¹ç¨»è‰ï¼Ÿ

// maximum size of implicit variables that we will allocate on the stack.
    //   p := new(T)          allocating T on the stack
    //   p := &amp;T{}            allocating T on the stack
    //   s := make([]T, n)    allocating [n]T on the stack
    //   s := []byte("...")   allocating [n]byte on the stack
    // Note: the flag smallframes can update this value.
    maxImplicitStackVarSize = int64(64 * 1024)
æ ¸å¿ƒé€»è¾‘ä½äºgo/src/cmd/compile/internal/gc/walk.goï¼Œn.Escä»£è¡¨å˜é‡æ˜¯å¦é€ƒé€¸

func walkexpr(n *Node, init *Nodes) *Node{
case OMAKESLICE:
    ...
    if n.Esc == EscNone {
        // var arr [r]T
        // n = arr[:l]
        i := indexconst(r)
        if i &lt; 0 {
            Fatalf("walkexpr: invalid index %v", r)
        }
        t = types.NewArray(t.Elem(), i) // [r]T
        var_ := temp(t)
        a := nod(OAS, var_, nil) // zero temp
        a = typecheck(a, ctxStmt)
        init.Append(a)
        r := nod(OSLICE, var_, nil) // arr[:l]
        r.SetSliceBounds(nil, l, nil)
        r = conv(r, n.Type) // in case n.Type is named.
        r = typecheck(r, ctxExpr)
        r = walkexpr(r, init)
        n = r
    } else {
        if t.Elem().NotInHeap() {
            yyerror("%v is go:notinheap; heap allocation disallowed", t.Elem())
        }

        len, cap := l, r

        fnname := "makeslice64"
        argtype := types.Types[TINT64]

        m := nod(OSLICEHEADER, nil, nil)
        m.Type = t

        fn := syslook(fnname)
        m.Left = mkcall1(fn, types.Types[TUNSAFEPTR], init, typename(t.Elem()), conv(len, argtype), conv(cap, argtype))
        m.Left.SetNonNil(true)
        m.List.Set2(conv(len, types.Types[TINT]), conv(cap, types.Types[TINT]))

        m = typecheck(m, ctxExpr)
        m = walkexpr(m, init)
        n = m
    }
å¯¹ä¸Šé¢ä»£ç å…·ä½“åˆ†æï¼Œå¦‚æœæ²¡æœ‰é€ƒé€¸ï¼Œåˆ†é…åœ¨æ ˆä¸­ã€‚

æŠ½è±¡ä¸ºï¼š

arr := [r]T
ss := arr[:l]
å¦‚æœå‘ç”Ÿäº†é€ƒé€¸ï¼Œè¿è¡Œæ—¶è°ƒç”¨makeslice64æˆ–makesliceåˆ†é…åœ¨å †ä¸­,å½“åˆ‡ç‰‡çš„é•¿åº¦å’Œå®¹é‡å°äºintç±»å‹çš„æœ€å¤§å€¼ï¼Œä¼šè°ƒç”¨makeslice,åä¹‹è°ƒç”¨makeslice64åˆ›å»ºåˆ‡ç‰‡ã€‚

makeslice64æœ€ç»ˆä¹Ÿæ˜¯è°ƒç”¨äº†makeslice,æ¯”è¾ƒç®€å•ï¼Œæœ€åè°ƒç”¨mallocgcç”³è¯·çš„å†…å­˜å¤§å°ä¸ºç±»å‹å¤§å° * å®¹é‡cap

// go/src/runtime/slice.go
func makeslice(et *_type, len, cap int) unsafe.Pointer {
    mem, overflow := math.MulUintptr(et.size, uintptr(cap))
    if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap {
        // NOTE: Produce a 'len out of range' error instead of a
        // 'cap out of range' error when someone does make([]T, bignumber).
        // 'cap out of range' is true too, but since the cap is only being
        // supplied implicitly, saying len is clearer.
        // See golang.org/issue/4085.
        mem, overflow := math.MulUintptr(et.size, uintptr(len))
        if overflow || mem &gt; maxAlloc || len &lt; 0 {
            panicmakeslicelen()
        }
        panicmakeslicecap()
    }

    return mallocgc(mem, et, true)
}

func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer {
    len := int(len64)
    if int64(len) != len64 {
        panicmakeslicelen()
    }

    cap := int(cap64)
    if int64(cap) != cap64 {
        panicmakeslicecap()
    }

    return makeslice(et, len, cap)
}
åˆ‡ç‰‡çš„æ‰©å®¹
Go ä¸­åˆ‡ç‰‡appendè¡¨ç¤ºæ·»åŠ å…ƒç´ ,ä½†ä¸æ˜¯ä½¿ç”¨äº†appendå°±éœ€è¦æ‰©å®¹,å¦‚ä¸‹ä»£ç ä¸éœ€è¦æ‰©å®¹

a:= make([]int,3,4)
append(a,1)
å½“Go ä¸­åˆ‡ç‰‡appendå½“å®¹é‡è¶…è¿‡äº†ç°æœ‰å®¹é‡,æ‰éœ€è¦è¿›è¡Œæ‰©å®¹,ä¾‹å¦‚ï¼š

a:= make([]int,3,3)
append(a,1)
æ ¸å¿ƒé€»è¾‘ä½äºgo/src/runtime/slice.go growsliceå‡½æ•°

func growslice(et *_type, old slice, cap int) slice {
    newcap := old.cap
    doublecap := newcap + newcap
    if cap &gt; doublecap {
        newcap = cap
    } else {
        if old.len &lt; 1024 {
            newcap = doublecap
        } else {

            for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
                newcap += newcap / 4
            }

            if newcap &lt;= 0 {
                newcap = cap
            }
        }
    }
    ...
}
ä¸Šé¢çš„ä»£ç æ˜¾ç¤ºäº†æ‰©å®¹çš„æ ¸å¿ƒé€»è¾‘,Go ä¸­åˆ‡ç‰‡æ‰©å®¹çš„ç­–ç•¥æ˜¯è¿™æ ·çš„ï¼š

é¦–å…ˆåˆ¤æ–­ï¼Œå¦‚æœæ–°ç”³è¯·å®¹é‡ï¼ˆcapï¼‰å¤§äº2å€çš„æ—§å®¹é‡ï¼ˆold.capï¼‰ï¼Œæœ€ç»ˆå®¹é‡ï¼ˆnewcapï¼‰å°±æ˜¯æ–°ç”³è¯·çš„å®¹é‡ï¼ˆcapï¼‰

å¦åˆ™åˆ¤æ–­ï¼Œå¦‚æœæ—§åˆ‡ç‰‡çš„é•¿åº¦å°äº1024ï¼Œåˆ™æœ€ç»ˆå®¹é‡(newcap)å°±æ˜¯æ—§å®¹é‡(old.cap)çš„ä¸¤å€ï¼Œå³ï¼ˆnewcap=doublecapï¼‰

å¦åˆ™åˆ¤æ–­ï¼Œå¦‚æœæ—§åˆ‡ç‰‡é•¿åº¦å¤§äºç­‰äº1024ï¼Œåˆ™æœ€ç»ˆå®¹é‡ï¼ˆnewcapï¼‰ä»æ—§å®¹é‡ï¼ˆold.capï¼‰å¼€å§‹å¾ªç¯å¢åŠ åŸæ¥çš„1/4ï¼Œå³ï¼ˆnewcap=old.cap,for {newcap += newcap/4}ï¼‰ç›´åˆ°æœ€ç»ˆå®¹é‡ï¼ˆnewcapï¼‰å¤§äºç­‰äºæ–°ç”³è¯·çš„å®¹é‡(cap)ï¼Œå³ï¼ˆnewcap &gt;= capï¼‰

å¦‚æœæœ€ç»ˆå®¹é‡ï¼ˆcapï¼‰è®¡ç®—å€¼æº¢å‡ºï¼Œåˆ™æœ€ç»ˆå®¹é‡ï¼ˆcapï¼‰å°±æ˜¯æ–°ç”³è¯·å®¹é‡ï¼ˆcapï¼‰

æ¥ç€æ ¹æ®åˆ‡ç‰‡ç±»å‹çš„å¤§å°,ç¡®å®šä¸åŒçš„å†…å­˜åˆ†é…å¤§å°ã€‚å…¶ä¸»è¦æ˜¯ç”¨ä½œå†…å­˜çš„å¯¹é½ã€‚å› æ­¤ï¼Œç”³è¯·çš„å†…å­˜å¯èƒ½ä¼šå¤§äºå®é™…çš„et.size * newcap

    switch {
    case et.size == 1:
        lenmem = uintptr(old.len)
        newlenmem = uintptr(cap)
        capmem = roundupsize(uintptr(newcap))
        overflow = uintptr(newcap) &gt; maxAlloc
        newcap = int(capmem)
    case et.size == sys.PtrSize:
        lenmem = uintptr(old.len) * sys.PtrSize
        newlenmem = uintptr(cap) * sys.PtrSize
        capmem = roundupsize(uintptr(newcap) * sys.PtrSize)
        overflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSize
        newcap = int(capmem / sys.PtrSize)
    case isPowerOfTwo(et.size):
        var shift uintptr
        if sys.PtrSize == 8 {
            // Mask shift for better code generation.
            shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63
        } else {
            shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31
        }
        lenmem = uintptr(old.len) &lt;&lt; shift
        newlenmem = uintptr(cap) &lt;&lt; shift
        capmem = roundupsize(uintptr(newcap) &lt;&lt; shift)
        overflow = uintptr(newcap) &gt; (maxAlloc &gt;&gt; shift)
        newcap = int(capmem &gt;&gt; shift)
    default:
        lenmem = uintptr(old.len) * et.size
        newlenmem = uintptr(cap) * et.size
        capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))
        capmem = roundupsize(capmem)
        newcap = int(capmem / et.size)
    }
æœ€åæ ¸å¿ƒæ˜¯ç”³è¯·å†…å­˜ã€‚è¦æ³¨æ„çš„æ˜¯ï¼Œæ–°çš„åˆ‡ç‰‡ä¸ä¸€å®šæ„å‘³ç€æ–°çš„åœ°å€ã€‚

æ ¹æ®åˆ‡ç‰‡ç±»å‹et.ptrdataæ˜¯å¦ä¸ºæŒ‡é’ˆ,éœ€è¦æ‰§è¡Œä¸åŒçš„é€»è¾‘ã€‚

    if et.ptrdata == 0 {
        p = mallocgc(capmem, nil, false)
        // The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).
        // Only clear the part that will not be overwritten.
        memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)
    } else {
        // Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.
        p = mallocgc(capmem, et, true)
        if lenmem &gt; 0 &amp;&amp; writeBarrier.enabled {
            // Only shade the pointers in old.array since we know the destination slice p
            // only contains nil pointers because it has been cleared during alloc.
            bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem)
        }
    }
    memmove(p, old.array, lenmem)

    return slice{p, old.len, newcap}
å½“åˆ‡ç‰‡ç±»å‹ä¸æ˜¯æŒ‡é’ˆ,åˆ†é…å†…å­˜ååªéœ€è¦å°†å†…å­˜çš„åé¢çš„å€¼æ¸…ç©º,memmove(p, old.array, lenmem) å‡½æ•°ç”¨äºå°†oldåˆ‡ç‰‡çš„å€¼èµ‹å€¼ç»™æ–°çš„åˆ‡ç‰‡

æ•´ä¸ªè¿‡ç¨‹çš„æŠ½è±¡æŠ½è±¡è¡¨ç¤ºå¦‚ä¸‹

old = make([]int,3,3)
new = append(old,1) =&gt; new = malloc(newcap * sizeof(int))   a[4]  = 0
new[1] = old[1]
new[2] = old[2]
new[3] = old[3]
å½“åˆ‡ç‰‡ç±»å‹ä¸ºæŒ‡é’ˆ,æŒ‡é’ˆéœ€è¦å†™å…¥å½“å‰åç¨‹ç¼“å†²åŒºä¸­,è¿™ä¸ªåœ°æ–¹æ¶‰åŠåˆ°GC å›æ”¶æœºåˆ¶ä¸­çš„å†™å±éšœ,åé¢ä»‹ç»ã€‚

åˆ‡ç‰‡çš„æˆªå–
å¯¹äºæ•°ç»„ä¸‹æ ‡çš„æˆªå–,å¦‚ä¸‹æ‰€ç¤ºï¼Œå¯ä»¥ä»å¤šä¸ªç»´åº¦è¯æ˜,åˆ‡ç‰‡çš„æˆªå–ç”Ÿæˆäº†ä¸€ä¸ªæ–°çš„åˆ‡ç‰‡,ä½†æ˜¯åº•å±‚æ•°æ®æºå´æ˜¯ä½¿ç”¨çš„åŒä¸€ä¸ªã€‚

    old := make([]int64,3,3)
    new := old[1:3]
    fmt.Printf("%p %p",arr,slice)
è¾“å‡ºä¸º:

0xc000018140 0xc000018148
äºŒè€…çš„åœ°å€æ­£å¥½ç›¸å·®äº†8ä¸ªå­—èŠ‚ï¼Œè¿™ä¸æ˜¯å¶ç„¶çš„,è€Œæ˜¯å› ä¸ºäºŒè€…æŒ‡å‘äº†ç›¸åŒçš„æ•°æ®æºï¼Œåˆšå¥½ç›¸å·®int64çš„å¤§å°ã€‚
å¦å¤–æˆ‘ä»¬ä¹Ÿå¯ä»¥ä»ç”Ÿæˆçš„æ±‡ç¼–çš„è¿‡ç¨‹æŸ¥çœ‹åˆ°åˆ°ä¸€äº›ç«¯å€ª

GOSSAFUNC=main GOOS=linux GOARCH=amd64 go tool compile main.go

image
åœ¨ssaçš„åˆå§‹é˜¶æ®µstart,old := make([]int64,3,3)å¯¹åº”çš„æ˜¯SliceMake &lt;[]int&gt; v10 v15 v15, SliceMakeæ“ä½œï¿¿éœ€è¦ä¼ é€’æ•°ç»„çš„æŒ‡é’ˆã€é•¿åº¦ã€å®¹é‡ã€‚
è€Œ new := old[1:3] å¯¹åº”SliceMake &lt;[]int&gt; v34 v28 v29ã€‚ä¼ é€’çš„æŒ‡é’ˆv34æ­£å¥½çš„åŸå§‹çš„Ptr + 8ä¸ªå­—èŠ‚åçš„ä½ç½®

ä¸‹é¢åˆ—å‡ºä¸€å¼ å›¾æ¯”è¾ƒå½¢è±¡çš„è¡¨ç¤ºåˆ‡ç‰‡å¼•ç”¨ç›¸åŒæ•°æ®æºçš„å›¾ï¼š

image
åˆ‡ç‰‡çš„å¤åˆ¶
ç”±äºåˆ‡ç‰‡çš„å¤åˆ¶ä¸ä¼šæ”¹å˜æŒ‡å‘çš„åº•å±‚æ•°æ®æºã€‚ä½†æ˜¯æˆ‘ä»¬æœ‰äº›æ—¶å€™å¸Œæœ›å»ºä¸€ä¸ªæ–°çš„æ•°ç»„ï¼Œè¿åº•å±‚æ•°æ®æºä¹Ÿæ˜¯å…¨æ–°çš„ã€‚è¿™ä¸ªæ—¶å€™å¯ä»¥ä½¿ç”¨copyå‡½æ•°

åˆ‡ç‰‡è¿›è¡Œå€¼æ‹·è´ï¼šcopy

// åˆ›å»ºç›®æ ‡åˆ‡ç‰‡
numbers1 := make([]int, len(numbers), cap(numbers)*2)
// å°†numbersçš„å…ƒç´ æ‹·è´åˆ°numbers1ä¸­
count := copy(numbers1, numbers)
åˆ‡ç‰‡è½¬æ•°ç»„

slice := []byte("abcdefgh")
var arr [4]byte
copy(arr[:], slice[:4])
//æˆ–è€…ç›´æ¥å¦‚ä¸‹,è¿™æ¶‰åŠåˆ°ä¸€ä¸ªç‰¹æ€§,å³åªä¼šæ‹·è´min(len(arr),len(slice)
copy(arr[:], slice)
copyå‡½æ•°åœ¨ç¼–è¯‘æ—¶ä¼šå†³å®šä½¿ç”¨å“ªä¸€ç§æ–¹å¼ï¼Œæ™®é€šçš„æ–¹å¼ä¼šç›´æ¥è°ƒç”¨memmove

func copyany(n *Node, init *Nodes, runtimecall bool) *Node {
    ...
    if runtimecall {
        if n.Right.Type.IsString() {
            fn := syslook("slicestringcopy")
            fn = substArgTypes(fn, n.Left.Type, n.Right.Type)
            return mkcall1(fn, n.Type, init, n.Left, n.Right)
        }

        fn := syslook("slicecopy")
        fn = substArgTypes(fn, n.Left.Type, n.Right.Type)
        return mkcall1(fn, n.Type, init, n.Left, n.Right, nodintconst(n.Left.Type.Elem().Width))
    }
    ...
    fn := syslook("memmove")
    fn = substArgTypes(fn, nl.Type.Elem(), nl.Type.Elem())
    nwid := temp(types.Types[TUINTPTR])
    setwid := nod(OAS, nwid, conv(nlen, types.Types[TUINTPTR]))
    ne.Nbody.Append(setwid)
    nwid = nod(OMUL, nwid, nodintconst(nl.Type.Elem().Width))
    call := mkcall1(fn, nil, init, nto, nfrm, nwid)
}
æŠ½è±¡è¡¨ç¤ºä¸ºï¼š

 init {
   n := len(a)
   if n &gt; len(b) { n = len(b) }
   if a.ptr != b.ptr { memmove(a.ptr, b.ptr, n*sizeof(elem(a))) }
 }
é™¤éæ˜¯åç¨‹è°ƒç”¨çš„æ–¹å¼go copy(numbers1, numbers) æˆ–è€…ï¼ˆåŠ å…¥äº†raceç­‰æ£€æµ‹ &amp;&amp; ä¸æ˜¯åœ¨ç¼–è¯‘goè¿è¡Œæ—¶ä»£ç ï¼‰ ä¼šè½¬è€Œè°ƒç”¨è¿è¡Œæ—¶slicestringcopy æˆ– slicecopy .

case OCOPY:
    n = copyany(n, init, instrumenting &amp;&amp; !compiling_runtime)
case OGO:
    switch n.Left.Op {
    case OCOPY:
        n.Left = copyany(n.Left, &amp;n.Ninit, true)
slicestringcopy æˆ– slicecopy æœ¬è´¨ä¸Šä»ç„¶æ˜¯è°ƒç”¨äº†memmoveåªæ˜¯è¿›è¡Œäº†é¢å¤–çš„raceå†²çªç­‰åˆ¤æ–­ã€‚

func slicecopy(to, fm slice, width uintptr) int {
    ...
    if raceenabled {
        callerpc := getcallerpc()
        pc := funcPC(slicecopy)
        racewriterangepc(to.array, uintptr(n*int(width)), callerpc, pc)
        racereadrangepc(fm.array, uintptr(n*int(width)), callerpc, pc)
    }
    if msanenabled {
        msanwrite(to.array, uintptr(n*int(width)))
        msanread(fm.array, uintptr(n*int(width)))
    }

    size := uintptr(n) * width
    if size == 1 { // common case worth about 2x to do here
        // TODO: is this still worth it with new memmove impl?
        *(*byte)(to.array) = *(*byte)(fm.array) // known to be a byte pointer
    } else {
        memmove(to.array, fm.array, size)
    }
    return n
}
æ€»ç»“
åˆ‡ç‰‡æ˜¯goè¯­è¨€ä¸­é‡è¦çš„æ•°æ®ç»“æœ,å…¶å’Œå…¶ä»–è¯­è¨€ä¸åŒçš„æ˜¯ï¼Œå…¶ç»´æŠ¤äº†åº•å±‚çš„å†…å­˜ï¼Œä»¥åŠé•¿åº¦å’Œå®¹é‡

åˆ‡ç‰‡ä¸æ•°ç»„çš„èµ‹å€¼æ‹·è´æœ‰æ˜æ˜¾åŒºåˆ«,åˆ‡ç‰‡åœ¨èµ‹å€¼æ‹·è´ä¸ä¸‹æ ‡æˆªæ–­æ—¶å¼•ç”¨äº†ç›¸åŒçš„åº•å±‚æ•°æ®

å¦‚æœè¦å®Œå…¨å¤åˆ¶åˆ‡ç‰‡,ä½¿ç”¨copyå‡½æ•°ã€‚å…¶é€»è¾‘æ˜¯æ–°å»ºä¸€ä¸ªæ–°çš„å†…å­˜,å¹¶æ‹·è´è¿‡å»ã€‚åœ¨æç«¯æƒ…å†µéœ€è¦è€ƒè™‘å…¶å¯¹æ€§èƒ½çš„å½±å“

åˆ‡ç‰‡å­—é¢é‡çš„åˆå§‹åŒ–ï¼Œæ•°ç»„å­˜å‚¨äºé™æ€åŒºã€‚åˆ‡ç‰‡makeçš„åˆå§‹åŒ–æ–¹å¼æ—¶,å¦‚æœmakeåˆå§‹åŒ–äº†ä¸€ä¸ªå¤§äº64KBçš„åˆ‡ç‰‡ï¼Œè¿™ä¸ªç©ºé—´ä¼šé€ƒé€¸åˆ°å †ä¸­,åœ¨è¿è¡Œæ—¶è°ƒç”¨makesliceåˆ›å»ºã€‚å°äº64KBçš„åˆ‡ç‰‡åœ¨æ ˆä¸­åˆå§‹åŒ–

Go ä¸­åˆ‡ç‰‡appendå½“å®¹é‡è¶…è¿‡äº†ç°æœ‰å®¹é‡,éœ€è¦è¿›è¡Œæ‰©å®¹,å…¶ç­–ç•¥æ˜¯ï¼š

é¦–å…ˆåˆ¤æ–­ï¼Œå¦‚æœæ–°ç”³è¯·å®¹é‡ï¼ˆcapï¼‰å¤§äº2å€çš„æ—§å®¹é‡ï¼ˆold.capï¼‰ï¼Œæœ€ç»ˆå®¹é‡ï¼ˆnewcapï¼‰å°±æ˜¯æ–°ç”³è¯·çš„å®¹é‡ï¼ˆcapï¼‰

å¦åˆ™åˆ¤æ–­ï¼Œå¦‚æœæ—§åˆ‡ç‰‡çš„é•¿åº¦å°äº1024ï¼Œåˆ™æœ€ç»ˆå®¹é‡(newcap)å°±æ˜¯æ—§å®¹é‡(old.cap)çš„ä¸¤å€ï¼Œå³ï¼ˆnewcap=doublecapï¼‰

å¦åˆ™åˆ¤æ–­ï¼Œå¦‚æœæ—§åˆ‡ç‰‡é•¿åº¦å¤§äºç­‰äº1024ï¼Œåˆ™æœ€ç»ˆå®¹é‡ï¼ˆnewcapï¼‰ä»æ—§å®¹é‡ï¼ˆold.capï¼‰å¼€å§‹å¾ªç¯å¢åŠ åŸæ¥çš„1/4ï¼Œå³ï¼ˆnewcap=old.cap,for {newcap += newcap/4}ï¼‰ç›´åˆ°æœ€ç»ˆå®¹é‡ï¼ˆnewcapï¼‰å¤§äºç­‰äºæ–°ç”³è¯·çš„å®¹é‡(cap)ï¼Œå³ï¼ˆnewcap &gt;= capï¼‰

å¦‚æœæœ€ç»ˆå®¹é‡ï¼ˆcapï¼‰è®¡ç®—å€¼æº¢å‡ºï¼Œåˆ™æœ€ç»ˆå®¹é‡ï¼ˆcapï¼‰å°±æ˜¯æ–°ç”³è¯·å®¹é‡ï¼ˆcapï¼‰

Go ä¸­åˆ‡ç‰‡appendåè¿”å›çš„åˆ‡ç‰‡åœ°å€å¹¶ä¸ä¸€å®šæ˜¯åŸæ¥çš„ã€ä¹Ÿä¸ä¸€å®šæ˜¯æ–°çš„å†…å­˜åœ°å€,å› æ­¤å¿…é¡»å°å¿ƒå…¶å¯èƒ½é‡åˆ°çš„é™·é˜±ã€‚ä¸€èˆ¬ä¼šä½¿ç”¨a = append(a,T)çš„æ–¹å¼ä¿è¯å®‰å…¨ã€‚

å‰æ–‡
golangå¿«é€Ÿå…¥é—¨[1]-goè¯­è¨€å¯¼è®º

golangå¿«é€Ÿå…¥é—¨[2.1]-goè¯­è¨€å¼€å‘ç¯å¢ƒé…ç½®-windows

golangå¿«é€Ÿå…¥é—¨[2.2]-goè¯­è¨€å¼€å‘ç¯å¢ƒé…ç½®-macOS

golangå¿«é€Ÿå…¥é—¨[2.3]-goè¯­è¨€å¼€å‘ç¯å¢ƒé…ç½®-linux

golangå¿«é€Ÿå…¥é—¨[3]-goè¯­è¨€helloworld

golangå¿«é€Ÿå…¥é—¨[4]-goè¯­è¨€å¦‚ä½•ç¼–è¯‘ä¸ºæœºå™¨ç 

golangå¿«é€Ÿå…¥é—¨[5.1]-goè¯­è¨€æ˜¯å¦‚ä½•è¿è¡Œçš„-é“¾æ¥å™¨

golangå¿«é€Ÿå…¥é—¨[5.2]-goè¯­è¨€æ˜¯å¦‚ä½•è¿è¡Œçš„-å†…å­˜æ¦‚è¿°

golangå¿«é€Ÿå…¥é—¨[5.3]-goè¯­è¨€æ˜¯å¦‚ä½•è¿è¡Œçš„-å†…å­˜åˆ†é…

golangå¿«é€Ÿå…¥é—¨[6.1]-é›†æˆå¼€å‘ç¯å¢ƒ-golandè¯¦è§£

golangå¿«é€Ÿå…¥é—¨[6.2]-é›†æˆå¼€å‘ç¯å¢ƒ-emacsè¯¦è§£

golangå¿«é€Ÿå…¥é—¨[7.1]-é¡¹ç›®ä¸ä¾èµ–ç®¡ç†-gopath

golangå¿«é€Ÿå…¥é—¨[7.2]-åŒ—å†¥ç¥åŠŸâ€”go moduleç»æŠ€

golangå¿«é€Ÿå…¥é—¨[8.1]-å˜é‡ç±»å‹ã€å£°æ˜èµ‹å€¼ã€ä½œç”¨åŸŸå£°æ˜å‘¨æœŸä¸å˜é‡å†…å­˜åˆ†é…

golangå¿«é€Ÿå…¥é—¨[8.2]-è‡ªåŠ¨ç±»å‹æ¨æ–­çš„ç§˜å¯†

golangå¿«é€Ÿå…¥é—¨[8.3]-æ·±å…¥ç†è§£æµ®ç‚¹æ•°

golangå¿«é€Ÿå…¥é—¨[8.4]-å¸¸é‡ä¸éšå¼ç±»å‹è½¬æ¢

golangå¿«é€Ÿå…¥é—¨[9.1]--æ·±å…¥å­—ç¬¦ä¸²çš„å­˜å‚¨ã€ç¼–è¯‘ä¸è¿è¡Œ

golangå¿«é€Ÿå…¥é—¨[9.2]-æ·±å…¥æ•°ç»„ç”¨æ³•ã€é™·é˜±ä¸ç¼–è¯‘æ—¶

https://mp.weixin.qq.com/s?__biz=MzU1NjY0MDk3NQ==&amp;mid=2247484222&amp;idx=1&amp;sn=feee698e4c3a32c47e2203bb76685e62&amp;chksm=fbc0bc9eccb7358868b3745a6f6bf21fe3a12a7e59d5fe7c224a1cebf7769f94b9b64d369431&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1587341167469&amp;sharer_shareid=8bc5c9f63486c7f1a0dc0c828de4b59b&amp;exportkey=ASllTw2sQCJzKPe6CqzWF54%3D&amp;pass_ticket=Xi4ovRoiqyRYOgFcVJvsZm%2Bj%2FbCpBkw%2B87QzEXYMWgQ8gmz%2FqPY8EuqR3690VyRi#rd
</autogenerated></autogenerated></autogenerated>
:ET