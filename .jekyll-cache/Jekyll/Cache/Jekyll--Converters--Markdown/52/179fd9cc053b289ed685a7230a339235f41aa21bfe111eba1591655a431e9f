I"Æ<<p>æ™®é€šçš„mapæ˜¯ä¸æ”¯æŒå¹¶å‘çš„ï¼Œæ¢è€Œè¨€ä¹‹,ä¸æ˜¯çº¿ç¨‹(goroutine)å®‰å…¨çš„ã€‚golang 1.4å¼€å§‹çš„mapçš„å¹¶å‘è¯»æ˜¯æ²¡æœ‰æ”¯æŒï¼Œä½†æ˜¯å¹¶å‘å†™ä¼šå‡ºç°è„æ•°æ®ã€‚golang 1.6ä¹‹åï¼Œå¹¶å‘åœ°è¯»å†™ä¼šç›´æ¥panicï¼š
fatal error: concurrent map read and map write
<!-- more -->
package main
func main() {
    m := make(map[int]int)
    go func() {
        for {
            _ = m[1]
        }
    }()
    go func() {
        for {
            m[2] = 2
        }
    }()
    select {}
}
æ‰€ä»¥éœ€è¦æ”¯æŒå¯¹mapçš„å¹¶å‘è¯»å†™æ—¶å€™ï¼Œåšä¸»ä½¿ç”¨ä¸¤ç§æ–¹æ³•ï¼š</p>

<p>ç¬¬ä¸‰æ–¹ç±»åº“ concurrent-mapã€‚
mapåŠ ä¸Šsync.RWMutexæ¥ä¿éšœçº¿ç¨‹(goroutine)å®‰å…¨çš„ã€‚
golang 1.9ä¹‹å,go åœ¨syncåŒ…ä¸‹å¼•å…¥äº†å¹¶å‘å®‰å…¨çš„mapï¼Œä¹Ÿä¸ºåšä¸»æä¾›äº†ç¬¬ä¸‰ç§æ–¹æ³•ã€‚æœ¬æ–‡é‡ç‚¹ä¹Ÿåœ¨æ­¤ï¼Œä¸ºäº†æ—¶æ•ˆæ€§ï¼Œæœ¬æ–‡åŸºäºgolang 1.10æºç è¿›è¡Œåˆ†æã€‚</p>

<p>sync.Map
ç»“æ„ä½“
Map
type Map struct {
    mu Mutex    //äº’æ–¥é”ï¼Œç”¨äºé”å®šdirty map</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read atomic.Value //ä¼˜å…ˆè¯»map,æ”¯æŒåŸå­æ“ä½œï¼Œæ³¨é‡Šä¸­æœ‰readOnlyä¸æ˜¯è¯´readæ˜¯åªè¯»ï¼Œè€Œæ˜¯å®ƒçš„ç»“æ„ä½“ã€‚readå®é™…ä¸Šæœ‰å†™çš„æ“ä½œ

dirty map[interface{}]*entry // dirtyæ˜¯ä¸€ä¸ªå½“å‰æœ€æ–°çš„mapï¼Œå…è®¸è¯»å†™

misses int // ä¸»è¦è®°å½•readè¯»å–ä¸åˆ°æ•°æ®åŠ é”è¯»å–read mapä»¥åŠdirty mapçš„æ¬¡æ•°ï¼Œå½“missesç­‰äºdirtyçš„é•¿åº¦æ—¶ï¼Œä¼šå°†dirtyå¤åˆ¶åˆ°read } readOnly readOnly ä¸»è¦ç”¨äºå­˜å‚¨ï¼Œé€šè¿‡åŸå­æ“ä½œå­˜å‚¨åœ¨Map.readä¸­å…ƒç´ ã€‚
</code></pre></div></div>

<p>type readOnly struct {
    m       map[interface{}]*entry
    amended bool // å¦‚æœæ•°æ®åœ¨dirtyä¸­ä½†æ²¡æœ‰åœ¨readä¸­ï¼Œè¯¥å€¼ä¸ºtrue,ä½œä¸ºä¿®æ”¹æ ‡è¯†
}
entry
type entry struct {
    // nil: è¡¨ç¤ºä¸ºè¢«åˆ é™¤ï¼Œè°ƒç”¨Delete()å¯ä»¥å°†read mapä¸­çš„å…ƒç´ ç½®ä¸ºnil
    // expunged: ä¹Ÿæ˜¯è¡¨ç¤ºè¢«åˆ é™¤ï¼Œä½†æ˜¯è¯¥é”®åªåœ¨readè€Œæ²¡æœ‰åœ¨dirtyä¸­ï¼Œè¿™ç§æƒ…å†µå‡ºç°åœ¨å°†readå¤åˆ¶åˆ°dirtyä¸­ï¼Œå³å¤åˆ¶çš„è¿‡ç¨‹ä¼šå…ˆå°†nilæ ‡è®°ä¸ºexpungedï¼Œç„¶åä¸å°†å…¶å¤åˆ¶åˆ°dirty
    //  å…¶ä»–: è¡¨ç¤ºå­˜ç€çœŸæ­£çš„æ•°æ®
    p unsafe.Pointer // *interface{}
}
åŸç†
å¦‚æœä½ æ¥è§¦è¿‡å¤§Javaï¼Œé‚£ä½ ä¸€å®šå¯¹CocurrentHashMapåˆ©ç”¨é”åˆ†æ®µæŠ€æœ¯å¢åŠ äº†é”çš„æ•°ç›®ï¼Œä»è€Œä½¿äº‰å¤ºåŒä¸€æŠŠé”çš„çº¿ç¨‹çš„æ•°ç›®å¾—åˆ°æ§åˆ¶çš„åŸç†è®°å¿†æ·±åˆ»ã€‚ 
é‚£ä¹ˆGolangçš„sync.Mapæ˜¯å¦ä¹Ÿæ˜¯ä½¿ç”¨äº†ç›¸åŒçš„åŸç†å‘¢ï¼Ÿsync.Mapçš„åŸç†å¾ˆç®€å•ï¼Œä½¿ç”¨äº†ç©ºé—´æ¢æ—¶é—´ç­–ç•¥ï¼Œé€šè¿‡å†—ä½™çš„ä¸¤ä¸ªæ•°æ®ç»“æ„(readã€dirty),å®ç°åŠ é”å¯¹æ€§èƒ½çš„å½±å“ã€‚
é€šè¿‡å¼•å…¥ä¸¤ä¸ªmapå°†è¯»å†™åˆ†ç¦»åˆ°ä¸åŒçš„mapï¼Œå…¶ä¸­read mapæä¾›å¹¶å‘è¯»å’Œå·²å­˜å…ƒç´ åŸå­å†™ï¼Œè€Œdirty mapåˆ™è´Ÿè´£è¯»å†™ã€‚ è¿™æ ·read mapå°±å¯ä»¥åœ¨ä¸åŠ é”çš„æƒ…å†µä¸‹è¿›è¡Œå¹¶å‘è¯»å–,å½“read mapä¸­æ²¡æœ‰è¯»å–åˆ°å€¼æ—¶,å†åŠ é”è¿›è¡Œåç»­è¯»å–,å¹¶ç´¯åŠ æœªå‘½ä¸­æ•°,å½“æœªå‘½ä¸­æ•°å¤§äºç­‰äºdirty mapé•¿åº¦,å°†dirty mapä¸Šå‡ä¸ºread mapã€‚ä»ä¹‹å‰çš„ç»“æ„ä½“çš„å®šä¹‰å¯ä»¥å‘ç°ï¼Œè™½ç„¶å¼•å…¥äº†ä¸¤ä¸ªmapï¼Œä½†æ˜¯åº•å±‚æ•°æ®å­˜å‚¨çš„æ˜¯æŒ‡é’ˆï¼ŒæŒ‡å‘çš„æ˜¯åŒä¸€ä»½å€¼ã€‚</p>

<p>å¼€å§‹æ—¶sync.Mapå†™å…¥æ•°æ®</p>

<p>X=1
Y=2
Z=3
dirty mapä¸»è¦æ¥å—å†™è¯·æ±‚ï¼Œread mapæ²¡æœ‰æ•°æ®ï¼Œæ­¤æ—¶read mapä¸dirty mapæ•°æ®å¦‚ä¸‹å›¾ã€‚</p>

<p>è¯»å–æ•°æ®çš„æ—¶å€™ä»read mapä¸­è¯»å–ï¼Œæ­¤æ—¶read mapå¹¶æ²¡æœ‰æ•°æ®ï¼Œmissè®°å½•ä»read mapè¯»å–å¤±è´¥çš„æ¬¡æ•°ï¼Œå½“misses&gt;=len(dirty map)æ—¶ï¼Œå°†dirty mapç›´æ¥å‡çº§ä¸ºread map,è¿™é‡Œç›´æ¥å¯¹dirty mapè¿›è¡Œåœ°å€æ‹·è´å¹¶ä¸”dirty mapè¢«æ¸…ç©ºï¼Œmissesç½®ä¸º0ã€‚æ­¤æ—¶read mapä¸dirty mapæ•°æ®å¦‚ä¸‹å›¾ã€‚
image</p>

<p>ç°åœ¨æœ‰éœ€æ±‚å¯¹Zå…ƒç´ è¿›è¡Œä¿®æ”¹Z=4ï¼Œsync.Mapä¼šç›´æ¥ä¿®æ”¹read mapçš„å…ƒç´ ã€‚</p>

<p>image</p>

<p>æ–°åŠ å…ƒç´ K=5ï¼Œæ–°åŠ çš„å…ƒç´ å°±éœ€è¦æ“ä½œdirty mapäº†ï¼Œå¦‚æœmissesè¾¾åˆ°é˜€å€¼ådirty mapç›´æ¥å‡çº§ä¸ºread mapå¹¶ä¸”dirty mapä¸ºç©ºmap(readçš„amended==false)ï¼Œåˆ™dirty mapéœ€è¦ä»read mapå¤åˆ¶æ•°æ®ã€‚</p>

<p>å‡çº§åçš„æ•ˆæœå¦‚ä¸‹ã€‚</p>

<p>å¦‚æœéœ€è¦åˆ é™¤Zï¼Œéœ€è¦åˆ†å‡ ç§æƒ…å†µï¼š 
ä¸€ç§read mapå­˜åœ¨è¯¥å…ƒç´ ä¸”readçš„amended==falseï¼šç›´æ¥å°†readä¸­çš„å…ƒç´ ç½®ä¸ºnilã€‚</p>

<p>å¦ä¸€ç§ä¸ºå…ƒç´ åˆšåˆšå†™å…¥dirty mapä¸”æœªå‡çº§ä¸ºread map:ç›´æ¥è°ƒç”¨golangå†…ç½®å‡½æ•°deleteåˆ é™¤dirty mapçš„å…ƒç´ ï¼›
image</p>

<p>è¿˜æœ‰ä¸€ç§æ˜¯read mapå’Œdirty mapåŒæ—¶å­˜åœ¨è¯¥å…ƒç´ ï¼šå°†read mapä¸­çš„å…ƒç´ ç½®ä¸ºnilï¼Œå› ä¸ºread mapå’Œdirty map ä½¿ç”¨çš„å‡ä¸ºå…ƒç´ åœ°å€ï¼Œæ‰€ä»¥å‡è¢«ç½®ä¸ºnilã€‚</p>

<p>ä¼˜åŒ–ç‚¹
ç©ºé—´æ¢æ—¶é—´ã€‚é€šè¿‡å†—ä½™çš„ä¸¤ä¸ªæ•°æ®ç»“æ„(readã€dirty),å®ç°åŠ é”å¯¹æ€§èƒ½çš„å½±å“ã€‚
ä½¿ç”¨åªè¯»æ•°æ®(read)ï¼Œé¿å…è¯»å†™å†²çªã€‚
åŠ¨æ€è°ƒæ•´ï¼Œmissæ¬¡æ•°å¤šäº†ä¹‹åï¼Œå°†dirtyæ•°æ®æå‡ä¸ºreadã€‚
double-checkingï¼ˆåŒé‡æ£€æµ‹ï¼‰ã€‚
å»¶è¿Ÿåˆ é™¤ã€‚ åˆ é™¤ä¸€ä¸ªé”®å€¼åªæ˜¯æ‰“æ ‡è®°ï¼Œåªæœ‰åœ¨æå‡dirtyçš„æ—¶å€™æ‰æ¸…ç†åˆ é™¤çš„æ•°æ®ã€‚
ä¼˜å…ˆä»readè¯»å–ã€æ›´æ–°ã€åˆ é™¤ï¼Œå› ä¸ºå¯¹readçš„è¯»å–ä¸éœ€è¦é”ã€‚
æ–¹æ³•æºç åˆ†æ
Load
Loadè¿”å›å­˜å‚¨åœ¨æ˜ å°„ä¸­çš„é”®å€¼ï¼Œå¦‚æœæ²¡æœ‰å€¼ï¼Œåˆ™è¿”å›nilã€‚okç»“æœæŒ‡ç¤ºæ˜¯å¦åœ¨æ˜ å°„ä¸­æ‰¾åˆ°å€¼ã€‚</p>

<p>func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
    // ç¬¬ä¸€æ¬¡æ£€æµ‹å…ƒç´ æ˜¯å¦å­˜åœ¨
    read, _ := m.read.Load().(readOnly)
    e, ok := read.m[key]
    if !ok &amp;&amp; read.amended {
        // ä¸ºdirty map åŠ é”
        m.mu.Lock()
        // ç¬¬äºŒæ¬¡æ£€æµ‹å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œä¸»è¦é˜²æ­¢åœ¨åŠ é”çš„è¿‡ç¨‹ä¸­,dirty mapè½¬æ¢æˆread map,ä»è€Œå¯¼è‡´è¯»å–ä¸åˆ°æ•°æ®
        read, _ = m.read.Load().(readOnly)
        e, ok = read.m[key]
        if !ok &amp;&amp; read.amended {
            // ä»dirty mapä¸­è·å–æ˜¯ä¸ºäº†åº”å¯¹read mapä¸­ä¸å­˜åœ¨çš„æ–°å…ƒç´ 
            e, ok = m.dirty[key]
            // ä¸è®ºå…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œå‡éœ€è¦è®°å½•missæ•°ï¼Œä»¥ä¾¿dirty mapå‡çº§ä¸ºread map
            m.missLocked()
        }
        // è§£é”
        m.mu.Unlock()
    }
    // å…ƒç´ ä¸å­˜åœ¨ç›´æ¥è¿”å›
    if !ok {
        return nil, false
    }
    return e.load()
}
dirty mapå‡çº§ä¸ºread map</p>

<p>func (m *Map) missLocked() {
    // missesè‡ªå¢1
    m.misses++
    // åˆ¤æ–­dirty mapæ˜¯å¦å¯ä»¥å‡çº§ä¸ºread map
    if m.misses &lt; len(m.dirty) {
        return
    }
    // dirty mapå‡çº§ä¸ºread map
    m.read.Store(readOnly{m: m.dirty})
    // dirty map æ¸…ç©º
    m.dirty = nil
    // missesé‡ç½®ä¸º0
    m.misses = 0
}
å…ƒç´ å–å€¼</p>

<p>func (e <em>entry) load() (value interface{}, ok bool) {
    p := atomic.LoadPointer(&amp;e.p)
    // å…ƒç´ ä¸å­˜åœ¨æˆ–è€…è¢«åˆ é™¤ï¼Œåˆ™ç›´æ¥è¿”å›
    if p == nil || p == expunged {
        return nil, false
    }
    return *(</em>interface{})(p), true
}
read mapä¸»è¦ç”¨äºè¯»å–ï¼Œæ¯æ¬¡Loadéƒ½å…ˆä»readè¯»å–ï¼Œå½“readä¸­ä¸å­˜åœ¨ä¸”amendedä¸ºtrueï¼Œå°±ä»dirtyè¯»å–æ•°æ® ã€‚æ— è®ºdirty mapä¸­æ˜¯å¦å­˜åœ¨è¯¥å…ƒç´ ï¼Œéƒ½ä¼šæ‰§è¡ŒmissLockedå‡½æ•°ï¼Œè¯¥å‡½æ•°å°†misses+1ï¼Œå½“m.misses &lt; len(m.dirty)æ—¶ï¼Œä¾¿ä¼šå°†dirtyå¤åˆ¶åˆ°readï¼Œæ­¤æ—¶å†å°†dirtyç½®ä¸ºnil,misses=0ã€‚</p>

<p>storage
è®¾ç½®Key=&gt;Valueã€‚</p>

<p>func (m *Map) Store(key, value interface{}) {
    // å¦‚æœreadå­˜åœ¨è¿™ä¸ªé”®ï¼Œå¹¶ä¸”è¿™ä¸ªentryæ²¡æœ‰è¢«æ ‡è®°åˆ é™¤ï¼Œå°è¯•ç›´æ¥å†™å…¥,å†™å…¥æˆåŠŸï¼Œåˆ™ç»“æŸ
    // ç¬¬ä¸€æ¬¡æ£€æµ‹
    read, _ := m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
        return
    }
    // dirty mapé”
    m.mu.Lock()
    // ç¬¬äºŒæ¬¡æ£€æµ‹
    read, _ = m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok {
        // unexpungeloccç¡®ä¿å…ƒç´ æ²¡æœ‰è¢«æ ‡è®°ä¸ºåˆ é™¤
        // åˆ¤æ–­å…ƒç´ è¢«æ ‡è¯†ä¸ºåˆ é™¤
        if e.unexpungeLocked() {
            // è¿™ä¸ªå…ƒç´ ä¹‹å‰è¢«åˆ é™¤äº†ï¼Œè¿™æ„å‘³ç€æœ‰ä¸€ä¸ªénilçš„dirtyï¼Œè¿™ä¸ªå…ƒç´ ä¸åœ¨é‡Œé¢.
            m.dirty[key] = e
        }
        // æ›´æ–°read map å…ƒç´ å€¼
        e.storeLocked(&amp;value)
    } else if e, ok := m.dirty[key]; ok {
        // æ­¤æ—¶read mapæ²¡æœ‰è¯¥å…ƒç´ ï¼Œä½†æ˜¯dirty mapæœ‰è¯¥å…ƒç´ ï¼Œå¹¶éœ€ä¿®æ”¹dirty mapå…ƒç´ å€¼ä¸ºæœ€æ–°å€¼
        e.storeLocked(&amp;value)
    } else {
        // read.amended==false,è¯´æ˜dirty mapä¸ºç©ºï¼Œéœ€è¦å°†read map å¤åˆ¶ä¸€ä»½åˆ°dirty map
        if !read.amended {
            m.dirtyLocked()
            // è®¾ç½®read.amended==trueï¼Œè¯´æ˜dirty mapæœ‰æ•°æ®
            m.read.Store(readOnly{m: read.m, amended: true})
        }
        // è®¾ç½®å…ƒç´ è¿›å…¥dirty mapï¼Œæ­¤æ—¶dirty mapæ‹¥æœ‰read mapå’Œæœ€æ–°è®¾ç½®çš„å…ƒç´ 
        m.dirty[key] = newEntry(value)
    }
    // è§£é”ï¼Œæœ‰äººè®¤ä¸ºé”çš„èŒƒå›´æœ‰ç‚¹å¤§ï¼Œå‡è®¾read mapæ•°æ®å¾ˆå¤§ï¼Œé‚£ä¹ˆæ‰§è¡Œm.dirtyLocked()ä¼šè€—è´¹èŠ±æ—¶é—´è¾ƒå¤šï¼Œå®Œå…¨å¯ä»¥åœ¨æ“ä½œdirty mapæ—¶æ‰åŠ é”ï¼Œè¿™æ ·çš„æƒ³æ³•æ˜¯ä¸å¯¹çš„ï¼Œå› ä¸ºm.dirtyLocked()ä¸­æœ‰å†™å…¥æ“ä½œ
    m.mu.Unlock()
}
å°è¯•å­˜å‚¨å…ƒç´ ã€‚</p>

<p>func (e *entry) tryStore(i *interface{}) bool {
    // è·å–å¯¹åº”Keyçš„å…ƒç´ ï¼Œåˆ¤æ–­æ˜¯å¦æ ‡è¯†ä¸ºåˆ é™¤
    p := atomic.LoadPointer(&amp;e.p)
    if p == expunged {
        return false
    }
    for {
        // caså°è¯•å†™å…¥æ–°å…ƒç´ å€¼
        if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) {
            return true
        }
        // åˆ¤æ–­æ˜¯å¦æ ‡è¯†ä¸ºåˆ é™¤
        p = atomic.LoadPointer(&amp;e.p)
        if p == expunged {
            return false
        }
    }
}
unexpungeloccç¡®ä¿å…ƒç´ æ²¡æœ‰è¢«æ ‡è®°ä¸ºåˆ é™¤ã€‚å¦‚æœè¿™ä¸ªå…ƒç´ ä¹‹å‰è¢«åˆ é™¤äº†ï¼Œå®ƒå¿…é¡»åœ¨æœªè§£é”å‰è¢«æ·»åŠ åˆ°dirty mapä¸Šã€‚</p>

<p>func (e *entry) unexpungeLocked() (wasExpunged bool) {
    return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)
}
ä»read mapå¤åˆ¶åˆ°dirty mapã€‚</p>

<p>func (m *Map) dirtyLocked() {
    if m.dirty != nil {
        return
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read, _ := m.read.Load().(readOnly)
m.dirty = make(map[interface{}]*entry, len(read.m))
for k, e := range read.m {
    // å¦‚æœæ ‡è®°ä¸ºnilæˆ–è€…expungedï¼Œåˆ™ä¸å¤åˆ¶åˆ°dirty map
    if !e.tryExpungeLocked() {
        m.dirty[k] = e
    }
} } LoadOrStore å¦‚æœå¯¹åº”çš„å…ƒç´ å­˜åœ¨ï¼Œåˆ™è¿”å›è¯¥å…ƒç´ çš„å€¼ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å°†å…ƒç´ å†™å…¥åˆ°sync.Mapã€‚å¦‚æœå·²åŠ è½½å€¼ï¼Œåˆ™åŠ è½½ç»“æœä¸ºtrue;å¦‚æœå·²å­˜å‚¨ï¼Œåˆ™ä¸ºfalseã€‚
</code></pre></div></div>

<p>func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) {
    // ä¸åŠ é”çš„æƒ…å†µä¸‹è¯»å–read map
    // ç¬¬ä¸€æ¬¡æ£€æµ‹
    read, _ := m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok {
        // å¦‚æœå…ƒç´ å­˜åœ¨ï¼ˆæ˜¯å¦æ ‡è¯†ä¸ºåˆ é™¤ç”±tryLoadOrStoreæ‰§è¡Œå¤„ç†ï¼‰ï¼Œå°è¯•è·å–è¯¥å…ƒç´ å·²å­˜åœ¨çš„å€¼æˆ–è€…å°†å…ƒç´ å†™å…¥
        actual, loaded, ok := e.tryLoadOrStore(value)
        if ok {
            return actual, loaded
        }
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m.mu.Lock()
// ç¬¬äºŒæ¬¡æ£€æµ‹
// ä»¥ä¸‹é€»è¾‘å‚çœ‹Store
read, _ = m.read.Load().(readOnly)
if e, ok := read.m[key]; ok {
    if e.unexpungeLocked() {
        m.dirty[key] = e
    }
    actual, loaded, _ = e.tryLoadOrStore(value)
} else if e, ok := m.dirty[key]; ok {
    actual, loaded, _ = e.tryLoadOrStore(value)
    m.missLocked()
} else {
    if !read.amended {
        m.dirtyLocked()
        m.read.Store(readOnly{m: read.m, amended: true})
    }
    m.dirty[key] = newEntry(value)
    actual, loaded = value, false
}
m.mu.Unlock()

return actual, loaded } å¦‚æœæ²¡æœ‰åˆ é™¤å…ƒç´ ï¼ŒtryLoadOrStoreå°†è‡ªåŠ¨åŠ è½½æˆ–å­˜å‚¨ä¸€ä¸ªå€¼ã€‚å¦‚æœåˆ é™¤å…ƒç´ ï¼ŒtryLoadOrStoreä¿æŒæ¡ç›®ä¸å˜å¹¶è¿”å›ok= falseã€‚
</code></pre></div></div>

<p>func (e <em>entry) tryLoadOrStore(i interface{}) (actual interface{}, loaded, ok bool) {
    p := atomic.LoadPointer(&amp;e.p)
    // å…ƒç´ æ ‡è¯†åˆ é™¤ï¼Œç›´æ¥è¿”å›
    if p == expunged {
        return nil, false, false
    }
    // å­˜åœ¨è¯¥å…ƒç´ çœŸå®å€¼ï¼Œåˆ™ç›´æ¥è¿”å›åŸæ¥çš„å…ƒç´ å€¼
    if p != nil {
        return *(</em>interface{})(p), true, true
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å¦‚æœpä¸ºnil(æ­¤å¤„çš„nilï¼Œå¹¶æ˜¯ä¸æ˜¯æŒ‡å…ƒç´ çš„å€¼ä¸ºnilï¼Œè€Œæ˜¯atomic.LoadPointer(&amp;e.p)ä¸ºnilï¼Œå…ƒç´ çš„nilåœ¨unsafe.Pointeræ˜¯æœ‰å€¼çš„)ï¼Œåˆ™æ›´æ–°è¯¥å…ƒç´ å€¼
ic := i
for {
    if atomic.CompareAndSwapPointer(&amp;e.p, nil, unsafe.Pointer(&amp;ic)) {
        return i, false, true
    }
    p = atomic.LoadPointer(&amp;e.p)
    if p == expunged {
        return nil, false, false
    }
    if p != nil {
        return *(*interface{})(p), true, true
    }
} } Delete åˆ é™¤å…ƒç´ ,é‡‡ç”¨å»¶è¿Ÿåˆ é™¤ï¼Œå½“read mapå­˜åœ¨å…ƒç´ æ—¶ï¼Œå°†å…ƒç´ ç½®ä¸ºnilï¼Œåªæœ‰åœ¨æå‡dirtyçš„æ—¶å€™æ‰æ¸…ç†åˆ é™¤çš„æ•°,å»¶è¿Ÿåˆ é™¤å¯ä»¥é¿å…åç»­è·å–åˆ é™¤çš„å…ƒç´ æ—¶å€™éœ€è¦åŠ é”ã€‚å½“read mapä¸å­˜åœ¨å…ƒç´ æ—¶ï¼Œç›´æ¥åˆ é™¤dirty mapä¸­çš„å…ƒç´ 
</code></pre></div></div>

<p>func (m *Map) Delete(key interface{}) {
    // ç¬¬ä¸€æ¬¡æ£€æµ‹
    read, _ := m.read.Load().(readOnly)
    e, ok := read.m[key]
    if !ok &amp;&amp; read.amended {
        m.mu.Lock()
        // ç¬¬äºŒæ¬¡æ£€æµ‹
        read, _ = m.read.Load().(readOnly)
        e, ok = read.m[key]
        if !ok &amp;&amp; read.amended {
            // ä¸è®ºdirty mapæ˜¯å¦å­˜åœ¨è¯¥å…ƒç´ ï¼Œéƒ½ä¼šæ‰§è¡Œåˆ é™¤
            delete(m.dirty, key)
        }
        m.mu.Unlock()
    }
    if ok {
        // å¦‚æœåœ¨readä¸­ï¼Œåˆ™å°†å…¶æ ‡è®°ä¸ºåˆ é™¤ï¼ˆnilï¼‰
        e.delete()
    }
}
å…ƒç´ å€¼ç½®ä¸ºnil</p>

<p>func (e *entry) delete() (hadValue bool) {
    for {
        p := atomic.LoadPointer(&amp;e.p)
        if p == nil || p == expunged {
            return false
        }
        if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
            return true
        }
    }
}
Range
éå†è·å–sync.Mapä¸­æ‰€æœ‰çš„å…ƒç´ ï¼Œä½¿ç”¨çš„ä¸ºå¿«ç…§æ–¹å¼ï¼Œæ‰€ä»¥ä¸ä¸€å®šæ˜¯å‡†ç¡®çš„ã€‚</p>

<p>func (m *Map) Range(f func(key, value interface{}) bool) {
    // ç¬¬ä¸€æ£€æµ‹
    read, _ := m.read.Load().(readOnly)
    // read.amended=true,è¯´æ˜dirty mapåŒ…å«æ‰€æœ‰æœ‰æ•ˆçš„å…ƒç´ ï¼ˆå«æ–°åŠ ï¼Œä¸å«è¢«åˆ é™¤çš„ï¼‰ï¼Œä½¿ç”¨dirty map
    if read.amended {
        // ç¬¬äºŒæ£€æµ‹
        m.mu.Lock()
        read, _ = m.read.Load().(readOnly)
        if read.amended {
            // ä½¿ç”¨dirty mapå¹¶ä¸”å‡çº§ä¸ºread map
            read = readOnly{m: m.dirty}
            m.read.Store(read)
            m.dirty = nil
            m.misses = 0
        }
        m.mu.Unlock()
    }
    // ä¸€è´¯åŸåˆ™ï¼Œä½¿ç”¨read mapä½œä¸ºè¯»
    for k, e := range read.m {
        v, ok := e.load()
        // è¢«åˆ é™¤çš„ä¸è®¡å…¥
        if !ok {
            continue
        }
        // å‡½æ•°è¿”å›falseï¼Œç»ˆæ­¢
        if !f(k, v) {
            break
        }
    }
}
æ€»ç»“
ç»è¿‡äº†ä¸Šé¢çš„åˆ†æå¯ä»¥å¾—åˆ°,sync.Mapå¹¶ä¸é€‚åˆåŒæ—¶å­˜åœ¨å¤§é‡è¯»å†™çš„åœºæ™¯,å¤§é‡çš„å†™ä¼šå¯¼è‡´read mapè¯»å–ä¸åˆ°æ•°æ®ä»è€ŒåŠ é”è¿›è¡Œè¿›ä¸€æ­¥è¯»å–,åŒæ—¶dirty mapä¸æ–­å‡çº§ä¸ºread mapã€‚ ä»è€Œå¯¼è‡´æ•´ä½“æ€§èƒ½è¾ƒä½,ç‰¹åˆ«æ˜¯é’ˆå¯¹cacheåœºæ™¯.é’ˆå¯¹append-onlyä»¥åŠå¤§é‡è¯»,å°‘é‡å†™åœºæ™¯ä½¿ç”¨sync.Mapåˆ™ç›¸å¯¹æ¯”è¾ƒåˆé€‚ã€‚</p>

<p>sync.Mapæ²¡æœ‰æä¾›è·å–å…ƒç´ ä¸ªæ•°çš„Len()æ–¹æ³•ï¼Œä¸è¿‡å¯ä»¥é€šè¿‡Range()å®ç°ã€‚</p>

<p>func Len(sm sync.Map) int {
    lengh := 0
    f := func(key, value interface{}) bool {
        lengh++
        return true
    }
    one:=lengh
    lengh=0
    sm.Range(f)
    if one != lengh {
        one = lengh
        lengh=0
        sm.Range(f)
        if one &lt;lengh {
            return lengh
        }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>}
return one }
</code></pre></div></div>
:ET