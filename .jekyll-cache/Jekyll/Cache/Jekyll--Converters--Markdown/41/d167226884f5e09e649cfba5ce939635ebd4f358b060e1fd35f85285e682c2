I"è*<p>åœ¨Go 1.7ï¼Œæˆ‘ä»¬æœ‰ä¸€ä¸ªæ–°åŒ…/ HTTP / httptraceæä¾›äº†ä¸€ä¸ªæ–¹ä¾¿çš„æœºåˆ¶ï¼Œè§‚å¯Ÿä¸€ä¸ªHTTPè¯·æ±‚æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆ
åˆ†å¸ƒå¼è·Ÿè¸ªæ˜¯ç›‘æµ‹å’Œåˆ†æå¾®æœåŠ¡æ¶æ„ç³»ç»Ÿï¼Œå¯¼å‡ºç»“æœåˆ°ä¸ºX-TRACEï¼Œå¦‚è°·æ­Œçš„Dapperå’ŒTwitterçš„Zipkin ã€‚ å®ƒä»¬çš„åº•å±‚åŸç†æ˜¯åˆ†å¸ƒå¼ç¯å¢ƒä¼ æ’­ ï¼Œå…¶ä¸­æ¶‰åŠçš„æŸäº›å…ƒæ•°æ®ä¸è¿›å…¥ç³»ç»Ÿçš„æ¯ä¸ªè¯·æ±‚ç›¸å…³è”ï¼Œå¹¶ä¸”è·¨çº¿ç¨‹å’Œè¿›ç¨‹è¾¹ç•Œä¼ æ’­å…ƒæ•°æ®è·Ÿéšè¯·æ±‚è¿›å‡ºå„ç§å¾®æœåŠ¡è°ƒç”¨ã€‚ å¦‚æœæˆ‘ä»¬ä¸ºæ¯ä¸ªå…¥ç«™è¯·æ±‚åˆ†é…ä¸€ä¸ªå”¯ä¸€çš„IDå¹¶å°†å…¶ä½œä¸ºåˆ†å¸ƒå¼ä¸Šä¸‹æ–‡çš„ä¸€éƒ¨åˆ†ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å°†æ¥è‡ªå¤šä¸ªçº¿ç¨‹å’Œå¤šä¸ªè¿›ç¨‹çš„å„ç§æ€§èƒ½åˆ†ææ•°æ®åˆå¹¶åˆ°ç»Ÿä¸€çš„è¡¨ç¤ºæˆ‘ä»¬ç³»ç»Ÿæ‰§è¡Œè¯·æ±‚çš„â€œè·Ÿè¸ªâ€ä¸­ã€‚
åˆ†å¸ƒå¼è·Ÿè¸ªéœ€è¦ä½¿ç”¨Hooké’©å­å’Œä¸Šä¸‹æ–‡ä¼ æ’­æœºåˆ¶æ¥æµ‹è¯•åº”ç”¨ç¨‹åºä»£ç ï¼ˆæˆ–å…¶ä½¿ç”¨çš„æ¡†æ¶ï¼‰ã€‚
æ²¡æœ‰è‰¯å¥½çš„APIä¸ºå¼€å‘äººå‘˜æä¾›åœ¨ç¼–ç¨‹è¯­è¨€ä¹‹é—´å†…éƒ¨ä¸€è‡´æ€§ï¼Œé‚£å°±æ— æ³•ç»‘å®šåˆ°æŒ‡å®šçš„è·Ÿè¸ªç³»ç»Ÿã€‚
2015å¹´10æœˆä¸€ä¸ªæ–°çš„ç¤¾åŒºå½¢æˆï¼Œå‚¬ç”Ÿäº†OpenTracing APIï¼Œä¸€ä¸ªå¼€æ”¾çš„ï¼Œå‚å•†ä¸­ç«‹çš„ï¼Œä¸è¯­è¨€æ— å…³çš„åˆ†å¸ƒå¼è·Ÿè¸ªæ ‡å‡†ã€‚ä½ å¯ä»¥é˜…è¯»æ›´å¤šå…³äºBen Sigelmanæœ‰å…³OpenTracingåŠ¨æœºå’Œè®¾è®¡åŸç†èƒŒåçš„æ–‡ç«  ã€‚
https://opentracing.io/
https://zipkin.io/
https://github.com/openzipkin/zipkin
https://github.com/openzipkin/zipkin-go
https://github.com/opentracing/opentracing-go
<!-- more --></p>

<p>import (
   â€œnet/httpâ€
   â€œnet/http/httptraceâ€</p>

<p>â€œgithub.com/opentracing/opentracing-goâ€
   â€œgithub.com/opentracing/opentracing-go/logâ€
   â€œgolang.org/x/net/contextâ€
)</p>

<p>// We will talk about this later
var tracer opentracing.Tracer</p>

<p>func AskGoogle(ctx context.Context) error {
   // retrieve current Span from Context
   var parentCtx opentracing.SpanContext
   parentSpan := opentracing.SpanFromContext(ctx); 
   if parentSpan != nil {
      parentCtx = parentSpan.Context()
   }</p>

<p>// start a new Span to wrap HTTP request
   span := tracer.StartSpan(
      â€œask googleâ€,
      opentracing.ChildOf(parentCtx),
   )</p>

<p>// make sure the Span is finished once weâ€™re done
   defer span.Finish()</p>

<p>// make the Span current in the context
   ctx = opentracing.ContextWithSpan(ctx, span)</p>

<p>// now prepare the request
   req, err := http.NewRequest(â€œGETâ€, â€œhttp://google.comâ€, nil)
   if err != nil {
      return err
   }</p>

<p>// attach ClientTrace to the Context, and Context to request 
   trace := NewClientTrace(span)
   ctx = httptrace.WithClientTrace(ctx, trace)
   req = req.WithContext(ctx)</p>

<p>// execute the request
   res, err := http.DefaultClient.Do(req)
   if err != nil {
      return err
   }</p>

<p>// Google home page is not too exciting, so ignore the result
   res.Body.Close()
   return nil
}</p>

<p>æ³¨æ„ï¼š</p>

<p>1.å›é¿äº†tracerå˜é‡åˆå§‹åŒ–çš„é—®é¢˜ã€‚</p>

<p>2.AskGoogleå‡½æ•°æ¥å—context.Contextå¯¹è±¡ã€‚è¿™æ˜¯ä¸ºå¼€å‘åˆ†å¸ƒå¼åº”ç”¨ç¨‹åºçš„Goæ¨èæ–¹å¼ï¼Œå› ä¸ºä¸Šä¸‹æ–‡å¯¹è±¡æ˜¯è¦è®©åˆ†å¸ƒå¼ç¯å¢ƒä¼ æ’­ã€‚</p>

<p>3.æˆ‘ä»¬å‡è®¾ä¸Šä¸‹æ–‡å·²ç»åŒ…å«çˆ¶è·Ÿè¸ªSpanã€‚ OpenTracing APIä¸­çš„Spanæ˜¯ç”¨äºè¡¨ç¤ºç”±å¾®æœåŠ¡æ‰§è¡Œçš„å·¥ä½œå•å…ƒã€‚HTTPè°ƒç”¨å°±æ˜¯å¯ä»¥åŒ…è£¹åœ¨è·Ÿè¸ªSpanä¸­çš„æ“ä½œæ¡ˆä¾‹ã€‚ å½“æˆ‘ä»¬è¿è¡Œå¤„ç†å…¥ç«™è¯·æ±‚çš„æœåŠ¡æ—¶ï¼ŒæœåŠ¡é€šå¸¸ä¼šä¸ºæ¯ä¸ªè¯·æ±‚åˆ›å»ºä¸€ä¸ªè·Ÿè¸ªèŒƒå›´ï¼Œå¹¶å°†å…¶å­˜å‚¨åœ¨ä¸Šä¸‹æ–‡ä¸­ï¼Œä»¥ä¾¿åœ¨å¯¹å¦ä¸€ä¸ªæœåŠ¡è¿›è¡Œä¸‹æ¸¸è°ƒç”¨æ—¶å¯ç”¨ï¼ˆåœ¨æˆ‘ä»¬çš„ç¤ºä¾‹ä¸­ä¸ºgoogle.com ï¼‰ã€‚</p>

<p>4.æˆ‘ä»¬å¯åŠ¨ä¸€ä¸ªæ–°çš„å­Spanæ¥åŒ…è£…å‡ºç«™HTTPè°ƒç”¨ã€‚ å¦‚æœçˆ¶Spanç¼ºå¤±ï¼Œè¿™æ˜¯å¥½æ–¹æ³•ã€‚</p>

<p>5.æœ€åï¼Œåœ¨åšå‡ºHTTPè¯·æ±‚ä¹‹å‰ï¼Œæˆ‘ä»¬å®ä¾‹åŒ–ä¸€ä¸ªClientTraceå¹¶å°†å…¶é™„åŠ åˆ°è¯·æ±‚ã€‚</p>

<p>ClientTraceç»“æ„æ˜¯httptraceçš„åŸºæœ¬æ„å»ºå— ã€‚å®ƒå…è®¸æˆ‘ä»¬åœ¨HTTPè¯·æ±‚çš„ç”Ÿå‘½å‘¨æœŸå†…æ³¨å†Œå°†ç”±HTTPå®¢æˆ·ç«¯æ‰§è¡Œçš„å›è°ƒå‡½æ•°ã€‚ ä¾‹å¦‚ï¼ŒClientTraceç»“æ„æœ‰è¿™æ ·çš„æ–¹æ³•ï¼š</p>

<p>type ClientTrace struct {
â€¦
        // DNSStart is called when a DNS lookup begins.
        DNSStart func(DNSStartInfo)
        // DNSDone is called when a DNS lookup ends.
        DNSDone func(DNSDoneInfo)
â€¦
}</p>
<p>
æˆ‘ä»¬åœ¨NewClientTraceæ–¹æ³•ä¸­åˆ›å»ºè¿™ä¸ªç»“æ„çš„ä¸€ä¸ªå®ä¾‹ï¼š

func NewClientTrace(span opentracing.Span) *httptrace.ClientTrace {
   trace := &amp;clientTrace{span: span}
   return &amp;httptrace.ClientTrace {
      DNSStart: trace.dnsStart,
      DNSDone:  trace.dnsDone,
   }
}

// clientTrace holds a reference to the Span and
// provides methods used as ClientTrace callbacks
type clientTrace struct {
   span opentracing.Span
}

func (h *clientTrace) dnsStart(info httptrace.DNSStartInfo) {
   h.span.LogKV(
      log.String("event", "DNS start"),
      log.Object("host", info.Host),
   )
}

func (h *clientTrace) dnsDone(httptrace.DNSDoneInfo) {
   h.span.LogKV(log.String("event", "DNS done"))
}

<p>
æˆ‘ä»¬ä¸ºDBBStartå’ŒDNSDoneäº‹ä»¶å®ç°æ³¨å†Œä¸¤ä¸ªå›è°ƒå‡½æ•°ï¼Œé€šè¿‡ç§æœ‰ç»“æ„clientTraceä¿æœ‰ä¸€ä¸ªæŒ‡å‘è·Ÿè¸ªSpanã€‚ åœ¨å›è°ƒæ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨Spançš„é”®å€¼è®°å½•APIæ¥è®°å½•äº‹ä»¶çš„ä¿¡æ¯ï¼Œä»¥åŠSpanæœ¬èº«éšå«æ•è·çš„æ—¶é—´æˆ³ã€‚

ä½ ä¸æ˜¯è¯´å…³äºUIçš„ä¸œè¥¿å—ï¼Ÿ

OpenTracing APIçš„å·¥ä½œæ–¹å¼æ˜¯ï¼Œä¸€æ—¦è°ƒç”¨è·Ÿè¸ªSpançš„Finishï¼ˆï¼‰æ–¹æ³•ï¼ŒSpanæ•è·çš„æ•°æ®å°†å‘é€åˆ°è·Ÿè¸ªç³»ç»Ÿåç«¯ï¼Œé€šå¸¸åœ¨åå°å¼‚æ­¥å‘é€ã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨è·Ÿè¸ªç³»ç»ŸUIæ¥æŸ¥æ‰¾è·Ÿè¸ªå¹¶åœ¨æ—¶é—´çº¿ä¸Šå°†å…¶å¯è§†åŒ–ã€‚ ç„¶è€Œï¼Œä¸Šè¿°ä¾‹å­åªæ˜¯ä¸ºäº†è¯´æ˜ä½¿ç”¨OpenTracingä¸httptraceçš„åŸç†ã€‚å¯¹äºçœŸæ­£çš„å·¥ä½œç¤ºä¾‹ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨ç°æœ‰çš„åº“https://github.com/opentracing-contrib/go-stdlib ã€‚ ä½¿ç”¨è¿™ä¸ªåº“æˆ‘ä»¬çš„å®¢æˆ·ç«¯ä»£ç ä¸éœ€è¦æ‹…å¿ƒè·Ÿè¸ªå®é™…çš„HTTPè°ƒç”¨ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬ä»ç„¶å¸Œæœ›åˆ›å»ºä¸€ä¸ªé¡¶å±‚è·Ÿè¸ªSpanæ¥è¡¨ç¤ºå®¢æˆ·ç«¯åº”ç”¨ç¨‹åºçš„æ•´ä½“æ‰§è¡Œï¼Œå¹¶è®°å½•ä»»ä½•é”™è¯¯ã€‚

package main

import (
   "fmt"
   "io/ioutil"
   "log"
   "net/http"

   "github.com/opentracing-contrib/go-stdlib/nethttp"
   "github.com/opentracing/opentracing-go"
   "github.com/opentracing/opentracing-go/ext"
   otlog "github.com/opentracing/opentracing-go/log"
   "golang.org/x/net/context"
)

func runClient(tracer opentracing.Tracer) {
   // nethttp.Transport from go-stdlib will do the tracing
   c := &amp;http.Client{Transport: &amp;nethttp.Transport{}}

   // create a top-level span to represent full work of the client
   span := tracer.StartSpan(client)
   span.SetTag(string(ext.Component), client)
   defer span.Finish()
   ctx := opentracing.ContextWithSpan(context.Background(), span)

   req, err := http.NewRequest(
      "GET",
      fmt.Sprintf("http://localhost:%s/", *serverPort),
      nil,
   )
   if err != nil {
      onError(span, err)
      return
   }

   req = req.WithContext(ctx)
   // wrap the request in nethttp.TraceRequest
   req, ht := nethttp.TraceRequest(tracer, req)
   defer ht.Finish()

   res, err := c.Do(req)
   if err != nil {
      onError(span, err)
      return
   }
   defer res.Body.Close()
   body, err := ioutil.ReadAll(res.Body)
   if err != nil {
      onError(span, err)
      return
   }
   fmt.Printf("Received result: %s\n", string(body))
}

func onError(span opentracing.Span, err error) {
   // handle errors by recording them in the span
   span.SetTag(string(ext.Error), true)
   span.LogKV(otlog.Error(err))
   log.Print(err)
}
<p>
ä¸Šé¢çš„å®¢æˆ·ç«¯ä»£ç è°ƒç”¨æœ¬åœ°æœåŠ¡å™¨ã€‚ è®©æˆ‘ä»¬å®ç°å®ƒã€‚

package main

import (
   "fmt"
   "io"
   "log"
   "net/http"
   "time"

   "github.com/opentracing-contrib/go-stdlib/nethttp"
   "github.com/opentracing/opentracing-go"
)

func getTime(w http.ResponseWriter, r *http.Request) {
   log.Print("Received getTime request")
   t := time.Now()
   ts := t.Format("Mon Jan _2 15:04:05 2006")
   io.WriteString(w, fmt.Sprintf("The time is %s", ts))
}

func redirect(w http.ResponseWriter, r *http.Request) {
   http.Redirect(w, r,
      fmt.Sprintf("http://localhost:%s/gettime", *serverPort), 301)
}

func runServer(tracer opentracing.Tracer) {
   http.HandleFunc("/gettime", getTime)
   http.HandleFunc("/", redirect)
   log.Printf("Starting server on port %s", *serverPort)
   http.ListenAndServe(
      fmt.Sprintf(":%s", *serverPort),
      // use nethttp.Middleware to enable OpenTracing for server
      nethttp.Middleware(tracer, http.DefaultServeMux))
}
 
æ³¨æ„ï¼Œå®¢æˆ·ç«¯å‘æ ¹ç«¯ç‚¹â€œ/â€å‘å‡ºè¯·æ±‚ï¼Œä½†æœåŠ¡å™¨å°†å…¶é‡å®šå‘åˆ°â€œ/ gettimeâ€ç«¯ç‚¹ã€‚ è¿™æ ·åšå…è®¸æˆ‘ä»¬æ›´å¥½åœ°è¯´æ˜å¦‚ä½•åœ¨è·Ÿè¸ªç³»ç»Ÿä¸­æ•è·è·Ÿè¸ªã€‚

å¼€å‘å’Œå·¥ç¨‹å›¢é˜Ÿå› ä¸ºç³»ç»Ÿç»„ä»¶æ°´å¹³æ‰©å±•ã€å¼€å‘å›¢é˜Ÿå°å‹åŒ–ã€æ•æ·å¼€å‘ã€CDï¼ˆæŒç»­é›†æˆï¼‰ã€è§£è€¦ç­‰å„ç§éœ€æ±‚ï¼Œæ­£åœ¨ä½¿ç”¨ç°ä»£çš„å¾®æœåŠ¡æ¶æ„æ›¿æ¢è€æ—§çš„å•ç‰‡æœºç³»ç»Ÿã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“ä¸€ä¸ªç”Ÿäº§ç³»ç»Ÿé¢å¯¹çœŸæ­£çš„é«˜å¹¶å‘ï¼Œæˆ–è€…è§£è€¦æˆå¤§é‡å¾®æœåŠ¡æ—¶ï¼Œä»¥å‰å¾ˆå®¹æ˜“å®ç°çš„é‡ç‚¹ä»»åŠ¡å˜å¾—å›°éš¾äº†ã€‚è¿‡ç¨‹ä¸­éœ€è¦é¢ä¸´ä¸€ç³»åˆ—é—®é¢˜ï¼šç”¨æˆ·ä½“éªŒä¼˜åŒ–ã€åå°çœŸæ˜¯é”™è¯¯åŸå› åˆ†æï¼Œåˆ†å¸ƒå¼ç³»ç»Ÿå†…å„ç»„ä»¶çš„è°ƒç”¨æƒ…å†µç­‰ã€‚å½“ä»£åˆ†å¸ƒå¼è·Ÿè¸ªç³»ç»Ÿï¼ˆä¾‹å¦‚ï¼ŒZipkin, Dapper, HTrace, X-Traceç­‰ï¼‰æ—¨åœ¨è§£å†³è¿™äº›é—®é¢˜ï¼Œä½†æ˜¯ä»–ä»¬ä½¿ç”¨ä¸å…¼å®¹çš„APIæ¥å®ç°å„è‡ªçš„åº”ç”¨éœ€æ±‚ã€‚å°½ç®¡è¿™äº›åˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿæœ‰ç€ç›¸ä¼¼çš„APIè¯­æ³•ï¼Œä½†å„ç§è¯­è¨€çš„å¼€å‘äººå‘˜ä¾ç„¶å¾ˆéš¾å°†ä»–ä»¬å„è‡ªçš„ç³»ç»Ÿï¼ˆä½¿ç”¨ä¸åŒçš„è¯­è¨€å’ŒæŠ€æœ¯ï¼‰å’Œç‰¹å®šçš„åˆ†å¸ƒå¼è¿½è¸ªç³»ç»Ÿè¿›è¡Œæ•´åˆï¼Œ

ä¸ºä»€ä¹ˆéœ€è¦OpenTracingï¼Ÿ
OpenTracingé€šè¿‡æä¾›å¹³å°æ— å…³ã€å‚å•†æ— å…³çš„APIï¼Œä½¿å¾—å¼€å‘äººå‘˜èƒ½å¤Ÿæ–¹ä¾¿çš„æ·»åŠ ï¼ˆæˆ–æ›´æ¢ï¼‰è¿½è¸ªç³»ç»Ÿçš„å®ç°ã€‚ OpenTracingæä¾›äº†ç”¨äºè¿è¥æ”¯æ’‘ç³»ç»Ÿçš„å’Œé’ˆå¯¹ç‰¹å®šå¹³å°çš„è¾…åŠ©ç¨‹åºåº“ã€‚ç¨‹åºåº“çš„å…·ä½“ä¿¡æ¯è¯·å‚è€ƒè¯¦ç»†çš„è§„èŒƒã€‚

ä»€ä¹ˆæ˜¯ä¸€ä¸ªTrace?
åœ¨å¹¿ä¹‰ä¸Šï¼Œä¸€ä¸ªtraceä»£è¡¨äº†ä¸€ä¸ªäº‹åŠ¡æˆ–è€…æµç¨‹åœ¨ï¼ˆåˆ†å¸ƒå¼ï¼‰ç³»ç»Ÿä¸­çš„æ‰§è¡Œè¿‡ç¨‹ã€‚åœ¨OpenTracingæ ‡å‡†ä¸­ï¼Œtraceæ˜¯å¤šä¸ªspanç»„æˆçš„ä¸€ä¸ªæœ‰å‘æ— ç¯å›¾ï¼ˆDAGï¼‰ï¼Œæ¯ä¸€ä¸ªspanä»£è¡¨traceä¸­è¢«å‘½åå¹¶è®¡æ—¶çš„è¿ç»­æ€§çš„æ‰§è¡Œç‰‡æ®µã€‚


åˆ†å¸ƒå¼è¿½è¸ªä¸­çš„æ¯ä¸ªç»„ä»¶éƒ½åŒ…å«è‡ªå·±çš„ä¸€ä¸ªæˆ–è€…å¤šä¸ªspanã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸€ä¸ªå¸¸è§„çš„RPCè°ƒç”¨è¿‡ç¨‹ä¸­ï¼ŒOpenTracingæ¨èåœ¨RPCçš„å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ï¼Œè‡³å°‘å„æœ‰ä¸€ä¸ªspanï¼Œç”¨äºè®°å½•RPCè°ƒç”¨çš„å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ä¿¡æ¯ã€‚

ä¸€ä¸ªçˆ¶çº§çš„spanä¼šæ˜¾ç¤ºçš„å¹¶è¡Œæˆ–è€…ä¸²è¡Œå¯åŠ¨å¤šä¸ªå­spanã€‚åœ¨OpenTracingæ ‡å‡†ä¸­ï¼Œç”šè‡³å…è®¸ä¸€ä¸ªå­spanæœ‰ä¸ªå¤šçˆ¶spanï¼ˆä¾‹å¦‚ï¼šå¹¶è¡Œå†™å…¥çš„ç¼“å­˜ï¼Œå¯èƒ½é€šè¿‡ä¸€æ¬¡åˆ·æ–°æ“ä½œå†™å…¥åŠ¨ä½œï¼‰ã€‚

è¿™ç§å±•ç°æ–¹å¼å¢åŠ æ˜¾ç¤ºäº†æ‰§è¡Œæ—¶é—´çš„ä¸Šä¸‹æ–‡ï¼Œç›¸å…³æœåŠ¡é—´çš„å±‚æ¬¡å…³ç³»ï¼Œè¿›ç¨‹æˆ–è€…ä»»åŠ¡çš„ä¸²è¡Œæˆ–å¹¶è¡Œè°ƒç”¨å…³ç³»ã€‚è¿™æ ·çš„è§†å›¾æœ‰åŠ©äºå‘ç°ç³»ç»Ÿè°ƒç”¨çš„å…³é”®è·¯å¾„ã€‚é€šè¿‡å…³æ³¨å…³é”®è·¯å¾„çš„æ‰§è¡Œè¿‡ç¨‹ï¼Œé¡¹ç›®å›¢é˜Ÿå¯èƒ½ä¸“æ³¨äºä¼˜åŒ–è·¯å¾„ä¸­çš„å…³é”®ä½ç½®ï¼Œæœ€å¤§å¹…åº¦çš„æå‡ç³»ç»Ÿæ€§èƒ½ã€‚ä¾‹å¦‚ï¼šå¯ä»¥é€šè¿‡è¿½è¸ªä¸€ä¸ªèµ„æºå®šä½çš„è°ƒç”¨æƒ…å†µï¼Œæ˜ç¡®åº•å±‚çš„è°ƒç”¨æƒ…å†µï¼Œå‘ç°å“ªäº›æ“ä½œæœ‰é˜»å¡çš„æƒ…å†µã€‚

http://bigbully.github.io/Dapper-translation/

https://github.com/bigbully/Dapper-translation
</p></p></p>
:ET