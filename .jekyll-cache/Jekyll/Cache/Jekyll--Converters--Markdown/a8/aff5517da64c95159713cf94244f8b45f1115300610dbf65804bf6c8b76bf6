I"ƒ<p>Unary Client Interceptor
UnaryClientInterceptor intercepts the execution of a unary RPC on the client. Invoker is the handler to complete the RPC and it is the responsibility of the interceptor to call it. It is a function type with the signature:</p>

<p>type UnaryClientInterceptor func(ctx context.Context, method string, req, reply interface{}, cc *ClientConn, invoker UnaryInvoker, opts â€¦CallOption) error</p>

<p>func UnaryClientInterceptor(log logr.Logger, opts â€¦Option) grpc.UnaryClientInterceptor {
	o := evaluateClientOpt(opts)
	return func(ctx context.Context, method string, req, reply interface{}, cc <em>grpc.ClientConn, invoker grpc.UnaryInvoker, opts â€¦grpc.CallOption) error {
		request := req.(</em>api.ClientRequestType)
		log.Info(â€œrequesting all product types from vendor: â€œ + request.GetVendor())
		fields := newClientLoggerFields(ctx, method)
		startTime := time.Now()
		err := invoker(ctx, method, req, reply, cc, optsâ€¦)
		logFinalClientLine(o, log, fields, startTime, err, â€œfinished client unary callâ€)
		return err
	}
}</p>

<p>Unary Server Interceptor
Unary server Interceptor has the signature:</p>

<p>type UnaryServerInterceptor func(ctx context.Context, req interface{}, info *UnaryServerInfo, handler UnaryHandler) (resp interface{}, err error)</p>

<p>It provides a hook to intercept the execution of a unary RPC on the server and it allow us to modify the response returned from the gRPC call. Context is used for timeouts but also to add/retrieve request metadata. info is the information on the gRPC server that is handling the request. handler has to be invoked to get the response back to the client. The Unary Server Interceptor looks fairly similar with the client, it is wraped within a function to evaluate the logging options if any.</p>

<p>func UnaryServerInterceptor(log logr.Logger, opts â€¦Option) grpc.UnaryServerInterceptor {
	o := evaluateServerOpt(opts)
	return func(ctx context.Context, req interface{}, info <em>grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
		request := req.(</em>api.ClientRequestType)
		log.Info(â€œhave received a request for â€œ + request.GetVendor() + â€œ as vendor â€œ)
		startTime := time.Now()
		newCtx := newLoggerForCall(ctx, info.FullMethod, startTime)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	resp, err := handler(newCtx, req)

	if !o.shouldLog(info.FullMethod, err) {
		return resp, err
	}
	code := o.codeFunc(err)
	level := o.levelFunc(code)
	durField, durVal := o.durationFunc(time.Since(startTime))
	fields := Extract(newCtx)
	fields[durField] = durVal
	fields["grpc.code"] = code.String()

	levelLogf(log, level, "finished streaming call with code "+code.String(), fields, err)

	return resp, err
} }
</code></pre></div></div>

<p>https://dev-state.com/posts/grpc_framework_3/
<!-- more -->
https://dev.to/davidsbond/golang-creating-grpc-interceptors-5el5</p>

<p>https://shijuvar.medium.com/writing-grpc-interceptors-in-go-bf3e7671fe48</p>

<p>https://github.com/grpc-ecosystem/go-grpc-middleware/blob/master/retry/retry.go</p>

<p>HTTPæ ‡å¤´æ˜¯å¦åŒºåˆ†å¤§å°å†™ï¼Ÿ
HTTPæŠ¥å¤´çš„åç§°æ˜¯ä¸åŒºåˆ†å¤§å°å†™ï¼Œæ ¹æ®RFC 2616ï¼š</p>

<p>æ¯ä¸ªæ ‡é¢˜å­—æ®µç”±ä¸€ä¸ªåå­—åè·Ÿä¸€ä¸ªå†’å·ï¼ˆâ€œï¼šâ€ï¼‰å’Œå­—æ®µå€¼ç»„æˆã€‚å­—æ®µåç§°ä¸åŒºåˆ†å¤§å°å†™ã€‚</p>

<p>ï¼ˆå­—æ®µå€¼å¯èƒ½åŒºåˆ†å¤§å°å†™ï¼Œä¹Ÿå¯èƒ½ä¸åŒºåˆ†å¤§å°å†™ï¼‰</p>

<p>å¦‚æœä¿¡ä»»ä¸»è¦çš„æµè§ˆå™¨éµå®ˆè¿™ä¸€ç‚¹ï¼Œä½ å°±å…¨éƒ¨è®¾ç½®ã€‚</p>

<p>é¡ºä¾¿è¯´ä¸€å¥ï¼Œä¸åƒå¤§å¤šæ•°çš„HTTPï¼Œæ–¹æ³•ï¼ˆåŠ¨è¯ï¼‰æ˜¯åŒºåˆ†å¤§å°å†™çš„ï¼š</p>

<p>æ–¹æ³•æ ‡è®°æŒ‡ç¤ºåœ¨</p>

<p>ç”±è¯·æ±‚URIæ ‡è¯†çš„èµ„æºä¸Šæ‰§è¡Œçš„æ–¹æ³•ã€‚è¯¥æ–¹æ³•æ˜¯åŒºåˆ†å¤§å°å†™çš„ã€‚</p>

<p>https://cloud.tencent.com/developer/ask/26311</p>

<p>gRPCè®©æˆ‘ä»¬å¯ä»¥åƒæœ¬åœ°è°ƒç”¨ä¸€æ ·å®ç°è¿œç¨‹è°ƒç”¨ï¼Œå¯¹äºæ¯ä¸€æ¬¡çš„RPCè°ƒç”¨ä¸­ï¼Œéƒ½å¯èƒ½ä¼šæœ‰ä¸€äº›æœ‰ç”¨çš„æ•°æ®ï¼Œè€Œè¿™äº›æ•°æ®å°±å¯ä»¥é€šè¿‡metadataæ¥ä¼ é€’ã€‚metadataæ˜¯ä»¥key-valueçš„å½¢å¼å­˜å‚¨æ•°æ®çš„ï¼Œå…¶ä¸­keyæ˜¯stringç±»å‹ï¼Œè€Œvalueæ˜¯[]stringï¼Œå³ä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ç±»å‹ã€‚metadataä½¿å¾—clientå’Œserverèƒ½å¤Ÿä¸ºå¯¹æ–¹æä¾›å…³äºæœ¬æ¬¡è°ƒç”¨çš„ä¸€äº›ä¿¡æ¯ï¼Œå°±åƒä¸€æ¬¡httpè¯·æ±‚çš„RequestHeaderå’ŒResponseHeaderä¸€æ ·ã€‚httpä¸­headerçš„ç”Ÿå‘½å‘¨å‘¨æœŸæ˜¯ä¸€æ¬¡httpè¯·æ±‚ï¼Œé‚£ä¹ˆmetadataçš„ç”Ÿå‘½å‘¨æœŸå°±æ˜¯ä¸€æ¬¡RPCè°ƒç”¨ã€‚</p>

<p>è¿™ä¸ªåŒ…ä¸­å®ç°äº†å¤šç§åˆ›å»ºmetadataçš„æ–¹æ³•ã€‚é¦–å…ˆæˆ‘ä»¬æ¥çœ‹çœ‹metadataçš„å®šä¹‰ï¼š</p>

<p>type MD map[string][]string
å‘é€metadata
åœ¨clientä¸­å¯ä»¥é€šè¿‡ä¸¤ä¸ªæ–¹æ³•å°†metadataå‘é€åˆ°serverç«¯ã€‚é€šè¿‡AppendToOutgoingContextæ–¹æ³•å¯ä»¥å°†key-valueå¯¹æ·»åŠ åˆ°å·²æœ‰çš„contextä¸­ã€‚å¦‚æœå¯¹åº”çš„contextæ²¡æœ‰metadataï¼Œé‚£ä¹ˆå°±ä¼šåˆ›å»ºä¸€ä¸ªï¼›å¦‚æœå·²æœ‰metadataäº†ï¼Œé‚£ä¹ˆå°±å°†æ•°æ®æ·»åŠ åˆ°åŸæ¥çš„metadataä¸­ï¼š</p>

<p>// create a new context with some metadata
ctx := metadata.AppendToOutgoingContext(ctx, â€œk1â€, â€œv1â€, â€œk1â€, â€œv2â€, â€œk2â€, â€œv3â€)</p>

<p>å¦ä¸€ä¸ªæ–¹æ³•æ˜¯é€šè¿‡NewOutgoingContextæ–¹æ³•å°†æ–°åˆ›å»ºçš„metadataæ·»åŠ åˆ°contextä¸­ï¼Œè¿™æ ·ä¼šè¦†ç›–æ‰åŸæ¥å·²æœ‰çš„metadataï¼Œæ‰€ä»¥ä½¿ç”¨çš„æ—¶å€™éœ€è¦æ³¨æ„ã€‚åŒæ—¶ï¼Œè¿™ä¸ªæ–¹æ³•æ¯”AppendToOutgoingContextæ–¹æ³•è¦æ…¢</p>

<p>4.1 æ¥æ”¶metadata
æœåŠ¡å™¨éœ€è¦åœ¨RPCè°ƒç”¨ä¸­çš„contextä¸­è·å–å®¢æˆ·ç«¯å‘é€çš„metadataã€‚å¦‚æœæ˜¯ä¸€ä¸ªæ™®é€šçš„RPCè°ƒç”¨ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç›´æ¥ç”¨contextï¼›å¦‚æœæ˜¯ä¸€ä¸ªStreamingè°ƒç”¨ï¼ŒæœåŠ¡å™¨éœ€è¦ä»ç›¸åº”çš„streamé‡Œè·å–contextï¼Œç„¶åè·å–metadataã€‚</p>

<p>Unary Call
func (s <em>server) SomeRPC(ctx context.Context, in *pb.someRequest) (</em>pb.someResponse, error) {
    md, ok := metadata.FromIncomingContext(ctx)
    // do something with metadata
}
https://www.jianshu.com/p/863dad87d16f</p>

<p>grpc SetHeader å’Œ SetTrailer çš„åŒºåˆ«å’Œè”ç³»</p>

<p>åœ¨ä½¿ç”¨grpcè¿‡ç¨‹ä¸­å‘ç°ï¼Œå‘é€ matedata æœ‰ä¸¤ç§æ–¹å¼ ä¸€ç§æ˜¯é€šè¿‡ grpc.SendHeader(ctx,md),å¦å¤–ä¸€ç§æ˜¯ grpc.SetTrailer(ctx,md)</p>

<p>ç–‘é—® æ—¢ç„¶å¯ä»¥é€šè¿‡ SendHeader å‘é€å…ƒæ•°æ®ï¼Œä¸ºä»€ä¹ˆè¿˜éœ€è¦é€šè¿‡ SetTrailer å‘é€å‘¢ï¼Ÿè¿™ä¸¤ä¸ªçš„åŒºåˆ«å’Œè”ç³»æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿ</p>

<p>è¿‡ç¨‹
é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“grpcé€šä¿¡æ¨¡å¼åˆ†ä¸ºå››ç§</p>

<p>ä¸€å…ƒRPCæ¨¡å¼
æœåŠ¡å™¨æµRPCæ¨¡å¼
å®¢æˆ·ç«¯æµRPCæ¨¡å¼
åŒå‘æµRPCæ¨¡å¼
ç„¶åï¼Œæˆ‘ä»¬çœ‹ ä¸€å…ƒRPCæ¨¡å¼ å’Œ åŒå‘æµRPCæ¨¡å¼ çš„åŒºåˆ«
headerå’Œtrailerçš„æ¥æ”¶æ—¶æœºä¸åŒï¼Œå¯ä»¥çœ‹å‡ºï¼Œåœ¨ä¸€å…ƒæ¨¡å¼ä¸­ï¼Œheaderå’Œtraileræ˜¯ä¸€èµ·åˆ°è¾¾å®¢æˆ·ç«¯çš„ï¼Œæ­¤æ—¶å®¢æˆ·ç«¯ä»headeræˆ–è€…trailerä¸­è·å– metadata æ˜¯ä¸€æ ·çš„ï¼Œä½†æ˜¯åœ¨æµæ¨¡å¼ä¸­ï¼Œheaderæ˜¯å…ˆåˆ°è¾¾ï¼Œç„¶åæ¥æ”¶å¤šä¸ªstreamå†…å®¹ï¼Œæœ€åæ‰è·å–åˆ°trailerï¼Œè·å–çš„æ—¶æœºæ˜¯ä¸ä¸€æ ·çš„ï¼Œæ‰€ä»¥ grpc æä¾›äº†ä¸¤ç§æ–¹å¼è®©æˆ‘ä»¬å‘é€ metadata</p>

<p>https://blog.csdn.net/luo1324574369/article/details/115221853</p>

:ET