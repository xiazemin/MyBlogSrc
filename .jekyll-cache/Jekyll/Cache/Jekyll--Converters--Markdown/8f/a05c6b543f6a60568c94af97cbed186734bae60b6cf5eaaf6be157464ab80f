I"î8<p>package main
import (
    â€œsyncâ€
    â€œfmtâ€
)</p>

<p>func main() {
    //å¼€ç®±å³ç”¨
    var sm sync.Map
    //store æ–¹æ³•,æ·»åŠ å…ƒç´ 
    sm.Store(1,â€aâ€)
    //Load æ–¹æ³•ï¼Œè·å¾—value
    if v,ok:=sm.Load(1);ok{
        fmt.Println(v)
    }
    //LoadOrStoreæ–¹æ³•ï¼Œè·å–æˆ–è€…ä¿å­˜
    //å‚æ•°æ˜¯ä¸€å¯¹keyï¼švalueï¼Œå¦‚æœè¯¥keyå­˜åœ¨ä¸”æ²¡æœ‰è¢«æ ‡è®°åˆ é™¤åˆ™è¿”å›åŸå…ˆçš„valueï¼ˆä¸æ›´æ–°ï¼‰å’Œtrueï¼›ä¸å­˜åœ¨åˆ™storeï¼Œè¿”å›è¯¥value å’Œfalse
    if vv,ok:=sm.LoadOrStore(1,â€câ€);ok{
        fmt.Println(vv)
    }
    if vv,ok:=sm.LoadOrStore(2,â€câ€);!ok{
        fmt.Println(vv)
    }
    //éå†è¯¥mapï¼Œå‚æ•°æ˜¯ä¸ªå‡½æ•°ï¼Œè¯¥å‡½æ•°å‚çš„ä¸¤ä¸ªå‚æ•°æ˜¯éå†è·å¾—çš„keyå’Œvalueï¼Œè¿”å›ä¸€ä¸ªboolå€¼ï¼Œå½“è¿”å›falseæ—¶ï¼Œéå†ç«‹åˆ»ç»“æŸã€‚
    sm.Range(func(k,v interface{})bool{
        fmt.Print(k)
        fmt.Print(â€œ:â€)
        fmt.Print(v)
        fmt.Println()
        return true
    })
}
<!-- more -->
sync.Map æºç è§£æ
æºç ä½äºï¼šsrc\sync\map.go
é¦–å…ˆæŸ¥çœ‹ä¸€ä¸‹sync.Mapçš„æ•°æ®ç»“æ„ï¼š</p>

<p>type Map struct {
    // è¯¥é”ç”¨æ¥ä¿æŠ¤dirty
    mu Mutex
    // å­˜è¯»çš„æ•°æ®ï¼Œå› ä¸ºæ˜¯atomic.valueç±»å‹ï¼Œåªè¯»ç±»å‹ï¼Œæ‰€ä»¥å®ƒçš„è¯»æ˜¯å¹¶å‘å®‰å…¨çš„
    read atomic.Value // readOnly
    //åŒ…å«æœ€æ–°çš„å†™å…¥çš„æ•°æ®ï¼Œå¹¶ä¸”åœ¨å†™çš„æ—¶å€™ï¼Œä¼šæŠŠread ä¸­æœªè¢«åˆ é™¤çš„æ•°æ®æ‹·è´åˆ°è¯¥dirtyä¸­ï¼Œå› ä¸ºæ˜¯æ™®é€šçš„mapå­˜åœ¨å¹¶å‘å®‰å…¨é—®é¢˜ï¼Œéœ€è¦ç”¨åˆ°ä¸Šé¢çš„muå­—æ®µã€‚
    dirty map[interface{}]*entry
    // ä»readè¯»æ•°æ®çš„æ—¶å€™ï¼Œä¼šå°†è¯¥å­—æ®µ+1ï¼Œå½“ç­‰äºlenï¼ˆdirtyï¼‰çš„æ—¶å€™ï¼Œä¼šå°†dirtyæ‹·è´åˆ°readä¸­ï¼ˆä»è€Œæå‡è¯»çš„æ€§èƒ½ï¼‰ã€‚
    misses int
}
readçš„æ•°æ®ç»“æ„æ˜¯ï¼š</p>

<p>type readOnly struct {
    m  map[interface{}]*entry
    // å¦‚æœMap.dirtyçš„æ•°æ®å’Œm ä¸­çš„æ•°æ®ä¸ä¸€æ ·æ˜¯ä¸ºtrue
    amended bool 
}</p>

<p>entryçš„æ•°æ®ç»“æ„ï¼š</p>

<p>type entry struct {
    //å¯è§valueæ˜¯ä¸ªæŒ‡é’ˆç±»å‹ï¼Œè™½ç„¶readå’Œdirtyå­˜åœ¨å†—ä½™æƒ…å†µï¼ˆamended=falseï¼‰ï¼Œä½†æ˜¯ç”±äºæ˜¯æŒ‡é’ˆç±»å‹ï¼Œå­˜å‚¨çš„ç©ºé—´åº”è¯¥ä¸æ˜¯é—®é¢˜
    p unsafe.Pointer // *interface{}
}</p>

<p>Delete
é¦–å…ˆæ¥çœ‹deleteæ–¹æ³•</p>

<p>func (m *Map) Delete(key interface{}) {
    read, _ := m.read.Load().(readOnly)
    e, ok := read.m[key]
    //å¦‚æœreadä¸­æ²¡æœ‰ï¼Œå¹¶ä¸”dirtyä¸­æœ‰æ–°å…ƒç´ ï¼Œé‚£ä¹ˆå°±å»dirtyä¸­å»æ‰¾
    if !ok &amp;&amp; read.amended {
        m.mu.Lock()
        //è¿™æ˜¯åŒæ£€æŸ¥ï¼ˆä¸Šé¢çš„ifåˆ¤æ–­å’Œé”ä¸æ˜¯ä¸€ä¸ªåŸå­æ€§æ“ä½œï¼‰
        read, _ = m.read.Load().(readOnly)
        e, ok = read.m[key]
        if !ok &amp;&amp; read.amended {
            //ç›´æ¥åˆ é™¤
            delete(m.dirty, key)
        }
        m.mu.Unlock()
    }
    if ok {
    //å¦‚æœreadä¸­å­˜åœ¨è¯¥keyï¼Œåˆ™å°†è¯¥value èµ‹å€¼nilï¼ˆé‡‡ç”¨æ ‡è®°çš„æ–¹å¼åˆ é™¤ï¼ï¼‰
        e.delete()
    }
}
func (e *entry) delete() (hadValue bool) {
    for {
        p := atomic.LoadPointer(&amp;e.p)
        if p == nil || p == expunged {
            return false
        }
        if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
            return true
        }
    }
}
Store
æ–°åŠ å…ƒç´ </p>

<p>func (m *Map) Store(key, value interface{}) {
    // å¦‚æœm.readå­˜åœ¨è¿™ä¸ªkeyï¼Œå¹¶ä¸”æ²¡æœ‰è¢«æ ‡è®°åˆ é™¤ï¼Œåˆ™å°è¯•æ›´æ–°ã€‚
    read, _ := m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
        return
    }
    // å¦‚æœreadä¸å­˜åœ¨æˆ–è€…å·²ç»è¢«æ ‡è®°åˆ é™¤
    m.mu.Lock()
    read, _ = m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok {
    //å¦‚æœentryè¢«æ ‡è®°expungeï¼Œåˆ™è¡¨æ˜dirtyæ²¡æœ‰keyï¼Œå¯æ·»åŠ å…¥dirtyï¼Œå¹¶æ›´æ–°entry
        if e.unexpungeLocked() { 
            //åŠ å…¥dirtyä¸­
            m.dirty[key] = e
        }
        //æ›´æ–°valueå€¼
        e.storeLocked(&amp;value) 
        //dirty å­˜åœ¨è¯¥keyï¼Œæ›´æ–°
    } else if e, ok := m.dirty[key]; ok { 
        e.storeLocked(&amp;value)
        //read å’Œdirtyéƒ½æ²¡æœ‰ï¼Œæ–°æ·»åŠ ä¸€æ¡
    } else {
     //dirtyä¸­æ²¡æœ‰æ–°çš„æ•°æ®ï¼Œå¾€dirtyä¸­å¢åŠ ç¬¬ä¸€ä¸ªæ–°é”®
        if !read.amended { 
            //å°†readä¸­æœªåˆ é™¤çš„æ•°æ®åŠ å…¥åˆ°dirtyä¸­
            m.dirtyLocked() 
            m.read.Store(readOnly{m: read.m, amended: true})
        }
        m.dirty[key] = newEntry(value) 
    }
    m.mu.Unlock()
}</p>

<p>//å°†readä¸­æœªåˆ é™¤çš„æ•°æ®åŠ å…¥åˆ°dirtyä¸­
func (m <em>Map) dirtyLocked() {
    if m.dirty != nil {
        return
    }
    read, _ := m.read.Load().(readOnly)
    m.dirty = make(map[interface{}]</em>entry, len(read.m))
    //readå¦‚æœè¾ƒå¤§çš„è¯ï¼Œå¯èƒ½å½±å“æ€§èƒ½
    for k, e := range read.m {
    //é€šè¿‡æ­¤æ¬¡æ“ä½œï¼Œdirtyä¸­çš„å…ƒç´ éƒ½æ˜¯æœªè¢«åˆ é™¤çš„ï¼Œå¯è§expungeçš„å…ƒç´ ä¸åœ¨dirtyä¸­
        if !e.tryExpungeLocked() {
            m.dirty[k] = e
        }
    }
}
//åˆ¤æ–­entryæ˜¯å¦è¢«æ ‡è®°åˆ é™¤ï¼Œå¹¶ä¸”å°†æ ‡è®°ä¸ºnilçš„entryæ›´æ–°æ ‡è®°ä¸ºexpunge
func (e *entry) tryExpungeLocked() (isExpunged bool) {
    p := atomic.LoadPointer(&amp;e.p)
    for p == nil {
        // å°†å·²ç»åˆ é™¤æ ‡è®°ä¸ºnilçš„æ•°æ®æ ‡è®°ä¸ºexpunged
        if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
            return true
        }
        p = atomic.LoadPointer(&amp;e.p)
    }
    return p == expunged
}
//å¯¹entry å°è¯•æ›´æ–°
func (e *entry) tryStore(i *interface{}) bool {
    p := atomic.LoadPointer(&amp;e.p)
    if p == expunged {
        return false
    }
    for {
        if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) {
            return true
        }
        p = atomic.LoadPointer(&amp;e.p)
        if p == expunged {
            return false
        }
    }
}
//readé‡Œ å°†æ ‡è®°ä¸ºexpungeçš„æ›´æ–°ä¸ºnil
func (e *entry) unexpungeLocked() (wasExpunged bool) {
    return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)
}
//æ›´æ–°entry
func (e *entry) storeLocked(i *interface{}) {
    atomic.StorePointer(&amp;e.p, unsafe.Pointer(i))
}</p>

<p>å¯è§ï¼Œæ¯æ¬¡æ“ä½œå…ˆæ£€æŸ¥readï¼Œå› ä¸ºread å¹¶å‘å®‰å…¨ï¼Œæ€§èƒ½å¥½äº›ï¼›readä¸æ»¡è¶³ï¼Œåˆ™åŠ é”æ£€æŸ¥dirtyï¼Œä¸€æ—¦æ˜¯æ–°çš„é”®å€¼ï¼Œdirtyä¼šè¢«readæ›´æ–°ã€‚
Load
åŠ è½½æ–¹æ³•ï¼ŒæŸ¥æ‰¾keyã€‚</p>

<p>func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
    //å› readåªè¯»ï¼Œçº¿ç¨‹å®‰å…¨ï¼Œå…ˆæŸ¥çœ‹æ˜¯å¦æ»¡è¶³æ¡ä»¶
    read, _ := m.read.Load().(readOnly)
    e, ok := read.m[key]
    //å¦‚æœreadæ²¡æœ‰ï¼Œå¹¶ä¸”dirtyæœ‰æ–°æ•°æ®ï¼Œé‚£ä»dirtyä¸­æŸ¥æ‰¾ï¼Œç”±äºdirtyæ˜¯æ™®é€šmapï¼Œçº¿ç¨‹ä¸å®‰å…¨ï¼Œè¿™ä¸ªæ—¶å€™ç”¨åˆ°äº’æ–¥é”äº†
    if !ok &amp;&amp; read.amended {
        m.mu.Lock()
        // åŒé‡æ£€æŸ¥
        read, _ = m.read.Load().(readOnly)
        e, ok = read.m[key]
        // å¦‚æœreadä¸­è¿˜æ˜¯ä¸å­˜åœ¨ï¼Œå¹¶ä¸”dirtyä¸­æœ‰æ–°æ•°æ®
        if !ok &amp;&amp; read.amended {
            e, ok = m.dirty[key]
            // mssLockedï¼ˆï¼‰å‡½æ•°æ˜¯æ€§èƒ½æ˜¯sync.Map æ€§èƒ½å¾—ä»¥ä¿è¯çš„é‡è¦å‡½æ•°ï¼Œç›®çš„è®²æœ‰é”çš„dirtyæ•°æ®ï¼Œæ›¿æ¢åˆ°åªè¯»çº¿ç¨‹å®‰å…¨çš„readé‡Œ
            m.missLocked()
        }
        m.mu.Unlock()
    }
    if !ok {
        return nil, false
    }
    return e.load()
}
//dirty æå‡è‡³read å…³é”®å‡½æ•°ï¼Œå½“misses ç»è¿‡å¤šæ¬¡å› ä¸ºloadä¹‹åï¼Œå¤§å°ç­‰äºlenï¼ˆdirtyï¼‰æ—¶å€™ï¼Œè®²dirtyæ›¿æ¢åˆ°readé‡Œï¼Œä»¥æ­¤è¾¾åˆ°æ€§èƒ½æå‡ã€‚
func (m *Map) missLocked() {
    m.misses++
    if m.misses &lt; len(m.dirty) {
        return
    }
    //åŸå­æ“ä½œï¼Œè€—æ—¶å¾ˆå°
    m.read.Store(readOnly{m: m.dirty})
    m.dirty = nil
    m.misses = 0
}
æºç ç”¨çš„æ˜¯1.9ç‰ˆæœ¬ï¼Œé€šè¿‡é˜…è¯»æºç æˆ‘ä»¬å‘ç°sync.Mapæ˜¯é€šè¿‡å†—ä½™çš„ä¸¤ä¸ªæ•°æ®ç»“æ„(readã€dirty),å®ç°æ€§èƒ½çš„æå‡ã€‚ä¸ºäº†æå‡æ€§èƒ½ï¼Œloadã€deleteã€storeç­‰æ“ä½œå°½é‡ä½¿ç”¨åªè¯»çš„readï¼›ä¸ºäº†æé«˜readçš„keyå‡»ä¸­æ¦‚ç‡ï¼Œé‡‡ç”¨åŠ¨æ€è°ƒæ•´ï¼Œå°†dirtyæ•°æ®æå‡ä¸ºreadï¼›å¯¹äºæ•°æ®çš„åˆ é™¤ï¼Œé‡‡ç”¨å»¶è¿Ÿæ ‡è®°åˆ é™¤æ³•ï¼Œåªæœ‰åœ¨æå‡dirtyçš„æ—¶å€™æ‰åˆ é™¤</p>

<p>Goå®˜æ–¹çš„faqå·²ç»æåˆ°å†…å»ºçš„mapä¸æ˜¯çº¿ç¨‹(goroutine)å®‰å…¨çš„ã€‚åœ¨Go 1.6ä¹‹å‰ï¼Œ å†…ç½®çš„mapç±»å‹æ˜¯éƒ¨åˆ†goroutineå®‰å…¨çš„ï¼Œå¹¶å‘çš„è¯»æ²¡æœ‰é—®é¢˜ï¼Œå¹¶å‘çš„å†™å¯èƒ½æœ‰é—®é¢˜ã€‚è‡ªgo 1.6ä¹‹åï¼Œ å¹¶å‘åœ°è¯»å†™mapä¼šæŠ¥é”™ï¼Œè¿™åœ¨ä¸€äº›çŸ¥åçš„å¼€æºåº“ä¸­éƒ½å­˜åœ¨è¿™ä¸ªé—®é¢˜ï¼Œæ‰€ä»¥go 1.9ä¹‹å‰çš„è§£å†³æ–¹æ¡ˆæ˜¯é¢å¤–ç»‘å®šä¸€ä¸ªé”ï¼Œå°è£…æˆä¸€ä¸ªæ–°çš„structæˆ–è€…å•ç‹¬ä½¿ç”¨é”éƒ½å¯ä»¥ã€‚å¦å¤–ç¬”è€…åœ¨go 1.9ä¹‹å‰é€šå¸¸æ˜¯ä½¿ç”¨concurrent-mapæ¥è§£å†³è¿™ç±»é—®é¢˜ï¼Œä½†æ˜¯ä¸æ˜¯æ‰€æœ‰çš„ç¬¬ä¸‰æ–¹åº“éƒ½ä»¥æ­¤æ¥è§£å†³é—®é¢˜ã€‚</p>

<p>æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹è¿™ä¸ªä»£ç æ ·ä¾‹ï¼šç¨‹åºä¸­ä¸€ä¸ªgoroutineä¸€ç›´è¯»ï¼Œä¸€ä¸ªgoroutineä¸€ç›´å†™åŒä¸€ä¸ªé”®å€¼ï¼Œå³ä½¿è¯»å†™çš„é”®ä¸ç›¸åŒï¼Œè€Œä¸”mapä¹Ÿæ²¡æœ‰â€æ‰©å®¹â€ç­‰æ“ä½œï¼Œä»£ç è¿˜æ˜¯ä¼šæŠ¥é”™çš„ï¼Œé”™è¯¯ä¿¡æ¯æ˜¯: fatal error: concurrent map read and map writeã€‚ã€‚</p>

<p>package main
func main() {
	m := make(map[int]int)
	go func() {
		for {
			_ = m[1]
		}
	}()
	go func() {
		for {
			m[2] = 2
		}
	}()
	select {}
}
é—®é¢˜çš„æ ¹æºåœ¨Goçš„æºä»£ç : hashmap_fast.go#L118,ä¼šçœ‹åˆ°è¯»çš„æ—¶å€™ä¼šæ£€æŸ¥hashWritingæ ‡å¿—ï¼Œ å¦‚æœæœ‰è¿™ä¸ªæ ‡å¿—ï¼Œå°±ä¼šæŠ¥å¹¶å‘é”™è¯¯ã€‚</p>

<p>å†™çš„æ—¶å€™ä¼šè®¾ç½®è¿™ä¸ªæ ‡å¿—: hashmap.go#L542</p>

<p>h.flags |= hashWriting
hashmap.go#L628è®¾ç½®å®Œä¹‹åä¼šå–æ¶ˆè¿™ä¸ªæ ‡è®°ã€‚è¿™æ ·å¹¶å‘è¯»å†™çš„æ£€æŸ¥æœ‰å¾ˆå¤šå¤„ï¼Œ æ¯”å¦‚å†™çš„æ—¶å€™ä¹Ÿä¼šæ£€æŸ¥æ˜¯ä¸æ˜¯æœ‰å¹¶å‘çš„å†™ï¼Œåˆ é™¤é”®çš„æ—¶å€™ç±»ä¼¼å†™ï¼Œéå†çš„æ—¶å€™å¹¶å‘è¯»å†™é—®é¢˜ç­‰ã€‚mapçš„å¹¶å‘é—®é¢˜å¹¶ä¸æ˜¯é‚£ä¹ˆå®¹æ˜“è¢«å‘ç°, ä½ å¯ä»¥åˆ©ç”¨-raceå‚æ•°æ¥æ£€æŸ¥ã€‚</p>

<p>å¹¶å‘åœ°ä½¿ç”¨mapå¯¹è±¡æ˜¯æˆ‘ä»¬æ—¥å¸¸å¼€å‘ä¸­ä¸€ä¸ªå¾ˆå¸¸è§çš„éœ€æ±‚ï¼Œç‰¹åˆ«æ˜¯åœ¨ä¸€äº›å¤§é¡¹ç›®ä¸­ã€‚mapæ€»ä¼šä¿å­˜goroutineå…±äº«çš„æ•°æ®ã€‚Go 1.9ä¹‹å‰åœ¨Goå®˜æ–¹blogçš„Go maps in actionä¸€æ–‡ä¸­ï¼Œç»™å‡ºäº†ä¸€ç§ç®€ä¾¿çš„è§£å†³æ–¹æ¡ˆã€‚</p>

<p>é¦–å…ˆï¼Œé€šè¿‡åµŒå…¥structä¸ºmapå¢åŠ ä¸€ä¸ªè¯»å†™é”</p>

<p>var counter = struct{
    sync.RWMutex
    m map[string]int
}{m: make(map[string]int)}</p>

<p>è¯»å†™æ•°æ®æ—¶ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿çš„åŠ é”</p>

<p>counter.RLock()
n := counter.m[â€œsome_keyâ€]
counter.RUnlock()
fmt.Println(â€œsome_key:â€, n)</p>

<p>counter.Lock()
counter.m[â€œsome_keyâ€]++
counter.Unlock()
å½“ç„¶ï¼Œä½ ä¹Ÿå¯ä»¥ä½¿ç”¨concurrent-mapæ¥è§£å†³é—®é¢˜</p>

<p>// Create a new map.
map := cmap.New()</p>

<p>// Sets item within map, sets â€œbarâ€ under key â€œfooâ€
map.Set(â€œfooâ€, â€œbarâ€)</p>

<p>// Retrieve item from map.
if tmp, ok := map.Get(â€œfooâ€); ok {
	bar := tmp.(string)
}</p>

<p>// Removes item under key â€œfooâ€
map.Remove(â€œfooâ€)
ä¸¤è€…æœ¬è´¨ä¸Šéƒ½æ˜¯ä½¿ç”¨sync.RWMutexæ¥ä¿éšœçº¿ç¨‹(goroutine)å®‰å…¨çš„ã€‚è¿™ç§è§£å†³æ–¹æ¡ˆç›¸å½“ç®€æ´ï¼Œå¹¶ä¸”åˆ©ç”¨è¯»å†™é”è€Œä¸æ˜¯Mutexå¯ä»¥è¿›ä¸€æ­¥å‡å°‘è¯»å†™çš„æ—¶å€™å› ä¸ºé”å¸¦æ¥çš„æ€§èƒ½ã€‚ä½†åœ¨mapçš„æ•°æ®éå¸¸å¤§çš„æƒ…å†µä¸‹ï¼Œä¸€æŠŠé”ä¼šå¯¼è‡´å¤§å¹¶å‘çš„å®¢æˆ·ç«¯å…±äº‰ä¸€æŠŠé”ï¼Œè¿™æ—¶ï¼Œåœ¨Go 1.9ä¸­sync.Mapå°±éå¸¸å®ç”¨ã€‚ï¼ˆé™¤äº†ä»¥ä¸Šè¿™äº›ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªç¬”è€…æƒ³æåˆ°çš„åº“ï¼Œcmapä¹Ÿæ˜¯ä¸€ä¸ªç›¸å½“å¥½ï¼Œå®‰å…¨ä¸”æ€§èƒ½å‡ºè‰²çš„ç¬¬ä¸‰æ–¹åº“ï¼‰</p>

<p>Go 1.9ä¸­sync.Mapçš„å®ç°æœ‰ä»¥ä¸‹ä¼˜åŒ–ç‚¹ï¼š</p>

<p>ç©ºé—´æ¢æ—¶é—´ã€‚ é€šè¿‡å†—ä½™çš„ä¸¤ä¸ªæ•°æ®ç»“æ„(readã€dirty),å®ç°åŠ é”å¯¹æ€§èƒ½çš„å½±å“ã€‚
ä½¿ç”¨åªè¯»æ•°æ®(read)ï¼Œé¿å…è¯»å†™å†²çªã€‚
åŠ¨æ€è°ƒæ•´ï¼Œmissæ¬¡æ•°å¤šäº†ä¹‹åï¼Œå°†dirtyæ•°æ®æå‡ä¸ºreadã€‚
double-checkingã€‚
å»¶è¿Ÿåˆ é™¤ã€‚ åˆ é™¤ä¸€ä¸ªé”®å€¼åªæ˜¯æ‰“æ ‡è®°ï¼Œåªæœ‰åœ¨æå‡dirtyçš„æ—¶å€™æ‰æ¸…ç†åˆ é™¤çš„æ•°æ®ã€‚
ä¼˜å…ˆä»readè¯»å–ã€æ›´æ–°ã€åˆ é™¤ï¼Œå› ä¸ºå¯¹readçš„è¯»å–ä¸éœ€è¦é”ã€‚
sync.Mapæ•°æ®ç»“æ„å¾ˆç®€å•ï¼ŒåŒ…å«å››ä¸ªå­—æ®µï¼šreadã€muã€dirtyã€missesã€‚</p>

<p>type Map struct {
	// å½“æ¶‰åŠåˆ°dirtyæ•°æ®çš„æ“ä½œçš„æ—¶å€™ï¼Œéœ€è¦ä½¿ç”¨æ­¤é”
	mu Mutex
	// ä¸€ä¸ªåªè¯»çš„æ•°æ®ç»“æ„ï¼Œå› ä¸ºåªè¯»ï¼Œæ‰€ä»¥ä¸ä¼šæœ‰è¯»å†™å†²çªã€‚
	// æ‰€ä»¥ä»è¿™ä¸ªæ•°æ®ä¸­è¯»å–æ€»æ˜¯å®‰å…¨çš„ã€‚
	// å®é™…ä¸Šï¼Œå®é™…ä¹Ÿä¼šæ›´æ–°è¿™ä¸ªæ•°æ®çš„entries,å¦‚æœentryæ˜¯æœªåˆ é™¤çš„(unexpunged), å¹¶ä¸éœ€è¦åŠ é”ã€‚å¦‚æœentryå·²ç»è¢«åˆ é™¤äº†ï¼Œéœ€è¦åŠ é”ï¼Œä»¥ä¾¿æ›´æ–°dirtyæ•°æ®ã€‚
	read atomic.Value // readOnly
	// dirtyæ•°æ®åŒ…å«å½“å‰çš„mapåŒ…å«çš„entries,å®ƒåŒ…å«æœ€æ–°çš„entries(åŒ…æ‹¬readä¸­æœªåˆ é™¤çš„æ•°æ®,è™½æœ‰å†—ä½™ï¼Œä½†æ˜¯æå‡dirtyå­—æ®µä¸ºreadçš„æ—¶å€™éå¸¸å¿«ï¼Œä¸ç”¨ä¸€ä¸ªä¸€ä¸ªçš„å¤åˆ¶ï¼Œè€Œæ˜¯ç›´æ¥å°†è¿™ä¸ªæ•°æ®ç»“æ„ä½œä¸ºreadå­—æ®µçš„ä¸€éƒ¨åˆ†),æœ‰äº›æ•°æ®è¿˜å¯èƒ½æ²¡æœ‰ç§»åŠ¨åˆ°readå­—æ®µä¸­ã€‚
	// å¯¹äºdirtyçš„æ“ä½œéœ€è¦åŠ é”ï¼Œå› ä¸ºå¯¹å®ƒçš„æ“ä½œå¯èƒ½ä¼šæœ‰è¯»å†™ç«äº‰ã€‚
	// å½“dirtyä¸ºç©ºçš„æ—¶å€™ï¼Œ æ¯”å¦‚åˆå§‹åŒ–æˆ–è€…åˆšæå‡å®Œï¼Œä¸‹ä¸€æ¬¡çš„å†™æ“ä½œä¼šå¤åˆ¶readå­—æ®µä¸­æœªåˆ é™¤çš„æ•°æ®åˆ°è¿™ä¸ªæ•°æ®ä¸­ã€‚
	dirty map[interface{}]*entry
	// å½“ä»Mapä¸­è¯»å–entryçš„æ—¶å€™ï¼Œå¦‚æœreadä¸­ä¸åŒ…å«è¿™ä¸ªentry,ä¼šå°è¯•ä»dirtyä¸­è¯»å–ï¼Œè¿™ä¸ªæ—¶å€™ä¼šå°†missesåŠ ä¸€ï¼Œ
	// å½“missesç´¯ç§¯åˆ° dirtyçš„é•¿åº¦çš„æ—¶å€™ï¼Œ å°±ä¼šå°†dirtyæå‡ä¸ºread,é¿å…ä»dirtyä¸­misså¤ªå¤šæ¬¡ã€‚å› ä¸ºæ“ä½œdirtyéœ€è¦åŠ é”ã€‚
	misses int
}</p>

<p>readçš„æ•°æ®ç»“æ„</p>

<p>type readOnly struct {
	m       map[interface{}]<em>entry
	amended bool // å¦‚æœMap.dirtyæœ‰äº›æ•°æ®ä¸åœ¨å…¶ä¸­çš„æ—¶å€™ï¼Œè¿™ä¸ªå€¼ä¸ºtrue
}
è¿™é‡Œçš„ç²¾é«“æ˜¯ï¼Œä½¿ç”¨äº†å†—ä½™çš„æ•°æ®ç»“æ„readã€dirtyã€‚dirtyä¸­ä¼šåŒ…å«readä¸­æœªåˆ é™¤çš„entriesï¼Œæ–°å¢åŠ çš„entriesä¼šåŠ å…¥åˆ°dirtyä¸­ã€‚amendedæŒ‡æ˜Map.dirtyä¸­æœ‰readOnly.mæœªåŒ…å«çš„æ•°æ®ï¼Œæ‰€ä»¥å¦‚æœä»Map.readæ‰¾ä¸åˆ°æ•°æ®çš„è¯ï¼Œè¿˜è¦è¿›ä¸€æ­¥åˆ°Map.dirtyä¸­æŸ¥æ‰¾ã€‚è€Œå¯¹Map.readçš„ä¿®æ”¹æ˜¯é€šè¿‡åŸå­æ“ä½œè¿›è¡Œçš„ã€‚è™½ç„¶readå’Œdirtyæœ‰å†—ä½™æ•°æ®ï¼Œä½†è¿™äº›æ•°æ®æ˜¯é€šè¿‡æŒ‡é’ˆæŒ‡å‘åŒä¸€ä¸ªæ•°æ®ï¼Œæ‰€ä»¥å°½ç®¡Mapçš„valueä¼šå¾ˆå¤§ï¼Œä½†æ˜¯å†—ä½™çš„ç©ºé—´å ç”¨è¿˜æ˜¯æœ‰é™çš„ã€‚readOnly.må’ŒMap.dirtyå­˜å‚¨çš„å€¼ç±»å‹æ˜¯</em>entry,å®ƒåŒ…å«ä¸€ä¸ªæŒ‡é’ˆp, æŒ‡å‘ç”¨æˆ·å­˜å‚¨çš„valueå€¼ã€‚</p>

<p>type entry struct {
	p unsafe.Pointer // *interface{}
}
pæœ‰ä¸‰ç§å€¼ï¼š</p>

<p>nil: entryå·²è¢«åˆ é™¤äº†ï¼Œå¹¶ä¸”m.dirtyä¸ºnil
expunged: entryå·²è¢«åˆ é™¤äº†ï¼Œå¹¶ä¸”m.dirtyä¸ä¸ºnilï¼Œè€Œä¸”è¿™ä¸ªentryä¸å­˜åœ¨äºm.dirtyä¸­
å…¶å®ƒï¼š entryæ˜¯ä¸€ä¸ªæ­£å¸¸çš„å€¼
ç†è§£äº†sync.Mapçš„æ•°æ®ç»“æ„ï¼Œé‚£ä¹ˆæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹sync.Mapçš„Loadæ–¹æ³•å®ç°</p>

<p>func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
	// 1.é¦–å…ˆä»m.readä¸­å¾—åˆ°åªè¯»readOnly,ä»å®ƒçš„mapä¸­æŸ¥æ‰¾ï¼Œä¸éœ€è¦åŠ é”
	read, _ := m.read.Load().(readOnly)
	e, ok := read.m[key]
	// 2. å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå¹¶ä¸”m.dirtyä¸­æœ‰æ–°æ•°æ®ï¼Œéœ€è¦ä»m.dirtyæŸ¥æ‰¾ï¼Œè¿™ä¸ªæ—¶å€™éœ€è¦åŠ é”
	if !ok &amp;&amp; read.amended {
		m.mu.Lock()
		// åŒæ£€æŸ¥ï¼Œé¿å…åŠ é”çš„æ—¶å€™m.dirtyæå‡ä¸ºm.read,è¿™ä¸ªæ—¶å€™m.readå¯èƒ½è¢«æ›¿æ¢äº†ã€‚
		read, _ = m.read.Load().(readOnly)
		e, ok = read.m[key]
		// å¦‚æœm.readä¸­è¿˜æ˜¯ä¸å­˜åœ¨ï¼Œå¹¶ä¸”m.dirtyä¸­æœ‰æ–°æ•°æ®
		if !ok &amp;&amp; read.amended {
			// ä»m.dirtyæŸ¥æ‰¾
			e, ok = m.dirty[key]
			// ä¸ç®¡m.dirtyä¸­å­˜ä¸å­˜åœ¨ï¼Œéƒ½å°†missesè®¡æ•°åŠ ä¸€
			// missLocked()ä¸­æ»¡è¶³æ¡ä»¶åå°±ä¼šæå‡m.dirty
			m.missLocked()
		}
		m.mu.Unlock()
	}
	if !ok {
		return nil, false
	}
	return e.load()
}
LoadåŠ è½½æ–¹æ³•ï¼Œæä¾›ä¸€ä¸ªé”®key,æŸ¥æ‰¾å¯¹åº”çš„å€¼value,å¦‚æœä¸å­˜åœ¨ï¼Œé€šè¿‡okåæ˜ ã€‚è¿™é‡Œçš„ç²¾é«“æ˜¯ä»m.readä¸­åŠ è½½ï¼Œä¸å­˜åœ¨çš„æƒ…å†µä¸‹ï¼Œå¹¶ä¸”m.dirtyä¸­æœ‰æ–°æ•°æ®ï¼ŒåŠ é”ï¼Œç„¶åä»m.dirtyä¸­åŠ è½½ã€‚å¦å¤–ä¸€ç‚¹æ˜¯è¿™é‡Œä½¿ç”¨äº†åŒæ£€æŸ¥çš„å¤„ç†ï¼Œå› ä¸ºåœ¨ä¸‹é¢çš„ä¸¤ä¸ªè¯­å¥ä¸­ï¼Œè¿™ä¸¤è¡Œè¯­å¥å¹¶ä¸æ˜¯ä¸€ä¸ªåŸå­æ“ä½œã€‚</p>

<p>if !ok &amp;&amp; read.amended {
		m.mu.Lock()</p>

<p>è™½ç„¶ç¬¬ä¸€å¥æ‰§è¡Œçš„æ—¶å€™æ¡ä»¶æ»¡è¶³ï¼Œä½†æ˜¯åœ¨åŠ é”ä¹‹å‰ï¼Œm.dirtyå¯èƒ½è¢«æå‡ä¸ºm.read,æ‰€ä»¥åŠ é”åè¿˜å¾—å†æ£€æŸ¥m.readï¼Œåç»­çš„æ–¹æ³•ä¸­éƒ½ä½¿ç”¨äº†è¿™ä¸ªæ–¹æ³•ã€‚å¦‚æœæˆ‘ä»¬æŸ¥è¯¢çš„é”®å€¼æ­£å¥½å­˜åœ¨äºm.readä¸­ï¼Œåˆ™æ— é¡»åŠ é”ï¼Œç›´æ¥è¿”å›ï¼Œç†è®ºä¸Šæ€§èƒ½ä¼˜å¼‚ã€‚å³ä½¿ä¸å­˜åœ¨äºm.readä¸­ï¼Œç»è¿‡misså‡ æ¬¡ä¹‹åï¼Œm.dirtyä¼šè¢«æå‡ä¸ºm.readï¼Œåˆä¼šä»m.readä¸­æŸ¥æ‰¾ã€‚æ‰€ä»¥å¯¹äºæ›´æ–°ï¼å¢åŠ è¾ƒå°‘ï¼ŒåŠ è½½å­˜åœ¨çš„keyå¾ˆå¤šçš„åœºæ™¯,æ€§èƒ½åŸºæœ¬å’Œæ— é”çš„mapç›¸å·®æ— å‡ ã€‚</p>

<p>ç»è¿‡misså‡ æ¬¡ä¹‹åï¼Œm.dirtyä¼šè¢«æå‡ä¸ºm.readï¼Œé‚£ä¹ˆm.dirtyåˆæ˜¯å¦‚ä½•è¢«æå‡çš„å‘¢ï¼Ÿé‡ç‚¹åœ¨missLockedæ–¹æ³•ä¸­ã€‚</p>

<p>func (m *Map) missLocked() {
	m.misses++
	if m.misses &lt; len(m.dirty) {
		return
	}
	m.read.Store(readOnly{m: m.dirty})
	m.dirty = nil
	m.misses = 0
}
æœ€åä¸‰è¡Œä»£ç å°±æ˜¯æå‡m.dirtyçš„ï¼Œå¾ˆç®€å•çš„å°†m.dirtyä½œä¸ºreadOnlyçš„må­—æ®µï¼ŒåŸå­æ›´æ–°m.readã€‚æå‡åm.dirtyã€m.missesé‡ç½®ï¼Œ å¹¶ä¸”m.read.amendedä¸ºfalseã€‚</p>

<p>sync.Mapçš„Storeæ–¹æ³•å®ç°</p>

<p>func (m *Map) Store(key, value interface{}) {
	// å¦‚æœm.readå­˜åœ¨è¿™ä¸ªé”®ï¼Œå¹¶ä¸”è¿™ä¸ªentryæ²¡æœ‰è¢«æ ‡è®°åˆ é™¤ï¼Œå°è¯•ç›´æ¥å­˜å‚¨ã€‚
	// å› ä¸ºm.dirtyä¹ŸæŒ‡å‘è¿™ä¸ªentry,æ‰€ä»¥m.dirtyä¹Ÿä¿æŒæœ€æ–°çš„entryã€‚
	read, _ := m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
		return
	}
	// å¦‚æœ<code class="language-plaintext highlighter-rouge">m.read</code>ä¸å­˜åœ¨æˆ–è€…å·²ç»è¢«æ ‡è®°åˆ é™¤
	m.mu.Lock()
	read, _ = m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok {
		if e.unexpungeLocked() { //æ ‡è®°æˆæœªè¢«åˆ é™¤
			m.dirty[key] = e //m.dirtyä¸­ä¸å­˜åœ¨è¿™ä¸ªé”®ï¼Œæ‰€ä»¥åŠ å…¥m.dirty
		}
		e.storeLocked(&amp;value) //æ›´æ–°
	} else if e, ok := m.dirty[key]; ok { // m.dirtyå­˜åœ¨è¿™ä¸ªé”®ï¼Œæ›´æ–°
		e.storeLocked(&amp;value)
	} else { //æ–°é”®å€¼
		if !read.amended { //m.dirtyä¸­æ²¡æœ‰æ–°çš„æ•°æ®ï¼Œå¾€m.dirtyä¸­å¢åŠ ç¬¬ä¸€ä¸ªæ–°é”®
			m.dirtyLocked() //ä»m.readä¸­å¤åˆ¶æœªåˆ é™¤çš„æ•°æ®
			m.read.Store(readOnly{m: read.m, amended: true})
		}
		m.dirty[key] = newEntry(value) //å°†è¿™ä¸ªentryåŠ å…¥åˆ°m.dirtyä¸­
	}
	m.mu.Unlock()
}</p>

<p>func (m <em>Map) dirtyLocked() {
	if m.dirty != nil {
		return
	}
	read, _ := m.read.Load().(readOnly)
	m.dirty = make(map[interface{}]</em>entry, len(read.m))
	for k, e := range read.m {
		if !e.tryExpungeLocked() {
			m.dirty[k] = e
		}
	}
}</p>

<p>func (e *entry) tryExpungeLocked() (isExpunged bool) {
	p := atomic.LoadPointer(&amp;e.p)
	for p == nil {
		// å°†å·²ç»åˆ é™¤æ ‡è®°ä¸ºnilçš„æ•°æ®æ ‡è®°ä¸ºexpunged
		if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
			return true
		}
		p = atomic.LoadPointer(&amp;e.p)
	}
	return p == expunged
}
Storeæ–¹æ³•æ˜¯æ›´æ–°æˆ–è€…æ–°å¢ä¸€ä¸ªentryã€‚ä»¥ä¸Šæ“ä½œéƒ½æ˜¯å…ˆä»æ“ä½œm.readå¼€å§‹çš„ï¼Œä¸æ»¡è¶³æ¡ä»¶å†åŠ é”ï¼Œç„¶åæ“ä½œm.dirtyã€‚Storeå¯èƒ½ä¼šåœ¨æŸç§æƒ…å†µä¸‹(åˆå§‹åŒ–æˆ–è€…m.dirtyåˆšè¢«æå‡å)ä»m.readä¸­å¤åˆ¶æ•°æ®ï¼Œå¦‚æœè¿™ä¸ªæ—¶å€™m.readä¸­æ•°æ®é‡éå¸¸å¤§ï¼Œå¯èƒ½ä¼šå½±å“æ€§èƒ½ã€‚</p>

<p>sync.Mapçš„Deleteæ–¹æ³•å®ç°</p>

<p>func (m *Map) Delete(key interface{}) {
	read, _ := m.read.Load().(readOnly)
	e, ok := read.m[key]
	if !ok &amp;&amp; read.amended {
		m.mu.Lock()
		read, _ = m.read.Load().(readOnly)
		e, ok = read.m[key]
		if !ok &amp;&amp; read.amended {
			delete(m.dirty, key)
		}
		m.mu.Unlock()
	}
	if ok {
		e.delete()
	}
}</p>

<p>func (e *entry) delete() (hadValue bool) {
	for {
		p := atomic.LoadPointer(&amp;e.p)
		// å·²æ ‡è®°ä¸ºåˆ é™¤
		if p == nil || p == expunged {
			return false
		}
		// åŸå­æ“ä½œï¼Œe.pæ ‡è®°ä¸ºnil
		if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
			return true
		}
	}
}
Deleteæ–¹æ³•åˆ é™¤ä¸€ä¸ªé”®å€¼ã€‚å’ŒStoreæ–¹æ³•ä¸€æ ·ï¼Œåˆ é™¤æ“ä½œè¿˜æ˜¯ä»m.readä¸­å¼€å§‹ï¼Œ å¦‚æœè¿™ä¸ªentryä¸å­˜åœ¨äºm.readä¸­ï¼Œå¹¶ä¸”m.dirtyä¸­æœ‰æ–°æ•°æ®ï¼Œåˆ™åŠ é”å°è¯•ä»m.dirtyä¸­åˆ é™¤ã€‚æ³¨æ„ï¼Œè¿˜æ˜¯è¦åŒæ£€æŸ¥çš„ã€‚ ä»m.dirtyä¸­ç›´æ¥åˆ é™¤å³å¯ï¼Œå°±å½“å®ƒæ²¡å­˜åœ¨è¿‡ï¼Œä½†æ˜¯å¦‚æœæ˜¯ä»m.readä¸­åˆ é™¤ï¼Œå¹¶ä¸ä¼šç›´æ¥åˆ é™¤ï¼Œè€Œæ˜¯æ‰“æ ‡è®°è€Œå·²ã€‚</p>

<p>sync.Mapçš„Rangeæ–¹æ³•å®ç°</p>

<p>func (m *Map) Range(f func(key, value interface{}) bool) {
	read, _ := m.read.Load().(readOnly)
	// å¦‚æœm.dirtyä¸­æœ‰æ–°æ•°æ®ï¼Œåˆ™æå‡m.dirty,ç„¶ååœ¨éå†
	if read.amended {
		//æå‡m.dirty
		m.mu.Lock()
		read, _ = m.read.Load().(readOnly) //åŒæ£€æŸ¥
		if read.amended {
			read = readOnly{m: m.dirty}
			m.read.Store(read)
			m.dirty = nil
			m.misses = 0
		}
		m.mu.Unlock()
	}
	// éå†, for rangeæ˜¯å®‰å…¨çš„
	for k, e := range read.m {
		v, ok := e.load()
		if !ok {
			continue
		}
		if !f(k, v) {
			break
		}
	}
}
åœ¨Goè¯­è¨€ä¸­ï¼Œfor â€¦ range mapæ˜¯å†…å»ºçš„è¯­è¨€ç‰¹æ€§ï¼Œæ‰€ä»¥æ²¡æœ‰åŠæ³•ä½¿ç”¨for rangeéå†sync.Map, äºæ˜¯å˜é€šçš„æœ‰äº†Rangeæ–¹æ³•ï¼Œé€šè¿‡å›è°ƒçš„æ–¹å¼éå†ã€‚Rangeæ–¹æ³•è°ƒç”¨å‰å¯èƒ½ä¼šåšä¸€ä¸ªm.dirtyçš„æå‡ï¼Œä¸è¿‡æå‡m.dirtyä¸æ˜¯ä¸€ä¸ªè€—æ—¶çš„æ“ä½œã€‚</p>

<p>sync.Mapçš„LoadOrStore æ–¹æ³•å®ç°</p>

<p>func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) {
	read, _ := m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok {
		actual, loaded, ok := e.tryLoadOrStore(value)
		if ok {
			return actual, loaded
		}
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m.mu.Lock()
read, _ = m.read.Load().(readOnly)
if e, ok := read.m[key]; ok {
	if e.unexpungeLocked() {
		m.dirty[key] = e
	}
	actual, loaded, _ = e.tryLoadOrStore(value)
} else if e, ok := m.dirty[key]; ok {
	actual, loaded, _ = e.tryLoadOrStore(value)
	m.missLocked()
} else {
	if !read.amended {
		// ç»™dirtyæ·»åŠ ä¸€ä¸ªæ–°keyï¼Œ
		// æ ‡è®°åªè¯»ä¸ºä¸å®Œæ•´
		m.dirtyLocked()
		m.read.Store(readOnly{m: read.m, amended: true})
	}
	m.dirty[key] = newEntry(value)
	actual, loaded = value, false
}
m.mu.Unlock()

return actual, loaded }
</code></pre></div></div>

<p>func (e <em>entry) tryLoadOrStore(i interface{}) (actual interface{}, loaded, ok bool) {
	p := atomic.LoadPointer(&amp;e.p)
	if p == expunged {
		return nil, false, false
	}
	if p != nil {
		return *(</em>interface{})(p), true, true
	}
	ic := i
	for {
		if atomic.CompareAndSwapPointer(&amp;e.p, nil, unsafe.Pointer(&amp;ic)) {
			return i, false, true
		}
		p = atomic.LoadPointer(&amp;e.p)
		if p == expunged {
			return nil, false, false
		}
		if p != nil {
			return <em>(</em>interface{})(p), true, true
		}
	}
}
LoadOrStoreæ–¹æ³•å¦‚æœæä¾›çš„keyå­˜åœ¨ï¼Œåˆ™è¿”å›å·²å­˜åœ¨çš„å€¼(Load)ï¼Œå¦åˆ™ä¿å­˜æä¾›çš„é”®å€¼(Store)ã€‚åŒæ ·æ˜¯ä»m.readå¼€å§‹ï¼Œç„¶åæ˜¯m.dirtyï¼Œæœ€åè¿˜æœ‰åŒæ£€æŸ¥æœºåˆ¶ã€‚</p>

<p>Go 1.9æºä»£ç ä¸­æä¾›äº†æ€§èƒ½çš„æµ‹è¯•ï¼š map_bench_test.goã€map_reference_test.goï¼Œå’Œä»¥å‰çš„è§£å†³æ–¹æ¡ˆæ¯”è¾ƒï¼Œæ€§èƒ½ä¼šæœ‰ä¸å°‘çš„æå‡ã€‚</p>

<p>æœ€åsync.Mapæ²¡æœ‰Lenæ–¹æ³•ï¼Œå¹¶ä¸”ç›®å‰æ²¡æœ‰è¿¹è±¡è¦åŠ ä¸Š (issue#20680),æ‰€ä»¥å¦‚æœæƒ³å¾—åˆ°å½“å‰Mapä¸­æœ‰æ•ˆçš„entriesçš„æ•°é‡ï¼Œéœ€è¦ä½¿ç”¨Rangeæ–¹æ³•éå†ä¸€æ¬¡ã€‚</p>

<p>https://github.com/orcaman/concurrent-map
ä¼—æ‰€å‘¨çŸ¥,goæ™®é€šçš„mapæ˜¯ä¸æ”¯æŒå¹¶å‘çš„ï¼Œæ¢è€Œè¨€ä¹‹,ä¸æ˜¯çº¿ç¨‹(goroutine)å®‰å…¨çš„ã€‚åšä¸»æ˜¯ä»golang 1.4å¼€å§‹ä½¿ç”¨çš„ï¼Œé‚£æ—¶å€™mapçš„å¹¶å‘è¯»æ˜¯æ²¡æœ‰æ”¯æŒï¼Œä½†æ˜¯å¹¶å‘å†™ä¼šå‡ºç°è„æ•°æ®ã€‚golang 1.6ä¹‹åï¼Œå¹¶å‘åœ°è¯»å†™ä¼šç›´æ¥panicï¼š
fatal error: concurrent map read and map write
å¤åˆ¶ä»£ç package main
func main() {
	m := make(map[int]int)
	go func() {
		for {
			_ = m[1]
		}
	}()
	go func() {
		for {
			m[2] = 2
		}
	}()
	select {}
}
å¤åˆ¶ä»£ç æ‰€ä»¥éœ€è¦æ”¯æŒå¯¹mapçš„å¹¶å‘è¯»å†™æ—¶å€™ï¼Œåšä¸»ä½¿ç”¨ä¸¤ç§æ–¹æ³•ï¼š</p>

<p>ç¬¬ä¸‰æ–¹ç±»åº“ concurrent-mapã€‚
mapåŠ ä¸Šsync.RWMutexæ¥ä¿éšœçº¿ç¨‹(goroutine)å®‰å…¨çš„ã€‚</p>

<p>golang 1.9ä¹‹å,go åœ¨syncåŒ…ä¸‹å¼•å…¥äº†å¹¶å‘å®‰å…¨çš„mapï¼Œä¹Ÿä¸ºåšä¸»æä¾›äº†ç¬¬ä¸‰ç§æ–¹æ³•ã€‚æœ¬æ–‡é‡ç‚¹ä¹Ÿåœ¨æ­¤ï¼Œä¸ºäº†æ—¶æ•ˆæ€§ï¼Œæœ¬æ–‡åŸºäºgolang 1.10æºç è¿›è¡Œåˆ†æã€‚
sync.Map
ç»“æ„ä½“
Map
type Map struct {
	mu Mutex    //äº’æ–¥é”ï¼Œç”¨äºé”å®šdirty map</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read atomic.Value //ä¼˜å…ˆè¯»map,æ”¯æŒåŸå­æ“ä½œï¼Œæ³¨é‡Šä¸­æœ‰readOnlyä¸æ˜¯è¯´readæ˜¯åªè¯»ï¼Œè€Œæ˜¯å®ƒçš„ç»“æ„ä½“ã€‚readå®é™…ä¸Šæœ‰å†™çš„æ“ä½œ

dirty map[interface{}]*entry // dirtyæ˜¯ä¸€ä¸ªå½“å‰æœ€æ–°çš„mapï¼Œå…è®¸è¯»å†™

misses int // ä¸»è¦è®°å½•readè¯»å–ä¸åˆ°æ•°æ®åŠ é”è¯»å–read mapä»¥åŠdirty mapçš„æ¬¡æ•°ï¼Œå½“missesç­‰äºdirtyçš„é•¿åº¦æ—¶ï¼Œä¼šå°†dirtyå¤åˆ¶åˆ°read } å¤åˆ¶ä»£ç readOnly readOnly ä¸»è¦ç”¨äºå­˜å‚¨ï¼Œé€šè¿‡åŸå­æ“ä½œå­˜å‚¨åœ¨Map.readä¸­å…ƒç´ ã€‚ type readOnly struct {
m       map[interface{}]*entry
amended bool // å¦‚æœæ•°æ®åœ¨dirtyä¸­ä½†æ²¡æœ‰åœ¨readä¸­ï¼Œè¯¥å€¼ä¸ºtrue,ä½œä¸ºä¿®æ”¹æ ‡è¯† } å¤åˆ¶ä»£ç entry type entry struct {
// nil: è¡¨ç¤ºä¸ºè¢«åˆ é™¤ï¼Œè°ƒç”¨Delete()å¯ä»¥å°†read mapä¸­çš„å…ƒç´ ç½®ä¸ºnil
// expunged: ä¹Ÿæ˜¯è¡¨ç¤ºè¢«åˆ é™¤ï¼Œä½†æ˜¯è¯¥é”®åªåœ¨readè€Œæ²¡æœ‰åœ¨dirtyä¸­ï¼Œè¿™ç§æƒ…å†µå‡ºç°åœ¨å°†readå¤åˆ¶åˆ°dirtyä¸­ï¼Œå³å¤åˆ¶çš„è¿‡ç¨‹ä¼šå…ˆå°†nilæ ‡è®°ä¸ºexpungedï¼Œç„¶åä¸å°†å…¶å¤åˆ¶åˆ°dirty
//  å…¶ä»–: è¡¨ç¤ºå­˜ç€çœŸæ­£çš„æ•°æ®
p unsafe.Pointer // *interface{} } å¤åˆ¶ä»£ç åŸç† å¦‚æœä½ æ¥è§¦è¿‡å¤§Javaï¼Œé‚£ä½ ä¸€å®šå¯¹CocurrentHashMapåˆ©ç”¨é”åˆ†æ®µæŠ€æœ¯å¢åŠ äº†é”çš„æ•°ç›®ï¼Œä»è€Œä½¿äº‰å¤ºåŒä¸€æŠŠé”çš„çº¿ç¨‹çš„æ•°ç›®å¾—åˆ°æ§åˆ¶çš„åŸç†è®°å¿†æ·±åˆ»ã€‚ é‚£ä¹ˆGolangçš„sync.Mapæ˜¯å¦ä¹Ÿæ˜¯ä½¿ç”¨äº†ç›¸åŒçš„åŸç†å‘¢ï¼Ÿsync.Mapçš„åŸç†å¾ˆç®€å•ï¼Œä½¿ç”¨äº†ç©ºé—´æ¢æ—¶é—´ç­–ç•¥ï¼Œé€šè¿‡å†—ä½™çš„ä¸¤ä¸ªæ•°æ®ç»“æ„(readã€dirty),å®ç°åŠ é”å¯¹æ€§èƒ½çš„å½±å“ã€‚ é€šè¿‡å¼•å…¥ä¸¤ä¸ªmapå°†è¯»å†™åˆ†ç¦»åˆ°ä¸åŒçš„mapï¼Œå…¶ä¸­read mapæä¾›å¹¶å‘è¯»å’Œå·²å­˜å…ƒç´ åŸå­å†™ï¼Œè€Œdirty mapåˆ™è´Ÿè´£è¯»å†™ã€‚ è¿™æ ·read mapå°±å¯ä»¥åœ¨ä¸åŠ é”çš„æƒ…å†µä¸‹è¿›è¡Œå¹¶å‘è¯»å–,å½“read mapä¸­æ²¡æœ‰è¯»å–åˆ°å€¼æ—¶,å†åŠ é”è¿›è¡Œåç»­è¯»å–,å¹¶ç´¯åŠ æœªå‘½ä¸­æ•°,å½“æœªå‘½ä¸­æ•°å¤§äºç­‰äºdirty mapé•¿åº¦,å°†dirty mapä¸Šå‡ä¸ºread mapã€‚ä»ä¹‹å‰çš„ç»“æ„ä½“çš„å®šä¹‰å¯ä»¥å‘ç°ï¼Œè™½ç„¶å¼•å…¥äº†ä¸¤ä¸ªmapï¼Œä½†æ˜¯åº•å±‚æ•°æ®å­˜å‚¨çš„æ˜¯æŒ‡é’ˆï¼ŒæŒ‡å‘çš„æ˜¯åŒä¸€ä»½å€¼ã€‚ å¼€å§‹æ—¶sync.Mapå†™å…¥æ•°æ® X=1 Y=2 Z=3 dirty mapä¸»è¦æ¥å—å†™è¯·æ±‚ï¼Œread mapæ²¡æœ‰æ•°æ® è¯»å–æ•°æ®çš„æ—¶å€™ä»read mapä¸­è¯»å–ï¼Œæ­¤æ—¶read mapå¹¶æ²¡æœ‰æ•°æ®ï¼Œmissè®°å½•ä»read mapè¯»å–å¤±è´¥çš„æ¬¡æ•°ï¼Œå½“misses&gt;=len(dirty map)æ—¶ï¼Œå°†dirty mapç›´æ¥å‡çº§ä¸ºread map,è¿™é‡Œç›´æ¥å¯¹dirty mapè¿›è¡Œåœ°å€æ‹·è´å¹¶ä¸”dirty mapè¢«æ¸…ç©ºï¼Œmissesç½®ä¸º0ã€‚
</code></pre></div></div>

<p>ç°åœ¨æœ‰éœ€æ±‚å¯¹Zå…ƒç´ è¿›è¡Œä¿®æ”¹Z=4ï¼Œsync.Mapä¼šç›´æ¥ä¿®æ”¹read mapçš„å…ƒç´ ã€‚</p>

<p>æ–°åŠ å…ƒç´ K=5ï¼Œæ–°åŠ çš„å…ƒç´ å°±éœ€è¦æ“ä½œdirty mapäº†ï¼Œå¦‚æœmissesè¾¾åˆ°é˜€å€¼ådirty mapç›´æ¥å‡çº§ä¸ºread mapå¹¶ä¸”dirty mapä¸ºç©ºmap(readçš„amended==false)ï¼Œåˆ™dirty mapéœ€è¦ä»read mapå¤åˆ¶æ•°æ®ã€‚
<img src="https://xiazemin.github.io/MyBlog/img/dirty_Map.png" />
å‡çº§åçš„æ•ˆæœå¦‚ä¸‹ã€‚
<img src="https://xiazemin.github.io/MyBlog/img/dirtyMap.png" /></p>

<p>å¦‚æœéœ€è¦åˆ é™¤Zï¼Œéœ€è¦åˆ†å‡ ç§æƒ…å†µï¼š
ä¸€ç§read mapå­˜åœ¨è¯¥å…ƒç´ ä¸”readçš„amended==falseï¼šç›´æ¥å°†readä¸­çš„å…ƒç´ ç½®ä¸ºnilã€‚</p>

<p>å¦ä¸€ç§ä¸ºå…ƒç´ åˆšåˆšå†™å…¥dirty mapä¸”æœªå‡çº§ä¸ºread map:ç›´æ¥è°ƒç”¨golangå†…ç½®å‡½æ•°deleteåˆ é™¤dirty mapçš„å…ƒç´ ï¼›</p>

<p>è¿˜æœ‰ä¸€ç§æ˜¯read mapå’Œdirty mapåŒæ—¶å­˜åœ¨è¯¥å…ƒç´ ï¼šå°†read mapä¸­çš„å…ƒç´ ç½®ä¸ºnilï¼Œå› ä¸ºread mapå’Œdirty map ä½¿ç”¨çš„å‡ä¸ºå…ƒç´ åœ°å€ï¼Œæ‰€ä»¥å‡è¢«ç½®ä¸ºnilã€‚</p>

<p>ä¼˜åŒ–ç‚¹</p>

<p>ç©ºé—´æ¢æ—¶é—´ã€‚é€šè¿‡å†—ä½™çš„ä¸¤ä¸ªæ•°æ®ç»“æ„(readã€dirty),å®ç°åŠ é”å¯¹æ€§èƒ½çš„å½±å“ã€‚
ä½¿ç”¨åªè¯»æ•°æ®(read)ï¼Œé¿å…è¯»å†™å†²çªã€‚
åŠ¨æ€è°ƒæ•´ï¼Œmissæ¬¡æ•°å¤šäº†ä¹‹åï¼Œå°†dirtyæ•°æ®æå‡ä¸ºreadã€‚
double-checkingï¼ˆåŒé‡æ£€æµ‹ï¼‰ã€‚
å»¶è¿Ÿåˆ é™¤ã€‚ åˆ é™¤ä¸€ä¸ªé”®å€¼åªæ˜¯æ‰“æ ‡è®°ï¼Œåªæœ‰åœ¨æå‡dirtyçš„æ—¶å€™æ‰æ¸…ç†åˆ é™¤çš„æ•°æ®ã€‚
ä¼˜å…ˆä»readè¯»å–ã€æ›´æ–°ã€åˆ é™¤ï¼Œå› ä¸ºå¯¹readçš„è¯»å–ä¸éœ€è¦é”ã€‚</p>

<p>æ–¹æ³•æºç åˆ†æ
Load
Loadè¿”å›å­˜å‚¨åœ¨æ˜ å°„ä¸­çš„é”®å€¼ï¼Œå¦‚æœæ²¡æœ‰å€¼ï¼Œåˆ™è¿”å›nilã€‚okç»“æœæŒ‡ç¤ºæ˜¯å¦åœ¨æ˜ å°„ä¸­æ‰¾åˆ°å€¼ã€‚
func (m <em>Map) Load(key interface{}) (value interface{}, ok bool) {
	// ç¬¬ä¸€æ¬¡æ£€æµ‹å…ƒç´ æ˜¯å¦å­˜åœ¨
	read, _ := m.read.Load().(readOnly)
	e, ok := read.m[key]
	if !ok &amp;&amp; read.amended {
		// ä¸ºdirty map åŠ é”
		m.mu.Lock()
		// ç¬¬äºŒæ¬¡æ£€æµ‹å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œä¸»è¦é˜²æ­¢åœ¨åŠ é”çš„è¿‡ç¨‹ä¸­,dirty mapè½¬æ¢æˆread map,ä»è€Œå¯¼è‡´è¯»å–ä¸åˆ°æ•°æ®
		read, _ = m.read.Load().(readOnly)
		e, ok = read.m[key]
		if !ok &amp;&amp; read.amended {
			// ä»dirty mapä¸­è·å–æ˜¯ä¸ºäº†åº”å¯¹read mapä¸­ä¸å­˜åœ¨çš„æ–°å…ƒç´ 
			e, ok = m.dirty[key]
			// ä¸è®ºå…ƒç´ æ˜¯å¦å­˜åœ¨ï¼Œå‡éœ€è¦è®°å½•missæ•°ï¼Œä»¥ä¾¿dirty mapå‡çº§ä¸ºread map
			m.missLocked()
		}
		// è§£é”
		m.mu.Unlock()
	}
	// å…ƒç´ ä¸å­˜åœ¨ç›´æ¥è¿”å›
	if !ok {
		return nil, false
	}
	return e.load()
}
å¤åˆ¶ä»£ç dirty mapå‡çº§ä¸ºread map
func (m *Map) missLocked() {
	// missesè‡ªå¢1
	m.misses++
	// åˆ¤æ–­dirty mapæ˜¯å¦å¯ä»¥å‡çº§ä¸ºread map
	if m.misses &lt; len(m.dirty) {
		return
	}
	// dirty mapå‡çº§ä¸ºread map
	m.read.Store(readOnly{m: m.dirty})
	// dirty map æ¸…ç©º
	m.dirty = nil
	// missesé‡ç½®ä¸º0
	m.misses = 0
}
å¤åˆ¶ä»£ç å…ƒç´ å–å€¼
func (e *entry) load() (value interface{}, ok bool) {
	p := atomic.LoadPointer(&amp;e.p)
	// å…ƒç´ ä¸å­˜åœ¨æˆ–è€…è¢«åˆ é™¤ï¼Œåˆ™ç›´æ¥è¿”å›
	if p == nil || p == expunged {
		return nil, false
	}
	return *(</em>interface{})(p), true
}
å¤åˆ¶ä»£ç read mapä¸»è¦ç”¨äºè¯»å–ï¼Œæ¯æ¬¡Loadéƒ½å…ˆä»readè¯»å–ï¼Œå½“readä¸­ä¸å­˜åœ¨ä¸”amendedä¸ºtrueï¼Œå°±ä»dirtyè¯»å–æ•°æ®  ã€‚æ— è®ºdirty mapä¸­æ˜¯å¦å­˜åœ¨è¯¥å…ƒç´ ï¼Œéƒ½ä¼šæ‰§è¡ŒmissLockedå‡½æ•°ï¼Œè¯¥å‡½æ•°å°†misses+1ï¼Œå½“m.misses &lt; len(m.dirty)æ—¶ï¼Œä¾¿ä¼šå°†dirtyå¤åˆ¶åˆ°readï¼Œæ­¤æ—¶å†å°†dirtyç½®ä¸ºnil,misses=0ã€‚
storage
è®¾ç½®Key=&gt;Valueã€‚
func (m *Map) Store(key, value interface{}) {
	// å¦‚æœreadå­˜åœ¨è¿™ä¸ªé”®ï¼Œå¹¶ä¸”è¿™ä¸ªentryæ²¡æœ‰è¢«æ ‡è®°åˆ é™¤ï¼Œå°è¯•ç›´æ¥å†™å…¥,å†™å…¥æˆåŠŸï¼Œåˆ™ç»“æŸ
	// ç¬¬ä¸€æ¬¡æ£€æµ‹
	read, _ := m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
		return
	}
	// dirty mapé”
	m.mu.Lock()
	// ç¬¬äºŒæ¬¡æ£€æµ‹
	read, _ = m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok {
		// unexpungeloccç¡®ä¿å…ƒç´ æ²¡æœ‰è¢«æ ‡è®°ä¸ºåˆ é™¤
		// åˆ¤æ–­å…ƒç´ è¢«æ ‡è¯†ä¸ºåˆ é™¤
		if e.unexpungeLocked() {
			// è¿™ä¸ªå…ƒç´ ä¹‹å‰è¢«åˆ é™¤äº†ï¼Œè¿™æ„å‘³ç€æœ‰ä¸€ä¸ªénilçš„dirtyï¼Œè¿™ä¸ªå…ƒç´ ä¸åœ¨é‡Œé¢.
			m.dirty[key] = e
		}
		// æ›´æ–°read map å…ƒç´ å€¼
		e.storeLocked(&amp;value)
	} else if e, ok := m.dirty[key]; ok {
		// æ­¤æ—¶read mapæ²¡æœ‰è¯¥å…ƒç´ ï¼Œä½†æ˜¯dirty mapæœ‰è¯¥å…ƒç´ ï¼Œå¹¶éœ€ä¿®æ”¹dirty mapå…ƒç´ å€¼ä¸ºæœ€æ–°å€¼
		e.storeLocked(&amp;value)
	} else {
		// read.amended==false,è¯´æ˜dirty mapä¸ºç©ºï¼Œéœ€è¦å°†read map å¤åˆ¶ä¸€ä»½åˆ°dirty map
		if !read.amended {
			m.dirtyLocked()
			// è®¾ç½®read.amended==trueï¼Œè¯´æ˜dirty mapæœ‰æ•°æ®
			m.read.Store(readOnly{m: read.m, amended: true})
		}
		// è®¾ç½®å…ƒç´ è¿›å…¥dirty mapï¼Œæ­¤æ—¶dirty mapæ‹¥æœ‰read mapå’Œæœ€æ–°è®¾ç½®çš„å…ƒç´ 
		m.dirty[key] = newEntry(value)
	}
	// è§£é”ï¼Œæœ‰äººè®¤ä¸ºé”çš„èŒƒå›´æœ‰ç‚¹å¤§ï¼Œå‡è®¾read mapæ•°æ®å¾ˆå¤§ï¼Œé‚£ä¹ˆæ‰§è¡Œm.dirtyLocked()ä¼šè€—è´¹èŠ±æ—¶é—´è¾ƒå¤šï¼Œå®Œå…¨å¯ä»¥åœ¨æ“ä½œdirty mapæ—¶æ‰åŠ é”ï¼Œè¿™æ ·çš„æƒ³æ³•æ˜¯ä¸å¯¹çš„ï¼Œå› ä¸ºm.dirtyLocked()ä¸­æœ‰å†™å…¥æ“ä½œ
	m.mu.Unlock()
}
å¤åˆ¶ä»£ç å°è¯•å­˜å‚¨å…ƒç´ ã€‚
func (e *entry) tryStore(i *interface{}) bool {
	// è·å–å¯¹åº”Keyçš„å…ƒç´ ï¼Œåˆ¤æ–­æ˜¯å¦æ ‡è¯†ä¸ºåˆ é™¤
	p := atomic.LoadPointer(&amp;e.p)
	if p == expunged {
		return false
	}
	for {
		// caså°è¯•å†™å…¥æ–°å…ƒç´ å€¼
		if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) {
			return true
		}
		// åˆ¤æ–­æ˜¯å¦æ ‡è¯†ä¸ºåˆ é™¤
		p = atomic.LoadPointer(&amp;e.p)
		if p == expunged {
			return false
		}
	}
}
å¤åˆ¶ä»£ç unexpungeloccç¡®ä¿å…ƒç´ æ²¡æœ‰è¢«æ ‡è®°ä¸ºåˆ é™¤ã€‚å¦‚æœè¿™ä¸ªå…ƒç´ ä¹‹å‰è¢«åˆ é™¤äº†ï¼Œå®ƒå¿…é¡»åœ¨æœªè§£é”å‰è¢«æ·»åŠ åˆ°dirty mapä¸Šã€‚
func (e *entry) unexpungeLocked() (wasExpunged bool) {
	return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)
}
å¤åˆ¶ä»£ç ä»read mapå¤åˆ¶åˆ°dirty mapã€‚
func (m *Map) dirtyLocked() {
	if m.dirty != nil {
		return
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read, _ := m.read.Load().(readOnly)
m.dirty = make(map[interface{}]*entry, len(read.m))
for k, e := range read.m {
	// å¦‚æœæ ‡è®°ä¸ºnilæˆ–è€…expungedï¼Œåˆ™ä¸å¤åˆ¶åˆ°dirty map
	if !e.tryExpungeLocked() {
		m.dirty[k] = e
	}
} } å¤åˆ¶ä»£ç LoadOrStore å¦‚æœå¯¹åº”çš„å…ƒç´ å­˜åœ¨ï¼Œåˆ™è¿”å›è¯¥å…ƒç´ çš„å€¼ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™å°†å…ƒç´ å†™å…¥åˆ°sync.Mapã€‚å¦‚æœå·²åŠ è½½å€¼ï¼Œåˆ™åŠ è½½ç»“æœä¸ºtrue;å¦‚æœå·²å­˜å‚¨ï¼Œåˆ™ä¸ºfalseã€‚ func (m *Map) LoadOrStore(key, value interface{}) (actual interface{}, loaded bool) {
// ä¸åŠ é”çš„æƒ…å†µä¸‹è¯»å–read map
// ç¬¬ä¸€æ¬¡æ£€æµ‹
read, _ := m.read.Load().(readOnly)
if e, ok := read.m[key]; ok {
	// å¦‚æœå…ƒç´ å­˜åœ¨ï¼ˆæ˜¯å¦æ ‡è¯†ä¸ºåˆ é™¤ç”±tryLoadOrStoreæ‰§è¡Œå¤„ç†ï¼‰ï¼Œå°è¯•è·å–è¯¥å…ƒç´ å·²å­˜åœ¨çš„å€¼æˆ–è€…å°†å…ƒç´ å†™å…¥
	actual, loaded, ok := e.tryLoadOrStore(value)
	if ok {
		return actual, loaded
	}
}

m.mu.Lock()
// ç¬¬äºŒæ¬¡æ£€æµ‹
// ä»¥ä¸‹é€»è¾‘å‚çœ‹Store
read, _ = m.read.Load().(readOnly)
if e, ok := read.m[key]; ok {
	if e.unexpungeLocked() {
		m.dirty[key] = e
	}
	actual, loaded, _ = e.tryLoadOrStore(value)
} else if e, ok := m.dirty[key]; ok {
	actual, loaded, _ = e.tryLoadOrStore(value)
	m.missLocked()
} else {
	if !read.amended {
		m.dirtyLocked()
		m.read.Store(readOnly{m: read.m, amended: true})
	}
	m.dirty[key] = newEntry(value)
	actual, loaded = value, false
}
m.mu.Unlock()

return actual, loaded } å¤åˆ¶ä»£ç å¦‚æœæ²¡æœ‰åˆ é™¤å…ƒç´ ï¼ŒtryLoadOrStoreå°†è‡ªåŠ¨åŠ è½½æˆ–å­˜å‚¨ä¸€ä¸ªå€¼ã€‚å¦‚æœåˆ é™¤å…ƒç´ ï¼ŒtryLoadOrStoreä¿æŒæ¡ç›®ä¸å˜å¹¶è¿”å›ok= falseã€‚ func (e *entry) tryLoadOrStore(i interface{}) (actual interface{}, loaded, ok bool) {
p := atomic.LoadPointer(&amp;e.p)
// å…ƒç´ æ ‡è¯†åˆ é™¤ï¼Œç›´æ¥è¿”å›
if p == expunged {
	return nil, false, false
}
// å­˜åœ¨è¯¥å…ƒç´ çœŸå®å€¼ï¼Œåˆ™ç›´æ¥è¿”å›åŸæ¥çš„å…ƒç´ å€¼
if p != nil {
	return *(*interface{})(p), true, true
}

// å¦‚æœpä¸ºnil(æ­¤å¤„çš„nilï¼Œå¹¶æ˜¯ä¸æ˜¯æŒ‡å…ƒç´ çš„å€¼ä¸ºnilï¼Œè€Œæ˜¯atomic.LoadPointer(&amp;e.p)ä¸ºnilï¼Œå…ƒç´ çš„nilåœ¨unsafe.Pointeræ˜¯æœ‰å€¼çš„)ï¼Œåˆ™æ›´æ–°è¯¥å…ƒç´ å€¼
ic := i
for {
	if atomic.CompareAndSwapPointer(&amp;e.p, nil, unsafe.Pointer(&amp;ic)) {
		return i, false, true
	}
	p = atomic.LoadPointer(&amp;e.p)
	if p == expunged {
		return nil, false, false
	}
	if p != nil {
		return *(*interface{})(p), true, true
	}
} } å¤åˆ¶ä»£ç Delete åˆ é™¤å…ƒç´ ,é‡‡ç”¨å»¶è¿Ÿåˆ é™¤ï¼Œå½“read mapå­˜åœ¨å…ƒç´ æ—¶ï¼Œå°†å…ƒç´ ç½®ä¸ºnilï¼Œåªæœ‰åœ¨æå‡dirtyçš„æ—¶å€™æ‰æ¸…ç†åˆ é™¤çš„æ•°,å»¶è¿Ÿåˆ é™¤å¯ä»¥é¿å…åç»­è·å–åˆ é™¤çš„å…ƒç´ æ—¶å€™éœ€è¦åŠ é”ã€‚å½“read mapä¸å­˜åœ¨å…ƒç´ æ—¶ï¼Œç›´æ¥åˆ é™¤dirty mapä¸­çš„å…ƒç´  func (m *Map) Delete(key interface{}) {
// ç¬¬ä¸€æ¬¡æ£€æµ‹
read, _ := m.read.Load().(readOnly)
e, ok := read.m[key]
if !ok &amp;&amp; read.amended {
	m.mu.Lock()
	// ç¬¬äºŒæ¬¡æ£€æµ‹
	read, _ = m.read.Load().(readOnly)
	e, ok = read.m[key]
	if !ok &amp;&amp; read.amended {
		// ä¸è®ºdirty mapæ˜¯å¦å­˜åœ¨è¯¥å…ƒç´ ï¼Œéƒ½ä¼šæ‰§è¡Œåˆ é™¤
		delete(m.dirty, key)
	}
	m.mu.Unlock()
}
if ok {
	// å¦‚æœåœ¨readä¸­ï¼Œåˆ™å°†å…¶æ ‡è®°ä¸ºåˆ é™¤ï¼ˆnilï¼‰
	e.delete()
} } å¤åˆ¶ä»£ç å…ƒç´ å€¼ç½®ä¸ºnil func (e *entry) delete() (hadValue bool) {
for {
	p := atomic.LoadPointer(&amp;e.p)
	if p == nil || p == expunged {
		return false
	}
	if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
		return true
	}
} } å¤åˆ¶ä»£ç Range éå†è·å–sync.Mapä¸­æ‰€æœ‰çš„å…ƒç´ ï¼Œä½¿ç”¨çš„ä¸ºå¿«ç…§æ–¹å¼ï¼Œæ‰€ä»¥ä¸ä¸€å®šæ˜¯å‡†ç¡®çš„ã€‚ func (m *Map) Range(f func(key, value interface{}) bool) {
// ç¬¬ä¸€æ£€æµ‹
read, _ := m.read.Load().(readOnly)
// read.amended=true,è¯´æ˜dirty mapåŒ…å«æ‰€æœ‰æœ‰æ•ˆçš„å…ƒç´ ï¼ˆå«æ–°åŠ ï¼Œä¸å«è¢«åˆ é™¤çš„ï¼‰ï¼Œä½¿ç”¨dirty map
if read.amended {
	// ç¬¬äºŒæ£€æµ‹
	m.mu.Lock()
	read, _ = m.read.Load().(readOnly)
	if read.amended {
		// ä½¿ç”¨dirty mapå¹¶ä¸”å‡çº§ä¸ºread map
		read = readOnly{m: m.dirty}
		m.read.Store(read)
		m.dirty = nil
		m.misses = 0
	}
	m.mu.Unlock()
}
// ä¸€è´¯åŸåˆ™ï¼Œä½¿ç”¨read mapä½œä¸ºè¯»
for k, e := range read.m {
	v, ok := e.load()
	// è¢«åˆ é™¤çš„ä¸è®¡å…¥
	if !ok {
		continue
	}
	// å‡½æ•°è¿”å›falseï¼Œç»ˆæ­¢
	if !f(k, v) {
		break
	}
} } å¤åˆ¶ä»£ç æ€»ç»“ ç»è¿‡äº†ä¸Šé¢çš„åˆ†æå¯ä»¥å¾—åˆ°,sync.Mapå¹¶ä¸é€‚åˆåŒæ—¶å­˜åœ¨å¤§é‡è¯»å†™çš„åœºæ™¯,å¤§é‡çš„å†™ä¼šå¯¼è‡´read mapè¯»å–ä¸åˆ°æ•°æ®ä»è€ŒåŠ é”è¿›è¡Œè¿›ä¸€æ­¥è¯»å–,åŒæ—¶dirty mapä¸æ–­å‡çº§ä¸ºread mapã€‚ ä»è€Œå¯¼è‡´æ•´ä½“æ€§èƒ½è¾ƒä½,ç‰¹åˆ«æ˜¯é’ˆå¯¹cacheåœºæ™¯.é’ˆå¯¹append-onlyä»¥åŠå¤§é‡è¯»,å°‘é‡å†™åœºæ™¯ä½¿ç”¨sync.Mapåˆ™ç›¸å¯¹æ¯”è¾ƒåˆé€‚ã€‚ sync.Mapæ²¡æœ‰æä¾›è·å–å…ƒç´ ä¸ªæ•°çš„Len()æ–¹æ³•ï¼Œä¸è¿‡å¯ä»¥é€šè¿‡Range()å®ç°ã€‚ func Len(sm sync.Map) int {
lengh := 0
f := func(key, value interface{}) bool {
	lengh++
	return true
}
one:=lengh
lengh=0
sm.Range(f)
if one != lengh {
    one = lengh
	lengh=0
	sm.Range(f)
	if one &lt;lengh {
		return lengh
	}
	
}
return one }
</code></pre></div></div>

<p>sync.Mapå®ç°åˆ†æ
golangçš„SDKä¸­æä¾›çº¿ç¨‹å®‰å…¨çš„mapå®ç°sync.Mapã€‚å®ƒæ˜¯é’ˆå¯¹RWMutex+mapçš„å®ç°æ–¹æ¡ˆä¸­å­˜åœ¨cache lineçš„false shareæå‡ºæ¥çš„ã€‚ä¸»è¦é€‚ç”¨äºä¸¤ä¸ªåœºæ™¯ï¼š</p>

<p>é’ˆå¯¹ä¸€ä¸ªkeyä¸€æ¬¡å†™å¤šæ¬¡è¯»ã€‚
å¤šä¸ªgoroutineå¹¶å‘è¯»å†™ä¿®æ”¹çš„keyæ˜¯æ²¡æœ‰äº¤é›†ã€‚</p>

<p>åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œç›¸æ¯”ä¸€ä¸ªMutexæˆ–è€…RWMutexåŠ ä¸Šæ™®é€šçš„mapï¼Œé”çš„ç«äº‰è¦å°‘çš„å¤šã€‚é‚£ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ</p>

<p>æ•°æ®ç»“æ„
type Map struct {
  mu Mutex</p>

<p>// read contains the portion of the mapâ€™s contents that are safe for
  // concurrent access (with or without mu held).
  //
  // The read field itself is always safe to load, but must only be stored with
  // mu held.
  //
  // Entries stored in read may be updated concurrently without mu, but updating
  // a previously-expunged entry requires that the entry be copied to the dirty
  // map and unexpunged with mu held.
  read atomic.Value // readOnly</p>

<p>// dirty contains the portion of the mapâ€™s contents that require mu to be
  // held. To ensure that the dirty map can be promoted to the read map quickly,
  // it also includes all of the non-expunged entries in the read map.
  //
  // Expunged entries are not stored in the dirty map. An expunged entry in the
  // clean map must be unexpunged and added to the dirty map before a new value
  // can be stored to it.
  //
  // If the dirty map is nil, the next write to the map will initialize it by
  // making a shallow copy of the clean map, omitting stale entries.
  dirty map[interface{}]*entry</p>

<p>// misses counts the number of loads since the read map was last updated that
  // needed to lock mu to determine whether the key was present.
  //
  // Once enough misses have occurred to cover the cost of copying the dirty
  // map, the dirty map will be promoted to the read map (in the unamended
  // state) and the next store to the map will make a new dirty copy.
  misses int
}</p>

<p>// readOnly is an immutable struct stored atomically in the Map.read field.
type readOnly struct {
  m       map[interface{}]*entry
  amended bool // true if the dirty map contains some key not in m.
}</p>

<p>// An entry is a slot in the map corresponding to a particular key.
type entry struct {
  // p points to the interface{} value stored for the entry.
  //
  // If p == nil, the entry has been deleted and m.dirty == nil.
  //
  // If p == expunged, the entry has been deleted, m.dirty != nil, and the entry
  // is missing from m.dirty.
  //
  // Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty
  // != nil, in m.dirty[key].
  //
  // An entry can be deleted by atomic replacement with nil: when m.dirty is
  // next created, it will atomically replace nil with expunged and leave
  // m.dirty[key] unset.
  //
  // An entryâ€™s associated value can be updated by atomic replacement, provided
  // p != expunged. If p == expunged, an entryâ€™s associated value can be updated
  // only after first setting m.dirty[key] = e so that lookups using the dirty
  // map find the entry.
  p unsafe.Pointer // *interface{}
}
Map.readåŒ…å«äº†éƒ¨åˆ†æ•°æ®ï¼Œè¯»å†™è¯·æ±‚ä¼˜å…ˆè€ƒè™‘readï¼Œé’ˆå¯¹å®ƒçš„æ“ä½œéƒ½æ˜¯CASï¼Œæ— é”çš„ã€‚</p>

<p>Map.dirtyåŒ…å«çš„æ•°æ®æ˜¯readçš„è¶…é›†ï¼Œå¯¹ä»–çš„æ“ä½œéœ€è¦åŠ é”ã€‚</p>

<p>readOnly.mè¡¨ç¤ºå½“å‰readçš„æ•°æ®ï¼ŒreadOnly.amendedè¡¨ç¤ºæ˜¯å¦æœ‰æ•°æ®åœ¨dirtyä¸­ã€‚</p>

<p>entryä¿å­˜å…·ä½“æ•°å€¼çš„æŒ‡é’ˆã€‚æœ‰ä¸‰ç§æƒ…å†µï¼š</p>

<p>nilï¼Œè¡¨ç¤ºå·²ç»åˆ é™¤ï¼Œè¿™ä¸ªæ—¶å€™dirtyä¸­entryçš„å€¼ä¹Ÿæ˜¯nilï¼Œå› ä¸ºä»–ä»¬æ˜¯åŒä¸€ä¸ªentryçš„åœ°å€ã€‚
expungedï¼Œè¡¨ç¤ºæ•°æ®å·²ç»æ“¦é™¤ï¼Œentryä¸åœ¨dirtyä¸­ã€‚
å…·ä½“çš„æ•°æ®å€¼ï¼Œä¸€å®šä¼šåœ¨dirtyä¸­ã€‚</p>

<p>æ¥å£
sync.MapåŒ…å«äº”ä¸ªæ¥å£ï¼šLoadã€Storeã€LoadOrStoreã€Deleteå’ŒRangeã€‚</p>

<p>Loadã€Storeã€LoadOrStoreå’ŒDelete
è¿™å‡ ä¸ªæ¥å£éƒ½æœ‰ç±»ä¼¼çš„æ¨¡å¼ï¼š</p>

<p>read, _ := m.read.Load().(readOnly)
if e, ok := read.m[key]; ok {
	ret := do_the_operation()
	if ret is success {
		return
	}
}
m.mu.Lock()
read, _ := m.read.Load().(readOnly)
if e, ok := read.m[key]; ok {
	ret := do_the_operation()
} else if e, ok := m.dirty[key]; ok {
	ret := do_the_operation()
}
m.mu.Unlock()
åˆ©ç”¨readçš„CASæ“ä½œå‡å°‘é”å¹¶å‘ï¼ŒåŒæ—¶ç”±äºå¹¶å‘å­˜åœ¨è·å–é”ä¹‹åè¿˜æ˜¯æœ‰å¯èƒ½æ•°æ®å·²ç»åœ¨readä¸­ï¼Œå› æ­¤è¿˜æ˜¯å¯¹readå†åšä¸€æ¬¡åŒæ ·çš„æ“ä½œï¼Œå¤ç”¨å†…å­˜ã€‚å¦‚æœæ•°æ®ä»ç„¶ä¸åœ¨readä¸­æ‰ä¼šè€ƒè™‘æ“ä½œdirtyã€‚é’ˆå¯¹æ•°æ®æ˜¯å¦åœ¨readä¸­è¿™å‡ ä¸ªæ¥å£çš„é€»è¾‘å¦‚ä¸‹ï¼š</p>

<p>readåŒ…å«äº†éƒ¨åˆ†æ•°æ®ï¼Œå¦‚æœkeyå­˜åœ¨å¹¶è€Œä¸”ä¸å®ƒå¯¹åº”çš„entryä¸æ˜¯expungedï¼Œæ•°æ®æ“ä½œä¼˜å…ˆåœ¨è¿™é‡Œè¿›è¡Œã€‚</p>

<p>Storeï¼šç›´æ¥æ›´æ–°entryå€¼ã€‚
Loadï¼šç›´æ¥è¿”å›entryå€¼ã€‚
LoadOrStore:é’ˆå¯¹entryåštryLoadOrStoreæ“ä½œã€‚
Delete:æŠŠentryè®¾ç½®æˆnilã€‚</p>

<p>å½“æ•°æ®ä¸åœ¨readä¸­æ—¶ï¼Œå°±ä¼šæ¶‰åŠåˆ°dirtyäº†ï¼š</p>

<p>Storeï¼š
a. å¦‚æœentryåœ¨readä¸­å¹¶ä¸”æ˜¯expungedï¼Œåˆ™å¤ç”¨ï¼ŒåŒæ—¶æŠŠå®ƒä¿®æ”¹æˆnilï¼Œç„¶åæŠŠentryèµ‹å€¼åˆ°dirtyï¼Œè¿™æ ·å°±é¿å…äº†åªåœ¨readä¸åœ¨dirtyçš„æƒ…å†µã€‚
b. å¦‚æœentryåœ¨dirtyä¸­ï¼Œé‚£ä¹ˆæ›´æ–°entryå€¼ã€‚
c. å¦‚æœentryä¹Ÿä¸åœ¨dirtyä¸­ï¼Œå¦‚æœdirtyæ˜¯nilï¼Œåˆ™å¤åˆ¶readä¸­çš„entryå€¼énilçš„æ•°æ®ã€‚ç„¶åï¼Œæ·»åŠ å€¼åˆ°dirtyã€‚
Loadï¼šä»dirtyæŸ¥æ‰¾ï¼ŒåŒæ—¶å¢åŠ missesã€‚å¦‚æœè¶…è¿‡ä¸€å®šçš„é˜€å€¼ï¼Œå°±ä¼šå‘ç”Ÿæ•°æ®ä»dirtyåˆ°readçš„è¿ç§»ã€‚
LoadOrStoreï¼šæµç¨‹å’ŒStoreæ¥å£ç±»ä¼¼ï¼Œåªæ˜¯è¿”å›å€¼å’Œå¯¹entryçš„å¤„ç†é€»è¾‘ä¸ä¸€æ ·ã€‚
a. å¦‚æœentryæœ‰å€¼ï¼Œåˆ™è¿”å›å…·ä½“å€¼ä»¥åŠå­˜åœ¨çš„æ ‡è¯†ã€‚
b. å¦‚æœentryå€¼ä¸ºnilï¼Œè®¾ç½®entryä¸ºæ–°çš„å€¼å¹¶è¿”å›å®ƒå’Œä¸å­˜åœ¨æ ‡è¯†ã€‚
c. å¦‚æœentryå€¼æ˜¯expungedï¼Œåˆ™è¿”å›nilå’Œå­˜åœ¨æ ‡å¿—ï¼Œè¿™ä¸ªæ˜¯æ¯”è¾ƒç‰¹æ®Šã€‚åœ¨LoadOrStoreåŒæ—¶ï¼Œå¹¶å‘çš„æŠŠentryä»readå¤åˆ¶åˆ°dirtyï¼Œè¿™ç§æƒ…å†µå°±ä¼šå‘ç”Ÿã€‚</p>

<p>Range
Rangeæ¥å£ç›¸å¯¹ç®€å•ï¼Œå¦‚æœæœ‰éƒ¨åˆ†æ•°æ®åœ¨dirtyä¸­å°±ä¼šæŠŠdirtyçš„æ•°æ®æå‡åˆ°readä¸­ï¼Œå¹¶é‡ç½®dirtyã€‚ç„¶åï¼Œéå†çš„æ˜¯dirtyæ•°æ®ã€‚å¦åˆ™ï¼Œåªéå†readä¸­çš„æ•°æ®ã€‚è¿™é‡Œä¸ä¿è¯èƒ½éå†åˆ°ä¹‹åæ·»åŠ çš„æ•°æ®ã€‚</p>

<p>é€šè¿‡ä¸Šé¢çš„é€»è¾‘æˆ‘ä»¬å‘ç°readå’Œdirtyç›´æ¥æ•°æ®æµè½¬é€»è¾‘å¦‚ä¸‹ï¼š</p>

<p>readåˆ°dirtyï¼šåœ¨Storeå’ŒLoadOrStoreçš„æ—¶å€™ï¼Œå¦‚æœéœ€è¦ä¿å­˜çš„keyæ—¢ä¸åœ¨readä¹Ÿä¸åœ¨dirtyï¼Œè€Œä¸”è¿™æ—¶dirtyæ˜¯nilï¼Œå°±ä¼šæŠŠreadä¸­çš„nilæ•°æ®å˜æˆexpungedï¼Œå¹¶å¤åˆ¶é™¤äº†è¿™ä»½ä»¥å¤–çš„æ•°æ®åˆ°dirtyã€‚
dirtyåˆ°readï¼š
a. åœ¨Loadå’ŒLoadOrStoreçš„æ—¶å€™ï¼Œå¦‚æœreadä¸­ä¸å­˜åœ¨ï¼Œéœ€è¦ä»dirtyä¸­è·å–æ•°æ®ï¼Œå°±ä¼šå¢åŠ missesï¼Œå½“missesç­‰äºdirtyçš„å¤§å°æ—¶ï¼Œå°±ä¼šæŠŠdirtyå°è£…æˆreadOnlyï¼Œç„¶ååŸå­çš„èµ‹å€¼ç»™readï¼Œå¹¶é‡ç½®dirtyã€‚
b. åœ¨Rangeçš„æ—¶å€™ï¼Œå¦‚æœæœ‰æ•°æ®ä¸åœ¨readä¸­åŒæ ·ä¼šæŠŠdirtyå°è£…æˆreadOnlyï¼Œç„¶ååŸå­çš„èµ‹å€¼ç»™readï¼Œå¹¶é‡ç½®dirtyæ•°æ®ã€‚</p>

<p>ç–‘é—®
ä¸ºä»€ä¹ˆéœ€è¦expungedçŠ¶æ€ï¼Ÿ</p>
<blockquote>
  <p>å¦‚æœæ²¡æœ‰è¿™ä¸ªçŠ¶æ€ï¼Œæ›´æ–°å·²ç»åˆ é™¤çš„ä½†æ˜¯å·²ç»å­˜åœ¨çš„æ•°æ®å°±éœ€è¦åŠ é”äº†ã€‚</p>
</blockquote>

<p>ä¸ºä»€ä¹ˆnewEntryçš„æ—¶å€™å–çš„æ˜¯å‚æ•°interface{}çš„åœ°å€ï¼Œè¿™ä¸ªåœ°å€ä¸æ˜¯æ ˆä¸Šçš„ä¹ˆï¼Œä¼šä¸ä¼šæœ‰é—®é¢˜ï¼Ÿ</p>
<blockquote>
  <p>å‚æ•°içš„åœ°å€è¢«ä¿å­˜åˆ°mapä¸­æ—¶ï¼Œå˜é‡&amp;iå·²ç»é€ƒé€¸åˆ°å †ä¸Šé¢å»äº†ã€‚</p>
</blockquote>

<p>æ€»ç»“
æ–‡ä¸­å¼€å¤´æåˆ°çš„ä¸¤ä¸ªä¸»è¦ä½¿ç”¨åœºæ™¯çš„åŸå› ä¸»è¦ä½¿ç”¨çš„ä»¥ä¸‹æŠ€æœ¯ï¼š</p>

<p>æ— é”çš„CASæ“ä½œã€‚
è¯»å†™åˆ†ç¦»ï¼Œé€šè¿‡ä¸€ä»½åªè¯»çš„æ•°æ®ç»“åˆCASæ“ä½œå‡å°‘é”ç«äº‰ã€‚
å»¶è¿Ÿåˆ é™¤ï¼Œåªæœ‰å½“åªè¯»çš„æ•°æ®è¢«å†™çš„æ•°æ®è¦†ç›–ä»¥åæ‰ä¼šè¢«gcå›æ”¶ã€‚
å†…å­˜å¤ç”¨ï¼Œå·²ç»åˆ é™¤çš„æ•°æ®æ‰€åœ¨çš„å†…å­˜ï¼Œå½“åŒä¸€ä¸ªkeyèµ‹å€¼çš„æ—¶å€™ï¼Œå¯ä»¥è¢«é‡æ–°è¢«ä½¿ç”¨ã€‚
åˆ†æ‘Šåˆ†æã€‚</p>

<p>sync.Map
type Map struct {
    // å¸¸ç”¨çš„é”,åœ¨æ“ä½œdirtyæ—¶ä¼šç”¨åˆ°
    mu Mutex</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read atomic.Value // readOnly

// dirtyå€¼è¦ä¹ˆä¸ºç©º,è¦ä¹ˆä¸ºå…¨éƒ¨é”®å€¼å¯¹
dirty map[interface{}]*entry

// åœ¨æŸ¥è¯¢readæ—¶,å‘½ä¸­å¤±è´¥çš„æ¬¡æ•°,å½“misseså¤§äºdirtyé•¿åº¦æ—¶,read.m ä¼šç›´æ¥æŒ‡å‘dirty
misses int } Map.readå®é™…å€¼æ˜¯readOnlyç»“æ„ä½“,å¯ä»¥çœ‹æˆæ˜¯æ¯”dirtyå¤šäº†ä¸€ä¸ªamendedå­—æ®µçš„ç»“æ„
</code></pre></div></div>

<p>æ³¨æ„è¿™ä¸ªå¹¶ä¸æ˜¯çœŸæ­£çš„åªè¯»,æ·»åŠ æ“ä½œæ˜¯é€šè¿‡ç›´æ¥å°†må­—æ®µæŒ‡å‘æ•´ä¸ªdirtyå®Œæˆçš„,åˆ é™¤æ“ä½œæ˜¯é€šè¿‡ä¿®æ”¹entryä¸ºexpungedå®Œæˆçš„</p>

<p>readOnly
type readOnly struct {
    m       map[interface{}]*entry
    amended bool 
}
ä¸»è¦çœ‹ä¸‹readOnly.amendedçš„å€¼å˜åŒ–æƒ…å†µ</p>

<p>åœ¨Storeæ–¹æ³•ä¸­,æ·»åŠ æ–°çš„é”®å€¼å¯¹æ—¶,å¦‚æœamended==false,ä¼šéå†readå€¼,å°†å…¶ä¸­æœªè¢«æ ‡è®°ä¸ºåˆ é™¤çš„è®°å½•,å¤åˆ¶åˆ°dirtyä¸­,ç„¶åread.amendedä¼šè¢«ä¿®æ”¹ä¸ºtrue</p>

<p>åœ¨Loadæ–¹æ³•ä¸­,å¦‚æœmissæ¬¡æ•°å¤§äºdiryé•¿åº¦æ—¶,ä¼šå°†read.mç›´æ¥æŒ‡å‘dirty,ä¸”read.amendedè¢«ç½®ä¸ºfalse</p>

<p>å¦‚æœamended==true,è¯´æ˜å½“å‰mapæ—¶é—´èŠ‚ç‚¹å¤„äºæ–°æ·»åŠ é”®å€¼å¯¹ä¹‹å,å¤åˆ¶dirtyåˆ°readä¹‹å‰,æ­¤æ—¶dirtyä¸ä¸ºç©º,ä¸”dirtyåŒ…æ‹¬æ‰€æœ‰Mapä¸­æœªè¢«åˆ é™¤çš„æ•°æ®,readä¸­çš„æ•°æ®å¯èƒ½å°‘äºdirty</p>

<p>å¦‚æœamended==false,è¯´æ˜è¯´æ˜dirtyä¸ºç©º</p>

<p>entry
type entry struct {
    p unsafe.Pointer // *interface{}
}
å®é™…æ˜¯é”®å€¼å¯¹ä¸­çš„value</p>

<p>å…³é”®æ“ä½œ
å¯»å€¼
func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
    read, _ := m.read.Load().(readOnly)
    e, ok := read.m[key]
    if !ok &amp;&amp; read.amended {
        m.mu.Lock()
        read, _ = m.read.Load().(readOnly)
        e, ok = read.m[key]
        if !ok &amp;&amp; read.amended {
            e, ok = m.dirty[key]
            m.missLocked() // å¦‚æœreadä¸­æ²¡æœ‰,æŸ¥è¯¢dirty
        }
        m.mu.Unlock()
    }
    if !ok {
        return nil, false
    }
    return e.load()
}
å¤åˆ¶dirtyåˆ°read,å¹¶æ¸…ç©ºdirty
func (m *Map) missLocked() {
    m.misses++
    if m.misses &lt; len(m.dirty) {
        return
    }
    m.read.Store(readOnly{m: m.dirty})
    m.dirty = nil
    m.misses = 0
}
å­˜å€¼
func (m *Map) Store(key, value interface{}) {
    read, _ := m.read.Load().(readOnly)
    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
        return
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m.mu.Lock()
read, _ = m.read.Load().(readOnly)
if e, ok := read.m[key]; ok {
    if e.unexpungeLocked() {
        m.dirty[key] = e
    }
    e.storeLocked(&amp;value)
} else if e, ok := m.dirty[key]; ok {
    e.storeLocked(&amp;value)
} else {
    if !read.amended {
        m.dirtyLocked()
        m.read.Store(readOnly{m: read.m, amended: true})
    }
    m.dirty[key] = newEntry(value)
}
m.mu.Unlock() } åœºæ™¯åˆ†æ map.Store(a,â€aâ€) -&gt; map.Store(b,â€bâ€) ç¬¬ä¸€æ¬¡map.Store(â€œaâ€,â€aâ€)
</code></pre></div></div>

<p>å› ä¸ºå¤‡ä»½æ ‡è®°ä¸ºfalse,æ‰§è¡Œm.dirtyLocked()
å¤åˆ¶read -&gt; dirty
å°†å¤‡ä»½æ ‡è®°read.amendedæ›´æ–°ä¸ºtrue
å°†aå­˜åœ¨dirtyä¸­
ç¬¬äºŒæ¬¡map.Store(â€œbâ€,â€bâ€)</p>

<p>è·³è¿‡if !read.amended åˆ¤æ–­
å‘dirtyä¸­å­˜å‚¨æ•°æ®
map.Store(â€œaâ€,â€aâ€) -&gt;map.Load(â€œaâ€) map.Store(â€œbâ€,â€bâ€)
map.Store(â€œaâ€,â€aâ€)</p>

<p>å› ä¸ºå¤‡ä»½æ ‡è®°ä¸ºfalse,æ‰§è¡Œm.dirtyLocked()
å¤åˆ¶read -&gt; dirty
å°†read.amendedæ›´æ–°ä¸ºtrue
å°†aå­˜åœ¨dirtyä¸­
map.Load(â€œaâ€)</p>

<p>ä»readä¸­è¯»å–å¤±è´¥
ä»dirtyä¸­è¯»å–
m.missLocked()
miss+1
å› ä¸ºmiss &gt;= len(dirty),ç›´æ¥å°†m.dirtyå¤åˆ¶åˆ°m.readä¸­
å¤‡ä»½æ ‡è®°m.read.amended = false
æ¸…ç©ºdirty
map.Store(â€œbâ€,â€bâ€)</p>

<p>å› ä¸ºå¤‡ä»½æ ‡è®°ä¸ºfalse,æ‰§è¡Œm.dirtyLocked()
å¤åˆ¶read -&gt; dirty
å°†read.amendedæ›´æ–°ä¸ºtrue
å°†aå­˜åœ¨dirtyä¸­
æ€»ç»“
sync.Mapæ˜¯å¦‚ä½•ä¿è¯æ€§èƒ½æ¯”ç›´æ¥åœ¨mapä¸­åŠ é”çš„æ€§èƒ½å¥½
å½“å†™å…¥æ“ä½œè¾ƒå¤šæ—¶,æ€§èƒ½æ˜¯æ— æ³•ä¿è¯çš„,å› ä¸ºæ¯æ¬¡éƒ½æœ‰å¯èƒ½è¦éå†readå¤åˆ¶åˆ°dirtyä¸­</p>

<p>å½“è¯»å¤šå†™å°‘æ—¶,readæ˜¯atomic.Valueç±»å‹, è¯»å–æ—¶åˆ©ç”¨äº†atomic.Value.Loadå®ç°äº†åŸå­æ“ä½œ,æ²¡æœ‰ç”¨åˆ°é”,æ‰€ä»¥æ€§èƒ½æœ‰æ‰€æå‡</p>

<p>æ€ä¹ˆç†è§£read.amended
å¯ä»¥æŠŠamendedç†è§£ä¸ºä¸€ä¸ªå¤‡ä»½æ ‡è®°,ä»readä¸­éå†æ•°æ®,å¤åˆ¶åˆ°dirtyä¸­,ç›¸å½“äºå®Œæˆå¤‡ä»½,amendedä¸ºtrue,dirtyä¸ºnilæ—¶,è¯´æ˜æœªå¤‡ä»½,amendedä¸ºfalse</p>

<p>Map.read å’Œ Map.dirtyçš„å…³ç³»
å¯ä»¥æŠŠreadçœ‹æˆæ˜¯ç¼“å­˜,å½“ç¼“å­˜å‘½ä¸­å¤±è´¥æ¬¡æ•°è¿‡å¤šæ—¶,ä¼šä»dirtyä¸­å¤åˆ¶æ•°æ®åˆ°readä¸­,å¦‚æœdirtyä¸ä¸ºç©º,é‚£ä¹ˆdirtyçš„æ•°æ®å¤§äºç­‰äºread</p>

<p>ä»dirtyä¸­å¤åˆ¶æ•°æ®åˆ°readä¸­,æ˜¯å¦ä¼šå¯¼è‡´åŸæ¥çš„readä¸­çš„æ•°æ®ä¸¢å¤±
ä¸ä¼š,æ¯æ¬¡dirtyåˆ›å»ºæ—¶,éƒ½æ˜¯ä»readä¸­è¯»å–æœªè¢«æ ‡è®°åˆ é™¤çš„æ•°æ®å¤åˆ¶åˆ°dirtyä¸­,ä¹‹ådirtyä¸­çš„æ•°æ®åªä¼šå¤šäºread,æ‰€ä»¥åœ¨ä»dirtyä¸­å¤åˆ¶æ•°æ®åˆ°readä¸­æ—¶,åªæ˜¯ä¼šä¸¢å¤±å·²è¢«æ ‡è®°åˆ é™¤çš„æ•°æ®,è€Œä¸ä¼šä¸¢å¤±å®é™…æ•°æ®</p>

<p>golang mapæ˜¯égoroutineå®‰å…¨ï¼Œå¦‚æœå¤šä¸ªgoroutineä½¿ç”¨mapéœ€è¦åŠ é”ã€‚ä½†åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹ï¼Œé”çš„äº‰ç”¨ä¼šé€ æˆç³»ç»Ÿæ€§èƒ½çš„ä¸‹é™ã€‚ä¸ºäº†è§£å†³è¿™ç§é—®é¢˜ï¼Œgo 1.9ä¹‹åæä¾›äº†çº¿ç¨‹å®‰å…¨ï¼šsync.mapã€‚sync.mapå¼•å…¥äº†ä¸¤ä¸ªæ•°æ®ç»“æ„readï¼Œdirtyæ¥å­˜å‚¨ï¼Œä»–ä»¬çš„åº•å±‚éƒ½æ˜¯ç”¨mapæ¥å®ç°ã€‚</p>

<p>Golangé€‰æ‹©äº† CAS è¿™ç§ä¸ç”¨åŠ é”çš„æ–¹æ¡ˆæ¥æ›´æ–°å€¼,å®ç°å¹¶å‘å®‰å…¨çš„mapã€‚
ä¸‹é¢ä¾‹ä¸¾äº†ä¸‰ä¸ªç»“æ„ä½“</p>

<p>map: sync.mapçš„ç»“æ„ä½“ï¼ŒåŒ…å«readå’Œdirtyï¼Œreadå’Œdirtyå­˜å‚¨äº†mapä¸­çœŸå®å­˜å‚¨çš„key/valueå€¼ã€‚missesè¡¨ç¤ºä»dirtyè¯»å–å€¼çš„æ¬¡æ•°
readonlyï¼šMap.readå€¼çš„ç»“æ„ä½“ç±»å‹ï¼Œmå­˜å‚¨key/valueçœŸå®å€¼ã€‚readOnly.amendedè¡¨ç¤ºreadæ˜¯å¦åˆ›å»ºäº†dirtyå‰¯æœ¬
entry: readå’Œdirtyä¸­å­˜å‚¨valueçš„æŒ‡é’ˆ</p>

<p>type Map struct {
    mu Mutex
    read atomic.Value // readOnly
    dirty map[interface{}]*entry
    misses int
}</p>

<p>type readOnly struct {
    m       map[interface{}]*entry
    amended bool 
}</p>

<p>type entry struct {
    p unsafe.Pointer // *interface{}
}
readæ˜¯readOnlyç»“æ„ä½“ï¼ŒçœŸå®æ•°æ®å­˜å‚¨åœ¨readOnly.mã€‚</p>

<p>readå’Œdirtyçš„å…³è”ï¼š
image.png</p>

<p>1: readç›¸å½“äºcacheï¼Œè¯»å–æ•°æ®æ—¶ï¼Œå…ˆä»readè¯»å–ï¼Œæ²¡æœ‰å–åˆ°ï¼Œä»dirtyè¯»å–ï¼ŒMap.misses++ã€‚
å½“Map.missesè¾¾åˆ°dirtyé•¿åº¦æ—¶ï¼ŒæŠŠdirtyé‡Œé¢çš„æ•°æ®å…¨éƒ¨copyåˆ°readä¸­ï¼Œå¹¶ä¸”dirtyç½®ä¸ºnilã€‚</p>

<p>2: readå’Œdirty mapå­˜å‚¨çš„å…ƒç´ å€¼æ˜¯æ”¾åœ¨entryç»“æ„ä½“ä¸­ã€‚readå’Œdirtyä¸­ç›¸åŒkeyå€¼æŒ‡å‘åŒä¸€ä¸ªentryåœ°å€ï¼Œæ‰€ä»¥å½“å¯¹readçš„keyå¯¹åº”çš„valueå€¼è¿›è¡Œä¿®æ”¹ï¼Œdirtyä¸­çš„å€¼ä¹Ÿä¼šç›¸åº”çš„è¢«ä¿®æ”¹ã€‚</p>

<p>entry.p çš„çŠ¶æ€ï¼š
1: nilè¡¨ç¤ºentryè¢«åˆ é™¤ï¼Œå¹¶ä¸”Map.dirty = nil
2: expunged(åˆå§‹åŒ–çš„entry.p)è¡¨ç¤ºentryè¢«åˆ é™¤ï¼Œä½†æ˜¯Map.dirty != nil
3: å…¶ä»–æƒ…å†µè¡¨ç¤ºå€¼å­˜åœ¨</p>

<p>snyc.Mapä¸»è¦æä¾›äº†æ’å…¥ï¼ŒæŸ¥æ‰¾ï¼Œåˆ é™¤æ“ä½œï¼Œæ¥ä¸‹æ¥ä¼šä¸»è¦ä¼šè®²è¿™ä¸‰ä¸ªæ–¹æ³•çš„å®ç°</p>

<p>æ’å…¥æµç¨‹
æ’å…¥key, value
1: å…ˆä»readä¸­è·å–keyï¼Œå¦‚æœå­˜åœ¨ï¼Œå¹¶ä¸”è¿™ä¸ªkeyæ²¡æœ‰è¢«åˆ é™¤ï¼Œåˆ™ç›´æ¥æ›´æ–°read[key] = entry{p: value}è¿”å›
2: å¦åˆ™ï¼Œkeyå­˜åœ¨ä½†æ˜¯è¢«åˆ é™¤äº†ï¼Œåœ¨dirtyä¸­æ’å…¥è¿™ä¸ªkeyï¼Œvalueå€¼ã€‚dirty[key] = entry{p: value}è¿”å›
3: å¦‚æœdirtyä¸ºnilï¼Œåˆ™å°†read mapçš„key,entry æ·»åŠ åˆ°æ–°åˆ›å»ºçš„dirty mapä¸­ï¼›ä¸ä¸ºnilï¼Œåˆ™è·³è¿‡ç¬¬3æ­¥
4: å°†key, valueæ’å…¥dirty mapä¸­ã€‚dirty[key] = entry{p: value}</p>

<p>æ’å…¥æ€»ç»“ï¼š
æ–°åŠ å…¥çš„keyå€¼ï¼Œä¼šæ’å…¥dirtyä¸­
ä»¥å‰å­˜åœ¨ï¼Œä½†æ˜¯åˆ é™¤è¿‡çš„keyï¼Œä¼šæ’å…¥dirtyä¸­
ä»¥å‰å­˜åœ¨ï¼Œä½†æ˜¯æ²¡è¢«åˆ é™¤çš„keyï¼Œreadä¼šæ›´æ–°è¿™ä¸ªkeyå¯¹åº”çš„valueå€¼ï¼Œ
æ‰€ä»¥ dirtyä¸ä¸ºnilçš„æ—¶å€™ï¼Œä¼šå…¨é‡ä¿å­˜keyå€¼ã€‚</p>

<p>æŸ¥æ‰¾æµç¨‹
æŸ¥æ‰¾key
1: ä»readä¸­è¯»å–åˆ°ï¼Œç›´æ¥è¿”å›
2: æ²¡æœ‰è¯»å–åˆ°ï¼Œå¹¶ä¸”dirtyä¸ä¸ºnilï¼Œå¯¹mapåŠ é”,ç„¶åå†è¯»å–ä¸€éread mapä¸­å†…å®¹ï¼ˆä¸»è¦é˜²æ­¢åœ¨åŠ é”çš„è¿‡ç¨‹ä¸­,æœ‰å¯èƒ½dirty mapå…¨éƒ¨copyåˆ°read map,dirtyç½®ä¸ºnilï¼‰,å¦‚æœreadå­˜åœ¨keyï¼Œç›´æ¥è¿”å›
3: readä¸å­˜åœ¨ï¼Œä»dirtyä¸­è¯»å–keyå¯¹åº”çš„valueå€¼è¿”å›ï¼Œå¹¶ä¸”map.misses++ã€‚å½“map.missesè¾¾åˆ°ä¸€å®šdirtyé•¿åº¦ï¼Œå°†dirty mapå…¨éƒ¨copyåˆ°read map,dirtyç½®ä¸ºnilã€‚</p>

<p>æŸ¥æ‰¾æ€»ç»“ï¼š
è¯»readæ²¡è¯»åˆ°ï¼Œä¼šä»dirtyä¸­è¯»å–ï¼Œå¹¶ä¸”misses æ¬¡æ•°+1ï¼Œå½“æ¬¡æ•°è¾¾åˆ°ä¸€å®šdirtyé•¿åº¦ï¼Œä¼šæŠŠdirty mapå…¨éƒ¨copyåˆ°read map,dirtyç½®ä¸ºnilã€‚</p>

<p>åˆ é™¤æµç¨‹
1: ä»readä¸­å»è¯»keyï¼Œå¦‚æœå­˜åœ¨ï¼Œç›´æ¥å°†ä»read[key]è·å–åˆ°entry.p ç½®ä¸ºnil
2: å¦åˆ™ï¼Œä»dirtyä¸­åˆ é™¤è¿™ä¸ªkeyå€¼
æ‰€ä»¥å¯ä»¥å¾—å‡ºï¼Œreadåˆ é™¤æ˜¯ç›´æ¥æŠŠentryçš„pç½®ä¸ºnil,keyä¿ç•™ã€‚ä»dirtyä¸­åˆ é™¤æ˜¯ç›´æ¥åˆ é™¤è¿™ä¸ªkey
Map is like a Go map[interface{}]interface{} but is safe for concurrent use
by multiple goroutines without additional locking or coordination.
Loads, stores, and deletes run in amortized constant time.</p>

<p>ä¸Šé¢ä¸€æ®µæ˜¯å®˜æ–¹å¯¹sync.Map çš„æè¿°ï¼Œä»æè¿°ä¸­çœ‹ï¼Œsync.Map è·Ÿmap å¾ˆåƒï¼Œsync.Map çš„åº•å±‚å®ç°ä¹Ÿæ˜¯ä¾é äº†mapï¼Œä½†æ˜¯sync.Map ç›¸å¯¹äº map æ¥è¯´ï¼Œæ˜¯å¹¶å‘å®‰å…¨çš„ã€‚</p>
<ol>
  <li>ç»“æ„æ¦‚è§ˆ
1.1. sync.Map
sync.Mapçš„ç»“æ„ä½“äº†
type Map struct {
 mu Mutex</li>
</ol>

<p>// åé¢æ˜¯readOnlyç»“æ„ä½“ï¼Œä¾é mapå®ç°ï¼Œä»…ä»…åªç”¨æ¥è¯»
	read atomic.Value // readOnly</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// è¿™ä¸ªmapä¸»è¦ç”¨æ¥å†™çš„ï¼Œéƒ¨åˆ†æ—¶å€™ä¹Ÿæ‰¿æ‹…è¯»çš„èƒ½åŠ›
dirty map[interface{}]*entry

// è®°å½•è‡ªä»ä¸Šæ¬¡æ›´æ–°äº†readä¹‹åï¼Œä»readè¯»å–keyå¤±è´¥çš„æ¬¡æ•°
misses int } å¤åˆ¶ä»£ç 1.2. readOnly sync.Map.readå±æ€§æ‰€å¯¹åº”çš„ç»“æ„ä½“äº†ï¼Œè¿™é‡Œä¸å¤ªæ˜ç™½ä¸ºä»€ä¹ˆä¸æŠŠreadOnlyç»“æ„ä½“çš„å±æ€§ç›´æ¥æ”¾å…¥åˆ°sync.Mapç»“æ„ä½“é‡Œ type readOnly struct {   // è¯»æ“ä½œæ‰€å¯¹åº”çš„map
m       map[interface{}]*entry   // dirtyæ˜¯å¦åŒ…å«mä¸­ä¸å­˜åœ¨çš„key
amended bool // true if the dirty map contains some key not in m. } å¤åˆ¶ä»£ç 1.3. entry entryå°±æ˜¯unsafe.Pointerï¼Œè®°å½•çš„æ˜¯æ•°æ®å­˜å‚¨çš„çœŸå®åœ°å€ type entry struct {
p unsafe.Pointer // *interface{} }
</code></pre></div></div>

<p>å¤åˆ¶ä»£ç 1.4. ç»“æ„ç¤ºæ„å›¾
é€šè¿‡ä¸Šé¢çš„ç»“æ„ä½“ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•ç”»å‡ºæ¥ä¸€ä¸ªç»“æ„ç¤ºæ„å›¾</p>

<ol>
  <li>
    <p>æµç¨‹åˆ†æ
æˆ‘ä»¬é€šè¿‡ä¸‹é¢çš„åŠ¨å›¾ï¼ˆä¹Ÿå¯ä»¥æ‰‹åŠ¨debugï¼‰ï¼Œçœ‹ä¸€ä¸‹åœ¨æˆ‘ä»¬æ‰§è¡ŒStore Load Delete çš„æ—¶å€™ï¼Œè¿™ä¸ªç»“æ„ä½“çš„å˜æ¢æ˜¯å¦‚ä½•çš„ï¼Œå…ˆå¢åŠ ä¸€ç‚¹æˆ‘ä»¬çš„è®¤çŸ¥
func main() {
 m := sync.Map{}
 m.Store(â€œtest1â€, â€œtest1â€)
 m.Store(â€œtest2â€, â€œtest2â€)
 m.Store(â€œtest3â€, â€œtest3â€)
 m.Load(â€œtest1â€)
 m.Load(â€œtest2â€)
 m.Load(â€œtest3â€)
 m.Store(â€œtest4â€, â€œtest4â€)
 m.Delete(â€œtestâ€)
 m.Load(â€œtestâ€)
}
å¤åˆ¶ä»£ç ä»¥ä¸Šé¢ä»£ç ä¸ºä¾‹ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹mçš„ç»“æ„å˜æ¢</p>
  </li>
  <li>
    <p>æºç åˆ†æ
3.1. æ–°å¢key
æ–°å¢ä¸€ä¸ªkey valueï¼Œé€šè¿‡Storeæ–¹æ³•æ¥å®ç°
func (m *Map) Store(key, value interface{}) {
 read, _ := m.read.Load().(readOnly)
  // å¦‚æœè¿™ä¸ªkeyå­˜åœ¨ï¼Œé€šè¿‡tryStoreæ›´æ–°
 if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
     return
 }
  // èµ°åˆ°è¿™é‡Œæœ‰ä¸¤ç§æƒ…å†µï¼Œ1. keyä¸å­˜åœ¨ 2. keyå¯¹åº”çš„å€¼è¢«æ ‡è®°ä¸ºexpungedï¼Œreadä¸­çš„entryæ‹·è´åˆ°dirtyæ—¶ï¼Œä¼šå°†keyæ ‡è®°ä¸ºexpungedï¼Œéœ€è¦æ‰‹åŠ¨è§£é”
 m.mu.Lock()
 read, _ = m.read.Load().(readOnly)
 if e, ok := read.m[key]; ok {
 // ç¬¬äºŒç§æƒ…å†µï¼Œå…ˆè§£é”ï¼Œç„¶åæ·»åŠ åˆ°dirty
     if e.unexpungeLocked() {
         // The entry was previously expunged, which implies that there is a
         // non-nil dirty map and this entry is not in it.
         m.dirty[key] = e
     }
     e.storeLocked(&amp;value)
 } else if e, ok := m.dirty[key]; ok {
 // mä¸­æ²¡æœ‰ï¼Œä½†æ˜¯dirtyä¸­å­˜åœ¨ï¼Œæ›´æ–°dirtyä¸­çš„å€¼
     e.storeLocked(&amp;value)
 } else {
 // å¦‚æœamend==falseï¼Œè¯´æ˜dirtyå’Œreadæ˜¯ä¸€è‡´çš„ï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦æ–°åŠ keyåˆ°dirtyé‡Œé¢ï¼Œæ‰€ä»¥æ›´æ–°read.amended
     if !read.amended {
         // Weâ€™re adding the first new key to the dirty map.
         // Make sure it is allocated and mark the read-only map as incomplete.
   // è¿™ä¸€æ­¥ä¼šå°†readä¸­æ‰€æœ‰çš„keyæ ‡è®°ä¸º expunged
         m.dirtyLocked()
         m.read.Store(readOnly{m: read.m, amended: true})
     }
     m.dirty[key] = newEntry(value)
 }
 m.mu.Unlock()
}
å¤åˆ¶ä»£ç 3.1.1. tryLock
func (e *entry) tryStore(i *interface{}) bool {
 p := atomic.LoadPointer(&amp;e.p)
  // è¿™ä¸ªentryæ˜¯keyå¯¹åº”çš„entryï¼Œpæ˜¯keyå¯¹åº”çš„å€¼ï¼Œå¦‚æœpè¢«è®¾ç½®ä¸ºexpungedï¼Œä¸èƒ½ç›´æ¥æ›´æ–°å­˜å‚¨
 if p == expunged {
     return false
 }
 for {
 // åŸå­æ›´æ–°
     if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) {
         return true
     }
     p = atomic.LoadPointer(&amp;e.p)
     if p == expunged {
         return false
     }
 }
}
å¤åˆ¶ä»£ç tryLockä¼šå¯¹keyå¯¹åº”çš„å€¼ï¼Œè¿›è¡Œåˆ¤æ–­ï¼Œæ˜¯å¦è¢«è®¾ç½®ä¸ºäº†expungedï¼Œè¿™ç§æƒ…å†µä¸‹ä¸èƒ½ç›´æ¥æ›´æ–°
3.1.2. dirtyLock
è¿™é‡Œå°±æ˜¯è®¾ç½® expunged æ ‡å¿—çš„åœ°æ–¹äº†ï¼Œè€Œè¿™ä¸ªå‡½æ•°æ­£æ˜¯å°†readä¸­çš„æ•°æ®åŒæ­¥åˆ°dirtyçš„æ“ä½œ
func (m *Map) dirtyLocked() {
  // dirty != nil è¯´æ˜dirtyåœ¨ä¸Šæ¬¡readåŒæ­¥dirtyæ•°æ®åï¼Œå·²ç»æœ‰äº†ä¿®æ”¹äº†ï¼Œè¿™æ—¶å€™readçš„æ•°æ®ä¸ä¸€å®šå‡†ç¡®ï¼Œä¸èƒ½åŒæ­¥
 if m.dirty != nil {
     return
 }</p>

    <p>read, _ := m.read.Load().(readOnly)
 m.dirty = make(map[interface{}]*entry, len(read.m))
 for k, e := range read.m {
 // è¿™é‡Œè°ƒç”¨tryExpungeLocked æ¥ç»™entryï¼Œå³keyå¯¹åº”çš„å€¼ è®¾ç½®æ ‡å¿—ä½
     if !e.tryExpungeLocked() {
         m.dirty[k] = e
     }
 }
}
å¤åˆ¶ä»£ç 3.1.3. tryExpungeLocked
é€šè¿‡åŸå­æ“ä½œï¼Œç»™entryï¼Œkeyå¯¹åº”çš„å€¼è®¾ç½® expunged æ ‡å¿—
func (e *entry) tryExpungeLocked() (isExpunged bool) {
 p := atomic.LoadPointer(&amp;e.p)
 for p == nil {
     if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
         return true
     }
     p = atomic.LoadPointer(&amp;e.p)
 }
 return p == expunged
}
å¤åˆ¶ä»£ç 3.1.4. unexpungeLocked
func (e *entry) unexpungeLocked() (wasExpunged bool) {
 return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)
}
å¤åˆ¶ä»£ç æ ¹æ®ä¸Šé¢åˆ†æï¼Œæˆ‘ä»¬å‘ç°ï¼Œåœ¨æ–°å¢çš„æ—¶å€™ï¼Œåˆ†ä¸ºå››ç§æƒ…å†µï¼š</p>
  </li>
</ol>

<p>keyåŸå…ˆå°±å­˜åœ¨äºreadä¸­ï¼Œè·å–keyæ‰€å¯¹åº”å†…å­˜åœ°å€ï¼ŒåŸå­æ€§ä¿®æ”¹
keyå­˜åœ¨ï¼Œä½†æ˜¯keyæ‰€å¯¹åº”çš„å€¼è¢«æ ‡è®°ä¸º expungedï¼Œè§£é”ï¼Œè§£é™¤æ ‡è®°ï¼Œå¹¶æ›´æ–°dirtyä¸­çš„keyï¼Œä¸readä¸­è¿›è¡ŒåŒæ­¥ï¼Œç„¶åä¿®æ”¹keyå¯¹åº”çš„å€¼
readä¸­æ²¡æœ‰keyï¼Œä½†æ˜¯dirtyä¸­å­˜åœ¨è¿™ä¸ªkeyï¼Œç›´æ¥ä¿®æ”¹dirtyä¸­keyçš„å€¼
readå’Œdirtyä¸­éƒ½æ²¡æœ‰å€¼ï¼Œå…ˆåˆ¤æ–­è‡ªä»readä¸Šæ¬¡åŒæ­¥dirtyçš„å†…å®¹åæœ‰æ²¡æœ‰å†ä¿®æ”¹è¿‡dirtyçš„å†…å®¹ï¼Œæ²¡æœ‰çš„è¯ï¼Œå…ˆåŒæ­¥readå’Œdirtyçš„å€¼ï¼Œç„¶åæ·»åŠ æ–°çš„key valueåˆ°dirtyä¸Šé¢</p>

<p>å½“å‡ºç°ç¬¬å››ç§æƒ…å†µçš„æ—¶å€™ï¼Œå¾ˆå®¹æ˜“äº§ç”Ÿä¸€ä¸ªå›°æƒ‘ï¼šæ—¢ç„¶read.amended == falseï¼Œè¡¨ç¤ºæ•°æ®æ²¡æœ‰ä¿®æ”¹ï¼Œä¸ºä»€ä¹ˆè¿˜è¦å°†readçš„æ•°æ®åŒæ­¥åˆ°dirtyé‡Œé¢å‘¢ï¼Ÿ
è¿™ä¸ªç­”æ¡ˆåœ¨Load å‡½æ•°é‡Œé¢ä¼šæœ‰ç­”æ¡ˆï¼Œå› ä¸ºï¼ŒreadåŒæ­¥dirtyçš„æ•°æ®çš„æ—¶å€™ï¼Œæ˜¯ç›´æ¥æŠŠdirtyæŒ‡å‘mapçš„æŒ‡é’ˆäº¤ç»™äº†read.mï¼Œç„¶åå°†dirtyçš„æŒ‡é’ˆè®¾ç½®ä¸ºnilï¼Œæ‰€ä»¥ï¼ŒåŒæ­¥ä¹‹åï¼Œdirtyå°±ä¸ºnil
ä¸‹é¢çœ‹çœ‹å…·ä½“çš„å®ç°
3.2. è¯»å–ï¼ˆLoadï¼‰
func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
	read, _ := m.read.Load().(readOnly)
	e, ok := read.m[key]
  // å¦‚æœreadçš„mapä¸­æ²¡æœ‰ï¼Œä¸”å­˜åœ¨ä¿®æ”¹
	if !ok &amp;&amp; read.amended {
		m.mu.Lock()
		// Avoid reporting a spurious miss if m.dirty got promoted while we were
		// blocked on m.mu. (If further loads of the same key will not miss, itâ€™s
		// not worth copying the dirty map for this key.)
    // å†æŸ¥æ‰¾ä¸€æ¬¡ï¼Œæœ‰å¯èƒ½åˆšåˆšå°†dirtyå‡çº§ä¸ºreadäº†
		read, _ = m.read.Load().(readOnly)
		e, ok = read.m[key]
		if !ok &amp;&amp; read.amended {
      // å¦‚æœamended è¿˜æ˜¯å¤„äºä¿®æ”¹çŠ¶æ€ï¼Œåˆ™å»dirtyä¸­æŸ¥æ‰¾
			e, ok = m.dirty[key]
			// Regardless of whether the entry was present, record a miss: this key
			// will take the slow path until the dirty map is promoted to the read
			// map.
      // å¢åŠ missesçš„è®¡æ•°ï¼Œåœ¨è®¡æ•°è¾¾åˆ°ä¸€å®šè§„åˆ™çš„æ—¶å€™ï¼Œè§¦å‘å‡çº§dirtyä¸ºread
			m.missLocked()
		}
		m.mu.Unlock()
	}
  // read dirtyä¸­éƒ½æ²¡æœ‰æ‰¾åˆ°
	if !ok {
		return nil, false
	}
  // æ‰¾åˆ°äº†ï¼Œé€šè¿‡loadåˆ¤æ–­å…·ä½“è¿”å›å†…å®¹
	return e.load()
}</p>

<p>func (e <em>entry) load() (value interface{}, ok bool) {
	p := atomic.LoadPointer(&amp;e.p)
  // å¦‚æœpä¸ºnilæˆ–è€…expungedæ ‡è¯†ï¼Œåˆ™keyä¸å­˜åœ¨
	if p == nil || p == expunged {
		return nil, false
	}
	return *(</em>interface{})(p), true
}
å¤åˆ¶ä»£ç ä¸ºä»€ä¹ˆæ‰¾åˆ°äº†pï¼Œä½†æ˜¯på¯¹åº”çš„å€¼ä¸ºnilå‘¢ï¼Ÿè¿™ä¸ªç­”æ¡ˆåœ¨åé¢è§£æDeleteå‡½æ•°çš„æ—¶å€™ä¼šè¢«æ­æ™“
3.2.1. missLocked
func (m *Map) missLocked() {
	m.misses++
	if m.misses &lt; len(m.dirty) {
		return
	}
  // ç›´æ¥æŠŠdirtyçš„æŒ‡é’ˆç»™read.mï¼Œå¹¶ä¸”è®¾ç½®dirtyä¸ºnilï¼Œè¿™é‡Œä¹Ÿå°±æ˜¯ Store å‡½æ•°çš„æœ€åä¼šè°ƒç”¨ m.dirtyLockedçš„åŸå› 
	m.read.Store(readOnly{m: m.dirty})
	m.dirty = nil
	m.misses = 0
}
å¤åˆ¶ä»£ç 3.3. åˆ é™¤ï¼ˆDeleteï¼‰
è¿™é‡Œçš„åˆ é™¤å¹¶ä¸æ˜¯ç®€å•çš„å°†keyä»mapä¸­åˆ é™¤
func (m *Map) Delete(key interface{}) {
	read, _ := m.read.Load().(readOnly)
	e, ok := read.m[key]
  // readä¸­æ²¡æœ‰è¿™ä¸ªkeyï¼Œä½†æ˜¯Mapè¢«æ ‡è¯†ä¿®æ”¹äº†ï¼Œé‚£ä¹ˆå»dirtyé‡Œé¢çœ‹çœ‹
	if !ok &amp;&amp; read.amended {
		m.mu.Lock()
		read, _ = m.read.Load().(readOnly)
		e, ok = read.m[key]
		if !ok &amp;&amp; read.amended {
      // è°ƒç”¨deleteåˆ é™¤dirtyçš„mapï¼Œdeleteä¼šåˆ¤æ–­keyæ˜¯å¦å­˜åœ¨çš„
			delete(m.dirty, key)
		}
		m.mu.Unlock()
	}
  // å¦‚æœreadä¸­å­˜åœ¨ï¼Œåˆ™å‡åˆ é™¤
	if ok {
		e.delete()
	}
}</p>

<p>func (e *entry) delete() (hadValue bool) {
	for {
		p := atomic.LoadPointer(&amp;e.p)
    // å·²ç»æ˜¯è¢«åˆ é™¤äº†ï¼Œä¸éœ€è¦ç®¡äº†
		if p == nil || p == expunged {
			return false
		}
    // åŸå­æ€§ å°†keyçš„å€¼è®¾ç½®ä¸ºnil
		if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
			return true
		}
	}
}
å¤åˆ¶ä»£ç æ ¹æ®ä¸Šé¢çš„é€»è¾‘å¯ä»¥çœ‹å‡ºï¼Œåˆ é™¤çš„æ—¶å€™ï¼Œå­˜åœ¨ä»¥ä¸‹å‡ ç§æƒ…å†µ</p>

<p>readä¸­æ²¡æœ‰ï¼Œä¸”Mapå­˜åœ¨ä¿®æ”¹ï¼Œåˆ™å°è¯•åˆ é™¤dirtyä¸­çš„mapä¸­çš„key
readä¸­æ²¡æœ‰ï¼Œä¸”Mapä¸å­˜åœ¨ä¿®æ”¹ï¼Œé‚£å°±æ˜¯æ²¡æœ‰è¿™ä¸ªkeyï¼Œæ— éœ€æ“ä½œ
readä¸­æœ‰ï¼Œå°è¯•å°†keyå¯¹åº”çš„å€¼è®¾ç½®ä¸ºnilï¼Œåé¢è¯»å–çš„æ—¶å€™å°±çŸ¥é“è¢«åˆ äº†ï¼Œå› ä¸ºdirtyä¸­mapçš„å€¼è·Ÿreadçš„mapä¸­çš„å€¼æŒ‡å‘çš„éƒ½æ˜¯åŒä¸€ä¸ªåœ°å€ç©ºé—´ï¼Œæ‰€ä»¥ï¼Œä¿®æ”¹äº†readä¹Ÿå°±æ˜¯ä¿®æ”¹äº†dirty</p>

<p>3.3. éå†ï¼ˆRangeï¼‰
éå†çš„é€»è¾‘å°±æ¯”è¾ƒç®€å•äº†ï¼ŒMapåªæœ‰ä¸¤ç§çŠ¶æ€ï¼Œè¢«ä¿®æ”¹è¿‡å’Œæ²¡æœ‰ä¿®æ”¹è¿‡
ä¿®æ”¹è¿‡ï¼šå°†dirtyçš„æŒ‡é’ˆäº¤ç»™readï¼Œreadå°±æ˜¯æœ€æ–°çš„æ•°æ®äº†ï¼Œç„¶åéå†readçš„map
æ²¡æœ‰ä¿®æ”¹è¿‡ï¼šéå†readçš„mapå°±å¥½äº†
func (m *Map) Range(f func(key, value interface{}) bool) {
	read, _ := m.read.Load().(readOnly)
	if read.amended {
		m.mu.Lock()
		read, _ = m.read.Load().(readOnly)
		if read.amended {
			read = readOnly{m: m.dirty}
			m.read.Store(read)
			m.dirty = nil
			m.misses = 0
		}
		m.mu.Unlock()
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for k, e := range read.m {
	v, ok := e.load()
	if !ok {
		continue
	}
	if !f(k, v) {
		break
	}
} } å¤åˆ¶ä»£ç 3.4. é€‚ç”¨åœºæ™¯ åœ¨å®˜æ–¹ä»‹ç»çš„æ—¶å€™ï¼Œä¹Ÿå¯¹é€‚ç”¨åœºæ™¯åšäº†è¯´æ˜
</code></pre></div></div>

<p>The Map type is optimized for two common use cases:
(1) when the entry for a given key is only ever written once but read many times, as in caches that only grow,
(2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys.
In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate Mutex or RWMutex.</p>

<p>é€šè¿‡å¯¹æºç çš„åˆ†ææ¥ç†è§£ä¸€ä¸‹äº§ç”Ÿè¿™ä¸¤æ¡è§„åˆ™çš„åŸå› ï¼š
è¯»å¤šå†™å°‘ï¼šè¯»å¤šå†™å°‘çš„ç¯å¢ƒä¸‹ï¼Œéƒ½æ˜¯ä»readçš„mapå»è¯»å–ï¼Œä¸éœ€è¦åŠ é”ï¼Œè€Œå†™å¤šè¯»å°‘çš„æƒ…å†µä¸‹ï¼Œéœ€è¦åŠ é”ï¼Œå…¶æ¬¡ï¼Œå­˜åœ¨å°†readæ•°æ®åŒæ­¥åˆ°dirtyçš„æ“ä½œçš„å¯èƒ½æ€§ï¼Œå¤§é‡çš„æ‹·è´æ“ä½œä¼šå¤§å¤§çš„é™ä½æ€§èƒ½
è¯»å†™ä¸åŒçš„keyï¼šsync.Mapæ˜¯é’ˆå¯¹keyçš„å€¼çš„åŸå­æ“ä½œï¼Œç›¸å½“äºåŠ é”åŠ è½½ keyä¸Šï¼Œæ‰€ä»¥ï¼Œå¤šä¸ªkeyçš„è¯»å†™æ˜¯å¯ä»¥åŒæ—¶å¹¶å‘çš„</p>

<p>åœ¨Go 1.6ä¹‹å‰ï¼Œ å†…ç½®çš„mapç±»å‹æ˜¯éƒ¨åˆ†goroutineå®‰å…¨çš„ï¼Œå¹¶å‘çš„è¯»æ²¡æœ‰é—®é¢˜ï¼Œå¹¶å‘çš„å†™å¯èƒ½æœ‰é—®é¢˜ã€‚è‡ªgo 1.6ä¹‹åï¼Œ å¹¶å‘åœ°è¯»å†™mapä¼šæŠ¥é”™ï¼Œè¿™åœ¨ä¸€äº›çŸ¥åçš„å¼€æºåº“ä¸­éƒ½å­˜åœ¨è¿™ä¸ªé—®é¢˜ï¼Œæ‰€ä»¥go 1.9ä¹‹å‰çš„è§£å†³æ–¹æ¡ˆæ˜¯é¢å¤–ç»‘å®šä¸€ä¸ªé”ï¼Œå°è£…æˆä¸€ä¸ªæ–°çš„structæˆ–è€…å•ç‹¬ä½¿ç”¨é”éƒ½å¯ä»¥ã€‚</p>

<p>æœ¬æ–‡å¸¦ä½ æ·±å…¥åˆ°sync.Mapçš„å…·ä½“å®ç°ä¸­ï¼Œçœ‹çœ‹ä¸ºäº†å¢åŠ ä¸€ä¸ªåŠŸèƒ½ï¼Œä»£ç æ˜¯å¦‚ä½•å˜çš„å¤æ‚çš„,ä»¥åŠä½œè€…åœ¨å®ç°sync.Mapçš„ä¸€äº›æ€æƒ³ã€‚</p>

<p>æœ‰å¹¶å‘é—®é¢˜çš„map
å®˜æ–¹çš„faqå·²ç»æåˆ°å†…å»ºçš„mapä¸æ˜¯çº¿ç¨‹(goroutine)å®‰å…¨çš„ã€‚</p>

<p>é¦–å…ˆï¼Œè®©æˆ‘ä»¬çœ‹ä¸€æ®µå¹¶å‘è¯»å†™çš„ä»£ç ,ä¸‹åˆ—ç¨‹åºä¸­ä¸€ä¸ªgoroutineä¸€ç›´è¯»ï¼Œä¸€ä¸ªgoroutineä¸€åªå†™åŒä¸€ä¸ªé”®å€¼ï¼Œå³å³ä½¿è¯»å†™çš„é”®ä¸ç›¸åŒï¼Œè€Œä¸”mapä¹Ÿæ²¡æœ‰â€æ‰©å®¹â€ç­‰æ“ä½œï¼Œä»£ç è¿˜æ˜¯ä¼šæŠ¥é”™ã€‚</p>

<p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
package main
func main() {
	m := make(map[int]int)
	go func() {
		for {
			_ = m[1]
		}
	}()
	go func() {
		for {
			m[2] = 2
		}
	}()
	select {}
}
é”™è¯¯ä¿¡æ¯æ˜¯: fatal error: concurrent map read and map writeã€‚</p>

<p>å¦‚æœä½ æŸ¥çœ‹Goçš„æºä»£ç : hashmap_fast.go#L118,ä¼šçœ‹åˆ°è¯»çš„æ—¶å€™ä¼šæ£€æŸ¥hashWritingæ ‡å¿—ï¼Œ å¦‚æœæœ‰è¿™ä¸ªæ ‡å¿—ï¼Œå°±ä¼šæŠ¥å¹¶å‘é”™è¯¯ã€‚</p>

<p>å†™çš„æ—¶å€™ä¼šè®¾ç½®è¿™ä¸ªæ ‡å¿—: hashmap.go#L542</p>

<p>1
h.flags |= hashWriting
hashmap.go#L628è®¾ç½®å®Œä¹‹åä¼šå–æ¶ˆè¿™ä¸ªæ ‡è®°ã€‚</p>

<p>å½“ç„¶ï¼Œä»£ç ä¸­è¿˜æœ‰å¥½å‡ å¤„å¹¶å‘è¯»å†™çš„æ£€æŸ¥ï¼Œ æ¯”å¦‚å†™çš„æ—¶å€™ä¹Ÿä¼šæ£€æŸ¥æ˜¯ä¸æ˜¯æœ‰å¹¶å‘çš„å†™ï¼Œåˆ é™¤é”®çš„æ—¶å€™ç±»ä¼¼å†™ï¼Œéå†çš„æ—¶å€™å¹¶å‘è¯»å†™é—®é¢˜ç­‰ã€‚</p>

<p>æœ‰æ—¶å€™ï¼Œmapçš„å¹¶å‘é—®é¢˜ä¸æ˜¯é‚£ä¹ˆå®¹æ˜“è¢«å‘ç°, ä½ å¯ä»¥åˆ©ç”¨-raceå‚æ•°æ¥æ£€æŸ¥ã€‚</p>

<p>Go 1.9ä¹‹å‰çš„è§£å†³æ–¹æ¡ˆ
ä½†æ˜¯ï¼Œå¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬ä¼šå¹¶å‘åœ°ä½¿ç”¨mapå¯¹è±¡ï¼Œå°¤å…¶æ˜¯åœ¨ä¸€å®šè§„æ¨¡çš„é¡¹ç›®ä¸­ï¼Œmapæ€»ä¼šä¿å­˜goroutineå…±äº«çš„æ•°æ®ã€‚åœ¨Goå®˜æ–¹blogçš„Go maps in actionä¸€æ–‡ä¸­ï¼Œæä¾›äº†ä¸€ç§ç®€ä¾¿çš„è§£å†³æ–¹æ¡ˆã€‚</p>

<p>1
2
3
4
var counter = struct{
    sync.RWMutex
    m map[string]int
}{m: make(map[string]int)}
å®ƒä½¿ç”¨åµŒå…¥structä¸ºmapå¢åŠ ä¸€ä¸ªè¯»å†™é”ã€‚</p>

<p>è¯»æ•°æ®çš„æ—¶å€™å¾ˆæ–¹ä¾¿çš„åŠ é”ï¼š</p>

<p>1
2
3
4
counter.RLock()
n := counter.m[â€œsome_keyâ€]
counter.RUnlock()
fmt.Println(â€œsome_key:â€, n)
å†™æ•°æ®çš„æ—¶å€™:</p>

<p>1
2
3
counter.Lock()
counter.m[â€œsome_keyâ€]++
counter.Unlock()
sync.Map
å¯ä»¥è¯´ï¼Œä¸Šé¢çš„è§£å†³æ–¹æ¡ˆç›¸å½“ç®€æ´ï¼Œå¹¶ä¸”åˆ©ç”¨è¯»å†™é”è€Œä¸æ˜¯Mutexå¯ä»¥è¿›ä¸€æ­¥å‡å°‘è¯»å†™çš„æ—¶å€™å› ä¸ºé”å¸¦æ¥çš„æ€§èƒ½ã€‚</p>

<p>ä½†æ˜¯ï¼Œå®ƒåœ¨ä¸€äº›åœºæ™¯ä¸‹ä¹Ÿæœ‰é—®é¢˜ï¼Œå¦‚æœç†Ÿæ‚‰Javaçš„åŒå­¦ï¼Œå¯ä»¥å¯¹æ¯”ä¸€ä¸‹javaçš„ConcurrentHashMapçš„å®ç°ï¼Œåœ¨mapçš„æ•°æ®éå¸¸å¤§çš„æƒ…å†µä¸‹ï¼Œä¸€æŠŠé”ä¼šå¯¼è‡´å¤§å¹¶å‘çš„å®¢æˆ·ç«¯å…±äº‰ä¸€æŠŠé”ï¼ŒJavaçš„è§£å†³æ–¹æ¡ˆæ˜¯shard, å†…éƒ¨ä½¿ç”¨å¤šä¸ªé”ï¼Œæ¯ä¸ªåŒºé—´å…±äº«ä¸€æŠŠé”ï¼Œè¿™æ ·å‡å°‘äº†æ•°æ®å…±äº«ä¸€æŠŠé”å¸¦æ¥çš„æ€§èƒ½å½±å“ï¼Œorcamanæä¾›äº†è¿™ä¸ªæ€è·¯çš„ä¸€ä¸ªå®ç°ï¼š concurrent-mapï¼Œä»–ä¹Ÿè¯¢é—®äº†Goç›¸å…³çš„å¼€å‘äººå‘˜æ˜¯å¦åœ¨Goä¸­ä¹Ÿå®ç°è¿™ç§æ–¹æ¡ˆï¼Œç”±äºå®ç°çš„å¤æ‚æ€§ï¼Œç­”æ¡ˆæ˜¯Yes, we considered it.,ä½†æ˜¯é™¤éæœ‰ç‰¹åˆ«çš„æ€§èƒ½æå‡å’Œåº”ç”¨åœºæ™¯ï¼Œå¦åˆ™æ²¡æœ‰è¿›ä¸€æ­¥çš„å¼€å‘æ¶ˆæ¯ã€‚</p>

<p>é‚£ä¹ˆï¼Œåœ¨Go 1.9ä¸­sync.Mapæ˜¯æ€ä¹ˆå®ç°çš„å‘¢ï¼Ÿå®ƒæ˜¯å¦‚ä½•è§£å†³å¹¶å‘æå‡æ€§èƒ½çš„å‘¢ï¼Ÿ</p>

<p>sync.Mapçš„å®ç°æœ‰å‡ ä¸ªä¼˜åŒ–ç‚¹ï¼Œè¿™é‡Œå…ˆåˆ—å‡ºæ¥ï¼Œæˆ‘ä»¬åé¢æ…¢æ…¢åˆ†æã€‚</p>

<p>ç©ºé—´æ¢æ—¶é—´ã€‚ é€šè¿‡å†—ä½™çš„ä¸¤ä¸ªæ•°æ®ç»“æ„(readã€dirty),å®ç°åŠ é”å¯¹æ€§èƒ½çš„å½±å“ã€‚
ä½¿ç”¨åªè¯»æ•°æ®(read)ï¼Œé¿å…è¯»å†™å†²çªã€‚
åŠ¨æ€è°ƒæ•´ï¼Œmissæ¬¡æ•°å¤šäº†ä¹‹åï¼Œå°†dirtyæ•°æ®æå‡ä¸ºreadã€‚
double-checkingã€‚
å»¶è¿Ÿåˆ é™¤ã€‚ åˆ é™¤ä¸€ä¸ªé”®å€¼åªæ˜¯æ‰“æ ‡è®°ï¼Œåªæœ‰åœ¨æå‡dirtyçš„æ—¶å€™æ‰æ¸…ç†åˆ é™¤çš„æ•°æ®ã€‚
ä¼˜å…ˆä»readè¯»å–ã€æ›´æ–°ã€åˆ é™¤ï¼Œå› ä¸ºå¯¹readçš„è¯»å–ä¸éœ€è¦é”ã€‚
ä¸‹é¢æˆ‘ä»¬ä»‹ç»sync.Mapçš„é‡ç‚¹ä»£ç ï¼Œä»¥ä¾¿ç†è§£å®ƒçš„å®ç°æ€æƒ³ã€‚</p>

<p>é¦–å…ˆï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹sync.Mapçš„æ•°æ®ç»“æ„ï¼š</p>

<p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
type Map struct {
	// å½“æ¶‰åŠåˆ°dirtyæ•°æ®çš„æ“ä½œçš„æ—¶å€™ï¼Œéœ€è¦ä½¿ç”¨è¿™ä¸ªé”
	mu Mutex
	// ä¸€ä¸ªåªè¯»çš„æ•°æ®ç»“æ„ï¼Œå› ä¸ºåªè¯»ï¼Œæ‰€ä»¥ä¸ä¼šæœ‰è¯»å†™å†²çªã€‚
	// æ‰€ä»¥ä»è¿™ä¸ªæ•°æ®ä¸­è¯»å–æ€»æ˜¯å®‰å…¨çš„ã€‚
	// å®é™…ä¸Šï¼Œå®é™…ä¹Ÿä¼šæ›´æ–°è¿™ä¸ªæ•°æ®çš„entries,å¦‚æœentryæ˜¯æœªåˆ é™¤çš„(unexpunged), å¹¶ä¸éœ€è¦åŠ é”ã€‚å¦‚æœentryå·²ç»è¢«åˆ é™¤äº†ï¼Œéœ€è¦åŠ é”ï¼Œä»¥ä¾¿æ›´æ–°dirtyæ•°æ®ã€‚
	read atomic.Value // readOnly
	// dirtyæ•°æ®åŒ…å«å½“å‰çš„mapåŒ…å«çš„entries,å®ƒåŒ…å«æœ€æ–°çš„entries(åŒ…æ‹¬readä¸­æœªåˆ é™¤çš„æ•°æ®,è™½æœ‰å†—ä½™ï¼Œä½†æ˜¯æå‡dirtyå­—æ®µä¸ºreadçš„æ—¶å€™éå¸¸å¿«ï¼Œä¸ç”¨ä¸€ä¸ªä¸€ä¸ªçš„å¤åˆ¶ï¼Œè€Œæ˜¯ç›´æ¥å°†è¿™ä¸ªæ•°æ®ç»“æ„ä½œä¸ºreadå­—æ®µçš„ä¸€éƒ¨åˆ†),æœ‰äº›æ•°æ®è¿˜å¯èƒ½æ²¡æœ‰ç§»åŠ¨åˆ°readå­—æ®µä¸­ã€‚
	// å¯¹äºdirtyçš„æ“ä½œéœ€è¦åŠ é”ï¼Œå› ä¸ºå¯¹å®ƒçš„æ“ä½œå¯èƒ½ä¼šæœ‰è¯»å†™ç«äº‰ã€‚
	// å½“dirtyä¸ºç©ºçš„æ—¶å€™ï¼Œ æ¯”å¦‚åˆå§‹åŒ–æˆ–è€…åˆšæå‡å®Œï¼Œä¸‹ä¸€æ¬¡çš„å†™æ“ä½œä¼šå¤åˆ¶readå­—æ®µä¸­æœªåˆ é™¤çš„æ•°æ®åˆ°è¿™ä¸ªæ•°æ®ä¸­ã€‚
	dirty map[interface{}]*entry
	// å½“ä»Mapä¸­è¯»å–entryçš„æ—¶å€™ï¼Œå¦‚æœreadä¸­ä¸åŒ…å«è¿™ä¸ªentry,ä¼šå°è¯•ä»dirtyä¸­è¯»å–ï¼Œè¿™ä¸ªæ—¶å€™ä¼šå°†missesåŠ ä¸€ï¼Œ
	// å½“missesç´¯ç§¯åˆ° dirtyçš„é•¿åº¦çš„æ—¶å€™ï¼Œ å°±ä¼šå°†dirtyæå‡ä¸ºread,é¿å…ä»dirtyä¸­misså¤ªå¤šæ¬¡ã€‚å› ä¸ºæ“ä½œdirtyéœ€è¦åŠ é”ã€‚
	misses int
}
å®ƒçš„æ•°æ®ç»“æ„å¾ˆç®€å•ï¼Œå€¼åŒ…å«å››ä¸ªå­—æ®µï¼šreadã€muã€dirtyã€missesã€‚</p>

<p>å®ƒä½¿ç”¨äº†å†—ä½™çš„æ•°æ®ç»“æ„readã€dirtyã€‚dirtyä¸­ä¼šåŒ…å«readä¸­ä¸ºåˆ é™¤çš„entriesï¼Œæ–°å¢åŠ çš„entriesä¼šåŠ å…¥åˆ°dirtyä¸­ã€‚</p>

<p>readçš„æ•°æ®ç»“æ„æ˜¯ï¼š</p>

<p>1
2
3
4
type readOnly struct {
	m       map[interface{}]*entry
	amended bool // å¦‚æœMap.dirtyæœ‰äº›æ•°æ®ä¸åœ¨ä¸­çš„æ—¶å€™ï¼Œè¿™ä¸ªå€¼ä¸ºtrue
}
amendedæŒ‡æ˜Map.dirtyä¸­æœ‰readOnly.mæœªåŒ…å«çš„æ•°æ®ï¼Œæ‰€ä»¥å¦‚æœä»Map.readæ‰¾ä¸åˆ°æ•°æ®çš„è¯ï¼Œè¿˜è¦è¿›ä¸€æ­¥åˆ°Map.dirtyä¸­æŸ¥æ‰¾ã€‚</p>

<p>å¯¹Map.readçš„ä¿®æ”¹æ˜¯é€šè¿‡åŸå­æ“ä½œè¿›è¡Œçš„ã€‚</p>

<p>è™½ç„¶readå’Œdirtyæœ‰å†—ä½™æ•°æ®ï¼Œä½†è¿™äº›æ•°æ®æ˜¯é€šè¿‡æŒ‡é’ˆæŒ‡å‘åŒä¸€ä¸ªæ•°æ®ï¼Œæ‰€ä»¥å°½ç®¡Mapçš„valueä¼šå¾ˆå¤§ï¼Œä½†æ˜¯å†—ä½™çš„ç©ºé—´å ç”¨è¿˜æ˜¯æœ‰é™çš„ã€‚</p>

<p>readOnly.må’ŒMap.dirtyå­˜å‚¨çš„å€¼ç±»å‹æ˜¯*entry,å®ƒåŒ…å«ä¸€ä¸ªæŒ‡é’ˆp, æŒ‡å‘ç”¨æˆ·å­˜å‚¨çš„valueå€¼ã€‚</p>

<p>1
2
3
type entry struct {
	p unsafe.Pointer // *interface{}
}
pæœ‰ä¸‰ç§å€¼ï¼š</p>

<p>nil: entryå·²è¢«åˆ é™¤äº†ï¼Œå¹¶ä¸”m.dirtyä¸ºnil
expunged: entryå·²è¢«åˆ é™¤äº†ï¼Œå¹¶ä¸”m.dirtyä¸ä¸ºnilï¼Œè€Œä¸”è¿™ä¸ªentryä¸å­˜åœ¨äºm.dirtyä¸­
å…¶å®ƒï¼š entryæ˜¯ä¸€ä¸ªæ­£å¸¸çš„å€¼
ä»¥ä¸Šæ˜¯sync.Mapçš„æ•°æ®ç»“æ„ï¼Œä¸‹é¢æˆ‘ä»¬é‡ç‚¹çœ‹çœ‹Loadã€Storeã€Deleteã€Rangeè¿™å››ä¸ªæ–¹æ³•ï¼Œå…¶å®ƒè¾…åŠ©æ–¹æ³•å¯ä»¥å‚è€ƒè¿™å››ä¸ªæ–¹æ³•æ¥ç†è§£ã€‚</p>

<p>Load
åŠ è½½æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯æä¾›ä¸€ä¸ªé”®key,æŸ¥æ‰¾å¯¹åº”çš„å€¼value,å¦‚æœä¸å­˜åœ¨ï¼Œé€šè¿‡okåæ˜ ï¼š</p>

<p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
func (m *Map) Load(key interface{}) (value interface{}, ok bool) {
	// 1.é¦–å…ˆä»m.readä¸­å¾—åˆ°åªè¯»readOnly,ä»å®ƒçš„mapä¸­æŸ¥æ‰¾ï¼Œä¸éœ€è¦åŠ é”
	read, _ := m.read.Load().(readOnly)
	e, ok := read.m[key]
	// 2. å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå¹¶ä¸”m.dirtyä¸­æœ‰æ–°æ•°æ®ï¼Œéœ€è¦ä»m.dirtyæŸ¥æ‰¾ï¼Œè¿™ä¸ªæ—¶å€™éœ€è¦åŠ é”
	if !ok &amp;&amp; read.amended {
		m.mu.Lock()
		// åŒæ£€æŸ¥ï¼Œé¿å…åŠ é”çš„æ—¶å€™m.dirtyæå‡ä¸ºm.read,è¿™ä¸ªæ—¶å€™m.readå¯èƒ½è¢«æ›¿æ¢äº†ã€‚
		read, _ = m.read.Load().(readOnly)
		e, ok = read.m[key]
		// å¦‚æœm.readä¸­è¿˜æ˜¯ä¸å­˜åœ¨ï¼Œå¹¶ä¸”m.dirtyä¸­æœ‰æ–°æ•°æ®
		if !ok &amp;&amp; read.amended {
			// ä»m.dirtyæŸ¥æ‰¾
			e, ok = m.dirty[key]
			// ä¸ç®¡m.dirtyä¸­å­˜ä¸å­˜åœ¨ï¼Œéƒ½å°†missesè®¡æ•°åŠ ä¸€
			// missLocked()ä¸­æ»¡è¶³æ¡ä»¶åå°±ä¼šæå‡m.dirty
			m.missLocked()
		}
		m.mu.Unlock()
	}
	if !ok {
		return nil, false
	}
	return e.load()
}
è¿™é‡Œæœ‰ä¸¤ä¸ªå€¼çš„å…³æ³¨çš„åœ°æ–¹ã€‚ä¸€ä¸ªæ˜¯é¦–å…ˆä»m.readä¸­åŠ è½½ï¼Œä¸å­˜åœ¨çš„æƒ…å†µä¸‹ï¼Œå¹¶ä¸”m.dirtyä¸­æœ‰æ–°æ•°æ®ï¼ŒåŠ é”ï¼Œç„¶åä»m.dirtyä¸­åŠ è½½ã€‚</p>

<p>äºŒæ˜¯è¿™é‡Œä½¿ç”¨äº†åŒæ£€æŸ¥çš„å¤„ç†ï¼Œå› ä¸ºåœ¨ä¸‹é¢çš„ä¸¤ä¸ªè¯­å¥ä¸­ï¼Œè¿™ä¸¤è¡Œè¯­å¥å¹¶ä¸æ˜¯ä¸€ä¸ªåŸå­æ“ä½œã€‚</p>

<p>1
2
if !ok &amp;&amp; read.amended {
		m.mu.Lock()
è™½ç„¶ç¬¬ä¸€å¥æ‰§è¡Œçš„æ—¶å€™æ¡ä»¶æ»¡è¶³ï¼Œä½†æ˜¯åœ¨åŠ é”ä¹‹å‰ï¼Œm.dirtyå¯èƒ½è¢«æå‡ä¸ºm.read,æ‰€ä»¥åŠ é”åè¿˜å¾—å†æ£€æŸ¥m.readï¼Œåç»­çš„æ–¹æ³•ä¸­éƒ½ä½¿ç”¨äº†è¿™ä¸ªæ–¹æ³•ã€‚</p>

<p>åŒæ£€æŸ¥çš„æŠ€æœ¯Javaç¨‹åºå‘˜éå¸¸ç†Ÿæ‚‰äº†ï¼Œå•ä¾‹æ¨¡å¼çš„å®ç°ä¹‹ä¸€å°±æ˜¯åˆ©ç”¨åŒæ£€æŸ¥çš„æŠ€æœ¯ã€‚</p>

<p>å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœæˆ‘ä»¬æŸ¥è¯¢çš„é”®å€¼æ­£å¥½å­˜åœ¨äºm.readä¸­ï¼Œæ— é¡»åŠ é”ï¼Œç›´æ¥è¿”å›ï¼Œç†è®ºä¸Šæ€§èƒ½ä¼˜å¼‚ã€‚å³ä½¿ä¸å­˜åœ¨äºm.readä¸­ï¼Œç»è¿‡misså‡ æ¬¡ä¹‹åï¼Œm.dirtyä¼šè¢«æå‡ä¸ºm.readï¼Œåˆä¼šä»m.readä¸­æŸ¥æ‰¾ã€‚æ‰€ä»¥å¯¹äºæ›´æ–°ï¼å¢åŠ è¾ƒå°‘ï¼ŒåŠ è½½å­˜åœ¨çš„keyå¾ˆå¤šçš„case,æ€§èƒ½åŸºæœ¬å’Œæ— é”çš„mapç±»ä¼¼ã€‚</p>

<p>ä¸‹é¢çœ‹çœ‹m.dirtyæ˜¯å¦‚ä½•è¢«æå‡çš„ã€‚ missLockedæ–¹æ³•ä¸­å¯èƒ½ä¼šå°†m.dirtyæå‡ã€‚</p>

<p>1
2
3
4
5
6
7
8
9
func (m *Map) missLocked() {
	m.misses++
	if m.misses &lt; len(m.dirty) {
		return
	}
	m.read.Store(readOnly{m: m.dirty})
	m.dirty = nil
	m.misses = 0
}
ä¸Šé¢çš„æœ€åä¸‰è¡Œä»£ç å°±æ˜¯æå‡m.dirtyçš„ï¼Œå¾ˆç®€å•çš„å°†m.dirtyä½œä¸ºreadOnlyçš„må­—æ®µï¼ŒåŸå­æ›´æ–°m.readã€‚æå‡åm.dirtyã€m.missesé‡ç½®ï¼Œ å¹¶ä¸”m.read.amendedä¸ºfalseã€‚</p>

<p>Store
è¿™ä¸ªæ–¹æ³•æ˜¯æ›´æ–°æˆ–è€…æ–°å¢ä¸€ä¸ªentryã€‚</p>

<p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
func (m <em>Map) Store(key, value interface{}) {
	// å¦‚æœm.readå­˜åœ¨è¿™ä¸ªé”®ï¼Œå¹¶ä¸”è¿™ä¸ªentryæ²¡æœ‰è¢«æ ‡è®°åˆ é™¤ï¼Œå°è¯•ç›´æ¥å­˜å‚¨ã€‚
	// å› ä¸ºm.dirtyä¹ŸæŒ‡å‘è¿™ä¸ªentry,æ‰€ä»¥m.dirtyä¹Ÿä¿æŒæœ€æ–°çš„entryã€‚
	read, _ := m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {
		return
	}
	// å¦‚æœ<code class="language-plaintext highlighter-rouge">m.read</code>ä¸å­˜åœ¨æˆ–è€…å·²ç»è¢«æ ‡è®°åˆ é™¤
	m.mu.Lock()
	read, _ = m.read.Load().(readOnly)
	if e, ok := read.m[key]; ok {
		if e.unexpungeLocked() { //æ ‡è®°æˆæœªè¢«åˆ é™¤
			m.dirty[key] = e //m.dirtyä¸­ä¸å­˜åœ¨è¿™ä¸ªé”®ï¼Œæ‰€ä»¥åŠ å…¥m.dirty
		}
		e.storeLocked(&amp;value) //æ›´æ–°
	} else if e, ok := m.dirty[key]; ok { // m.dirtyå­˜åœ¨è¿™ä¸ªé”®ï¼Œæ›´æ–°
		e.storeLocked(&amp;value)
	} else { //æ–°é”®å€¼
		if !read.amended { //m.dirtyä¸­æ²¡æœ‰æ–°çš„æ•°æ®ï¼Œå¾€m.dirtyä¸­å¢åŠ ç¬¬ä¸€ä¸ªæ–°é”®
			m.dirtyLocked() //ä»m.readä¸­å¤åˆ¶æœªåˆ é™¤çš„æ•°æ®
			m.read.Store(readOnly{m: read.m, amended: true})
		}
		m.dirty[key] = newEntry(value) //å°†è¿™ä¸ªentryåŠ å…¥åˆ°m.dirtyä¸­
	}
	m.mu.Unlock()
}
func (m *Map) dirtyLocked() {
	if m.dirty != nil {
		return
	}
	read, _ := m.read.Load().(readOnly)
	m.dirty = make(map[interface{}]</em>entry, len(read.m))
	for k, e := range read.m {
		if !e.tryExpungeLocked() {
			m.dirty[k] = e
		}
	}
}
func (e *entry) tryExpungeLocked() (isExpunged bool) {
	p := atomic.LoadPointer(&amp;e.p)
	for p == nil {
		// å°†å·²ç»åˆ é™¤æ ‡è®°ä¸ºnilçš„æ•°æ®æ ‡è®°ä¸ºexpunged
		if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {
			return true
		}
		p = atomic.LoadPointer(&amp;e.p)
	}
	return p == expunged
}
ä½ å¯ä»¥çœ‹åˆ°ï¼Œä»¥ä¸Šæ“ä½œéƒ½æ˜¯å…ˆä»æ“ä½œm.readå¼€å§‹çš„ï¼Œä¸æ»¡è¶³æ¡ä»¶å†åŠ é”ï¼Œç„¶åæ“ä½œm.dirtyã€‚</p>

<p>Storeå¯èƒ½ä¼šåœ¨æŸç§æƒ…å†µä¸‹(åˆå§‹åŒ–æˆ–è€…m.dirtyåˆšè¢«æå‡å)ä»m.readä¸­å¤åˆ¶æ•°æ®ï¼Œå¦‚æœè¿™ä¸ªæ—¶å€™m.readä¸­æ•°æ®é‡éå¸¸å¤§ï¼Œå¯èƒ½ä¼šå½±å“æ€§èƒ½ã€‚</p>

<p>Delete
åˆ é™¤ä¸€ä¸ªé”®å€¼ã€‚</p>

<p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
func (m *Map) Delete(key interface{}) {
	read, _ := m.read.Load().(readOnly)
	e, ok := read.m[key]
	if !ok &amp;&amp; read.amended {
		m.mu.Lock()
		read, _ = m.read.Load().(readOnly)
		e, ok = read.m[key]
		if !ok &amp;&amp; read.amended {
			delete(m.dirty, key)
		}
		m.mu.Unlock()
	}
	if ok {
		e.delete()
	}
}
åŒæ ·ï¼Œåˆ é™¤æ“ä½œè¿˜æ˜¯ä»m.readä¸­å¼€å§‹ï¼Œ å¦‚æœè¿™ä¸ªentryä¸å­˜åœ¨äºm.readä¸­ï¼Œå¹¶ä¸”m.dirtyä¸­æœ‰æ–°æ•°æ®ï¼Œåˆ™åŠ é”å°è¯•ä»m.dirtyä¸­åˆ é™¤ã€‚</p>

<p>æ³¨æ„ï¼Œè¿˜æ˜¯è¦åŒæ£€æŸ¥çš„ã€‚ ä»m.dirtyä¸­ç›´æ¥åˆ é™¤å³å¯ï¼Œå°±å½“å®ƒæ²¡å­˜åœ¨è¿‡ï¼Œä½†æ˜¯å¦‚æœæ˜¯ä»m.readä¸­åˆ é™¤ï¼Œå¹¶ä¸ä¼šç›´æ¥åˆ é™¤ï¼Œè€Œæ˜¯æ‰“æ ‡è®°ï¼š</p>

<p>1
2
3
4
5
6
7
8
9
10
11
12
13
func (e *entry) delete() (hadValue bool) {
	for {
		p := atomic.LoadPointer(&amp;e.p)
		// å·²æ ‡è®°ä¸ºåˆ é™¤
		if p == nil || p == expunged {
			return false
		}
		// åŸå­æ“ä½œï¼Œe.pæ ‡è®°ä¸ºnil
		if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {
			return true
		}
	}
}
Range
å› ä¸ºfor â€¦ range mapæ˜¯å†…å»ºçš„è¯­è¨€ç‰¹æ€§ï¼Œæ‰€ä»¥æ²¡æœ‰åŠæ³•ä½¿ç”¨for rangeéå†sync.Map, ä½†æ˜¯å¯ä»¥ä½¿ç”¨å®ƒçš„Rangeæ–¹æ³•ï¼Œé€šè¿‡å›è°ƒçš„æ–¹å¼éå†ã€‚</p>

<p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
func (m *Map) Range(f func(key, value interface{}) bool) {
	read, _ := m.read.Load().(readOnly)
	// å¦‚æœm.dirtyä¸­æœ‰æ–°æ•°æ®ï¼Œåˆ™æå‡m.dirty,ç„¶ååœ¨éå†
	if read.amended {
		//æå‡m.dirty
		m.mu.Lock()
		read, _ = m.read.Load().(readOnly) //åŒæ£€æŸ¥
		if read.amended {
			read = readOnly{m: m.dirty}
			m.read.Store(read)
			m.dirty = nil
			m.misses = 0
		}
		m.mu.Unlock()
	}
	// éå†, for rangeæ˜¯å®‰å…¨çš„
	for k, e := range read.m {
		v, ok := e.load()
		if !ok {
			continue
		}
		if !f(k, v) {
			break
		}
	}
}
Rangeæ–¹æ³•è°ƒç”¨å‰å¯èƒ½ä¼šåšä¸€ä¸ªm.dirtyçš„æå‡ï¼Œä¸è¿‡æå‡m.dirtyä¸æ˜¯ä¸€ä¸ªè€—æ—¶çš„æ“ä½œã€‚</p>

<p>sync.Mapçš„æ€§èƒ½
Go 1.9æºä»£ç ä¸­æä¾›äº†æ€§èƒ½çš„æµ‹è¯•ï¼š map_bench_test.goã€map_reference_test.go</p>

<p>æˆ‘ä¹ŸåŸºäºè¿™äº›ä»£ç ä¿®æ”¹äº†ä¸€ä¸‹ï¼Œå¾—åˆ°ä¸‹é¢çš„æµ‹è¯•æ•°æ®ï¼Œç›¸æ¯”è¾ƒä»¥å‰çš„è§£å†³æ–¹æ¡ˆï¼Œæ€§èƒ½å¤šå°‘å›æœ‰äº›æå‡ï¼Œå¦‚æœä½ ç‰¹åˆ«å…³æ³¨æ€§èƒ½ï¼Œå¯ä»¥è€ƒè™‘sync.Mapã€‚</p>

<p>1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
BenchmarkHitAll/<em>sync.RWMutexMap-4   	20000000	        83.8 ns/op
BenchmarkHitAll/</em>sync.Map-4          	30000000	        59.9 ns/op
BenchmarkHitAll_WithoutPrompting/<em>sync.RWMutexMap-4         	20000000	        96.9 ns/op
BenchmarkHitAll_WithoutPrompting/</em>sync.Map-4                	20000000	        64.1 ns/op
BenchmarkHitNone/<em>sync.RWMutexMap-4                         	20000000	        79.1 ns/op
BenchmarkHitNone/</em>sync.Map-4                                	30000000	        43.3 ns/op
BenchmarkHit_WithoutPrompting/<em>sync.RWMutexMap-4            	20000000	        81.5 ns/op
BenchmarkHit_WithoutPrompting/</em>sync.Map-4                   	30000000	        44.0 ns/op
BenchmarkUpdate/<em>sync.RWMutexMap-4                          	 5000000	       328 ns/op
BenchmarkUpdate/</em>sync.Map-4                                 	10000000	       146 ns/op
BenchmarkUpdate_WithoutPrompting/<em>sync.RWMutexMap-4         	 5000000	       336 ns/op
BenchmarkUpdate_WithoutPrompting/</em>sync.Map-4                	 5000000	       324 ns/op
BenchmarkDelete/<em>sync.RWMutexMap-4                          	10000000	       155 ns/op
BenchmarkDelete/</em>sync.Map-4                                 	30000000	        55.0 ns/op
BenchmarkDelete_WithoutPrompting/<em>sync.RWMutexMap-4         	10000000	       173 ns/op
BenchmarkDelete_WithoutPrompting/</em>sync.Map-4                	10000000	       147 ns/op
å…¶å®ƒ
sync.Mapæ²¡æœ‰Lenæ–¹æ³•ï¼Œå¹¶ä¸”ç›®å‰æ²¡æœ‰è¿¹è±¡è¦åŠ ä¸Š (issue#20680),æ‰€ä»¥å¦‚æœæƒ³å¾—åˆ°å½“å‰Mapä¸­æœ‰æ•ˆçš„entriesçš„æ•°é‡ï¼Œéœ€è¦ä½¿ç”¨Rangeæ–¹æ³•éå†ä¸€æ¬¡ï¼Œ æ¯”è¾ƒXç–¼ã€‚</p>

<p>LoadOrStoreæ–¹æ³•å¦‚æœæä¾›çš„keyå­˜åœ¨ï¼Œåˆ™è¿”å›å·²å­˜åœ¨çš„å€¼(Load)ï¼Œå¦åˆ™ä¿å­˜æä¾›çš„é”®å€¼(Store)ã€‚</p>

<p>æœ‰ä¸€ç‚¹æ²¡æœ‰çœ‹æ˜ç™½ï¼Œè¿˜è¯·å¤§å®¶å¸®å¿™è§£é‡Šä¸€ä¸‹ï¼š</p>

<p>å½“å‘mapä¸­æ’å…¥æ–°çš„ä¹‹å‰ä¸å­˜åœ¨çš„è®°å½•æ—¶ï¼Œä¼šå‘dirtyä¸­å†™å…¥è¿™ä¸ªè®°å½•ï¼ŒåŒæ—¶ä¼šå°†readä¸­æ²¡æœ‰åˆ é™¤çš„è®°å½•æ‹·è´åˆ°dirtyä¸­ã€‚å› ä¸ºåç»­å½“missæ¬¡æ•°è¿‡å¤šçš„æ—¶å€™ï¼Œdirtyä¼šæ›¿æ¢æ‰readã€‚</p>

<p>ä½†æ˜¯åœ¨deleteæ“ä½œçš„æ—¶å€™ï¼Œæˆ‘å‘ç°åªåˆ é™¤äº†readä¸­çš„å€¼ï¼Œæ²¡æœ‰å¯¹dirtyè¿›è¡Œå¤„ç†ã€‚è¿™æ ·å¦‚æœåç»­è¿›è¡Œmissåˆ‡æ¢çš„æ—¶å€™ï¼Œä¹‹å‰åˆ é™¤æ‰çš„å€¼ä¸æ˜¯å°±åˆå‡ºç°äº†å—ï¼Ÿ</p>

<p>å› ä¸ºreadå’ŒdirtyæŒ‡å‘åŒä¸€ä¸ªå…ƒç´ ã€‚ åœ¨readä¸­æ ‡è®°äº†ç›¸å½“äºåœ¨dirtyä¸­ä¹Ÿæ ‡è®°äº†</p>

<p>https://colobu.com/2017/07/11/dive-into-sync-Map/</p>
:ET