I"ÊJ<p>golangçš„webæ¡†æ¶echoå’Œginéƒ½ä½¿ç”¨äº†radix treeä½œä¸ºè·¯ç”±æŸ¥æ‰¾çš„ç®—æ³•
https://github.com/labstack/echo
https://github.com/gin-gonic/gin
<!-- more -->
åœ¨ginçš„è·¯ç”±ä¸­ï¼Œæ¯ä¸€ä¸ªHttp Method(GET, PUT, POSTâ€¦)éƒ½å¯¹åº”äº†ä¸€æ£µ radix tree</p>

<p>func (engine *Engine) addRoute(method, path string, handlers HandlersChain) {
    // â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// è·å–methodå¯¹åº”çš„æ ‘ï¼Œå¦‚æœæ²¡æœ‰å°±åˆ›å»º
root := engine.trees.get(method)
if root == nil {
    // åˆ›å»ºradix treeï¼Œåªæœ‰æ ¹èŠ‚ç‚¹
    root = new(node)
    engine.trees = append(engine.trees, methodTree{method: method, root: root})
}
root.addRoute(path, handlers) }
</code></pre></div></div>

<p>radix treeå¯ä»¥è¢«è®¤ä¸ºæ˜¯ä¸€æ£µç®€æ´ç‰ˆçš„å‰ç¼€æ ‘ã€‚æ‹¥æœ‰å…±åŒå‰ç¼€çš„èŠ‚ç‚¹ä¹Ÿå…±äº«åŒä¸€ä¸ªçˆ¶èŠ‚ç‚¹ã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªGETæ–¹æ³•å¯¹åº”çš„è·¯ç”±æ ‘çš„ç»“æ„ï¼š</p>

<p>Priority   Path             Handle
9          \                *&lt;1&gt;
3          â”œs               nil
2          |â”œearch\         *&lt;2&gt;
1          |â””upport\        *&lt;3&gt;
2          â”œblog\           *&lt;4&gt;
1          |    â””:post      nil
1          |         â””\     *&lt;5&gt;
2          â”œabout-us\       *&lt;6&gt;
1          |        â””team\  *&lt;7&gt;
1          â””contact\        *&lt;8&gt;
*<num>æ˜¯æ–¹æ³•ï¼ˆhandlerï¼‰å¯¹åº”çš„æŒ‡é’ˆï¼Œä»æ ¹èŠ‚ç‚¹éå†åˆ°å¶å­èŠ‚ç‚¹æˆ‘ä»¬å°±èƒ½å¾—åˆ°å®Œæ•´çš„è·¯ç”±è¡¨ï¼Œå›¾ä¸­çš„ç¤ºä¾‹å®ç°äº†ä»¥ä¸‹è·¯ç”±ï¼š</num></p>

<p>GET(â€œ/â€, func1)
GET(â€œ/search/â€, func2)
GET(â€œ/support/â€, func3)
GET(â€œ/blog/â€, func4)
GET(â€œ/blog/:post/â€, func5)
GET(â€œ/about-us/â€, func6)
GET(â€œ/about-us/team/â€, func7)
GET(â€œ/contact/â€, func8)
:postæ˜¯çœŸå®çš„post nameçš„ä¸€ä¸ªå ä½ç¬¦ï¼ˆå°±æ˜¯ä¸€ä¸ªå‚æ•°ï¼‰ã€‚è¿™é‡Œä½“ç°äº†radix treeç›¸è¾ƒäºhash-mapçš„ä¸€ä¸ªä¼˜ç‚¹ï¼Œæ ‘ç»“æ„å…è®¸æˆ‘ä»¬çš„è·¯å¾„ä¸­å­˜åœ¨åŠ¨æ€çš„éƒ¨åˆ†ï¼ˆå‚æ•°ï¼‰,å› ä¸ºæˆ‘ä»¬åŒ¹é…çš„æ˜¯è·¯ç”±çš„æ¨¡å¼è€Œä¸æ˜¯hashå€¼</p>

<p>ä¸ºäº†æ›´å…·æ‰©å±•æ€§ï¼Œæ¯ä¸€å±‚çš„èŠ‚ç‚¹æŒ‰ç…§priorityæ’åºï¼Œpriorityæ˜¯èŠ‚ç‚¹çš„å­èŠ‚ç‚¹ï¼ˆå„¿å­èŠ‚ç‚¹ï¼Œå­™å­èŠ‚ç‚¹ç­‰ï¼‰æ³¨å†Œçš„handlerçš„æ•°é‡ï¼Œè¿™æ ·åšæœ‰ä¸¤ä¸ªå¥½å¤„ï¼š</p>

<p>è¢«æœ€å¤šè·¯å¾„åŒ…å«çš„èŠ‚ç‚¹ä¼šè¢«æœ€å…ˆè¯„ä¼°ã€‚è¿™æ ·å¯ä»¥è®©å°½é‡å¤šçš„è·¯ç”±å¿«é€Ÿè¢«å®šä½ã€‚
æœ‰ç‚¹åƒæˆæœ¬è¡¥å¿ã€‚æœ€é•¿çš„è·¯å¾„å¯ä»¥è¢«æœ€å…ˆè¯„ä¼°ï¼Œè¡¥å¿ä½“ç°åœ¨æœ€é•¿çš„è·¯å¾„éœ€è¦èŠ±è´¹æ›´é•¿çš„æ—¶é—´æ¥å®šä½ï¼Œå¦‚æœæœ€é•¿è·¯å¾„çš„èŠ‚ç‚¹èƒ½è¢«ä¼˜å…ˆè¯„ä¼°ï¼ˆå³æ¯æ¬¡æ‹¿å­èŠ‚ç‚¹éƒ½å‘½ä¸­ï¼‰ï¼Œé‚£ä¹ˆæ‰€èŠ±æ—¶é—´ä¸ä¸€å®šæ¯”çŸ­è·¯å¾„çš„è·¯ç”±é•¿ã€‚ä¸‹é¢å±•ç¤ºäº†èŠ‚ç‚¹ï¼ˆæ¯ä¸ª-å¯ä»¥çœ‹åšä¸€ä¸ªèŠ‚ç‚¹ï¼‰è¯„ä¼°çš„è·¯å¾„ï¼šä»å·¦åˆ°å³ï¼Œä»ä¸Šåˆ°ä¸‹
â”œâ€”â€”â€”â€”
â”œâ€”â€”â€”
â”œâ€”â€“
â”œâ€”-
â”œâ€“
â”œâ€“
â””-
èŠ‚ç‚¹æ•°æ®ç»“æ„</p>

<p>èŠ‚ç‚¹çš„æ•°æ®ç»“æ„å¦‚ä¸‹ï¼š</p>

<p>type node struct {
    // èŠ‚ç‚¹è·¯å¾„ï¼Œæ¯”å¦‚ä¸Šé¢çš„sï¼Œearchï¼Œå’Œupport
    path      string
    // èŠ‚ç‚¹æ˜¯å¦æ˜¯å‚æ•°èŠ‚ç‚¹ï¼Œæ¯”å¦‚ä¸Šé¢çš„:post
    wildChild bool
    // èŠ‚ç‚¹ç±»å‹ï¼ŒåŒ…æ‹¬static, root, param, catchAll
    // static: é™æ€èŠ‚ç‚¹ï¼Œæ¯”å¦‚ä¸Šé¢çš„sï¼Œearchç­‰èŠ‚ç‚¹
    // root: æ ‘çš„æ ¹èŠ‚ç‚¹
    // catchAll: æœ‰<em>åŒ¹é…çš„èŠ‚ç‚¹
    // param: å‚æ•°èŠ‚ç‚¹
    nType     nodeType
    // è·¯å¾„ä¸Šæœ€å¤§å‚æ•°ä¸ªæ•°
    maxParams uint8
    // å’Œchildrenå­—æ®µå¯¹åº”, ä¿å­˜çš„æ˜¯åˆ†è£‚çš„åˆ†æ”¯çš„ç¬¬ä¸€ä¸ªå­—ç¬¦
    // ä¾‹å¦‚searchå’Œsupport, é‚£ä¹ˆsèŠ‚ç‚¹çš„indiceså¯¹åº”çš„â€euâ€
    // ä»£è¡¨æœ‰ä¸¤ä¸ªåˆ†æ”¯, åˆ†æ”¯çš„é¦–å­—æ¯åˆ†åˆ«æ˜¯eå’Œu
    indices   string
    // å„¿å­èŠ‚ç‚¹
    children  []</em>node
    // å¤„ç†å‡½æ•°
    handlers  HandlersChain
    // ä¼˜å…ˆçº§ï¼Œå­èŠ‚ç‚¹æ³¨å†Œçš„handleræ•°é‡
    priority  uint32
}
æ·»åŠ è·¯ç”±
func (n <em>node) addRoute(path string, handlers HandlersChain) {
    fullPath := path
    n.priority++
    numParams := countParams(path)
    // non-empty tree
    if len(n.path) &gt; 0 || len(n.children) &gt; 0 {
    walk:
        for {
            // Update maxParams of the current node
            if numParams &gt; n.maxParams {
                n.maxParams = numParams
            }
            // Find the longest common prefix.
            // This also implies that the common prefix contains no â€˜:â€™ or â€˜</em>â€™
            // since the existing key canâ€™t contain those chars.
            i := 0
            max := min(len(path), len(n.path))
            for i &lt; max &amp;&amp; path[i] == n.path[i] {
                i++
            }
            // Split edge
            // å¼€å§‹åˆ†è£‚ï¼Œæ¯”å¦‚ä¸€å¼€å§‹pathæ˜¯searchï¼Œæ–°æ¥äº†supportï¼Œsæ˜¯ä»–ä»¬åŒ¹é…çš„éƒ¨åˆ†ï¼Œ
            // é‚£ä¹ˆä¼šå°†sæ‹¿å‡ºæ¥ä½œä¸ºparentèŠ‚ç‚¹ï¼Œå¢åŠ earchå’Œupportä½œä¸ºchildèŠ‚ç‚¹
            if i &lt; len(n.path) {
                child := node{
                    path:      n.path[i:],  // ä¸åŒ¹é…çš„éƒ¨åˆ†ä½œä¸ºchildèŠ‚ç‚¹
                    wildChild: n.wildChild,
                    indices:   n.indices,
                    children:  n.children,
                    handlers:  n.handlers,
                    priority:  n.priority - 1,  // é™çº§æˆå­èŠ‚ç‚¹ï¼Œpriorityå‡1
                }
                // Update maxParams (max of all children)
                for i := range child.children {
                    if child.children[i].maxParams &gt; child.maxParams {
                        child.maxParams = child.children[i].maxParams
                    }
                }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            // å½“å‰èŠ‚ç‚¹çš„å­èŠ‚ç‚¹å˜æˆåˆšåˆšåˆ†è£‚çš„å‡ºæ¥çš„èŠ‚ç‚¹
            n.children = []*node{&amp;child}
            // []byte for proper unicode char conversion, see #65
            n.indices = string([]byte{n.path[i]})
            n.path = path[:i]
            n.handlers = nil
            n.wildChild = false
        }
        // Make new node a child of this node
        // å°†æ–°æ¥çš„èŠ‚ç‚¹æ’å…¥æ–°çš„parentèŠ‚ç‚¹ä½œä¸ºå­èŠ‚ç‚¹
        if i &lt; len(path) {
            path = path[i:]
				// å¦‚æœæ˜¯å‚æ•°èŠ‚ç‚¹ï¼ˆåŒ…å«:æˆ–*ï¼‰
            if n.wildChild {
                n = n.children[0]
                n.priority++
                // Update maxParams of the child node
                if numParams &gt; n.maxParams {
                    n.maxParams = numParams
                }
                numParams--
                // Check if the wildcard matches
                // ä¾‹å¦‚ï¼š/blog/:pp å’Œ /blog/:pppï¼Œéœ€è¦æ£€æŸ¥æ›´é•¿çš„é€šé…ç¬¦
                if len(path) &gt;= len(n.path) &amp;&amp; n.path == path[:len(n.path)] {
                    // check for longer wildcard, e.g. :name and :names
                    if len(n.path) &gt;= len(path) || path[len(n.path)] == '/' {
                        continue walk
                    }
                }
                panic("path segment '" + path +
                    "' conflicts with existing wildcard '" + n.path +
                    "' in path '" + fullPath + "'")
            }
				// é¦–å­—æ¯ï¼Œç”¨æ¥ä¸indicesåšæ¯”è¾ƒ
            c := path[0]
            // slash after param
            if n.nType == param &amp;&amp; c == '/' &amp;&amp; len(n.children) == 1 {
                n = n.children[0]
                n.priority++
                continue walk
            }
            // Check if a child with the next path byte exists
            // åˆ¤æ–­å­èŠ‚ç‚¹ä¸­æ˜¯å¦æœ‰å’Œå½“å‰pathæœ‰åŒ¹é…çš„ï¼Œåªéœ€è¦æŸ¥çœ‹å­èŠ‚ç‚¹pathçš„ç¬¬ä¸€ä¸ªå­—æ¯å³å¯ï¼Œå³indices
            // æ¯”å¦‚sçš„å­èŠ‚ç‚¹ç°åœ¨æ˜¯earchå’Œupportï¼Œindicesä¸ºeu
            // å¦‚æœæ–°æ¥çš„è·¯ç”±ä¸ºsuperï¼Œé‚£ä¹ˆå°±æ˜¯å’Œupportæœ‰åŒ¹é…çš„éƒ¨åˆ†uï¼Œå°†ç»§ç»­åˆ†ç±»ç°åœ¨çš„upportèŠ‚ç‚¹
            for i := 0; i &lt; len(n.indices); i++ {
                if c == n.indices[i] {
                    i = n.incrementChildPrio(i)
                    n = n.children[i]
                    continue walk
                }
            }
            // Otherwise insert it
            if c != ':' &amp;&amp; c != '*' {
                // []byte for proper unicode char conversion, see #65
                // è®°å½•ç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œæ”¾åœ¨indicesä¸­
                n.indices += string([]byte{c})
                child := &amp;node{
                    maxParams: numParams,
                }
                // å¢åŠ å­èŠ‚ç‚¹
                n.children = append(n.children, child)
                n.incrementChildPrio(len(n.indices) - 1)
                n = child
            }
            n.insertChild(numParams, path, fullPath, handlers)
            return
        } else if i == len(path) { // Make node a (in-path) leaf
            // è·¯å¾„ç›¸åŒï¼Œå¦‚æœå·²æœ‰handlerå°±æŠ¥é”™ï¼Œæ²¡æœ‰å°±èµ‹å€¼
            if n.handlers != nil {
                panic("handlers are already registered for path ''" + fullPath + "'")
            }
            n.handlers = handlers
        }
        return
    }
} else { // Empty treeï¼Œç©ºæ ‘ï¼Œæ’å…¥èŠ‚ç‚¹ï¼ŒèŠ‚ç‚¹ç§ç±»æ˜¯root
    n.insertChild(numParams, path, fullPath, handlers)
    n.nType = root
} } æ­¤å‡½æ•°çš„ä¸»è¦ç›®çš„æ˜¯æ‰¾åˆ°æ’å…¥èŠ‚ç‚¹çš„ä½ç½®ï¼Œå¦‚æœå’Œç°æœ‰èŠ‚ç‚¹å­˜åœ¨ç›¸åŒçš„å‰ç¼€ï¼Œé‚£ä¹ˆè¦å°†ç°æœ‰èŠ‚ç‚¹è¿›è¡Œåˆ†è£‚ï¼Œç„¶åå†æ’å…¥ï¼Œä¸‹é¢æ˜¯insertChildå‡½æ•°
</code></pre></div></div>

<p>æ’å…¥å­èŠ‚ç‚¹
// @1: å‚æ•°ä¸ªæ•°
// @2: è·¯å¾„
// @3: å®Œæ•´è·¯å¾„
// @4: å¤„ç†å‡½æ•°
func (n <em>node) insertChild(numParams uint8, path string, fullPath string, handlers HandlersChain) {
    var offset int // already handled bytes of the path
    // find prefix until first wildcard (beginning with â€˜:â€™â€™ or â€˜</em>â€™â€™)
    // æ‰¾åˆ°å‰ç¼€ï¼Œåªè¦åŒ¹é…åˆ°wildcard
    for i, max := 0, len(path); numParams &gt; 0; i++ {
        c := path[i]
        if c != â€˜:â€™ &amp;&amp; c != â€˜<em>â€™ {
            continue
        }
        // find wildcard end (either â€˜/â€™ or path end)
        end := i + 1
        for end &lt; max &amp;&amp; path[end] != â€˜/â€™ {
            switch path[end] {
            // the wildcard name must not contain â€˜:â€™ and â€˜</em>â€™
            case â€˜:â€™, â€˜<em>â€™:
                panic(â€œonly one wildcard per path segment is allowed, has: â€˜â€ +
                    path[i:] + â€œâ€™ in path â€˜â€ + fullPath + â€œâ€™â€)
            default:
                end++
            }
        }
        // check if this Node existing children which would be
        // unreachable if we insert the wildcard here
        if len(n.children) &gt; 0 {
            panic(â€œwildcard route â€˜â€ + path[i:end] +
                â€œâ€™ conflicts with existing children in path â€˜â€ + fullPath + â€œâ€™â€)
        }
        // check if the wildcard has a name
        if end-i &lt; 2 {
            panic(â€œwildcards must be named with a non-empty name in path â€˜â€ + fullPath + â€œâ€™â€)
        }
        if c == â€˜:â€™ { // param
            // split path at the beginning of the wildcard
            if i &gt; 0 {
                n.path = path[offset:i]
                offset = i
            }
            child := &amp;node{
                nType:     param,
                maxParams: numParams,
            }
            n.children = []</em>node{child}
            n.wildChild = true
            n = child
            n.priority++
            numParamsâ€“
            // if the path doesnâ€™t end with the wildcard, then there
            // will be another non-wildcard subpath starting with â€˜/â€™
            if end &lt; max {
                n.path = path[offset:end]
                offset = end</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            child := &amp;node{
                maxParams: numParams,
                priority:  1,
            }
            n.children = []*node{child}
            // ä¸‹æ¬¡å¾ªç¯è¿™ä¸ªæ–°çš„childèŠ‚ç‚¹
            n = child
        }
    } else { // catchAll
        if end != max || numParams &gt; 1 {
            panic("catch-all routes are only allowed at the end of the path in path '" + fullPath + "'")
        }
        if len(n.path) &gt; 0 &amp;&amp; n.path[len(n.path)-1] == '/' {
            panic("catch-all conflicts with existing handle for the path segment root in path '" + fullPath + "'")
        }
        // currently fixed width 1 for '/'
        i--
        if path[i] != '/' {
            panic("no / before catch-all in path '" + fullPath + "'")
        }
        n.path = path[offset:i]
        // first node: catchAll node with empty path
        child := &amp;node{
            wildChild: true,
            nType:     catchAll,
            maxParams: 1,
        }
        n.children = []*node{child}
        n.indices = string(path[i])
        n = child
        n.priority++
        // second node: node holding the variable
        child = &amp;node{
            path:      path[i:],
            nType:     catchAll,
            maxParams: 1,
            handlers:  handlers,
            priority:  1,
        }
        n.children = []*node{child}
        return
    }
}
// insert remaining path part and handle to the leaf
n.path = path[offset:]
n.handlers = handlers } insertChildå‡½æ•°æ˜¯æ ¹æ®pathæœ¬èº«è¿›è¡Œåˆ†å‰², å°†/åˆ†å¼€çš„éƒ¨åˆ†åˆ†åˆ«ä½œä¸ºèŠ‚ç‚¹ä¿å­˜, å½¢æˆä¸€æ£µæ ‘ç»“æ„. æ³¨æ„å‚æ•°åŒ¹é…ä¸­çš„:å’Œ*çš„åŒºåˆ«, å‰è€…æ˜¯åŒ¹é…ä¸€ä¸ªå­—æ®µ, åè€…æ˜¯åŒ¹é…åé¢æ‰€æœ‰çš„è·¯å¾„
</code></pre></div></div>

<p>è·¯å¾„æŸ¥æ‰¾
åŒ¹é…æ¯ä¸ªchildrençš„pathï¼Œæœ€é•¿åŒ¹é…</p>

<p>// Returns the handle registered with the given path (key). The values of
// wildcards are saved to a map.
// If no handle can be found, a TSR (trailing slash redirect) recommendation is
// made if a handle exists with an extra (without the) trailing slash for the
// given path.
func (n *node) getValue(path string, po Params, unescape bool) (handlers HandlersChain, p Params, tsr bool) {
    p = po
walk: // Outer loop for walking the tree
    for {
        // å°šæœªåˆ°è¾¾pathçš„ç»ˆç‚¹
        if len(path) &gt; len(n.path) {
            // å‰é¢ä¸€æ®µéœ€è¦ä¸€è‡´
            if path[:len(n.path)] == n.path {
                path = path[len(n.path):]
                // If this node does not have a wildcard (param or catchAll)
                // child,  we can just look up the next child node and continue
                // to walk down the tree
                if !n.wildChild {
                    c := path[0]
                    for i := 0; i &lt; len(n.indices); i++ {
                        if c == n.indices[i] {
                            n = n.children[i]
                            continue walk
                        }
                    }
                    // Nothing found.
                    // We can recommend to redirect to the same URL without a
                    // trailing slash if a leaf exists for that path.
                    tsr = (path == â€œ/â€ &amp;&amp; n.handlers != nil)
                    return
                }
                // handle wildcard child
                n = n.children[0]
                switch n.nType {
                case param:
                    // find param end (either â€˜/â€™ or path end)
                    end := 0
                    for end &lt; len(path) &amp;&amp; path[end] != â€˜/â€™ {
                        end++
                    }
                    // save param value
                    if cap(p) &lt; int(n.maxParams) {
                        p = make(Params, 0, n.maxParams)
                    }
                    i := len(p)
                    p = p[:i+1] // expand slice within preallocated capacity
                    p[i].Key = n.path[1:]
                    val := path[:end]
                    if unescape {
                        var err error
                        if p[i].Value, err = url.QueryUnescape(val); err != nil {
                            p[i].Value = val // fallback, in case of error
                        }
                    } else {
                        p[i].Value = val
                    }
                    // we need to go deeper!
                                        if end &lt; len(path) {
                        if len(n.children) &gt; 0 {
                            path = path[end:]
                            n = n.children[0]
                            continue walk
                        }
                        // â€¦ but we canâ€™t
                        tsr = (len(path) == end+1)
                        return
                    }
                    if handlers = n.handlers; handlers != nil {
                        return
                    }
                    if len(n.children) == 1 {
                        // No handle found. Check if a handle for this path + a
                        // trailing slash exists for TSR recommendation
                        n = n.children[0]
                        tsr = (n.path == â€œ/â€ &amp;&amp; n.handlers != nil)
                    }
                    return
                case catchAll:
                    // save param value
                    if cap(p) &lt; int(n.maxParams) {
                        p = make(Params, 0, n.maxParams)
                    }
                    i := len(p)
                    p = p[:i+1] // expand slice within preallocated capacity
                    p[i].Key = n.path[2:]
                    if unescape {
                        var err error
                        if p[i].Value, err = url.QueryUnescape(path); err != nil {
                            p[i].Value = path // fallback, in case of error
                        }
                    } else {
                        p[i].Value = path
                    }
                    handlers = n.handlers
                    return
                default:
                    panic(â€œinvalid node typeâ€)
                }
            }
        } else if path == n.path {
            // We should have reached the node containing the handle.
            // Check if this node has a handle registered.
            if handlers = n.handlers; handlers != nil {
                return
            }
            if path == â€œ/â€ &amp;&amp; n.wildChild &amp;&amp; n.nType != root {
                tsr = true
                return
            }
            // No handle found. Check if a handle for this path + a
            // trailing slash exists for trailing slash recommendation
            for i := 0; i &lt; len(n.indices); i++ {
                if n.indices[i] == â€˜/â€™ {
                    n = n.children[i]
                    tsr = (len(n.path) == 1 &amp;&amp; n.handlers != nil) ||
                        (n.nType == catchAll &amp;&amp; n.children[0].handlers != nil)
                    return
                }
            }
            return
        }
        // Nothing found. We can recommend to redirect to the same URL with an
        // extra trailing slash if a leaf exists for that path
        tsr = (path == â€œ/â€) ||
            (len(n.path) == len(path)+1 &amp;&amp; n.path[len(path)] == â€˜/â€™ &amp;&amp;
                path == n.path[:len(n.path)-1] &amp;&amp; n.handlers != nil)
        return
    }
}</p>
:ET