I"¡%<p>https://gocn.vip/topics/10008
<!-- more -->
æŸ¥çœ‹æœåŠ¡å™¨çš„ç›‘æ§ç³»ç»Ÿ, CPU, å†…å­˜, è´Ÿè½½ç­‰æŒ‡æ ‡æ­£å¸¸
æ’æŸ¥æ—¥å¿—, æ—¥å¿—èƒ½å¤Ÿå“åº”çš„ç»“æœä¹Ÿæ­£å¸¸. request.log ä¸­å“åº”æ—¶é•¿é«˜è¾¾æ•°ç§’
æŸ¥çœ‹æ•°æ®åº“, codis ç›‘æ§, å„é¡¹æŒ‡æ ‡æ­£å¸¸
ä¸å¾—å·², åªèƒ½æ‰“å¼€çº¿ä¸Š pprof æŸ¥çœ‹ Go ç›¸å…³å‚æ•°æ˜¯å¦æ­£å¸¸. æœçœŸä¸€ä¸‹å­å°±æ‰¾åˆ°é—®é¢˜å‘ç”Ÿçš„åŸå› </p>

<p>go-cache</p>

<p>è¿™æ˜¯å½“æ—¶çº¿ä¸Š pprof çš„æˆªå›¾, å‘ç° 40 å¤šä¸‡ goroutine éƒ½é˜»å¡åœ¨ go-cache çš„ Set å‡½æ•°ä¸Š. æ›´å‡†ç¡®çš„è¯´ 40 å¤šä¸‡ goroutine åœ¨å‘ç”Ÿå¾ˆä¸¥é‡çš„é”ç«äº‰. è¿™å°±è®©äººè§‰å¾—å¾ˆæ„å¤–äº†.</p>

<p>å¹¸å¥½å½“æ—¶åœ¨å‹æµ‹æ¥å£çš„æ—¶å€™, ä¸ºäº†é¿å… go-cache çš„å½±å“ç»“æœçš„å½±å“, å¼•å…¥äº†ä¸€ä¸ªé…ç½®é¡¹æ¥æ§åˆ¶æ˜¯å¦å¼€å¯ go-cache, äºæ˜¯ç«‹é©¬çº¿ä¸Šå…³é—­ go-cache, æ¥å£å“åº”æ¢å¤æ­£å¸¸.</p>

<p>é—®é¢˜æ¥äº†
è™½è¯´é—®é¢˜è§£å†³äº†, ä½†æ˜¯æ˜¯ç”±äºä»€ä¹ˆåŸå› é€ æˆçš„å‘¢?</p>

<p>ä¸ºä»€ä¹ˆ go-cache ä¼šå‘ç”Ÿè¿™ä¹ˆä¸¥é‡çš„é”ç«äº‰ ?
æ˜¯ç”±äº go-cache æœ‰ä»£ç  bug å— ?
å¦‚ä½•æ‰èƒ½ç¨³å®šå¤ç°å‘¢ ?
go-cache æºç å‰–æ
ä¸ºäº†æ¢ç©¶è¿™ä¸ª bug å¼•èµ·çš„åŸå› , æˆ‘å°†æ•´ä¸ª go-cache çš„æºç è¯»äº†ä¸€é, å…¶å® go-cache ç›¸å¯¹äº freecache, bigcache è¿˜æ˜¯ç›¸å¯¹ç®€å•è®¸å¤š.</p>

<p>type cache struct {
    defaultExpiration time.Duration
    items             map[string]Item
    mu                sync.RWMutex
    onEvicted         func(string, interface{})
    janitor           *janitor
}
ä»ç»“æ„ä½“ä¸Š, go-cache ä¸»è¦è¿˜æ˜¯ç”± map + RWMutex ç»„æˆ.</p>

<p>Set â€“ go-cache æœ€é‡è¦çš„å‡½æ•°
// Add an item to the cache, replacing any existing item. If the duration is 0
// (DefaultExpiration), the cacheâ€™s default expiration time is used. If it is -1
// (NoExpiration), the item never expires.
func (c *cache) Set(k string, x interface{}, d time.Duration) {
    // â€œInliningâ€ of set
    var e int64
    if d == DefaultExpiration {
        d = c.defaultExpiration
    }
    if d &gt; 0 {
        e = time.Now().Add(d).UnixNano()
    }
    c.mu.Lock()
    c.items[k] = Item{
        Object:     x,
        Expiration: e,
    }
    // TODO: Calls to mu.Unlock are currently not deferred because defer
    // adds ~200 ns (as of go1.)
    c.mu.Unlock()
}
Set éœ€è¦ä¸‰ä¸ªå‚æ•°: key, value, d(è¿‡æœŸæ—¶é—´). å¦‚æœ d ä¸º 0, åˆ™ä½¿ç”¨ go-cache é»˜è®¤è¿‡æœŸæ—¶é—´, è¿™ä¸ªé»˜è®¤è¿‡æœŸæ—¶é—´æ˜¯ go-cache.New() æ—¶è®¾ç½®çš„. å¦‚æœ d ä¸º -1, é‚£ä¹ˆè¿™ä¸ª key ä¸ä¼šè¿‡æœŸ</p>

<p>å®ç°è¿‡ç¨‹:</p>

<p>RWMutex.Lock
è®¾ç½®è¿‡æœŸæ—¶é—´, å°† value æ”¾å…¥ map ä¸­
RWMutex.Unlock
è¿˜æœ‰å¦å¤–å‡ ä¸ªè¡ç”Ÿå‡½æ•°: SetDefault, Add, Replace, è¿™é‡Œå°±ä¸åšå…·ä½“ä»‹ç»</p>

<p>Get go-cache æœ€é‡è¦çš„å‡½æ•°
func (c *cache) Get(k string) (interface{}, bool) {
    c.mu.RLock()
    // â€œInliningâ€ of get and Expired
    item, found := c.items[k]
    if !found {
        c.mu.RUnlock()
        return nil, false
    }
    if item.Expiration &gt; 0 {
        if time.Now().UnixNano() &gt; item.Expiration {
            c.mu.RUnlock()
            return nil, false
        }
    }
    c.mu.RUnlock()
    return item.Object, true
}
RWMutex.RLock
åˆ¤æ–­æ˜¯å¦å­˜åœ¨
åˆ¤æ–­æ˜¯å¦è¿‡æœŸ
RLock.RUnlock
Increment/Decrement
go-cache å¯¹æ•°å€¼ç±»å‹çš„å€¼æ˜¯æ¯”è¾ƒå‹å¥½çš„, æä¾›å¤§é‡å‡½æ•° Increment, IncrementFloatç­‰å‡½æ•°, èƒ½å¤Ÿè½»æ¾å¯¹å†…å­˜ä¸­çš„å„ç§æ•°å€¼è¿›è¡ŒåŠ å‡, å…¶å®ç°ä¹Ÿç®€å•</p>

<p>func (c *cache) IncrementUint16(k string, n uint16) (uint16, error) {
    c.mu.Lock()
    v, found := c.items[k]
    if !found || v.Expired() {
        c.mu.Unlock()
        return 0, fmt.Errorf(â€œItem %s not foundâ€, k)
    }
    rv, ok := v.Object.(uint16)
    if !ok {
        c.mu.Unlock()
        return 0, fmt.Errorf(â€œThe value for %s is not an uint16â€, k)
    }
    nv := rv + n
    v.Object = nv
    c.items[k] = v
    c.mu.Unlock()
    return nv, nil
}
RWMutex.Lock
åˆ¤æ–­æŸä¸ª key åœ¨ map ä¸­æ˜¯å¦å­˜åœ¨
åˆ¤æ–­æ˜¯å¦è¿™ä¸ª key æ˜¯å¦è¿‡æœŸ
å¯¹è¿™ä¸ªå€¼åŠ  n
RWMutex.Unlock
è½ç›˜/æ¢å¤æ–¹æ¡ˆ
go-cache è‡ªå¸¦è½ç›˜/æ¢å¤æ–¹æ¡ˆ, å°†å†…å­˜ä¸­çš„å€¼è¿›è¡Œè½ç›˜, åŒæ—¶å°†æ–‡ä»¶ä¸­çš„å†…å®¹æ¢å¤. ä¸è¿‡æˆ‘æ„Ÿè§‰è¿™ä¸ªåŠŸèƒ½æŒºé¸¡è‚‹çš„, æ²¡å¿…è¦åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨. è¿™é‡Œå°±ä¸åšè¿‡å¤šçš„ä»‹ç»äº†.</p>

<p>go-cache è¿‡æœŸæ¸…ç†æ–¹æ¡ˆ</p>

<p>func (c *cache) DeleteExpired() {
    log.Printf(â€œstart check at:%vâ€, time.Now())
    var evictedItems []keyAndValue
    now := time.Now().UnixNano()
    c.mu.Lock()
    for k, v := range c.items {
        // â€œInliningâ€ of expired
        if v.Expiration &gt; 0 &amp;&amp; now &gt; v.Expiration {
            ov, evicted := c.delete(k)
            if evicted {
                evictedItems = append(evictedItems, keyAndValue{k, ov})
            }
        }
    }
    c.mu.Unlock()
    for _, v := range evictedItems {
        c.onEvicted(v.key, v.value)
    }
}</p>

<p>func (j *janitor) Run(c *cache) {
    ticker := time.NewTicker(j.Interval)
    for {
        select {
        case &lt;-ticker.C:
            c.DeleteExpired()
        case &lt;-j.stop:
            ticker.Stop()
            return
        }
    }
}</p>

<p>func runJanitor(c *cache, ci time.Duration) {
    j := &amp;janitor{
        Interval: ci,
        stop:     make(chan bool),
    }
    c.janitor = j
    go j.Run(c)
}</p>

<p>func newCacheWithJanitor(de time.Duration, ci time.Duration, m map[string]Item) *Cache {
    c := newCache(de, m)
    // This trick ensures that the janitor goroutine (whichâ€“granted it
    // was enabledâ€“is running DeleteExpired on c forever) does not keep
    // the returned C object from being garbage collected. When it is
    // garbage collected, the finalizer stops the janitor goroutine, after
    // which c can be collected.
    C := &amp;Cache{c}
    if ci &gt; 0 {
        runJanitor(c, ci)
        runtime.SetFinalizer(C, stopJanitor)
    }
    return C
}
å¯ä»¥çœ‹åˆ° go-cache æ¯è¿‡ä¸€æ®µæ—¶é—´ (j.Interval, è¿™ä¸ªå€¼ä¹Ÿæ˜¯é€šè¿‡ go-cache.New è®¾ç½®), å°±ä¼šå¯åŠ¨æ¸…ç†å·¥ä½œ.</p>

<p>æ¸…ç†æ—¶åŸç†:</p>

<p>RWMutex.Lock()
éå†æ•´ä¸ª map, æ£€æŸ¥ map ä¸­çš„ value æ˜¯å¦è¿‡æœŸ
RWMutex.Unlock()
åŒæ—¶, è¿˜åˆ©ç”¨äº† runtime.SetFinalizer åœ¨ go-cache ç”Ÿå‘½å‘¨æœŸç»“æŸæ—¶, ä¸»åŠ¨å®Œæˆå¯¹è¿‡æœŸæ¸…ç†åç¨‹çš„ç»ˆæ­¢</p>

<p>æºç åˆ†ææ€»ç»“
éè§ˆæ•´ä¸ª go-cache æºç , ä¼šå‘ç° go-cache å®Œå…¨é ç€ RWMutex ä¿è¯æ•°æ®çš„æ­£ç¡®æ€§.</p>

<p>è€ƒè™‘ä¸‹é¢çš„é—®é¢˜:</p>

<p>å½“ go-cache.New() æ—¶è®¾ç½®çš„å®šæ—¶æ¸…ç†çš„æ—¶é—´è¿‡é•¿, åŒæ—¶ Set çš„ key çš„è¿‡æœŸæ—¶é—´æ¯”è¾ƒé•¿, è¿™æ ·ä¼šä¸ä¼šå¯¼è‡´ go-cache.map ä¸­çš„å…ƒç´ è¿‡å¤š?
ä¼šä¸ä¼šå½“æ¸…ç†å¯åŠ¨æ—¶, é”å®šäº† go-cache.map (æ³¨æ„è¿™ä¸ªæ—¶å€™æ˜¯å†™é”), ç”±äº go-cache.map ä¸­å…ƒç´ è¿‡å¤š, å¯¼è‡´ map ä¸€ç›´è¢«é”å®š, é‚£ä¹ˆè¿™ä¸ªæ—¶å€™æ‰€æœ‰çš„ Set å‡½æ•°æ˜¯ä¸æ˜¯å°±ä¼šäº§ç”Ÿ Lock ç«äº‰?
ä½¿ç”¨ go-cache çš„æ—¶å€™, å½“æŸä¸ªæ¥å£çš„ QPS å¾ˆé«˜, ç¨‹åºé‡Œç”±äºä½¿ç”¨é—®é¢˜, å°†æŸäº›ä¸è¯¥å¾€ go-cache å­˜çš„ value ä¹Ÿå­˜äº†è¿›å», é‚£ä¹ˆä¼šä¸ä¼šå¯¼è‡´ Set ä¹‹é—´çš„ Lock ç«äº‰å‘¢?
åœºæ™¯è¿˜åŸ
åˆ©ç”¨ä¸‹é¢çš„ç¨‹åºå¯ä»¥è½»æ¾è¿˜åŸä¸Šé¢çš„é—®é¢˜åœºæ™¯. ä¸Šé¢æå‡ºçš„é—®é¢˜, éƒ½ä¼šé€ æˆ go-cache lock ç«äº‰. è¿™é‡Œåˆ©ç”¨ pprof æŸ¥çœ‹ç¨‹åºçš„æŒ‡æ ‡</p>

<p>var goroutineNums = flag.Int(â€œgnâ€, 2, â€œgoroutine numsâ€)
func main() {
    flag.Parse()
    go func() {
        log.Println(http.ListenAndServe(â€œlocalhost:6060â€, nil))
    }()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rand.Seed(time.Now().Unix())
lc := cache.New(time.Minute*5, time.Minute*2)
log.Printf("start at:%v", time.Now())
aaaKey := "aaa:%d:buy:cnt"
log.Println("set run over")

for i := 0; i &lt; *goroutineNums; i++ {
    go func(idx int) {
        for {
            key := fmt.Sprintf(aaaKey, rand.Int())
            newKey := fmt.Sprintf("%s:%d", key, rand.Int())
            v := rand.Int()
            lc.Set(newKey, v, time.Millisecond)
        }
    }(i)
}

// æŸ¥çœ‹ go-cache ä¸­ key çš„æ•°é‡
go func() {
    ticker := time.NewTicker(time.Second)
    for {
        select {
        case &lt;-ticker.C:
            log.Printf("lc size:%d", lc.ItemCount())
        }
    }
}()
select {} } æ¨¡æ‹Ÿæ¥å£é«˜ QPS ./go-cache-test -gn 2000 2020/03/12 00:32:33 start at:2020-03-12 00:32:33.949073 +0800 CST m=+0.001343027 2020/03/12 00:32:34 lc size:538398 2020/03/12 00:32:35 lc size:1149109 high-qps
</code></pre></div></div>

<p>ç¬é—´å°±ä¼šå‡ºç°é”ç«äº‰</p>

<p>æ¨¡æ‹Ÿ go-cache å¯åŠ¨æ¸…ç†æ—¶çš„æƒ…å½¢
./go-cache-test -gn 2 <br />
2020/03/12 00:37:33 start at:2020-03-12 00:37:33.171238 +0800 CST m=+0.001457393
â€¦
2020/03/12 00:40:35 lc size:54750220
2020/03/12 00:40:35 start clear at:2020-03-12 00:40:35.103586 +0800 CST m=+120.005547323
2020/03/12 00:41:51 lc size:33
2020/03/12 00:41:51 lc size:50
clear</p>

<p>ä¼šçœ‹åˆ°å½“æ¸…ç† map çš„æ—¶å€™, å¦‚æœ map ä¸­çš„æ•°æ®è¿‡å¤šå°±ä¼šé€ æˆ Lock ç«äº‰, é€ æˆå…¶ä»–æ•°æ®æ— æ³•å†™å…¥ map</p>

<p>æ€»ç»“
æˆ‘ä½¿ç”¨çš„é—®é¢˜
èƒŒæ™¯: æŸæ¥å£ QPS æœ‰ç‚¹é«˜</p>

<p>å½“æ—¶è€ƒè™‘åˆ°ç”¨æˆ·è´­ä¹°çŠ¶æ€ (è¿™ä¸ªçŠ¶æ€å¯èƒ½éšæ—¶å˜åŒ–) å¦‚æœèƒ½å¤Ÿåœ¨æœ¬åœ°ç¼“å­˜ä¸­ç¼“å­˜ 10s, é‚£ä¹ˆç”¨æˆ·å†æ¬¡ç‚¹è¿›æ¥çš„æ—¶å€™èƒ½ä»æœ¬åœ°å–äº†, å°±é€ æˆå¤§é‡çš„æ•°æ®éƒ½å†™å…¥äº† map ä¸­
ç”±äºæ¥å£ QPS æ¯”è¾ƒé«˜, è®¾ç½®ç”¨æˆ·è´­ä¹°çŠ¶æ€æ—¶å°±å¯èƒ½é€ æˆç«äº‰, é€ æˆæ¥å£å“åº”è¶…æ—¶
go-cache ä½¿ç”¨æ³¨æ„ç‚¹
å°½é‡å­˜æ”¾é‚£äº›ç›¸å¯¹ä¸æ€ä¹ˆå˜åŒ–çš„æ•°æ®, é€‚ç”¨äºæ‰€æœ‰çš„ local cache(åŒ…æ‹¬ map, sync.map)
go-cache çš„è¿‡æœŸæ£€æŸ¥æ—¶é—´è¦è®¾ç½®ç›¸å¯¹è¾ƒå°, ä¹Ÿä¸èƒ½è¿‡å°
é‚£äº›é«˜ QPS çš„æ¥å£å°½é‡ä¸è¦å»ç›´æ¥ Set æ•°æ®, å¦‚æœå¿…é¡» Set å¯ä»¥é‡‡ç”¨å¼‚æ­¥æ“ä½œ
ç›‘æ§ go-cache é‡Œé¢ key çš„æ•°é‡, å¦‚æœè¿‡å¤šæ—¶, éœ€è¦åŠæ—¶è°ƒæ•´å‚æ•°
èµ„æ–™
go-cache
bigcache
freecache
runtime.SetFinalizer</p>
:ET