I"œ«<p>é€šç”¨tcpæ¢æ´»åŸç†
å…¶å®ï¼Œæ¢æ´»åŸç†ç‰¹åˆ«ç®€å•ï¼Œåªè¦ç¨æ‡‚è®¡ç®—æœºç½‘ç»œå°±èƒ½å¤Ÿç†è§£ã€‚</p>

<p>æ£€æµ‹ç«¯ å‘èµ·tcpä¸‰æ¬¡æ¡æ‰‹ï¼Œå»ºç«‹æ–°è¿æ¥ï¼Œè¿æ¥å»ºç«‹æˆåŠŸä»£è¡¨æœåŠ¡æ´»ç€ï¼Œå»ºç«‹å¤±è´¥ä»£è¡¨æœåŠ¡æ­»äº†ï¼Œä¹‹åå‘é€rståŒ…ä¸»åŠ¨æ–­å¼€è¿æ¥ã€‚
è¢«æ£€æµ‹ç«¯ æ¥å—æ£€æµ‹ç«¯å‘é€çš„ä¸‰æ¬¡æ¡æ‰‹æ‰‹å»ºç«‹è¿æ¥ï¼Œå½“æ¥æ”¶åˆ°æ£€æµ‹ç«¯çš„rståŒ…åï¼Œè¢«æ£€æµ‹ç«¯æ–­å¼€è¿æ¥ï¼Œé‡Šæ”¾èµ„æºã€‚
<!-- more -->
ä½†æ˜¯å‡å¦‚rståŒ…ä¸¢å¤±äº†ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆæ ·çš„æƒ…å†µå‘¢ï¼Ÿæˆ‘ä»¬ä»¥thriftä¸ºä¾‹è®²è¿°ä¸€ä¸‹ä¹‹åæ‰€å‘ç”Ÿçš„äº‹æƒ…ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚
<img src="https://xiazemin.github.io/MyBlog/img/livenessprobe.png" /></p>

<p>ç»è¿‡ä¸‰æ¬¡æ¡æ‰‹åï¼ŒæœåŠ¡ç«¯å·²ç»å»ºç«‹ä¸€ä¸ªæ–°çš„æ•°æ®è¿æ¥ï¼Œå¹¶æŠŠè¿æ¥ä¸¢ç»™å·¥ä½œçº¿ç¨‹ã€‚æœåŠ¡ç«¯çš„å·¥ä½œçº¿ç¨‹ç›‘å¬è¿æ¥ï¼Œå¹¶å‡†å¤‡æ¥æ”¶è¯·æ±‚ï¼ˆæ¯•ç«Ÿï¼Œä»»ä½•ä¸€ä¸ªthriftæœåŠ¡éƒ½æ˜¯å…ˆæ¥æ”¶è¯·æ±‚æ•°æ®ï¼Œä¹‹åè¿›è¡Œè®¡ç®—ï¼Œæœ€åè¿”å›å“åº”æ•°æ®ï¼Œæ‰€ä»¥å½“æ–°è¿æ¥å»ºç«‹åï¼Œthrifté»˜è®¤é¦–å…ˆè¯»å–è¿æ¥ä¸Šçš„æ•°æ®ï¼‰ã€‚</p>

<p>æ£€æµ‹ç«¯å»ºç«‹è¿æ¥æˆåŠŸåï¼Œè®¤ä¸ºä¸‹æ¸¸æœåŠ¡è¿˜æ´»ç€ï¼Œæ‰€ä»¥ç«‹åˆ»å‘é€rståŒ…ï¼ˆæ£€æµ‹ç«¯è®¤ä¸ºè¿™ä¸ªrståŒ…ä¸€å®šä¼šåˆ°è¾¾è¢«æ£€æµ‹æœåŠ¡ï¼‰ï¼Œå¹¶ä¸”é‡Šæ”¾è¿æ¥èµ„æºã€‚</p>

<p>ä½†æ˜¯å¦‚æœç½‘ç»œçŠ¶æ€ä¸å¥½ï¼ŒrståŒ…ä¸¢å¤±ï¼Œé‚£ä¹ˆæœåŠ¡ç«¯ï¼ˆè¢«æ£€æµ‹ç«¯ï¼‰çš„å·¥ä½œçº¿ç¨‹å°±ä¼šæ— é™åˆ¶çš„hangåœ¨è¯»å–è¿æ¥æ•°æ®ä¸Šï¼ˆå› ä¸ºæ£€æµ‹ç«¯å·²ç»å•æ–¹é¢è®¤ä¸ºè¿æ¥æ–­å¼€ï¼Œä¸ä¼šå†™ä»»ä½•æ•°æ®ï¼Œæ‰€ä»¥æœåŠ¡ç«¯ä¹Ÿè¯»ä¸åˆ°ä»»ä½•æ•°æ®ï¼‰ã€‚å¦‚æœå¤šä¸¢å‡ ä¸ªrståŒ…ï¼Œé‚£å¯ä»¥é¢„æœŸæ— è®ºä½ æœ‰å¤šå°‘thriftå·¥ä½œçº¿ç¨‹ï¼Œéƒ½å°†ä¼šhangæ­»ã€‚</p>

<p>æ­¤æ—¶çœŸæ­£è°ƒç”¨æœåŠ¡çš„å®¢æˆ·ç«¯çš„è¯·æ±‚ä¹Ÿæ— é™åˆ¶çš„hangä½ï¼Œå› ä¸ºè¿™äº›è¯·æ±‚å¾—ä¸åˆ°thriftå·¥ä½œçº¿ç¨‹çš„å¤„ç†ã€‚</p>

<p>æœ€æœ€å¯æ€•çš„æ˜¯ï¼šç”±äºæ¢æ´»åªæ˜¯å•çº¯çš„å»ºç«‹è¿æ¥è€Œå¹¶ä¸å‘é€æˆ–è€…æ¥å—é¢å¤–æ•°æ®ï¼Œå¹¶ä¸”thriftæœåŠ¡æœ‰å•ç‹¬çš„çº¿ç¨‹è¿›è¡Œacceptï¼Œè¿™å¯¼è‡´äº†è¿æ¥å»ºç«‹æ¯æ¬¡éƒ½æˆåŠŸï¼Œä½†å®é™…ä¸ŠæœåŠ¡å·²ç»æ²¡æœ‰äº†è®¡ç®—èƒ½åŠ›ã€‚</p>

<p>æœ€åçš„ç»“å±€å°±æ˜¯ï¼šæ•´ä¸ªç³»ç»Ÿæµé‡çªç„¶é™ä½ï¼Œä¸‹æ¸¸æ¥æ”¶ä¸åˆ°è¯·æ±‚ï¼ˆä»¥ä¸ºæ˜¯ä¸Šæ¸¸è°ƒç”¨çš„é”…ï¼‰ï¼Œä¸Šæ¸¸å‘å‡ºçš„è¯·æ±‚å¾—ä¸åˆ°å“åº”ï¼ˆè®¤ä¸ºæ˜¯ä¸‹æ¸¸æœåŠ¡çš„é”…ï¼‰ï¼Œå¹¶ä¸”æ²¡æœ‰æŠ¥è­¦çŸ­ä¿¡å‘å‡ºï¼ˆä»¥ä¸ºæ˜¯è¿ç»´çš„é”…ï¼‰ï¼Œå¯¹æ’æŸ¥é—®é¢˜é€ æˆå¾ˆå¤§çš„å›°æ‰°ã€‚</p>

<p>å‡ºç°è¿™ç§é—®é¢˜æ—¶æœ‰ä¸€ä¸ªéå¸¸æ˜æ˜¾çš„ç°è±¡ï¼šå³ä½¿åœ¨ç³»ç»Ÿæµé‡ä¸º0çš„æƒ…å†µä¸‹ï¼ŒæœåŠ¡ç«¯ä¹Ÿä¼šä¸æ–­æœ‰æ–°è¿æ¥å»ºç«‹å¹¶å¤„äºEstablishçŠ¶æ€ï¼ˆè¿™æ˜¯å› ä¸ºå‘¨æœŸæ€§çš„æ¢æ´»å¯¼è‡´çš„ï¼‰ï¼Œå¹¶ä¸”æœåŠ¡ç«¯æ—¥å¿—ä¸æ»šåŠ¨ï¼Œå®¢æˆ·ç«¯è¯·æ±‚æ— å“åº”ã€‚å¦‚æœä½ çš„ç³»ç»Ÿæœ‰è¿™ç§æƒ…å†µï¼Œé‚£ä¹ˆå¤šåŠå’Œæ¢æ´»æœ‰å…³ã€‚</p>

<p>æˆ‘å½“æ—¶é‡åˆ°çš„æƒ…å†µæ¯”è¾ƒç³Ÿç³•ï¼Œå› ä¸ºä¹‹å‰ä¸€æ®µæ—¶é—´rstä¸¢åŒ…ç‡ç‰¹åˆ«ä½ï¼Œå¹³å‡å‡ å¤©ä¸¢ä¸€ä¸ªrståŒ…ï¼Œæ‰€ä»¥æœåŠ¡hangæ­»é€ æˆçš„å½±å“å¹¶ä¸å¤§ï¼Œåªè¦æŠ½ç©ºé‡æ–°å¯åŠ¨æœåŠ¡å³å¯ã€‚å¯æ˜¯çªç„¶æŸä¸€å¤©ï¼Œå•å°æœåŠ¡çš„rstä¸¢åŒ…æ•°è¾¾åˆ°äº†ç§’çº§ï¼šéš”å‡ ç§’ä¸¢ä¸€ä¸ªrståŒ…ï¼Œå¯¼è‡´æˆ‘çš„æœåŠ¡çŸ­æ—¶é—´å†…å…¨éƒ¨hangæ­»ã€‚</p>

<p>HTTPæ¢æ´»åŸç†
åœ¨å®é™…å·¥ä½œä¸­ï¼Œå¯¹äºHTTPæœåŠ¡çš„æ¢æ´»é€šå¸¸ä¹Ÿé‡‡å–TCPæ¢æ´»åŸç†ï¼Œæ¯•ç«ŸHTTPå»ºç«‹åœ¨TCPæœåŠ¡ä¹‹ä¸Šï¼Œæ‰€ä»¥TCPæ¢æ´»åŒæ ·é€‚ç”¨äºHTTPæœåŠ¡ã€‚å¾ˆå¤šHTTPæœåŠ¡å®ç°åŸç†å’Œthriftå¤§åŒå°å¼‚ï¼Œæ‰€ä»¥å½“TCPæ¢æ´»çš„rståŒ…ä¸¢å¤±åï¼ŒHTTPæœåŠ¡åŒæ ·ä¼šhangåœ¨è¯»å–è¿æ¥æ•°æ®ã€‚</p>

<p>ä¸ºäº†é¿å…rståŒ…ä¸¢å¤±ï¼ŒHTTPæœåŠ¡é€šå¸¸ä½¿ç”¨HTTPæ¢æ´»è¯·æ±‚ï¼šæ¢æµ‹ç«¯å¯¹è¢«æ¢æµ‹ç«¯å‘é€ç‰¹å®šçš„HTTPè¯·æ±‚ï¼Œå¹¶ä¸”éªŒè¯è¢«æ¢æµ‹ç«¯çš„å“åº”æ•°æ®æ˜¯å¦ç¬¦åˆé¢„æœŸã€‚å¦‚æœrståŒ…ä¸¢å¤±ï¼ŒæœåŠ¡ç«¯è¿æ¥æœ€å·®çš„æƒ…å†µä¸‹ä¼šå¤„äºTIME_WAITçŠ¶æ€ï¼Œç»è¿‡2å€è¶…æ—¶æ—¶é—´åæœåŠ¡ç«¯ä¼šä¸»åŠ¨å…³é—­è¿æ¥é‡Šæ”¾èµ„æºï¼Œè¿™æ ·æœåŠ¡ç«¯çš„å·¥ä½œçº¿ç¨‹ä¸ä¼šé•¿æ—¶é—´çš„è¢«å ç”¨ï¼Œç›¸æ¯”äºç”¨TCPæ¢æ´»è¦å¥½çš„å¤šã€‚HTTPæ¢æ´»åŸç†å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚
<img src="https://xiazemin.github.io/MyBlog/img/livenessprobe_http.png" /></p>

<p>æ­¤æ—¶rståŒ…è™½ç„¶ä¸¢å¤±ï¼Œä½†æ˜¯ç”±äºæ¢æµ‹ä½¿ç”¨çš„HTTPè¯·æ±‚ï¼Œé‚£ä¹ˆæ•´ä¸ªè¯·æ±‚çš„äº¤äº’å°±ä¼šå®Œæˆï¼ˆæ¢æµ‹ç«¯ä¼šç­‰å¾…æœåŠ¡ç«¯çš„å“åº”æ•°æ®ï¼Œæ‰€ä»¥èƒ½å¤Ÿç¡®ä¿æœåŠ¡ç«¯èƒ½å¤Ÿå®Œæˆè¿™ä¸ªå“åº”ï¼‰ï¼ŒæœåŠ¡ç«¯å‘é€å®Œå“åº”æ•°æ®åä¼šä¸»åŠ¨å…³é—­è¿æ¥ï¼Œå‘é€FINåŒ…ï¼ˆä¸€èˆ¬çš„HTTPæœåŠ¡æ¡†æ¶é»˜è®¤éƒ½ä¼šè¿™ä¹ˆåšï¼‰ï¼ŒæœåŠ¡ç«¯è¿æ¥å¤„äºTIME_WAITçŠ¶æ€ï¼Œç»è¿‡ä¸€æ®µæ—¶é—´åè¿æ¥é‡Šæ”¾ï¼Œä¸ä¼šé•¿æ—¶é—´å ç”¨æœåŠ¡ç«¯èµ„æºã€‚</p>

<p>å¯¹äºHTTPæœåŠ¡ï¼Œæˆ‘ä»¬éœ€è¦æä¾›ä¸€ä¸ªä¸è€—è´¹cpuå’Œå†…å­˜çš„è°ƒç”¨æ¥å£ï¼Œè¿™ä¸ªæ¥å£åªæ˜¯ä¸ºäº†æ»¡è¶³HTTPæ¢æ´»è¯·æ±‚è°ƒç”¨ï¼Œå¦‚æœæ¢æ´»æ¥å£æ­»äº†ï¼Œå¯ä»¥è®¤ä¸ºè¿™ä¸ªæœåŠ¡ä¹Ÿæ­»äº†ã€‚</p>

<p>å¦‚ä½•ç¡®ä¿ä¸è¢«æ¢æ´»ææ­»ï¼Ÿ
æˆ‘ä»¬ä¸èƒ½ä¿è¯ç½‘ç»œæ—¶æ—¶åˆ»åˆ»æ­£å¸¸rståŒ…ä¸ä¸¢å¤±ï¼Œæ‰€ä»¥æˆ‘ä»¬åªèƒ½æ”¹é€ æœåŠ¡ä½¿å¾—å…¶æ›´å¥å£®ã€‚
æ­£ç¡®è§£å†³æ–¹æ¡ˆå¦‚ä¸‹ï¼š</p>

<p>æœåŠ¡ç«¯åŠ å…¥è¯»è¶…æ—¶æ—¶é—´ã€‚å½“rståŒ…ä¸¢å¤±å¯¼è‡´æœåŠ¡ç«¯çº¿ç¨‹hangåœ¨è¯»å–ä¸Šï¼Œè¶…è¿‡ä¸€å®šæ—¶é—´åæœåŠ¡ç«¯çº¿ç¨‹ä¼šä¸»åŠ¨æ–­å¼€è¿æ¥ï¼Œé‡Šæ”¾èµ„æºï¼Œä»è€Œç¡®ä¿æœåŠ¡ç«¯çº¿ç¨‹èƒ½å¤ŸæœåŠ¡äºå…¶å®ƒè¯·æ±‚ã€‚
å®¢æˆ·ç«¯è¯·æ±‚æœåŠ¡ç«¯åŠ å…¥è¶…æ—¶é™åˆ¶å¹¶è¿›è¡Œé‡è¯•ã€‚å½“ä¸€ä¸ªæœåŠ¡hangæ­»ï¼Œå¯¼è‡´è¿æ¥å…¶ä¸Šçš„å®¢æˆ·ç«¯ä¹Ÿhangä½åï¼Œè¶…è¿‡ä¸€æ®µæ—¶é—´åï¼Œå®¢æˆ·ç«¯ä¸»åŠ¨æ–­å¼€è¿æ¥å¹¶ä¸”å°è¯•è¯·æ±‚å…¶å®ƒå¯ç”¨æœåŠ¡ã€‚</p>

<ol>
  <li>TCPä¿æ´»çš„å¿…è¦æ€§</li>
</ol>

<p>1) å¾ˆå¤šé˜²ç«å¢™ç­‰å¯¹äºç©ºé—²socketè‡ªåŠ¨å…³é—­</p>

<p>2) å¯¹äºéæ­£å¸¸æ–­å¼€, æœåŠ¡å™¨å¹¶ä¸èƒ½æ£€æµ‹åˆ°. ä¸ºäº†å›æ”¶èµ„æº, å¿…é¡»æä¾›ä¸€ç§æ£€æµ‹æœºåˆ¶.</p>

<ol>
  <li>å¯¼è‡´TCPæ–­è¿çš„å› ç´ </li>
</ol>

<p>å¦‚æœç½‘ç»œæ­£å¸¸, socketä¹Ÿé€šè¿‡closeæ“ä½œæ¥è¿›è¡Œä¼˜é›…çš„å…³é—­, é‚£ä¹ˆä¸€åˆ‡å®Œç¾. å¯æ˜¯æœ‰å¾ˆå¤šæƒ…å†µ, æ¯”å¦‚ç½‘çº¿æ•…éšœ, å®¢æˆ·ç«¯ä¸€ä¾§çªç„¶æ–­ç”µæˆ–è€…å´©æºƒç­‰ç­‰, è¿™äº›æƒ…å†µserverå¹¶ä¸èƒ½æ­£å¸¸æ£€æµ‹åˆ°è¿æ¥çš„æ–­å¼€.</p>

<ol>
  <li>ä¿æ´»çš„ä¸¤ç§æ–¹å¼:</li>
</ol>

<p>1) åº”ç”¨å±‚é¢çš„å¿ƒè·³æœºåˆ¶</p>

<p>è‡ªå®šä¹‰å¿ƒè·³æ¶ˆæ¯å¤´. ä¸€èˆ¬å®¢æˆ·ç«¯ä¸»åŠ¨å‘é€, æœåŠ¡å™¨æ¥æ”¶åè¿›è¡Œå›åº”(ä¹Ÿå¯ä»¥ä¸å›åº”). è¿™é‡Œä¸è¿›è¡Œè¯¦è¿°.</p>

<p>PS: æœ‰äººä»è½¯ä»¶çš„åŠŸèƒ½è§’åº¦åˆ—å‡ºç¬¬ä¸‰ç§æ–¹å¼, å°±æ˜¯é€šè¿‡ç¬¬ä¸‰æ–¹è½¯ä»¶æ¥è¿›è¡Œæ¢æµ‹, ç¡®å®šè¿æ¥çš„æœ‰æ•ˆæ€§. è¿™ç§æ–¹å¼å±€é™æ€§å¾ˆå¤§, è€Œä¸”ä¸å±äºè½¯ä»¶å†…éƒ¨çš„åŠŸèƒ½å®ç°. ä¸è¿›è¡Œè®¨è®º.</p>

<p>2) TCPåè®®è‡ªå¸¦çš„ä¿æ´»åŠŸèƒ½</p>

<p>æ‰“å¼€keep-aliveåŠŸèƒ½å³å¯. å…·ä½“å±æ€§ä¹Ÿå¯ä»¥é€šè¿‡APIè®¾å®š.</p>

<ol>
  <li>ä¸¤ç§æ–¹å¼çš„ä¼˜åŠ£æ€§</li>
</ol>

<p>TCPåè®®è‡ªå¸¦çš„ä¿æ´»åŠŸèƒ½, ä½¿ç”¨èµ·æ¥ç®€å•, å‡å°‘äº†åº”ç”¨å±‚ä»£ç çš„å¤æ‚åº¦. æ¨æµ‹ä¹Ÿä¼šæ›´èŠ‚çœæµé‡, å› ä¸ºä¸€èˆ¬æ¥è¯´åº”ç”¨å±‚çš„æ•°æ®ä¼ è¾“åˆ°åè®®å±‚æ—¶éƒ½ä¼šè¢«åŠ ä¸Šé¢å¤–çš„åŒ…å¤´åŒ…å°¾. ç”±TCPåè®®æä¾›çš„æ£€æ´», å…¶å‘çš„æ¢æµ‹åŒ…, ç†è®ºä¸Šå®ç°çš„ä¼šæ›´ç²¾å¦™(ç”¨æ›´å°‘çš„å­—èŠ‚å®Œæˆæ›´å¤šçš„ç›®æ ‡), è€—è´¹æ›´å°‘çš„æµé‡.</p>

<p>ç”±åº”ç”¨è‡ªå·±å®ç°çš„åº”ç”¨å±‚çš„å¿ƒè·³, ä¸ºå¿ƒè·³æ¶ˆæ¯é¢å¤–å®šä¹‰ä¸€ä¸ªæ¶ˆæ¯ç±»å‹å°±å¯ä»¥äº†. å°±æ˜¯åº”ç”¨æ­£å¸¸çš„æ¶ˆæ¯åŒ…, åªæ˜¯è¿™ä¸ªåŒ…ç‰¹æ®Šç‚¹, ä¸“é—¨ç”¨æ¥æ£€æ´»è€Œå·², é€šå¸¸æ¯”è¾ƒå°, å¯èƒ½åªæœ‰æ¶ˆæ¯å¤´å°±å¯ä»¥äº†, é™¤ééœ€è¦é¢å¤–çš„ä¿¡æ¯.</p>

<p>åº”ç”¨å±‚å¿ƒè·³çš„å¥½å¤„æˆ‘ä¸ªäººçš„ç†è§£æœ‰ä¸¤ç‚¹:</p>

<p>ä¸€æ˜¯æ¯”è¾ƒçµæ´», å› ä¸ºåè®®å±‚çš„å¿ƒè·³åªèƒ½æä¾›æœ€çº¯ç²¹çš„æ£€æ´»åŠŸèƒ½, ä½†æ˜¯åº”ç”¨å±‚è‡ªå·±å¯ä»¥éšæ„æ§åˆ¶, åŒ…æ‹¬åè®®å¯èƒ½æä¾›çš„æ˜¯ç§’çº§çš„, ä½†æ˜¯ä½ æƒ³åšæˆæ¯«ç§’çº§çš„éƒ½ä»»æ„(è™½ç„¶å®é™…å‡ ä¹ä¸ä¼šæœ‰è¿™ç§æ—¶é—´çº§åˆ«çš„å¿ƒè·³), åŒ…é‡Œè¿˜ç”šè‡³å¯ä»¥æºå¸¦é¢å¤–çš„ä¿¡æ¯, è¿™äº›éƒ½æ˜¯çµæ´»ä¹‹å¤„.</p>

<p>äºŒæ˜¯é€šç”¨, åº”ç”¨å±‚çš„å¿ƒè·³ä¸ä¾èµ–åè®®. å¦‚æœæœ‰ä¸€å¤©ä¸ç”¨TCPè¦æ”¹ä¸ºUDPäº†, åè®®å±‚ä¸æä¾›å¿ƒè·³æœºåˆ¶äº†, ä½†æ˜¯ä½ åº”ç”¨å±‚çš„å¿ƒè·³ä¾æ—§æ˜¯é€šç”¨çš„, å¯èƒ½åªéœ€è¦åšå°‘è®¸æ”¹åŠ¨å°±å¯ä»¥ç»§ç»­ä½¿ç”¨.</p>

<p>åº”ç”¨å±‚å¿ƒè·³çš„ä¸å¥½çš„åœ°æ–¹ä¹Ÿå¾ˆæ˜¾è€Œæ˜“è§, å¢åŠ å¼€å‘å·¥ä½œé‡, ç”±äºåº”ç”¨ç‰¹å®šçš„ç½‘ç»œæ¡†æ¶, è¿˜å¯èƒ½å¾ˆå¢åŠ ä»£ç ç»“æ„çš„å¤æ‚åº¦. å†å°±æ˜¯æ ¹æ®ä¸Šé¢çš„æ¨æµ‹, åº”ç”¨å±‚å¿ƒè·³çš„æµé‡æ¶ˆè€—è¿˜æ˜¯æ›´å¤§çš„, æ¯•ç«Ÿè¿™æœ¬è´¨ä¸Šè¿˜æ˜¯ä¸ªæ™®é€šçš„æ•°æ®åŒ….</p>

<ol>
  <li>åˆ°åº•é€‰ç”¨é‚£ç§å¿ƒè·³æ–¹å¼?</li>
</ol>

<p>ä¼˜åŠ£ç‚¹ç¬¬4èŠ‚å·²ç»è¿›è¡Œäº†é˜è¿°, å› æ­¤å¦‚æœèƒ½ç¡®å®šä½ ä»¬æ›´æ¢åè®®çš„å¯èƒ½æ€§éå¸¸å°, åŒæ—¶åªæ˜¯éœ€è¦æ£€æ´»çš„åŠŸèƒ½, é‚£ä¹ˆç”¨åè®®è‡ªå¸¦çš„å°±ç»å¯¹OKäº†, ä½¿ç”¨ç®€å•è€Œä¸”é«˜æ•ˆ. æœ‰äº›è‡ªè´Ÿçš„äººæ€»å–œæ¬¢ç”¨è‡ªå·±æçš„, æ¥ä»£æ›¿æˆç†Ÿåè®®è‡ªå¸¦çš„ä¸œè¥¿, ä»£æ›¿ç³»ç»Ÿå†…æ ¸æä¾›çš„ä¸œè¥¿, å…¶å®å¾€å¾€ä½ åº”ç”¨å±‚å®ç°çš„ä¸œè¥¿, éƒ½æ˜¯æ›´æ‹™åŠ£çš„. ç½‘ä¸Šçœ‹äº†ä¸€äº›å…³äºåè®®çš„Keep-aliveä¸é è°±çš„è¯´æ³•, ä¹Ÿéƒ½æ¯”è¾ƒç©ºæƒ³å’Œæƒ³å½“ç„¶, éƒ½æ²¡æœ‰æ‹¿å‡ºä»»ä½•äº‹å®è®ºæ®æˆ–å®éªŒæ•°æ®.</p>

<ol>
  <li>ç±»Unixå¹³å°å¦‚ä½•ä½¿ç”¨Keep-alive</li>
</ol>

<p>keepaliveé»˜è®¤æ˜¯å…³é—­çš„, å› ä¸ºè™½ç„¶æµé‡æå°, æ¯•ç«Ÿæ˜¯å¼€é”€. å› æ­¤éœ€è¦ç”¨æˆ·æ‰‹åŠ¨å¼€å¯. æœ‰ä¸¤ç§æ–¹å¼å¼€å¯.</p>

<p>1) åœ¨ä»£ç é‡Œé’ˆå¯¹æ¯ä¸ªsocketè¿›è¡Œå•ç‹¬è®¾å®š, ä½¿ç”¨èµ·æ¥çµæ´».</p>

<p>é™¤äº†keepAlive å¼€å…³, è¿˜æœ‰keepIdle, keepInterval, keepCount 3ä¸ªå±æ€§, ä½¿ç”¨ç®€å•, å¦‚ä¸‹:
int keepAlive = 1;   // å¼€å¯keepaliveå±æ€§. ç¼ºçœå€¼: 0(å…³é—­)<br />
int keepIdle = 60;   // å¦‚æœåœ¨60ç§’å†…æ²¡æœ‰ä»»ä½•æ•°æ®äº¤äº’,åˆ™è¿›è¡Œæ¢æµ‹. ç¼ºçœå€¼:7200(s)<br />
int keepInterval = 5;   // æ¢æµ‹æ—¶å‘æ¢æµ‹åŒ…çš„æ—¶é—´é—´éš”ä¸º5ç§’. ç¼ºçœå€¼:75(s)<br />
int keepCount = 2;   // æ¢æµ‹é‡è¯•çš„æ¬¡æ•°. å…¨éƒ¨è¶…æ—¶åˆ™è®¤å®šè¿æ¥å¤±æ•ˆ..ç¼ºçœå€¼:9(æ¬¡)<br />
setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, (void<em>)&amp;keepAlive, sizeof(keepAlive));<br />
setsockopt(s, SOL_TCP, TCP_KEEPIDLE, (void</em>)&amp;keepIdle, sizeof(keepIdle));<br />
setsockopt(s, SOL_TCP, TCP_KEEPINTVL, (void<em>)&amp;keepInterval, sizeof(keepInterval));<br />
setsockopt(s, SOL_TCP, TCP_KEEPCNT, (void</em>)&amp;keepCount, sizeof(keepCount));</p>

<p>ä½¿ç”¨æ—¶éœ€è¦#include &lt;netinet/tcp.h&gt;, å¦åˆ™SOL_TCPå’ŒTCP_KEEPIDLEç­‰3ä¸ªå®æ‰¾ä¸åˆ°.</p>

<p>2) ä¿®æ”¹é…ç½®æ–‡ä»¶, å¯¹æ•´ä¸ªç³»ç»Ÿæ‰€æœ‰çš„socketæœ‰æ•ˆ.</p>

<p>æˆ‘ä»¬å¯ä»¥ç”¨catå‘½ä»¤æŸ¥çœ‹åˆ°ç³»ç»Ÿä¸­è¿™å‡ ä¸ªé»˜è®¤çš„å€¼.</p>

<p>#cat /proc/sys/net/ipv4/tcp_keepalive_time  7200</p>

<p>#cat /proc/sys/net/ipv4/tcp_keepalive_intvl  75</p>

<p>#cat /proc/sys/net/ipv4/tcp_keepalive_probes  9</p>

<p>ä¿®æ”¹å®ƒä»¬:</p>

<p>#echo 60 &gt; /proc/sys/net/ipv4/tcp_keepalive_time</p>

<p>#echo 5 &gt; /proc/sys/net/ipv4/tcp_keepalive_intvl</p>

<p>#echo 3 &gt; /proc/sys/net/ipv4/tcp_keepalive_probes</p>

<p>TCPåè®®ä¸­æœ‰é•¿è¿æ¥å’ŒçŸ­è¿æ¥ä¹‹åˆ†ã€‚çŸ­è¿æ¥åœ¨æ•°æ®åŒ…å‘é€å®Œæˆåå°±ä¼šè‡ªå·±æ–­å¼€ï¼Œé•¿è¿æ¥åœ¨å‘åŒ…å®Œæ¯•åï¼Œä¼šåœ¨ä¸€å®šçš„æ—¶é—´å†…ä¿æŒè¿æ¥ï¼Œå³æˆ‘ä»¬é€šå¸¸æ‰€è¯´çš„Keepaliveï¼ˆå­˜æ´»å®šæ—¶å™¨ï¼‰åŠŸèƒ½ã€‚  www.2cto.com<br />
é»˜è®¤çš„Keepaliveè¶…æ—¶éœ€è¦7,200,000 millisecondsï¼Œå³2å°æ—¶ï¼Œæ¢æµ‹æ¬¡æ•°ä¸º5æ¬¡ã€‚å®ƒçš„åŠŸæ•ˆå’Œç”¨æˆ·è‡ªå·±å®ç°çš„å¿ƒè·³æœºåˆ¶æ˜¯ä¸€æ ·çš„ã€‚å¼€å¯KeepaliveåŠŸèƒ½éœ€è¦æ¶ˆè€—é¢å¤–çš„å®½å¸¦å’Œæµé‡ï¼Œå°½ç®¡è¿™å¾®ä¸è¶³é“ï¼Œä½†åœ¨æŒ‰æµé‡è®¡è´¹çš„ç¯å¢ƒä¸‹å¢åŠ äº†è´¹ç”¨ï¼Œå¦ä¸€æ–¹é¢ï¼ŒKeepaliveè®¾ç½®ä¸åˆç†æ—¶å¯èƒ½ä¼šå› ä¸ºçŸ­æš‚çš„ç½‘ç»œæ³¢åŠ¨è€Œæ–­å¼€å¥åº·çš„TCPè¿æ¥ã€‚</p>

<p>keepaliveå¹¶ä¸æ˜¯TCPè§„èŒƒçš„ä¸€éƒ¨åˆ†ã€‚åœ¨Host Requirements RFCç½—åˆ—æœ‰ä¸ä½¿ç”¨å®ƒçš„ä¸‰ä¸ªç†ç”±ï¼šï¼ˆ1ï¼‰åœ¨çŸ­æš‚çš„æ•…éšœæœŸé—´ï¼Œå®ƒä»¬å¯èƒ½å¼•èµ·ä¸€ä¸ªè‰¯å¥½è¿æ¥ï¼ˆgood connectionï¼‰è¢«é‡Šæ”¾ï¼ˆdroppedï¼‰ï¼Œï¼ˆ2ï¼‰å®ƒä»¬æ¶ˆè´¹äº†ä¸å¿…è¦çš„å®½å¸¦ï¼Œï¼ˆ3ï¼‰åœ¨ä»¥æ•°æ®åŒ…è®¡è´¹çš„äº’è”ç½‘ä¸Šå®ƒä»¬ï¼ˆé¢å¤–ï¼‰èŠ±è´¹é‡‘é’±ã€‚ç„¶è€Œï¼Œåœ¨è®¸å¤šçš„å®ç°ä¸­æä¾›äº†å­˜æ´»å®šæ—¶å™¨ã€‚
ä¸€äº›æœåŠ¡å™¨åº”ç”¨ç¨‹åºå¯èƒ½ä»£è¡¨å®¢æˆ·ç«¯å ç”¨èµ„æºï¼Œå®ƒä»¬éœ€è¦çŸ¥é“å®¢æˆ·ç«¯ä¸»æœºæ˜¯å¦å´©æºƒã€‚å­˜æ´»å®šæ—¶å™¨å¯ä»¥ä¸ºè¿™äº›åº”ç”¨ç¨‹åºæä¾›æ¢æµ‹æœåŠ¡ã€‚TelnetæœåŠ¡å™¨å’ŒRloginæœåŠ¡å™¨çš„è®¸å¤šç‰ˆæœ¬éƒ½é»˜è®¤æä¾›å­˜æ´»é€‰é¡¹ã€‚
ä¸ªäººè®¡ç®—æœºç”¨æˆ·ä½¿ç”¨TCP/IPåè®®é€šè¿‡Telnetç™»å½•ä¸€å°ä¸»æœºï¼Œè¿™æ˜¯èƒ½å¤Ÿè¯´æ˜éœ€è¦ä½¿ç”¨å­˜æ´»å®šæ—¶å™¨çš„ä¸€ä¸ªå¸¸ç”¨ä¾‹å­ã€‚å¦‚æœæŸä¸ªç”¨æˆ·åœ¨ä½¿ç”¨ç»“æŸæ—¶åªæ˜¯å…³æ‰äº†ç”µæºï¼Œè€Œæ²¡æœ‰æ³¨é”€ï¼ˆlog offï¼‰ï¼Œé‚£ä¹ˆä»–å°±ç•™ä¸‹äº†ä¸€ä¸ªåŠæ‰“å¼€ï¼ˆhalf-openï¼‰çš„è¿æ¥ã€‚å¦‚æœå®¢æˆ·ç«¯æ¶ˆå¤±ï¼Œç•™ç»™äº†æœåŠ¡å™¨ç«¯åŠæ‰“å¼€çš„è¿æ¥ï¼Œå¹¶ä¸”æœåŠ¡å™¨åˆåœ¨ç­‰å¾…å®¢æˆ·ç«¯çš„æ•°æ®ï¼Œé‚£ä¹ˆç­‰å¾…å°†æ°¸è¿œæŒç»­ä¸‹å»ã€‚å­˜æ´»ç‰¹å¾çš„ç›®çš„å°±æ˜¯åœ¨æœåŠ¡å™¨ç«¯æ£€æµ‹è¿™ç§åŠæ‰“å¼€è¿æ¥ã€‚
ä¹Ÿå¯ä»¥åœ¨å®¢æˆ·ç«¯è®¾ç½®å­˜æ´»å™¨é€‰é¡¹ï¼Œä¸”æ²¡æœ‰ä¸å…è®¸è¿™æ ·åšçš„ç†ç”±ï¼Œä½†é€šå¸¸è®¾ç½®åœ¨æœåŠ¡å™¨ã€‚å¦‚æœè¿æ¥ä¸¤ç«¯éƒ½éœ€è¦æ¢æµ‹å¯¹æ–¹æ˜¯å¦æ¶ˆå¤±ï¼Œé‚£ä¹ˆå°±å¯ä»¥åœ¨ä¸¤ç«¯åŒæ—¶è®¾ç½®ï¼ˆæ¯”å¦‚NFSï¼‰ã€‚</p>

<p>keepaliveå·¥ä½œåŸç†ï¼š
è‹¥åœ¨ä¸€ä¸ªç»™å®šè¿æ¥ä¸Šï¼Œä¸¤å°æ—¶ä¹‹å†…æ— ä»»ä½•æ´»åŠ¨ï¼ŒæœåŠ¡å™¨ä¾¿å‘å®¢æˆ·ç«¯å‘é€ä¸€ä¸ªæ¢æµ‹æ®µã€‚ï¼ˆæˆ‘ä»¬å°†åœ¨ä¸‹é¢çš„ä¾‹å­ä¸­çœ‹åˆ°æ¢æµ‹æ®µçš„æ ·å­ã€‚ï¼‰å®¢æˆ·ç«¯ä¸»æœºå¿…é¡»æ˜¯ä¸‹åˆ—å››ç§çŠ¶æ€ä¹‹ä¸€ï¼š
1) å®¢æˆ·ç«¯ä¸»æœºä¾æ—§æ´»è·ƒï¼ˆupï¼‰è¿è¡Œï¼Œå¹¶ä¸”ä»æœåŠ¡å™¨å¯åˆ°è¾¾ã€‚ä»å®¢æˆ·ç«¯TCPçš„æ­£å¸¸å“åº”ï¼ŒæœåŠ¡å™¨çŸ¥é“å¯¹æ–¹ä»ç„¶æ´»è·ƒã€‚æœåŠ¡å™¨çš„TCPä¸ºæ¥ä¸‹æ¥çš„ä¸¤å°æ—¶å¤ä½å­˜æ´»å®šæ—¶å™¨ï¼Œå¦‚æœåœ¨è¿™ä¸¤ä¸ªå°æ—¶åˆ°æœŸä¹‹å‰ï¼Œè¿æ¥ä¸Šå‘ç”Ÿåº”ç”¨ç¨‹åºçš„é€šä¿¡ï¼Œåˆ™å®šæ—¶å™¨é‡æ–°ä¸ºå¾€ä¸‹çš„ä¸¤å°æ—¶å¤ä½ï¼Œå¹¶ä¸”æ¥ç€äº¤æ¢æ•°æ®ã€‚
2) å®¢æˆ·ç«¯å·²ç»å´©æºƒï¼Œæˆ–è€…å·²ç»å…³é—­ï¼ˆdownï¼‰ï¼Œæˆ–è€…æ­£åœ¨é‡å¯è¿‡ç¨‹ä¸­ã€‚åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹ï¼Œå®ƒçš„TCPéƒ½ä¸ä¼šå“åº”ã€‚æœåŠ¡å™¨æ²¡æœ‰æ”¶åˆ°å¯¹å…¶å‘å‡ºæ¢æµ‹çš„å“åº”ï¼Œå¹¶ä¸”åœ¨75ç§’ä¹‹åè¶…æ—¶ã€‚æœåŠ¡å™¨å°†æ€»å…±å‘é€10ä¸ªè¿™æ ·çš„æ¢æµ‹ï¼Œæ¯ä¸ªæ¢æµ‹75ç§’ã€‚å¦‚æœæ²¡æœ‰æ”¶åˆ°ä¸€ä¸ªå“åº”ï¼Œå®ƒå°±è®¤ä¸ºå®¢æˆ·ç«¯ä¸»æœºå·²ç»å…³é—­å¹¶ç»ˆæ­¢è¿æ¥ã€‚
3) å®¢æˆ·ç«¯æ›¾ç»å´©æºƒï¼Œä½†å·²ç»é‡å¯ã€‚è¿™ç§æƒ…å†µä¸‹ï¼ŒæœåŠ¡å™¨å°†ä¼šæ”¶åˆ°å¯¹å…¶å­˜æ´»æ¢æµ‹çš„å“åº”ï¼Œä½†è¯¥å“åº”æ˜¯ä¸€ä¸ªå¤ä½ï¼Œä»è€Œå¼•èµ·æœåŠ¡å™¨å¯¹è¿æ¥çš„ç»ˆæ­¢ã€‚
4) å®¢æˆ·ç«¯ä¸»æœºæ´»è·ƒè¿è¡Œï¼Œä½†ä»æœåŠ¡å™¨ä¸å¯åˆ°è¾¾ã€‚è¿™ä¸çŠ¶æ€2ç±»ä¼¼ï¼Œå› ä¸ºTCPæ— æ³•åŒºåˆ«å®ƒä»¬ä¸¤ä¸ªã€‚å®ƒæ‰€èƒ½è¡¨æ˜çš„ä»…æ˜¯æœªæ”¶åˆ°å¯¹å…¶æ¢æµ‹çš„å›å¤ã€‚</p>

<p>æœåŠ¡å™¨ä¸å¿…æ‹…å¿ƒå®¢æˆ·ç«¯ä¸»æœºè¢«å…³é—­ç„¶åé‡å¯çš„æƒ…å†µï¼ˆè¿™é‡ŒæŒ‡çš„æ˜¯æ“ä½œå‘˜æ‰§è¡Œçš„æ­£å¸¸å…³é—­ï¼Œè€Œä¸æ˜¯ä¸»æœºçš„å´©æºƒï¼‰ã€‚å½“ç³»ç»Ÿè¢«æ“ä½œå‘˜å…³é—­æ—¶ï¼Œæ‰€æœ‰çš„åº”ç”¨ç¨‹åºè¿›ç¨‹ï¼ˆä¹Ÿå°±æ˜¯å®¢æˆ·ç«¯è¿›ç¨‹ï¼‰éƒ½å°†è¢«ç»ˆæ­¢ï¼Œå®¢æˆ·ç«¯TCPä¼šåœ¨è¿æ¥ä¸Šå‘é€ä¸€ä¸ªFINã€‚æ”¶åˆ°è¿™ä¸ªFINåï¼ŒæœåŠ¡å™¨TCPå‘æœåŠ¡å™¨è¿›ç¨‹æŠ¥å‘Šä¸€ä¸ªæ–‡ä»¶ç»“æŸï¼Œä»¥å…è®¸æœåŠ¡å™¨æ£€æµ‹è¿™ç§çŠ¶æ€ã€‚
åœ¨ç¬¬ä¸€ç§çŠ¶æ€ä¸‹ï¼ŒæœåŠ¡å™¨åº”ç”¨ç¨‹åºä¸çŸ¥é“å­˜æ´»æ¢æµ‹æ˜¯å¦å‘ç”Ÿã€‚å‡¡äº‹éƒ½æ˜¯ç”±TCPå±‚å¤„ç†çš„ï¼Œå­˜æ´»æ¢æµ‹å¯¹åº”ç”¨ç¨‹åºé€æ˜ï¼Œç›´åˆ°åé¢2ï¼Œ3ï¼Œ4ä¸‰ç§çŠ¶æ€å‘ç”Ÿã€‚åœ¨è¿™ä¸‰ç§çŠ¶æ€ä¸‹ï¼Œé€šè¿‡æœåŠ¡å™¨çš„TCPï¼Œè¿”å›ç»™æœåŠ¡å™¨åº”ç”¨ç¨‹åºé”™è¯¯ä¿¡æ¯ã€‚ï¼ˆé€šå¸¸æœåŠ¡å™¨å‘ç½‘ç»œå‘å‡ºä¸€ä¸ªè¯»è¯·æ±‚ï¼Œç­‰å¾…å®¢æˆ·ç«¯çš„æ•°æ®ã€‚å¦‚æœå­˜æ´»ç‰¹å¾è¿”å›ä¸€ä¸ªé”™è¯¯ä¿¡æ¯ï¼Œåˆ™å°†è¯¥ä¿¡æ¯ä½œä¸ºè¯»æ“ä½œçš„è¿”å›å€¼è¿”å›ç»™æœåŠ¡å™¨ã€‚ï¼‰åœ¨çŠ¶æ€2ï¼Œé”™è¯¯ä¿¡æ¯ç±»ä¼¼äºâ€œè¿æ¥è¶…æ—¶â€ã€‚çŠ¶æ€3åˆ™ä¸ºâ€œè¿æ¥è¢«å¯¹æ–¹å¤ä½â€ã€‚ç¬¬å››ç§çŠ¶æ€çœ‹èµ·æ¥åƒè¿æ¥è¶…æ—¶ï¼Œæˆ–è€…æ ¹æ®æ˜¯å¦æ”¶åˆ°ä¸è¯¥è¿æ¥ç›¸å…³çš„ICMPé”™è¯¯ä¿¡æ¯ï¼Œè€Œå¯èƒ½è¿”å›å…¶å®ƒçš„é”™è¯¯ä¿¡æ¯ã€‚</p>

<p>linuxå†…æ ¸åŒ…å«å¯¹keepaliveçš„æ”¯æŒã€‚å…¶ä¸­ä½¿ç”¨äº†ä¸‰ä¸ªå‚æ•°ï¼štcp_keepalive_timeï¼ˆå¼€å¯keepaliveçš„é—²ç½®æ—¶ é•¿ï¼‰tcp_keepalive_intvlï¼ˆkeepaliveæ¢æµ‹åŒ…çš„å‘é€é—´éš”ï¼‰å’Œtcp_keepalive_probes ï¼ˆå¦‚æœå¯¹æ–¹ä¸äºˆåº”ç­”ï¼Œæ¢æµ‹åŒ…çš„å‘é€æ¬¡æ•°ï¼‰ï¼›åœ¨liunxä¸­ï¼Œkeepaliveæ˜¯ä¸€ä¸ªå¼€å…³é€‰é¡¹ï¼Œå¯ä»¥é€šè¿‡å‡½æ•°æ¥ä½¿èƒ½ã€‚å…·ä½“åœ°è¯´ï¼Œå¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä»£ç ï¼š
setsockopt(rs, SOL_SOCKET, SO_KEEPALIVE, (void *)&amp;keepAlive, sizeof(keepAlive));
å½“tcpæ£€æµ‹åˆ°å¯¹ç«¯socketä¸å†å¯ç”¨æ—¶(ä¸èƒ½å‘å‡ºæ¢æµ‹åŒ…,æˆ–æ¢æµ‹åŒ…æ²¡æœ‰æ”¶åˆ°ACKçš„å“åº”åŒ…),selectä¼šè¿”å›socketå¯è¯»,å¹¶ä¸”åœ¨recvæ—¶è¿”å›-1,åŒæ—¶ç½®ä¸Šerrnoä¸ºETIMEDOUTã€‚æ­¤æ—¶TCPçš„çŠ¶æ€æ˜¯æ–­å¼€çš„ã€‚</p>

<p>keepaliveå‚æ•°è®¾ç½®ä»£ç å¦‚ä¸‹ï¼š 
// å¼€å¯KeepAlive
BOOL bKeepAlive = TRUE;
int nRet = ::setsockopt(socket_handle, SOL_SOCKET, SO_KEEPALIVE, (char*)&amp;bKeepAlive, sizeof(bKeepAlive));
if (nRet == SOCKET_ERROR)
{
return FALSE;
}</p>

<p>// è®¾ç½®KeepAliveå‚æ•°
tcp_keepalive alive_in                = {0};
tcp_keepalive alive_out                = {0};
alive_in.keepalivetime                = 5000;                // å¼€å§‹é¦–æ¬¡KeepAliveæ¢æµ‹å‰çš„TCPç©ºé—­æ—¶é—´
alive_in.keepaliveinterval        = 1000;                // ä¸¤æ¬¡KeepAliveæ¢æµ‹é—´çš„æ—¶é—´é—´éš”
alive_in.onoff                                = TRUE;
unsigned long ulBytesReturn = 0;
nRet = WSAIoctl(socket_handle, SIO_KEEPALIVE_VALS, &amp;alive_in, sizeof(alive_in),
&amp;alive_out, sizeof(alive_out), &amp;ulBytesReturn, NULL, NULL);
if (nRet == SOCKET_ERROR)
{
return FALSE;
}</p>

<p>å¼€å¯Keepaliveé€‰é¡¹ä¹‹åï¼Œå¯¹äºä½¿ç”¨IOCPæ¨¡å‹çš„æœåŠ¡å™¨ç«¯ç¨‹åºæ¥è¯´ï¼Œä¸€æ—¦æ£€æµ‹åˆ°è¿æ¥æ–­å¼€ï¼ŒGetQueuedCompletionStatuså‡½æ•°å°†ç«‹å³è¿”å›FALSEï¼Œä½¿å¾—æœåŠ¡å™¨ç«¯èƒ½åŠæ—¶æ¸…é™¤è¯¥è¿æ¥ã€é‡Šæ”¾è¯¥è¿æ¥ç›¸å…³çš„èµ„æºã€‚å¯¹äºä½¿ç”¨selectæ¨¡å‹çš„å®¢æˆ·ç«¯æ¥è¯´ï¼Œè¿æ¥æ–­å¼€è¢«æ¢æµ‹åˆ°æ—¶ï¼Œä»¥recvç›®çš„é˜»å¡åœ¨socketä¸Šçš„selectæ–¹æ³•å°†ç«‹å³è¿”å›SOCKET_ERRORï¼Œä»è€Œå¾—çŸ¥è¿æ¥å·²å¤±æ•ˆï¼Œå®¢æˆ·ç«¯ç¨‹åºä¾¿æœ‰æœºä¼šåŠæ—¶æ‰§è¡Œæ¸…é™¤å·¥ä½œã€æé†’ç”¨æˆ·æˆ–é‡æ–°è¿æ¥ã€‚</p>

<p>TCPè¿æ¥éæ­£å¸¸æ–­å¼€çš„æ£€æµ‹(KeepAliveæ¢æµ‹)
æ­¤å¤„çš„â€éæ­£å¸¸æ–­å¼€â€æŒ‡TCPè¿æ¥ä¸æ˜¯ä»¥ä¼˜é›…çš„æ–¹å¼æ–­å¼€,å¦‚ç½‘çº¿æ•…éšœç­‰ç‰©ç†é“¾è·¯çš„åŸå› ,è¿˜æœ‰çªç„¶ä¸»æœºæ–­ç”µç­‰åŸå› 
æœ‰ä¸¤ç§æ–¹æ³•å¯ä»¥æ£€æµ‹:1.TCPè¿æ¥åŒæ–¹å®šæ—¶å‘æ¡æ‰‹æ¶ˆæ¯ 2.åˆ©ç”¨TCPåè®®æ ˆä¸­çš„KeepAliveæ¢æµ‹
ç¬¬äºŒç§æ–¹æ³•ç®€å•å¯é ,åªéœ€å¯¹TCPè¿æ¥ä¸¤ä¸ªSocketè®¾å®šKeepAliveæ¢æµ‹ã€‚</p>

<p>TCPä¿æ´»å¯èƒ½å¸¦æ¥çš„é—®é¢˜</p>

<p>1ï¼Œ ä¸­é—´è®¾å¤‡å› å¤§é‡ä¿æ´»è¿æ¥ï¼Œå¯¼è‡´å…¶è¿æ¥è¡¨æ»¡</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ç½‘å…³è®¾å¤‡ç”±äºä¿æ´»é—®é¢˜ï¼Œå¯¼è‡´å…¶è¿æ¥è¡¨æ»¡ï¼Œæ— æ³•æ–°å»ºè¿æ¥ï¼ˆXXå±€ç½‘é—¸æ•…éšœæ¡ˆä¾‹ï¼‰æˆ–æ€§èƒ½ä¸‹é™ä¸¥é‡ 2ï¼Œ æ­£å¸¸è¿æ¥è¢«é‡Šæ”¾

   å½“è¿æ¥ä¸€ç«¯åœ¨å‘é€ä¿æ´»æ¢æµ‹æŠ¥æ–‡æ—¶ï¼Œä¸­é—´ç½‘ç»œæ­£å¥½ç”±äºå„ç§å¼‚å¸¸ï¼ˆå¦‚é“¾è·¯ä¸­æ–­ã€ä¸­é—´è®¾å¤‡é‡å¯ç­‰ï¼‰è€Œæ— æ³•å°†è¯¥ä¿æ´»æ¢æµ‹æŠ¥æ–‡æ­£ç¡®è½¬å‘è‡³å¯¹ç«¯æ—¶ï¼Œå¯èƒ½ä¼šå¯¼è‡´æ¢æµ‹çš„ä¸€æ–¹é‡Šæ”¾æœ¬æ¥æ­£å¸¸çš„è¿æ¥ï¼Œä½†æ˜¯è¿™ç§å¯èƒ½æƒ…å†µå‘ç”Ÿçš„æ¦‚ç‡è¾ƒå°ï¼Œå¦å¤–ï¼Œä¸€èˆ¬ä¹Ÿå¯ä»¥å¢åŠ ä¿æ´»æ¢æµ‹æŠ¥æ–‡å‘ç”Ÿçš„æ¬¡æ•°æ¥å‡å°è¿™ç§æƒ…å†µå‘ç”Ÿçš„æ¦‚ç‡å’Œå½±å“ã€‚
</code></pre></div></div>

<p>TCPä¿æ´»çš„è®¾ç½®</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ä¸€èˆ¬è€Œè¨€ï¼Œä¿æ´»æ¢æµ‹ä¸»è¦åœ¨æœåŠ¡å™¨ç«¯å®ç°ï¼Œå¦‚æœåº”ç”¨å±‚æœ‰ç›¸åº”çš„ä¿æ´»æœºåˆ¶æ—¶ï¼Œä¼ è¾“å±‚çš„TCPä¿æ´»å°±å¯ä»¥ä¸ç”¨ã€‚

    åœ¨windowsç³»ç»Ÿä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¿®æ”¹æ³¨å†Œè¡¨ç­‰æ¥è¾¾åˆ°å¼€å¯ã€è°ƒæ•´ä¿æ´»ç›¸å…³ HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters KeepAliveInterval  é¡¹ï¼šTcpip\Parameters æ•°å€¼ç±»å‹ï¼šREG_DWORD - æ—¶é—´ï¼ˆä»¥æ¯«ç§’ä¸ºå•ä½ï¼‰ æœ‰æ•ˆèŒƒå›´ï¼š1 - 0xFFFFFFFF é»˜è®¤å€¼ï¼š1000ï¼ˆ1 ç§’ï¼‰ è¯´æ˜ï¼šæ­¤å‚æ•°ç¡®å®šåœ¨æ”¶åˆ°å“åº”ä¹‹å‰ï¼Œä¿æ´»é‡ä¼ ä¹‹é—´çš„æ—¶é—´é—´éš”ã€‚ä¸€æ—¦æ”¶åˆ°ä¸€ä¸ªå“åº”ï¼Œå°†ç”± KeepAliveTime å€¼é‡æ–°æ§åˆ¶åœ¨ä¸‹ä¸€æ¬¡ä¿æ´»ä¼ è¾“ä¹‹å‰çš„å»¶è¿Ÿã€‚å¦‚æœç»è¿‡ TcpMaxDataRetransmissions æŒ‡å®šçš„é‡æ–°ä¼ è¾“æ¬¡æ•°åä»æ— å“åº”ï¼Œå°†æ”¾å¼ƒè¿æ¥ã€‚  KeepAliveTime  é¡¹ï¼šTcpip\Parameters æ•°å€¼ç±»å‹ï¼šREG_DWORD - æ—¶é—´ï¼ˆä»¥æ¯«ç§’ä¸ºå•ä½ï¼‰ æœ‰æ•ˆèŒƒå›´ï¼š1 - 0xFFFFFFFF é»˜è®¤å€¼ï¼š7,200,000ï¼ˆä¸¤ä¸ªå°æ—¶ï¼‰ è¯´æ˜ï¼šæ­¤å‚æ•°æ§åˆ¶ TCP è¯•å›¾é€šè¿‡å‘é€ä¿æ´»æ•°æ®åŒ…æ¥éªŒè¯ç©ºé—²è¿æ¥æ˜¯å¦ä»ç„¶ä¿æŒçš„æ¬¡æ•°ã€‚å¦‚æœè¿œç¨‹ç³»ç»Ÿä»ç„¶å¯ä»¥è¿æ¥å¹¶ä¸”æ­£åœ¨è¿è¡Œï¼Œå®ƒå°±ä¼šå“åº”ä¿æ´»ä¼ è¾“ã€‚é»˜è®¤æƒ…å†µä¸‹ä¸å‘é€ä¿æ´»æ•°æ®åŒ…ã€‚åº”ç”¨ç¨‹åºå¯ä»¥åœ¨è¿æ¥ä¸Šå¯ç”¨æ­¤åŠŸèƒ½ã€‚
</code></pre></div></div>

<p>Probe æ˜¯ç”±Kubeletæ‰§è¡Œçš„ï¼Œå¯¹ Container çš„å®šæœŸæ£€æµ‹æœºåˆ¶ï¼Œç”¨äºç¡®å®š Container æ˜¯å¦å­˜æ´»ï¼Œæˆ–è€…æ˜¯å¦å¯ä»¥æä¾›æœåŠ¡(æ¥æ”¶è®¿é—®æµé‡)ã€‚</p>

<p>Probeè¢« Kubelet ä½¿ç”¨æ—¶æ ¹æ®å…¶ä½œç”¨åˆ†ä¸ºä¸¤ç±»:</p>

<p>livenessProbe: è¡¨ç¤º Container æ˜¯å¦ä¸ºæ­£å¸¸è¿è¡Œ(running)çŠ¶æ€
å¦‚æœæ¢æµ‹ç»“æœä¸ºFailureï¼ŒKubelet ä¼šæ€æ‰å¯¹åº”çš„å®¹å™¨ï¼Œå¹¶ä¸”æ ¹æ®å…¶ restart policy æ¥å†³å®šæ˜¯å¦é‡å¯;
å¦‚æœ Container æ²¡æœ‰æä¾›è‡ªå®šä¹‰çš„ liveness probeï¼Œé»˜è®¤è§†ä¸ºè¿”å›Successã€‚
éœ€è¦å®šä¹‰initial delayæ¥å†³å®šä»€ä¹ˆæ—¶å€™å¼€å§‹æ¢æµ‹ï¼Œé¿å…åˆå§‹åŒ–æ—¶é—´å¤ªçŸ­å¯¼è‡´ä¸€ç›´å¾ªç¯é‡å¯å®¹å™¨ï¼›
readinessProbe: è¡¨ç¤º Container æ˜¯å¦å¯ä»¥æ­£å¸¸æä¾›æœåŠ¡
å¦‚æœæ¢æµ‹ç»“æœä¸ºFailureï¼Œendpoints controller ä¼šå°†å¯¹åº”çš„ Pod IP ä»æ‰€æœ‰åŒ¹é…ä¸Šçš„ Service çš„ Endpoint åˆ—è¡¨ä¸­ç§»é™¤ï¼›
é»˜è®¤åœ¨initial delayæ—¶é—´ç»“æŸä¹‹å‰ï¼Œreadiness probe è¿”å›Failure;
å¦‚æœ Container æ²¡æœ‰æä¾›è‡ªå®šä¹‰çš„ readiness probeï¼Œé»˜è®¤
è§†ä¸ºè¿”å›Successã€‚
Probe å®é™…ä¸Šæ˜¯é€šè¿‡è°ƒç”¨ç”±Container å®ç°çš„ Handler æ¥å®ç°çš„ï¼Œå¯ä»¥å®ç°çš„ Handler åŒ…æ‹¬ï¼š</p>

<p>ExecAction: åœ¨å®¹å™¨é‡Œæ‰§è¡Œä¸€ä¸ªåˆ¶å®šå‘½ä»¤ï¼Œå¦‚æœå‘½ä»¤é€€å‡ºæ—¶è¿”å›0ï¼Œåˆ™è®¤ä¸ºæ£€æµ‹æˆåŠŸ(Success)ï¼Œå¦åˆ™è®¤ä¸ºæ£€æµ‹å¤±è´¥(Failure)ï¼›
TCPSocketAction: é’ˆå¯¹ å®¹å™¨IP:ç«¯å£ çš„ç»„åˆè¿›è¡Œ TCP è¿æ¥æ£€æŸ¥ï¼Œå¦‚æœå¯¹åº”IP:ç«¯å£å¤„äºå¼€æ”¾çŠ¶æ€ï¼Œåˆ™è®¤ä¸ºæˆåŠŸï¼Œå¦åˆ™è®¤ä¸ºå¤±è´¥ï¼›
HTTPGetAction: é’ˆå¯¹ å®¹å™¨IP:ç«¯å£:APIè·¯å¾„ çš„ç»„åˆè¿›è¡Œ HTTP GET è¯·æ±‚ï¼Œå¦‚æœ HTTP Responseçš„ Status Code åœ¨200~400ä¹‹é—´ï¼Œåˆ™è®¤ä¸ºæ£€æµ‹æˆåŠŸï¼Œå¦åˆ™è®¤ä¸ºå¤±è´¥ï¼›
æ‰€ä»¥æ ¹æ®å¯¹åº” Handler çš„è°ƒç”¨ç»“æœï¼Œæ¯ä¸ª Probe çš„æ¢æµ‹ç»“æœå¯ä»¥æœ‰ä»¥ä¸‹ä¸‰ç§ç±»å‹:</p>

<p>Success: å¯¹åº” Handler è¿”å›æˆåŠŸ;
Failure: å¯¹åº” Handler è¿”å›å¤±è´¥;
Unknown: å¯¹åº” Handler æ— æ³•æ­£å¸¸æ‰§è¡Œ;
ä»€ä¹ˆæ—¶å€™åº”è¯¥ä½¿ç”¨ liveness æˆ–è€… readiness probes?
çœ‹äº†ä¸Šé¢å…³äºä¸¤ç§ probe çš„ä»‹ç»åï¼Œå°±ä¼šæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œæ˜¯ä¸æ˜¯å®¹å™¨æ˜¯å¦å­˜æ´»ä¸€å®šè¦å®šä¹‰ liveness probe æ¥æ¢æµ‹ï¼Œå®¹å™¨æ˜¯å¦å¯æœåŠ¡ä¸€å®šè¦å®šä¹‰ readiness æ¥æ¢æµ‹ï¼Ÿ</p>

<p>ç­”æ¡ˆæ˜¯å¦å®šçš„ã€‚</p>

<p>å…³äºå®¹å™¨çš„å­˜æ´»æƒ…å†µ:</p>

<p>å®¹å™¨æœ¬èº«çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†èƒ½å¤Ÿè§£å†³çš„é—®é¢˜ï¼Œä¸éœ€è¦é€šè¿‡ liveness æ¥è¿›è¡Œæ¢æµ‹ï¼Œæ¯”å¦‚å®¹å™¨çš„ PID1 è¿›ç¨‹åœ¨å‘ç”Ÿé”™è¯¯çš„æ—¶å€™é€€å‡ºçš„åœºæ™¯ï¼ŒKubelet ä¼šæ ¹æ®å®¹å™¨çš„çŠ¶å†µå’Œ Pod çš„ restartPolicy æ¥è¿›è¡Œè°ƒè°ï¼›
å½“ä½ å¸Œæœ›ä¸æ­¢åŸºäºå®¹å™¨æœ¬èº«çš„å­˜æ´»çŠ¶æ€ï¼Œè€Œæ˜¯é€šè¿‡æŸç§è‡ªå®šä¹‰æ–¹å¼æ¥å†³å®š Kubelet æ˜¯å¦è§†å®¹å™¨ä¸ºå­˜æ´»æ—¶ï¼Œéœ€è¦ä½¿ç”¨ liveness probeï¼Œä¸¾ä¸ªä¾‹å­ï¼Œå¦‚æœå®¹å™¨çš„ PID1 è¿›ç¨‹æ˜¯ä¸€ä¸ªå¸¸é©»çš„ init è¿›ç¨‹ï¼Œè€Œæˆ‘ä»¬å¸Œæœ›é€šè¿‡è¿™ä¸ª init å¯åŠ¨çš„ flask è¿›ç¨‹æ¥åˆ¤æ–­å®¹å™¨æ˜¯å¦ä¸ºå­˜æ´»ï¼Œå¦‚æœ flask è¿›ç¨‹å¯åŠ¨ä¸æˆåŠŸï¼Œå°±æ€æ‰å®¹å™¨ï¼Œå¹¶æ ¹æ®restartPolicyè¿›è¡Œè°ƒè°ï¼Œè¿™ä¸ªæ—¶å€™å¯ä»¥ä½¿ç”¨è‡ªå®šä¹‰ liveness probeã€‚
å…³äºå®¹å™¨çš„å¯æœåŠ¡æƒ…å†µ:</p>

<p>å½“ä½ å¸Œæœ›æœ‰æŸä¸€ç§æœºåˆ¶ï¼Œè§£å†³å®¹å™¨å¯åŠ¨æˆåŠŸï¼Œå’Œå®¹å™¨å¯ä»¥æä¾›æœåŠ¡ä¹‹é—´çš„åŒºåˆ†ï¼Œä½ éœ€è¦ä½¿ç”¨ readiness probe,æ¯”å¦‚åº”ç”¨å¯åŠ¨æˆåŠŸï¼Œä½†éœ€è¦æ¯”è¾ƒé•¿çš„çš„åˆå§‹åŒ–æ—¶é—´å(æ¯”å¦‚æ‹‰å–å¤§é‡åˆå§‹åŒ–æ•°æ®)æ‰èƒ½æ­£å¸¸æä¾›æœåŠ¡ï¼Œè¿™ä¸ªæ—¶å€™ä»…ä»…ä»¥å®¹å™¨æ˜¯å¦å­˜æ´»æ¥å†³å®šæœåŠ¡çŠ¶æ€æ˜¯ä¸å¤Ÿçš„ï¼Œç­‰åˆ° readiness æ¢æµ‹æˆåŠŸï¼Œå®¹å™¨æ‰ä¼šè¢«åŠ å…¥åˆ° endpoint é‡Œå»å¯¹å¤–æä¾›æœåŠ¡ï¼›
å½“ä½ å¸Œæœ›å®¹å™¨åœ¨å­˜æ´»çŠ¶æ€ä¸‹ï¼Œæ ¹æ®æŸç§æ¡ä»¶æ¥è®© Kubelet è®¤ä¸ºå®ƒå¤„äºç»´æŠ¤çŠ¶æ€ï¼Œè‡ªåŠ¨æŠŠå®ƒä» endpoint ä¸­å»æ‰ï¼Œåœæ­¢å¯¹å¤–æä¾›æœåŠ¡ï¼Œä½ éœ€è¦ä½¿ç”¨å’Œ liveness probe ä¸åŒçš„ readiness probe(å®¹å™¨å·²ç»å¯åŠ¨ï¼Œå½“å¯¹åº”æœåŠ¡æ­£åœ¨ç»´æŠ¤ä¸­â€¦)ï¼›
å®¹å™¨æœ¬èº«ç”Ÿå‘½å‘¨æœŸèƒ½å¤Ÿè§£å†³çš„æœåŠ¡é—®é¢˜ï¼Œä¹Ÿä¸éœ€è¦é€šè¿‡ readiness probe æ¥æ¢æµ‹æ˜¯å¦å¯æœåŠ¡ï¼Œæ¯”å¦‚å½“ä¸€ä¸ª Pod è¢«åˆ é™¤çš„æ—¶å€™ï¼ŒPod ä¼šè¢«ç½®ä¸º unready çŠ¶æ€ï¼Œä¸ç®¡ readiness probe æ˜¯å¦å­˜åœ¨ï¼Œä¹Ÿä¸ç®¡å…¶ç»“æœå¦‚ä½•ã€‚
probes çš„å®è·µ
exec-liveness.yaml:</p>

<p>apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-exec
spec:
  containers:</p>
<ul>
  <li>name: liveness
image: k8s.gcr.io/busybox
args:
    <ul>
      <li>/bin/sh</li>
      <li>-c</li>
      <li>touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600
livenessProbe:
exec:
  command:
        <ul>
          <li>cat</li>
          <li>/tmp/healthy
initialDelaySeconds: 5
periodSeconds: 5
è§‚æµ‹ Pod çŠ¶æ€ï¼š</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p>root@kmaster135:/home/chenjiaxi01/yaml/pods/probe# kubectl describe pod liveness-exec
Name:               liveness-exec
â€¦
Tolerations:     node.kubernetes.io/not-ready:NoExecute for 300s
                 node.kubernetes.io/unreachable:NoExecute for 300s
Events:
  Type     Reason     Age                  From               Message
  â€”-     â€”â€”     â€”-                 â€”-               â€”â€”-
  Normal   Scheduled  4m19s                default-scheduler  Successfully assigned default/liveness-exec to dnode136
  Normal   Killing    2m2s                 kubelet, dnode136  Killing container with id docker://liveness:Container failed liveness probe.. Container will be killed and recreated.
  Warning  Failed     107s                 kubelet, dnode136  Failed to pull image â€œk8s.gcr.io/busyboxâ€: rpc error: code = Unknown desc = Error response from daemon: Get https://k8s.gcr.io/v2/busybox/manifests/latest: dial tcp [2404:6800:4008:c06::52]:443: connect: network is unreachable
  Warning  Failed     107s                 kubelet, dnode136  Error: ErrImagePull
  Normal   BackOff    106s                 kubelet, dnode136  Back-off pulling image â€œk8s.gcr.io/busyboxâ€
  Warning  Failed     106s                 kubelet, dnode136  Error: ImagePullBackOff
  Normal   Pulling    93s (x3 over 4m8s)   kubelet, dnode136  pulling image â€œk8s.gcr.io/busyboxâ€
  Normal   Pulled     72s (x2 over 3m18s)  kubelet, dnode136  Successfully pulled image â€œk8s.gcr.io/busyboxâ€
  Normal   Created    72s (x2 over 3m17s)  kubelet, dnode136  Created container
  Normal   Started    72s (x2 over 3m17s)  kubelet, dnode136  Started container
  Warning  Unhealthy  27s (x6 over 2m42s)  kubelet, dnode136  Liveness probe failed: cat: canâ€™t open â€˜/tmp/healthyâ€™: No such file or directory
å¯ä»¥çœ‹åˆ°åœ¨ 30s è¿‡åï¼Œliveness æ¢æµ‹å¤±è´¥ï¼Œkubelet ä¼šåˆ æ‰å®¹å™¨ï¼Œå¹¶æ ¹æ®é»˜è®¤restartPolicy=Alwaysé‡å¯å®¹å™¨ï¼›</p>

<p>å‘ç°æœ‰ä¸ªé—®é¢˜, Node ä¸Šæœ‰é•œåƒï¼Œä½†è¿˜æ˜¯ä¼šå»å°è¯•è¿œç¨‹æ‹‰å–é•œåƒï¼ŒåŸå› æ˜¯imagePullPolicy: Alwaysï¼Œå¦‚æœæƒ³è¦åœ¨æœ¬åœ°æœ‰å¯¹åº”é•œåƒçš„æ—¶å€™ä¸æ‹‰å–ï¼Œåº”è¯¥è®¾ç½®ä¸ºimagePullPolcy: IfNotPresent ã€‚</p>

<p>ä»£ç å®ç°
ä»£ç ç‰ˆæœ¬: release-1.12</p>

<p>Kubelet ä¸­çš„æ•°æ®ç»“æ„
pkg/kubelet/kubelet.go</p>

<p>// Kubelet is the main kubelet implementation.
type Kubelet struct {
    kubeletConfiguration componentconfig.KubeletConfiguration
    â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Handles container probing.
probeManager prober.Manager
// Manages container health check results.
livenessManager proberesults.Manager
... } åˆå§‹åŒ– pkg/kubelet/kubelet.go
</code></pre></div></div>

<p>// NewMainKubelet instantiates a new Kubelet object along with all the required internal modules.
// No initialization of Kubelet and its modules should happen here.
func NewMainKubelet(kubeCfg <em>componentconfig.KubeletConfiguration, kubeDeps *KubeletDeps, crOptions *options.ContainerRuntimeOptions, standaloneMode bool, hostnameOverride, nodeIP, providerID string) (</em>Kubelet, error) {
    â€¦
    klet := &amp;Kubelet{
        hostname:                       hostname,
        nodeName:                       nodeName,
        kubeClient:                     kubeDeps.KubeClient,
        â€¦
    }
    â€¦
    klet.probeManager = prober.NewManager(
        klet.statusManager,
        klet.livenessManager,
        klet.runner,
        containerRefManager,
        kubeDeps.Recorder)
    â€¦
}
å¯åŠ¨
pkg/kubelet/kubelet.go
// Run starts the kubelet reacting to config updates
func (kl *Kubelet) Run(updates &lt;-chan kubetypes.PodUpdate) {
    â€¦
    // Start component sync loops.
    kl.statusManager.Start()
    kl.probeManager.Start()
    â€¦
}
ä½¿ç”¨:
Pod è¢«åˆ›å»ºæ—¶: pkg/kubelet/kubelet.go</p>

<p>// HandlePodAdditions is the callback in SyncHandler for pods being added from
// a config source.
func (kl <em>Kubelet) HandlePodAdditions(pods []</em>v1.Pod) {
    start := kl.clock.Now()
    sort.Sort(sliceutils.PodsByCreationTime(pods))
    for _, pod := range pods {
        existingPods := kl.podManager.GetPods()
        // Always add the pod to the pod manager. Kubelet relies on the pod
        // manager as the source of truth for the desired state. If a pod does
        // not exist in the pod manager, it means that it has been deleted in
        // the apiserver and no action (other than cleanup) is required.
        kl.podManager.AddPod(pod)
        â€¦
        kl.probeManager.AddPod(pod)
    }
}
Pod è¢«åˆ é™¤æ—¶: pkg/kubelet/kubelet.go</p>

<p>// HandlePodRemoves is the callback in the SyncHandler interface for pods
// being removed from a config source.
func (kl <em>Kubelet) HandlePodRemoves(pods []</em>v1.Pod) {
    start := kl.clock.Now()
    for _, pod := range pods {
        kl.podManager.DeletePod(pod)
        â€¦
        kl.probeManager.RemovePod(pod)
    }
prober.Manager æ¥å£
pkg/kubelet/prober/prober_manager.go</p>

<p>// Manager manages pod probing. It creates a probe â€œworkerâ€ for every container that specifies a
// probe (AddPod). The worker periodically probes its assigned container and caches the results. The
// manager use the cached probe results to set the appropriate Ready state in the PodStatus when
// requested (UpdatePodStatus). Updating probe parameters is not currently supported.
// TODO: Move liveness probing out of the runtime, to here.
type Manager interface {
    // AddPod creates new probe workers for every container probe. This should be called for every
    // pod created.
    AddPod(pod *v1.Pod)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// RemovePod handles cleaning up the removed pod state, including terminating probe workers and
// deleting cached results.
RemovePod(pod *v1.Pod)

// CleanupPods handles cleaning up pods which should no longer be running.
// It takes a list of "active pods" which should not be cleaned up.
CleanupPods(activePods []*v1.Pod)

// UpdatePodStatus modifies the given PodStatus with the appropriate Ready state for each
// container based on container running status, cached probe results and worker states.
UpdatePodStatus(types.UID, *v1.PodStatus)

// Start starts the Manager sync loops.
Start() } prober.Manager è´Ÿè´£ Pod æ¢æµ‹çš„ç®¡ç†ï¼Œæä¾›äº†äº”ä¸ªæ–¹æ³•ï¼š
</code></pre></div></div>

<p>AddPod(pod <em>v1.Pod): åœ¨ Pod åˆ›å»ºæ—¶è¢«çŸ¥é“ç”¨ï¼Œä¸ºæ¯ä¸ªå®¹å™¨ probe åˆ›å»ºæ–°çš„ probe worker;
RemovePod(pod *v1.Pod): æ¸…ç†è¢«åˆ é™¤çš„ Pod çš„ Probe çŠ¶æ€ï¼ŒåŒ…æ‹¬åœæ­¢ probe wokers ä»¥åŠæ¸…ç†æ‰ç¼“å­˜çš„ç»“æœï¼›
CleanupPods(activePods []</em>v1.Pod): æ¸…ç†ä¸éœ€è¦è¿è¡Œçš„ Pods(??å’Œ RemovePod çš„åŒºåˆ«å’Œè”ç³»ï¼Ÿï¼Ÿ);
UpdatePodStatus(type.UID, *v1.PodStatus): åŸºäºå®¹å™¨çš„è¿è¡ŒçŠ¶æ€ã€ç¼“å­˜çš„æ¢æµ‹ç»“æœï¼Œworker çš„çŠ¶æ€æ¥æ›´æ–° PodStatus;
Start(): å¯åŠ¨ Manager åŒæ­¥å¾ªç¯ï¼›
åŸºäºä¸Šè¿°çš„äº”ä¸ªæ–¹æ³•ï¼ŒManager ä¼šé€šè¿‡AddPodåœ¨ Pod åˆ›å»ºæ—¶ä¸ºæ¯ä¸ª containeråˆ›å»ºä¸€ä¸ªprobe workeræŒ‡å®šå¯¹åº”çš„æ¢é’ˆï¼Œworker å®šæœŸæ‰§è¡Œæ¢æµ‹å¹¶ç¼“å­˜ç»“æœã€‚åŸºäºç¼“å­˜çš„ç»“æœï¼ŒManagerä¼šåœ¨è¢«è¯·æ±‚çš„æ—¶å€™é€šè¿‡UpdatePodStatusæ›´æ–°PodStatusä¸­çš„ReadyçŠ¶æ€ã€‚å½“å®¹å™¨è¢«åˆ é™¤çš„æ—¶å€™ï¼Œé€šè¿‡RemovePodå›æ”¶workerã€‚</p>

<p>// TODO: Move liveness probing out of the runtime, to here. å¦‚ä½•ç†è§£</p>

<p>æ¥å£çš„å®ç°: prober.manager
type manager struct {
    // Map of active workers for probes
    workers map[probeKey]*worker
    // Lock for accessing &amp; mutating workers
    workerLock sync.RWMutex</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// The statusManager cache provides pod IP and container IDs for probing.
statusManager status.Manager

// readinessManager manages the results of readiness probes
readinessManager results.Manager

// livenessManager manages the results of liveness probes
livenessManager results.Manager

// prober executes the probe actions.
prober *prober } prober.manageråŒ…æ‹¬å¦‚ä¸‹æ•°æ®ç»“æ„:
</code></pre></div></div>

<p>workers: ç»´æŠ¤ probe å’Œ worker ä¹‹é—´çš„æ˜ å°„ï¼›
workerLock: è®¿é—® worker æ—¶éœ€è¦åŠ é”ï¼›
statusManager: æä¾› Pod å’Œ Container ä¿¡æ¯;
readinessManager: ä¿å­˜ readiness probes ç»“æœï¼›
livenessManager: ä¿å­˜ liveness probes ç»“æœ;
prober: å…·ä½“æ‰§è¡Œ probe åŠ¨ä½œ;
worker: probe æ¢æµ‹çš„ä¸»è¦é€»è¾‘
worker å¯¹è±¡å°è£…äº†å¯¹ä¸€ä¸ª probe æ¢æµ‹çš„ä¸»è¦ä»»åŠ¡ï¼›</p>

<p>å…¶æ•°æ®ç»“æ„å¦‚ä¸‹:</p>

<p>pkg/kubelet/prober/worker.go:37</p>

<p>// worker handles the periodic probing of its assigned container. Each worker has a go-routine
// associated with it which runs the probe loop until the container permanently terminates, or the
// stop channel is closed. The worker uses the probe Managerâ€™s statusManager to get up-to-date
// container IDs.
type worker struct {
    // Channel for stopping the probe.
    stopCh chan struct{}
    // The pod containing this probe (read-only)
    pod *v1.Pod
    // The container to probe (read-only)
    container v1.Container
    // Describes the probe configuration (read-only)
    spec *v1.Probe
    // The type of the worker.
    probeType probeType
    // The probe value during the initial delay.
    initialValue results.Result
    // Where to store this workers results.
    resultsManager results.Manager
    probeManager   *manager
    // The last known container ID for this worker.
    containerID kubecontainer.ContainerID
    // The last probe result for this worker.
    lastResult results.Result
    // How many times in a row the probe has returned the same result.
    resultRun int
    // If set, skip probing.
    onHold bool
    // proberResultsMetricLabels holds the labels attached to this worker
    // for the ProberResults metric.
    proberResultsMetricLabels prometheus.Labels
}
å…¶æ–¹æ³•åŒ…æ‹¬:</p>

<p>newWorker: æ ¹æ®ç”¨æˆ·ä¼ å…¥çš„ proberTypeç­‰å‚æ•°ï¼Œåˆå§‹åŒ–ä¸€ä¸ªå¯¹åº”åˆ° container-liveness/readiness æ¢æµ‹ä»»åŠ¡çš„workerï¼›
run: æŒ‰ç…§ç”¨æˆ·æŒ‡å®šçš„Probe.PeriodSecondsï¼Œå‘¨æœŸæ€§æ‰§è¡Œ worker çš„doProbeæ“ä½œï¼Œç›´åˆ°æ”¶åˆ°é€€å‡ºä¿¡å·;
stop: å‘å‡ºç»ˆæ­¢ä¿¡å·ï¼Œåœæ­¢ woker;
doProbe: çœŸæ­£æ‰§è¡Œæ¢æµ‹åŠ¨ä½œï¼Œè¿”å›æ¢æµ‹ç»“æœtrue/falseï¼›
ä¸»è¦çœ‹doProbeçš„å…·ä½“å®ç°:</p>

<p>// doProbe probes the container once and records the result.
// Returns whether the worker should continue.
func (w *worker) doProbe() (keepGoing bool) {
    defer func() { recover() }() // Actually eat panics (HandleCrash takes care of logging)
    defer runtime.HandleCrash(func(_ interface{}) { keepGoing = true })</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>... // é˜²å¾¡å¼ç¼–ç¨‹ï¼Œå»æ‰ä¸éœ€è¦ probe çš„æƒ…å†µï¼Œæ¯”å¦‚ Pod ä¸å­˜åœ¨ï¼ŒContainer ä¸å­˜åœ¨ç­‰

// TODO: in order for exec probes to correctly handle downward API env, we must be able to reconstruct
// the full container environment here, OR we must make a call to the CRI in order to get those environment
// values from the running container.
result, err := w.probeManager.prober.probe(w.probeType, w.pod, status, w.container, w.containerID)
if err != nil {
    // Prober error, throw away the result.
    return true
}

... // æ ¹æ® Probe çš„ç»“æœå’Œå¯¹åº”é…ç½®(æ¯”å¦‚é‡è¯•æ¬¡æ•°ç­‰)ï¼Œå†³å®šæ˜¯å¦è¿”å›æˆåŠŸ doProbe å¯¹å®¹å™¨çš„ä¸åŒæƒ…å†µè¿›è¡Œåˆ†ç±»ï¼Œå†³å®šæ˜¯å¦è¦è¿›è¡Œ probeï¼Œå¹¶ä¸”å¤„ç† probe çš„ç»“æœï¼Œå†³å®šæ˜¯å¦è¿”å›æˆåŠŸ(true)ï¼›
</code></pre></div></div>

<p>ä¸‹é¢ç»§ç»­çœ‹w.probeManager.prober.probeï¼Œåˆ†åˆ«æ”¯æŒexec,tcp,httpGetä¸‰ç§ Probe ç±»å‹ï¼Œä»£ç å®ç°:</p>

<p>pkg/kubelet/prober/prober.go:81:</p>

<p>// probe probes the container.
func (pb *prober) probe(probeType probeType, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID) (results.Result, error) {
    var probeSpec *v1.Probe
    switch probeType {
    case readiness:
        probeSpec = container.ReadinessProbe
    case liveness:
        probeSpec = container.LivenessProbe
    default:
        return results.Failure, fmt.Errorf(â€œUnknown probe type: %qâ€, probeType)
    }
    â€¦
    result, output, err := pb.runProbeWithRetries(probeType, probeSpec, pod, status, container, containerID, maxProbeRetries)
    â€¦
}
runProbeWithRetries å°è£…äº†é‡è¯•é€»è¾‘ï¼Œæœ€ç»ˆè°ƒç”¨åˆ°runProbeï¼ŒæŒ‰ç…§ä¸åŒçš„ Probe ç±»å‹å®ç°ä¸åŒçš„ Probe å…·ä½“æ¢æµ‹æµç¨‹ï¼ŒåŸºäºæˆ‘ä»¬çš„é—®é¢˜èƒŒæ™¯ï¼Œæˆ‘ä»¬ç›®å‰ä¸»è¦å…³å¿ƒçš„æ˜¯ HTTPGet çš„å…·ä½“å®ç°ï¼Œé—®é¢˜æ˜¯:</p>

<p>ç”¨æˆ·æ˜¯å¦å¯ä»¥æŒ‡å®š HTTPGet çš„ Hostï¼Ÿ
å¦‚æœç”¨æˆ·æ²¡æœ‰æŒ‡å®šï¼Œé»˜è®¤çš„ Host æ˜¯(çŒœæµ‹æ˜¯ ClusterIP)ï¼Ÿ
pkg/kubelet/prober/prober.go:147</p>

<p>func (pb *prober) runProbe(probeType probeType, p *v1.Probe, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID) (probe.Result, string, error) {
    timeout := time.Duration(p.TimeoutSeconds) * time.Second
    if p.Exec != nil {
        glog.V(4).Infof(â€œExec-Probe Pod: %v, Container: %v, Command: %vâ€, pod, container, p.Exec.Command)
        command := kubecontainer.ExpandContainerCommandOnlyStatic(p.Exec.Command, container.Env)
        return pb.exec.Probe(pb.newExecInContainer(container, containerID, command, timeout))
    }
    if p.HTTPGet != nil {
        scheme := strings.ToLower(string(p.HTTPGet.Scheme))
       // 1. ç”¨æˆ·å¯ä»¥æŒ‡å®š HTTPGet çš„ Host;
       // 2. å¦‚æœç”¨æˆ·æ²¡æœ‰æŒ‡å®šï¼Œé»˜è®¤çš„ Host å°±æ˜¯ PodIPã€‚
        host := p.HTTPGet.Host
        if host == â€œâ€ {
            host = status.PodIP
        }
        port, err := extractPort(p.HTTPGet.Port, container)
        if err != nil {
            return probe.Unknown, â€œâ€, err
        }
        path := p.HTTPGet.Path
        glog.V(4).Infof(â€œHTTP-Probe Host: %v://%v, Port: %v, Path: %vâ€, scheme, host, port, path)
        url := formatURL(scheme, host, port, path)
        headers := buildHeader(p.HTTPGet.HTTPHeaders)
        glog.V(4).Infof(â€œHTTP-Probe Headers: %vâ€, headers)
        if probeType == liveness {
            return pb.livenessHttp.Probe(url, headers, timeout)
        } else { // readiness
            return pb.readinessHttp.Probe(url, headers, timeout)
        }
    }
    if p.TCPSocket != nil {
        port, err := extractPort(p.TCPSocket.Port, container)
        if err != nil {
            return probe.Unknown, â€œâ€, err
        }
        host := p.TCPSocket.Host
        if host == â€œâ€ {
            host = status.PodIP
        }
        glog.V(4).Infof(â€œTCP-Probe Host: %v, Port: %v, Timeout: %vâ€, host, port, timeout)
        return pb.tcp.Probe(host, port, timeout)
    }
    glog.Warningf(â€œFailed to find probe builder for container: %vâ€, container)
    return probe.Unknown, â€œâ€, fmt.Errorf(â€œMissing probe handler for %s:%sâ€, format.Pod(pod), container.Name)
}
ç»§ç»­è¿½æŸ¥ä¸‹å»ä¼šè¿½æŸ¥åˆ°DoHTTPProbe: pkg/probe/http/http.go:66</p>

<p>// DoHTTPProbe checks if a GET request to the url succeeds.
// If the HTTP response code is successful (i.e. 400 &gt; code &gt;= 200), it returns Success.
// If the HTTP response code is unsuccessful or HTTP communication fails, it returns Failure.
// This is exported because some other packages may want to do direct HTTP probes.
func DoHTTPProbe(url *url.URL, headers http.Header, client HTTPGetInterface) (probe.Result, string, error) {
    req, err := http.NewRequest(â€œGETâ€, url.String(), nil)
    â€¦
    if headers.Get(â€œHostâ€) != â€œâ€ {
        req.Host = headers.Get(â€œHostâ€)
    }
    res, err := client.Do(req)
    if err != nil {
        // Convert errors into failures to catch timeouts.
        return probe.Failure, err.Error(), nil
    }
    defer res.Body.Close()
    â€¦
    if res.StatusCode &gt;= http.StatusOK &amp;&amp; res.StatusCode &lt; http.StatusBadRequest {
        glog.V(4).Infof(â€œProbe succeeded for %s, Response: %vâ€, url.String(), *res)
        return probe.Success, body, nil
    }
    glog.V(4).Infof(â€œProbe failed for %s with request headers %v, response body: %vâ€, url.String(), headers, body)
    return probe.Failure, fmt.Sprintf(â€œHTTP probe failed with statuscode: %dâ€, res.StatusCode), nil
}
å‘é€ HTTP è¯·æ±‚è¿›è¡Œæ¢æµ‹ï¼Œè‡³æ­¤ HTTPGet Probe çš„æµç¨‹æ¢³ç†å®Œæ¯•ã€‚</p>

<p>å…¶ä»–çŸ¥è¯†
select ä½œä¸ºå¹¶å‘æ§åˆ¶çš„ç†è§£
// run periodically probes the container.
func (w *worker) run() {
    probeTickerPeriod := time.Duration(w.spec.PeriodSeconds) * time.Second</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// If kubelet restarted the probes could be started in rapid succession.
// Let the worker wait for a random portion of tickerPeriod before probing.
time.Sleep(time.Duration(rand.Float64() * float64(probeTickerPeriod)))

probeTicker := time.NewTicker(probeTickerPeriod)

defer func() {
    // Clean up.
    probeTicker.Stop()
    if !w.containerID.IsEmpty() {
        w.resultsManager.Remove(w.containerID)
    }

    w.probeManager.removeWorker(w.pod.UID, w.container.Name, w.probeType)
    ProberResults.Delete(w.proberResultsMetricLabels)
}()
</code></pre></div></div>

<p>probeLoop:
    for w.doProbe() {
        // Wait for next probe tick.
        select {
        case &lt;-w.stopCh:
            break probeLoop
        case &lt;-probeTicker.C:
            // continue
        }
    }
}
è¿™ä¸ªprobeLoopçš„ç”¨æ³•ä¸æ˜¯å¾ˆç†è§£,ç›´æ¥å†™ä¸ª sample æ¥çœ‹çœ‹ï¼š</p>

<p>func main() {
    stopCh := make(chan int)
    ticker := time.NewTicker(1 * time.Second)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go func() {
    time.Sleep(3 * time.Second)
    stopCh &lt;- 0
    fmt.Println("Send to stopCh")
}()
</code></pre></div></div>

<p>testLoop:
    for {
        select {
        case &lt;-stopCh:
            fmt.Println(â€œReceive from stopCh, breakâ€)
            break testLoop
        case &lt;-ticker.C:
            fmt.Println(â€œRunningâ€¦â€)
            // continue
        }
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println("Done") } å®šä¹‰ä¸€ä¸ªå¾ªç¯çš„åå­—è€Œå·²ï¼Œå¦‚æœå»æ‰çš„è¯ï¼Œæ— æ³•ç›´æ¥ break æ•´ä¸ªå¾ªç¯ï¼Œè€Œåªæ˜¯ break ä¸€æ¬¡å¾ªç¯ï¼› time.Tickerçš„ä½¿ç”¨æ–¹å¼å€¼å¾—å­¦ä¹ ï¼Œç”¨äºé…ç½®å®šæ—¶ä»»åŠ¡ï¼Œç›´åˆ°æ”¶åˆ°æŸä¸ªç»ˆæ­¢ä¿¡å·ï¼› for{}ä¾¿æ˜¯ä¸€ä¸ªä¸€ç›´è¿è¡Œçš„å¾ªç¯ï¼Œç­‰åŒäºPythonä¸­çš„while(true); worker.stop çš„å†™æ³• pkg/kubelet/prober/worker.go:147
</code></pre></div></div>

<p>// stop stops the probe worker. The worker handles cleanup and removes itself from its manager.
// It is safe to call stop multiple times.
func (w *worker) stop() {
    select {
    case w.stopCh &lt;- struct{}{}:
    default: // Non-blocking.
    }
}
è¿™æ ·å†™å’Œä»¥ä¸‹è¿™ä¹ˆå†™æœ‰ä»€ä¹ˆåŒºåˆ«:</p>

<p>func (w *worker) stop() {
    w.stopCh &lt;- struct{}{}
}
Non-blocking çš„å†™æ³•ï¼Œå¦‚æœ channel å·²ç»å†™æ»¡ï¼Œä¸ä¼šé˜»å¡ä½ stop æ‰€åœ¨çš„ Goroutineï¼Œä¸Šå±‚å°±ç®—é‡å¤æ‰§è¡Œï¼Œä¹Ÿä¸ä¼šå¼•å‘é”™è¯¯ï¼Œç›¸å½“äº stop æ“ä½œæ˜¯å¹‚ç­‰çš„ï¼Œå¥å£®æ€§æé«˜ï¼›</p>

<p>Sample å¦‚ä¸‹:</p>

<p>var stopCh = make(chan struct{}, 1)</p>

<p>func nonblockingStop() {
    select {
    case stopCh &lt;- struct{}{}:
        fmt.Println(â€œWrite to stopChâ€¦ Breakâ€)
    default:
        fmt.Println(â€œCannot write to stopChâ€¦ Runningâ€)
        // non-blocking
    }
}</p>

<p>func stop() {
    stopCh &lt;- struct{}{}
}</p>

<p>func looping() {
testLoop:
    for {
        select {
        case &lt;-stopCh:
            fmt.Println(â€œReceive End Signalâ€¦Doneâ€)
            break testLoop
        default:
            fmt.Println(â€œCannot Receive End Signalâ€¦Doneâ€)
            time.Sleep(500 * time.Millisecond)
        }
    }
}</p>

<p>func main() {
    // make stop blocked
    go looping()
    time.Sleep(time.Second)
    for i := 0; i &lt;= 2; i++ {
        //stop()
        nonblockingStop()
    }
    time.Sleep(3 * time.Second)
}</p>

<p>æ‰§è¡Œä¸‰æ¬¡stop()ä¼šæ­»é”ï¼Œä½†æ˜¯ nonblockingStop ä¸ä¼šï¼›</p>
:ET