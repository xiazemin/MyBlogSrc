I"Œe<p>ä¼—æ‰€å‘¨çŸ¥ï¼Œåœ¨golangä¸­ï¼Œsliceï¼ˆåˆ‡ç‰‡ï¼‰æ˜¯æˆ‘ä»¬æœ€å¸¸ä½¿ç”¨åˆ°çš„ä¸€ç§æ•°æ®ç»“æ„ï¼Œæ˜¯ä¸€ç§å¯å˜é•¿åº¦çš„æ•°ç»„ï¼Œæœ¬ç¯‡æ–‡ç« æˆ‘ä»¬ä¸»è¦ç»“åˆæºç æ¥ä»‹ç»ä¸€ä¸‹sliceçš„åº•å±‚å®ç°ï¼Œä»¥åŠåœ¨ä½¿ç”¨sliceæ—¶çš„ä¸€äº›æ³¨æ„äº‹é¡¹ã€‚
Sliceç»“æ„ä½“
é¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸€æ®µä»£ç ï¼š
package
 main
import (
â€œfmtâ€
  â€œunsafeâ€
)
func main() {
var a int
  var b int8
  var c int16
  var d int32
  var e int64
  slice := make([]int, 0)
  slice = append(slice, 1)
  fmt.Printf(â€œint:%d\nint8:%d\nint16:%d\nint32:%d\nint64:%d\nâ€, unsafe.Sizeof(a), unsafe.Sizeof(b), unsafe.Sizeof(c), unsafe.Sizeof(d), unsafe.Sizeof(e))
  fmt.Printf(â€œslice:%dâ€, unsafe.Sizeof(slice))
}
è¯¥ç¨‹åºè¾“å‡ºgolangä¸­å¸¸ç”¨æ•°æ®ç±»å‹å å¤šå°‘byteï¼Œè¾“å‡ºç»“æœæ˜¯ï¼š</p>

<p>int:8
int8:1
int16:2
int32:4
int64:8
slice:24
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°sliceå 24byteï¼Œä¸ºä»€ä¹ˆä¼šå 24byteï¼Œè¿™å°±è·Ÿsliceåº•å±‚å®šä¹‰çš„ç»“æ„æœ‰å…³ï¼Œæˆ‘ä»¬åœ¨golangçš„runtime/slice.goä¸­å¯ä»¥æ‰¾åˆ°sliceçš„ç»“æ„å®šä¹‰ï¼Œå¦‚ä¸‹ï¼š
type slice struct {
array
 unsafe.Pointer
//æŒ‡å‘åº•å±‚æ•°ç»„çš„æŒ‡é’ˆ
  len int//åˆ‡ç‰‡çš„é•¿åº¦
  cap int//åˆ‡ç‰‡çš„å®¹é‡
}
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°sliceä¸­å®šä¹‰äº†ä¸‰ä¸ªå˜é‡ï¼Œä¸€ä¸ªæ˜¯æŒ‡å‘åº•å±‚æ•°å­—çš„æŒ‡é’ˆarrayï¼Œå¦å¤–ä¸¤ä¸ªæ˜¯åˆ‡ç‰‡çš„é•¿åº¦lenå’Œåˆ‡ç‰‡çš„å®¹é‡capã€‚
sliceåˆå§‹åŒ–
ç®€å•äº†è§£äº†sliceçš„åº•å±‚ç»“æ„åï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹sliceçš„åˆå§‹åŒ–ï¼Œåœ¨golangä¸­sliceæœ‰å¤šé‡åˆå§‹åŒ–æ–¹å¼ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬å°±ä¸ä¸€ä¸€ä»‹ç»äº†ï¼Œæˆ‘ä»¬ä¸»è¦å…³æ³¨sliceåœ¨åº•å±‚æ˜¯å¦‚ä½•åˆå§‹åŒ–çš„ï¼Œé¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸€æ®µä»£ç ï¼š
package main
import â€œfmtâ€
func main() {
  slice := make([]int, 0)
  slice = append(slice, 1)
  fmt.Println(slice, len(slice), cap(slice))
}
<!-- more -->
å¾ˆç®€å•çš„ä¸€æ®µä»£ç ï¼Œmakeä¸€ä¸ªsliceï¼Œå¾€sliceä¸­appendä¸€ä¸ªä¸€ä¸ª1ï¼Œæ‰“å°sliceå†…å®¹ï¼Œé•¿åº¦å’Œå®¹é‡ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬åˆ©ç”¨gotoolæä¾›çš„å·¥å…·å°†ä»¥ä¸Šä»£ç åæ±‡ç¼–ï¼š
go tool compile -S slice.go
å¾—åˆ°æ±‡ç¼–ä»£ç å¦‚ä¸‹ï¼ˆæˆªå–éƒ¨åˆ†ï¼‰ï¼š
0x0000 00000 (slice.go
:
8
)  TEXT<br />
â€œâ€
.main(SB), ABIInternal, $
152
-0
  0x0000 00000 (slice.go:8)  MOVQ  (TLS), CX
  0x0009 00009 (slice.go:8)  LEAQ  -24(SP), AX
  0x000e 00014 (slice.go:8)  CMPQ  AX, 16(CX)
  0x0012 00018 (slice.go:8)  JLS  375
  0x0018 00024 (slice.go:8)  SUBQ  $152, SP
  0x001f 00031 (slice.go:8)  MOVQ  BP, 144(SP)
  0x0027 00039 (slice.go:8)  LEAQ  144(SP), BP
  0x002f 00047 (slice.go:8)  FUNCDATA  $0, gclocals- f14a5bc6d08bc46424827f54d2e3f8ed(SB)//ç¼–è¯‘å™¨äº§ç”Ÿï¼Œç”¨äºä¿å­˜ä¸€äº›åƒåœ¾æ”¶é›†ç›¸å…³çš„ä¿¡æ¯
  0x002f 00047 (slice.go:8)  FUNCDATA  $1, gclocals- 3e7bd269c75edba02eda3b9069a96409(SB)
  0x002f 00047 (slice.go:8)  FUNCDATA  $2, gclocals- f6aec3988379d2bd21c69c093370a150(SB)
  0x002f 00047 (slice.go:8)  FUNCDATA  $3, â€œâ€œ.main.stkobj(SB)
  0x002f 00047 (slice.go:9)  PCDATA  $0, $1
  0x002f 00047 (slice.go:9)  PCDATA  $1, $0
  0x002f 00047 (slice.go:9)  LEAQ  type.int(SB), AX
  0x0036 00054 (slice.go:9)  PCDATA  $0, $0
  0x0036 00054 (slice.go:9)  MOVQ  AX, (SP)
  0x003a 00058 (slice.go:9)  XORPS  X0, X0
  0x003d 00061 (slice.go:9)  MOVUPS  X0, 8(SP)
  0x0042 00066 (slice.go:9)  CALL  runtime.makeslice(SB)//åˆå§‹åŒ–slice
  0x0047 00071 (slice.go:9)  PCDATA  $0, $1
  0x0047 00071 (slice.go:9)  MOVQ  24(SP), AX
  0x004c 00076 (slice.go:10)  PCDATA  $0, $2
  0x004c 00076 (slice.go:10)  LEAQ  type.int(SB), CX
  0x0053 00083 (slice.go:10)  PCDATA  $0, $1
  0x0053 00083 (slice.go:10)  MOVQ  CX, (SP)
  0x0057 00087 (slice.go:10)  PCDATA  $0, $0
  0x0057 00087 (slice.go:10)  MOVQ  AX, 8(SP)
  0x005c 00092 (slice.go:10)  XORPS  X0, X0
  0x005f 00095 (slice.go:10)  MOVUPS  X0, 16(SP)
  0x0064 00100 (slice.go:10)  MOVQ  $1, 32(SP)
  0x006d 00109 (slice.go:10)  CALL  runtime.growslice(SB)//appendæ“ä½œ
  0x0072 00114 (slice.go:10)  PCDATA  $0, $1
  0x0072 00114 (slice.go:10)  MOVQ  40(SP), AX
  0x0077 00119 (slice.go:10)  MOVQ  48(SP), CX
  0x007c 00124 (slice.go:10)  MOVQ  56(SP), DX
  0x0081 00129 (slice.go:10)  MOVQ  DX, â€œâ€œ.slice.cap+72(SP)
  0x0086 00134 (slice.go:10)  MOVQ  $1, (AX)
  0x008d 00141 (slice.go:11)  PCDATA  $0, $0
  0x008d 00141 (slice.go:11)  MOVQ  AX, (SP)
  0x0091 00145 (slice.go:10)  LEAQ  1(CX), AX
  0x0095 00149 (slice.go:10)  MOVQ  AX, â€œâ€œ.slice.len+64(SP)
  0x009a 00154 (slice.go:11)  MOVQ  AX, 8(SP)
  0x009f 00159 (slice.go:11)  MOVQ  DX, 16(SP)
  0x00a4 00164 (slice.go:11)  CALL  runtime.convTslice(SB)//ç±»å‹è½¬æ¢
  0x00a9 00169 (slice.go:11)  PCDATA  $0, $1
  0x00a9 00169 (slice.go:11)  MOVQ  24(SP), AX
  0x00ae 00174 (slice.go:11)  PCDATA  $0, $0
  0x00ae 00174 (slice.go:11)  PCDATA  $1, $1
  0x00ae 00174 (slice.go:11)  MOVQ  AX, â€œâ€..autotmp_33+88(SP)
  0x00b3 00179 (slice.go:11)  MOVQ  â€œâ€œ.slice.len+64(SP), CX
  0x00b8 00184 (slice.go:11)  MOVQ  CX, (SP)
  0x00bc 00188 (slice.go:11)  CALL  runtime.convT64(SB)
  0x00c1 00193 (slice.go:11)  PCDATA  $0, $1
  0x00c1 00193 (slice.go:11)  MOVQ  8(SP), AX
  0x00c6 00198 (slice.go:11)  PCDATA  $0, $0
  0x00c6 00198 (slice.go:11)  PCDATA  $1, $2
  0x00c6 00198 (slice.go:11)  MOVQ  AX, â€œâ€..autotmp_34+80(SP)
  0x00cb 00203 (slice.go:11)  MOVQ  â€œâ€œ.slice.cap+72(SP), CX
  0x00d0 00208 (slice.go:11)  MOVQ  CX, (SP)
  0x00d4 00212 (slice.go:11)  CALL  runtime.convT64(SB)
  0x00d9 00217 (slice.go:11)  PCDATA  $0, $1
  0x00d9 00217 (slice.go:11)  MOVQ  8(SP), AX
  0x00de 00222 (slice.go:11)  PCDATA  $1, $3
  0x00de 00222 (slice.go:11)  XORPS  X0, X0
å¤§å®¶å¯èƒ½çœ‹åˆ°è¿™é‡Œæœ‰ç‚¹è’™ï¼Œè¿™æ˜¯åœ¨å¹²å•¥ï¼Œå…¶å®æˆ‘ä»¬åªéœ€è¦å…³æ³¨ä¸€äº›å…³é”®çš„ä¿¡æ¯å°±å¥½äº†ï¼Œä¸»è¦æ˜¯è¿™å‡ è¡Œï¼š
0x0042 00066 (slice.go
:
9
)<br />
CALL
  runtime.makeslice(SB)
//åˆå§‹åŒ–slice
0x006d 00109 (slice.go:10)  CALL  runtime.growslice(SB)//appendæ“ä½œ
0x00a4 00164 (slice.go:11)  CALL  runtime.convTslice(SB)//ç±»å‹è½¬æ¢
0x00bc 00188 (slice.go:11)  CALL  runtime.convT64(SB)
0x00d4 00212 (slice.go:11)  CALL  runtime.convT64(SB)
æˆ‘ä»¬èƒ½è§‚å¯Ÿå‡ºï¼Œåº•å±‚æ˜¯è°ƒç”¨runtimeä¸­çš„makesliceæ–¹æ³•æ¥åˆ›å»ºsliceçš„ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹makesliceå‡½æ•°åˆ°åº•åšäº†ä»€ä¹ˆã€‚
func makeslice
(et *_type, len, cap int) unsafe
.
Pointer {
  mem, overflow := math.MulUintptr(et.size, 
uintptr
(
cap
))
  if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap {
// NOTE: Produce a â€˜len out of rangeâ€™ error instead of a
// â€˜cap out of rangeâ€™ error when someone does make([]T, bignumber).
    // â€˜cap out of rangeâ€™ is true too, but since the cap is only being
    // supplied implicitly, saying len is clearer.
    // See golang.org/issue/4085.
    mem, overflow := math.MulUintptr(et.size, uintptr(len))
    if overflow || mem &gt; maxAlloc || len &lt; 0 {
      panicmakeslicelen()
    }
    panicmakeslicecap()
  }</p>

<p>// Allocate an object of size bytes.
  // Small objects are allocated from the per-P cacheâ€™s free lists.
  // Large objects (&gt; 32 kB) are allocated straight from the heap.
  return mallocgc(mem, et, true)
}
func panicmakeslicelen() {
panic
(errorString(
â€œmakeslice: len out of rangeâ€
))
}
func panicmakeslicecap() {
  panic(errorString(â€œmakeslice: cap out of rangeâ€))
}
MulUintptrå‡½æ•°æºç ï¼š
package
math
import â€œruntime/internal/sysâ€
const MaxUintptr = ^uintptr(0)
// MulUintptr returns a * b and whether the multiplication overflowed.
// On supported platforms this is an intrinsic lowered by the compiler.
func MulUintptr(a, b uintptr) (uintptr, bool) {
if a|b &lt; 1
Â«(
4
<em>sys.PtrSize) || a == 
0 {//a|b &lt; 1Â«(4</em>8)
    return a * b, false
  }
  overflow := b &gt; MaxUintptr/a
  return a * b, overflow
}
ç®€å•æ¥è¯´ï¼Œmakesliceå‡½æ•°çš„å·¥ä½œä¸»è¦å°±æ˜¯è®¡ç®—sliceæ‰€éœ€å†…å­˜å¤§å°ï¼Œç„¶åè°ƒç”¨mallocgcè¿›è¡Œå†…å­˜çš„åˆ†é…ã€‚è®¡ç®—sliceæ‰€éœ€å†…å­˜åˆæ˜¯é€šè¿‡MulUintptræ¥å®ç°çš„ï¼ŒMulUintptrçš„æºç æˆ‘ä»¬ä¹Ÿå·²ç»è´´å‡ºï¼Œä¸»è¦å°±æ˜¯ç”¨åˆ‡ç‰‡ä¸­å…ƒç´ å¤§å°å’Œåˆ‡ç‰‡çš„å®¹é‡ç›¸ä¹˜è®¡ç®—å‡ºæ‰€éœ€å ç”¨çš„å†…å­˜ç©ºé—´ï¼Œå¦‚æœå†…å­˜æº¢å‡ºï¼Œæˆ–è€…è®¡ç®—å‡ºçš„å†…å­˜å¤§å°å¤§äºæœ€å¤§å¯åˆ†é…å†…å­˜ï¼ŒMulUintptrçš„overflowä¼šè¿”å›trueï¼Œmakesliceå°±ä¼šæŠ¥é”™ã€‚å¦å¤–å¦‚æœä¼ å…¥é•¿åº¦å°äº0æˆ–è€…é•¿åº¦å°äºå®¹é‡ï¼Œmakesliceä¹Ÿä¼šæŠ¥é”™ã€‚
appendæ“ä½œ
é¦–å…ˆæˆ‘ä»¬æ¥çœ‹ä¸€æ®µç¨‹åºï¼š
package main</p>

<p>import (
â€œ
fmt
â€œ
   â€œunsafeâ€
)</p>

<p>func main() {
   slice := make([]int, 0, 10)
   slice = append(slice, 1)
   fmt.Println(unsafe.Pointer(&amp;slice[0]), len(slice), cap(slice))
   slice = append(slice, 2)
   fmt.Println(unsafe.Pointer(&amp;slice[0]), len(slice), cap(slice))
}
æˆ‘ä»¬ç›´æ¥ç»™å‡ºç»“æœï¼š</p>

<p>0xc00009e000 1 10
0xc00009e000 2 10
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå½“sliceå®¹é‡è¶³å¤Ÿæ—¶ï¼Œæˆ‘ä»¬å¾€sliceä¸­appendä¸€ä¸ª2ï¼Œsliceåº•å±‚æ•°ç»„æŒ‡å‘çš„å†…å­˜åœ°å€æ²¡æœ‰å‘ç”Ÿæ”¹å˜ï¼›å†çœ‹ä¸€æ®µç¨‹åºï¼š
func main() {
   slice := make([]int, 0)
   slice = append(slice, 1)
   fmt.Printf(â€œ%p %d %d\nâ€, unsafe.Pointer(&amp;slice[0]), len(slice), cap(slice))
   slice = append(slice, 2)
   fmt.Printf(â€œ%p %d %d\nâ€, unsafe.Pointer(&amp;slice[0]), len(slice), cap(slice))
}
è¾“å‡ºç»“æœæ˜¯ï¼š</p>

<p>0xc00009a008 1 1
0xc00009a030 2 2
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å½“å¾€sliceä¸­appendä¸€ä¸ª1åï¼Œsliceåº•å±‚æ•°ç»„çš„æŒ‡é’ˆæŒ‡å‘åœ°å€0xc00009a008ï¼Œé•¿åº¦ä¸º1ï¼Œå®¹é‡ä¸º1ã€‚è¿™æ—¶å†å¾€sliceä¸­appendä¸€ä¸ª2ï¼Œé‚£ä¹ˆsliceçš„å®¹é‡ä¸å¤Ÿäº†ï¼Œæ­¤æ—¶åº•å±‚æ•°ç»„ä¼šå‘ç”Ÿcopyï¼Œä¼šé‡æ–°åˆ†é…ä¸€å—æ–°çš„å†…å­˜åœ°å€ï¼Œå®¹é‡ä¹Ÿå˜æˆäº†2ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¼šçœ‹åˆ°åº•å±‚æ•°ç»„çš„æŒ‡é’ˆæŒ‡å‘åœ°å€å‘ç”Ÿäº†æ”¹å˜ã€‚æ ¹æ®ä¹‹å‰æ±‡ç¼–çš„ç»“æœæˆ‘ä»¬çŸ¥æ™“äº†ï¼Œappendæ“ä½œå…¶å®æ˜¯è°ƒç”¨äº†runtime/slice.goä¸­çš„growsliceå‡½æ•°ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹æºç ï¼š
func growslice
(et <em>_type, old slice, cap int) slice {
  â€¦
  â€¦
  if cap &lt; old.cap {
panic
(errorString(
â€œgrowslice: cap out of rangeâ€
))
  }
  if et.size == 0 {
// append should not create a slice with nil pointer but non-zero len.
    // We assume that append doesnâ€™t need to preserve old.array in this case.
    return slice{unsafe.Pointer(&amp;zerobase), old.len, cap}
  }
  newcap := old.cap//1280
  doublecap := newcap + newcap//1280+1280=2560
  if cap &gt; doublecap {
newcap
 = 
cap
  } else {
if old.len &lt; 1024 {
newcap
 = doublecap
    } else {
// Check 0 &lt; newcap to detect overflow
      // and prevent an infinite loop.
      for 0 &lt; newcap &amp;&amp; newcap &lt; cap {
newcap
 += newcap / 
4
//1280</em>1.25=1600
      }
      // Set newcap to the requested cap when
      // the newcap calculation overflowed.
      if newcap &lt;= 0 {
        newcap = cap
      }
    }
  }
  â€¦
}
æˆ‘ä»¬ä¸»è¦å…³æ³¨ä¸‹capçš„æ‰©å®¹è§„åˆ™ï¼Œä»æºç ä¸­æˆ‘ä»¬å¯ä»¥ç®€å•çš„æ€»ç»“å‡ºsliceå®¹é‡çš„æ‰©å®¹è§„åˆ™ï¼šå½“åŸsliceçš„capå°äº1024æ—¶ï¼Œæ–°sliceçš„capå˜ä¸ºåŸæ¥çš„2å€ï¼›åŸsliceçš„capå¤§äº1024æ—¶ï¼Œæ–°sliceå˜ä¸ºåŸæ¥çš„1.25å€ï¼Œæˆ‘ä»¬å†™ä¸ªç¨‹åºæ¥éªŒè¯ä¸‹ï¼š
package
 main
import â€œfmtâ€
func main() {
  slice := 
make
([]
int
, 
0
)
  oldCap := cap(slice)
  for i := 0; i &lt; 4096; i++ {
    slice = append(slice, i)
    newCap := cap(slice)
    if newCap != oldCap {
      fmt.Printf(â€œoldCap = %-4d  after append %-4d  newCap = %-4d\nâ€, oldCap, i, newCap)
      oldCap = newCap
    }
  }
}
è¿™æ®µç¨‹åºå®ç°çš„åŠŸèƒ½æ˜¯ï¼šå½“capå‘ç”Ÿæ”¹å˜æ—¶ï¼Œæ‰“å°å‡ºcapæ”¹å˜å‰åçš„å€¼ã€‚æˆ‘ä»¬æ¥çœ‹ç¨‹åºçš„è¾“å‡ºç»“æœï¼š</p>

<p>oldCap = 0 after append 0 newCap = 1 
oldCap = 1 after append 1 newCap = 2 
oldCap = 2 after append 2 newCap = 4 
oldCap = 4 after append 4 newCap = 8 
oldCap = 8 after append 8 newCap = 16 
oldCap = 16 after append 16 newCap = 32 
oldCap = 32 after append 32 newCap = 64 
oldCap = 64 after append 64 newCap = 128 
oldCap = 128 after append 128 newCap = 256 
oldCap = 256 after append 256 newCap = 512 
oldCap = 512 after append 512 newCap = 1024
oldCap = 1024 after append 1024 newCap = 1280
oldCap = 1280 after append 1280 newCap = 1696
oldCap = 1696 after append 1696 newCap = 2304
oldCap = 2304 after append 2304 newCap = 3072
oldCap = 3072 after append 3072 newCap = 4096
ä¸€å¼€å§‹çš„æ—¶å€™çœ‹èµ·æ¥è·Ÿæˆ‘è¯´çš„æ‰©å®¹è§„åˆ™æ˜¯ä¸€æ ·çš„ï¼Œä»1-&gt;2-&gt;4-&gt;8-&gt;16â€¦-&gt;1024ï¼Œéƒ½æ˜¯æˆå€å¢é•¿ï¼Œå½“capå¤§äº1024åï¼Œå†appendå…ƒç´ ï¼Œcapå˜ä¸º1280ï¼Œå˜æˆäº†1024çš„1.25å€ï¼Œä¹Ÿç¬¦åˆæˆ‘ä»¬çš„è§„åˆ™ï¼›ä½†æ˜¯ç»§ç»­appendï¼Œ1280-&gt;1696ï¼Œä¼¼ä¹ä¸æ˜¯1.25å€ï¼Œè€Œæ˜¯1.325å€ï¼Œå¯è§æ‰©å®¹è§„åˆ™å¹¶ä¸æ˜¯æˆ‘ä»¬ä»¥ä¸Šæ‰€è¯´çš„é‚£ä¹ˆç®€å•ï¼Œæˆ‘ä»¬å†ç»§ç»­å¾€ä¸‹çœ‹æºç ï¼š</p>

<p>var overflow bool
  var lenmem, newlenmem, capmem uintptr
  // Specialize for common values of et.size.
  // For 1 we donâ€™t need any division/multiplication.
  // For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.
  // For powers of 2, use a variable shift.
  switch {
case et.size == 1
:
    lenmem = uintptr(old.len)
    newlenmem = uintptr(cap)
    capmem = roundupsize(uintptr(newcap))
    overflow = uintptr(newcap) &gt; maxAlloc
    newcap = int(capmem)
  case et.size == sys.PtrSize:
    lenmem = 
uintptr
(old.
len
) * sys.PtrSize
    newlenmem = uintptr(cap) * sys.PtrSize
    capmem = roundupsize(uintptr(newcap) * sys.PtrSize)//13568
    overflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSize
    newcap = int(capmem / sys.PtrSize)//13568/8=1696
  case isPowerOfTwo(et.size):
var shift uintptr
    if sys.PtrSize == 8 {
// Mask shift for better code generation.
      shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63
    } else {
      shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31
    }
    lenmem = uintptr(old.len) Â«Â shift
    newlenmem = uintptr(cap) Â«Â shift
    capmem = roundupsize(uintptr(newcap) Â«Â shift)
    overflow = uintptr(newcap) &gt; (maxAllocÂ Â» shift)
    newcap = int(capmemÂ Â» shift)
  default:
    lenmem = uintptr(old.len) * et.size
    newlenmem = uintptr(cap) * et.size
    capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))
    capmem = roundupsize(capmem)
    newcap = int(capmem / et.size)
  }
æˆ‘ä»¬çœ‹åˆ°æ¯ä¸ªcaseä¸­éƒ½æ‰§è¡Œäº†roundupsizeï¼Œæˆ‘ä»¬å†çœ‹ä¸‹roundupsizeçš„æºç ï¼Œå¦‚ä¸‹ï¼š</p>

<p>package
 runtime
// Returns size of the memory block that mallocgc will allocate if you ask for the size.
func roundupsize(size uintptr) uintptr {
if size &lt; _MaxSmallSize {//size=1600*8=12800&lt;32768
    if size &lt;= smallSizeMax-8 {//12800&lt;=0
      return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
    } else {
return uintptr
(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv
-1
)/largeSizeDiv]])
//size_to_class128[92]= 56
      //class_to_size[56]=13568
      //13568/8=1696
    }
  }
  if size+_PageSize &lt; size {
return size
  }
  return round(size, _PageSize)
}
const _MaxSmallSize   = 32768
const smallSizeDiv    = 8
const smallSizeMax    = 1024
const largeSizeDiv    = 128
å…¶å®roundupsizeæ˜¯å†…å­˜å¯¹é½çš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬çŸ¥é“golangä¸­å†…å­˜åˆ†é…æ˜¯æ ¹æ®å¯¹è±¡å¤§å°æ¥é…ä¸åŒçš„mspanï¼Œä¸ºäº†é¿å…é€ æˆè¿‡å¤šçš„å†…å­˜ç¢ç‰‡ï¼Œsliceåœ¨æ‰©å®¹ä¸­éœ€è¦å¯¹æ‰©å®¹åçš„capå®¹é‡è¿›è¡Œå†…å­˜å¯¹é½çš„æ“ä½œï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å¯¹ç…§æºç æ¥å®é™…è®¡ç®—ä¸‹capå®¹é‡æ˜¯å¦ç”±1280å˜æˆäº†1696ã€‚
ä»ä»¥ä¸Šæµç¨‹å›¾å¯ä»¥çœ‹å‡ºï¼Œcapåœ¨å˜æˆ1600ååˆè¿›å…¥äº†å†…å­˜å¯¹é½çš„è¿‡ç¨‹ï¼Œæœ€ç»ˆcapå˜ä¸ºäº†1696ã€‚
sliceæˆªå–
goä¸­çš„sliceæ˜¯æ”¯æŒæˆªå–æ“ä½œçš„ï¼Œè™½ç„¶ä½¿ç”¨èµ·æ¥éå¸¸çš„æ–¹ä¾¿ï¼Œä½†æ˜¯æœ‰å¾ˆå¤šå‘ï¼Œç¨æœ‰ä¸æ…å°±ä¼šå‡ºç°bugä¸”ä¸æ˜“æ’æŸ¥ã€‚
è®©æˆ‘ä»¬æ¥çœ‹ä¸€æ®µç¨‹åºï¼š
package
 main</p>

<p>import â€œfmtâ€</p>

<p>func main() {
  slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
  s1 := slice[2:5]
  s2 := s1[2:7]
  fmt.Printf(â€œlen=%-4d cap=%-4d slice=%-1v \nâ€, len(slice), cap(slice), slice)
  fmt.Printf(â€œlen=%-4d cap=%-4d s1=%-1v \nâ€, len(s1), cap(s1), s1)
  fmt.Printf(â€œlen=%-4d cap=%-4d s2=%-1v \nâ€, len(s2), cap(s2), s2)
}
ç¨‹åºè¾“å‡ºï¼š</p>

<h1 id="len">len</h1>
<p>10 cap=10 slice=[0 1 2 3 4 5 6 7 8 9
] 
len=3 cap=8 s1=[2 3 4] 
len=5 cap=6 s2=[4 5 6 7 8]
s1çš„é•¿åº¦å˜æˆ3ï¼Œcapå˜ä¸º8ï¼ˆé»˜è®¤æˆªå–åˆ°æœ€å¤§å®¹é‡ï¼‰ï¼Œ ä½†æ˜¯s2æˆªå–s1çš„ç¬¬2åˆ°ç¬¬7ä¸ªå…ƒç´ ï¼Œå·¦é—­å³å¼€ï¼Œå¾ˆå¤šäººæƒ³é—®ï¼Œs1æ ¹æœ¬æ²¡æœ‰é‚£ä¹ˆå…ƒç´ å•Šï¼Œä½†æ˜¯å®é™…æƒ…å†µæ˜¯s2æˆªå–åˆ°äº†ï¼Œå¹¶ä¸”æ²¡æœ‰å‘ç”Ÿæ•°ç»„è¶Šç•Œï¼ŒåŸå› å°±æ˜¯s2å®é™…æˆªå–çš„æ˜¯åº•å±‚æ•°ç»„ï¼Œç›®å‰sliceã€s1ã€s2éƒ½æ˜¯å…±ç”¨çš„åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚</p>

<p>æˆ‘ä»¬ç»§ç»­æ“ä½œï¼š</p>

<p>fmt.Println(â€œâ€”â€”â€“append 100â€”â€”â€”â€”â€”-â€œ)
s2 = append(s2, 100)
è¾“å‡ºç»“æœæ˜¯ï¼š</p>

<hr />
<p>append 100
â€”â€”â€”â€”â€”-
len=10 cap=10 slice=[0 1 2 3 4 5 6 7 8 100] 
len=3 cap=8 s1=[2 3 4] 
len=6 cap=6 s2=[4 5 6 7 8 100]
æˆ‘ä»¬çœ‹åˆ°å¾€s2é‡Œappendæ•°æ®å½±å“åˆ°äº†sliceï¼Œæ­£æ˜¯å› ä¸ºä¸¤è€…åº•å±‚æ•°ç»„æ˜¯ä¸€æ ·çš„ï¼›ä½†æ˜¯æ—¢ç„¶éƒ½æ˜¯å…±ç”¨çš„åŒä¸€åº•å±‚æ•°ç»„ï¼Œs1ä¸ºä»€ä¹ˆæ²¡æœ‰100ï¼Œè¿™ä¸ªé—®é¢˜å†ä¸‹ä¸€èŠ‚ä¼šè®²åˆ°ï¼Œå¤§å®¶ç¨å®‰å‹¿èºã€‚æˆ‘ä»¬ç»§ç»­è¿›è¡Œæ“ä½œï¼š</p>

<p>fmt.Println(â€œâ€”â€”â€“append 200â€”â€”â€”â€”â€”-â€œ)
s2 = append(s2, 200)
è¾“å‡ºç»“æœæ˜¯ï¼š</p>

<hr />
<p>append 200
â€”â€”â€”â€”â€”-
len=10 cap=10 slice=[0 1 2 3 4 5 6 7 8 100] 
len=3 cap=8 s1=[2 3 4] 
len=7 cap=12 s2=[4 5 6 7 8 100 200]
æˆ‘ä»¬çœ‹åˆ°ç»§ç»­å¾€s2ä¸­appendä¸€ä¸ª200ï¼Œä½†æ˜¯åªæœ‰s2å‘ç”Ÿäº†å˜åŒ–ï¼Œsliceå¹¶æœªæ”¹å˜ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿå¯¹ï¼Œæ˜¯å› ä¸ºåœ¨appendå®Œ100åï¼Œs2çš„å®¹é‡å·²æ»¡ï¼Œå†å¾€s2ä¸­appendï¼Œåº•å±‚æ•°ç»„å‘ç”Ÿå¤åˆ¶ï¼Œç³»ç»Ÿåˆ†é…äº†ä¸€å—æ–°çš„å†…å­˜åœ°å€ç»™s2ï¼Œs2çš„å®¹é‡ä¹Ÿç¿»å€äº†ã€‚</p>

<p>æˆ‘ä»¬ç»§ç»­æ“ä½œï¼š</p>

<p>fmt.Println(â€œâ€”â€”â€“modify s1â€”â€”â€”â€”â€”-â€œ)
s1[2] = 20
è¾“å‡ºä¼šæ˜¯ä»€ä¹ˆæ ·å‘¢ï¼Ÿ</p>

<p>â€”â€”â€“modify s1â€”â€”â€”â€”â€”-
len=10   cap=10   slice=[0 1 2 3 20 5 6 7 8 100] 
len=3    cap=8    s1=[2 3 20] 
len=7    cap=12   s2=[4 5 6 7 8 100 200]
è¿™å°±å¾ˆå®¹æ˜“ç†è§£äº†ï¼Œæˆ‘ä»¬å¯¹s1è¿›è¡Œæ›´æ–°ï¼Œå½±å“äº†sliceï¼Œå› ä¸ºä¸¤è€…å…±ç”¨çš„è¿˜æ˜¯åŒä¸€åº•å±‚æ•°ç»„ï¼Œs2æœªå‘ç”Ÿæ”¹å˜æ˜¯å› ä¸ºåœ¨ä¸Šä¸€æ­¥æ—¶åº•å±‚æ•°ç»„å·²ç»å‘ç”Ÿäº†å˜åŒ–ï¼›</p>

<p>ä»¥æ­¤æ¥çœ‹ï¼Œsliceæˆªå–çš„å‘ç¡®å®å¾ˆå¤šï¼Œæå®¹æ˜“å‡ºç°bugï¼Œå¹¶ä¸”éš¾ä»¥æ’æŸ¥ï¼Œå¤§å®¶åœ¨ä½¿ç”¨çš„æ—¶å€™ä¸€å®šæ³¨æ„ã€‚</p>

<p>sliceæ·±æ‹·è´
ä¸Šä¸€èŠ‚ä¸­å¯¹sliceè¿›è¡Œçš„æˆªå–ï¼Œæ–°çš„sliceå’ŒåŸå§‹sliceå…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ï¼Œå› æ­¤å¯ä»¥çœ‹åšæ˜¯å¯¹sliceçš„æµ…æ‹·è´ï¼Œé‚£ä¹ˆåœ¨goä¸­å¦‚ä½•å®ç°å¯¹sliceçš„æ·±æ‹·è´å‘¢ï¼Ÿé‚£ä¹ˆå°±è¦ä¾èµ–golangæä¾›çš„copyå‡½æ•°äº†ï¼Œæˆ‘ä»¬ç”¨ä¸€æ®µç¨‹åºæ¥ç®€å•çœ‹ä¸‹å¦‚ä½•å®ç°æ·±æ‹·è´ï¼š
func main
() {</p>

<p>// Creating slices
  slice1 := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
  var slice2 []int
  slice3 := make([]int, 5)</p>

<p>// Before copying
  fmt.Println(â€œâ€”â€”â€”â€”before copyâ€”â€”â€”â€”-â€œ)
  fmt.Printf(â€œlen=%-4d cap=%-4d slice1=%v\nâ€, len(slice1), cap(slice1), slice1)
  fmt.Printf(â€œlen=%-4d cap=%-4d slice2=%v\nâ€, len(slice2), cap(slice2), slice2)
  fmt.Printf(â€œlen=%-4d cap=%-4d slice3=%v\nâ€, len(slice3), cap(slice3), slice3)</p>

<p>// Copying the slices
  copy_1 := copy(slice2, slice1)
  fmt.Println()
  fmt.Printf(â€œlen=%-4d cap=%-4d slice1=%v\nâ€, len(slice1), cap(slice1), slice1)
  fmt.Printf(â€œlen=%-4d cap=%-4d slice2=%v\nâ€, len(slice2), cap(slice2), slice2)
  fmt.Println(â€œTotal number of elements copied:â€, copy_1)
}
é¦–å…ˆå®šä¹‰äº†ä¸‰ä¸ªsliceï¼Œç„¶åå°†slice1 copyåˆ°slice2ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹è¾“å‡ºç»“æœï¼š</p>

<p>â€”â€”â€”â€”before 
copy
â€”â€”â€”â€”-
len=10 cap=10 slice1=[0 1 2 3 4 5 6 7 8 9]
len=0 cap=0 slice2=[]
len
=
5 cap
=
5 slice3=[0 0 0 0 0
]</p>

<p>len=10 cap=10 slice1=[0 1 2 3 4 5 6 7 8 9]
len=0 cap=0 slice2=[]
Total number of elements copied: 0
æˆ‘ä»¬å‘ç°slice1çš„å†…å®¹å¹¶æœªcopyåˆ°slice2ï¼Œä¸ºä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬å†è¯•ä¸‹å°†slice1 copyåˆ°slice3ï¼Œå¦‚ä¸‹ï¼š</p>

<p>copy_2 := copy(slice3, slice1)
è¾“å‡ºç»“æœï¼š
len=10   cap=10   slice1=[0 1 2 3 4 5 6 7 8 9]
len=5    cap=5    slice3=[0 1 2 3 4]
Total number of elements copied: 5
æˆ‘ä»¬çœ‹åˆ°copyæˆåŠŸï¼Œslice3å’Œslice2å”¯ä¸€çš„åŒºåˆ«å°±æ˜¯slice3çš„å®¹é‡ä¸º5ï¼Œè€Œslice2å®¹é‡ä¸º0ï¼Œé‚£ä¹ˆæ˜¯å¦æ˜¯æ·±æ‹·è´å‘¢ï¼Œæˆ‘ä»¬ä¿®æ”¹slice3çš„å†…å®¹çœ‹ä¸‹ï¼š
slice3[0] = 100
æˆ‘ä»¬å†çœ‹ä¸‹è¾“å‡ºç»“æœï¼š
len
=
10 cap=10 slice1=[0 1 2 3 4 5 6 7 8 9
]
len=5 cap=5 slice3=[100 1 2 3 4]
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä¿®æ”¹slice3åï¼Œslice1çš„å€¼å¹¶æœªæ”¹å˜ï¼Œå¯è§copyå®ç°çš„æ˜¯æ·±æ‹·è´ã€‚ç”±æ­¤å¯è§ï¼Œcopyå‡½æ•°ä¸ºsliceæä¾›äº†æ·±æ‹·è´èƒ½åŠ›ï¼Œä½†æ˜¯éœ€è¦åœ¨æ‹·è´å‰ç”³è¯·å†…å­˜ç©ºé—´ã€‚å‚ç…§makesliceå’Œgrowsliceæˆ‘ä»¬å¯¹æœ¬èŠ‚ä¸€å¼€å§‹çš„ç¨‹åºè¿›è¡Œåæ±‡ç¼–ï¼Œå¾—åˆ°æ±‡ç¼–ä»£ç ï¼ˆéƒ¨åˆ†ï¼‰å¦‚ä¸‹ï¼š
0x0080 00128 (slice.go
:
10
)
CALL
runtime
.makeslice
(
SB
)
  0x0085 00133 (slice.go:10)  PCDATA  $0, $1
  0x0085 00133 (slice.go:10)  MOVQ  24(SP), AX
  0x008a 00138 (slice.go:10)  PCDATA  $1, $2
  0x008a 00138 (slice.go:10)  MOVQ  AX, â€œâ€..autotmp_75+96(SP)
  0x008f 00143 (slice.go:11)  PCDATA  $0, $4
  0x008f 00143 (slice.go:11)  MOVQ  â€œâ€..autotmp_74+104(SP), CX
  0x0094 00148 (slice.go:11)  CMPQ  AX, CX
  0x0097 00151 (slice.go:11)  JEQ  176
  0x0099 00153 (slice.go:11)  PCDATA  $0, $5
  0x0099 00153 (slice.go:11)  MOVQ  AX, (SP)
  0x009d 00157 (slice.go:11)  PCDATA  $0, $0
  0x009d 00157 (slice.go:11)  MOVQ  CX, 8(SP)
  0x00a2 00162 (slice.go:11)  MOVQ  $40, 16(SP)
  0x00ab 00171 (slice.go:11)  CALL  runtime.memmove(SB)
  0x00b0 00176 (slice.go:12)  MOVQ  $10, (SP)
  0x00b8 00184 (slice.go:12)  CALL  runtime.convT64(SB)
æˆ‘ä»¬å‘ç°copyå‡½æ•°å…¶å®æ˜¯è°ƒç”¨runtime.memmoveï¼Œå…¶å®æˆ‘ä»¬åœ¨ç ”ç©¶runtime/slice.goæ–‡ä»¶ä¸­çš„æºç çš„æ—¶å€™ï¼Œä¼šå‘ç°æœ‰ä¸€ä¸ªslicecopyå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°æœ€ç»ˆå°±æ˜¯è°ƒç”¨runtime.memmoveæ¥å®ç°sliceçš„copyçš„ï¼Œæˆ‘ä»¬çœ‹ä¸‹æºç ï¼š
func slicecopy
(to, fm slice, width uintptr) int {
// å¦‚æœæºåˆ‡ç‰‡æˆ–è€…ç›®æ ‡åˆ‡ç‰‡æœ‰ä¸€ä¸ªé•¿åº¦ä¸º0ï¼Œé‚£ä¹ˆå°±ä¸éœ€è¦æ‹·è´ï¼Œç›´æ¥ return 
  if fm.len == 0 || to.len == 0 {
return 0
  }</p>

<p>// n è®°å½•ä¸‹æºåˆ‡ç‰‡æˆ–è€…ç›®æ ‡åˆ‡ç‰‡è¾ƒçŸ­çš„é‚£ä¸€ä¸ªçš„é•¿åº¦
  n := fm.len
  if to.len &lt; n {
n
 = to.
len
  }</p>

<p>// å¦‚æœå…¥å‚ width = 0ï¼Œä¹Ÿä¸éœ€è¦æ‹·è´äº†ï¼Œè¿”å›è¾ƒçŸ­çš„åˆ‡ç‰‡çš„é•¿åº¦
  if width == 0 {
return n
  }</p>

<p>//å¦‚æœå¼€å¯ç«äº‰æ£€æµ‹
  if raceenabled {
callerpc
 := getcallerpc()
    pc := funcPC(slicecopy)
    racewriterangepc(to.array, uintptr(n<em>int(width)), callerpc, pc)
    racereadrangepc(fm.array, uintptr(n</em>int(width)), callerpc, pc)
  }
  if msanenabled {
    msanwrite(to.
array
, 
uintptr
(n*
int
(width)))
    msanread(fm.array, uintptr(n*int(width)))
  }</p>

<p>size := uintptr(n) * width
  if size == 1 { // common case worth about 2x to do here
    // TODO: is this still worth it with new memmove impl?
//å¦‚æœåªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆç›´æ¥è¿›è¡Œåœ°å€è½¬æ¢
    <em>(</em>byte)(to.array) = <em>(</em>byte)(fm.array) // known to be a byte pointer
  } else {
//å¦‚æœä¸æ­¢ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆå°±ä» fm.array åœ°å€å¼€å§‹ï¼Œæ‹·è´åˆ° to.array åœ°å€ä¹‹åï¼Œæ‹·è´ä¸ªæ•°ä¸ºsize
    memmove(to.array, fm.array, size)
  }
  return n
}
æºç è§£è¯»è§ä¸­æ–‡æ³¨é‡Šã€‚
å€¼ä¼ é€’è¿˜æ˜¯å¼•ç”¨ä¼ é€’
sliceåœ¨ä½œä¸ºå‡½æ•°å‚æ•°è¿›è¡Œä¼ é€’çš„æ—¶å€™ï¼Œæ˜¯å€¼ä¼ é€’è¿˜æ˜¯å¼•ç”¨ä¼ é€’ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€æ®µç¨‹åºï¼š
package
 main</p>

<p>import â€œfmtâ€</p>

<p>func main() {
  slice := 
make
([]
int
, 
0
, 
10
)
  slice = append(slice, 1)
  fmt.Println(slice, len(slice), cap(slice))
  fn(slice)
  fmt.Println(slice, len(slice), cap(slice))
}
func fn(in []int) {
  in = append(in, 5)
}
å¾ˆç®€å•çš„ä¸€æ®µç¨‹åºï¼Œæˆ‘ä»¬ç›´æ¥æ¥çœ‹è¾“å‡ºç»“æœï¼š
[
1
] 
1 10
[1] 1 10
å¯è§fnå†…çš„appendæ“ä½œå¹¶æœªå¯¹sliceäº§ç”Ÿå½±å“ï¼Œé‚£æˆ‘ä»¬å†çœ‹ä¸€æ®µä»£ç ï¼š
package
 main</p>

<p>import â€œfmtâ€</p>

<p>func main() {
  slice := 
make
([]
int
, 
0
, 
10
)
  slice = append(slice, 1)
  fmt.Println(slice, len(slice), cap(slice))
  fn(slice)
  fmt.Println(slice, len(slice), cap(slice))
}
func fn(in []int) {
  in[0] = 100
}
è¾“å‡ºæ˜¯ä»€ä¹ˆï¼Ÿæˆ‘ä»¬æ¥çœ‹ä¸‹ï¼š</p>

<p>[
1
] 
1 10
[100] 1 10
sliceå±…ç„¶æ”¹å˜äº†ï¼Œæ˜¯ä¸æ˜¯æœ‰ç‚¹æ··ä¹±ï¼Ÿå‰é¢æˆ‘ä»¬è¯´åˆ°sliceåº•å±‚å…¶å®æ˜¯ä¸€ä¸ªç»“æ„ä½“ï¼Œlenã€capã€arrayåˆ†åˆ«è¡¨ç¤ºé•¿åº¦ã€å®¹é‡ã€åº•å±‚æ•°ç»„çš„åœ°å€ï¼Œå½“sliceä½œä¸ºå‡½æ•°çš„å‚æ•°ä¼ é€’çš„æ—¶å€™ï¼Œè·Ÿæ™®é€šç»“æ„ä½“çš„ä¼ é€’æ˜¯æ²¡æœ‰åŒºåˆ«çš„ï¼›å¦‚æœç›´æ¥ä¼ sliceï¼Œå®å‚sliceæ˜¯ä¸ä¼šè¢«å‡½æ•°ä¸­çš„æ“ä½œæ”¹å˜çš„ï¼Œä½†æ˜¯å¦‚æœä¼ é€’çš„æ˜¯sliceçš„æŒ‡é’ˆï¼Œæ˜¯ä¼šæ”¹å˜åŸæ¥çš„sliceçš„ï¼›å¦å¤–ï¼Œæ— è®ºæ˜¯ä¼ é€’sliceè¿˜æ˜¯sliceçš„æŒ‡é’ˆï¼Œå¦‚æœæ”¹å˜äº†sliceçš„åº•å±‚æ•°ç»„ï¼Œé‚£ä¹ˆéƒ½æ˜¯ä¼šå½±å“sliceçš„ï¼Œè¿™ç§é€šè¿‡æ•°ç»„ä¸‹æ ‡çš„æ–¹å¼æ›´æ–°sliceæ•°æ®ï¼Œæ˜¯ä¼šå¯¹åº•å±‚æ•°ç»„è¿›è¡Œæ”¹å˜çš„ï¼Œæ‰€ä»¥å°±ä¼šå½±å“sliceã€‚</p>

<p>é‚£ä¹ˆï¼Œè®²åˆ°è¿™é‡Œï¼Œåœ¨ç¬¬ä¸€æ®µç¨‹åºä¸­åœ¨fnå‡½æ•°å†…appendçš„5åˆ°å“ªé‡Œå»äº†ï¼Œä¸å¯èƒ½å‡­ç©ºæ¶ˆå¤±å•Šï¼Œæˆ‘ä»¬å†æ¥çœ‹ä¸€æ®µç¨‹åºï¼š
package
 main</p>

<p>import â€œfmtâ€</p>

<p>func main() {
  slice := 
make
([]
int
, 
0
, 
10
)
  slice = append(slice, 1)
  fmt.Println(slice, len(slice), cap(slice))
  fn(slice)
  fmt.Println(slice, len(slice), cap(slice))
  s1 := slice[0:9]//æ•°ç»„æˆªå–
  fmt.Println(s1, len(s1), cap(s1))
}
func fn(in []int) {
  in = append(in, 5)
}
æˆ‘ä»¬æ¥çœ‹è¾“å‡ºç»“æœï¼š
[
1
] 
1 10
[1] 1 10
[1 5 0 0 0 0 0 0 0] 9 10
æ˜¾ç„¶ï¼Œè™½ç„¶åœ¨appendåï¼Œsliceä¸­å¹¶æœªå±•ç¤ºå‡º5ï¼Œä¹Ÿæ— æ³•é€šè¿‡slice[1]å–åˆ°ï¼ˆä¼šæ•°ç»„è¶Šç•Œï¼‰,ä½†æ˜¯å®é™…ä¸Šåº•å±‚æ•°ç»„å·²ç»æœ‰äº†5è¿™ä¸ªå…ƒç´ ï¼Œä½†æ˜¯ç”±äºsliceçš„lenæœªå‘ç”Ÿæ”¹å˜ï¼Œæ‰€ä»¥æˆ‘ä»¬åœ¨ä¸Šå±‚æ˜¯æ— æ³•è·å–åˆ°5è¿™ä¸ªå…ƒç´ çš„ã€‚é‚£ä¹ˆï¼Œå†é—®ä¸€ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬æ˜¯ä¸æ˜¯å¯ä»¥æ‰‹åŠ¨å¼ºåˆ¶æ”¹å˜sliceçš„lené•¿åº¦ï¼Œè®©æˆ‘ä»¬å¯ä»¥è·å–åˆ°5è¿™ä¸ªå…ƒç´ å‘¢ï¼Ÿæ˜¯å¯ä»¥çš„ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸€æ®µç¨‹åºï¼š
package
 main</p>

<p>import (
â€œfmtâ€
  â€œreflectâ€
  â€œunsafeâ€
)</p>

<p>func main() {
  slice := 
make
([]
int
, 
0
, 
10
)
  slice = append(slice, 1)
  fmt.Println(slice, len(slice), cap(slice))
  fn(slice)
  fmt.Println(slice, len(slice), cap(slice))
  (*reflect.SliceHeader)(unsafe.Pointer(&amp;slice)).Len = 2 //å¼ºåˆ¶ä¿®æ”¹sliceé•¿åº¦
  fmt.Println(slice, len(slice), cap(slice))
}</p>

<p>func fn(in []int) {
  in = append(in, 5)
}
æˆ‘ä»¬æ¥çœ‹è¾“å‡ºç»“æœï¼š
[
1
] 
1 10
[1] 1 10
[1 5] 2 10
å¯ä»¥çœ‹å‡ºï¼Œé€šè¿‡å¼ºåˆ¶ä¿®æ”¹sliceçš„lenï¼Œæˆ‘ä»¬å¯ä»¥è·å–åˆ°äº†5è¿™ä¸ªå…ƒç´ ã€‚
æ‰€ä»¥å†æ¬¡å›ç­”ä¸€å¼€å§‹æˆ‘ä»¬æå‡ºçš„é—®é¢˜ï¼Œsliceæ˜¯å€¼ä¼ é€’è¿˜æ˜¯å¼•ç”¨ä¼ é€’ï¼Ÿç­”æ¡ˆæ˜¯å€¼ä¼ é€’ï¼
ä»¥ä¸Šï¼Œåœ¨ä½¿ç”¨golangä¸­çš„sliceçš„æ—¶å€™å¤§å®¶ä¸€å®šæ³¨æ„ï¼Œå¦åˆ™ç¨æœ‰ä¸æ…å°±ä¼šå‡ºç°bugã€‚</p>
:ET