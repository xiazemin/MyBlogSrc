I"Ü<p>å‚è€ƒï¼š
https://github.com/howeyc/fsnotify
https://beego.me/docs/install/bee.md
<!-- more -->
bee ä½¿ç”¨fsnotifyåŒ…ï¼Œä½¿ç”¨kqueueæ£€æŸ¥æ–‡ä»¶å˜åŒ–ï¼Œæ ¹æ®ä¿®æ”¹æ—¶é—´æˆ³ï¼Œæ¯sæ£€æŸ¥ä¸€æ¬¡ï¼Œå¦‚æœæœ‰å˜åŒ–å°±é‡æ–°ç¼–è¯‘ï¼Œè°ƒç”¨è·¯å¾„å¦‚ä¸‹ï¼š
beego/bee/bee.go
var commands = []*Command{
	cmdNew,
	cmdRun,
	â€¦
	}
func main() {
  â€¦
  for _, cmd := range commands {
		â€¦
		os.Exit(cmd.Run(cmd, args))
		â€¦
}</p>

<p>beego/bee/run.go
   var cmdRun = &amp;Command{
   â€¦
   }
   func init() {
	cmdRun.Run = runApp
	â€¦
	}
	func runApp(cmd *Command, args []string) int {
	â€¦
	crupath, _ := os.Getwd()
	â€¦
	gps := GetGOPATHs()
	â€¦
	NewWatcher(paths, files, true)
	Autobuild(files, true)
	â€¦
	}</p>

<p>beego/bee/watch.go	
    func NewWatcher(paths []string, files []string, isgenerate bool) {
	 watcher, err := fsnotify.NewWatcher()
	 select {
				case e := &lt;-watcher.Event:
				mt := getFileModTime(e.Name)	          â€¦
	          Autobuild(files, isgenerate)
	          }
	  }
	 func Autobuild(files []string, isgenerate bool) {
       appName := appname
		if runtime.GOOS == â€œwindowsâ€ {
			appName += â€œ.exeâ€
		}
		args := []string{â€œbuildâ€}
		args = append(args, â€œ-oâ€, appName)
		if buildTags != â€œâ€ {
			args = append(args, â€œ-tagsâ€, buildTags)
		}
		args = append(args, filesâ€¦)
		bcmd := exec.Command(cmdName, argsâ€¦)
		bcmd.Env = append(os.Environ(), â€œGOGC=offâ€)
		bcmd.Stdout = os.Stdout
		bcmd.Stderr = os.Stderr
		err = bcmd.Run()
    }</p>

<p>howeyc/fsnotify/fsnotify_bsd.go	 
func NewWatcher() (*Watcher, error) {
	fd, errno := syscall.Kqueue()
	if fd == -1 {
		return nil, os.NewSyscallError(â€œkqueueâ€, errno)
	}
	w := &amp;Watcher{
		kq:              fd,
		watches:         make(map[string]int),
		fsnFlags:        make(map[string]uint32),
		enFlags:         make(map[string]uint32),
		paths:           make(map[int]string),
		finfo:           make(map[int]os.FileInfo),
		fileExists:      make(map[string]bool),
		externalWatches: make(map[string]bool),
		internalEvent:   make(chan *FileEvent),
		Event:           make(chan *FileEvent),
		Error:           make(chan error),
		done:            make(chan bool, 1),
	}
   go w.readEvents()
	go w.purgeEvents()
	return w, nil
}
è¯´æ˜å‡ ä¸ªæ¦‚å¿µ, struct event, kevent()å’Œkqueueã€‚</p>

<p>struct eventå°±æ˜¯kevent()æ“ä½œçš„æœ€åŸºæœ¬çš„äº‹ä»¶ç»“æ„ã€‚
kevent() æ˜¯ä¸€ä¸ªç³»ç»Ÿè°ƒç”¨syscallï¼Œè€Œkqueueæ˜¯freebsdå†…æ ¸ä¸­çš„ä¸€ä¸ªäº‹ä»¶é˜Ÿåˆ—kernel queueã€‚
kevent()æ˜¯kqueueçš„ç”¨æˆ·ç•Œé¢ï¼Œæ˜¯å¯¹kqueueè¿›è¡Œæ·»åŠ ï¼Œåˆ é™¤æ“ä½œçš„ç”¨æˆ·æ€çš„ç•Œé¢ã€‚
 ===</p>

<p>ä¸‹é¢å°±é‡ç‚¹ä»‹ç»ä¸€ä¸‹struct eventå’Œkevent()è¿™ä¸¤ä¸ªå¼€å‘è€…å¿…é¡»è¦äº†è§£çš„å‚æ•°å’ŒAPIã€‚</p>
<ol>
  <li>struct event ç»“æ„ä½“ä¸­ä¸»è¦æˆå‘˜ä»‹ç»
ident     â€“ æ ‡è®°äº‹ä»¶çš„æè¿°ç¬¦, socketfd, filefd, signal
filter      â€“ äº‹ä»¶çš„ç±»å‹, è¯»äº‹ä»¶:EVFILT_READ, å†™äº‹ä»¶:EVFILT_WRITE, ä¿¡å·:EVFILT_SIGNAL
flags     â€“ äº‹ä»¶çš„è¡Œä¸º, å¯¹kqueueçš„æ“ä½œ:
æ·»åŠ åˆ°kqueueä¸­:EV_ADD, ä»kqueueä¸­åˆ é™¤:EV_DELETE, è¿™ä¸¤ç§æ˜¯ä¸»è¦çš„è¡Œä¸º
ä¸€æ¬¡æ€§äº‹ä»¶:EV_ONESHOT, æ­¤äº‹ä»¶æ˜¯æˆ–æ“ä½œ, æŒ‡å®šäº†è¯¥äº‹ä»¶, kevent()è¿”å›å, äº‹ä»¶ä¼šä»kqueueä¸­åˆ é™¤
æ›´æ–°äº‹ä»¶: EV_CLEAR,æ­¤äº‹ä»¶æ˜¯æˆ–æ“ä½œ, æ‰‹å†Œä¸Šçš„è§£é‡Šæ˜¯ï¼Œå½“äº‹ä»¶é€šçŸ¥ç»™ç”¨æˆ·åï¼Œäº‹ä»¶çš„çŠ¶æ€ä¼šè¢«é‡ç½®ã€‚å¯ä»¥ç”¨åœ¨ç±»ä¼¼äºepollçš„ETæ¨¡å¼ï¼Œä¹Ÿå¯ä»¥ç”¨åœ¨æè¿°ç¬¦æœ‰æ—¶ä¼šå‡ºé”™çš„æƒ…å†µã€‚
å…¶ä»–äº‹ä»¶: EOFäº‹ä»¶:EV_EOF, é”™è¯¯äº‹ä»¶:EV_ERROR(è¿”å›å€¼)
fflags    -
data     -
udata   â€“ ç”¨æˆ·æŒ‡å®šçš„æ•°æ®</li>
  <li>kevent() å„å‚æ•°çš„è¯´æ˜
kq               - kqueue() è¿”å›çš„å”¯ä¸€æè¿°ç¬¦, æ ‡è®°ç€ä¸€ä¸ªå†…æ ¸é˜Ÿåˆ—
changes       â€“ éœ€è¦å¯¹kqueueè¿›è¡Œä¿®æ”¹çš„äº‹ä»¶é›†åˆ, æ­¤å‚æ•°å°±æ˜¯kevent()å¯¹ç›®å‰kqueueä¸­çš„äº‹ä»¶çš„æ“ä½œï¼Œæ¯”å¦‚åˆ é™¤kqueueä¸­å·²ç»å­˜åœ¨çš„äº‹ä»¶ï¼Œæˆ–è€…å‘kqueueä¸­æ·»åŠ æ–°çš„äº‹ä»¶ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œkevent()é€šè¿‡æ­¤å‚æ•°å¯¹kqueueçš„ä¿®æ”¹
nchanges     â€“ éœ€è¦ä¿®æ”¹çš„äº‹ä»¶çš„ä¸ªæ•°
events         â€“ kevent()ä¼šæŠŠæ‰€æœ‰äº‹ä»¶å­˜å‚¨åœ¨eventsä¸­
nevents       â€“ kevent()éœ€è¦çŸ¥é“å­˜å‚¨ç©ºé—´æœ‰å¤šå¤§, == 0 : kevent()ä¼šç«‹å³è¿”å›
timeout        â€“ è¶…æ—¶æ§åˆ¶, = NULL:kevent()ä¼šä¸€ç›´ç­‰åˆ°æœ‰å…³æ³¨çš„äº‹ä»¶å‘ç”Ÿ; != NULL:kevent()ä¼šç­‰å¾…æŒ‡å®šçš„æ—¶é—´
 ===
æœ‰å‡ ç‚¹éœ€è¦è¯´æ˜çš„æ˜¯ ï¼š
1) æŒ‡å®šEV_ADD|EV_ONESHOTæˆ–è€…EV_DELETE|EV_ONESHOTçš„è¡Œä¸º, kevent()è¿”å›å, ä¼šæŠŠäº‹ä»¶ä»kqueueä¸­åˆ é™¤;
2) å½“äº‹ä»¶ç±»å‹æŒ‡å®šä¸ºEVFILT_SIGNALçš„æ—¶å€™, struct event ä¸­dataä¼šè¿”å›æ­¤æ—¶ä¿¡å·å‘ç”Ÿäº†å¤šå°‘æ¬¡
3) å¦‚æœ nevents == 0, kevent()ä¼šç«‹å³è¿”å›, ä¸ä¼šç†ä¼štimeoutæŒ‡å®šçš„è¶…æ—¶æ—¶é—´, è¿™æ˜¯ä¸€ç§ç›´æ¥æ³¨å†Œäº‹ä»¶çš„æ–¹æ³•.</li>
</ol>

<p>å¸¸è§çš„I/Oæ¨¡å‹ï¼š
blocking I/O
nonblocking I/O
I/O multiplexing (select and poll)
signal driven I/O (SIGIO)
asynchronous I/O (the POSIX aio_functions)â€”â€”â€”â€”â€”å¼‚æ­¥IOæ¨¡å‹æœ€å¤§çš„ç‰¹ç‚¹æ˜¯ å®Œæˆåå‘å›é€šçŸ¥ã€‚</p>

<p>é˜»å¡ä¸å¦ï¼Œå–å†³äºå®ç°IOäº¤æ¢çš„æ–¹å¼ã€‚
  å¼‚æ­¥é˜»å¡æ˜¯åŸºäºselectï¼Œselectå‡½æ•°æœ¬èº«çš„å®ç°æ–¹å¼æ˜¯é˜»å¡çš„ï¼Œè€Œé‡‡ç”¨selectå‡½æ•°æœ‰ä¸ªå¥½å¤„å°±æ˜¯å®ƒå¯ä»¥åŒæ—¶ç›‘å¬å¤šä¸ªæ–‡ä»¶å¥æŸ„.
  å¼‚æ­¥éé˜»å¡ç›´æ¥åœ¨å®Œæˆåé€šçŸ¥ï¼Œç”¨æˆ·è¿›ç¨‹åªéœ€è¦å‘èµ·ä¸€ä¸ªIOæ“ä½œç„¶åç«‹å³è¿”å›ï¼Œç­‰IOæ“ä½œçœŸæ­£çš„å®Œæˆä»¥åï¼Œåº”ç”¨ç¨‹åºä¼šå¾—åˆ°IOæ“ä½œå®Œæˆçš„é€šçŸ¥ï¼Œæ­¤æ—¶ç”¨æˆ·è¿›ç¨‹åªéœ€è¦å¯¹æ•°æ®è¿›è¡Œå¤„ç†å°±å¥½äº†ï¼Œä¸éœ€è¦è¿›è¡Œå®é™…çš„IOè¯»å†™æ“ä½œï¼Œå› ä¸ºçœŸæ­£çš„IOè¯»å–æˆ–è€…å†™å…¥æ“ä½œå·²ç»ç”±å†…æ ¸å®Œæˆäº†ã€‚</p>

<p>selectå’Œiocpåˆ†åˆ«å¯¹åº”ç¬¬3ç§ä¸ç¬¬5ç§æ¨¡å‹ï¼Œé‚£ä¹ˆepollä¸kqueueå‘¢ï¼Ÿå…¶å®ä¹Ÿäºselectå±äºåŒä¸€ç§æ¨¡å‹ï¼Œåªæ˜¯æ›´é«˜çº§ä¸€äº›ï¼Œå¯ä»¥çœ‹ä½œæœ‰äº†ç¬¬4ç§æ¨¡å‹çš„æŸäº›ç‰¹æ€§ï¼Œå¦‚callbackæœºåˆ¶ã€‚</p>

<p>ä¸ºä»€ä¹ˆepoll,kqueueæ¯”selecté«˜çº§ï¼Ÿ 
ç­”æ¡ˆæ˜¯ï¼Œä»–ä»¬æ— è½®è¯¢ã€‚å› ä¸ºä»–ä»¬ç”¨callbackå–ä»£äº†ã€‚æƒ³æƒ³çœ‹ï¼Œå½“å¥—æ¥å­—æ¯”è¾ƒå¤šçš„æ—¶å€™ï¼Œæ¯æ¬¡select()éƒ½è¦é€šè¿‡éå†FD_SETSIZEä¸ªSocketæ¥å®Œæˆè°ƒåº¦,ä¸ç®¡å“ªä¸ªSocketæ˜¯æ´»è·ƒçš„,éƒ½éå†ä¸€éã€‚è¿™ä¼šæµªè´¹å¾ˆå¤šCPUæ—¶é—´ã€‚å¦‚æœèƒ½ç»™å¥—æ¥å­—æ³¨å†ŒæŸä¸ªå›è°ƒå‡½æ•°ï¼Œå½“ä»–ä»¬æ´»è·ƒæ—¶ï¼Œè‡ªåŠ¨å®Œæˆç›¸å…³æ“ä½œï¼Œé‚£å°±é¿å…äº†è½®è¯¢ï¼Œè¿™æ­£æ˜¯epollä¸kqueueåšçš„ã€‚</p>

<p>windows or *nix ï¼ˆIOCP or kqueue/epollï¼‰ï¼Ÿ
 è¯šç„¶ï¼ŒWindowsçš„IOCPéå¸¸å‡ºè‰²ï¼Œç›®å‰å¾ˆå°‘æœ‰æ”¯æŒasynchronous I/Oçš„ç³»ç»Ÿï¼Œä½†æ˜¯ç”±äºå…¶ç³»ç»Ÿæœ¬èº«çš„å±€é™æ€§ï¼Œå¤§å‹æœåŠ¡å™¨è¿˜æ˜¯åœ¨UNIXä¸‹ã€‚è€Œä¸”æ­£å¦‚ä¸Šé¢æ‰€è¿°ï¼Œkqueue/epoll ä¸ IOCPç›¸æ¯”ï¼Œå°±æ˜¯å¤šäº†ä¸€å±‚ä»å†…æ ¸copyæ•°æ®åˆ°åº”ç”¨å±‚çš„é˜»å¡ï¼Œä»è€Œä¸èƒ½ç®—ä½œasynchronous I/Oç±»ã€‚ä½†æ˜¯ï¼Œè¿™å±‚å°å°çš„é˜»å¡æ— è¶³è½»é‡ï¼Œkqueueä¸epollå·²ç»åšå¾—å¾ˆä¼˜ç§€äº†ã€‚
æä¾›ä¸€è‡´çš„æ¥å£ï¼ŒIO Design Patterns
å®é™…ä¸Šï¼Œä¸ç®¡æ˜¯å“ªç§æ¨¡å‹ï¼Œéƒ½å¯ä»¥æŠ½è±¡ä¸€å±‚å‡ºæ¥ï¼Œæä¾›ä¸€è‡´çš„æ¥å£ï¼Œå¹¿ä¸ºäººçŸ¥çš„æœ‰ACE,Libeventï¼ˆåŸºäºreactoræ¨¡å¼ï¼‰è¿™äº›ï¼Œä»–ä»¬éƒ½æ˜¯è·¨å¹³å°çš„ï¼Œè€Œä¸”ä»–ä»¬è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜çš„I/Oå¤ç”¨æœºåˆ¶ï¼Œç”¨æˆ·åªéœ€è°ƒç”¨æ¥å£å³å¯ã€‚è¯´åˆ°è¿™é‡Œåˆå¾—è¯´è¯´2ä¸ªè®¾è®¡æ¨¡å¼ï¼ŒReactor and Proactorã€‚è§ï¼šReactoræ¨¡å¼â€“VSâ€“Proactoræ¨¡å¼ã€‚Libeventæ˜¯Reactoræ¨¡å‹ï¼ŒACEæä¾›Proactoræ¨¡å‹ã€‚å®é™…éƒ½æ˜¯å¯¹å„ç§I/Oå¤ç”¨æœºåˆ¶çš„å°è£…ã€‚</p>

<p>åªæœ‰IOCPæ˜¯asynchronous I/Oï¼Œå…¶ä»–æœºåˆ¶æˆ–å¤šæˆ–å°‘éƒ½ä¼šæœ‰ä¸€ç‚¹é˜»å¡ã€‚
selectä½æ•ˆæ˜¯å› ä¸ºæ¯æ¬¡å®ƒéƒ½éœ€è¦è½®è¯¢ã€‚ä½†ä½æ•ˆä¹Ÿæ˜¯ç›¸å¯¹çš„ï¼Œè§†æƒ…å†µè€Œå®šï¼Œä¹Ÿå¯é€šè¿‡è‰¯å¥½çš„è®¾è®¡æ”¹å–„
epoll, kqueueã€selectæ˜¯Reacoræ¨¡å¼ï¼ŒIOCPæ˜¯Proactoræ¨¡å¼ã€‚</p>

:ET