I"¥<p>google profileå·¥å…·ä»¥åŠå…¶ä»–å¸¸ç”¨profileçš„å·¥å…·ï¼Œå¦‚GNU gprofã€oprofileç­‰(éƒ½æ˜¯å¼€æºé¡¹ç›®)ï¼Œå¹¶å¯¹å…¶å®ç°åŸç†åšäº†ç®€å•åˆ†æå’Œæ¯”è¾ƒã€‚
<!-- more -->
ä¸€ã€       GUN Gropf
       Gprofæ˜¯GNU profilerå·¥å…·ã€‚å¯ä»¥æ˜¾ç¤ºç¨‹åºè¿è¡Œçš„â€œflatprofileâ€ï¼ŒåŒ…æ‹¬æ¯ä¸ªå‡½æ•°çš„è°ƒç”¨æ¬¡æ•°ï¼Œæ¯ä¸ªå‡½æ•°æ¶ˆè€—çš„å¤„ç†å™¨æ—¶é—´ã€‚ä¹Ÿå¯ä»¥æ˜¾ç¤ºâ€œè°ƒç”¨å›¾â€ï¼ŒåŒ…æ‹¬ å‡½æ•°çš„è°ƒç”¨å…³ç³»ï¼Œæ¯ä¸ªå‡½æ•°è°ƒç”¨èŠ±è´¹äº†å¤šå°‘æ—¶é—´ã€‚è¿˜å¯ä»¥æ˜¾ç¤ºâ€œæ³¨é‡Šçš„æºä»£ç â€ï¼Œæ˜¯ç¨‹åºæºä»£ç çš„ä¸€ä¸ªå¤æœ¬ï¼Œæ ‡è®°æœ‰ç¨‹åºä¸­æ¯è¡Œä»£ç çš„æ‰§è¡Œæ¬¡æ•°ã€‚å…³äºGprofçš„ ä½¿ç”¨ä»¥åŠå®ç°åŸç†ç½‘ä¸Šå·²æœ‰å¤šç¯‡æ–‡ç« æåŠï¼Œæœ¬æ–‡å°±ä¸å†è¯¦è¿°ï¼Œåªæ˜¯å¯¹å…¶è¿›è¡Œæ¢³ç†å’Œæ€»ç»“ï¼Œæ–¹ä¾¿é˜…è¯»ã€‚ï¼ˆGprofçš„å®˜æ–¹ç½‘ å€ï¼šhttp://www.cs.utah.edu/dept/old/texinfo/as/gprof_toc.htmlï¼Œhttp: //sourceware.org/binutils/docs/gprof/index.html ç»å¯¹æƒå¨çš„å‚è€ƒèµ„æ–™ã€‚ï¼‰
1.1        å®‰è£…
       Glibcè‡ªå¸¦ï¼Œæ— éœ€å¦å¤–å®‰è£…</p>

<p>1.3        å®ç°åŸç†
     å¼•ç”¨å®˜ç½‘è¯´æ˜ï¼š</p>

<p>Profiling works by changing how every function in your program iscompiled so that when it is called, it will stash away some informationabout where it was called from. From this, the profiler can figure outwhat function called it, and can count how many times it was called.This change is made by the compiler when your program is compiled withthe `-pgâ€™ option.</p>

<p>Profiling also involves watching your program as it runs, andkeeping a histogram of where the program counter happens to be everynow and then. Typically the program counter is looked at around 100times per second of run time, but the exact frequency may vary fromsystem to system.</p>

<p>A special startup routine allocates memory for the histogram andsets up a clock signal handler to make entries in it. Use of thisspecial startup routine is one of the effects of using <code class="language-plaintext highlighter-rouge">gcc ... -pg' tolink. The startup file also includes an </code>exitâ€™ function which isresponsible for writing the file `gmon.outâ€™.</p>

<p>Number-of-calls information for library routines is collected byusing a special version of the C library. The programs in it are thesame as in the usual C library, but they were compiled with <code class="language-plaintext highlighter-rouge">-pg'. Ifyou link your program with </code>gcc â€¦ -pgâ€™, it automatically uses theprofiling version of the library.</p>

<p>The output from gprof gives no indication of parts of your programthat are limited by I/O or swapping bandwidth. This is because samplesof the program counter are taken at fixed intervals of run time.Therefore, the time measurements in gprof output say nothing about timethat your program was not running. For example, a part of the programthat creates so much data that it cannot all fit in physical memory atonce may run very slowly due to thrashing, but gprof will say it useslittle time. On the other hand, sampling by run time has the advantagethat the amount of load due to other users wonâ€™t directly affect theoutput you get.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> å½“æˆ‘ä»¬ä½¿ç”¨"-pg" é€‰é¡¹ç¼–è¯‘ç¨‹åºåï¼Œgccä¼šåšä¸‰ä¸ªå·¥ä½œï¼š

1. ç¨‹åºçš„å…¥å£å¤„(main å‡½æ•°ä¹‹å‰)æ’å…¥monstartupå‡½æ•°çš„è°ƒç”¨ä»£ç ï¼Œå®Œæˆprofileçš„åˆå§‹åŒ–å·¥ä½œï¼ŒåŒ…æ‹¬åˆ†é…ä¿å­˜ä¿¡æ¯çš„å†…å­˜ä»¥åŠè®¾ç½®ä¸€ä¸ªclock ä¿¡å·å¤„ç†å‡½æ•°ï¼›

2. åœ¨æ¯ä¸ªå‡½æ•°çš„å…¥å£å¤„æ’å…¥_mcountå‡½æ•°çš„è°ƒç”¨ä»£ç ï¼Œç”¨äºç»Ÿè®¡å‡½æ•°çš„è°ƒç”¨ä¿¡æ¯ï¼šåŒ…æ‹¬è°ƒç”¨æ—¶é—´ã€è°ƒç”¨æ¬¡æ•°ä»¥åŠè°ƒç”¨æ ˆä¿¡æ¯ï¼›
</code></pre></div></div>

<ol>
  <li>åœ¨ç¨‹åºé€€å‡ºæ—¶(åœ¨ atexit () é‡Œ)æ’å…¥_mcleanup()å‡½æ•°çš„è°ƒç”¨ä»£ç ï¼Œè´Ÿè´£å°†profileä¿¡æ¯è¾“å‡ºåˆ°gmon.outä¸­ã€‚</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>è¿™äº›è¿‡ç¨‹å¯ä»¥é€šè¿‡objdumpåæ±‡ç¼–æ˜¾ç¤ºå‡ºæ¥ï¼š

 objdump -S a.out

 0000000000400aba&lt;main&gt;:

400aba:      55                        push   %rbp

400abb:       48 89e5              mov    %rsp,%rbp

400abe:       48 83 ec20          sub   $0x20,%rsp

400ac2:       e8 69 fd ffff          callq  400830&lt;mcount@plt&gt;

 ......

 å¯ä»¥çœ‹å‡ºï¼Œåœ¨mainå‡½æ•°çš„å…¥å£æ’å…¥äº†ä¸€è¡Œæ±‡ç¼–ä»£ç ï¼šcallq  400830 &lt;mcount@plt&gt; ï¼Œè¿™æ ·mainå‡½æ•°çš„ç¬¬ä¸€è¡Œæ‰§è¡Œä»£ç å°±æ˜¯è°ƒç”¨_mcountå‡½æ•°ã€‚

 æˆ‘ä»¬æ¥ä¸‹æ¥å†çœ‹çœ‹glibcçš„è¿™ä¸‰ä¸ªå‡½æ•°å…·ä½“éƒ½åšäº†ä»€ä¹ˆï¼š

 

a ) __monstartup  æ­¤å‡½æ•°çš„å®šä¹‰åœ¨glibcçš„gmon/gmon.cä¸­
</code></pre></div></div>

<p>A special startup routine allocates memory for the histogram andeither calls profil() or sets up a clock signal handler. This routine(monstartup) can be invoked in several ways. On Linux systems, aspecial profiling startup file gcrt0.o, which invokes monstartup beforemain, is used instead of the default crt0.o. Use of this specialstartup file is one of the effects of using `gcc â€¦ -pgâ€™ to link. OnSPARC systems, no special startup files are used. Rather, the mcountroutine, when it is invoked for the first time (typically when main iscalled), calls monstartup.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> linuxç³»ç»Ÿä¸­ï¼Œ__monstartupæ˜¯åœ¨__gmon_start__ ä¸­è°ƒç”¨çš„ã€‚åœ¨ç¨‹åºé“¾æ¥è¿‡ç¨‹ä¸­ï¼Œgccç”¨gcrt0.oæ›¿ä»£äº†é»˜è®¤çš„crt0.oï¼Œä»è€Œä¿®æ”¹äº†mainå‡½æ•°æ‰§è¡Œå‰çš„åˆå§‹åŒ–å·¥ä½œï¼š
</code></pre></div></div>

<p>crt0.oæ˜¯åº”ç”¨ç¨‹åºç¼–è¯‘é“¾æ¥æ—¶éœ€è¦çš„èµ·åŠ¨æ–‡ä»¶ï¼Œåœ¨ç¨‹åºé“¾æ¥é˜¶æ®µè¢«é“¾æ¥ã€‚ä¸»è¦å·¥ä½œæ˜¯åˆè¯•åŒ–åº”ç”¨ç¨‹åºæ ˆï¼Œåˆè¯•åŒ–ç¨‹åºçš„è¿è¡Œç¯å¢ƒå’Œåœ¨ç¨‹åºé€€å‡ºæ—¶æ¸…é™¤å’Œé‡Šæ”¾èµ„æºã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> __gmon_start__çš„å®šä¹‰åœ¨csu/gmon-start.cä¸­
</code></pre></div></div>

<p>void</p>

<p><strong>gmon_start</strong> (void)</p>

<p>{</p>

<p>#ifdef HAVE_INITFINI</p>

<p>/* Protect from being called more than once.  Since crti.o is linked</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> into every shared library, each of their init functions will call us.  */
</code></pre></div></div>

<p>static int called;</p>

<p>if (called)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return;
</code></pre></div></div>

<p>called = 1;</p>

<p>#endif</p>

<p>/* Start keeping profiling records.  */</p>

<p>__monstartup ((u_long) TEXT_START, (u_long) &amp;etext);</p>

<p>/* Call _mcleanup before exiting; it will write out gmon.out from the</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> collected data.  */
</code></pre></div></div>

<p>atexit (&amp;_mcleanup);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__gmon_start__ ä¸ä»…è°ƒç”¨äº†__monstartupå‡½æ•°ï¼Œè¿˜æ³¨å†Œäº†ä¸€ä¸ªæ¸…ç†å‡½æ•°_mcleanupï¼Œæ­¤å‡½æ•°å°†åœ¨ç¨‹åºç»“æŸæ—¶è¢«è°ƒç”¨ã€‚_mcleanupçš„åŠŸèƒ½ä¼šåœ¨åç»­è¯´æ˜ï¼Œæ¥ä¸‹æ¥è®©æˆ‘ä»¬çœ‹çœ‹__monstartupå‡½æ•°éƒ½åšäº†ä»€ä¹ˆã€‚
</code></pre></div></div>

<p>void</p>

<p>__monstartup (lowpc, highpc)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> u_long lowpc;

 u_long highpc;
</code></pre></div></div>

<p>{</p>

<p>register int o;</p>

<p>char *cp;</p>

<p>struct gmonparam *p = &amp;_gmonparam;</p>

<p>/*</p>

<ul>
  <li>
    <p>round lowpc and highpc to multiples of the density weâ€™re using</p>
  </li>
  <li>
    <p>so the rest of the scaling (here and in gprof) stays in ints.</p>
  </li>
</ul>

<p>*/</p>

<p>p-&gt;lowpc = ROUNDDOWN(lowpc, HISTFRACTION * sizeof(HISTCOUNTER));</p>

<p>p-&gt;highpc = ROUNDUP(highpc, HISTFRACTION * sizeof(HISTCOUNTER));</p>

<p>p-&gt;textsize = p-&gt;highpc - p-&gt;lowpc;</p>

<p>p-&gt;kcountsize = ROUNDUP(p-&gt;textsize / HISTFRACTION, sizeof(*p-&gt;froms));</p>

<p>p-&gt;hashfraction = HASHFRACTION;</p>

<p>p-&gt;log_hashfraction = -1;</p>

<p>/* The following test must be kept in sync with the corresponding</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> test in mcount.c.  */
</code></pre></div></div>

<p>if ((HASHFRACTION &amp; (HASHFRACTION - 1)) == 0) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  /* if HASHFRACTION is a power of two, mcount can use shifting

 instead of integer division.  Precompute shift amount. */

  p-&gt;log_hashfraction = ffs(p-&gt;hashfraction * sizeof(*p-&gt;froms)) - 1;
</code></pre></div></div>

<p>}</p>

<p>p-&gt;fromssize = p-&gt;textsize / HASHFRACTION;</p>

<p>p-&gt;tolimit = p-&gt;textsize * ARCDENSITY / 100;</p>

<p>if (p-&gt;tolimit &lt; MINARCS)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p-&gt;tolimit = MINARCS;
</code></pre></div></div>

<p>else if (p-&gt;tolimit &gt; MAXARCS)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p-&gt;tolimit = MAXARCS;
</code></pre></div></div>

<p>p-&gt;tossize = p-&gt;tolimit * sizeof(struct tostruct);</p>

<p>cp = calloc (p-&gt;kcountsize + p-&gt;fromssize + p-&gt;tossize, 1);</p>

<p>if (! cp)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{

  ERR("monstartup: out of memory\n");

  p-&gt;tos = NULL;

  p-&gt;state = GMON_PROF_ERROR;

  return;

}
</code></pre></div></div>

<p>p-&gt;tos = (struct tostruct *)cp;</p>

<p>cp += p-&gt;tossize;</p>

<p>p-&gt;kcount = (HISTCOUNTER *)cp;</p>

<p>cp += p-&gt;kcountsize;</p>

<p>p-&gt;froms = (ARCINDEX *)cp;</p>

<p>p-&gt;tos[0].link = 0;</p>

<p>o = p-&gt;highpc - p-&gt;lowpc;</p>

<p>if (p-&gt;kcountsize &lt; (u_long) o)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
</code></pre></div></div>

<p>#ifndef hp300</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  s_scale = ((float)p-&gt;kcountsize / o ) * SCALE_1_TO_1;
</code></pre></div></div>

<p>#else</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  /* avoid floating point operations */

  int quot = o / p-&gt;kcountsize;

 

  if (quot &gt;= 0x10000)

s_scale = 1;

  else if (quot &gt;= 0x100)

s_scale = 0x10000 / quot;

  else if (o &gt;= 0x800000)

s_scale = 0x1000000 / (o / (p-&gt;kcountsize &gt;&gt; 8));

  else

s_scale = 0x1000000 / ((o &lt;&lt; 8) / p-&gt;kcountsize);
</code></pre></div></div>

<p>#endif</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>} else

  s_scale = SCALE_1_TO_1;
</code></pre></div></div>

<p>__moncontrol(1);</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>å¯ä»¥çœ‹ä¹¦ï¼Œå‡½æ•°ä¸­çš„å¤§éƒ¨åˆ†ä»£ç éƒ½æ˜¯åœ¨åšåˆå§‹åŒ–å·¥ä½œï¼Œä¸ºprofileä¿¡æ¯åˆ†é…å­˜å‚¨ç©ºé—´ï¼Œå®ƒçš„ä¸¤ä¸ªå‚æ•°lowpcï¼Œhighpcï¼ˆé€šè¿‡è°ƒè¯•å¯ä»¥å¾—çŸ¥lowpcèµ·å§‹æ˜¯ç¨‹åºä»£ç æ®µçš„èµ·å§‹åœ°å€ï¼Œè€Œhighpcæ˜¯ç¨‹åºä»£ç æ®µçš„ç»“æŸåœ°å€ï¼Œ&amp;etextï¼‰ï¼Œåˆ†åˆ«ä»£è¡¨äº†éœ€è¦è®°å½•profileä¿¡æ¯çš„åœ°å€èŒƒå›´ï¼Œè¶…è¿‡è¿™ä¸ªèŒƒå›´çš„åœ°å€ï¼Œgprofæ˜¯ä¸ä¼šè®°å½•profileä¿¡æ¯çš„ã€‚è¿™ä¹Ÿè§£é‡Šäº†ä¸ºä½•gprofä¸èƒ½æ”¯æŒå¯¹åŠ¨æ€åº“çš„è§£æï¼Œä»¥ä¸ºåŠ¨æ€åº“çš„è£…è½½æ˜¯åœ¨ç¨‹åºä»£ç æ®µä¹‹å¤–çš„ã€‚æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªå®ä¾‹å¯ä»¥è¯æ˜è¿™ä¸€ç‚¹ã€‚

 ä»¥ä¸€ä¸ªç®€å•çš„æµ‹è¯•ç¨‹åºä¸ºä¾‹ï¼š
</code></pre></div></div>

<p>#include <stdio.h></stdio.h></p>

<p>int or_f(int a,int b)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return a^b;
</code></pre></div></div>

<p>}</p>

<p>int main(int argc,char** argv)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printf("%d\n",or_f(1,2));

sleep(30);

return 1;
</code></pre></div></div>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ç¼–è¯‘ç”Ÿæˆ./testå¯æ‰§è¡Œç¨‹åºã€‚æˆ‘ä»¬ç”¨readelfå·¥å…·è·å–testæ–‡ä»¶çš„æ®µä¿¡æ¯ï¼Œ

 readelf -S test
</code></pre></div></div>

<p>Section Headers:</p>

<p>[Nr] Name              Type             Address           Offset</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Size              EntSize          Flags  Link  Info  Align
</code></pre></div></div>

<p>â€¦â€¦</p>

<p>[12] .text             PROGBITS         0000000000400540  00000540</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   0000000000000278  0000000000000000  AX       0     0     16
</code></pre></div></div>

<p>â€¦â€¦.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ä»è¾“å‡ºå¯ä»¥çœ‹å‡ºï¼Œtestå¯æ‰§è¡Œç¨‹åºçš„textä»£ç åœ°å€ä¸º0x400540 ~ 0x400540 + 0x278ã€‚

 æ¥ä¸‹æ¥è¿è¡Œ./test ï¼Œé€šè¿‡å¯¹glibcä»£ç çš„ä¿®æ”¹ï¼Œæˆ‘ä»¬æ‰“å°å‡º__monstartupå‡½æ•°çš„ä¸¤ä¸ªå®å‚å€¼ï¼Œç»“æœå¦‚ä¸‹ï¼š

 lowpc: 400540, highpc: 4007c6ï¼Œæ­£å¥½å¯¹åº”ç€testç¨‹åºçš„ä»£ç æ®µèŒƒå›´ã€‚

 åŒæ—¶æˆ‘ä»¬ä¹Ÿdumpå‡ºtestç¨‹åº¦åœ¨å†…å­˜ä¸­çš„è£…è½½åœ°å€ï¼š

 cat /proc/$self/maps:
</code></pre></div></div>

<p>00400000-00401000 r-xp 00000000 08:03 70746688                           /tmp/test</p>

<p>00600000-00601000 rw-p 00000000 08:03 70746688                           /tmp/test</p>

<p>10ca4000-10cc5000 rw-p 10ca4000 00:00 0                                  [heap]</p>

<p>3536600000-353661c000 r-xp 00000000 08:03 93028660                       /lib64/ld-2.5.so</p>

<p>353681b000-353681c000 râ€“p 0001b000 08:03 93028660                       /lib64/ld-2.5.so</p>

<p>353681c000-353681d000 rw-p 0001c000 08:03 93028660                       /lib64/ld-2.5.so</p>

<p>2b4f1af23000-2b4f1af25000 rw-p 2b4f1af23000 00:00 0</p>

<p>2b4f1af25000-2b4f1b063000 r-xp 00000000 08:03 32931849       /root/glibc-2.5-42-build/lib/libc-2.5.so</p>

<p>2b4f1b063000-2b4f1b263000 â€”p 0013e000 08:03 32931849      /root/glibc-2.5-42-build/lib/libc-2.5.so</p>

<p>2b4f1b263000-2b4f1b267000 râ€“p 0013e000 08:03 32931849      /root/glibc-2.5-42-build/lib/libc-2.5.so</p>

<p>2b4f1b267000-2b4f1b268000 rw-p 00142000 08:03 32931849     /root/glibc-2.5-42-build/lib/libc-2.5.so</p>

<p>2b4f1b268000-2b4f1b26f000 rw-p 2b4f1b268000 00:00 0</p>

<p>7fffa306b000-7fffa3080000 rw-p 7ffffffea000 00:00 0                      [stack]</p>

<p>ffffffffff600000-ffffffffffe00000 â€”p 00000000 00:00 0                  [vdso]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> testè£…è½½åˆ°å†…å­˜çš„åœ°å€èŒƒå›´ä¸º00400000-00401000ï¼Œä¸ºlibc.soè£…è½½åˆ°å†…å­˜çš„åœ°å€èŒƒå›´ä¸º2b4f1af25000-2b4f1b063000ï¼Œç°åœ¨ä¸åœ¨lowpcå’ŒhighpcèŒƒå›´ä¹‹å†…ï¼Œæ‰€ä»¥libcä¸­çš„å‡½æ•°æ˜¯ä¸ä¼šè¢«gprofè§£æçš„ã€‚

 __monstartupå‡½æ•°çš„æœ€åä¼šè°ƒç”¨__moncontrolå‡½æ•°æ¥è®¾ç½®ä¸€ä¸ªclockä¿¡å·å¤„ç†å‡½æ•°ç”¨äºè®¾ç½®æå–sampleã€‚

__moncontrolçš„å®šä¹‰åœ¨glibcçš„gmon/gmon.cä¸­
</code></pre></div></div>

<p>void</p>

<p>__moncontrol (mode)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> int mode;
</code></pre></div></div>

<p>{</p>

<p>struct gmonparam *p = &amp;_gmonparam;</p>

<p>/* Donâ€™t change the state if we ran into an error.  */</p>

<p>if (p-&gt;state == GMON_PROF_ERROR)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return;
</code></pre></div></div>

<p>if (mode)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{

  /* start */

  __profil((void *) p-&gt;kcount, p-&gt;kcountsize, p-&gt;lowpc, s_scale);

  p-&gt;state = GMON_PROF_ON;

}
</code></pre></div></div>

<p>else</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{

  /* stop */

  __profil(NULL, 0, 0, 0);

  p-&gt;state = GMON_PROF_OFF;

}
</code></pre></div></div>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> å…¶ä¸­__profilçš„å®šä¹‰åœ¨sysdeps/posix/profil.cä¸­
</code></pre></div></div>

<p>int</p>

<p>__profil (u_short *sample_buffer, size_t size, size_t offset, u_int scale)</p>

<p>{</p>

<p>struct sigaction act;</p>

<p>struct itimerval timer;</p>

<p>#ifndef IS_IN_rtld</p>

<p>static struct sigaction oact;</p>

<p>static struct itimerval otimer;</p>

<h1 id="define-oact_ptr-oact">define oact_ptr &amp;oact</h1>

<h1 id="define-otimer_ptr-otimer">define otimer_ptr &amp;otimer</h1>

<p>if (sample_buffer == NULL)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{

  /* Disable profiling.  */

  if (samples == NULL)

/* Wasn't turned on.  */

return 0;

 

  if (__setitimer (ITIMER_PROF, &amp;otimer, NULL) &lt; 0)

return -1;

  samples = NULL;

  return __sigaction (SIGPROF, &amp;oact, NULL);

}
</code></pre></div></div>

<p>if (samples)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{

  /* Was already turned on.  Restore old timer and signal handler

 first.  */

  if (__setitimer (ITIMER_PROF, &amp;otimer, NULL) &lt; 0

  || __sigaction (SIGPROF, &amp;oact, NULL) &lt; 0)

return -1;

}
</code></pre></div></div>

<p>#else</p>

<p>/* In ld.so profiling should never be disabled once it runs.  */</p>

<p>//assert (sample_buffer != NULL);</p>

<h1 id="define-oact_ptr-null">define oact_ptr NULL</h1>

<h1 id="define-otimer_ptr-null">define otimer_ptr NULL</h1>

<p>#endif</p>

<p>samples = sample_buffer;</p>

<p>nsamples = size / sizeof *samples;</p>

<p>pc_offset = offset;</p>

<p>pc_scale = scale;</p>

<p>act.sa_handler = (sighandler_t) &amp;profil_counter;</p>

<p>act.sa_flags = SA_RESTART;</p>

<p>__sigfillset (&amp;act.sa_mask);</p>

<p>if (__sigaction (SIGPROF, &amp;act, oact_ptr) &lt; 0)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return -1;
</code></pre></div></div>

<p>timer.it_value.tv_sec = 0;</p>

<p>timer.it_value.tv_usec = 1000000 / __profile_frequency ();</p>

<p>timer.it_interval = timer.it_value;</p>

<p>return __setitimer (ITIMER_PROF, &amp;timer, otimer_ptr);</p>

<p>}</p>

<p>è¿™ä¸ªå‡½æ•°çš„ä¸»è¦ä½œç”¨å°±æ˜¯å®šä¹‰äº†ä¸€ä¸ªSIGPROFä¿¡å·å¤„ç†å‡½æ•°ï¼Œå¹¶é€šè¿‡__setitimerå‡½æ•°è®¾ç½®SIGPROFçš„å‘é€é¢‘ç‡ã€‚è¿™ä¸ªä¿¡å·å¤„ç†å‡½æ•°çš„åŠŸèƒ½å¾ˆå…³é”®ï¼Œåç»­ä»ä¼šè¯´æ˜ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bï¼‰_mcount  æ­¤å‡½æ•°çš„å®šä¹‰åœ¨sysdeps/generic/machine-gmon.hä¸­
</code></pre></div></div>

<p>#define MCOUNT \</p>

<p>void _mcount (void)                                  \</p>

<p>{                                          \</p>

<p>mcount_internal ((u_long) RETURN_ADDRESS (1), (u_long) RETURN_ADDRESS (0)); \</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> å…¶ä¸­((u_long) RETURN_ADDRESS (nr)è°ƒç”¨äº†__builtin_return_address(nr)å‡½æ•°ï¼Œ__builtin_return_address(nr)ä¼šè¿”å›å½“å‰è°ƒ ç”¨æ ˆä¸­ç¬¬nrå¸§çš„pcåœ°å€ã€‚æ‰€ä»¥(u_long)RETURN_ADDRESS (0)è¿”å›çš„æ˜¯å½“å‰å‡½æ•°åœ°å€topcï¼›è€Œ(u_long) RETURN_ADDRESS(1)è¿”å›çš„æ˜¯å½“å‰å‡½æ•°çš„è¿”å›åœ°å€frompcã€‚
</code></pre></div></div>

<p>__builtin_return_address(LEVEL)</p>

<p>â€”This function returns the return address of the currentfunction,or of one of its callers. The LEVEL argument is number offrames to scan up the call stack. A value of â€˜0â€™ yields the returnaddress of the current function,a value of â€˜1â€™ yields the returnaddress of the caller of the current function,and so forth.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mcount_internalçš„å®šä¹‰åœ¨gmon/mcont.cä¸­
</code></pre></div></div>

<p>_MCOUNT_DECL(frompc, selfpc)    /* _mcount; may be static, inline, etc */</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>register ARCINDEX *frompcindex;

register struct tostruct *top, *prevtop;

register struct gmonparam *p;

register ARCINDEX toindex;

int i;

 

p = &amp;_gmonparam;

/*

 * check that we are profiling

 * and that we aren't recursively invoked.

 */

if (catomic_compare_and_exchange_bool_acq (&amp;p-&gt;state, GMON_PROF_BUSY,

                       GMON_PROF_ON))

  return;

 

/*

 * check that frompcindex is a reasonable pc value.

 * for example:    signal catchers get called from the stack,

 *        not from text space.  too bad.

 */

frompc -= p-&gt;lowpc;

if (frompc &gt; p-&gt;textsize)

    goto done;

 

/* The following test used to be

    if (p-&gt;log_hashfraction &gt;= 0)

   But we can simplify this if we assume the profiling data

   is always initialized by the functions in gmon.c.  But

   then it is possible to avoid a runtime check and use the

   smae `if' as in gmon.c.  So keep these tests in sync.  */

if ((HASHFRACTION &amp; (HASHFRACTION - 1)) == 0) {

  /* avoid integer divide if possible: */

    i = frompc &gt;&gt; p-&gt;log_hashfraction;

} else {

    i = frompc / (p-&gt;hashfraction * sizeof(*p-&gt;froms));

}

frompcindex = &amp;p-&gt;froms[i];

toindex = *frompcindex;

if (toindex == 0) {

    /*

     *    first time traversing this arc

     */

    toindex = ++p-&gt;tos[0].link;

    if (toindex &gt;= p-&gt;tolimit)

        /* halt further profiling */

        goto overflow;

 

    *frompcindex = toindex;

    top = &amp;p-&gt;tos[toindex];

    top-&gt;selfpc = selfpc;

    top-&gt;count = 1;

    top-&gt;link = 0;

    goto done;

}

top = &amp;p-&gt;tos[toindex];

if (top-&gt;selfpc == selfpc) {

    /*

     * arc at front of chain; usual case.

     */

    top-&gt;count++;

    goto done;

}

/*

 * have to go looking down chain for it.

 * top points to what we are looking at,

 * prevtop points to previous top.

 * we know it is not at the head of the chain.

 */

for (; /* goto done */; ) {

    if (top-&gt;link == 0) {

        /*

         * top is end of the chain and none of the chain

         * had top-&gt;selfpc == selfpc.

         * so we allocate a new tostruct

         * and link it to the head of the chain.

         */

        toindex = ++p-&gt;tos[0].link;

        if (toindex &gt;= p-&gt;tolimit)

            goto overflow;

 

        top = &amp;p-&gt;tos[toindex];

        top-&gt;selfpc = selfpc;

        top-&gt;count = 1;

        top-&gt;link = *frompcindex;

        *frompcindex = toindex;

        goto done;

    }

    /*

     * otherwise, check the next arc on the chain.

     */

    prevtop = top;

    top = &amp;p-&gt;tos[top-&gt;link];

    if (top-&gt;selfpc == selfpc) {

        /*

         * there it is.

         * increment its count

         * move it to the head of the chain.

         */

        top-&gt;count++;

        toindex = prevtop-&gt;link;

        prevtop-&gt;link = top-&gt;link;

        top-&gt;link = *frompcindex;

        *frompcindex = toindex;

        goto done;

    }

 

}
</code></pre></div></div>

<p>done:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p-&gt;state = GMON_PROF_ON;

return;
</code></pre></div></div>

<p>overflow:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p-&gt;state = GMON_PROF_ERROR;

return;
</code></pre></div></div>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>æ­¤å‡½æ•°çš„ä¸»è¦åŠŸèƒ½å°±æ˜¯è®°å½•æ¯ä¸ªå‡½æ•°çš„è°ƒç”¨æ¬¡æ•°ï¼Œä»¥åŠå‡½æ•°ä¹‹é—´çš„è°ƒç”¨å…³ç³»è¡¨ã€‚å¹¶å°†è¿™äº›ä¿¡æ¯ä¿å­˜åœ¨å…¨å±€å˜é‡_gmonparamä¸­ã€‚ç”±äºæ­¤å‡½æ•°æ˜¯é€šè¿‡hackçš„æ–¹å¼æ¥è°ƒç”¨çš„ï¼ˆæ’å…¥å…¥å£ä»£ç ï¼‰ï¼Œå› æ­¤å…¶è·å–çš„ä¿¡æ¯éƒ½æ˜¯ç²¾ç¡®çš„ã€‚å¼ºè°ƒzè¿™ä¸€ç‚¹çš„ç›®çš„æ˜¯ä¸ºäº†ä¸‹é¢å°†è¦ä»‹ç»çš„å¦ä¸€ä¸ªä¸»è¦å‡½æ•°: profil_counter ã€‚å› æº¯åˆ°gccçš„ä¸€ä¸ªæ­¥éª¤ï¼Œmonstartupå‡½æ•°åœ¨åˆå§‹åŒ–çš„æœ€åé˜¶æ®µï¼Œé€šè¿‡sigactionè°ƒç”¨æ³¨å†Œäº†ä¸€ä¸ªSIGPROFä¿¡å·å¤„ç†å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•° profil_counterã€‚è¿™ä¸ªå‡½æ•°ä¼šä»¥__profile_frequency()çš„é¢‘ç‡è¢«è°ƒç”¨ï¼Œå¹¶å®Œæˆprofileçš„ä¸»è¦å·¥ä½œï¼šæ”¶é›† sampleä¿¡æ¯ï¼Œä»¥æ­¤æ¥è®¡ç®—æ¯ä¸ªå‡½æ•°çš„æ¶ˆè€—æ—¶é—´ã€‚

profil_counterå‡½æ•°çš„å®šä¹‰ä¾èµ–äºå…·ä½“çš„ç³»ç»Ÿå¹³å°ï¼ŒX86_64å¹³å°ä¸‹çš„å®šä¹‰æ˜¯åœ¨sysdeps/unix/sysv/linux/x86_64/profil-counter.hä¸­
</code></pre></div></div>

<p>static void</p>

<p>profil_counter (int signo, SIGCONTEXT scp)</p>

<p>{</p>

<p>profil_count ((void *) GET_PC (scp));</p>

<p>/* This is a hack to prevent the compiler from implementing the</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> above function call as a sibcall.  The sibcall would overwrite

 the signal context.  */
</code></pre></div></div>

<p>asm volatile (â€œâ€);</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>å…¶æœ€ç»ˆè°ƒç”¨çš„profil_countå®šä¹‰åœ¨sysdeps/posix/profil.cä¸­
</code></pre></div></div>

<p>static inline void</p>

<p>profil_count (void *pc)</p>

<p>{</p>

<p>size_t i = (pc - pc_offset - (void *) 0) / 2;</p>

<p>if (sizeof (unsigned long long int) &gt; sizeof (size_t))</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i = (unsigned long long int) i * pc_scale / 65536;
</code></pre></div></div>

<p>else</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i = i / 65536 * pc_scale + i % 65536 * pc_scale / 65536;
</code></pre></div></div>

<p>if (i &lt; nsamples)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>++samples[i];
</code></pre></div></div>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> è¿™æ®µä»£ç çš„é€»è¾‘æœ‰ç‚¹æ™¦æ¶©ï¼Œéœ€è¦è”ç³»ä¹‹å‰çš„å¤„ç†é€»è¾‘æ¥ç†è§£ã€‚pc_offsetã€pc_scaleä»¥åŠsamplesè¿™äº› å…¨å±€å˜é‡çš„èµ‹å€¼æ˜¯åœ¨__profilå‡½æ•°ä¸­å¤„ç†çš„ã€‚å›æº¯__profilçš„é€»è¾‘ä»£ç ï¼Œå°±å¯ä»¥çœ‹å‡ºsamples=_gmonparam-&gt; kcount, ç”¨äºä¿å­˜sampleä¿¡æ¯ï¼Œpc_offset =p-&gt;lowpcï¼Œæ˜¯ç¨‹åºä»£ç æ®µçš„èµ·å§‹åœ°å€ï¼Œpc_scaleæ˜¯ä¸€ä¸ªæ¯”ä¾‹å› å­ï¼Œç”¨äºæ§åˆ¶sampleçš„æå–ç²’åº¦ã€‚ç»¼åˆä¸Šä¸‹æ–‡ï¼Œgprofåœ¨è¿™é‡Œçš„ å¤„ç†é€»è¾‘æ˜¯å°†lowpc~lowpc+65536ï¼ˆlinuxä¸‹é»˜è®¤ä¸€ä¸ªæ®µçš„å¤§å°ä¸º64Kï¼‰èŒƒå›´å†…çš„ä»£ç æ˜ å°„åˆ°ä¸€ä¸ªå†…å­˜æ•°ç»„ï¼Œè€Œpc_scaleå…¶å®å°±æ˜¯ å†³å®šäº†æ˜ å°„ç²’åº¦ã€‚å¯¹äºä»»ä½•ä¸€ä¸ªå¤„äº[lowpc,lowpc+65536]èŒƒå›´å†…çš„pcï¼Œå…¶å¯¹åº”çš„æ•°ç»„ä¸‹æ ‡æ˜¯: pc - lowpc / (65536/ pc_scale)  = (pc - lowpc) * pc_scale /65536;è¿™æ ·ä¸€ä¸ªæ•°ç»„é¡¹ï¼ˆä¸€ä¸ªsampleï¼‰å¯¹åº”äº†ä¸€æ®µpc_scaleé•¿åº¦çš„ç¨‹åºåœ°å€ï¼Œè€Œæ¯å½“è¿™æ®µåœ°å€å†…çš„ä»£ç è¢«æ‰§è¡Œæ—¶ï¼Œç›¸åº”çš„sampleè®¡æ•° å°±ä¼šåŠ 1ã€‚
</code></pre></div></div>

<p>c ) æœ€åå½“ç¨‹åºç»“æŸæ—¶ï¼Œä¼šè°ƒç”¨_mcleanupï¼Œå…¶å®šä¹‰åœ¨gmon/gmon.cä¸­ã€‚</p>

<p>void</p>

<p>_mcleanup (void)</p>

<p>{</p>

<p>__moncontrol (0);</p>

<p>if (_gmonparam.state != GMON_PROF_ERROR)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>write_gmon ();
</code></pre></div></div>

<p>/* free the memory. */</p>

<p>free (_gmonparam.tos);</p>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>é¦–å…ˆå…¶é€šè¿‡__moncontrolï¼ˆ0ï¼‰ç»“æŸprofilå·¥ä½œï¼Œå…¶æ¬¡é€šè¿‡write_gmon ()å‡½æ•°å°†profileä¿¡æ¯è¾“å‡ºåˆ°gmon.outæ–‡ä»¶ä¸­ã€‚

write_gmoå‡½æ•°çš„å®šä¹‰åœ¨gmon/gmon.cä¸­
</code></pre></div></div>

<p>static void</p>

<p>write_gmon (void)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct gmon_hdr ghdr __attribute__ ((aligned (__alignof__ (int))));

int fd = -1;

char *env;
</code></pre></div></div>

<p>#ifndef O_NOFOLLOW</p>

<h1 id="define-o_nofollow----0">define O_NOFOLLOW    0</h1>

<p>#endif</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>env = getenv ("GMON_OUT_PREFIX");

if (env != NULL &amp;&amp; !__libc_enable_secure)

  {

size_t len = strlen (env);

char buf[len + 20];

__snprintf (buf, sizeof (buf), "%s.%u", env, __getpid ());

fd = open_not_cancel (buf, O_CREAT|O_TRUNC|O_WRONLY|O_NOFOLLOW, 0666);

  }

 

if (fd == -1)

  {

fd = open_not_cancel ("gmon.out", O_CREAT|O_TRUNC|O_WRONLY|O_NOFOLLOW,

              0666);

if (fd &lt; 0)

  {

    char buf[300];

    int errnum = errno;

    __fxprintf (NULL, "_mcleanup: gmon.out: %s\n",

        __strerror_r (errnum, buf, sizeof buf));

    return;

  }

  }

 

/* write gmon.out header: */

memset (&amp;ghdr, '\0', sizeof (struct gmon_hdr));

memcpy (&amp;ghdr.cookie[0], GMON_MAGIC, sizeof (ghdr.cookie));

*(int32_t *) ghdr.version = GMON_VERSION;

write_not_cancel (fd, &amp;ghdr, sizeof (struct gmon_hdr));

 

/* write PC histogram: */

write_hist (fd);

 

/* write call-graph: */

write_call_graph (fd);

 

/* write basic-block execution counts: */

write_bb_counts (fd);

 

close_not_cancel_no_status (fd);
</code></pre></div></div>

<p>}</p>

<p>é€šè¿‡write_histã€write_call_graphã€write_bb_countsè¿™ä¸‰ä¸ªå­å‡½æ•°ï¼Œå…¶åˆ†åˆ«å°†pc histogramã€call-graphä»¥åŠbasic-block execution countsä¿¡æ¯è¾“å‡ºåˆ°gmon.outä¸­ã€‚</p>

<p>1.4        gprofçš„è¾“å‡ºåˆ†æ
     åœ¨gmon.outæ–‡ä»¶äº§ç”Ÿä¹‹åï¼Œå¯ä»¥é€šè¿‡GNU binutilsä¸­æä¾›çš„å·¥å…·gprofæ¥åˆ†ææ•°æ®ï¼Œè½¬æ¢æˆå®¹æ˜“é˜…è¯»ã€ç†è§£çš„æ ¼å¼ï¼ˆæ–‡å­—ã€å›¾ç‰‡ç­‰ï¼‰ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> gprofçš„ä¸»è¦ä»£ç åœ¨gprof/gprof.cä¸­

åœ¨gmon_out_readå‡½æ•°ä¸­ï¼Œå…¶åˆ†åˆ«é€šè¿‡hist_read_recã€cg_read_recã€bb_read_recæ¥è¯»å– gmon.outä¸­å¯¹åº”çš„pc histogramã€call-graphä»¥åŠbasic-block executioncountsä¿¡æ¯ã€‚åœ¨å°†pchistogramæ˜ å°„åˆ°å…·ä½“å‡½æ•°æ—¶é—´çš„å¤„ç†ä¸Šï¼Œgprofé‡‡ç”¨äº†ä¸€ç§è¿‘ä¼¼ç®—æ³•ï¼š
</code></pre></div></div>

<p>sym_high_pc</p>

<p>sym_low_pc</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> å…¶ä¸­ï¼Œbin_low_pcå¾…ç”¨sampleæ•°ç»„ä¸­çš„ä»»æ„ä¸€é¡¹æ‰€å¯¹åº”çš„PCåœ°å€ï¼šè€Œbin_high_pcä»£è¡¨bin_low_pcä¸‹ä¸€ä¸ªsampleå¯¹åº”çš„PCåœ°å€ï¼š

 bin_low_pc = lowpc + (bfd_vma)(hist_scale * i);

 bin_high_pc = lowpc +(bfd_vma) (hist_scale * (i + 1));

 sym_low_pcå¾…ç”¨å¯æ‰§è¡Œç¨‹åºä¸­æŸä¸ªç¬¦å·ï¼ˆå‡½æ•°åã€æ®µåç­‰ï¼‰æ‰€å¯¹åº”çš„PCåœ°å€ï¼Œsym_high_pcä¸ºä¸‹ä¸€ä¸ªç¬¦å·é¡¹æ‰€å¯¹åº”çš„PCåœ°å€ï¼š

sym_low_pc =symtab.base[j].hist.scaled_addr;

sym_high_pc = symtab.base[j +1].hist.scaled_addr;

gprofåªå°†[bin_low_pc, bin_high_pc]å’Œ[sym_low_pc ,sym_high_pc]é‡åˆåŒºåŸŸï¼ˆä»¥ç®­å¤´æ ‡è¯†ï¼‰çš„sampleæ¬¡æ•°ç®—ä¸ºsym_low_pcç¬¦å·çš„æ¶ˆè€—æ—¶é—´ã€‚

 overlap = MIN (bin_high_pc,sym_high_pc) - MAX (bin_low_pc, sym_low_pc);
</code></pre></div></div>

<p>credit = overlap * time /hist_scale;  // time = sample[i], hist_scale = pc_scale.</p>

<p>1.5        å°ç»“
     Gprofæ˜¯GUN å·¥å…·é“¾ä¸­è‡ªå¸¦çš„profilerï¼Œæ— éœ€å®‰è£…æˆæœ¬ï¼Œä¸gccçš„ç»“åˆè®©å…¶ä½¿ç”¨æ–¹ä¾¿ï¼Œèƒ½å¤Ÿå¿«é€Ÿä¸Šæ‰‹ã€‚ä½†æ˜¯gprofä¹Ÿæœ‰å…¶ä¸€å®šçš„ç¼ºé™·ï¼Œ</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1ã€å®ƒçš„æµ‹è¯•ç»“æœå¹¶ä¸èƒ½ä¿è¯å®Œå…¨å‡†ç¡®ï¼š  å®ƒæ— æ³•ç»Ÿè®¡ç¨‹åºè€—åœ¨IOä»¥åŠswapä¸Šçš„æ—¶é—´ï¼š
</code></pre></div></div>

<p>The output from gprof gives no indication of parts of your programthat are limited by I/O or swapping bandwidth. This is because samplesof the program counter are taken at fixed intervals of the programâ€™srun time. Therefore, the time measurements in gprof output say nothingabout time that your program was not running. For example, a part ofthe program that creates so much data that it cannot all fit inphysical memory at once may run very slowly due to thrashing, but gprofwill say it uses little time. On the other hand, sampling by run timehas the advantage that the amount of load due to other users wonâ€™tdirectly affect the output you get.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> è€Œä¸”ï¼Œç”±äºå…¶é€šè¿‡é‡‡é›†sampleæ¥è®¡ç®—profileçš„æ–¹å¼ï¼Œæœ¬èº«å°±å­˜åœ¨ä¸€å®šçš„å¤±çœŸï¼š
</code></pre></div></div>

<p>The run-time figures that gprof gives you are based on a samplingprocess, so they are subject to statistical inaccuracy. If a functionruns only a small amount of time, so that on the average the samplingprocess ought to catch that function in the act only once, there is apretty good chance it will actually find that function zero times, ortwice.</p>

<p>By contrast, the number-of-calls figures are derived by counting,not sampling. They are completely accurate and will not vary from runto run if your program is deterministic.</p>

<p>The sampling period that is printed at the beginning of theflat profile says how often samples are taken. The rule of thumb isthat a run-time figure is accurate if it is considerably bigger thanthe sampling period.</p>

<p>The actual amount of error is usually more than one sampling period. In fact, if a value is n times the sampling period, the expected error in it is the square-root of nsampling periods. If the sampling period is 0.01 seconds and fooâ€™srun-time is 1 second, the expected error in fooâ€™s run-time is 0.1seconds. It is likely to vary this much on the average from one profiling run to the next. (Sometimes it will vary more.)</p>

<p>This does not mean that a small run-time figure is devoid of information. If the programâ€™s totalrun-time is large, a small run-time for one function does tell you thatthat function used an insignificant fraction of the whole programâ€™stime. Usually this means it is not worth optimizing.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2. gprofä¸èƒ½æ”¯æŒåŠ¨æ€åº“çš„è§£æã€‚åŸå› åœ¨æœ¬æ–‡ä¸­å·²ç»åˆ†æã€‚

3. gprofä¸æ˜“ç»´æŠ¤å’Œæ‰©å±•ï¼Œå› ä¸ºgprofçš„ä»£ç æ˜¯å°è£…åœ¨GNUå·¥å…·é“¾çš„glibcä»¥åŠbinutilsä¸­ï¼Œä¿®æ”¹libcçš„é£é™©è¾ƒå¤§ï¼Œè€Œä¸”ç‰ˆæœ¬ä¹Ÿä¸æ˜“ç»´æŠ¤ï¼ˆä¸åŒç³»ç»Ÿä¸­ä½¿ç”¨çš„libcç‰ˆæœ¬ä¸ä¸€è‡´ï¼Œå¦‚æœå•ç‹¬æ›´æ–°glibcï¼Œä¼šå‡ºç°ç¨‹åºcrashï¼‰ã€‚
</code></pre></div></div>

<p>äºŒã€       GooglePerformance Tools
Goolgleperformance toolsæ˜¯googleå…¬å¸å¼€å‘çš„ä¸€å¥—ç”¨äºC++Profileçš„å·¥å…·é›†ã€‚å…¶ä¸­åŒ…æ‹¬ï¼š</p>

<p>ä¸€ä¸ªä¼˜åŒ–çš„å†…å­˜ç®¡ç†ç®—æ³•â€”tcmallocæ€§èƒ½ä¼˜äºmallocã€‚</p>

<p>ä¸€ä¸ªç”¨äºCPU profileçš„å·¥å…·ï¼Œç”¨äºæ£€æµ‹ç¨‹åºçš„æ€§èƒ½çƒ­ç‚¹ï¼Œè¿™ä¸ªåŠŸèƒ½å’Œgprofç±»ä¼¼ã€‚</p>

<p>ä¸€ä¸ªç”¨äºå †æ£€æŸ¥å·¥å…·ï¼Œç”¨äºæ£€æµ‹ç¨‹åºåœ¨æ˜¯å¤Ÿæœ‰å†…å­˜æ³„éœ²ï¼Œè¿™ä¸ªåŠŸèƒ½å’Œvalgrindç±»ä¼¼ã€‚</p>

<p>ä¸€ä¸ªç”¨äºHeap profileçš„å·¥å…·ï¼Œç”¨äºç›‘æ§ç¨‹åºåœ¨æ‰§è¡Œè¿‡ç¨‹çš„å†…å­˜ä½¿ç”¨æƒ…å†µã€‚</p>

<p>å®˜æ–¹æ–‡æ¡£ï¼š</p>

<p>http://code.google.com/p/google-perftools/wiki/GooglePerformanceTools</p>

<p>å®ƒçš„ä½¿ç”¨æ–¹å¼æ¯”è¾ƒç®€å•ï¼šé¦–å…ˆåœ¨ç¼–è¯‘ç¨‹åºçš„æ—¶å€™åŠ ä¸Šç›¸åº”çš„é“¾æ¥åº“ï¼Œç„¶ååœ¨è¿è¡Œç¨‹åºæ—¶</p>

<p>é€šè¿‡è®¾ç½®ç›¸åº”çš„ç¯å¢ƒå˜é‡æ¥æ¿€æ´»å·¥å…·ã€‚</p>

<p>1.ä½¿ç”¨å…¶æä¾›çš„å†…å­˜ç®¡ç†å‡½æ•°â€”TC Malloc:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   gcc [...] -ltcmalloc  
</code></pre></div></div>

<p>2.ä½¿ç”¨å…¶å †å†…å­˜æ£€æŸ¥å·¥å…·:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   gcc [...] -o myprogram -ltcmalloc

   HEAPCHECK=normal ./myprogram   
</code></pre></div></div>

<p>3.ä½¿ç”¨Heap Profiler:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  gcc [...] -o myprogram -ltcmalloc

  HEAPPROFILE=/tmp/netheap ./myprogram  
</code></pre></div></div>

<p>4.ä½¿ç”¨Cpu Profiler:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  gcc [...] -o myprogram -lprofiler

  CPUPROFILE=/tmp/profile ./myprogram
</code></pre></div></div>

<p>å®ƒçš„è¾“å‡ºä¹Ÿå¾ˆæ¸…æ™°,ä¸‹å›¾æ˜¯ä¸€ä¸ªCpuProfilerçš„ç»“æœå›¾ï¼Œå…¶ä¸­æ¯ä¸ªæ–¹å—ä»£ç ä¸€ä¸ªå‡½æ•°ï¼Œæ–¹å—é—´çš„ç®­å¤´æè¿°äº†å‡½æ•°ä¹‹é—´çš„è°ƒç”¨å…³ç³»ï¼Œæ¯ä¸ªæ–¹å—é‡Œé¢æœ‰ ä¸¤ä¸ªæ•°å­—ï¼šX ofYï¼Œå…¶ä¸­Yè¡¨ç¤ºåœ¨ç¨‹åºæ‰§è¡Œè¿‡ç¨‹ä¸­å‡½æ•°æ‰€æ¶ˆè€—çš„æ€»ä½“æ—¶é—´ï¼ŒXè¡¨ç¤ºå‡½æ•°è‡ªèº«æ‰€æ¶ˆè€—çš„æ—¶é—´ï¼Œæ‰€ä»¥Y-XåŠæ—¶å‡½æ•°æ‰€è°ƒç”¨çš„å­å‡½æ•°æ¶ˆè€—æ—¶é—´ã€‚å¦‚æœå‡½æ•°æ²¡æœ‰å­å‡½ æ•°ï¼Œåˆ™åªæ˜¾ç¤ºæ€»ä½“æ—¶é—´ã€‚ï¼ˆXï¼ŒYçš„å•ä½å¾—sampleï¼Œæ¯ä¸ªsampleæ‰€ä»£è¡¨çš„æ—¶é—´å¯ä»¥è®¾ç½®ï¼Œé»˜è®¤ä¸º10msï¼‰</p>

<p>2.1        å®‰è£…
     a) å®‰è£…libunwind</p>

<p>libunwindæ˜¯ä¸€ä¸ªç”¨äºè§£æç¨‹åºè°ƒç”¨æ ˆçš„C++åº“ï¼Œç”±äºglibcå†…å»ºçš„æ ˆå›æ»šåŠŸèƒ½åœ¨64ä½ç³»ç»Ÿä¸Šæœ‰bugï¼Œå› æ­¤googleperformance toolså»ºè®®ä½¿ç”¨libunwind</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   ä¸‹è½½libunwind-0.99-beta.tar.gz

   cd $HOME
</code></pre></div></div>

<p>tarxzvf libunwind-0.99-beta.tar.gz</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   mkdir libunwind-0.99-beta-build

   cd libunwind-0.99-beta

   ./configure â€“prefix=$HOME/libunwind-0.99-beta-build

 

 b) å®‰è£…Google PerformanceTools

   æ³¨æ„ï¼šå¦‚æœåœ¨ç³»ç»Ÿç›®å½•ä¸­æ‰¾ä¸åˆ°libunwindï¼Œgoogle performance toolså°†é»˜è®¤ä½¿ç”¨glibcçš„å†…å»ºåŠŸèƒ½ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦æ‰‹åŠ¨è®¾ç½®libunwindçš„å®‰è£…ç›®å½•ã€‚
</code></pre></div></div>

<p>ä¸‹è½½google-perftools-1.6.tar.gz</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   cd $HOME

   tar xzvf google-perftools-1.6.tar.gz

   mkdir google-perftools-1.6-build

   cd google-perftools-1.6

   ./configure â€“prefix=$HOME/ google-perftools-1.6-build
</code></pre></div></div>

<p>CPPFLAGS=-I$HOME/libunwind-0.99-beta-build/include</p>

<p>LDFLAGS=-L$HOME/libunwind-0.99-beta-build/lib</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   make &amp;&amp; make install
</code></pre></div></div>

<p>2.2        ç”¨æ³•
       å‚è€ƒå®˜æ–¹æ–‡æ¡£ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   è¿™é‡Œæœ‰ä¸¤ç‚¹æƒ³çªå‡ºä»‹ç»ä¸‹ï¼Œä¸€ä¸ªæ˜¯å¯¹åŠ¨æ€åº“çš„æ”¯æŒï¼Œä¸€ä¸ªå¯¹åŠ¨æ€profileråŠŸèƒ½çš„æ”¯æŒã€‚
</code></pre></div></div>

<p>2.2.1 åŠ¨æ€åº“çš„æ”¯æŒ
      åœ¨ç¬¬ä¸€ç« èŠ‚é‡Œé¢æˆ‘ä»¬å·²ç»è¯æ˜å’Œåˆ†æGUNProfilerä¸æä¾›å¯¹åŠ¨æ€åº“çš„æ”¯æŒï¼Œè™½ç„¶å¯ä»¥é€šè¿‡ä¿®æ”¹glibcçš„ä»£ç æ¥æ‰©å±•æ­¤åŠŸèƒ½ï¼Œä½†æ˜¯ ç»´æŠ¤æˆæœ¬è¾ƒå¤§ã€‚è€ŒGoolgle performancetoolsæœ¬èº«å°±å·²ç»æä¾›äº†å¯¹åŠ¨æ€åº“çš„æ”¯æŒåŠŸèƒ½ã€‚å½“ç„¶åŠ¨æ€åº“çš„ä½¿ç”¨ä¹Ÿåˆ†ä¸¤ç§æƒ…å†µï¼šä¸€ç§æ˜¯åœ¨è¿è¡Œæ—¶åŠ¨æ€é“¾æ¥åº“ï¼Œä¸€ç§æ˜¯åœ¨è¿è¡Œæ—¶åŠ¨æ€åŠ  è½½åº“ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   è¿è¡Œæ—¶é“¾æ¥å¯ä»¥åŠ¨æ€åœ°å°†ç¨‹åºå’Œå…±äº«åº“é“¾æ¥å¹¶è®© Linux åœ¨æ‰§è¡Œæ—¶åŠ è½½åº“ï¼ˆå¦‚æœå®ƒå·²ç»åœ¨å†…å­˜ä¸­äº†ï¼Œåˆ™æ— éœ€å†åŠ è½½ï¼‰ã€‚ä»¥ä¸€ä¸ªå…·ä½“ä¾‹å­æ¥è¯´æ˜ï¼š
</code></pre></div></div>

<p>//libtestprofiler.h</p>

<p>extern â€œCâ€{</p>

<p>int loopop();</p>

<p>}</p>

<p>libtestprofiler.cppåªå®šä¹‰äº†ä¸€ä¸ªè€—æ—¶è®¡ç®—å‡½æ•°ï¼Œä¾¿äºåˆ†æã€‚</p>

<p>// libtestprofiler.cpp</p>

<p>#include â€œlibtestprofiler.hâ€</p>

<p>extern â€œCâ€{</p>

<p>int loopop()</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int n = 0;

for(int i = 0; i &lt; 1000000; i++)

    for(int j = 0; j &lt; 10000; j++)

    {  

        n |= i%100 + j/100;

    }  

return n;
</code></pre></div></div>

<p>}</p>

<p>å°†libtestprofiler.cppç¼–è¯‘ä¸ºåŠ¨æ€åº“ï¼š</p>

<p>g++â€“shared -fPIC -g -O0 -o libtestprofiler.so libtestprofiler.cpp</p>

<p>åœ¨ä¸»ç¨‹åºä¸­è°ƒç”¨åŠ¨æ€åº“ï¼š</p>

<p>#include <iostream></iostream></p>

<p>#include â€œlibtestprofiler.hâ€</p>

<p>using namespace std;</p>

<p>int main(int argc,char** argv)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cout &lt;&lt; "loopop: " &lt;&lt; loopop() &lt;&lt; endl;

return 1;
</code></pre></div></div>

<p>}</p>

<p>ç¼–è¯‘ä¸»ç¨‹åºï¼Œå¹¶åŠ¨æ€é“¾æ¥libtestprofiler.soï¼š</p>

<p>a)   é¦–å…ˆé‡‡ç”¨GUN Profileçš„æ–¹å¼ç¼–è¯‘ä¸»ç¨‹åº</p>

<p>g++ -g -O0 -omain main.cpp -ltestprofiler -L. â€“pg</p>

<p>./main</p>

<p>gprof â€“b ./mainç»“æœå¦‚ä¸‹ï¼š</p>

<p>Each sample counts as 0.01 seconds.</p>

<p>no time accumulated</p>

<p>%   cumulative   self              self     total</p>

<p>time   seconds   seconds    calls  Ts/call  Ts/call  name</p>

<p>0.00      0.00     0.00        1     0.00     0.00  global constructors keyed to main</p>

<p>0.00      0.00     0.00        1     0.00     0.00  __static_initialization_and_destruction_0(int, int)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  0.00      0.00     0.00        1     0.00     0.00  data_start
</code></pre></div></div>

<p>å’Œé¢„æƒ³ä¸€æ ·ï¼ŒGNU Profile ä¸èƒ½è§£æåŠ¨æ€åº“çš„æ€§èƒ½çƒ­ç‚¹ã€‚</p>

<p>b)   å†ä»¥google CPU Profileçš„æ–¹å¼ç¼–è¯‘ä¸»ç¨‹åºï¼š</p>

<p>g++ -g -O0 -omain main.cpp -ltestprofiler -L. -lprofiler-L/home/wul/google-perftools-1.6-build/lib</p>

<p>CPUPROFILE=perf.out./main</p>

<p>pprof â€“text./main  ./perf.outï¼Œç»“æœå¦‚ä¸‹ï¼š</p>

<p>Using local file ./main.</p>

<p>Using local file ./perf.out.</p>

<p>Removing killpg from all stack traces.</p>

<p>Total: 5923 samples</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5923 100.0% 100.0%     5923 100.0% loopop

   0   0.0% 100.0%     5923 100.0% __libc_start_main

   0   0.0% 100.0%     5923 100.0% _start

       0   0.0% 100.0%     5923 100.0% main
</code></pre></div></div>

<p>ç”±æ­¤è¯æ˜ï¼ŒGoogle CPU Profileræ”¯æŒå¯¹åŠ¨æ€é“¾æ¥åº“çš„æ€§èƒ½åˆ†æã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   è¿è¡Œæ—¶åŠ è½½å…è®¸ç¨‹åºå¯ä»¥æœ‰é€‰æ‹©åœ°è°ƒç”¨åº“ä¸­çš„å‡½æ•°ã€‚ä½¿ç”¨åŠ¨æ€åŠ è½½è¿‡ç¨‹ï¼Œç¨‹åºå¯ä»¥å…ˆåŠ è½½ä¸€ä¸ªç‰¹å®šçš„åº“ï¼ˆå·²åŠ è½½åˆ™ä¸å¿…ï¼‰ï¼Œç„¶åè°ƒç”¨è¯¥åº“ä¸­çš„æŸä¸€ç‰¹å®šå‡½æ•°ï¼Œè¿™æ˜¯æ„å»ºæ”¯æŒæ’ä»¶çš„åº”ç”¨ç¨‹åºçš„ä¸€ä¸ªæ™®éçš„æ–¹æ³•ã€‚

   è¿˜æ˜¯ä»¥ä¸Šè¿°ç¨‹åºä¸ºä¾‹ï¼Œå¯¹ä¸»ç¨‹åºä»£ç è¿›ä¿®æ”¹ï¼š
</code></pre></div></div>

<p>#include <stdio.h></stdio.h></p>

<p>#include <dlfcn.h></dlfcn.h></p>

<p>char LIBPATH[] = â€œ./libtestprofiler.soâ€;</p>

<p>typedef int (*op_t) ();</p>

<p>int main(int argc,char** argv)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void* dl_handle;

op_t loopop;

char* error;

 

/* Open the shared object */

dl_handle = dlopen( LIBPATH, RTLD_LAZY );

if (!dl_handle) {

    printf( "dlopen failed! %s\n", dlerror() );

    return 1;

}  

 

/* Resolve the symbol (loopop) from the object */

loopop = (op_t)dlsym( dl_handle, "loopop");

error = dlerror();

if (error != NULL) {

    printf( "dlsym failed! %s\n", error );

    return 1;
</code></pre></div></div>

<p>}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Call the resolved loopop and print the result */

printf("result:  %d\n", (loopop)() );

 

/* Close the object */

dlclose( dl_handle );

 

return 0;
</code></pre></div></div>

<p>}</p>

<p>ç¼–è¯‘ï¼š</p>

<p>g++ -g -O0  -o main_dl main_dl.cpp  -lprofiler -L/home/wul/google-perftools-1.6-build/lib-ldl</p>

<p>CPUPROFILE=perf_dl.out./main_dl</p>

<p>pprofâ€“text ./main_dl  ./perf_dl.outï¼Œç»“æœå¦‚ä¸‹ï¼š</p>

<p>Using local file ./main_dl.</p>

<p>Using local file ./perf_dl.out.</p>

<p>Removing killpg from all stack traces.</p>

<p>Total: 5949 samples</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 843  14.2%  14.2%      843  14.2% 0x00002b2f203d25d6

 â€¦â€¦

   0   0.0% 100.0%        1   0.0% 0x00002b2f203d25ed

   0   0.0% 100.0%     5949 100.0% __libc_start_main

   0   0.0% 100.0%     5949 100.0% _start

   0   0.0% 100.0%     5949 100.0% main
</code></pre></div></div>

<p>å¾ˆå¥‡æ€ªï¼Œè¿™ä¸ªç»“æœæ˜¾ç¤ºlibtestprofiler.soåº“ä¸­çš„ç¬¦å·æ²¡æœ‰æ­£ç¡®è§£æï¼Œperf_dl.outæ–‡ä»¶ä¹Ÿæ²¡æœ‰åŒ…å« libtestprofiler.soçš„å†…å­˜æ˜ å°„ä¿¡æ¯ï¼Œä½†æ˜¯æˆ‘ä»¬ç¡®å®åœ¨ä¸»ç¨‹åºå·²ç»é€šè¿‡dlopenå°†åŠ¨æ€åº“è£…è½½åˆ°å†…å­˜å¹¶æ‰§è¡ŒæˆåŠŸäº†ï¼Œä¸ºä½•åœ¨ä¸»ç¨‹åºçš„å†…å­˜æ˜  å°„è¡¨ä¸­æ‰¾ä¸åˆ°åŠ¨æ€åº“çš„ä¿¡æ¯å‘¢ï¼Ÿç»è¿‡ä¸€ç•ªåˆ†æå’Œè°ƒæŸ¥ï¼Œç»ˆäºæ‰¾åˆ°åŸå› ï¼Œå› ä¸ºperf_dl.outæ–‡ä»¶çš„è¾“å‡ºå·¥ä½œæ˜¯åœ¨ä¸»ç¨‹åºæ‰§è¡Œç»“æŸä¹‹åã€ç³»ç»Ÿå›æ”¶èµ„æºçš„æ—¶å€™ è°ƒç”¨çš„ï¼ˆå…·ä½“è§å®ç°åŸç†ä¸€èŠ‚ï¼‰ï¼Œè€Œåœ¨æ­¤æ—¶ä¸»ç¨‹åºæ‰§è¡Œäº†dlclose()å‡½æ•°å¸è½½äº†libtestprofiler.soï¼Œæ‰€ä»¥éšådumpå‡ºçš„å†…å­˜æ˜ å°„ è¡¨å½“ç„¶å°±ä¸ä¼šåŒ…å«libtestprofiler.soçš„ä¿¡æ¯äº†ã€‚æˆ‘ä»¬æµ‹è¯•ä¸‹å°†dlclose(dl_handle)æ³¨é‡Šåçš„è¿è¡Œç»“æœï¼š</p>

<p>Using local file ./main_dl.</p>

<p>Using local file ./perf_dl.out.</p>

<p>Removing killpg from all stack traces.</p>

<p>Total: 5923 samples</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>5923 100.0% 100.0%     5923 100.0% loopop

   0   0.0% 100.0%     5923 100.0% __libc_start_main

   0   0.0% 100.0%     5923 100.0% _start

       0   0.0% 100.0%     5923 100.0% main
</code></pre></div></div>

<p>å“ˆå“ˆï¼ŒåŠ¨æ€åº“ä¸­çš„ç¬¦å·åˆèƒ½æ­£å¸¸è§£æäº†ã€‚</p>

<p>2.2.2 åŠ¨æ€profileråŠŸèƒ½
         è¿™é‡Œé¦–å…ˆéœ€è¦è§£é‡Šä¸‹ä½•è°“åŠ¨æ€profileråŠŸèƒ½ï¼šä¼ ç»Ÿçš„profilerå·¥å…·ï¼Œä»¥GUNProfilerä¸ºä¾‹ï¼Œåªèƒ½ç¼–è¯‘é˜¶æ®µæ§åˆ¶profilerçš„å¼€å…³ ï¼ˆ-fprofile-arcs-ftest-coverageï¼‰ï¼Œä½†æ˜¯æˆ‘ä»¬æœ‰æ—¶å€™éœ€è¦åœ¨ç¨‹åºçš„è¿è¡Œé˜¶æ®µï¼Œæˆ–è€…è¯´è¿è¡Œçš„ä¸­é—´é˜¶æ®µæ§åˆ¶profilerçš„å¼€ å…³ã€‚Googleperformance toolså¯ä»¥é€šè¿‡CPUPROFILEç¯å¢ƒå˜é‡åœ¨ç¨‹åºè¿è¡Œåˆé˜¶æ®µæ§åˆ¶cpuprofilerçš„å¼€å…³ï¼Œè€Œä¸”æ ¹æ®æ–‡æ¡£/usr/doc/google- perftools-1.5/pprof_remote_servers.htmlçš„æç¤ºï¼Œå¯ä»¥é€šè¿‡åŠŸèƒ½æ‰©å±•å¯ä»¥å®ç°åœ¨è¿è¡Œä¸­é—´é˜¶æ®µæˆ–é€šè¿‡httpåè®®è¿œ ç¨‹æ§åˆ¶profilerä¿¡æ¯çš„åŠŸèƒ½ã€‚gperftools-httpdé¡¹ç›®å°±å·²ç»åˆæ­¥å®Œæˆäº†è¿™ä¸ªåŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥ä½“éªŒä¸€ä¸‹ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   1ï¼ä»http://code.google.com/p/gperftools-httpd/ä¸‹è½½gperftools-httpdå®‰è£…ã€‚

   2ï¼ä¿®æ”¹ä¸‹æµ‹è¯•ç¨‹åº main.cpp, æ­£å¸¸è¿è¡Œæ—¶é—´ï¼Œæ–¹ä¾¿æµ‹è¯•
</code></pre></div></div>

<p>#include <iostream></iostream></p>

<p>#include â€œgperftools-httpd.hâ€</p>

<p>#include â€œlibtestprofiler.hâ€</p>

<p>using namespace std;</p>

<p>int main(int argc,char** argv)</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ghttpd();

while(1)

    cout &lt;&lt; "loopop: " &lt;&lt; loopop() &lt;&lt; endl;

return 1;
</code></pre></div></div>

<p>}</p>

<p>è¿™ä¸ªç¨‹åºä¸»è¦åšäº†ä¸¤ç‚¹ä¿®æ”¹ï¼Œè°ƒç”¨ghttpd()å¯åŠ¨ä¸€ä¸ªè½»é‡çº§web serviveï¼Œå·²å®Œæˆpprofçš„è¿œç¨‹è¯·æ±‚æœåŠ¡ï¼›é€šè¿‡whileå¾ªç¯åŠ é•¿äº†ç¨‹åºçš„æ‰§è¡Œæ—¶é—´ï¼Œå·²æ–¹ä¾¿éªŒè¯åŠ¨æ€profileråŠŸèƒ½ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   3ï¼ç¼–è¯‘ï¼Œéœ€è¦è¿æ¥libghttpd.soã€libprofiler.so
</code></pre></div></div>

<p>g++-g -O0 -o  main main.cpp-I/home/wul/gperftools-httpd-0.2-ltestprofiler -L.-L/home/wul/gperftools-httpd-0.2/  -lghttpd -lprofiler -L/home/wul/google-perftools-1.6-build/lib-dl -lpthread</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   4. å¯åŠ¨æµ‹è¯•ç¨‹åº

   ./main æ³¨æ„æˆ‘ä»¬è¿™æ—¶å¹¶æ²¡æœ‰è®¾ç½®CPUPROFILEç¯å¢ƒå˜é‡ï¼Œå³è¡¨ç¤ºæ­¤æ—¶CPU  PROFILEåŠŸèƒ½è¿˜æ²¡æœ‰æ‰“å¼€ã€‚

   5ï¼é€šè¿‡pprofå·¥å…·è¿œç¨‹æ‰“å¼€æµ‹è¯•ç¨‹åºçš„CPU profileåŠŸèƒ½ï¼š

   pprof  ./main  http://localhost:9999/pprof/profileï¼Œç»“æœå¦‚ä¸‹ï¼š
</code></pre></div></div>

<p>Using local file ./main.</p>

<p>Gathering CPU profile from http://localhost:9999/pprof/profile?seconds=30 for 30 seconds to</p>

<p>/home/wul/pprof/main.1292168091.localhost</p>

<p>Be patientâ€¦</p>

<p>Wrote profile to /home/wul/pprof/main.1292168091.localhost</p>

<p>Removing _L_mutex_unlock_15 from all stack traces.</p>

<p>Welcome to pprof!  For help, type â€˜helpâ€™.</p>

<p>(pprof) text</p>

<p>Total: 2728 samples</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2728 100.0% 100.0%     2728 100.0% loopop

   0   0.0% 100.0%     2728 100.0% __libc_start_main

   0   0.0% 100.0%     2728 100.0% _start

   0   0.0% 100.0%     2728 100.0% main

   ä»ç»“æœä¸­å¯ä»¥çœ‹å‡ºï¼Œå½“pprofå‘æœ¬åœ°webæœåŠ¡http://localhost:9999/å‘ é€Getpprof/profileè¯·æ±‚æ—¶ï¼Œæµ‹è¯•ç¨‹åºå°±ä¼šè‡ªåŠ¨å¼€å¯profileåŠŸèƒ½ï¼Œé»˜è®¤çš„ç›‘æ§æ—¶é—´æ®µæ˜¯now~now+30sï¼ˆæ—¶é—´é•¿çŸ­å¯ä»¥é€šè¿‡ secondså‚æ•°è®¾ç½®ï¼‰ï¼Œç­‰å¾…30sä¹‹åï¼Œæµ‹è¯•ç¨‹åºåœæ­¢profileï¼Œå°†ç»“æœè¿”å›ç»™pprofå¹¶ä¿å­˜åœ¨/home/wul/pprof /main.1292168091.localhostä¸­ï¼Œæ­¤æ—¶å†é€šè¿‡textå‘½ä»¤å°±å¯ä»¥çœ‹åˆ°è§£æåçš„è¾“å‡ºäº†ã€‚pprofå·¥å…·è¿˜æ”¯æŒå…¶å®ƒçš„queryå‚ æ•°ï¼Œè­¬å¦‚é‡‡æ ·é¢‘ç‡æ§åˆ¶ã€è§¦å‘é‡‡æ ·äº‹ä»¶ç­‰ï¼Œå…·ä½“å¯ä»¥å‚è€ƒgperftools-httpdä»¥åŠgoogle performancetoolsçš„å®˜æ–¹æ–‡æ¡£ã€‚
</code></pre></div></div>

<p>2.3         å®ç°åŸç†
       Google performance toolsåŒ…å«å››å¤§åŠŸèƒ½ï¼Œä½†æ˜¯æœ¬ç« ä¸»è¦é›†ä¸­ä»‹ç»CPU profileråŠŸèƒ½ï¼Œä»¥ä¾¿å’ŒGNU profileråšæ¨ªå‘å¯¹æ¯”ã€‚</p>

<p>2.3.1     CPU Profile
googleCPU profileçš„å®ç°æ–¹å¼ä¸åŒäºgprofï¼Œä½†æ˜¯ä¸¤ä¸ªçš„å®ç°åŸç†æœ‰ç‚¹ç›¸ä¼¼ã€‚CPUprofileræ˜¯é€šè¿‡è®¾ç½®SIGPROFä¿¡å·å¤„ç†å‡½æ•°æ¥é‡‡é›† sampleçš„ï¼Œè¿™ç‚¹å’Œgprofä¸€æ ·ï¼Œä½†æ˜¯CPUprofileræ²¡æœ‰åœ¨å‡½æ•°å…¥å£æ’å…¥ä»£ç ï¼Œè€Œæ˜¯é€šè¿‡ä¿å­˜è°ƒç”¨æ ˆä¿¡æ¯æ¥è®°å½•å‡½æ•°çš„è°ƒç”¨å›¾å’Œè°ƒç”¨æ¬¡æ•°ã€‚ CPUprofilerçš„ä¸»è¦å®ç°ä»£ç åœ¨src/profiler.ccä¸­ã€‚è¿™ä¸ªæ–‡ä»¶ä¸­å®šä¹‰äº†ä¸€ä¸ªCpuProfilerç±»ï¼Œå¹¶å£°æ˜ä¸€ä¸ªè¯¥ç±»çš„é™æ€å®ä¾‹ã€‚ è¿™æ ·åœ¨mainå‡½æ•°ä¹‹å‰ï¼Œæ­¤é™æ€å®ä¾‹å°±ä¼šè¢«åˆå§‹åŒ–ã€‚</p>

<p>// Initialize profiling: activated if getenv(â€œCPUPROFILEâ€) exists.</p>

<p>CpuProfiler::CpuProfiler()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>: prof_handler_token_(NULL) {
</code></pre></div></div>

<p>// TODO(cgd) Move this code <em>out</em> of the CpuProfile constructor into a</p>

<p>// separate object responsible for initialization. With ProfileHandler there</p>

<p>// is no need to limit the number of profilers.  charfname[PATH_MAX];  if (!GetUniquePathFromEnv(â€œCPUPROFILEâ€, fname)) {   return;</p>

<p>}</p>

<p>// We donâ€™t enable profiling if setuid â€“ itâ€™s a security risk</p>

<p>#ifdef HAVE_GETEUID</p>

<p>if (getuid() != geteuid())</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return;
</code></pre></div></div>

<p>#endif</p>

<p>if (!Start(fname, NULL)) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RAW_LOG(FATAL, "Can't turn on cpu profiling for '%s': %s\n",

        fname, strerror(errno));
</code></pre></div></div>

<p>}</p>

<p>}</p>

<p>è¯¥æ„é€ å‡½æ•°é¦–å…ˆä¼šåˆ¤æ–­ç³»ç»Ÿå˜é‡CPUPROFILEæ˜¯å¦è¢«è®¾ç½®ï¼Œå¦‚æœè®¾ç½®äº†ï¼Œåˆ™å¯åŠ¨CPU profilerè¿›ç¨‹ï¼Œå¦åˆ™ï¼Œç›´æ¥è¿”å›ã€‚æˆ‘ä»¬åœ¨çœ‹çœ‹Startå‡½æ•°åšäº†ä»€ä¹ˆï¼š</p>

<p>bool CpuProfiler::Start(const char* fname, const ProfilerOptions* options) {</p>

<p>SpinLockHolder cl(&amp;lock_);</p>

<p>if (collector_.enabled()) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return false;
</code></pre></div></div>

<p>}</p>

<p>ProfileHandlerState prof_handler_state;</p>

<p>ProfileHandlerGetState(&amp;prof_handler_state);</p>

<p>ProfileData::Options collector_options;</p>

<p>collector_options.set_frequency(prof_handler_state.frequency);</p>

<p>if (!collector_.Start(fname, collector_options)) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return false;
</code></pre></div></div>

<p>}</p>

<p>filter_ = NULL;</p>

<p>if (options != NULL &amp;&amp; options-&gt;filter_in_thread != NULL) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>filter_ = options-&gt;filter_in_thread;

filter_arg_ = options-&gt;filter_in_thread_arg;
</code></pre></div></div>

<p>}</p>

<p>// Setup handler for SIGPROF interrupts</p>

<p>EnableHandler();</p>

<p>return true;</p>

<p>}</p>

<p>æ­¤å‡½æ•°é¦–å…ˆä¼šè°ƒç”¨ProfileHandlerGetStateæ¥è·å–å…¶å®ƒçš„æ§åˆ¶å‚æ•°ï¼ŒåŒ…æ‹¬CPUPROFILE_REALTIMEå’ŒCPUPROFILE_FREQUENCYã€‚</p>

<p>CPUPROFILE_FREQUENCY=x</p>

<p>default: 100</p>

<p>How many interrupts/second the cpu-profiler samples.</p>

<p>CPUPROFILE_REALTIME=1</p>

<p>default: [not set]</p>

<p>If set to any value (including 0 or the empty string), useITIMER_REAL instead of ITIMER_PROF to gather profiles. In general,ITIMER_REAL is not as accurate as ITIMER_PROF, and also interacts badlywith use of alarm(), so prefer ITIMER_PROF unless you have a reasonprefer ITIMER_REAL.</p>

<p>å…¶æ¬¡ï¼Œå‡½æ•°è°ƒç”¨ProfileData::Startä¸ºè®°å½•profilerä¿¡æ¯åˆ†é…å†…å­˜å¹¶åˆå§‹åŒ–ï¼Œå…¶å®šä¹‰åœ¨profiledata.ccä¸­ã€‚</p>

<p>bool ProfileData::Start(const char* fname,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    const ProfileData::Options&amp; options) {
</code></pre></div></div>

<p>if (enabled()) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return false;
</code></pre></div></div>

<p>}</p>

<p>// Open output file and initialize various data structures</p>

<table>
  <tbody>
    <tr>
      <td>int fd = open(fname, O_CREAT</td>
      <td>O_WRONLY</td>
      <td>O_TRUNC, 0666);</td>
    </tr>
  </tbody>
</table>

<p>if (fd &lt; 0) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Can't open outfile for write

return false;
</code></pre></div></div>

<p>}</p>

<p>start_time_ = time(NULL);</p>

<p>fname_ = strdup(fname);</p>

<p>// Reset counters</p>

<p>num_evicted_ = 0;</p>

<p>count_       = 0;</p>

<p>evictions_   = 0;</p>

<p>total_bytes_ = 0;</p>

<p>hash_ = new Bucket[kBuckets];</p>

<p>evict_ = new Slot[kBufferLength];</p>

<p>memset(hash_, 0, sizeof(hash_[0]) * kBuckets);</p>

<p>// Record special entries</p>

<p>evict_[num_evicted_++] = 0;                     // count for header</p>

<p>evict_[num_evicted_++] = 3;                     // depth for header</p>

<p>evict_[num_evicted_++] = 0;                     // Version number</p>

<p>CHECK_NE(0, options.frequency());</p>

<p>int period = 1000000 / options.frequency();</p>

<p>evict_[num_evicted_++] = period;                // Period (microseconds)</p>

<p>evict_[num_evicted_++] = 0;                     // Padding</p>

<p>out_ = fd;</p>

<p>return true;</p>

<p>}</p>

<p>å…¶ä¸­slotæ•°ç»„evict_å°±æ˜¯profilerè¾“å‡ºæ–‡ä»¶ä¸­çš„ä¿å­˜å†…å®¹ï¼Œå…·ä½“å¯å‚è€ƒprofilerè¾“å‡ºæ–‡ä»¶çš„æ ¼å¼è¯´æ˜ã€‚Bucketæ•°ç»„hash_æ˜¯ç”¨äºä¸´æ—¶ä¿å­˜ç¨‹åºè°ƒç”¨æ ˆä¿¡æ¯çš„hashè¡¨ï¼Œnum_evictedè®°å½•evict_æ•°ç»„ä¸­çš„æœ‰æ•ˆé•¿åº¦ã€‚è¿™äº›å˜é‡åœ¨åç»­å°†ä¼šç»å¸¸å‡ºç°ã€‚å›åˆ°profiler.ccä¸­çš„CpuProfiler::Startå‡½æ•°ï¼Œå…¶æœ€åä¸€æ­¥è°ƒç”¨çš„æ˜¯EnableHandler()ï¼Œ ç”¨äºè®¾ç½®SIGPROFçš„ä¿¡å·å¤„ç†å‡½æ•°ã€‚</p>

<p>void CpuProfiler::EnableHandler() {</p>

<p>RAW_CHECK(prof_handler_token_ == NULL, â€œSIGPROF handler already registeredâ€);</p>

<p>prof_handler_token_ = ProfileHandlerRegisterCallback(prof_handler, this);</p>

<p>RAW_CHECK(prof_handler_token_ != NULL, â€œFailed to set up SIGPROF handlerâ€);</p>

<p>}</p>

<p>å‡½æ•°é€šè¿‡ProfileHandlerRegisterCallbackæ³¨å†Œäº†ä¸€ä¸ªå›è°ƒå‡½æ•°prof_handlerï¼š</p>

<p>ProfileHandlerToken* ProfileHandler::RegisterCallback(</p>

<p>ProfileHandlerCallback callback, void* callback_arg) {</p>

<p>ProfileHandlerToken* token = new ProfileHandlerToken(callback, callback_arg);</p>

<p>SpinLockHolder cl(&amp;control_lock_);</p>

<p>DisableHandler();</p>

<p>{</p>

<p>SpinLockHolder sl(&amp;signal_lock_);</p>

<p>callbacks_.push_back(token);</p>

<p>}</p>

<p>// Start the timer if timer is shared and this is a first callback.</p>

<p>if ((callback_count_ == 0) &amp;&amp; (timer_sharing_ == TIMERS_SHARED)) {</p>

<p>StartTimer();</p>

<p>}</p>

<p>++callback_count_;</p>

<p>EnableHandler();</p>

<p>return token;</p>

<p>}</p>

<p>ç´§æ¥ç€é€šè¿‡ProfileHandler::EnableHandleræ³¨å†ŒSIGPROFä¿¡å·å¤„ç†å‡½æ•°SignalHandlerã€‚</p>

<p>void ProfileHandler::EnableHandler() {</p>

<p>struct sigaction sa;</p>

<p>sa.sa_sigaction = SignalHandler;</p>

<table>
  <tbody>
    <tr>
      <td>sa.sa_flags = SA_RESTART</td>
      <td>SA_SIGINFO;</td>
    </tr>
  </tbody>
</table>

<p>sigemptyset(&amp;sa.sa_mask);</p>

<p>const int signal_number = (timer_type_ == ITIMER_PROF ? SIGPROF : SIGALRM);</p>

<p>RAW_CHECK(sigaction(signal_number, &amp;sa, NULL) == 0, â€œsigprof (enable)â€);</p>

<p>}</p>

<p>åˆ°æ­¤ï¼ŒCPU profileçš„åˆå§‹åŒ–å·¥ä½œåŸºæœ¬ä¸Šéƒ½å®Œæˆäº†ï¼Œæ€»ç»“ä¸€ä¸‹ä¸»è¦æ˜¯å®Œæˆäº†ä¸¤ä¸ªå·¥ä½œï¼šä¸€ä¸ªæ˜¯å†…å­˜çš„åˆ†é…ä»¥åŠåˆå§‹åŒ–ï¼Œä¸€ä¸ªæ˜¯æ³¨å†ŒSIGPROFä¿¡å·å¤„ç†å‡½æ•°ï¼Œä»¥ä¾¿é‡‡é›†sampleä¿¡æ¯ã€‚æ‰€ä»¥æ¥ä¸‹æ¥çš„é‡ç‚¹å°†æ˜¯åˆ†æCPU profileæ˜¯å¦‚ä½•é‡‡é›†sampleçš„ã€‚é¦–å…ˆçœ‹çœ‹SignalHandlerå‡½æ•°çš„å®šä¹‰ï¼š</p>

<p>void ProfileHandler::SignalHandler(int sig, siginfo_t* sinfo, void* ucontext) {</p>

<p>int saved_errno = errno;</p>

<p>RAW_CHECK(instance_ != NULL, â€œProfileHandler is not initializedâ€);</p>

<p>{</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SpinLockHolder sl(&amp;instance_-&gt;signal_lock_);

++instance_-&gt;interrupts_;

for (CallbackIterator it = instance_-&gt;callbacks_.begin();

     it != instance_-&gt;callbacks_.end();

     ++it) {

  (*it)-&gt;callback(sig, sinfo, ucontext, (*it)-&gt;callback_arg);

}
</code></pre></div></div>

<p>}</p>

<p>errno = saved_errno;</p>

<p>}</p>

<p>ä»ä»£ç ä¸­å¯ä»¥çœ‹å‡ºï¼ŒSignalHandleré™¤äº†è®°å½•ä¸­æ–­æ¬¡æ•°ä¹‹å¤–ï¼Œéå†è°ƒç”¨äº†callbacks_é“¾ä¸­çš„æ‰€æœ‰å›è°ƒå‡½æ•°ï¼Œå›æº¯CPU Profileå‰é¢çš„åˆå§‹åŒ–å·¥ä½œï¼Œè¿™é‡Œå°±ä¼šè°ƒç”¨prof_handlerå‡½æ•°ï¼š</p>

<p>// Signal handler that records the pc in the profile-data structure. We do no</p>

<p>// synchronization here.  profile-handler.cc guarantees that at most one</p>

<p>// instance of prof_handler() will run at a time. All other routines that</p>

<p>// access the data touched by prof_handler() disable this signal handler before</p>

<p>// accessing the data and therefore cannot execute concurrently with</p>

<p>// prof_handler().</p>

<p>void CpuProfiler::prof_handler(int sig, siginfo_t<em>, void</em> signal_ucontext,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                           void* cpu_profiler) {
</code></pre></div></div>

<p>CpuProfiler* instance = static_cast&lt;CpuProfiler*&gt;(cpu_profiler);</p>

<table>
  <tbody>
    <tr>
      <td>if (instance-&gt;filter_ == NULL</td>
      <td>Â </td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (*instance-&gt;filter_)(instance-&gt;filter_arg_)) {

void* stack[ProfileData::kMaxStackDepth];

// The top-most active routine doesn't show up as a normal

// frame, but as the "pc" value in the signal handler context.

stack[0] = GetPC(*reinterpret_cast&lt;ucontext_t*&gt;(signal_ucontext));

 

// We skip the top two stack trace entries (this function and one

// signal handler frame) since they are artifacts of profiling and

// should not be measured.  Other profiling related frames may be

// removed by "pprof" at analysis time.  Instead of skipping the top

// frames, we could skip nothing, but that would increase the

// profile size unnecessarily.

int depth = GetStackTraceWithContext(stack + 1, arraysize(stack) - 1,

                                     2, signal_ucontext);

depth++;  // To account for pc value in stack[0];

 

instance-&gt;collector_.Add(depth, stack);
</code></pre></div></div>

<p>}</p>

<p>}</p>

<p>ä»ä»£ç çš„æ³¨è§£ç‰‡æ®µä¸­å¯ä»¥ç†è§£æ­¤å‡½æ•°çš„ä¸»è¦å·¥ä½œå°±æ˜¯è®°å½•å°†å½“å‰ç¨‹åºçš„è°ƒç”¨æ ˆä¿¡æ¯ã€‚é¡¾åæ€ä¹‰ï¼ŒGetPCå‡½æ•°ç”¨äºè·å–å½“å‰pcæŒ‡é’ˆï¼Œå®ƒæ˜¯åˆ©ç”¨linuxç³»ç»Ÿçš„ä¿¡å·å¤„ç†æœºåˆ¶æ¥è·å–å½“å‰pcçš„ï¼ˆå…·ä½“å¯å‚è€ƒã€Šunixç¯å¢ƒé«˜çº§ç¼–ç¨‹ã€‹ï¼‰ï¼Œ å…¶ä¸»è¦å®ç°ä»£ç åœ¨getpc.hä¸­ï¼š</p>

<p>inline void* GetPC(const ucontext_t&amp; signal_ucontext) {</p>

<p>//    fprintf(stderr,â€In GetPC3â€);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return (void*)signal_ucontext.PC_FROM_UCONTEXT;   // defined in config.h
</code></pre></div></div>

<p>}</p>

<p>GetStackTraceWithContextå‡½æ•°å®Œæˆäº†cpu profilerè¿‡ç¨‹ä¸­æœ€é‡è¦çš„ä¸€æ­¥ï¼Œå®ƒæœ€ç»ˆè°ƒç”¨äº†libunwindåº“ï¼Œdumpå‡ºäº†å½“å‰çš„å‡½æ•°è°ƒç”¨æ ˆä¿¡æ¯ï¼Œå…¶ä¸»è¦å®ç°ä»£ç åœ¨stacktrace_libunwind-inl.hä¸­ï¼š</p>

<p>int GET_STACK_TRACE_OR_FRAMES {</p>

<p>fprintf(stderr,â€in libunwind\nâ€);</p>

<p>void *ip;</p>

<p>int n = 0;</p>

<p>unw_cursor_t cursor;</p>

<p>unw_context_t uc;</p>

<p>#if IS_STACK_FRAMES</p>

<p>unw_word_t sp = 0, next_sp = 0;</p>

<p>#endif</p>

<p>if (recursive) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return 0;
</code></pre></div></div>

<p>}</p>

<p>++recursive;</p>

<p>unw_getcontext(&amp;uc);</p>

<p>int ret = unw_init_local(&amp;cursor, &amp;uc);</p>

<p>assert(ret &gt;= 0);</p>

<p>skip_count++;         // Do not include current frame</p>

<p>while (skip_countâ€“) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if (unw_step(&amp;cursor) &lt;= 0) {

      goto out;

  }
</code></pre></div></div>

<p>#if IS_STACK_FRAMES</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if (unw_get_reg(&amp;cursor, UNW_REG_SP, &amp;next_sp)) {

      goto out;

  }
</code></pre></div></div>

<p>#endif</p>

<p>}</p>

<p>while (n &lt; max_depth) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if (unw_get_reg(&amp;cursor, UNW_REG_IP, (unw_word_t *) &amp;ip) &lt; 0) {

      break;

  }
</code></pre></div></div>

<p>#if IS_STACK_FRAMES</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  sizes[n] = 0;
</code></pre></div></div>

<p>#endif</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>result[n++] = ip;

if (unw_step(&amp;cursor) &lt;= 0) {

  break;

}
</code></pre></div></div>

<p>#if IS_STACK_FRAMES</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sp = next_sp;

if (unw_get_reg(&amp;cursor, UNW_REG_SP, &amp;next_sp) , 0) {

  break;

}

sizes[n - 1] = next_sp - sp;
</code></pre></div></div>

<p>#endif</p>

<p>}</p>

<p>out:</p>

<p>â€“recursive;</p>

<p>return n;</p>

<p>è¿™ä¸ªå‡½æ•°çš„è¿‡ç¨‹æœ‰ç‚¹å¤æ‚ï¼Œå®ƒçš„ä¸»è¦åŠŸèƒ½æ˜¯å›æ»šå½“å‰è°ƒç”¨æ ˆï¼Œå¹¶å°†æ ˆæŒ‡é’ˆéƒ½ä¿å­˜åœ¨stackæ•°ç»„ä¸­ï¼Œæ ¹æ®è¿™äº›ä¿¡æ¯å°±å¯ä»¥è®°å½•ç¨‹åºæŒ‡ä»¤çš„æ‰§è¡Œæ¬¡æ•°ï¼Œä»¥åŠæè¿°å‡½æ•°ä¹‹é—´çš„è°ƒç”¨å…³ç³»å›¾ã€‚ï¼ˆå…·ä½“å®ç°åŸç†è¯·å‚è€ƒlibunwindå®˜ç½‘è¯´æ˜ï¼‰ã€‚å†å¯¹åˆ°prof_handlerå‡½æ•°ä¸­ï¼Œç¨‹åºçš„æœ€åä¸€æ­¥å°±æ˜¯å°†å½“å‰è·å–çš„è°ƒç”¨æ ˆä¿¡æ¯ä¿å­˜åˆ°é¢„å…ˆåˆ†é…çš„å†…å­˜ä¸­ï¼Œå…¶å…·ä½“å®ç°åœ¨profiledata.ccæ–‡ä»¶ä¸­ï¼š</p>

<p>void ProfileData::Add(int depth, const void* const* stack) {</p>

<p>if (!enabled()) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return;
</code></pre></div></div>

<p>}</p>

<p>if (depth &gt; kMaxStackDepth) depth = kMaxStackDepth;</p>

<p>RAW_CHECK(depth &gt; 0, â€œProfileData::Add depth &lt;= 0â€);</p>

<p>// Make hash-value</p>

<p>Slot h = 0;</p>

<p>for (int i = 0; i &lt; depth; i++) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Slot slot = reinterpret_cast&lt;Slot&gt;(stack[i]);

h = (h &lt;&lt; 8) | (h &gt;&gt; (8*(sizeof(h)-1)));

h += (slot * 31) + (slot * 7) + (slot * 3);
</code></pre></div></div>

<p>}</p>

<p>count_++;</p>

<p>// See if table already has an entry for this trace</p>

<p>bool done = false;</p>

<p>Bucket* bucket = &amp;hash_[h % kBuckets];</p>

<p>for (int a = 0; a &lt; kAssociativity; a++) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entry* e = &amp;bucket-&gt;entry[a];

if (e-&gt;depth == depth) {

  bool match = true;

  for (int i = 0; i &lt; depth; i++) {

    if (e-&gt;stack[i] != reinterpret_cast&lt;Slot&gt;(stack[i])) {

      match = false;

      break;

    }

  }

  if (match) {

    e-&gt;count++;

    done = true;

    break;

  }

}
</code></pre></div></div>

<p>}</p>

<p>if (!done) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Evict entry with smallest count

Entry* e = &amp;bucket-&gt;entry[0];

for (int a = 1; a &lt; kAssociativity; a++) {

  if (bucket-&gt;entry[a].count &lt; e-&gt;count) {

    e = &amp;bucket-&gt;entry[a];

  }

}

if (e-&gt;count &gt; 0) {

  evictions_++;

  Evict(*e);

}

 

// Use the newly evicted entry

e-&gt;depth = depth;

e-&gt;count = 1;

for (int i = 0; i &lt; depth; i++) {

  e-&gt;stack[i] = reinterpret_cast&lt;Slot&gt;(stack[i]);

}
</code></pre></div></div>

<p>}</p>

<p>}</p>

<p>æ­¤å‡½æ•°çš„å¤„ç†æµç¨‹å¦‚ä¸‹:</p>

<p>1ï¼å¯¹stackæ•°ç»„çš„æ‰€æœ‰é¡¹åšhashï¼Œå¾—åˆ°ä¸€ä¸ªhashå€¼ï¼›</p>

<p>2ï¼æ ¹æ®hashå€¼åœ¨hash_è¡¨ä¸­æŸ¥æ‰¾æ­¤è°ƒç”¨æ ˆï¼Œå¦‚æœæ‰¾åˆ°åŒ¹é…é¡¹åˆ™å¢åŠ è¯¥é¡¹çš„æ‰§è¡Œæ¬¡æ•°ï¼›</p>

<p>3ï¼å¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆ™å°†ä»ç›¸åº”çš„hashæ§½ä¸­popå‡ºæ‰§è¡Œæ¬¡æ•°æœ€å°‘çš„ä¸€ä¸ªè°ƒç”¨æ ˆï¼Œå°†æ­¤è°ƒç”¨æ ˆä¸­çš„æ‰€æœ‰æ ˆæŒ‡é’ˆå€¼æŒ‰é¡ºåºä¿å­˜åˆ°evict_æ•°ç»„ä¸­ï¼Œå¹¶å°†æ–°è°ƒç”¨æ ˆpushåˆ°hashæ§½ä¸­ã€‚</p>

<p>åˆ°æ­¤ï¼ŒCPU profileçš„ä¸»è¦æµç¨‹éƒ½èµ°å®Œäº†ï¼Œæ€»ç»“ä¸€ä¸‹å…¶ä¸€ç›´åœ¨å¾ªç¯æ‰§è¡Œä¸€ä¸ªåŠ¨ä½œï¼šå®šæœŸä¿å­˜ç¨‹åºçš„å½“å‰è°ƒç”¨æ ˆä¿¡æ¯ã€‚åœ¨è¢«æµ‹ç¨‹åºæ‰§è¡Œç»“æŸä¹‹åï¼ŒCPU profileæ‰€åšçš„æœ€åä¸€æ­¥å·¥ä½œå°±æ˜¯å°†evict_æ•°ç»„ä¸­ä¿å­˜çš„æ•°æ®è¾“å‡ºåˆ°%CPUPROFILERç¯å¢ƒå˜é‡åˆ¶å®šçš„æ–‡ä»¶ä¸­ï¼ˆprofiledata.ccï¼‰ï¼š</p>

<p>void ProfileData::Stop() {</p>

<p>if (!enabled()) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return;
</code></pre></div></div>

<p>}</p>

<p>// Move data from hash table to eviction buffer</p>

<p>for (int b = 0; b &lt; kBuckets; b++) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bucket* bucket = &amp;hash_[b];

for (int a = 0; a &lt; kAssociativity; a++) {

  if (bucket-&gt;entry[a].count &gt; 0) {

    Evict(bucket-&gt;entry[a]);

  }

}
</code></pre></div></div>

<p>}</p>

<p>if (num_evicted_ + 3 &gt; kBufferLength) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Ensure there is enough room for end of data marker

FlushEvicted();
</code></pre></div></div>

<p>}</p>

<p>// Write end of data marker</p>

<p>evict_[num_evicted_++] = 0;         // count</p>

<p>evict_[num_evicted_++] = 1;         // depth</p>

<p>evict_[num_evicted_++] = 0;         // end of data marker</p>

<p>FlushEvicted();</p>

<p>// Dump â€œ/proc/self/mapsâ€ so we get list of mapped shared libraries</p>

<p>DumpProcSelfMaps(out_);</p>

<p>Reset();</p>

<p>fprintf(stderr, â€œPROFILE: interrupts/evictions/bytes = %d/%d/%â€ PRIuS â€œ\nâ€,</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      count_, evictions_, total_bytes_);
</code></pre></div></div>

<p>}</p>

<p>åœ¨dumpå‡ºevict_æ•°ç»„æ•°æ®ä¹‹åï¼Œå‡½æ•°è¿˜é€šè¿‡DumpProcSelfMapså°†/prof/self/mapä¸­çš„ä¿¡æ¯è¿½åŠ åˆ°è¾“å‡ºæ–‡ä»¶ä¸­ï¼Œè¿™ äº›ä¿¡æ¯è®°å½•äº†åº”ç”¨ç¨‹åºçš„å†…å­˜æ˜ å°„æƒ…å†µï¼Œæ˜¯pprofå·¥å…·è§£ææŒ‡ä»¤ç¬¦å·çš„é‡è¦ä¾æ®ã€‚ï¼ˆå…³äº/prof/self/mapä¸­çš„ä¿¡æ¯è¯´æ˜å¯ä»¥å‚è€ƒã€Šç¨‹åºå‘˜çš„è‡ªæˆ‘ ä¿®å…»ã€‹ï¼‰</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   è™½ç„¶ç›‘æ§ç¨‹åºå·²ç»åœæ­¢ï¼Œä½†æ˜¯CPUprofilerçš„å·¥ä½œè¿˜æ²¡å®Œå…¨ç»“æŸï¼Œå› ä¸ºä¹‹å‰ä¿å­˜åœ¨$CPUPROFILERæ–‡ä»¶ä¸­çš„æ•°æ®éƒ½æ˜¯äºŒè¿›åˆ¶æ ¼å¼çš„ï¼Œä¸å…·å¤‡å¯è¯»æ€§ï¼Œéœ€è¦å€ŸåŠ©pprofå·¥å…·çš„è§£æåŠŸèƒ½æ‰èƒ½æ­éœ²å®ƒçš„çœŸå®ä¿¡æ¯ã€‚

   pprofæ˜¯ç”¨perlè¯­è¨€ç¼–å†™çš„è§£æå·¥å…·ï¼Œå®ƒçš„ä¸»è¦åŠŸèƒ½å°±æ˜¯å°†CPU profileçš„è¾“å‡ºæ•°æ®è½¬æ¢æˆå®¹æ˜“é˜…è¯»ç†è§£çš„å¯è§†æ ¼å¼ï¼Œå¦‚textã€pdfã€gifç­‰ï¼Œæ¥ä¸‹æ¥æœ¬æ–‡å°†è®²è§£pprofçš„ä¸»è¦å·¥ä½œåŸç†ï¼Œå…·ä½“ç»†èŠ‚å¯ä»¥å‚è€ƒpprofä»£ç ã€‚

  $CPUPROFILERæ–‡ä»¶ä¸­ä¿å­˜äº†ä¸¤éƒ¨åˆ†ä¿¡æ¯ï¼šå‰éƒ¨åˆ†æ˜¯å®šæœŸdumpçš„è°ƒç”¨æ ˆä¿¡æ¯ï¼Œæ¯ä¸ªè°ƒç”¨æ ˆä¿¡æ¯ä¸­éƒ½åŒ…å«äº†æ‰§è¡Œæ¬¡æ•°ã€æ ˆæ·±åº¦ä»¥åŠ æ ˆæŒ‡é’ˆå€¼ï¼ˆå³æŒ‡ä»¤åœ°å€ï¼‰ï¼›ååŠéƒ¨åˆ†è®°å½•åº”ç”¨ç¨‹åºçš„å†…å­˜æ˜ å°„å›¾ã€‚æ‰€ä»¥ç¬¬ä¸€æ­¥ï¼Œpprofæ ¹æ®å†…å­˜æ˜ å°„å›¾å’Œç¨‹åºç¬¦å·è¡¨å°†è°ƒç”¨æ ˆä¸­çš„æŒ‡ä»¤åœ°å€ç¿»è¯‘æˆå®¹æ˜“ç†è§£çš„ç¨‹ åºä»£ç ï¼›ç¬¬äºŒæ­¥ï¼Œpprofæ ¹æ®ç¬¬ä¸€éƒ¨åˆ†ä¿å­˜çš„æ ˆä¿¡æ¯æè¿°å‡ºç¨‹åºä¸­çš„å‡½æ•°è°ƒç”¨å›¾ï¼›æœ€åä¸€æ­¥ï¼Œpprofæ ¹æ®æ ˆæ‰§è¡Œæ¬¡æ•°è®¡ç®—å‡ºæ¯æ®µä»£ç çš„æ‰§è¡Œæ¬¡æ•°ï¼Œå†æ ¹æ®å®š æ—¶å™¨çš„æ‰§è¡Œé¢‘ç‡ä¼°ç®—å‡ºç¨‹åºæ®µçš„æ‰§è¡Œæ—¶é—´ï¼Œè¿›è€Œæ‰¾å‡ºç¨‹åºçš„æ€§èƒ½çƒ­ç‚¹ã€‚
</code></pre></div></div>

<p>2.4        å°ç»“
       Google performance toolsé‡‡ç”¨äº†å’ŒGUNProfilerè¿‘ä¼¼çš„åŸç†ã€ä¸åŒçš„æ–¹å¼æ¥è¾¾åˆ°profilerçš„æ•ˆæœã€‚ç”±äºå…¶é€šè¿‡è®°å½•è°ƒç”¨æ ˆä¿¡æ¯æ¥åæ¨ç¨‹åºæ®µçš„æ‰§è¡Œæ¬¡æ•°ï¼Œä¸å¯ é¿å…åœ°ä¼šå‡ºç°é—æ¼å’Œè¯¯ç®—æƒ…å†µï¼Œè€Œä¸”å’ŒGUNProfilerä¸€æ ·ï¼Œå®ƒä¹Ÿæ˜¯é€šè¿‡sampleçš„é‡‡æ ·é¢‘ç‡æ¥ä¼°ç®—ç¨‹åºæ®µçš„è¿è¡Œæ—¶é—´ï¼Œå› æ­¤æœ€ç»ˆè®¡ç®—ç»“æœå¹¶ä¸æ˜¯ååˆ† ç²¾ç¡®çš„ï¼Œå…·æœ‰ä¸€å®šçš„è¯¯å·®ã€‚ä½†æ˜¯ï¼ŒGoogle performance toolsè¾ƒä¹‹å…¶ä»–Profilerå·¥å…·è€Œè¨€ï¼Œæœ‰å…¶è‡ªèº«çš„ç‰¹ç‚¹å’Œä¼˜åŠ¿ï¼ŒGoogleperformance toolsæ˜¯ä¸€ä¸ªç”¨æˆ·æ€ç¨‹åºï¼Œä¸éœ€è¦å†…æ ¸æä¾›æ”¯æŒï¼ˆå¯¹æ¯”oprofilerï¼‰ï¼›å®ƒå¯¹è¢«ç›‘æ§ç¨‹åºçš„å…¥ä¾µç¨‹åºåº¦è¾ƒå°ï¼ˆå¯¹æ¯”GUNProfilerï¼‰ï¼Œæ— éœ€ä¿®æ”¹ ç¨‹åºä»£ç ï¼Œä»¥attachçš„æ–¹å¼è·Ÿè¸ªç¨‹åºæ‰§è¡ŒçŠ¶æ€ï¼›è€Œä¸”å®ƒä¹Ÿæ˜¯googleçš„å¼€æºé¡¹ç›®ä¹‹ä¸€ï¼Œå·¥ç¨‹é‡è¾ƒå°ï¼Œæ–¹é¢åæœŸæ‰©å±•å’ŒäºŒæ¬¡å¼€å‘ã€‚</p>

<p>ä¸‰ã€       C++ Profilerå·¥å…·ç‰¹æ€§å¯¹æ¯”
æ€»ç»“å‰ä¸¤ç« çš„è°ƒç ”ç»“æœï¼Œå¯¹ç›®å‰å¸¸ç”¨çš„C++ profilerå·¥å…·åšäº†ä¸€ä¸ªç®€å•çš„å¯¹æ¯”ï¼Œå¯¹æ¯”çš„ç„¦ç‚¹ä¸»è¦é›†ä¸­åœ¨æ—¥å¸¸ä½¿ç”¨ä¸­å¤§å®¶æ‰€å‘ç°æˆ–æ¯”è¾ƒå…³æ³¨çš„é—®é¢˜ã€‚ä¸è¿‡ç”±äºæ—¶é—´å…³ç³»ï¼Œæ‰€é€‰å·¥å…·å’Œå¯¹æ¯”é¡¹éƒ½ååˆ†æœ‰é™ï¼Œå¸Œæœ›èƒ½åœ¨åæœŸçš„è¿›ä¸€æ­¥å·¥ä½œä¸­å®Œå–„è¡¥å……ã€‚</p>

<p>C++Profilerå·¥å…·</p>

<p>ç²¾ç¡®åº¦</p>

<p>å¯¹åŠ¨æ€åº“çš„æ”¯æŒ</p>

<p>å¯¹åŠ¨æ€æ§åˆ¶çš„æ”¯æŒ</p>

<p>äºŒæ¬¡å¼€å‘å’Œç»´æŠ¤æˆæœ¬</p>

<p>GUN profile</p>

<p>è¾ƒé«˜ï¼Œå¯¹å‡½æ•°æ‰§è¡Œæ¬¡æ•°çš„ç»Ÿè®¡æ˜¯100%æ­£ç¡®çš„ï¼Œä½†æ˜¯å¯¹å‡½æ•°æ‰§è¡Œæ—¶é—´çš„ç»Ÿè®¡æ˜¯é€šè¿‡é‡‡æ ·å¹³ç‡ä¼°ç®—çš„ï¼Œå­˜åœ¨ä¸€å®šçš„åå·®ã€‚</p>

<p>No</p>

<p>ç¼–è¯‘æ—¶å†³å®šï¼Œçµæ´»æ€§è¾ƒå·®</p>

<p>ä»£ç é›†æˆåœ¨glibcä¸­ï¼ŒäºŒæ¬¡å¼€å‘å’Œä¿®æ”¹çš„å½±å“é¢è¾ƒå¤§ï¼Œè€Œä¸”å‘å¸ƒä¸æ˜“ã€‚</p>

<p>Google performance tools</p>

<p>ä¸€èˆ¬ï¼Œå¯¹å‡½æ•°æ¬¡æ•°å’Œæ‰§è¡Œæ—¶é—´çš„ç»Ÿè®¡éƒ½æ˜¯é€šè¿‡é‡‡æ ·é¢‘ç‡ä¼°ç®—çš„ï¼Œå­˜åœ¨ä¸€å®šçš„åå·®å’Œé—æ¼ã€‚</p>

<p>Yes</p>

<p>è¿è¡Œæ—¶æ§åˆ¶ï¼Œæ›´æ–¹é¢æ“ä½œ</p>

<p>ç‹¬ç«‹çš„ç¬¬ä¸‰æ–¹åº“ï¼Œå¼€æºé¡¹ç›®ï¼ŒäºŒæ¬¡å¼€å‘å’Œç»´æŠ¤æˆæœ¬è¾ƒä½ã€‚</p>

<p>Oprofile</p>

:ET