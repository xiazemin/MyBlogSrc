I"ÛA<p>https://mp.weixin.qq.com/s/FdAQlSsXCYOiBHKbgsGepQ
å®¢æˆ·ç«¯äº¤äº’</p>

<p>åœ¨ç¬¬ä¸€ç¯‡æ–‡ç« ä¸­æˆ‘ä»¬ç®€è¦è®¨è®ºäº†å®¢æˆ·ç«¯äº¤äº’ï¼Œå¦‚æœä¸æ¸…æ™°å»ºè®®å¯ä»¥å†å›é¡¾ä¸€ä¸‹ã€‚è¿™é‡Œæˆ‘ä»¬å…ˆä¸å…³æ³¨å®¢æˆ·ç«¯å¦‚ä½•æ‰¾åˆ°é¢†å¯¼è€…ï¼Œå°†é‡ç‚¹è®¨è®ºå½“æ‰¾åˆ°ä¸€ä¸ªé¢†å¯¼è€…æ—¶ä¼šå‘ç”Ÿä»€ä¹ˆã€‚</p>

<p>é¦–å…ˆï¼Œå®¢æˆ·ç«¯å°†å‘½ä»¤æäº¤ç»™é¢†å¯¼è€…ã€‚åœ¨Rafté›†ç¾¤ä¸­ï¼Œå‘½ä»¤é€šå¸¸åªæäº¤ç»™å•ä¸ªèŠ‚ç‚¹ã€‚</p>

<p>é¢†å¯¼è€…å°†å‘½ä»¤å¤åˆ¶åˆ°å…¶è·Ÿéšè€…ã€‚</p>

<p>æœ€åï¼Œå¦‚æœå¤§å¤šæ•°é›†ç¾¤èŠ‚ç‚¹éƒ½æ‰¿è®¤åœ¨å…¶æ—¥å¿—ä¸­æœ‰è¯¥å‘½ä»¤ï¼Œè¯¥å‘½ä»¤å°†è¢«æäº¤ï¼Œå¹¶å‘æ‰€æœ‰å®¢æˆ·ç«¯é€šçŸ¥æ–°çš„æäº¤ã€‚</p>

<p>æ³¨æ„æäº¤å’Œæäº¤å‘½ä»¤ä¹‹é—´çš„ä¸å¯¹ç§°æ€§ - åœ¨æ£€æŸ¥æˆ‘ä»¬å³å°†è®¨è®ºçš„å®ç°å†³ç­–æ—¶ï¼Œè¿™ä¸€ç‚¹å¾ˆé‡è¦ã€‚å‘½ä»¤è¢«æäº¤åˆ°å•ä¸ªRaftèŠ‚ç‚¹ï¼Œä½†æ˜¯å¤šä¸ªèŠ‚ç‚¹ï¼ˆç‰¹åˆ«æ˜¯æ‰€æœ‰å·²è¿æ¥/æ´»åŠ¨çš„èŠ‚ç‚¹å•Šï¼‰ä¼šåœ¨ä¸€æ®µæ—¶é—´åå°†å…¶æäº¤å¹¶é€šçŸ¥å…¶å®¢æˆ·ç«¯ã€‚
<!-- more -->
çŠ¶æ€æœºä»£è¡¨ä½¿ç”¨Raftè¿›è¡Œå¤åˆ¶çš„ä»»æ„æœåŠ¡ã€‚</p>

<p>ç„¶åæˆ‘ä»¬åœ¨Raft ConsensusModuleæ¨¡å—çš„ä¸Šä¸‹æ–‡ä¸­è®¨è®ºå®¢æˆ·ç«¯ï¼Œæˆ‘ä»¬é€šå¸¸æŒ‡çš„æ˜¯æ­¤æœåŠ¡ï¼Œå› ä¸ºè¿™æ˜¯å°†æäº¤æŠ¥å‘Šåˆ°çš„åœ°æ–¹ã€‚æ¢å¥è¯è¯´ï¼Œä»Consensusæ¨¡å—åˆ°æœåŠ¡çŠ¶æ€æœºçš„é»‘è‰²ç®­å¤´å°±æ˜¯è¯¥é€šçŸ¥ã€‚</p>

<p>2</p>

<p>å®ç°ï¼šæäº¤ç®¡é“</p>

<p>åœ¨æˆ‘ä»¬çš„å®ç°ä¸­ï¼Œå½“ä¸€ä¸ª ConsensusModule è¢«åˆ›å»ºæ—¶ï¼Œå®ƒæ¥å—ä¸€ä¸ªæäº¤ç®¡é“ - ä¸€ä¸ªç”¨æ¥å‘è°ƒç”¨è€…å‘é€æäº¤å‘½ä»¤çš„é€šé“ï¼šcommitChan chan&lt;-CommitEntryã€‚å®šä¹‰å¦‚ä¸‹ï¼š</p>

<p>// CommitEntry is the data reported by Raft to the commit channel. Each commit
// entry notifies the client that consensus was reached on a command and it can
// be applied to the clientâ€™s state machine.
type CommitEntry struct {
  // Command is the client command being committed.
  Command interface{}</p>

<p>// Index is the log index at which the client command is committed.
  Index int</p>

<p>// Term is the Raft term at which the client command is committed.
  Term int
}
ä½¿ç”¨é€šé“æ˜¯ä¸€ç§è®¾è®¡é€‰æ‹©ï¼Œä½†ä¸æ˜¯å”¯ä¸€æ–¹å¼ã€‚ä¹Ÿå¯ä»¥æ”¹ç”¨å›è°ƒã€‚åˆ›å»ºConsensusModuleæ—¶ï¼Œè°ƒç”¨è€…å°†æ³¨å†Œä¸€ä¸ªå›è°ƒå‡½æ•°ï¼Œåªè¦æœ‰è¦æäº¤çš„å‘½ä»¤ï¼Œå°±ä¼šè°ƒç”¨è¯¥å›è°ƒå‡½æ•°ã€‚</p>

<p>åœ¨å®ç°é€šé“ä¸Šå‘é€æ¡ç›®çš„åŠŸèƒ½ä¹‹å‰ã€‚æˆ‘ä»¬éœ€è¦å…ˆè®¨è®ºRaftæœåŠ¡å™¨å¦‚ä½•å¤åˆ¶å‘½ä»¤å¹¶ç¡®å®šå‘½ä»¤æ˜¯å¦å·²æäº¤ã€‚</p>

<p>3</p>

<p>Raftæ—¥å¿—</p>

<p>åœ¨æ–‡ç« ä¸­å¤šæ¬¡æåˆ°Raftæ—¥å¿—ï¼Œä½†è¿˜æ²¡æœ‰è¯¦ç»†ä»‹ç»ã€‚æ—¥å¿—åªæ˜¯åº”è¯¥åº”ç”¨äºçŠ¶æ€æœºçš„çº¿æ€§å‘½ä»¤åºåˆ—ï¼›å¦‚æœæœ‰éœ€è¦ï¼Œæ—¥å¿—åº”è¯¥è¶³ä»¥ä»æŸä¸ªå¼€å§‹çŠ¶æ€â€œé‡æ”¾â€çŠ¶æ€æœºã€‚åœ¨æ­£å¸¸è¿è¡ŒæœŸé—´ï¼Œæ‰€æœ‰RaftèŠ‚ç‚¹çš„æ—¥å¿—éƒ½æ˜¯ç›¸åŒçš„ï¼›å½“é¢†å¯¼è€…æ”¶åˆ°æ–°å‘½ä»¤æ—¶ï¼Œå°†å…¶å­˜æ”¾åœ¨è‡ªå·±çš„æ—¥å¿—ä¸­ï¼Œç„¶åå¤åˆ¶åˆ°è·Ÿéšè€…ã€‚è·Ÿéšè€…å°†å‘½ä»¤æ”¾åœ¨æ—¥å¿—ä¸­ï¼Œå¹¶ç¡®è®¤ç»™é¢†å¯¼è€…ï¼Œé¢†å¯¼è€…å°†ä¿ç•™å·²å®‰å…¨å¤åˆ¶åˆ°ç¾¤é›†ä¸­å¤§å¤šæ•°æœåŠ¡å™¨çš„æœ€æ–°æ—¥å¿—ç´¢å¼•çš„è®¡æ•°ã€‚</p>

<p>æ¯ä¸ªæ¡†éƒ½æ˜¯ä¸€ä¸ªæ—¥å¿—æ¡ç›®ï¼›æ¡†é¡¶éƒ¨çš„æ•°å­—æ˜¯å°†å…¶æ·»åŠ åˆ°æ—¥å¿—ä¸­çš„ä»»æœŸã€‚åº•éƒ¨æ˜¯æ­¤æ—¥å¿—åŒ…å«çš„é”®å€¼å‘½ä»¤ã€‚æ¯ä¸ªæ—¥å¿—æ¡ç›®éƒ½æœ‰ä¸€ä¸ªçº¿æ€§ç´¢å¼•ã€‚æ¡†çš„é¢œè‰²æ˜¯ä»»æœŸçš„å¦ä¸€ç§è¡¨ç¤ºå½¢å¼ã€‚</p>

<p>å¦‚æœå°†æ­¤æ—¥å¿—åº”ç”¨äºç©ºé”®å€¼å­˜å‚¨ï¼Œåˆ™æœ€ç»ˆç»“æœå°†å…·æœ‰å€¼x = 4ï¼Œy = 7ã€‚</p>

<p>åœ¨æˆ‘ä»¬çš„å®ç°ä¸­ï¼Œæ—¥å¿—æ¡ç›®ç”±ä»¥ä¸‹å½¢å¼è¡¨ç¤ºï¼š</p>

<p>type LogEntry struct {
  Command interface{}
  Term    int
}
æ¯ä¸ªConsensusModuleçš„æ—¥å¿—éƒ½åªæ˜¯log []LogEntryã€‚ç”¨æˆ·ç«¯é€šå¸¸ä¸åœ¨ä¹ä»»æœŸã€‚ä»»æœŸå¯¹Raftçš„æ­£ç¡®æ€§è‡³å…³é‡è¦ï¼Œåœ¨é˜…è¯»ä»£ç æ—¶åŠ¡å¿…ç‰¢è®°ã€‚</p>

<p>4</p>

<p>æäº¤æ–°çš„å‘½ä»¤</p>

<p>æ–°çš„Submitæ–¹æ³•ï¼Œä½¿å®¢æˆ·ç«¯å¯ä»¥æäº¤æ–°å‘½ä»¤ï¼š</p>

<p>func (cm *ConsensusModule) Submit(command interface{}) bool {
  cm.mu.Lock()
  defer cm.mu.Unlock()</p>

<p>cm.dlog(â€œSubmit received by %v: %vâ€, cm.state, command)
  if cm.state == Leader {
    cm.log = append(cm.log, LogEntry{Command: command, Term: cm.currentTerm})
    cm.dlog(â€œâ€¦ log=%vâ€, cm.log)
    return true
  }
  return false
}
å¾ˆç®€å•ï¼Œå¦‚æœæ­¤CMæ˜¯é¢†å¯¼è€…ï¼Œåˆ™å°†æ–°å‘½ä»¤é™„åŠ åˆ°æ—¥å¿—ä¸­å¹¶è¿”å›trueã€‚å¦åˆ™ï¼Œå°†è¢«å¿½ç•¥å¹¶è¿”å›falseã€‚</p>

<p>é—®ï¼šâ€œæäº¤â€è¿”å›çš„çœŸå®å€¼æ˜¯å¦è¡¨æ˜å®¢æˆ·ç«¯å·²å‘é¢†å¯¼è€…æäº¤äº†å‘½ä»¤ï¼Ÿ</p>

<p>ç­”ï¼šåœ¨æå°‘æ•°æƒ…å†µä¸‹ï¼Œé¢†å¯¼è€…å¯èƒ½ä¼šä¸å…¶ä»–RaftæœåŠ¡å™¨åˆ†å¼€ï¼Œè€Œåè€…åœ¨ä¸€æ®µæ—¶é—´åä¼šç»§ç»­é€‰ä¸¾æ–°çš„é¢†å¯¼è€…ã€‚ä½†æ˜¯ï¼Œå®¢æˆ·å¯èƒ½ä»åœ¨ä¸æ—§çš„é¢†å¯¼è€…é€šä¿¡ã€‚å®¢æˆ·ç«¯åº”ç­‰å¾…ä¸€æ®µåˆç†çš„æ—¶é—´ï¼Œä»¥ä½¿å…¶æäº¤çš„å‘½ä»¤å‡ºç°åœ¨æäº¤é€šé“ä¸Šï¼›å¦‚æœä¸æ˜¯ï¼Œåˆ™è¡¨ç¤ºå®ƒè”ç³»äº†é”™è¯¯çš„é¢†å¯¼è€…ï¼Œåº”ä¸å…¶ä»–é¢†å¯¼è€…é‡è¯•ã€‚</p>

<p>5</p>

<p>å¤åˆ¶æ—¥å¿—æ¡ç›®</p>

<p>æˆ‘ä»¬çœ‹åˆ°ï¼Œæäº¤ç»™é¢†å¯¼è€…çš„æ–°å‘½ä»¤è¢«æ·»åŠ åˆ°æ—¥å¿—çš„æœ«å°¾ã€‚è¿™ä¸ªæ–°å‘½ä»¤å¦‚ä½•åˆ°è¾¾è·Ÿéšè€…ï¼Ÿé¢†å¯¼è€…éµå¾ªçš„æ­¥éª¤åœ¨Raftè®ºæ–‡ä¸­è¿›è¡Œäº†ç²¾ç¡®æè¿°ã€‚æˆ‘ä»¬åœ¨ leaderSendHeartbeats ä¸­å®Œæˆå®ç°ã€‚</p>

<p>func (cm *ConsensusModule) leaderSendHeartbeats() {
  cm.mu.Lock()
  savedCurrentTerm := cm.currentTerm
  cm.mu.Unlock()</p>

<p>for _, peerId := range cm.peerIds {
    go func(peerId int) {
      cm.mu.Lock()
      ni := cm.nextIndex[peerId]
      prevLogIndex := ni - 1
      prevLogTerm := -1
      if prevLogIndex &gt;= 0 {
        prevLogTerm = cm.log[prevLogIndex].Term
      }
      entries := cm.log[ni:]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  args := AppendEntriesArgs{
    Term:         savedCurrentTerm,
    LeaderId:     cm.id,
    PrevLogIndex: prevLogIndex,
    PrevLogTerm:  prevLogTerm,
    Entries:      entries,
    LeaderCommit: cm.commitIndex,
  }
  cm.mu.Unlock()
  cm.dlog("sending AppendEntries to %v: ni=%d, args=%+v", peerId, ni, args)
  var reply AppendEntriesReply
  if err := cm.server.Call(peerId, "ConsensusModule.AppendEntries", args, &amp;reply); err == nil {
    cm.mu.Lock()
    defer cm.mu.Unlock()
    if reply.Term &gt; savedCurrentTerm {
      cm.dlog("term out of date in heartbeat reply")
      cm.becomeFollower(reply.Term)
      return
    }

    if cm.state == Leader &amp;&amp; savedCurrentTerm == reply.Term {
      if reply.Success {
        cm.nextIndex[peerId] = ni + len(entries)
        cm.matchIndex[peerId] = cm.nextIndex[peerId] - 1
        cm.dlog("AppendEntries reply from %d success: nextIndex := %v, matchIndex := %v", peerId, cm.nextIndex, cm.matchIndex)

        savedCommitIndex := cm.commitIndex
        for i := cm.commitIndex + 1; i &lt; len(cm.log); i++ {
          if cm.log[i].Term == cm.currentTerm {
            matchCount := 1
            for _, peerId := range cm.peerIds {
              if cm.matchIndex[peerId] &gt;= i {
                matchCount++
              }
            }
            if matchCount*2 &gt; len(cm.peerIds)+1 {
              cm.commitIndex = i
            }
          }
        }
        if cm.commitIndex != savedCommitIndex {
          cm.dlog("leader sets commitIndex := %d", cm.commitIndex)
          cm.newCommitReadyChan &lt;- struct{}{}
        }
      } else {
        cm.nextIndex[peerId] = ni - 1
        cm.dlog("AppendEntries reply from %d !success: nextIndex := %d", peerId, ni-1)
      }
    }
  }
}(peerId)   } } è¿™æ¯”æˆ‘ä»¬åœ¨ä¸Šä¸€éƒ¨åˆ†ä¸­æ‰€åšçš„è¦å¤æ‚å¾—å¤šï¼Œä½†å®é™…ä¸Šå®ƒä»…éµå¾ªæœ¬æ–‡çš„å›¾2ã€‚å…³äºæ­¤ä»£ç çš„ä¸€äº›æ³¨æ„äº‹é¡¹ï¼š
</code></pre></div></div>

<p>ç°åœ¨å·²å®Œå…¨å¡«å……äº†AE RPCçš„å­—æ®µï¼šæœ‰å…³å…¶å«ä¹‰ï¼Œè¯·å‚è§æœ¬æ–‡ä¸­çš„å›¾2ã€‚</p>

<p>AEå“åº”æœ‰ä¸€ä¸ª success å­—æ®µï¼Œè¯¥å­—æ®µå‘Šè¯‰é¢†å¯¼è€…è·Ÿéšè€…æ˜¯å¦çœ‹åˆ°prevLogIndex å’Œ prevLogTerm åŒ¹é…ã€‚é¢†å¯¼è€…åŸºäºæ­¤å­—æ®µæ›´æ–°æ­¤è·Ÿéšè€…çš„nextIndexã€‚</p>

<p>commitIndex æ ¹æ®å¤åˆ¶ç‰¹å®šæ—¥å¿—ç´¢å¼•çš„å…³æ³¨è€…çš„æ•°é‡è¿›è¡Œæ›´æ–°ã€‚å¦‚æœç´¢å¼•è¢«å¤šæ•°å¤åˆ¶ï¼Œåˆ™ commitIndex å‰è¿›åˆ°è¯¥ç´¢å¼•ã€‚</p>

<p>ä¸æˆ‘ä»¬ä¹‹å‰è®¨è®ºçš„ç”¨æˆ·ç«¯äº¤äº’æœ‰å…³ï¼Œè¿™éƒ¨åˆ†ä»£ç ç‰¹åˆ«é‡è¦ï¼š</p>

<p>if cm.commitIndex != savedCommitIndex {
  cm.dlog(â€œleader sets commitIndex := %dâ€, cm.commitIndex)
  cm.newCommitReadyChan &lt;- struct{}{}
}
newCommitReadyChan æ˜¯CMå†…éƒ¨ä½¿ç”¨çš„é€šé“ï¼Œç”¨äºæŒ‡ç¤ºå·²å‡†å¤‡å¥½å°†æ–°æ¡ç›®é€šè¿‡æäº¤é€šé“å‘é€åˆ°å®¢æˆ·ç«¯ã€‚å®ƒç”±åœ¨CMå¯åŠ¨æ—¶åœ¨goroutineä¸­è¿è¡Œçš„ä»¥ä¸‹æ–¹æ³•èµ·ä½œç”¨ï¼š</p>

<p>func (cm *ConsensusModule) commitChanSender() {
  for range cm.newCommitReadyChan {
    // Find which entries we have to apply.
    cm.mu.Lock()
    savedTerm := cm.currentTerm
    savedLastApplied := cm.lastApplied
    var entries []LogEntry
    if cm.commitIndex &gt; cm.lastApplied {
      entries = cm.log[cm.lastApplied+1 : cm.commitIndex+1]
      cm.lastApplied = cm.commitIndex
    }
    cm.mu.Unlock()
    cm.dlog(â€œcommitChanSender entries=%v, savedLastApplied=%dâ€, entries, savedLastApplied)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i, entry := range entries {
  cm.commitChan &lt;- CommitEntry{
    Command: entry.Command,
    Index:   savedLastApplied + i + 1,
    Term:    savedTerm,
  }
}   }   cm.dlog("commitChanSender done") } æ­¤æ–¹æ³•æ›´æ–° lastApplied çŠ¶æ€å˜é‡ä»¥ç¡®å®šå“ªäº›æ¡ç›®å·²ç»å‘é€åˆ°å®¢æˆ·ç«¯ï¼Œå¹¶ä¸”ä»…å‘é€æ–°æ¡ç›®ã€‚
</code></pre></div></div>

<p>6</p>

<p>æ›´æ–°è·Ÿéšè€…çš„æ—¥å¿—</p>

<p>æˆ‘ä»¬å·²ç»çœ‹åˆ°äº†é¢†å¯¼è€…å¦‚ä½•å¤„ç†æ–°çš„æ—¥å¿—æ¡ç›®ã€‚ç°åœ¨ä»‹ç»è·Ÿéšè€…çš„ä»£ç å®ç°ã€‚ç‰¹åˆ«æ˜¯ AppendEntries RPCã€‚</p>

<p>func (cm *ConsensusModule) AppendEntries(args AppendEntriesArgs, reply *AppendEntriesReply) error {
  cm.mu.Lock()
  defer cm.mu.Unlock()
  if cm.state == Dead {
    return nil
  }
  cm.dlog(â€œAppendEntries: %+vâ€, args)</p>

<p>if args.Term &gt; cm.currentTerm {
    cm.dlog(â€œâ€¦ term out of date in AppendEntriesâ€)
    cm.becomeFollower(args.Term)
  }</p>

<p>reply.Success = false
  if args.Term == cm.currentTerm {
    if cm.state != Follower {
      cm.becomeFollower(args.Term)
    }
    cm.electionResetEvent = time.Now()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Does our log contain an entry at PrevLogIndex whose term matches
// PrevLogTerm? Note that in the extreme case of PrevLogIndex=-1 this is
// vacuously true.
if args.PrevLogIndex == -1 ||
  (args.PrevLogIndex &lt; len(cm.log) &amp;&amp; args.PrevLogTerm == cm.log[args.PrevLogIndex].Term) {
  reply.Success = true

  // Find an insertion point - where there's a term mismatch between
  // the existing log starting at PrevLogIndex+1 and the new entries sent
  // in the RPC.
  logInsertIndex := args.PrevLogIndex + 1
  newEntriesIndex := 0

  for {
    if logInsertIndex &gt;= len(cm.log) || newEntriesIndex &gt;= len(args.Entries) {
      break
    }
    if cm.log[logInsertIndex].Term != args.Entries[newEntriesIndex].Term {
      break
    }
    logInsertIndex++
    newEntriesIndex++
  }
  // At the end of this loop:
  // - logInsertIndex points at the end of the log, or an index where the
  //   term mismatches with an entry from the leader
  // - newEntriesIndex points at the end of Entries, or an index where the
  //   term mismatches with the corresponding log entry
  if newEntriesIndex &lt; len(args.Entries) {
    cm.dlog("... inserting entries %v from index %d", args.Entries[newEntriesIndex:], logInsertIndex)
    cm.log = append(cm.log[:logInsertIndex], args.Entries[newEntriesIndex:]...)
    cm.dlog("... log is now: %v", cm.log)
  }

  // Set commit index.
  if args.LeaderCommit &gt; cm.commitIndex {
    cm.commitIndex = intMin(args.LeaderCommit, len(cm.log)-1)
    cm.dlog("... setting commitIndex=%d", cm.commitIndex)
    cm.newCommitReadyChan &lt;- struct{}{}
  }
}   }
</code></pre></div></div>

<p>reply.Term = cm.currentTerm
  cm.dlog(â€œAppendEntries reply: %+vâ€, *reply)
  return nil
}
å½“æ³¨æ„åˆ°é¢†å¯¼è€…çš„ LeaderCommit å¤§äºå…¶è‡ªå·±çš„ cm.commitIndex æ—¶ï¼Œè·Ÿéšè€…çŸ¥é“é¢†å¯¼è€…è€ƒè™‘æäº¤é¢å¤–çš„æ¡ç›®æ—¶ï¼Œå°†åœ¨ ch.newCommitReadyChan ä¸Šå‘é€ã€‚</p>

<p>å½“é¢†å¯¼è€…ä½¿ç”¨AEå‘é€æ–°çš„æ—¥å¿—æ¡ç›®æ—¶ï¼Œå°†å‘ç”Ÿä»¥ä¸‹æƒ…å†µï¼š</p>

<p>è·Ÿéšè€…å°†æ–°æ¡ç›®è¿½åŠ åˆ°å…¶æ—¥å¿—ä¸­ï¼Œå¹¶å‘é¢†å¯¼è€…å›å¤success = trueã€‚</p>

<p>ç»“æœï¼Œé¢†å¯¼è€…ä¸ºæ­¤è·Ÿéšè€…æ›´æ–°å…¶matchIndexã€‚å½“è¶³å¤Ÿçš„è·Ÿéšè€…çš„ä¸‹ä¸€ä¸ªç´¢å¼•å…·æœ‰matchIndexæ—¶ï¼Œé¢†å¯¼è€…å°†æ›´æ–°commitIndexå¹¶å°†å…¶å‘é€ç»™ä¸‹ä¸€ä¸ªAEä¸­çš„æ‰€æœ‰è·Ÿéšè€…ï¼ˆåœ¨leaderCommitå­—æ®µä¸­ï¼‰ã€‚</p>

<p>å½“è·Ÿéšè€…æ”¶åˆ°æ–°çš„LeaderCommitæ¶ˆæ¯æ—¶ï¼Œå·²ç»çŸ¥é“æäº¤äº†æ–°çš„æ—¥å¿—æ¡ç›®ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡æäº¤é€šé“å°†å…¶å‘é€ç»™å…¶ç”¨æˆ·ç«¯ã€‚</p>

<p>7</p>

<p>é€‰ä¸¾å®‰å…¨</p>

<p>ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬å·²ç»ç ”ç©¶äº†æ·»åŠ çš„æ–°ä»£ç ä»¥æ”¯æŒæ—¥å¿—å¤åˆ¶ã€‚ä½†æ˜¯ï¼Œæ—¥å¿—ä¹Ÿä¼šå½±å“Raftçš„é€‰ä¸¾ã€‚Raftä½¿ç”¨é€‰ä¸¾ç¨‹åºæ¥é˜²æ­¢å€™é€‰äººèµ¢å¾—é€‰ä¸¾ï¼Œé™¤éå…¶æ—¥å¿—è‡³å°‘ä¸é›†ç¾¤ä¸­å¤§å¤šæ•°èŠ‚ç‚¹çš„æ—¥å¿—ä¸€æ ·ã€‚</p>

<p>å› æ­¤ï¼ŒRVåŒ…å«lastLogIndexå’ŒlastLogTermå­—æ®µã€‚å½“å€™é€‰äººå‘å‡ºRVæ—¶ï¼Œå°†ä½¿ç”¨æœ‰å…³å…¶æœ€åä¸€ä¸ªæ—¥å¿—æ¡ç›®çš„ä¿¡æ¯å¡«å……è¿™äº›RVã€‚è·Ÿéšè€…å°†è¿™äº›å­—æ®µä¸è‡ªå·±çš„å­—æ®µè¿›è¡Œæ¯”è¾ƒï¼Œå¹¶ç¡®å®šå€™é€‰äººæ˜¯å¦æ˜¯æœ€æ–°çš„æ‰å¯ä»¥è¢«é€‰ä¸¾ã€‚</p>

<p>func (cm *ConsensusModule) startElection() {
  cm.state = Candidate
  cm.currentTerm += 1
  savedCurrentTerm := cm.currentTerm
  cm.electionResetEvent = time.Now()
  cm.votedFor = cm.id
  cm.dlog(â€œbecomes Candidate (currentTerm=%d); log=%vâ€, savedCurrentTerm, cm.log)</p>

<p>var votesReceived int32 = 1</p>

<p>// Send RequestVote RPCs to all other servers concurrently.
  for _, peerId := range cm.peerIds {
    go func(peerId int) {
      cm.mu.Lock()
      savedLastLogIndex, savedLastLogTerm := cm.lastLogIndexAndTerm()
      cm.mu.Unlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  args := RequestVoteArgs{
    Term:         savedCurrentTerm,
    CandidateId:  cm.id,
    LastLogIndex: savedLastLogIndex,
    LastLogTerm:  savedLastLogTerm,
  }

  cm.dlog("sending RequestVote to %d: %+v", peerId, args)
  var reply RequestVoteReply
  if err := cm.server.Call(peerId, "ConsensusModule.RequestVote", args, &amp;reply); err == nil {
    cm.mu.Lock()
    defer cm.mu.Unlock()
    cm.dlog("received RequestVoteReply %+v", reply)

    if cm.state != Candidate {
      cm.dlog("while waiting for reply, state = %v", cm.state)
      return
    }

    if reply.Term &gt; savedCurrentTerm {
      cm.dlog("term out of date in RequestVoteReply")
      cm.becomeFollower(reply.Term)
      return
    } else if reply.Term == savedCurrentTerm {
      if reply.VoteGranted {
        votes := int(atomic.AddInt32(&amp;votesReceived, 1))
        if votes*2 &gt; len(cm.peerIds)+1 {
          // Won the election!
          cm.dlog("wins election with %d votes", votes)
          cm.startLeader()
          return
        }
      }
    }
  }
}(peerId)   }
</code></pre></div></div>

<p>// Run another election timer, in case this election is not successful.
  go cm.runElectionTimer()
}
lastLogIndexAndTermæ˜¯ä¸€ä¸ªæ–°çš„å¸®åŠ©å™¨æ–¹æ³•ï¼š</p>

<p>// lastLogIndexAndTerm returns the last log index and the last log entryâ€™s term
// (or -1 if thereâ€™s no log) for this server.
// Expects cm.mu to be locked.
func (cm *ConsensusModule) lastLogIndexAndTerm() (int, int) {
  if len(cm.log) &gt; 0 {
    lastIndex := len(cm.log) - 1
    return lastIndex, cm.log[lastIndex].Term
  } else {
    return -1, -1
  }
}
æˆ‘ä»¬çš„å®ç°æ˜¯åŸºäº0çš„ç´¢å¼•ï¼Œè€Œä¸æ˜¯åŸºäº1çš„Raftç´¢å¼•ã€‚å› æ­¤-1ç»å¸¸ä½œä¸ºä¸€ä¸ªæ ‡è®°å€¼ã€‚</p>

<p>è¿™æ˜¯ä¸€ä¸ªæ›´æ–°çš„RVå¤„ç†ç¨‹åºï¼Œå®ç°é€‰ä¸¾å®‰å…¨æ£€æŸ¥ï¼š</p>

<p>func (cm *ConsensusModule) RequestVote(args RequestVoteArgs, reply *RequestVoteReply) error {
  cm.mu.Lock()
  defer cm.mu.Unlock()
  if cm.state == Dead {
    return nil
  }
  lastLogIndex, lastLogTerm := cm.lastLogIndexAndTerm()
  cm.dlog(â€œRequestVote: %+v [currentTerm=%d, votedFor=%d, log index/term=(%d, %d)]â€, args, cm.currentTerm, cm.votedFor, lastLogIndex, lastLogTerm)</p>

<p>if args.Term &gt; cm.currentTerm {
    cm.dlog(â€œâ€¦ term out of date in RequestVoteâ€)
    cm.becomeFollower(args.Term)
  }</p>

<p>if cm.currentTerm == args.Term &amp;&amp;
    (cm.votedFor == -1 || cm.votedFor == args.CandidateId) &amp;&amp;
    (args.LastLogTerm &gt; lastLogTerm ||
      (args.LastLogTerm == lastLogTerm &amp;&amp; args.LastLogIndex &gt;= lastLogIndex)) {
    reply.VoteGranted = true
    cm.votedFor = args.CandidateId
    cm.electionResetEvent = time.Now()
  } else {
    reply.VoteGranted = false
  }
  reply.Term = cm.currentTerm
  cm.dlog(â€œâ€¦ RequestVote reply: %+vâ€, reply)
  return nil
}
8</p>

<p>ä¸‹ä¸€æ­¥</p>

<p>åœ¨ç›®å‰çš„Raftå®ç°ä¸­ï¼Œæœ‰ä¸€ä¸ªé—®é¢˜æ˜¯æ²¡æœ‰è¿›è¡ŒæŒä¹…åŒ–æ“ä½œã€‚å¦‚æœæœåŠ¡å™¨æ•…éšœé‡å¯ï¼Œå°†ä¼šé€ æˆä¿¡æ¯ä¸¢å¤±ã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å°†åœ¨ä¸‹ä¸€éƒ¨åˆ†å¢åŠ æŒä¹…åŒ–æ“ä½œï¼Œä»¥åŠå¯¹æœ¬ç¯‡ä¸­éƒ¨åˆ†åŠŸèƒ½è¿›è¡Œä¼˜åŒ–ã€‚æ•¬è¯·å…³æ³¨ï¼</p>

<p>Raftå‚è€ƒï¼šhttps://raft.github.io/raft.pdf</p>

<p>ä»£ç å‚è€ƒï¼šhttps://github.com/eliben/raft</p>
:ET