I"ë%<p>type Hijacker interface {
	Hijack() (net.Conn, *bufio.ReadWriter, error)
}
//è¿”å›è¿æ¥æ¥å£net.Connå’ŒReadWriter,bufioè¯»å†™çš„
// Hijack lets the caller take over the connection. â€”â€“Hijackè®©è°ƒç”¨è€…ç®¡ç†è¿æ¥</p>

<p>// After a call to Hijack(), the HTTP server library</p>

<p>// will not do anything else with the connection.</p>

<p>// It becomes the callerâ€™s responsibility to manage</p>

<p>// and close the connection.</p>

<p>â€”â€”â€”â€”è°ƒç”¨Hijackåï¼ŒHTTPçš„serverä¸ä¼šå¯¹è¿æ¥åšå¤šä½™çš„å¤„ç†è®©ç”¨æˆ·è‡ªå·±ç®¡ç†å’Œå…³é—­è¿æ¥</p>

<p>å†çœ‹ä¸€ä¸‹dockerä¸­å¯¹hijackçš„ä½¿ç”¨</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     dial, err := cli.dial()  //è®¾ç½®TCP keepAliveåšé•¿è¿æ¥
// When we set up a TCP connection for hijack, there could be long periods
// of inactivity (a long running command with no output) that in certain
// network setups may cause ECONNTIMEOUT, leaving the client in an unknown
// state. Setting TCP KeepAlive on the socket connection will prohibit
// ECONNTIMEOUT unless the socket connection truly is broken
if tcpConn, ok := dial.(*net.TCPConn); ok {
	tcpConn.SetKeepAlive(true)
	tcpConn.SetKeepAlivePeriod(30 * time.Second)
}
if err != nil {
	if strings.Contains(err.Error(), "connection refused") { return fmt.Errorf("Cannot connect to the Docker daemon. Is 'docker daemon' running on this host?")
	}
	return err
}
clientconn := httputil.NewClientConn(dial, nil) 
defer clientconn.Close()
 
// Server hijacks the connection, error 'connection closed' expected
clientconn.Do(req)
 
rwc, br := clientconn.Hijack() 
//æ¸…ç†æ‰buffer è¿™æ­¥éå¸¸é‡è¦,è¿”å›è¿™ä¸ªä¸¤ä¸ªå‚æ•°å°±æ˜¯ç»™ç”¨æˆ·è‡ªå·±ç®¡ç†è¿æ¥å’Œæ•°æ®å¤„ç†
defer rwc.Close()
</code></pre></div></div>

<p>å†çœ‹çœ‹clientconn.Hijackçš„å®ç°ï¼š</p>

<p>func (cc <em>ClientConn) Hijack() (c net.Conn, r *bufio.Reader) {
	cc.lk.Lock()
	defer cc.lk.Unlock()
	c = cc.c
	r = cc.r
	cc.c = nil
	cc.r = nil
	return
}
//å°±æ˜¯åœ¨NewClientConnæ—¶å€™ä¿å­˜çš„net.Connå’Œbufio.Reader
func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn {
	if r == nil {
		r = bufio.NewReader(c)
	}
	return &amp;ClientConn{
		c:        c,
		r:        r,
		pipereq:  make(map[</em>http.Request]uint),
		writeReq: (*http.Request).Write,
	}
}
æ€»ç»“ï¼šhijackå°±æ˜¯ä¸ç”¨é‡æ–°å»ºç«‹è¿æ¥æˆ–è€…é‡æ–°æ„é€ ClientConnè®¾ç½®net.Connå’Œbufioï¼Œç„¶åä¸æ–­å¤ç”¨net.Connå’Œbufioï¼Œè‡ªå·±ç®¡ç†
<!-- more -->
Hijack()å¯ä»¥å°†HTTPå¯¹åº”çš„TCPè¿æ¥å–å‡ºï¼Œè¿æ¥åœ¨Hijack()ä¹‹åï¼ŒHTTPçš„ç›¸å…³æ“ä½œå°±ä¼šå—åˆ°å½±å“ï¼Œè°ƒç”¨æ–¹éœ€è¦è´Ÿè´£å»å…³é—­è¿æ¥ã€‚çœ‹ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚</p>

<p>func handle1(w http.ResponseWriter, r *http.Request) {
	hj, _ := w.(http.Hijacker)
	conn, buf, _ := hj.Hijack()
	defer conn.Close()
	buf.WriteString(â€œhello worldâ€)
	buf.Flush()
}</p>

<p>func handle2(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, â€œhello worldâ€)
}
é—®é¢˜æ¥äº†ï¼Œä¸Šé¢ä¸¤ä¸ªhandleæ–¹æ³•æœ‰ä»€ä¹ˆåŒºåˆ«å‘¢ï¼Ÿå¾ˆç®€å•ï¼ŒåŒæ ·æ˜¯httpè¯·æ±‚ï¼Œè¿”å›çš„ç»“æœä¸€ä¸ªéµå¾ªhttpåè®®ï¼Œä¸€ä¸ªä¸éµå¾ªã€‚</p>

<p>âœ  ~ curl -i http://localhost:9090/handle1
hello world%                                                                                                                                                                                                                            âœ  ~ curl -i http://localhost:9090/handle2
HTTP/1.1 200 OK
Date: Thu, 14 Jun 2018 07:51:31 GMT
Content-Length: 11
Content-Type: text/plain; charset=utf-8</p>

<p>hello world%
åˆ†åˆ«æ˜¯ä»¥ä¸Šä¸¤è€…çš„è¿”å›ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œhijackä¹‹åçš„è¿”å›ï¼Œè™½ç„¶bodyæ˜¯ç›¸åŒçš„ï¼Œä½†æ˜¯å®Œå…¨æ²¡æœ‰éµå¾ªhttpåè®®ã€‚ï¼ˆåºŸè¯ï¼Œåˆ«äººéƒ½è¯´äº†hijackä¹‹åè¿”å›äº†bodyç„¶åç›´æ¥å…³é—­äº†ï¼Œå“ªæ¥çš„headers = = ï¼‰</p>

<p>ä½†æˆ‘ä»¬è¿˜æ˜¯è¦çœ‹çœ‹ä¸ºå•¥..</p>

<p>func (c *conn) serve(ctx context.Context) {
	â€¦
  	serverHandler{c.server}.ServeHTTP(w, w.req)
    w.cancelCtx()
    if c.hijacked() {
      return
    }
    w.finishRequest()
  	â€¦
}
è¿™æ˜¯net/httpåŒ…ä¸­çš„æ–¹æ³•ï¼Œä¹Ÿæ˜¯httpè·¯ç”±çš„æ ¸å¿ƒæ–¹æ³•ã€‚è°ƒç”¨ServeHTTPï¼ˆä¹Ÿå°±æ˜¯ä¸Šè¾¹çš„handleæ–¹æ³•ï¼‰æ–¹æ³•ï¼Œå¦‚æœè¢«hijackäº†å°±ç›´æ¥returnäº†ï¼Œè€Œä¸€èˆ¬çš„httpè¯·æ±‚ä¼šç»è¿‡åè¾¹çš„finishRequestæ–¹æ³•ï¼ŒåŠ å…¥headersç­‰å¹¶å…³é—­è¿æ¥ã€‚
ä¸Šè¾¹æˆ‘ä»¬è¯´äº†Hijackæ–¹æ³•ï¼Œä¸€èˆ¬åœ¨åœ¨åˆ›å»ºè¿æ¥é˜¶æ®µä½¿ç”¨HTTPè¿æ¥ï¼Œåç»­è‡ªå·±å®Œå…¨å¤„ç†connectionã€‚ç¬¦åˆè¿™æ ·çš„ä½¿ç”¨åœºæ™¯çš„å¹¶ä¸å¤šï¼ŒåŸºäºHTTPåè®®çš„rpcç®—ä¸€ä¸ªï¼Œä»HTTPå‡çº§åˆ°WebSocketä¹Ÿç®—ä¸€ä¸ªã€‚</p>

<p>RPCä¸­çš„åº”ç”¨
goä¸­è‡ªå¸¦çš„rpcå¯ä»¥ç›´æ¥å¤ç”¨http serverå¤„ç†è¯·æ±‚çš„é‚£ä¸€å¥—æµç¨‹å»åˆ›å»ºè¿æ¥ï¼Œè¿æ¥åˆ›å»ºå®Œæ¯•åå†ä½¿ç”¨Hijackæ–¹æ³•æ‹¿åˆ°è¿æ¥ã€‚</p>

<p>// ServeHTTP implements an http.Handler that answers RPC requests.
func (server *server) servehttp(w http.responsewriter, req *http.request) {
	if req.method != â€œconnectâ€ {
		w.header().set(â€œcontent-typeâ€, â€œtext/plain; charset=utf-8â€)
		w.writeheader(http.statusmethodnotallowed)
		io.writestring(w, â€œ405 must connect\nâ€)
		return
	}
	conn, _, err := w.(http.hijacker).hijack()
	if err != nil {
		log.print(â€œrpc hijacking â€œ, req.remoteaddr, â€œ: â€œ, err.error())
		return
	}
	io.writestring(conn, â€œhttp/1.0 â€œ+connected+â€\n\nâ€)
	server.serveconn(conn)
}
å®¢æˆ·ç«¯é€šè¿‡å‘æœåŠ¡ç«¯å‘é€methodä¸ºconnectçš„è¯·æ±‚åˆ›å»ºè¿æ¥ï¼Œåˆ›å»ºæˆåŠŸåå³å¯å¼€å§‹rpcè°ƒç”¨ã€‚</p>

<p>websocketä¸­çš„åº”ç”¨
// ServeHTTP implements the http.Handler interface for a WebSocket
func (s Server) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	s.serveWebSocket(w, req)
}</p>

<p>func (s Server) serveWebSocket(w http.ResponseWriter, req *http.Request) {
	rwc, buf, err := w.(http.Hijacker).Hijack()
	if err != nil {
		panic(â€œHijack failed: â€œ + err.Error())
	}
	// The server should abort the WebSocket connection if it finds
	// the client did not send a handshake that matches with protocol
	// specification.
	defer rwc.Close()
	conn, err := newServerConn(rwc, buf, req, &amp;s.Config, s.Handshake)
	if err != nil {
		return
	}
	if conn == nil {
		panic(â€œunexpected nil connâ€)
	}
	s.Handler(conn)
}
websocketåœ¨åˆ›å»ºè¿æ¥çš„é˜¶æ®µä¸httpä½¿ç”¨ç›¸åŒçš„åè®®ï¼Œè€Œåœ¨åè¾¹çš„æ•°æ®ä¼ è¾“çš„è¿‡ç¨‹ä¸­ä½¿ç”¨äº†ä»–è‡ªå·±çš„åè®®ï¼Œç¬¦åˆäº†Hijackçš„ç”¨é€”ã€‚é€šè¿‡serveWebSocketæ–¹æ³•å°†HTTPåè®®å‡çº§åˆ°Websocketåè®®ã€‚</p>

<p>Grpc Stream
å†™è¿‡ä¸€äº› Grpc çš„åŒå­¦åº”è¯¥éƒ½äº†è§£ï¼Œåœ¨ GRPC ä¸­æœ‰å››ç§ç±»å‹çš„ RPCï¼ŒåŒæ—¶ GRPC æ˜¯æ„å»ºåœ¨ HTTP/2.0 ä¹‹ä¸Šçš„ï¼Œé‚£ä¹ˆæœ‰æ²¡æœ‰åŠæ³•å¯ä»¥é€šè¿‡ HTTP/1.1 æ¥æ”¯æŒ GRPC çš„ stream rpc å‘¢ï¼Ÿè¿™é‡Œå…¶å®å°±å¯ä»¥é€šè¿‡ hijack çš„é»‘ç§‘æŠ€æ¥å®ç°ï¼Œå°† Client å’Œ Server ä¸¤ç«¯è¿›è¡Œ hijack ä¸€ç•ªï¼Œå…¶å®å°±æœ‰ç‚¹ç±»ä¼¼äºåœ¨ TCP ä¹‹ä¸Šé€šä¿¡äº†ã€‚</p>

<p>Websocket ç®¡ç†
Websocket å…¶å®ä¹Ÿæ˜¯æœ‰ç‚¹ç±»ä¼¼ï¼Œå› ä¸º Websocket ç¬¬ä¸€é˜¶æ®µèµ°çš„æ˜¯æ™®é€šçš„ HTTPï¼Œåé¢é©¬ä¸Šå°±å‡çº§ä¸º Websocket åè®®äº†ï¼Œæ‰€ä»¥å¦‚æœä½ å¸Œæœ›ä½œä¸ºä¸­é—´äººæ“ä½œä¸€äº›äº‹æƒ…çš„è¯ï¼Œé‚£ä¹ˆ hijack æˆ–è®¸æ˜¯ä¸€ä¸ªå¾ˆé‡è¦çš„é€‰æ‹©ã€‚</p>

<p>func (c *conn) serve(ctx context.Context) {
    â€¦
    serverHandler{c.server}.ServeHTTP(w, w.req)
    w.cancelCtx()
    if c.hijacked() {
      return
    }
    w.finishRequest()
    â€¦
}</p>

<p>è¿™æ˜¯net/httpåŒ…ä¸­çš„æ–¹æ³•ï¼Œä¹Ÿæ˜¯httpè·¯ç”±çš„æ ¸å¿ƒæ–¹æ³•ã€‚è°ƒç”¨ServeHTTPï¼ˆä¹Ÿå°±æ˜¯ä¸Šè¾¹çš„handleæ–¹æ³•ï¼‰æ–¹æ³•ï¼Œå¦‚æœè¢«hijackäº†å°±ç›´æ¥returnäº†ï¼Œè€Œä¸€èˆ¬çš„httpè¯·æ±‚ä¼šç»è¿‡åè¾¹çš„finishRequestæ–¹æ³•ï¼ŒåŠ å…¥headersç­‰å¹¶å…³é—­è¿æ¥ã€‚
æ‰“å¼€æ–¹å¼
ä¸Šè¾¹æˆ‘ä»¬è¯´äº†Hijackæ–¹æ³•ï¼Œä¸€èˆ¬åœ¨åœ¨åˆ›å»ºè¿æ¥é˜¶æ®µä½¿ç”¨HTTPè¿æ¥ï¼Œåç»­è‡ªå·±å®Œå…¨å¤„ç†connectionã€‚ç¬¦åˆè¿™æ ·çš„ä½¿ç”¨åœºæ™¯çš„å¹¶ä¸å¤šï¼ŒåŸºäºHTTPåè®®çš„rpcç®—ä¸€ä¸ªï¼Œä»HTTPå‡çº§åˆ°WebSocketä¹Ÿç®—ä¸€ä¸ªã€‚
RPCä¸­çš„åº”ç”¨
goä¸­è‡ªå¸¦çš„rpcå¯ä»¥ç›´æ¥å¤ç”¨http serverå¤„ç†è¯·æ±‚çš„é‚£ä¸€å¥—æµç¨‹å»åˆ›å»ºè¿æ¥ï¼Œè¿æ¥åˆ›å»ºå®Œæ¯•åå†ä½¿ç”¨Hijackæ–¹æ³•æ‹¿åˆ°è¿æ¥ã€‚
// ServeHTTP implements an http.Handler that answers RPC requests.
func (server *server) servehttp(w http.responsewriter, req *http.request) {
    if req.method != â€œconnectâ€ {
        w.header().set(â€œcontent-typeâ€, â€œtext/plain; charset=utf-8â€)
        w.writeheader(http.statusmethodnotallowed)
        io.writestring(w, â€œ405 must connect\nâ€)
        return
    }
    conn, _, err := w.(http.hijacker).hijack()
    if err != nil {
        log.print(â€œrpc hijacking â€œ, req.remoteaddr, â€œ: â€œ, err.error())
        return
    }
    io.writestring(conn, â€œhttp/1.0 â€œ+connected+â€\n\nâ€)
    server.serveconn(conn)
}</p>

<p>å®¢æˆ·ç«¯é€šè¿‡å‘æœåŠ¡ç«¯å‘é€methodä¸ºconnectçš„è¯·æ±‚åˆ›å»ºè¿æ¥ï¼Œåˆ›å»ºæˆåŠŸåå³å¯å¼€å§‹rpcè°ƒç”¨ã€‚
websocketä¸­çš„åº”ç”¨
// ServeHTTP implements the http.Handler interface for a WebSocket
func (s Server) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    s.serveWebSocket(w, req)
}</p>

<p>func (s Server) serveWebSocket(w http.ResponseWriter, req *http.Request) {
    rwc, buf, err := w.(http.Hijacker).Hijack()
    if err != nil {
        panic(â€œHijack failed: â€œ + err.Error())
    }
    // The server should abort the WebSocket connection if it finds
    // the client did not send a handshake that matches with protocol
    // specification.
    defer rwc.Close()
    conn, err := newServerConn(rwc, buf, req, &amp;s.Config, s.Handshake)
    if err != nil {
        return
    }
    if conn == nil {
        panic(â€œunexpected nil connâ€)
    }
    s.Handler(conn)
}</p>

<p>websocketåœ¨åˆ›å»ºè¿æ¥çš„é˜¶æ®µä¸httpä½¿ç”¨ç›¸åŒçš„åè®®ï¼Œè€Œåœ¨åè¾¹çš„æ•°æ®ä¼ è¾“çš„è¿‡ç¨‹ä¸­ä½¿ç”¨äº†ä»–è‡ªå·±çš„åè®®ï¼Œç¬¦åˆäº†Hijackçš„ç”¨é€”ã€‚é€šè¿‡serveWebSocketæ–¹æ³•å°†HTTPåè®®å‡çº§åˆ°Websocketåè®®ã€‚</p>
:ET