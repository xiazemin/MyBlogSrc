I"ÕO<p>Podã€Serviceã€Volume å’Œ Namespace æ˜¯ Kubernetes é›†ç¾¤ä¸­å››å¤§åŸºæœ¬å¯¹è±¡ï¼Œå®ƒä»¬èƒ½å¤Ÿè¡¨ç¤ºç³»ç»Ÿä¸­éƒ¨ç½²çš„åº”ç”¨ã€å·¥ä½œè´Ÿè½½ã€ç½‘ç»œå’Œç£ç›˜èµ„æºï¼Œå…±åŒå®šä¹‰äº†é›†ç¾¤çš„çŠ¶æ€ã€‚Kubernetes ä¸­å¾ˆå¤šå…¶ä»–çš„èµ„æºå…¶å®åªå¯¹è¿™äº›åŸºæœ¬çš„å¯¹è±¡è¿›è¡Œäº†ç»„åˆã€‚
<!-- more -->
åœ¨æ¥ä¸‹æ¥çš„å‡ ç¯‡æ–‡ç« ä¸­æˆ‘ä»¬å°†ç®€å•ä»‹ç» Kubernetes ä¸­çš„å››ç§åŸºæœ¬å¯¹è±¡ä¸­ Pod å¹¶æ ¹æ®æºä»£ç åˆ†æå®ƒçš„ä½œç”¨å’Œå®ç°åŸç†ã€‚</p>

<p>Pod
Pod æ˜¯ Kubernetes é›†ç¾¤ä¸­èƒ½å¤Ÿè¢«åˆ›å»ºå’Œç®¡ç†çš„æœ€å°éƒ¨ç½²å•å…ƒï¼Œæƒ³è¦å½»åº•å’Œå®Œæ•´çš„äº†è§£ Kubernetes çš„å®ç°åŸç†ï¼Œæˆ‘ä»¬å¿…é¡»è¦æ¸…æ¥š Pod çš„å®ç°åŸç†ä»¥åŠæœ€ä½³å®è·µã€‚</p>

<p>åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†åˆ†ä¸¤ä¸ªéƒ¨åˆ†å¯¹ Pod è¿›è¡Œè§£æï¼Œç¬¬ä¸€éƒ¨åˆ†ä¸»è¦ä¼šä»æ¦‚å¿µå…¥æ‰‹ä»‹ç» Pod ä¸­å¿…é¡»äº†è§£çš„ç‰¹æ€§ï¼Œè€Œç¬¬äºŒéƒ¨åˆ†ä¼šä»‹ç» Pod ä»åˆ›å»ºåˆ°åˆ é™¤çš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…çš„é‡è¦äº‹ä»¶åœ¨æºç å±‚é¢æ˜¯å¦‚ä½•å®ç°çš„ã€‚
ä½œä¸º Kubernetes é›†ç¾¤ä¸­çš„åŸºæœ¬å•å…ƒï¼ŒPod å°±æ˜¯æœ€å°å¹¶ä¸”æœ€ç®€å•çš„ Kubernetes å¯¹è±¡ï¼Œè¿™ä¸ªç®€å•çš„å¯¹è±¡å…¶å®å°±èƒ½å¤Ÿç‹¬ç«‹å¯åŠ¨ä¸€ä¸ªåç«¯è¿›ç¨‹å¹¶åœ¨é›†ç¾¤çš„å†…éƒ¨ä¸ºè°ƒç”¨æ–¹æä¾›æœåŠ¡
è¿™ä¸ª YAML æ–‡ä»¶æè¿°äº†ä¸€ä¸ª Pod å¯åŠ¨æ—¶è¿è¡Œçš„å®¹å™¨å’Œå‘½ä»¤ä»¥åŠå®ƒçš„é‡å¯ç­–ç•¥ï¼Œåœ¨å½“å‰ Pod å‡ºç°é”™è¯¯æˆ–è€…æ‰§è¡Œç»“æŸåæ˜¯å¦åº”è¯¥è¢« Kubernetes çš„æ§åˆ¶å™¨æ‹‰èµ·æ¥ï¼Œé™¤äº†è¿™äº›æ¯”è¾ƒæ˜¾çœ¼çš„é…ç½®ä¹‹å¤–ï¼Œå…ƒæ•°æ® metadata çš„é…ç½®ä¹Ÿéå¸¸é‡è¦ï¼Œname æ˜¯å½“å‰å¯¹è±¡åœ¨ Kuberentes é›†ç¾¤ä¸­çš„å”¯ä¸€æ ‡è¯†ç¬¦ï¼Œè€Œæ ‡ç­¾ labels å¯ä»¥å¸®åŠ©æˆ‘ä»¬å¿«é€Ÿé€‰æ‹©å¯¹è±¡ã€‚</p>

<p>åœ¨åŒä¸€ä¸ª Pod ä¸­ï¼Œæœ‰å‡ ä¸ªæ¦‚å¿µç‰¹åˆ«å€¼å¾—å…³æ³¨ï¼Œé¦–å…ˆå°±æ˜¯å®¹å™¨ï¼Œåœ¨ Pod ä¸­å…¶å®å¯ä»¥åŒæ—¶è¿è¡Œä¸€ä¸ªæˆ–è€…å¤šä¸ªå®¹å™¨ï¼Œè¿™äº›å®¹å™¨èƒ½å¤Ÿå…±äº«ç½‘ç»œã€å­˜å‚¨ä»¥åŠ CPUã€å†…å­˜ç­‰èµ„æºã€‚åœ¨è¿™ä¸€å°èŠ‚ä¸­æˆ‘ä»¬å°†å…³æ³¨ Pod ä¸­çš„å®¹å™¨ã€å·å’Œç½‘ç»œä¸‰å¤§æ¦‚å¿µã€‚
æ¯ä¸€ä¸ª Kubernetes çš„ Pod å…¶å®éƒ½å…·æœ‰ä¸¤ç§ä¸åŒçš„å®¹å™¨ï¼Œä¸¤ç§ä¸åŒå®¹å™¨çš„èŒè´£å…¶å®ååˆ†æ¸…æ™°ï¼Œä¸€ç§æ˜¯ InitContainerï¼Œè¿™ç§å®¹å™¨ä¼šåœ¨ Pod å¯åŠ¨æ—¶è¿è¡Œï¼Œä¸»è¦ç”¨äºåˆå§‹åŒ–ä¸€äº›é…ç½®ï¼Œå¦ä¸€ç§æ˜¯ Pod åœ¨ Running çŠ¶æ€æ—¶å†…éƒ¨å­˜æ´»çš„ Containerï¼Œå®ƒä»¬çš„ä¸»è¦ä½œç”¨æ˜¯å¯¹å¤–æä¾›æœåŠ¡æˆ–è€…ä½œä¸ºå·¥ä½œèŠ‚ç‚¹å¤„ç†å¼‚æ­¥ä»»åŠ¡ç­‰ç­‰ã€‚
é€šè¿‡å¯¹ä¸åŒå®¹å™¨ç±»å‹çš„å‘½åæˆ‘ä»¬ä¹Ÿå¯ä»¥çœ‹å‡ºï¼ŒInitContainer ä¼šæ¯” Container ä¼˜å…ˆå¯åŠ¨ï¼Œåœ¨ kubeGenericRuntimeManager.SyncPod æ–¹æ³•ä¸­ä¼šå…ˆåå¯åŠ¨ä¸¤ç§å®¹å™¨ã€‚</p>

<p>func (m *kubeGenericRuntimeManager) SyncPod(pod *v1.Pod, _ v1.PodStatus, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) {
    // Step 1: Compute sandbox and container changes.
    // Step 2: Kill the pod if the sandbox has changed.
    // Step 3: kill any running containers in this pod which are not to keep.
    // Step 4: Create a sandbox for the pod if necessary.
    // â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Step 5: start the init container.
if container := podContainerChanges.NextInitContainerToStart; container != nil {
    msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeInit)
}

// Step 6: start containers in podContainerChanges.ContainersToStart.
for _, idx := range podContainerChanges.ContainersToStart {
    container := &amp;pod.Spec.Containers[idx]

    msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeRegular)
}

return } é€šè¿‡åˆ†æç§æœ‰æ–¹æ³• startContainer çš„å®ç°æˆ‘ä»¬å¾—å‡ºï¼šå®¹å™¨çš„ç±»å‹æœ€ç»ˆåªä¼šå½±å“åœ¨ Debug æ—¶åˆ›å»ºçš„æ ‡ç­¾ï¼Œæ‰€ä»¥å¯¹äº Kubernetes æ¥è¯´ä¸¤ç§å®¹å™¨çš„å¯åŠ¨å’Œæ‰§è¡Œä¹Ÿå°±åªæœ‰é¡ºåºå…ˆåçš„ä¸åŒã€‚
</code></pre></div></div>

<p>å·
æ¯ä¸€ä¸ª Pod ä¸­çš„å®¹å™¨æ˜¯å¯ä»¥é€šè¿‡å·ï¼ˆVolumeï¼‰çš„æ–¹å¼å…±äº«æ–‡ä»¶ç›®å½•çš„ï¼Œè¿™äº› Volume èƒ½å¤Ÿå­˜å‚¨æŒä¹…åŒ–çš„æ•°æ®ï¼›åœ¨å½“å‰ Pod å‡ºç°æ•…éšœæˆ–è€…æ»šåŠ¨æ›´æ–°æ—¶ï¼Œå¯¹åº” Volume ä¸­çš„æ•°æ®å¹¶ä¸ä¼šè¢«æ¸…é™¤ï¼Œè€Œæ˜¯ä¼šåœ¨ Pod é‡å¯åé‡æ–°æŒ‚è½½åˆ°æœŸæœ›çš„æ–‡ä»¶ç›®å½•ä¸­</p>

<p>kubelet.go æ–‡ä»¶ä¸­çš„ç§æœ‰æ–¹æ³• syncPod ä¼šè°ƒç”¨ WaitForAttachAndMount æ–¹æ³•ä¸ºç­‰å¾…å½“å‰ Pod å¯åŠ¨éœ€è¦çš„æŒ‚è½½æ–‡ä»¶ï¼š</p>

<p>func (vm *volumeManager) WaitForAttachAndMount(pod *v1.Pod) error {
    expectedVolumes := getExpectedVolumes(pod)
    uniquePodName := util.GetUniquePodName(pod)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vm.desiredStateOfWorldPopulator.ReprocessPod(uniquePodName)

wait.PollImmediate(
    podAttachAndMountRetryInterval,
    podAttachAndMountTimeout,
    vm.verifyVolumesMountedFunc(uniquePodName, expectedVolumes))

return nil } æˆ‘ä»¬ä¼šåœ¨åé¢çš„ç« èŠ‚è¯¦ç»†åœ°ä»‹ç» Kubernetes ä¸­å·çš„åˆ›å»ºã€æŒ‚è½½æ˜¯å¦‚ä½•è¿›è¡Œçš„ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬éœ€è¦çŸ¥é“çš„æ˜¯å·çš„æŒ‚è½½æ˜¯ Pod å¯åŠ¨ä¹‹å‰å¿…é¡»è¦å®Œæˆçš„å·¥ä½œï¼š
</code></pre></div></div>

<p>func (kl *Kubelet) syncPod(o syncPodOptions) error {
    // â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if !kl.podIsTerminated(pod) {
    kl.volumeManager.WaitForAttachAndMount(pod)
}

pullSecrets := kl.getPullSecretsForPod(pod)

result := kl.containerRuntime.SyncPod(pod, apiPodStatus, podStatus, pullSecrets, kl.backOff)
kl.reasonCache.Update(pod.UID, result)

return nil } åœ¨å½“å‰ Pod çš„å·åˆ›å»ºå®Œæˆä¹‹åï¼Œå°±ä¼šè°ƒç”¨ä¸Šä¸€èŠ‚ä¸­æåˆ°çš„ SyncPod å…¬æœ‰æ–¹æ³•ç»§ç»­è¿›è¡ŒåŒæ­¥ Pod ä¿¡æ¯å’Œåˆ›å»ºã€å¯åŠ¨å®¹å™¨çš„å·¥ä½œã€‚
</code></pre></div></div>

<p>ç½‘ç»œ
åŒä¸€ä¸ª Pod ä¸­çš„å¤šä¸ªå®¹å™¨ä¼šè¢«å…±åŒåˆ†é…åˆ°åŒä¸€ä¸ª Host ä¸Šå¹¶ä¸”å…±äº«ç½‘ç»œæ ˆï¼Œä¹Ÿå°±æ˜¯è¯´è¿™äº› Pod èƒ½å¤Ÿé€šè¿‡ localhost äº’ç›¸è®¿é—®åˆ°å½¼æ­¤çš„ç«¯å£å’ŒæœåŠ¡ï¼Œå¦‚æœä½¿ç”¨äº†ç›¸åŒçš„ç«¯å£ä¹Ÿä¼šå‘ç”Ÿå†²çªï¼ŒåŒä¸€ä¸ª Pod ä¸Šçš„æ‰€æœ‰å®¹å™¨ä¼šè¿æ¥åˆ°åŒä¸€ä¸ªç½‘ç»œè®¾å¤‡ä¸Šï¼Œè¿™ä¸ªç½‘ç»œè®¾å¤‡å°±æ˜¯ç”± Pod Sandbox ä¸­çš„æ²™ç®±å®¹å™¨åœ¨ RunPodSandbox æ–¹æ³•ä¸­å¯åŠ¨æ—¶åˆ›å»ºçš„ï¼š</p>

<p>func (ds <em>dockerService) RunPodSandbox(ctx context.Context, r *runtimeapi.RunPodSandboxRequest) (</em>runtimeapi.RunPodSandboxResponse, error) {
    config := r.GetConfig()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Step 1: Pull the image for the sandbox.
image := defaultSandboxImage

// Step 2: Create the sandbox container.
createConfig, _ := ds.makeSandboxDockerConfig(config, image)
createResp, _ := ds.client.CreateContainer(*createConfig)

resp := &amp;runtimeapi.RunPodSandboxResponse{PodSandboxId: createResp.ID}

ds.setNetworkReady(createResp.ID, false)

// Step 3: Create Sandbox Checkpoint.
ds.checkpointManager.CreateCheckpoint(createResp.ID, constructPodSandboxCheckpoint(config))

// Step 4: Start the sandbox container.
ds.client.StartContainer(createResp.ID)

// Step 5: Setup networking for the sandbox.
cID := kubecontainer.BuildContainerID(runtimeName, createResp.ID)
networkOptions := make(map[string]string)
ds.network.SetUpPod(config.GetMetadata().Namespace, config.GetMetadata().Name, cID, config.Annotations, networkOptions)

return resp, nil } æ²™ç®±å®¹å™¨å…¶å®å°±æ˜¯ pause å®¹å™¨ï¼Œä¸Šè¿°æ–¹æ³•å¼•ç”¨çš„ defaultSandboxImage å…¶å®å°±æ˜¯å®˜æ–¹æä¾›çš„ k8s.gcr.io/pause:3.1 é•œåƒï¼Œè¿™é‡Œä¼šåˆ›å»ºæ²™ç®±é•œåƒå’Œæ£€æŸ¥ç‚¹å¹¶å¯åŠ¨å®¹å™¨ã€‚
</code></pre></div></div>

<p>kubernetes-pod-network
kubernetes-pod-network
æ¯ä¸€ä¸ªèŠ‚ç‚¹ä¸Šéƒ½ä¼šç”± Kubernetes çš„ç½‘ç»œæ’ä»¶ Kubenet åˆ›å»ºä¸€ä¸ªåŸºæœ¬çš„ cbr0 ç½‘æ¡¥å¹¶ä¸ºæ¯ä¸€ä¸ª Pod åˆ›å»º veth è™šæ‹Ÿç½‘ç»œè®¾å¤‡ï¼ŒåŒä¸€ä¸ª Pod ä¸­çš„æ‰€æœ‰å®¹å™¨å°±ä¼šé€šè¿‡è¿™ä¸ªç½‘ç»œè®¾å¤‡å…±äº«ç½‘ç»œï¼Œä¹Ÿå°±æ˜¯èƒ½å¤Ÿé€šè¿‡ localhost äº’ç›¸è®¿é—®å½¼æ­¤æš´éœ²çš„ç«¯å£å’ŒæœåŠ¡ã€‚</p>

<p>å°ç»“
Kubernetes ä¸­çš„æ¯ä¸€ä¸ª Pod éƒ½åŒ…å«å¤šä¸ªå®¹å™¨ï¼Œè¿™äº›å®¹å™¨åœ¨é€šè¿‡ Kubernetes åˆ›å»ºä¹‹åå°±èƒ½å…±äº«ç½‘ç»œå’Œå­˜å‚¨ï¼Œè¿™å…¶å®æ˜¯ Pod éå¸¸é‡è¦çš„ç‰¹æ€§ï¼Œæˆ‘ä»¬èƒ½é€šè¿‡è¿™ä¸ªç‰¹æ€§æ„å»ºæ¯”è¾ƒå¤æ‚çš„æœåŠ¡æ‹“æ‰‘å’Œä¾èµ–å…³ç³»ã€‚</p>

<p>ç”Ÿå‘½å‘¨æœŸ
æƒ³è¦æ·±å…¥ç†è§£ Pod çš„å®ç°åŸç†ï¼Œæœ€å¥½æœ€å¿«çš„åŠæ³•å°±æ˜¯ä» Pod çš„ç”Ÿå‘½å‘¨æœŸå…¥æ‰‹ï¼Œé€šè¿‡ç†è§£ Pod åˆ›å»ºã€é‡å¯å’Œåˆ é™¤çš„åŸç†æˆ‘ä»¬æœ€ç»ˆå°±èƒ½å¤Ÿç³»ç»Ÿåœ°æŒæ¡ Pod çš„ç”Ÿå‘½å‘¨æœŸä¸æ ¸å¿ƒåŸç†ã€‚</p>

<p>kubernetes-pod-lifecycle
kubernetes-pod-lifecycle
å½“ Pod è¢«åˆ›å»ºä¹‹åï¼Œå°±ä¼šè¿›å…¥å¥åº·æ£€æŸ¥çŠ¶æ€ï¼Œå½“ Kubernetes ç¡®å®šå½“å‰ Pod å·²ç»èƒ½å¤Ÿæ¥å—å¤–éƒ¨çš„è¯·æ±‚æ—¶ï¼Œæ‰ä¼šå°†æµé‡æ‰“åˆ°æ–°çš„ Pod ä¸Šå¹¶ç»§ç»­å¯¹å¤–æä¾›æœåŠ¡ï¼Œåœ¨è¿™æœŸé—´å¦‚æœå‘ç”Ÿäº†é”™è¯¯å°±å¯èƒ½ä¼šè§¦å‘é‡å¯æœºåˆ¶ï¼Œåœ¨ Pod è¢«åˆ é™¤ä¹‹å‰éƒ½ä¼šè§¦å‘ä¸€ä¸ª PreStop çš„é’©å­ï¼Œå…¶ä¸­çš„æ–¹æ³•ä¹‹å‰å®Œæˆä¹‹å Pod æ‰ä¼šè¢«åˆ é™¤ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬å°±ä¼šæŒ‰ç…§è¿™é‡Œçš„é¡ºåºä¾æ¬¡ä»‹ç» Pod ã€ä»ç”Ÿåˆ°æ­»ã€çš„è¿‡ç¨‹ã€‚</p>

<p>åˆ›å»º
Pod çš„åˆ›å»ºéƒ½æ˜¯é€šè¿‡ SyncPod æ¥å®ç°çš„ï¼Œåˆ›å»ºçš„è¿‡ç¨‹å¤§ä½“ä¸Šå¯ä»¥åˆ†ä¸ºå…­ä¸ªæ­¥éª¤ï¼š</p>

<p>è®¡ç®— Pod ä¸­æ²™ç›’å’Œå®¹å™¨çš„å˜æ›´ï¼›</p>

<p>å¼ºåˆ¶åœæ­¢ Pod å¯¹åº”çš„æ²™ç›’ï¼›</p>

<p>å¼ºåˆ¶åœæ­¢æ‰€æœ‰ä¸åº”è¯¥è¿è¡Œçš„å®¹å™¨ï¼›</p>

<p>ä¸º Pod åˆ›å»ºæ–°çš„æ²™ç›’ï¼›</p>

<p>åˆ›å»º Pod è§„æ ¼ä¸­æŒ‡å®šçš„åˆå§‹åŒ–å®¹å™¨ï¼›</p>

<p>ä¾æ¬¡åˆ›å»º Pod è§„æ ¼ä¸­æŒ‡å®šçš„å¸¸è§„å®¹å™¨ï¼›</p>

<p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ° Pod çš„åˆ›å»ºè¿‡ç¨‹å…¶å®æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œé¦–å…ˆè®¡ç®— Pod è§„æ ¼å’Œæ²™ç®±çš„å˜æ›´ï¼Œç„¶ååœæ­¢å¯èƒ½å½±å“è¿™ä¸€æ¬¡åˆ›å»ºæˆ–è€…æ›´æ–°çš„å®¹å™¨ï¼Œæœ€åä¾æ¬¡åˆ›å»ºæ²™ç›’ã€åˆå§‹åŒ–å®¹å™¨å’Œå¸¸è§„å®¹å™¨ã€‚</p>

<p>func (m *kubeGenericRuntimeManager) SyncPod(pod *v1.Pod, _ v1.PodStatus, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, backOff *flowcontrol.Backoff) (result kubecontainer.PodSyncResult) {
    podContainerChanges := m.computePodActions(pod, podStatus)
    if podContainerChanges.CreateSandbox {
        ref, _ := ref.GetReference(legacyscheme.Scheme, pod)
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if podContainerChanges.KillPod {
    if podContainerChanges.CreateSandbox {
        m.purgeInitContainers(pod, podStatus)
    }
} else {
    for containerID, containerInfo := range podContainerChanges.ContainersToKill {
        m.killContainer(pod, containerID, containerInfo.name, containerInfo.message, nil)           }
    }
}

podSandboxID := podContainerChanges.SandboxID
if podContainerChanges.CreateSandbox {
    podSandboxID, _, _ = m.createPodSandbox(pod, podContainerChanges.Attempt)
}
podSandboxConfig, _ := m.generatePodSandboxConfig(pod, podContainerChanges.Attempt)

if container := podContainerChanges.NextInitContainerToStart; container != nil {
    msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeInit)
}

for _, idx := range podContainerChanges.ContainersToStart {
    container := &amp;pod.Spec.Containers[idx]
    msg, _ := m.startContainer(podSandboxID, podSandboxConfig, container, pod, podStatus, pullSecrets, podIP, kubecontainer.ContainerTypeRegular)
}

return } ç®€åŒ–åçš„ SyncPod æ–¹æ³•çš„è„‰ç»œéå¸¸æ¸…æ™°ï¼Œå¯ä»¥å¾ˆå¥½åœ°ç†è§£æ•´ä¸ªåˆ›å»º Pod çš„å·¥ä½œæµç¨‹ï¼›è€Œåˆå§‹åŒ–å®¹å™¨å’Œå¸¸è§„å®¹å™¨è¢«è°ƒç”¨ startContainer æ¥å¯åŠ¨ï¼š
</code></pre></div></div>

<p>func (m *kubeGenericRuntimeManager) startContainer(podSandboxID string, podSandboxConfig *runtimeapi.PodSandboxConfig, container *v1.Container, pod *v1.Pod, podStatus *kubecontainer.PodStatus, pullSecrets []v1.Secret, podIP string, containerType kubecontainer.ContainerType) (string, error) {
    imageRef, _, _ := m.imagePuller.EnsureImageExists(pod, container, pullSecrets)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ...
containerID, _ := m.runtimeService.CreateContainer(podSandboxID, containerConfig, podSandboxConfig)

m.internalLifecycle.PreStartContainer(pod, container, containerID)

m.runtimeService.StartContainer(containerID)

if container.Lifecycle != nil &amp;&amp; container.Lifecycle.PostStart != nil {
    kubeContainerID := kubecontainer.ContainerID{
        Type: m.runtimeName,
        ID:   containerID,
    }
    msg, _ := m.runner.Run(kubeContainerID, pod, container, container.Lifecycle.PostStart)
}

return "", nil } åœ¨å¯åŠ¨æ¯ä¸€ä¸ªå®¹å™¨çš„è¿‡ç¨‹ä¸­ä¹Ÿéƒ½æŒ‰ç…§ç›¸åŒçš„æ­¥éª¤è¿›è¡Œæ“ä½œï¼š
</code></pre></div></div>

<p>é€šè¿‡é•œåƒæ‹‰å–å™¨è·å¾—å½“å‰å®¹å™¨ä¸­ä½¿ç”¨é•œåƒçš„å¼•ç”¨ï¼›</p>

<p>è°ƒç”¨è¿œç¨‹çš„ runtimeService åˆ›å»ºå®¹å™¨ï¼›</p>

<p>è°ƒç”¨å†…éƒ¨çš„ç”Ÿå‘½å‘¨æœŸæ–¹æ³• PreStartContainer ä¸ºå½“å‰çš„å®¹å™¨è®¾ç½®åˆ†é…çš„ CPU ç­‰èµ„æºï¼›</p>

<p>è°ƒç”¨è¿œç¨‹çš„ runtimeService å¼€å§‹è¿è¡Œé•œåƒï¼›</p>

<p>å¦‚æœå½“å‰çš„å®¹å™¨åŒ…å« PostStart é’©å­å°±ä¼šæ‰§è¡Œè¯¥å›è°ƒï¼›</p>

<p>æ¯æ¬¡ SyncPod è¢«è°ƒç”¨æ—¶ä¸ä¸€å®šæ˜¯åˆ›å»ºæ–°çš„ Pod å¯¹è±¡ï¼Œå®ƒè¿˜ä¼šæ‰¿æ‹…æ›´æ–°ã€åˆ é™¤å’ŒåŒæ­¥ Pod è§„æ ¼çš„èŒèƒ½ï¼Œæ ¹æ®è¾“å…¥çš„æ–°è§„æ ¼æ‰§è¡Œç›¸åº”çš„æ“ä½œã€‚</p>

<p>å¥åº·æ£€æŸ¥
å¦‚æœæˆ‘ä»¬éµå¾ª Pod çš„æœ€ä½³å®è·µï¼Œå…¶å®åº”è¯¥å°½å¯èƒ½åœ°ä¸ºæ¯ä¸€ä¸ª Pod æ·»åŠ  livenessProbe å’Œ readinessProbe çš„å¥åº·æ£€æŸ¥ï¼Œè¿™ä¸¤è€…èƒ½å¤Ÿä¸º Kubernetes æä¾›é¢å¤–çš„å­˜æ´»ä¿¡æ¯ï¼Œå¦‚æœæˆ‘ä»¬é…ç½®äº†åˆé€‚çš„å¥åº·æ£€æŸ¥æ–¹æ³•å’Œè§„åˆ™ï¼Œé‚£ä¹ˆå°±ä¸ä¼šå‡ºç°æœåŠ¡æœªå¯åŠ¨å°±è¢«æ‰“å…¥æµé‡æˆ–è€…é•¿æ—¶é—´æœªå“åº”ä¾ç„¶æ²¡æœ‰é‡å¯ç­‰é—®é¢˜ã€‚</p>

<p>åœ¨ Pod è¢«åˆ›å»ºæˆ–è€…è¢«ç§»é™¤æ—¶ï¼Œä¼šè¢«åŠ å…¥åˆ°å½“å‰èŠ‚ç‚¹ä¸Šçš„ ProbeManager ä¸­ï¼ŒProbeManager ä¼šè´Ÿè´£è¿™äº› Pod çš„å¥åº·æ£€æŸ¥ï¼š</p>

<p>func (kl <em>Kubelet) HandlePodAdditions(pods []</em>v1.Pod) {
    start := kl.clock.Now()
    for _, pod := range pods {
        kl.podManager.AddPod(pod)
        kl.dispatchWork(pod, kubetypes.SyncPodCreate, mirrorPod, start)
        kl.probeManager.AddPod(pod)
    }
}</p>

<p>func (kl <em>Kubelet) HandlePodRemoves(pods []</em>v1.Pod) {
    start := kl.clock.Now()
    for _, pod := range pods {
        kl.podManager.DeletePod(pod)
        kl.deletePod(pod)
        kl.probeManager.RemovePod(pod)
    }
}
ç®€åŒ–åçš„ HandlePodAdditions å’Œ HandlePodRemoves æ–¹æ³•éå¸¸ç›´ç™½ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥æ¥çœ‹ ProbeManager å¦‚ä½•å¤„ç†ä¸åŒèŠ‚ç‚¹çš„å¥åº·æ£€æŸ¥ã€‚</p>

<p>kubernetes-probe-manager
kubernetes-probe-manager
æ¯ä¸€ä¸ªæ–°çš„ Pod éƒ½ä¼šè¢«è°ƒç”¨ ProbeManager  çš„AddPod å‡½æ•°ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šåˆå§‹åŒ–ä¸€ä¸ªæ–°çš„ Goroutine å¹¶åœ¨å…¶ä¸­è¿è¡Œå¯¹å½“å‰ Pod è¿›è¡Œå¥åº·æ£€æŸ¥ï¼š</p>

<p>func (m *manager) AddPod(pod *v1.Pod) {
    key := probeKey{podUID: pod.UID}
    for _, c := range pod.Spec.Containers {
        key.containerName = c.Name</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if c.ReadinessProbe != nil {
        key.probeType = readiness
        w := newWorker(m, readiness, pod, c)
        m.workers[key] = w
        go w.run()
    }

    if c.LivenessProbe != nil {
        key.probeType = liveness
        w := newWorker(m, liveness, pod, c)
        m.workers[key] = w
        go w.run()
    }
} } åœ¨æ‰§è¡Œå¥åº·æ£€æŸ¥çš„è¿‡ç¨‹ä¸­ï¼ŒWorker åªæ˜¯è´Ÿè´£æ ¹æ®å½“å‰ Pod çš„çŠ¶æ€å®šæœŸè§¦å‘ä¸€æ¬¡ Probeï¼Œå®ƒä¼šæ ¹æ® Pod çš„é…ç½®åˆ†åˆ«é€‰æ‹©è°ƒç”¨ Execã€HTTPGet æˆ– TCPSocket ä¸‰ç§ä¸åŒçš„ Probe æ–¹å¼ï¼š
</code></pre></div></div>

<p>func (pb *prober) runProbe(probeType probeType, p *v1.Probe, pod *v1.Pod, status v1.PodStatus, container v1.Container, containerID kubecontainer.ContainerID) (probe.Result, string, error) {
    timeout := time.Duration(p.TimeoutSeconds) * time.Second
    if p.Exec != nil {
        command := kubecontainer.ExpandContainerCommandOnlyStatic(p.Exec.Command, container.Env)
        return pb.exec.Probe(pb.newExecInContainer(container, containerID, command, timeout))
    }
    if p.HTTPGet != nil {
        scheme := strings.ToLower(string(p.HTTPGet.Scheme))
        host := p.HTTPGet.Host
        port, _ := extractPort(p.HTTPGet.Port, container)
        path := p.HTTPGet.Path
        url := formatURL(scheme, host, port, path)
        headers := buildHeader(p.HTTPGet.HTTPHeaders)
        if probeType == liveness {
            return pb.livenessHttp.Probe(url, headers, timeout)
        } else { // readiness
            return pb.readinessHttp.Probe(url, headers, timeout)
        }
    }
    if p.TCPSocket != nil {
        port, _ := extractPort(p.TCPSocket.Port, container)
        host := p.TCPSocket.Host
        return pb.tcp.Probe(host, port, timeout)
    }
    return probe.Unknown, â€œâ€, fmt.Errorf(â€œMissing probe handler for %s:%sâ€, format.Pod(pod), container.Name)
}
Kubernetes åœ¨ Pod å¯åŠ¨åçš„ InitialDelaySeconds æ—¶é—´å†…ä¼šç­‰å¾… Pod çš„å¯åŠ¨å’Œåˆå§‹åŒ–ï¼Œåœ¨è¿™ä¹‹åä¼šå¼€å§‹å¥åº·æ£€æŸ¥ï¼Œé»˜è®¤çš„å¥åº·æ£€æŸ¥é‡è¯•æ¬¡æ•°æ˜¯ä¸‰æ¬¡ï¼Œå¦‚æœå¥åº·æ£€æŸ¥æ­£å¸¸è¿è¡Œè¿”å›äº†ä¸€ä¸ªç¡®å®šçš„ç»“æœï¼Œé‚£ä¹ˆ Worker å°±æ˜¯è®°å½•è¿™æ¬¡çš„ç»“æœï¼Œåœ¨è¿ç»­å¤±è´¥ FailureThreshold æ¬¡æˆ–è€…æˆåŠŸ SuccessThreshold æ¬¡ï¼Œé‚£ä¹ˆå°±ä¼šæ”¹å˜å½“å‰ Pod çš„çŠ¶æ€ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºäº†é¿å…ç”±äºæœåŠ¡ä¸ç¨³å®šå¸¦æ¥çš„æŠ–åŠ¨ã€‚</p>

<p>åˆ é™¤
å½“ Kubelet åœ¨ HandlePodRemoves æ–¹æ³•ä¸­æ¥æ”¶åˆ°æ¥è‡ªå®¢æˆ·ç«¯çš„åˆ é™¤è¯·æ±‚æ—¶ï¼Œå°±ä¼šé€šè¿‡ä¸€ä¸ªåä¸º deletePod çš„ç§æœ‰æ–¹æ³•ä¸­çš„ Channel å°†è¿™ä¸€äº‹ä»¶ä¼ é€’ç»™ PodKiller è¿›è¡Œå¤„ç†ï¼š</p>

<p>func (kl *Kubelet) deletePod(pod *v1.Pod) error {
    kl.podWorkers.ForgetWorker(pod.UID)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>runningPods, _ := kl.runtimeCache.GetPods()
runningPod := kubecontainer.Pods(runningPods).FindPod("", pod.UID)
podPair := kubecontainer.PodPair{APIPod: pod, RunningPod: &amp;runningPod}

kl.podKillingCh &lt;- &amp;podPair
return nil } Kubelet é™¤äº†å°†äº‹ä»¶é€šçŸ¥ç»™ PodKiller ä¹‹å¤–ï¼Œè¿˜éœ€è¦å°†å½“å‰ Pod å¯¹åº”çš„ Worker ä»æŒæœ‰çš„ podWorkers ä¸­åˆ é™¤ï¼›PodKiller å…¶å®å°±æ˜¯ Kubelet æŒæœ‰çš„ä¸€ä¸ª Goroutineï¼Œå®ƒä¼šåœ¨åå°æŒç»­è¿è¡Œå¹¶ç›‘å¬æ¥è‡ª podKillingCh çš„äº‹ä»¶ï¼š
</code></pre></div></div>

<p>kubernetes-pod-killer
kubernetes-pod-killer
ç»è¿‡ä¸€ç³»åˆ—çš„æ–¹æ³•è°ƒç”¨ä¹‹åï¼Œæœ€ç»ˆè°ƒç”¨å®¹å™¨è¿è¡Œæ—¶çš„ killContainersWithSyncResult æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•ä¼šåŒæ­¥åœ°æ€æ‰å½“å‰ Pod ä¸­å…¨éƒ¨çš„å®¹å™¨ï¼š</p>

<p>func (m <em>kubeGenericRuntimeManager) killContainersWithSyncResult(pod *v1.Pod, runningPod kubecontainer.Pod, gracePeriodOverride *int64) (syncResults []</em>kubecontainer.SyncResult) {
    containerResults := make(chan *kubecontainer.SyncResult, len(runningPod.Containers))</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _, container := range runningPod.Containers {
    go func(container *kubecontainer.Container) {
        killContainerResult := kubecontainer.NewSyncResult(kubecontainer.KillContainer, container.Name)
        m.killContainer(pod, container.ID, container.Name, "Need to kill Pod", gracePeriodOverride)
        containerResults &lt;- killContainerResult
    }(container)
}
close(containerResults)

for containerResult := range containerResults {
    syncResults = append(syncResults, containerResult)
}
return } å¯¹äºæ¯ä¸€ä¸ªå®¹å™¨æ¥è¯´ï¼Œå®ƒä»¬åœ¨è¢«åœæ­¢ä¹‹å‰éƒ½ä¼šå…ˆè°ƒç”¨ PreStop çš„é’©å­æ–¹æ³•ï¼Œè®©å®¹å™¨ä¸­çš„åº”ç”¨ç¨‹åºèƒ½å¤Ÿæœ‰æ—¶é—´å®Œæˆä¸€äº›æœªå¤„ç†çš„æ“ä½œï¼Œéšåè°ƒç”¨è¿œç¨‹çš„æœåŠ¡åœæ­¢è¿è¡Œçš„å®¹å™¨ï¼š
</code></pre></div></div>

<p>func (m *kubeGenericRuntimeManager) killContainer(pod *v1.Pod, containerID kubecontainer.ContainerID, containerName string, reason string, gracePeriodOverride *int64) error {
    containerSpec := kubecontainer.GetContainerSpec(pod, containerName);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gracePeriod := int64(minimumGracePeriodInSeconds)
switch {
case pod.DeletionGracePeriodSeconds != nil:
    gracePeriod = *pod.DeletionGracePeriodSeconds
case pod.Spec.TerminationGracePeriodSeconds != nil:
    gracePeriod = *pod.Spec.TerminationGracePeriodSeconds
}

m.executePreStopHook(pod, containerID, containerSpec, gracePeriod
m.internalLifecycle.PreStopContainer(containerID.ID)
m.runtimeService.StopContainer(containerID.ID, gracePeriod)
m.containerRefManager.ClearRef(containerID)

return err } ä»è¿™ä¸ªç®€åŒ–ç‰ˆæœ¬çš„ killContainer æ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥å¤§è‡´çœ‹å‡ºåœæ­¢è¿è¡Œå®¹å™¨çš„å¤§è‡´é€»è¾‘ï¼Œå…ˆä» Pod çš„è§„æ ¼ä¸­è®¡ç®—å‡ºå½“å‰åœæ­¢æ‰€éœ€è¦çš„æ—¶é—´ï¼Œç„¶åè¿è¡Œé’©å­æ–¹æ³•å’Œå†…éƒ¨çš„ç”Ÿå‘½å‘¨æœŸæ–¹æ³•ï¼Œæœ€åå°†å®¹å™¨åœæ­¢å¹¶æ¸…é™¤å¼•ç”¨ã€‚
</code></pre></div></div>
:ET