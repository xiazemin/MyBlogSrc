I"é8<p>å¿ƒè·³å¤„ç†çš„å¿…è¦æ€§ï¼š
æœåŠ¡ç«¯éœ€è¦åŒæ—¶å¤„ç†ä¸Šåƒç”šè‡³ä¸Šä¸‡çš„å®¢æˆ·ç«¯çš„è¿æ¥ï¼Œæ‰€ä»¥æ¯ä¸ªè¿æ¥èµ„æºéƒ½æ˜¯å¾ˆå®è´µçš„ï¼Œå½“å®¢æˆ·ç«¯æ–­å¼€è¿æ¥çš„æ—¶å€™æœåŠ¡ç«¯åº”è¯¥åŠæ—¶ç§»é™¤è¯¥è¿æ¥ã€‚
æ­£å¸¸æƒ…å†µä¸‹ï¼Œå®¢æˆ·ç«¯æ–­å¼€è¿æ¥çš„æ—¶å€™ï¼Œä¼šå’ŒæœåŠ¡ç«¯è¿›è¡Œå››æ¬¡æŒ¥æ‰‹ï¼ŒæœåŠ¡ç«¯å°±ä¼šçŸ¥é“è¿™ä¸ªè¿æ¥ å·²ç»ä¸èƒ½ç”¨äº†ä¼˜é›…çš„é€€å‡ºç›‘å¬æ¶ˆæ¯ã€‚ä½†æ˜¯æ€»ä¼šæœ‰æ„å¤–ï¼Œæ¯”å¦‚å®¢æˆ·ç«¯å¿½ç„¶æ–­ç½‘äº†ï¼Œæ²¡ç”µäº†ï¼Œè¿™ä¸ªæ—¶å€™å®¢æˆ·ç«¯è‚¯å®šä¸å¯èƒ½æŒ‰ç…§æµç¨‹å’Œ æœåŠ¡ç«¯è¿›è¡ŒæŒ¥æ‰‹ï¼Œä¸çŸ¥é“æ¶ˆæ¯çš„ æœåŠ¡ç«¯è¿˜å‚»å‚»çš„åœ¨å“ªå„¿ç­‰ç€ï¼Œä¸çŸ¥é“å®¢æˆ·ç«¯æ—©å°±èµ°äº†ã€‚
è¿™ä¸ªæ—¶å€™ å¿ƒè·³åŒ…å°±å¾ˆå®Œç¾çš„è§£å†³äº†æ­¤é—®é¢˜ã€‚å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯çº¦å®šå¥½æ¯éš”ä¸€æ®µæ—¶é—´ å°±ä¼šå‘æ¶ˆæ¯ï¼Œå¦‚æœæœåŠ¡ç«¯æ¯è¿‡ä¸€æ®µæ—¶é—´æ²¡æœ‰æ”¶åˆ°å®¢æˆ·ç«¯ çš„å¿ƒè·³æ¶ˆæ¯ å°±è¯´æ˜ å®¢æˆ·ç«¯å‡ºäº‹äº†ï¼ŒæœåŠ¡ç«¯å°±åˆ é™¤æ­¤è¿æ¥ï¼Œç¡®ä¿ èµ„æºæœ€å¤§åŒ–ã€‚
ä¸€èˆ¬å¿ƒè·³åŒ…å°±æ˜¯ ç¬¦åˆè¯¥åè®®çš„ æœ€å°åŒ…ã€‚
<!-- more -->
ä¸€èˆ¬çš„goè¯­è¨€æ¡†æ¶éƒ½æ˜¯ä¸€ä¸ªè¿æ¥å•ç‹¬å¼€ä¸€ä¸ªåç¨‹ å»å¤„ç†è¯»å–è¶…æ—¶é—®é¢˜
å½“åç¨‹æ•°é‡å¤šåˆ°ä¸€å®šç¨‹åº¦çš„æ—¶å€™ï¼Œåç¨‹ä¹‹é—´çš„è°ƒåº¦ä¹Ÿæ˜¯ä¸€ä¸ªå¾ˆå¤§çš„ æ¶ˆè€—
ä¸€ä¸ªåç¨‹ è¿›è¡Œ å¿ƒè·³æ£€æµ‹ã€‚</p>

<p>. æ¯å½“ä¸€ä¸ªè¿æ¥æˆåŠŸæ¥æ”¶åˆ°æ¶ˆæ¯çš„æ—¶å€™ï¼Œå°±åœ¨è¯¥è¿æ¥å¯¹è±¡ ä¸Šè®¾ç½®å½“å‰æ—¶é—´æˆ³ã€‚æ¥ä¿å­˜æœ€è¿‘ä¸€æ¬¡æ¥æ”¶æ¶ˆæ¯çš„æ—¶é—´
. åœ¨æ¡†æ¶å¯åŠ¨çš„æ—¶å€™å°±å¼€å¯ä¸€ä¸ªåç¨‹ ï¼Œæ¯éš”ä¸€æ®µæ—¶é—´å°±éå† å½“å‰æ‰€æœ‰è¿æ¥å¯¹è±¡ ï¼Œå¦‚æœå½“å‰æ—¶é—´ å‡å» è¿æ¥å¯¹è±¡é‡Œçš„æœ€è¿‘æ¥æ”¶æ—¶é—´ è¶…è¿‡å¿ƒè·³æ—¶é—´ï¼Œå°±è¯´æ˜ è¯¥è¿æ¥ å·²ç»æ­»äº†å°±æ‰§è¡Œåˆ é™¤</p>

<p>åœ¨å¤šå®¢æˆ·ç«¯åŒæ—¶è®¿é—®æœåŠ¡å™¨çš„å·¥ä½œæ¨¡å¼ä¸‹ï¼Œé¦–å…ˆè¦ä¿è¯æœåŠ¡å™¨çš„è¿è¡Œæ­£å¸¸ã€‚å› æ­¤ï¼ŒServerå’ŒClientå»ºç«‹é€šè®¯åï¼Œç¡®ä¿è¿æ¥çš„åŠæ—¶æ–­å¼€å°±éå¸¸é‡è¦ã€‚å¦åˆ™ï¼Œå¤šä¸ªå®¢æˆ·ç«¯é•¿æ—¶é—´å ç”¨ç€è¿æ¥ä¸å…³é—­ï¼Œæ˜¯éå¸¸å¯æ€•çš„æœåŠ¡å™¨èµ„æºæµªè´¹ã€‚ä¼šä½¿å¾—æœåŠ¡å™¨å¯æœåŠ¡çš„å®¢æˆ·ç«¯æ•°é‡å¤§å¹…åº¦å‡å°‘ã€‚</p>

<p>å› æ­¤ï¼Œé’ˆå¯¹çŸ­é“¾æ¥å’Œé•¿è¿æ¥ï¼Œæ ¹æ®ä¸šåŠ¡çš„éœ€æ±‚ï¼Œé…å¥—ä¸åŒçš„å¤„ç†æœºåˆ¶ã€‚</p>

<p>çŸ­è¿æ¥</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ä¸€èˆ¬å»ºç«‹å®Œè¿æ¥ï¼Œå°±ç«‹åˆ»ä¼ è¾“æ•°æ®ã€‚ä¼ è¾“å®Œæ•°æ®ï¼Œè¿æ¥å°±å…³é—­ã€‚æœåŠ¡ç«¯æ ¹æ®éœ€è¦ï¼Œè®¾å®šè¿æ¥çš„æ—¶é•¿ã€‚è¶…è¿‡æ—¶é—´é•¿åº¦ï¼Œå°±ç®—å®¢æˆ·ç«¯è¶…æ—¶ã€‚ç«‹åˆ»å…³é—­è¿æ¥ã€‚
</code></pre></div></div>

<p>é•¿è¿æ¥</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>å»ºç«‹è¿æ¥åï¼Œä¼ è¾“æ•°æ®ï¼Œç„¶åè¦ä¿æŒè¿æ¥ï¼Œç„¶åå†æ¬¡ä¼ è¾“æ•°æ®ã€‚ç›´åˆ°è¿æ¥å…³é—­ã€‚
</code></pre></div></div>

<p>socketè¯»å†™å¯ä»¥é€šè¿‡ SetDeadlineã€SetReadDeadlineã€SetWriteDeadlineè®¾ç½®é˜»å¡çš„æ—¶é—´ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>å¦‚æœåšçŸ­è¿æ¥ï¼Œç›´æ¥åœ¨Serverç«¯çš„è¿æ¥ä¸Šè®¾ç½®SetReadDeadlineã€‚å½“ä½ è®¾ç½®çš„æ—¶é™åˆ°è¾¾ï¼Œæ— è®ºå®¢æˆ·ç«¯æ˜¯å¦è¿˜åœ¨ç»§ç»­ä¼ é€’æ¶ˆæ¯ï¼ŒæœåŠ¡ç«¯éƒ½ä¸ä¼šå†æ¥æ”¶ã€‚å¹¶ä¸”å·²ç»å…³é—­è¿æ¥ã€‚
</code></pre></div></div>

<p>æ ¹æ®ä¸šåŠ¡éœ€è¦ï¼Œå®¢æˆ·ç«¯å¯èƒ½éœ€è¦é•¿æ—¶é—´ä¿æŒè¿æ¥ã€‚ä½†æ˜¯æœåŠ¡ç«¯ä¸èƒ½æ— é™åˆ¶çš„ä¿æŒã€‚è¿™å°±éœ€è¦ä¸€ä¸ªæœºåˆ¶ï¼Œå¦‚æœè¶…è¿‡æŸä¸ªæ—¶é—´é•¿åº¦ï¼ŒæœåŠ¡ç«¯æ²¡æœ‰è·å¾—å®¢æˆ·ç«¯çš„æ•°æ®ï¼Œå°±åˆ¤å®šå®¢æˆ·ç«¯å·²ç»ä¸éœ€è¦è¿æ¥äº†ï¼ˆæ¯”å¦‚å®¢æˆ·ç«¯æŒ‚æ‰äº†ï¼‰ã€‚</p>

<p>åšåˆ°è¿™ä¸ªï¼Œéœ€è¦ä¸€ä¸ªå¿ƒè·³æœºåˆ¶ã€‚åœ¨é™å®šçš„æ—¶é—´å†…ï¼Œå®¢æˆ·ç«¯ç»™æœåŠ¡ç«¯å‘é€ä¸€ä¸ªæŒ‡å®šçš„æ¶ˆæ¯ï¼Œä»¥ä¾¿æœåŠ¡ç«¯çŸ¥é“å®¢æˆ·ç«¯è¿˜æ´»ç€ã€‚</p>

<p>func sender(conn *net.TCPConn) {
    for i := 0; i &lt; 10; i++{
        words := strconv.Itoa(i)+â€ Hello Iâ€™m MyHeartbeat Client.â€
        msg, err := conn.Write([]byte(words))
        if err != nil {
            Log(conn.RemoteAddr().String(), â€œFatal error: â€œ, err)
            os.Exit(1)
        }
        Log(â€œæœåŠ¡ç«¯æ¥æ”¶äº†â€, msg)
        time.Sleep(2 * time.Second)
    }
    for i := 0; i &lt; 2 ; i++ {
        time.Sleep(12 * time.Second)
    }
    for i := 0; i &lt; 10; i++{
        words := strconv.Itoa(i)+â€ Hi Iâ€™m MyHeartbeat Client.â€
        msg, err := conn.Write([]byte(words))
        if err != nil {
            Log(conn.RemoteAddr().String(), â€œFatal error: â€œ, err)
            os.Exit(1)
        }
        Log(â€œæœåŠ¡ç«¯æ¥æ”¶äº†â€, msg)
        time.Sleep(2 * time.Second)
    }</p>

<p>}</p>

<p>è¿™æ®µå®¢æˆ·ç«¯ä»£ç ï¼Œå®ç°äº†ä¸¤ä¸ªç›¸åŒçš„ä¿¡æ¯å‘é€é¢‘ç‡ç»™æœåŠ¡ç«¯ã€‚ä¸¤ä¸ªé¢‘ç‡ä¸­é—´ï¼Œæˆ‘ä»¬è®©è¿è¡Œä¼‘æ¯äº†12ç§’ã€‚ç„¶åï¼Œæˆ‘ä»¬åœ¨æœåŠ¡ç«¯çš„å¯¹åº”æœºåˆ¶æ˜¯è¿™æ ·çš„ã€‚
func HeartBeating(conn net.Conn, bytes chan byte, timeout int) {
    select {
    case fk := &lt;- bytes:
        Log(conn.RemoteAddr().String(), â€œå¿ƒè·³:ç¬¬â€, string(fk), â€œtimesâ€)
        conn.SetDeadline(time.Now().Add(time.Duration(timeout) * time.Second))
        break</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    case &lt;- time.After(5 * time.Second):
        Log("conn dead now")
        conn.Close()
} }
</code></pre></div></div>

<p>æ¯æ¬¡æ¥æ”¶åˆ°å¿ƒè·³æ•°æ®å°± SetDeadline å»¶é•¿ä¸€ä¸ªæ—¶é—´æ®µ timeoutã€‚å¦‚æœæ²¡æœ‰æ¥åˆ°å¿ƒè·³æ•°æ®ï¼Œ5ç§’åè¿æ¥å…³é—­ã€‚</p>

<p>å¿ƒè·³æœºåˆ¶
â€ƒclientæ¯éš”å‡ åˆ†é’Ÿå‘é€ä¸€ä¸ªå›ºå®šä¿¡æ¯ç»™æœåŠ¡ç«¯ï¼ŒæœåŠ¡ç«¯æ”¶åˆ°åå›å¤ä¸€ä¸ªå›ºå®šä¿¡æ¯å¦‚æœæœåŠ¡ç«¯å‡ åˆ†é’Ÿå†…æ²¡æœ‰æ”¶åˆ°å®¢æˆ·ç«¯ä¿¡æ¯åˆ™è§†å®¢æˆ·ç«¯æ–­å¼€ã€‚å‘åŒ…æ–¹å¯ä»¥æ˜¯å®¢æˆ·ä¹Ÿå¯ä»¥æ˜¯æœåŠ¡ç«¯..
â€ƒå¿ƒè·³åŒ…ä¹‹æ‰€ä»¥å«å¿ƒè·³åŒ…æ˜¯å› ä¸ºï¼šå®ƒåƒå¿ƒè·³ä¸€æ ·æ¯éš”å›ºå®šæ—¶é—´å‘ä¸€æ¬¡ï¼Œä»¥æ­¤æ¥å‘Šè¯‰æœåŠ¡å™¨ï¼Œè¿™ä¸ªå®¢æˆ·ç«¯è¿˜æ´»ç€ã€‚äº‹å®ä¸Šè¿™æ˜¯ä¸ºäº†ä¿æŒé•¿è¿æ¥ï¼Œè‡³äºè¿™ä¸ªåŒ…çš„å†…å®¹ï¼Œæ˜¯æ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«è§„å®šçš„ï¼Œä¸è¿‡ä¸€èˆ¬éƒ½æ˜¯å¾ˆå°çš„åŒ…ï¼Œæˆ–è€…åªåŒ…å«åŒ…å¤´çš„ä¸€ä¸ªç©ºåŒ…ã€‚å¿ƒè·³åŒ…ä¸»è¦ä¹Ÿå°±æ˜¯ç”¨äºé•¿è¿æ¥çš„ä¿æ´»å’Œæ–­çº¿å¤„ç†ã€‚ä¸€èˆ¬çš„åº”ç”¨ä¸‹ï¼Œåˆ¤å®šæ—¶é—´åœ¨30-40ç§’æ¯”è¾ƒä¸é”™ã€‚å¦‚æœå®åœ¨è¦æ±‚é«˜ï¼Œé‚£å°±åœ¨6-9ç§’ã€‚</p>

<p>package main
import (
 â€œencoding/jsonâ€
 â€œerrorsâ€
 â€œflagâ€
 â€œfmtâ€
 â€œio/ioutilâ€
 â€œlogâ€
 â€œnetâ€
 â€œosâ€
 â€œstringsâ€
 â€œtimeâ€
)
// é•œåƒç»“æ„
type Image struct {
 Created uint64
 Id string
 ParentId string
 RepoTags []string
 Size uint64
 VirtualSize uint64
}
// å®¹å™¨ç»“æ„
type Container struct {
 Id string <code class="language-plaintext highlighter-rouge">json:"Id"</code>
 Names []string <code class="language-plaintext highlighter-rouge">json:"Names"</code>
 Image string <code class="language-plaintext highlighter-rouge">json:"Image"</code>
 ImageID string <code class="language-plaintext highlighter-rouge">json:"ImageID"</code>
 Command string <code class="language-plaintext highlighter-rouge">json:"Command"</code>
 Created uint64 <code class="language-plaintext highlighter-rouge">json:"Created"</code>
 State string <code class="language-plaintext highlighter-rouge">json:"State"</code>
 Status string <code class="language-plaintext highlighter-rouge">json:"Status"</code>
 Ports []Port <code class="language-plaintext highlighter-rouge">json:"Ports"</code>
 Labels map[string]string <code class="language-plaintext highlighter-rouge">json:"Labels"</code>
 HostConfig map[string]string <code class="language-plaintext highlighter-rouge">json:"HostConfig"</code>
 NetworkSettings map[string]interface{} <code class="language-plaintext highlighter-rouge">json:"NetworkSettings"</code>
 Mounts []Mount <code class="language-plaintext highlighter-rouge">json:"Mounts"</code>
}
// docker ç«¯å£æ˜ å°„
type Port struct {
 IP string <code class="language-plaintext highlighter-rouge">json:"IP"</code>
 PrivatePort int <code class="language-plaintext highlighter-rouge">json:"PrivatePort"</code>
 PublicPort int <code class="language-plaintext highlighter-rouge">json:"PublicPort"</code>
 Type string <code class="language-plaintext highlighter-rouge">json:"Type"</code>
}
// docker æŒ‚è½½
type Mount struct {
 Type string <code class="language-plaintext highlighter-rouge">json:"Type"</code>
 Source string <code class="language-plaintext highlighter-rouge">json:"Source"</code>
 Destination string <code class="language-plaintext highlighter-rouge">json:"Destination"</code>
 Mode string <code class="language-plaintext highlighter-rouge">json:"Mode"</code>
 RW bool <code class="language-plaintext highlighter-rouge">json:"RW"</code>
 Propatation string <code class="language-plaintext highlighter-rouge">json:"Propagation"</code>
}
// è¿æ¥åˆ—è¡¨
var SockAddr = â€œ/var/run//docker.sockâ€ //è¿™å¯ä¸æ˜¯éšä¾¿å†™çš„ï¼Œæ˜¯dockerå®˜ç½‘æ–‡æ¡£çš„å¥—æ¥å­—é»˜è®¤å€¼ï¼Œå½“ç„¶å®ˆæŠ¤è¿›ç¨‹é€šè®¯æ–¹å¼è¿˜æœ‰tcp,fdç­‰æ–¹å¼ï¼Œå„è‡ªéƒ½æœ‰é€‚ç”¨åœºæ™¯ã€‚ã€‚ã€‚
var imagesSock = â€œGET /images/json HTTP/1.0\r\n\r\nâ€ //dockerå¯¹å¤–çš„é•œåƒapiæ“ä½œ
var containerSock = â€œGET /containers/json?all=true HTTP/1.0\r\n\r\nâ€  //dockerå¯¹å¤–çš„å®¹å™¨æŸ¥çœ‹api
var startContainerSock = â€œPOST /containers/%s/start HTTP/1.0\r\n\r\nâ€ //dockerå¯¹å¤–çš„å®¹å™¨å¯åŠ¨api
// ç™½åå•
var whiteList []string
func main() {
 // è¯»å–å‘½ä»¤è¡Œå‚æ•°
 // ç™½åå•åˆ—è¡¨
 list := flag.String(â€œlistâ€, â€œâ€, â€œdocker white list to restart, eg: token,explorerâ€)
 // è½®è¯¢çš„æ—¶é—´é—´éš”ï¼Œå•ä½ç§’
 times := flag.Int64(â€œtimeâ€, 10, â€œtime interval to set read docker containers [second], default is 10 secondâ€)
 flag.Parse()
 // è§£ælist =&gt; whiteList
 whiteList = strings.Split(<em>list, â€œ,â€) //å°†æˆ‘ä»¬å‘½ä»¤è¡Œä¸­listå‚æ•°çš„å®¹å™¨åˆ—è¡¨è§£æåˆ°ä»£ç ä¸­
 log.SetOutput(os.Stdout)
 log.Println(â€œstart docker watchingâ€¦â€)
 log.Printf(â€œYour whiteList: %v\nâ€, *list)
 log.Printf(â€œYour shedule times: %ds\nâ€, *times)
  //æ¥ä¸‹æ¥çš„è¿™ä¸ªforå¾ªç¯å°±æ˜¯æ¯éš”ä¸€å®šæ—¶é—´ç›‘æ§dockerå®¹å™¨æ˜¯å¦æ­£å¸¸è¿è¡Œï¼Œä¸æ­£å¸¸å°±é‡æ–°å¯åŠ¨å®ƒ
 for {
  // è½®è¯¢docker
  err := listenDocker() 
  if err != nil {
   log.Println(err.Error())
  }
  time.Sleep(time.Duration(</em>times)<em>time.Second)
 }
}
func listenDocker() error {
 // è·å–å®¹å™¨åˆ—è¡¨,æ‹¿åˆ°æ‰€æœ‰çš„å®¹å™¨ä¿¡æ¯
 containers, err := readContainer() 
 if err != nil {
  return errors.New(â€œread container error: â€œ + err.Error())
 }
 // å…ˆéå†ç™½åå•å¿«ï¼Œæ¬¡æ•°å°‘
 for _, name := range whiteList {
 Name:
  for _, container := range containers {
   for _, cname := range container.Names {
    // å¦‚æœåŒ¹é…åˆ°ç™½åå•
    if cname[1:] == name {
     // å…³å¿ƒä¸€ä¸‹å®¹å™¨çŠ¶æ€
     log.Printf(â€œid=%s, name=%s, state=%sâ€, container.Id[:12], container.Names, container.Status)
     if strings.Contains(container.Status, â€œExitedâ€) {
      // å¦‚æœå‡ºç°å¼‚å¸¸é€€å‡ºçš„å®¹å™¨ï¼Œå¯åŠ¨å®ƒ
      log.Printf(â€œfind container: [%s] has exited, ready to start it. â€œ, name)
      e := startContainer(container.Id)
      if e != nil {
       log.Println(â€œstart container error: â€œ, e.Error())
      }
      break Name
     }
    }
   }
  }
 }
 return nil
}
// è·å– unix sock è¿æ¥
func connectDocker() (</em>net.UnixConn, error) {
 addr := net.UnixAddr{SockAddr, â€œunixâ€}  // SockAddr è¿™ä¸ªå˜é‡çš„å€¼è¢«è®¾å®šä¸ºdockerçš„/var/run/docker å¥—æ¥å­—è·¯å¾„å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´æ­¤å¤„å°±æ˜¯æ‹¨é€šä¸dockerçš„daemoné€šè®¯å»ºç«‹çš„å…³é”®å¤„,å…¶ä»–å¤„çš„ä»£ç å°±æ˜¯äº›æ­£å¸¸çš„é€»è¾‘å¤„ç†äº†
 return net.DialUnix(â€œunixâ€, nil, &amp;addr)
}
// å¯åŠ¨å®¹å™¨
func startContainer(id string) error {
 conn, err := connectDocker()
 if err != nil {
  return errors.New(â€œconnect error: â€œ + err.Error())
 }
 start := fmt.Sprintf(startContainerSock, id)
 fmt.Println(start)
 cmd := []byte(start)
 code, err := conn.Write(cmd)
 if err != nil {
  return err
 }
 log.Println(â€œstart container response code: â€œ, code)
 // å¯åŠ¨å®¹å™¨ç­‰å¾…20ç§’ï¼Œé˜²æ­¢æ•°æ®é‡å‘
 time.Sleep(20<em>time.Second)
 return nil
}
// è·å–å®¹å™¨åˆ—è¡¨
func readContainer() ([]Container, error) {
 conn, err := connectDocker() //å»ºç«‹ä¸€ä¸ªunixè¿æ¥,è¿™å…¶å®æ˜¯ä¸€ä¸ªå…³é”®ç‚¹ï¼Œéœ€è¦ä½ äº†è§£unix å¥—æ¥å­— å»ºç«‹è¿æ¥
 if err != nil {
  return nil, errors.New(â€œconnect error: â€œ + err.Error())
 }
 _, err = conn.Write([]byte(containerSock))
 if err != nil {
  return nil, err
 }
 result, err := ioutil.ReadAll(conn)
 if err != nil {
  return nil, err
 }
 body := getBody(result)
 var containers []Container
 err = json.Unmarshal(body, &amp;containers)
 if err != nil {
  return nil, err
 }
 log.Println(â€œlen of containers: â€œ, len(containers))
 if len(containers) == 0 {
  return nil, errors.New(â€œno containersâ€)
 }
 return containers, nil
}
// è·å–é•œåƒåˆ—è¡¨
func readImage(conn *net.UnixConn) ([]Image, error) {
 _, err := conn.Write([]byte(imagesSock))
 if err != nil {
  return nil, err
 }
 result, err := ioutil.ReadAll(conn)
 if err != nil {
  return nil, err
 }
 body := getBody(result[:])
 var images []Image
 err = json.Unmarshal(body, &amp;images)
 if err != nil {
  return nil, err
 }
 return images, nil
}
// ä»è¿”å›çš„ http å“åº”ä¸­æå– body
func getBody(result []byte) (body []byte) {
 for i:=0; i&lt;=len(result)-4; i++ {
  if result[i] == 13 &amp;&amp; result[i+1] == 10 &amp;&amp; result[i+2] == 13 &amp;&amp; result[i+3] == 10 {
   body = result[i+4:]
   break
  }
 }
 return
}
/</em>
error log :
 1ã€write unix @-&gt;/var/run/docker.sock: write: broken pipe
  å»ºç«‹çš„tcpè¿æ¥ä¸èƒ½å¤ç”¨ï¼Œæ¯æ¬¡æ“ä½œéƒ½å»ºç«‹è¿æ¥
 */
ä½¿ç”¨æ–¹æ³•</p>

<p>1.ç¼–è¯‘</p>

<p>go build -o main main.go</p>

<p>2.linuxä¸‹ç›´æ¥å½“å¯æ‰§è¡Œæ–‡ä»¶æ‰§è¡Œä¾¿å¯</p>

<p>./main -list=â€å®¹å™¨åç§°1,å®¹å™¨åç§°2â€¦â€</p>

<p>æ€è·¯åˆ†æ:</p>

<p>åŸæ¥dockerè¿™ä¸ªè½¯ä»¶å¯¹å¤–æ˜¯æä¾›äº†ä¸€äº›åˆ—apiç”¨æ¥ç®¡ç†å®¹å™¨çš„å¢åˆ è¯¥æŸ¥çš„ å®˜æ–¹apiæ–‡æ¡£ ,æ—¢ç„¶æä¾›äº†apiäº†é‚£ä¹ˆä»»ä½•è¯­è¨€éƒ½èƒ½å®ç°å¯¹å…¶çš„ç®¡ç†æ§åˆ¶åŠåŠ¨æ€éƒ¨ç½²äº†ã€‚</p>

<p>ä½†å…¶å®è¿™é‡Œé¢çœŸè¦å¼„æ˜ç™½è¿˜æ˜¯æœ‰å¾ˆå¤šè¯è¦è®²äº†</p>

<p>dockerè¿™ä¸ªæœåŠ¡å·²ç»å·²è¿›ç¨‹çš„å½¢å¼è¿è¡Œåœ¨linuxçš„ç³»ç»Ÿä¸­äº†ï¼Œä¸ºä»€ä¹ˆæˆ‘ä»¬è¾“å…¥dockeræœ‰å…³çš„å‘½ä»¤èƒ½å¤Ÿä¸ä¹‹äº¤äº’ï¼Œè¿™å¥½åƒæ˜¯ä¸€ä¸ªä¹ ä»¥ä¸ºå¸¸çš„è¡Œä¸ºï¼Œè²Œä¼¼ç†åº”å¦‚æ­¤ï¼Œä½†æ˜¯è¦çŸ¥é“æˆ‘ä»¬æ˜¯åœ¨ä¸ä¸€ä¸ªæ­£åœ¨è¿è¡Œçš„è¿›ç¨‹å‘ç”Ÿé€šè®¯ï¼Œè‹¥ä»ä¸ä»¥ä¸ºç„¶ï¼Œè¯·æ¥ä»¥ä¸‹é—®ï¼š</p>

<p>1.è¿›ç¨‹é—´éƒ½æ˜¯å¦‚ä½•é€šè®¯çš„ï¼Ÿ è¿›ç¨‹é€šè®¯é—´æ–¹å¼</p>

<p>åœ¨æ˜ç™½äº†è¿›ç¨‹ä¹‹é—´çš„é€šè®¯æ–¹å¼ä¹‹åï¼Œæˆ‘æ˜ç™½äº†dockerçš„è¿™ä¸ªdaemoné€šè®¯åŸç†ï¼Œç¬é—´å°±æ‰“é€šäº†ä¹‹å‰å¯¹k8ç®¡ç†dockerçš„ç–‘æƒ‘(è€å®è®²åªçŸ¥é“kuberneteså¾ˆå¼ºå¤§,å´æ²¡æƒ³æ˜ç™½å®ƒæ˜¯å¦‚ä½•èƒ½åŠ¨æ€å¢å®¹æˆ‘çš„å®¹å™¨é…ç½®,è´Ÿè½½ç­‰ç­‰ç­‰),å¥—æ¥å­—(socket) /var/run/docker è¿™ä¸ªæˆ‘ä»¬ä½¿ç”¨èµ·æ¥ä¸ä¼šæ¥è§¦åˆ°ï¼Œç†è§£èµ·æ¥å´å¿…é¡»æ‰“é€šçš„å…³é”®ç‚¹è¯·åŠ¡å¿…äº†è§£å®ƒã€‚</p>

:ET