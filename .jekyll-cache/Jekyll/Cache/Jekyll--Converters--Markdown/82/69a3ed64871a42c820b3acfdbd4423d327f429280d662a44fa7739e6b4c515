I"*<p>预防半连接攻击，SYN-Cookie是一种有效的机制，它的基本原理非常简单，那就是“完成三次握手前不为任何一个连接分配任何资源
1.编码信息
将一些本应该在本地保存的信息编码到返回给客户端的SYN-ACK的初始化序列号或者时间戳里面。握手尚未完成不分配任何资源(Linux即不分配request结构体)。
2.解码信息
等到客户端的ACK最终到来的时候，再从ACK序列号里面解码出保存的信息。
3.建立连接
利用第2步解码出来的信息建立一个TCP连接，此时因为握手已经完成，可以分配资源了。
<!-- more -->
编码过程图示
	<img src="https://xiazemin.github.io/MyBlog/img/syncookie_encode.jpeg" />
解码过程图示
		<img src="https://xiazemin.github.io/MyBlog/img/syncookie_decode.jpeg" />
通过上面的编码解码过程中好像没有什么check/compare操作，一般而言，对于类似HASH或者摘要的算法，都需要对信息进行比对，比如对一段信息生产一个摘要，为了确保该信息没有被篡改，需要再次使用相同的算法生成摘要，如果两段摘要的值不同，说明信息被篡改了！对于上面的算法，在生产Cookie的时候，我们注意到使用hash算法对元组生产了一个值，但是对于解码的过程，它并没有再次计算这个值与原始携带的值做比对，这样合理吗？
        这事实上是Linux的一个hack！Linux将一段data做了限定，比如它的值严格在0-7之间，将这个data一同参与运算，而不是仅仅将其编码到固定的某几个bit，算法寄希望于：如果数据是伪造的或者被篡改了，那么解码出来的data的值仍然处在规定的严格区间里的可能性微乎其微！
24比特数据的编码和解码的过程：</p>
:ET