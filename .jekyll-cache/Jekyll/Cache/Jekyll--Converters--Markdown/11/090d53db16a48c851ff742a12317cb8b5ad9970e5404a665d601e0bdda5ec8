I"³<p>è¿™ä¸ªé—®é¢˜è¦ä»net/http/pprofçš„åŸç†è¯´èµ·ï¼Œå¯ä»¥çœ‹åˆ°
func init() {
    http.HandleFunc(â€œ/debug/pprof/â€, Index)
    http.HandleFunc(â€œ/debug/pprof/cmdlineâ€, Cmdline)
    http.HandleFunc(â€œ/debug/pprof/profileâ€, Profile)
    http.HandleFunc(â€œ/debug/pprof/symbolâ€, Symbol)
    http.HandleFunc(â€œ/debug/pprof/traceâ€, Trace)
}
å¼•å…¥ _ â€œnet/http/pprofâ€ï¼Œinitå‡½æ•°ä¼šæ·»åŠ pprofçš„è·¯ç”±ä¿¡æ¯åˆ°defaultMutexï¼Œè€Œå¦‚æœhttpæ³¨å†Œäº†å…¶ä»–è·¯ç”±ï¼Œå¯¼è‡´http.HandleFuncå¤±æ•ˆï¼Œä¹Ÿå°±ä¼šé€ æˆäº†404çš„é—®é¢˜
<!-- more -->
type Server struct {
	Addr    string  // TCP address to listen on, â€œ:httpâ€ if empty
	Handler Handler // handler to invoke, http.DefaultServeMux if nil
â€¦
}</p>

<p>type serverHandler struct {
	srv *Server
}</p>

<p>func (sh serverHandler) ServeHTTP(rw ResponseWriter, req <em>Request) {
	handler := sh.srv.Handler
	if handler == nil {
		handler = DefaultServeMux
	}
	if req.RequestURI == â€œ</em>â€ &amp;&amp; req.Method == â€œOPTIONSâ€ {
		handler = globalOptionsHandler{}
	}
	handler.ServeHTTP(rw, req)
}</p>

<p>å¦‚æœsh.srv.Handler éç©ºå°±ä¸ä¼šä½¿ç”¨é»˜è®¤çš„router</p>

<p>handlerçš„æ³¨å†Œ
func ListenAndServe(addr string, handler Handler) error {
	server := &amp;Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}</p>

<p>é»˜è®¤è·¯ç”±çš„æ³¨å†Œ
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	DefaultServeMux.HandleFunc(pattern, handler)
}</p>

<p>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
	if handler == nil {
		panic(â€œhttp: nil handlerâ€)
	}
	mux.Handle(pattern, HandlerFunc(handler))
}</p>

<p>func (mux *ServeMux) Handle(pattern string, handler Handler) {
	e := muxEntry{h: handler, pattern: pattern}
	mux.m[pattern] = e
}</p>

<p>var DefaultServeMux = &amp;defaultServeMux</p>

<p>var defaultServeMux ServeMux</p>

<p>æˆ‘ä½¿ç”¨çš„æ˜¯httprouteråŒ…
è®¿é—®http://localhost:8080/debug/pprof/goroutine?debug=1ç­‰å…¶ä»–å†…éƒ¨é¡µé¢æ—¶ï¼Œä»æ—§æŠ¥404ï¼Œå†æ¬¡åˆ†æåŸå› ï¼Œhttprouteræ·»åŠ è·¯ç”±ä¿¡æ¯ï¼Œå¦‚ç¬¬ä¸€æ¡ï¼Œä»…æ·»åŠ äº†/debug/pprof/çš„è·¯ç”±ä¿¡æ¯ï¼Œå¹¶ä¸ä¼šå¯¹å­è·¯å¾„ä½œè·¯ç”±ç‰µå¼•ï¼Œå¯¼è‡´404</p>

<p>æ‰€ä»¥è§£å†³åŠæ³•ï¼š</p>

<p>ç”¨http.Handle(â€œ/â€, router) å°†httprouterçš„è·¯ç”±æ³¨å†Œç»™httpè·¯ç”±ï¼Œhttp.ListenAndServe(addr, nil) æ›¿ä»£http.ListenAndServe(addr, router)ï¼Œè¿™æ—¶ï¼Œrouterå’Œhttp/pproféƒ½å¯ä»¥ç”Ÿæ•ˆäº†</p>

<p>http.Handle(â€œ/â€, router)
http.ListenAndServe(addr, nil)
å½“ç„¶è¿˜å¯ä»¥ç”¨ç¬¬ä¸‰æ–¹routerçš„prefixåŠŸèƒ½ï¼Œå¦‚Gorillaçš„</p>

<p>router.NewRoute().PathPrefix(â€œ/debug/pprof/â€).HandlerFunc(pprof.Index)</p>

<p>/debug/pprof/profileï¼šè®¿é—®è¿™ä¸ªé“¾æ¥ä¼šè‡ªåŠ¨è¿›è¡Œ CPU profilingï¼ŒæŒç»­ 30sï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªæ–‡ä»¶ä¾›ä¸‹è½½
/debug/pprof/blockï¼šGoroutineé˜»å¡äº‹ä»¶çš„è®°å½•ã€‚é»˜è®¤æ¯å‘ç”Ÿä¸€æ¬¡é˜»å¡äº‹ä»¶æ—¶å–æ ·ä¸€æ¬¡ã€‚
/debug/pprof/goroutinesï¼šæ´»è·ƒGoroutineçš„ä¿¡æ¯çš„è®°å½•ã€‚ä»…åœ¨è·å–æ—¶å–æ ·ä¸€æ¬¡ã€‚
/debug/pprof/heapï¼š å †å†…å­˜åˆ†é…æƒ…å†µçš„è®°å½•ã€‚é»˜è®¤æ¯åˆ†é…512Kå­—èŠ‚æ—¶å–æ ·ä¸€æ¬¡ã€‚
/debug/pprof/mutex: æŸ¥çœ‹äº‰ç”¨äº’æ–¥é”çš„æŒæœ‰è€…ã€‚
/debug/pprof/threadcreate: ç³»ç»Ÿçº¿ç¨‹åˆ›å»ºæƒ…å†µçš„è®°å½•ã€‚ ä»…åœ¨è·å–æ—¶å–æ ·ä¸€æ¬¡ã€‚</p>

<p>go tool pprof http://localhost:6060/debug/pprof/profile?seconds=600</p>

<p>flatï¼šç»™å®šå‡½æ•°ä¸Šè¿è¡Œè€—æ—¶
flat%ï¼šåŒä¸Šçš„ CPU è¿è¡Œè€—æ—¶æ€»æ¯”ä¾‹
sum%ï¼šç»™å®šå‡½æ•°ç´¯ç§¯ä½¿ç”¨ CPU æ€»æ¯”ä¾‹
cumï¼šå½“å‰å‡½æ•°åŠ ä¸Šå®ƒä¹‹ä¸Šçš„è°ƒç”¨è¿è¡Œæ€»è€—æ—¶
cum%ï¼šåŒä¸Šçš„ CPU è¿è¡Œè€—æ—¶æ€»æ¯”ä¾‹
 go tool pprof http://localhost:56887/debug/pprof/heap</p>

<p>-inuse_spaceï¼šåˆ†æåº”ç”¨ç¨‹åºçš„å¸¸é©»å†…å­˜å ç”¨æƒ…å†µ
-alloc_objectsï¼šåˆ†æåº”ç”¨ç¨‹åºçš„å†…å­˜ä¸´æ—¶åˆ†é…æƒ…å†µ</p>

<p>https://github.com/caibirdme/hand-to-hand-optimize-go</p>
:ET