I"Á4<p>æˆ‘ä»¬åœ¨å¼€å‘æ—¶ï¼Œæœ‰æ—¶ä¼šç¢°åˆ°ä¸€ä¸ªæ¥å£çš„è®¿é—®é‡çªç„¶ä¸Šå‡ï¼Œå¯¼è‡´æœåŠ¡å“åº”å»¶è¿Ÿæˆ–è€…å®•æœºçš„æƒ…å†µã€‚è¿™æ—¶ï¼Œé™¤äº†åˆ©ç”¨ç¼“å­˜ä¹‹å¤–ï¼Œä¹Ÿå¯ä»¥ç”¨åˆ°singlefilghtæ¥è§£å†³
package main</p>

<p>import (
    â€œfmtâ€
    â€œsyncâ€
    â€œsync/atomicâ€
    â€œtimeâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"golang.org/x/sync/singleflight" )
</code></pre></div></div>

<p>func main() {
    g := singleflight.Group{}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wg := sync.WaitGroup{}

for i := 0; i &lt; 100; i++ {
    wg.Add(1)
    go func(j int) {
        defer wg.Done()
        val, err, shared := g.Do("a", a)
        if err != nil {
            fmt.Println(err)
            return
        }
        fmt.Printf("index: %d, val: %d, shared: %v\n", j, val, shared)
    }(i)
}

wg.Wait()
</code></pre></div></div>

<p>}</p>

<p>var (
    count = int64(0)
)</p>

<p>// æ¨¡æ‹Ÿæ¥å£æ–¹æ³•
func a() (interface{}, error) {
    time.Sleep(time.Millisecond * 500)
    return atomic.AddInt64(&amp;count, 1), nil
}</p>

<p>// éƒ¨åˆ†è¾“å‡ºï¼Œsharedè¡¨ç¤ºæ˜¯å¦å…±äº«äº†å…¶ä»–è¯·æ±‚çš„è¿”å›ç»“æœ
index: 2, val: 1, shared: false
index: 71, val: 1, shared: true
index: 69, val: 1, shared: true
index: 73, val: 1, shared: true
index: 8, val: 1, shared: true
index: 24, val: 1, shared: true
<!-- more -->
valè¿™é‡Œç»å¤§éƒ¨åˆ†éƒ½ä¸º1æ˜¯å› ä¸ºç¨‹åºè¿è¡Œæ—¶é—´å¤ªå¿«äº†ï¼Œå¯ä»¥è¯•ç€æŠŠtime.Sleepæ—¶é—´ç¼©çŸ­ä¸€ç‚¹çœ‹çœ‹æ•ˆæœ</p>

<p>singleflightæ ¸å¿ƒä»£ç éå¸¸ç®€å•</p>

<p>// æˆå‘˜éå¸¸å°‘ï¼Œå°±ä¸¤ä¸ª
type Group struct {
    mu sync.Mutex    <br />
    m  map[string]*call
}</p>

<p>func (g <em>Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) {
    g.mu.Lock()
    if g.m == nil {
        g.m = make(map[string]</em>call)
    }
    // åˆ¤æ–­keyæ˜¯å¦å­˜åœ¨ï¼Œå­˜åœ¨åˆ™è¡¨ç¤ºæœ‰å…¶ä»–è¯·æ±‚å…ˆä¸€æ­¥è¿›æ¥ï¼Œ
    // ç›´æ¥ç­‰å¾…å…¶ä»–è¯·æ±‚è¿”å›å°±è¡Œ
    if c, ok := g.m[key]; ok {
        c.dups++
        g.mu.Unlock()
        c.wg.Wait()
        return c.val, c.err, true
    }
    // ä¸å­˜åœ¨å°±åˆ›å»ºä¸€ä¸ªæ–°çš„callå¯¹è±¡ï¼Œç„¶åå»æ‰§è¡Œ
    c := new(call)
    c.wg.Add(1)
    g.m[key] = c
    g.mu.Unlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g.doCall(c, key, fn)
return c.val, c.err, c.dups &gt; 0 } doCallæ–¹æ³•å¾ˆç®€å•ï¼Œè¿™é‡Œå°±ä¸å±•å¼€äº†ï¼Œé™¤äº†Doæ–¹æ³•ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªå¼‚æ­¥çš„DoChanæ–¹æ³•ï¼ŒåŸç†ä¸€æ¨¡ä¸€æ ·ã€‚
</code></pre></div></div>

<p>æˆ‘ä»¬ä¸€èˆ¬å¯ä»¥åœ¨ä¸€äº›ç±»ä¼¼äºå¹‚ç­‰çš„æ¥å£ä¸Šç”¨singleflight</p>

<p>singleflight.goæ–‡ä»¶ä¸­æ˜¯singleflightæ¨¡å—çš„ä»£ç ï¼Œè¿™ä¸»è¦æ˜¯è¿›è¡Œç›¸åŒè®¿é—®çš„ä¸€ä¸ªåˆå¹¶æ“ä½œã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœå¯¹äºæŸä¸ªkeyçš„è¯·æ±‚å·²ç»å­˜åœ¨å¹¶ä¸”æ­£åœ¨è¿›è¡Œï¼Œåˆ™å¯¹è¯¥keyçš„æ–°çš„è¯·æ±‚ä¼šå µå¡åœ¨è¿™é‡Œï¼Œç­‰åŸæ¥çš„è¯·æ±‚ç»“æŸåï¼Œå°†è¯·æ±‚å¾—åˆ°çš„ç»“æœåŒæ—¶è¿”å›ç»™å µå¡ä¸­çš„è¯·æ±‚ã€‚</p>

<p>è¯¥éƒ¨åˆ†å°±å°è£…äº†ä¸€ä¸ªæ¥å£ï¼š</p>

<p>func (g *Group) Do(key string, fn func() (interface{}, error)) (interface{}, error)
1
é¦–å…ˆï¼Œå…ˆå®šä¹‰äº†ä¸‹é¢ä¸¤ä¸ªç»“æ„ä½“ï¼š</p>

<p>//å®é™…è¯·æ±‚å‡½æ•°çš„å°è£…ç»“æ„ä½“
// call is an in-flight or completed Do call
type call struct {
	wg  sync.WaitGroup
	//å®é™…çš„è¯·æ±‚å‡½æ•°
	val interface{}
	err error
}</p>

<p>//ä¸»è¦æ˜¯ç”¨æ¥ç»„ç»‡å·²ç»å­˜åœ¨çš„å¯¹æŸkeyçš„è¯·æ±‚å’Œå¯¹åº”çš„å®é™…è¯·æ±‚å‡½æ•°æ˜ å°„
// Group represents a class of work and forms a namespace in which
// units of work can be executed with duplicate suppression.
type Group struct {
	//ç”¨äºå¯¹mä¸Šé”ï¼Œä¿æŠ¤m
	mu sync.Mutex       // protects m
	m  map[string]*call // lazily initialized
}</p>

<p>ä¸‹é¢å…·ä½“è®²è§£ä¸€ä¸‹è¿™ä¸ªå‡½æ•°ã€‚</p>

<p>è¯¥å‡½æ•°å…¥å‚æ˜¯ä¸€ä¸ªkeyå’Œä¸€ä¸ªå®é™…è¯·æ±‚å‡½æ•°ï¼Œå‡ºå‚æ˜¯ä¸€ä¸ªæ¥å£ç±»å‹å’Œä¸€ä¸ªé”™è¯¯ç±»å‹ã€‚</p>

<p>è¿™é‡Œåˆ©ç”¨äº†goçš„é”æœºåˆ¶ï¼Œæ¯”å¦‚Metuxã€WaitGroupç­‰ã€‚</p>

<p>// Do executes and returns the results of the given function, making
// sure that only one execution is in-flight for a given key at a
// time. If a duplicate comes in, the duplicate caller waits for the
// original to complete and receives the same results.
func (g <em>Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) {
	//æœ‰å¯èƒ½è¦ä¿®æ”¹mï¼Œæ‰€ä»¥å…ˆä¸Šé”è¿›è¡Œä¿æŠ¤
	g.mu.Lock()
	//å¦‚æœmä¸ºnilï¼Œåˆ™åˆå§‹åŒ–ä¸€ä¸ª
	if g.m == nil {
		g.m = make(map[string]</em>call)
	}
	//å¦‚æœmä¸­å­˜åœ¨å¯¹è¯¥keyçš„è¯·æ±‚ï¼Œåˆ™è¯¥çº¿ç¨‹ä¸ä¼šç›´æ¥å†æ¬¡è®¿é—®keyï¼Œæ‰€ä»¥é‡Šæ”¾é”
	//ç„¶åå µå¡ç­‰å¾…å·²ç»å­˜åœ¨çš„è¯·æ±‚å¾—åˆ°çš„ç»“æœ
	if c, ok := g.m[key]; ok {
		//è§£é”
		g.mu.Unlock()
		//å µå¡
		c.wg.Wait()
		//å¦‚æœå·²ç»å­˜åœ¨çš„è¯·æ±‚å®Œæˆï¼Œåˆ™å µå¡çŠ¶æ€ä¼šè§£é™¤ï¼Œç»§ç»­å‘ä¸‹æ‰§è¡Œï¼Œå¾—åˆ°æ­£ç¡®ç»“æœ
		return c.val, c.err
	}
	//å¦‚æœä¸å­˜åœ¨å¯¹è¯¥keyçš„è¯·æ±‚ï¼Œåˆ™æœ¬çº¿ç¨‹è¦è¿›è¡Œå®é™…çš„è¯·æ±‚ï¼Œä¿æŒmçš„é”å®šçŠ¶æ€
	//åˆ›å»ºä¸€ä¸ªå®é™…è¯·æ±‚ç»“æ„ä½“
	c := new(call)
	//ä¸ºäº†ä¿è¯å…¶ä»–çš„ç›¸åŒè¯·æ±‚çš„å µå¡
	c.wg.Add(1)
	//ç»„ç»‡å¥½æ˜ å°„å…³ç³»
	g.m[key] = c
	//è§£é”m
	g.mu.Unlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//æ‰§è¡ŒçœŸæ­£çš„è¯·æ±‚å‡½æ•°ï¼Œå¾—åˆ°å¯¹è¯¥keyè¯·æ±‚çš„ç»“æœ
c.val, c.err = fn()
//å¾—åˆ°ç»“æœåå–æ¶ˆå…¶ä»–è¯·æ±‚çš„å µå¡
c.wg.Done()

//è¯¥æ¬¡è¯·æ±‚å®Œæˆåï¼Œè¦ä»å·²å­˜åœ¨è¯·æ±‚mapä¸­åˆ æ‰
g.mu.Lock()
delete(g.m, key)
g.mu.Unlock()

//è¿”å›è¯·æ±‚ç»“æœ
return c.val, c.err }
</code></pre></div></div>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œsyncâ€
	â€œtimeâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/golang/groupcache/singleflight" )
</code></pre></div></div>

<p>func NewDelayReturn(dur time.Duration, n int) func() (interface{}, error) {
	return func() (interface{}, error) {
		time.Sleep(dur)
		return n, nil
	}
}</p>

<p>func main() {
	g := singleflight.Group{}
	wg := sync.WaitGroup{}
	wg.Add(2)
	go func() {
		ret, err := g.Do(â€œkeyâ€, NewDelayReturn(time.Second<em>1, 1))
		if err != nil {
			panic(err)
		}
		fmt.Printf(â€œkey-1 get %v\nâ€, ret)
		wg.Done()
	}()
	go func() {
		time.Sleep(100 * time.Millisecond) // make sure this is call is later
		ret, err := g.Do(â€œkeyâ€, NewDelayReturn(time.Second</em>2, 2))
		if err != nil {
			panic(err)
		}
		fmt.Printf(â€œkey-2 get %v\nâ€, ret)
		wg.Done()
	}()
	wg.Wait()
}
æ‰§è¡Œç»“æœ(è€—æ—¶ï¼š 1.019s)</p>

<p>key-2 get 1
key-1 get 1</p>

<p>èƒŒæ™¯
å…ˆæ¥äº†è§£ä¸€ä¸‹ç¼“å­˜é—®é¢˜çš„å‡ ç§åœºæ™¯ï¼Œä»¥redisä¸ºä¾‹</p>

<p>ç¼“å­˜ç©¿é€
ç¼“å­˜ç©¿é€ï¼Œæ˜¯æŒ‡æŸ¥è¯¢ä¸€ä¸ªæ•°æ®åº“ä¸€å®šä¸å­˜åœ¨çš„æ•°æ®ã€‚æ­£å¸¸çš„ä½¿ç”¨ç¼“å­˜æµç¨‹å¤§è‡´æ˜¯ï¼Œæ•°æ®æŸ¥è¯¢å…ˆè¿›è¡Œç¼“å­˜æŸ¥è¯¢ï¼Œå¦‚æœkeyä¸å­˜åœ¨æˆ–è€…keyå·²ç»è¿‡æœŸï¼Œå†å¯¹æ•°æ®åº“è¿›è¡ŒæŸ¥è¯¢ï¼Œå¹¶æŠŠæŸ¥è¯¢åˆ°çš„å¯¹è±¡ï¼Œæ”¾è¿›ç¼“å­˜ã€‚å¦‚æœæ•°æ®åº“æŸ¥è¯¢å¯¹è±¡ä¸ºç©ºï¼Œåˆ™ä¸æ”¾è¿›ç¼“å­˜ã€‚</p>

<p>ä»£ç æµç¨‹
1.å‚æ•°ä¼ å…¥å¯¹è±¡ä¸»é”®ID
2.æ ¹æ®keyä»ç¼“å­˜ä¸­è·å–å¯¹è±¡
3.å¦‚æœå¯¹è±¡ä¸ä¸ºç©ºï¼Œç›´æ¥è¿”å›
4.å¦‚æœå¯¹è±¡ä¸ºç©ºï¼Œè¿›è¡Œæ•°æ®åº“æŸ¥è¯¢
5.å¦‚æœä»æ•°æ®åº“æŸ¥è¯¢å‡ºçš„å¯¹è±¡ä¸ä¸ºç©ºï¼Œåˆ™æ”¾å…¥ç¼“å­˜ï¼ˆè®¾å®šè¿‡æœŸæ—¶é—´ï¼‰
æƒ³è±¡ä¸€ä¸‹è¿™ä¸ªæƒ…å†µï¼Œå¦‚æœä¼ å…¥çš„å‚æ•°ä¸º-1ï¼Œä¼šæ˜¯æ€ä¹ˆæ ·ï¼Ÿè¿™ä¸ª-1ï¼Œå°±æ˜¯ä¸€å®šä¸å­˜åœ¨çš„å¯¹è±¡ã€‚å°±ä¼šæ¯æ¬¡éƒ½å»æŸ¥è¯¢æ•°æ®åº“ï¼Œè€Œæ¯æ¬¡æŸ¥è¯¢éƒ½æ˜¯ç©ºï¼Œæ¯æ¬¡åˆéƒ½ä¸ä¼šè¿›è¡Œç¼“å­˜ã€‚å‡å¦‚æœ‰æ¶æ„æ”»å‡»ï¼Œå°±å¯ä»¥åˆ©ç”¨è¿™ä¸ªæ¼æ´ï¼Œå¯¹æ•°æ®åº“é€ æˆå‹åŠ›ï¼Œç”šè‡³å‹å®æ•°æ®åº“ã€‚å³ä¾¿æ˜¯é‡‡ç”¨UUIDï¼Œä¹Ÿæ˜¯å¾ˆå®¹æ˜“æ‰¾åˆ°ä¸€ä¸ªä¸å­˜åœ¨çš„KEYï¼Œè¿›è¡Œæ”»å‡»ã€‚</p>

<p>å°ç¼–åœ¨å·¥ä½œä¸­ï¼Œä¼šé‡‡ç”¨ç¼“å­˜ç©ºå€¼çš„æ–¹å¼ï¼Œä¹Ÿå°±æ˜¯ã€ä»£ç æµç¨‹ã€‘ä¸­ç¬¬5æ­¥ï¼Œå¦‚æœä»æ•°æ®åº“æŸ¥è¯¢çš„å¯¹è±¡ä¸ºç©ºï¼Œä¹Ÿæ”¾å…¥ç¼“å­˜ï¼Œåªæ˜¯è®¾å®šçš„ç¼“å­˜è¿‡æœŸæ—¶é—´è¾ƒçŸ­ï¼Œæ¯”å¦‚è®¾ç½®ä¸º60ç§’ã€‚</p>

<p>ç¼“å­˜é›ªå´©
ç¼“å­˜é›ªå´©ï¼Œæ˜¯æŒ‡åœ¨æŸä¸€ä¸ªæ—¶é—´æ®µï¼Œç¼“å­˜é›†ä¸­è¿‡æœŸå¤±æ•ˆã€‚</p>

<p>äº§ç”Ÿé›ªå´©çš„åŸå› ä¹‹ä¸€ï¼Œæ¯”å¦‚åœ¨å†™æœ¬æ–‡çš„æ—¶å€™ï¼Œé©¬ä¸Šå°±è¦åˆ°åŒåäºŒé›¶ç‚¹ï¼Œå¾ˆå¿«å°±ä¼šè¿æ¥ä¸€æ³¢æŠ¢è´­ï¼Œè¿™æ³¢å•†å“æ—¶é—´æ¯”è¾ƒé›†ä¸­çš„æ”¾å…¥äº†ç¼“å­˜ï¼Œå‡è®¾ç¼“å­˜ä¸€ä¸ªå°æ—¶ã€‚é‚£ä¹ˆåˆ°äº†å‡Œæ™¨ä¸€ç‚¹é’Ÿçš„æ—¶å€™ï¼Œè¿™æ‰¹å•†å“çš„ç¼“å­˜å°±éƒ½è¿‡æœŸäº†ã€‚è€Œå¯¹è¿™æ‰¹å•†å“çš„è®¿é—®æŸ¥è¯¢ï¼Œéƒ½è½åˆ°äº†æ•°æ®åº“ä¸Šï¼Œå¯¹äºæ•°æ®åº“è€Œè¨€ï¼Œå°±ä¼šäº§ç”Ÿå‘¨æœŸæ€§çš„å‹åŠ›æ³¢å³°ã€‚</p>

<p>æ¯”å¦‚ç”µå•†é¡¹ç›®ï¼Œä¸€èˆ¬æ˜¯é‡‡å–ä¸åŒåˆ†ç±»å•†å“ï¼Œç¼“å­˜ä¸åŒå‘¨æœŸã€‚åœ¨åŒä¸€åˆ†ç±»ä¸­çš„å•†å“ï¼ŒåŠ ä¸Šä¸€ä¸ªéšæœºå› å­ã€‚è¿™æ ·èƒ½å°½å¯èƒ½åˆ†æ•£ç¼“å­˜è¿‡æœŸæ—¶é—´ï¼Œè€Œä¸”ï¼Œçƒ­é—¨ç±»ç›®çš„å•†å“ç¼“å­˜æ—¶é—´é•¿ä¸€äº›ï¼Œå†·é—¨ç±»ç›®çš„å•†å“ç¼“å­˜æ—¶é—´çŸ­ä¸€äº›ï¼Œä¹Ÿèƒ½èŠ‚çœç¼“å­˜æœåŠ¡çš„èµ„æºã€‚</p>

<p>å…¶å®é›†ä¸­è¿‡æœŸï¼Œå€’ä¸æ˜¯éå¸¸è‡´å‘½ï¼Œæ¯”è¾ƒè‡´å‘½çš„ç¼“å­˜é›ªå´©ï¼Œæ˜¯ç¼“å­˜æœåŠ¡å™¨æŸä¸ªèŠ‚ç‚¹å®•æœºæˆ–æ–­ç½‘ã€‚å› ä¸ºè‡ªç„¶å½¢æˆçš„ç¼“å­˜é›ªå´©ï¼Œä¸€å®šæ˜¯åœ¨æŸä¸ªæ—¶é—´æ®µé›†ä¸­åˆ›å»ºç¼“å­˜ï¼Œé‚£ä¹ˆé‚£ä¸ªæ—¶å€™æ•°æ®åº“èƒ½é¡¶ä½å‹åŠ›ï¼Œè¿™ä¸ªæ—¶å€™ï¼Œæ•°æ®åº“ä¹Ÿæ˜¯å¯ä»¥é¡¶ä½å‹åŠ›çš„ã€‚æ— éå°±æ˜¯å¯¹æ•°æ®åº“äº§ç”Ÿå‘¨æœŸæ€§çš„å‹åŠ›è€Œå·²ã€‚è€Œç¼“å­˜æœåŠ¡èŠ‚ç‚¹çš„å®•æœºï¼Œå¯¹æ•°æ®åº“æœåŠ¡å™¨é€ æˆçš„å‹åŠ›æ˜¯ä¸å¯é¢„çŸ¥çš„ï¼Œå¾ˆæœ‰å¯èƒ½ç¬é—´å°±æŠŠæ•°æ®åº“å‹å®ã€‚</p>

<p>ç¼“å­˜å‡»ç©¿
ç¼“å­˜å‡»ç©¿ï¼Œæ˜¯æŒ‡ä¸€ä¸ªkeyéå¸¸çƒ­ç‚¹ï¼Œåœ¨ä¸åœçš„æ‰›ç€å¤§å¹¶å‘ï¼Œå¤§å¹¶å‘é›†ä¸­å¯¹è¿™ä¸€ä¸ªç‚¹è¿›è¡Œè®¿é—®ï¼Œå½“è¿™ä¸ªkeyåœ¨å¤±æ•ˆçš„ç¬é—´ï¼ŒæŒç»­çš„å¤§å¹¶å‘å°±ç©¿ç ´ç¼“å­˜ï¼Œç›´æ¥è¯·æ±‚æ•°æ®åº“ï¼Œå°±åƒåœ¨ä¸€ä¸ªå±éšœä¸Šå‡¿å¼€äº†ä¸€ä¸ªæ´ã€‚ç›¸å½“äºç”µå•†é¡¹ç›®ä¸­çš„â€œçˆ†æ¬¾â€ã€‚</p>

<p>å…¶å®ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹è¿™ç§çˆ†æ¬¾å¾ˆéš¾å¯¹æ•°æ®åº“æœåŠ¡å™¨é€ æˆå‹å®æ€§çš„å‹åŠ›ã€‚è¾¾åˆ°è¿™ä¸ªçº§åˆ«çš„å…¬å¸æ²¡æœ‰å‡ å®¶çš„ã€‚å¦‚æœæµé‡ä¸å¤§ï¼ŒåŠ¡å®ä¸€ç‚¹å°±æ˜¯ç›´æ¥è®¾ç½®ç¼“å­˜æ°¸ä¸è¿‡æœŸï¼Œå³ä¾¿æŸäº›å•†å“è‡ªå·±å‘é…µæˆäº†çˆ†æ¬¾ï¼Œä¹Ÿæ˜¯ç›´æ¥è®¾ä¸ºæ°¸ä¸è¿‡æœŸå°±å¥½äº†ã€‚</p>

<p>ä½†æ˜¯ä¸‡ä¸€æµé‡å¾ˆå¤§ï¼Œé‡åˆ°è¿™ç§ç¼“å­˜å‡»ç©¿æ€ä¹ˆåŠï¼Œè¿™ä¸ªæ—¶å€™æ¨èä¸€æ¬¾golangçš„åŒ…singleflight</p>

<p>åŸç†ï¼š
å¤šä¸ªå¹¶å‘è¯·æ±‚å¯¹ä¸€ä¸ªå¤±æ•ˆçš„keyè¿›è¡Œæºæ•°æ®è·å–æ—¶ï¼Œåªè®©å…¶ä¸­ä¸€ä¸ªå¾—åˆ°æ‰§è¡Œï¼Œå…¶ä½™é˜»å¡ç­‰å¾…åˆ°æ‰§è¡Œçš„é‚£ä¸ªè¯·æ±‚å®Œæˆåï¼Œå°†ç»“æœä¼ é€’ç»™é˜»å¡çš„å…¶ä»–è¯·æ±‚è¾¾åˆ°é˜²æ­¢å‡»ç©¿çš„æ•ˆæœã€‚</p>

<p>demoï¼š
æ¨¡æ‹Ÿä¸€ç™¾ä¸ªå¹¶å‘è¯·æ±‚åœ¨ç¼“å­˜å¤±æ•ˆçš„ç¬é—´åŒæ—¶è°ƒç”¨rpcè®¿é—®æºæ•°æ®</p>

<p>package backup</p>

<p>import (
    â€œfmtâ€
    â€œgithub.com/golang/groupcache/singleflightâ€
    â€œnet/httpâ€
    â€œnet/rpcâ€
    â€œsyncâ€
    â€œtimeâ€
)</p>

<p>type (
    Arg struct {
        Caller int
    }
    Data struct{}
)</p>

<p>// æ¨¡æ‹Ÿä»æ•°æ®æºè·å–æ•°æ®
func (d *Data) GetData(arg *Arg, replay *string) error {
    fmt.Printf(â€œrequest from client %d\nâ€, arg.Caller)
    time.Sleep(1 * time.Second)
    *replay = â€œsource data from rpcServerâ€
    return nil
}</p>

<p>func main() {
    d := new(Data)
    rpc.Register(d)
    rpc.HandleHTTP()
    fmt.Println(â€œstart rpc serverâ€)
    if err := http.ListenAndServe(â€œ:8976â€, nil); err != nil {
        panic(err)
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>client, err := rpc.DialHTTP("tcp", ":8976")
if (err != nil) {
    panic(err)
}

singleFlight := new(singleflight.Group)
wg := sync.WaitGroup{}
wg.Add(100)

//ç„¶åå†æ¨¡æ‹Ÿä¸€ç™¾ä¸ªå¹¶å‘è¯·æ±‚åœ¨ç¼“å­˜å¤±æ•ˆçš„ç¬é—´åŒæ—¶è°ƒç”¨rpcè®¿é—®æºæ•°æ®
for i := 0; i &lt; 100; i++ {
    fn := func() (interface{}, error) {
        var replay string
        err = client.Call("Data.GetData", Arg{Caller: i}, &amp;replay)
        //ä»æ•°æ®æºæ‹¿åˆ°æ•°æ®åå†æ›´æ–°ç¼“å­˜ç­‰
        //...
        //...
        return replay, err
    }

    go func(i int) {
        result, _ := singleFlight.Do("foo", fn)
        fmt.Printf("caller %d get result '%s'\n", i, result)
        wg.Done()
    }(i)
}
</code></pre></div></div>

<p>}</p>

<p>æ•ˆæœï¼š</p>

<p>å¯ä»¥çœ‹åˆ°100ä¸ªå¹¶å‘è¯·æ±‚ä»æºæ•°æ®è·å–æ—¶ï¼ŒrpcServerç«¯åªæ”¶åˆ°äº†æ¥è‡ªclient 17çš„è¯·æ±‚ï¼Œè€Œå…¶ä½™99ä¸ªæœ€åä¹Ÿéƒ½å¾—åˆ°äº†æ­£ç¡®çš„è¿”å›å€¼ã€‚</p>

<p>å…¶å®singleflightå°±å‡ åè¡Œä»£ç ,ä¸»è¦å°±ç”¨åˆ°syncåŒ…çš„ä¸¤ä¸ªç‰¹æ€§Mutexå’ŒWaitGroupï¼Œæ‰€ä»¥è¯´çœ‹ä¼˜ç§€å¼€æºä»£ç æ˜¯å­¦ä¹ æœ€å¿«çš„æ–¹å¼ï¼Œæ²¡æœ‰ä¹‹ä¸€ã€‚</p>

<p>package singleflight</p>

<p>import â€œsyncâ€</p>

<p>// call is an in-flight or completed Do call
type call struct {
    wg  sync.WaitGroup
    val interface{}
    err error
}</p>

<p>// Group represents a class of work and forms a namespace in which
// units of work can be executed with duplicate suppression.
type Group struct {
    mu sync.Mutex       // protects m
    m  map[string]*call // lazily initialized
}</p>

<p>// Do executes and returns the results of the given function, making
// sure that only one execution is in-flight for a given key at a
// time. If a duplicate comes in, the duplicate caller waits for the
// original to complete and receives the same results.
func (g <em>Group) Do(key string, fn func() (interface{}, error)) (interface{}, error) {
    g.mu.Lock()
    if g.m == nil {
        g.m = make(map[string]</em>call)
    }
    if c, ok := g.m[key]; ok {
        g.mu.Unlock()
        c.wg.Wait()
        return c.val, c.err
    }
    c := new(call)
    c.wg.Add(1)
    g.m[key] = c
    g.mu.Unlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c.val, c.err = fn()
c.wg.Done()

g.mu.Lock()
delete(g.m, key)
g.mu.Unlock()

return c.val, c.err }
</code></pre></div></div>

:ET