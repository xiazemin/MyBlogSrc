I"“b<p>golangä¸­çš„é”æ˜¯é€šè¿‡CASåŸå­æ“ä½œå®ç°çš„ï¼ŒMutexç»“æ„å¦‚ä¸‹ï¼š
type Mutex struct {
    state int32              <br />
    sema  uint32
}</p>

<p>//stateè¡¨ç¤ºé”å½“å‰çŠ¶æ€ï¼Œæ¯ä¸ªä½éƒ½æœ‰æ„ä¹‰ï¼Œé›¶å€¼è¡¨ç¤ºæœªä¸Šé”
//semaç”¨åšä¿¡å·é‡ï¼Œé€šè¿‡PVæ“ä½œä»ç­‰å¾…é˜Ÿåˆ—ä¸­é˜»å¡/å”¤é†’goroutineï¼Œç­‰å¾…é”çš„goroutineä¼šæŒ‚åˆ°ç­‰å¾…é˜Ÿåˆ—ä¸­ï¼Œå¹¶ä¸”é™·å…¥ç¡çœ ä¸è¢«è°ƒåº¦ï¼Œunlocké”æ—¶æ‰å”¤é†’ã€‚å…·ä½“åœ¨sync/mutex.go Lockå‡½æ•°å®ç°ä¸­ã€‚</p>

<p>æ’æ’­ä¸€ä¸‹sema
è™½ç„¶åœ¨Mutexä¸­å°±æ˜¯ä¸€ä¸ªæ•´å½¢å­—æ®µï¼Œä½†æ˜¯å®ƒæ˜¯å¾ˆé‡è¦çš„ä¸€ç¯ï¼Œè¿™ä¸ªå­—æ®µå°±æ˜¯ç”¨äºä¿¡å·é‡ç®¡ç†goroutineçš„ç¡çœ å’Œå”¤é†’çš„ã€‚
semaå…·ä½“å®ç°è¿˜æ²¡è¯¦çœ‹ï¼Œè¿™é‡Œå¤§æ¦‚åˆ†æä¸‹åŠŸèƒ½ï¼Œæ³¨æ„ä¸å‡†ç¡®ï¼ï¼
é¦–å…ˆsemaä¸ºgoroutineçš„â€œè°ƒåº¦â€æä¾›äº†ä¸€ç§å®ç°ï¼Œå¯ä»¥è®©goroutineé˜»å¡å’Œå”¤é†’
ä¿¡å·é‡ç”³è¯·èµ„æºåœ¨runtime/sema.goä¸­semacquire1
ä¿¡å·é‡é‡Šæ”¾èµ„æºåœ¨semrelease1ä¸­
é¦–å…ˆsemaä¸­ï¼Œä¸€ä¸ªsemaRootç»“æ„å’Œä¸€ä¸ªå…¨å±€semtableå˜é‡ï¼Œä¸€ä¸ªsemaRootç”¨äºä¸€ä¸ªä¿¡å·é‡çš„PVæ“ä½œ(çŒœæµ‹ä¸goroutineè°ƒåº¦æ¨¡å‹MGPæœ‰å…³ï¼Œä¸€ä¸ªProcessoræŒ‚å¤šä¸ªgoroutineï¼Œå¯¹äºä¸€ä¸ªprocessorä¸‹çš„å¤šä¸ªgoroutineçš„éœ€è¦ä¸€ä¸ªä¿¡å·é‡æ¥ç®¡ç†ï¼Œå½“ç„¶éœ€è¦ä¸€ä¸ªè½»é‡çš„é”åœ¨goroutineçš„çŠ¶æ€è½¬æ¢æ—¶åŠ é”ï¼Œå³ä¸‹é¢çš„lockç»“æ„ï¼Œè¿™ä¸ªé”ä¸Mutexä¸­çš„é”ä¸ç›¸åŒçš„ï¼Œæ˜¯semaä¸­è‡ªå·±å®ç°çš„)ï¼Œå¤šä¸ªsemaRootçš„åˆ†é…å’ŒæŸ¥æ‰¾å°±é€šè¿‡å…¨å±€å˜é‡semtableæ¥ç®¡ç†
type semaRoot struct {
    lock  mutex
    treap *sudog // root of balanced tree of unique waiters.
    nwait uint32 // Number of waiters. Read w/o the lock.
}
var semtable [semTabSize]struct {
    root semaRoot
    pad  [cpu.CacheLinePadSize - unsafe.Sizeof(semaRoot{})]byte
}
<!-- more --></p>

<p>1 è®©å½“å‰goroutineç¡çœ é˜»å¡æ˜¯é€šè¿‡goparkunlockå®ç°çš„ï¼Œåœ¨semacquire1ä¸­è¿™æ ·è°ƒç”¨ï¼š
          1ï¼‰ root := semroot(addr)
                semrootä¸­æ˜¯é€šè¿‡ä¿¡å·é‡åœ°å€æ‰¾åˆ°semaRootç»“æ„
          2ï¼‰ ç•¥è¿‡ä¸€æ®µâ€¦.. ç›´æ¥åˆ°ä½¿å½“å‰goroutineç¡çœ ä½ç½®
                é¦–å…ˆlock(&amp;root.lock)ä¸Šé”
                ç„¶åè°ƒç”¨root.queue()è®©å½“å‰goroutineè¿›å…¥ç­‰å¾…é˜Ÿåˆ—(æ³¨æ„ä¸€ä¸ªä¿¡å·é‡ç®¡ç†å¤šä¸ªgoroutineï¼Œgoroutineç¡çœ å‰ï¼Œæœ¬èº«çš„è¯¦ç»†ä¿¡æ¯å°±è¦ä¿å­˜èµ·æ¥ï¼Œæ”¾åˆ°é˜Ÿåˆ—ä¸­ï¼Œä¹Ÿå°±æ˜¯åœ¨æŒ‚åˆ°äº†semaRootç»“æ„çš„treapä¸Šï¼Œçœ‹æ³¨é‡Šé˜Ÿåˆ—æ˜¯ç”¨å¹³è¡¡æ ‘å®ç°çš„ï¼Ÿ)
          3ï¼‰è°ƒç”¨goparkunlock(&amp;root.lock, waitReasonSemacquire, traceEvGoBlockSync, 4) 
                æœ€åä¼šè°ƒç”¨åˆ°goparkï¼Œgoparkä¼šè®©ç³»ç»Ÿé‡æ–°æ‰§è¡Œä¸€æ¬¡è°ƒåº¦ï¼Œåœ¨é‡æ–°è°ƒåº¦ä¹‹å‰ï¼Œä¼šå°†å½“å‰goroutineï¼Œå³Gå¯¹è±¡çŠ¶æ€ç½®ä¸ºsleepçŠ¶æ€ï¼Œä¸å†è¢«è°ƒåº¦ç›´åˆ°è¢«å”¤é†’ï¼Œç„¶åunlocké”ï¼Œè¿™ä¸ªå‡½æ•°ç»™äº†ç³»ç»Ÿä¸€ä¸ªæœºä¼šï¼Œå°†ä»£ç æ‰§è¡Œæƒé™è½¬äº¤ç»™runtimeè°ƒåº¦å™¨ï¼Œruntimeä¼šå»è°ƒåº¦åˆ«çš„goroutineã€‚</p>

<p>2 æ—¢ç„¶é˜»å¡ï¼Œå°±éœ€è¦æœ‰å”¤é†’çš„æœºåˆ¶
   å”¤é†’æœºåˆ¶æ˜¯é€šè¿‡semtableç»“æ„
   sema.goå¹¶éä¸“é—¨ä¸ºmutexé”ä¸­çš„è®¾è®¡çš„ï¼Œåœ¨mutexä¸­ä½¿ç”¨çš„è¯ï¼Œæ˜¯åœ¨å…¶å®ƒgoroutineé‡Šæ”¾Mutexæ—¶ï¼Œè°ƒç”¨çš„semrelease1ï¼Œä»é˜Ÿåˆ—ä¸­å”¤é†’goroutineæ‰§è¡Œã€‚è¯¦ç»†æ²¡çœ‹ã€‚
   ä¸è¿‡æ ¹æ®åˆ†æï¼ŒMutexæ˜¯äº’æ–¥é”ï¼ŒMutexä¸­çš„ä¿¡å·é‡åº”è¯¥æ˜¯äºŒå€¼ä¿¡å·é‡ï¼Œåªæœ‰0å’Œ1ã€‚åœ¨Mutexä¸­è°ƒç”¨Lockï¼Œå‡å¦‚æ‰§è¡Œåˆ°semacquire1ï¼Œä»ä¸­åˆ¤æ–­ä¿¡å·é‡å¦‚æœä¸º0ï¼Œå°±è®©å½“å‰goroutineç¡çœ ï¼Œ
func cansemacquire(addr *uint32) bool {
    for {
        v := atomic.Load(addr)
        if v == 0 {
            return false
        }
        if atomic.Cas(addr, v, v-1) {
            return true
        }
    }
}
      å¦‚æœä¸æ–­æœ‰goroutineå°è¯•è·å–Mutexé”ï¼Œéƒ½ä¼šåˆ¤æ–­åˆ°ä¿¡å·é‡ä¸º0ï¼Œä¼šä¸æ–­æœ‰goroutineé™·å…¥ç¡çœ çŠ¶æ€ã€‚åªæœ‰å½“unlockæ—¶ï¼Œä¿¡å·é‡æ‰ä¼š+1ï¼Œå½“ç„¶ä¸èƒ½é‡å¤æ‰§è¡Œunlockï¼Œæ‰€ä»¥è¿™ä¸ªä¿¡å·é‡åº”è¯¥åªä¸º0å’Œ1ã€‚</p>

<p>å¤§æ¦‚åˆ†æäº†ä¸‹semaï¼Œè½¬å›åˆ°Mutexä¸­æ¥ã€‚
ä¸Šé¢è¯´äº†semaå­—æ®µçš„ä½œç”¨ï¼Œstateå­—æ®µåœ¨Mutexä¸­æ˜¯æ›´ä¸ºæ ¸å¿ƒçš„å­—æ®µï¼Œæ ‡è¯†äº†å½“å‰é”çš„ä¸€ä¸ªçŠ¶æ€ã€‚
state     |31|30|â€¦.|      2    |     1      |      0     |
                  |                |           |      ç¬¬0ä½è¡¨ç¤ºå½“å‰è¢«åŠ é”ï¼Œ0ï¼Œunlock,   1 locked
                  |                |        æ˜¯å¦æœ‰goroutineå·²è¢«å”¤é†’ï¼Œ0 å”¤é†’ï¼Œ 1 æ²¡æœ‰
                  |           è¿™ä¸€ä½è¡¨ç¤ºå½“å‰Mutexå¤„äºä»€ä¹ˆæ¨¡å¼ï¼Œä¸¤ç§æ¨¡å¼ï¼Œ0 Normal   1 Starving
             ç¬¬ä¸‰ä½è¡¨ç¤ºå°è¯•Lockè¿™ä¸ªé”è€Œç­‰å¾…çš„goroutineçš„ä¸ªæ•°</p>

<p>å…ˆè§£é‡Šä¸‹Mutexçš„normalå’Œstarvingä¸¤ç§æ¨¡å¼ï¼Œä»£ç ä¸­å…³äºMutexçš„æ³¨é‡Šå¦‚ä¸‹</p>

<p>ä¸¤ç§æ¨¡å¼æ˜¯ä¸ºäº†é”çš„å…¬å¹³æ€§è€Œå®ç°ï¼Œæ‘˜å–ç½‘ä¸Šçš„ä¸€æ®µç¿»è¯‘ï¼šhttp://blog.51cto.com/qiangmzsx/2134786
äº’æ–¥é‡å¯åˆ†ä¸ºä¸¤ç§æ“ä½œæ¨¡å¼:æ­£å¸¸å’Œé¥¥é¥¿ã€‚
åœ¨æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œç­‰å¾…çš„goroutinesæŒ‰ç…§FIFOï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰é¡ºåºæ’é˜Ÿï¼Œä½†æ˜¯goroutineè¢«å”¤é†’ä¹‹åå¹¶ä¸èƒ½ç«‹å³å¾—åˆ°mutexé”ï¼Œå®ƒéœ€è¦ä¸æ–°åˆ°è¾¾çš„goroutineäº‰å¤ºmutexé”ã€‚
å› ä¸ºæ–°åˆ°è¾¾çš„goroutineå·²ç»åœ¨CPUä¸Šè¿è¡Œäº†ï¼Œæ‰€ä»¥è¢«å”¤é†’çš„goroutineå¾ˆå¤§æ¦‚ç‡æ˜¯äº‰å¤ºmutexé”æ˜¯å¤±è´¥çš„ã€‚å‡ºç°è¿™æ ·çš„æƒ…å†µæ—¶å€™ï¼Œè¢«å”¤é†’çš„goroutineéœ€è¦æ’é˜Ÿåœ¨é˜Ÿåˆ—çš„å‰é¢ã€‚
å¦‚æœè¢«å”¤é†’çš„goroutineæœ‰è¶…è¿‡1msæ²¡æœ‰è·å–åˆ°mutexé”ï¼Œé‚£ä¹ˆå®ƒå°±ä¼šå˜ä¸ºé¥¥é¥¿æ¨¡å¼ã€‚
åœ¨é¥¥é¥¿æ¨¡å¼ä¸­ï¼Œmutexé”ç›´æ¥ä»è§£é”çš„goroutineäº¤ç»™é˜Ÿåˆ—å‰é¢çš„goroutineã€‚æ–°è¾¾åˆ°çš„goroutineä¹Ÿä¸ä¼šå»äº‰å¤ºmutexé”ï¼ˆå³ä½¿æ²¡æœ‰é”ï¼Œä¹Ÿä¸èƒ½å»è‡ªæ—‹ï¼‰ï¼Œè€Œæ˜¯åˆ°ç­‰å¾…é˜Ÿåˆ—å°¾éƒ¨æ’é˜Ÿã€‚
åœ¨é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œæœ‰ä¸€ä¸ªgoroutineè·å–åˆ°mutexé”äº†ï¼Œå¦‚æœå®ƒæ»¡è¶³ä¸‹æ¡ä»¶ä¸­çš„ä»»æ„ä¸€ä¸ªï¼Œmutexå°†ä¼šåˆ‡æ¢å›å»æ­£å¸¸æ¨¡å¼ï¼š</p>
<ol>
  <li>æ˜¯ç­‰å¾…é˜Ÿåˆ—ä¸­çš„æœ€åä¸€ä¸ªgoroutine</li>
  <li>å®ƒçš„ç­‰å¾…æ—¶é—´ä¸è¶…è¿‡1msã€‚
æ­£å¸¸æ¨¡å¼æœ‰æ›´å¥½çš„æ€§èƒ½ï¼Œå› ä¸ºgoroutineå¯ä»¥è¿ç»­å¤šæ¬¡è·å¾—mutexé”ï¼›
é¥¥é¥¿æ¨¡å¼å¯¹äºé¢„é˜²é˜Ÿåˆ—å°¾éƒ¨goroutineä¸€è‡´æ— æ³•è·å–mutexé”çš„é—®é¢˜ã€‚</li>
</ol>

<p>å…·ä½“å®ç°å¦‚ä¸‹ï¼š
åœ¨Lockå‡½æ•°ä¸­
    // Fast path: grab unlocked mutex.
    // 1  ä½¿ç”¨åŸå­æ“ä½œä¿®æ”¹é”çŠ¶æ€ä¸ºlocked
    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
        if race.Enabled {
            race.Acquire(unsafe.Pointer(m))
        } <br />
        return
    } <br />
Mutexå¤šä¸ªgoroutineåœ¨ä»»ä½•æ—¶æœºéƒ½ä¼šå°è¯•å»è·å–ï¼ŒMutexçš„stateåˆå®æ—¶åœ¨å˜åŒ–ï¼Œå„ç§åœºæ™¯æœ‰ç‚¹å¤šï¼Œè¿™é‡ŒæŒ‘å…¸å‹çš„æ¥è¯´ã€‚
1ï¼‰ å‡è®¾å½“å‰mutexå¤„äºåˆå§‹çŠ¶æ€ï¼Œå³m.state=0ï¼Œé‚£ä¹ˆå½“å‰goroutineä¼šåœ¨è¿™é‡Œä¼šç›´æ¥è·å–åˆ°é”ï¼Œm.stateå˜ä¸ºlockedï¼Œ
åˆ™m.state = 00â€¦001     ä¸Šé”äº†ï¼ŒNot Woken, normalçŠ¶æ€ã€‚ 
      è¿æ°”å¥½ï¼Œä¸€æ¥å°±è·å–åˆ°ï¼Œå°±è·Ÿä¸Šé¢è¯´çš„ä¸€æ ·ï¼Œæ¥æ—¶å°±åœ¨cpué‡Œï¼Œåˆèµ¶ä¸Šé”æ²¡äººå ï¼Œå¤©ç”Ÿè‡ªå¸¦å…‰ç¯ï¼Œå‘µå‘µã€‚
      Lockç»“æŸreturn</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  å¦‚æœè¿™ä¸ªgoroutineä¸é‡Šæ”¾é”ï¼Œé‚£ä¹ˆç„¶åå†æ¥ä¸€ä¸ªgoroutineå°±é”ä¸ä¸Šäº†ï¼Œè¿›å…¥ç¬¬äºŒæ­¥
</code></pre></div></div>

<p>2ï¼‰ ç´§æ¥ç€ä¸€ä¸ªforå¾ªç¯ï¼Œå¤§æ¦‚å°±æ˜¯å°è¯•è·å–é”ï¼Œæ±‚è€Œä¸å¾—ï¼Œå°±ç¡ä¸€ä¼šå§ï¼Œç­‰ç€è¢«å«é†’ï¼Œé†’äº†çœ‹çœ‹æ˜¯ä¸æ˜¯ç­‰çš„æ—¶é—´å¤ªé•¿é¥¿äº†ï¼Œé¥¿äº†å°±è¿›å…¥starvingï¼Œstarvingå°±ä¼šè¢«ä¼˜å…ˆè°ƒåº¦äº†ï¼Œæ²¡æœ‰é‚£è¿æ°”ï¼Œå°±åªèƒ½ç­‰äº†ã€‚
    var waitStartTime int64
    starving := false
    awoke := false
    iter := 0
    old := m.state    //åˆšæ‰å·²ç»è®¾ç½®m.state=001ï¼Œoldä¹Ÿä¸º001
    for {
        // Donâ€™t spin in starvation mode, ownership is handed off to waiters
        // so we wonâ€™t be able to acquire the mutex anyway.
        // old=001ï¼Œé”ç€å‘¢
        // ç„¶åruntime_canSpinçœ‹çœ‹èƒ½ä¸èƒ½è‡ªæ—‹å•Šï¼Œå°±æ˜¯çœ‹ä¼ è¿›æ¥çš„iterï¼Œæ¯æ¬¡å¾ªç¯éƒ½æ˜¯è‡ªå¢
        // è‡ªæ—‹æ¡ä»¶ï¼šå¤šæ ¸ï¼ŒGOMAXPROCS&gt;1ï¼Œè‡³å°‘æœ‰å¦å¤–ä¸€ä¸ªè¿è¡Œçš„På¹¶ä¸”æœ¬åœ°é˜Ÿåˆ—ä¸ç©ºã€‚æˆ–è®¸æ˜¯å®³æ€•å•æ ¸è‡ªæ—‹ï¼Œç¨‹åºéƒ½åœäº†ã€‚å¦å¤–æœ€å¤šè‡ªæ—‹4æ¬¡ï¼Œiterä¸º4æ—¶ä¸ä¼šå†è¿›if
                             æˆ‘ä»¬è¿™é‡Œè€ƒè™‘å¤šæ ¸çš„æƒ…å†µï¼Œä¼šè¿›if
        // oldåœ¨æ¯æ¬¡ifä¸­ä¼šé‡æ–°è·å–ï¼Œè¿™é‡Œè‡ªæ—‹çš„ç›®çš„å°±æ˜¯ç­‰å¾…é”é‡Šæ”¾ï¼Œå½“å‰å ç”¨cpuçš„goroutineå°±å¯ä»¥å äº†ï¼Œgoé‡Œé¢æ€»æ˜¯å°½é‡è®©åœ¨cpuä¸­çš„goroutineå ç”¨é”
        if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
            // Active spinning makes sense.
            // Try to set mutexWoken flag to inform Unlock
            // to not wake other blocked goroutines.
            // å½“å‰awokeä¸ºfalseï¼Œä½†æ˜¯æ²¡æœ‰goroutineåœ¨ç­‰å¾…ï¼Œé‚£ä¹ˆunlockæ—¶ï¼Œæ²¡å¿…è¦å”¤é†’é˜Ÿåˆ—goroutineã€‚
            if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; oldÂ»mutexWaiterShift != 0 &amp;&amp;
atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                awoke = true
            } <br />
            runtime_doSpin()     //è‡ªæ—‹ï¼Œæ‰§è¡Œæ²¡ç”¨çš„æŒ‡ä»¤30æ¬¡
            iter++
            old = m.state           //oldé‡æ–°è·å–ä¸€æ¬¡stateå€¼ï¼Œå¦‚æœæœ‰å…¶å®ƒgoroutineé‡Šæ”¾äº†ï¼Œé‚£ä¹ˆä¸‹æ¬¡å¾ªç¯å°±ä¸è¿›ifäº†
            continue                   //è‡ªæ—‹å®Œå†å¾ªç¯ä¸€æ¬¡
        } <br />
        //ifå‡ºæ¥åï¼Œä¼šæœ‰ä¸¤ç§æƒ…å†µ
        2.1ï¼‰å…¶å®ƒgoroutine  unlockäº†ï¼Œä¸Šé¢ifåˆ¤æ–­éLockedè·³å‡ºï¼Œæ­¤æ—¶ m.state=000, old=000, awoke=false, æ²¡æœ‰goroutineåœ¨ç­‰å¾…ï¼Œè¿™æ˜¯æœ€ç®€å•çš„æƒ…å†µäº†
        new := old                  //new=000,   old=000,  m.state=000,  awoke=falseï¼Œè¿™é‡Œåˆå§‹åŒ–newï¼Œåé¢è¦è®¾ç½®é”çŠ¶æ€ï¼Œm.stateè®¾ç½®ä¸ºnew
        // Donâ€™t try to acquire starving mutex, new arriving goroutines must queue.
        if old&amp;mutexStarving == 0 {      //new=000, å½“å‰é”å¹¶ä¸æ˜¯starvingæ¨¡å¼ï¼Œæ­£åœ¨è¿è¡Œçš„goroutineè¦å ç”¨è¿™ä¸ªé”ï¼Œå¦‚æœæ˜¯starvingæ¨¡å¼ï¼Œå½“å‰çš„goroutineè¦å»æ’é˜Ÿï¼ŒæŠŠé”è®©ç»™é˜Ÿåˆ—ä¸­å¿«é¥¿æ­»çš„å…„å¼Ÿ   <br />
            new |= mutexLocked              //new=001ï¼Œ è¦ä¸Šé”
        } <br />
        if old&amp;(mutexLocked|mutexStarving) != 0 {       //old=000, å½“å‰æ­£åœ¨è·‘çš„è¿™ä¸ªgoroutineè¦å é”ï¼Œä¸ä¼šè¿›é˜Ÿåˆ—ï¼Œ new=001
            new += 1 Â«Â mutexWaiterShift
        } <br />
        // The current goroutine switches mutex to starvation mode.
        // But if the mutex is currently unlocked, donâ€™t do the switch.
        // Unlock expects that starving mutex has waiters, which will not
        // be true in this case.
        if starving &amp;&amp; old&amp;mutexLocked != 0 {             //starving=falseï¼Œåªæœ‰goroutineåœ¨unlockå”¤é†’åï¼Œå‘ç°ç­‰å¾…æ—¶é—´è¿‡é•¿ï¼Œstarvingæ‰è®¾ç½®ä¸ºtrueï¼Œå› ä¸ºé˜Ÿåˆ—ä¸­å…¶å®ƒçš„goroutineéƒ½ç­‰çš„æœ‰ç‚¹é•¿äº†ï¼Œæ‰€ä»¥åœ¨é”å¯ç”¨æ—¶ï¼Œä¼˜å…ˆç»™é˜Ÿåˆ—ä¸­çš„goroutineã€‚è¿™ä¸ªé€»è¾‘åœ¨åé¢ï¼Œå½“å‰ä¸è¿›è¿™ä¸ªifï¼Œnew=001
            new |= mutexStarving
        } <br />
        if awoke {                       //awokeä¸ºfalseï¼Œä¸å»å”¤é†’ç­‰å¾…é˜Ÿåˆ—ï¼Œ newä»ä¸º001
            // The goroutine has been woken from sleep,
            // so we need to reset the flag in either case.
            if new&amp;mutexWoken == 0 {
                throw(â€œsync: inconsistent mutex stateâ€)
            } <br />
            new &amp;^= mutexWoken
        } 
           è‡³æ­¤newåˆå§‹åŒ–å®Œæ¯•ï¼Œnew=001ï¼Œè¦å»æ›´æ”¹Mutexçš„é”çŠ¶æ€ï¼ŒçœŸæ­£ç‹¬å é”äº†
          //ä¿é™©èµ·è§ï¼Œä»¥é˜²åœ¨newè®¾ç½®è¿‡ç¨‹ä¸­ï¼Œæœ‰å…¶å®ƒgoroutineæ›´æ”¹äº†é”çŠ¶æ€ï¼ŒåŸå­æ€§çš„è®¾ç½®å½“å‰é”çŠ¶æ€ä¸ºnew=001ï¼Œè¿™é‡Œå°±æ˜¯ä¸Šé”
          if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {      <br />
            if old&amp;(mutexLocked|mutexStarving) == 0 {                           //old=000ï¼Œç›´æ¥breakï¼Œå› ä¸ºä¸Šé¢æ˜¯å°†m.stateç½®ä¸ºä¸Šé”ï¼Œå·²ç»æˆåŠŸäº†ï¼Œè‡³æ­¤åé¢é€»è¾‘ä¸èµ°äº†
                break // locked the mutex with CAS                                    //å›å¤´çœ‹2.1ï¼Œæˆ‘ä»¬å¦‚æœæ˜¯è‡ªæ—‹æ¬¡æ•°å¤Ÿäº†è·³å‡ºå‘¢ï¼Ÿå¦‚2.2é€»è¾‘
            } <br />
            // If we were already waiting before, queue at the front of the queue.
            queueLifo := waitStartTime != 0
            if waitStartTime == 0 {
                waitStartTime = runtime_nanotime()
            } <br />
            runtime_SemacquireMutex(&amp;m.sema, queueLifo)
            starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
            old = m.state
            if old&amp;mutexStarving != 0 {
                // If this goroutine was woken and mutex is in starvation mode,
                // ownership was handed off to us but mutex is in somewhat
                // inconsistent state: mutexLocked is not set and we are still
                // accounted as waiter. Fix that.
                if old&amp;(mutexLocked|mutexWoken) != 0 || oldÂ»mutexWaiterShift == 0 {
                    throw(â€œsync: inconsistent mutex stateâ€)
                } <br />
                delta := int32(mutexLocked - 1Â«mutexWaiterShift)
                if !starving || oldÂ»mutexWaiterShift == 1 {
                    // Exit starvation mode.
                    // Critical to do it here and consider wait time.
                    // Starvation mode is so inefficient, that two goroutines
                    // can go lock-step infinitely once they switch mutex
                    // to starvation mode.
                    delta -= mutexStarving
                }
                atomic.AddInt32(&amp;m.state, delta)
                break
            }
            awoke = true
            iter = 0
        } else {
            old = m.state
        }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   2.2ï¼‰new := old,    æ­¤æ—¶new=001, old=001, m.state=001, awoke=false ï¼ˆawokeåœ¨ifä¸­è®¾ç½®ä¸ºtrueçš„æƒ…å†µå°±ä¸è®¨è®ºäº†ï¼Œå¤ªå¤šäº†ã€‚ã€‚ã€‚ã€‚)
    // Don't try to acquire starving mutex, new arriving goroutines must queue.
    if old&amp;mutexStarving == 0 {
        new |= mutexLocked                    //new=001
    }
    if old&amp;(mutexLocked|mutexStarving) != 0 {   //old=001, å½“å‰è·‘çš„è¿™ä¸ªgoroutineè¦è¿›é˜Ÿåˆ—ï¼Œnewçš„ç¬¬3ä½åˆ°ç¬¬31ä½è¡¨ç¤ºé˜Ÿåˆ—ä¸­goroutineæ•°é‡ï¼Œè¿™é‡Œ+1
        new += 1 &lt;&lt; mutexWaiterShift                 //new=1001
    }
    // The current goroutine switches mutex to starvation mode.
    // But if the mutex is currently unlocked, don't do the switch.
    // Unlock expects that starving mutex has waiters, which will not
    // be true in this case.
    if starving &amp;&amp; old&amp;mutexLocked != 0 {        //starving=falseï¼Œå¹¶ä¸éœ€è¦è¿›å…¥starvingæ¨¡å¼
        new |= mutexStarving
    }
    if awoke {                                                      //awoke=false
        // The goroutine has been woken from sleep,
        // so we need to reset the flag in either case.
        if new&amp;mutexWoken == 0 {
            throw("sync: inconsistent mutex state")
        }
        new &amp;^= mutexWoken
    }
          newåˆå§‹åŒ–ä¸º1001ï¼Œ old=001
    if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
        if old&amp;(mutexLocked|mutexStarving) == 0 {                 //old=001ï¼Œè¿™é‡Œä¸ä¼šbreakï¼Œå› ä¸ºå½“å‰çš„goroutineæ‹¿ä¸åˆ°é”éœ€è¦é˜»å¡ç¡çœ 
            break // locked the mutex with CAS
        }
        // If we were already waiting before, queue at the front of the queue.
        queueLifo := waitStartTime != 0                                     //åˆ¤æ–­å½“å‰goroutineæ˜¯ä¸æ˜¯forå¾ªç¯ç¬¬ä¸€æ¬¡èµ°åˆ°è¿™é‡Œï¼Œæ˜¯çš„è¯ï¼ŒwaitStartTime=0
        if waitStartTime == 0 {                                                    //queueLifoçš„trueè¿˜æ˜¯falseå†³å®šäº†goroutineå…¥é˜Ÿåˆ—æ—¶ï¼Œæ˜¯æ’é˜Ÿè¿˜æ˜¯æ’åˆ°é˜Ÿå¤´
            waitStartTime = runtime_nanotime()
        }
        runtime_SemacquireMutex(&amp;m.sema, queueLifo)          //å½“å‰goroutineå…¥ç­‰å¾…é˜Ÿåˆ—, è·³åˆ° â€œæ³¨è„š1â€ï¼Œæ›´å¤šè¯´æ˜ã€‚æ­¤æ—¶goroutineä¼šé˜»å¡åœ¨è¿™ï¼Œé”é‡Šæ”¾ï¼Œå¦‚æœåœ¨é˜Ÿå¤´ï¼Œæ‰ä¼šè¢«å”¤é†’ã€‚
        starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs   //å”¤é†’æ—¶åˆ¤æ–­æ˜¯å¦ç­‰å¾…æ—¶é—´è¿‡é•¿ï¼Œè¶…è¿‡äº†1msï¼Œå°±è®¾ç½®starvingä¸ºtrueï¼Œâ€œæ³¨è„š2â€æ›´å¤šè¯´æ˜
        old = m.state
        if old&amp;mutexStarving != 0 {
            // If this goroutine was woken and mutex is in starvation mode,
            // ownership was handed off to us but mutex is in somewhat
            // inconsistent state: mutexLocked is not set and we are still
            // accounted as waiter. Fix that.
            if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {
                throw("sync: inconsistent mutex state")
            }
            delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)
            if !starving || old&gt;&gt;mutexWaiterShift == 1 {
                // Exit starvation mode.
                // Critical to do it here and consider wait time.
                // Starvation mode is so inefficient, that two goroutines
                // can go lock-step infinitely once they switch mutex
                // to starvation mode.
                delta -= mutexStarving
            }
            atomic.AddInt32(&amp;m.state, delta)
            break
        }
        awoke = true
        iter = 0
    } else {
        old = m.state
    }
</code></pre></div></div>

<p>æ³¨è„š1    è¿™çš„runtime_SemacquireMutexæ˜¯å¯¹ä¸Šé¢è¯´çš„sema.goä¸­semacquire1çš„ç®€å•å°è£…ï¼Œé‡Œé¢æœ€åä¼šè°ƒç”¨goParkè®©å½“å‰goroutineè®©å‡ºæ‰§è¡Œæƒé™ç»™runtimeï¼ŒåŒæ—¶è®¾ç½®å½“å‰goroutineä¸ºç¡çœ çŠ¶æ€ï¼Œä¸å‚ä¸è°ƒåº¦(è¡¨ç°åœ¨ç¨‹åºä¸Šï¼Œå°±æ˜¯é˜»åœ¨é‚£äº†)ã€‚</p>

<p>æ³¨è„š2    1ï¼‰ è¿™ä¹Ÿåˆ†ä¸¤ç§æƒ…å†µï¼Œå¦‚æœæ²¡æœ‰è¶…1msï¼Œstarving=false
                     old = m.state              //å½“å‰è‚¯å®šæ˜¯unlockäº†ï¼Œå½“å‰goroutineæ‰è¢«å”¤é†’äº†ï¼Œæ‰€ä»¥oldè‡³å°‘ä¸º000ï¼Œæˆ‘ä»¬å‡å®šä¸º000
                     if old&amp;mutexStarving != 0    //oldä¸æ˜¯starvingæ¨¡å¼ï¼Œä¸è¿›if</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>               awoke = true    //å……ç½®awokeå’Œiterï¼Œé‡æ–°èµ°å¾ªç¯
                iter = 0
                 ///////////////////////////
                 ä¸‹æ¬¡å¾ªç¯ä¸­ï¼Œæœ€åä¼šè®¾ç½®new=001ï¼Œå½“å‰goroutineè¢«å”¤é†’ï¼ŒåŠ é”1ï¼Œä¸æ˜¯starvingçŠ¶æ€ã€‚
                 æœ€åä¼šåœ¨ä¸‹é¢è¿™breakï¼Œè·³å‡ºLockå‡½æ•°
    if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
        if old&amp;(mutexLocked|mutexStarving) == 0 {
            break // locked the mutex with CAS
        }
 
 
        2ï¼‰å¦‚æœè¶…äº†1msï¼Œstraving = true
             old = m.state              //å½“å‰è‚¯å®šæ˜¯unlockäº†ï¼Œå½“å‰goroutineæ‰è¢«å”¤é†’äº†ï¼Œæ‰€ä»¥oldè‡³å°‘ä¸º000ï¼Œæˆ‘ä»¬å‡å®šä¸º000
               if old&amp;mutexStarving != 0    //oldä¸æ˜¯starvingæ¨¡å¼ï¼Œä¸è¿›if
 
               awoke = true    //å……ç½®awokeå’Œiterï¼Œé‡æ–°èµ°å¾ªç¯
               iter = 0
               ///////////////////////////
             ä¸‹æ¬¡å¾ªç¯ new=101ï¼Œ é”å¤„äºstarvingæ¨¡å¼ï¼Œå½“å‰goroutineè¢«å”¤é†’ï¼Œå·²åŠ é”
 
äºŒ  å¦‚æœå¤„äºstarvingä¼šæœ‰ä»€ä¹ˆå½±å“ï¼Ÿä¸»è¦æç°åœ¨Unlockå‡½æ•°ä¸­
// Fast path: drop lock bit.
//å…ˆæ¸…æ‰lockä½ï¼Œå‡è®¾æœ€ç®€å•çš„æƒ…å†µï¼Œå…¶å®ƒä½éƒ½ä¸º0ï¼Œåˆ™m.state=000, new=000
new := atomic.AddInt32(&amp;m.state, -mutexLocked)
if (new+mutexLocked)&amp;mutexLocked == 0 {
    throw("sync: unlock of unlocked mutex")
}
 
//è¿™é‡Œå°±æ˜¯starvingæ¨¡å¼çš„å½±å“ï¼Œå¦‚æœå¤„äºstarvingæ¨¡å¼ï¼Œé‚£ä¹ˆç›´æ¥èµ°elseï¼Œä»é˜Ÿåˆ—å¤´éƒ¨å”¤é†’ä¸€ä¸ªgoroutineã€‚
if new&amp;mutexStarving == 0 {
    old := new                   //old = 000
    for {
        // If there are no waiters or a goroutine has already
        // been woken or grabbed the lock, no need to wake anyone.
        // In starvation mode ownership is directly handed off from unlocking
        // goroutine to the next waiter. We are not part of this chain,
        // since we did not observe mutexStarving when we unlocked the mutex above.
        // So get off the way.
        //å¦‚æœé˜Ÿåˆ—ä¸­æ²¡æœ‰ç­‰å¾…çš„goroutineæˆ–è€…æœ‰goroutineå·²ç»è¢«å”¤é†’å¹¶ä¸”æŠ¢å äº†é”(è¿™ç§æƒ…å†µå°±å¦‚lockä¸­ï¼Œæ­£å¥½å¤„åœ¨cpuä¸­çš„goroutineåœ¨è‡ªæ—‹ï¼Œæ­£å¥½åœ¨unlockåï¼Œé©¬ä¸ŠæŠ¢å äº†é”)ï¼Œé‚£ä¹ˆå°±ä¸éœ€è¦wakeç­‰å¾…é˜Ÿåˆ—äº†ã€‚
        if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
            return
        }
        
        //å¦‚æœé˜Ÿåˆ—ä¸­æœ‰ç­‰ç€çš„ï¼Œå¹¶ä¸”ä¹Ÿæ²¡æœ‰å¤„åœ¨cpuä¸­çš„goroutineå»è‡ªæ—‹è·å–é”ï¼Œé‚£ä¹ˆå°±æŠ“ä½æœºä¼šä»ç­‰å¾…é˜Ÿåˆ—ä¸­å”¤é†’ä¸€ä¸ªgoroutineã€‚
        // Grab the right to wake someone.
        new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
        if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            runtime_Semrelease(&amp;m.sema, false)
            return
        }
        old = m.state
    }
} else {
    // Starving mode: handoff mutex ownership to the next waiter.
    // Note: mutexLocked is not set, the waiter will set it after wakeup.
    // But mutex is still considered locked if mutexStarving is set,
    // so new coming goroutines won't acquire it.
 
    //starvingæ¨¡å¼ï¼Œç›´æ¥ä»é˜Ÿåˆ—å¤´å–goroutineå”¤é†’ã€‚ä¸Šé¢lockå‡½æ•°ä¸­æ²¡æœ‰åˆ†æruntime_SemacquireMutex(&amp;m.sema, queueLifo)é˜»å¡è¢«å”¤é†’åï¼Œå¦‚æœlockå¤„äºæ˜¯starvingæ¨¡å¼ï¼Œä¼šæ€ä¹ˆæ ·ï¼Œè¿™é‡Œåˆ†æä¸€ä¸‹ï¼Œæ³¨è„š3
    runtime_Semrelease(&amp;m.sema, true)
}
</code></pre></div></div>

<p>æ³¨è„š3  é¦–å…ˆåœ¨unlockå‡½æ•°å¼€å¤´å³ä½¿æ¸…äº†lockä½ï¼Œcpuä¸­çš„goroutineä¹Ÿä¸èƒ½è·å–åˆ°é”(å› ä¸ºåˆ¤æ–­m.stateçš„starvingä½æ˜¯é¥¥é¥¿æ¨¡å¼ï¼Œåªèƒ½é˜Ÿåˆ—ä¸­ç­‰å¾…çš„goroutineå–è·å–é”ï¼Œæ‰€ä»¥cpuä¸­çš„goroutineä¼šè¿›å…¥ç­‰å¾…é˜Ÿåˆ—)ï¼Œé‚£ä¹ˆåœ¨unlockå‡½æ•°ä¸­runtime_Semrelease(&amp;m.sema, true)æ—¶ï¼Œä¼šå”¤é†’é˜Ÿåˆ—ä¸­ä¸€ä¸ªç¡çœ çš„goroutineã€‚
å›åˆ°lockå‡½æ•°ä¸­ï¼Œæ­¤æ—¶m.stateåº”ä¸º100</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        runtime_SemacquireMutex(&amp;m.sema, queueLifo)   //åœ¨è¿™è¢«å”¤é†’
        starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
        old = m.state            //old = 100
        if old&amp;mutexStarving != 0 {         //lockå¤„äºstarvingä¸­
            // If this goroutine was woken and mutex is in starvation mode,
            // ownership was handed off to us but mutex is in somewhat
            // inconsistent state: mutexLocked is not set and we are still
            // accounted as waiter. Fix that.
            if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {
                throw("sync: inconsistent mutex state")
            }
            delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)                //å…ˆå°†å½“å‰ç­‰å¾…é˜Ÿåˆ—å‡ä¸€ä¸ª
            if !starving || old&gt;&gt;mutexWaiterShift == 1 {                              //å¦‚æœå½“å‰é˜Ÿåˆ—ç©ºäº†ï¼Œå°±æŠŠstarvingæ¸…0äº†
                // Exit starvation mode.
                // Critical to do it here and consider wait time.
                // Starvation mode is so inefficient, that two goroutines
                // can go lock-step infinitely once they switch mutex
                // to starvation mode.
                delta -= mutexStarving
            }
            atomic.AddInt32(&amp;m.state, delta)      //åŠ é”è·³å‡º
            break
        } æ€»ç»“ï¼šè¿™é‡Œåªç®€å•è¯´äº†ä¸‹äº’æ–¥é”ï¼Œå¦å¤–è¿˜æœ‰è¯»å†™é”ï¼Œä¸åšèµ˜è¿°ã€‚äº’æ–¥é”æ˜¯åœ¨åŸå­æ“ä½œatomicä¹‹ä¸Šå®ç°çš„ï¼Œåé¢ä¼šå†è¯¦ç»†å†™ä¸‹åŸå­æ“ä½œã€‚ è¿™é‡Œå…ˆè¯´å‡ ä¸ªæœ‰æ„æ€çš„é—®é¢˜ï¼Œç­”æ¡ˆä¸ä¸€å®šæ­£ç¡®ï¼Œå¸Œæœ›å¤§ä½¬æŒ‡æ­£ã€‚ 1  ä¸€ä¸ªå…¨å±€intå˜é‡ï¼Œå¤šæ ¸ä¸­ä¸€ä¸ªgoroutineè¯»ï¼Œä¸€ä¸ªå†™ï¼Œæ²¡æœ‰æ›´å¤šæ“ä½œï¼Œéœ€ä¸éœ€è¦åšåŸå­æ“ä½œã€‚    åº”è¯¥æ˜¯ä¸éœ€è¦åŠ çš„ï¼Œintel P6å¤„ç†å™¨åœ¨ç¡¬ä»¶å±‚é¢ä¸Šæ˜¯æ”¯æŒ32ä½å˜é‡çš„loadå’Œstoreçš„åŸå­æ€§çš„ã€‚å¦å¤–ç¼–è¯‘å™¨å¯¹äºå˜é‡çš„è¯»æˆ–å†™ä¹Ÿä¸ä¼šç¼–è¯‘æˆå¤šæ¡æŒ‡ä»¤ã€‚
</code></pre></div></div>

<p>2   ä¸€ä¸ªå…¨å±€intå˜é‡i, å¯¹äºå¤šæ ¸ï¼Œä¸¤ä¸ªåç¨‹éƒ½åŒæ—¶æ‰§è¡Œi++ï¼Œéœ€è¦åŸå­æ“ä½œå—ï¼Ÿ
    éœ€è¦çš„ï¼Œå¯¹äºi++ï¼Œæ˜¯å…¸å‹çš„è¯»æ”¹å†™æ“ä½œï¼Œå¯¹äºè¿™æ ·çš„æ“ä½œï¼Œéœ€è¦CASåŸå­æ“ä½œä¿è¯åŸå­æ€§ã€‚</p>

<p>3  å¯¹äºä¸€ä¸ªmapï¼Œå†™åŠ åŸå­æ“ä½œï¼Œè¯»è¦ä¸è¦åŠ 
    å¦‚æœåªæ˜¯è¯»æˆ–è€…å†™ï¼Œå¹¶ä¸”å€¼ç±»å‹æ˜¯æ•´å½¢çš„ï¼Œåº”è¯¥æ˜¯ä¸éœ€è¦atomicåŸå­æ“ä½œçš„ï¼Œè¿™é‡Œçš„æ„æ€æ˜¯å¯¹äºæ•´å½¢ï¼Œä¸ä¼šå‡ºç°å†™ä¸€åŠï¼Œæˆ–è€…è¯»ä¸€åŠçš„æƒ…å†µï¼Œä½†æ˜¯ä¸å¯é¿å…çš„ï¼Œä¼šå‡ºç°è¿™ç§æƒ…å†µï¼Œgoroutine1å¯¹mapå†™å…¥1ï¼Œgoroutine2è¯»åˆ°1ï¼Œåœ¨å¤„ç†çš„è¿‡ç¨‹ä¸­ï¼Œgoroutine1åˆé‡æ–°èµ‹å€¼ã€‚</p>

<p>https://www.cnblogs.com/myJune/p/10068439.html
http://www.bubuko.com/infodetail-2872971.html?<strong>cf_chl_jschl_tk</strong>=f4815289b70d6b614e5fdf695f3cdf0c0fac1ac0-1604124726-0-AUUbX5tdd3NhZr6R91-SsU7Swv0fDuqIiiMeNPYTDCYS8zYjWnEW5JLoL-ZFXDmdelVg5Lazzw_eQOobeN1pFcomqPTaA-ijTScYVISxdAU4AFMp3PmR9BAwXDkkdFT9Uwvd2gIR-u_JhwlnQN22jRB3LMvKKMTkXSIahKv7jYNpeDNRxWlwpNpcsHBRwIqznwi6pcPL618geF3X1yx0E6POx2QD8aBUknvNaqaYAaLl4OA7VNo6NY2559idhIxmWxGCiukdNzH_iHT_DQjk8PlN4pv3NEoP7qn-kkvQv7H-</p>

<p>https://www.cnblogs.com/ts65214/p/12977159.html</p>

<p>https://blog.csdn.net/weixin_40318210/article/details/80301288</p>

<p>https://blog.csdn.net/panxj856856/article/details/80377850</p>

<p>https://www.zhihu.com/question/332113890/answer/762392859</p>

<p>https://blog.csdn.net/wll1228/article/details/108086938</p>

<p>https://studygolang.com/articles/10161</p>

<p>https://zhuanlan.zhihu.com/p/27608263</p>
:ET