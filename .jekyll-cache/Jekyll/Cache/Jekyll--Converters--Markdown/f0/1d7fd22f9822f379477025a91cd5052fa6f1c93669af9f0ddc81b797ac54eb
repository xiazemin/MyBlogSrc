I"éP<p>Goè‡ªä»å®£å¸ƒGo1 Compatibleåï¼Œç›´åˆ°è¿™æ¬¡çš„Go 1.14å‘å¸ƒï¼ŒGoçš„è¯­æ³•å’Œæ ¸å¿ƒåº“éƒ½æ²¡æœ‰åšå‡ºä¸å…¼å®¹çš„å˜åŒ–ã€‚è¿™è®©å¾ˆå¤šå…¶ä»–ä¸»æµè¯­è¨€çš„æ‹¥è¶¸ä»¬è§‰å¾—Goå¾ˆâ€œæ— è¶£â€ã€‚ä½†è¿™ç§æ‰¿è¯ºæ°æ°æ˜¯Goå›¢é˜ŸèƒŒååŠªåŠ›ä»˜å‡ºçš„ç»“æœï¼Œå› æ­¤Goçš„æ¯ä¸ªå‘å¸ƒç‰ˆæœ¬éƒ½å€¼å¾—å¹¿å¤§gopherå°Šé‡ï¼Œæ¯ä¸ªå‘å¸ƒç‰ˆæœ¬éƒ½æ˜¯Goå›¢é˜Ÿèƒ½æ‹¿å‡ºçš„æœ€å¥½ç‰ˆæœ¬ã€‚</p>

<p>ä¸‹é¢æˆ‘ä»¬å°±æ¥è§£è¯»ä¸€ä¸‹Go 1.14çš„å˜åŒ–ï¼Œçœ‹çœ‹è¿™ä¸ªæ–°ç‰ˆæœ¬ä¸­æœ‰å“ªäº›å€¼å¾—æˆ‘ä»¬é‡ç‚¹å…³æ³¨çš„å˜åŒ–ã€‚
https://tonybai.com/2020/03/08/some-changes-in-go-1-14/
<!-- more -->
ä¸€. è¯­è¨€è§„èŒƒ
å’Œå…¶ä»–ä¸»æµè¯­è¨€ç›¸æ¯”ï¼ŒGoè¯­è¨€çš„è¯­æ³•è§„èŒƒçš„å˜åŒ–é‚£æ˜¯æå…¶å°‘çš„ï¼ˆå¹¿å¤§Gopherä»¬å·²ç»ä¹ æƒ¯äº†è¿™ä¸ªèŠ‚å¥:)ï¼‰ï¼Œå¶å°”å‘å¸ƒä¸€ä¸ªå˜åŒ–ï¼Œé‚£è‡ªç„¶æ˜¯è¦å¼•èµ·å¹¿å¤§Gopherä¸¥é‡å…³æ³¨çš„:)ã€‚ä¸è¿‡äº‹å…ˆè¯´æ˜ï¼šåªè¦Goç‰ˆæœ¬ä¾ç„¶æ˜¯1.xï¼Œé‚£ä¹ˆè¿™ä¸ªè§„èŒƒå˜åŒ–ä¹Ÿæ˜¯backward-compitableçš„ã€‚</p>

<p>Go 1.14æ–°å¢çš„è¯­æ³•å˜åŒ–æ˜¯ï¼šåµŒå…¥æ¥å£çš„æ–¹æ³•é›†å¯é‡å ã€‚è¿™ä¸ªå˜åŒ–èƒŒåçš„æœ´ç´ æ€æƒ³æ˜¯è¿™æ ·çš„ã€‚çœ‹ä¸‹é¢ä»£ç (æ¥è‡ªè¿™é‡Œ)ï¼š</p>

<p>type I interface { f(); String() string }
type J interface { g(); String() string }</p>

<p>type IJ interface { I; J }  â€”â€“ (1)
type IJ interface { f(); g(); String() string }  â€”- (2)</p>

<p>ä»£ç ä¸­å·²çŸ¥å®šä¹‰çš„Iå’ŒJä¸¤ä¸ªæ¥å£çš„æ–¹æ³•é›†ä¸­éƒ½åŒ…å«æœ‰
String() string
è¿™ä¸ªæ–¹æ³•ã€‚åœ¨è¿™æ ·çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¦‚æœæƒ³å®šä¹‰ä¸€ä¸ªæ–¹æ³•é›†åˆä¸ºUnion(I, J)çš„æ–°æ¥å£
IJ
ï¼Œæˆ‘ä»¬åœ¨Go 1.13åŠä¹‹å‰çš„ç‰ˆæœ¬ä¸­åªèƒ½ä½¿ç”¨ç¬¬(2)ç§æ–¹å¼ï¼Œå³åªèƒ½åœ¨æ–°æ¥å£
IJ
ä¸­é‡æ–°ä¹¦å†™ä¸€éæ‰€æœ‰çš„æ–¹æ³•åŸå‹ï¼Œè€Œæ— æ³•åƒç¬¬(1)ç§æ–¹å¼é‚£æ ·ä½¿ç”¨åµŒå…¥æ¥å£çš„ç®€æ´æ–¹å¼è¿›è¡Œã€‚</p>

<p>Go 1.14é€šè¿‡æ”¯æŒåµŒå…¥æ¥å£çš„æ–¹æ³•é›†å¯é‡å è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼š</p>

<p>// go1.14-examples/overlapping_interface.go
package foo</p>

<p>type I interface {
    f()
    String() string
}
type J interface {
    g()
    String() string
}</p>

<p>type IJ interface {
    I
    J
}</p>

<p>åœ¨go 1.13.6ä¸Šè¿è¡Œï¼š</p>

<p>$go build overlapping_interface.go</p>
<h1 id="command-line-arguments">command-line-arguments</h1>
<p>./overlapping_interface.go:14:2: duplicate method String</p>

<p>ä½†åœ¨go 1.14ä¸Šè¿è¡Œï¼š</p>

<p>$go build overlapping_interface.go</p>

<p>// ä¸€åˆ‡okï¼Œæ— æŠ¥é”™</p>

<p>ä¸è¿‡å¯¹overlapping interfaceçš„æ”¯æŒä»…é™äºæ¥å£å®šä¹‰ä¸­ï¼Œå¦‚æœä½ è¦åœ¨structå®šä¹‰ä¸­åµŒå…¥interfaceï¼Œæ¯”å¦‚åƒä¸‹é¢è¿™æ ·ï¼š</p>

<p>// go1.14-examples/overlapping_interface1.go
package main</p>

<p>type I interface {
    f()
    String() string
}</p>

<p>type implOfI struct{}</p>

<p>func (implOfI) f() {}
func (implOfI) String() string {
    return â€œimplOfIâ€
}</p>

<p>type J interface {
    g()
    String() string
}</p>

<p>type implOfJ struct{}</p>

<p>func (implOfJ) g() {}
func (implOfJ) String() string {
    return â€œimplOfJâ€
}</p>

<p>type Foo struct {
    I
    J
}</p>

<p>func main() {
    f := Foo{
        I: implOfI{},
        J: implOfJ{},
    }
    println(f.String())
}</p>

<p>è™½ç„¶Goç¼–è¯‘å™¨æ²¡æœ‰ç›´æ¥æŒ‡å‡ºç»“æ„ä½“Fooä¸­åµŒå…¥çš„ä¸¤ä¸ªæ¥å£Iå’ŒJå­˜åœ¨æ–¹æ³•çš„é‡å ï¼Œä½†åœ¨ä½¿ç”¨Fooç»“æ„ä½“æ—¶ï¼Œä¸‹é¢çš„ç¼–è¯‘å™¨é”™è¯¯è‚¯å®šè¿˜æ˜¯ä¼šç»™å‡ºçš„ï¼š</p>

<p>$ go run overlapping_interface1.go</p>
<h1 id="command-line-arguments-1">command-line-arguments</h1>
<p>./overlapping_interface1.go:37:11: ambiguous selector f.String</p>

<p>å¯¹äºç»“æ„ä½“ä¸­åµŒå…¥çš„æ¥å£çš„æ–¹æ³•é›†æ˜¯å¦å­˜åœ¨overlapï¼Œgoç¼–è¯‘å™¨ä¼¼ä¹å¹¶æ²¡æœ‰ä¸¥æ ¼åšâ€œå®æ—¶â€æ£€æŸ¥ï¼Œè¿™ä¸ªæ£€æŸ¥è¢«å»¶è¿Ÿåˆ°ä¸ºç»“æ„ä½“å®ä¾‹é€‰æ‹©methodçš„æ‰§è¡Œè€…ç¯èŠ‚äº†ï¼Œå°±åƒä¸Šé¢ä¾‹å­é‚£æ ·ã€‚å¦‚æœæˆ‘ä»¬æ­¤æ—¶è®©Fooç»“æ„ä½“ overrideä¸€ä¸ªStringæ–¹æ³•ï¼Œé‚£ä¹ˆå³ä¾¿Iå’ŒJçš„æ–¹æ³•é›†å­˜åœ¨overlapä¹Ÿæ˜¯æ— å…³ç´§è¦çš„ï¼Œå› ä¸ºç¼–è¯‘å™¨ä¸ä¼šå†æ¨¡æ£±ä¸¤å¯ï¼Œå¯ä»¥æ­£ç¡®çš„ä¸ºFooå®ä¾‹é€‰å‡ºç©¶ç«Ÿæ‰§è¡Œå“ªä¸ªStringæ–¹æ³•ï¼š</p>

<p>// go1.14-examples/overlapping_interface2.go</p>

<p>â€¦. â€¦.</p>

<p>func (Foo) String() string {
        return â€œFooâ€
}</p>

<p>func main() {
        f := Foo{
                I: implOfI{},
                J: implOfJ{},
        }
        println(f.String())
}</p>

<p>è¿è¡Œè¯¥ä»£ç ï¼š</p>

<p>$go run overlapping_interface2.go
Foo</p>

<p>äºŒ. Goè¿è¡Œæ—¶</p>
<ol>
  <li>æ”¯æŒå¼‚æ­¥æŠ¢å å¼è°ƒåº¦
åœ¨ã€ŠGoroutineè°ƒåº¦å®ä¾‹ç®€è¦åˆ†æã€‹ä¸€æ–‡ä¸­ï¼Œæˆ‘æ›¾æåˆ°è¿‡è¿™æ ·ä¸€ä¸ªä¾‹å­ï¼š</li>
</ol>

<p>// go1.14-examples/preemption_scheduler.go
package main</p>

<p>import (
    â€œfmtâ€
    â€œruntimeâ€
    â€œtimeâ€
)</p>

<p>func deadloop() {
    for {
    }
}</p>

<p>func main() {
    runtime.GOMAXPROCS(1)
    go deadloop()
    for {
        time.Sleep(time.Second * 1)
        fmt.Println(â€œI got scheduled!â€)
    }
}</p>

<p>åœ¨åªæœ‰ä¸€ä¸ª
P
çš„æƒ…å†µä¸‹ï¼Œä¸Šé¢çš„ä»£ç ä¸­deadloopæ‰€åœ¨goroutineå°†æŒç»­å æ®è¯¥
P
ï¼Œä½¿å¾—main goroutineä¸­çš„ä»£ç å¾—ä¸åˆ°è°ƒåº¦(GOMAXPROCS=1çš„æƒ…å†µä¸‹)ï¼Œå› æ­¤æˆ‘ä»¬æ— æ³•çœ‹åˆ°
I got scheduled!
å­—æ ·è¾“å‡ºã€‚è¿™æ˜¯å› ä¸ºGo 1.13åŠä»¥å‰çš„ç‰ˆæœ¬çš„æŠ¢å æ˜¯â€åä½œå¼â€œçš„ï¼Œåªåœ¨æœ‰å‡½æ•°è°ƒç”¨çš„åœ°æ–¹æ‰èƒ½æ’å…¥â€œæŠ¢å â€ä»£ç (åŸ‹ç‚¹)ï¼Œè€Œdeadloopæ²¡æœ‰ç»™ç¼–è¯‘å™¨æ’å…¥æŠ¢å ä»£ç çš„æœºä¼šã€‚è¿™ä¼šå¯¼è‡´GCåœ¨ç­‰å¾…æ‰€æœ‰goroutineåœæ­¢æ—¶ç­‰å¾…æ—¶é—´è¿‡é•¿ï¼Œä»è€Œå¯¼è‡´GCå»¶è¿Ÿï¼›ç”šè‡³åœ¨ä¸€äº›ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œå¯¼è‡´åœ¨STWï¼ˆstop the worldï¼‰æ—¶æ­»é”ã€‚</p>

<p>Go 1.14é‡‡ç”¨äº†åŸºäºç³»ç»Ÿä¿¡å·çš„å¼‚æ­¥æŠ¢å è°ƒåº¦ï¼Œè¿™æ ·ä¸Šé¢çš„deadloopæ‰€åœ¨çš„goroutineä¹Ÿå¯ä»¥è¢«æŠ¢å äº†ï¼š</p>

<p>// ä½¿ç”¨Go 1.14ç‰ˆæœ¬ç¼–è¯‘å™¨è¿è¡Œä¸Šè¿°ä»£ç </p>

<p>$go run preemption_scheduler.go
I got scheduled!
I got scheduled!
I got scheduled!</p>

<p>ä¸è¿‡ç”±äºç³»ç»Ÿä¿¡å·å¯èƒ½åœ¨ä»£ç æ‰§è¡Œåˆ°ä»»æ„åœ°æ–¹å‘ç”Ÿï¼Œåœ¨Go runtimeèƒ½coveråˆ°çš„åœ°æ–¹ï¼ŒGo runtimeè‡ªç„¶ä¼šå¤„ç†å¥½è¿™äº›ç³»ç»Ÿä¿¡å·ã€‚ä½†æ˜¯å¦‚æœä½ æ˜¯é€šè¿‡
syscall
åŒ…æˆ–
golang.org/x/sys/unix
åœ¨Unix/Linux/Macä¸Šç›´æ¥è¿›è¡Œç³»ç»Ÿè°ƒç”¨ï¼Œé‚£ä¹ˆä¸€æ—¦åœ¨ç³»ç»Ÿè°ƒç”¨æ‰§è¡Œè¿‡ç¨‹ä¸­è¿›ç¨‹æ”¶åˆ°ç³»ç»Ÿä¸­æ–­ä¿¡å·ï¼Œè¿™äº›ç³»ç»Ÿè°ƒç”¨å°±ä¼šå¤±è´¥ï¼Œå¹¶ä»¥EINTRé”™è¯¯è¿”å›ï¼Œå°¤å…¶æ˜¯ä½é€Ÿç³»ç»Ÿè°ƒç”¨ï¼ŒåŒ…æ‹¬ï¼šè¯»å†™ç‰¹å®šç±»å‹æ–‡ä»¶(ç®¡é“ã€ç»ˆç«¯è®¾å¤‡ã€ç½‘ç»œè®¾å¤‡)ã€è¿›ç¨‹é—´é€šä¿¡ç­‰ã€‚åœ¨è¿™æ ·çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å°±éœ€è¦è‡ªå·±å¤„ç†EINTRé”™è¯¯ã€‚ä¸€ä¸ªæœ€å¸¸è§çš„é”™è¯¯å¤„ç†æ–¹å¼å°±æ˜¯é‡è¯•ã€‚å¯¹äºå¯é‡å…¥çš„ç³»ç»Ÿè°ƒç”¨æ¥è¯´ï¼Œåœ¨æ”¶åˆ°EINTRä¿¡å·åçš„é‡è¯•æ˜¯å®‰å…¨çš„ã€‚å¦‚æœä½ æ²¡æœ‰è‡ªå·±è°ƒç”¨syscallåŒ…ï¼Œé‚£ä¹ˆå¼‚æ­¥æŠ¢å è°ƒåº¦å¯¹ä½ å·²æœ‰çš„ä»£ç å‡ ä¹æ— å½±å“ã€‚</p>

<p>Go 1.14çš„å¼‚æ­¥æŠ¢å è°ƒåº¦åœ¨windows/arm, darwin/arm, js/wasm, and plan9/*ä¸Šä¾ç„¶å°šæœªæ”¯æŒï¼ŒGoå›¢é˜Ÿè®¡åˆ’åœ¨Go 1.15ä¸­è§£å†³æ‰è¿™äº›é—®é¢˜ã€‚</p>

<ol>
  <li>deferæ€§èƒ½å¾—ä»¥ç»§ç»­ä¼˜åŒ–
åœ¨Go 1.13ä¸­ï¼Œdeferæ€§èƒ½å¾—åˆ°ç†è®ºä¸Š30%çš„æå‡ã€‚æˆ‘ä»¬è¿˜ç”¨é‚£ä¸ªä¾‹å­æ¥çœ‹çœ‹go 1.14ä¸go 1.13ç‰ˆæœ¬ç›¸æ¯”deferæ€§èƒ½åˆæœ‰å¤šå°‘æå‡ï¼ŒåŒæ—¶å†çœ‹çœ‹ä½¿ç”¨deferå’Œä¸ä½¿ç”¨deferçš„å¯¹æ¯”ï¼š</li>
</ol>

<p>// go1.14-examples/defer_benchmark_test.go
package defer_test</p>

<p>import â€œtestingâ€</p>

<p>func sum(max int) int {
    total := 0
    for i := 0; i &lt; max; i++ {
        total += i
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return total }
</code></pre></div></div>

<p>func foo() {
    defer func() {
        sum(10)
    }()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sum(100) }
</code></pre></div></div>

<p>func Bar() {
    sum(100)
    sum(10)
}</p>

<p>func BenchmarkDefer(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        foo()
    }
}
func BenchmarkWithoutDefer(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        Bar()
    }
}</p>

<p>æˆ‘ä»¬åˆ†åˆ«ç”¨Go 1.13å’ŒGo 1.14è¿è¡Œä¸Šé¢çš„åŸºå‡†æµ‹è¯•ä»£ç ï¼š</p>

<p>Go 1.13:</p>

<p>$go test -bench . defer_benchmark_test.go
goos: darwin
goarch: amd64
BenchmarkDefer-8              17873574            66.7 ns/op
BenchmarkWithoutDefer-8       26935401            43.7 ns/op
PASS
ok      command-line-arguments    2.491s</p>

<p>Go 1.14:</p>

<p>$go test -bench . defer_benchmark_test.go
goos: darwin
goarch: amd64
BenchmarkDefer-8              26179819            45.1 ns/op
BenchmarkWithoutDefer-8       26116602            43.5 ns/op
PASS
ok      command-line-arguments    2.418s
æˆ‘ä»¬çœ‹åˆ°ï¼ŒGo 1.14çš„deferæ€§èƒ½ç…§æ¯”Go 1.13è¿˜æœ‰å¤§å¹…æå‡ï¼Œå¹¶ä¸”å·²ç»ä¸ä¸ä½¿ç”¨deferçš„æ€§èƒ½ç›¸å·®æ— å‡ äº†ï¼Œè¿™ä¹Ÿæ˜¯Goå®˜æ–¹é¼“åŠ±å¤§å®¶åœ¨æ€§èƒ½æ•æ„Ÿçš„ä»£ç æ‰§è¡Œè·¯å¾„ä¸Šä¹Ÿå¤§èƒ†ä½¿ç”¨deferçš„åŸå› ã€‚</p>

<p>img{512x368}</p>

<p>å›¾ï¼šå„ä¸ªGoç‰ˆæœ¬deferæ€§èƒ½å¯¹æ¯”(å›¾æ¥è‡ªäºhttps://twitter.com/janiszt/status/1215601972281253888)</p>
<ol>
  <li>internal timerçš„é‡æ–°å®ç°
é‰´äºgo timeré•¿æœŸä»¥æ¥æ€§èƒ½ä¸èƒ½ä»¤äººæ»¡æ„ï¼ŒGo 1.14å‡ ä¹é‡æ–°å®ç°äº†runtimeå±‚çš„timerã€‚å…¶å®ç°æ€è·¯éµå¾ªäº†Dmitry Vyukovå‡ å¹´å‰æå‡ºçš„å®ç°é€»è¾‘ï¼šå°†timeråˆ†é…åˆ°æ¯ä¸ªPä¸Šï¼Œé™ä½é”ç«äº‰ï¼›å»æ‰timer threadï¼Œå‡å°‘ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ï¼›ä½¿ç”¨netpollçš„timeoutå®ç°timeræœºåˆ¶ã€‚</li>
</ol>

<p>// $GOROOT/src/runtime/time.go</p>

<p>type timer struct {
        // If this timer is on a heap, which Pâ€™s heap it is on.
        // puintptr rather than *p to match uintptr in the versions
        // of this struct defined in other packages.
        pp puintptr</p>

<p>}</p>

<p>// addtimer adds a timer to the current P.
// This should only be called with a newly created timer.
// That avoids the risk of changing the when field of a timer in some Pâ€™s heap,
// which could cause the heap to become unsorted.</p>

<p>func addtimer(t *timer) {
        // when must never be negative; otherwise runtimer will overflow
        // during its delta calculation and never expire other runtime timers.
        if t.when &lt; 0 {
                t.when = maxWhen
        }
        if t.status != timerNoStatus {
                badTimer()
        }
        t.status = timerWaiting</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    addInitializedTimer(t) }
</code></pre></div></div>

<p>// addInitializedTimer adds an initialized timer to the current P.
func addInitializedTimer(t *timer) {
        when := t.when</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pp := getg().m.p.ptr()
    lock(&amp;pp.timersLock)
    ok := cleantimers(pp) &amp;&amp; doaddtimer(pp, t)
    unlock(&amp;pp.timersLock)
    if !ok {
            badTimer()
    }

    wakeNetPoller(when) } ... ...
</code></pre></div></div>

<p>è¿™æ ·ä½ çš„ç¨‹åºä¸­å¦‚æœå¤§é‡ä½¿ç”¨time.Afterã€time.Tickæˆ–è€…åœ¨å¤„ç†ç½‘ç»œè¿æ¥æ—¶å¤§é‡ä½¿ç”¨SetDeadlineï¼Œä½¿ç”¨Go 1.14ç¼–è¯‘åï¼Œä½ çš„åº”ç”¨å°†å¾—åˆ°timeræ€§èƒ½çš„è‡ªç„¶æå‡ã€‚</p>

<p>img{512x368}</p>

<p>å›¾ï¼šåˆ‡æ¢åˆ°æ–°timerå®ç°åçš„å„Benchmarkæ•°æ®
ä¸‰. Go moduleå·²ç»production readyäº†
Go 1.14ä¸­å¸¦æ¥çš„å…³äºgo moduleçš„æœ€å¤§æƒŠå–œå°±æ˜¯Go moduleå·²ç»production readyäº†ï¼Œè¿™æ„å‘³ç€å…³äºgo moduleçš„è¿ä½œæœºåˆ¶ï¼Œgo toolçš„å„ç§å‘½ä»¤å’Œå…¶å‚æ•°å½¢å¼ã€è¡Œä¸ºç‰¹å¾å·²è¶‹ç¨³å®šäº†ã€‚ç¬”è€…ä»Go 1.11å¼•å…¥go moduleä»¥æ¥å°±ä¸€ç›´å…³æ³¨å’Œä½¿ç”¨Go moduleï¼Œå°¤å…¶æ˜¯Go 1.13ä¸­å¢åŠ go module proxyçš„æ”¯æŒï¼Œä½¿å¾—ä¸­å›½å¤§é™†çš„gopherå†ä¹Ÿä¸ç”¨ä¸ºè·å–ç±»ä¼¼
golang.org/x/xxx
è·¯å¾„ä¸‹çš„moduleè€Œè‹¦æ¼äº†ã€‚</p>

<p>Go 1.14ä¸­go moduleçš„ä¸»è¦å˜åŠ¨å¦‚ä¸‹ï¼š</p>

<p>a) module-awareæ¨¡å¼ä¸‹å¯¹vendorçš„å¤„ç†ï¼šå¦‚æœgo.modä¸­go versionæ˜¯go 1.14åŠä»¥ä¸Šï¼Œä¸”å½“å‰repoé¡¶å±‚ç›®å½•ä¸‹æœ‰vendorç›®å½•ï¼Œé‚£ä¹ˆgoå·¥å…·é“¾å°†é»˜è®¤ä½¿ç”¨vendor(å³-mod=vendor)ä¸­çš„packageï¼Œè€Œä¸æ˜¯module cacheä¸­çš„($GOPATH/pkg/modä¸‹)ã€‚åŒæ—¶åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œgo å·¥å…·ä¼šæ ¡éªŒvendor/modules.txtä¸go.modæ–‡ä»¶ï¼Œå®ƒä»¬éœ€è¦ä¿æŒåŒæ­¥ï¼Œå¦åˆ™æŠ¥é”™ã€‚</p>

<p>åœ¨ä¸Šè¿°å‰æä¸‹ï¼Œå¦‚è¦éè¦ä½¿ç”¨module cacheæ„å»ºï¼Œåˆ™éœ€è¦ä¸ºgoå·¥å…·é“¾æ˜¾å¼ä¼ å…¥
-mod=mod
ï¼Œæ¯”å¦‚ï¼š
go build -mod=mod ./â€¦
ã€‚</p>

<p>b) å¢åŠ GOINSECUREï¼Œå¯ä»¥ä¸å†è¦æ±‚éå¾—ä»¥httpsè·å–moduleï¼Œæˆ–è€…å³ä¾¿ä½¿ç”¨httpsï¼Œä¹Ÿä¸å†å¯¹serverè¯ä¹¦è¿›è¡Œæ ¡éªŒã€‚</p>

<p>c) åœ¨module-awareæ¨¡å¼ä¸‹ï¼Œå¦‚æœæ²¡æœ‰å»ºç«‹go.modæˆ–goå·¥å…·é“¾æ— æ³•æ‰¾åˆ°go.modï¼Œé‚£ä¹ˆä½ å¿…é¡»æ˜¾å¼ä¼ å…¥è¦å¤„ç†çš„goæºæ–‡ä»¶åˆ—è¡¨ï¼Œå¦åˆ™go toolså°†éœ€è¦ä½ æ˜ç¡®go.modã€‚æ¯”å¦‚ï¼šåœ¨ä¸€ä¸ªæ²¡æœ‰go.modçš„ç›®å½•ä¸‹ï¼Œè¦ç¼–è¯‘ä¸€ä¸ªhello.goï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨go build hello.go(hello.goéœ€è¦æ˜¾å¼æ”¾åœ¨å‘½ä»¤åé¢ï¼‰ï¼Œå¦‚æœä½ æ‰§è¡Œ
go build .
å°±ä¼šå¾—åˆ°ç±»ä¼¼å¦‚ä¸‹é”™è¯¯ä¿¡æ¯ï¼š</p>

<p>$go build .
go: cannot find main module, but found .git/config in /Users/tonybai
    to create a module there, run:
    cd .. &amp;&amp; go mod init</p>

<p>ä¹Ÿå°±æ˜¯è¯´åœ¨æ²¡æœ‰go.modçš„æƒ…å†µä¸‹ï¼Œgoå·¥å…·é“¾çš„åŠŸèƒ½æ˜¯å—é™çš„ã€‚</p>

<p>d) go moduleæ”¯æŒsubversionä»“åº“äº†ï¼Œä¸è¿‡subversionä½¿ç”¨åº”è¯¥å¾ˆâ€œå°ä¼—â€äº†ã€‚</p>

<p>è¦ç³»ç»Ÿå…¨é¢çš„äº†è§£go moduleçš„å½“å‰è¡Œä¸ºæœºåˆ¶ï¼Œå»ºè®®è¿˜æ˜¯é€šè¯»ä¸€éGo commandæ‰‹å†Œä¸­å…³äºmoduleçš„è¯´æ˜ä»¥åŠå®˜æ–¹go module wikiã€‚</p>

<p>å››. ç¼–è¯‘å™¨
Go 1.14 goç¼–è¯‘å™¨åœ¨-raceå’Œ-msançš„æƒ…å†µä¸‹ï¼Œé»˜è®¤ä¼šæ‰§è¡Œ
-d=checkptr
ï¼Œå³å¯¹unsafe.Pointerçš„ä½¿ç”¨è¿›è¡Œåˆæ³•æ€§æ£€æŸ¥ï¼Œä¸»è¦æ£€æŸ¥ä¸¤é¡¹å†…å®¹ï¼š</p>

<p>å½“å°†unsafe.Pointerè½¬å‹ä¸º
*T
æ—¶ï¼ŒTçš„å†…å­˜å¯¹é½ç³»æ•°ä¸èƒ½é«˜äºåŸåœ°å€çš„
æ¯”å¦‚ä¸‹é¢ä»£ç ï¼š</p>

<p>// go1.14-examples/compiler_checkptr1.go
package main</p>

<p>import (
    â€œfmtâ€
    â€œunsafeâ€
)</p>

<p>func main() {
    var byteArray = [10]byte{â€˜aâ€™, â€˜bâ€™, â€˜câ€™}
    var p <em>int64 = (</em>int64)(unsafe.Pointer(&amp;byteArray[1]))
    fmt.Println(*p)
}</p>

<p>ä»¥-raceè¿è¡Œä¸Šè¿°ä»£ç ï¼š</p>

<p>$go run -race compiler_checkptr1.go
fatal error: checkptr: unsafe pointer conversion</p>

<p>goroutine 1 [running]:
runtime.throw(0x11646fd, 0x23)
    /Users/tonybai/.bin/go1.14/src/runtime/panic.go:1112 +0x72 fp=0xc00004cee8 sp=0xc00004ceb8 pc=0x106d152
runtime.checkptrAlignment(0xc00004cf5f, 0x1136880, 0x1)
    /Users/tonybai/.bin/go1.14/src/runtime/checkptr.go:13 +0xd0 fp=0xc00004cf18 sp=0xc00004cee8 pc=0x1043b70
main.main()
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.14-examples/compiler_checkptr1.go:10 +0x70 fp=0xc00004cf88 sp=0xc00004cf18 pc=0x11283b0
runtime.main()
    /Users/tonybai/.bin/go1.14/src/runtime/proc.go:203 +0x212 fp=0xc00004cfe0 sp=0xc00004cf88 pc=0x106f7a2
runtime.goexit()
    /Users/tonybai/.bin/go1.14/src/runtime/asm_amd64.s:1373 +0x1 fp=0xc00004cfe8 sp=0xc00004cfe0 pc=0x109b801
exit status 2</p>

<p>checkptræ£€æµ‹åˆ°ï¼šè½¬æ¢åçš„int64ç±»å‹çš„å†…å­˜å¯¹é½ç³»æ•°ä¸¥æ ¼ç¨‹åº¦è¦é«˜äºè½¬åŒ–å‰çš„åŸåœ°å€(ä¸€ä¸ªbyteå˜é‡çš„åœ°å€)ã€‚int64å¯¹é½ç³»æ•°ä¸º8ï¼Œè€Œä¸€ä¸ªbyteå˜é‡åœ°å€å¯¹é½ç³»æ•°ä»…ä¸º1ã€‚</p>

<p>åšå®ŒæŒ‡é’ˆç®—æœ¯åï¼Œè½¬æ¢åçš„unsafe.Pointerä»åº”æŒ‡å‘åŸå…ˆGoå †å¯¹è±¡
compiler_checkptr2.go
package main</p>

<p>import (
    â€œunsafeâ€
)</p>

<p>func main() {
    var n = 5
    b := make([]byte, n)
    end := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;b[0])) + uintptr(n+10))
    _ = end
}</p>

<p>è¿è¡Œä¸Šè¿°ä»£ç ï¼š</p>

<p>$go run  -race compiler_checkptr2.go
fatal error: checkptr: unsafe pointer arithmetic</p>

<p>goroutine 1 [running]:
runtime.throw(0x10b618b, 0x23)
    /Users/tonybai/.bin/go1.14/src/runtime/panic.go:1112 +0x72 fp=0xc00003e720 sp=0xc00003e6f0 pc=0x1067192
runtime.checkptrArithmetic(0xc0000180b7, 0xc00003e770, 0x1, 0x1)
    /Users/tonybai/.bin/go1.14/src/runtime/checkptr.go:41 +0xb5 fp=0xc00003e750 sp=0xc00003e720 pc=0x1043055
main.main()
    /Users/tonybai/go/src/github.com/bigwhite/experiments/go1.14-examples/compiler_checkptr2.go:10 +0x8d fp=0xc00003e788 sp=0xc00003e750 pc=0x1096ced
runtime.main()
    /Users/tonybai/.bin/go1.14/src/runtime/proc.go:203 +0x212 fp=0xc00003e7e0 sp=0xc00003e788 pc=0x10697e2
runtime.goexit()
    /Users/tonybai/.bin/go1.14/src/runtime/asm_amd64.s:1373 +0x1 fp=0xc00003e7e8 sp=0xc00003e7e0 pc=0x1092581
exit status 2</p>

<p>checkptræ£€æµ‹åˆ°è½¬æ¢åçš„unsafe.Pointerå·²ç»è¶…å‡ºåŸå…ˆheap object: bçš„èŒƒå›´äº†ï¼Œäºæ˜¯æŠ¥é”™ã€‚</p>

<p>ä¸è¿‡ç›®å‰Goæ ‡å‡†åº“ä¾ç„¶å°šæœªèƒ½å®Œå…¨é€šè¿‡checkptrçš„æ£€æŸ¥ï¼Œå› ä¸ºæœ‰äº›åº“ä»£ç æ˜¾ç„¶è¿åäº†unsafe.Pointerçš„ä½¿ç”¨è§„åˆ™ã€‚</p>

<p>Go 1.13å¼•å…¥äº†æ–°çš„Escape Analysisï¼ŒGo 1.14ä¸­æˆ‘ä»¬å¯ä»¥é€šè¿‡
-m=2
æŸ¥çœ‹è¯¦ç»†çš„é€ƒé€¸åˆ†æè¿‡ç¨‹æ—¥å¿—ï¼Œæ¯”å¦‚ï¼š</p>

<p>$go run  -gcflags â€˜-m=2â€™ compiler_checkptr2.go</p>
<h1 id="command-line-arguments-2">command-line-arguments</h1>
<p>./compiler_checkptr2.go:7:6: can inline main as: func() { var n int; n = 5; b := make([]byte, n); end := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;b[0])) + uintptr(n + 100)); _ = end }
./compiler_checkptr2.go:9:11: make([]byte, n) escapes to heap:
./compiler_checkptr2.go:9:11:   flow: {heap} = &amp;{storage for make([]byte, n)}:
./compiler_checkptr2.go:9:11:     from make([]byte, n) (non-constant size) at ./compiler_checkptr2.go:9:11
./compiler_checkptr2.go:9:11: make([]byte, n) escapes to heap</p>

<p>äº”. æ ‡å‡†åº“
æ¯ä¸ªGoç‰ˆæœ¬ï¼Œå˜åŒ–æœ€å¤šçš„å°±æ˜¯æ ‡å‡†åº“ï¼Œè¿™é‡Œæˆ‘ä»¬æŒ‘ä¸€ä¸ªå¯èƒ½å½±å“åç»­æˆ‘ä»¬ç¼–å†™å•å…ƒæµ‹è¯•è¡Œä¸ºæ–¹å¼çš„å˜åŒ–è¯´è¯´ï¼Œé‚£å°±æ˜¯testingåŒ…çš„Tå’ŒBç±»å‹éƒ½å¢åŠ äº†è‡ªå·±çš„Cleanupæ–¹æ³•ã€‚æˆ‘ä»¬é€šè¿‡ä»£ç æ¥çœ‹ä¸€ä¸‹Cleanupæ–¹æ³•çš„ä½œç”¨ï¼š</p>

<p>// go1.14-examples/testing_cleanup_test.go
package main</p>

<p>import â€œtestingâ€</p>

<p>func TestCase1(t *testing.T) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>t.Run("A=1", func(t *testing.T) {
    t.Logf("subtest1 in testcase1")

})
t.Run("A=2", func(t *testing.T) {
    t.Logf("subtest2 in testcase1")
})
t.Cleanup(func() {
    t.Logf("cleanup1 in testcase1")
})
t.Cleanup(func() {
    t.Logf("cleanup2 in testcase1")
}) }
</code></pre></div></div>

<p>func TestCase2(t *testing.T) {
    t.Cleanup(func() {
        t.Logf(â€œcleanup1 in testcase2â€)
    })
    t.Cleanup(func() {
        t.Logf(â€œcleanup2 in testcase2â€)
    })
}
è¿è¡Œä¸Šé¢æµ‹è¯•ï¼š</p>

<p>$go test -v testing_cleanup_test.go
=== RUN   TestCase1
=== RUN   TestCase1/A=1
    TestCase1/A=1: testing_cleanup_test.go:8: subtest1 in testcase1
=== RUN   TestCase1/A=2
    TestCase1/A=2: testing_cleanup_test.go:12: subtest2 in testcase1
    TestCase1: testing_cleanup_test.go:18: cleanup2 in testcase1
    TestCase1: testing_cleanup_test.go:15: cleanup1 in testcase1
â€” PASS: TestCase1 (0.00s)
    â€” PASS: TestCase1/A=1 (0.00s)
    â€” PASS: TestCase1/A=2 (0.00s)
=== RUN   TestCase2
    TestCase2: testing_cleanup_test.go:27: cleanup2 in testcase2
    TestCase2: testing_cleanup_test.go:24: cleanup1 in testcase2
â€” PASS: TestCase2 (0.00s)
PASS
ok      command-line-arguments    0.005s
æˆ‘ä»¬çœ‹åˆ°ï¼š</p>

<p>Cleanupæ–¹æ³•è¿è¡Œäºæ‰€æœ‰æµ‹è¯•ä»¥åŠå…¶å­æµ‹è¯•å®Œæˆä¹‹åã€‚</p>

<p>Cleanupæ–¹æ³•ç±»ä¼¼äºdeferï¼Œå…ˆæ³¨å†Œçš„cleanupå‡½æ•°åæ‰§è¡Œï¼ˆæ¯”å¦‚ä¸Šé¢ä¾‹å­ä¸­å„ä¸ªcaseçš„cleanup1å’Œcleanup2ï¼‰ã€‚</p>

<p>åœ¨æ‹¥æœ‰Cleanupæ–¹æ³•å‰ï¼Œæˆ‘ä»¬ç»å¸¸åƒä¸‹é¢è¿™æ ·åšï¼š</p>

<p>// go1.14-examples/old_testing_cleanup_test.go
package main</p>

<p>import â€œtestingâ€</p>

<p>func setup(t *testing.T) func() {
    t.Logf(â€œsetup before testâ€)
    return func() {
        t.Logf(â€œteardown/cleanup after testâ€)
    }
}</p>

<p>func TestCase1(t *testing.T) {
    f := setup(t)
    defer f()
    t.Logf(â€œtest the testcaseâ€)
}
è¿è¡Œä¸Šé¢æµ‹è¯•ï¼š</p>

<p>$go test -v old_testing_cleanup_test.go
=== RUN   TestCase1
    TestCase1: old_testing_cleanup_test.go:6: setup before test
    TestCase1: old_testing_cleanup_test.go:15: test the testcase
    TestCase1: old_testing_cleanup_test.go:8: teardown/cleanup after test
â€” PASS: TestCase1 (0.00s)
PASS
ok      command-line-arguments    0.005s
æœ‰äº†Cleanupæ–¹æ³•åï¼Œæˆ‘ä»¬å°±ä¸éœ€è¦å†åƒä¸Šé¢é‚£æ ·å•ç‹¬ç¼–å†™ä¸€ä¸ªè¿”å›cleanupå‡½æ•°çš„setupå‡½æ•°äº†ã€‚</p>

<p>æ­¤æ¬¡Go 1.14è¿˜å°†å¯¹unicodeæ ‡å‡†çš„æ”¯æŒä»unicode 11 å‡çº§åˆ° unicode 12 ï¼Œå…±å¢åŠ äº†554ä¸ªæ–°å­—ç¬¦ã€‚</p>

<p>å…­. å…¶ä»–
è¶…å¼ºçš„å¯ç§»æ¤æ€§æ˜¯Goçš„ä¸€ä¸ªçŸ¥åæ ‡ç­¾ï¼Œåœ¨æ–°å¹³å°æ”¯æŒæ–¹é¢ï¼ŒGoå‘æ¥æ˜¯â€œæ€¥å…ˆé”‹â€ã€‚Go 1.14ä¸º64bit RISC-Væä¾›äº†åœ¨linuxä¸Šçš„å®éªŒæ€§æ”¯æŒ(GOOS=linux, GOARCH=riscv64)ã€‚</p>

<p>rustè¯­è¨€å·²ç»é€šè¿‡cargo-fuzzä»å·¥å…·å±‚é¢ä¸ºfuzz testæä¾›äº†åŸºç¡€æ”¯æŒã€‚Go 1.14ä¹Ÿåœ¨è¿™æ–¹é¢åšå‡ºäº†åŠªåŠ›ï¼Œå¹¶ä¸”Goå·²ç»åœ¨å‘å°†fuzz testå˜æˆGo testçš„ä¸€ç­‰å…¬æ°‘è€ŒåŠªåŠ›ã€‚</p>

<p>ä¸ƒ. å°ç»“
Go 1.14çš„è¯¦ç»†å˜æ›´è¯´æ˜åœ¨è¿™é‡Œå¯ä»¥æŸ¥çœ‹ã€‚æ•´ä¸ªç‰ˆæœ¬çš„milestoneå¯¹åº”çš„issueé›†åˆåœ¨è¿™é‡Œã€‚</p>

<p>ä¸è¿‡ç›®å‰Go 1.14åœ¨ç‰¹å®šç‰ˆæœ¬linuxå†…æ ¸ä¸Šä¼šå‡ºç°crashçš„é—®é¢˜ï¼Œå½“ç„¶è¿™ä¸ªé—®é¢˜æºäºè¿™äº›å†…æ ¸çš„ä¸€ä¸ªå·²çŸ¥bugã€‚åœ¨è¿™ä¸ªissueä¸­æœ‰å…³äºè¿™ä¸ªé—®é¢˜çš„è¯¦ç»†è¯´æ˜ï¼Œæ¶‰åŠåˆ°çš„Linuxå†…æ ¸ç‰ˆæœ¬åŒ…æ‹¬ï¼š5.2.x, 5.3.0-5.3.14, 5.4.0-5.4.1ã€‚
æœ¬ç¯‡åšå®¢æ¶‰åŠçš„ä»£ç åœ¨è¿™é‡Œå¯ä»¥ä¸‹è½½ã€‚</p>
:ET