I"¡C<p>æˆ‘ä»¬é€šè¿‡ kubectl describe [èµ„æº] å‘½ä»¤ï¼Œå¯ä»¥åœ¨çœ‹åˆ° Event è¾“å‡ºï¼Œå¹¶ä¸”ç»å¸¸ä¾èµ– event è¿›è¡Œé—®é¢˜å®šä½ï¼Œä» event ä¸­å¯ä»¥åˆ†ææ•´ä¸ª POD çš„è¿è¡Œè½¨è¿¹ï¼Œä¸ºæœåŠ¡çš„å®¢è§‚æµ‹æ€§æä¾›æ•°æ®æ¥æºï¼Œç”±æ­¤å¯è§ï¼Œevent åœ¨ Kubernetes ä¸­èµ·ç€ä¸¾è¶³è½»é‡çš„ä½œç”¨ã€‚</p>

<p>eventå±•ç¤º</p>

<p>event å¹¶ä¸åªæ˜¯ kubelet ä¸­éƒ½æœ‰çš„ï¼Œå…³äº event çš„æ“ä½œè¢«å°è£…åœ¨client-go/tools/recordåŒ…ï¼Œæˆ‘ä»¬å®Œå…¨å¯ä»¥åœ¨å†™å…¥è‡ªå®šä¹‰çš„ eventã€‚
https://gocn.vip/topics/9965
<!-- more -->
Event å®šä¹‰
å…¶å® event ä¹Ÿæ˜¯ä¸€ä¸ªèµ„æºå¯¹è±¡ï¼Œå¹¶ä¸”é€šè¿‡ apiserver å°† event å­˜å‚¨åœ¨ etcd ä¸­ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡ kubectl get event å‘½ä»¤æŸ¥çœ‹å¯¹åº”çš„ event å¯¹è±¡ã€‚</p>

<p>ä»¥ä¸‹æ˜¯ä¸€ä¸ª event çš„ yaml æ–‡ä»¶ï¼š</p>

<p>apiVersion: v1
count: 1
eventTime: null
firstTimestamp: â€œ2020-03-02T13:08:22Zâ€
involvedObject:
  apiVersion: v1
  kind: Pod
  name: example-foo-d75d8587c-xsf64
  namespace: default
  resourceVersion: â€œ429837â€
  uid: ce611c62-6c1a-4bd8-9029-136a1adf7de4
kind: Event
lastTimestamp: â€œ2020-03-02T13:08:22Zâ€
message: Pod sandbox changed, it will be killed and re-created.
metadata:
  creationTimestamp: â€œ2020-03-02T13:08:30Zâ€
  name: example-foo-d75d8587c-xsf64.15f87ea1df862b64
  namespace: default
  resourceVersion: â€œ479466â€
  selfLink: /api/v1/namespaces/default/events/example-foo-d75d8587c-xsf64.15f87ea1df862b64
  uid: 9fe6f72a-341d-4c49-960b-e185982d331a
reason: SandboxChanged
reportingComponent: â€œâ€
reportingInstance: â€œâ€
source:
  component: kubelet
  host: minikube
type: Normal</p>

<p>ä¸»è¦å­—æ®µè¯´æ˜ï¼š**</p>

<p>involvedObjectï¼š è§¦å‘ event çš„èµ„æºç±»å‹
lastTimestampï¼šæœ€åä¸€æ¬¡è§¦å‘çš„æ—¶é—´
messageï¼šäº‹ä»¶è¯´æ˜
metadata :event çš„å…ƒä¿¡æ¯ï¼Œnameï¼Œnamespace ç­‰
reasonï¼ševent çš„åŸå› 
sourceï¼šä¸ŠæŠ¥äº‹ä»¶çš„æ¥æºï¼Œæ¯”å¦‚ kubelet ä¸­çš„æŸä¸ªèŠ‚ç‚¹
type:äº‹ä»¶ç±»å‹ï¼ŒNormal æˆ– Warning
event å­—æ®µå®šä¹‰å¯ä»¥çœ‹è¿™é‡Œï¼štypes.go#L5078</p>

<p>æ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹çœ‹ï¼Œæ•´ä¸ª event æ˜¯å¦‚ä½•ä¸‹å…¥çš„ã€‚</p>

<p>å†™å…¥äº‹ä»¶
1ã€è¿™é‡Œä»¥ kubelet ä¸ºä¾‹ï¼Œçœ‹çœ‹æ˜¯å¦‚ä½•è¿›è¡Œäº‹ä»¶å†™å…¥çš„ 2ã€æ–‡ä¸­ä»£ç ä»¥ Kubernetes 1.17.3 ä¸ºä¾‹è¿›è¡Œåˆ†æ
å…ˆä»¥ä¸€å¹…å›¾æ¥çœ‹ä¸‹æ•´ä¸ªçš„å¤„ç†æµç¨‹
eventå¤„ç†è¿‡ç¨‹</p>

<p>åˆ›å»ºæ“ä½œäº‹ä»¶çš„å®¢æˆ·ç«¯ï¼š
kubelet/app/server.go#L461</p>

<p>// makeEventRecorder sets up kubeDeps.Recorder if itâ€™s nil. Itâ€™s a no-op otherwise.
func makeEventRecorder(kubeDeps *kubelet.Dependencies, nodeName types.NodeName) {
    if kubeDeps.Recorder != nil {
        return
    }
    //äº‹ä»¶å¹¿æ’­
    eventBroadcaster := record.NewBroadcaster()
    //åˆ›å»ºEventRecorder
    kubeDeps.Recorder = eventBroadcaster.NewRecorder(legacyscheme.Scheme, v1.EventSource{Component: componentKubelet, Host: string(nodeName)})
    //å‘é€eventè‡³logè¾“å‡º
    eventBroadcaster.StartLogging(klog.V(3).Infof)
    if kubeDeps.EventClient != nil {
        klog.V(4).Infof(â€œSending events to api server.â€)
        //å‘é€eventè‡³apiserver
        eventBroadcaster.StartRecordingToSink(&amp;v1core.EventSinkImpl{Interface: kubeDeps.EventClient.Events(â€œâ€)})
    } else {
        klog.Warning(â€œNo api server defined - no events will be sent to API server.â€)
    }
}
é€šè¿‡ makeEventRecorder åˆ›å»ºäº† EventRecorder å®ä¾‹ï¼Œè¿™æ˜¯ä¸€ä¸ªäº‹ä»¶å¹¿æ’­å™¨ï¼Œé€šè¿‡å®ƒæä¾›äº† StartLogging å’Œ StartRecordingToSink ä¸¤ä¸ªäº‹ä»¶å¤„ç†å‡½æ•°ï¼Œåˆ†åˆ«å°† event å‘é€ç»™ log å’Œ apiserverã€‚
NewRecorderåˆ›å»ºäº† EventRecorder çš„å®ä¾‹ï¼Œå®ƒæä¾›äº† Event ï¼ŒEventf ç­‰æ–¹æ³•ä¾›äº‹ä»¶è®°å½•ã€‚</p>

<p>EventBroadcaster
æˆ‘ä»¬æ¥çœ‹ä¸‹ EventBroadcaster æ¥å£å®šä¹‰ï¼ševent.go#L113</p>

<p>// EventBroadcaster knows how to receive events and send them to any EventSink, watcher, or log.
type EventBroadcaster interface {
    //
    StartEventWatcher(eventHandler func(*v1.Event)) watch.Interface
    StartRecordingToSink(sink EventSink) watch.Interface
    StartLogging(logf func(format string, args â€¦interface{})) watch.Interface
    NewRecorder(scheme *runtime.Scheme, source v1.EventSource) EventRecorder</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Shutdown() } å…·ä½“å®ç°æ˜¯é€šè¿‡ eventBroadcasterImpl struct æ¥å®ç°äº†å„ä¸ªæ–¹æ³•ã€‚
</code></pre></div></div>

<p>å…¶ä¸­ StartLogging å’Œ StartRecordingToSink å…¶å®å°±æ˜¯å®Œæˆäº†å¯¹äº‹ä»¶çš„æ¶ˆè´¹ï¼ŒEventRecorder å®ç°å¯¹äº‹ä»¶çš„å†™å…¥ï¼Œä¸­é—´é€šè¿‡ channel å®ç°äº†ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡å‹ã€‚</p>

<p>EventRecorder
æˆ‘ä»¬å…ˆæ¥çœ‹ä¸‹EventRecorder æ¥å£å®šä¹‰ï¼ševent.go#L88ï¼Œæä¾›äº†ä¸€ä¸‹ 4 ä¸ªæ–¹æ³•</p>

<p>// EventRecorder knows how to record events on behalf of an EventSource.
type EventRecorder interface {
    // Event constructs an event from the given information and puts it in the queue for sending.
    // â€˜objectâ€™ is the object this event is about. Event will make a referenceâ€“ or you may also
    // pass a reference to the object directly.
    // â€˜typeâ€™ of this event, and can be one of Normal, Warning. New types could be added in future
    // â€˜reasonâ€™ is the reason this event is generated. â€˜reasonâ€™ should be short and unique; it
    // should be in UpperCamelCase format (starting with a capital letter). â€œreasonâ€ will be used
    // to automate handling of events, so imagine people writing switch statements to handle them.
    // You want to make that easy.
    // â€˜messageâ€™ is intended to be human readable.
    //
    // The resulting event will be created in the same namespace as the reference object.
    Event(object runtime.Object, eventtype, reason, message string)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Eventf is just like Event, but with Sprintf for the message field.
Eventf(object runtime.Object, eventtype, reason, messageFmt string, args ...interface{})

// PastEventf is just like Eventf, but with an option to specify the event's 'timestamp' field.
PastEventf(object runtime.Object, timestamp metav1.Time, eventtype, reason, messageFmt string, args ...interface{})

// AnnotatedEventf is just like eventf, but with annotations attached
AnnotatedEventf(object runtime.Object, annotations map[string]string, eventtype, reason, messageFmt string, args ...interface{}) }
</code></pre></div></div>

<p>ä¸»è¦å‚æ•°è¯´æ˜ï¼š</p>

<p>object å¯¹åº” event èµ„æºå®šä¹‰ä¸­çš„ involvedObject
eventtype å¯¹åº” event èµ„æºå®šä¹‰ä¸­çš„ typeï¼Œå¯é€‰ Normalï¼ŒWarning.
reason ï¼šäº‹ä»¶åŸå› 
message ï¼šäº‹ä»¶æ¶ˆæ¯
æˆ‘ä»¬æ¥çœ‹ä¸‹å½“æˆ‘ä»¬è°ƒç”¨ Event(object runtime.Object, eventtype, reason, message string) çš„æ•´ä¸ªè¿‡ç¨‹ã€‚
å‘ç°æœ€ç»ˆéƒ½è°ƒç”¨åˆ°äº† generateEvent æ–¹æ³•ï¼ševent.go#L316</p>

<p>func (recorder *recorderImpl) generateEvent(object runtime.Object, annotations map[string]string, timestamp metav1.Time, eventtype, reason, message string) {
    â€¦..
    event := recorder.makeEvent(ref, annotations, eventtype, reason, message)
    event.Source = recorder.source
    go func() {
        // NOTE: events should be a non-blocking operation
        defer utilruntime.HandleCrash()
        recorder.Action(watch.Added, event)
    }()
}
æœ€ç»ˆäº‹ä»¶åœ¨ä¸€ä¸ª goroutine ä¸­é€šè¿‡è°ƒç”¨ recorder.Action è¿›å…¥å¤„ç†ï¼Œè¿™é‡Œä¿è¯äº†æ¯æ¬¡è°ƒç”¨ event æ–¹æ³•éƒ½æ˜¯éé˜»å¡çš„ã€‚
å…¶ä¸­ makeEvent çš„ä½œç”¨ä¸»è¦æ˜¯æ„é€ äº†ä¸€ä¸ª event å¯¹è±¡ï¼Œäº‹ä»¶ name æ ¹æ® InvolvedObject ä¸­çš„ name åŠ ä¸Šæ—¶é—´æˆ³ç”Ÿæˆï¼š</p>

<p>æ³¨æ„çœ‹ï¼šå¯¹äºä¸€äº›é namespace èµ„æºäº§ç”Ÿçš„ eventï¼Œevent çš„ namespace æ˜¯ default
func (recorder *recorderImpl) makeEvent(ref *v1.ObjectReference, annotations map[string]string, eventtype, reason, message string) *v1.Event {
    t := metav1.Time{Time: recorder.clock.Now()}
    namespace := ref.Namespace
    if namespace == â€œâ€ {
        namespace = metav1.NamespaceDefault
    }
    return &amp;v1.Event{
        ObjectMeta: metav1.ObjectMeta{
            Name:        fmt.Sprintf(â€œ%v.%xâ€, ref.Name, t.UnixNano()),
            Namespace:   namespace,
            Annotations: annotations,
        },
        InvolvedObject: *ref,
        Reason:         reason,
        Message:        message,
        FirstTimestamp: t,
        LastTimestamp:  t,
        Count:          1,
        Type:           eventtype,
    }
}
è¿›ä¸€æ­¥è·Ÿè¸ªActionæ–¹æ³•ï¼Œapimachinery/blob/master/pkg/watch/mux.go#L188:23</p>

<p>// Action distributes the given event among all watchers.
func (m *Broadcaster) Action(action EventType, obj runtime.Object) {
    m.incoming &lt;- Event{action, obj}
}
å°† event å†™å…¥åˆ°äº†ä¸€ä¸ª channel é‡Œé¢ã€‚
æ³¨æ„ï¼š
è¿™ä¸ª Action æ–¹å¼æ˜¯apimachineryåŒ…ä¸­çš„æ–¹æ³•ï¼Œå› ä¸ºå®ç°çš„ sturt recorderImpl
å°† *watch.Broadcaster ä½œä¸ºä¸€ä¸ªåŒ¿å structï¼Œå¹¶ä¸”åœ¨ NewRecorder è¿›è¡Œ Broadcaster èµ‹å€¼ï¼Œè¿™ä¸ªBroadcasterå…¶å®å°±æ˜¯ eventBroadcasterImpl ä¸­çš„Broadcasterã€‚</p>

<p>åˆ°æ­¤ï¼ŒåŸºæœ¬æ¸…æ¥šäº† event æœ€ç»ˆè¢«å†™å…¥åˆ°äº† Broadcaster ä¸­çš„ incoming channel ä¸­ï¼Œä¸‹é¢çœ‹ä¸‹æ˜¯æ€ä¹ˆè¿›è¡Œæ¶ˆè´¹çš„ã€‚</p>

<p>æ¶ˆè´¹äº‹ä»¶
åœ¨ makeEventRecorder è°ƒç”¨çš„ StartLogging å’Œ StartRecordingToSink å…¶å®å°±æ˜¯å®Œæˆäº†å¯¹äº‹ä»¶çš„æ¶ˆè´¹ã€‚</p>

<p>StartLoggingç›´æ¥å°† event è¾“å‡ºåˆ°æ—¥å¿—
StartRecordingToSinkå°†äº‹ä»¶å†™å…¥åˆ° apiserver
ä¸¤ä¸ªæ–¹æ³•å†…éƒ¨éƒ½è°ƒç”¨äº† StartEventWatcher æ–¹æ³•ï¼Œå¹¶ä¸”ä¼ å…¥ä¸€ä¸ª eventHandler æ–¹æ³•å¯¹ event è¿›è¡Œå¤„ç†</p>

<p>func (e <em>eventBroadcasterImpl) StartEventWatcher(eventHandler func(</em>v1.Event)) watch.Interface {
    watcher := e.Watch()
    go func() {
        defer utilruntime.HandleCrash()
        for watchEvent := range watcher.ResultChan() {
            event, ok := watchEvent.Object.(*v1.Event)
            if !ok {
                // This is all local, so thereâ€™s no reason this should
                // ever happen.
                continue
            }
            eventHandler(event)
        }
    }()
    return watcher
}
å…¶ä¸­ watcher.ResultChan æ–¹æ³•å°±æ‹¿åˆ°äº†äº‹ä»¶ï¼Œè¿™é‡Œæ˜¯åœ¨ä¸€ä¸ª goroutine ä¸­é€šè¿‡func (m *Broadcaster) loop() ==&gt;func (m *Broadcaster) distribute(event Event) æ–¹æ³•è°ƒç”¨å°† event åˆå†™å…¥äº†broadcasterWatcher.result</p>

<p>ä¸»è¦çœ‹ä¸‹ StartRecordingToSink æä¾›çš„çš„eventHandlerï¼Œ recordToSink æ–¹æ³•ï¼š</p>

<p>func recordToSink(sink EventSink, event *v1.Event, eventCorrelator *EventCorrelator, sleepDuration time.Duration) {
    // Make a copy before modification, because there could be multiple listeners.
    // Events are safe to copy like this.
    eventCopy := *event
    event = &amp;eventCopy
    result, err := eventCorrelator.EventCorrelate(event)
    if err != nil {
        utilruntime.HandleError(err)
    }
    if result.Skip {
        return
    }
    tries := 0
    for {
        if recordEvent(sink, result.Event, result.Patch, result.Event.Count &gt; 1, eventCorrelator) {
            break
        }
        tries++
        if tries &gt;= maxTriesPerEvent {
            klog.Errorf(â€œUnable to write event â€˜%#vâ€™ (retry limit exceeded!)â€, event)
            break
        }
        // Randomize the first sleep so that various clients wonâ€™t all be
        // synced up if the master goes down.
        // ç¬¬ä¸€æ¬¡é‡è¯•å¢åŠ éšæœºæ€§ï¼Œé˜²æ­¢ apiserver é‡å¯çš„æ—¶å€™æ‰€æœ‰çš„äº‹ä»¶éƒ½åœ¨åŒä¸€æ—¶é—´å‘é€äº‹ä»¶
        if tries == 1 {
            time.Sleep(time.Duration(float64(sleepDuration) * rand.Float64()))
        } else {
            time.Sleep(sleepDuration)
        }
    }
}
å…¶ä¸­ event è¢«ç»è¿‡äº†ä¸€ä¸ª eventCorrelator.EventCorrelate(event) æ–¹æ³•åšé¢„å¤„ç†ï¼Œä¸»è¦æ˜¯èšåˆç›¸åŒçš„äº‹ä»¶ï¼ˆé¿å…äº§ç”Ÿçš„äº‹ä»¶è¿‡å¤šï¼Œå¢åŠ  etcd å’Œ apiserver çš„å‹åŠ›ï¼Œä¹Ÿä¼šå¯¼è‡´æŸ¥çœ‹ pod äº‹ä»¶å¾ˆä¸æ¸…æ™°ï¼‰</p>

<p>ä¸‹é¢ä¸€ä¸ª for å¾ªç¯å°±æ˜¯åœ¨è¿›è¡Œé‡è¯•ï¼Œæœ€å¤§é‡è¯•æ¬¡æ•°æ˜¯ 12 æ¬¡ï¼Œè°ƒç”¨ recordEvent æ–¹æ³•æ‰çœŸæ­£å°† event å†™å…¥åˆ°äº† apiserverã€‚</p>

<p>äº‹ä»¶å¤„ç†
æˆ‘ä»¬æ¥çœ‹ä¸‹EventCorrelateæ–¹æ³•ï¼š</p>

<p>// EventCorrelate filters, aggregates, counts, and de-duplicates all incoming events
func (c <em>EventCorrelator) EventCorrelate(newEvent *v1.Event) (</em>EventCorrelateResult, error) {
    if newEvent == nil {
        return nil, fmt.Errorf(â€œevent is nilâ€)
    }
    aggregateEvent, ckey := c.aggregator.EventAggregate(newEvent)
    observedEvent, patch, err := c.logger.eventObserve(aggregateEvent, ckey)
    if c.filterFunc(observedEvent) {
        return &amp;EventCorrelateResult{Skip: true}, nil
    }
    return &amp;EventCorrelateResult{Event: observedEvent, Patch: patch}, err
}</p>

<p>åˆ†åˆ«è°ƒç”¨äº† aggregator.EventAggregate ï¼Œlogger.eventObserve ï¼Œ filterFunc ä¸‰ä¸ªæ–¹æ³•ï¼Œåˆ†åˆ«ä½œç”¨æ˜¯ï¼š</p>

<p>aggregator.EventAggregateï¼šèšåˆ eventï¼Œå¦‚æœåœ¨æœ€è¿‘ 10 åˆ†é’Ÿå‡ºç°è¿‡ 10 ä¸ªç›¸ä¼¼çš„äº‹ä»¶ï¼ˆé™¤äº† message å’Œæ—¶é—´æˆ³ä¹‹å¤–å…¶ä»–å…³é”®å­—æ®µéƒ½ç›¸åŒçš„äº‹ä»¶ï¼‰ï¼Œaggregator ä¼šæŠŠå®ƒä»¬çš„ message è®¾ç½®ä¸º (combined from similar events)+event.Message
logger.eventObserveï¼šå®ƒä¼šæŠŠç›¸åŒçš„äº‹ä»¶ä»¥åŠåŒ…å« aggregator è¢«èšåˆäº†çš„ç›¸ä¼¼çš„äº‹ä»¶ï¼Œé€šè¿‡å¢åŠ  Count å­—æ®µæ¥è®°å½•äº‹ä»¶å‘ç”Ÿäº†å¤šå°‘æ¬¡ã€‚
filterFunc: è¿™é‡Œå®ç°äº†ä¸€ä¸ªåŸºäºä»¤ç‰Œæ¡¶çš„é™æµç®—æ³•ï¼Œå¦‚æœè¶…è¿‡è®¾å®šçš„é€Ÿç‡åˆ™ä¸¢å¼ƒï¼Œä¿è¯äº† apiserver çš„å®‰å…¨ã€‚
æˆ‘ä»¬ä¸»è¦æ¥çœ‹ä¸‹aggregator.EventAggregateæ–¹æ³•ï¼š</p>

<p>func (e <em>EventAggregator) EventAggregate(newEvent *v1.Event) (</em>v1.Event, string) {
    now := metav1.NewTime(e.clock.Now())
    var record aggregateRecord
    // eventKey is the full cache key for this event
    //eventKey æ˜¯å°†é™¤äº†æ—¶é—´æˆ³å¤–æ‰€æœ‰å­—æ®µç»“åˆåœ¨ä¸€èµ·
    eventKey := getEventKey(newEvent)
    // aggregateKey is for the aggregate event, if one is needed.
    //aggregateKey æ˜¯é™¤äº†messageå’Œæ—¶é—´æˆ³å¤–çš„å­—æ®µç»“åˆåœ¨ä¸€èµ·ï¼ŒlocalKey æ˜¯message
    aggregateKey, localKey := e.keyFunc(newEvent)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Do we have a record of similar events in our cache?
e.Lock()
defer e.Unlock()
//ä»cacheä¸­æ ¹æ®aggregateKeyæŸ¥è¯¢æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœæ˜¯ç›¸åŒæˆ–è€…ç›¸ç±»ä¼¼çš„äº‹ä»¶ä¼šè¢«æ”¾å…¥cacheä¸­
value, found := e.cache.Get(aggregateKey)
if found {
    record = value.(aggregateRecord)
}

//åˆ¤æ–­ä¸Šæ¬¡äº‹ä»¶äº§ç”Ÿçš„æ—¶é—´æ˜¯å¦è¶…è¿‡10åˆ†é’Ÿï¼Œå¦‚ä½•æ“ä½œåˆ™é‡æ–°ç”Ÿæˆä¸€ä¸ªlocalKeysé›†åˆï¼ˆé›†åˆä¸­å­˜æ”¾messageï¼‰
maxInterval := time.Duration(e.maxIntervalInSeconds) * time.Second
interval := now.Time.Sub(record.lastTimestamp.Time)
if interval &gt; maxInterval {
    record = aggregateRecord{localKeys: sets.NewString()}
}

// Write the new event into the aggregation record and put it on the cache
//å°†locakKeyä¹Ÿå°±æ˜¯messageæ”¾å…¥é›†åˆä¸­ï¼Œå¦‚æœmessageç›¸åŒå°±æ˜¯è¦†ç›–äº†
record.localKeys.Insert(localKey)
record.lastTimestamp = now
e.cache.Add(aggregateKey, record)

// If we are not yet over the threshold for unique events, don't correlate them
//åˆ¤æ–­localKeysé›†åˆä¸­å­˜æ”¾çš„ç±»ä¼¼äº‹ä»¶æ˜¯å¦è¶…è¿‡10ä¸ªï¼Œ
if uint(record.localKeys.Len()) &lt; e.maxEvents {
    return newEvent, eventKey
}

// do not grow our local key set any larger than max
record.localKeys.PopAny()

// create a new aggregate event, and return the aggregateKey as the cache key
// (so that it can be overwritten.)
eventCopy := &amp;v1.Event{
    ObjectMeta: metav1.ObjectMeta{
        Name:      fmt.Sprintf("%v.%x", newEvent.InvolvedObject.Name, now.UnixNano()),
        Namespace: newEvent.Namespace,
    },
    Count:          1,
    FirstTimestamp: now,
    InvolvedObject: newEvent.InvolvedObject,
    LastTimestamp:  now,
    //è¿™é‡Œä¼šå¯¹messageåŠ ä¸ªå‰ç¼€ï¼š(combined from similar events):
    Message:        e.messageFunc(newEvent),
    Type:           newEvent.Type,
    Reason:         newEvent.Reason,
    Source:         newEvent.Source,
}
return eventCopy, aggregateKey } aggregator.EventAggregateæ–¹æ³•ä¸­å…¶å®å°±æ˜¯åˆ¤æ–­äº†é€šè¿‡ cache å’Œ localKeys åˆ¤æ–­äº‹ä»¶æ˜¯å¦ç›¸ä¼¼ï¼Œå¦‚æœæœ€è¿‘ 10 åˆ†é’Ÿå‡ºç°è¿‡ 10 ä¸ªç›¸ä¼¼çš„äº‹ä»¶å°±åˆå¹¶å¹¶åŠ ä¸Šå‰ç¼€ï¼Œåç»­é€šè¿‡logger.eventObserveæ–¹æ³•è¿›è¡Œ count ç´¯åŠ ï¼Œå¦‚æœ message ä¹Ÿç›¸åŒï¼Œè‚¯å®šå°±æ˜¯ç›´æ¥ count++ã€‚
</code></pre></div></div>

<p>æ€»ç»“
å¥½äº†ï¼Œevent å¤„ç†çš„æ•´ä¸ªæµç¨‹åŸºæœ¬å°±æ˜¯è¿™æ ·ï¼Œæˆ‘ä»¬å¯ä»¥æ¦‚æ‹¬ä¸€ä¸‹ï¼Œå¯ä»¥ç»“åˆæ–‡ä¸­çš„å›¾å¯¹æ¯”ä¸€èµ·çœ‹ä¸‹ï¼š</p>

<p>åˆ›å»º EventRecorder å¯¹è±¡ï¼Œé€šè¿‡å…¶æä¾›çš„ Event ç­‰æ–¹æ³•ï¼Œåˆ›å»ºå¥½ event å¯¹è±¡
å°†åˆ›å»ºå‡ºæ¥çš„å¯¹è±¡å‘é€ç»™ EventBroadcaster ä¸­çš„ channel ä¸­
EventBroadcaster é€šè¿‡åå°è¿è¡Œçš„ goroutineï¼Œä»ç®¡é“ä¸­å–å‡ºäº‹ä»¶ï¼Œå¹¶å¹¿æ’­ç»™æå‰æ³¨å†Œå¥½çš„ handler å¤„ç†
å½“è¾“å‡º log çš„ handler æ”¶åˆ°äº‹ä»¶å°±ç›´æ¥æ‰“å°äº‹ä»¶
å½“ EventSink handler æ”¶åˆ°å¤„ç†äº‹ä»¶å°±é€šè¿‡é¢„å¤„ç†ä¹‹åå°†äº‹ä»¶å‘é€ç»™ apiserver
å…¶ä¸­é¢„å¤„ç†åŒ…å«ä¸‰ä¸ªåŠ¨ä½œï¼Œ1ã€é™æµ 2ã€èšåˆ 3ã€è®¡æ•°
apiserver æ”¶åˆ°äº‹ä»¶å¤„ç†ä¹‹åå°±å­˜å‚¨åœ¨ etcd ä¸­
å›é¡¾ event çš„æ•´ä¸ªæµç¨‹ï¼Œå¯ä»¥çœ‹åˆ° event å¹¶ä¸æ˜¯ä¿è¯ 100% äº‹ä»¶å†™å…¥ï¼ˆä»é¢„å¤„ç†çš„è¿‡ç¨‹æ¥çœ‹ï¼‰ï¼Œè¿™æ ·åšæ˜¯ä¸ºäº†åç«¯æœåŠ¡ etcd çš„å¯ç”¨æ€§ï¼Œå› ä¸º event äº‹ä»¶åœ¨æ•´ä¸ªé›†ç¾¤ä¸­äº§ç”Ÿæ˜¯éå¸¸é¢‘ç¹çš„ï¼Œå°¤å…¶åœ¨æœåŠ¡ä¸ç¨³å®šçš„æ—¶å€™ï¼Œè€Œç›¸æ¯” Deployment,Pod ç­‰å…¶ä»–èµ„æºï¼Œåˆæ²¡é‚£ä¹ˆçš„é‡è¦ã€‚æ‰€ä»¥è¿™é‡Œåšäº†ä¸ªå–èˆã€‚</p>

<p>å‚è€ƒæ–‡æ¡£ï¼š</p>

<p>https://cizixs.com/2017/06/22/kubelet-source-code-analysis-part4-event/</p>
:ET