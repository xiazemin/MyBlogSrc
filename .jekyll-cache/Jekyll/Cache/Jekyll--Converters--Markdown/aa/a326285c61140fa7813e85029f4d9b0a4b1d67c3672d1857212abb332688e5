I"Ÿ<p>éœ€è¦ä½¿ç”¨Go IDçš„åœºæ™¯ï¼Œ æ¯”å¦‚åœ¨å¤šgoroutineé•¿æ—¶é—´è¿è¡Œä»»åŠ¡çš„æ—¶å€™ï¼Œæˆ‘ä»¬é€šè¿‡æ—¥å¿—æ¥è·Ÿè¸ªä»»åŠ¡çš„æ‰§è¡Œæƒ…å†µï¼Œå¯ä»¥é€šè¿‡go idæ¥å¤§è‡´åœ°è·Ÿè¸ªç¨‹åºå¹¶å‘æ‰§è¡Œçš„æ—¶å€™çš„çŠ¶å†µã€‚</p>

<p>æ–¹æ³•æœ‰ä¸‰ç§ï¼š
é€šè¿‡Stackä¿¡æ¯è§£æå‡ºID   goid.ExtractGID(buf[:runtime.Stack(buf[:], false)])
é€šè¿‡æ±‡ç¼–è·å–runtimeÂ·getgæ–¹æ³•çš„è°ƒç”¨ç»“æœ
ç›´æ¥ä¿®æ”¹è¿è¡Œæ—¶çš„ä»£ç ï¼Œexportä¸€ä¸ªå¯ä»¥å¤–éƒ¨è°ƒç”¨çš„GoID()æ–¹æ³•
<!-- more -->
 #1æ¯”è¾ƒæ…¢ï¼Œ #2å› ä¸ºæ˜¯hackçš„æ–¹å¼(Go teamå¹¶ä¸æƒ³æš´éœ²go idçš„ä¿¡æ¯), é’ˆå¯¹ä¸åŒçš„Goç‰ˆæœ¬ä¸­éœ€è¦ç‰¹æ®Šçš„hackæ‰‹æ®µï¼Œ #3éœ€è¦å®šåˆ¶Goè¿è¡Œæ—¶ï¼Œä¸é€šç”¨ã€‚å½“æ—¶çš„petermattis/goidæä¾›äº† #2 çš„æ–¹æ³•ï¼Œ ä½†æ˜¯åªèƒ½åœ¨ go 1.3ä¸­æ‰èµ·ä½œç”¨ï¼Œæ‰€ä»¥åªèƒ½é€‰æ‹©#1çš„æ–¹å¼è·å–go idã€‚</p>

<p>ä¾ç…§Goä»£ç ä¸­çš„æ–‡æ¡£HACKING, goè¿è¡Œæ—¶ä¸­å®ç°äº†ä¸€ä¸ªgetg()æ–¹æ³•ï¼Œå¯ä»¥è·å–å½“å‰çš„goroutineï¼š</p>

<p>getg() alone returns the current g</p>

<p>å½“ç„¶è¿™ä¸ªæ–¹æ³•æ˜¯å†…éƒ¨æ–¹æ³•ï¼Œä¸æ˜¯exported,ä¸èƒ½è¢«å¤–éƒ¨çš„è°ƒç”¨ï¼Œè€Œä¸”è¿”å›çš„æ•°æ®ç»“æ„ä¹Ÿæ˜¯æœªexportedçš„ã€‚å¦‚æœæœ‰åŠæ³•æš´éœ²å‡ºè¿™ä¸ªæ–¹æ³•ï¼Œé—®é¢˜å°±è§£å†³äº†ã€‚</p>

<p>petermattis/goid æ¨¡ä»¿runtime.getgæš´éœ²å‡ºä¸€ä¸ªgetgçš„æ–¹æ³•
// +build amd64 amd64p32
// +build go1.5
#include â€œtextflag.hâ€
// func getg() uintptr
TEXT Â·getg(SB),NOSPLIT,$0-8
	MOVQ (TLS), BX
	MOVQ BX, ret+0(FP)
	RET
ä¸Šé¢çš„ä»£ç å®é™…æ˜¯å°†å½“å‰çš„goroutineçš„ç»“æ„ä½“çš„æŒ‡é’ˆ(TLS)è¿”å›ã€‚
TLS å…¶å®æ˜¯çº¿ç¨‹æœ¬åœ°å­˜å‚¨ ï¼ˆThread Local Storage ï¼‰çš„ç¼©å†™ã€‚è¿™ä¸ªæŠ€æœ¯åœ¨å¾ˆå¤šç¼–ç¨‹è¯­è¨€ä¸­éƒ½æœ‰ç”¨åˆ°
åœ¨ Go è¯­è¨€ä¸­ï¼ŒTLS å­˜å‚¨äº†ä¸€ä¸ª G ç»“æ„ä½“çš„æŒ‡é’ˆã€‚è¿™ä¸ªæŒ‡é’ˆæ‰€æŒ‡å‘çš„ç»“æ„ä½“åŒ…æ‹¬ Go ä¾‹ç¨‹çš„å†…éƒ¨ç»†èŠ‚</p>

<p>å› æ­¤ï¼Œå½“åœ¨ä¸åŒçš„ä¾‹ç¨‹ä¸­è®¿é—®è¯¥å˜é‡æ—¶ï¼Œå®é™…è®¿é—®çš„æ˜¯è¯¥ä¾‹ç¨‹ç›¸åº”çš„å˜é‡æ‰€æŒ‡å‘çš„ç»“æ„ä½“ã€‚é“¾æ¥å™¨çŸ¥é“è¿™ä¸ªå˜é‡æ‰€åœ¨çš„ä½ç½®ï¼Œå‰é¢çš„æŒ‡ä»¤ä¸­ç§»åŠ¨åˆ° CX å¯„å­˜å™¨çš„å°±æ˜¯è¿™ä¸ªå˜é‡ã€‚å¯¹äº AMD64ï¼ŒTLS æ˜¯ç”¨ FS å¯„å­˜å™¨æ¥å®ç°çš„ï¼Œ æ‰€åœ¨æˆ‘ä»¬å‰é¢çœ‹åˆ°çš„å‘½ä»¤å®é™…ä¸Šå¯ä»¥ç¿»è¯‘ä¸º MOVQ FS, CXã€‚</p>

<p>ä¸åŒçš„Goç‰ˆæœ¬è·å–çš„æ•°æ®ç»“æ„å¯èƒ½æ˜¯ä¸åŒçš„ï¼Œæ‰€ä»¥petermattis/goidé’ˆå¯¹1.5ã€1.6ã€1.9æœ‰å˜åŠ¨çš„ç‰ˆæœ¬å®šåˆ¶äº†ä¸åŒçš„æ•°æ®ç»“æ„ï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€è¦å¾—åˆ°goroutineçš„ID,æ‰€ä»¥åªéœ€å®ç°ï¼š
func Get() int64 {
	gg := (*g)(unsafe.Pointer(getg()))
	return gg.goid
}</p>

<p>æ¯”å¦‚æˆ‘ä»¬å¯ä»¥æ‰©å±•ä¸€ä¸‹ï¼Œå¾—åˆ°å½“å‰å“ªä¸ªmæ­£åœ¨è¿è¡Œï¼Œç”šè‡³å¯ä»¥å¾—åˆ°å½“å‰çš„çº¿ç¨‹çš„ä¿¡æ¯ï¼š
func GetM() int32 {
	gg := (<em>g)(unsafe.Pointer(getg()))
	m := (</em>m)(unsafe.Pointer(gg.m))
	return m.id
}
sigsetåœ¨ä¸åŒçš„å¹³å°çš„å¤§å°æ˜¯ä¸ä¸€æ ·çš„ï¼Œå¯ä»¥å‚è€ƒos_*.goä¸­å„å¹³å°çš„å®šä¹‰ã€‚ä¸Šé¢æ˜¯å¾—åˆ°mçš„ID, æ›´å…¨çš„mçš„ç»“æ„å®šä¹‰æµ·åŒ…æ‹¬threadç­‰ä¿¡æ¯ã€‚</p>

<p>é¿å…å¼€å‘è€…æ»¥ç”¨goroutine idå®ç°goroutine local storage (ç±»ä¼¼javaçš„â€thread-localâ€ storage)ï¼Œ å› ä¸ºgoroutine local storageå¾ˆéš¾è¿›è¡Œåƒåœ¾å›æ”¶ã€‚å› æ­¤å°½ç®¡ä»¥å‰æš´éœ²å‡ºäº†ç›¸åº”çš„æ–¹æ³•ï¼Œç°åœ¨å·²ç»æŠŠå®ƒéšè—äº†ã€‚</p>

<p>func GoID() int {
	var buf [64]byte
	n := runtime.Stack(buf[:], false)
	idField := strings.Fields(strings.TrimPrefix(string(buf[:n]), â€œgoroutine â€œ))[0]
	id, err := strconv.Atoi(idField)
	if err != nil {
		panic(fmt.Sprintf(â€œcannot get goroutine id: %vâ€, err))
	}
	return id
}</p>

<p>å®ƒåˆ©ç”¨runtime.Stackçš„å †æ ˆä¿¡æ¯ã€‚runtime.Stack(buf []byte, all bool) intä¼šå°†å½“å‰çš„å †æ ˆä¿¡æ¯å†™å…¥åˆ°ä¸€ä¸ªsliceä¸­ï¼Œå †æ ˆçš„ç¬¬ä¸€è¡Œä¸ºgoroutine #### [â€¦,å…¶ä¸­####å°±æ˜¯å½“å‰çš„gororutine id,é€šè¿‡è¿™ä¸ªèŠ±æ‹›å°±å®ç°GoIDæ–¹æ³•äº†ã€‚</p>

<p>ä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè·å–å †æ ˆä¿¡æ¯ä¼šå½±å“æ€§èƒ½ï¼Œæ‰€ä»¥å»ºè®®ä½ åœ¨debugçš„æ—¶å€™æ‰ç”¨å®ƒã€‚</p>

<p>ä¸åº”è¯¥æš´éœ²goidï¼ˆfaq: document why there is no way to get a goroutine IDï¼‰ï¼Œä¸»è¦æœ‰ä»¥ä¸‹å‡ ç‚¹ç†ç”±ï¼š</p>

<p>goroutineè®¾è®¡ç†å¿µæ˜¯è½»é‡ï¼Œé¼“åŠ±å¼€å‘è€…ä½¿ç”¨å¤šgoroutineè¿›è¡Œå¼€å‘ï¼Œä¸å¸Œæœ›å¼€å‘è€…é€šè¿‡goidåšgoroutine local storageæˆ–thread local storageï¼ˆTLSï¼‰çš„äº‹æƒ…ï¼›
Golangå¼€å‘è€…Bradè®¤ä¸ºTLSåœ¨C/C++å®è·µä¸­ä¹Ÿé—®é¢˜å¤šå¤šï¼Œæ¯”å¦‚ä¸€äº›ä½¿ç”¨TLSçš„åº“ï¼ŒthreadçŠ¶æ€éå¸¸å®¹æ˜“è¢«éæœŸæœ›çº¿ç¨‹ä¿®æ”¹ï¼Œå¯¼è‡´crash.
goroutineå¹¶ä¸ç­‰ä»·äºthread, å¼€å‘è€…å¯ä»¥é€šè¿‡syscallè·å–thread idï¼Œå› æ­¤æ ¹æœ¬ä¸éœ€è¦æš´éœ²goid.</p>

<p>é€šè¿‡stackä¿¡æ¯è·å–goroutine id.
é€šè¿‡ä¿®æ”¹æºä»£ç è·å–goroutine id.
é€šè¿‡CGoè·å–goroutine id.
é€šè¿‡æ±‡ç¼–è·å–goroutine id.
é€šè¿‡æ±‡ç¼–è·å–ä¼ªgoroutine id.</p>

<p>é€šè¿‡CGoè·å–goroutine id
é‚£ä¹ˆæœ‰æ²¡æœ‰æ€§èƒ½å¥½ï¼ŒåŒæ—¶ä¸å½±å“ç§»æ¤æ€§ï¼Œä¸”ç»´æŠ¤æˆæœ¬ä½çš„æ–¹æ³•å‘¢ï¼Ÿé‚£å°±æ˜¯æ¥è‡ªDave Cheneyçš„CGoæ–¹å¼ï¼š</p>

<p>æ–‡ä»¶id.cï¼š
#include â€œruntime.hâ€
int64 Â·Id(void) {
    return g-&gt;goid;
}</p>

<p>æ–‡ä»¶id.go
package id
func Id() int64</p>

<p>runtime.getg()
è¿™ä¸ªå‡½æ•°ç”¨äºè·å–å½“å‰æ­£åœ¨æ‰§è¡Œçš„ goroutine çš„ä¿¡æ¯ï¼ˆ/usr/local/go/src/runtime/stubs.go#21ï¼‰ã€‚
// getg returns the pointer to the current g.
// The compiler rewrites calls to this function into instructions
// that fetch the g directly (from TLS or from the dedicated register).
func getg() *g</p>

<p>ä»æ³¨é‡Šé‡Œå¯ä»¥çœ‹åˆ°ï¼Œè¿™ä¸ªå‡½æ•°å¹¶ä¸æ˜¯åœ¨ runtime é‡Œå®ç°çš„ï¼Œè€Œæ˜¯ç”±ç¼–è¯‘å™¨è´Ÿè´£å†™å…¥å‡½æ•°ä½“ã€‚è€Œä¸”å†™æ˜äº†æ˜¯æ¥è‡ªäº TLSï¼ˆThread-local Storageï¼‰æˆ–è€…æŒ‡å®šçš„å¯„å­˜å™¨çš„ã€‚</p>

<p>ç„¶ååœ¨ç¼–è¯‘å™¨ä¸­æœç´¢ getg ç›¸å…³çš„å†…å®¹ï¼Œå¯ä»¥åœ¨ ssa.go ä¸­å‘ç°ä¸ä¹‹ç›¸å…³çš„è¯´æ˜ï¼ˆcmd/compile/internal/amd64/ssa.go#712ï¼‰ï¼š
case ssa.OpAMD64LoweredGetG:
    r := v.Reg()
    // See the comments in cmd/internal/obj/x86/obj6.go
    // near CanUse1InsnTLS for a detailed explanation of these instructions.
    if x86.CanUse1InsnTLS(gc.Ctxt) {
        // MOVQ (TLS), r
        â€¦
    } else {
        // MOVQ TLS, r
        // MOVQ (r)(TLS*1), r
        â€¦
    }</p>
:ET