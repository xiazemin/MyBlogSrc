I"¤€<ol>
  <li>accept åªæ˜¯ä»å…¨è¿æ¥é˜Ÿåˆ—æ‹¿å‡ºä¸€ä¸ªå·²ç»å»ºç«‹å¥½çš„socketï¼Œå¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œåˆ™é˜»å¡ã€‚</li>
</ol>

<p>ã€€ã€€ã€€ã€€2. connect è¿‡ç¨‹ä¸ºä¸‰æ¬¡æ¡æ‰‹è¿‡ç¨‹ï¼Œæ˜¯ç”±å†…æ ¸å®Œæˆçš„ï¼Œconnectåªæ˜¯é€šçŸ¥å†…æ ¸ï¼šæˆ‘è¦å‘èµ·è¿æ¥äº†ã€‚æ‰€ä»¥ä¸‹å›¾ä¸­çš„connectæŒ‡å‘çš„æ˜¯æœåŠ¡å™¨çš„listenå‡½æ•°å’Œacceptå‡½æ•°ä¹‹é—´</p>

<p>ã€€ã€€ã€€ã€€3. listen å‡½æ•°ä¸é˜»å¡ï¼Œä»…ä»…å‘ŠçŸ¥å†…æ ¸ï¼Œå°†socketå˜æˆè¢«åŠ¨è¿æ¥çš„ç›‘å¬å¥—æ¥å­—ï¼Œå¹¶åœ¨listenä¹‹å‰å¯ä»¥è¿›è¡Œä¸€äº›socketé€‰é¡¹å‚æ•°çš„è®¾ç½®ï¼Œä¾‹å¦‚æ˜¯å¦é‡ç”¨ç­‰ã€‚</p>

<p>ã€€ã€€ã€€ã€€4. backlogå‚æ•°è¡¨ç¤ºè¿æ¥é˜Ÿåˆ—çš„é•¿åº¦, åœ¨Linux 2.2ç‰ˆæœ¬ ä»¥åï¼Œè¯¥å‚æ•°ä»…è¡¨ç¤ºå·²å®Œæˆé˜Ÿåˆ—çš„å¤§å°ï¼Œä¸åŒ…å«æœªå®Œæˆè¿æ¥çš„å¤§å°ï¼Œç”±ç³»ç»Ÿå‚æ•° net/ipv4/tcp_max_syn_backlogé™åˆ¶è¯¥é˜Ÿåˆ—é•¿åº¦çš„æœ€å¤§å€¼ï¼Œå› æ­¤æ–¹æ¡ˆæ˜¯ï¼šé€šè¿‡ç³»ç»Ÿå‚æ•°è®¾ç½®åŠè¿æ¥é˜Ÿåˆ—å¤§å°ï¼Œé€šè¿‡åº”ç”¨å‚æ•°è®¾ç½®å…¨è¿æ¥å¤§å°ã€‚ ä¸åŒç³»ç»Ÿï¼Œè¯¥å‚æ•°çš„å«ä¹‰ä¸åŒï¼Œå¯å‚è€ƒhttp://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.htmlçš„è¯´æ˜</p>

<p>ã€€ã€€ã€€ã€€5. åŠè¿æ¥é˜Ÿåˆ—é•¿åº¦æ˜¯æŒ‡æœåŠ¡å™¨å¤„äºSYN_RCVDçŠ¶æ€çš„å¥—æ¥å­—ä¸ªæ•°ï¼ŒåŠè¿æ¥åˆ°å…¨è¿æ¥çš„é€šè¿‡è®¾ç½®é‡ä¼ æ¬¡æ•°æ¥åˆ¤æ–­æ˜¯å¦è¶…æ—¶ï¼ˆtcp_synack_retriesï¼Œå®¢æˆ·ç«¯çš„è¶…æ—¶å¯¹åº”ä¸ºtcp_syn_retries ï¼Œé‡ä¼ æ—¶é—´é—´éš”ä¸€èˆ¬ä¸º3s,6s,12s,â€¦ï¼‰</p>

<p>ã€€ã€€ã€€ã€€6. å…¨è¿æ¥é˜Ÿåˆ—é•¿åº¦æ˜¯æŒ‡å¤„äºESTABLISHEDçŠ¶æ€çš„å¥—æ¥å­—ä¸ªæ•°ï¼Œå³ä¸Šé¢ç¬¬4ç‚¹è¯´æ˜çš„backlogçš„é•¿åº¦ï¼ˆç‰¹æŒ‡Linux 2.2ç‰ˆæœ¬åï¼‰ï¼Œ è¿™ä¸ªè®¾ç½®æ˜¯ä¸ªå‚è€ƒå€¼, ä¸æ˜¯ç²¾ç¡®å€¼. å¦‚æœå¤§äº/proc/sys/net/core/somaxconn, åˆ™å–somaxconnçš„å€¼, è¯¥å€¼è¡¨ç¤ºå·²è¿æ¥é˜Ÿåˆ—æœ€å¤§å€¼
<!-- more -->
å·²å®Œæˆé˜Ÿåˆ—æ»¡å
ã€€ã€€é€šå¸¸æœªå®Œæˆé˜Ÿåˆ—çš„é•¿åº¦å¤§äºå·²å®Œæˆé˜Ÿåˆ—.
ã€€ã€€å·²å®Œæˆé˜Ÿåˆ—æ»¡å, å½“æœåŠ¡å™¨æ”¶åˆ°æ¥è‡ªå®¢æˆ·ç«¯çš„ACKåŒ…æ—¶
ã€€ã€€å¦‚æœ /proc/sys/net/ipv4/tcp_abort_on_overflow è®¾ä¸º 1, ç›´æ¥å›RSTåŒ…,ç»“æŸè¿æ¥.
ã€€ã€€å¦åˆ™å¿½è§†ACKåŒ….
ã€€ã€€å†…æ ¸æœ‰å®šæ—¶å™¨ç®¡ç†æœªå®Œæˆé˜Ÿåˆ—,å¯¹äºç”±äºç½‘ç»œåŸå› æ²¡æ”¶åˆ°ACKåŒ…æˆ–æ˜¯æ”¶åˆ°ACKåŒ…åè¢«å¿½è§†çš„SYN_RCVDè¿æ¥é‡å‘SYN+ACKåŒ…, æœ€å¤šé‡å‘æ¬¡æ•°ç”±/proc/sys/net/ipv4/tcp_synack_retries è®¾å®š.</p>

<p>ã€€ã€€backlog å³ä¸Šè¿°å·²å®Œæˆé˜Ÿåˆ—çš„å¤§å°, è¿™ä¸ªè®¾ç½®æ˜¯ä¸ªå‚è€ƒå€¼,ä¸æ˜¯ç²¾ç¡®å€¼. å†…æ ¸ä¼šåšäº›è°ƒæ•´, å¤§äº/proc/sys/net/core/somaxconn, åˆ™å–somaxconnçš„å€¼</p>

<p>æœªå®Œæˆé˜Ÿåˆ—æ»¡å
ã€€ã€€å¦‚æœå¯ç”¨syncookies (net.ipv4.tcp_syncookies = 1),æ–°çš„è¿æ¥ä¸è¿›å…¥æœªå®Œæˆé˜Ÿåˆ—,ä¸å—å½±å“.
ã€€ã€€å¦åˆ™,æœåŠ¡å™¨ä¸åœ¨æ¥å—æ–°çš„è¿æ¥.</p>

<p>SYN æ´ªæ°´æ”»å‡»(syn flood attack)
ã€€ã€€é€šè¿‡ä¼ªé€ IPå‘æœåŠ¡å™¨å‘é€SYNåŒ…,å¡æ»¡æœåŠ¡å™¨çš„æœªå®Œæˆé˜Ÿåˆ—,æœåŠ¡å™¨å‘é€SYN+ACKåŒ… æ²¡å›å¤,åå¤SYN+ACKåŒ…,ä½¿æœåŠ¡å™¨ä¸å¯ç”¨.</p>

<p>ã€€ã€€å¯ç”¨syncookies æ˜¯ç®€å•æœ‰æ•ˆçš„æŠµå¾¡æªæ–½.
ã€€ã€€å¯ç”¨syncookies,ä»…æœªå®Œæˆé˜Ÿåˆ—æ»¡åæ‰ç”Ÿæ•ˆ.
ã€€ã€€
connect()å‡½æ•°
å¯¹äºå®¢æˆ·ç«¯çš„ connect() å‡½æ•°ï¼Œè¯¥å‡½æ•°çš„åŠŸèƒ½ä¸ºå®¢æˆ·ç«¯ä¸»åŠ¨è¿æ¥æœåŠ¡å™¨ï¼Œå»ºç«‹è¿æ¥æ˜¯é€šè¿‡ä¸‰æ¬¡æ¡æ‰‹ï¼Œè€Œè¿™ä¸ªè¿æ¥çš„è¿‡ç¨‹æ˜¯ç”±å†…æ ¸å®Œæˆï¼Œä¸æ˜¯è¿™ä¸ªå‡½æ•°å®Œæˆçš„ï¼Œè¿™ä¸ªå‡½æ•°çš„ä½œç”¨ä»…ä»…æ˜¯é€šçŸ¥ Linux å†…æ ¸ï¼Œè®© Linux å†…æ ¸è‡ªåŠ¨å®Œæˆ TCP ä¸‰æ¬¡æ¡æ‰‹è¿æ¥ï¼ˆä¸‰æ¬¡æ¡æ‰‹è¯¦æƒ…ï¼Œè¯·çœ‹ã€Šæµ…è°ˆ TCP ä¸‰æ¬¡æ¡æ‰‹ã€‹ï¼‰ï¼Œæœ€åæŠŠè¿æ¥çš„ç»“æœè¿”å›ç»™è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼ˆæˆåŠŸè¿æ¥ä¸º0ï¼Œ å¤±è´¥ä¸º-1ï¼‰ã€‚</p>

<p>é€šå¸¸çš„æƒ…å†µï¼Œå®¢æˆ·ç«¯çš„ connect() å‡½æ•°é»˜è®¤ä¼šä¸€ç›´é˜»å¡ï¼Œç›´åˆ°ä¸‰æ¬¡æ¡æ‰‹æˆåŠŸæˆ–è¶…æ—¶å¤±è´¥æ‰è¿”å›ï¼ˆæ­£å¸¸çš„æƒ…å†µï¼Œè¿™ä¸ªè¿‡ç¨‹å¾ˆå¿«å®Œæˆï¼‰ã€‚</p>

<p>listen()å‡½æ•°
å¯¹äºæœåŠ¡å™¨ï¼Œå®ƒæ˜¯è¢«åŠ¨è¿æ¥çš„ã€‚ä¸¾ä¸€ä¸ªç”Ÿæ´»ä¸­çš„ä¾‹å­ï¼Œé€šå¸¸çš„æƒ…å†µä¸‹ï¼Œç§»åŠ¨çš„å®¢æœï¼ˆç›¸å½“äºæœåŠ¡å™¨ï¼‰æ˜¯ç­‰å¾…ç€å®¢æˆ·ï¼ˆç›¸å½“äºå®¢æˆ·ç«¯ï¼‰ç”µè¯çš„åˆ°æ¥ã€‚è€Œè¿™ä¸ªè¿‡ç¨‹ï¼Œéœ€è¦è°ƒç”¨listen()å‡½æ•°ã€‚</p>

<p>#include&lt;sys/socket.h&gt;<br />
int listen(int sockfd, int backlog);<br />
listen() å‡½æ•°çš„ä¸»è¦ä½œç”¨å°±æ˜¯å°†å¥—æ¥å­—( sockfd )å˜æˆè¢«åŠ¨çš„è¿æ¥ç›‘å¬å¥—æ¥å­—ï¼ˆè¢«åŠ¨ç­‰å¾…å®¢æˆ·ç«¯çš„è¿æ¥ï¼‰ï¼Œè‡³äºå‚æ•° backlog çš„ä½œç”¨æ˜¯è®¾ç½®å†…æ ¸ä¸­è¿æ¥é˜Ÿåˆ—çš„é•¿åº¦ï¼ˆè¿™ä¸ªé•¿åº¦æœ‰ä»€ä¹ˆç”¨ï¼Œåé¢åšè¯¦ç»†çš„è§£é‡Šï¼‰ï¼ŒTCP ä¸‰æ¬¡æ¡æ‰‹ä¹Ÿä¸æ˜¯ç”±è¿™ä¸ªå‡½æ•°å®Œæˆï¼Œlisten()çš„ä½œç”¨ä»…ä»…å‘Šè¯‰å†…æ ¸ä¸€äº›ä¿¡æ¯ã€‚</p>

<p>è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œlisten()å‡½æ•°ä¸ä¼šé˜»å¡ï¼Œå®ƒä¸»è¦åšçš„äº‹æƒ…ä¸ºï¼Œå°†è¯¥å¥—æ¥å­—å’Œå¥—æ¥å­—å¯¹åº”çš„è¿æ¥é˜Ÿåˆ—é•¿åº¦å‘Šè¯‰ Linux å†…æ ¸ï¼Œç„¶åï¼Œlisten()å‡½æ•°å°±ç»“æŸã€‚</p>

<p>è¿™æ ·çš„è¯ï¼Œå½“æœ‰ä¸€ä¸ªå®¢æˆ·ç«¯ä¸»åŠ¨è¿æ¥ï¼ˆconnect()ï¼‰ï¼ŒLinux å†…æ ¸å°±è‡ªåŠ¨å®ŒæˆTCP ä¸‰æ¬¡æ¡æ‰‹ï¼Œå°†å»ºç«‹å¥½çš„é“¾æ¥è‡ªåŠ¨å­˜å‚¨åˆ°é˜Ÿåˆ—ä¸­ï¼Œå¦‚æ­¤é‡å¤ã€‚</p>

<p>æ‰€ä»¥ï¼Œåªè¦ TCP æœåŠ¡å™¨è°ƒç”¨äº† listen()ï¼Œå®¢æˆ·ç«¯å°±å¯ä»¥é€šè¿‡ connect() å’ŒæœåŠ¡å™¨å»ºç«‹è¿æ¥ï¼Œè€Œè¿™ä¸ªè¿æ¥çš„è¿‡ç¨‹æ˜¯ç”±å†…æ ¸å®Œæˆã€‚</p>

<p>ä¸‹é¢ä¸ºæµ‹è¯•çš„æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ä»£ç ï¼Œè¿è¡Œç¨‹åºæ—¶ï¼Œè¦å…ˆè¿è¡ŒæœåŠ¡å™¨ï¼Œå†è¿è¡Œå®¢æˆ·ç«¯ï¼š</p>

<p>æœåŠ¡å™¨</p>

<p>#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>                         
#include <unistd.h>  
#include &lt;sys/socket.h&gt;  
#include &lt;netinet/in.h&gt;  
#include &lt;arpa/inet.h&gt;                  
int main(int argc, char *argv[])  
{  
    unsigned short port = 8000;</unistd.h></string.h></stdlib.h></stdio.h></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int sockfd;  
sockfd = socket(AF_INET, SOCK_STREAM, 0);// åˆ›å»ºé€šä¿¡ç«¯ç‚¹ï¼šå¥—æ¥å­—  
if(sockfd &lt; 0)  
{  
    perror("socket");  
    exit(-1);  
}  
  
struct sockaddr_in my_addr;  
bzero(&amp;my_addr, sizeof(my_addr));          
my_addr.sin_family = AF_INET;  
my_addr.sin_port   = htons(port);  
my_addr.sin_addr.s_addr = htonl(INADDR_ANY);  
  
int err_log = bind(sockfd, (struct sockaddr*)&amp;my_addr, sizeof(my_addr));  
if( err_log != 0)  
{  
    perror("binding");  
    close(sockfd);        
    exit(-1);  
}  
  
err_log = listen(sockfd, 10);  
if(err_log != 0)  
{  
    perror("listen");  
    close(sockfd);        
    exit(-1);  
}     
  
printf("listen client @port=%d...\n",port);  
  
sleep(10);  // å»¶æ—¶10s  
  
system("netstat -an | grep 8000");  // æŸ¥çœ‹è¿æ¥çŠ¶æ€  
  
return 0;   }
</code></pre></div></div>

<p>å®¢æˆ·ç«¯ï¼š
#include <stdio.h>  
#include <unistd.h>  
#include <string.h>  
#include <stdlib.h>  
#include &lt;arpa/inet.h&gt;  
#include &lt;sys/socket.h&gt;  
#include &lt;netinet/in.h&gt;  
int main(int argc, char *argv[])  
{  
    unsigned short port = 8000;             // æœåŠ¡å™¨çš„ç«¯å£å·  
    char *server_ip = "10.221.20.12";       // æœåŠ¡å™¨ipåœ°å€</stdlib.h></string.h></unistd.h></stdio.h></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int sockfd;  
sockfd = socket(AF_INET, SOCK_STREAM, 0);// åˆ›å»ºé€šä¿¡ç«¯ç‚¹ï¼šå¥—æ¥å­—  
if(sockfd &lt; 0)  
{  
    perror("socket");  
    exit(-1);  
}  
  
struct sockaddr_in server_addr;  
bzero(&amp;server_addr,sizeof(server_addr)); // åˆå§‹åŒ–æœåŠ¡å™¨åœ°å€  
server_addr.sin_family = AF_INET;  
server_addr.sin_port = htons(port);  
inet_pton(AF_INET, server_ip, &amp;server_addr.sin_addr);  
  
int err_log = connect(sockfd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));      // ä¸»åŠ¨è¿æ¥æœåŠ¡å™¨  
if(err_log != 0)  
{  
    perror("connect");  
    close(sockfd);  
    exit(-1);  
}  
  
system("netstat -an | grep 8000");  // æŸ¥çœ‹è¿æ¥çŠ¶æ€  
  
while(1);  
  
return 0;   }
</code></pre></div></div>

<p>è¿è¡Œç¨‹åºæ—¶ï¼Œè¦å…ˆè¿è¡ŒæœåŠ¡å™¨ï¼Œå†è¿è¡Œå®¢æˆ·ç«¯ï¼Œè¿è¡Œç»“æœå¦‚ä¸‹
ä¸‰æ¬¡æ¡æ‰‹çš„è¿æ¥é˜Ÿåˆ—
è¿™é‡Œè¯¦ç»†çš„ä»‹ç»ä¸€ä¸‹ listen() å‡½æ•°çš„ç¬¬äºŒä¸ªå‚æ•°ï¼ˆ backlogï¼‰çš„ä½œç”¨ï¼šå‘Šè¯‰å†…æ ¸è¿æ¥é˜Ÿåˆ—çš„é•¿åº¦ã€‚</p>

<p>ä¸ºäº†æ›´å¥½çš„ç†è§£ backlog å‚æ•°ï¼Œæˆ‘ä»¬å¿…é¡»è®¤è¯†åˆ°å†…æ ¸ä¸ºä»»ä½•ä¸€ä¸ªç»™å®šçš„ç›‘å¬å¥—æ¥å£ç»´æŠ¤ä¸¤ä¸ªé˜Ÿåˆ—ï¼š</p>

<p>1ã€æœªå®Œæˆè¿æ¥é˜Ÿåˆ—ï¼ˆincomplete connection queueï¼‰ï¼Œæ¯ä¸ªè¿™æ ·çš„ SYN åˆ†èŠ‚å¯¹åº”å…¶ä¸­ä¸€é¡¹ï¼šå·²ç”±æŸä¸ªå®¢æˆ·å‘å‡ºå¹¶åˆ°è¾¾æœåŠ¡å™¨ï¼Œè€ŒæœåŠ¡å™¨æ­£åœ¨ç­‰å¾…å®Œæˆç›¸åº”çš„ TCP ä¸‰æ¬¡æ¡æ‰‹è¿‡ç¨‹ã€‚è¿™äº›å¥—æ¥å£å¤„äº SYN_RCVD çŠ¶æ€ã€‚</p>

<p>2ã€å·²å®Œæˆè¿æ¥é˜Ÿåˆ—ï¼ˆcompleted connection queueï¼‰ï¼Œæ¯ä¸ªå·²å®Œæˆ TCP ä¸‰æ¬¡æ¡æ‰‹è¿‡ç¨‹çš„å®¢æˆ·å¯¹åº”å…¶ä¸­ä¸€é¡¹ã€‚è¿™äº›å¥—æ¥å£å¤„äº ESTABLISHED çŠ¶æ€ã€‚</p>

<p>å½“æ¥è‡ªå®¢æˆ·çš„ SYN åˆ°è¾¾æ—¶ï¼ŒTCP åœ¨æœªå®Œæˆè¿æ¥é˜Ÿåˆ—ä¸­åˆ›å»ºä¸€ä¸ªæ–°é¡¹ï¼Œç„¶åå“åº”ä»¥ä¸‰æ¬¡æ¡æ‰‹çš„ç¬¬äºŒä¸ªåˆ†èŠ‚ï¼šæœåŠ¡å™¨çš„ SYN å“åº”ï¼Œå…¶ä¸­ç¨å¸¦å¯¹å®¢æˆ· SYN çš„ ACKï¼ˆå³SYN+ACKï¼‰ï¼Œè¿™ä¸€é¡¹ä¸€ç›´ä¿ç•™åœ¨æœªå®Œæˆè¿æ¥é˜Ÿåˆ—ä¸­ï¼Œç›´åˆ°ä¸‰æ¬¡æ¡æ‰‹çš„ç¬¬ä¸‰ä¸ªåˆ†èŠ‚ï¼ˆå®¢æˆ·å¯¹æœåŠ¡å™¨ SYN çš„ ACK ï¼‰åˆ°è¾¾æˆ–è€…è¯¥é¡¹è¶…æ—¶ä¸ºæ­¢ï¼ˆæ›¾ç»æºè‡ªBerkeleyçš„å®ç°ä¸ºè¿™äº›æœªå®Œæˆè¿æ¥çš„é¡¹è®¾ç½®çš„è¶…æ—¶å€¼ä¸º75ç§’ï¼‰ã€‚</p>

<p>å¦‚æœä¸‰æ¬¡æ¡æ‰‹æ­£å¸¸å®Œæˆï¼Œè¯¥é¡¹å°±ä»æœªå®Œæˆè¿æ¥é˜Ÿåˆ—ç§»åˆ°å·²å®Œæˆè¿æ¥é˜Ÿåˆ—çš„é˜Ÿå°¾ã€‚</p>

<p>backlog å‚æ•°å†å²ä¸Šè¢«å®šä¹‰ä¸ºä¸Šé¢ä¸¤ä¸ªé˜Ÿåˆ—çš„å¤§å°ä¹‹å’Œï¼Œå¤§å¤šæ•°å®ç°é»˜è®¤å€¼ä¸º 5ï¼Œå½“æœåŠ¡å™¨æŠŠè¿™ä¸ªå®Œæˆè¿æ¥é˜Ÿåˆ—çš„æŸä¸ªè¿æ¥å–èµ°åï¼Œè¿™ä¸ªé˜Ÿåˆ—çš„ä½ç½®åˆç©ºå‡ºä¸€ä¸ªï¼Œè¿™æ ·æ¥å›å®ç°åŠ¨æ€å¹³è¡¡ï¼Œä½†åœ¨é«˜å¹¶å‘ web æœåŠ¡å™¨ä¸­æ­¤å€¼æ˜¾ç„¶ä¸å¤Ÿã€‚</p>

<p>accept()å‡½æ•°
accept()å‡½æ•°åŠŸèƒ½æ˜¯ï¼Œä»å¤„äº established çŠ¶æ€çš„è¿æ¥é˜Ÿåˆ—å¤´éƒ¨å–å‡ºä¸€ä¸ªå·²ç»å®Œæˆçš„è¿æ¥ï¼Œå¦‚æœè¿™ä¸ªé˜Ÿåˆ—æ²¡æœ‰å·²ç»å®Œæˆçš„è¿æ¥ï¼Œaccept()å‡½æ•°å°±ä¼šé˜»å¡ï¼Œç›´åˆ°å–å‡ºé˜Ÿåˆ—ä¸­å·²å®Œæˆçš„ç”¨æˆ·è¿æ¥ä¸ºæ­¢ã€‚</p>

<p>å¦‚æœï¼ŒæœåŠ¡å™¨ä¸èƒ½åŠæ—¶è°ƒç”¨ accept() å–èµ°é˜Ÿåˆ—ä¸­å·²å®Œæˆçš„è¿æ¥ï¼Œé˜Ÿåˆ—æ»¡æ‰åä¼šæ€æ ·å‘¢ï¼ŸUNPï¼ˆã€Šunixç½‘ç»œç¼–ç¨‹ã€‹ï¼‰å‘Šè¯‰æˆ‘ä»¬ï¼ŒæœåŠ¡å™¨çš„è¿æ¥é˜Ÿåˆ—æ»¡æ‰åï¼ŒæœåŠ¡å™¨ä¸ä¼šå¯¹å†å¯¹å»ºç«‹æ–°è¿æ¥çš„synè¿›è¡Œåº”ç­”ï¼Œæ‰€ä»¥å®¢æˆ·ç«¯çš„ connect å°±ä¼šè¿”å› ETIMEDOUTã€‚ä½†å®é™…ä¸ŠLinuxçš„å¹¶ä¸æ˜¯è¿™æ ·çš„ï¼</p>

<p>ä¸‹é¢ä¸ºæµ‹è¯•ä»£ç ï¼ŒæœåŠ¡å™¨ listen() å‡½æ•°åªæŒ‡å®šé˜Ÿåˆ—é•¿åº¦ä¸º 2ï¼Œå®¢æˆ·ç«¯æœ‰ 6 ä¸ªä¸åŒçš„å¥—æ¥å­—ä¸»åŠ¨è¿æ¥æœåŠ¡å™¨ï¼ŒåŒæ—¶ï¼Œä¿è¯å®¢æˆ·ç«¯çš„ 6 ä¸ª connect()å‡½æ•°éƒ½å…ˆè°ƒç”¨å®Œæ¯•ï¼ŒæœåŠ¡å™¨çš„ accpet() æ‰å¼€å§‹è°ƒç”¨ã€‚</p>

<p>æœåŠ¡å™¨ï¼š
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>                         
#include <unistd.h>  
#include &lt;sys/socket.h&gt;  
#include &lt;netinet/in.h&gt;  
#include &lt;arpa/inet.h&gt;</unistd.h></string.h></stdlib.h></stdio.h></p>

<p>int main(int argc, char *argv[])<br />
{<br />
    unsigned short port = 8000;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int sockfd = socket(AF_INET, SOCK_STREAM, 0);     
if(sockfd &lt; 0)  
{  
    perror("socket");  
    exit(-1);  
}  
  
struct sockaddr_in my_addr;  
bzero(&amp;my_addr, sizeof(my_addr));          
my_addr.sin_family = AF_INET;  
my_addr.sin_port   = htons(port);  
my_addr.sin_addr.s_addr = htonl(INADDR_ANY);  
  
int err_log = bind(sockfd, (struct sockaddr*)&amp;my_addr, sizeof(my_addr));  
if( err_log != 0)  
{  
    perror("binding");  
    close(sockfd);        
    exit(-1);  
}  
  
err_log = listen(sockfd, 2);    // ç­‰å¾…é˜Ÿåˆ—ä¸º2  
if(err_log != 0)  
{  
    perror("listen");  
    close(sockfd);        
    exit(-1);  
}     
printf("after listen\n");  
  
sleep(20);  //å»¶æ—¶ 20ç§’  
  
printf("listen client @port=%d...\n",port);  
  
int i = 0;  
  
while(1)  
{     
  
    struct sockaddr_in client_addr;          
    char cli_ip[INET_ADDRSTRLEN] = "";       
    socklen_t cliaddr_len = sizeof(client_addr);      
      
    int connfd;  
    connfd = accept(sockfd, (struct sockaddr*)&amp;client_addr, &amp;cliaddr_len);         
    if(connfd &lt; 0)  
    {  
        perror("accept");  
        continue;  
    }  
  
    inet_ntop(AF_INET, &amp;client_addr.sin_addr, cli_ip, INET_ADDRSTRLEN);  
    printf("-----------%d------\n", ++i);  
    printf("client ip=%s,port=%d\n", cli_ip,ntohs(client_addr.sin_port));  
      
    char recv_buf[512] = {0};  
    while( recv(connfd, recv_buf, sizeof(recv_buf), 0) &gt; 0 )  
    {  
        printf("recv data ==%s\n",recv_buf);  
        break;  
    }  
      
    close(connfd);     //å…³é—­å·²è¿æ¥å¥—æ¥å­—  
    //printf("client closed!\n");  
}  
close(sockfd);         //å…³é—­ç›‘å¬å¥—æ¥å­—  
return 0;   }
</code></pre></div></div>

<p>å®¢æˆ·ç«¯ï¼š
#include <stdio.h>  
#include <unistd.h>  
#include <string.h>  
#include <stdlib.h>  
#include &lt;arpa/inet.h&gt;  
#include &lt;sys/socket.h&gt;  
#include &lt;netinet/in.h&gt;</stdlib.h></string.h></unistd.h></stdio.h></p>

<p>void test_connect()<br />
{<br />
    unsigned short port = 8000;             // æœåŠ¡å™¨çš„ç«¯å£å·<br />
    char *server_ip = â€œ10.221.20.12â€;       // æœåŠ¡å™¨ipåœ°å€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int sockfd;  
sockfd = socket(AF_INET, SOCK_STREAM, 0);// åˆ›å»ºé€šä¿¡ç«¯ç‚¹ï¼šå¥—æ¥å­—  
if(sockfd &lt; 0)  
{  
    perror("socket");  
    exit(-1);  
}  
  
struct sockaddr_in server_addr;  
bzero(&amp;server_addr,sizeof(server_addr)); // åˆå§‹åŒ–æœåŠ¡å™¨åœ°å€  
server_addr.sin_family = AF_INET;  
server_addr.sin_port = htons(port);  
inet_pton(AF_INET, server_ip, &amp;server_addr.sin_addr);  
  
int err_log = connect(sockfd, (struct sockaddr*)&amp;server_addr, sizeof(server_addr));      // ä¸»åŠ¨è¿æ¥æœåŠ¡å™¨  
if(err_log != 0)  
{  
    perror("connect");  
    close(sockfd);  
    exit(-1);  
}  
  
printf("err_log ========= %d\n", err_log);  
  
char send_buf[100]="this is for test";  
send(sockfd, send_buf, strlen(send_buf), 0);   // å‘æœåŠ¡å™¨å‘é€ä¿¡æ¯  
  
system("netstat -an | grep 8000");  // æŸ¥çœ‹è¿æ¥çŠ¶æ€  
  
//close(sockfd);   }  
</code></pre></div></div>

<p>int main(int argc, char *argv[])<br />
{<br />
    pid_t pid;<br />
    pid = fork();</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(0 == pid){  
  
    test_connect();     // 1  
      
    pid_t pid = fork();  
    if(0 == pid){  
        test_connect(); // 2  
      
    }else if(pid &gt; 0){  
        test_connect(); // 3  
    }  
      
}else if(pid &gt; 0){  
      
    test_connect(); // 4  
      
    pid_t pid = fork();  
    if(0 == pid){  
        test_connect(); // 5  
      
    }else if(pid &gt; 0){  
        test_connect(); // 6  
    }  
  
}  
  
while(1);  
  
return 0;   }
</code></pre></div></div>

<p>åŒæ ·æ˜¯å…ˆè¿è¡ŒæœåŠ¡å™¨ï¼Œåœ¨è¿è¡Œå®¢æˆ·ç«¯ï¼ŒæœåŠ¡å™¨ accept()å‡½æ•°å‰å»¶æ—¶äº† 20 ç§’ï¼Œ ä¿è¯äº†å®¢æˆ·ç«¯çš„ connect() å…¨éƒ¨è°ƒç”¨å®Œæ¯•åå†è°ƒç”¨ accept(),è¿è¡Œç»“æœå¦‚ä¸‹ï¼š</p>

<p>æœåŠ¡å™¨è¿è¡Œæ•ˆæœå›¾ï¼š</p>

<p>æŒ‰ç…§ UNP çš„è¯´æ³•ï¼Œè¿æ¥é˜Ÿåˆ—æ»¡åï¼ˆè¿™é‡Œè®¾ç½®é•¿åº¦ä¸º 2ï¼Œå‘äº† 6 ä¸ªè¿æ¥ï¼‰ï¼Œä»¥åå†è°ƒç”¨ connect() åº”è¯¥ç»Ÿç»Ÿè¶…æ—¶å¤±è´¥ï¼Œä½†å®é™…ä¸Šæµ‹è¯•ç»“æœæ˜¯ï¼šæœ‰çš„ connect()ç«‹åˆ»æˆåŠŸè¿”å›äº†ï¼Œæœ‰çš„ç»è¿‡æ˜æ˜¾å»¶è¿ŸåæˆåŠŸè¿”å›äº†ã€‚å¯¹äºæœåŠ¡å™¨ accpet() å‡½æ•°ä¹Ÿæ˜¯è¿™æ ·çš„ç»“æœï¼šæœ‰çš„ç«‹é©¬æˆåŠŸè¿”å›ï¼Œæœ‰çš„å»¶è¿ŸåæˆåŠŸè¿”å›ã€‚</p>

<p>å¯¹äºä¸Šé¢æœåŠ¡å™¨çš„ä»£ç ï¼Œæˆ‘ä»¬æŠŠlisen()çš„ç¬¬äºŒä¸ªå‚æ•°æ”¹ä¸º 0 çš„æ•°ï¼Œé‡æ–°è¿è¡Œç¨‹åºï¼Œå‘ç°ï¼š</p>

<p>å®¢æˆ·ç«¯ connect() å…¨éƒ¨è¿”å›è¿æ¥æˆåŠŸï¼ˆæœ‰äº›ä¼šå»¶æ—¶ï¼‰ï¼š</p>

<p>å¯¹äºä¸Šé¢æœåŠ¡å™¨çš„ä»£ç ï¼Œæˆ‘ä»¬æŠŠlisen()çš„ç¬¬äºŒä¸ªå‚æ•°æ”¹ä¸ºå¤§äº 6 çš„æ•°(å¦‚ 10)ï¼Œé‡æ–°è¿è¡Œç¨‹åºï¼Œå‘ç°ï¼Œå®¢æˆ·ç«¯ connect() ç«‹é©¬è¿”å›è¿æ¥æˆåŠŸï¼Œ æœåŠ¡å™¨ accpet() å‡½æ•°ä¹Ÿç«‹é©¬è¿”å›æˆåŠŸã€‚</p>

<p>TCP çš„è¿æ¥é˜Ÿåˆ—æ»¡åï¼ŒLinux ä¸ä¼šå¦‚ä¹¦ä¸­æ‰€è¯´çš„æ‹’ç»è¿æ¥ï¼Œåªæ˜¯æœ‰äº›ä¼šå»¶æ—¶è¿æ¥ï¼Œè€Œä¸”accept()æœªå¿…èƒ½æŠŠå·²ç»å»ºç«‹å¥½çš„è¿æ¥å…¨éƒ¨å–å‡ºæ¥ï¼ˆå¦‚ï¼šå½“é˜Ÿåˆ—çš„é•¿åº¦æŒ‡å®šä¸º 0 ï¼‰ï¼Œå†™ç¨‹åºæ—¶æœåŠ¡å™¨çš„ listen() çš„ç¬¬äºŒä¸ªå‚æ•°æœ€å¥½è¿˜æ˜¯æ ¹æ®éœ€è¦å¡«å†™ï¼Œå†™å¤ªå¤§ä¸å¥½ï¼ˆå…·ä½“å¯ä»¥çœ‹cat /proc/sys/net/core/somaxconnï¼Œé»˜è®¤æœ€å¤§å€¼é™åˆ¶æ˜¯ 128ï¼‰ï¼Œæµªè´¹èµ„æºï¼Œå†™å¤ªå°ä¹Ÿä¸å¥½ï¼Œå»¶æ—¶å»ºç«‹è¿æ¥ã€‚</p>

<p>tcpä¸‰æ¬¡æ¡æ‰‹çš„è¿‡ç¨‹
ç¬¬ä¸€æ¬¡ï¼šå®¢æˆ·ç«¯å‘é€SYN(Synchronize Sequence Numbers)æŠ¥æ–‡ï¼Œæ ‡å¿—ä½SYN=1,åºåˆ—å·seq=jã€‚
ç¬¬äºŒæ¬¡ï¼šæœåŠ¡ç«¯æ”¶åˆ°SYNæŠ¥æ–‡åï¼Œå›åº”ACK(Acknowledgement)ï¼Œæ ‡å¿—ä½ACK=1,ç¡®è®¤å·ackä¸ºj+1ï¼Œ åŒæ—¶è‡ªå·±ä¹Ÿå‘é€ä¸€ä¸ªSYNæŠ¥æ–‡ï¼ŒSYN=1,åºåˆ—å·seqå‡è®¾ä¸ºkï¼Œ å³ä¸€ä¸ªACK+SYNåŒ…
ç¬¬ä¸‰æ¬¡ï¼šå®¢æˆ·ç«¯æ”¶åˆ°æŠ¥æ–‡åï¼Œå‘é€ä¸€ä¸ªACKæŠ¥æ–‡ï¼Œæ ‡å¿—ä½ACK=1ï¼Œç¡®è®¤å·ack=(k+1) åˆ°æœåŠ¡å™¨ï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨è¿›å…¥ESTABLISHEDçŠ¶æ€ï¼ŒTCPé“¾æ¥æˆåŠŸã€‚
SYNæ˜¯åŒæ­¥æŠ¥æ–‡æ ‡å¿—ä½ï¼Œå»ºç«‹è¿æ¥æ—¶ä¸º1ï¼Œè¿æ¥å»ºç«‹åç½®ä¸º0ï¼ŒACKæ—¶ç¡®è®¤æ ‡å¿—ä½ä¸€èˆ¬ä¸º1
tcpå››æ¬¡æŒ¥æ‰‹è¿‡ç¨‹ï¼Œä¸ºä»€ä¹ˆæ˜¯4æ¬¡å‘¢ï¼Ÿ
å‡å¦‚å®¢æˆ·ç«¯ä¸»åŠ¨å‘èµ·å…³é—­æ“ä½œ
ç¬¬ä¸€æ¬¡ï¼š å®¢æˆ·ç«¯å‘é€FINæŠ¥æ–‡ï¼Œå‡è®¾ä¸ºåºåˆ—å·seq=iç»™æœåŠ¡å™¨ã€‚
ç¬¬äºŒæ¬¡ï¼š æœåŠ¡å‘é€ACKæŠ¥æ–‡ï¼Œack=(i+1)ç»™å®¢æˆ·ç«¯ï¼Œå¯èƒ½æ•°æ®è¿˜æ²¡æœ‰æ¥æ”¶å®Œæ¯•ï¼Œæ‰€ä»¥æœåŠ¡ç«¯socketçŠ¶æ€ç”±ESTABLISHED -&gt; CLOSE_WAITçŠ¶æ€ã€‚
ç¬¬ä¸‰æ¬¡ï¼š æœåŠ¡ç«¯ç«¯å¤„ç†å®Œæ¯•ï¼Œå‘é€FINæŠ¥æ–‡ï¼Œåºåˆ—å·ä¸ºjã€‚
ç¬¬å››æ¬¡ï¼š å®¢æˆ·ç«¯æ”¶åˆ°æŠ¥æ–‡åï¼Œå‘é€ACKæŠ¥æ–‡ï¼Œack=j+1, å¹¶è¿›å…¥TIME_WAITçŠ¶æ€ã€‚ç­‰å¾…2MSLåè‡ªåŠ¨å…³é—­
ä¸ºä»€ä¹ˆå®¢æˆ·ç«¯ä¸å‘å®Œackå°±é‡Šæ”¾å‘¢ï¼Œå› ä¸ºæœåŠ¡å™¨å¯èƒ½æ²¡æ”¶åˆ°ackï¼ŒæœåŠ¡å™¨ä¼šé‡æ–°å‘é€FINè¯·æ±‚å…³é—­è¿æ¥ï¼Œå®¢æˆ·ç«¯é‡æ–°å‘é€ackï¼Œæ‰€ä»¥ä¸€ä¸ªæ¥å›å°±æ˜¯2
ä¸ªæŠ¥æ–‡å‘¨æœŸã€‚å½“è¿æ¥å¤„äº2MSLç­‰å¾…é˜¶æ®µæ—¶ä»»ä½•è¿Ÿåˆ°çš„æŠ¥æ–‡æ®µéƒ½å°†è¢«ä¸¢å¼ƒã€‚
å€Ÿç”¨ä¸€å¼ å›¾è¡¨ç¤ºä¸€ä¸‹
aa</p>

<p>å¦‚æœå·²ç»å»ºç«‹äº†è¿æ¥ï¼Œä½†æ˜¯å®¢æˆ·ç«¯çªç„¶å‡ºç°æ•…éšœäº†æ€ä¹ˆåŠï¼Ÿ
TCPè¿˜è®¾æœ‰ä¸€ä¸ªä¿æ´»è®¡æ—¶å™¨ï¼Œæ˜¾ç„¶ï¼Œå®¢æˆ·ç«¯å¦‚æœå‡ºç°æ•…éšœï¼ŒæœåŠ¡å™¨ä¸èƒ½ä¸€ç›´ç­‰ä¸‹å»ï¼Œç™½ç™½æµªè´¹èµ„æºã€‚æœåŠ¡å™¨æ¯æ”¶åˆ°ä¸€æ¬¡å®¢æˆ·ç«¯çš„è¯·æ±‚åéƒ½ä¼šé‡æ–°å¤ä½è¿™ä¸ªè®¡æ—¶å™¨ï¼Œæ—¶é—´é€šå¸¸æ˜¯è®¾ç½®ä¸º2å°æ—¶ï¼Œè‹¥ä¸¤å°æ—¶è¿˜æ²¡æœ‰æ”¶åˆ°å®¢æˆ·ç«¯çš„ä»»ä½•æ•°æ®ï¼ŒæœåŠ¡å™¨å°±ä¼šå‘é€ä¸€ä¸ªæ¢æµ‹æŠ¥æ–‡æ®µï¼Œä»¥åæ¯éš”75åˆ†é’Ÿå‘é€ä¸€æ¬¡ã€‚è‹¥ä¸€è¿å‘é€10ä¸ªæ¢æµ‹æŠ¥æ–‡ä»ç„¶æ²¡ååº”ï¼ŒæœåŠ¡å™¨å°±è®¤ä¸ºå®¢æˆ·ç«¯å‡ºäº†æ•…éšœï¼Œæ¥ç€å°±å…³é—­è¿æ¥ã€‚</p>

<p>æŸ¥çœ‹ç½‘ç»œé“¾æ¥çš„å‘½ä»¤
æŸ¥çœ‹ä¸åŒçŠ¶æ€çš„é“¾æ¥æ•°
netstat -an | awk â€˜/^tcp/ {++y[$NF]} END {for(w in y) print w, y[w]}â€™
åŠè¿æ¥çŠ¶æ€é˜Ÿåˆ—sync_queueå’Œå…¨è¿æ¥é˜Ÿåˆ—accept_queue
ç¬¬ä¸€ç§å®ç°ï¼š
BSDå®ç°å’Œåœ¨linux2.2ä¹‹å‰ï¼Œlistenç³»ç»Ÿè°ƒç”¨backlogå‚æ•°è¡¨ç¤ºåŠé“¾æ¥+å…¨é“¾æ¥é˜Ÿåˆ—æ•°ä¹‹å’Œ
å½“é˜Ÿåˆ—æ»¡äº†ä»¥åï¼ŒæœåŠ¡ç«¯å†æ”¶åˆ°SYNæ—¶ï¼Œå°†ä¸ä¼šè¿”å›SYN/ACKã€‚æ¯”è¾ƒä¼˜é›…çš„å¤„ç†æ–¹æ³•å°±æ˜¯ä¸å¤„ç†è¿™æ¡è¿æ¥ï¼Œä¸è¿”å›RSTï¼Œè®©å®¢æˆ·ç«¯é‡è¯•.
acceptç³»ç»Ÿè°ƒç”¨åªæ˜¯ç®€å•åœ°ä»å®Œæˆé˜Ÿåˆ—ä¸­å–å‡ºè¿æ¥.
ç¬¬äºŒç§å®ç°ï¼š
linuxå†…æ ¸2.2ä»¥ä¸Šçš„ç‰ˆæœ¬ï¼ŒSYN_RCVDé˜Ÿåˆ—çš„å¤§å°ç”±proc/sys/net/ipv4/tcp_max_syn_backlogç³»ç»Ÿå‚æ•°æŒ‡å®šï¼ŒESTABLISHEDé˜Ÿåˆ—ç”±backlogå’Œ/proc/sys/net/core/somaxconnä¸­è¾ƒå°çš„æŒ‡å®š
å¦‚æœå…¨è¿æ¥é˜Ÿåˆ—æ»¡äº†æ€ä¹ˆåŠï¼Ÿ
æœåŠ¡å™¨ä¸äºˆå¤„ç†ï¼Œè¿™æ ·å®¢æˆ·ç«¯ä¼šä»»åŠ¡æ•°æ®ä¸¢å¤±ï¼Œé‡æ–°å‘é€ackç¡®è®¤ï¼Œå¦‚æœæœåŠ¡å™¨æœ‰ç©ºé—´ï¼Œä¼šé‡æ–°åŠ å…¥åˆ°ESTABLISHEDé˜Ÿåˆ—ã€‚
å¦‚æœclientç«¯æ²¡æ”¶åˆ°æœåŠ¡å™¨å‘æ¥çš„FINï¼Œé‚£ä¹ˆclientä¼šä¸€ç›´æ˜¯FIN_WAIT_2å—ï¼Ÿ
è®¾ç½®ç³»ç»Ÿå˜é‡
sysctl -w net.ipv4.tcp_fin_timeout=5
ç›´æ¥ctrl+cæ€æ­»å®¢æˆ·ç«¯ï¼Œå‘ç°FIN_WAIT_2çš„çŠ¶æ€çš„é“¾æ¥ï¼Œä¸€ä¼šå°±æ¶ˆå¤±äº†ï¼Œå¹¶ä¸ä¼šè¿›å…¥TIMEWAITçŠ¶æ€ã€‚
æ€ä¹ˆæŸ¥çœ‹é“¾æ¥çŠ¶æ€å‘¢ï¼Ÿ
1
2
3
netstat -natp | grep 8888</p>

<p>8888æ˜¯æœåŠ¡ç«¯ç›‘å¬çš„ç«¯å£ï¼Œå› ä¸ºtcpé“¾æ¥æ€»æ˜¯æœ‰ä¸€ç«¯æ˜¯8888ç«¯å£çš„ã€‚
æŸ¥çœ‹æ¯ä¸ªipå’ŒæœåŠ¡å™¨çš„è¿æ¥æ•°</p>

<p>1
netstat -nat|awk â€˜{print$5}â€™|awk -F : â€˜{print$1}â€™|sort|uniq -c|sort -rn
ä»€ä¹ˆæ˜¯MSLå‘¢ï¼Ÿ</p>

<p>linuxä¸Šçš„å®šä¹‰ï¼Œå°±æ˜¯60s
1
2
#define TCP_TIMEWAIT_LEN (60*HZ) 
                  * state, about 60 seconds */
å…¨è¿æ¥é˜Ÿåˆ—æ»¡äº†æ€ä¹ˆåŠå‘¢ï¼Ÿ
æœåŠ¡å™¨æ ¹æ® /proc/sys/net/ipv4/tcp_abort_on_overflowçš„å€¼å¤„ç†
0 è¡¨ç¤ºä¸¢å¼ƒackï¼Œè®©å®¢æˆ·ç«¯é‡æ–°å‘ack
1 è¡¨ç¤ºè¡¨ç¤ºå‘é€ä¸€ä¸ªRSTç»™å®¢æˆ·ç«¯ï¼Œç›´æ¥åºŸå¼ƒæ‰è¿™ä¸ªæ¡æ‰‹è¿‡ç¨‹ï¼Œå®¢æˆ·ç«¯ä¼šå‡ºç°connection reset by peerçš„é”™è¯¯</p>

<p>socketä¸Šå®šä¹‰äº†å‡ ä¸ªIOäº‹ä»¶ï¼šçŠ¶æ€æ”¹å˜äº‹ä»¶ã€æœ‰æ•°æ®å¯è¯»äº‹ä»¶ã€æœ‰å‘é€ç¼“å­˜å¯å†™äº‹ä»¶ã€æœ‰IOé”™è¯¯äº‹ä»¶ã€‚</p>

<p>å¯¹äºè¿™äº›äº‹ä»¶ï¼Œsocketä¸­åˆ†åˆ«å®šä¹‰äº†ç›¸åº”çš„äº‹ä»¶å¤„ç†å‡½æ•°ï¼Œä¹Ÿç§°å›è°ƒå‡½æ•°ã€‚</p>

<p>Socket I/Oäº‹ä»¶çš„å¤„ç†è¿‡ç¨‹ä¸­ï¼Œè¦ä½¿ç”¨åˆ°sockä¸Šçš„ä¸¤ä¸ªé˜Ÿåˆ—ï¼šç­‰å¾…é˜Ÿåˆ—å’Œå¼‚æ­¥é€šçŸ¥é˜Ÿåˆ—ï¼Œè¿™ä¸¤ä¸ªé˜Ÿåˆ—ä¸­</p>

<p>éƒ½ä¿å­˜ç€ç­‰å¾…è¯¥Socket I/Oäº‹ä»¶çš„è¿›ç¨‹ã€‚</p>

<p>Qï¼šä¸ºä»€ä¹ˆè¦ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—ï¼Œç­‰å¾…é˜Ÿåˆ—å’Œå¼‚æ­¥é€šçŸ¥é˜Ÿåˆ—æœ‰ä»€ä¹ˆåŒºåˆ«å‘¢ï¼Ÿ</p>

<p>Aï¼šç­‰å¾…é˜Ÿåˆ—ä¸Šçš„è¿›ç¨‹ä¼šç¡çœ ï¼Œç›´åˆ°Socket I/Oäº‹ä»¶çš„å‘ç”Ÿï¼Œç„¶ååœ¨äº‹ä»¶å¤„ç†å‡½æ•°ä¸­è¢«å”¤é†’ã€‚</p>

<p>å¼‚æ­¥é€šçŸ¥é˜Ÿåˆ—ä¸Šçš„è¿›ç¨‹åˆ™ä¸éœ€è¦ç¡çœ ï¼ŒSocket I/Oäº‹ä»¶å‘æ—¶ï¼Œäº‹ä»¶å¤„ç†å‡½æ•°ä¼šç»™å®ƒä»¬å‘é€åˆ°ä¿¡å·ï¼Œ</p>

<p>è¿™äº›è¿›ç¨‹äº‹å…ˆæ³¨å†Œçš„ä¿¡å·å¤„ç†å‡½æ•°å°±èƒ½å¤Ÿè¢«æ‰§è¡Œã€‚</p>

<p>ç­‰å¾…é˜Ÿåˆ—
Socketå±‚ä½¿ç”¨ç­‰å¾…é˜Ÿåˆ—æ¥è¿›è¡Œé˜»å¡ç­‰å¾…ï¼Œåœ¨ç­‰å¾…æœŸé—´ï¼Œé˜»å¡åœ¨æ­¤socketä¸Šçš„è¿›ç¨‹ä¼šç¡çœ ã€‚</p>

<p>struct sock {
    â€¦
    struct socket_wq __rcu <em>sk_wq; /</em> socketçš„ç­‰å¾…é˜Ÿåˆ—å’Œå¼‚æ­¥é€šçŸ¥é˜Ÿåˆ— */
    â€¦
}</p>

<p>struct socket_wq {
    /* Note: wait MUST be first field of socket_wq <em>/
    wait_queue_head_t wait; /</em> ç­‰å¾…é˜Ÿåˆ—å¤´ <em>/
    struct fasync_struct *fasync_list; /</em> å¼‚æ­¥é€šçŸ¥é˜Ÿåˆ— */
    struct rcu_head *rcu;
};
(1)  socketçš„ç­‰å¾…é˜Ÿåˆ—å¤´</p>

<p>struct __wait_queue_head {
    spinlock_t lock;
    struct list_head task_list;
};
typedef struct __wait_queue_head wait_queue_head_t;
(2) è¿›ç¨‹çš„ç­‰å¾…ä»»åŠ¡</p>

<p>struct __wait_queue {
    unsigned int flags;
#define WQ_FLAG_EXCLUSIVE 0x01
    void <em>private; /</em> æŒ‡å‘å½“å‰çš„è¿›ç¨‹æ§åˆ¶å— <em>/
    wait_queue_func_t func; /</em> å”¤é†’å‡½æ•° <em>/
    struct list_head task_list; /</em> ç”¨äºé“¾æ¥å…¥ç­‰å¾…é˜Ÿåˆ— <em>/
};
typedef struct __wait_queue wait_queue_t;
typedef int (</em>wait_queue_func_t) (wait_queue_t *wait, unsigned mode, int flags, void *key);
int default_wake_function(wait_queue_t *wait, unsigned mode, int flags, void *key);
(3) åˆå§‹åŒ–ç­‰å¾…ä»»åŠ¡</p>

<p>#define DEFINE_WAIT(name) DEFINE_WAIT_FUNC(name, autoremove_wake_function)</p>

<p>#define DEFINE_WAIT_FUNC(name, function)    <br />
    wait_queue_t name = {    <br />
        .private = current,    <br />
        .func = function,    <br />
        .task_list = LIST_HEAD_INIT((name).task_list),    <br />
    }</p>

<p>int autoremove_wake_function(wait_queue_t <em>wait, unsigned mode, int sync, void *key)
{
    int ret = default_wake_function(wait, mode, sync, key); /</em> é»˜è®¤çš„å”¤é†’å‡½æ•° */</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (ret)
    list_del_init(&amp;wait-&gt;task_list); /* ä»ç­‰å¾…é˜Ÿåˆ—ä¸­åˆ é™¤ */
 
return ret; }
</code></pre></div></div>

<p>int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags, void *key)
{
    return try_to_wake_up(curr-&gt;private, mode, wake_flags);
}
try_to_wake_up()é€šè¿‡æŠŠè¿›ç¨‹çš„çŠ¶æ€è®¾ç½®ä¸ºTASK_RUNNINGï¼Œå¹¶æŠŠè¿›ç¨‹æ’å…¥CPUè¿è¡Œé˜Ÿåˆ—ï¼Œæ¥å”¤é†’ç¡çœ çš„è¿›ç¨‹ã€‚</p>

<p>(4) æŠŠç­‰å¾…ä»»åŠ¡æ’å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—ä¸­</p>

<p>è·å–sockçš„ç­‰å¾…é˜Ÿåˆ—ã€‚</p>

<p>static inline wait_queue_head_t *sk_sleep(struct sock *sk)
{
    BUILD_BUG_ON(offsetof(struct socket_wq, wait) != 0);
    return &amp;rcu_dereference_raw(sk-&gt;sk_wq)-&gt;wait;
}
æŠŠç­‰å¾…ä»»åŠ¡åŠ å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—ä¸­ï¼ŒåŒæ—¶è®¾ç½®å½“å‰è¿›ç¨‹çš„çŠ¶æ€ï¼ŒTASK_INTERRUPTIBLEæˆ–TASK_UNINTERRUPTIBLEã€‚</p>

<p>void prepare_to_wait(wait_queue_head_t <em>q, wait_queue_t *wait, int state)
{
    unsigned long flags;
    wait-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE; /</em> å¯ä»¥åŒæ—¶å”¤é†’å¤šä¸ªç­‰å¾…è¿›ç¨‹ */</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spin_lock_irqsave(&amp;q-&gt;lock, flags);
 
if (list_empty(&amp;wait-&gt;task_list))
    __add_wait_queue(q, wait); /* æŠŠç­‰å¾…ä»»åŠ¡åŠ å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—çš„å¤´éƒ¨ï¼Œä¼šæœ€å…ˆè¢«å”¤é†’ */
 
set_current_state(state); /* è®¾ç½®è¿›ç¨‹çš„çŠ¶æ€ */
 
spin_unlock_irqrestore(&amp;q-&gt;lock, flags); } prepare_to_wait()å’Œprepare_to_wait_exclusive()éƒ½æ˜¯ç”¨æ¥æŠŠç­‰å¾…ä»»åŠ¡åŠ å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—ä¸­ï¼Œä¸åŒä¹‹å¤„åœ¨äº
</code></pre></div></div>

<p>ä½¿ç”¨prepare_to_wait_exclusive()æ—¶ï¼Œä¼šåœ¨ç­‰å¾…ä»»åŠ¡ä¸­æ·»åŠ WQ_FLAG_EXCLUSIVEæ ‡å¿—ï¼Œè¡¨ç¤ºä¸€æ¬¡åªèƒ½</p>

<p>å”¤é†’ä¸€ä¸ªç­‰å¾…ä»»åŠ¡ï¼Œç›®çš„æ˜¯ä¸ºäº†é¿å…æƒŠç¾¤ç°è±¡ã€‚</p>

<p>void prepare_to_wait_exclusive(wait_queue_head_t *q, wait_queue_t *wait, int state)
{
    unsigned long flags;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* è¿™ä¸ªæ ‡å¿—è¡¨ç¤ºä¸€æ¬¡åªå”¤é†’ä¸€ä¸ªç­‰å¾…ä»»åŠ¡ï¼Œé¿å…æƒŠç¾¤ç°è±¡ */
wait-&gt;flags |= WQ_FLAG_EXCLUSIVE;
 
spin_lock_irqsave(&amp;q-&gt;lock, flags);
 
if (list_empty(&amp;wait-&gt;task_list))
    __add_wait_queue_tail(q, wait); /* æŠŠæ­¤ç­‰å¾…ä»»åŠ¡åŠ å…¥åˆ°ç­‰å¾…é˜Ÿåˆ—å°¾éƒ¨ */
 
set_current_state(state); /* è®¾ç½®å½“å‰è¿›ç¨‹çš„çŠ¶æ€ */
 
spin_unlock_irqrestore(&amp;q-&gt;lock, flags); }
</code></pre></div></div>

<p>static inline void __add_wait_queue_tail(wait_queue_head_t *head, wait_queue_t *new)
{
    list_add_tail(&amp;new-&gt;task_list, &amp;head-&gt;task_list);
}</p>

<p>#define set_current_state(state_value)    <br />
    set_mb(current-&gt;state, (state_value))
(5) åˆ é™¤ç­‰å¾…ä»»åŠ¡</p>

<p>ä»ç­‰å¾…é˜Ÿåˆ—ä¸­åˆ é™¤ç­‰å¾…ä»»åŠ¡ï¼ŒåŒæ—¶æŠŠç­‰å¾…è¿›ç¨‹çš„çŠ¶æ€ç½®ä¸ºå¯è¿è¡ŒçŠ¶æ€ï¼Œå³TASK_RUNNINGã€‚</p>

<p>/**</p>
<ul>
  <li>finish_wait - clean up after waiting in a queue</li>
  <li>@q: waitqueue waited onï¼Œç­‰å¾…é˜Ÿåˆ—å¤´</li>
  <li>@wait: wait descriptorï¼Œç­‰å¾…ä»»åŠ¡
 *</li>
  <li>Sets current thread back to running state and removes the wait</li>
  <li>
    <p>descriptor from the given waitqueue if still queued.
 */
void finish_wait(wait_queue_head_t *q, wait_queue_t *wait)
{
 unsigned long flags;
 __set_current_state(TASK_RUNNING);</p>

    <p>if (! list_empty_careful(&amp;wait-&gt;task_list)) {
     spin_lock_irqsave(&amp;q-&gt;lock, flags);</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> list_del_init(&amp;wait-&gt;task_list); /* ä»ç­‰å¾…é˜Ÿåˆ—ä¸­åˆ é™¤ */
 
 spin_unlock_irqrestore(&amp;q-&gt;lock, flags);  } } connectç­‰å¾… (1) ç¡çœ 
</code></pre></div>    </div>
  </li>
</ul>

<p>connect()çš„è¶…æ—¶æ—¶é—´ä¸ºsk-&gt;sk_sndtimeoï¼Œåœ¨sock_init_data()ä¸­åˆå§‹åŒ–ä¸ºMAX_SCHEDULE_TIMEOUTï¼Œ</p>

<p>è¡¨ç¤ºæ— é™ç­‰å¾…ï¼Œå¯ä»¥é€šè¿‡SO_SNDTIMEOé€‰é¡¹æ¥ä¿®æ”¹ã€‚</p>

<p>static long inet_wait_for_connect(struct sock <em>sk, long timeo, int writebias)
{
    DEFINE_WAIT(wait);  /</em> åˆå§‹åŒ–ç­‰å¾…ä»»åŠ¡ */</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* æŠŠç­‰å¾…ä»»åŠ¡åŠ å…¥åˆ°socketçš„ç­‰å¾…é˜Ÿåˆ—å¤´éƒ¨ï¼ŒæŠŠè¿›ç¨‹çš„çŠ¶æ€è®¾ä¸ºTASK_INTERRUPTIBLE */
prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);
sk-&gt;sk_write_pending += writebias;
 
/* Basic assumption: if someone sets sk-&gt;sk_err, he _must_ change state of the socket
 * from TCP_SYN_*. Connect() does not allow to get error notifications without closing
 * the socket.
 */
 
/* å®Œæˆä¸‰æ¬¡æ¡æ‰‹åï¼ŒçŠ¶æ€å°±ä¼šå˜ä¸ºTCP_ESTABLISHEDï¼Œä»è€Œé€€å‡ºå¾ªç¯ */
while ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
    release_sock(sk); /* ç­‰ä¸‹è¦ç¡è§‰äº†ï¼Œå…ˆé‡Šæ”¾é” */
 
    /* è¿›å…¥ç¡çœ ï¼Œç›´åˆ°è¶…æ—¶æˆ–æ”¶åˆ°ä¿¡å·ï¼Œæˆ–è€…è¢«I/Oäº‹ä»¶å¤„ç†å‡½æ•°å”¤é†’ã€‚
     * 1. å¦‚æœæ˜¯æ”¶åˆ°ä¿¡å·é€€å‡ºçš„ï¼Œtimeoä¸ºå‰©ä½™çš„jiffiesã€‚
     * 2. å¦‚æœä½¿ç”¨äº†SO_SNDTIMEOé€‰é¡¹ï¼Œè¶…æ—¶é€€å‡ºåï¼Œtimeoä¸º0ã€‚
     * 3. å¦‚æœæ²¡æœ‰ä½¿ç”¨SO_SNDTIMEOé€‰é¡¹ï¼Œtimeoä¸ºæ— ç©·å¤§ï¼Œå³MAX_SCHEDULE_TIMEOUTï¼Œ
     *      é‚£ä¹ˆè¿”å›å€¼ä¹Ÿæ˜¯è¿™ä¸ªï¼Œè€Œè¶…æ—¶æ—¶é—´ä¸å®šã€‚ä¸ºäº†æ— é™é˜»å¡ï¼Œéœ€è¦ä¸Šé¢çš„whileå¾ªç¯ã€‚
     */
    timeo = schedule_timeout(timeo); 
 
    lock_sock(sk); /* è¢«å”¤é†’åé‡æ–°ä¸Šé” */
 
    /* å¦‚æœè¿›ç¨‹æœ‰å¾…å¤„ç†çš„ä¿¡å·ï¼Œæˆ–è€…ç¡çœ è¶…æ—¶äº†ï¼Œé€€å‡ºå¾ªç¯ï¼Œä¹‹åä¼šè¿”å›é”™è¯¯ç  */
    if (signal_pending(current) || !timeo)
        break;
 
    /* ç»§ç»­ç¡çœ å§ */
    prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);
}
 
/* ç­‰å¾…ç»“æŸæ—¶ï¼ŒæŠŠç­‰å¾…è¿›ç¨‹ä»ç­‰å¾…é˜Ÿåˆ—ä¸­åˆ é™¤ï¼ŒæŠŠå½“å‰è¿›ç¨‹çš„çŠ¶æ€è®¾ä¸ºTASK_RUNNING */
finish_wait(sk_sleep(sk), &amp;wait);
sk-&gt;sk_write_pending -= writebias;
return timeo; }  (2) å”¤é†’
</code></pre></div></div>

<p>ä¸‰æ¬¡æ¡æ‰‹ä¸­ï¼Œå½“å®¢æˆ·ç«¯æ”¶åˆ°SYNACKã€å‘å‡ºACKåï¼Œè¿æ¥å°±æˆåŠŸå»ºç«‹äº†ã€‚</p>

<p>æ­¤æ—¶è¿æ¥çš„çŠ¶æ€ä»TCP_SYN_SENTæˆ–TCP_SYN_RECVå˜ä¸ºTCP_ESTABLISHEDï¼Œsockçš„çŠ¶æ€å‘ç”Ÿå˜åŒ–ï¼Œ</p>

<p>ä¼šè°ƒç”¨sock_def_wakeup()æ¥å¤„ç†è¿æ¥çŠ¶æ€å˜åŒ–äº‹ä»¶ï¼Œå”¤é†’è¿›ç¨‹ï¼Œconnect()å°±èƒ½æˆåŠŸè¿”å›äº†ã€‚</p>

<p>sock_def_wakeup()çš„å‡½æ•°è°ƒç”¨è·¯å¾„å¦‚ä¸‹ï¼š</p>

<p>tcp_v4_rcv</p>

<p>tcp_v4_do_rcv</p>

<p>tcp_rcv_state_process</p>

<p>tcp_rcv_synsent_state_process</p>

<p>tcp_finish_connect</p>

<p>sock_def_wakeup</p>

<p>wake_up_interruptible_all</p>

<p>__wake_up</p>

<p>__wake_up_common</p>

<p>void tcp_finish_connect(struct sock <em>sk, struct sk_buff *skb)
{
    â€¦
    tcp_set_state(sk, TCP_ESTABLISHED); /</em> åœ¨è¿™é‡Œè®¾ç½®ä¸ºè¿æ¥å·²å»ºç«‹çš„çŠ¶æ€ <em>/
    â€¦
    if (! sock_flag(sk, SOCK_DEAD)) {
        sk-&gt;sk_state_change(sk); /</em> æŒ‡å‘sock_def_wakeupï¼Œä¼šå”¤é†’è°ƒç”¨connect()çš„è¿›ç¨‹ï¼Œå®Œæˆè¿æ¥çš„å»ºç«‹ <em>/
        sk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT); /</em> å¦‚æœä½¿ç”¨äº†å¼‚æ­¥é€šçŸ¥ï¼Œåˆ™å‘é€SIGIOé€šçŸ¥è¿›ç¨‹å¯å†™ */
    }
}
acceptç­‰å¾…
(1) ç¡çœ </p>

<p>accept()è¶…æ—¶æ—¶é—´ä¸ºsk-&gt;sk_rcvtimeoï¼Œåœ¨sock_init_data()ä¸­åˆå§‹åŒ–ä¸ºMAX_SCHEDULE_TIMEOUTï¼Œè¡¨ç¤ºæ— é™ç­‰å¾…ã€‚</p>

<p>/* Wait for an incoming connection, avoid race conditions.</p>
<ul>
  <li>
    <p>This must be called with the socket locked.
 <em>/
static int inet_csk_wait_for_connect(struct sock *sk, long timeo)
{
 struct inet_connection_sock *icsk = inet_csk(sk);
 DEFINE_WAIT(wait); /</em> åˆå§‹åŒ–ç­‰å¾…ä»»åŠ¡ */
 int err;</p>

    <p>for (; ;) {
     /* æŠŠç­‰å¾…ä»»åŠ¡åŠ å…¥åˆ°socketçš„ç­‰å¾…é˜Ÿåˆ—ä¸­ï¼ŒæŠŠè¿›ç¨‹çŠ¶æ€è®¾ç½®ä¸ºTASK_INTERRUPTIBLE */
     prepare_to_wait_exclusive(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> release_sock(sk); /* ç­‰ä¸‹å¯èƒ½è¦ç¡è§‰äº†ï¼Œå…ˆé‡Šæ”¾ */
 
 if (reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue)) /* å¦‚æœå…¨è¿æ¥é˜Ÿåˆ—ä¸ºç©º */
     timeo = schedule_timeout(timeo); /* è¿›å…¥ç¡çœ ç›´åˆ°è¶…æ—¶æˆ–æ”¶åˆ°ä¿¡å·ï¼Œæˆ–è¢«IOäº‹ä»¶å¤„ç†å‡½æ•°å”¤é†’ */
 
 lock_sock(sk); /* é†’æ¥åé‡æ–°ä¸Šé” */
 err = 0;
 /* å…¨è¿æ¥é˜Ÿåˆ—ä¸ä¸ºç©ºæ—¶ï¼Œè¯´æ˜æœ‰æ–°çš„è¿æ¥å»ºç«‹äº†ï¼ŒæˆåŠŸè¿”å› */
 if (! reqsk_queue_empty(&amp;icsk-&gt;icsk_accept_queue))
     break;
 
 err = -EINVAL;
 if (sk-&gt;sk_state != TCP_LISTEN) /* å¦‚æœsockä¸å¤„äºç›‘å¬çŠ¶æ€äº†ï¼Œé€€å‡ºï¼Œè¿”å›é”™è¯¯ç  */
     break;
 
 err = sock_intr_errno(timeo);
 
 /* å¦‚æœè¿›ç¨‹æœ‰å¾…å¤„ç†çš„ä¿¡å·ï¼Œé€€å‡ºï¼Œè¿”å›é”™è¯¯ç ã€‚
  * å› ä¸ºtimeoé»˜è®¤ä¸ºMAX_SCHEDULE_TIMEOUTï¼Œæ‰€ä»¥erré»˜è®¤ä¸º-ERESTARTSYSã€‚
  * æ¥ä¸‹æ¥ä¼šé‡æ–°è°ƒç”¨æ­¤å‡½æ•°ï¼Œæ‰€ä»¥accept()ä¾ç„¶é˜»å¡ã€‚
  */
 if (signal_pending(current))
     break; 
 
 err = -EAGAIN;
 if (! timeo) /* å¦‚æœç­‰å¾…è¶…æ—¶ï¼Œå³è¶…è¿‡ç”¨æˆ·è®¾ç½®çš„sk-&gt;sk_rcvtimeoï¼Œé€€å‡º */
     break;  }
</code></pre></div>    </div>

    <p>/* ä»ç­‰å¾…é˜Ÿåˆ—ä¸­åˆ é™¤ç­‰å¾…ä»»åŠ¡ï¼ŒæŠŠç­‰å¾…è¿›ç¨‹çš„çŠ¶æ€è®¾ä¸ºTASK_RUNNING */
 finish_wait(sk_sleep(sk), &amp;wait);
 return err;
}
(2) å”¤é†’</p>
  </li>
</ul>

<p>ä¸‰æ¬¡æ¡æ‰‹ä¸­ï¼Œå½“æœåŠ¡å™¨ç«¯æ¥æ”¶åˆ°ACKå®Œæˆè¿æ¥å»ºç«‹çš„æ—¶å€™ï¼Œä¼šæŠŠæ–°çš„è¿æ¥é“¾å…¥å…¨è¿æ¥é˜Ÿåˆ—ä¸­ï¼Œ</p>

<p>ç„¶åå”¤é†’ç›‘å¬socketä¸Šçš„ç­‰å¾…è¿›ç¨‹ï¼Œaccept()å°±èƒ½æˆåŠŸè¿”å›äº†ã€‚</p>

<p>ä¸‰æ¬¡æ¡æ‰‹æ—¶ï¼Œå½“æ”¶åˆ°å®¢æˆ·ç«¯çš„ACKåï¼Œç»è¿‡å¦‚ä¸‹è°ƒç”¨ï¼š</p>

<p>tcp_v4_rcv</p>

<p>tcp_v4_do_rcv</p>

<p>tcp_child_process</p>

<p>sock_def_readable</p>

<p>wake_up_interruptible_sync_poll</p>

<p>__wake_up_sync_key</p>

<p>__wake_up_common</p>

<p>æœ€ç»ˆè°ƒç”¨æˆ‘ä»¬ç»™ç­‰å¾…ä»»åŠ¡æ³¨å†Œçš„å”¤é†’å‡½æ•°ã€‚</p>

<p>æˆ‘ä»¬æ¥çœ‹ä¸‹accept()æ˜¯å¦‚ä½•é¿å…æƒŠç¾¤ç°è±¡çš„ã€‚</p>

<p>static void __wake_up_common(wait_queue_head_t *q, unsigned int mode, int nr_exclusive,
                             int wake_flags, void *key)
{
    wait_queue_t *curr, *next;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>list_for_each_entry_safe(curr, next, &amp;q-&gt;task_list, task_list) {
    unsigned flags = curr-&gt;flags;
 
    if (curr-&gt;func(curr, mode, wake_flags, key) &amp;&amp; (flags &amp; WQ_FLAG_EXCLUSIVE)
        !--nr_exclusive)
        break;
} } åˆå§‹åŒ–ç­‰å¾…ä»»åŠ¡æ—¶ï¼Œflags |= WQ_FLAG_EXCLUSIVEã€‚ä¼ å…¥çš„nr_exclusiveä¸º1ï¼Œè¡¨ç¤ºåªå…è®¸å”¤é†’ä¸€ä¸ªç­‰å¾…ä»»åŠ¡ã€‚
</code></pre></div></div>

<p>æ‰€ä»¥è¿™é‡Œåªä¼šå”¤é†’ä¸€ä¸ªç­‰å¾…çš„è¿›ç¨‹ï¼Œä¸ä¼šå¯¼è‡´æƒŠç¾¤ç°è±¡</p>
:ET