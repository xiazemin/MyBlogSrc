I"î<p>https://github.com/gin-gonic/gin
https://github.com/julienschmidt/httprouter
https://github.com/julienschmidt/go-http-routing-benchmark</p>

<!-- more -->
<p>http.ServeMux
http.ServeMux æ˜¯æ ‡å‡†åº“è‡ªå¸¦çš„URLè·¯ç”±. å…¶å®ç°æ¯”è¾ƒç®€å•, æ¯ä¸ªè·¯å¾„æ³¨å†Œåˆ°ä¸€ä¸ªå­—å…¸é‡Œé¢, æŸ¥æ‰¾çš„æ—¶å€™, éå†å­—å…¸, å¹¶åŒ¹é…æœ€é•¿è·¯å¾„.</p>

<p>package http</p>

<p>// å›è°ƒå‡½æ•°æ¥å£
type HandlerFunc func(ResponseWriter, *Request)</p>

<p>// è·¯ç”±ç»“æ„
type ServeMux struct {
	mu    sync.RWMutex
	m     map[string]muxEntry // è·¯ç”±æŸ¥æ‰¾å­—å…¸
	hosts bool // whether any patterns contain hostnames
}</p>

<p>// æ³¨å†Œè·¯ç”±
func (mux *ServeMux) Handle(pattern string, handler Handler)</p>

<p>// è·¯ç”±æŸ¥æ‰¾é€»è¾‘
func (mux *ServeMux) match(path string) (h Handler, pattern string) {
	var n = 0
	for k, v := range mux.m {
		if !pathMatch(k, path) {
			continue
		}
		if h == nil || len(k) &gt; n {
			n = len(k)
			h = v.h
			pattern = v.pattern
		}
	}
	return
}</p>

<p>func pathMatch(pattern, path string) bool {
	if len(pattern) == 0 {
		// should not happen
		return false
	}
	n := len(pattern)
	if pattern[n-1] != â€˜/â€™ {
		return pattern == path
	}
	return len(path) &gt;= n &amp;&amp; path[0:n] == pattern
}
http.ServeMuxçš„å±€é™æ€§:</p>

<p>ä¸èƒ½å¤Ÿæ ¹æ®è¯·æ±‚æ–¹æ³•è·¯ç”±
å¤„ç†æ¯æ¬¡è¯·æ±‚, ä¼šéå†ä¸€éå­—å…¸, æ€§èƒ½ä¸å¥½
ä¸æ”¯æŒåŠ¨æ€è·¯ç”±, URLé‡Œé¢çš„è·¯å¾„å‚æ•°éœ€è¦è‡ªå·±è§£æPathå»åš
æ ¹æ®æœ€é•¿åŒ¹é…æ¥åˆ†å‘, å­˜åœ¨ä¸€ä¸ªè¯·æ±‚æœ‰æ½œåœ¨å¤šä¸ªæ¥æ”¶è€…çš„æƒ…å†µ, å¯èƒ½é€ æˆå›°æƒ‘, ä¾‹:</p>

<p>userMux := http.NewServeMux()
  userMux.HandleFunc(â€œ/â€, userDefaultHandler) // handle /user/*
  userMux.HandleFunc(â€œ/listâ€, userListHandler) // handle /user/list</p>

<p>mux := http.NewServeMux()
  mux.HandleFunc(â€œ/userâ€, evilUserHandler)
  mux.Handle(â€œ/user/â€, userMux)
  mux.HandleFunc(â€œ/user/listâ€, evilUserListHander) // override previous handler</p>

<p>GET /user =&gt; evilUserHandler
  GET /user/ =&gt; userDefaultHandler
  GET /user/yangchen =&gt; userDefaultHandler
  GET /user/list =&gt; evilUserListHander
httprouter
ç›®å‰é¡¹ç›®ä½¿ç”¨çš„æ˜¯gin, å…¶è·¯ç”±é‡‡ç”¨äº†httprouter. ç›¸å¯¹äº http.ServeMux, httprouteræ”¯æŒ:</p>

<p>æ ¹æ®æ–¹æ³•æ³¨å†Œè·¯ç”±
æ”¯æŒåŠ¨æ€è·¯ç”±
æˆ‘ä»¬æ¥çœ‹ä¸‹å…¶è·¯ç”±è§£æå®ç°:</p>

<p>package httprouter</p>

<p>// å›è°ƒå‡½æ•°æ¥å£, æä¾›äº†Paramså‚æ•°
type Handle func(http.ResponseWriter, *http.Request, Params)</p>

<p>// æ³¨å†Œè·¯ç”±, å¤šäº†methodå‚æ•°
func (r *Router) Handle(method, path string, handle Handle)</p>

<p>// è·¯ç”±ç»“æ„
type Router struct {
	trees map[string]*node // è·¯ç”±æŸ¥æ‰¾æ ‘
    â€¦
}</p>

<p>// èŠ‚ç‚¹ç»“æ„
type node struct {
    path      string
    wildChild bool
    nType     nodeType
    maxParams uint8
    indices   string
    children  []*node
    handle    Handle
    priority  uint32
}</p>

<p>// è·¯ç”±æŸ¥æ‰¾é€»è¾‘
func (n *node) getValue(path string) (handle Handle, p Params, tsr bool) {
walk: // outer loop for walking the tree
    for {
        if len(path) &gt; len(n.path) {
            if path[:len(n.path)] == n.path {
                path = path[len(n.path):]
                â€¦
                c := path[0]
                for i := 0; i &lt; len(n.indices); i++ {
                    if c == n.indices[i] {
                        n = n.children[i]
                        continue walk
                    }
                }
                â€¦
        } else if path == n.path {
            // We should have reached the node containing the handle.
            // Check if this node has a handle registered.
            if handle = n.handle; handle != nil {
                return
            }
            â€¦
        }
    }
    â€¦
}
ä»è·¯ç”±å®ç°ä¸Šæ¥çœ‹, ç”¨äº† radix tree çš„ç»“æ„, æŸ¥æ‰¾çš„æ—¶å€™æ›´åŠ é«˜æ•ˆ; åœ¨é‡åˆ°åŒ¹é…çš„æ—¶å€™ç«‹å³è¿”å›, ä¸åƒhttp.ServeMuxéœ€è¦éå†å†³è®®.</p>

<p>é—®é¢˜
ç”±äºå…¶ç²¾ç¡®è·¯ç”±, å› æ­¤æ²¡æ³•æŠŠéƒ¨åˆ†è·¯ç”±åŠŸèƒ½åˆ†å‘åˆ°å¦å¤–ä¸€ä¸ªè·¯ç”±å™¨ä¸­. ä¹Ÿå°±æ˜¯è¯´, ä¸€æ—¦ä¸Šäº†è½¦, å°±ä¸‹ä¸æ¥äº†.</p>

<p>ä¾‹å¦‚ net/http/pprof.Index è‡ªå·±å®ç°äº†å­è·¯ç»çš„æ´¾å‘åŠŸèƒ½, å°±å¾ˆéš¾åµŒå…¥åˆ° httprouter ä¸­å».</p>

<p>åŒä¸€è·¯å¾„ä¸‹ä¸æ”¯æŒå›ºå®šè·¯å¾„å’Œå‚æ•°è·¯å¾„å…±å­˜, ä¾‹</p>

<p>r.GET(â€œ/listâ€, listHandler)
r.GET(â€œ/:methodâ€, dispatchHandler)
// runtime panic
å‚è§è¿™é‡Œ.</p>

<p>è™½ç„¶è¿™æ˜¯ç‰¹æ€§è€Œä¸æ˜¯BUG, ä½†æ˜¯ä½¿ç”¨è¿‡ç¨‹ä¸­ç¡®æœ‰ä¸çˆ½.</p>

<p>gin
gin çš„è·¯ç”±å™¨æ˜¯åŸºäº httprouter çš„. æå‡ ä¸ªæ¯”è¾ƒæœ‰ç”¨çš„åŠŸèƒ½:</p>

<p>é“¾å¼, æ’ä»¶åŒ–çš„ä¸­é—´å±‚(MiddleWare)æ¨¡å—æ”¯æŒ, å¾ˆæ–¹ä¾¿å¢åŠ æ—¥å¿—/ç›‘æ§/é™æµç­‰é€šç”¨åŠŸèƒ½
æ”¯æŒè·¯ç”±ç»„(RouterGroup)çš„å†™æ³•, ä»è€Œæ³¨å†ŒHTTPæœåŠ¡æ¨¡å—ä¸éœ€è¦å…³å¿ƒæœåŠ¡çš„ç»å¯¹è·¯å¾„, æ–¹ä¾¿ç»„åˆ
æ•°æ®ç»‘å®š(Binding)ç­‰å¸®åŠ©æ–¹æ³•, å½“ç„¶è¿™äº›å’Œæˆ‘ä»¬è¿™é‡Œä¸»è¦è®¨è®ºçš„è·¯ç”±åŠŸèƒ½å°±æ‰¯å¾—æ¯”è¾ƒè¿œäº†
çœ‹ä¸ªä¾‹å­</p>

<p>r := gin.New()
g := r.Group(â€œ/userâ€)
// æ¯ä¸ªè·¯ç”±ç»„å¯ä»¥å…±ç”¨ä¸­é—´å±‚
g.Use(ThrottleHanler)
// æ³¨å†Œapiç›¸å…³æ–¹æ³•
g.GET(â€œ/listâ€, â€¦)
// â€¦
beego
beegoæ˜¯å›½äººå¼€å‘çš„Webå¼€å‘æ¡†æ¶, åœ¨go-http-routing-benchmarkä¸­, å…¶è·¯ç”±æ€§èƒ½ä¼¼ä¹è¡¨ç°ä¸ä½³, æˆ‘ä»¬æ¥æ·±ç©¶ä¸‹åŸå› .</p>

<p>çœ‹ä¸€ä¸‹å…¶è·¯ç”±å®ç°, ä¹Ÿæ˜¯ä½¿ç”¨äº†æŸ¥æ‰¾æ ‘, ä½†æ˜¯å¯¹å­èŠ‚ç‚¹æŸ¥æ‰¾æ—¶, éœ€è¦éå†, è€Œhttprouterçš„æ¯ä¸ªèŠ‚ç‚¹, ä¿å­˜äº†å¯¹äºå…¶å­èŠ‚ç‚¹çš„è·¯ç”±ä¿¡æ¯node.indices, æŸ¥æ‰¾ä¸Šè‡ªç„¶æ›´å¿«. æ­¤å¤–, beegoè·¯ç”±æŸ¥æ‰¾æ–¹æ³•ä½¿ç”¨äº†é€’å½’çš„æ–¹å¼(Tree.match), è€Œhttprouteråœ¨ä¸€ä¸ªæ‰§è¡Œå¾ªç¯(node.getValue)é‡Œå°±å¯ä»¥æå®š, è‡ªç„¶æ•ˆç‡æ›´é«˜.</p>

<p>// è·¯ç”±ç»“æ„
type ControllerRegister struct {
	routers      map[string]*Tree // è·¯ç”±æŸ¥æ‰¾æ ‘
	â€¦
}</p>

<p>// èŠ‚ç‚¹ç»“æ„
// Tree has three elements: FixRouter/wildcard/leaves
// fixRouter sotres Fixed Router
// wildcard stores params
// leaves store the endpoint information
type Tree struct {
	//prefix set for static router
	prefix string
	//search fix route first
	fixrouters []<em>Tree
	//if set, failure to match fixrouters search then search wildcard
	wildcard *Tree
	//if set, failure to match wildcard search
	leaves []</em>leafInfo
}</p>

<p>// è·¯ç”±æŸ¥æ‰¾é€»è¾‘
func (t *Tree) match(pattern string, wildcardValues []string, ctx *context.Context) (runObject interface{}) {
    â€¦
    for _, subTree := range t.fixrouters {
        if subTree.prefix == seg {
            runObject = subTree.match(pattern, wildcardValues, ctx)
            if runObject != nil {
                break
            }
        }
    }
    â€¦
}
å½“ç„¶, æ‹¿httprouterä¸€ä¸ªçº¯è·¯ç”±åº“, å’Œbeegoè¿™æ ·ä¸€ä¸ªåŠŸèƒ½ä¸°å¯Œçš„MVCå¼€å‘æ¡†æ¶, æ˜¯ä¸å…¬å¹³çš„.</p>

<p>beegoè·¯ç”±æ¨¡å—å’ŒControllerè”ç³»ç´§å¯†, æä¾›äº†æ›´åŠ ä¸°å¯Œçš„åŠŸèƒ½, å¦‚å¤§å°å†™è¯†åˆ«, è·¯ç”±è¿‡æ»¤å™¨ç­‰. åˆ—ä¸¤ç‚¹çœ‹ä¸Šå»æŒºæœ‰ç”¨çš„ç‰¹æ€§:</p>

<p>è·¯ç”±è§„åˆ™æ”¯æŒæ­£åˆ™, å¦‚</p>

<p>/api/:id([0-9]+
è·¯å¾„åç¼€å‚æ•°ä¹Ÿä¼šæä¾›, è€Œä¸æ˜¯è·¯ç”±å¤±æ•ˆ, ä¾‹å­:</p>

<p># è·¯ç”±è§„åˆ™
  /user/:name =&gt; handler</p>

<p># è¯·æ±‚è·¯å¾„
  /user/alice/2016/01/01</p>

<p>httprouter =&gt; 404
  beego =&gt; handler // ctx.Input.Params = {0: 2016, 1: 01, 2: 02}
æ€»ç»“
å¯¹äºè·¯ç”±é€‰æ‹©, å¤Ÿç”¨å°±å¥½, http.ServeMux ä»åŠŸèƒ½ä»¥åŠæ€§èƒ½ä¸Šéƒ½ä¸å¤Ÿä»¤äººæ»¡æ„, å»ºè®®ç”¨ httprouter æ›¿ä»£. å¦‚æœåšåç«¯APIæœåŠ¡, ginæŒºè¶æ‰‹, åŠŸèƒ½åŸºæœ¬å¤Ÿç”¨äº†. beego çš„è·¯ç”±, æ˜¯ä¸ºäº†å…¶MVCæ¡†æ¶æœåŠ¡çš„, ä¸æ–¹ä¾¿å•ç‹¬æ‹¿å‡ºæ¥ç”¨.</p>

<p>å‚è€ƒè¿æ¥
gin
httprouter
go-http-routing-benchmark
radix_tree</p>
:ET