I"à<p>sync.Poolæ˜¯ä¸€ä¸ªå¯ä»¥å­˜æˆ–å–çš„ä¸´æ—¶å¯¹è±¡æ± ã€‚å¯¹å¤–æä¾›Newã€Getã€Putç­‰APIï¼Œåˆ©ç”¨mutexæ”¯æŒå¤šçº¿ç¨‹å¹¶å‘ã€‚</p>

<p>ç›®æ ‡
sync.Poolè§£å†³ä»¥ä¸‹é—®é¢˜ï¼š</p>

<p>å¢åŠ ä¸´æ—¶å¯¹è±¡çš„ç”¨å¤ç”¨ç‡ï¼Œå‡å°‘GCè´Ÿæ‹…
é€šè¿‡å¯¹è±¡çš„å¤ç”¨ï¼Œå‡å°‘å†…å­˜ç”³è¯·å¼€é”€ï¼Œæœ‰åˆ©äºæé«˜ä¸€éƒ¨åˆ†æ€§èƒ½
<!-- more -->
å®ç°
è¿™ä¸€éƒ¨åˆ†å›ç­”å¦‚ä½•å®ç°çš„é—®é¢˜ã€‚</p>

<p>å…³äºäº†è§£å®ç°ï¼Œæœ€å¥½çš„åŠæ³•å°±æ˜¯çœ‹ä»£ç ã€‚</p>

<p>æè¿°
type Pool struct {
    noCopy noCopy</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local     unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal
localSize uintptr        // size of the local array

// New optionally specifies a function to generate
// a value when Get would otherwise return nil.
// It may not be changed concurrently with calls to Get.
New func() interface{} } å„ä¸ªæˆå‘˜å«ä¹‰å¦‚ä¸‹ï¼š
</code></pre></div></div>

<p>noCopyï¼š é˜²æ­¢sync.Poolè¢«å¤åˆ¶</p>

<p>localï¼š poolLocalæ•°ç»„çš„æŒ‡é’ˆ</p>

<p>localSizeï¼š poolLocalæ•°ç»„å¤§å°</p>

<p>Newï¼š å‡½æ•°æŒ‡é’ˆç”³è¯·å…·ä½“çš„å¯¹è±¡ï¼Œä¾¿äºç”¨æˆ·å®šåˆ¶å„ç§ç±»å‹çš„å¯¹è±¡</p>

<p>// Local per-P Pool appendix.
type poolLocalInternal struct {
    private interface{}   // Can be used only by the respective P.
    shared  []interface{} // Can be used by any P.
    Mutex                 // Protects shared.
}</p>

<p>type poolLocal struct {
    poolLocalInternal</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Prevents false sharing on widespread platforms with
// 128 mod (cache line size) = 0 .
pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte } privateï¼šprivateç§æœ‰æ± ï¼Œåªèƒ½è¢«å¯¹åº”Pä½¿ç”¨ï¼ˆè¯´æ˜ï¼šPæ˜¯æŒ‡goroutineæ‰§è¡Œæ‰€å ç”¨çš„å¤„ç†å™¨ï¼Œä¸‹åŒï¼‰
</code></pre></div></div>

<p>sharedï¼š sharedå…±äº«æ± ï¼Œèƒ½è¢«ä»»ä½•Pä½¿ç”¨</p>

<p>Mutexï¼š ä¿æŠ¤sharedå…±äº«æ± </p>

<p>padï¼špoolLocalç»“æ„ä½“ä¸­ç‰¹åˆ«å¢åŠ äº†padæˆå‘˜ï¼Œè¿™æ˜¯ä¸ºäº†é˜²æ­¢false sharingã€‚</p>

<p>æ“ä½œ
æ“ä½œåˆ†ä¸ºå››ç§ç±»å‹ï¼š</p>

<p>New
Get
Put
CleanUp
New
è¿™éƒ¨åˆ†ä¸»è¦è§£å†³é—®é¢˜ï¼šå¦‚ä½•åˆ›å»ºä¸€ä¸ªå…·ä½“å¯¹è±¡æ± ï¼Ÿ</p>

<p>å…·ä½“å‚è€ƒä»£ç å¦‚ä¸‹ï¼š</p>

<p>// Object Object
type Object struct {
    a int
    b int
}</p>

<p>var pool = sync.Pool{
    New: func() interface{} { return new(Object) },
}
Get
Getè§£å†³äº†å¦‚ä½•ä»å…·ä½“sync.Poolä¸­è·å–å¯¹è±¡çš„é—®é¢˜ã€‚</p>

<p>è·å–å¯¹è±¡æœ‰ä¸‰ä¸ªæ¥æºï¼š</p>

<p>privateæ± 
sharedæ± 
ç³»ç»Ÿçš„Heapå†…å­˜
è·å–å¯¹è±¡é¡ºåºæ˜¯å…ˆä»privateæ± è·å–ï¼Œå¦‚æœä¸æˆåŠŸåˆ™ä»sharedæ± è·å–ï¼Œå¦‚æœç»§ç»­ä¸æˆåŠŸï¼Œåˆ™ä»Heapä¸­ç”³è¯·ä¸€ä¸ªå¯¹è±¡ã€‚è¿™æ˜¯ä¸æ˜¯æœ‰ç†Ÿæ‚‰çš„å‘³é“ï¼Ÿåœ¨ä¸¤çº§cacheçš„æƒ…å†µä¸‹ï¼ŒCPUè·å–æ•°æ®ï¼Œå…ˆä»L1 cacheå¼€å§‹ï¼Œå†æ˜¯L2 cacheï¼Œ æ˜¯å†…å­˜ã€‚</p>

<p>å…·ä½“ä»£ç å®ç°å¦‚ä¸‹ï¼š</p>

<p>func (p *Pool) Get() interface{} {
    if race.Enabled {
        race.Disable()
    }
    l := p.pin() // ç»‘å®šprivateæ± å’ŒP
    x := l.private
    l.private = nil
    runtime_procUnpin() // å»ç»‘å®šprivateæ± å’ŒP
    if x == nil { //  privateæ± è·å–å¤±è´¥
        l.Lock()
        last := len(l.shared) - 1
        if last &gt;= 0 {
            x = l.shared[last] // ä»sharedæ± è·å–æœ€åä¸€ä¸ªå¯¹è±¡ 
            l.shared = l.shared[:last] // ä»sharedæ± åˆ é™¤æœ€åä¸€ä¸ªå¯¹è±¡
        }
        l.Unlock()
        if x == nil { 
            x = p.getSlow() // pidå¯¹åº”poolLocalæ²¡æœ‰è·å–æˆåŠŸï¼Œå¼€å§‹éå†æ•´ä¸ªpoolLocalæ•°ç»„
        }
    }
    if race.Enabled {
        race.Enable()
        if x != nil {
            race.Acquire(poolRaceAddr(x))
        }
    }
    if x == nil &amp;&amp; p.New != nil {
        x = p.New() // ä»heapç”³è¯·å¯¹è±¡
    }
    return x
}</p>

<p>func (p *Pool) getSlow() (x interface{}) {
    // See the comment in pin regarding ordering of the loads.
    size := atomic.LoadUintptr(&amp;p.localSize) // load-acquire
    local := p.local                         // load-consume
    // Try to steal one element from other procs.
    pid := runtime_procPin()
    runtime_procUnpin()
    for i := 0; i &lt; int(size); i++ { // éå†poolLocalæ•°ç»„
        l := indexLocal(local, (pid+i+1)%int(size)) // æ³¨æ„pid+i+1 è¿™æ ·å¯ä»¥ä»pid+1ä½ç½®å¼€å§‹æ•´ä¸ªéå†
        l.Lock()
        last := len(l.shared) - 1
        if last &gt;= 0 {
            x = l.shared[last]
            l.shared = l.shared[:last]
            l.Unlock()
            break
        }
        l.Unlock()
    }
    return x
}</p>

<p>// pin pins the current goroutine to P, disables preemption and returns poolLocal pool for the P.
// Caller must call runtime_procUnpin() when done with the pool.
func (p *Pool) pin() *poolLocal {
    pid := runtime_procPin()
    // In pinSlow we store to localSize and then to local, here we load in opposite order.
    // Since weâ€™ve disabled preemption, GC cannot happen in between.
    // Thus here we must observe local at least as large localSize.
    // We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).
    s := atomic.LoadUintptr(&amp;p.localSize) // load-acquire
    l := p.local                          // load-consume
    if uintptr(pid) &lt; s {
        return indexLocal(l, pid)
    }
    return p.pinSlow() // æ²¡æœ‰å¯¹åº”poolLocalï¼Œè¿›å…¥æ…¢è·¯å¾„å¤„ç†
}</p>

<p>func (p *Pool) pinSlow() *poolLocal {
    // Retry under the mutex.
    // Can not lock the mutex while pinned.
    runtime_procUnpin()
    allPoolsMu.Lock()
    defer allPoolsMu.Unlock()
    pid := runtime_procPin()
    // poolCleanup wonâ€™t be called while we are pinned.
    s := p.localSize
    l := p.local
    if uintptr(pid) &lt; s { // æ ¹æ®pidè·å–poolLocal
        return indexLocal(l, pid) 
    }
    if p.local == nil {
        allPools = append(allPools, p)
    }
    // If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.
    size := runtime.GOMAXPROCS(0)
    local := make([]poolLocal, size) // é‡æ–°åˆ†é…poolLocal
    atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[0])) // store-release
    atomic.StoreUintptr(&amp;p.localSize, uintptr(size))         // store-release
    return &amp;local[pid] // è¿”å›æ–°çš„poolLocal
}</p>

<p>æ€»ç»“Getä¸»è¦è¦ç‚¹å¦‚ä¸‹ï¼š</p>

<p>å…ˆä»æœ¬Pç»‘å®šçš„poolLocalè·å–å¯¹è±¡ï¼šå…ˆä»æœ¬poolLocalçš„privateæ± è·å–å¯¹è±¡ï¼Œå†ä»æœ¬poolLocalçš„sharedæ± è·å–å¯¹è±¡
ä¸Šä¸€æ­¥æ²¡æœ‰æˆåŠŸè·å–å¯¹è±¡ï¼Œå†ä»å…¶ä»–Pçš„sharedæ± è·å–å¯¹è±¡
ä¸Šä¸€æ­¥æ²¡æœ‰æˆåŠŸè·å–å¯¹è±¡ï¼Œåˆ™ä»Heapç”³è¯·å¯¹è±¡
Put
Putå®Œæˆå°†å¯¹è±¡æ”¾å›å¯¹è±¡æ± ã€‚</p>

<p>// Put adds x to the pool.
func (p *Pool) Put(x interface{}) {
    if x == nil {
        return
    }
    if race.Enabled {
        if fastrand()%4 == 0 {
            // Randomly drop x on floor.
            return
        }
        race.ReleaseMerge(poolRaceAddr(x))
        race.Disable()
    }
    l := p.pin() // ç»‘å®šprivateæ± å’ŒP
    if l.private == nil {
        l.private = x   // æ”¾å›privateæ± ä¸­
        x = nil
    }
    runtime_procUnpin() // å»ç»‘å®šprivateæ± å’ŒP
    if x != nil {
        l.Lock()
        l.shared = append(l.shared, x)  // æ”¾å›sharedæ± 
        l.Unlock()
    }
    if race.Enabled {
        race.Enable()
    }
}
ä¸Šé¢çš„ä»£ç æ€»ç»“å¦‚ä¸‹ï¼š</p>

<p>å¦‚æœpoolLocalInternalçš„privateä¸ºç©ºï¼Œåˆ™å°†å›æ”¶çš„å¯¹è±¡æ”¾åˆ°privateæ± ä¸­
å¦‚æœpoolLocalInternalçš„privateéç©ºï¼Œåˆ™å°†å›æ”¶çš„å¯¹è±¡æ”¾åˆ°sharedæ± ä¸­
CleanUp
CleanUpå®ç°
æ³¨å†ŒpoolCleanupå‡½æ•°ã€‚</p>

<p>func init() {
   runtime_registerPoolCleanup(poolCleanup)
}</p>

<p>poolCleanupå‡½æ•°å…·ä½“å®ç°ï¼Œ</p>

<p>func poolCleanup() {
    // This function is called with the world stopped, at the beginning of a garbage collection.
    // It must not allocate and probably should not call any runtime functions.
    // Defensively zero out everything, 2 reasons:
    // 1. To prevent false retention of whole Pools.
    // 2. If GC happens while a goroutine works with l.shared in Put/Get,
    //    it will retain whole Pool. So next cycle memory consumption would be doubled.
    for i, p := range allPools {
        allPools[i] = nil
        for i := 0; i &lt; int(p.localSize); i++ {
            l := indexLocal(p.local, i)
            l.private = nil
            for j := range l.shared {
                l.shared[j] = nil
            }
            l.shared = nil
        }
        p.local = nil
        p.localSize = 0
    }
    allPools = []*Pool{}
}
CleanUpæ—¶æœº
ä»€ä¹ˆæ—¶å€™è¿›è¡ŒCleanUpå›æ”¶å¯¹è±¡æ± ï¼Ÿåœ¨gcå¼€å§‹å‰ã€‚</p>

<p>å…·ä½“ä»£ç (ä»£ç æ–‡ä»¶ä¸ºruntime/mgc.go)å¦‚ä¸‹ï¼š</p>

<p>func gcStart(trigger gcTrigger) {
    â€¦ 
    // clearpools before we start the GC. If we wait they memory will not be
    // reclaimed until the next GC cycle.
    clearpools() // åœ¨è¿™é‡Œæ¸…ç†sync.Pool</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>work.cycles++

gcController.startCycle()
work.heapGoal = memstats.next_gc

// In STW mode, disable scheduling of user Gs. This may also
// disable scheduling of this goroutine, so it may block as
// soon as we start the world again.
if mode != gcBackgroundMode {
    schedEnableUser(false)
}
... } func clearpools() {
// clear sync.Pools
if poolcleanup != nil {
    poolcleanup() // å¦‚æœpoolcleanupä¸ä¸ºç©ºï¼Œè°ƒç”¨poolcleanupå‡½æ•°
}

// Clear central sudog cache.
// Leave per-P caches alone, they have strictly bounded size.
// Disconnect cached list before dropping it on the floor,
// so that a dangling ref to one entry does not pin all of them.
lock(&amp;sched.sudoglock)
var sg, sgnext *sudog
for sg = sched.sudogcache; sg != nil; sg = sgnext {
    sgnext = sg.next
    sg.next = nil
}
sched.sudogcache = nil
unlock(&amp;sched.sudoglock)

// Clear central defer pools.
// Leave per-P pools alone, they have strictly bounded size.
lock(&amp;sched.deferlock)
for i := range sched.deferpool {
    // disconnect cached list before dropping it on the floor,
    // so that a dangling ref to one entry does not pin all of them.
    var d, dlink *_defer
    for d = sched.deferpool[i]; d != nil; d = dlink {
        dlink = d.link
        d.link = nil
    }
    sched.deferpool[i] = nil
}
unlock(&amp;sched.deferlock) } æ€»ç»“ æ€»ç»“ä¸€ä¸‹sync.Poolçš„å®ç°ï¼Œè¦ç‚¹å¦‚ä¸‹ï¼š
</code></pre></div></div>

<p>æä¾›Newå®šä¹‰å®ç°ç”¨æˆ·è‡ªå®šä¹‰å¯¹è±¡
éœ€è¦ä½¿ç”¨å¯¹è±¡è°ƒç”¨Getä»å¯¹è±¡æ± è·å–ä¸´æ—¶å¯¹è±¡ï¼ŒGetä¼˜å…ˆçº§é¦–å…ˆæ˜¯æœ¬Pç»‘å®šçš„poolLocal, å…¶æ¬¡æ˜¯å…¶ä»–Pç»‘å®šçš„poolLocalï¼Œæœ€åæ˜¯Heapå†…å­˜
å¯¹è±¡ä½¿ç”¨å®Œæ¯•è°ƒç”¨Putå°†ä¸´æ—¶å¯¹è±¡æ”¾å›å¯¹è±¡æ± 
æœªè¢«ä½¿ç”¨çš„å¯¹è±¡ä¼šå®šæ—¶GCå›æ”¶
å¯¹è±¡æ²¡æœ‰ç±»ä¼¼äºlinux cache objectå¯¹åº”çš„freeå‡½æ•°
åº”ç”¨
sync.Poolå¹¶ä¸æ˜¯ä¸‡èƒ½è¯ã€‚è¦æ ¹æ®å…·ä½“æƒ…å¢ƒè€Œå®šæ˜¯å¦ä½¿ç”¨sync.Poolã€‚</p>

<p>æ€»ç»“ä¸é€‚åˆä½¿ç”¨sync.Poolçš„æƒ…å¢ƒï¼Œå…·ä½“å¦‚ä¸‹ï¼š</p>

<p>å¯¹è±¡ä¸­åˆ†é…çš„ç³»ç»Ÿèµ„æºå¦‚socketï¼Œbuffer
å¯¹è±¡éœ€è¦è¿›è¡Œå¼‚æ­¥å¤„ç†
å¯¹è±¡æ˜¯ç»„åˆå¯¹è±¡ï¼Œå¦‚å­˜åœ¨æŒ‡é’ˆæŒ‡å‘å…¶ä»–çš„å¯¹è±¡
æ‰¹é‡å¯¹è±¡éœ€è¦å¹¶å‘å¤„ç†
å¤ç”¨å¯¹è±¡å¤§å°å­˜åœ¨çš„æ³¢åŠ¨ï¼Œå¦‚å¯¹è±¡ç»“æ„æˆå‘˜å­˜åœ¨slice
åœ¨æ’é™¤ä¸Šé¢æƒ…å¢ƒä¸‹ï¼Œé€‚åˆä½¿ç”¨çš„sync.Poolåº”æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼Œå…·ä½“å¦‚ä¸‹ï¼š</p>

<p>å¯¹è±¡æ˜¯bufferæˆ–éç»„åˆç±»å‹å¦‚buffer reader, json decode, bufio writer
å¯¹è±¡å†…å­˜å¯ä»¥é‡å¤ä½¿ç”¨
åŒæ—¶åœ¨ä½¿ç”¨åº”è¯¥æ³¨æ„é—®é¢˜ï¼š</p>

<p>Putå¯¹è±¡ä¹‹å‰å®Œæˆåˆå§‹åŒ–ï¼Œé¿å…æ•°æ®æ±¡æŸ“å¸¦æ¥é—®é¢˜, è¿™å¯èƒ½å¸¦æ¥å„ç§å„æ ·çš„é—®é¢˜
å†™ä»£ç æ—¶è¦æ»¡è¶³one Getï¼Œ one Putçš„è¦æ±‚
æ³¨æ„è·å–å¯¹è±¡åæ˜¯å¦å­˜åœ¨ä¿®æ”¹å¯¹è±¡å†…å­˜å­˜å±€çš„ä»£ç 
å…³æ³¨åº”ç”¨åœºæ™¯æ˜¯å¦å®¹æ˜“å‡ºç°Poolç«äº‰çš„æƒ…å†µ
sync.Poolä¸æ˜¯ä¸‡èƒ½è¯ï¼Œä¸è¦æ‹¿ç€é”¤å­ï¼Œçœ‹ä»€ä¹ˆéƒ½æ˜¯é’‰å­</p>

<p>https://github.com/golang/go/issues/23199</p>

<p>Go 1.13æŒç»­å¯¹ sync.Poolè¿›è¡Œäº†æ”¹è¿›ï¼Œè¿™é‡Œæˆ‘ä»¬æœ‰ä¸¤ä¸ªç®€å•çš„çµé­‚æ‹·é—®ï¼š</p>

<p>1ã€åšäº†å“ªäº›æ”¹è¿›ï¼Ÿ
2ã€å¦‚ä½•åšçš„æ”¹è¿›ï¼Ÿ</p>

<p>é¦–å…ˆå›ç­”ç¬¬ä¸€ä¸ªé—®é¢˜ï¼š</p>

<p>å¯¹STWæš‚åœæ—¶é—´åšäº†ä¼˜åŒ–, é¿å…å¤§çš„sync.Poolä¸¥é‡å½±å“STWæ—¶é—´
ç¬¬äºŒä¸ªä¼˜åŒ–æ˜¯GCæ—¶å…¥è‚¡å¯¹sync.Poolè¿›è¡Œå›æ”¶ï¼Œä¸ä¼šä¸€æ¬¡å°†æ± åŒ–å¯¹è±¡å…¨éƒ¨å›æ”¶ï¼Œè¿™å°±é¿å…äº†sync.Poolé‡Šæ”¾å¯¹è±¡å’Œé‡å»ºå¯¹è±¡å¯¼è‡´çš„æ€§èƒ½å°–åˆºï¼Œé€ ç¦äºsync.Poolé‡åº¦ç”¨æˆ·ã€‚
ç¬¬ä¸‰ä¸ªå°±æ˜¯å¯¹æ€§èƒ½çš„ä¼˜åŒ–ã€‚
å¯¹ä»¥ä¸Šçš„æ”¹è¿›ä¸»è¦æ˜¯ä¸¤æ¬¡æäº¤ï¼š: sync: use lock-free structure for Pool stealingå’Œsync: use lock-free structure for Pool stealingã€‚</p>

<p>ä¸¤æ¬¡æäº¤éƒ½ä¸åŒç¨‹åº¦çš„å¯¹æ€§èƒ½æœ‰æ‰€æå‡ï¼Œä¾æ®ä¸åŒçš„åœºæ™¯ï¼Œæå‡0.7% ï½ 92%ä¸åŒã€‚ Goå¼€å‘è€…æœ‰ä¸€ä¸ªå¾ˆå¥½çš„ä¹ æƒ¯ï¼Œæˆ–è€…å«åšçº¦å®šï¼Œæˆ–è€…æ˜¯ä»–ä»¬çš„å¼€å‘è§„èŒƒï¼Œå¯¹äºæ ‡å‡†åº“çš„ä¿®æ”¹éƒ½ä¼šæ‰§è¡Œæ€§èƒ½çš„æ¯”è¾ƒï¼Œä»£ç çš„ä¿®æ”¹ä¸åº”è¯¥å¸¦æ¥æ€§èƒ½çš„é™ä½ã€‚è¿™ä¸¤æ¬¡æäº¤çš„æ³¨é‡Šæ–‡æ¡£éƒ½è¯¦ç»†çš„ä»‹ç»äº†æ€§èƒ½çš„æ¯”è¾ƒç»“æœã€‚</p>

<p>çŸ¥é“äº†ç¬¬ä¸€ä¸ªé—®é¢˜çš„ç­”æ¡ˆå¯ä»¥è®©æˆ‘ä»¬å¯¹sync.Poolæœ‰ä¿¡å¿ƒï¼Œåœ¨ä¸€äº›åœºæ™¯ä¸‹å¯ä»¥è€ƒè™‘ä½¿ç”¨sync.Poolï¼Œä»¥ä¾¿å‡å°‘å¯¹è±¡çš„åˆ›å»ºå’Œå›æ”¶å¯¹GCçš„å½±å“ã€‚</p>

<p>äº†è§£ç¬¬äºŒä¸ªé—®é¢˜å¯ä»¥è®©æˆ‘ä»¬å­¦åˆ°Goå¼€å‘è€…çš„ä¼˜åŒ–æ‰‹æ®µï¼Œæˆ–è®¸åœ¨æˆ‘ä»¬è‡ªå·±çš„é¡¹ç›®ä¸­ä¹Ÿä½¿ç”¨è¿™äº›ä¼˜åŒ–æ‰‹æ®µæ¥ä¼˜åŒ–æˆ‘ä»¬è‡ªå·±çš„ä»£ç ã€‚</p>

<p>sync: use lock-free structure for Pool stealing
ç¬¬ä¸€æ¬¡æäº¤æå‡ç”¨æ¥æé«˜sync.Poolçš„æ€§èƒ½ï¼Œå‡å°‘STWæ—¶é—´ã€‚</p>

<p>Go 1.13ä¹‹å‰ï¼ŒPoolä½¿ç”¨ä¸€ä¸ªMutexä¿æŠ¤çš„sliceæ¥å­˜å‚¨æ¯ä¸ªshardçš„overflowå¯¹è±¡ã€‚(sync.Poolä½¿ç”¨shardæ–¹å¼å­˜å‚¨æ± åŒ–å¯¹è±¡ï¼Œå‡å°‘ç«äº‰ã€‚ æ¯ä¸ªPå¯¹åº”ä¸€ä¸ªshardã€‚å¦‚æœéœ€è¦åˆ›å»ºå¤šäºä¸€ä¸ªæ± åŒ–å¯¹è±¡ï¼Œè¿™äº›å¯¹è±¡å°±å«åšoverflow)ã€‚</p>

<p>1
2
3
4
5
type poolLocalInternal struct {		 type poolLocalInternal struct {
 	private interface{}   // Can be used only by the respective P.	by the respective P.
 	shared  []interface{} // Can be used by any P.
 	Mutex                 // Protects shared.		
 }
é‚£ä¹ˆåœ¨Go 1.13ä¸­ï¼Œä½¿ç”¨æ˜¯ä»¥ lock-freeçš„æ•°æ®ç»“æ„ä»£æ›¿slice + Mutexçš„æ–¹å¼ï¼š</p>

<p>1
2
3
4
type poolLocalInternal struct {
	private interface{} // Can be used only by the respective P.
	shared  poolChain   // Local P can pushHead/popHead; any P can popTail.
}
è¿™ä¸ªlock-freeçš„æ•°æ®ç»“æ„çš„å®ç°å¾ˆç‰¹åˆ«ã€‚</p>

<p>æˆ‘ä»¬çŸ¥é“ï¼Œå®ç°lock-freeçš„æ•°æ®ç»“æ„ä¸€èˆ¬é‡‡ç”¨atomicçš„æ–¹å¼å®ç°ï¼Œé€šè¿‡CASé¿å…æ“ä½œblockä½ã€‚sync.Poolä¹Ÿæ˜¯é‡‡ç”¨è¿™ç§æ–¹å¼ï¼Œå®ƒå®šä¹‰äº†ä¸€ä¸ªlock-freeçš„åŒå‘é“¾è¡¨:</p>

<p>1
2
3
4
type poolDequeue struct {
	headTail uint64
	vals []eface
}
poolDequeueæ˜¯ä¸€ä¸ªç‰¹åˆ«çš„é˜Ÿåˆ—ï¼Œæœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š</p>

<p>lock-free
å›ºå®šå¤§å°ï¼Œringå½¢ç»“æ„(åº•å±‚å­˜å‚¨ä½¿ç”¨æ•°ç»„,ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆæ ‡è®°eheadã€tail)
å•ç”Ÿäº§è€…
å¤šæ¶ˆè´¹è€…
ç”Ÿäº§è€…å¯ä»¥ä»headè¿›è¡ŒpushHeadã€popHead
æ¶ˆè´¹è€…å¯ä»¥ä»tailè¿›è¡ŒpopTail
å®ƒçš„headå’Œtailæ˜¯é‡‡ç”¨ä¸€ä¸ªuint64æ•°å€¼æ¥è¡¨ç¤ºçš„ï¼Œå¥½å¤„å°±æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡atomicå¯¹è¿™ä¸¤ä¸ªå€¼æ•´ä½“è¿›è¡ŒCASã€‚å®ƒæä¾›äº†unpackã€packå¯ä»¥ä»headTailä¸­è§£æåˆç‹¬ç«‹çš„headå’Œtail, ä»¥åŠæ‰§è¡Œç›¸åçš„æ“ä½œã€‚</p>

<p>æ•°ç»„å­˜å‚¨åœ¨valsæ•°ç»„ä¸­ï¼Œå®ƒé‡‡ç”¨interfaceçš„ç»“æ„è¿›è¡Œå­˜å‚¨ã€‚</p>

<p>å¦‚æœä½ çœ‹å®ƒçš„pushHeadã€popHeadå’ŒpopTailä»£ç ï¼Œå¯ä»¥çœ‹åˆ°å®ƒä¸»è¦ä½¿ç”¨atomicæ¥å®ç°lock-freeã€‚lock-freeä»£ç æ¯”è¾ƒç®€å•ï¼Œæœ¬æ–‡å°±ä¸è¿›è¡Œè¯¦ç»†è§£è¯»äº†ï¼Œé˜…è¯»çš„æ—¶å€™æ³¨æ„headå’Œtailçš„è¾¹ç•Œé—®é¢˜ã€‚å› ä¸ºå®ƒæ˜¯ä½¿ç”¨ä¸€ä¸ªæ•°ç»„(å‡†ç¡®çš„è¯´æ˜¯slice)å®ç°ä¸€ä¸ªringbufferçš„æ•°æ®ç»“æ„ï¼Œè¿™æ ·èƒ½å……åˆ†åˆ©ç”¨åˆ†é…çš„ç©ºé—´ã€‚</p>

<p>sync.Poolè¿˜ä¸æ˜¯ç›´æ¥ä½¿ç”¨poolDequeueè¿™æ ·ä¸€ä¸ªæ•°æ®ç»“æ„ï¼ŒåŸå› åœ¨äºpoolDequeueæ˜¯ä¸€ä¸ªå›ºå®šå¤§å°çš„é˜Ÿåˆ—ï¼Œè¿™ä¸ªå¤§å°å–ä»€ä¹ˆå€¼æ‰åˆç†å‘¢ï¼Ÿå–çš„å¤ªå°ï¼Œä»¥åå¯èƒ½ä¸å¾—ä¸grow, å–çš„å¤ªå¤§ï¼Œåˆå¯èƒ½æµªè´¹ã€‚</p>

<p>è§£å†³è¿™ä¸ªé—®é¢˜å°±æ˜¯é‡‡ç”¨åŠ¨æ€å¢é•¿çš„æ–¹å¼ã€‚å®ƒå®šä¹‰äº†ä¸€ä¸ªé˜Ÿåˆ—é“¾è¡¨æ± ,å¯ä»¥å®ç°åŠ¨æ€çš„ä¸Šè¿°é˜Ÿåˆ—çš„å¢å‡:
type poolChain struct {
	head <em>poolChainElt //åªä¼šè¢«ç”Ÿäº§è€…ä½¿ç”¨
	tail *poolChainElt //åªä¼šè¢«æ¶ˆè´¹è€…ä½¿ç”¨
}
ä¸€å¼€å§‹ï¼Œå®ƒä¼šä½¿ç”¨é•¿åº¦ä¸º8çš„poolDequeueåšå­˜å‚¨ï¼Œä¸€æ—¦è¿™ä¸ªé˜Ÿåˆ—æ»¡äº†ï¼Œå°±ä¼šå†åˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸º16çš„é˜Ÿåˆ—ï¼Œä»¥æ­¤ç±»æ¨ï¼Œåªè¦å½“å‰çš„é˜Ÿåˆ—æ»¡äº†ï¼Œå°±ä¼šæ–°åˆ›å»ºä¸€ 2</em>nçš„poolDequeueåšå­˜å‚¨ã€‚å¦‚æœå½“å‰çš„poolDequeueæ¶ˆè´¹å®Œï¼Œå°±ä¼šä¸¢å¼ƒã€‚</p>

<p>è¿™æ ·ä¸€ä¸ªåŠ¨æ€å¯å˜çš„lock-freeé˜Ÿåˆ—æ­£æ˜¯sync.Poolæ‰€è¦çš„,å½“ç„¶ä¸ºäº†CPUç¼“å­˜ä¼˜åŒ–è¿˜è¿›è¡Œäº†ç¼“å­˜è¡Œçš„å¯¹é½ï¼š
type poolLocalInternal struct {
	private interface{} // Can be used only by the respective P.
	shared  poolChain   // Local P can pushHead/popHead; any P can popTail.
}
type poolLocal struct {
	poolLocalInternal
	pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte
}
type Pool struct {
	noCopy noCopy
	local     unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal
	localSize uintptr        // size of the local array
	New func() interface{}
}
Poolä½¿ç”¨shardçš„æ–¹å¼å®ç°æ± (localå®é™…ä¸Šæ˜¯[P]poolLocal, è¿™é‡Œé‡‡ç”¨æŒ‡é’ˆçš„æ–¹å¼)ï¼Œå®ƒçš„Getã€Putç§»é™¤äº†Mutexçš„åŠ é”æ§åˆ¶ï¼Œè€Œæ˜¯é‡‡ç”¨lock-freeæ•°æ®ç»“æ„poolChainå®ç°ã€‚</p>

<p>å½“ç„¶æœ‰äººå¯èƒ½æå‡ºè´¨ç–‘: lock-freeçœŸçš„æ¯”Mutexæ€§èƒ½å¥½å—ï¼Ÿåœ¨ä¸€å®šçš„ç«äº‰æ¡ä»¶ä¸‹ï¼Œç¡®å®lock-freeçš„æ€§èƒ½è¦å¥½äºMutex, å¦‚æœä½ ä¸¾æç«¯çš„ä¾‹å­ï¼Œæ¯”å¦‚ç«äº‰éå¸¸æ¿€çƒˆçš„æƒ…å†µï¼Œæˆ–è®¸ä¼šæœ‰ä¸åŒçš„ç»“æœï¼Œä½†æ˜¯ç»å¤§éƒ¨åˆ†æƒ…å†µä¸‹ï¼Œlock-freeæ€§èƒ½è¿˜æ˜¯è¦å¥½ä¸€äº›ã€‚</p>

<p>æ³¨æ„Poolçš„å®ç°ä¸­ä½¿ç”¨äº†runtime_procPin()æ–¹æ³•ï¼Œå®ƒå¯ä»¥å°†ä¸€ä¸ªgoroutineæ­»æ­»å ç”¨å½“å‰ä½¿ç”¨çš„P(P-M-Gä¸­çš„processor)ï¼Œä¸å…è®¸å…¶å®ƒgoroutine/MæŠ¢å ,è¿™æ ·å®ƒå°±å¯ä»¥è‡ªç”±çš„ä½¿ç”¨shardä¸­å’Œè¿™ä¸ªPç›¸å…³çš„localï¼Œä¸å¿…æ‹…å¿ƒç«äº‰çš„é—®é¢˜ã€‚é‡Šæ”¾pinçš„æ–¹æ³•æ˜¯runtime_procUnpinã€‚</p>

<p>æ­¤æ—¶çš„poolCleanup (GCçš„æ—¶å€™å¯¹æ± åŒ–å¯¹è±¡çš„é‡Šæ”¾)è¿˜æ˜¯å…¨éƒ¨æ¸…ç©ºï¼Œè¿›ä¸€æ­¥çš„ä¼˜åŒ–åœ¨ä¸‹ä¸€ä¸ªæäº¤ä¸­ã€‚</p>

<p>sync: smooth out Pool behavior over GC with a victim cache
ä¸Šä¸€èŠ‚æåˆ°æ¯æ¬¡Poolæ¸…ç†çš„æ—¶å€™éƒ½æ˜¯æŠŠæ‰€æœ‰çš„æ± åŒ–å¯¹è±¡éƒ½é‡Šæ”¾æ‰ï¼Œè¿™ä¼šå¸¦æ¥ä¸¤ä¸ªé—®é¢˜ï¼š</p>

<p>æµªè´¹: æ± åŒ–å¯¹è±¡å…¨éƒ¨é‡Šæ”¾åç­‰éœ€è¦çš„æ—¶å€™åˆä¸å¾—ä¸é‡æ–°åˆ›å»º
GCå°–å³°:çªç„¶é‡Šæ”¾å¤§é‡çš„æ± åŒ–å¯¹è±¡ä¼šå¯¼è‡´GCè€—æ—¶å¢åŠ 
æ‰€ä»¥è¿™æ¬¡æäº¤å¼•å…¥äº†victim cacheçš„æœºåˆ¶ã€‚victim cacheåŸæ˜¯CPUç¡¬ä»¶å¤„ç†ç¼“å­˜çš„ä¸€ç§æŠ€æœ¯,</p>

<p>æ‰€è°“å—å®³è€…ç¼“å­˜ï¼ˆVictim Cacheï¼‰ï¼Œæ˜¯ä¸€ä¸ªä¸ç›´æ¥åŒ¹é…æˆ–ä½ç›¸è”ç¼“å­˜å¹¶ç”¨çš„ã€å®¹é‡å¾ˆå°çš„å…¨ç›¸è”ç¼“å­˜ã€‚å½“ä¸€ä¸ªæ•°æ®å—è¢«é€å‡ºç¼“å­˜æ—¶ï¼Œå¹¶ä¸ç›´æ¥ä¸¢å¼ƒï¼Œè€Œæ˜¯æš‚å…ˆè¿›å…¥å—å®³è€…ç¼“å­˜ã€‚å¦‚æœå—å®³è€…ç¼“å­˜å·²æ»¡ï¼Œå°±æ›¿æ¢æ‰å…¶ä¸­ä¸€é¡¹ã€‚å½“è¿›è¡Œç¼“å­˜æ ‡ç­¾åŒ¹é…æ—¶ï¼Œåœ¨ä¸ç´¢å¼•æŒ‡å‘æ ‡ç­¾åŒ¹é…çš„åŒæ—¶ï¼Œå¹¶è¡ŒæŸ¥çœ‹å—å®³è€…ç¼“å­˜ï¼Œå¦‚æœåœ¨å—å®³è€…ç¼“å­˜å‘ç°åŒ¹é…ï¼Œå°±å°†å…¶æ­¤æ•°æ®å—ä¸ç¼“å­˜ä¸­çš„ä¸åŒ¹é…æ•°æ®å—åšäº¤æ¢ï¼ŒåŒæ—¶è¿”å›ç»™å¤„ç†å™¨ã€‚</p>

<p>from wikipedia</p>

<p>ç›¸æ¯”è¾ƒå…ˆå‰çš„ç›´æ¥æ¸…é™¤Pool, è¿™æ¬¡ä¿®æ”¹åæ˜¯æ¸…é™¤victim cacheï¼Œç„¶åå°†primary cacheè½¬ç§»ç»™victim cacheã€‚å¦‚æœsync.Poolçš„è·å–é‡Šæ”¾é€Ÿåº¦ç¨³å®šï¼Œé‚£ä¹ˆå°±ä¸ä¼šåˆæ–°çš„æ± å¯¹è±¡è¿›è¡Œåˆ†é…ã€‚å¦‚æœè·å–çš„é€Ÿåº¦ä¸‹é™äº†ï¼Œé‚£ä¹ˆå¯¹è±¡å¯èƒ½ä¼šåœ¨ä¸¤ä¸ªGCå‘¨æœŸå†…è¢«é‡Šæ”¾ï¼Œè€Œä¸æ˜¯ä»¥å‰çš„ä¸€ä¸ªGCå‘¨æœŸã€‚</p>

<p>åŒæ—¶ï¼Œvictim cacheçš„è®¾è®¡ä¹Ÿé—´æ¥çš„æå‡GCçš„æ€§èƒ½ï¼Œå› ä¸ºç¨³å®šçš„sync.Poolä½¿ç”¨å¯¼è‡´æ± åŒ–çš„å¯¹è±¡éƒ½æ˜¯long-liveçš„å¯¹è±¡ï¼Œè€ŒGCçš„ä¸»è¦å¯¹è±¡æ˜¯short-liveçš„å¯¹è±¡ï¼Œæ‰€ä»¥ä¼šå‡å°‘GCçš„æ‰§è¡Œã€‚</p>

<p>ç›¸å¯¹äºä»¥å‰çš„å®ç°ï¼Œç°åœ¨çš„sync.Poolçš„å®ç°å¢åŠ äº†victimç›¸å…³çš„ä¸¤ä¸ªå­—æ®µ:
type Pool struct {
	noCopy noCopy
	local     unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal
	localSize uintptr        // size of the local array
	victim     unsafe.Pointer // local from previous cycle
	victimSize uintptr        // size of victims array
	New func() interface{}
}
å®ƒä¸»è¦å½±å“ä¸¤ä¸ªæ–¹æ³•çš„å®ç°: getSlowå’ŒpoolCleanupã€‚</p>

<p>å½“å‰goroutineä»è‡ªå·±çš„På¯¹åº”çš„æœ¬åœ°è·å–ä¸åˆ°freeçš„æ± åŒ–å¯¹è±¡çš„è¯ï¼Œå°±ä¼šè°ƒç”¨getSlow, å°è¯•ä»å…¶å®ƒshardä¸­â€å·å–â€ã€‚</p>

<p>å¦‚æœä¸å¹¸çš„æ˜¯å…¶å®ƒshardä¹Ÿæ²¡æœ‰freeçš„æ± åŒ–å¯¹è±¡çš„è¯ï¼Œé‚£ä¹ˆå°±å°±å°è¯•ä»victimä¸­æ‰¾ä¸€ä¸ªï¼Œå¯»æ‰¾çš„æ–¹æ³•å’Œä»æœ¬åœ°ä¸­å¯»æ‰¾æ˜¯ä¸€æ ·ä¸€æ ·çš„ã€‚</p>

<p>æ‰¾åˆ°çš„è¯å°±è¿”å›ï¼Œæ‰¾ä¸åˆ°çš„è¯å¦‚æœå®šä¹‰Newåˆ›å»ºå‡½æ•°ï¼Œå°±åˆ›å»ºä¸€ä¸ªï¼Œå¦‚æœæ²¡å®šä¹‰Newè¿”å›ç©ºã€‚</p>

<p>æ¸…ç†çš„æ—¶å€™å°±æ˜¯æŠŠæ¯ä¸€ä¸ªsync.Poolçš„victiméƒ½æ¸…ç©º,ç„¶åå†æŠŠæœ¬åœ°localçš„æ± åŒ–å¯¹è±¡èµ‹å€¼ç»™victimï¼Œ æœ¬åœ°å¯¹è±¡éƒ½æ¸…ç©ºã€‚</p>

<p>sync.Pool æ•´ä½“ Get/Put é€»è¾‘
Vincent Blanchonæ›¾åœ¨ä»–çš„Go: Understand the Design of Sync.Poolä¸€æ–‡ä¸­ç»™å‡ºäº†sync.Pool go 1.12ç‰ˆæœ¬çš„Get/Putçš„æµç¨‹å›¾ã€‚è¿™é‡Œæˆ‘ç”»äº†ä¸€ä¸ªgo 1.13ç‰ˆæœ¬çš„æµç¨‹å›¾ï¼Œå¯ä»¥å¾ˆå¥½çš„ç†è§£sync.Poolå¤„ç†çš„è¿‡ç¨‹ã€‚
https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/
SyncåŒ…æä¾›äº†å¼ºå¤§çš„å¯è¢«é‡å¤åˆ©ç”¨å®ä¾‹æ± ï¼Œä¸ºäº†é™ä½åƒåœ¾å›æ”¶çš„å‹åŠ›ã€‚åœ¨ä½¿ç”¨è¿™ä¸ªåŒ…ä¹‹å‰ï¼Œéœ€è¦å°†ä½ çš„åº”ç”¨è·‘å‡ºä½¿ç”¨poolä¹‹å‰ä¸ä¹‹åçš„benchmarkæ•°æ®ï¼Œå› ä¸ºåœ¨ä¸€äº›æƒ…å†µä¸‹ä½¿ç”¨å¦‚æœä½ ä¸æ¸…æ¥špoolå†…éƒ¨åŸç†çš„è¯ï¼Œåè€Œä¼šè®©åº”ç”¨çš„æ€§èƒ½ä¸‹é™ã€‚
poolçš„å±€é™æ€§
æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ä¸€äº›åŸºç¡€çš„ä¾‹å­ï¼Œæ¥çœ‹çœ‹ä»–åœ¨ä¸€ä¸ªç›¸å½“ç®€å•æƒ…å†µä¸‹ï¼ˆåˆ†é…1Kå†…å­˜ï¼‰æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼š
type Small struct {
   a int
}</p>

<p>var pool = sync.Pool{
   New: func() interface{} { return new(Small) },
}</p>

<p>//go:noinline
func inc(s *Small) { s.a++ }</p>

<p>func BenchmarkWithoutPool(b *testing.B) {
   var s *Small
   for i := 0; i &lt; b.N; i++ {
      for j := 0; j &lt; 10000; j++ {
         s = &amp;Small{ a: 1, }
         b.StopTimer(); inc(s); b.StartTimer()
      }
   }
}</p>

<p>func BenchmarkWithPool(b <em>testing.B) {
   var s *Small
   for i := 0; i &lt; b.N; i++ {
      for j := 0; j &lt; 10000; j++ {
         s = pool.Get().(</em>Small)
         s.a = 1
         b.StopTimer(); inc(s); b.StartTimer()
         pool.Put(s)
      }
   }
}
å¤åˆ¶ä»£ç ä¸‹é¢æ˜¯ä¸¤ä¸ªbenchmarksï¼Œä¸€ä¸ªæ˜¯ä½¿ç”¨äº†sync.poolä¸€ä¸ªæ²¡æœ‰ä½¿ç”¨
name           time/op        alloc/op        allocs/op
WithoutPool-8  3.02ms Â± 1%    160kB Â± 0%      1.05kB Â± 1%
WithPool-8     1.36ms Â± 6%   1.05kB Â± 0%        3.00 Â± 0%
å¤åˆ¶ä»£ç ç”±äºè¿™ä¸ªéå†æœ‰10kçš„è¿­ä»£ï¼Œé‚£ä¸ªæ²¡æœ‰ä½¿ç”¨poolçš„benchmarkæ˜¾ç¤ºåœ¨å †ä¸Šåˆ›å»ºäº†10kçš„å†…å­˜åˆ†é…ï¼Œè€Œä½¿ç”¨äº†poolçš„åªä½¿ç”¨äº†3. 3ä¸ªåˆ†é…ç”±poolè¿›è¡Œçš„ï¼Œä½†åªæœ‰ä¸€ä¸ªç»“æ„ä½“çš„å®ä¾‹è¢«åˆ†é…åˆ°å†…å­˜ã€‚åˆ°ç›®å‰ä¸ºæ­¢å¯ä»¥çœ‹åˆ°ä½¿ç”¨poolå¯¹äºå†…å­˜çš„å¤„ç†ä»¥åŠå†…å­˜æ¶ˆè€—ä¸Šé¢æ›´åŠ å‹å–„ã€‚
ä½†æ˜¯ï¼Œåœ¨å®é™…ä¾‹å­é‡Œé¢ï¼Œå½“ä½ ä½¿ç”¨poolï¼Œä½ çš„åº”ç”¨å°†ä¼šæœ‰å¾ˆå¤šæ–°åœ¨å †ä¸Šçš„å†…å­˜åˆ†é…ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œå½“å†…å­˜å‡é«˜äº†ï¼Œå°±ä¼šè§¦å‘åƒåœ¾å›æ”¶ã€‚
æˆ‘ä»¬å¯ä»¥å¼ºåˆ¶åƒåœ¾å›æ”¶çš„å‘ç”Ÿé€šè¿‡ä½¿ç”¨runtime.GC()æ¥æ¨¡æ‹Ÿè¿™ç§æƒ…å½¢
name           time/op        alloc/op        allocs/op
WithoutPool-8  993ms Â± 1%    249kB Â± 2%      10.9k Â± 0%
WithPool-8     1.03s Â± 4%    10.6MB Â± 0%     31.0k Â± 0%
å¤åˆ¶ä»£ç æˆ‘ä»¬ç°åœ¨å¯ä»¥çœ‹åˆ°ä½¿ç”¨äº†poolçš„æƒ…å†µåè€Œå†…å­˜åˆ†é…æ¯”ä¸ä½¿ç”¨poolçš„æ—¶å€™é«˜äº†ã€‚æˆ‘ä»¬æ¥æ·±å…¥åœ°çœ‹ä¸€ä¸‹è¿™ä¸ªåŒ…çš„æºç æ¥ç†è§£ä¸ºä»€ä¹ˆä¼šè¿™æ ·ã€‚
å†…éƒ¨å·¥ä½œæµ
çœ‹ä¸€ä¸‹sync/pool.goæ–‡ä»¶ä¼šç»™æˆ‘ä»¬å±•ç¤ºä¸€ä¸ªåˆå§‹åŒ–å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°é‡Œé¢çš„å†…å®¹èƒ½è§£é‡Šæˆ‘ä»¬åˆšåˆšçš„æƒ…æ™¯ï¼š
func init() {
   runtime_registerPoolCleanup(poolCleanup)
}
å¤åˆ¶ä»£ç è¿™é‡Œåœ¨è¿è¡Œæ—¶æ³¨å†Œæˆäº†ä¸€ä¸ªæ–¹æ³•å»æ¸…ç†poolsã€‚å¹¶ä¸”åŒæ ·çš„æ–¹æ³•åœ¨åƒåœ¾å›æ”¶é‡Œé¢ä¹Ÿä¼šè§¦å‘ï¼Œåœ¨æ–‡ä»¶runtime/mgc.goé‡Œé¢
func gcStart(trigger gcTrigger) {
   [â€¦]
   // clearpools before we start the GC
   clearpools()
å¤åˆ¶ä»£ç è¿™å°±è§£é‡Šäº†ä¸ºä»€ä¹ˆå½“è°ƒç”¨åƒåœ¾å›æ”¶æ—¶ï¼Œæ€§èƒ½ä¼šä¸‹é™ã€‚poolsåœ¨æ¯æ¬¡åƒåœ¾å›æ”¶å¯åŠ¨æ—¶éƒ½ä¼šè¢«æ¸…ç†ã€‚è¿™ä¸ªæ–‡æ¡£å…¶å®å·²ç»æœ‰è­¦å‘Šæˆ‘ä»¬
Any item stored in the Pool may be removed automatically at any time without notification
å¤åˆ¶ä»£ç æ¥ä¸‹æ¥è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªå·¥ä½œæµæ¥ç†è§£ä¸€ä¸‹è¿™é‡Œé¢æ˜¯å¦‚ä½•ç®¡ç†çš„</p>

<p>sync.Pool workflow in Go 1.12</p>

<p>æˆ‘ä»¬åˆ›å»ºçš„æ¯ä¸€ä¸ªsync.Poolï¼Œgoéƒ½ä¼šç”Ÿæˆä¸€ä¸ªå†…éƒ¨æ± poolLocalè¿æ¥ç€å„ä¸ªprocesserï¼ˆGMPä¸­çš„Pï¼‰ã€‚è¿™äº›å†…éƒ¨çš„æ± ç”±ä¸¤ä¸ªå±æ€§ç»„æˆprivateå’Œsharedã€‚å‰è€…åªæ˜¯ä»–çš„æ‰€æœ‰è€…å¯ä»¥è®¿é—®(pushä»¥åŠpopæ“ä½œï¼Œä¹Ÿå› æ­¤ä¸éœ€è¦é”)ï¼Œè€Œ`sharedå¯ä»¥è¢«ä»»ä½•processerè¯»å–å¹¶ä¸”æ˜¯éœ€è¦è‡ªå·±ç»´æŒå¹¶å‘å®‰å…¨ã€‚è€Œå®é™…ä¸Šï¼Œpoolä¸æ˜¯ä¸€ä¸ªç®€å•çš„æœ¬åœ°ç¼“å­˜ï¼Œä»–æœ‰å¯èƒ½åœ¨æˆ‘ä»¬çš„ç¨‹åºä¸­è¢«ç”¨äºä»»ä½•çš„åç¨‹æˆ–è€…goroutines
Goçš„1.13ç‰ˆå°†æ”¹å–„å¯¹sharedçš„è®¿é—®ï¼Œè¿˜å°†å¸¦æ¥ä¸€ä¸ªæ–°çš„ç¼“å­˜ï¼Œè¯¥ç¼“å­˜è§£å†³ä¸åƒåœ¾å›æ”¶å™¨å’Œæ¸…é™¤æ± æœ‰å…³çš„é—®é¢˜ã€‚
æ–°çš„æ— éœ€é”poolå’Œvictim cache
Go 1.13ç‰ˆæœ¬ä½¿ç”¨äº†ä¸€ä¸ªæ–°çš„åŒå‘é“¾è¡¨ä½œä¸ºshared poolï¼Œå»é™¤äº†é”ï¼Œæé«˜äº†sharedçš„è®¿é—®æ•ˆç‡ã€‚è¿™ä¸ªæ”¹é€ ä¸»è¦æ˜¯ä¸ºäº†æé«˜ç¼“å­˜æ€§èƒ½ã€‚è¿™é‡Œæ˜¯ä¸€ä¸ªè®¿é—®sharedçš„æµç¨‹</p>

<p>new shared pools in Go 1.13</p>

<p>åœ¨è¿™ä¸ªæ–°çš„é“¾å¼poolé‡Œé¢ï¼Œæ¯ä¸€ä¸ªprocesspréƒ½å¯ä»¥åœ¨é“¾è¡¨çš„å¤´è¿›è¡Œpushä¸popï¼Œç„¶åè®¿é—®sharedå¯ä»¥ä»é“¾è¡¨çš„å°¾popå‡ºå­å—ã€‚ç»“æ„ä½“çš„å¤§å°åœ¨æ‰©å®¹çš„æ—¶å€™ä¼šå˜æˆåŸæ¥çš„ä¸¤å€ï¼Œç„¶åç»“æ„ä½“ä¹‹é—´ä½¿ç”¨next/prevæŒ‡é’ˆè¿›è¡Œè¿æ¥ã€‚ç»“æ„ä½“é»˜è®¤å¤§å°æ˜¯å¯ä»¥æ”¾ä¸‹8ä¸ªå­é¡¹ã€‚è¿™æ„å‘³ç€ç¬¬äºŒä¸ªç»“æ„ä½“å¯ä»¥å®¹çº³16ä¸ªå­é¡¹ï¼Œç¬¬ä¸‰ä¸ªæ˜¯32ä¸ªå­é¡¹ä»¥æ­¤ç±»æ¨ã€‚åŒæ ·åœ°ï¼Œæˆ‘ä»¬ç°åœ¨ä¸å†éœ€è¦é”ï¼Œä»£ç æ‰§è¡Œå…·æœ‰åŸå­æ€§ã€‚
å…³äºæ–°ç¼“å­˜ï¼Œæ–°ç­–ç•¥éå¸¸ç®€å•ã€‚ ç°åœ¨æœ‰2ç»„æ± ï¼šæ´»åŠ¨æ± å’Œå·²å½’æ¡£æ± ã€‚ å½“åƒåœ¾æ”¶é›†å™¨è¿è¡Œæ—¶ï¼Œå®ƒå°†ä¿ç•™æ¯ä¸ªæ± å¯¹è¯¥æ± å†…æ–°å±æ€§çš„å¼•ç”¨ï¼Œç„¶ååœ¨æ¸…ç†å½“å‰æ± ä¹‹å‰å°†æ± çš„é›†åˆå¤åˆ¶åˆ°å½’æ¡£æ± ä¸­ï¼š
// Drop victim caches from all pools.
for _, p := range oldPools {
   p.victim = nil
   p.victimSize = 0
}</p>

<p>// Move primary cache to victim cache.
for _, p := range allPools {
   p.victim = p.local
   p.victimSize = p.localSize
   p.local = nil
   p.localSize = 0
}</p>

<p>// The pools with non-empty primary caches now have non-empty
// victim caches and no pools have primary caches.
oldPools, allPools = allPools, nil
å¤åˆ¶ä»£ç é€šè¿‡è¿™ç§ç­–ç•¥ï¼Œç”±äºå—å®³è€…ç¼“å­˜ï¼Œè¯¥åº”ç”¨ç¨‹åºç°åœ¨å°†æœ‰ä¸€ä¸ªæ›´å¤šçš„åƒåœ¾æ”¶é›†å™¨å‘¨æœŸæ¥åˆ›å»º/æ”¶é›†å¸¦æœ‰å¤‡ä»½çš„æ–°é¡¹ç›®ã€‚ åœ¨å·¥ä½œæµä¸­ï¼Œå°†åœ¨å…±äº«æ± ä¹‹ååœ¨è¿‡ç¨‹ç»“æŸæ—¶è¯·æ±‚ç‰ºç‰²è€…ç¼“å­˜ã€‚</p>

<p>ä¸€èˆ¬ sync.Pool ç”¨ä½œå°å¯¹åƒæ± ï¼Œæ¯”å¦‚å‰å…¬å¸åŒäº‹ï¼Œåœ¨ thrift golang lib å¢åŠ äº† sync.Pool å®ç° []byte ç­‰å¯¹è±¡çš„å¤ç”¨ã€‚ç½‘ä¸Šä¹Ÿæœ‰å¾ˆå¤š objectPool çš„è½®å­ï¼Œä½†æ€»ä½“å®ç°éƒ½ä¸å¦‚ sync.Pool é«˜æ•ˆã€‚</p>

<p>åŸºæœ¬åŸç†ä¸æ¼”è¿›åˆæ¢
æƒ³è±¡ä¸€ä¸‹å¦‚æœæˆ‘ä»¬è‡ªå·±å®ç°ï¼Œè¯¥æ€ä¹ˆåšå‘¢ï¼Ÿç”¨ä¸€ä¸ªå®šé•¿çš„ channel ä¿å­˜å¯¹è±¡ï¼Œæ‹¿åˆ°äº†å°±ç”¨ï¼Œæ‹¿ä¸åˆ°å°± new åˆ›å»ºä¸€ä¸ªï¼Œä¼ªä»£ç å¤§è‡´å¦‚ä¸‹ï¼š</p>

<p>type ObjectPool struct {
    ch chan {}interface
    newFunc func() {}interface
}</p>

<p>func (o *ObjectPool) Get() {}interface {
    select {
        v := &lt;-o.ch:
          return v
        default:
    }
    return o.newFunc()
}</p>

<p>func (o *ObjectPool) Put(v {}interface) {
    select {
        o.ch &lt;- v:
        default:
    }
}
ä»£ç å¾ˆç®€æ´ï¼Œåˆ©ç”¨ select default è¯­æ³•å®ç°æ— é˜»å¡æ“ä½œã€‚è¿™é‡Œæœ€å¤§çš„é—®é¢˜å°±æ˜¯ channel ä¹Ÿæ˜¯æœ‰ä»£ä»·çš„ï¼Œä¸€æŠŠå¤§é”è®©æ€§èƒ½ä¼šå˜å¾—å¾ˆä½ï¼Œå‚è€ƒæˆ‘ä¹‹å‰çš„å…³ dpvs æ€§èƒ½ä¼˜åŒ–ã€‚é‚£æ€ä¹ˆä¼˜åŒ–å‘¢ï¼Ÿå¤šæ ¸ cpu é«˜å¹¶å‘ç¼–ç¨‹ï¼Œå°±æ˜¯è¦æ¯ä¸ª cpu æ‹¥æœ‰è‡ªå·±çš„æœ¬åœ°æ•°æ®ï¼Œè¿™æ ·å°±é¿å…äº†é”äº‰ç”¨çš„å¼€é”€ã€‚è€Œäº‹å®ä¸Š sync.Pool ä¹Ÿæ˜¯è¿™ä¹ˆåšçš„ã€‚</p>

<p>çœ‹äº†ä¸‹æäº¤è®°å½•ï¼Œä»å¢åŠ è¯¥åŠŸèƒ½åå®ç°çš„å¤§æ–¹ç°åŸºæœ¬æ²¡å˜ï¼š</p>

<p>æ¯ä¸ª P (é€»è¾‘å¹¶å‘æ¨¡å‹ï¼Œå‚è€ƒ GMP) æ‹¥æœ‰æœ¬åœ°ç¼“å­˜é˜Ÿåˆ—ï¼Œå¦‚æœæœ¬åœ°è·å–ä¸åˆ°å¯¹è±¡ï¼Œå†ä»å…¶å®ƒ P å»å·ä¸€ä¸ªï¼Œå…¶å®ƒ P ä¹Ÿæ²¡çš„è¯ï¼Œè°ƒ new factory åˆ›å»ºæ–°çš„è¿”å›ã€‚
Pool é‡Œçš„å¯¹è±¡ä¸æ˜¯æ°¸ç”Ÿçš„ï¼Œè€çš„å®ç°ï¼Œå¯¹è±¡å¦‚æœä»…ç”± Pool å¼•ç”¨ï¼Œé‚£ä¹ˆä¼šåœ¨ä¸‹æ¬¡ GC ä¹‹é—´è¢«é”€æ¯ã€‚ä½†æ˜¯æœ€æ–°ä¼˜åŒ– 22950 é‡Œï¼Œä¸ºäº†ä¼˜åŒ– GC å Pool ä¸ºç©ºå¯¼è‡´çš„å†·å¯åŠ¨æ€§èƒ½æŠ–åŠ¨ï¼Œå¢åŠ äº† victim cache, ç”¨æ¥ä¿å­˜ä¸Šä¸€æ¬¡ GC æœ¬åº”è¢«é”€æ¯çš„å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹è±¡è‡³å°‘å­˜æ´»ä¸¤æ¬¡ GC é—´éš”ã€‚
æ€§èƒ½ä¼˜åŒ–ï¼Œå°†æœ¬åœ°é˜Ÿåˆ—å˜æˆæ— é”é˜Ÿåˆ—( å•ç”Ÿäº§è€…ï¼Œå¤šæ¶ˆè´¹è€…æ¨¡å‹ï¼Œä¸¥æ ¼æ¥è®²ä¸é€šç”¨)ï¼Œè¿˜æœ‰ä¸€äº› fix bugâ€¦
æ•°æ®ç»“æ„åŠæ¼”è¿›
type Pool struct {
    local     unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal
    localSize uintptr        // size of the local array</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// New optionally specifies a function to generate
// a value when Get would otherwise return nil.
// It may not be changed concurrently with calls to Get.
New func() interface{} }
</code></pre></div></div>

<p>// Local per-P Pool appendix.
type poolLocal struct {
    private interface{}   // Can be used only by the respective P.
    shared  []interface{} // Can be used by any P.
    Mutex                 // Protects shared.
    pad     [128]byte     // Prevents false sharing.
}
å¯¹è±¡æ˜¯å­˜å‚¨åœ¨ poolLocal é‡Œçš„ï¼Œprivate å­—æ®µè¡¨ç¤ºæœ€æ–°ç”Ÿæˆçš„å•ä¸ªå¯¹è±¡ï¼Œåªèƒ½ç”±æœ¬åœ° P è®¿é—®ï¼Œshared æ˜¯ä¸€ä¸ª slice, å¯ä»¥è¢«ä»»æ„ P è®¿é—®ï¼ŒMutex ç”¨æ¥ä¿æŠ¤ shared. pad ç”¨æ¥å¯¹é½ï¼Œä½œç”¨å‚è€ƒæˆ‘ä¹‹å‰çš„ cpu cache</p>

<p>å†åŠ å¤´çœ‹ Pool ç»“æ„ä½“ï¼ŒNew æ˜¯åˆ›å»ºå¯¹è±¡çš„å·¥å‚æ–¹æ³•ã€‚local æ˜¯ä¸€ä¸ªæŒ‡å‘ []poolLocal çš„æŒ‡é’ˆ(å‡†ç¡®è¯´ï¼Œæ˜¯ slice åº•å±‚æ•°ç»„çš„é¦–åœ°å€)ï¼ŒlocalSize æ˜¯ slice çš„é•¿åº¦ï¼Œç”±äº P çš„ä¸ªæ•°æ˜¯å¯ä»¥åœ¨çº¿è°ƒæ•´çš„ï¼Œæ‰€ä»¥ localSize è¿è¡Œæ—¶å¯èƒ½ä¼šå˜åŒ–ã€‚è®¿é—®æ—¶ï¼ŒP çš„ id å¯¹åº” []poolLocal ä¸‹æ ‡ç´¢å¼•ã€‚</p>

<p>type Pool struct {
    noCopy noCopy</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local     unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal
localSize uintptr        // size of the local array

victim     unsafe.Pointer // local from previous cycle
victimSize uintptr        // size of victims array

// New optionally specifies a function to generate
// a value when Get would otherwise return nil.
// It may not be changed concurrently with calls to Get.
New func() interface{} }
</code></pre></div></div>

<p>// Local per-P Pool appendix.
type poolLocalInternal struct {
    private interface{} // Can be used only by the respective P.
    shared  poolChain   // Local P can pushHead/popHead; any P can popTail.
}</p>

<p>type poolLocal struct {
    poolLocalInternal</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Prevents false sharing on widespread platforms with
// 128 mod (cache line size) = 0 .
pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte } Pool å¢åŠ äº† noCopy å­—æ®µï¼ŒPool é»˜è®¤åˆ›å»ºåç¦æ­¢æ‹·è´ï¼Œå¿…é¡»ä½¿ç”¨æŒ‡é’ˆã€‚noCopy ç”¨æ¥ç¼–ç»æ—¶ go vet æ£€æŸ¥ï¼Œé™æ€è¯­è¨€å°±æ˜¯çˆ½ï¼Œç¼–ç»æœŸå¹²äº†å¥½å¤šè„æ´»ç´¯æ´»ã€‚å‚è€ƒ issue 8005 , é‡Œé¢æœ‰å¾ˆå¤šè®¨è®ºï¼Œå…³äºç¦æ­¢æ‹·è´å¦‚ä½•å®ç°ã€‚ å¢åŠ  victim cache, ä»¥å‡å°‘ GC åå†·å¯åŠ¨å¯¼è‡´çš„æ€§èƒ½æŠ–åŠ¨ã€‚ poolLocal æ‹†æˆäº†ä¸¤ä¸ªç»“æ„ä½“ï¼Œpad å®ç°ä¹Ÿç¨å¾®å˜äº†ä¸‹ï¼Œä¸ºäº†å…¼å®¹æ›´å¤šç¡¬ä»¶ cache line size. å¦å¤–æœ€é‡è¦çš„ä¼˜åŒ–ï¼Œå°±æ˜¯ shared slice å˜æˆäº†æ— é”é˜Ÿåˆ—ã€‚ ç¬¬ä¸€ç‰ˆæœ¬å®ç° å¯¹è±¡ put // Put adds x to the pool. func (p *Pool) Put(x interface{}) {
if raceenabled {
    // Under race detector the Pool degenerates into no-op.
    // It's conforming, simple and does not introduce excessive
    // happens-before edges between unrelated goroutines.
    return
}
if x == nil {
    return
}
l := p.pin()
if l.private == nil {
    l.private = x
    x = nil
}
runtime_procUnpin()
if x == nil {
    return
}
l.Lock()
l.shared = append(l.shared, x)
l.Unlock() } é€»è¾‘å¾ˆç®€å•ï¼Œå…ˆ pin ä½ï¼Œå¦‚æœ private å­—æ®µä¸ºç©ºï¼Œå°†å¯¹è±¡æ”¾åˆ° private å­—æ®µï¼Œå¦åˆ™æ·»åŠ åˆ° share æ± é‡Œã€‚
</code></pre></div></div>

<p>å¯¹è±¡ get
func (p *Pool) Get() interface{} {
    if raceenabled { // race æ£€æµ‹æ—¶ç¦ç”¨ Pool åŠŸèƒ½ï¼Œåç»­å»æ‰äº†è¿™ä¸ª
        if p.New != nil {
            return p.New()
        }
        return nil
    }
    l := p.pin() // pin ä¼šç¦æ­¢ P è¢«æŠ¢å ï¼Œå¹¶è¿”å›æœ¬åœ° P å¯¹åº”çš„ poolLocal ä¿¡æ¯ã€‚
    x := l.private
    l.private = nil
    runtime_procUnpin()
    if x != nil { // å¦‚æœ private æœ‰äº†ï¼Œå°±ä¸ç”¨å»çœ‹ share ç›´æ¥è¿”å›å°±å¥½
        return x
    }
    l.Lock() // ä¸Šé”ä¿æŠ¤ share
    last := len(l.shared) - 1
    if last &gt;= 0 {
        x = l.shared[last]
        l.shared = l.shared[:last]
    }
    l.Unlock()
    if x != nil { // æ­¤æ—¶ä» share ä¸­æ‹¿åˆ°äº†å¯¹è±¡ï¼Œè¿”å›å³å¯
        return x
    }
    return p.getSlow() // èµ°æ…¢çš„é€»è¾‘ï¼šä»å…¶å®ƒ P å·æˆ–æ˜¯è°ƒç”¨ new å·¥å‚æ–¹æ³•åˆ›å»º
}</p>

<p>func (p *Pool) getSlow() (x interface{}) {
    // See the comment in pin regarding ordering of the loads.
    size := atomic.LoadUintptr(&amp;p.localSize) // load-acquire
    local := p.local                         // load-consume
    // Try to steal one element from other procs.
    pid := runtime_procPin()
    runtime_procUnpin()
    for i := 0; i &lt; int(size); i++ { // è½®å¾ªä»ä¸‹ä¸€ä¸ª P æœ¬åœ°é˜Ÿåˆ—å·æ•°æ®
        l := indexLocal(local, (pid+i+1)%int(size))
        l.Lock()
        last := len(l.shared) - 1
        if last &gt;= 0 {
            x = l.shared[last]
            l.shared = l.shared[:last]
            l.Unlock()
            break
        }
        l.Unlock()
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x == nil &amp;&amp; p.New != nil { // å…¶å®ƒ P ä¸­ä¹Ÿæ²¡å·åˆ°ï¼ŒNew ä¸€ä¸ª
    x = p.New()
}
return x } ä»è¿™é‡Œï¼Œå¯ä»¥çœ‹åˆ°å¤§ä½“é€»è¾‘ï¼Œå’Œä¹‹å‰æè¿°åŸºæœ¬ä¸€è‡´ï¼Œé‚£å…·ä½“ pin å¦‚ä½•å®ç°çš„å‘¢ï¼Ÿæœ‰ä»€ä¹ˆä½œç”¨å‘¢ï¼Ÿæ¥ç€çœ‹æºç 
</code></pre></div></div>

<p>func syncÂ·runtime_procPin() (p int) {
    M *mp;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mp = m;
// Disable preemption.
mp-&gt;locks++;
p = mp-&gt;p-&gt;id; }
</code></pre></div></div>

<p>func syncÂ·runtime_procUnpin() {
    m-&gt;locksâ€“;
}
å®é™…ä¸Š syncÂ·runtime_procPin å’Œ syncÂ·runtime_procUnpin å°±æ˜¯é’ˆå¯¹ M è¿›è¡ŒåŠ é”ï¼Œé˜²æ­¢è¢« runtime æŠ¢å è€Œå·±ã€‚Pin é™¤äº†ä¸Šé”ï¼Œä¼šè¿”å› P çš„ id</p>

<p>// pin pins the current goroutine to P, disables preemption and returns poolLocal pool for the P.
// Caller must call runtime_procUnpin() when done with the pool.
func (p *Pool) pin() *poolLocal {
    pid := runtime_procPin()
    // In pinSlow we store to localSize and then to local, here we load in opposite order.
    // Since weâ€™ve disabled preemption, GC can not happen in between.
    // Thus here we must observe local at least as large localSize.
    // We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).
    s := atomic.LoadUintptr(&amp;p.localSize) // load-acquire è·å– []poolLocal slice é•¿åº¦
    l := p.local                          // load-consume è·å– []poolLocal é¦–åœ°å€
    if uintptr(pid) &lt; s { // ç”±äº P çš„ id å°±æ˜¯ []poolLocal ä¸‹æ ‡
        return indexLocal(l, pid)
    }
    return p.pinSlow()
}</p>

<p>func (p <em>Pool) pinSlow() *poolLocal {
    // Retry under the mutex.
    // Can not lock the mutex while pinned.
    runtime_procUnpin()
    allPoolsMu.Lock()
    defer allPoolsMu.Unlock()
    pid := runtime_procPin()
    // poolCleanup wonâ€™t be called while we are pinned.
    s := p.localSize
    l := p.local
    if uintptr(pid) &lt; s { // pid å°±æ˜¯ slice çš„ä¸‹æ‘ï¼Œæ‰€ä»¥å¦‚æœ pid å°äº s å°±æŸ¥æ‰¾ slice
        return indexLocal(l, pid)
    }
    if p.local == nil { // ç¬¬ä¸€æ¬¡ä½¿ç”¨ï¼ŒæŠŠ Pool æ·»åŠ åˆ°å…¨å±€ allPools 
        allPools = append(allPools, p)
    }
    // If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one. èµ°æ‰©å®¹é€»è¾‘
    size := runtime.GOMAXPROCS(0)
    local := make([]poolLocal, size)
    atomic.StorePointer((</em>unsafe.Pointer)(&amp;p.local), unsafe.Pointer(&amp;local[0])) // store-release
    atomic.StoreUintptr(&amp;p.localSize, uintptr(size))                            // store-release
    return &amp;local[pid]
}
    // l æ˜¯æŒ‡é’ˆåœ°åœ°ï¼Œåšç±»å‹è½¬æ¢ï¼Œç„¶åè¿”å›ä¸‹æ ‡ i çš„ poolLocal
func indexLocal(l unsafe.Pointer, i int) <em>poolLocal {
    return &amp;(</em>[1000000]poolLocal)(l)[i]
}
pin çš„ä½œç”¨å°†å½“å‰ goroutine å’Œ P è¿›è¡Œç»‘å®šï¼Œç¦æ­¢æŠ¢å ï¼Œç„¶åè¿”å›å½“å‰ P æ‰€å¯¹åº”çš„ poolLocal ç»“æ„ä½“ã€‚</p>

<p>localSize æ˜¯ []poolLocal slice é•¿åº¦ï¼Œç”±äºæ˜¯ç”¨ pid åšä¸‹æ ‡ç´¢å¼•ï¼Œæ‰€ä»¥å¦‚æœ pid å°äº localSizeï¼Œç›´æ¥è¿”å›ï¼Œå¦åˆ™èµ° pinSlow é€»è¾‘
pinSlow è§¦å‘æœ‰ä¸¤ç‚¹ï¼šPool ç¬¬ä¸€æ¬¡è¢«ä½¿ç”¨ï¼ŒGOMAXPROCS è¿è¡Œæ—¶ä¸ªæ”¹ã€‚è¿™æ—¶å¯ä»¥çœ‹åˆ° p.local ç›´æ¥ç”¨ä¸€ä¸ªæ–°çš„ slice è¦†ç›–äº†ï¼Œæ—§çš„å¯¹è±¡æ± ä¼šè¢«ä¸¢å¼ƒã€‚
å¯ä»¥çœ‹åˆ°ï¼Œæ•´ä½“å®ç°ä¸æ˜¯å¾ˆå¤æ‚ï¼Œæœ€æ–°ç‰ˆæœ¬ä¸ç¬¬ä¸€ç‰ˆå˜åŒ–ä¸å¤ªå¤§ã€‚</p>

<p>å¯¹è±¡ cleanup
func poolCleanup() {
    // This function is called with the world stopped, at the beginning of a garbage collection.
    // It must not allocate and probably should not call any runtime functions.
    // Defensively zero out everything, 2 reasons:
    // 1. To prevent false retention of whole Pools.
    // 2. If GC happens while a goroutine works with l.shared in Put/Get,
    //    it will retain whole Pool. So next cycle memory consumption would be doubled.
    for i, p := range allPools {
        allPools[i] = nil
        for i := 0; i &lt; int(p.localSize); i++ {
            l := indexLocal(p.local, i)
            l.private = nil
            for j := range l.shared {
                l.shared[j] = nil
            }
            l.shared = nil
        }
    }
    allPools = []*Pool{}
}</p>

<p>var (
    allPoolsMu Mutex
    allPools   []*Pool
)</p>

<p>func init() {
    runtime_registerPoolCleanup(poolCleanup)
}
ä»£ç å¾ˆç®€å•ï¼Œinit å‡½æ•°ä¼šå°† poolCleanup æ³¨å†Œåˆ° runtime, åœ¨ GC å¼€å§‹ï¼ŒSTW åæ‰§è¡Œï¼Œéå† poolLocal ç„¶åè§£å¼•ç”¨å³å¯ã€‚</p>

<p>indexLocal æ€§èƒ½ä¼˜åŒ–
å‚è§å®˜æ–¹ commitï¼Œä¿®æ”¹å¦‚ä¸‹</p>

<p>func indexLocal(l unsafe.Pointer, i int) *poolLocal {</p>
<ul>
  <li>return &amp;(*[1000000]poolLocal)(l)[i]</li>
  <li>lp := unsafe.Pointer(uintptr(l) + uintptr(i)*unsafe.Sizeof(poolLocal{}))</li>
  <li>return (*poolLocal)(lp)
 }
    Performance results on linux/amd64:</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name            old time/op  new time/op  delta
Pool-4          19.1ns Â± 2%  10.1ns Â± 1%  -47.15%  (p=0.000 n=10+8)
PoolOverflow-4  3.11Âµs Â± 1%  2.10Âµs Â± 2%  -32.66%  (p=0.000 n=10+10)

Performance results on linux/386:

name            old time/op  new time/op  delta
Pool-4          20.0ns Â± 2%  13.1ns Â± 1%  -34.59%  (p=0.000 n=10+9)
PoolOverflow-4  3.51Âµs Â± 1%  2.49Âµs Â± 0%  -28.99%  (p=0.000 n=10+8) å¯ä»¥çœ‹åˆ°ï¼Œä¿®æ”¹åæ€§èƒ½å¤§å¹…æå‡ï¼Œé‚£ä¹ˆè¿™æ¬¡æ€§èƒ½ä¼˜åŒ–çš„åŸç†æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿï¼Ÿï¼ŸåŸç‰ˆæœ¬æ˜¯è½¬åŒ–æˆ [1000000]poolLocal å®šé•¿æ•°ç»„åå¯»å€ï¼Œä¸€ä¸ªæ˜¯ç›´æ¥æ ¹æ® offset å®šä½åˆ°æŒ‡å®šå†…å­˜ï¼Œç„¶ååš poolLocal ç±»å‹è½¬æ¢ã€‚å…ˆçœ‹ä¸‹æ±‡ç¼–å®ç°
</code></pre></div></div>

<p>â€â€œ.indexLocal STEXT nosplit size=20 args=0x18 locals=0x0
    0x0000 00000 (test.go:11)   TEXT    â€œâ€œ.indexLocal(SB), NOSPLIT|ABIInternal, $0-24
    0x0000 00000 (test.go:11)   FUNCDATA    $0, gclocalsÂ·9fad110d66c97cf0b58d28cccea80b12(SB)
    0x0000 00000 (test.go:11)   FUNCDATA    $1, gclocalsÂ·7d2d5fca80364273fb07d5820a76fef4(SB)
    0x0000 00000 (test.go:11)   FUNCDATA    $3, gclocalsÂ·9a26515dfaeddd28bcbc040f1199f48d(SB)
    0x0000 00000 (test.go:12)   PCDATA  $2, $0
    0x0000 00000 (test.go:12)   PCDATA  $0, $0
    0x0000 00000 (test.go:12)   MOVQ    â€œâ€œ.i+16(SP), AX
    0x0005 00005 (test.go:12)   PCDATA  $2, $1
    0x0005 00005 (test.go:12)   PCDATA  $0, $1
    0x0005 00005 (test.go:12)   MOVQ    â€œâ€œ.l+8(SP), CX
    0x000a 00010 (test.go:12)   PCDATA  $2, $2
    0x000a 00010 (test.go:12)   LEAQ    (CX)(AX<em>8), AX
    0x000e 00014 (test.go:13)   PCDATA  $2, $0
    0x000e 00014 (test.go:13)   PCDATA  $0, $2
    0x000e 00014 (test.go:13)   MOVQ    AX, â€œâ€.~r2+24(SP)
    0x0013 00019 (test.go:13)   RET
    0x0000 48 8b 44 24 10 48 8b 4c 24 08 48 8d 04 c1 48 89  H.D$.H.L$.Hâ€¦H.
    0x0010 44 24 18 c3                                      D$..
â€œâ€œ.indexLocal2 STEXT nosplit size=58 args=0x18 locals=0x8
    0x0000 00000 (test.go:16)   TEXT    â€œâ€œ.indexLocal2(SB), NOSPLIT|ABIInternal, $8-24
    0x0000 00000 (test.go:16)   SUBQ    $8, SP
    0x0004 00004 (test.go:16)   MOVQ    BP, (SP)
    0x0008 00008 (test.go:16)   LEAQ    (SP), BP
    0x000c 00012 (test.go:16)   FUNCDATA    $0, gclocalsÂ·9fad110d66c97cf0b58d28cccea80b12(SB)
    0x000c 00012 (test.go:16)   FUNCDATA    $1, gclocalsÂ·7d2d5fca80364273fb07d5820a76fef4(SB)
    0x000c 00012 (test.go:16)   FUNCDATA    $3, gclocalsÂ·9fb7f0986f647f17cb53dda1484e0f7a(SB)
    0x000c 00012 (test.go:17)   PCDATA  $2, $1
    0x000c 00012 (test.go:17)   PCDATA  $0, $1
    0x000c 00012 (test.go:17)   MOVQ    â€œâ€œ.l+16(SP), AX
    0x0011 00017 (test.go:17)   TESTB   AL, (AX)
    0x0013 00019 (test.go:17)   MOVQ    â€œâ€œ.i+24(SP), CX
    0x0018 00024 (test.go:17)   CMPQ    CX, $1000000
    0x001f 00031 (test.go:17)   JCC 51
    0x0021 00033 (test.go:17)   LEAQ    (AX)(CX</em>8), AX
    0x0025 00037 (test.go:17)   PCDATA  $2, $0
    0x0025 00037 (test.go:17)   PCDATA  $0, $2
    0x0025 00037 (test.go:17)   MOVQ    AX, â€œâ€.~r2+32(SP)
    0x002a 00042 (test.go:17)   MOVQ    (SP), BP
    0x002e 00046 (test.go:17)   ADDQ    $8, SP
    0x0032 00050 (test.go:17)   RET
    0x0033 00051 (test.go:17)   PCDATA  $0, $1
    0x0033 00051 (test.go:17)   CALL    runtime.panicindex(SB)
    0x0038 00056 (test.go:17)   UNDEF
indexLocal æ˜¯ä¼˜åŒ–ä¹‹åçš„ï¼ŒindexLocal2 æ˜¯ä¼˜åŒ–å‰çš„ä»£ç ã€‚å¯ä»¥çœ‹å¤šï¼Œè€ç‰ˆæœ¬å¤šäº†ä¸ª CMPQ, ä¹Ÿå°±æ˜¯æŸ¥çœ‹æ˜¯å¦æ•°ç»„è¶Šç•Œçš„æ£€æŸ¥ï¼Œå¤šäº†å±‚åˆ†æ”¯é¢„æµ‹çš„é€»è¾‘ã€‚æƒ³ä¸åˆ°å§ï¼Œä¸¤ç§è½¬æ¢æ–¹å¼è¿˜æœ‰æ€§èƒ½å·®è·ã€‚</p>

<p>å¢åŠ æ— é”é˜Ÿåˆ—
poolLocal.share å­—æ®µç”± []interface{} å˜æˆäº† poolChain, è¿™ä¸ªé˜Ÿåˆ—ä¸“ä¸º Pool è€Œè®¾è®¡ï¼Œå•ç”Ÿäº§è€…å¤šæ¶ˆè´¹è€…ï¼Œå¤šæ¶ˆè´¹è€…æ¶ˆè´¹æ—¶ä½¿ç”¨ CAS å®ç°æ— é”ï¼Œå‚è§ commit. ä¸ªäººè§‰å¾—ä¸å¦‚ dpdk ring å®ç°çš„å¥½ã€‚</p>

<p>Currently, Pool stores each per-P shardâ€™s overflow in a slice
protected by a Mutex. In order to store to the overflow or steal from
another shard, a P must lock that shardâ€™s Mutex. This allows for
simple synchronization between Put and Get, but has unfortunate
consequences for clearing pools.</p>

<p>Pools are cleared during STW sweep termination, and hence rely on
pinning a goroutine to its P to synchronize between Get/Put and
clearing. This makes the Get/Put fast path extremely fast because it
can rely on quiescence-style coordination, which doesnâ€™t even require
atomic writes, much less locking.</p>

<p>The catch is that a goroutine cannot acquire a Mutex while pinned to
its P (as this could deadlock). Hence, it must drop the pin on the
slow path. But this means the slow path is not synchronized with
clearing. As a result,</p>

<p>1) Itâ€™s difficult to reason about races between clearing and the slow
path. Furthermore, this reasoning often depends on unspecified nuances
of where preemption points can occur.</p>

<p>2) Clearing must zero out the pointer to every object in every Pool to
prevent a concurrent slow path from causing all objects to be
retained. Since this happens during STW, this has an O(# objects in
Pools) effect on STW time.</p>

<p>3) We canâ€™t implement a victim cache without making clearing even
slower.</p>

<p>This CL solves these problems by replacing the locked overflow slice
with a lock-free structure. This allows Gets and Puts to be pinned the
whole time theyâ€™re manipulating the shards slice (Pool.local), which
eliminates the races between Get/Put and clearing. This, in turn,
eliminates the need to zero all object pointers, reducing clearing to
O(# of Pools) during STW.</p>

<p>In addition to significantly reducing STW impact, this also happens to
speed up the Get/Put fast-path and the slow path. It somewhat
increases the cost of PoolExpensiveNew, but weâ€™ll fix that in the next
CL.</p>

<p>name                 old time/op     new time/op     delta
Pool-12                 3.00ns Â± 0%     2.21ns Â±36%  -26.32%  (p=0.000 n=18+19)
PoolOverflow-12          600ns Â± 1%      587ns Â± 1%   -2.21%  (p=0.000 n=16+18)
PoolSTW-12              71.0Âµs Â± 2%      5.6Âµs Â± 3%  -92.15%  (p=0.000 n=20+20)
PoolExpensiveNew-12     3.14ms Â± 5%     3.69ms Â± 7%  +17.67%  (p=0.000 n=19+20)</p>

<p>name                 old p50-ns/STW  new p50-ns/STW  delta
PoolSTW-12               70.7k Â± 1%       5.5k Â± 2%  -92.25%  (p=0.000 n=20+20)</p>

<p>name                 old p95-ns/STW  new p95-ns/STW  delta
PoolSTW-12               73.1k Â± 2%       6.7k Â± 4%  -90.86%  (p=0.000 n=18+19)</p>

<p>name                 old GCs/op      new GCs/op      delta
PoolExpensiveNew-12       0.38 Â± 1%       0.39 Â± 1%   +2.07%  (p=0.000 n=20+18)</p>

<p>name                 old New/op      new New/op      delta
PoolExpensiveNew-12       33.9 Â± 6%       40.0 Â± 6%  +17.97%  (p=0.000 n=19+20)
å®Œæ•´çš„çœ‹ä¸‹ Get ä»£ç å®ç°ï¼š</p>

<p>func (p *Pool) Get() interface{} {
    if race.Enabled {
        race.Disable()
    }
    l, pid := p.pin()
    x := l.private
    l.private = nil
    if x == nil {
        // Try to pop the head of the local shard. We prefer
        // the head over the tail for temporal locality of
        // reuse.
        x, _ = l.shared.popHead()
        if x == nil {
            x = p.getSlow(pid)
        }
    }
    runtime_procUnpin()
    if race.Enabled {
        race.Enable()
        if x != nil {
            race.Acquire(poolRaceAddr(x))
        }
    }
    if x == nil &amp;&amp; p.New != nil {
        x = p.New()
    }
    return x
}</p>

<p>func (p *Pool) getSlow(pid int) interface{} {
    // See the comment in pin regarding ordering of the loads.
    size := atomic.LoadUintptr(&amp;p.localSize) // load-acquire
    local := p.local                         // load-consume
    // Try to steal one element from other procs.
    for i := 0; i &lt; int(size); i++ {
        l := indexLocal(local, (pid+i+1)%int(size))
        if x, _ := l.shared.popTail(); x != nil {
            return x
        }
    }
    return nil
}
å…·ä½“æ— é”é˜Ÿåˆ—æ€ä¹ˆå®ç°çš„ï¼Œå°±ä¸è´´äº†ï¼Œå„ç§ CASâ€¦ æ²¡å•¥ç‰¹åˆ«çš„ã€‚</p>

<p>å¢åŠ  victim cache
ä¸ºä»€ä¹ˆè¦å¢åŠ  victim cache çœ‹è¿™ä¸ª 22950ï¼Œè¯´ç™½äº†ï¼Œå°±æ˜¯è¦å‡å°‘ GC æ¸…é™¤æ‰€æœ‰ Pool åçš„å†·å¯åŠ¨é—®é¢˜ï¼Œè®©åˆ†é…å¯¹è±¡æ›´å¹³æ»‘ã€‚å‚è§ commit.</p>

<p>Currently, every Pool is cleared completely at the start of each GC.
This is a problem for heavy users of Pool because it causes an
allocation spike immediately after Pools are clear, which impacts both
throughput and latency.</p>

<p>This CL fixes this by introducing a victim cache mechanism. Instead of
clearing Pools, the victim cache is dropped and the primary cache is
moved to the victim cache. As a result, in steady-state, there are
(roughly) no new allocations, but if Pool usage drops, objects will
still be collected within two GCs (as opposed to one).</p>

<p>This victim cache approach also improves Poolâ€™s impact on GC dynamics.
The current approach causes all objects in Pools to be short lived.
However, if an application is in steady state and is just going to
repopulate its Pools, then these objects impact the live heap size <em>as
if</em> they were long lived. Since Pooled objects count as short lived
when computing the GC trigger and goal, but act as long lived objects
in the live heap, this causes GC to trigger too frequently. If Pooled
objects are a non-trivial portion of an applicationâ€™s heap, this
increases the CPU overhead of GC. The victim cache lets Pooled objects
affect the GC trigger and goal as long-lived objects.</p>

<p>This has no impact on Get/Put performance, but substantially reduces
the impact to the Pool user when a GC happens. PoolExpensiveNew
demonstrates this in the substantially reduction in the rate at which
the â€œNewâ€ function is called.</p>

<p>name                 old time/op     new time/op     delta
Pool-12                 2.21ns Â±36%     2.00ns Â± 0%     ~     (p=0.070 n=19+16)
PoolOverflow-12          587ns Â± 1%      583ns Â± 1%   -0.77%  (p=0.000 n=18+18)
PoolSTW-12              5.57Âµs Â± 3%     4.52Âµs Â± 4%  -18.82%  (p=0.000 n=20+19)
PoolExpensiveNew-12     3.69ms Â± 7%     1.25ms Â± 5%  -66.25%  (p=0.000 n=20+19)</p>

<p>name                 old p50-ns/STW  new p50-ns/STW  delta
PoolSTW-12               5.48k Â± 2%      4.53k Â± 2%  -17.32%  (p=0.000 n=20+20)</p>

<p>name                 old p95-ns/STW  new p95-ns/STW  delta
PoolSTW-12               6.69k Â± 4%      5.13k Â± 3%  -23.31%  (p=0.000 n=19+18)</p>

<p>name                 old GCs/op      new GCs/op      delta
PoolExpensiveNew-12       0.39 Â± 1%       0.32 Â± 2%  -17.95%  (p=0.000 n=18+20)</p>

<p>name                 old New/op      new New/op      delta
PoolExpensiveNew-12       40.0 Â± 6%       12.4 Â± 6%  -68.91%  (p=0.000 n=20+19)
é‡ç‚¹åœ¨æ³¨é‡Šçš„ç¬¬ä¸€æ®µï¼Œä»¥å‰ Pool çš„åŸç†ï¼šå¦‚æœå¯¹è±¡åœ¨ GC æ—¶åªæœ‰ Pool å¼•ç”¨è¿™ä¸ªå¯¹è±¡ï¼Œé‚£ä¹ˆä¼šåœ¨ GC æ—¶è¢«é‡Šæ”¾æ‰ã€‚ä½†æ˜¯å¯¹äº Pool é‡åº¦ç”¨æˆ·æ¥è®²ï¼ŒGC åä¼šæœ‰å¤§é‡çš„å¯¹è±¡åˆ†é…åˆ›å»ºï¼Œå½±å“ååå’Œæ€§èƒ½ã€‚è¿™ä¸ª patch å°±æ˜¯ä¸ºäº†è®©æ›´å¹³æ»‘ï¼Œå˜æˆäº†å¯¹è±¡è‡³å°‘å­˜æ´»ä¸¤ä¸ª GC åŒºé—´ã€‚</p>

<p>func poolCleanup() {
    // This function is called with the world stopped, at the beginning of a garbage collection.
    // It must not allocate and probably should not call any runtime functions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Because the world is stopped, no pool user can be in a
// pinned section (in effect, this has all Ps pinned).

// Drop victim caches from all pools.
for _, p := range oldPools {
    p.victim = nil
    p.victimSize = 0
}

// Move primary cache to victim cache.
for _, p := range allPools {
    p.victim = p.local
    p.victimSize = p.localSize
    p.local = nil
    p.localSize = 0
}

// The pools with non-empty primary caches now have non-empty
// victim caches and no pools have primary caches.
oldPools, allPools = allPools, nil } å¯ä»¥çœ‹ä¸‹æ–°ç‰ˆ poolCleanup å‡½æ•°æœ€åä¸€è¡Œã€‚ä½¿ç”¨æ—¶ Get ä¼šåœ¨ slow path é€»è¾‘é‡Œè°ƒç”¨ victim cache.
</code></pre></div></div>

<p>æ€»ç»“
è¡¡é‡ä¸€ä¸ªåŸºç¡€ç»„ä»¶ï¼Œä¸ä»…è¦çœ‹ä»–çš„æ€§èƒ½ï¼Œè¿˜è¦è€ƒæ»¤ç¨³å®šæ€§ï¼Œå°¤å…¶æ˜¯è¿™ç§è¯­è¨€æ ‡å‡†åº“ã€‚</p>

<p>æœ€è¿‘golangçš„1.13ç‰ˆæœ¬å‘å¸ƒäº†ï¼Œæœ‰å¾ˆå¤šæ–°ç‰¹æ€§ä¸æ”¹è¿›åˆå…¥ã€‚è¿™é‡Œä¸»è¦åˆ†æsync.poolçš„ä¼˜åŒ–ã€‚</p>

<p>æœ¬æ–‡ä¸»è¦è§£ç­”ä»¥ä¸‹å‡ ä¸ªé—®é¢˜ï¼š</p>

<p>sync.poolä¼˜åŒ–ä½“ç°åœ¨å“ªé‡Œï¼Ÿ
ä¼˜åŒ–æ˜¯å¦‚ä½•å®ç°ï¼Ÿ
ä¼˜åŒ–çš„å¥½å¤„æœ‰å“ªäº›ï¼Ÿ
ä¼˜åŒ–
å…·ä½“ä¼˜åŒ–é¡¹å¦‚ä¸‹ï¼š</p>

<p>æ— é”åŒ–
GCç­–ç•¥
æ— é”åŒ–
sync.poolå®ç°äº†æ— é”åŒ–ï¼Œå…·ä½“å¦‚ä¸‹ï¼š</p>

<p>go1.12.1ç‰ˆæœ¬å®ç°</p>

<p>// Local per-P Pool appendix.
type poolLocalInternal struct {
    private interface{}   // Can be used only by the respective P.
    shared  []interface{} // Can be used by any P.
    Mutex                 // Protects shared.
}
go1.13ç‰ˆæœ¬</p>

<p>// Local per-P Pool appendix.
type poolLocalInternal struct {
    private interface{} // Can be used only by the respective P.
    shared  poolChain   // Local P can pushHead/popHead; any P can popTail.
}
é€šè¿‡ä¸Šé¢å¯¹æ¯”å‘ç°äº†go1.12ç‰ˆæœ¬çš„Mutexåˆ é™¤äº†ã€‚é‚£ä¹ˆgo1.13ç‰ˆæœ¬åˆæ˜¯å¦‚ä½•å®ç°æ— é”åŒ–çš„å‘¢ï¼Ÿ</p>

<p>å…ˆå›ç­”é—®é¢˜ï¼šgo1.13é€šè¿‡poolChainå®ç°SPMCçš„æ— é”é˜Ÿåˆ—æ¥å®ç°æ— é”åŒ–ã€‚</p>

<p>poolChainæ˜¯ä»€ä¹ˆä¸œä¸œå‘¢ï¼Ÿ</p>

<p>åˆ«æ€¥ï¼Œä»£ç é¢å‰æ— ç§˜å¯†ã€‚ æˆ‘ä»¬å…·ä½“çœ‹ä¸€ä¸‹ä»£ç å°±å¯ä»¥äº†ã€‚</p>

<p>// poolChain is a dynamically-sized version of poolDequeue.
//
// This is implemented as a doubly-linked list queue of poolDequeues
// where each dequeue is double the size of the previous one. Once a
// dequeue fills up, this allocates a new one and only ever pushes to
// the latest dequeue. Pops happen from the other end of the list and
// once a dequeue is exhausted, it gets removed from the list.
type poolChain struct {
    // head is the poolDequeue to push to. This is only accessed
    // by the producer, so doesnâ€™t need to be synchronized.
    head *poolChainElt</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// tail is the poolDequeue to popTail from. This is accessed
// by consumers, so reads and writes must be atomic.
tail *poolChainElt }
</code></pre></div></div>

<p>type poolChainElt struct {
    poolDequeue</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// next and prev link to the adjacent poolChainElts in this
// poolChain.
//
// next is written atomically by the producer and read
// atomically by the consumer. It only transitions from nil to
// non-nil.
//
// prev is written atomically by the consumer and read
// atomically by the producer. It only transitions from
// non-nil to nil.
next, prev *poolChainElt } å…³äºpoolChainæ˜¯å¦‚ä½•å®ç°SPMCæ— é”é˜Ÿåˆ—ï¼Ÿå…·ä½“å¯ä»¥åˆ†æpoolqueue.goçš„ä»£ç ã€‚ è¿™ä¸€éƒ¨åˆ†ä¸å±•å¼€è¯´æ˜ï¼Œè¦ç‚¹å¦‚ä¸‹ï¼š
</code></pre></div></div>

<p>æ— é”é˜Ÿåˆ—æ˜¯SPMC
æ— é”é˜Ÿåˆ—æ˜¯å¯ä»¥çµæ´»è°ƒæ•´å¤§å°ï¼Œè°ƒæ•´å¤§å°çš„æ–¹æ³•ï¼šslice+double-listå®ç°ï¼ˆæ ¹æ®è¿™ä¸ªæ€è·¯æ¥é˜…è¯»ä»£ç ä¹Ÿæ˜¯å®¹æ˜“ç†è§£ ï¼‰
æ— é”é˜Ÿåˆ—çš„å®ç°åŸºç¡€æ˜¯CAS
å¥½å¤„
é¿å…é”çš„å¼€é”€ï¼Œmutexå˜æˆatomic
GCç­–ç•¥
ç›¸æ¯”è¾ƒäºgo1.12ç‰ˆæœ¬ï¼Œgo1.13ç‰ˆæœ¬ä¸­å¢åŠ äº†victim cacheã€‚å…·ä½“ä½œæ³•æ˜¯ï¼š</p>

<p>GCå¤„ç†è¿‡ç¨‹ç›´æ¥å›æ”¶oldPoolsçš„å¯¹è±¡
GCå¤„ç†å¹¶ä¸ç›´æ¥å°†allPoolsçš„objectç›´æ¥è¿›è¡ŒGCå¤„ç†ï¼Œè€Œæ˜¯ä¿å­˜åˆ°oldPoolsï¼Œç­‰åˆ°ä¸‹ä¸€ä¸ªGCå‘¨æœŸåˆ°äº†å†å¤„ç†
å…·ä½“ä»£ç å¦‚ä¸‹ï¼š</p>

<p>var (
    allPoolsMu Mutex
    allPools   []*Pool
)
var (
    allPoolsMu Mutex</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// allPools is the set of pools that have non-empty primary
// caches. Protected by either 1) allPoolsMu and pinning or 2)
// STW.
allPools []*Pool

// oldPools is the set of pools that may have non-empty victim
// caches. Protected by STW.
oldPools []*Pool ) func poolCleanup() {
// This function is called with the world stopped, at the beginning of a garbage collection.
// It must not allocate and probably should not call any runtime functions.

// Because the world is stopped, no pool user can be in a
// pinned section (in effect, this has all Ps pinned).

// Drop victim caches from all pools.
for _, p := range oldPools {
    p.victim = nil
    p.victimSize = 0
}

// Move primary cache to victim cache.
for _, p := range allPools {
    p.victim = p.local
    p.victimSize = p.localSize
    p.local = nil
    p.localSize = 0
}

// The pools with non-empty primary caches now have non-empty
// victim caches and no pools have primary caches.
oldPools, allPools = allPools, nil } è¿™æ ·å¯å¯¼è‡´Getçš„å®ç°æœ‰å˜åŒ–ï¼ŒåŸæ¥çš„å®ç°æ˜¯ï¼š
</code></pre></div></div>

<p>å…ˆä»æœ¬Pç»‘å®šçš„poolLocalè·å–å¯¹è±¡ï¼šå…ˆä»æœ¬poolLocalçš„privateæ± è·å–å¯¹è±¡ï¼Œå†ä»æœ¬poolLocalçš„sharedæ± è·å–å¯¹è±¡
ä¸Šä¸€æ­¥æ²¡æœ‰æˆåŠŸè·å–å¯¹è±¡ï¼Œå†ä»å…¶ä»–Pçš„sharedæ± è·å–å¯¹è±¡
ä¸Šä¸€æ­¥æ²¡æœ‰æˆåŠŸè·å–å¯¹è±¡ï¼Œåˆ™ä»Heapç”³è¯·å¯¹è±¡
å¼•å…¥victim cacheï¼ŒGetå®ç°å˜æˆå¦‚ä¸‹ï¼š</p>

<p>å…ˆä»æœ¬Pç»‘å®šçš„poolLocalè·å–å¯¹è±¡ï¼šå…ˆä»æœ¬poolLocalçš„privateæ± è·å–å¯¹è±¡ï¼Œå†ä»æœ¬poolLocalçš„sharedæ± è·å–å¯¹è±¡
ä¸Šä¸€æ­¥æ²¡æœ‰æˆåŠŸè·å–å¯¹è±¡ï¼Œå†ä»å…¶ä»–Pçš„sharedæ± è·å–å¯¹è±¡
ä¸Šä¸€æ­¥æ²¡æœ‰æˆåŠŸï¼Œåˆ™ä»victim cacheè·å–å¯¹è±¡
ä¸Šä¸€æ­¥æ²¡æœ‰æˆåŠŸè·å–å¯¹è±¡ï¼Œåˆ™ä»Heapç”³è¯·å¯¹è±¡
å…·ä½“ä»£ç å¦‚ä¸‹ï¼š</p>

<p>func (p *Pool) getSlow(pid int) interface{} {
    // See the comment in pin regarding ordering of the loads.
    size := atomic.LoadUintptr(&amp;p.localSize) // load-acquire
    locals := p.local                        // load-consume
    // Try to steal one element from other procs.
    for i := 0; i &lt; int(size); i++ {
        l := indexLocal(locals, (pid+i+1)%int(size))
        if x, _ := l.shared.popTail(); x != nil {
            return x
        }
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Try the victim cache. We do this after attempting to steal
// from all primary caches because we want objects in the
// victim cache to age out if at all possible.
// å°è¯•ä»victim cacheè·å–
size = atomic.LoadUintptr(&amp;p.victimSize)
if uintptr(pid) &gt;= size {
    return nil
}
locals = p.victim
l := indexLocal(locals, pid)
if x := l.private; x != nil {
    l.private = nil
    return x
}
for i := 0; i &lt; int(size); i++ {
    l := indexLocal(locals, (pid+i)%int(size))
    if x, _ := l.shared.popTail(); x != nil {
        return x
    }
}

// Mark the victim cache as empty for future gets don't bother
// with it.
atomic.StoreUintptr(&amp;p.victimSize, 0)

return nil } å¥½å¤„ ç©ºé—´ä¸Šé€šè¿‡å¼•å…¥victim cacheå¢åŠ äº†Getè·å–å†…å­˜çš„é€‰é¡¹ï¼Œå¢åŠ äº†å¯¹è±¡å¤ç”¨çš„æ¦‚ç‡ æ—¶é—´ä¸Šé€šè¿‡å»¶è¿ŸGCï¼Œå¢åŠ äº†å¯¹è±¡å¤ç”¨çš„æ—¶é—´é•¿åº¦ ä¸Šé¢è¿™ä¸ªä¸¤ä¸ªæ–¹é¢é™ä½äº†GCå¼€é”€ï¼Œå¢åŠ äº†å¯¹è±¡ä½¿ç”¨æ•ˆç‡
</code></pre></div></div>
:ET