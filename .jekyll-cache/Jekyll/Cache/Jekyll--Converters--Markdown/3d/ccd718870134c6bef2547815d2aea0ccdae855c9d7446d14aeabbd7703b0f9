I"†<p>æˆ‘ä»¬çŸ¥é“åœ¨go 1.8.xåï¼Œgolangåœ¨httpé‡ŒåŠ å…¥äº†shutdownæ–¹æ³•ï¼Œç”¨æ¥æ§åˆ¶ä¼˜é›…é€€å‡ºã€‚ä»€ä¹ˆæ˜¯ä¼˜é›…é€€å‡ºï¼Ÿ ç®€å•è¯´å°±æ˜¯ä¸å¤„ç†æ–°è¯·æ±‚ï¼Œä½†æ˜¯ä¼šå¤„ç†æ­£åœ¨è¿›è¡Œçš„è¯·æ±‚ï¼ŒæŠŠæ—§è¯·æ±‚éƒ½å¤„ç†å®Œï¼Œä¹Ÿå°±æ˜¯éƒ½responseä¹‹åï¼Œé‚£ä¹ˆå°±é€€å‡ºã€‚</p>

<p>ç¤¾åŒºé‡Œä¸å°‘http gracefulåŠ¨æ€é‡å¯ï¼Œå¹³æ»‘é‡å¯çš„åº“ï¼Œå¤§å¤šæ˜¯åŸºäºhttp.shutdownåšçš„ã€‚å¹³æ»‘å¯åŠ¨çš„åŸç†å¾ˆç®€å•ï¼Œforkå­è¿›ç¨‹ï¼Œç»§æ‰¿listen fd, è€è¿›ç¨‹ä¼˜é›…é€€å‡º
<!-- more -->
http shutdown æºç åˆ†æ</p>

<p>å…ˆæ¥çœ‹ä¸‹http shutdownçš„ä¸»æ–¹æ³•å®ç°é€»è¾‘ã€‚ç”¨atomicæ¥åšé€€å‡ºæ ‡è®°çš„çŠ¶æ€ï¼Œç„¶åå…³é—­å„ç§çš„èµ„æºï¼Œç„¶åä¸€ç›´é˜»å¡çš„ç­‰å¾…æ— ç©ºé—²è¿æ¥ï¼Œæ¯500msè½®è¯¢ä¸€æ¬¡ã€‚</p>

<p>// xiaorui.cc</p>

<p>var shutdownPollInterval = 500 * time.Millisecond</p>

<p>func (srv *Server) Shutdown(ctx context.Context) error {
    // æ ‡è®°é€€å‡ºçš„çŠ¶æ€
    atomic.StoreInt32(&amp;srv.inShutdown, 1)
    srv.mu.Lock()
    // å…³é—­listen fdï¼Œæ–°è¿æ¥æ— æ³•å»ºç«‹ã€‚
    lnerr := srv.closeListenersLocked()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// æŠŠserver.goçš„done chanç»™closeæ‰ï¼Œé€šçŸ¥ç­‰å¾…çš„worekré€€å‡º
srv.closeDoneChanLocked()

// æ‰§è¡Œå›è°ƒæ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æ³¨å†Œshutdownçš„å›è°ƒæ–¹æ³•
for _, f := range srv.onShutdown {
    go f()
}

// æ¯500msæ¥æ£€æŸ¥ä¸‹ï¼Œæ˜¯å¦æ²¡æœ‰ç©ºé—²çš„è¿æ¥äº†ï¼Œæˆ–è€…ç›‘å¬ä¸Šæ¸¸ä¼ é€’çš„ctxä¸Šä¸‹æ–‡ã€‚
ticker := time.NewTicker(shutdownPollInterval)
defer ticker.Stop()
for {
    if srv.closeIdleConns() {
        return lnerr
    }
    select {
    case &lt;-ctx.Done():
        return ctx.Err()
    case &lt;-ticker.C:
    }
} } â€¦
</code></pre></div></div>

<p>æ˜¯å¦æ²¡æœ‰ç©ºé—²çš„è¿æ¥
func (s *Server) closeIdleConns() bool {
	s.mu.Lock()
	defer s.mu.Unlock()
	quiescent := true
	for c := range s.activeConn {
		st, unixSec := c.getState()
		if st == StateNew &amp;&amp; unixSec &lt; time.Now().Unix()-5 {
			st = StateIdle
		}
		if st != StateIdle || unixSec == 0 {
			quiescent = false
			continue
		}
		c.rwc.Close()
		delete(s.activeConn, c)
	}
	return quiescent
}
å…³é—­server.doneChanå’Œç›‘å¬çš„æ–‡ä»¶æè¿°ç¬¦</p>

<p>// xiaorui.cc</p>

<p>// å…³é—­doen chan
func (s *Server) closeDoneChanLocked() {
    ch := s.getDoneChanLocked()
    select {
    case &lt;-ch:
        // Already closed. Donâ€™t close again.
    default:
        // Safe to close here. Weâ€™re the only closer, guarded
        // by s.mu.
        close(ch)
    }
}</p>

<p>// å…³é—­ç›‘å¬çš„fd
func (s <em>Server) closeListenersLocked() error {
    var err error
    for ln := range s.listeners {
        if cerr := (</em>ln).Close(); cerr != nil &amp;&amp; err == nil {
            err = cerr
        }
        delete(s.listeners, ln)
    }
    return err
}</p>

<p>// å…³é—­è¿æ¥
func (c *conn) Close() error {
    if !c.ok() {
        return syscall.EINVAL
    }
    err := c.fd.Close()
    if err != nil {
        err = &amp;OpError{Op: â€œcloseâ€, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
    }
    return err
}
è¿™ä¹ˆä¸€ç³»åˆ—çš„æ“ä½œåï¼Œserver.goçš„servä¸»ç›‘å¬æ–¹æ³•ä¹Ÿå°±é€€å‡ºäº†ã€‚</p>

<p>// xiaorui.cc 
func (srv *Server) Serve(l net.Listener) error {
    â€¦
    for {
        rw, e := l.Accept()
        if e != nil {
            select {
             // é€€å‡º
            case &lt;-srv.getDoneChan():
                return ErrServerClosed
            default:
            }
            â€¦
            return e
        }
        tempDelay = 0
        c := srv.newConn(rw)
        c.setState(c.rwc, StateNew) // before Serve can return
        go c.serve(ctx)
    }
}</p>

<p>// xiaorui.cc
é‚£ä¹ˆå¦‚ä½•ä¿è¯ç”¨æˆ·åœ¨è¯·æ±‚å®Œæˆåï¼Œå†å…³é—­è¿æ¥çš„ï¼Ÿ</p>

<p>// xiaorui.cc</p>

<p>func (s *Server) doKeepAlives() bool {
	return atomic.LoadInt32(&amp;s.disableKeepAlives) == 0 &amp;&amp; !s.shuttingDown()
}</p>

<p>// Serve a new connection.
func (c *conn) serve(ctx context.Context) {
	defer func() {
                â€¦ xiaorui.cc â€¦
		if !c.hijacked() {
                        // å…³é—­è¿æ¥ï¼Œå¹¶ä¸”æ ‡è®°é€€å‡º
			c.close()
			c.setState(c.rwc, StateClosed)
		}
	}()
        â€¦
	ctx, cancelCtx := context.WithCancel(ctx)
	c.cancelCtx = cancelCtx
	defer cancelCtx()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c.r = &amp;connReader{conn: c}
c.bufr = newBufioReader(c.r)
c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&lt;&lt;10)

for {
            // æ¥æ”¶è¯·æ±‚
	w, err := c.readRequest(ctx)
	if c.r.remain != c.server.initialReadLimitSize() {
		c.setState(c.rwc, StateActive)
	}
            ...
            ...
            // åŒ¹é…è·¯ç”±åŠå›è°ƒå¤„ç†æ–¹æ³•
	serverHandler{c.server}.ServeHTTP(w, w.req)
	w.cancelCtx()
	if c.hijacked() {
		return
	}
            ...
            // åˆ¤æ–­æ˜¯å¦åœ¨shutdown mode, é€‰æ‹©é€€å‡º
	if !w.conn.server.doKeepAlives() {
		return
	}
}
... ä½¿ç”¨å®ä¾‹ package main
</code></pre></div></div>

<p>import (
    â€œcontextâ€
    â€œfmtâ€
    â€œnet/httpâ€
    â€œosâ€
    â€œos/signalâ€
    â€œsyncâ€
    â€œsyscallâ€
    â€œtimeâ€
)</p>

<p>const addr = â€œ:9527â€</p>

<p>func main() {
    http.HandleFunc(â€œ/â€, func(w http.ResponseWriter, r <em>http.Request) {
        fmt.Fprint(w, â€œjust another http serverâ€¦â€)
    })
    //ä½¿ç”¨é»˜è®¤è·¯ç”±åˆ›å»º http server
    srv := http.Server{
        Addr:    addr,
        Handler: http.DefaultServeMux,
    }
    //ä½¿ç”¨WaitGroupåŒæ­¥Goroutine
    var wg sync.WaitGroup
    exit := make(chan os.Signal)
    //ç›‘å¬ Ctrl+C ä¿¡å·
    signal.Notify(exit, syscall.SIGINT, syscall.SIGTERM)
    go func() {
        &lt;-exit
        wg.Add(1)
        //ä½¿ç”¨contextæ§åˆ¶srv.Shutdownçš„è¶…æ—¶æ—¶é—´
        ctx, cancel := context.WithTimeout(context.Background(), 15</em>time.Second)
        defer cancel()
        err := srv.Shutdown(ctx)
        if err != nil {
            fmt.Println(err)
        }
        wg.Done()
    }()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println("listening at " + addr)
err := srv.ListenAndServe()

fmt.Println("waiting for the remaining connections to finish...")
wg.Wait()
if err != nil &amp;&amp; err != http.ErrServerClosed {
    panic(err)
}
fmt.Println("gracefully shutdown the http server...") }
</code></pre></div></div>

<p>ä¸¤ç§æ™®éçš„æ–¹æ³•ã€‚è¿™äº›æ–¹æ³•å¯ä»¥è¢«å¦‚ä¸‹æ¦‚æ‹¬:</p>

<p>ä½ å¯ä»¥åœ¨å¥—æ¥å­—ä¸Šè®¾ç½® SO_REUSEPORT ï¼Œä»è€Œè®©å¤šä¸ªè¿›ç¨‹èƒ½å¤Ÿè¢«ç»‘å®šåˆ°åŒä¸€ä¸ªç«¯å£ä¸Šã€‚åˆ©ç”¨è¿™ä¸ªæ–¹æ³•ï¼Œä½ ä¼šæœ‰å¤šä¸ªæ¥å—é˜Ÿåˆ—å‘å¤šä¸ªè¿›ç¨‹æä¾›æ•°æ®ã€‚
å¤åˆ¶å¥—æ¥å­—ï¼Œå¹¶æŠŠå®ƒä»¥æ–‡ä»¶çš„å½¢å¼ä¼ é€ç»™ä¸€ä¸ªå­è¿›ç¨‹ï¼Œç„¶ååœ¨æ–°çš„è¿›ç¨‹ä¸­é‡æ–°åˆ›å»ºè¿™ä¸ªå¥—æ¥å­—ã€‚ä½¿ç”¨è¿™ç§æ–¹æ³•ï¼Œä½ å°†æœ‰ä¸€ä¸ªæ¥å—é˜Ÿåˆ—å‘å¤šä¸ªè¿›ç¨‹æä¾›æ•°æ®ã€‚]
åœ¨æˆ‘ä»¬åˆæœŸçš„è®¨è®ºä¸­ï¼Œæˆ‘ä»¬äº†è§£åˆ°å‡ ä¸ªå…³äº SO_REUSEPORT çš„é—®é¢˜ã€‚æˆ‘ä»¬çš„ä¸€ä¸ªå·¥ç¨‹å¸ˆä¹‹å‰ä½¿ç”¨è¿™ä¸ªæ–¹æ³•ï¼Œå¹¶ä¸”æ³¨æ„åˆ°ç”±äºå…¶å¤šä¸ªæ¥å—é˜Ÿåˆ—ï¼Œæœ‰æ—¶å€™ä¼šä¸¢å¼ƒæŒ‚èµ·çš„ TCP è¿æ¥ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œå½“æˆ‘ä»¬è¿›è¡Œè¿™äº›è®¨è®ºçš„æ—¶å€™ï¼ŒGo å¹¶æ²¡æœ‰å¾ˆå¥½åœ°æ”¯æŒåœ¨ä¸€ä¸ª net.Listener ä¸Šè®¾ç½® SO_REUSEPORTã€‚ç„¶è€Œï¼Œåœ¨è¿‡å»çš„å‡ å¤©ä¸­ï¼Œåœ¨è¿™ä¸ªé—®é¢˜ä¸Šæœ‰äº†è¿›å±•ï¼Œçœ‹èµ·æ¥åƒ Go ä¸ä¹…å°±ä¼šæ”¯æŒè®¾ç½®å¥—æ¥å­—å±æ€§ã€‚</p>

<p>ç¬¬äºŒç§æ–¹æ³•ä¹Ÿå¾ˆå¸å¼•äººï¼Œå› ä¸ºå®ƒçš„ç®€å•æ€§ä»¥åŠå¤§å¤šæ•°å¼€å‘äººå‘˜ç†Ÿæ‚‰çš„ä¼ ç»ŸUnix çš„ fork/exec äº§ç”Ÿæ¨¡å‹ï¼Œå³å°†æ‰€æœ‰æ‰“å¼€æ–‡ä»¶ä¼ é€’ç»™å­è¿›ç¨‹çš„çº¦å®šã€‚éœ€è¦æ³¨æ„çš„ä¸€ç‚¹ï¼Œos/exec åŒ…å®é™…ä¸Šä¸èµåŒè¿™ç§ç”¨æ³•ã€‚ä¸»è¦æ˜¯å‡ºäºå®‰å…¨ä¸Šçš„è€ƒé‡ï¼Œå®ƒåªä¼ é€’ stdin , stdout å’Œ stderr ç»™å­è¿›ç¨‹ã€‚ç„¶è€Œï¼Œ os åŒ…ç¡®å®æä¾›è¾ƒä½çº§çš„åŸè¯­ï¼Œå¯ç”¨äºå°†æ–‡ä»¶ä¼ é€’ç»™å­ç¨‹åºï¼Œè¿™å°±æ˜¯æˆ‘ä»¬æƒ³åšçš„ã€‚</p>

:ET