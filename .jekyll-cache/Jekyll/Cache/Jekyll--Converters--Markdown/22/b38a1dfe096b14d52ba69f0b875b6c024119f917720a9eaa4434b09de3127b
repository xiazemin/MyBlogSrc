I"˜y<p>å·²ç»å®‰è£…Go 1.11åŠä»¥ä¸Šç‰ˆæœ¬ã€‚</p>

<p>Getting Started
ç¼–è¾‘main.go</p>

<p>package main</p>

<p>import â€œfmtâ€</p>

<p>func main() {
    fmt.Println(â€œHello, Go WebAssembly!â€)
}
æŠŠmain.go buildæˆWebAssembly(ç®€å†™ä¸ºwasm)äºŒè¿›åˆ¶æ–‡ä»¶</p>

<p>GOOS=js GOARCH=wasm go build -o lib.wasm main.go
æŠŠJavaScriptä¾èµ–æ‹·è´åˆ°å½“å‰è·¯å¾„</p>

<p>cp â€œ$(go env GOROOT)/misc/wasm/wasm_exec.jsâ€ .</p>

<p>ls  /usr/local/go/misc/wasm/
go_js_wasm_exec wasm_exec.html  wasm_exec.js</p>

<p>åˆ›å»ºä¸€ä¸ªindex.htmlæ–‡ä»¶ï¼Œå¹¶å¼•å…¥wasm_exec.jsæ–‡ä»¶ï¼Œè°ƒç”¨åˆšæ‰buildçš„lib.wasm</p>

<html>
    <head>
        <meta charset="utf-8" />
        <script src="wasm_exec.js"></script>
        <script>
            const go = new Go();
            WebAssembly.instantiateStreaming(fetch("lib.wasm"), go.importObject).then((result) => {
                go.run(result.instance);
            });
        </script>
    </head>
    <body></body>
</html>
<p>åˆ›å»ºserver.goç›‘å¬8080ç«¯å£ï¼Œserveå½“å‰è·¯å¾„</p>

<p>package main</p>

<p>import (
  â€œflagâ€
  â€œlogâ€
  â€œnet/httpâ€
)</p>

<p>var (
  listen = flag.String(â€œlistenâ€, â€œ:8080â€, â€œlisten addressâ€)
  dir    = flag.String(â€œdirâ€, â€œ.â€, â€œdirectory to serveâ€)
)</p>

<p>func main() {
  flag.Parse()
  log.Printf(â€œlistening on %qâ€¦â€, <em>listen)
  err := http.ListenAndServe(</em>listen, http.FileServer(http.Dir(*dir)))
  log.Fatalln(err)
}
å¯åŠ¨æœåŠ¡</p>

<p>go run server.go
åœ¨æµè§ˆå™¨è®¿é—®localhost:8080,æ‰“å¼€æµè§ˆå™¨consoleï¼Œå°±å¯ä»¥çœ‹åˆ°è¾“å‡ºHello, Go WebAssembly!ã€‚</p>

<p>reference
https://github.com/golang/go/wiki/WebAssembly
<!-- more -->
ç¼–å†™main.go</p>

<p>package main</p>

<p>import (
  â€œstrconvâ€
  â€œsyscall/jsâ€
)
// ä¼ å…¥value1, value2, resultä¸‰ä¸ªå…ƒç´ çš„idï¼Œå°†value1+value2ç»“æœèµ‹ç»™resultå…ƒç´ 
func add(ids []js.Value) {
  // æ ¹æ®idè·å–è¾“å…¥å€¼
  value1 := js.Global().Get(â€œdocumentâ€).Call(â€œgetElementByIdâ€, ids[0].String()).Get(â€œvalueâ€).String()
  value2 := js.Global().Get(â€œdocumentâ€).Call(â€œgetElementByIdâ€, ids[1].String()).Get(â€œvalueâ€).String()</p>

<p>int1, _ := strconv.Atoi(value1)
  int2, _ := strconv.Atoi(value2)
  // å°†ç›¸åŠ ç»“æœsetç»™resultå…ƒç´ 
  js.Global().Get(â€œdocumentâ€).Call(â€œgetElementByIdâ€, ids[2].String()).Set(â€œvalueâ€, int1+int2)
}</p>

<p>// æ·»åŠ ç›‘å¬äº‹ä»¶
func registerCallbacks() {
  js.Global().Set(â€œaddâ€, js.NewCallback(add))
}</p>

<p>func main() {
  c := make(chan struct{}, 0)
  println(â€œGo WebAssembly Initialized!â€)
  registerCallbacks()</p>

<p>&lt;-c
}</p>

<p>å°†main.goç¼–è¯‘æˆlib.wasm</p>

<p>GOOS=js GOARCH=wasm go build -o lib.wasm main.go
åœ¨index.htmlä¸­è°ƒç”¨lib.wasm</p>

<html>
  <head>
    <meta charset="utf-8" />
    <script src="wasm_exec.js"></script>
    <script>
      if (!WebAssembly.instantiateStreaming) { // polyfill
        WebAssembly.instantiateStreaming = async (resp, importObject) => {
          const source = await (await resp).arrayBuffer();
          return await WebAssembly.instantiate(source, importObject);
        };
      }

      const go = new Go();
      let mod, inst;
      WebAssembly.instantiateStreaming(fetch("lib.wasm"), go.importObject).then(async (result) => {
        mod = result.module;
        inst = result.instance;
        await go.run(inst)
      });
    </script>
  </head>
  <body>
    <input type="text" id="value1" />
    <input type="text" id="value2" />
    <button type="button" id="add" onclick="add('value1', 'value2', 'result');">add</button>
    <input type="text" id="result" />
  </body>
</html>
<p>æ‰“å¼€serverï¼Œåœ¨æµè§ˆå™¨æ‰“å¼€å³å¯è°ƒç”¨WebAssemblyäºŒè¿›åˆ¶æ–‡ä»¶æ‰§è¡Œã€‚</p>

<p>go run server.go
ç¤ºä¾‹ä»£ç GitHub
https://github.com/wlchn/go-webassembly
reference
https://tutorialedge.net/golang/go-webassembly-tutorial/</p>

<p>https://github.com/golang/go/wiki/WebAssembly
https://godoc.org/syscall/js
https://github.com/siongui/godom/
https://github.com/gopherjs/gopherjs</p>

<p>WebAssemblyï¼ˆä¹Ÿç§°ä¸ºwasmï¼‰å°†å¾ˆå¿«æ”¹å˜è¿™ç§æƒ…å†µã€‚ä½¿ç”¨WebAssemblyå¯ä»¥ç”¨ä»»ä½•è¯­è¨€ç¼–å†™Webåº”ç”¨ç¨‹åºã€‚åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬å°†äº†è§£å¦‚ä½•ç¼–å†™Goç¨‹åºå¹¶ä½¿ç”¨wasmåœ¨æµè§ˆå™¨ä¸­è¿è¡Œå®ƒä»¬ã€‚</p>

<p>ä½†é¦–å…ˆï¼Œä»€ä¹ˆæ˜¯WebAssembly
webassembly.org å°†å…¶å®šä¹‰ä¸ºâ€œåŸºäºå †æ ˆçš„è™šæ‹Ÿæœºçš„äºŒè¿›åˆ¶æŒ‡ä»¤æ ¼å¼â€ã€‚è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„å®šä¹‰ï¼Œä½†è®©æˆ‘ä»¬å°†å…¶åˆ†è§£ä¸ºæˆ‘ä»¬å¯ä»¥è½»æ¾ç†è§£çš„å†…å®¹ã€‚</p>

<p>ä»æœ¬è´¨ä¸Šè®²ï¼Œwasmæ˜¯ä¸€ç§äºŒè¿›åˆ¶æ ¼å¼; å°±åƒELFï¼ŒMachå’ŒPEä¸€æ ·ã€‚å”¯ä¸€çš„åŒºåˆ«æ˜¯å®ƒé€‚ç”¨äºè™šæ‹Ÿç¼–è¯‘ç›®æ ‡ï¼Œè€Œä¸æ˜¯å®é™…çš„ç‰©ç†æœºå™¨ã€‚ä¸ºä½•è™šæ‹Ÿï¼Ÿå› ä¸ºä¸åŒäº C/C++ äºŒè¿›åˆ¶æ–‡ä»¶ï¼ŒwasmäºŒè¿›åˆ¶æ–‡ä»¶ä¸é’ˆå¯¹ç‰¹å®šå¹³å°ã€‚å› æ­¤ï¼Œæ‚¨å¯ä»¥åœ¨Linuxï¼ŒWindowså’ŒMacä¸­ä½¿ç”¨ç›¸åŒçš„äºŒè¿›åˆ¶æ–‡ä»¶è€Œæ— éœ€è¿›è¡Œä»»ä½•æ›´æ”¹ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦å¦ä¸€ä¸ªâ€œä»£ç†â€ï¼Œå®ƒå°†äºŒè¿›åˆ¶æ–‡ä»¶ä¸­çš„wasmæŒ‡ä»¤è½¬æ¢ä¸ºç‰¹å®šäºå¹³å°çš„æŒ‡ä»¤å¹¶è¿è¡Œå®ƒä»¬ã€‚é€šå¸¸ï¼Œè¿™ä¸ªâ€œä»£ç†â€æ˜¯ä¸€ä¸ªæµè§ˆå™¨ï¼Œä½†ä»ç†è®ºä¸Šè®²ï¼Œå®ƒä¹Ÿå¯ä»¥æ˜¯å…¶ä»–ä»»ä½•ä¸œè¥¿ã€‚</p>

<p>è¿™ä¸ºæˆ‘ä»¬æä¾›äº†ä¸€ä¸ªé€šç”¨çš„ç¼–è¯‘ç›®æ ‡ï¼Œå¯ä»¥ä½¿ç”¨æˆ‘ä»¬é€‰æ‹©çš„ä»»ä½•ç¼–ç¨‹è¯­è¨€æ„å»ºWebåº”ç”¨ç¨‹åºï¼åªè¦æˆ‘ä»¬ç¼–è¯‘ä¸ºwasmæ ¼å¼ï¼Œæˆ‘ä»¬å°±ä¸å¿…æ‹…å¿ƒç›®æ ‡å¹³å°ã€‚å°±åƒæˆ‘ä»¬ç¼–å†™ä¸€ä¸ªWebåº”ç”¨ç¨‹åºä¸€æ ·ï¼Œä½†æ˜¯ç°åœ¨æˆ‘ä»¬æœ‰äº†ç”¨æˆ‘ä»¬é€‰æ‹©çš„ä»»ä½•è¯­è¨€ç¼–å†™å®ƒçš„ä¼˜åŠ¿ã€‚</p>

<p>ä½ å¥½ WASM
è®©æˆ‘ä»¬ä»ä¸€ä¸ªç®€å•çš„â€œhello worldâ€ç¨‹åºå¼€å§‹ï¼Œä½†æ˜¯è¦ç¡®ä¿æ‚¨çš„Goç‰ˆæœ¬è‡³å°‘ä¸º1.11ã€‚æˆ‘ä»¬å¯ä»¥è¿™æ ·å†™ï¼š</p>

<p>package main</p>

<p>import (
    â€œfmtâ€
)</p>

<p>func main() {
    fmt.Println(â€œhello wasmâ€)
}
ä¿å­˜ä¸ºtest.goã€‚çœ‹èµ·æ¥åƒæ˜¯ä¸€ä¸ªæ™®é€šçš„Goç¨‹åºã€‚ç°åœ¨è®©æˆ‘ä»¬å°†å®ƒç¼–è¯‘ä¸ºwasmå¹³å°ç¨‹åºã€‚æˆ‘ä»¬éœ€è¦è®¾ç½®GOOSå’ŒGOARCHã€‚</p>

<p>$GOOS=js GOARCH=wasm go build -o test.wasm test.go
ç°åœ¨æˆ‘ä»¬ç”Ÿæˆäº† wasm äºŒè¿›åˆ¶æ–‡ä»¶ã€‚ä½†ä¸åŸç”Ÿç³»ç»Ÿä¸åŒï¼Œæˆ‘ä»¬éœ€è¦åœ¨æµè§ˆå™¨ä¸­è¿è¡Œå®ƒã€‚ä¸ºæ­¤ï¼Œè¿˜éœ€è¦å†åšä¸€ç‚¹å·¥ä½œæ¥å®ç°è¿™ä¸€ç›®æ ‡ï¼š</p>

<p>WebæœåŠ¡å™¨æ¥è¿è¡Œåº”ç”¨
ä¸€ä¸ªindex.htmlæ–‡ä»¶ï¼Œå…¶ä¸­åŒ…å«åŠ è½½wasmäºŒè¿›åˆ¶æ–‡ä»¶æ‰€éœ€çš„ä¸€äº›jsä»£ç ã€‚
è¿˜æœ‰ä¸€ä¸ªjsæ–‡ä»¶ï¼Œå®ƒä½œä¸ºæµè§ˆå™¨å’Œæˆ‘ä»¬çš„wasmäºŒè¿›åˆ¶æ–‡ä»¶ä¹‹é—´çš„é€šä¿¡æ¥å£ã€‚</p>

<p>ç°åœ¨Goç›®å½•ä¸­å·²ç»åŒ…å«äº†htmlå’Œjsæ–‡ä»¶ï¼Œå› æ­¤æˆ‘ä»¬å°†å…¶å¤åˆ¶è¿‡æ¥ã€‚</p>

<p>$cp â€œ$(go env GOROOT)/misc/wasm/wasm_exec.jsâ€ .
$cp â€œ$(go env GOROOT)/misc/wasm/wasm_exec.htmlâ€ .</p>

<p>DOM API
ä½†é¦–å…ˆï¼Œè¦ä½¿Goä»£ç ä¸æµè§ˆå™¨è¿›è¡Œäº¤äº’ï¼Œæˆ‘ä»¬éœ€è¦ä¸€ä¸ªDOM APIã€‚æˆ‘ä»¬æœ‰syscall/jsåº“æ¥å¸®åŠ©æˆ‘ä»¬è§£å†³è¿™ä¸ªé—®é¢˜ã€‚å®ƒæ˜¯ä¸€ä¸ªéå¸¸ç®€å•å´åŠŸèƒ½å¼ºå¤§çš„DOM APIå½¢å¼ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å…¶ä¸Šæ„å»ºæˆ‘ä»¬çš„åº”ç”¨ç¨‹åºã€‚åœ¨æˆ‘ä»¬åˆ¶ä½œåº”ç”¨ç¨‹åºä¹‹å‰ï¼Œè®©æˆ‘ä»¬å¿«é€Ÿäº†è§£å®ƒçš„ä¸€äº›åŠŸèƒ½ã€‚</p>

<p>å›è°ƒ
ä¸ºäº†å“åº”DOMäº‹ä»¶ï¼Œæˆ‘ä»¬å£°æ˜äº†å›è°ƒå¹¶ç”¨è¿™æ ·çš„äº‹ä»¶å°†å®ƒä»¬è¿æ¥èµ·æ¥ï¼š</p>

<p>import â€œsyscall/jsâ€</p>

<p>// Declare callback
cb := js.NewEventCallback(js.PreventDefault, func(ev js.Value) {
    // handle event
})</p>

<p>// Hook it up with a DOM event
js.Global().Get(â€œdocumentâ€).
    Call(â€œgetElementByIdâ€, â€œmyBtnâ€).
    Call(â€œaddEventListenerâ€, â€œclickâ€, cb)</p>

<p>// Call cb.Release() on your way out.
æ›´æ–°DOM
è¦ä»Goä¸­æ›´æ–°DOMï¼Œæˆ‘ä»¬å¯ä»¥</p>

<p>import â€œsyscall/jsâ€</p>

<p>js.Global().Get(â€œdocumentâ€).
        Call(â€œgetElementByIdâ€, â€œmyTextBoxâ€).
        Set(â€œvalueâ€, â€œhello wasmâ€)
æ‚¨ç”šè‡³å¯ä»¥è°ƒç”¨JSå‡½æ•°å¹¶æ“ä½œæœ¬æœºJSå¯¹è±¡ï¼Œå¦‚ FileReaderæˆ–Canvasã€‚æŸ¥çœ‹syscall/jsæ–‡æ¡£ä»¥è·å–æ›´å¤šè¯¦ç»†ä¿¡æ¯ã€‚</p>

<p>æ­£ç¡®çš„ Web åº”ç”¨ç¨‹åº
æ¥ä¸‹æ¥æˆ‘ä»¬å°†æ„å»ºä¸€ä¸ªå°åº”ç”¨ç¨‹åºï¼Œå®ƒå°†è·å–è¾“å…¥çš„å›¾åƒï¼Œç„¶åå¯¹å›¾åƒæ‰§è¡Œä¸€äº›æ“ä½œï¼Œå¦‚äº®åº¦ï¼Œå¯¹æ¯”åº¦ï¼Œè‰²è°ƒï¼Œé¥±å’Œåº¦ï¼Œæœ€åå°†è¾“å‡ºå›¾åƒå‘é€å›æµè§ˆå™¨ã€‚ æ¯ä¸ªæ•ˆæœéƒ½ä¼šæœ‰æ»‘å—ï¼Œç”¨æˆ·å¯ä»¥æ›´æ”¹è¿™äº›æ•ˆæœå¹¶å®æ—¶æŸ¥çœ‹ç›®æ ‡å›¾åƒçš„å˜åŒ–ã€‚</p>

<p>é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦ä»æµè§ˆå™¨è·å–è¾“å…¥çš„å›¾åƒç»™åˆ°æˆ‘ä»¬çš„Goä»£ç ï¼Œä»¥ä¾¿å¯ä»¥å¤„ç†å®ƒã€‚ä¸ºäº†æœ‰æ•ˆåœ°åšåˆ°è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦é‡‡å–ä¸€äº›ä¸å®‰å…¨çš„æŠ€å·§ï¼Œè¿™é‡Œè·³è¿‡å…·ä½“ç»†èŠ‚ã€‚æ‹¥æœ‰å›¾åƒåï¼Œå®ƒå®Œå…¨åœ¨æˆ‘ä»¬çš„æ§åˆ¶ä¹‹ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥è‡ªç”±åœ°åšä»»ä½•äº‹æƒ…ã€‚ä¸‹é¢æ˜¯å›¾åƒåŠ è½½å™¨å›è°ƒçš„ç®€çŸ­ç‰‡æ®µï¼Œä¸ºç®€æ´èµ·è§ç•¥æœ‰ç®€åŒ–ï¼š</p>

<p>onImgLoadCb = js.NewCallback(func(args []js.Value) {
    reader := bytes.NewReader(inBuf) // inBuf is a []uint8 slice where our image is loaded
    sourceImg, _, err := image.Decode(reader)
    if err != nil {
        // handle error
    }
    // Now the sourceImg is an image.Image with which we are free to do anything!
})</p>

<p>js.Global().Set(â€œloadImageâ€, onImgLoadCb)
ç„¶åæˆ‘ä»¬ä»æ•ˆæœæ»‘å—ä¸­è·å–ç”¨æˆ·å€¼ï¼Œå¹¶æ“çºµå›¾åƒã€‚æˆ‘ä»¬ä½¿ç”¨äº†å¾ˆæ£’çš„bildåº“ã€‚ä¸‹é¢æ˜¯å›è°ƒçš„ä¸€å°éƒ¨åˆ†ï¼š</p>

<p>import â€œgithub.com/anthonynsimon/bild/adjustâ€</p>

<p>contrastCb = js.NewEventCallback(js.PreventDefault, func(ev js.Value) {
    delta := ev.Get(â€œtargetâ€).Get(â€œvalueAsNumberâ€).Float()
    res := adjust.Contrast(sourceImg, delta)
})</p>

<p>js.Global().Get(â€œdocumentâ€).
        Call(â€œgetElementByIdâ€, â€œcontrastâ€).
        Call(â€œaddEventListenerâ€, â€œchangeâ€, contrastCb)
åœ¨æ­¤ä¹‹åï¼Œæˆ‘ä»¬å°†ç›®æ ‡å›¾åƒç¼–ç ä¸ºjpegå¹¶å°†å…¶å‘é€å›æµè§ˆå™¨ã€‚è¿™æ˜¯å®Œæ•´çš„åº”ç”¨ç¨‹åº</p>

<p>ç”±äºGoæ˜¯ä¸€ç§åƒåœ¾æ”¶é›†è¯­è¨€ï¼Œå› æ­¤æ•´ä¸ªè¿è¡Œæ—¶éƒ½åœ¨wasmäºŒè¿›åˆ¶æ–‡ä»¶ä¸­ã€‚å› æ­¤ï¼ŒäºŒè¿›åˆ¶æ–‡ä»¶é€šå¸¸æœ‰å‡ MBçš„å¤§å°ã€‚ä¸C/Rustç­‰å…¶ä»–è¯­è¨€ç›¸æ¯”ï¼Œè¿™ä»ç„¶æ˜¯ä¸€ä¸ªç—›ç‚¹; å› ä¸ºå‘æµè§ˆå™¨å‘é€MBçº§æ•°æ®å¹¶ä¸ç†æƒ³ã€‚ä½†æ˜¯ï¼Œå¦‚æœwasmè§„èŒƒæœ¬èº«æ”¯æŒGCï¼Œé‚£ä¹ˆè¿™å¯èƒ½ä¼šæ”¹å˜ã€‚
Goä¸­çš„Wasmæ”¯æŒæ­£å¼è¿›è¡Œè¯•éªŒã€‚syscall/js APIæœ¬èº«ä¹Ÿåœ¨ä¸æ–­å˜åŒ–ï¼Œæœªæ¥å¯èƒ½ä¼šå‘ç”Ÿå˜åŒ–ã€‚å¦‚æœæ‚¨å‘ç°é”™è¯¯ï¼Œè¯·éšæ—¶åœ¨æˆ‘ä»¬issuesæŠ¥å‘Šé—®é¢˜ã€‚
ä¸æ‰€æœ‰æŠ€æœ¯ä¸€æ ·ï¼ŒWebAssemblyä¹Ÿä¸æ˜¯ä¸€é¢—é“¶å¼¹ã€‚æœ‰æ—¶ï¼Œç®€å•çš„JSæ›´å¿«æ›´å®¹æ˜“ç¼–å†™ã€‚ç„¶è€Œï¼Œwasmè§„èŒƒæœ¬èº«æ­£åœ¨å¼€å‘ä¸­ï¼Œå¹¶ä¸”å³å°†æ¨å‡ºæ›´å¤šåŠŸèƒ½ã€‚çº¿ç¨‹æ”¯æŒå°±æ˜¯è¿™æ ·ä¸€ä¸ªç‰¹æ€§ã€‚</p>

<p>ç¯å¢ƒ
éœ€è¦golangç‰ˆæœ¬é«˜äºgo1.11, æœ¬æ–‡golangç‰ˆæœ¬:</p>

<p>å‡çº§go ç‰ˆæœ¬åidea golang æ ‡å‡†åº“ä¹Ÿæ ‡çº¢ è§£å†³åŠæ³•ï¼Œå°† /usr/local/go/ ä¹ŸåŠ å…¥gopath é—®é¢˜è§£å†³</p>

<p>$ go version</p>
<blockquote>
  <p>go version go1.11.1 darwin/amd64
jsä¸­è°ƒç”¨golangå‡½æ•°æ¡ˆä¾‹
æœ¬æ¡ˆä¾‹åŸºäºgoland IDEç¼–å†™, ä¸ºäº†è·å–syscall/jsåº“çš„è‡ªåŠ¨æç¤º, éœ€è¦å¯¹IDEè¿›è¡Œå¦‚ä¸‹è®¾ç½®:
<img src="https://xiazemin.github.io/MyBlog/img/system_js.jpg" /></p>
</blockquote>

<p>ç‚¹å‡»File -&gt; Project Structure æ‰“å¼€é¡¹ç›®ç»“æ„é…ç½®çª—å£ã€‚ åŠ è½½go1.13.5</p>

<p>è§£å†³æ–¹æ³•æ˜¯ File-Invalidate Caches ç„¶åé‡å¯IDEAã€‚</p>

<p>./webassembly.go:54:35: undefined: js.NewCallback</p>

<p>js.Global().Set(â€œjsFunctionNameâ€, js.NewCallback(goCallback))
should be as:</p>

<p>js.Global().Set(â€œjsFunctionNameâ€, js.FuncOf(goCallback))
Note the signature of goCallback has changed and now since Go 1.12, there is a support for return values. For example, here is how to expose a simple add function:</p>

<p>// function definition
func add(this js.Value, i []js.Value) interface{} {
  return js.ValueOf(i[0].Int()+i[1].Int())
}</p>

<p>// exposing to JS
js.Global().Set(â€œaddâ€, js.FuncOf(add))</p>

<p>https://stackoverflow.com/questions/55800163/golangs-syscall-js-js-newcallback-is-undefined</p>

<p>./main.go:22:34: cannot use add (type func([]js.Value)) as type func(js.Value, []js.Value) interface {} in argument to js.FuncOf</p>

<p>//https://godoc.org/syscall/js
//https://github.com/golang/go/wiki/WebAssembly#getting-started</p>

<p>https://github.com/vugu/vugu</p>

<p>åœ¨æ¯ä¸ªæµè§ˆå™¨é‡Œé¢ï¼Œæ— è®ºChromeï¼ŒFirefoxï¼ŒSafariï¼ŒEdgeï¼Œèƒ½å¤Ÿè¿è¡Œçš„è¯­è¨€å°±æ˜¯Javascriptã€‚ä¸ºäº†èƒ½å¤Ÿè®©å…¶ä»–è¯­è¨€çš„ä»£ç åœ¨æµè§ˆå™¨ä¸­è¿è¡Œï¼ŒWebAssemblyè¢«åˆ›é€ å‡ºæ¥ã€‚å®ƒæ‹¥æœ‰æ›´å¥½æ€§èƒ½ï¼Œæ›´å°çš„sizeï¼Œèƒ½å¤Ÿæ›´å¿«çš„åŠ è½½å’Œæ‰§è¡Œã€‚æˆ‘ä»¬æ— éœ€ç¼–å†™WebAssemblyçš„ä»£ç ï¼Œåªéœ€è¦å°†å…¶ä»–é«˜çº§è¯­è¨€ç¼–è¯‘æˆWebAssemblyï¼Œè¿™æ ·å°±èƒ½åœ¨æµè§ˆå™¨ä¸­å¤ç”¨å¤§é‡çš„å…¶ä»–è¯­è¨€ç°æœ‰çš„ä»£ç ã€‚</p>

<p>WebAssemblyä»åœ¨æŒç»­çš„å‘å±•ï¼Œè¿˜æœ‰å¤§é‡çš„ç‰¹æ€§å³å°†åˆ°æ¥ã€‚å…¶æœ€æ—©å‘æ˜å‡ºæ¥æ˜¯ä¸ºäº†å°†C++çš„è½¬è¯‘æˆJSï¼Œç„¶ååœ¨æµè§ˆå™¨ä¸­è¿è¡Œèµ·æ¥ï¼Œè¿™æ ·å°±èƒ½æŠŠå¤§é‡ç°æœ‰çš„C++ä»£ç åœ¨æµè§ˆå™¨ä¸­å¤ç”¨ã€‚è¢«è½¬è¯‘åçš„JSä»£ç æ¯”åŸç”Ÿçš„JSä»£ç è¦æ…¢ï¼ŒMozillaçš„å·¥ç¨‹å¸ˆå‘ç°ä¸€ç§ç±»å‹ç³»ç»Ÿï¼Œå¯ä»¥è®©è¢«è½¬è¯‘åçš„JSè¿è¡Œå¾—æ›´å¿«ï¼Œè¿™å°±æ˜¯asm.js. åŒæ—¶ï¼Œå…¶ä»–æµè§ˆå™¨å‚å•†å‘ç°asm.jsçš„è¿è¡Œé€Ÿåº¦éå¸¸å¿«ï¼Œä¹ŸæŠŠè¿™ç§ä¼˜åŒ–åŠ å…¥åˆ°ä»–ä»¬çš„æµè§ˆå™¨å¼•æ“ä¸­ã€‚è¿™ä»…ä»…æ˜¯å¼€å§‹ï¼Œå·¥ç¨‹å¸ˆä»¬ä»åœ¨æŒç»­åŠªåŠ›ï¼Œä½†æ˜¯ï¼Œä¸æ˜¯å°†å…¶ä»–è¯­è¨€ç¼–è¯‘æˆJSï¼Œè€Œæ˜¯ä¸€ç§æ–°çš„è¯­è¨€ï¼Œé‚£å°±æ˜¯WebAssemblyã€‚</p>

<p>æœ€å°å¯ç”¨äº§å“</p>

<p>WebAssemblyä¸ä»…ä»…æ”¯æŒC/C++ï¼ŒåŒæ—¶ä¹Ÿå¸Œæœ›æ”¯æŒæ›´å¤šçš„é«˜çº§è¯­è¨€ï¼Œå› æ­¤ï¼Œéœ€è¦ä¸€ä¸ªè¯­è¨€æ— å…³çš„ç¼–è¯‘ç›®æ ‡ï¼Œå°±åƒæ±‡ç¼–è¯­è¨€ä¸€æ ·ï¼Œæ”¯æŒä»»ä½•è¯­è¨€ç¼–è¯‘æˆæ±‡ç¼–è¯­è¨€ã€‚è¿™ä¸ªç¼–è¯‘ç›®æ ‡æœ‰å¦‚ä¸‹çš„ç‰¹ç‚¹ï¼š</p>

<p>è·Ÿå…·ä½“çš„å¹³å°æ— å…³ï¼Œå› æ­¤ä¸åŒå¹³å°çš„ä¸åŒæµè§ˆå™¨éƒ½èƒ½è¿è¡ŒWebAssemblyã€‚
æ‹¥æœ‰è¶³å¤Ÿå¿«çš„è¿è¡Œé€Ÿåº¦ï¼Œèƒ½å¤Ÿå¸¦æ¥è¶³å¤Ÿæµç•…çš„äº¤äº’ä½“éªŒã€‚
åŠ è½½é€Ÿåº¦è¦è¶³å¤Ÿå¿«ï¼Œå› æ­¤ï¼Œéœ€è¦ç¼–è¯‘ç›®æ ‡èƒ½å¤Ÿè¢«å‹ç¼©ï¼Œå‡å°åŠ è½½å†…å®¹çš„å¤§å°
èƒ½å¤Ÿæ‰‹åŠ¨çš„ç®¡ç†ï¼Œåˆ†é…å†…å­˜ã€‚æˆ‘ä»¬çŸ¥é“C/C++ä¸€ç±»çš„è¯­è¨€æ”¯æŒæŒ‡é’ˆçš„ç‰¹æ€§ï¼Œé€šè¿‡æŒ‡é’ˆå¯ä»¥è¯»å†™ç‰¹å®šåœ°å€çš„å†…å­˜ï¼›ä¸ºäº†å®‰å…¨è€ƒè™‘ï¼Œè¿˜è¦å¯¹é™åˆ¶ç‰¹å®šåœ°å€çš„å†…å­˜è¿›è¡Œæ“ä½œã€‚å‡ºäºä»¥ä¸Šçš„äº®ç‚¹ï¼ŒWebAssemblyä½¿ç”¨äº†çº¿æ€§å†…å­˜æ¨¡å‹ã€‚
é€šè¿‡ä»¥ä¸Šçš„ç‰¹ç‚¹ï¼Œä¿è¯äº†WebAssemblyèƒ½å¤Ÿåœ¨ç”Ÿäº§ç¯å¢ƒä¸­ä½¿ç”¨èµ·æ¥ã€‚</p>

<p>å¦‚ä½•åº”å¯¹ç¹é‡çš„æ¡Œé¢åº”ç”¨</p>

<p>æˆ‘ä»¬çŸ¥é“ï¼Œå¤§é‡çš„æ¡Œé¢åº”ç”¨ï¼ŒåƒPSï¼ŒAutoCADï¼Œè¿™äº›åº”ç”¨éå¸¸çš„åºå¤§ï¼Œå¯¹æ€§èƒ½è¦æ±‚éå¸¸è‹›åˆ»ã€‚è¦å…ˆè®©ä»–ä»¬åœ¨æµè§ˆå™¨é‡Œé¢è¿è¡Œèµ·æ¥éå¸¸çš„éš¾ï¼Œå› æ­¤éœ€è¦æ›´å¤šçš„ç‰¹æ€§æ¥ç¡®ä¿æ›´ä½³çš„æ€§èƒ½ï¼š</p>

<p>é¦–å½“å…¶å†²çš„ï¼Œæ˜¯éœ€è¦æ”¯æŒå¤šçº¿ç¨‹ã€‚ç°ä»£çš„è®¡ç®—æœºéƒ½æ˜¯å¤šæ ¸çš„ï¼Œé€šè¿‡å¤šçº¿ç¨‹èƒ½å¤Ÿæ›´å¥½çš„åˆ©ç”¨è®¡ç®—æœºçš„è®¡ç®—èƒ½åŠ›ã€‚
SIMD(å•æŒ‡ä»¤å¤šæ•°æ®)ã€‚é€šè¿‡SIMDï¼Œèƒ½å¤Ÿå°†ä¸€ç»„å†…å­˜åˆ’åˆ†æˆä¸åŒçš„æ‰§è¡Œå•å…ƒï¼Œå°±åƒå¤šæ ¸ä¸€æ ·ã€‚
64ä½å¯»å€ã€‚å€ŸåŠ©64ä½å¯»å€ï¼Œèƒ½å¤Ÿä½¿ç”¨æ›´å¤šçš„å†…å­˜ï¼Œè¿™å¯¹ä¸€äº›å†…å­˜æ•æ„Ÿæ€§çš„åº”ç”¨æ˜¯éå¸¸æœ‰åˆ©çš„ã€‚
æµå¼ç¼–è¯‘ã€‚å‰é¢æåˆ°äº†ï¼Œæå‡åŠ è½½çš„é€Ÿåº¦ï¼Œå…¶å®æˆ‘ä»¬æœ‰æ›´å¥½çš„åŠæ³•ï¼Œå°±æ˜¯åˆšä¸‹è½½çš„æ—¶å€™å°±å¼€å§‹ç¼–è¯‘ï¼Œè¿™å°†æ˜¯å·¨å¤§çš„æå‡ã€‚
HTTPç¼“å­˜ã€‚å¦‚ä½•ä¸¤ä¸ªæµè§ˆå™¨åŠ è½½ç›¸åŒçš„WebAssemblyä»£ç ï¼Œå°†ä¼šç¼–è¯‘æˆç›¸åŒçš„æœºå™¨ç ï¼Œå› æ­¤å¯ä»¥å°†ç¼–è¯‘åçš„æœºå™¨ç ä¿å­˜åœ¨HTTPç¼“å­˜ä¸­ï¼Œè¿™æ ·å°±å¯ä»¥è·³è¿‡ç¼–è¯‘çš„è¿‡ç¨‹ï¼Œå¤ç”¨æœºå™¨ç ã€‚
ç°çŠ¶
å¤šçº¿ç¨‹ï¼šä¸€ä¸ªè‰æ¡ˆå·²ç»æ¥è¿‘å®Œæˆï¼Œå…¶ä¸­çš„å…³é”®SharedArrayBuffersï¼Œå·²ç»è¢«å¦å†³äº†ã€‚
SIMDï¼šæ­£åœ¨å¼€å‘ä¸­â€¦
64ä½å¯»å€ï¼šwasm-64å³å°†ç™»åœº
æµå¼ç¼–è¯‘ï¼šFirefoxå·²ç»åœ¨2017å¹´æ”¯æŒï¼Œå…¶ä»–æµè§ˆå™¨ä¹Ÿå³å°†æ”¯æŒ
è™½ç„¶è¿™äº›ç‰¹æ€§ä»åœ¨å¼€å‘ä¸­ï¼Œä½†æ˜¯æˆ‘ä»¬èƒ½å¤Ÿçœ‹åˆ°å·²ç»æœ‰å¤§é‡çš„æ¡Œé¢åº”ç”¨åœ¨æµè§ˆå™¨ä¸­è¿è¡Œèµ·æ¥ï¼Œå…¶ä¸­æœ€å¤§çš„å¹•ååŠŸè‡£å°±æ˜¯WebAssemblyã€‚</p>

<p>WebAssemblyä¸JavaScript</p>

<p>å¯¹äºå¾ˆå¤šçš„webåº”ç”¨åœºæ™¯ï¼Œæˆ‘ä»¬å¯èƒ½åªéœ€è¦åœ¨ä¸€äº›æ€§èƒ½æ•æ„Ÿçš„éƒ¨åˆ†ï¼Œä½¿ç”¨WebAssemblyã€‚å› æ­¤ï¼ŒæŸäº›æ¨¡å—éœ€è¦ç”¨WebAssemblyæ¥ç¼–å†™ï¼Œç„¶åæ›¿æ¢æ‰é‚£äº›JSå†™çš„éƒ¨åˆ†ã€‚ä¸€ä¸ªä¾‹å­å°±æ˜¯Firefoxä¸­çš„source map libraryçš„parserï¼Œå®ƒç”¨WebAssemblyç¼–å†™ï¼Œæ¯”åŸæ¥ç”¨JSç¼–å†™çš„å¿«11å€ã€‚ä¸ºäº†èƒ½è®©è¿™ç§åœºæ™¯ä¸‹ï¼ŒWebAssemblyæ›´å¥½çš„å‘æŒ¥ä½œç”¨ï¼Œæœ‰æ›´å¤šçš„è¦æ±‚ï¼š</p>

<p>JSå’ŒWASMèƒ½å¤Ÿæ›´å¿«çš„ç›¸äº’è°ƒç”¨ã€‚å› ä¸ºè¦å°†WASMä»£ç ä½œä¸ºæ¨¡å—ç»§æ‰¿åˆ°ç°å­˜çš„JSåº”ç”¨ä¸­ï¼Œéœ€è¦ä»–ä»¬èƒ½å¤Ÿæ›´å¿«çš„ç›¸äº’è°ƒç”¨ï¼ŒFirefoxä¸­å·²ç»æœ‰äº†å·¨å¤§çš„æå‡
å¿«é€Ÿè€Œå®¹æ˜“çš„æ•°æ®è½¬æ¢ã€‚åœ¨JSå’ŒWASMç›¸äº’è°ƒç”¨æ—¶ï¼Œéœ€è¦ä¼ é€’æ•°æ®ï¼Œè¦æƒ³å®ç°ä¸Šé¢çš„ä¸¤ä¸ªç›®æ ‡ï¼Œéå¸¸çš„éš¾ï¼šWASMåªç†è§£æ•°å­—ï¼Œé‚£å°±éœ€è¦å°†å„ç§æ•°æ®æ ¼å¼è½¬æ¢æˆæ•°å­—
ES moduleã€‚é›†æˆWASMæ¨¡å—ï¼Œé€šå¸¸åœ¨JSä¸­ä½¿ç”¨importï¼Œexportå…³é”®è¯ï¼Œå› æ­¤ï¼Œæµè§ˆå™¨éœ€è¦å†…ç½®ES moduleã€‚
å·¥å…·é“¾ã€‚åœ¨JSä¸­ï¼Œå¯ä»¥ä½¿ç”¨npmï¼Œbrowerç­‰å·¥å…·ï¼Œä½†æ˜¯åœ¨WASMä¸­ï¼Œå¥½åƒæ²¡æœ‰è¿™ä¸ªå·¥å…·â€¦
å…¼å®¹æ€§ã€‚å‰ç«¯å¼€å‘ï¼Œéƒ½é€ƒä¸äº†å…¼å®¹æ€§çš„é—®é¢˜ã€‚
ç°çŠ¶
Firefoxä¸­ï¼ŒJSå’ŒWASMèƒ½å¤Ÿå¾ˆå¿«çš„è°ƒç”¨
å¼•ç”¨ç±»å‹è‰æ¡ˆç™»åœºï¼Œå…¶å¢åŠ äº†ä¸€ç§æ–°çš„ï¼ŒWASMå‡½æ•°èƒ½å¤Ÿæ¥æ”¶å’Œè¿”å›çš„ç±»å‹ï¼Œè¿™ä¸ªç±»å‹å¼•ç”¨ä¸€ä¸ªå¤–éƒ¨çš„objectï¼Œå¯ä»¥æ˜¯JSçš„Objectã€‚
ä¸€ä¸ªES moduleçš„è‰æ¡ˆè¢«æåŠï¼Œæµè§ˆå™¨å‚å•†æ­£åœ¨æ”¯æŒã€‚
Rustç”Ÿæ€çš„wasm-packèƒ½å¤Ÿåƒnpmä¸€æ ·æ”¯æŒåŒ…ç®¡ç†
å€ŸåŠ©wasm2jså·¥å…·ï¼Œèƒ½å¤Ÿè®©WASMåœ¨æ—§ç‰ˆçš„æµè§ˆå™¨ä¸­å¾—åˆ°æ”¯æŒ
é€šè¿‡ä»¥ä¸Šçš„ç‰¹æ€§ä»¥åŠæ­£åœ¨å¼€å‘ä¸­çš„åŠŸèƒ½ï¼ŒWASMçš„èƒ½åŠ›å¾—åˆ°é‡Šæ”¾ï¼Œæ¥ä¸‹æ¥å°±æ˜¯å¦‚ä½•å†ç°æœ‰çš„Webç”Ÿæ€ä¸­ä½¿ç”¨WASMã€‚</p>

<p>åº”ç”¨</p>

<p>åœ¨å‰ç«¯å¼€å‘ä¸­ï¼Œå¤§é‡æ¶‰åŠçš„æ¡†æ¶åŠç¼–è¯‘æˆJSçš„è¯­è¨€éƒ½å°†æ˜¯WASMå‘æŒ¥ä½œç”¨çš„åœºæ™¯ã€‚æ‰€ä»¥å°±æœ‰ä¸¤ç§é€‰æ‹©äº†ï¼š1ï¼Œä½¿ç”¨WASMæ¥é‡å†™ç°æœ‰çš„Webæ¡†æ¶ï¼›2ï¼Œå°†Reasonmlï¼ŒElmç­‰è¯­è¨€ç¼–è¯‘æˆWASMã€‚ä¸ºäº†å®ç°è¿™äº›åŠŸèƒ½ï¼Œéœ€è¦WASMæä¾›æ›´å¤šé«˜çº§è¯­è¨€çš„ç‰¹æ€§ï¼ŒåŒ…æ‹¬ï¼š</p>

<p>GCã€‚é¦–å…ˆï¼Œæä¾›GCåŠŸèƒ½å¯¹é‡å†™webæ¡†æ¶æ˜¯éå¸¸æœ‰ä¼˜åŠ¿çš„ã€‚ä¾‹å¦‚ï¼šä½¿ç”¨WASMé‡å†™Reactä¸­çš„diffåŠŸèƒ½ï¼Œå€ŸåŠ©å¤šçº¿ç¨‹ï¼Œæ‰‹åŠ¨çš„å†…å­˜åˆ†é…ï¼Œèƒ½å¤Ÿæä¾›ä»¥å‰æ— æ³•ç°è±¡çš„é«˜æ€§èƒ½ï¼Œä½†æ˜¯å½“ä½ è·ŸJS å¯¹è±¡äº¤äº’æ—¶ï¼Œä¾‹å¦‚ç»„ä»¶ï¼Œä»ç„¶éœ€è¦GCæ¥å‡è½»å¼€å‘çš„è´Ÿæ‹…ã€‚
å¼‚å¸¸å¤„ç†ã€‚å¾ˆå¤šçš„é«˜çº§è¯­è¨€ï¼Œå¦‚C/C++æä¾›å¼‚å¸¸å¤„ç†ï¼Œåœ¨æŸäº›ç‰¹å®šåœºæ™¯ä¸‹éå¸¸æœ‰ç”¨ï¼ŒåŒæ—¶JSä¹Ÿæœ‰å¼‚å¸¸å¤„ç†ï¼Œå½“WASMå’ŒJSäº’æ“ä½œæ—¶ï¼Œä¹Ÿéœ€è¦æœ‰å¼‚å¸¸å¤„ç†çš„æ”¯æŒã€‚
debugã€‚è¿™ä¸ªå°±ä¸å¤šè¯´
ç°çŠ¶
JSæ‹¥æœ‰Typed Objects è‰æ¡ˆï¼ŒWASMæ‹¥æœ‰GCè‰æ¡ˆã€‚é€šè¿‡è¿™ä¸¤ä¸ªè‰æ¡ˆï¼ŒJSå’ŒWASMéƒ½èƒ½å¤Ÿæ¸…æ™°çš„çŸ¥é“ä¸€ä¸ªå¯¹è±¡çš„ç»“æ„ä»¥åŠå¦‚ä½•å»å­˜å‚¨ï¼Œä½¿ç”¨ï¼Œå›æ”¶ã€‚
å¼‚å¸¸å¤„ç†ã€‚ç›®å‰è¿˜åœ¨å¼€å‘é˜¶æ®µã€‚
debugã€‚ç›®å‰ï¼Œå¤§å¤šæ•°æµè§ˆå™¨å·²ç»æ”¯æŒã€‚</p>

<p>https://hacks.mozilla.org/2018/10/webassemblys-post-mvp-future/</p>

<p>https://cloud.tencent.com/developer/article/1369556</p>

<p>able Of Contents
Introduction
Starting Point
Function Registration
Components
Building a Router
A Full Example
Challenges Going Forward
Conclusion
JavaScript Frontend frameworks have undoubtedly helped to push the boundaries of what was previously possible in the context of a browser. Ever more complex applications have come out built on top of the likes of React, Angular and VueJS to name but a few and thereâ€™s the well known joke about how a new frontend framework seems to come out every day.</p>

<p>However, this pace of development is exceptionally good news for developers around the world. With each new framework, we discover better ways of handling state, or rendering efficiently with things like the shadow DOM.</p>

<p>The latest trend however, seems to be moving towards writing these frameworks in languages other than JavaScript and compiling them into WebAssembly. Weâ€™re starting to see major improvements in the way that JavaScript and WebAssembly communicates thanks to the likes of Lin Clark and weâ€™ll undoubtedly see more major improvements as WebAssembly starts to become more prominent in our lives.</p>

<p>Introduction
So, in this tutorial, I thought it would be a good idea to build the base of an incredibly simple frontend framework written in Go that compiles into WebAssembly. At a minimum, this will include the following features:</p>

<p>Function Registration
Components
Super Simplistic-Routing
Iâ€™m warning you now though that these are going to be incredibly simple and nowhere near production ready. If this is article is somewhat popular, Iâ€™ll hopefully be taking it forward however, and trying to build something that meets the requirements of a semi-decent frontend framework.</p>

<p>Github: The full source code of this project can be found here: elliotforbes/oak. If you fancy contributing to the project, feel free, Iâ€™d be happy to get any pull requests!</p>

<p>Starting Point
Right, letâ€™s dive into our editor of choice and start coding! The first thing weâ€™ll want to do is create a really simple index.html that will act as our entry point for our frontend framework:</p>

<p>1&lt;!doctype html&gt;
 2<!--
 3Copyright 2018 The Go Authors. All rights reserved.
 4Use of this source code is governed by a BSD-style
 5license that can be found in the LICENSE file.
 6-->
 7&lt;html&gt;
 8
 9&lt;head&gt;
10    <meta charset="utf-8" />
11    <title>Go wasm</title>
12    <script src="./static/wasm_exec.js"></script>
13    <script src="./static/entrypoint.js"></script>
14&lt;/head&gt;
15&lt;body&gt;  <br />
16
17  &lt;div class="container"&gt;
18    &lt;h2&gt;Oak WebAssembly Framework&lt;/h2&gt;
19  &lt;/div&gt;
20&lt;/body&gt;
21
22&lt;/html&gt;
Youâ€™ll notice these have 2 js files being imported at the top, these allow us to execute our finished WebAssembly binary. The first of which is about 414 lines long so, in the interest of keeping this tutorial readable, I recommend you download it from here: https://github.com/elliotforbes/oak/blob/master/examples/blog/static/wasm_exec.js</p>

<p>The second is our entrypoint.js file. This will fetch and run the lib.wasm that weâ€™ll be building very shortly.</p>

<p>1// static/entrypoint.js
2const go = new Go();
3WebAssembly.instantiateStreaming(fetch(â€œlib.wasmâ€), go.importObject).then((result) =&gt; {
4    go.run(result.instance);
5});
Finally, now that we have that out of the way, we can start diving into some Go code! Create a new file called main.go which will contain the entry point to our Oak Web Framework!</p>

<p>1// main.go
2package main
3
4func main() {
5    println(â€œOak Framework Initializedâ€)
6}
This is as simple as it gets. Weâ€™ve created a really simple Go program that should just print out Oak Framework Initialized when we open up our web app. To verify that everything works, we need to compile this using the following command:</p>

<p>1$ GOOS=js GOARCH=wasm go build -o lib.wasm main.go
This should then build our Go code and output our lib.wasm file which we referenced in our entrypoint.js file.</p>

<p>Awesome, if everything worked, then we are ready to try it out in the browser! We can use a really simple file server like this:</p>

<p>1// server.go
 2package main
 3
 4import (
 5    â€œflagâ€
 6    â€œlogâ€
 7    â€œnet/httpâ€
 8)
 9
10var (
11    listen = flag.String(â€œlistenâ€, â€œ:8080â€, â€œlisten addressâ€)
12    dir    = flag.String(â€œdirâ€, â€œ.â€, â€œdirectory to serveâ€)
13)
14
15func main() {
16    flag.Parse()
17    log.Printf(â€œlistening on %qâ€¦â€, <em>listen)
18    log.Fatal(http.ListenAndServe(</em>listen, http.FileServer(http.Dir(*dir))))
19}
You can then serve your application by typing go run server.go and you should be able to access your app from http://localhost:8080.</p>

<p>Function Registration
Ok, so weâ€™ve got a fairly basic print statement working, but in the grand scheme of things, I donâ€™t quite think that qualifies it as a Web Framework just yet.</p>

<p>Letâ€™s take a look at how we can build functions in Go and register these so we can call them in our index.html. Weâ€™ll create a new utility function which will take in both a string which will be the name of our function as well as the Go function it will map to.</p>

<p>Add the following to your existing main.go file:</p>

<p>1// main.go
2import â€œsyscall/jsâ€
3
4// RegisterFunction
5func RegisterFunction(funcName string, myfunc func(i []js.Value)) {
6    js.Global().Set(funcName, js.NewCallback(myfunc))
7}
So, this is where things start to become a bit more useful. Our framework now allows us to register functions so users of the framework can start creating their own functionality.</p>

<p>Other projects using our framework can start to register their own functions that can subsequently be used within their own frontend applications.</p>

<p>Components
So, I guess the next thing we need to consider adding to our framework is the concept of components. Basically, I want to be able to define a components/ directory within a project that uses this, and within that directory I want to be able to build like a home.gocomponent that features all the code needed for my homepage.</p>

<p>So, how do we go about doing this?</p>

<p>Well, React tends to feature classes that feature render() functions which return the HTML/JSX/whatever code you wish to render for said component. Letâ€™s steal this and use it within our own components.</p>

<p>I essentially want to be able to do something like this within a project that uses this framework:</p>

<p>1package components
2
3type HomeComponent struct{}
4
5var Home HomeComponent
6
7func (h HomeComponent) Render() string {
8    return â€œ&lt;h2&gt;Home Component&lt;/h2&gt;â€
9}
So, within my components package, I define a HomeComponent which features a Render() method which returns our HTML.</p>

<p>In order to add components to our framework, weâ€™ll keep it simple and just define an interface to which any components we subsequently define will have to adhere to. Create a new file called components/comopnent.go within our Oak framework:</p>

<p>1// components/component.go
2package component
3
4type Component interface {
5    Render() string
6}
What happens if we want to add new functions to our various components? Well, this allows us to do just that. We can use the oak.RegisterFunction call within the initfunction of our component to register any functions we want to use within our component!</p>

<p>1package components
 2
 3import (
 4    â€œsyscall/jsâ€
 5
 6    â€œgithub.com/elliotforbes/oakâ€
 7)
 8
 9type AboutComponent struct{}
10
11var About AboutComponent
12
13func init() {
14    oak.RegisterFunction(â€œcoolFuncâ€, CoolFunc)
15}
16
17func CoolFunc(i []js.Value) {
18    println(â€œdoes stuffâ€)
19}
20
21func (a AboutComponent) Render() string {
22    return <code class="language-plaintext highlighter-rouge">&lt;div&gt;
23                        &lt;h2&gt;About Component Actually Works&lt;/h2&gt;
24                        &lt;button onClick="coolFunc();"&gt;Cool Func&lt;/button&gt;
25                    &lt;/div&gt;</code>
26}
When we combine this with a router, we should be able to see our HTML being rendered to our page and we should be able to click that button which calls coolFunc() and it will print out does stuff within our browser console!</p>

<p>Awesome, letâ€™s see how we can go about building a simple router now.</p>

<p>Building a Router
Ok, so weâ€™ve got the concept of components within our web framework down. Weâ€™ve almost finished right?</p>

<p>Not quite, the next thing weâ€™ll likely need is a means to navigate between different components. Most frameworks seem to have a &lt;div&gt; with a particular id that they bind to and render all their components within, so weâ€™ll steal that same tactic within Oak.</p>

<p>Letâ€™s create a router/router.go file within our oak framework so that we can start hacking away.</p>

<p>Within this, weâ€™ll want to map string paths to components, we wont do any URL checking, weâ€™ll just keep everything in memory for now to keep things simple:</p>

<p>1// router/router.go
 2package router
 3
 4import (
 5    â€œsyscall/jsâ€
 6
 7    â€œgithub.com/elliotforbes/oak/componentâ€
 8)
 9
10type Router struct {
11    Routes map[string]component.Component
12}
13
14var router Router
15
16func init() {
17    router.Routes = make(map[string]component.Component)
18}
So within this, weâ€™ve created a new Router struct which contains Routes which are a map of strings to the components we defined in the previous section.</p>

<p>Routing wonâ€™t be a mandatory concept within our framework, weâ€™ll want users to choose when they wish to initialize a new router. So letâ€™s create a new function that will register a Link function and also bind the first route in our map to our &lt;div id="view"/&gt; html tag:</p>

<p>1// router/router.go
 2// â€¦
 3func NewRouter() {
 4    js.Global().Set(â€œLinkâ€, js.NewCallback(Link))
 5    js.Global().Get(â€œdocumentâ€).Call(â€œgetElementByIdâ€, â€œviewâ€).Set(â€œinnerHTMLâ€, â€œâ€)
 6}
 7
 8func RegisterRoute(path string, component component.Component) {
 9    router.Routes[path] = component
10}
11
12func Link(i []js.Value) {
13    println(â€œLink Hitâ€)
14
15    comp := router.Routes[i[0].String()]
16    html := comp.Render()
17
18    js.Global().Get(â€œdocumentâ€).Call(â€œgetElementByIdâ€, â€œviewâ€).Set(â€œinnerHTMLâ€, html)
19}
You should notice, weâ€™ve created a RegisterRoute function which allows us to register a path to a given component.</p>

<p>Our Link function is also pretty cool in the sense that it will allow us to navigate between various components within a project. We can specify really simple <button>elements to allow us to navigate to registered paths like so:</button></p>

<p>1<button onclick="Link('link')">Clicking this will render our mapped Link component</button>
Awesome, so weâ€™ve got a really simple router up and running now, if we wanted to use this in a simple application we could do so like this:</p>

<p>1// my-project/main.go
 2package main
 3
 4import (
 5    â€œgithub.com/elliotforbes/oakâ€
 6    â€œgithub.com/elliotforbes/oak/examples/blog/componentsâ€
 7    â€œgithub.com/elliotforbes/oak/routerâ€
 8)
 9
10func main() {
11    // Starts the Oak framework
12    oak.Start()
13
14    // Starts our Router
15    router.NewRouter()
16    router.RegisterRoute(â€œhomeâ€, components.Home)
17    router.RegisterRoute(â€œaboutâ€, components.About)
18
19    // keeps our app running
20    done := make(chan struct{}, 0)
21    &lt;-done
22}
A Full Example
With all of this put together, we can start building really simple web applications that feature components and routing. If you want to see a couple of examples as to how this works, then check out the examples within the official repo: elliotforbes/oak/examples</p>

<p>Challenges Going Forward
The code in this framework is in no way production ready, but Iâ€™m hoping this post kicks off good discussion as to how we can start building more production ready frameworks in Go.</p>

<p>If nothing else, it starts the journey of identifying what still has to be done to make this a viable alternative to the likes of React/Angular/VueJS, all of which are phenomenal frameworks that massively speed up developer productivity.</p>

<p>Iâ€™m hoping this article motivates some of you to go off and start looking at how you can improve on this incredibly simple starting point.</p>

<p>Conclusion
If you enjoyed this tutorial, then please feel free to share it to your friends, on your twitter, or wherever you feel like, it really helps the site and directly supports me writing more!</p>

<p>Iâ€™m also on YouTube, so feel free to subscribe to my channel for more Go content! - TutorialEdge.</p>

<p>The full source code for the Oak framework can be found here: github.com/elliotforbes/oak. Feel free to submit PRs!</p>

<p>https://www.vugu.org/doc/start
https://github.com/vugu/vugu</p>
:ET