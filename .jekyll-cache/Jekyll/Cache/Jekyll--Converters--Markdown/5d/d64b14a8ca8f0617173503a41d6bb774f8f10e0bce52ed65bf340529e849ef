I"Ğ2<p>åŸå‹</p>

<p>func Print(a â€¦interface{}) (n int, err error) { return Fprint(os.Stdout, aâ€¦)}func Println(a â€¦interface{}) (n int, err error) { return Fprintln(os.Stdout, aâ€¦)}func Printf(format string, a â€¦interface{}) (n int, err error) { return Fprintf(os.Stdout, format, aâ€¦)}
Printï¼šä½¿ç”¨é»˜è®¤æ ¼å¼è¯´æ˜ç¬¦æ‰“å°æ ¼å¼å¹¶å†™å…¥æ ‡å‡†è¾“å‡ºã€‚å½“ä¸¤è€…éƒ½ä¸æ˜¯å­—ç¬¦ä¸²æ—¶ï¼Œåœ¨æ“ä½œæ•°ä¹‹é—´æ·»åŠ ç©ºæ ¼
Printlnï¼šåŒä¸Šï¼Œä¸åŒçš„åœ°æ–¹æ˜¯å§‹ç»ˆåœ¨æ“ä½œæ•°ä¹‹é—´æ·»åŠ ç©ºæ ¼ï¼Œå¹¶é™„åŠ æ¢è¡Œç¬¦
Printfï¼šæ ¹æ®æ ¼å¼è¯´æ˜ç¬¦è¿›è¡Œæ ¼å¼åŒ–å¹¶å†™å…¥æ ‡å‡†è¾“å‡º
ä»¥ä¸Šä¸‰ç±»å°±æ˜¯æœ€å¸¸è§çš„æ ¼å¼åŒ– I/O çš„æ–¹æ³•
<!-- more -->
æ¡ˆä¾‹ä¸€ï¼šPrint</p>

<p>åœ¨è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ Print æ–¹æ³•åšä¸€ä¸ªåˆ†æï¼Œä¾¿äºåé¢çš„åŠ æ·±ç†è§£</p>

<p>func Print(a â€¦interface{}) (n int, err error) { return Fprint(os.Stdout, aâ€¦)}Print ä½¿ç”¨é»˜è®¤æ ¼å¼è¯´æ˜ç¬¦æ‰“å°æ ¼å¼å¹¶å†™å…¥æ ‡å‡†è¾“å‡ºã€‚å¦å¤–å½“ä¸¤è€…éƒ½ä¸ºéç©ºå­—ç¬¦ä¸²æ—¶å°†æ’å…¥ä¸€ä¸ªç©ºæ ¼</p>

<p>åŸå‹</p>

<p>func Fprint(w io.Writer, a â€¦interface{}) (n int, err error) { p := newPrinter() p.doPrint(a) n, err = w.Write(p.buf) p.free() return}è¯¥å‡½æ•°ä¸€å…±æœ‰ä¸¤ä¸ªå½¢å‚ï¼š</p>

<p>wï¼šè¾“å‡ºæµï¼Œåªè¦å®ç° io.Writer å°±å¯ä»¥ï¼ˆæŠ½è±¡ï¼‰ä¸ºæµçš„å†™å…¥
aï¼šä»»æ„ç±»å‹çš„å¤šä¸ªå€¼
åˆ†æä¸»å¹²æµç¨‹</p>

<p>1ã€ p := newPrinter(): ç”³è¯·ä¸€ä¸ªä¸´æ—¶å¯¹è±¡æ± ï¼ˆsync.Poolï¼‰</p>

<p>var ppFree = sync.Pool{ New: func() interface{} { return new(pp) },}func newPrinter() <em>pp { p := ppFree.Get().(</em>pp) p.panicking = false p.erroring = false p.fmt.init(&amp;p.buf) return p}
ppFree.Get()ï¼šåŸºäº sync.Pool å®ç° *pp çš„ä¸´æ—¶å¯¹è±¡æ± ï¼Œæ¯æ¬¡è·å–ä¸€å®šä¼šè¿”å›ä¸€ä¸ªæ–°çš„ pp å¯¹è±¡ç”¨äºæ¥ä¸‹æ¥çš„å¤„ç†
*pp.panickingï¼šç”¨äºè§£å†³æ— é™é€’å½’çš„ panicã€recover é—®é¢˜ï¼Œä¼šæ ¹æ®è¯¥å‚æ•°åœ¨ catchPanic åŠæ—¶ææ–­
*pp.erroringï¼šç”¨äºè¡¨ç¤ºæ­£åœ¨å¤„ç†é”™è¯¯æ— æ•ˆçš„ verb æ ‡è¯†ç¬¦ï¼Œä¸»è¦ä½œç”¨æ˜¯é˜²æ­¢è°ƒç”¨ handleMethods æ–¹æ³•
*pp.fmt.init(&amp;p.buf)ï¼šåˆå§‹åŒ– fmt é…ç½®ï¼Œä¼šè®¾ç½® buf å¹¶ä¸”æ¸…ç©º fmtFlags æ ‡å¿—ä½
2ã€ p.doPrint(a): æ‰§è¡Œçº¦å®šçš„æ ¼å¼åŒ–åŠ¨ä½œï¼ˆå‚æ•°é—´å¢åŠ ä¸€ä¸ªç©ºæ ¼ã€æœ€åä¸€ä¸ªå‚æ•°å¢åŠ æ¢è¡Œç¬¦ï¼‰</p>

<p>func (p *pp) doPrint(a []interface{}) { prevString := false for argNum, arg := range a { true &amp;&amp; false isString := arg != nil &amp;&amp; reflect.TypeOf(arg).Kind() == reflect.String // Add a space between two non-string arguments. if argNum &gt; 0 &amp;&amp; !isString &amp;&amp; !prevString { p.buf.WriteByte(â€˜ â€˜) } p.printArg(arg, â€˜vâ€™) prevString = isString }}å¯ä»¥çœ‹åˆ°åº•å±‚é€šè¿‡åˆ¤æ–­è¯¥å…¥å‚ï¼ŒåŒæ—¶æ»¡è¶³ä»¥ä¸‹æ¡ä»¶å°±ä¼šæ·»åŠ åˆ†éš”ç¬¦ï¼ˆç©ºæ ¼ï¼‰ï¼š</p>

<p>å½“å‰å…¥å‚ä¸ºå¤šä¸ªå‚æ•°ï¼ˆä¾‹å¦‚ï¼šSliceï¼‰
å½“å‰å…¥å‚ä¸ä¸º nil ä¸”ä¸ä¸ºå­—ç¬¦ä¸²ï¼ˆé€šè¿‡åå°„ç¡®å®šï¼‰
å½“å‰å…¥å‚ä¸ä¸ºé¦–é¡¹æˆ–ä¸Šä¸€ä¸ªå…¥å‚ä¸ä¸ºå­—ç¬¦ä¸²
è€Œåœ¨ Print æ–¹æ³•ä¸­ï¼Œä¸éœ€è¦æŒ‡å®šæ ¼å¼ç¬¦ã€‚å®é™…ä¸Šåœ¨è¯¥æ–¹æ³•å†…ç›´æ¥æŒ‡å®šä¸º vã€‚ä¹Ÿå°±æ˜¯é»˜è®¤æ ¼å¼çš„å€¼</p>

<p>p.printArg(arg, â€˜vâ€™)
w.Write(p.buf): å†™å…¥æ ‡å‡†è¾“å‡ºï¼ˆio.Writerï¼‰
*pp.free(): é‡Šæ”¾å·²ç¼“å­˜çš„å†…å®¹ã€‚åœ¨ä½¿ç”¨å®Œä¸´æ—¶å¯¹è±¡åï¼Œä¼šå°† bufã€argã€value æ¸…ç©ºå†é‡æ–°å­˜æ”¾åˆ° ppFree ä¸­ã€‚ä»¥ä¾¿äºåé¢å†å–å‡ºé‡ç”¨ï¼ˆåˆ©ç”¨ sync.Pool çš„ä¸´æ—¶å¯¹è±¡ç‰¹æ€§ï¼‰
æ¡ˆä¾‹äºŒï¼šPrintf</p>

<p>æ ‡è¯†ç¬¦</p>

<p>Verbs</p>

<p>%v the value in a default format when printing structs, the plus flag (%+v) adds field names%#v a Go-syntax representation of the value%T a Go-syntax representation of the type of the value%% a literal percent sign; consumes no value%t the word true or falseFlags</p>

<ul>
  <li>always print a sign for numeric values; guarantee ASCII-only output for %q (%+q)- pad with spaces on the right rather than the left (left-justify the field)# alternate format: add leading 0 for octal (%#o), 0x for hex (%#x); 0X for hex (%#X); suppress 0x for %p (%#p); for %q, print a raw (backquoted) string if strconv.CanBackquote returns true; always print a decimal point for %e, %E, %f, %F, %g and %G; do not remove trailing zeros for %g and %G; write e.g. U+0078 â€˜xâ€™ if the character is printable for %U (%#U).â€™ â€˜ (space) leave a space for elided sign in numbers (% d); put spaces between bytes printing strings or slices in hex (% x, % X)0 pad with leading zeros rather than spaces; for numbers, this moves the padding after the signè¯¦ç»†å»ºè®®å‚è§ Godoc</li>
</ul>

<p>åŸå‹</p>

<p>func Fprintf(w io.Writer, format string, a â€¦interface{}) (n int, err error) { p := newPrinter() p.doPrintf(format, a) n, err = w.Write(p.buf) p.free() return}ä¸ Print ç›¸æ¯”ï¼Œæœ€å¤§çš„ä¸åŒå°±æ˜¯ doPrintf æ–¹æ³•äº†ã€‚åœ¨è¿™é‡Œæˆ‘ä»¬æ¥è¯¦ç»†çœ‹çœ‹å…¶ä»£ç ï¼Œå¦‚ä¸‹ï¼š</p>

<p>func (p <em>pp) doPrintf(format string, a []interface{}) { end := len(format) argNum := 0 // we process one argument per non-trivial format afterIndex := false // previous item in format was an index like [3]. p.reordered = falseformatLoop: for i := 0; i &lt; end; { p.goodArgNum = true lasti := i for i &lt; end &amp;&amp; format[i] != â€˜%â€™ { i++ } if i &gt; lasti { p.buf.WriteString(format[lasti:i]) } if i &gt;= end { // done processing format string break } // Process one verb i++ // Do we have flags? p.fmt.clearflags() simpleFormat: for ; i &lt; end; i++ { c := format[i] switch c { case â€˜#â€™: //â€™#â€™ã€â€™0â€™ã€â€™+â€™ã€â€™-â€˜ã€â€™ â€˜ â€¦ default: if â€˜aâ€™ &lt;= c &amp;&amp; c &lt;= â€˜zâ€™ &amp;&amp; argNum &lt; len(a) { â€¦ p.printArg(a[argNum], rune(c)) argNum++ i++ continue formatLoop } break simpleFormat } } // Do we have an explicit argument index? argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a)) // Do we have width? if i &lt; end &amp;&amp; format[i] == â€˜</em>â€™ { â€¦ } // Do we have precision? if i+1 &lt; end &amp;&amp; format[i] == â€˜.â€™ { â€¦ } if !afterIndex { argNum, i, afterIndex = p.argNumber(argNum, format, i, len(a)) } if i &gt;= end { p.buf.WriteString(noVerbString) break } â€¦ switch { case verb == â€˜%â€™: // Percent does not absorb operands and ignores f.wid and f.prec. p.buf.WriteByte(â€˜%â€™) case !p.goodArgNum: p.badArgNum(verb) case argNum &gt;= len(a): // No argument left over to print for the current verb. p.missingArg(verb) case verb == â€˜vâ€™: â€¦ fallthrough default: p.printArg(a[argNum], verb) argNum++ } } if !p.reordered &amp;&amp; argNum &lt; len(a) { â€¦ }}åˆ†æä¸»å¹²æµç¨‹</p>

<p>å†™å…¥ % ä¹‹å‰çš„å­—ç¬¦å†…å®¹
å¦‚æœæ‰€æœ‰æ ‡å¿—ä½å¤„ç†å®Œæ¯•ï¼ˆåˆ°è¾¾å­—ç¬¦å°¾éƒ¨ï¼‰ï¼Œåˆ™è·³å‡ºå¤„ç†é€»è¾‘
ï¼ˆå¾€åç§»ï¼‰è·³è¿‡ % ï¼Œå¼€å§‹å¤„ç†å…¶ä»– verb æ ‡å¿—ä½
æ¸…ç©ºï¼ˆé‡æ–°åˆå§‹åŒ–ï¼‰ fmt é…ç½®
å¤„ç†ä¸€äº›åŸºç¡€çš„ verb æ ‡è¯†ç¬¦ï¼ˆsimpleFormatï¼‰ã€‚å¦‚ï¼šâ€™#â€™ã€â€™0â€™ã€â€™+â€™ã€â€™-â€˜ã€â€™ â€˜ ä»¥åŠç®€å•çš„ verbs æ ‡è¯†ç¬¦ï¼ˆä¸åŒ…å«ç²¾åº¦ã€å®½åº¦å’Œå‚æ•°ç´¢å¼•ï¼‰ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè‹¥å½“å‰å­—ç¬¦ä¸ºç®€å• verb æ ‡è¯†ç¬¦ã€‚åˆ™ç›´æ¥è¿›è¡Œå¤„ç†ã€‚å®Œæˆåä¼šç›´æ¥åç§»åˆ°ä¸‹ä¸€ä¸ªå­—ç¬¦ã€‚å…¶ä½™æ ‡å¿—ä½åˆ™å˜æ›´ fmt é…ç½®é¡¹ï¼Œä¾¿äºåç»­å¤„ç†
å¤„ç†å‚æ•°ç´¢å¼•ï¼ˆargument indexï¼‰
å¤„ç†å‚æ•°å®½åº¦ï¼ˆwidthï¼‰
å¤„ç†å‚æ•°ç²¾åº¦ï¼ˆprecisionï¼‰
% ä¹‹åè‹¥ä¸å­˜åœ¨ verbs æ ‡è¯†ç¬¦åˆ™è¿”å› noVerbStringã€‚å€¼ä¸º %!(NOVERB)
å¤„ç†ç‰¹æ®Š verbs æ ‡è¯†ç¬¦ï¼ˆå¦‚ï¼šâ€™%%â€™ã€â€™%#vâ€™ã€â€™%+vâ€™ï¼‰ã€é”™è¯¯æƒ…å†µï¼ˆå¦‚ï¼šå‚æ•°ç´¢å¼•æŒ‡å®šé”™è¯¯ã€å‚æ•°é›†ä¸ªæ•°ä¸ verbs æ ‡è¯†ç¬¦æ•°é‡ä¸åŒ¹é…ï¼‰æˆ–è¿›è¡Œæ ¼å¼åŒ–å‚æ•°é›†
å¸¸è§„æµç¨‹å¤„ç†å®Œæ¯•
åœ¨ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œè‹¥æä¾›çš„å‚æ•°é›†æ¯” verb æ ‡è¯†ç¬¦å¤šã€‚fmt å°†ä¼šè´ªå©ªæ£€æŸ¥ä¸‹å»ï¼Œå°†å¤šå‡ºçš„å‚æ•°é›†ä»¥ç‰¹å®šçš„æ ¼å¼è¾“å‡ºï¼Œå¦‚ä¸‹ï¼š</p>

<p>fmt.Printf(â€œ%dâ€, 1, 2, 3)// 1%!(EXTRA int=2, int=3)
çº¦å®šå‰ç¼€é¢å¤–æ ‡å¿—ï¼š%!(EXTRA
å½“å‰å‚æ•°çš„ç±»å‹
çº¦å®šæ ¼å¼ç¬¦ï¼š=
å½“å‰å‚æ•°çš„å€¼ï¼ˆé»˜è®¤ä»¥ %v æ ¼å¼åŒ–ï¼‰
çº¦å®šæ ¼å¼ç¬¦ï¼š)
å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œå½“æŒ‡å®šäº†å‚æ•°ç´¢å¼•æˆ–å®é™…å¤„ç†çš„å‚æ•°å°äºå…¥å‚çš„å‚æ•°é›†æ—¶ï¼Œå°±ä¸ä¼šè¿›è¡Œè´ªå©ªåŒ¹é…æ¥å±•ç¤º</p>

<p>æ¡ˆä¾‹ä¸‰ï¼šPrintln</p>

<p>åŸå‹</p>

<p>func Fprintln(w io.Writer, a â€¦interface{}) (n int, err error) { p := newPrinter() p.doPrintln(a) n, err = w.Write(p.buf) p.free() return}åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ï¼Œæœ€å¤§çš„åŒºåˆ«å°±æ˜¯ doPrintlnï¼Œæˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹ï¼Œå¦‚ä¸‹ï¼š</p>

<p>func (p *pp) doPrintln(a []interface{}) { for argNum, arg := range a { if argNum &gt; 0 { p.buf.WriteByte(â€˜ â€˜) } p.printArg(arg, â€˜vâ€™) } p.buf.WriteByte(â€˜\nâ€™)}åˆ†æä¸»å¹²æµç¨‹</p>

<p>å¾ªç¯å…¥å‚çš„å‚æ•°é›†ï¼Œå¹¶ä»¥ç©ºæ ¼åˆ†éš”
æ ¼å¼åŒ–å½“å‰å‚æ•°ï¼Œé»˜è®¤ä»¥ %v å¯¹å‚æ•°è¿›è¡Œæ ¼å¼åŒ–
åœ¨ç»“å°¾æ·»åŠ  \n å­—ç¬¦
å¦‚ä½•æ ¼å¼åŒ–å‚æ•°</p>

<p>åœ¨ä¸Šä¾‹çš„æ‰§è¡Œæµç¨‹åˆ†æä¸­ï¼Œå¯ä»¥çœ‹åˆ°æ ¼å¼åŒ–å‚æ•°è¿™ä¸€æ­¥æ˜¯åœ¨ p.printArg(arg, verb) æ‰§è¡Œçš„ï¼Œæˆ‘ä»¬ä¸€èµ·æ¥çœ‹çœ‹å®ƒéƒ½åšäº†äº›ä»€ä¹ˆï¼Ÿ</p>

<p>func (p *pp) printArg(arg interface{}, verb rune) { p.arg = arg p.value = reflect.Value{} if arg == nil { switch verb { case â€˜Tâ€™, â€˜vâ€™: p.fmt.padString(nilAngleString) default: p.badVerb(verb) } return } switch verb { case â€˜Tâ€™: p.fmt.fmt_s(reflect.TypeOf(arg).String()) return case â€˜pâ€™: p.fmtPointer(reflect.ValueOf(arg), â€˜pâ€™) return } // Some types can be done without reflection. switch f := arg.(type) { case bool: p.fmtBool(f, verb) case float32: p.fmtFloat(float64(f), 32, verb) â€¦ case reflect.Value: if f.IsValid() &amp;&amp; f.CanInterface() { p.arg = f.Interface() if p.handleMethods(verb) { return } } p.printValue(f, verb, 0) default: if !p.handleMethods(verb) { p.printValue(reflect.ValueOf(f), verb, 0) } }}åœ¨å°èŠ‚ä»£ç ä¸­å¯ä»¥çœ‹è§ï¼Œfmt æœ¬èº«å¯¹ä¸åŒçš„ç±»å‹åšäº†ä¸åŒçš„å¤„ç†ã€‚è¿™æ ·å­å°±é¿å…äº†é€šè¿‡åå°„ç¡®å®šã€‚ç›¸å¯¹çš„æé«˜äº†æ€§èƒ½</p>

<p>å…¶ä¸­æœ‰ä¸¤ä¸ªç‰¹æ®Šçš„æ–¹æ³•ï¼Œåˆ†åˆ«æ˜¯ handleMethods å’Œ badVerbï¼Œæ¥ä¸‹æ¥åˆ†åˆ«æ¥çœ‹çœ‹ä»–ä»¬çš„ä½œç”¨æ˜¯ä»€ä¹ˆ</p>

<p>1ã€badVerb</p>

<p>å®ƒä¸»è¦ç”¨äºæ ¼å¼åŒ–å¹¶å¤„ç†é”™è¯¯çš„è¡Œä¸ºã€‚æˆ‘ä»¬å¯ä»¥ä¸€èµ·æ¥çœ‹çœ‹ï¼Œä»£ç å¦‚ä¸‹ï¼š</p>

<p>func (p *pp) badVerb(verb rune) { p.erroring = true p.buf.WriteString(percentBangString) p.buf.WriteRune(verb) p.buf.WriteByte(â€˜(â€˜) switch { case p.arg != nil: p.buf.WriteString(reflect.TypeOf(p.arg).String()) p.buf.WriteByte(â€˜=â€™) p.printArg(p.arg, â€˜vâ€™) â€¦ default: p.buf.WriteString(nilAngleString) } p.buf.WriteByte(â€˜)â€™) p.erroring = false}åœ¨å¤„ç†é”™è¯¯æ ¼å¼åŒ–æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹æ¯”ä»¥ä¸‹ä¾‹å­ï¼š</p>

<p>fmt.Printf(â€œ%sâ€, []int64{1, 2, 3})// [%!s(int64=1) %!s(int64=2) %!s(int64=3)]%åœ¨ badVerb ä¸­å¯ä»¥çœ‹åˆ°é”™è¯¯å­—ç¬¦ä¸²çš„å¤„ç†ä¸»è¦åˆ†ä¸ºä»¥ä¸‹éƒ¨åˆ†ï¼š</p>

<p>çº¦å®šå‰ç¼€é”™è¯¯æ ‡å¿—ï¼š%!
å½“å‰çš„æ ¼å¼åŒ–æ“ä½œç¬¦
çº¦å®šæ ¼å¼ç¬¦ï¼š(
å½“å‰å‚æ•°çš„ç±»å‹
çº¦å®šæ ¼å¼ç¬¦ï¼š=
å½“å‰å‚æ•°çš„å€¼ï¼ˆé»˜è®¤ä»¥ %v æ ¼å¼åŒ–ï¼‰
çº¦å®šæ ¼å¼ç¬¦ï¼š)
2ã€handleMethods</p>

<p>func (p *pp) handleMethods(verb rune) (handled bool) { if p.erroring { return } // Is it a Formatter? if formatter, ok := p.arg.(Formatter); ok { handled = true defer p.catchPanic(p.arg, verb) formatter.Format(p, verb) return } // If weâ€™re doing Go syntax and the argument knows how to supply it, take care of it now. â€¦ return false}è¿™ä¸ªæ–¹æ³•æ¯”è¾ƒç‰¹æ®Šï¼Œä¸€èˆ¬åœ¨è‡ªå®šä¹‰ç»“æ„ä½“å’ŒæœªçŸ¥æƒ…å†µä¸‹è¿›è¡Œè°ƒç”¨ã€‚ä¸»è¦æµç¨‹æ˜¯ï¼š</p>

<p>è‹¥å½“å‰å‚æ•°ä¸ºé”™è¯¯ verb æ ‡è¯†ç¬¦ï¼Œåˆ™ç›´æ¥è¿”å›
åˆ¤æ–­æ˜¯å¦å®ç°äº† Formatter
å®ç°ï¼Œåˆ™åˆ©ç”¨è‡ªå®šä¹‰ Formatter æ ¼å¼åŒ–å‚æ•°
æœªå®ç°ï¼Œåˆ™æœ€å¤§ç¨‹åº¦çš„åˆ©ç”¨ Go syntax é»˜è®¤è§„åˆ™å»æ ¼å¼åŒ–å‚æ•°
æ‹“å±•</p>

<p>åœ¨ fmt æ ‡å‡†åº“ä¸­å¯ä»¥é€šè¿‡è‡ªå®šä¹‰ç»“æ„ä½“æ¥å®ç°æ–¹æ³•çš„è‡ªå®šä¹‰ï¼Œå¤§è‡´å¦‚ä¸‹å‡ ç§</p>

<p>fmt.State</p>

<p>type State interface { Write(b []byte) (n int, err error) Width() (wid int, ok bool) Precision() (prec int, ok bool) Flag(c int) bool}State ç”¨äºè·å–æ ‡å¿—ä½çš„çŠ¶æ€å€¼ï¼Œæ¶‰åŠå¦‚ä¸‹ï¼š</p>

<p>Writeï¼šå°†æ ¼å¼åŒ–å®Œæ¯•çš„å­—ç¬¦å†™å…¥ç¼“å†²åŒºä¸­ï¼Œç­‰å¾…ä¸‹ä¸€æ­¥å¤„ç†
Widthï¼šè¿”å›å®½åº¦ä¿¡æ¯å’Œæ˜¯å¦è¢«è®¾ç½®
Precisionï¼šè¿”å›ç²¾åº¦ä¿¡æ¯å’Œæ˜¯å¦è¢«è®¾ç½®
Flagï¼šè¿”å›ç‰¹æ®Šæ ‡å¿—ç¬¦ï¼ˆâ€™#â€™ã€â€™0â€™ã€â€™+â€™ã€â€™-â€˜ã€â€™ â€˜ï¼‰æ˜¯å¦è¢«è®¾ç½®
fmt.Formatter</p>

<p>type Formatter interface { Format(f State, c rune)}Formatter ç”¨äºå®ç°è‡ªå®šä¹‰æ ¼å¼åŒ–æ–¹æ³•ã€‚å¯é€šè¿‡åœ¨è‡ªå®šä¹‰ç»“æ„ä½“ä¸­å®ç° Format æ–¹æ³•æ¥å®ç°è¿™ä¸ªç›®çš„</p>

<p>å¦å¤–ï¼Œå¯ä»¥é€šè¿‡ f è·å–åˆ°å½“å‰æ ‡è¯†ç¬¦çš„å®½åº¦ã€ç²¾åº¦ç­‰çŠ¶æ€å€¼ã€‚c ä¸º verb æ ‡è¯†ç¬¦ï¼Œå¯ä»¥å¾—åˆ°å…¶åŠ¨ä½œæ˜¯ä»€ä¹ˆ</p>

<p>fmt.Stringer</p>

<p>type Stringer interface { String() string}å½“è¯¥å¯¹è±¡ä¸º Stringã€Arrayã€Slice ç­‰ç±»å‹æ—¶ï¼Œå°†ä¼šè°ƒç”¨ String() æ–¹æ³•å¯¹ç±»å­—ç¬¦ä¸²è¿›è¡Œæ ¼å¼åŒ–</p>

<p>fmt.GoStringer</p>

<p>type GoStringer interface { GoString() string}å½“æ ¼å¼åŒ–ç‰¹å®š verb æ ‡è¯†ç¬¦ï¼ˆ%vï¼‰æ—¶ï¼Œå°†è°ƒç”¨ GoString() æ–¹æ³•å¯¹å…¶è¿›è¡Œæ ¼å¼åŒ–</p>

<p>æ€»ç»“</p>

<p>é€šè¿‡æœ¬æ–‡å¯¹ fmt æ ‡å‡†åº“çš„åˆ†æï¼Œå¯ä»¥å‘ç°å®ƒæœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š</p>

<p>åœ¨æ‹“å±•æ€§æ–¹é¢ï¼Œå¯ä»¥è‡ªå®šä¹‰æ ¼å¼åŒ–æ–¹æ³•ç­‰
åœ¨å®Œæ•´åº¦æ–¹é¢ï¼Œå°½å¯èƒ½çš„è´ªå©ªåŒ¹é…ï¼Œè¾“å‡ºå‚æ•°é›†
åœ¨æ€§èƒ½æ–¹é¢ï¼Œæ¯ç§ä¸åŒçš„å‚æ•°ç±»å‹ï¼Œéƒ½å®ç°äº†ä¸åŒçš„æ ¼å¼åŒ–å¤„ç†æ“ä½œ
åœ¨æ€§èƒ½æ–¹é¢ï¼Œå°½å¯èƒ½çš„æœ€çŸ­åŒ¹é…ï¼Œæ ¼å¼åŒ–å‚æ•°é›†</p>
:ET