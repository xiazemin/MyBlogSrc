I"<p>å¾€192.168.1.27çš„æœºå™¨çš„8080ç«¯å£é€šè¿‡UDPåè®®å‘é€æ•°æ®ï¼Œä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š
æ³¨æ„ï¼šåŠè§’è‹±æ–‡è¾“å…¥ï¼š
echo â€œhello world!â€ &gt; /dev/udp/192.168.1.27/8080
<!-- more --></p>

<p>è¡¨ç¤ºå‘é€æ•°æ®åŒ…å†…å®¹â€hello world!â€åˆ°192.168.1.27æœºå™¨ã€‚
é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨æœåŠ¡å™¨ä¸Šå°†ç›‘æ§è„šæœ¬çš„å‘Šè­¦æ•°æ®å†…å®¹æ¨é€ç»™æŸä¸ªä¸­é—´æœåŠ¡(192.168.1.27)ï¼Œè¿™ä¸ªä¸­é—´æœåŠ¡å¯ä»¥åˆ©ç”¨websocketæŠ€æœ¯å°†æ•°æ®æ¨é€ç»™å‰ç«¯å±•ç¤ºï¼ˆç”µå­ç™½æ¿é¢„è­¦ç­‰å½¢å¼ï¼‰</p>

<table>
  <tbody>
    <tr>
      <td>å¦‚æœå¾€é ç¨‹UDPç«¯å£ç™¼é€æ•¸æ“šï¼Œé‚£éº¼å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼šecho â€œhelloâ€</td>
      <td>socat - udp4-datagram:192.168.1.80:5060</td>
    </tr>
  </tbody>
</table>

<p>æ„æ€æ˜¯å¾€é ç¨‹192.168.1.80çš„5060ç«¯å£ç™¼é€æ•¸æ“šåŒ…hello</p>

<p>/dev/tcp</p>

<p>$exec 5&lt;&gt;/dev/tcp/time.nist.gov/13; cat &lt;&amp;5 &amp; cat &gt;&amp;5; exec 5&gt;&amp;-
[1] 909</p>

<p>58753 19-09-27 03:59:13 50 0 0   0.0 UTC(NIST) *</p>

<p>$exec 5&lt;&gt;/dev/udp/127.0.0.1/8082; cat &lt;&amp;5 &amp; cat &gt;&amp;5; exec 5&gt;&amp;-</p>

<p>$exec 5&lt;&gt;/dev/udp/127.0.0.1/8082; cat &lt;&amp;5 &amp; cat &gt;&amp;5; exec 5&gt;&amp;-
[1] 2274
-bash: 5: Bad file descriptor
-bash: 5: Bad file descriptor
[1]+  Exit 1                  cat 0&lt;&amp;5</p>

<p>$nc -u 127.0.0.1 8082</p>

<p>$exec 3&lt;&gt;/dev/udp/127.0.0.1/8082</p>

<p>$echo $(read &lt; /dev/udp/127.0.0.1/8082)</p>

<p>https://n0where.net/bash-open-tcpudp-sockets</p>

<p>Bash shell has a built-in feature that allows to open TCP/UDP sockets using a simple syntax. This is very useful when tools like netcat are not installed or we donâ€™t have the permission to use it.</p>

<p>The syntax is</p>

<p>$ exec {file-descriptor}&lt;&gt;/dev/{protocol}/{host}/{port}</p>

<p>{file-descriptor} â€“ 0, 1 and 2 are seserved for stdin, stout and stderr respectively. At least 3 must be used. The Bash manual suggest to be careful in using descriptors above 9 since there could be conflict with descriptors used internally by the shell.
&lt;&gt; â€“ the file is open for both reading and writing
{protocol} â€“ TCP or UDP
{host} â€“ ip address or domain name of the host
{port} â€“ logic port</p>

<p>Sockets can be closed using</p>

<p>$ exec {file-descriptor}&lt;&gt;&amp;-
To send a message through the socket</p>

<p>echo -e -n â€œ$MSG_OUTâ€ &gt;&amp;3
or</p>

<p>printf â€œ$MSG_OUTâ€ &gt;&amp;3
To read a message from the socket</p>

<p>read -r -u -n $MSG_IN &lt;&amp;3
Output can be printed recursively</p>

<p>while read LINE &lt;&amp;3
do
    echo $LINE &gt;&amp;1
done
Or read entirely in one variable</p>

<p>OUTPUT=$(dd bs=$BYTES count=1 &lt;&amp;3 2&gt; /dev/null)</p>

<p>Example:
$ exec 3&lt;&gt;/dev/tcp/127.0.0.1/1234
We are opening a socket for reading and writing to the 1234 port in the loopback interface.</p>

<p>The /dev/tcp and /dev/udp files arenâ€™t real devices but are keywords interpreted by the Bash shell. Being a â€œbashismâ€ this solution is not portable even if seems that ksh and zsh shells have the same feature enabled.</p>

<p>In this example we fetch the Google main page:</p>

<p>$ exec 3&lt;&gt;/dev/tcp/www.google.com/80
$ echo -e â€œGET / HTTP/1.1\n\nâ€ &gt;&amp;3
$ cat &lt;&amp;3
Itâ€™s good practice to always close file descriptors</p>

<p>$ exec 3&lt;&amp;-
$ exec 3&gt;&amp;-</p>

<p>Finally,  IRC server example:</p>

<p>#!/bin/bash</p>

<p>##########################################################</p>
<h1 id="config">Config</h1>

<p>NICK=â€CyberPunkâ€
SERVER=â€irc.n0where.netâ€
PORT=6667
CHANNEL=â€#CyberPunkâ€</p>

<p>##########################################################</p>
<h1 id="main">Main</h1>

<p>exec 3&lt;&gt;/dev/tcp/${SERVER}/${PORT}
echo â€œNICK ${NICK}â€ &gt;&amp;3
echo â€œUSER ${NICK} 8 * : ${NICK}â€ &gt;&amp;3
echo â€œJOIN ${CHANNEL}â€ &gt;&amp;3
cat &lt;&amp;3</p>

<p>exit $?</p>

<p>Enable/disable net redirections
More the feature must be enabled in Bash at compile time. To enable it if you want to compile the Bash yourself include the flag</p>

<p>â€“enable-net-redirections
while to disable it explicitly use</p>

<p>â€“disable-net-redirections
Each distribution may or not have the feature enabled in their precompiled Bash.</p>
:ET