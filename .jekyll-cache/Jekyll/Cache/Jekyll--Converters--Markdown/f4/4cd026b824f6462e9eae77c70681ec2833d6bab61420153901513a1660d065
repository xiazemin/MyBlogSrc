I"<p>https://golang.org/doc/asm
GO语言汇编：plan9（贝尔操作系统）
go开发者与plan 9开发者同一人，Rob Pike
寄存器：
数据寄存器：R0-R7，地址寄存器：A0-A7，浮点寄存器：F0-F7。
伪栈寄存器：FP, SP, TOS
数据：
PC用来控制程序执行，SB用来引用全局变量。
Go语言汇编
FUNCDATA和PCDATA是编译器产生的，用于保存一些给垃圾收集的信息。
NOPTR和RODATA的数据不需要被垃圾收集。比指针还要小的数据也被当做NOPTR。不要在go汇编里写非只读数据。
plan9函数调用协议中采用的是caller-save的模式，也就是由调用者负责保存寄存器。
TEXT !$Add(SB),$0
MOVQ x+0(FP), BX
MOVQ y+8(FP), BP
ADDQ BP, BX
MOVQ BX, ret+16(FP)
RET
TEXT    ““.main(SB), $56-0
56 代表local 大小
0 代表args大小
movl 四字节mov intel指令集
movq 八字节
例子中的TEXT指令就定义了一个叫bytes·Equal的符号（注意是中点号·），接下来就是对应的指令（可以理解成函数体），而最后RET则是返回指令（退出当前stack）。通常情况下，参数大小后跟随着stack frame的大小，使用减号（-）分割。$0-49意味着这是一个0-byte的栈，并且有49-byte长的参数。NOSPLIT说明,不允许调度器调整stack frame的大小,这就意味着必须人工指定stack frame大小。
字符串 函数都放在SB   stack basic register</p>
:ET