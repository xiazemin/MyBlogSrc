I">><p>在应用程序中，经常需要全局唯一的ID作为数据库主键。如何生成全局唯一ID？</p>

<p>首先，需要确定全局唯一ID是整型还是字符串？如果是字符串，那么现有的UUID就完全满足需求，不需要额外的工作。缺点是字符串作为ID占用空间大，索引效率比整型低。</p>

<p>如果采用整型作为ID，那么首先排除掉32位int类型，因为范围太小，必须使用64位long型。</p>

<p>采用整型作为ID时，如何生成自增、全局唯一且不重复的ID？</p>

<p>方案一：利用数据库的自增ID，从1开始，基本可以做到连续递增。Oracle可以用SEQUENCE，MySQL可以用主键的AUTO_INCREMENT，虽然不能保证全局唯一，但每个表唯一，也基本满足需求。</p>

<p>数据库自增ID的缺点是数据在插入前，无法获得ID。数据在插入后，获取的ID虽然是唯一的，但一定要等到事务提交后，ID才算是有效的。有些双向引用的数据，不得不插入后再做一次更新，比较麻烦。</p>

<p>第二种方式是采用一个集中式ID生成器，它可以是Redis，也可以是ZooKeeper，也可以利用数据库的表记录最后分配的ID。</p>

<p>这种方式最大的缺点是复杂性太高，需要严重依赖第三方服务，而且代码配置繁琐。一般来说，越是复杂的方案，越不可靠，并且测试越痛苦。</p>

<p>第三种方式是类似Twitter的Snowflake算法，它给每台机器分配一个唯一标识，然后通过时间戳+标识+自增实现全局唯一ID。这种方式好处在于ID生成算法完全是一个无状态机，无网络调用，高效可靠。缺点是如果唯一标识有重复，会造成ID冲突。</p>

<p>Snowflake算法采用41bit毫秒时间戳，加上10bit机器ID，加上12bit序列号，理论上最多支持1024台机器每秒生成4096000个序列号，对于Twitter的规模来说够用了。</p>

<p>但是对于绝大部分普通应用程序来说，根本不需要每秒超过400万的ID，机器数量也达不到1024台，所以，我们可以改进一下，使用更短的ID生成方式：</p>

<p>53bitID由32bit秒级时间戳+16bit自增+5bit机器标识组成，累积32台机器，每秒可以生成6.5万个序列号
<!-- more -->
一、需求缘起</p>

<p>几乎所有的业务系统，都有生成一个唯一记录标识的需求，例如：</p>

<p>消息标识：message-id</p>

<p>订单标识：order-id</p>

<p>帖子标识：tiezi-id</p>

<p>这个记录标识往往就是数据库中的主键，数据库上会建立聚集索引（cluster index），即在物理存储上以这个字段排序。</p>

<p>这个记录标识上的查询，往往又有分页或者排序的业务需求，例如：</p>

<p>拉取最新的一页消息</p>

<p>select message-id/ order by time/ limit 100</p>

<p>拉取最新的一页订单</p>

<p>select order-id/ order by time/ limit 100</p>

<p>拉取最新的一页帖子</p>

<p>select tiezi-id/ order by time/ limit 100</p>

<p>所以往往要有一个time字段，并且在time字段上建立普通索引（non-cluster index）。</p>

<p>普通索引存储的是实际记录的指针，其访问效率会比聚集索引慢，如果记录标识在生成时能够基本按照时间有序，则可以省去这个time字段的索引查询：</p>

<p>select message-id/ (order by message-id)/limit 100</p>

<p>强调，能这么做的前提是，message-id的生成基本是趋势时间递增的。</p>

<p>这就引出了记录标识生成（也就是上文提到的三个XXX-id）的两大核心需求：</p>

<p>全局唯一</p>

<p>趋势有序</p>

<p>这也是本文要讨论的核心问题：如何高效生成趋势有序的全局唯一ID。</p>

<p>二、常见方法、不足与优化</p>

<p>方法一：使用数据库的 auto_increment 来生成全局唯一递增ID</p>

<p>优点：</p>

<p>简单，使用数据库已有的功能</p>

<p>能够保证唯一性</p>

<p>能够保证递增性</p>

<p>步长固定</p>

<p>缺点：</p>

<p>可用性难以保证：数据库常见架构是一主多从+读写分离，生成自增ID是写请求，主库挂了就玩不转了</p>

<p>扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展</p>

<p>改进方法：</p>

<p>冗余主库，避免写入单点</p>

<p>数据水平切分，保证各主库生成的ID不重复</p>

<p>如上图所述，由1个写库变成3个写库，每个写库设置不同的auto_increment初始值，以及相同的增长步长，以保证每个数据库生成的ID是不同的（上图中库0生成0,3,6,9…，库1生成1,4,7,10，库2生成2,5,8,11…）</p>

<p>改进后的架构保证了可用性，但缺点是：</p>

<p>丧失了ID生成的“绝对递增性”：先访问库0生成0,3，再访问库1生成1，可能导致在非常短的时间内，ID生成不是绝对递增的（这个问题不大，目标是趋势递增，不是绝对递增）</p>

<p>数据库的写压力依然很大，每次生成ID都要访问数据库</p>

<p>为了解决上述两个问题，引出了第二个常见的方案。</p>

<p>方法二：单点批量ID生成服务</p>

<p>分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。</p>

<p>数据库写压力大，是因为每次生成ID都访问了数据库，可以使用批量的方式降低数据库写压力。</p>

<p>如上图所述，数据库使用双master保证可用性，数据库中只存储当前ID的最大值，例如0。</p>

<p>ID生成服务假设每次批量拉取6个ID，服务访问数据库，将当前ID的最大值修改为5，这样应用访问ID生成服务索要ID，ID生成服务不需要每次访问数据库，就能依次派发0,1,2,3,4,5这些ID了。</p>

<p>当ID发完后，再将ID的最大值修改为11，就能再次派发6,7,8,9,10,11这些ID了，于是数据库的压力就降低到原来的1/6。</p>

<p>优点：</p>

<p>保证了ID生成的绝对递增有序</p>

<p>大大的降低了数据库的压力，ID生成可以做到每秒生成几万几十万个</p>

<p>缺点：</p>

<p>服务仍然是单点</p>

<p>如果服务挂了，服务重启起来之后，继续生成ID可能会不连续，中间出现空洞（服务内存是保存着0,1,2,3,4,5，数据库中max-id是5，分配到3时，服务重启了，下次会从6开始分配，4和5就成了空洞，不过这个问题也不大）</p>

<p>虽然每秒可以生成几万几十万个ID，但毕竟还是有性能上限，无法进行水平扩展</p>

<p>改进方法：</p>

<p>单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”，所以我们能用以下方法优化上述缺点（1）：</p>

<p>如上图，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。</p>

<p>这个切换的过程对调用方是透明的，可以自动完成，常用的技术是vip+keepalived，具体就不在这里展开。</p>

<p>另外，ID-gen-service也可以实施水平扩展，以解决上述缺点（3），但会引发一致性问题，具体解决方案详见《浅谈CAS在分布式ID生成方案上的应用》。</p>

<p>方法三：uuid/guid</p>

<p>不管是通过数据库，还是通过服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。</p>

<p>有没有一种本地生成ID的方法，即高性能，又时延低呢？</p>

<p>uuid是一种常见的方案：</p>

<p>string ID =GenUUID();</p>

<p>优点：</p>

<p>本地生成ID，不需要进行远程调用，时延低</p>

<p>扩展性好，基本可以认为没有性能上限</p>

<p>缺点：</p>

<p>无法保证趋势递增</p>

<p>uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）</p>

<p>方法四：取当前毫秒数</p>

<p>uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？</p>

<p>取当前毫秒数是一种常见方案：</p>

<p>uint64 ID = GenTimeMS();</p>

<p>优点：</p>

<p>本地生成ID，不需要进行远程调用，时延低</p>

<p>生成的ID趋势递增</p>

<p>生成的ID是整数，建立索引后查询效率高</p>

<p>缺点：</p>

<p>如果并发量超过1000，会生成重复的ID</p>

<p>这个缺点要了命了，不能保证ID的唯一性。当然，使用微秒可以降低冲突概率，但每秒最多只能生成1000000个ID，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题。</p>

<p>方法五：类snowflake算法</p>

<p>snowflake是twitter开源的分布式ID生成算法，其核心思想为，一个long型的ID：</p>

<p>41bit作为毫秒数</p>

<p>10bit作为机器编号</p>

<p>12bit作为毫秒内序列号</p>

<p>算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。</p>

<p>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>

<p>举例，假设某公司ID生成器服务的需求如下：</p>

<p>单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W</p>

<p>有2个机房，预计未来5年机房数量小于4个</p>

<p>每个机房机器数小于100台</p>

<p>目前有5个业务线有ID生成需求，预计未来业务线数量小于10个</p>

<p>…</p>

<p>分析过程如下：</p>

<p>高位取从2017年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数</p>

<p>每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号</p>

<p>5年内机房数小于4个，预留2bit给机房标识</p>

<p>每个机房小于100台机器，预留7bit给每个机房内的服务器标识</p>

<p>业务线小于10个，预留4bit给业务线标识</p>

<p>这样设计的64bit标识，可以保证：</p>

<p>每个业务线、每个机房、每个机器生成的ID都是不同的</p>

<p>同一个机器，每个毫秒内生成的ID都是不同的</p>

<p>同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的</p>

<p>将毫秒数放在最高位，保证生成的ID是趋势递增的</p>

<p>缺点：</p>

<p>由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）</p>

<p>基于时间戳
比如流水号规则如下：XX-YYYYMMDD-N位随机数，这也是企业级应用开发常用的规则。此流水号对人比较友好，可识别性高，但容量受后面随机数的限制，且数据量越大，生成时难度越高。前三部分每天的流水号基本固定，后面的N位随机数生成后，需要校验此前不存在，可依赖redis的set机制，每天的随机数都写到一个set集合中[set容易达42亿之多，完全够用]，重新生成后要与set集合作比对，以确保其唯一性。一天内不重复，再结合确定日期来保证其唯一性。</p>

<p>N位随机数生成时，可基于系统时间戳，再与一个大数取模生成。</p>

<p>UUID/GUID
最简单直接暴力的方式，虽然能够保证ID的唯一性，但是，它无法满足业务系统需要的很多其他特性，例如：时间粗略有序性，可反解和可制造型。另外，UUID产生的时候使用完全的时间数据，性能比较差，并且UUID比较长，占用空间大，间接导致数据库性能下降，更重要的是，UUID并不具有有序性。系统容量较小的时候可以采用，变大后不建议采用此方式。</p>

<p>Vesta
GitHub 地址：https://github.com/robertleepeak/vesta-id-generator</p>

<p>Vesta是一款通用的ID产生器，互联网俗称统一发号器，它具有全局唯一、粗略有序、可反解和可制造等特性，它支持三种发布模式：嵌入发布模式、中心服务器发布模式、REST发布模式，根据业务的性能需求，它可以产生最大峰值型和最小粒度型两种类型的ID，它的实现架构使其具有高性能，高可用和可伸缩等互联网产品需要的质量属性，是一款通用的高性能的发号器产品。 提供4种应用部署方式，具体使用依场景而定：</p>

<p>REST发布模式（Netty）</p>

<p>REST发布模式（Tomcat）</p>

<p>中心服务器发布模式</p>

<p>嵌入式发布模式</p>

<p>Twitter-Snowflake
GitHub 地址：https://github.com/twitter/snowflake</p>

<p>Twitter-Snowflake算法产生的背景相当简单，为了满足Twitter每秒上万条消息的请求，每条消息都必须分配一条唯一的id，这些id还需要一些大致的顺序（方便客户端排序），并且在分布式系统中不同机器产生的id必须不同。</p>

<p>snowflake的结构如下(用-分开):</p>

<p>0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000</p>

<p>第一位为未使用，接下来的41位为毫秒级时间(41位的长度可以使用69年)，然后是5位datacenterId和5位workerId(10位的长度最多支持部署1024个节点） ，最后12位是毫秒内的计数（12位的计数顺序号支持每个节点每毫秒产生4096个ID序号）</p>

<p>一共加起来刚好64位，为一个Long型。(转换成字符串长度为18)</p>

<p> snowflake生成的ID整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和workerId作区分），并且效率较高。据说：snowflake每秒能够产生26万个ID。</p>

<p>基于redis的分布式ID生成器
GitHub 地址：https://github.com/hengyunabc/redis-id-generator</p>

<p>依赖redis的EVAL,EVALSHA两个命令，利用redis的lua脚本执行功能，在每个节点上通过lua脚本生成唯一ID。 生成的ID是64位的：</p>

<p>使用41 bit来存放时间，精确到毫秒，可以使用41年。</p>

<p>使用12 bit来存放逻辑分片ID，最大分片ID是4095</p>

<p>使用10 bit来存放自增长ID，意味着每个节点，每毫秒最多可以生成1024个ID</p>

<p>Redis提供了TIME命令，可以取得redis服务器上的秒数和微秒数。因些lua脚本返回的是一个四元组。</p>

<p>second, microSecond, partition, seq</p>

<p>客户端要自己处理，生成最终ID。</p>

<p>((second * 1000 + microSecond / 1000) « (12 + 10)) + (shardId « 10) + seq;</p>

<p>在redis-id-generator-java目录下，有example和benchmark代码，提供了 Java客户端生成模式，其它语言只要支持redis evalsha命令就可以了。</p>

<p>MongoDB的ObjectId
Mongodb集合中的每个document中都必须有一个”_id”键，这个键的值可以是任何类型的，在默认的情况下是个Objectid对象。mongodb的ObejctId生产思想在很多方面挺值得我们借鉴的，特别是在大型分布式的开发，如何构建轻量级的生产，如何将生产的负载进行转移，如何以空间换取时间提高生产的最大优化等等。</p>

<p>像微信这种用户量特别大的请求，根据业务特点，多个用户批量取最大分段
https://mp.weixin.qq.com/s?__biz=MzI4NDMyNTU2Mw==&amp;mid=2247483679&amp;idx=1&amp;sn=584dbd80aa08fa1188627ad725680928&amp;mpshare=1&amp;scene=1&amp;srcid=1208L9z4yXKLW60rPph2ZmMn#rd</p>
:ET