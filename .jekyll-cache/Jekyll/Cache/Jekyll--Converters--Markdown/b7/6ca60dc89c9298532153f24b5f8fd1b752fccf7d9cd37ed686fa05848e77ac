I"<p>函数式编程是一种编程模型，他将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念。
闭包是由函数及其相关引用环境组合而成的实体(即：闭包=函数+引用环境)。
<!-- more -->
闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束所组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。那么为什么要把引用环境与函数组合起来呢？这主要是因为在支持嵌套作用域的语言中，有时不能简单直接地确定函数的引用环境。这样的语言一般具有这样的特性：
函数是一等公民（First-class value），即函数可以作为另一个函数的返回值或参数，还可以作为一个变量的值。
函数可以嵌套定义，即在一个函数内部可以定义另一个函数。
func adder() func(int) int {
    sum := 0
    innerfunc := func(x int) int {
        sum += x
        return sum
    }
    return innerfunc
}</p>

<p>func main() {
    pos, neg := adder(), adder()
    for i := 0; i &lt; 10; i++ {
        fmt.Println(pos(i), neg(-2*i))
    }
内嵌函数innerfunc中引用到外层函数中的局部变量sum，这段代码的运行结果：
0 0<br />
1 -2<br />
3 -6<br />
6 -12 <br />
10 -20<br />
15 -30<br />
21 -42<br />
28 -56<br />
36 -72<br />
45 -90
当用不同的参数调用adder函数得到（pos(i)，neg(i)）函数时，得到的结果是隔离的，也就是说每次调用adder返回的函数都将生成并保存一个新的局部变量sum。其实这里adder函数返回的就是闭包。
这个就是Go中的闭包，一个函数和与其相关的引用环境组合而成的实体。一句关于闭包的名言: 对象是附有行为的数据，而闭包是附有数据的行为。
函数式编程具有五个鲜明的特点。</p>
:ET