I"’<p>ä½•ä¸ºbasic authentication
In the context of a HTTP transaction, basic access authentication is a method for a HTTP user agent to provide a user name and password when making a request.</p>

<p>ä½†æ˜¯è¿™ç§è®¤è¯æ–¹å¼æœ‰å¾ˆå¤šçš„ç¼ºç‚¹ï¼š 
è™½ç„¶åŸºæœ¬è®¤è¯éå¸¸å®¹æ˜“å®ç°ï¼Œä½†è¯¥æ–¹æ¡ˆå»ºç«‹åœ¨ä»¥ä¸‹çš„å‡è®¾çš„åŸºç¡€ä¸Šï¼Œå³ï¼šå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨ä¸»æœºä¹‹é—´çš„è¿æ¥æ˜¯å®‰å…¨å¯ä¿¡çš„ã€‚ç‰¹åˆ«æ˜¯ï¼Œå¦‚æœæ²¡æœ‰ä½¿ç”¨SSL/TLSè¿™æ ·çš„ä¼ è¾“å±‚å®‰å…¨çš„åè®®ï¼Œé‚£ä¹ˆä»¥æ˜æ–‡ä¼ è¾“çš„å¯†é’¥å’Œå£ä»¤å¾ˆå®¹æ˜“è¢«æ‹¦æˆªã€‚è¯¥æ–¹æ¡ˆä¹ŸåŒæ ·æ²¡æœ‰å¯¹æœåŠ¡å™¨è¿”å›çš„ä¿¡æ¯æä¾›ä¿æŠ¤ã€‚
SplitN slices s into substrings separated by sep and returns a slice of the substrings between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. 
çœ‹åˆ°äº†å—ï¼Œgolangä¸­çš„stringsåŒ…ä¸ºæˆ‘ä»¬æä¾›äº†å¼ºå¤§çš„å­—ç¬¦ä¸²å¤„ç†èƒ½åŠ›ã€‚</p>

<p>package main</p>

<p>import (
    â€œencoding/base64â€
    â€œnet/httpâ€
    â€œstringsâ€
)</p>

<p>func checkAuth(w http.ResponseWriter, r *http.Request) bool {
    s := strings.SplitN(r.Header.Get(â€œAuthorizationâ€), â€œ â€œ, 2)
    if len(s) != 2 {
        return false
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b, err := base64.StdEncoding.DecodeString(s[1])
if err != nil {
    return false
}

pair := strings.SplitN(string(b), ":", 2)
if len(pair) != 2 {
    return false
}

return pair[0] == "user" &amp;&amp; pair[1] == "pass" }
</code></pre></div></div>

<p>func main() {
    http.HandleFunc(â€œ/â€, func(w http.ResponseWriter, r *http.Request) {
        if checkAuth(w, r) {
            w.Write([]byte(â€œhello world!â€))
            return
        }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    w.Header().Set("WWW-Authenticate", `Basic realm="MY REALM"`)
    w.WriteHeader(401)
    w.Write([]byte("401 Unauthorized\n"))
})

http.ListenAndServe(":8080, nil) }
</code></pre></div></div>

<p>å®¢æˆ·ç«¯ï¼š
func basicAuth(username, password string) string {
  auth := username + â€œ:â€ + password
   return base64.StdEncoding.EncodeToString([]byte(auth))
}</p>

<p>func redirectPolicyFunc(req <em>http.Request, via []</em>http.Request) error{
 req.Header.Add(â€œAuthorizationâ€,â€Basic â€œ + basicAuth(â€œusername1â€,â€password123â€))
 return nil
}</p>

<p>func main() {</p>

<p>client := &amp;http.Client{
    Jar: cookieJar,
    CheckRedirect: redirectPolicyFunc,
}</p>

<p>req, err := http.NewRequest(â€œGETâ€, â€œhttp://localhost/â€, nil)
    req.Header.Add(â€œAuthorizationâ€,â€Basic â€œ + basicAuth(â€œusername1â€,â€password123â€))</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resp, err := client.Do(req) }
</code></pre></div></div>

<p>goji/httpauth
HTTP Authentication middlewares
è·å–ï¼š 
go get github.com/goji/httpauth
https://github.com/goji/httpauth
package main</p>

<p>import (
    â€œnet/httpâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/goji/httpauth" )
</code></pre></div></div>

<p>func main() {
    finalHandler := http.HandlerFunc(final)
    authHandler := httpauth.SimpleBasicAuth(â€œusernameâ€, â€œpasswordâ€)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http.Handle("/", authHandler(finalHandler))
http.ListenAndServe(":8080", nil) }
</code></pre></div></div>

<p>func final(w http.ResponseWriter, r *http.Request) {
    w.Write([]byte(â€œOKâ€))
}
curl â€“i username:password@localhost:8080
HTTP/1.1 200 OK
Date: Thu, 01 Feb 2018 05:27:33 GMT
Content-Length: 2
Content-Type: text/plain; charset=utf-8</p>

<p>OK</p>

<p>æˆ–è€…æµè§ˆå™¨
 http://username:password@localhost:8080
<!-- more -->
BasicAuth returns the username and password provided in the requestâ€™s Authorization header, if the request uses HTTP Basic Authentication. See RFC 2617, Section 2.
https://golang.org/pkg/net/http/#Request.BasicAuth</p>

<p>// BasicAuth wraps a handler requiring HTTP basic auth for it using the given
// username and password and the specified realm, which shouldnâ€™t contain quotes.
//
// Most web browser display a dialog with something like:
//
//    The website says: â€œ<realm>"
//
// Which is really stupid so you may want to set the realm to a message rather than
// an actual realm.
func BasicAuth(handler http.HandlerFunc, username, password, realm string) http.HandlerFunc {</realm></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return func(w http.ResponseWriter, r *http.Request) {

    user, pass, ok := r.BasicAuth()

    if !ok || subtle.ConstantTimeCompare([]byte(user), []byte(username)) != 1 || subtle.ConstantTimeCompare([]byte(pass), []byte(password)) != 1 {
        w.Header().Set("WWW-Authenticate", `Basic realm="`+realm+`"`)
        w.WriteHeader(401)
        w.Write([]byte("Unauthorised.\n"))
        return
    }

    handler(w, r)
} }
</code></pre></div></div>

<p>â€¦</p>

<p>http.HandleFunc(â€œ/â€, BasicAuth(handleIndex, â€œadminâ€, â€œ123456â€, â€œPlease enter your username and password for this siteâ€))</p>

<p>func checkAuth(w http.ResponseWriter, r *http.Request) bool {
    s := strings.SplitN(r.Header.Get(â€œAuthorizationâ€), â€œ â€œ, 2)
    if len(s) != 2 { return false }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>b, err := base64.StdEncoding.DecodeString(s[1])
if err != nil { return false }

pair := strings.SplitN(string(b), ":", 2)
if len(pair) != 2 { return false }

return pair[0] == "user" &amp;&amp; pair[1] == "pass" }
</code></pre></div></div>

<p>yourRouter.HandleFunc(â€œ/â€, func(w http.ResponseWriter, r *http.Request) {
    if checkAuth(w, r) {
        yourOriginalHandler.ServeHTTP(w, r)
        return
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>w.Header().Set("WWW-Authenticate", `Basic realm="MY REALM"`)
w.WriteHeader(401)
w.Write([]byte("401 Unauthorized\n")) })
</code></pre></div></div>

<p>HTTP authentication with PHP
It is possible to use the header() function to send an â€œAuthentication Requiredâ€ message to the client browser causing it to pop up a Username/Password input window. Once the user has filled in a username and a password, the URL containing the PHP script will be called again with the predefined variables PHP_AUTH_USER, PHP_AUTH_PW, and AUTH_TYPE set to the user name, password and authentication type respectively. These predefined variables are found in the $_SERVER array. Both â€œBasicâ€ and â€œDigestâ€ (since PHP 5.1.0) authentication methods are supported. See the header() function for more information.</p>

<p>http://php.net/manual/en/features.http-auth.php
http://www.php.net/manual/en/function.parse-url.php
&lt;?php</p>

<p>$url = â€˜http://usr:pss@example.com:81/mypath/myfile.html?a=b&amp;b[]=2&amp;b[]=3#myfragmentâ€™; 
if ($url === unparse_url(parse_url($url))) { 
  print â€œYES, they match!\nâ€; 
}</p>

<p>function unparse_url($parsed_url) { 
  $scheme   = isset($parsed_url[â€˜schemeâ€™]) ? $parsed_url[â€˜schemeâ€™] . â€˜://â€™ : â€˜â€™; 
  $host     = isset($parsed_url[â€˜hostâ€™]) ? $parsed_url[â€˜hostâ€™] : â€˜â€™; 
  $port     = isset($parsed_url[â€˜portâ€™]) ? â€˜:â€™ . $parsed_url[â€˜portâ€™] : â€˜â€™; 
  $user     = isset($parsed_url[â€˜userâ€™]) ? $parsed_url[â€˜userâ€™] : â€˜â€™; 
  $pass     = isset($parsed_url[â€˜passâ€™]) ? â€˜:â€™ . $parsed_url[â€˜passâ€™]  : â€˜â€™; 
  $pass     = ($user || $pass) ? â€œ$pass@â€ : â€˜â€™; 
  $path     = isset($parsed_url[â€˜pathâ€™]) ? $parsed_url[â€˜pathâ€™] : â€˜â€™; 
  $query    = isset($parsed_url[â€˜queryâ€™]) ? â€˜?â€™ . $parsed_url[â€˜queryâ€™] : â€˜â€™; 
  $fragment = isset($parsed_url[â€˜fragmentâ€™]) ? â€˜#â€™ . $parsed_url[â€˜fragmentâ€™] : â€˜â€™; 
  return â€œ$scheme$user$pass$host$port$path$query$fragmentâ€; 
}</p>

<p>?&gt;</p>

:ET