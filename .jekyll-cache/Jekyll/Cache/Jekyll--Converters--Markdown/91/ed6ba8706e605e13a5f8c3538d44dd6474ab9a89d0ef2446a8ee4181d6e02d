I"…=<p>https://github.com/mitchellh/cli
åŠŸèƒ½
è¯¥æ¡†æ¶æ˜¯ä¸ªäººå¼€å‘çš„å‘½ä»¤è¡Œç¨‹åºæ¡†æ¶ï¼Œä½œè€…è¿˜æˆç«‹äº†å…¬å¸ï¼ˆHashiCorpï¼‰ï¼Œå…¶å…¬å¸çš„äº§å“ä¹Ÿé‡‡ç”¨è¿™ä¸ªCLIæ¡†æ¶ã€‚</p>

<p>è§£è¯»
æ¡†æ¶çš„æ€è·¯æ˜¯ï¼šæŠŠå‘½ä»¤å’Œæ‰§è¡Œæ–¹æ³•ä»¥mapçš„å½¢å¼è®°å½•åœ¨å†…éƒ¨ï¼Œç„¶åæ ¹æ®ç”¨æˆ·è¾“å…¥çš„å‘½ä»¤ï¼Œå†³å®šæ‰§è¡Œå“ªä¸ªæ–¹æ³•ã€‚å®é™…ä¸Šè®°å½•çš„æ˜¯å‘½ä»¤å­—ç¬¦ä¸²å’ŒCommandFactoryï¼Œç”±CommandFactoryåˆ›å»ºCommandç„¶åæ‰§è¡Œã€‚</p>

<p>æ¡†æ¶é»˜è®¤æ”¯æŒversionå’Œhelpä¸¤ä¸ªåŠŸèƒ½ã€‚
<!-- more -->
package main</p>

<p>import (
	â€œfmtâ€
	â€œosâ€
	â€œgithub.com/mitchellh/cliâ€
)</p>

<p>func main() {
	c := cli.NewCLI(â€œappâ€, â€œ1.0.0â€)    //è¿™é‡ŒæŒ‡å®šäº†APPåå­—å’Œç‰ˆæœ¬
	c.Args = os.Args[1:]
	c.Commands = map[string]cli.CommandFactory{
		â€œfooâ€: fooCommandFactory,    //å®šä¹‰fooå‘½ä»¤å’Œå·¥å‚
		â€œbarâ€: barCommandFactory,    //å®šä¹‰barå‘½ä»¤å’Œå·¥å‚
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exitStatus, err := c.Run()
if err != nil {
	fmt.Println(err)
}

os.Exit(exitStatus) }
</code></pre></div></div>

<p>//fooå‘½ä»¤å·¥å‚
func fooCommandFactory() (cli.Command, error) {
	fmt.Println(â€œI am foo commandâ€)
	return new(FooCommand), nil
}
//barå‘½ä»¤å·¥å‚
func barCommandFactory() (cli.Command, error) {
	fmt.Println(â€œI am bar commandâ€)
	return new(BarCommand), nil
}
//fooå‘½ä»¤å®ç°
type FooCommand struct{}</p>

<p>// Help should return long-form help text that includes the command-line
// usage, a brief few sentences explaining the function of the command,
// and the complete list of flags the command accepts.
func (f *FooCommand) Help() string {
	return â€œhelp fooâ€
}</p>

<p>// Run should run the actual command with the given CLI instance and
// command-line arguments. It should return the exit status when it is
// finished.
//
// There are a handful of special exit codes this can return documented
// above that change behavior.
func (f *FooCommand) Run(args []string) int {
	fmt.Println(â€œFoo Command is runningâ€)
	return 1
}</p>

<p>// Synopsis should return a one-line, short synopsis of the command.
// This should be less than 50 characters ideally.
func (f *FooCommand) Synopsis() string {
	return â€œfoo command Synopsisâ€
}</p>

<p>//barå‘½ä»¤å®ç°
type BarCommand struct{}</p>

<p>// Help should return long-form help text that includes the command-line
// usage, a brief few sentences explaining the function of the command,
// and the complete list of flags the command accepts.
func (b *BarCommand) Help() string {
	return â€œhelp barâ€
}</p>

<p>// Run should run the actual command with the given CLI instance and
// command-line arguments. It should return the exit status when it is
// finished.
//
// There are a handful of special exit codes this can return documented
// above that change behavior.
func (b *BarCommand) Run(args []string) int {
	fmt.Println(â€œbar Command is runningâ€)
	return 1
}</p>

<p>// Synopsis should return a one-line, short synopsis of the command.
// This should be less than 50 characters ideally.
func (b *BarCommand) Synopsis() string {
	return â€œbar command Synopsisâ€
}
è¿è¡Œgo buildç¼–è¯‘ï¼Œç„¶åè¿è¡Œï¼Œå°±å¯ä»¥çœ‹åˆ°æ‰§è¡Œç»“æœï¼š</p>

<p>name@mypc MINGW64 /d/go-repo/test
$ go build cli1</p>

<p>name@mypc MINGW64 /d/go-repo/test
$ ll
total 3924
-rwxr-xr-x 1 name 197121 4017152 2æœˆ  21 09:47 cli1.exe*
drwxr-xr-x 1 name 197121       0 2æœˆ  18 14:19 src/</p>

<p>name@mypc MINGW64 /d/go-repo/test
$ ./cli1
I am bar command
I am foo command
I am bar command
I am foo command
Usage: app [â€“version] [â€“help] <command /> [<args>]</args></p>

<p>Available commands are:
    bar    bar command Synopsis
    foo    foo command Synopsis</p>

<p>name@mypc MINGW64 /d/go-repo/test
$ ./cli1 foo
I am bar command
I am foo command
I am foo command
Foo Command is running</p>

<p>github.com/spf13/cobra
è¿™ä¸ªæ¯”è¾ƒæœ‰åäº†ï¼Œ å¥½å¤šæ¡†æ¶éƒ½ä½¿ç”¨äº†è¿™ä¸ª
ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•çš„ä½¿ç”¨</p>

<p>ä»£ç 
package main
â€‹
import (
 â€œgithub.com/spf13/cobraâ€
)
â€‹
func main() {
 cmd := newCommand()
 cmd.AddCommand(newNestedCommand())
â€‹
 rootCmd := &amp;cobra.Command{}
 rootCmd.AddCommand(cmd)
â€‹
 if err := rootCmd.Execute(); err != nil {
  println(err.Error())
 }
}
func newCommand() *cobra.Command {
 cmd := &amp;cobra.Command{
  Run: func(cmd *cobra.Command, args []string) {
   println(<code class="language-plaintext highlighter-rouge">Foo</code>)
  },
  Use: <code class="language-plaintext highlighter-rouge">foo</code>,
  Short: â€œCommand fooâ€,
  Long: â€œThis is a commandâ€,
 }
â€‹
 return cmd
}
â€‹
func newNestedCommand() *cobra.Command {
 cmd := &amp;cobra.Command{
  Run: func(cmd *cobra.Command, args []string) {
   println(<code class="language-plaintext highlighter-rouge">Bar</code>)
  },
  Use: <code class="language-plaintext highlighter-rouge">bar</code>,
  Short: â€œCommand barâ€,
  Long: â€œThis is a nested commandâ€,
 }
â€‹
 return cmd
}</p>

<p>æ•ˆæœ
go run main.go
Usage:
   [command]
â€‹
Available Commands:
  foo Command foo
  help Help about any command
â€‹
Flags:
  -h, â€“help help for this command
â€‹
Use â€œ [command] â€“helpâ€ for more information about a command.</p>

<p>github.com/urfave/cli
è¿™ä¸ªä¹Ÿæ¯”è¾ƒæœ‰åï¼Œå¥½å¤šæ¡†æ¶ä¹Ÿä½¿ç”¨äº†è¿™ä¸ª</p>

<p>ä»£ç 
package main
â€‹
import (
 â€œlogâ€
 â€œosâ€
 â€œsortâ€
â€‹
 â€œgithub.com/urfave/cliâ€
)
â€‹
func main() {
 app := cli.NewApp()
â€‹
 app.Flags = []cli.Flag{
  cli.StringFlag{
   Name: â€œlang, lâ€,
   Value: â€œenglishâ€,
   Usage: â€œLanguage for the greetingâ€,
  },
  cli.StringFlag{
   Name: â€œconfig, câ€,
   Usage: â€œLoad configuration from <code class="language-plaintext highlighter-rouge">FILE</code>â€,
  },
 }
â€‹
 app.Commands = []cli.Command{
  {
   Name: â€œcompleteâ€,
   Aliases: []string{â€œcâ€},
   Usage: â€œcomplete a task on the listâ€,
   Action: func(c <em>cli.Context) error {
    log.Print(â€œdddâ€)
    return nil
   },
  },
  {
   Name: â€œaddâ€,
   Aliases: []string{â€œaâ€},
   Usage: â€œadd a task to the listâ€,
   Action: func(c *cli.Context) error {
    return nil
   },
  },
 }
â€‹
 sort.Sort(cli.FlagsByName(app.Flags))
 sort.Sort(cli.CommandsByName(app.Commands))
â€‹
 err := app.Run(os.Args)
 if err != nil {
  log.Fatal(err)
 }
}
è¿è¡Œæ•ˆæœ
go run cmd/cli/main.go 
NAME:
   main - A new cli application
â€‹
USAGE:
   main [global options] command [command options] [argumentsâ€¦]
â€‹
VERSION:
   0.0.0
â€‹
COMMANDS:
   add, a add a task to the list
   complete, c complete a task on the list
   help, h Shows a list of commands or help for one command
â€‹
GLOBAL OPTIONS:
   â€“config FILE, -c FILE Load configuration from FILE
   â€“lang value, -l value Language for the greeting (default: â€œenglishâ€)
   â€“help, -h show help
   â€“version, -v print the version 
github.com/google/subcommands
ä»£ç 
package main
â€‹
import (
   â€œcontextâ€
   â€œflagâ€
   â€œfmtâ€
   â€œosâ€
   â€œstringsâ€
â€‹
   â€œgithub.com/google/subcommandsâ€
)
â€‹
type printCmd struct {
   capitalize bool
}
â€‹
func (</em>printCmd) Name() string { return â€œprintâ€ }
func (<em>printCmd) Synopsis() string { return â€œPrint args to stdout.â€ }
func (</em>printCmd) Usage() string {
   return <code class="language-plaintext highlighter-rouge">print [-capitalize] &lt;some text&gt;:
   Print args to stdout.
  </code>
}
â€‹
func (p *printCmd) SetFlags(f *flag.FlagSet) {
   f.BoolVar(&amp;p.capitalize, â€œcapitalizeâ€, false, â€œcapitalize outputâ€)
}
â€‹
func (p *printCmd) Execute(_ context.Context, f *flag.FlagSet, _ â€¦interface{}) subcommands.ExitStatus {
   for _, arg := range f.Args() {
      if p.capitalize {
         arg = strings.ToUpper(arg)
      }
      fmt.Printf(â€œ%s â€œ, arg)
   }
   fmt.Println()
   return subcommands.ExitSuccess
}
func main() {
   subcommands.Register(subcommands.HelpCommand(), â€œâ€)
   subcommands.Register(subcommands.FlagsCommand(), â€œâ€)
   subcommands.Register(subcommands.CommandsCommand(), â€œâ€)
   subcommands.Register(&amp;printCmd{}, â€œâ€)
â€‹
   flag.Parse()
   ctx := context.Background()
   os.Exit(int(subcommands.Execute(ctx)))
}
â€‹</p>

<p>æ•ˆæœ
go run cmd/subcommands/main.go     <br />
Usage: main <flags> <subcommand> <subcommand args="">
â€‹
Subcommands:
        commands list all command names
        flags describe all known top-level flags
        help describe subcommands and their syntax
        print Print args to stdout.
â€‹
â€‹
Use "main flags" for a list of top-level flags
exit status 2
github.com/mitchellh/cli
è¿™ä¸ªæ˜¯hashicorp å¥½å¤šäº§å“ä½¿ç”¨çš„ä¸€ä¸ªcli</subcommand></subcommand></flags></p>

<p>ä»£ç 
package main
â€‹
import (
   â€œfmtâ€
   â€œlogâ€
   â€œosâ€
â€‹
   â€œgithub.com/mitchellh/cliâ€
)
â€‹
func fooCommandFactory() (cli.Command, error) {
   return new(FooCommand), nil
}
â€‹
func barCommandFactory() (cli.Command, error) {
   return new(BarCommand), nil
}
â€‹
// FooCommand fooCommand
type FooCommand struct{}
â€‹
// Help should return long-form help text that includes the command-line
// usage, a brief few sentences explaining the function of the command,
// and the complete list of flags the command accepts.
func (f *FooCommand) Help() string {
   return â€œhelp fooâ€
}
â€‹
// Run should run the actual command with the given CLI instance and
// command-line arguments. It should return the exit status when it is
// finished.
//
// There are a handful of special exit codes this can return documented
// above that change behavior.
func (f *FooCommand) Run(args []string) int {
   fmt.Println(â€œFoo Command is runningâ€)
   return 1
}
â€‹
// Synopsis should return a one-line, short synopsis of the command.
// This should be less than 50 characters ideally.
func (f *FooCommand) Synopsis() string {
   return â€œfoo command Synopsisâ€
}
â€‹
// BarCommand barCommand
type BarCommand struct{}
â€‹
// Help should return long-form help text that includes the command-line
// usage, a brief few sentences explaining the function of the command,
// and the complete list of flags the command accepts.
func (b *BarCommand) Help() string {
   return â€œhelp barâ€
}
â€‹
// Run should run the actual command with the given CLI instance and
// command-line arguments. It should return the exit status when it is
// finished.
//
// There are a handful of special exit codes this can return documented
// above that change behavior.
func (b *BarCommand) Run(args []string) int {
   fmt.Println(â€œbar Command is runningâ€)
   return 1
}
â€‹
// Synopsis should return a one-line, short synopsis of the command.
// This should be less than 50 characters ideally.
func (b *BarCommand) Synopsis() string {
   return â€œbar command Synopsisâ€
}
func main() {
   c := cli.NewCLI(â€œappâ€, â€œ1.0.0â€)
   c.Args = os.Args[1:]
   c.Commands = map[string]cli.CommandFactory{
      â€œfooâ€: fooCommandFactory,
      â€œbarâ€: barCommandFactory,
   }
â€‹
   exitStatus, err := c.Run()
   if err != nil {
      log.Println(err)
   }
â€‹
   os.Exit(exitStatus)
} 
è¿è¡Œæ•ˆæœ
go run cmd/hashicorp-cli/main.go     <br />
Usage: app [â€“version] [â€“help] <command /> [<args>]
â€‹
Available commands are:
    bar bar command Synopsis
    foo foo command Synopsis
github.com/alecthomas/kingpin
è¿™ä¸ªcli pacakge ä¹Ÿæ˜¯å¤§å®¶ç”¨çš„æ¯”è¾ƒå¤šçš„ä¸€ä¸ª</args></p>

<p>ä»£ç 
package main
â€‹
import (
   â€œfmtâ€
   â€œosâ€
â€‹
   â€œgopkg.in/alecthomas/kingpin.v2â€
)
â€‹
func listHosts() []string {
   // Provide a dynamic list of hosts from a hosts file or otherwise
   // for bash completion. In this example we simply return static slice.
â€‹
   // You could use this functionality to reach into a hosts file to provide
   // completion for a list of known hosts.
   return []string{â€œsshhost.exampleâ€, â€œwebhost.exampleâ€, â€œftphost.exampleâ€}
}
â€‹
type NetcatCommand struct {
   hostName string
   port int
   format string
}
â€‹
func (n *NetcatCommand) run(c *kingpin.ParseContext) error {
   fmt.Printf(â€œWould have run netcat to hostname %v, port %d, and output format %v\nâ€, n.hostName, n.port, n.format)
   return nil
}
â€‹
func configureNetcatCommand(app *kingpin.Application) {
   c := &amp;NetcatCommand{}
   nc := app.Command(â€œncâ€, â€œConnect to a Hostâ€).Action(c.run)
   nc.Flag(â€œnop-flagâ€, â€œExample of a flag with no optionsâ€).Bool()
â€‹
   // You can provide hint options using a function to generate them
   nc.Flag(â€œhostâ€, â€œProvide a hostname to ncâ€).
      Required().
      HintAction(listHosts).
      StringVar(&amp;c.hostName)
â€‹
   // You can provide hint options statically
   nc.Flag(â€œportâ€, â€œProvide a port to connect toâ€).
      Required().
      HintOptions(â€œ80â€, â€œ443â€, â€œ8080â€).
      IntVar(&amp;c.port)
â€‹
   // Enum/EnumVar options will be turned into completion options automatically
   nc.Flag(â€œformatâ€, â€œDefine the output formatâ€).
      Default(â€œrawâ€).
      EnumVar(&amp;c.format, â€œrawâ€, â€œjsonâ€)
â€‹
   // You can combine HintOptions with HintAction too
   nc.Flag(â€œhost-with-multiâ€, â€œDefine a hostnameâ€).
      HintAction(listHosts).
      HintOptions(â€œmyhost.comâ€).
      String()
â€‹
   // And combine with themselves
   nc.Flag(â€œhost-with-multi-optionsâ€, â€œDefine a hostnameâ€).
      HintOptions(â€œmyhost.comâ€).
      HintOptions(â€œmyhost2.comâ€).
      String()
â€‹
   // If you specify HintOptions/HintActions for Enum/EnumVar, the options
   // provided for Enum/EnumVar will be overridden.
   nc.Flag(â€œformat-with-override-1â€, â€œDefine a formatâ€).
      HintAction(listHosts).
      Enum(â€œoption1â€, â€œoption2â€)
â€‹
   nc.Flag(â€œformat-with-override-2â€, â€œDefine a formatâ€).
      HintOptions(â€œmyhost.comâ€, â€œmyhost2.comâ€).
      Enum(â€œoption1â€, â€œoption2â€)
}
â€‹
func addSubCommand(app *kingpin.Application, name string, description string) {
   c := app.Command(name, description).Action(func(c *kingpin.ParseContext) error {
      fmt.Printf(â€œWould have run command %s.\nâ€, name)
      return nil
   })
   c.Flag(â€œnop-flagâ€, â€œExample of a flag with no optionsâ€).Bool()
}
â€‹
func main() {
   app := kingpin.New(â€œcompletionâ€, â€œMy application with bash completion.â€)
   app.Flag(â€œflag-1â€, â€œâ€).String()
   app.Flag(â€œflag-2â€, â€œâ€).HintOptions(â€œopt1â€, â€œopt2â€).String()
â€‹
   configureNetcatCommand(app)
â€‹
   // Add some additional top level commands
   addSubCommand(app, â€œlsâ€, â€œAdditional top level command to show command completionâ€)
   addSubCommand(app, â€œpingâ€, â€œAdditional top level command to show command completionâ€)
   addSubCommand(app, â€œnmapâ€, â€œAdditional top level command to show command completionâ€)
â€‹
   kingpin.MustParse(app.Parse(os.Args[1:]))
}
è¿è¡Œæ•ˆæœ
go run cmd/kingpin/main.go 
usage: completion [<flags>] <command /> [<args> ...]
â€‹
My application with bash completion.
â€‹
Flags:
  --help Show context-sensitive help (also try --help-long and --help-man).
  --flag-1=FLAG-1  
  --flag-2=FLAG-2  
â€‹
Commands:
  help [<command />...]
    Show help.
â€‹
  nc --host=HOST --port=PORT [<flags>]
    Connect to a Host
â€‹
  ls [<flags>]
    Additional top level command to show command completion
â€‹
  ping [<flags>]
    Additional top level command to show command completion
â€‹
  nmap [<flags>]
    Additional top level command to show command completion
è¯´æ˜
ä»¥ä¸Šæ˜¯å‡ ä¸ªæ•´ç†çš„cliï¼ŒåæœŸä¼šç»§ç»­å®Œå–„</flags></flags></flags></flags></args></flags></p>

<p>å‚è€ƒèµ„æ–™
https://github.com/google/subcommands
https://github.com/urfave/cli
https://github.com/mitchellh/cli
https://github.com/alecthomas/kingpin
http://github.com/spf13/cobra
https://github.com/rongfengliang/cliapp</p>

:ET