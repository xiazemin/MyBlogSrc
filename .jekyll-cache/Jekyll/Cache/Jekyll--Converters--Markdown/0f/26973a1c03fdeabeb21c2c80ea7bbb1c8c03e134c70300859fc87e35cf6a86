I"Y<p>ä»€ä¹ˆæ˜¯â€œæŒä¹…åŒ–â€ 
æŒä¹…ï¼ˆPersistenceï¼‰ï¼Œå³æŠŠæ•°æ®ï¼ˆå¦‚å†…å­˜ä¸­çš„å¯¹è±¡ï¼‰ä¿å­˜åˆ°å¯æ°¸ä¹…ä¿å­˜çš„å­˜å‚¨è®¾å¤‡ä¸­ï¼ˆå¦‚ç£ç›˜ï¼‰ã€‚æŒä¹…åŒ–çš„ä¸»è¦åº”ç”¨æ˜¯å°†å†…å­˜ä¸­çš„æ•°æ®å­˜å‚¨åœ¨å…³ç³»å‹çš„æ•°æ®åº“ä¸­ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥å­˜å‚¨åœ¨ç£ç›˜æ–‡ä»¶ä¸­ã€XMLæ•°æ®æ–‡ä»¶ä¸­ç­‰ç­‰ã€‚</p>

<p>ä»€ä¹ˆæ˜¯ â€œæŒä¹…å±‚â€ 
æŒä¹…å±‚ï¼ˆPersistence Layerï¼‰ï¼Œå³ä¸“æ³¨äºå®ç°æ•°æ®æŒä¹…åŒ–åº”ç”¨é¢†åŸŸçš„æŸä¸ªç‰¹å®šç³»ç»Ÿçš„ä¸€ä¸ªé€»è¾‘å±‚é¢ï¼Œå°†æ•°æ®ä½¿ç”¨è€…å’Œæ•°æ®å®ä½“ç›¸å…³è”ã€‚</p>

<p>ä»€ä¹ˆæ˜¯ORM</p>

<p>å³Object-Relationl Mappingï¼Œå®ƒçš„ä½œç”¨æ˜¯åœ¨å…³ç³»å‹æ•°æ®åº“å’Œå¯¹è±¡ä¹‹é—´ä½œä¸€ä¸ªæ˜ å°„ï¼Œè¿™æ ·ï¼Œæˆ‘ä»¬åœ¨å…·ä½“çš„æ“ä½œæ•°æ®åº“çš„æ—¶å€™ï¼Œå°±ä¸éœ€è¦å†å»å’Œå¤æ‚çš„SQLè¯­å¥æ‰“äº¤é“ï¼Œåªè¦åƒå¹³æ—¶æ“ä½œå¯¹è±¡ä¸€æ ·æ“ä½œå®ƒå°±å¯ä»¥äº† ã€‚</p>

<p>ä¸ºä»€ä¹ˆè¦åšæŒä¹…åŒ–å’ŒORMè®¾è®¡(é‡è¦)</p>

<p>åœ¨ç›®å‰çš„ä¼ä¸šåº”ç”¨ç³»ç»Ÿè®¾è®¡ä¸­ï¼ŒMVCï¼Œå³ Modelï¼ˆæ¨¡å‹ï¼‰- Viewï¼ˆè§†å›¾ï¼‰- Controlï¼ˆæ§åˆ¶ï¼‰ä¸ºä¸»è¦çš„ç³»ç»Ÿæ¶æ„æ¨¡å¼ã€‚MVC ä¸­çš„ Model åŒ…å«äº†å¤æ‚çš„ä¸šåŠ¡é€»è¾‘å’Œæ•°æ®é€»è¾‘ï¼Œä»¥åŠæ•°æ®å­˜å–æœºåˆ¶ï¼ˆå¦‚ JDBCçš„è¿æ¥ã€SQLç”Ÿæˆå’ŒStatementåˆ›å»ºã€è¿˜æœ‰ResultSetç»“æœé›†çš„è¯»å–ç­‰ï¼‰ç­‰ã€‚å°†è¿™äº›å¤æ‚çš„ä¸šåŠ¡é€»è¾‘å’Œæ•°æ®é€»è¾‘åˆ†ç¦»ï¼Œä»¥å°†ç³»ç»Ÿçš„ç´§è€¦ åˆå…³ç³»è½¬åŒ–ä¸ºæ¾è€¦åˆå…³ç³»ï¼ˆå³è§£è€¦åˆï¼‰ï¼Œæ˜¯é™ä½ç³»ç»Ÿè€¦åˆåº¦è¿«åˆ‡è¦åšçš„ï¼Œä¹Ÿæ˜¯æŒä¹…åŒ–è¦åšçš„å·¥ä½œã€‚MVC æ¨¡å¼å®ç°äº†æ¶æ„ä¸Šå°†è¡¨ç°å±‚ï¼ˆå³Viewï¼‰å’Œæ•°æ®å¤„ç†å±‚ï¼ˆå³Modelï¼‰åˆ†ç¦»çš„è§£è€¦åˆï¼Œè€ŒæŒä¹…åŒ–çš„è®¾è®¡åˆ™å®ç°äº†æ•°æ®å¤„ç†å±‚å†…éƒ¨çš„ä¸šåŠ¡é€»è¾‘å’Œæ•°æ®é€»è¾‘åˆ†ç¦»çš„è§£è€¦åˆã€‚ è€Œ ORM ä½œä¸ºæŒä¹…åŒ–è®¾è®¡ä¸­çš„æœ€é‡è¦ä¹Ÿæœ€å¤æ‚çš„æŠ€æœ¯ï¼Œä¹Ÿæ˜¯ç›®å‰ä¸šç•Œçƒ­ç‚¹æŠ€æœ¯ã€‚</p>

<p>ç®€å•æ¥è¯´ï¼ŒæŒ‰é€šå¸¸çš„ç³»ç»Ÿè®¾è®¡ï¼Œä½¿ç”¨ JDBC æ“ä½œæ•°æ®åº“ï¼Œä¸šåŠ¡å¤„ç†é€»è¾‘å’Œæ•°æ®å­˜å–é€»è¾‘æ˜¯æ··æ‚åœ¨ä¸€èµ·çš„ã€‚
ä¸€èˆ¬åŸºæœ¬éƒ½æ˜¯å¦‚ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š
1ã€å»ºç«‹æ•°æ®åº“è¿æ¥ï¼Œè·å¾— Connection å¯¹è±¡ã€‚
2ã€æ ¹æ®ç”¨æˆ·çš„è¾“å…¥ç»„è£…æŸ¥è¯¢ SQL è¯­å¥ã€‚
3ã€æ ¹æ® SQL è¯­å¥å»ºç«‹ Statement å¯¹è±¡ æˆ–è€… PreparedStatement å¯¹è±¡ã€‚
4ã€ç”¨ Connection å¯¹è±¡æ‰§è¡Œ SQLè¯­å¥ï¼Œè·å¾—ç»“æœé›† ResultSet å¯¹è±¡ã€‚
5ã€ç„¶åä¸€æ¡ä¸€æ¡è¯»å–ç»“æœé›† ResultSet å¯¹è±¡ä¸­çš„æ•°æ®ã€‚
6ã€æ ¹æ®è¯»å–åˆ°çš„æ•°æ®ï¼ŒæŒ‰ç‰¹å®šçš„ä¸šåŠ¡é€»è¾‘è¿›è¡Œè®¡ç®—ã€‚
7ã€æ ¹æ®è®¡ç®—å¾—åˆ°çš„ç»“æœå†ç»„è£…æ›´æ–° SQL è¯­å¥ã€‚
8ã€å†ä½¿ç”¨ Connection å¯¹è±¡æ‰§è¡Œæ›´æ–° SQL è¯­å¥ï¼Œä»¥æ›´æ–°æ•°æ®åº“ä¸­çš„æ•°æ®ã€‚
7ã€æœ€åä¾æ¬¡å…³é—­å„ä¸ª Statement å¯¹è±¡å’Œ Connection å¯¹è±¡ã€‚</p>

<p>ç”±ä¸Šå¯çœ‹å‡ºä»£ç é€»è¾‘éå¸¸å¤æ‚ï¼Œè¿™è¿˜ä¸åŒ…æ‹¬æŸæ¡è¯­å¥æ‰§è¡Œå¤±è´¥çš„å¤„ç†é€»è¾‘ã€‚å…¶ä¸­çš„ä¸šåŠ¡å¤„ç†é€»è¾‘å’Œæ•°æ®å­˜å–é€»è¾‘å®Œå…¨æ··æ‚åœ¨ä¸€å—ã€‚è€Œä¸€ä¸ªå®Œæ•´çš„ç³»ç»Ÿè¦åŒ…å«æˆ åƒä¸Šä¸‡ä¸ªè¿™æ ·é‡å¤çš„è€Œåˆæ··æ‚çš„å¤„ç†è¿‡ç¨‹ï¼Œå‡å¦‚è¦å¯¹å…¶ä¸­æŸäº›ä¸šåŠ¡é€»è¾‘æˆ–è€…ä¸€äº›ç›¸å…³è”çš„ä¸šåŠ¡æµç¨‹åšä¿®æ”¹ï¼Œè¦æ”¹åŠ¨çš„ä»£ç é‡å°†ä¸å¯æƒ³è±¡ã€‚å¦ä¸€æ–¹é¢ï¼Œå‡å¦‚è¦æ¢æ•°æ®åº“ äº§å“æˆ–è€…è¿è¡Œç¯å¢ƒä¹Ÿå¯èƒ½æ˜¯ä¸ªä¸å¯èƒ½å®Œæˆçš„ä»»åŠ¡ã€‚è€Œç”¨æˆ·çš„è¿è¡Œç¯å¢ƒå’Œè¦æ±‚å´åƒå·®ä¸‡åˆ«ï¼Œæˆ‘ä»¬ä¸å¯èƒ½ä¸ºæ¯ä¸€ä¸ªç”¨æˆ·æ¯ä¸€ç§è¿è¡Œç¯å¢ƒè®¾è®¡ä¸€å¥—ä¸€æ ·çš„ç³»ç»Ÿã€‚
æ‰€ ä»¥å°±è¦å°†ä¸€æ ·çš„å¤„ç†ä»£ç å³ä¸šåŠ¡é€»è¾‘å’Œå¯èƒ½ä¸ä¸€æ ·çš„å¤„ç†å³æ•°æ®å­˜å–é€»è¾‘åˆ†ç¦»å¼€æ¥ï¼Œå¦ä¸€æ–¹é¢ï¼Œå…³ç³»å‹æ•°æ®åº“ä¸­çš„æ•°æ®åŸºæœ¬éƒ½æ˜¯ä»¥ä¸€è¡Œè¡Œçš„æ•°æ®è¿›è¡Œå­˜å–çš„ï¼Œè€Œç¨‹åº è¿è¡Œå´æ˜¯ä¸€ä¸ªä¸ªå¯¹è±¡è¿›è¡Œå¤„ç†ï¼Œè€Œç›®å‰å¤§éƒ¨åˆ†æ•°æ®åº“é©±åŠ¨æŠ€æœ¯ï¼ˆå¦‚ADO.NETã€JDBCã€ODBCç­‰ç­‰ï¼‰å‡æ˜¯ä»¥è¡Œé›†çš„ç»“æœé›†ä¸€æ¡æ¡è¿›è¡Œå¤„ç†çš„ã€‚æ‰€ä»¥ä¸ºè§£å†³ è¿™ä¸€å›°éš¾ï¼Œå°±å‡ºç° ORM è¿™ä¸€ä¸ªå¯¹è±¡å’Œæ•°æ®ä¹‹é—´æ˜ å°„æŠ€æœ¯ã€‚</p>

<p>ä¸¾ä¾‹æ¥è¯´ï¼Œæ¯”å¦‚è¦å®Œæˆä¸€ä¸ªè´­ç‰©æ‰“æŠ˜ä¿ƒé”€çš„ç¨‹åºï¼Œç”¨ ORM æ€æƒ³å°†å¦‚ä¸‹å®ç°ï¼ˆå¼•è‡ªã€Šæ·±å…¥æµ…å‡ºHibernateã€‹ï¼‰ï¼š
ä¸šåŠ¡é€»è¾‘å¦‚ä¸‹ï¼š
public Double calcAmount(String customerid, double amount) 
{
    // æ ¹æ®å®¢æˆ·IDè·å¾—å®¢æˆ·è®°å½•
    Customer customer = CustomerManager.getCustomer(custmerid); 
    // æ ¹æ®å®¢æˆ·ç­‰çº§è·å¾—æ‰“æŠ˜è§„åˆ™
    Promotion promotion = PromotionManager.getPromotion(customer.getLevel()); 
    // ç´¯ç§¯å®¢æˆ·æ€»æ¶ˆè´¹é¢ï¼Œå¹¶ä¿å­˜ç´¯è®¡ç»“æœ
    customer.setSumAmount(customer.getSumAmount().add(amount); 
    CustomerManager.save(customer); 
    // è¿”å›æ‰“æŠ˜åçš„é‡‘é¢
    return amount.multiply(protomtion.getRatio()); 
}
è¿™ æ ·ä»£ç å°±éå¸¸æ¸…æ™°äº†ï¼Œè€Œä¸”ä¸æ•°æ®å­˜å–é€»è¾‘å®Œå…¨åˆ†ç¦»ã€‚è®¾è®¡ä¸šåŠ¡é€»è¾‘ä»£ç çš„æ—¶å€™å®Œå…¨ä¸éœ€è¦è€ƒè™‘æ•°æ®åº“JDBCçš„é‚£äº›åƒç¯‡ä¸€å¾‹çš„æ“ä½œï¼Œè€Œå°†å®ƒäº¤ç»™ CustomerManager å’Œ PromotionManager ä¸¤ä¸ªç±»å»å®Œæˆã€‚è¿™å°±æ˜¯ä¸€ä¸ªç®€å•çš„ ORM è®¾è®¡ï¼Œå®é™…çš„ ORM å®ç°æ¡†æ¶æ¯”è¿™ä¸ªè¦å¤æ‚çš„å¤šã€‚
<!-- more -->
æ•°æ®åº“æŸ¥è¯¢
åœ¨ go å¼€å‘ä¸­, æŸ¥è¯¢æ•°æ®åº“ä¸€èˆ¬æœ‰ä¸¤ç§é€‰æ‹©:</p>

<p>ä½¿ç”¨ orm (gorm\xorm ç­‰)
ç›´æ¥å†™ SQL
ç›´æ¥ç¼–å†™ SQL è¯­ä¹‰æ¸…æ™°, ä¸æ˜“å‡ºé”™, ä½†æ˜¯é‡åˆ°å¤šä¸ªå¯å˜æ¡ä»¶æ—¶æ˜¾å¾—ä¸çµæ´»</p>

<p>ORM æœ‰æ¨¡å‹å…³ç³», è®°å½•é¢„åŠ è½½ (sql ç”Ÿæˆä¼˜åŒ–) ç­‰åŠŸèƒ½, ä½†æ˜¯ sql è¯­å¥å¯¹å¼€å‘äººå‘˜ç›¸å¯¹é€æ˜, ç®¡äº†å¤ªå¤šæ•°æ®åº“ç›¸å…³çš„ä¸œè¥¿, ç›¸å¯¹å°é—­, è¯­æ³•æ™¦æ¶©è¯­ä¹‰ä¸æ˜ç¡®, æƒ³è¦æ“ä½œ db è¿æ¥ã€æ„é€ å¤æ‚ SQL å¾ˆç¹ç</p>

<p>æŸ¥è¯¢æ„é€ å™¨
å¯¹äºæŸ¥è¯¢åœºæ™¯å°‘ã€æŸ¥è¯¢æ¡ä»¶ç›¸å¯¹å›ºå®šçš„ç³»ç»Ÿ, ç›´æ¥å†™ SQL æ— ç–‘æ˜¯ä¸€ç§å¥½çš„é€‰æ‹©ã€‚é‚£ä¹ˆ, å¯¹äº SQL å¤šå˜çš„åœºæ™¯è€Œåˆä¸æƒ³ä½¿ç”¨ orm çš„å¼€å‘è€…, å¦‚ä½•èƒ½å¿«é€Ÿå¼€å‘æ•°æ®å±‚å‘¢?</p>

<p>go çš„å®˜æ–¹åŒ…å·²ç»æä¾›äº†å¥½ç”¨çš„ database/sql å·¥å…·, ä¹Ÿæœ‰å„ä¸ªæ•°æ®åº“çš„é©±åŠ¨åŒ…, å±è”½äº†åº•å±‚é©±åŠ¨å·®å¼‚, ä½¿æ•°æ®åº“æŸ¥è¯¢å˜å¾—ç®€å•, åªéœ€æä¾› SQL è¯­å¥å’Œå ä½ç¬¦å‚æ•°å³å¯å¿«é€ŸæŸ¥è¯¢, ä¹Ÿæ— éœ€è€ƒè™‘ SQL æ³¨å…¥ç­‰é—®é¢˜ã€‚é‚£ä¹ˆ, åªè¦è§£å†³äº† SQL è¯­å¥å’Œå ä½ç¬¦å‚æ•°çš„æ„é€ é—®é¢˜, å°±è§£å†³äº†ç›´æ¥å†™ SQL çš„çµæ´»æ€§é—®é¢˜ã€‚</p>

<p>ä¸ºäº†è§£å†³ SQL è¯­å¥å’Œå ä½ç¬¦å‚æ•°çš„æ„é€ é—®é¢˜, æˆ‘ä»¬éœ€è¦æŸ¥è¯¢æ„é€ å™¨ (Query Builder)ã€‚ç®€è€Œè¨€ä¹‹, æŸ¥è¯¢æ„é€ å™¨å°±æ˜¯åˆ©ç”¨ database/sql çš„ä¼˜åŠ¿, æä¾›äº†ä¸€ç§ orm å’Œ raw sql ä¹‹é—´çš„ä¸­é—´æ–¹æ¡ˆã€‚æœ‰äº†æŸ¥è¯¢æ„é€ å™¨, ä½ å¯ä»¥åœ¨é‡åˆ°ä¸å®š SQL æ—¶åŠ¨æ€æ„é€  SQL, é‡åˆ°å¤æ‚ç¡®å®š SQL æ—¶ç›´æ¥å†™åŸç”Ÿ SQL, ä½¿æ•°æ®æŸ¥è¯¢æ›´åŠ çµæ´»å¯æ§ã€‚</p>

<p>æ€è·¯
åšä»€ä¹ˆ
æŸ¥è¯¢æ„é€ å™¨, é¡¾åæ€ä¹‰, æœ€ä¸»è¦çš„å°±æ˜¯æ„é€ ã€‚æ„é€ ä»€ä¹ˆ? æŸ¥è¯¢è¯­å¥ã€‚æŸ¥è¯¢è¯­å¥æœ¬èº«å°±æ˜¯ä¸€ä¸ªæ»¡è¶³æ ‡å‡† SQL è§„èŒƒçš„å­—ç¬¦ä¸², æ‰€ä»¥æˆ‘ä»¬è¦åšæŸ¥è¯¢æ„é€ å™¨, ä¸»è¦çš„ä»»åŠ¡å°±æ˜¯æ„é€ å­—ç¬¦ä¸²ã€‚</p>

<p>æ‹†è§£ SQL
åœ¨æ„é€ ä¸€æ¡ SQL ä¹‹å‰, ä¸å¦¨çœ‹çœ‹ä¸€æ¡ SQL æ˜¯ä»€ä¹ˆæ ·çš„å§ã€‚</p>

<p>SELECT <code class="language-plaintext highlighter-rouge">name</code>,<code class="language-plaintext highlighter-rouge">age</code>,<code class="language-plaintext highlighter-rouge">school</code> FROM <code class="language-plaintext highlighter-rouge">test</code> WHERE <code class="language-plaintext highlighter-rouge">name</code> = â€˜jackâ€™
å¤æ‚ç‚¹çš„, å¸¦è”åˆæŸ¥è¯¢ã€åˆ†ç»„ã€æ’åºã€åˆ†é¡µ</p>

<p>SELECT <code class="language-plaintext highlighter-rouge">t1</code>.<code class="language-plaintext highlighter-rouge">name</code>,<code class="language-plaintext highlighter-rouge">t1</code>.<code class="language-plaintext highlighter-rouge">age</code>,<code class="language-plaintext highlighter-rouge">t2</code>.<code class="language-plaintext highlighter-rouge">teacher</code>,<code class="language-plaintext highlighter-rouge">t3</code>.<code class="language-plaintext highlighter-rouge">address</code> FROM <code class="language-plaintext highlighter-rouge">test</code> as t1 LEFT JOIN <code class="language-plaintext highlighter-rouge">test2</code> as <code class="language-plaintext highlighter-rouge">t2</code> ON <code class="language-plaintext highlighter-rouge">t1</code>.<code class="language-plaintext highlighter-rouge">class</code> = <code class="language-plaintext highlighter-rouge">t2</code>.<code class="language-plaintext highlighter-rouge">class</code> INNER JOIN <code class="language-plaintext highlighter-rouge">test3</code> as t3 ON <code class="language-plaintext highlighter-rouge">t1</code>.<code class="language-plaintext highlighter-rouge">school</code> = <code class="language-plaintext highlighter-rouge">t3</code>.<code class="language-plaintext highlighter-rouge">school</code> WHERE <code class="language-plaintext highlighter-rouge">t1</code>.<code class="language-plaintext highlighter-rouge">age</code> &gt;= 20 GROUP BY <code class="language-plaintext highlighter-rouge">t1</code>.<code class="language-plaintext highlighter-rouge">age</code> HAVING COUNT(<code class="language-plaintext highlighter-rouge">t1</code>.<code class="language-plaintext highlighter-rouge">age</code>) &gt; 2 ORDER BY <code class="language-plaintext highlighter-rouge">t1</code>.<code class="language-plaintext highlighter-rouge">age</code> DESC LIMIT 10 OFFSET 0
å½“ç„¶, æ ‡å‡† SQL è¿˜æœ‰å¾ˆå¤šè¯­æ³•è§„å®š, è¿™é‡Œå°±ä¸ä¸€ä¸€ä¸¾ä¾‹ã€‚è€Œå¯¹äºè§„èŒƒä¸­æœ€å¸¸ç”¨çš„è¯­æ³•, æˆ‘ä»¬çš„æŸ¥è¯¢æ„é€ å™¨å¿…é¡»è¦æœ‰æ„é€ å®ƒä»¬çš„èƒ½åŠ›</p>

<p>ä¸€ä¸ªæ ‡å‡†çš„æŸ¥è¯¢è¯­å¥ç»“æ„å¦‚ä¸‹:</p>

<p>SELECT [å­—æ®µ] FROM [è¡¨å] [JOIN å­å¥] [WHERE å­å¥] [GROUP BY å­å¥] [HAVING å­å¥] [ORDER BY å­å¥] [LIMIT å­å¥]
å…¶ä¸­ JOIN å­å¥ã€WHERE å­å¥ã€ HAVING å­å¥å’Œ LIMIT å­å¥ä¼šç”¨åˆ°å ä½ç¬¦å‚æ•°</p>

<p>å†çœ‹ INSERTã€UPDATEã€DELETE æ“ä½œçš„ç»“æ„:</p>

<p>INSERT</p>

<p>INSERT INTO [è¡¨å] ([å­—æ®µå]) VALUES ([è¦æ’å…¥çš„å€¼])
è¦æ’å…¥çš„å€¼ä¼šç”¨åˆ°å ä½ç¬¦å‚æ•°</p>

<p>UPDATE</p>

<p>UPDATE [è¡¨å] [SET å­å¥] [WHERE å­å¥] 
SET å­å¥å’Œ WHERE å­å¥ä¼šç”¨åˆ°å ä½ç¬¦å‚æ•°</p>

<p>DELETE</p>

<p>DELETE FROM [è¡¨å] [WHERE å­å¥] 
WHERE å­å¥ä¼šç”¨åˆ°å ä½ç¬¦å‚æ•°</p>

<p>OK, æ‹†è§£åæ˜¯ä¸æ˜¯è§‰å¾— SQL è¯­å¥çš„åŸºæœ¬ç»“æ„å¾ˆç®€å•? è¦å®ç°æŸ¥è¯¢æ„é€ å™¨, åªéœ€æŒ‰ç…§è¿™äº›è¯­å¥çš„ç»“æ„æ„é€ å‡ºç›¸åº”çš„å­—ç¬¦ä¸², å¹¶ä¿å­˜éœ€è¦çš„å ä½ç¬¦å‚æ•°å³å¯ã€‚</p>

<p>å®ç°
æœ‰äº†æ€è·¯, å®ç°èµ·æ¥å°±ç®€å•äº†ã€‚</p>

<p>å‚è€ƒå…¶ä»–è¯­è¨€çš„æŸ¥è¯¢æ„é€ å™¨, æ–¹æ³•åç›´æ¥ä½“ç° SQL è¯­æ³•, å¤šä¸ºé“¾å¼è°ƒç”¨:</p>

<p>$db.table(â€œ<code class="language-plaintext highlighter-rouge">test</code>â€).
    where(â€œaâ€, â€œ&gt;â€, 20).
    where(â€œbâ€, â€œ=â€, â€œaaaâ€).
    get()
è¦å®ç°æŸ¥è¯¢æ„é€ å™¨, è¿™æ˜¯ä¸€ä¸ªå¥½çš„ç¤ºèŒƒã€‚</p>

<p>è¯ä¸å¤šè¯´, å¼€å†™!</p>

<p>é¦–å…ˆå®šä¹‰æˆ‘ä»¬çš„ SQLBuilder ç±»å‹:</p>

<p>type SQLBuilder struct {
    _select       string // select å­å¥å­—ç¬¦ä¸²
    _insert       string // insert å­å¥å­—ç¬¦ä¸²
    _update       string // update å­å¥å­—ç¬¦ä¸²
    _delete       string // delete å­å¥å­—ç¬¦ä¸²
    _table        string // è¡¨å
    _join         string // join å­å¥å­—ç¬¦ä¸²
    _where        string // where å­å¥å­—ç¬¦ä¸²
    _groupBy      string // group by å­å¥å­—ç¬¦ä¸²
    _having       string // having å­å¥å­—ç¬¦ä¸²
    _orderBy      string // order by å­å¥å­—ç¬¦ä¸²
    _limit        string // limit å­å¥å­—ç¬¦ä¸²
    _insertParams []interface{} // insert æ’å…¥å€¼éœ€è¦çš„å ä½ç¬¦å‚æ•°
    _updateParams []interface{} // update SET å­å¥éœ€è¦çš„å ä½ç¬¦å‚æ•°
    _whereParams  []interface{} // where å­å¥éœ€è¦çš„å ä½ç¬¦å‚æ•°
    _havingParams []interface{} // having å­å¥éœ€è¦çš„å ä½ç¬¦å‚æ•°
    _limitParams  []interface{} // limit å­å¥éœ€è¦çš„å ä½ç¬¦å‚æ•°
    _joinParams   []interface{} // join å­å¥éœ€è¦çš„å ä½ç¬¦å‚æ•°
}
SQLBuilder çš„æ„é€ å‡½æ•°:</p>

<p>func NewSQLBuilder() *SQLBuilder {
    return &amp;SQLBuilder{}
}
è·å– SQL å­—ç¬¦ä¸²
è·å–å­—ç¬¦ä¸²å¾ˆç®€å•, åªè¦æŒ‰ç…§ SQL çš„è§„å®šå°†å„ä¸ªå­å¥ç»„åˆå³å¯ã€‚</p>

<p>è·å– QuerySQL:</p>

<p>var ErrTableEmpty = errors.New(â€œtable emptyâ€)</p>

<p>func (sb *SQLBuilder) GetQuerySQL() (string, error) {
    if sb._table == â€œâ€ {
        return â€œâ€, ErrTableEmpty
    }
    var buf strings.Builder</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>buf.WriteString("SELECT ")
if sb._select != "" {
    buf.WriteString(sb._select)
} else {
    buf.WriteString("*")
}
buf.WriteString(" FROM ")
buf.WriteString(sb._table)
if sb._join != "" {
    buf.WriteString(" ")
    buf.WriteString(sb._join)
}
if sb._where != "" {
    buf.WriteString(" ")
    buf.WriteString(sb._where)
}
if sb._groupBy != "" {
    buf.WriteString(" ")
    buf.WriteString(sb._groupBy)
}
if sb._having != "" {
    buf.WriteString(" ")
    buf.WriteString(sb._having)
}
if sb._orderBy != "" {
    buf.WriteString(" ")
    buf.WriteString(sb._orderBy)
}
if sb._limit != "" {
    buf.WriteString(" ")
    buf.WriteString(sb._limit)
}

return buf.String(), nil } tips: ä¸Šè¿°ä»£ç ä½¿ç”¨ strings.Builder åŒ…æ¥æ‹¼æ¥å­—ç¬¦ä¸²ã€‚å½“ç„¶æ„é€ æŸ¥è¯¢è¯­å¥æœ¬èº«ä¸æ˜¯ä¸€ä¸ªé«˜é¢‘æ“ä½œ, ä¸è€ƒè™‘æ•ˆç‡ä½¿ç”¨ + æ¥æ‹¼æ¥ä¹Ÿæ˜¯å¯ä»¥çš„
</code></pre></div></div>

<p>è·å– InsertSQL:</p>

<p>var ErrInsertEmpty = errors.New(â€œinsert content emptyâ€)</p>

<p>func (sb *SQLBuilder) GetInsertSQL() (string, error) {
    if sb._table == â€œâ€ {
        return â€œâ€, ErrTableEmpty
    }
    if sb._insert == â€œâ€ {
        return â€œâ€, ErrInsertEmpty
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var buf strings.Builder

buf.WriteString("INSERT INTO ")
buf.WriteString(sb._table)
buf.WriteString(" ")
buf.WriteString(sb._insert)

return buf.String(), nil } è·å– UpdateSQL:
</code></pre></div></div>

<p>var ErrUpdateEmpty = errors.New(â€œupdate content emptyâ€)</p>

<p>func (sb *SQLBuilder) GetUpdateSQL() (string, error) {
    if sb._table == â€œâ€ {
        return â€œâ€, ErrTableEmpty
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if sb._update == "" {
    return "", ErrUpdateEmpty
}

var buf strings.Builder

buf.WriteString("UPDATE ")
buf.WriteString(sb._table)
buf.WriteString(" ")
buf.WriteString(sb._update)
if sb._where != "" {
    buf.WriteString(" ")
    buf.WriteString(sb._where)
}

return buf.String(), nil } è·å– DeteleSQL:
</code></pre></div></div>

<p>func (sb *SQLBuilder) GetDeleteSQL() (string, error) {
    if sb._table == â€œâ€ {
        return â€œâ€, ErrTableEmpty
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var buf strings.Builder

buf.WriteString("DELETE FROM ")
buf.WriteString(sb._table)
if sb._where != "" {
    buf.WriteString(" ")
    buf.WriteString(sb._where)
}

return buf.String(), nil } è·å–å ä½ç¬¦å‚æ•° åŒæ ·, æˆ‘ä»¬è¦å¡«å……å ä½ç¬¦ "?" çš„å‚æ•°ä¹Ÿéœ€è¦è·å¾—, queryã€insertã€updateã€delete æ‹¥æœ‰çš„å‚æ•°ç±»å‹éƒ½æœ‰å·®åˆ«, ä¹Ÿéƒ½æœ‰ç€ä¸åŒçš„é¡ºåº
</code></pre></div></div>

<p>func (sb *SQLBuilder) GetQueryParams() []interface{} {
    params := []interface{}{}
    params = append(params, sb._joinParamsâ€¦)
    params = append(params, sb._whereParamsâ€¦)
    params = append(params, sb._havingParamsâ€¦)
    params = append(params, sb._limitParamsâ€¦)
    return params
}</p>

<p>func (sb *SQLBuilder) GetInsertParams() []interface{} {
    params := []interface{}{}
    params = append(params, sb._insertParamsâ€¦)
    return params
}</p>

<p>func (sb *SQLBuilder) GetUpdateParams() []interface{} {
    params := []interface{}{}
    params = append(params, sb._updateParamsâ€¦)
    params = append(params, sb._whereParamsâ€¦)
    return params
}</p>

<p>func (sb *SQLBuilder) GetDeleteParams() []interface{} {
    params := []interface{}{}
    params = append(params, sb._whereParamsâ€¦)
    return params
}
è¡¨åè®¾ç½®
è®¾ç½®è¡¨å, è¿™é‡Œæˆ‘ä»¬è®¾ç½®å®Œæˆåè¿”å› SQLBuilder æŒ‡é’ˆè‡ªå·±, å¯ä»¥å®Œæˆé“¾å¼è°ƒç”¨ã€‚ä¹‹åå¤§éƒ¨åˆ†æ–¹æ³•éƒ½ä¼šä½¿ç”¨è¿™ç§æ–¹å¼ã€‚</p>

<p>func (sb *SQLBuilder) Table(table string) *SQLBuilder {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sb._table = table

return sb } ç”¨ä¾‹:
</code></pre></div></div>

<p>package main</p>

<p>import (
    â€œgithub.com/wazsmwazsm/QueryBuilder/builderâ€
    â€œlogâ€
)</p>

<p>func main() {
    sb := builder.NewSQLBuilder()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sql, err := sb.Table("`test`").
    Select("*").
    GetQuerySQL()
if err != nil {
    log.Fatal(err)
}

params := sb.GetQueryParams()

log.Println(sql)    // SELECT * FROM `test`
log.Println(params) // [] } select å­å¥ è®¾ç½® select å­å¥, æ”¯æŒå¤šä¸ªå‚æ•°ç”¨é€—å·éš”å¼€, æ³¨æ„æœ€åä¸€ä¸ªé€—å·è¦å»æ‰
</code></pre></div></div>

<p>func (sb *SQLBuilder) Select(cols â€¦string) *SQLBuilder {
    var buf strings.Builder</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for k, col := range cols {

    buf.WriteString(col)

    if k != len(cols)-1 {
        buf.WriteString(",")
    }
}

sb._select = buf.String()

return sb } ç”¨ä¾‹:
</code></pre></div></div>

<p>package main</p>

<p>import (
    â€œgithub.com/wazsmwazsm/QueryBuilder/builderâ€
    â€œlogâ€
)</p>

<p>func main() {
    sb := builder.NewSQLBuilder()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sql, err := sb.Table("`test`").
    Select("`age`", "COUNT(age)").
    GetQuerySQL()
if err != nil {
    log.Fatal(err)
}

params := sb.GetQueryParams()

log.Println(sql)    // SELECT `age`,COUNT(age) FROM `test`
log.Println(params) // [] } where å­å¥ where å¯¹äº where å­å¥, ç¬¬ä¸€ä¸ª where æ¡ä»¶éœ€è¦ WHERE å…³é”®å­—, å†æœ‰å…¶å®ƒæ¡ä»¶, ä¼šé€šè¿‡ AND å’Œ OR æ¥è¿æ¥, é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¢åŠ  Where() å’Œ OrWhere() æ–¹æ³•, ä¸¤ä¸ªæ–¹æ³•å…¬å…±é€»è¾‘å¯ä»¥æå‡ºæ¥:
</code></pre></div></div>

<p>func (sb *SQLBuilder) Where(field string, condition string, value interface{}) *SQLBuilder {
    return sb.where(â€œANDâ€, condition, field, value)
}</p>

<p>func (sb *SQLBuilder) OrWhere(field string, condition string, value interface{}) *SQLBuilder {
    return sb.where(â€œORâ€, condition, field, value)
}</p>

<p>func (sb *SQLBuilder) where(operator string, condition string, field string, value interface{}) *SQLBuilder {
    var buf strings.Builder</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>buf.WriteString(sb._where) // è½½å…¥ä¹‹å‰çš„ where å­å¥

if buf.Len() == 0 { // where å­å¥è¿˜æ²¡è®¾ç½®
    buf.WriteString("WHERE ")
} else { // å·²ç»è®¾ç½®, æ‹¼æ¥ OR æˆ– AND æ“ä½œç¬¦
    buf.WriteString(" ")
    buf.WriteString(operator)
    buf.WriteString(" ")
}

buf.WriteString(field) // æ‹¼æ¥å­—æ®µ

buf.WriteString(" ")
buf.WriteString(condition) // æ‹¼æ¥æ¡ä»¶ =ã€!=ã€&lt;ã€&gt;ã€like ç­‰
buf.WriteString(" ")
buf.WriteString("?") // æ‹¼æ¥å ä½ç¬¦

sb._where = buf.String() // å†™å­—ç¬¦ä¸²

sb._whereParams = append(sb._whereParams, value) // push å ä½ç¬¦å‚æ•°åˆ°æ•°ç»„

return sb } ç”¨ä¾‹:
</code></pre></div></div>

<p>package main</p>

<p>import (
    â€œgithub.com/wazsmwazsm/QueryBuilder/builderâ€
    â€œlogâ€
)</p>

<p>func main() {
    sb := builder.NewSQLBuilder()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sql, err := sb.Table("`test`").
    Select("`name`", "`age`", "`school`").
    Where("`name`", "=", "jack").
    Where("`age`", "&gt;=", 18).
    OrWhere("`name`", "like", "%admin%").
    GetQuerySQL()
if err != nil {
    log.Fatal(err)
}

params := sb.GetQueryParams()

log.Println(sql)    // SELECT `name`,`age`,`school` FROM `test` WHERE `name` = ? AND `age` &gt;= ? OR `name` like ?
log.Println(params) // [jack 18 %admin%] } ä¸Šè¿°ä»£ç å¯ä»¥è§£å†³ç®€å•çš„æ¡ä»¶å­å¥, å¦‚æœé‡åˆ° WHERE a = ? AND (b = ? OR c = ?) è¿™æ ·çš„å¤æ‚å­å¥, è¯¥å¦‚ä½•æ„é€ å‘¢? é¢å¯¹è¿™ç§åœºæ™¯, æˆ‘ä»¬éœ€è¦æä¾›ä¹¦å†™åŸç”Ÿ where å­å¥çš„èƒ½åŠ›, å¢åŠ  WhereRaw() å’Œ OrWhereRaw() æ–¹æ³•:
</code></pre></div></div>

<p>func (sb *SQLBuilder) WhereRaw(s string, values â€¦interface{}) *SQLBuilder {
    return sb.whereRaw(â€œANDâ€, s, values)
}</p>

<p>func (sb *SQLBuilder) OrWhereRaw(s string, values â€¦interface{}) *SQLBuilder {
    return sb.whereRaw(â€œORâ€, s, values)
}</p>

<p>func (sb *SQLBuilder) whereRaw(operator string, s string, values []interface{}) *SQLBuilder {
    var buf strings.Builder</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>buf.WriteString(sb._where) // append

if buf.Len() == 0 {
    buf.WriteString("WHERE ")
} else {
    buf.WriteString(" ")
    buf.WriteString(operator)
    buf.WriteString(" ")
}

buf.WriteString(s) // ç›´æ¥ä½¿ç”¨ raw SQL å­—ç¬¦ä¸²
sb._where = buf.String()

for _, value := range values {
    sb._whereParams = append(sb._whereParams, value)
}

return sb } ç”¨ä¾‹:
</code></pre></div></div>

<p>package main</p>

<p>import (
    â€œgithub.com/wazsmwazsm/QueryBuilder/builderâ€
    â€œlogâ€
)</p>

<p>func main() {
    sb := builder.NewSQLBuilder()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sql, err := sb.Table("`test`").
    Select("`name`", "`age`", "`school`").
    WhereRaw("`title` = ?", "hello").
    Where("`name`", "=", "jack").
    OrWhereRaw("(`age` = ? OR `age` = ?) AND `class` = ?", 22, 25, "2-3").
    GetQuerySQL()
if err != nil {
    log.Fatal(err)
}

params := sb.GetQueryParams()

log.Println(sql)    // SELECT `name`,`age`,`school` FROM `test` WHERE `title` = ? AND `name` = ? OR (`age` = ? OR `age` = ?) AND `class` = ?
log.Println(params) // [hello jack 22 25 2-3] }
</code></pre></div></div>

<p>where in
where in ä¹Ÿæ˜¯å¸¸è§çš„ where å­å¥, where in å­å¥åˆ†ä¸º where inã€or where inã€where not inã€or where not in å››ç§æ¨¡å¼, å ä½ç¬¦æ•°é‡ç­‰äº where in çš„é›†åˆæ•°é‡ã€‚</p>

<p>æˆ‘ä»¬å¸Œæœ›æ„é€  where in å­å¥çš„æ–¹æ³•å…¥å‚æ˜¯ä¸€ä¸ª slice, å ä½ç¬¦çš„æ•°é‡ç­‰äº slice çš„é•¿åº¦, é‚£ä¹ˆæˆ‘ä»¬éœ€è¦å°è£…ä¸€ä¸ªç”Ÿæˆå ä½ç¬¦çš„å‡½æ•°:</p>

<p>func GenPlaceholders(n int) string {
    var buf strings.Builder</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i := 0; i &lt; n-1; i++ {
    buf.WriteString("?,") // ç”Ÿæˆ n-1 ä¸ª "?" å ä½ç¬¦
}

if n &gt; 0 {
    buf.WriteString("?") // ç”Ÿæˆæœ€åä¸€ä¸ªå ä½ç¬¦, å¦‚æœ n &lt;= 0 åˆ™ä¸ç”Ÿæˆä»»ä½•å ä½ç¬¦
}

return buf.String() }
</code></pre></div></div>

<p>æŒ‰ç…§ where in å­å¥çš„å››ç§æ¨¡å¼, å¢åŠ  WhereIn() OrWhereIn() WhereNotIn() OrWhereNotIn() æ–¹æ³•:</p>

<p>func (sb *SQLBuilder) WhereIn(field string, values â€¦interface{}) *SQLBuilder {
    return sb.whereIn(â€œANDâ€, â€œINâ€, field, values)
}</p>

<p>func (sb *SQLBuilder) OrWhereIn(field string, values â€¦interface{}) *SQLBuilder {
    return sb.whereIn(â€œORâ€, â€œINâ€, field, values)
}</p>

<p>func (sb *SQLBuilder) WhereNotIn(field string, values â€¦interface{}) *SQLBuilder {
    return sb.whereIn(â€œANDâ€, â€œNOT INâ€, field, values)
}</p>

<p>func (sb *SQLBuilder) OrWhereNotIn(field string, values â€¦interface{}) *SQLBuilder {
    return sb.whereIn(â€œORâ€, â€œNOT INâ€, field, values)
}</p>

<p>func (sb *SQLBuilder) whereIn(operator string, condition string, field string, values []interface{}) *SQLBuilder {
    var buf strings.Builder</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>buf.WriteString(sb._where) // append

if buf.Len() == 0 {
    buf.WriteString("WHERE ")
} else {
    buf.WriteString(" ")
    buf.WriteString(operator)
    buf.WriteString(" ")
}

buf.WriteString(field)

plhs := GenPlaceholders(len(values)) // ç”Ÿæˆå ä½ç¬¦
buf.WriteString(" ")
buf.WriteString(condition)
buf.WriteString(" ")
buf.WriteString("(")
buf.WriteString(plhs) // æ‹¼æ¥å ä½ç¬¦
buf.WriteString(")")

sb._where = buf.String()

for _, value := range values { 
    sb._whereParams = append(sb._whereParams, value) // push å ä½ç¬¦å‚æ•°
}

return sb } ç”¨ä¾‹:
</code></pre></div></div>

<p>package main</p>

<p>import (
    â€œgithub.com/wazsmwazsm/QueryBuilder/builderâ€
    â€œlogâ€
)</p>

<p>func main() {
    sb := builder.NewSQLBuilder()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sql, err := sb.Table("`test`").
    Select("`name`", "`age`", "`school`").
    WhereIn("`id`", 1, 2, 3).
    OrWhereNotIn("`uid`", 2, 4).
    GetQuerySQL()
if err != nil {
    log.Fatal(err)
}

params := sb.GetQueryParams()

log.Println(sql)    // SELECT `name`,`age`,`school` FROM `test` WHERE `id` IN (?,?,?) OR `uid` NOT IN (?,?)
log.Println(params) // [1 2 3 2 4] }
</code></pre></div></div>

<p>group by å­å¥
group by å­å¥å¯ä»¥æ ¹æ®å¤šä¸ªå­—æ®µåˆ†ç»„:</p>

<p>func (sb *SQLBuilder) GroupBy(fields â€¦string) *SQLBuilder {
    var buf strings.Builder</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>buf.WriteString("GROUP BY ")

for k, field := range fields {

    buf.WriteString(field)

    if k != len(fields)-1 {
        buf.WriteString(",")
    }
}

sb._groupBy = buf.String()

return sb } having å­å¥å’Œ where å­å¥åŸºæœ¬ç›¸åŒ, è¿™é‡Œå°±ä¸è´¹ç¯‡å¹…è¯´æ˜äº†, è¯¦ç»†è§ QueryBuilder/builder/builder.go
</code></pre></div></div>

<p>ç”¨ä¾‹:</p>

<p>package main</p>

<p>import (
    â€œgithub.com/wazsmwazsm/QueryBuilder/builderâ€
    â€œlogâ€
)</p>

<p>func main() {
    sb := builder.NewSQLBuilder()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sql, err := sb.Table("`test`").
    Select("`school`", "`class`", "COUNT(*) as `ct`").
    GroupBy("`school`", "`class`").
    Having("`ct`", "&gt;", "2").
    GetQuerySQL()
if err != nil {
    log.Fatal(err)
}

params := sb.GetQueryParams()

log.Println(sql)    // SELECT `school`,`class`,COUNT(*) as `ct` FROM `test` GROUP BY `school`,`class` HAVING `ct` &gt; ?
log.Println(params) // [2] }
</code></pre></div></div>

<p>order by å­å¥å’Œ limit å­å¥
order by å­å¥å¯ä»¥æ ¹æ®å¤šä¸ªå­—æ®µæ¥æ’åº:</p>

<p>func (sb *SQLBuilder) OrderBy(operator string, fields â€¦string) *SQLBuilder {
    var buf strings.Builder</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>buf.WriteString("ORDER BY ")

for k, field := range fields {

    buf.WriteString(field)

    if k != len(fields)-1 {
        buf.WriteString(",")
    }
}

buf.WriteString(" ")
buf.WriteString(operator) // DESC æˆ– ASC

sb._orderBy = buf.String()

return sb } limit æ¥é™åˆ¶æŸ¥è¯¢çš„ç»“æœ, è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ LIMIT OFFSET è¯­æ³•, è¿™ä¸ªè¯­æ³•æ˜¯æ ‡å‡† SQL è§„å®šçš„, LIMIT x,x è¿™ä¸ªå½¢å¼åªæœ‰ mysql æ”¯æŒ
</code></pre></div></div>

<p>func (sb *SQLBuilder) Limit(offset, num interface{}) *SQLBuilder {
    var buf strings.Builder</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>buf.WriteString("LIMIT ? OFFSET ?")

sb._limit = buf.String()

sb._limitParams = append(sb._limitParams, num, offset)

return sb }
</code></pre></div></div>

<p>ç”¨ä¾‹:</p>

<p>package main</p>

<p>import (
    â€œgithub.com/wazsmwazsm/QueryBuilder/builderâ€
    â€œlogâ€
)</p>

<p>func main() {
    sb := builder.NewSQLBuilder()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sql, err := sb.Table("`test`").
    Select("`name`", "`age`", "`school`").
    Where("`name`", "=", "jack").
    Where("`age`", "&gt;=", 18).
    OrderBy("DESC", "`age`", "`class`").
    Limit(1, 10).
    GetQuerySQL()
if err != nil {
    log.Fatal(err)
}

params := sb.GetQueryParams()

log.Println(sql)    // SELECT `name`,`age`,`school` FROM `test` WHERE `name` = ? AND `age` &gt;= ? ORDER BY `age`,`class` DESC LIMIT ? OFFSET ?
log.Println(params) // [jack 18 10 1] }
</code></pre></div></div>

<p>join å­å¥
ä½¿ç”¨ join å­å¥å, SQL å˜å¾—å¤æ‚ã€‚æ ‡å‡† SQL join æœ‰ left joinã€right joinã€inner joinã€full join å‡ ç§æ¨¡å¼ join å­å¥çš„ on æ¡ä»¶ç±»ä¼¼ where å­å¥, è¿è¡¨åéœ€è¦ç»™è¡¨èµ·åˆ«åç”¨æ¥åŒºåˆ†å­—æ®µæ‰€å±â€¦é¢å¯¹è¿™æ ·çµæ´»å¤šå˜çš„è¯­æ³•, æˆ‘ä»¬è¿™é‡Œè¾ƒå¥½çš„æ–¹å¼å°±æ˜¯æä¾› raw sql çš„å½¢å¼æ¥å¤„ç† join æ“ä½œ:</p>

<p>func (sb *SQLBuilder) JoinRaw(join string, values â€¦interface{}) *SQLBuilder {
    var buf strings.Builder</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>buf.WriteString(sb._join)
if buf.Len() != 0 {
    buf.WriteString(" ")
}
buf.WriteString(join) // æ‹¼æ¥ raw join sql

sb._join = buf.String()

for _, value := range values {
    sb._joinParams = append(sb._joinParams, value)
}

return sb } ç”¨ä¾‹ (æ„é€ ä¸€ä¸ªå¤æ‚çš„æŸ¥è¯¢):
</code></pre></div></div>

<p>package main</p>

<p>import (
    â€œgithub.com/wazsmwazsm/QueryBuilder/builderâ€
    â€œlogâ€
)</p>

<p>func main() {
    sb := builder.NewSQLBuilder()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sql, err := sb.Table("`test` as t1").
    Select("`t1`.`name`", "`t1`.`age`", "`t2`.`teacher`", "`t3`.`address`").
    JoinRaw("LEFT JOIN `test2` as `t2` ON `t1`.`class` = `t2`.`class`").
    JoinRaw("INNER JOIN `test3` as t3 ON `t1`.`school` = `t3`.`school`").
    Where("`t1`.`age`", "&gt;=", 18).
    GroupBy("`t1`.`age`").
    Having("COUNT(`t1`.`age`)", "&gt;", 2).
    OrderBy("DESC", "`t1`.`age`").
    Limit(1, 10).
    GetQuerySQL()
if err != nil {
    log.Fatal(err)
}

params := sb.GetQueryParams()

log.Println(sql)    // SELECT `t1`.`name`,`t1`.`age`,`t2`.`teacher`,`t3`.`address` FROM `test` as t1 LEFT JOIN `test2` as `t2` ON `t1`.`class` = `t2`.`class` INNER JOIN `test3` as t3 ON `t1`.`school` = `t3`.`school` WHERE `t1`.`age` &gt;= ? GROUP BY `t1`.`age` HAVING COUNT(`t1`.`age`) &gt; ? ORDER BY `t1`.`age` DESC LIMIT ? OFFSET ?
log.Println(params) // [18 2 10 1] }
</code></pre></div></div>

<p>insert
insert SQL æ„å»º:</p>

<p>func (sb *SQLBuilder) Insert(cols []string, values â€¦interface{}) *SQLBuilder {
    var buf strings.Builder</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// æ‹¼æ¥å­—æ®µ
buf.WriteString("(")
for k, col := range cols {

    buf.WriteString(col)

    if k != len(cols)-1 {
        buf.WriteString(",")
    }
}
buf.WriteString(") VALUES (")

// æ‹¼æ¥å ä½ç¬¦
for k := range cols {
    buf.WriteString("?")
    if k != len(cols)-1 {
        buf.WriteString(",")
    }
}
buf.WriteString(")")

sb._insert = buf.String()

for _, value := range values { // push å ä½ç¬¦å‚æ•°
    sb._insertParams = append(sb._insertParams, value)
}

return sb } ç”¨ä¾‹:
</code></pre></div></div>

<p>package main</p>

<p>import (
    â€œgithub.com/wazsmwazsm/QueryBuilder/builderâ€
    â€œlogâ€
)</p>

<p>func main() {
    sb := builder.NewSQLBuilder()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sql, err := sb.Table("`test`").
    Insert([]string{"`name`", "`age`"}, "jack", 18).
    GetInsertSQL()
if err != nil {
    log.Fatal(err)
}

params := sb.GetInsertParams()

log.Println(sql)    // INSERT INTO `test` (`name`,`age`) VALUES (?,?)
log.Println(params) // [jack 18] }
</code></pre></div></div>

<p>update
update SQL æ„å»º:</p>

<p>package main</p>

<p>import (
    â€œgithub.com/wazsmwazsm/QueryBuilder/builderâ€
    â€œlogâ€
)</p>

<p>func main() {
    sb := builder.NewSQLBuilder()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sql, err := sb.Table("`test`").
    Update([]string{"`name`", "`age`"}, "jack", 18).
    Where("`id`", "=", 11).
    GetUpdateSQL()
if err != nil {
    log.Fatal(err)
}

params := sb.GetUpdateParams()

log.Println(sql)    // UPDATE `test` SET `name` = ?,`age` = ? WHERE `id` = ?
log.Println(params) // [jack 18 11] }
</code></pre></div></div>

<p>delete
delete SQL æ„å»º:</p>

<p>package main</p>

<p>import (
    â€œgithub.com/wazsmwazsm/QueryBuilder/builderâ€
    â€œlogâ€
)</p>

<p>func main() {
    sb := builder.NewSQLBuilder()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sql, err := sb.Table("`test`").
    Where("`id`", "=", 11).
    GetDeleteSQL()
if err != nil {
    log.Fatal(err)
}

params := sb.GetDeleteParams()

log.Println(sql)    // DELETE FROM `test` WHERE `id` = ?
log.Println(params) // [11] }
</code></pre></div></div>

<p>OK, æŸ¥è¯¢æ„é€ å™¨çš„å®ç°åˆ°æ­¤ç»“æŸ, æ˜¯ä¸æ˜¯å¾ˆç®€å•å‘¢?</p>

<p>ä½¿ç”¨
æŸ¥è¯¢æ„é€ å™¨å®ç°äº†, é‚£ä¹ˆå°±ç»“åˆ database/sql ç”¨ç”¨å§!</p>

<p>ä»¥ mysql ä¸ºä¾‹:</p>

<p>package main</p>

<p>import (
    â€œdatabase/sqlâ€
    â€œfmtâ€
    _ â€œgithub.com/go-sql-driver/mysqlâ€
    â€œgithub.com/wazsmwazsm/QueryBuilder/builderâ€
    â€œlogâ€
)</p>

<p>// Info å®šä¹‰ä¸€ä¸ªæ•°æ®æ¨¡å‹, ç”¨äºæ¥æ”¶æŸ¥è¯¢æ•°æ®
type Info struct {
    Age      int
    AgeCount int
}</p>

<p>func main() {
    // åˆ›å»º mysql è¿æ¥
    dataSource := fmt.Sprintf(â€œ%s:%s@tcp(%s:%v)/%s?charset=utf8â€,
        â€œtestâ€, â€œtestâ€, â€œ127.0.0.1â€, 3306, â€œtestâ€)
    mysqlConn, err := sql.Open(â€œmysqlâ€, dataSource)
    if err != nil {
        log.Panic(â€œDb connect failed!â€ + err.Error())
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// åˆ›å»ºæŸ¥è¯¢æ„é€ å™¨å®ä¾‹
sb := builder.NewSQLBuilder()

querySQL, err := sb.Table("`test`").
    Select("`age`", "COUNT(age)").
    GroupBy("`age`").
    GetQuerySQL()
if err != nil {
    log.Fatal(err)
}

params := sb.GetQueryParams()

// æ‰§è¡ŒæŸ¥è¯¢
rows, err := mysqlConn.Query(querySQL, params...)
if err != nil {
    log.Panic(err)
}
defer rows.Close()

// æŸ¥è¯¢æ•°æ®ç»‘å®šåˆ° info ç»“æ„ä¸­
infos := []*Info{}
for rows.Next() {
    info := new(Info)
    if err := rows.Scan(
        &amp;info.Age,
        &amp;info.AgeCount,
    ); err != nil {
        log.Panicln(err)
    }
    infos = append(infos, info)
}

for _, info := range infos {
    fmt.Println(info)
}
</code></pre></div></div>

<p>}</p>

<p>ä¸ºäº†æ”¯æŒä¸šåŠ¡å±‚ä¸­çš„äº‹åŠ¡ï¼Œæˆ‘è¯•å›¾åœ¨Goä¸­æŸ¥æ‰¾ç±»ä¼¼Springçš„å£°æ˜å¼äº‹åŠ¡ç®¡ç†ï¼Œä½†æ˜¯æ²¡æ‰¾åˆ°ï¼Œæ‰€ä»¥æˆ‘å†³å®šè‡ªå·±å†™ä¸€ä¸ªã€‚ äº‹åŠ¡å¾ˆå®¹æ˜“åœ¨Goä¸­å®ç°ï¼Œä½†å¾ˆéš¾åšåˆ°æ­£ç¡®åœ°å®ç°ã€‚</p>

<p>éœ€æ±‚:
1.å°†ä¸šåŠ¡é€»è¾‘ä¸äº‹åŠ¡ä»£ç åˆ†å¼€ã€‚
åœ¨ç¼–å†™ä¸šåŠ¡ç”¨ä¾‹æ—¶ï¼Œå¼€å‘è€…åº”è¯¥åªéœ€è€ƒè™‘ä¸šåŠ¡é€»è¾‘ï¼Œä¸éœ€è¦åŒæ—¶è€ƒè™‘æ€æ ·ç»™ä¸šåŠ¡é€»è¾‘åŠ äº‹åŠ¡ç®¡ç†ã€‚å¦‚æœä»¥åéœ€è¦æ·»åŠ äº‹åŠ¡æ”¯æŒï¼Œä½ å¯ä»¥åœ¨ç°æœ‰ä¸šåŠ¡é€»è¾‘çš„åŸºç¡€ä¸Šè¿›è¡Œç®€å•å°è£…ï¼Œè€Œæ— éœ€æ›´æ”¹ä»»ä½•å…¶ä»–ä»£ç ã€‚äº‹åŠ¡å®ç°ç»†èŠ‚åº”è¯¥å¯¹ä¸šåŠ¡é€»è¾‘é€æ˜ã€‚</p>

<p>2.äº‹åŠ¡é€»è¾‘åº”è¯¥ä½œç”¨äºç”¨ä¾‹å±‚ï¼ˆä¸šåŠ¡é€»è¾‘ï¼‰
ä¸åœ¨æŒä¹…å±‚ä¸Šã€‚</p>

<p>3.æ•°æ®æœåŠ¡ï¼ˆæ•°æ®æŒä¹…æ€§ï¼‰å±‚åº”å¯¹äº‹åŠ¡é€»è¾‘é€æ˜ã€‚
è¿™æ„å‘³ç€æŒä¹…æ€§ä»£ç åº”è¯¥æ˜¯ç›¸åŒçš„ï¼Œæ— è®ºå®ƒæ˜¯å¦æ”¯æŒäº‹åŠ¡</p>

<p>4.ä½ å¯ä»¥é€‰æ‹©å»¶è¿Ÿæ”¯æŒäº‹ç‰©ã€‚
ä½ å¯ä»¥å…ˆç¼–å†™æ²¡æœ‰äº‹åŠ¡çš„ç”¨ä¾‹ï¼Œç¨åå¯ä»¥åœ¨ä¸ä¿®æ”¹ç°æœ‰ä»£ç çš„æƒ…å†µä¸‹ç»™è¯¥ç”¨ä¾‹åŠ ä¸Šäº‹åŠ¡ã€‚ä½ åªéœ€æ·»åŠ æ–°ä»£ç ã€‚</p>

<p>æˆ‘æœ€ç»ˆçš„è§£å†³æ–¹æ¡ˆè¿˜ä¸æ˜¯å£°æ˜å¼äº‹åŠ¡ç®¡ç†ï¼Œä½†å®ƒéå¸¸æ¥è¿‘ã€‚åˆ›å»ºä¸€ä¸ªçœŸæ­£çš„å£°æ˜å¼äº‹åŠ¡ç®¡ç†éœ€è¦ä»˜å‡ºå¾ˆå¤šåŠªåŠ›ï¼Œå› æ­¤æˆ‘æ„å»ºäº†ä¸€ä¸ªå¯ä»¥å®ç°å£°æ˜å¼äº‹åŠ¡çš„å¤§å¤šæ•°åŠŸèƒ½çš„äº‹åŠ¡ç®¡ç†ï¼ŒåŒæ—¶åˆæ²¡èŠ±å¾ˆå¤šç²¾åŠ›ã€‚</p>

<p>æ–¹æ¡ˆ:
æœ€ç»ˆè§£å†³æ–¹æ¡ˆæ¶‰åŠæœ¬ç¨‹åºçš„æ‰€æœ‰å±‚çº§ï¼Œæˆ‘å°†é€ä¸€è§£é‡Šå®ƒä»¬ã€‚</p>

<p>æ•°æ®åº“é“¾æ¥å°è£…</p>

<p>åœ¨Goçš„â€œsqlâ€libä¸­ï¼Œæœ‰ä¸¤ä¸ªæ•°æ®åº“é“¾æ¥sql.DBå’Œsql.Tx. ä¸éœ€è¦äº‹åŠ¡æ—¶ï¼Œä½¿ç”¨sql.DBè®¿é—®æ•°æ®åº“; å½“éœ€è¦äº‹åŠ¡æ—¶ï¼Œä½ ä½¿ç”¨sql.Tx. ä¸ºäº†å…±äº«ä»£ç ï¼ŒæŒä¹…å±‚éœ€è¦åŒæ—¶æ”¯æŒä¸¤è€…ã€‚ å› æ­¤éœ€è¦å¯¹æ•°æ®åº“é“¾æ¥è¿›è¡Œå°è£…ï¼Œç„¶åæŠŠå®ƒä½œä¸ºæ•°æ®åº“è®¿é—®æ–¹æ³•çš„æ¥æ”¶å™¨ã€‚ æˆ‘ä»è¿™é‡ŒÂ¹å¾—åˆ°äº†ç²—ç•¥çš„æƒ³æ³•ã€‚</p>

<p>// SqlGdbc (SQL Go database connection) is a wrapper for SQL database handler ( can be <em>sql.DB or *sql.Tx)
// It should be able to work with all SQL data that follows SQL standard.
type SqlGdbc interface {
    Exec(query string, args â€¦interface{}) (sql.Result, error)
    Prepare(query string) (</em>sql.Stmt, error)
    Query(query string, args â€¦interface{}) (*sql.Rows, error)
    QueryRow(query string, args â€¦interface{}) *sql.Row
    // If need transaction support, add this interface
    Transactioner
}</p>

<p>// SqlDBTx is the concrete implementation of sqlGdbc by using *sql.DB
type SqlDBTx struct {
    DB *sql.DB
}</p>

<p>// SqlConnTx is the concrete implementation of sqlGdbc by using *sql.Tx
type SqlConnTx struct {
    DB *sql.Tx
}
æ•°æ®åº“å®ç°ç±»å‹SqlDBTxå’ŒsqlConnTxéƒ½éœ€è¦å®ç°SqlGdbcæ¥å£ï¼ˆåŒ…æ‹¬â€œTransactionerâ€ï¼‰æ¥å£æ‰è¡Œã€‚ éœ€è¦ä¸ºæ¯ä¸ªæ•°æ®åº“ï¼ˆä¾‹å¦‚MySQLï¼Œ CouchDBï¼‰å®ç°â€œTransactionerâ€æ¥å£ä»¥æ”¯æŒäº‹åŠ¡ã€‚</p>

<p>// Transactioner is the transaction interface for database handler
// It should only be applicable to SQL database
type Transactioner interface {
    // Rollback a transaction
    Rollback() error
    // Commit a transaction
    Commit() error
    // TxEnd commits a transaction if no errors, otherwise rollback
    // txFunc is the operations wrapped in a transaction
    TxEnd(txFunc func() error) error
    // TxBegin gets *sql.DB from receiver and return a SqlGdbc, which has a *sql.Tx
    TxBegin() (SqlGdbc, error)
}
æ•°æ®åº“å­˜å‚¨å±‚ï¼ˆdatastore layerï¼‰çš„äº‹ç‰©ç®¡ç†ä»£ç </p>

<p>ä»¥ä¸‹æ˜¯â€œTransactionerâ€æ¥å£çš„å®ç°ä»£ç ï¼Œå…¶ä¸­åªæœ‰TxBeginï¼ˆï¼‰æ˜¯åœ¨SqlDBTxï¼ˆsql.DBï¼‰ä¸Šå®ç°ï¼Œå› ä¸ºäº‹åŠ¡ä»sql.DBå¼€å§‹ï¼Œç„¶åæ‰€æœ‰äº‹åŠ¡çš„å…¶ä»–æ“ä½œéƒ½åœ¨SqlConnTxï¼ˆsql.Txï¼‰ä¸Šã€‚ æˆ‘ä»è¿™é‡ŒÂ²å¾—åˆ°äº†è¿™ä¸ªæƒ³æ³•ã€‚</p>

<p>// TransactionBegin starts a transaction
func (sdt *SqlDBTx) TxBegin() (gdbc.SqlGdbc, error) {
    tx, err := sdt.DB.Begin()
    sct := SqlConnTx{tx}
    return &amp;sct, err
}</p>

<p>func (sct *SqlConnTx) TxEnd(txFunc func() error) error {
    var err error
    tx := sct.DB</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defer func() {
    if p := recover(); p != nil {
        tx.Rollback()
        panic(p) // re-throw panic after Rollback
    } else if err != nil {
        tx.Rollback() // err is non-nil; don't change it
    } else {
        err = tx.Commit() // if Commit returns error update err with commit err
    }
}()
err = txFunc()
return err }
</code></pre></div></div>

<p>func (sct *SqlConnTx) Rollback() error {
    return sct.DB.Rollback()
}
ç”¨ä¾‹å±‚çš„äº‹ç‰©æ¥å£</p>

<p>åœ¨ç”¨ä¾‹å±‚ä¸­ï¼Œä½ å¯ä»¥æ‹¥æœ‰ç›¸åŒä¸šåŠ¡åŠŸèƒ½çš„ä¸€ä¸ªå‡½æ•°çš„ä¸¤ä¸ªç‰ˆæœ¬ï¼Œä¸€ä¸ªæ”¯æŒäº‹åŠ¡ï¼Œä¸€ä¸ªä¸æ”¯æŒï¼Œå¹¶ä¸”å®ƒä»¬çš„åç§°å¯ä»¥å…±äº«ç›¸åŒçš„å‰ç¼€ï¼Œè€Œäº‹åŠ¡å¯ä»¥æ·»åŠ â€œwithTxâ€ä½œä¸ºåç¼€ã€‚ ä¾‹å¦‚ï¼Œåœ¨ä»¥ä¸‹ä»£ç ä¸­ï¼Œâ€œModifyAndUnregisterâ€æ˜¯ä¸æ”¯æŒäº‹åŠ¡çš„é‚£ä¸ªï¼Œâ€œModifyAndUnregisterWithTxâ€æ˜¯æ”¯æŒäº‹åŠ¡çš„é‚£ä¸ªã€‚ â€œEnableTxerâ€æ˜¯ç”¨ä¾‹å±‚ä¸Šå”¯ä¸€çš„äº‹åŠ¡æ”¯æŒæ¥å£ï¼Œä»»ä½•æ”¯æŒäº‹åŠ¡çš„â€œç”¨ä¾‹â€éƒ½éœ€è¦å®ƒã€‚ è¿™é‡Œçš„æ‰€æœ‰ä»£ç éƒ½åœ¨æ˜¯ç”¨ä¾‹å±‚çº§ï¼ˆåŒ…æ‹¬â€œEnableTxerâ€ï¼‰ä»£ç ï¼Œä¸æ¶‰åŠæ•°æ®åº“å†…å®¹ã€‚</p>

<p>type RegistrationUseCaseInterface interface {
â€¦
    // ModifyAndUnregister change user information and then unregister the user based on the User.Id passed in.
    // It is created to illustrate transaction, no real use.
    ModifyAndUnregister(user *model.User) error
    // ModifyAndUnregisterWithTx change user information and then unregister the user based on the User.Id passed in.
    // It supports transaction
    // It is created to illustrate transaction, no real use.
    ModifyAndUnregisterWithTx(user *model.User) error
    // EnableTx enable transaction support on use case. Need to be included for each use case needs transaction
    // It replaces the underline database handler to sql.Tx for each data service that used by this use case
    EnableTxer
}
// EnableTxer is the transaction interface for use case layer
type EnableTxer interface {
    EnableTx()
}
ä»¥ä¸‹æ˜¯ä¸åŒ…å«äº‹åŠ¡çš„ä¸šåŠ¡é€»è¾‘ä»£ç çš„ç¤ºä¾‹ã€‚ â€œmodifyAndUnregisterï¼ˆrucï¼Œuserï¼‰â€æ˜¯äº‹åŠ¡å’Œéäº‹åŠ¡ç”¨ä¾‹å‡½æ•°å…±äº«çš„ä¸šåŠ¡åŠŸèƒ½ã€‚ ä½ éœ€è¦ä½¿ç”¨TxBeginï¼ˆï¼‰å’ŒTxEndï¼ˆï¼‰ï¼ˆåœ¨TxDataInterfaceä¸­ï¼‰æ¥åŒ…è£…ä¸šåŠ¡åŠŸèƒ½ä»¥æ”¯æŒäº‹åŠ¡ï¼Œè¿™äº›æ˜¯æ•°æ®æœåŠ¡å±‚æ¥å£ï¼Œå¹¶ä¸”ä¸æ•°æ®åº“è®¿é—®å±‚æ— å…³ã€‚ è¯¥ç”¨ä¾‹è¿˜å®ç°äº†â€œEnableTxï¼ˆï¼‰â€æ¥å£ï¼Œè¯¥æ¥å£å®é™…ä¸Šå°†åº•å±‚æ•°æ®åº“é“¾æ¥ä»sql.DBåˆ‡æ¢åˆ°sql.Tx.</p>

<p>// The use case of ModifyAndUnregister without transaction
func (ruc *RegistrationUseCase) ModifyAndUnregister(user *model.User) error {
    return modifyAndUnregister(ruc, user)
}</p>

<p>// The use case of ModifyAndUnregister with transaction
func (ruc *RegistrationUseCase) ModifyAndUnregisterWithTx(user *model.User) error {
    tdi, err := ruc.TxDataInterface.TxBegin()
    if err != nil {
        return errors.Wrap(err, â€œâ€)
    }
    ruc.EnableTx()
    return tdi.TxEnd(func() error {
        // wrap the business function inside the TxEnd function
        return modifyAndUnregister(ruc, user)
    })
}</p>

<p>// The business function will be wrapped inside a transaction and inside a non-transaction function
// It needs to be written in a way that every error will be returned so it can be catched by TxEnd() function,
// which will handle commit and rollback
func modifyAndUnregister(ruc *RegistrationUseCase, user *model.User) error {
    udi := ruc.UserDataInterface
    err := modifyUser(udi, user)
    if err != nil {
        return errors.Wrap(err, â€œâ€)
    }
    err = unregisterUser(udi, user.Name)
    if err != nil {
        return errors.Wrap(err, â€œâ€)
    }
    return nil
}</p>

<p>func (ruc *RegistrationUseCase) EnableTx() {
    // Only UserDataInterface need transaction support here. If there are other data services need it,
    // then they also need to enable transaction here
    ruc.UserDataInterface.EnableTx(ruc.TxDataInterface)
}
ä¸ºä»€ä¹ˆæˆ‘éœ€è¦åœ¨â€œTxDataInterfaceâ€ä¸­è°ƒç”¨å‡½æ•°â€œEnbaleTxâ€æ¥æ›¿æ¢åº•å±‚æ•°æ®åº“é“¾æ¥è€Œä¸æ˜¯ç›´æ¥åœ¨ç”¨ä¾‹ä¸­æ‰§è¡Œï¼Ÿ å› ä¸ºsql.DBå’Œsql.Txå±‚çº§è¦æ¯”ç”¨ä¾‹å±‚ä½å‡ ä¸ªçº§åˆ«ï¼Œç›´æ¥è°ƒç”¨ä¼šæç ¸ä¾èµ–å…³ç³»ã€‚ ä¿æŒåˆç†ä¾èµ–å…³ç³»çš„è¯€çªæ˜¯åœ¨æ¯ä¸€å±‚ä¸Šéƒ½æœ‰TxBeginï¼ˆï¼‰å’ŒTxEndï¼ˆï¼‰å¹¶é€å±‚è°ƒç”¨å®ƒä»¬ä»¥ç»´æŒåˆç†çš„ä¾èµ–å…³ç³»ã€‚</p>

<p>æ•°æ®æœåŠ¡å±‚çš„äº‹ç‰©æ¥å£</p>

<p>æˆ‘ä»¬è®¨è®ºäº†ç”¨ä¾‹å±‚å’Œæ•°æ®å­˜å‚¨å±‚ä¸Šçš„äº‹åŠ¡åŠŸèƒ½ï¼Œæˆ‘ä»¬è¿˜éœ€è¦æ•°æ®æœåŠ¡å±‚ä¸­çš„äº‹åŠ¡åŠŸèƒ½å°†è¿™ä¸¤è€…è¿æ¥åœ¨ä¸€èµ·ã€‚ ä»¥ä¸‹ä»£ç æ˜¯æ•°æ®æœåŠ¡å±‚çš„äº‹åŠ¡æ¥å£ï¼ˆâ€œTxDataInterfaceâ€ï¼‰ã€‚ â€œTxDataInterfaceâ€æ˜¯ä»…ä¸ºäº‹ç‰©ç®¡ç†è€Œåˆ›å»ºçš„æ•°æ®æœåŠ¡å±‚æ¥å£ã€‚ æ¯ä¸ªæ•°æ®åº“åªéœ€è¦å®ç°ä¸€æ¬¡ã€‚ è¿˜æœ‰ä¸€ä¸ªâ€œEnableTxerâ€æ¥å£ï¼ˆè¿™æ˜¯ä¸€ä¸ªæ•°æ®æœåŠ¡å±‚æ¥å£ï¼Œä¸è¦ä¸ç”¨ä¾‹å±‚ä¸­çš„â€œEnableTxerâ€æ¥å£æ··æ·†ï¼‰ï¼Œå®ç°â€œEnableTxerâ€æ¥å£å°†å¼€å¯æ•°æ®æœåŠ¡ç±»å‹å¯¹äº‹åŠ¡çš„æ”¯æŒï¼Œä¾‹å¦‚ï¼Œ å¦‚æœæƒ³è¦â€œUserDataInterfaceâ€æ”¯æŒäº‹ç‰©ï¼Œå°±éœ€è¦å®ƒå®ç°â€œEnableTxerâ€æ¥å£ã€‚</p>

<p>// TxDataInterface represents operations needed for transaction support.
// It only needs to be implemented once for each database
// For sqlGdbc, it is implemented for SqlDBTx in transaction.go
type TxDataInterface interface {
    // TxBegin starts a transaction. It gets a DB handler from the receiver and return a TxDataInterface, which has a
    // *sql.Tx inside. Any data access wrapped inside a transaction will go through the *sql.Tx
    TxBegin() (TxDataInterface, error)
    // TxEnd is called at the end of a transaction and based on whether there is an error, it commits or rollback the
    // transaction.
    // txFunc is the business function wrapped in a transaction
    TxEnd(txFunc func() error) error
    // Return the underline transaction handler, sql.Tx
    GetTx() gdbc.SqlGdbc
}</p>

<p>// This interface needs to be included in every data service interface that needs transaction support
type EnableTxer interface {
    // EnableTx enables transaction, basically it replaces the underling database handle sql.DB with sql.Tx
    EnableTx(dataInterface TxDataInterface)
}</p>

<p>// UserDataInterface represents interface for user data access through database
type UserDataInterface interface {
â€¦
    Update(user *model.User) (rowsAffected int64, err error)
    // Insert adds a user to a database. The returned resultUser has a Id, which is auto generated by database
    Insert(user *model.User) (resultUser *model.User, err error)
    // Need to add this for transaction support
    EnableTxer
}
ä»¥ä¸‹ä»£ç æ˜¯â€œTxDataInterfaceâ€çš„å®ç°ã€‚ â€œTxDataSqlâ€æ˜¯â€œTxDataInterfaceâ€çš„å…·ä½“ç±»å‹ã€‚ å®ƒè°ƒç”¨åº•å±‚æ•°æ®åº“é“¾æ¥çš„å¼€å§‹å’Œç»“æŸå‡½æ•°æ¥æ‰§è¡ŒçœŸæ­£çš„äº‹åŠ¡æ“ä½œã€‚</p>

<p>// TxDataSql is the generic implementation for transaction for SQL database
// You only need to do it once for each SQL database
type TxDataSql struct {
    DB gdbc.SqlGdbc
}</p>

<p>func (tds *TxDataSql) TxEnd(txFunc func() error) error {
    return tds.DB.TxEnd(txFunc)
}</p>

<p>func (tds *TxDataSql) TxBegin() (dataservice.TxDataInterface, error) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sqlTx, error := tds.DB.TxBegin()
tdi := TxDataSql{sqlTx}
tds.DB = tdi.DB
return &amp;tdi, error } func (tds *TxDataSql) GetTx() gdbc.SqlGdbc {
return tds.DB } äº‹ç‰©ç­–ç•¥:
</code></pre></div></div>

<p>ä½ å¯èƒ½ä¼šé—®ä¸ºä»€ä¹ˆæˆ‘åœ¨ä¸Šé¢çš„ä»£ç ä¸­éœ€è¦â€œTxDataSqlâ€ï¼Ÿ ç¡®å®å¯ä»¥åœ¨æ²¡æœ‰å®ƒçš„æƒ…å†µä¸‹å®ç°äº‹åŠ¡ï¼Œå®é™…ä¸Šæœ€å¼€çš„ç¨‹åºé‡Œå°±æ²¡æœ‰å®ƒã€‚ ä½†æ˜¯æˆ‘è¿˜æ˜¯è¦åœ¨æŸäº›æ•°æ®æœåŠ¡ä¸­å®ç°â€œTxDataInterfaceâ€æ¥å¼€å§‹å’Œç»“æŸäº‹åŠ¡ã€‚ ç”±äºè¿™æ˜¯åœ¨ç”¨ä¾‹å±‚ä¸­å®Œæˆçš„ï¼Œç”¨ä¾‹å±‚ä¸çŸ¥é“å“ªä¸ªæ•°æ®æœåŠ¡ç±»å‹å®ç°äº†æ¥å£ï¼Œå› æ­¤å¿…é¡»åœ¨æ¯ä¸ªæ•°æ®æœåŠ¡æ¥å£ä¸Šå®ç°â€œTxDataInterfaceâ€ï¼ˆä¾‹å¦‚ï¼Œâ€œUserDataInterfaceâ€å’Œâ€œCourseDataInterfaceâ€ï¼‰ä»¥ä¿è¯ â€œç”¨ä¾‹å±‚â€ä¸ä¼šé€‰æ‹©æ²¡æœ‰æ¥å£çš„â€œæ•°æ®æœåŠ¡ï¼ˆdata serviceï¼‰â€ã€‚ åœ¨åˆ›å»ºâ€œTxDataSqlâ€ä¹‹åï¼Œæˆ‘åªéœ€è¦åœ¨â€œTxDataSqlâ€ä¸­å®ç°ä¸€æ¬¡â€œTxDataInterfaceâ€ï¼Œç„¶åæ¯ä¸ªæ•°æ®æœåŠ¡ç±»å‹åªéœ€è¦å®ç°â€œEnableTxï¼ˆï¼‰â€å°±è¡Œäº†ã€‚</p>

<p>// UserDataSql is the SQL implementation of UserDataInterface
type UserDataSql struct {
    DB gdbc.SqlGdbc
}</p>

<p>func (uds *UserDataSql) EnableTx(tx dataservice.TxDataInterface) {
    uds.DB = tx.GetTx()
}</p>

<p>func (uds <em>UserDataSql) FindByName(name string) (</em>model.User, error) {
    //logger.Log.Debug(â€œcall FindByName() and name is:â€, name)
    rows, err := uds.DB.Query(QUERY_USER_BY_NAME, name)
    if err != nil {
        return nil, errors.Wrap(err, â€œâ€)
    }
    defer rows.Close()
    return retrieveUser(rows)
}
ä¸Šé¢çš„ä»£ç æ˜¯â€œUserDataServiceâ€æ¥å£çš„å®ç°ç¨‹åºã€‚ â€œEnableTxï¼ˆï¼‰â€æ–¹æ³•ä»â€œTxDataInterfaceâ€è·å¾—sql.Txå¹¶å°†â€œUserDataSqlâ€ä¸­çš„sql.DBæ›¿æ¢ä¸ºsql.Tx.</p>

<p>æ•°æ®è®¿é—®æ–¹æ³•ï¼ˆä¾‹å¦‚ï¼ŒFindByNameï¼ˆï¼‰ï¼‰åœ¨äº‹åŠ¡ä»£ç å’Œéäº‹åŠ¡ä»£ç ä¹‹é—´å…±äº«ï¼Œå¹¶ä¸”ä¸éœ€è¦çŸ¥é“â€œUserDataSql.DBâ€æ˜¯sql.DBè¿˜æ˜¯sql.Tx.</p>

<p>ä¾èµ–å…³ç³»æ¼æ´:</p>

<p>ä¸Šé¢çš„ä»£ç å®ç°ä¸­å­˜åœ¨ä¸€ä¸ªç¼ºé™·ï¼Œè¿™ä¼šç ´åæˆ‘çš„è®¾è®¡å¹¶ä½¿å…¶ä¸å®Œç¾ã€‚å®ƒæ˜¯â€œTxDataInterfaceâ€ä¸­çš„å‡½æ•°â€œGetTxï¼ˆï¼‰â€ï¼Œå®ƒæ˜¯ä¸€ä¸ªæ•°æ®æœåŠ¡å±‚æ¥å£ï¼Œå› æ­¤å®ƒä¸åº”è¯¥ä¾èµ–äºgdbc.SqlGdbcï¼ˆæ•°æ®åº“æ¥å£ï¼‰ã€‚ä½ å¯èƒ½è®¤ä¸ºæ•°æ®æœåŠ¡å±‚çš„å®ç°ä»£ç æ— è®ºå¦‚ä½•éƒ½éœ€è¦è®¿é—®æ•°æ®åº“ï¼Œå½“å‰è¿™æ˜¯æ­£ç¡®çš„ã€‚ä½†æ˜¯ï¼Œä½ å¯ä»¥åœ¨å°†æ¥æ›´æ”¹å®ç°å»è°ƒç”¨gRPCå¾®æœåŠ¡ï¼ˆè€Œä¸æ˜¯æ•°æ®åº“ï¼‰ã€‚å¦‚æœæ¥å£ä¸ä¾èµ–äºSQLæ¥å£çš„è¯ï¼Œåˆ™å¯ä»¥è‡ªç”±æ›´æ”¹å®ç°ï¼Œä½†å¦‚æœä¸æ˜¯ï¼Œåˆ™å³ä½¿ä½ çš„æ¥å£å®ç°å·²æ›´æ”¹ï¼Œè¯¥æ¥å£ä¹Ÿä¼šæ°¸ä¹…ä¿ç•™å¯¹SQLçš„ä¾èµ–ã€‚</p>

<p>ä¸ºä»€ä¹ˆå®ƒæ˜¯æœ¬ç¨‹åºä¸­æ‰“ç ´ä¾èµ–å…³ç³»çš„å”¯ä¸€åœ°æ–¹ï¼Ÿå› ä¸ºå¯¹äºå…¶ä»–æ¥å£ï¼Œå®¹å™¨è´Ÿè´£åˆ›å»ºå…·ä½“ç±»å‹ï¼Œè€Œç¨‹åºçš„å…¶ä½™éƒ¨åˆ†ä»…ä½¿ç”¨æ¥å£ã€‚ä½†æ˜¯å¯¹äºäº‹åŠ¡ï¼Œåœ¨åˆ›å»ºå…·ä½“ç±»å‹ä¹‹åï¼Œéœ€è¦å°†åº•å±‚æ•°æ®åº“å¤„ç†ç¨‹åºä»sql.DBæ›¿æ¢ä¸ºsql.Txï¼Œè¿™ç ´åäº†è®¾è®¡ã€‚</p>

<p>å®ƒæœ‰è§£å†³æ–¹æ³•å—ï¼Ÿæ˜¯çš„ï¼Œå®¹å™¨å¯ä»¥ä¸ºéœ€è¦äº‹åŠ¡çš„å‡½æ•°åˆ›å»ºsql.Txè€Œä¸æ˜¯sql.DBï¼Œè¿™æ ·æˆ‘å°±ä¸éœ€è¦åœ¨ä»¥åçš„ç”¨ä¾‹çº§åˆ«ä¸­æ›¿æ¢å®ƒã€‚ä½†æ˜¯ï¼Œé…ç½®æ–‡ä»¶ä¸­éœ€è¦ä¸€ä¸ªæ ‡å¿—æ¥æŒ‡ç¤ºå‡½æ•°æ˜¯å¦éœ€è¦äº‹åŠ¡ï¼Œ è€Œä¸”è¿™ä¸ªæ ‡å¿—éœ€è¦é…å¤‡ç»™ç”¨ä¾‹ä¸­çš„æ¯ä¸ªå‡½æ•°ã€‚è¿™æ˜¯ä¸€ä¸ªå¤ªå¤§çš„æ”¹åŠ¨ï¼Œæ‰€ä»¥æˆ‘å†³å®šç°åœ¨å…ˆè¿™æ ·ï¼Œä»¥åå†é‡æ–°å®¡è§†å®ƒã€‚</p>

<p>å¥½å¤„:
é€šè¿‡è¿™ä¸ªå®ç°ï¼Œäº‹åŠ¡ä»£ç å¯¹ä¸šåŠ¡é€»è¾‘å‡ ä¹æ˜¯é€æ˜çš„ï¼ˆé™¤äº†æˆ‘ä¸Šé¢æåˆ°çš„ç¼ºé™·ï¼‰ã€‚ä¸šåŠ¡é€»è¾‘ä¸­æ²¡æœ‰æ•°æ®å­˜å‚¨ï¼ˆdatastoreï¼‰çº§äº‹åŠ¡ä»£ç ï¼Œå¦‚Tx.Beginï¼ŒTx.Commitå’ŒTx.Rollbackï¼ˆä½†ä½ ç¡®å®éœ€è¦ä¸šåŠ¡çº§åˆ«äº‹ç‰©å‡½æ•°Tx.Beginå’ŒTx.Endï¼‰ï¼Œä¸ä»…å¦‚æ­¤ï¼Œä½ çš„æŒä¹…æ€§ä»£ç ä¸­ä¹Ÿå‡ ä¹æ²¡æœ‰æ•°æ®å­˜å‚¨çº§äº‹åŠ¡ä»£ç ã€‚ å¦‚éœ€åœ¨ç”¨ä¾‹å±‚ä¸Šå¯ç”¨äº‹åŠ¡ï¼Œä½ åªéœ€è¦åœ¨ç”¨ä¾‹ä¸Šå®ç°EnableTxï¼ˆï¼‰å¹¶å°†ä¸šåŠ¡å‡½æ•°å°è£…åœ¨â€œTxBeginï¼ˆï¼‰â€ï¼ŒEnableTxï¼ˆï¼‰å’Œâ€œTxEndï¼ˆï¼‰â€ä¸­ï¼Œå¦‚ä¸Šä¾‹æ‰€ç¤ºã€‚ åœ¨æŒä¹…å±‚ä¸Šï¼Œå¤§å¤šæ•°äº‹åŠ¡ä»£ç å·²ç»ç”±â€œtxDataService.goâ€å®ç°ï¼Œä½ åªéœ€è¦ä¸ºç‰¹å®šçš„æ•°æ®æœåŠ¡ï¼ˆä¾‹å¦‚UserDataServiceï¼‰å®ç°â€œEnableTxâ€ã€‚ äº‹åŠ¡æ”¯æŒçš„çœŸæ­£æ“ä½œæ˜¯åœ¨â€œtransaction.goâ€æ–‡ä»¶ä¸­å®ç°çš„ï¼Œå®ƒå®ç°äº†â€œTransactionerâ€æ¥å£ï¼Œå®ƒæœ‰å››ä¸ªå‡½æ•°ï¼Œâ€œRollbackâ€, â€œCommitâ€, â€œTxBeginâ€ å’Œ â€œTxEndâ€ã€‚</p>

<p>å¯¹ç”¨ä¾‹å¢åŠ äº‹ç‰©æ”¯æŒçš„æ­¥éª¤:
å‡è®¾æˆ‘ä»¬éœ€è¦åœ¨ç”¨ä¾‹â€œlistCourseâ€ä¸­ä¸ºä¸€ä¸ªå‡½æ•°æ·»åŠ äº‹åŠ¡æ”¯æŒï¼Œä»¥ä¸‹æ˜¯æ­¥éª¤</p>

<p>åœ¨åˆ—è¡¨è¯¾ç¨‹ç”¨ä¾‹ï¼ˆâ€œlistCourse.goâ€ï¼‰ä¸­å®ç°â€œEnableTxerâ€ç•Œé¢
åœ¨åŸŸæ¨¡å‹ï¼ˆâ€œcourseâ€ï¼‰æ•°æ®æœåŠ¡å±‚ï¼ˆcourseDataMysql.goï¼‰ä¸­å®ç°â€œEnableTxerâ€æ¥å£
åˆ›å»ºä¸€ä¸ªæ–°çš„äº‹åŠ¡å¯ç”¨å‡½æ•°å¹¶å°†ç°æœ‰ä¸šåŠ¡å‡½æ•°åŒ…è£…åœ¨â€œTxBeginï¼ˆï¼‰â€ï¼ŒEnableTxï¼ˆï¼‰å’Œâ€œTxEndï¼ˆï¼‰â€ä¸­
ç¼ºé™·:
é¦–å…ˆï¼Œå®ƒä»ç„¶ä¸æ˜¯å£°æ˜â€‹â€‹å¼äº‹ç‰©ç®¡ç†;ç¬¬äºŒï¼Œå®ƒæ²¡æœ‰å®Œå…¨è¾¾åˆ°éœ€æ±‚ä¸­çš„ï¼ƒ4ã€‚è¦å°†ç”¨ä¾‹å‡½æ•°ä»éäº‹åŠ¡æ›´æ”¹ä¸ºäº‹åŠ¡ï¼Œä½ å¯ä»¥åˆ›å»ºä¸€ä¸ªæ”¯æŒäº‹åŠ¡çš„æ–°å‡½æ•°ï¼Œå®ƒéœ€è¦æ›´æ”¹è°ƒç”¨å‡½æ•°; æˆ–è€…ä½ ä¿®æ”¹ç°æœ‰å‡½æ•°å¹¶å°†å…¶åŒ…è£…åˆ°äº‹åŠ¡ä¸­ï¼Œè¿™ä¹Ÿéœ€è¦ä»£ç æ›´æ”¹ã€‚ä¸ºäº†å®ç°ï¼ƒ4ï¼Œéœ€è¦æ·»åŠ è®¸å¤šä»£ç ï¼Œå› æ­¤æˆ‘å°†å…¶æ¨è¿Ÿåˆ°ä»¥åã€‚ç¬¬ä¸‰ï¼Œå®ƒä¸æ”¯æŒåµŒå¥—äº‹åŠ¡ï¼ˆNested Transactionï¼‰ï¼Œå› æ­¤ä½ éœ€è¦æ‰‹åŠ¨ç¡®ä¿ä»£ç ä¸­æ²¡æœ‰å‘ç”ŸåµŒå¥—äº‹åŠ¡ã€‚å¦‚æœä»£ç åº“ä¸æ˜¯å¤ªå¤æ‚ï¼Œè¿™å¾ˆå®¹æ˜“åšåˆ°ã€‚å¦‚æœä½ æœ‰ä¸€ä¸ªéå¸¸å¤æ‚çš„ä»£ç åº“ï¼Œæœ‰å¾ˆå¤šäº‹åŠ¡å’Œéäº‹åŠ¡å‡½æ•°æ··åœ¨ä¸€èµ·ï¼Œé‚£ä¹ˆæ‰‹å·¥åšèµ·æ¥ä¼šæ¯”è¾ƒå›°éš¾ï¼Œè¿™æ˜¯éœ€è¦åœ¨ç¨‹åºä¸­å®ç°åµŒå¥—äº‹åŠ¡æˆ–æ‰¾åˆ°å·²ç»æ”¯æŒå®ƒçš„æ–¹æ¡ˆã€‚æˆ‘æ²¡æœ‰èŠ±æ—¶é—´ç ”ç©¶æ·»åŠ åµŒå¥—äº‹åŠ¡æ‰€éœ€çš„å·¥ä½œé‡ï¼Œä½†è¿™å¯èƒ½å¹¶ä¸å®¹æ˜“ã€‚å¦‚æœä½ å¯¹å®ƒæ„Ÿå…´è¶£ï¼Œè¿™é‡ŒÂ³æ˜¯ä¸€äº›è®¨è®ºã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå¯¹äºå¤§å¤šæ•°æƒ…å†µè€Œè¨€ï¼Œå½“å‰çš„è§£å†³æ–¹æ¡ˆå¯èƒ½æ˜¯åœ¨ä»£ä»·ä¸å¤§çš„æƒ…å†µä¸‹çš„æœ€ä½³æ–¹æ¡ˆã€‚</p>

<p>åº”ç”¨èŒƒå›´:
é¦–å…ˆï¼Œå®ƒåªæ”¯æŒSQLæ•°æ®åº“çš„äº‹åŠ¡ã€‚ å¦‚æœä½ æœ‰NoSqlæ•°æ®åº“ï¼Œå®ƒå°†æ— æ³•å·¥ä½œï¼ˆå¤§å¤šæ•°NoSqlæ•°æ®åº“æ— è®ºå¦‚ä½•éƒ½ä¸æ”¯æŒäº‹åŠ¡ï¼‰ã€‚ å…¶æ¬¡ï¼Œå¦‚æœäº‹åŠ¡è·¨è¶Šäº†æ•°æ®åº“çš„è¾¹ç•Œï¼ˆä¾‹å¦‚åœ¨ä¸åŒçš„å¾®æœåŠ¡å™¨ä¹‹é—´ï¼‰ï¼Œé‚£ä¹ˆå®ƒå°†æ— æ³•å·¥ä½œã€‚ åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ éœ€è¦ä½¿ç”¨Sagaâ´ã€‚å®ƒçš„åŸç†æ˜¯ä¸ºäº‹ç‰©ä¸­çš„æ¯ä¸ªæ“ä½œå†™ä¸€ä¸ªè¡¥å¿æ“ä½œï¼Œç„¶ååœ¨å›æ»šé˜¶æ®µæŒ¨ä¸ªæ‰§è¡Œæ¯ä¸€ä¸ªè¡¥å¿æ“ä½œã€‚ åœ¨å½“å‰æ¡†æ¶ä¸­æ·»åŠ Sageè§£å†³æ–¹æ¡ˆåº”è¯¥ä¸éš¾ã€‚</p>

<p>å…¶ä»–æ•°æ®åº“ç›¸å…³é—®é¢˜:
å…³é—­æ•°æ®åº“é“¾æ¥ï¼ˆClose connectionï¼‰</p>

<p>æˆ‘ä»æ¥æ²¡æœ‰ä¸ºæ•°æ®åº“é“¾æ¥è°ƒç”¨Closeï¼ˆï¼‰å‡½æ•°ï¼Œå› ä¸ºæ²¡æœ‰å¿…è¦è¿™æ ·åšã€‚ ä½ å¯ä»¥ä¼ å…¥sql.DBæˆ–sql.Txä½œä¸ºæŒä¹…æ€§å‡½æ•°çš„æ¥æ”¶å™¨ï¼ˆreceiverï¼‰ã€‚ å¯¹äºsql.DBï¼Œæ•°æ®åº“å°†è‡ªåŠ¨åˆ›å»ºé“¾æ¥æ± å¹¶ä¸ºä½ ç®¡ç†é“¾æ¥ã€‚ é“¾æ¥å®Œæˆåï¼Œå®ƒå°†è¿”å›åˆ°é“¾æ¥æ± ï¼Œæ— éœ€å…³é—­ã€‚ å¯¹äºsql.Txï¼Œåœ¨äº‹åŠ¡ç»“æŸæ—¶ï¼Œä½ å¯ä»¥æäº¤æˆ–å›æ»šï¼Œä¹‹åé“¾æ¥å°†è¿”å›åˆ°è¿æ¥æ± ï¼Œè€Œæ— éœ€å…³é—­ã€‚ è¯·å‚é˜…æ­¤å¤„âµ å’Œ æ­¤å¤„â¶ .</p>

<p>å¯¹è±¡å…³ç³»æ˜ å°„ï¼ˆO/R mappingï¼‰</p>

<p>æˆ‘ç®€è¦åœ°æŸ¥çœ‹äº†å‡ ä¸ªâ€œO/Râ€æ˜ å°„åº“ï¼Œä½†å®ƒä»¬æ²¡æœ‰æä¾›æˆ‘æ‰€éœ€è¦çš„åŠŸèƒ½ã€‚ æˆ‘è®¤ä¸ºâ€œO/Ræ˜ å°„â€åªé€‚åˆä¸¤ç§æƒ…å†µã€‚ é¦–å…ˆï¼Œä½ çš„åº”ç”¨ç¨‹åºä¸»è¦æ˜¯CRUDï¼Œæ²¡æœ‰å¤ªå¤šçš„æŸ¥è¯¢æˆ–æœç´¢; ç¬¬äºŒï¼Œå¼€å‘äººå‘˜ä¸ç†Ÿæ‚‰SQLã€‚ å¦‚æœä¸æ˜¯è¿™ç§æƒ…å†µï¼Œåˆ™O/Ræ˜ å°„ä¸ä¼šæä¾›å¤ªå¤šå¸®åŠ©ã€‚ æˆ‘æƒ³ä»æ‰©å±•æ•°æ®åº“æ¨¡å—ä¸­è·å¾—ä¸¤ä¸ªåŠŸèƒ½ï¼Œä¸€ä¸ªæ˜¯å°†sql.rowåŠ è½½åˆ°æˆ‘çš„åŸŸæ¨¡å‹ç»“æ„ï¼ˆåŒ…æ‹¬å¤„ç†NULLå€¼ï¼‰ä¸­ï¼ˆä¾‹å¦‚â€œUserâ€ï¼‰ï¼Œå¦ä¸€ä¸ªæ˜¯è‡ªåŠ¨å…³é—­sqlç±»å‹ï¼Œå¦‚sql.statementæˆ–sql.rowsã€‚ æœ‰ä¸€äº›sqlæ‰©å±•åº“ä¼¼ä¹æä¾›äº†è‡³å°‘éƒ¨åˆ†è¿™æ ·çš„åŠŸèƒ½ã€‚ æˆ‘è¿˜æ²¡æœ‰å°è¯•ï¼Œä½†ä¼¼ä¹å€¼å¾—ä¸€è¯•ã€‚</p>

<p>å»¶è¿Ÿï¼ˆDeferï¼‰:</p>

<p>åœ¨è¿›è¡Œæ•°æ®åº“è®¿é—®æ—¶ï¼Œä½ å°†è¿›è¡Œå¤§é‡é‡å¤è°ƒç”¨ä»¥å…³é—­æ•°æ®åº“ç±»å‹ï¼ˆä¾‹å¦‚statements, rowsï¼‰ã€‚ä¾‹å¦‚ä»¥ä¸‹ä»£ç ä¸­çš„â€œdefer row.closeï¼ˆï¼‰â€ã€‚ ä½ æƒ³è¦è®°ä½è¿™ä¸€ç‚¹ï¼Œè¦åœ¨é”™è¯¯å¤„ç†å‡½æ•°ä¹‹åè°ƒç”¨â€œdefer row.closeï¼ˆï¼‰â€ï¼Œå› ä¸ºå¦‚æœä¸æ˜¯è¿™æ ·ï¼Œå½“å‡ºç°é”™è¯¯æ—¶ï¼Œâ€œrowsâ€å°†ä¸ºnilï¼Œè¿™å°†å¯¼è‡´ææ…Œå¹¶ä¸”ä¸ä¼šæ‰§è¡Œé”™è¯¯å¤„ç†ä»£ç ã€‚</p>

<p>func (uds <em>UserDataSql) Find(id int) (</em>model.User, error) {
    rows, err := uds.DB.Query(QUERY_USER_BY_ID, id)
    if err != nil {
        return nil, errors.Wrap(err, â€œâ€)
    }
    defer rows.Close()
    return retrieveUser(rows)
}
ææ…Œï¼ˆpanicï¼‰:</p>

<p>æˆ‘çœ‹åˆ°å¾ˆå¤šGoæ•°æ®åº“ä»£ç åœ¨å‡ºç°æ•°æ®åº“é”™è¯¯æ—¶æŠ›å‡ºäº†ææ…Œï¼ˆpanicï¼‰è€Œä¸æ˜¯é”™è¯¯ï¼ˆerrorï¼‰ï¼Œè¿™å¯èƒ½ä¼šå¯¼è‡´å¾®æœåŠ¡å‡ºç°é—®é¢˜ï¼Œå› ä¸ºåœ¨å¾®æœåŠ¡ç¯å¢ƒä¸­ä½ é€šå¸¸å¸Œæœ›æœåŠ¡ä¸€ç›´è¿è¡Œã€‚ å‡è®¾å½“æ›´æ–°è¯­å¥ä¸­å‡ºç°SQLé”™è¯¯æ—¶ï¼Œç”¨æˆ·å°†æ— æ³•è®¿é—®è¯¥åŠŸèƒ½ï¼Œè¿™å¾ˆç³Ÿç³•ã€‚ ä½†å¦‚æœå› ä¸ºè¿™ä¸ªï¼Œæ•´ä¸ªå¾®æœåŠ¡æˆ–ç½‘ç«™è¢«å…³é—­ï¼Œé‚£å°±æ›´ç³Ÿäº†ã€‚ å› æ­¤ï¼Œæ­£ç¡®çš„æ–¹æ³•æ˜¯å°†é”™è¯¯ä¼ æ’­åˆ°ä¸Šä¸€çº§å¹¶è®©å®ƒå†³å®šè¦åšä»€ä¹ˆã€‚ å› æ­¤æ­£ç¡®çš„åšæ³•æ˜¯ä¸åœ¨ä½ çš„ç¨‹åºä¸­æŠ›å‡ºpanicï¼Œä½†å¦‚æœç¬¬ä¸‰æ–¹åº“æŠ›å‡ºææ…Œå‘¢ï¼Ÿ è¿™æ—¶ä½ éœ€è¦æ•è·ææ…Œå¹¶ä»ä¸­æ¢å¤ä»¥ä¿æŒä½ çš„æœåŠ¡æ­£å¸¸è¿è¡Œã€‚ æˆ‘åœ¨å¦ä¸€ç¯‡æ–‡ç« â€œæ—¥å¿—ç®¡ç†â€â¸ä¸­æœ‰å…·ä½“ç¤ºä¾‹.</p>

<p>æºç¨‹åº:
å®Œæ•´çš„æºç¨‹åºé“¾æ¥ github: https://github.com/jfeng45/seâ€¦</p>

<p>ç´¢å¼•:
[1]db transaction in golang</p>

<p>[2]database/sql Txâ€”detecting Commit or Rollback</p>

<p>[3]database/sql: nested transaction or save point support</p>

<p>[4]GOTO 2015 â€¢ Applying the Saga Pattern â€¢ Caitie McCaffrey â€” YouTube</p>

<p>[5]Common Pitfalls When Using database/sql in Go</p>

<p>[6]Go database/sql tutorial</p>

<p>[7]sqlx</p>

<p>[8]Go Microservice with Clean Architecture: Application Logging</p>

<p>https://stackoverflow.com/questions/26593867/db-transaction-in-golang</p>

<p>https://www.vividcortex.com/blog/2015/09/22/common-pitfalls-go/</p>

<p>http://go-database-sql.org/connection-pool.html</p>

<p>https://www.netmeister.org/blog/ops-lessons.html</p>

<p>æœ€è¿‘ï¼Œæˆ‘ä¸€ç›´åœ¨ç ”ç©¶ Go ä¸­ä¸æ•°æ®åº“äº¤äº’çš„å„ç§è§£å†³æ–¹æ¡ˆã€‚åœ¨ Go ä¸­ä¸æ•°æ®åº“äº¤äº’æˆ‘ä½¿ç”¨çš„åº•å±‚åº“æ˜¯ sqlxã€‚ä½ åªéœ€è¦å†™å‡º SQLï¼Œå¹¶ä½¿ç”¨ db tag æ ‡è®°ç»“æ„ï¼Œä¹‹åè®© sqlx å¤„ç†å…¶ä½™å·¥ä½œã€‚ä½†æ˜¯ï¼Œæˆ‘é‡åˆ°çš„ä¸»è¦é—®é¢˜æ˜¯ç¬¦åˆè¯­æ³•ä¹ æƒ¯çš„æŸ¥è¯¢æ„å»ºã€‚è¿™è®©æˆ‘è°ƒæŸ¥äº†è¿™ä¸ªé—®é¢˜ï¼Œå¹¶åœ¨æœ¬æ–‡ä¸­è®°ä¸‹äº†ä¸€äº›æƒ³æ³•ã€‚</p>

<p>åœ¨ Go ä¸­ï¼Œç¬¬ä¸€ç±»å‡½æ•°æ˜¯è¿›è¡Œ SQL æŸ¥è¯¢æ„å»ºçš„æƒ¯ç”¨æ–¹æ³•ã€‚è¯¥ä»“åº“åŒ…å«æˆ‘ç¼–å†™çš„ä¸€äº›ç¤ºä¾‹ä»£ç ï¼šhttps://github.com/andrewpillar/queryã€‚</p>

<p>GORMã€åˆ†å±‚å¤æ‚æ€§å’Œ Active Record æ¨¡å¼
åœ¨ Go ä¸­ï¼Œå¤§å¤šæ•°æ¶‰è¶³æ•°æ®åº“å·¥ä½œçš„äººæ›´å¯èƒ½ä½¿ç”¨ Gormã€‚Gorm æ˜¯ä¸€ä¸ªåŠŸèƒ½å®Œå¤‡çš„ ORMï¼Œæ”¯æŒè¿ç§»ã€å…³ç³»ã€äº‹åŠ¡ç­‰ç­‰ã€‚å¯¹äºé‚£äº›ä½¿ç”¨è¿‡ ActiveRecord æˆ– Eloquent çš„äººæ¥è¯´ï¼ŒGorm çš„ç”¨æ³•åº”è¯¥å¾ˆç†Ÿæ‚‰ã€‚</p>

<p>æˆ‘ä»¥å‰ç®€å•åœ°ä½¿ç”¨è¿‡ Gormï¼Œå¯¹äºç®€å•çš„ã€åŸºäº CRUD çš„åº”ç”¨ç¨‹åºï¼Œè¿™å¾ˆå¥½ã€‚ç„¶è€Œï¼Œå½“æ¶‰åŠæ›´å¤šåˆ†å±‚å¤æ‚æ€§æ—¶ï¼Œæˆ‘å‘ç°å®ƒåšçš„å¹¶ä¸å¥½ã€‚å‡è®¾æˆ‘ä»¬æ­£åœ¨æ„å»ºä¸€ä¸ªåšå®¢åº”ç”¨ç¨‹åºï¼Œæˆ‘ä»¬å…è®¸ç”¨æˆ·é€šè¿‡ URL ä¸­çš„æŸ¥è¯¢å­—ç¬¦ä¸²æœç´¢å¸–å­ã€‚å¦‚æœå­˜åœ¨è¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬å¸Œæœ›ç”¨çš„çº¦æŸæ¡ä»¶ï¼šWHERE title LIKEã€‚</p>

<p>posts := make([]Post, 0)
search := r.URL.Query().Get(â€œsearchâ€)
db := Gorm.Open(â€œpostgresâ€, â€œâ€¦â€)
if search != â€œâ€ {
	db = db.Where(â€œtitle LIKE ?â€, â€œ%â€ + search + â€œ%â€)
}
db.Find(&amp;posts)
æ²¡æœ‰ä»€ä¹ˆå¯äº‰è®®çš„ï¼Œæˆ‘ä»¬åªæ˜¯æ£€æŸ¥æ˜¯å¦æœ‰å€¼å¹¶ä¿®æ”¹å¯¹ Gorm æœ¬èº«çš„è°ƒç”¨ã€‚ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬æƒ³åœ¨ç‰¹å®šæ—¥æœŸä¹‹åæœç´¢å¸–å­æ€ä¹ˆåŠï¼Ÿæˆ‘ä»¬éœ€è¦æ·»åŠ ä¸€äº›æ£€æŸ¥ï¼Œé¦–å…ˆæŸ¥çœ‹ URL ä¸­æ˜¯å¦å­˜åœ¨å…³äºæ—¥æœŸçš„æŸ¥è¯¢å­—ç¬¦ä¸² (after)ï¼Œå¦‚æœå­˜åœ¨åˆ™ä¿®æ”¹æŸ¥è¯¢æ¡ä»¶ã€‚</p>

<p>posts := make([]Post, 0)</p>

<p>search := r.URL.Query().Get(â€œsearchâ€)
after := r.URL.Query().Get(â€œafterâ€)</p>

<p>db := Gorm.Open(â€œpostgresâ€, â€œâ€¦â€)
if search != â€œâ€ {
	db = db.Where(â€œtitle LIKE ?â€, â€œ%â€ + search + â€œ%â€)
}
if after != â€œâ€ {
	db = db.Where(â€œcreated_at &gt; ?â€, after)
}
db.Find(&amp;posts)
å¦‚ä¸Šæ‰€ç¤ºï¼Œæˆ‘å‘ç° GORM çš„æœ€å¤§ç¼ºç‚¹æ˜¯å¤„ç†åˆ†å±‚çš„å¤æ‚é€»è¾‘æ—¶ååˆ†ç¹çã€‚ä½†é€šå¸¸æƒ…å†µä¸‹ï¼Œç¼–å†™ SQL æ—¶ä½ ä¼šæƒ³è¦è¿™æ ·åšã€‚è¯•æƒ³ä½ åœ¨æŸ¥è¯¢ä¸­æ ¹æ®ç”¨æˆ·è¾“å…¥æ·»åŠ ä¸€ä¸ª Where æ¡ä»¶æˆ–è€…å†³å®šå¦‚ä½•æ’åºè®°å½•ã€‚</p>

<p>æˆ‘ç›¸ä¿¡è¿™å½’ç»“ä¸ºä¸€ä»¶äº‹ï¼Œå¯¹æ­¤æˆ‘å‰æ®µæ—¶é—´åœ¨ HN åšäº†ä¸€ä¸ªè¯„è®º[2]ï¼š</p>

<p>å°±æˆ‘ä¸ªäººè€Œè¨€ï¼Œæˆ‘è®¤ä¸ºåŸºäº ORM çš„ Active Record é£æ ¼ï¼Œå¯¹ Go è€Œè¨€ç±»ä¼¼ Gormï¼Œå¹¶ä¸é€‚åˆæœ¬èº«å°±ä¸æ˜¯ OOP çš„è¯­è¨€ã€‚ä»”ç»†ç¿»é˜… Gorm çš„ç›¸å…³æ–‡æ¡£ï¼ŒGorm ä¼¼ä¹ä¸¥é‡ä¾èµ–æ–¹æ³•é“¾ï¼Œè¿™å¯¹ Go è€Œè¨€ä¼¼ä¹ä¹Ÿæ˜¯é”™è¯¯çš„ï¼šè€ƒè™‘ä¸€ä¸‹ Go è¯­è¨€ä¸­å¦‚ä½•å¤„ç† errorã€‚æˆ‘è®¤ä¸ºï¼ŒORM åº”è¯¥å°½å¯èƒ½ä¸è¯­æ³•ä¹ æƒ¯ä¿æŒä¸€è‡´ã€‚</p>

<p>æ­¤è¯„è®ºæäº¤åœ¨åšå®¢ To ORM or not to ORM[3] ä¸Šï¼Œæˆ‘å¼ºçƒˆå»ºè®®æ‚¨é˜…è¯»è¯¥æ–‡ã€‚è¯¥æ–‡ä½œè€…åœ¨ Gorm é—®é¢˜ä¸Šå¾—å‡ºäº†ä¸æˆ‘çš„ä¸€è‡´ç»“è®ºã€‚</p>

<p>åœ¨ Go ä¸­ç¬¦åˆè¯­æ³•ä¹ æƒ¯çš„æŸ¥è¯¢æ„å»º
æ ‡å‡†åº“ä¸­åŒ… database/sql éå¸¸é€‚åˆä¸æ•°æ®åº“äº¤äº’ã€‚sqlx æ˜¯åŸºäºæ­¤çš„ã€å¤„ç†è¿”å›æ•°æ®çš„ä¸€ä¸ªä¼˜ç§€æ‰©å±•ã€‚ä½†æ˜¯ï¼Œè¿™ä»ç„¶æ²¡æœ‰å®Œå…¨è§£å†³æ‰‹å¤´çš„é—®é¢˜ã€‚æˆ‘ä»¬å¦‚ä½•é«˜æ•ˆåœ°ã€ç¨‹åºåŒ–åœ°ã€ç¬¦åˆ Go è¯­æ³•ä¹ æƒ¯åœ°æ„å»ºå¤æ‚çš„æŸ¥è¯¢ ? å‡è®¾æˆ‘ä»¬ä½¿ç”¨ sqlx è¿›è¡Œä¸Šè¿°ç›¸åŒçš„æŸ¥è¯¢ï¼Œé‚£æ˜¯ä»€ä¹ˆæ ·å­å‘¢ï¼Ÿ</p>

<p>posts := make([]Post, 0)</p>

<p>search := r.URL.Query().Get(â€œsearchâ€)
after := r.URL.Query().Get(â€œafterâ€)</p>

<p>db := sqlx.Open(â€œpostgresâ€, â€œâ€¦â€)</p>

<p>query := â€œSELECT * FROM postsâ€
args := make([]interface{}, 0)</p>

<p>if search != â€œâ€ {
	query += â€œ WHERE title LIKE ?â€
	args = append(args, search)
}</p>

<p>if after != â€œâ€ {
	if search != â€œâ€ {
		query += â€œ AND â€œ
	} else {
		query += â€œ WHERE â€œ
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>query += "created_at &gt; ?"

args = append(args, after) }
</code></pre></div></div>

<p>err := db.Select(&amp;posts, sqlx.Rebind(query), argsâ€¦)
æ²¡æœ‰æ¯”æˆ‘ä»¬ç”¨ Gorm åšçš„å¥½å¤šå°‘ï¼Œäº‹å®ä¸Šæ›´åŠ ä¸‘é™‹ã€‚æˆ‘ä»¬æ£€æŸ¥äº†ä¸¤æ¬¡ search æ˜¯å¦å­˜åœ¨ï¼Œä»¥ä¾¿æˆ‘ä»¬å¯ä»¥ä¸ºæŸ¥è¯¢æä¾›æ­£ç¡®çš„ SQL è¯­æ³•ï¼Œæˆ‘ä»¬å°†å‚æ•°å­˜å‚¨åœ¨ []interface{} åˆ‡ç‰‡ä¸­ï¼Œæˆ‘ä»¬å°† SQL æ‹¼æ¥åˆ°ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚è¿™äº›åŒæ ·éƒ½æ˜¯ä¸å¯æ‰©å±•ã€ä¸æ˜“äºç»´æŠ¤çš„ã€‚</p>

<p>ç†æƒ³æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¸Œæœ›èƒ½å¤Ÿæ„å»ºæŸ¥è¯¢ï¼Œå¹¶å°†å…¶äº¤ç»™ sqlx æ¥å¤„ç†å…¶ä½™çš„äº‹æƒ…ã€‚é‚£ä¹ˆï¼ŒGo ä¸­çš„ç¬¦åˆè¯­æ³•ä¹ æƒ¯çš„æŸ¥è¯¢æ„å»ºå™¨ä¼šæ˜¯ä»€ä¹ˆæ ·å­ï¼Ÿå—¯ï¼Œåœ¨æˆ‘çœ‹æ¥ï¼Œå®ƒå°†é‡‡ç”¨ä¸¤ç§å½¢å¼ä¹‹ä¸€ï¼Œç¬¬ä¸€ç§æ˜¯åˆ©ç”¨å¯é€‰çš„ç»“æ„ä½“ï¼Œå¦ä¸€ç§åˆ©ç”¨ç¬¬ä¸€ç±»å‡½æ•°ã€‚</p>

<p>æˆ‘ä»¬æ¥çœ‹çœ‹ squirrel[4]ã€‚è¿™ä¸ªåº“æä¾›äº†æ„å»ºæŸ¥è¯¢çš„èƒ½åŠ›ï¼Œå¹¶ä»¥æˆ‘è®¤ä¸ºæ›´åŠ ç¬¦åˆ Go è¯­æ³•ä¹ æƒ¯çš„æ–¹å¼ç›´æ¥æ‰§è¡Œå®ƒä»¬ã€‚å½“ç„¶ï¼Œåœ¨æ­¤æˆ‘ä»¬åªå…³æ³¨æŸ¥è¯¢æ„å»ºæ–¹é¢ã€‚</p>

<p>ä½¿ç”¨ squirrelï¼Œæˆ‘ä»¬å¯ä»¥åƒè¿™æ ·å®ç°ä¸Šé¢çš„é€»è¾‘ã€‚</p>

<p>posts := make([]Post, 0)</p>

<p>search := r.URL.Query().Get(â€œsearchâ€)
after := r.URL.Query().Get(â€œafterâ€)</p>

<p>eqs := make([]sq.Eq, 0)</p>

<p>if search != â€œâ€ {
	eqs = append(eqs, sq.Like{â€œtitleâ€, â€œ%â€ + search + â€œ%â€})
}</p>

<p>if after != â€œâ€ {
	eqs = append(eqs, sq.Gt{â€œcreated_atâ€, after})
}</p>

<p>q := sq.Select(â€œ*â€).From(â€œpostsâ€)</p>

<p>for _, eq := range eqs {
	q = q.Where(eq)
}</p>

<p>query, args, err := q.ToSql()</p>

<p>if err != nil {
	return
}</p>

<p>err := db.Select(&amp;posts, query, argsâ€¦)
è¿™æ¯”æˆ‘ä»¬ä½¿ç”¨ Gorm æ—¶è¦å¥½ä¸€äº›ï¼Œå¹¶ä¸”æ¯”æˆ‘ä»¬ä¹‹å‰åšçš„å­—ç¬¦ä¸²è¿æ¥è¦å¥½å‡ è‹±é‡Œã€‚ç„¶è€Œï¼Œç¼–å†™ä»ç„¶ç¨æ˜¾ç¹çã€‚å¯¹ SQL æŸ¥è¯¢ä¸­çš„æŸäº›å­å¥ï¼Œsquirrel ä½¿ç”¨å¯é€‰çš„ç»“æ„ä½“è¡¨ç¤ºã€‚åœ¨ Go ä¸­å¯¹äº APIï¼Œå¯é€‰ç»“æ„ä½“æ˜¯ä¸€ç§å¸¸è§æ¨¡å¼ï¼Œæ—¨åœ¨å®ç°é«˜åº¦å¯é…ç½®ã€‚</p>

<p>Go ä¸­ç”¨äºæŸ¥è¯¢æ„å»ºçš„ API åº”æ»¡è¶³ä»¥ä¸‹ä¸¤ä¸ªéœ€æ±‚ï¼š</p>

<p>ç¬¦åˆè¯­æ³•ä¹ æƒ¯
å¯æ‰©å±•
å¦‚ä½•ç”¨ Go å®ç°è¿™ä¸€ç›®æ ‡ï¼Ÿ</p>

<p>æŸ¥è¯¢æ„å»ºï¼šç¬¬ä¸€ç±»å‡½æ•°
Dave Cheney æ ¹æ® Rob Pike å…³äºåŒä¸€ä¸»é¢˜çš„å¸–å­æ’°å†™äº†ä¸¤ç¯‡å…³äºç¬¬ä¸€ç±»å‡½æ•°çš„åšå®¢æ–‡ç« ã€‚æ„Ÿå…´è¶£å¯ä»¥æ‰¾åˆ°å¦‚ä¸‹åŸæ–‡ï¼š</p>

<p>Self-referential functions and the design of options[5]
Functional options for friendly APIs[6]
Do not fear the first class functions[7]
æˆ‘å¼ºçƒˆå»ºè®®é˜…è¯»ä»¥ä¸Šä¸‰ç¯‡æ–‡ç« ï¼Œå¹¶åœ¨ä½ ä¸‹æ¬¡å®ç°é«˜åº¦å¯é…ç½®çš„ API æ—¶ä½¿ç”¨ä»–ä»¬æ‰€å»ºè®®çš„æ¨¡å¼ã€‚</p>

<p>ä¸‹é¢æ˜¯æŸ¥è¯¢æ„å»ºçš„ç¤ºä¾‹ï¼š</p>

<p>posts := make([]*Post, 0)</p>

<p>db := sqlx.Open(â€œpostgresâ€, â€œâ€¦â€)</p>

<p>q := Select(
	Columns(â€œ*â€),
	Table(â€œpostsâ€),
)</p>

<p>err := db.Select(&amp;posts, q.Build(), q.Args()â€¦)
æˆ‘çŸ¥é“ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆç®€å•çš„ä¾‹å­ã€‚ä½†æ˜¯è®©æˆ‘ä»¬æ¥çœ‹çœ‹æˆ‘ä»¬å¦‚ä½•å®ç°è¿™æ ·çš„ APIï¼Œä»¥ä¾¿å®ƒå¯ä»¥ç”¨äºæŸ¥è¯¢æ„å»ºã€‚é¦–å…ˆï¼Œæˆ‘ä»¬åº”è¯¥å®ç°ä¸€ä¸ªæŸ¥è¯¢ç»“æ„æ¥è·Ÿè¸ªå…¶åœ¨æ„å»ºæ—¶çš„çŠ¶æ€ã€‚</p>

<p>type statement uint8</p>

<p>type Query struct {
	stmt  statement
	table []string
	cols  []string
	args  []interface{}
}</p>

<p>const (
	_select statement = iota
)
ä¸Šè¿°ç»“æ„å°†è·Ÿè¸ªæˆ‘ä»¬æ­£åœ¨æ„å»ºçš„è¯­å¥ï¼ŒåŒ…æ‹¬ SELECTã€UPDATEã€INSERTã€DELETE ç­‰ç­‰ï¼Œè¿½è¸ªæˆ‘ä»¬æ­£åœ¨æ“ä½œçš„è¡¨ï¼Œè¿½è¸ªæˆ‘ä»¬æ­£åœ¨ä½¿ç”¨çš„åˆ—ï¼Œè¿½è¸ªå°†è¢«ä¼ é€’åˆ°æœ€ç»ˆçš„æŸ¥è¯¢è¯­å¥ä¸­çš„å‚æ•°ã€‚ä¸ºäº†ç®€å•èµ·è§ï¼Œè®©æˆ‘ä»¬ä¸“æ³¨äºå®ç° SELECT è¯­å¥çš„æŸ¥è¯¢æ„å»ºå™¨ã€‚</p>

<p>æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ç§ç±»å‹ï¼Œè¯¥ç±»å‹å¯ç”¨äºä¿®æ”¹æˆ‘ä»¬æ­£åœ¨æ„å»ºçš„æŸ¥è¯¢ï¼Œè¯¥ç±»å‹ä½œä¸ºç¬¬ä¸€ç±»å‡½æ•°å°†è¢«å¤šæ¬¡ä¼ é€’ã€‚æ¯æ¬¡è°ƒç”¨æ­¤å‡½æ•°æ—¶ï¼Œå®ƒéƒ½åº”è¿”å›æ–°çš„ã€è¢«ä¿®æ”¹åçš„æŸ¥è¯¢ï¼ˆå¦‚æœé€‚ç”¨ï¼‰ã€‚</p>

<p>type Option func(q Query) Query
æˆ‘ä»¬ç°åœ¨å¯ä»¥å®ç°æ„å»ºå™¨çš„ç¬¬ä¸€éƒ¨åˆ† : Select å‡½æ•°ã€‚è¿™å°†å¼€å§‹ä¸ºæˆ‘ä»¬çš„ SELECT è¯­å¥æ„å»ºæŸ¥è¯¢ã€‚</p>

<p>func Select(opts â€¦Option) Query {
	q := Query{
		stmt: select_,
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _, opt := range opts {
	q = opt(q)
}

return q }
</code></pre></div></div>

<p>æ‚¨ç°åœ¨åº”è¯¥èƒ½å¤Ÿçœ‹åˆ°ä¸€åˆ‡å¦‚ä½•æ…¢æ…¢åœ°æ±‡èšåˆ°ä¸€èµ·ï¼Œä»¥åŠ UPDATEã€INSERTã€DELETE ç­‰è¯­å¥æ€æ ·ç®€å•çš„æ„å»ºæŸ¥è¯¢ã€‚å¦‚æœæ²¡æœ‰å®é™…å®ç°ä¸€äº› options å¹¶ä¼ é€’åˆ° Select å‡½æ•°ä¸­ï¼Œä¸Šé¢çš„ Select å‡½æ•°æ˜¯å®Œå…¨æ— ç”¨çš„ï¼Œæˆ‘ä»¬æ¥ç»§ç»­å®ç°ã€‚</p>

<p>func Columns(cols â€¦string) Option {
	returnfunc(q Query) Query {
		q.cols = cols</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	return q
} }
</code></pre></div></div>

<p>func Table(table string) Option {
	returnfunc(q Query) Query {
		q.table = table</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	return q
} } å¦‚æ‚¨æ‰€è§ï¼Œæˆ‘ä»¬ä»¥æŸç§æ–¹å¼å®ç°è¿™äº›ç¬¬ä¸€ç±»å‡½æ•°ï¼Œå®ƒä»¬è¿”å›ä»¥åå°†è¢«è°ƒç”¨çš„ã€åŸºç¡€çš„ Option å‡½æ•°ã€‚é€šå¸¸æœŸæœ› Option å‡½æ•°ä¿®æ”¹ä¼ é€’ç»™å®ƒçš„ Query å¯¹è±¡ï¼Œå¹¶è¿”å› Query çš„ä¸€ä¸ªå‰¯æœ¬ã€‚
</code></pre></div></div>

<p>ä¸ºäº†å¯¹æˆ‘ä»¬æ„å»ºå¤æ‚æŸ¥è¯¢çš„ç”¨ä¾‹æœ‰ç”¨ï¼Œæˆ‘ä»¬åº”è¯¥å®ç° WHERE å‘æŸ¥è¯¢æ·»åŠ å­å¥çš„åŠŸèƒ½ã€‚è¿™å°†è¦æ±‚å¿…é¡»è·Ÿè¸ª WHERE æŸ¥è¯¢ä¸­çš„å„ç§å­å¥ã€‚</p>

<p>type where struct {
	col string
	op  string
	val interface{}
}</p>

<p>type Query struct {
	stmt   statement
	table  []string
	cols   []string
	wheres []where
	args   []interface{}
}
æˆ‘ä»¬ä¸º WHERE å­å¥å®šä¹‰äº†ä¸€ç§è‡ªå®šä¹‰ç±»å‹ï¼Œå¹¶å‘åŸå§‹ Query ç»“æ„æ·»åŠ ä¸€ä¸ªå±æ€§ wheresã€‚è®©æˆ‘ä»¬ä¸ºæˆ‘ä»¬çš„éœ€æ±‚å®ç°ä¸¤ç§ç±»å‹çš„ Where å­å¥ï¼Œç¬¬ä¸€ç§æ˜¯ WHERE LIKEï¼Œå¦ä¸€ç§æ˜¯ WHERE &gt;ã€‚</p>

<p>func WhereLike(col string, val interface{}) Option {
	returnfunc(q Query) Query {
		w := where{
			col: col,
			op:  â€œLIKEâ€,
			val: fmt.Sprintf(â€œ$%dâ€, len(q.args) + 1),
		}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	q.wheres = append(q.wheres, w)
	q.args = append(q.args, val)

	return q
} }
</code></pre></div></div>

<p>func WhereGt(col string, val interface{}) Option {
	returnfunc(q Query) Query {
		w := where{
			col: col,
			op:  â€œ&gt;â€,
			val: fmt.Sprintf(â€œ$%dâ€, len(q.args) + 1),
		}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	q.wheres = append(q.wheres, w)
	q.args = append(q.args, val)

	return q
} } åœ¨å¤„ç† WHERE å‘æŸ¥è¯¢æ·»åŠ å­å¥æ—¶ï¼Œæˆ‘ä»¬éœ€é€‚å½“åœ°ä¸ºåº•å±‚ SQL é©±åŠ¨ç¨‹åºå¤„ç†ç»‘å®šå€¼çš„è¯­æ³•ã€‚æˆ‘ä»¬çš„ç¤ºä¾‹æ˜¯ Postgresï¼Œå°†å®é™…å€¼æœ¬èº«å­˜å‚¨åˆ° Query çš„ args åˆ‡ç‰‡ä¸­ã€‚
</code></pre></div></div>

<p>å› æ­¤ï¼Œæˆ‘ä»¬å®ç°çš„å¦‚æ­¤å°‘ï¼Œå¹¶èƒ½å¤Ÿä»¥ç¬¦åˆè¯­æ³•ä¹ æƒ¯çš„æ–¹å¼å®ç°æˆ‘ä»¬æœŸå¾…çš„åŠŸèƒ½ã€‚</p>

<p>posts := make([]Post, 0)</p>

<p>search := r.URL.Query().Get(â€œsearchâ€)
after := r.URL.Query().Get(â€œafterâ€)</p>

<p>db := sqlx.Open(â€œpostgresâ€, â€œâ€¦â€)</p>

<p>opts := []Option{
	Columns(â€œ*â€),
	Table(â€œpostsâ€),
}</p>

<p>if search != â€œâ€ {
	opts = append(opts, WhereLike(â€œtitleâ€, â€œ%â€ + search + â€œ%â€))
}</p>

<p>if after != â€œâ€ {
	opts = append(opts, WhereGt(â€œcreated_atâ€, after))
}</p>

<p>q := Select(optsâ€¦)</p>

<p>err := db.Select(&amp;posts, q.Build(), q.Args()â€¦)
ç¨å¥½ä¸€ç‚¹ï¼Œä½†ä»ç„¶ä¸æ˜¯å¾ˆå¥½ã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥æ‰©å±•åŠŸèƒ½ä»¥è·å¾—æˆ‘ä»¬æƒ³è¦çš„åŠŸèƒ½ã€‚å› æ­¤ï¼Œè®©æˆ‘ä»¬å®ç°ä¸€äº›å‡½æ•°ï¼Œè¿™äº›å‡½æ•°å°†è¿”å›æ»¡è¶³æˆ‘ä»¬ç‰¹å®šéœ€æ±‚çš„ Optionã€‚</p>

<p>func Search(col, val string) Option {
	returnfunc(q Query) Query {
		if val == â€œâ€ {
			return q
		}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	return WhereLike(col, "%" + val + "%")(q)
} }
</code></pre></div></div>

<p>func After(val string) Option {
	returnfunc(q Query) Query {
		if val == â€œâ€ {
			return q
		}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	return WhereGt("created_at", val)(q)
} } é€šè¿‡å®ç°ä¸Šè¿°ä¸¤ä¸ªå‡½æ•°ï¼Œæˆ‘ä»¬ç°åœ¨å¯ä»¥å¹²å‡€åœ°ä¸ºæˆ‘ä»¬çš„ç”¨ä¾‹æ„å»ºä¸€ä¸ªç¨å¾®å¤æ‚çš„æŸ¥è¯¢ã€‚å¦‚æœä¼ é€’ç»™å®ƒä»¬çš„å€¼è¢«è®¤ä¸ºæ˜¯æ­£ç¡®çš„ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°éƒ½åªä¼šä¿®æ”¹æŸ¥è¯¢ã€‚
</code></pre></div></div>

<p>posts := make([]Post, 0)</p>

<p>search := r.URL.Query().Get(â€œsearchâ€)
after := r.URL.Query().Get(â€œafterâ€)</p>

<p>db := sqlx.Open(â€œpostgresâ€, â€œâ€¦â€)</p>

<p>q := Select(
	Columns(â€œ*â€),
	Table(â€œpostsâ€),
	Search(â€œtitleâ€, search),
	After(after),
)</p>

<p>err := db.Select(&amp;posts, q.Build(), q.Args()â€¦)
æˆ‘å‘ç°åœ¨ Go ä¸­è¿™æ˜¯æ„å»ºå¤æ‚æŸ¥è¯¢æ—¶ä¸€ç§æ›´åŠ ç¬¦åˆè¯­æ³•ä¹ æƒ¯çš„æ–¹å¼ã€‚ç°åœ¨ï¼Œå½“ç„¶ä½ å·²ç»åœ¨å¸–å­ä¸­åšåˆ°äº†è¿™ä¸€ç‚¹ï¼Œå¹¶ä¸”å¿…é¡»æƒ³çŸ¥é“ï¼Œâ€œè¿™å¾ˆå¥½ä½†ä½ æ²¡æœ‰å®ç° Buildï¼ˆï¼‰å’Œ Argsï¼ˆï¼‰æ–¹æ³•â€ã€‚åœ¨æŸç§ç¨‹åº¦ä¸Šï¼Œè¿™æ˜¯äº‹å®ã€‚ä¸ºäº†ä¸å†å»¶é•¿è¿™ä¸ªå¸–å­ (å·²ç»è¶³å¤Ÿï¼‰ï¼Œæˆ‘æ²¡æœ‰æ‰“æ‰°ã€‚æ‰€ä»¥ï¼Œå¦‚æœæ‚¨å¯¹è¿™é‡Œä»‹ç»çš„ä¸€äº›æƒ³æ³•æ„Ÿå…´è¶£ï¼Œè¯·æŸ¥çœ‹æˆ‘æäº¤åœ¨ GitHub çš„ Code[8]ã€‚å®ƒæ²¡æœ‰ä»»ä½•ä¸¥è°¨æ€§ï¼Œå®ƒæ²¡æœ‰è¦†ç›–æŸ¥è¯¢æ„å»ºå™¨æ‰€éœ€çš„æ‰€æœ‰å†…å®¹ï¼Œå®ƒä¹Ÿç¼ºå°‘ Join å­—å¥ï¼›ä»…ä»…æ˜¯ä¸ºç¤ºä¾‹å¹¶æ”¯æŒ Postgres ç»‘å®šå€¼è¯­æ³•ã€‚</p>

<p>å¦‚æœæ‚¨å¯¹æˆ‘åœ¨æœ¬æ–‡ä¸­æ‰€è¯´çš„å†…å®¹æœ‰ä»»ä½•ä¸åŒæ„è§ï¼Œæˆ–æƒ³è¿›ä¸€æ­¥è®¨è®ºï¼Œè¯·é€šè¿‡é‚®ä»¶ me@andrewpillar.com ä¸æˆ‘è”ç³»ã€‚</p>

<p>via: https://andrewpillar.com/programming/2019/07/13/orms-and-query-building-in-go/</p>

<p>ä½œè€…ï¼šandrewpillar[9]è¯‘è€…ï¼šzhoudingding[10]æ ¡å¯¹ï¼špolaris1119[11]</p>

<p>æœ¬æ–‡ç”± GCTT[12] åŸåˆ›ç¼–è¯‘ï¼ŒGo ä¸­æ–‡ç½‘[13] è£èª‰æ¨å‡º</p>

<p>å‚è€ƒèµ„æ–™
[1]
Programming: https://andrewpillar.com/programming/</p>

<p>[2]
è¯„è®º: https://news.ycombinator.com/item?id=19851753</p>

<p>[3]
To ORM or not to ORM: https://eli.thegreenplace.net/2019/to-orm-or-not-to-orm/</p>

<p>[4]
squirrel: https://github.com/masterminds/squirrel</p>

<p>[5]
Self-referential functions and the design of options: https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html</p>

<p>[6]
Functional options for friendly APIs: https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis</p>

<p>[7]
Do not fear the first class functions: https://dave.cheney.net/2016/11/13/do-not-fear-first-class-functions</p>

<p>[8]
Code: https://github.com/andrewpillar/query</p>

<p>[9]
andrewpillar: https://github.com/andrewpillar</p>

<p>[10]
zhoudingding: https://github.com/DingdingZhou/</p>

<p>[11]
polaris1119: https://github.com/polaris1119</p>

<p>[12]
GCTT: https://github.com/studygolang/GCTT</p>

<p>[13]
Go ä¸­æ–‡ç½‘: https://studygolang.com/</p>

:ET