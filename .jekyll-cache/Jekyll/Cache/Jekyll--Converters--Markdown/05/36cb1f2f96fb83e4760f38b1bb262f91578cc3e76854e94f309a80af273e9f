I"±&<p>1ã€å»ºç«‹è¿æ¥
é¦–å…ˆæ˜¯Openï¼Œ
db, err := sql.Open(â€œmysqlâ€, â€œuser:password@/dbnameâ€)
db æ˜¯ä¸€ä¸ª*sql.DBç±»å‹çš„æŒ‡é’ˆï¼Œåœ¨åé¢çš„æ“ä½œä¸­ï¼Œéƒ½è¦ç”¨åˆ°db
openä¹‹åï¼Œå¹¶æ²¡æœ‰ä¸æ•°æ®åº“å»ºç«‹å®é™…çš„è¿æ¥ï¼Œä¸æ•°æ®åº“å»ºç«‹å®é™…çš„è¿æ¥æ˜¯é€šè¿‡Pingæ–¹æ³•å®Œæˆã€‚æ­¤å¤–ï¼Œdbåº”è¯¥åœ¨æ•´ä¸ªç¨‹åºçš„ç”Ÿå‘½å‘¨æœŸä¸­å­˜åœ¨ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œç¨‹åºä¸€å¯åŠ¨ï¼Œå°±é€šè¿‡Openè·å¾—dbï¼Œç›´åˆ°ç¨‹åºç»“æŸï¼Œå†Close dbï¼Œè€Œä¸æ˜¯ç»å¸¸Open/Closeã€‚
err = db.Ping()</p>

<p>https://studygolang.com/articles/7372
https://github.com/go-sql-driver/mysql/wiki/Examples</p>

<p>2ã€åŸºæœ¬ç”¨æ³•
DBçš„ä¸»è¦æ–¹æ³•æœ‰ï¼š
Query æ‰§è¡Œæ•°æ®åº“çš„Queryæ“ä½œï¼Œä¾‹å¦‚ä¸€ä¸ªSelectè¯­å¥ï¼Œè¿”å›*Rows</p>

<p>QueryRow æ‰§è¡Œæ•°æ®åº“è‡³å¤šè¿”å›1è¡Œçš„Queryæ“ä½œï¼Œè¿”å›*Row</p>

<p>PrePare å‡†å¤‡ä¸€ä¸ªæ•°æ®åº“queryæ“ä½œï¼Œè¿”å›ä¸€ä¸ª*Stmtï¼Œç”¨äºåç»­queryæˆ–æ‰§è¡Œã€‚è¿™ä¸ªStmtå¯ä»¥è¢«å¤šæ¬¡æ‰§è¡Œï¼Œæˆ–è€…å¹¶å‘æ‰§è¡Œ</p>

<p>Exec æ‰§è¡Œæ•°ä¸è¿”å›ä»»ä½•rowsçš„æ®åº“è¯­å¥ï¼Œä¾‹å¦‚deleteæ“ä½œ</p>

<p>Stmtçš„ä¸»è¦æ–¹æ³•ï¼š
Exec
Query
QueryRow
Close
ç”¨æ³•ä¸DBç±»ä¼¼
Rowsçš„ä¸»è¦æ–¹æ³•ï¼š
Cloumnsï¼š è¿”å›[]stringï¼Œcolumn names
Scanï¼š
Nextï¼š
Closeï¼š</p>

<p>https://studygolang.com/articles/7372</p>

<p>import (
â€œdatabase/sqlâ€
_ â€œgithub.com/go-sql-driver/mysqlâ€
)</p>

<p>https://github.com/go-sql-driver/mysql/wiki/Examples</p>

<p>driver.go
func init() {
	sql.Register(â€œmysqlâ€, &amp;MySQLDriver{})
}</p>

<p>func (d MySQLDriver) Open(dsn string) (driver.Conn, error) {
	cfg, err := ParseDSN(dsn)
 return c.Connect(context.Background())
}</p>

<p>type DialContextFunc func(ctx context.Context, addr string) (net.Conn, error)
var dials     map[string]DialContextFunc</p>

<p>func RegisterDialContext(net string, dial DialContextFunc) {
}</p>

<p>connector.go</p>

<p>type connector struct {
	cfg *Config // immutable private copy.
}</p>

<p>func (c *connector) Connect(ctx context.Context) (driver.Conn, error){
   mc := &amp;mysqlConn{
		maxAllowedPacket: maxPacketSize,
		maxWriteSize:     maxPacketSize - 1,
		closech:          make(chan struct{}),
		cfg:              c.cfg,
    }
   nd := net.Dialer{Timeout: mc.cfg.Timeout}
   mc.netConn, err = dial(dctx, mc.cfg.Addr)
   authResp, err := mc.auth(authData, plugin)</p>

<p>}</p>

<p>func (c *connector) Driver() driver.Driver {
	return &amp;MySQLDriver{}
}</p>

<p>connection.go
type mysqlConn struct {
}</p>

<p>func (mc *mysqlConn) Prepare(query string) (driver.Stmt, error) {
   err := mc.writeCommandPacketStr(comStmtPrepare, query)
   stmt := &amp;mysqlStmt{
		mc: mc,
   }
   columnCount, err := stmt.readPrepareResultPacket()
}</p>

<p>func (mc *mysqlConn) Begin() (driver.Tx, error) {
}
func (mc *mysqlConn) Close() (err error){
}</p>

<p>statement.go
type mysqlStmt struct {
	mc         *mysqlConn
	id         uint32
	paramCount int
}
func (stmt *mysqlStmt) Close() error 
func (stmt *mysqlStmt) Exec(args []driver.Value) (driver.Result, error) {
}
func (stmt *mysqlStmt) Query(args []driver.Value) (driver.Rows, error) {
}
func (stmt *mysqlStmt) NumInput() int</p>

<p>var (
	_ driver.ConnBeginTx        = &amp;mysqlConn{}
	_ driver.ConnPrepareContext = &amp;mysqlConn{}
	_ driver.ExecerContext      = &amp;mysqlConn{}
	_ driver.Pinger             = &amp;mysqlConn{}
	_ driver.QueryerContext     = &amp;mysqlConn{}
)</p>

<p>æŸ¥è¯¢
func (mc <em>mysqlConn) query(query string, args []driver.Value) (</em>textRows, error) {
   // try client-side prepare to reduce roundtrip
    prepared, err := mc.interpolateParams(query, args)
    err := mc.writeCommandPacketStr(comQuery, query)
    resLen, err = mc.readResultSetHeaderPacket()
    switch err := rows.NextResultSet();
    rows.rs.columns, err = mc.readColumns(resLen)
}</p>

<p>src/database/sql/sql.go</p>

<p>var 	drivers   = make(map[string]driver.Driver)
func Register(name string, driver driver.Driver) {
    drivers[name] = driver
}</p>

<p>src/database/driver/driver.go
type Driver interface {
    Open(name string) (Conn, error)
}</p>

<p>type Conn interface {
   Prepare(query string) (Stmt, error)
   Close() error
   Begin() (Tx, error)
}</p>

<p>type Stmt interface {
   Close() error
   NumInput() int
   Exec(args []Value) (Result, error)
   Query(args []Value) (Rows, error)
}</p>

<p>type Result interface {
  LastInsertId() (int64, error)
  RowsAffected() (int64, error)
}</p>

<p>type Rows interface {
    Columns() []string
    Close() error
    Next(dest []Value) error
}</p>

<p>åˆå§‹åŒ–ï¼š
func Open(driverName, dataSourceName string) (*DB, error) {
 //è·å–é©±åŠ¨
 driveri, ok := drivers[driverName]
connector, err := driverCtx.OpenConnector(dataSourceName)
//è¿æ¥æ•°æ®åº“
return OpenDB(dsnConnector{dsn: dataSourceName, driver: driveri}), nil
}</p>

<p>func OpenDB(c driver.Connector) *DB {
   go db.connectionOpener(ctx)
}</p>

<p>// Runs in a separate goroutine, opens new connections when requested.
func (db *DB) connectionOpener(ctx context.Context) {
	for {
		select {
		case &lt;-ctx.Done():
			return
		case &lt;-db.openerCh:
			db.openNewConnection(ctx)
		}
	}
}</p>

<p>func (db *DB) openNewConnection(ctx context.Context) {
	ci, err := db.connector.Connect(ctx)
	db.maybeOpenNewConnections()
}</p>

<p>func (db *DB) maybeOpenNewConnections() {
     db.openerCh &lt;- struct{}{}
}</p>

<p>func (dc *driverConn) finalClose() error {
dc.db.maybeOpenNewConnections()
}</p>

<p>func (db <em>DB) conn(ctx context.Context, strategy connReuseStrategy) (</em>driverConn, error) {
    db.maybeOpenNewConnections()
}</p>

<p>func (db *DB) putConn(dc *driverConn, err error, resetSession bool) {
   db.maybeOpenNewConnections()
}</p>

<p>æŸ¥è¯¢
func (db <em>DB) query(ctx context.Context, query string, args []interface{}, strategy connReuseStrategy) (</em>Rows, error) {
dc, err := db.conn(ctx, strategy)
return db.queryDC(ctx, nil, dc, dc.releaseConn, query, args)
}</p>

<p>func (db <em>DB) queryDC(ctx, txctx context.Context, dc *driverConn, releaseConn func(error), query string, args []interface{}) (</em>Rows, error) {
  nvdargs, err = driverArgsConnLocked(dc.ci, nil, args)
  rowsi, err = ctxDriverQuery(ctx, queryerCtx, queryer, query, nvdargs)
}</p>

<p>database/sql/ctxutil.go</p>

<p>func ctxDriverQuery(ctx context.Context, queryerCtx driver.QueryerContext, queryer driver.Queryer, query string, nvdargs []driver.NamedValue) (driver.Rows, error) {
   return queryerCtx.QueryContext(ctx, query, nvdargs)
   return queryer.Query(query, dargs)
}</p>

<p>æ‰§è¡Œ
func (db *DB) exec(ctx context.Context, query string, args []interface{}, strategy connReuseStrategy) (Result, error) {
dc, err := db.conn(ctx, strategy)
return db.execDC(ctx, dc, dc.releaseConn, query, args)
}</p>

<p>https://www.cnblogs.com/simpman/p/6510604.html
https://www.mysqlzh.com/api/89.html
https://studygolang.com/articles/1795
https://learnku.com/go/t/49692
SQL é¢„ç¼–è¯‘æŠ€æœ¯
https://blog.csdn.net/weixin_29586681/article/details/113327370
https://www.cnblogs.com/sflik/p/4587368.html
https://blog.csdn.net/qq_37102984/article/details/108988837
https://blog.csdn.net/weixin_33728708/article/details/90620309
https://www.zhihu.com/question/375120061</p>

<p>Buffer.go
buffer æ˜¯ä¸€ä¸ªç”¨äºç»™ æ•°æ®åº“è¿æ¥ (net.Conn) è¿›è¡Œç¼“å†²çš„ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œå…¶ç»“æ„ä¸ºï¼š</p>

<p>type buffer struct {
    buf     []byte     // ç¼“å†²æ± ä¸­çš„æ•°æ®
    nc      net.Conn   // è´Ÿè´£ç¼“å†²çš„æ•°æ®åº“è¿æ¥å¯¹è±¡
    idx     int        // å·²è¯»æ•°æ®ç´¢å¼•
    length  int        // ç¼“å†²æ± ä¸­æœªè¯»æ•°æ®çš„é•¿åº¦
    timeout time.Duration // æ•°æ®åº“è¿æ¥çš„è¶…æ—¶è®¾ç½®
}
å¯ä»¥çœ‹åˆ°ï¼Œå› ä¸º æ•°æ®åº“è¿æ¥ (net.Conn) åœ¨é€šä¿¡çš„æ—¶å€™æ˜¯ åŒæ­¥ çš„ã€‚è€Œä¸ºäº†è®©å…¶èƒ½å¤Ÿ åŒæ—¶ è¯»/å†™ ï¼Œæ‰€ä»¥å®ç°äº† buffer è¿™ä¸ªæ•°æ®ç»“æ„ï¼Œé€šè¿‡è¯¥ buffer è¿›è¡Œæ•°æ®ç¼“å†²è¿˜èƒ½å®ç° é›¶æ‹·è´ ( zero-copy-ish )</p>

<p>Collations.go
collations åŒ…å«äº† MySQL æ‰€æœ‰æ”¯æŒçš„ å­—ç¬¦é›† æ ¼å¼ï¼Œå¹¶æ”¯æŒé€šè¿‡ COLLATION_NAME è¿”å›å…¶å­—ç¬¦é›† ID</p>

<p>Dsn.go
DSN å³ æ•°æ®æºåç§° ï¼ˆData Source Nameï¼‰ ï¼Œæ˜¯ é©±åŠ¨ç¨‹åºè¿æ¥æ•°æ®åº“çš„å˜é‡ä¿¡æ¯ ï¼Œç®€è€Œè¨€ä¹‹å°±æ˜¯æ ¹æ®ä½ è¿æ¥çš„ä¸åŒæ•°æ®åº“ä½¿ç”¨å¯¹åº”çš„è¿æ¥ä¿¡æ¯ã€‚</p>

<p>é€šå¸¸ï¼Œæ•°æ®åº“çš„è¿æ¥é…ç½®å°±æ˜¯åœ¨è¿™é‡Œå®šä¹‰çš„ï¼š</p>

<p>// Config åŸºæœ¬çš„æ•°æ®åº“è¿æ¥ä¿¡æ¯
type Config struct {
    User         string            // Username
    Passwd       string            // Password (requires User)
    Net          string            // Network type
    Addr         string            // Network address (requires Net)
    DBName       string            // Database name
    Params       map[string]string // Connection parameters
    Collation    string            // Connection collation
    Loc          *time.Location    // Location for time.Time values
    TLSConfig    string            // TLS configuration name
    tls          *tls.Config       // TLS configuration
    Timeout      time.Duration     // Dial timeout
    ReadTimeout  time.Duration     // I/O read timeout
    WriteTimeout time.Duration     // I/O write timeout</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>AllowAllFiles           bool // å…è®¸æ–‡ä»¶ä½¿ç”¨ LOAD DATA LOCAL INFILE å¯¼å…¥æ•°æ®åº“
AllowCleartextPasswords bool // æ”¯æŒæ˜æ–‡å¯†ç å®¢æˆ·ç«¯
AllowOldPasswords       bool // å…è®¸ä½¿ç”¨ä¸å¯é çš„æ—§å¯†ç 
ClientFoundRows         bool // è¿”å›åŒ¹é…çš„è¡Œæ•°è€Œä¸æ˜¯å—å½±å“çš„è¡Œæ•°
ColumnsWithAlias        bool // å°†è¡¨åå‰ç½®åœ¨åˆ—å
InterpolateParams       bool // å°†å ä½ç¬¦æ’å…¥æŸ¥è¯¢çš„SQLå­—ç¬¦ä¸²
MultiStatements         bool // å…è®¸ä¸€æ¡è¯­å¥å¤šæ¬¡æŸ¥è¯¢
ParseTime               bool // æ ¼å¼åŒ–æ—¶é—´å€¼ä¸º time.Time å˜é‡
Strict                  bool // å°† warnings è¿”å› errors }
</code></pre></div></div>

<p>Packets.go
æ¥ä¸‹æ¥å°±è¦æ·±å…¥åˆ° MySQL çš„é€šä¿¡åè®®</p>

<p>https://www.jianshu.com/p/8e0bfed0bb90</p>

<!-- more -->
:ET