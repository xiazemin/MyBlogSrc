I"ï[<p>Cobraæ˜¯ä¸€ä¸ªåº“ï¼Œå…¶æä¾›ç®€å•çš„æ¥å£æ¥åˆ›å»ºå¼ºå¤§ç°ä»£çš„CLIæ¥å£ï¼Œç±»ä¼¼äºgitæˆ–è€…goå·¥å…·ã€‚åŒæ—¶ï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ªåº”ç”¨ï¼Œç”¨æ¥ç”Ÿæˆä¸ªäººåº”ç”¨æ¡†æ¶ï¼Œä»è€Œå¼€å‘ä»¥Cobraä¸ºåŸºç¡€çš„åº”ç”¨ã€‚Dockeræºç ä¸­ä½¿ç”¨äº†Cobraã€‚</p>

<p>æ¦‚å¿µ
CobraåŸºäºä¸‰ä¸ªåŸºæœ¬æ¦‚å¿µcommands,argumentså’Œflagsã€‚å…¶ä¸­commandsä»£è¡¨è¡Œä¸ºï¼Œargumentsä»£è¡¨æ•°å€¼ï¼Œflagsä»£è¡¨å¯¹è¡Œä¸ºçš„æ”¹å˜ã€‚</p>

<p>åŸºæœ¬æ¨¡å‹å¦‚ä¸‹ï¼š</p>

<p>APPNAME VERB NOUN â€“ADJECTIVEæˆ–è€…APPNAME COMMAND ARG â€“FLAG</p>

<p>ä¾‹å¦‚ï¼š</p>

<h1 id="serveræ˜¯commandsportæ˜¯flag">serveræ˜¯commandsï¼Œportæ˜¯flag</h1>
<p>hugo server â€“port=1313</p>

<h1 id="cloneæ˜¯commandsurlæ˜¯argumentsbraeæ˜¯flags">cloneæ˜¯commandsï¼ŒURLæ˜¯argumentsï¼Œbraeæ˜¯flags</h1>
<p>git clone URL â€“bare
Commands
Commandsæ˜¯åº”ç”¨çš„ä¸­å¿ƒç‚¹ï¼ŒåŒæ ·commandså¯ä»¥æœ‰å­å‘½ä»¤(children commands)ï¼Œå…¶åˆ†åˆ«åŒ…å«ä¸åŒçš„è¡Œä¸ºã€‚</p>

<p>Commandsçš„ç»“æ„ä½“å¦‚ä¸‹ï¼š</p>

<p>type Command struct {
    Use string // The one-line usage message.
    Short string // The short description shown in the â€˜helpâ€™ output.
    Long string // The long message shown in the â€˜help <this-command>' output.
    Run func(cmd *Command, args []string) // Run runs the command.
}
Flags
Flagsç”¨æ¥æ”¹å˜commandsçš„è¡Œä¸ºã€‚å…¶å®Œå…¨æ”¯æŒPOSIXå‘½ä»¤è¡Œæ¨¡å¼å’ŒGoçš„flagåŒ…ã€‚è¿™é‡Œçš„flagä½¿ç”¨çš„æ˜¯spf13/pflagåŒ…ï¼Œå…·ä½“å¯ä»¥å‚è€ƒGolangä¹‹ä½¿ç”¨Flagå’ŒPflag.
<!-- more -->
å®‰è£…ä¸å¯¼å…¥
å®‰è£…
go get -u github.com/spf13/cobra/cobra
å¯¼å…¥
import "github.com/spf13/cobra"
Cobraæ–‡ä»¶ç»“æ„
cjappçš„åŸºæœ¬ç»“æ„
  â–¾ cjapp/
    â–¾ cmd/
        add.go
        your.go
        commands.go
        here.go
      main.go
main.go
å…¶ç›®çš„å¾ˆç®€å•ï¼Œå°±æ˜¯åˆå§‹åŒ–Cobraã€‚å…¶å†…å®¹åŸºæœ¬å¦‚ä¸‹ï¼š</this-command></p>

<p>package main</p>

<p>import (
  â€œfmtâ€
  â€œosâ€</p>

<p>â€œ{pathToYourApp}/cmdâ€
)</p>

<p>func main() {
  if err := cmd.RootCmd.Execute(); err != nil {
    fmt.Println(err)
    os.Exit(1)
  }
}
ä½¿ç”¨cobraç”Ÿæˆå™¨
cobra init
å‘½ä»¤cobra init [yourApp]å°†ä¼šåˆ›å»ºåˆå§‹åŒ–åº”ç”¨ï¼ŒåŒæ—¶æä¾›æ­£ç¡®çš„æ–‡ä»¶ç»“æ„ã€‚åŒæ—¶ï¼Œå…¶éå¸¸æ™ºèƒ½ï¼Œä½ åªéœ€ç»™å®ƒä¸€ä¸ªç»å¯¹è·¯å¾„ï¼Œæˆ–è€…ä¸€ä¸ªç®€å•çš„è·¯å¾„ã€‚</p>

<p>cobra add
cobra add serve
Â«â€˜COMMENTâ€™
serve created at /home/chenjian/gofile/src/cjapp/cmd/serve.go
COMMENT</p>

<p>cobra add config
Â«â€˜COMMENTâ€™
config created at /home/chenjian/gofile/src/cjapp/cmd/config.go
COMMENT</p>

<p>cobra add create -p â€˜configCmdâ€™
Â«â€˜COMMENTâ€™
create created at /home/chenjian/gofile/src/cjapp/cmd/create.go
COMMENT</p>

<p>cobraç”Ÿæˆå™¨é…ç½®
Cobraç”Ÿæˆå™¨é€šè¿‡~/.cjapp.yaml(Linuxä¸‹)æˆ–è€…$HOME/.cjapp.yaml(windows)æ¥ç”ŸæˆLICENSEã€‚</p>

<p>ä¸€ä¸ª.cjapp.yamlæ ¼å¼ä¾‹å­å¦‚ä¸‹ï¼š</p>

<p>author: Chen Jian <a href="mailto:chenjian158978@gmail.com">chenjian158978@gmail.com</a>
license: MIT
æˆ–è€…å¯ä»¥è‡ªå®šä¹‰LICENSE:</p>

<p>license:
  header: This file is part of {{ .appName }}.
  text: |
    {{ .copyright }}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This is my license. There are many like it, but this one is mine.
My license is my best friend. It is my life. I must master it as I must
master my life. äººå·¥æ„å»ºCobraåº”ç”¨ äººå·¥æ„å»ºéœ€è¦è‡ªå·±åˆ›å»ºmain.goæ–‡ä»¶å’ŒRootCmdæ–‡ä»¶ã€‚

Short:   "call me jack",
Long: `A Fast and Flexible Static Site Generator built with
            love by spf13 and friends in Go.
            Complete documentation is available at https://o-my-chenjian.com`,
Run: func(cmd *cobra.Command, args []string) {
	fmt.Printf("OK")
}, }
</code></pre></div></div>

<p>var cfgFile, projectBase, userLicense string</p>

<p>func init() {
	cobra.OnInitialize(initConfig)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// åœ¨æ­¤å¯ä»¥å®šä¹‰è‡ªå·±çš„flagæˆ–è€…configè®¾ç½®ï¼ŒCobraæ”¯æŒæŒä¹…æ ‡ç­¾(persistent flag)ï¼Œå®ƒå¯¹äºæ•´ä¸ªåº”ç”¨ä¸ºå…¨å±€
// åœ¨StringVarPä¸­éœ€è¦å¡«å†™`shorthand`ï¼Œè¯¦ç»†è§pflagæ–‡æ¡£
RootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (defalut in $HOME/.cobra.yaml)")
RootCmd.PersistentFlags().StringVarP(&amp;projectBase, "projectbase", "b", "", "base project directory eg. github.com/spf13/")
RootCmd.PersistentFlags().StringP("author", "a", "YOUR NAME", "Author name for copyright attribution")
RootCmd.PersistentFlags().StringVarP(&amp;userLicense, "license", "l", "", "Name of license for the project (can provide `licensetext` in config)")
RootCmd.PersistentFlags().Bool("viper", true, "Use Viper for configuration")

// CobraåŒæ ·æ”¯æŒå±€éƒ¨æ ‡ç­¾(local flag)ï¼Œå¹¶åªåœ¨ç›´æ¥è°ƒç”¨å®ƒæ—¶è¿è¡Œ
RootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")

// ä½¿ç”¨viperå¯ä»¥ç»‘å®šflag
viper.BindPFlag("author", RootCmd.PersistentFlags().Lookup("author"))
viper.BindPFlag("projectbase", RootCmd.PersistentFlags().Lookup("projectbase"))
viper.BindPFlag("useViper", RootCmd.PersistentFlags().Lookup("viper"))
viper.SetDefault("author", "NAME HERE &lt;EMAIL ADDRESS&gt;")
viper.SetDefault("license", "apache") }
</code></pre></div></div>

<p>func Execute()  {
	RootCmd.Execute()
}</p>

<p>func initConfig() {
	// å‹¿å¿˜è¯»å–configæ–‡ä»¶ï¼Œæ— è®ºæ˜¯ä»cfgFileè¿˜æ˜¯ä»homeæ–‡ä»¶
	if cfgFile != â€œâ€ {
		viper.SetConfigName(cfgFile)
	} else {
		// æ‰¾åˆ°homeæ–‡ä»¶
		home, err := homedir.Dir()
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	// åœ¨homeæ–‡ä»¶å¤¹ä¸­æœç´¢ä»¥â€œ.cobraâ€ä¸ºåç§°çš„config
	viper.AddConfigPath(home)
	viper.SetConfigName(".cobra")
}
// è¯»å–ç¬¦åˆçš„ç¯å¢ƒå˜é‡
viper.AutomaticEnv()

if err := viper.ReadInConfig(); err != nil {
	fmt.Println("Can not read config:", viper.ConfigFileUsed())
} }
</code></pre></div></div>

<p>main.go
main.goçš„ç›®çš„å°±æ˜¯åˆå§‹åŒ–Cobra</p>

<p>ä»£ç ä¸‹è½½ï¼š cjappmanu_cmd_main.go</p>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œosâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"cjappmanu/cmd" )
</code></pre></div></div>

<p>func main() {
	if err := cmd.RootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}</p>

<p>é™„åŠ å‘½ä»¤
é™„åŠ å‘½ä»¤å¯ä»¥åœ¨/cmd/æ–‡ä»¶å¤¹ä¸­å†™ï¼Œä¾‹å¦‚ä¸€ä¸ªç‰ˆæœ¬ä¿¡æ¯æ–‡ä»¶ï¼Œå¯ä»¥åˆ›å»º/cmd/version.go</p>

<p>ä»£ç ä¸‹è½½ï¼š version.go</p>

<p>package cmd</p>

<p>import (
	â€œfmtâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/spf13/cobra" )
</code></pre></div></div>

<p>func init() {
	RootCmd.AddCommand(versionCmd)
}</p>

<p>var versionCmd = &amp;cobra.Command{
	Use:   â€œversionâ€,
	Short: â€œPrint the version number of ChenJianâ€,
	Long:  <code class="language-plaintext highlighter-rouge">All software has versions. This is Hugo's</code>,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println(â€œChen Jian Version: v1.0 â€“ HEADâ€)
	},
}</p>

<p>åŒæ—¶ï¼Œå¯ä»¥å°†å‘½ä»¤æ·»åŠ åˆ°çˆ¶é¡¹ä¸­ï¼Œè¿™ä¸ªä¾‹å­ä¸­RootCmdä¾¿æ˜¯çˆ¶é¡¹ã€‚åªéœ€è¦æ·»åŠ ï¼š</p>

<p>RootCmd.AddCommand(versionCmd)
å¤„ç†Flags
Persistent Flags
persistentæ„æ€æ˜¯è¯´è¿™ä¸ªflagèƒ½ä»»ä½•å‘½ä»¤ä¸‹å‡å¯ä½¿ç”¨ï¼Œé€‚åˆå…¨å±€flagï¼š</p>

<p>RootCmd.PersistentFlags().BoolVarP(&amp;Verbose, â€œverboseâ€, â€œvâ€, false, â€œverbose outputâ€)
Local Flags
CobraåŒæ ·æ”¯æŒå±€éƒ¨æ ‡ç­¾(local flag)ï¼Œå¹¶åªåœ¨ç›´æ¥è°ƒç”¨å®ƒæ—¶è¿è¡Œ</p>

<p>RootCmd.Flags().StringVarP(&amp;Source, â€œsourceâ€, â€œsâ€, â€œâ€, â€œSource directory to read fromâ€)
Bind flag with Config
ä½¿ç”¨viperå¯ä»¥ç»‘å®šflag</p>

<p>var author string</p>

<p>func init() {
  RootCmd.PersistentFlags().StringVar(&amp;author, â€œauthorâ€, â€œYOUR NAMEâ€, â€œAuthor name for copyright attributionâ€)
  viper.BindPFlag(â€œauthorâ€, RootCmd.PersistentFlags().Lookup(â€œauthorâ€))
}
Positional and Custom Arguments
Positional Arguments
Leagacy arg validationæœ‰ä»¥ä¸‹å‡ ç±»ï¼š</p>

<p>NoArgs: å¦‚æœåŒ…å«ä»»ä½•ä½ç½®å‚æ•°ï¼Œå‘½ä»¤æŠ¥é”™
ArbitraryArgs: å‘½ä»¤æ¥å—ä»»ä½•å‚æ•°
OnlyValidArgs: å¦‚æœæœ‰ä½ç½®å‚æ•°ä¸åœ¨ValidArgsä¸­ï¼Œå‘½ä»¤æŠ¥é”™
MinimumArgs(init): å¦‚æœå‚æ•°æ•°ç›®å°‘äºNä¸ªåï¼Œå‘½ä»¤è¡ŒæŠ¥é”™
MaximumArgs(init): å¦‚æœå‚æ•°æ•°ç›®å¤šä½™Nä¸ªåï¼Œå‘½ä»¤è¡ŒæŠ¥é”™
ExactArgs(init): å¦‚æœå‚æ•°æ•°ç›®ä¸æ˜¯Nä¸ªè¯ï¼Œå‘½ä»¤è¡ŒæŠ¥é”™
RangeArgs(min, max): å¦‚æœå‚æ•°æ•°ç›®ä¸åœ¨èŒƒå›´(min, max)ä¸­ï¼Œå‘½ä»¤è¡ŒæŠ¥é”™
Custom Arguments
var cmd = &amp;cobra.Command{
  Short: â€œhelloâ€,
  Args: func(cmd *cobra.Command, args []string) error {
    if len(args) &lt; 1 {
      return errors.New(â€œrequires at least one argâ€)
    }
    if myapp.IsValidColor(args[0]) {
      return nil
    }
    return fmt.Errorf(â€œinvalid color specified: %sâ€, args[0])
  },
  Run: func(cmd *cobra.Command, args []string) {
    fmt.Println(â€œHello, World!â€)
  },
}
å®ä¾‹
å°†root.goä¿®æ”¹ä¸ºä»¥ä¸‹ï¼š</p>

<p>ä»£ç ä¸‹è½½ï¼š example_root.go</p>

<p>package cmd</p>

<p>import (
	â€œfmtâ€
	â€œosâ€
	â€œstringsâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>homedir "github.com/mitchellh/go-homedir"
"github.com/spf13/cobra"
"github.com/spf13/viper" )
</code></pre></div></div>

<p>var cfgFile string
var echoTimes int</p>

<p>var RootCmd = &amp;cobra.Command{
	Use: â€œappâ€,
}</p>

<p>var cmdPrint = &amp;cobra.Command{
	Use:   â€œprint [string to print]â€,
	Short: â€œPrint anything to the screenâ€,
	Long: <code class="language-plaintext highlighter-rouge">print is for printing anything back to the screen.
For many years people have printed back to the screen.</code>,
	Args: cobra.MinimumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println(â€œPrint: â€œ + strings.Join(args, â€œ â€œ))
	},
}</p>

<p>var cmdEcho = &amp;cobra.Command{
	Use:   â€œecho [string to echo]â€,
	Short: â€œEcho anything to the screenâ€,
	Long: <code class="language-plaintext highlighter-rouge">echo is for echoing anything back.
Echo works a lot like print, except it has a child command.</code>,
	Args: cobra.MinimumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println(â€œPrint: â€œ + strings.Join(args, â€œ â€œ))
	},
}</p>

<p>var cmdTimes = &amp;cobra.Command{
	Use:   â€œtimes [# times] [string to echo]â€,
	Short: â€œEcho anything to the screen more timesâ€,
	Long: <code class="language-plaintext highlighter-rouge">echo things multiple times back to the user by providing
a count and a string.</code>,
	Args: cobra.MinimumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		for i := 0; i &lt; echoTimes; i++ {
			fmt.Println(â€œEcho: â€œ + strings.Join(args, â€œ â€œ))
		}
	},
}</p>

<p>func init() {
	cobra.OnInitialize(initConfig)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmdTimes.Flags().IntVarP(&amp;echoTimes, "times", "t", 1, "times to echo the input")

// ä¸¤ä¸ªé¡¶å±‚çš„å‘½ä»¤ï¼Œå’Œä¸€ä¸ªcmdEchoå‘½ä»¤ä¸‹çš„å­å‘½ä»¤cmdTimes
RootCmd.AddCommand(cmdPrint, cmdEcho)
cmdEcho.AddCommand(cmdTimes) }
</code></pre></div></div>

<p>func Execute() {
	RootCmd.Execute()
}</p>

<p>func initConfig() {
	// å‹¿å¿˜è¯»å–configæ–‡ä»¶ï¼Œæ— è®ºæ˜¯ä»cfgFileè¿˜æ˜¯ä»homeæ–‡ä»¶
	if cfgFile != â€œâ€ {
		viper.SetConfigName(cfgFile)
	} else {
		// æ‰¾åˆ°homeæ–‡ä»¶
		home, err := homedir.Dir()
		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	// åœ¨homeæ–‡ä»¶å¤¹ä¸­æœç´¢ä»¥â€œ.cobraâ€ä¸ºåç§°çš„config
	viper.AddConfigPath(home)
	viper.SetConfigName(".cobra")
}
// è¯»å–ç¬¦åˆçš„ç¯å¢ƒå˜é‡
viper.AutomaticEnv()

if err := viper.ReadInConfig(); err != nil {
	fmt.Println("Can not read config:", viper.ConfigFileUsed())
} }
</code></pre></div></div>

<p>æ“ä½œå¦‚ä¸‹ï¼š</p>

<p>go run main.go</p>

<p>Â«â€˜COMMENTâ€™
Usage:
  app [command]</p>

<p>Available Commands:
  echo        Echo anything to the screen
  help        Help about any command
  print       Print anything to the screen
  version     Print the version number of ChenJian</p>

<p>Flags:
  -h, â€“help   help for app</p>

<p>Use â€œapp [command] â€“helpâ€ for more information about a command.
COMMENT</p>

<p>go run main.go echo -h</p>

<p>Â«â€˜COMMENTâ€™
echo is for echoing anything back.
Echo works a lot like print, except it has a child command.</p>

<p>Usage:
  app echo [string to echo] [flags]
  app echo [command]</p>

<p>Available Commands:
  times       Echo anything to the screen more times</p>

<p>Flags:
  -h, â€“help   help for echo</p>

<p>Use â€œapp echo [command] â€“helpâ€ for more information about a command.
COMMENT</p>

<p>go run main.go echo times -h</p>

<p>Â«â€˜COMMENTâ€™
echo things multiple times back to the user by providing
a count and a string.</p>

<p>Usage:
  app echo times [# times] [string to echo] [flags]</p>

<p>Flags:
  -h, â€“help        help for times
  -t, â€“times int   times to echo the input (default 1)
COMMENT</p>

<p>go run main.go print HERE I AM
Â«â€˜COMMENTâ€™
Print: HERE I AM
COMMENT</p>

<p>go run main.go version
Â«â€˜COMMENTâ€™
Chen Jian Version: v1.0 â€“ HEAD
COMMENT</p>

<p>go run main.go echo times WOW -t 3
Â«â€˜COMMENTâ€™
Echo: WOW
Echo: WOW
Echo: WOW
COMMENT
è‡ªå®šä¹‰helpå’Œusage
help
é»˜è®¤çš„helpå‘½ä»¤å¦‚ä¸‹ï¼š</p>

<p>func (c *Command) initHelp() {
  if c.helpCommand == nil {
    c.helpCommand = &amp;Command{
      Use:   â€œhelp [command]â€,
      Short: â€œHelp about any commandâ€,
      Long: <code class="language-plaintext highlighter-rouge">Help provides help for any command in the application.
        Simply type </code> + c.Name() + ` help [path to command] for full details.`,
      Run: c.HelpFunc(),
    }
  }
  c.AddCommand(c.helpCommand)
}
å¯ä»¥é€šè¿‡ä»¥ä¸‹æ¥è‡ªå®šä¹‰help:</p>

<p>command.SetHelpCommand(cmd <em>Command)
command.SetHelpFunc(f func(</em>Command, []string))
command.SetHelpTemplate(s string)
usage
é»˜è®¤çš„helpå‘½ä»¤å¦‚ä¸‹ï¼š</p>

<p>return func(c *Command) error {
  err := tmpl(c.Out(), c.UsageTemplate(), c)
  return err
}
å¯ä»¥é€šè¿‡ä»¥ä¸‹æ¥è‡ªå®šä¹‰help:</p>

<p>command.SetUsageFunc(f func(*Command) error)</p>

<p>command.SetUsageTemplate(s string)
å…ˆæ‰§è¡Œä¸åæ‰§è¡Œ
RunåŠŸèƒ½çš„æ‰§è¡Œå…ˆåé¡ºåºå¦‚ä¸‹ï¼š</p>

<p>PersistentPreRun
PreRun
Run
PostRun
PersistentPostRun
é”™è¯¯å¤„ç†å‡½æ•°
RunEåŠŸèƒ½çš„æ‰§è¡Œå…ˆåé¡ºåºå¦‚ä¸‹ï¼š</p>

<p>PersistentPreRunE
PreRunE
RunE
PostRunE
PersistentPostRunE
å¯¹ä¸æ˜å‘½ä»¤çš„å»ºè®®
å½“é‡åˆ°ä¸æ˜å‘½ä»¤ï¼Œä¼šæœ‰æå‡ºä¸€å®šçš„å»ºï¼Œå…¶é‡‡ç”¨æœ€å°ç¼–è¾‘è·ç¦»ç®—æ³•(Levenshtein distance)ã€‚ä¾‹å¦‚ï¼š</p>

<p>hugo srever</p>

<p>Â«â€˜COMMENTâ€™
Error: unknown command â€œsreverâ€ for â€œhugoâ€</p>

<p>Did you mean this?
        server</p>

<p>Run â€˜hugo â€“helpâ€™ for usage.
COMMENT
å¦‚æœä½ æƒ³å…³é—­æ™ºèƒ½æç¤ºï¼Œå¯ä»¥ï¼š</p>

<p>command.DisableSuggestions = true</p>

<p>// æˆ–è€…</p>

<p>command.SuggestionsMinimumDistance = 1
æˆ–è€…ä½¿ç”¨SuggestForå±æ€§æ¥è‡ªå®šä¹‰ä¸€äº›å»ºè®®ï¼Œä¾‹å¦‚ï¼š</p>

<p>kubectl remove
Â«â€˜COMMENTâ€™
Error: unknown command â€œremoveâ€ for â€œkubectlâ€</p>

<p>Did you mean this?
        delete</p>

<p>Run â€˜kubectl helpâ€™ for usage.
COMMENT</p>

<p>main è°ƒç”¨ cmd.Execute()ï¼Œé‚£æˆ‘ä»¬æ‰¾åˆ°è¿™ä¸ªåœ°æ–¹ï¼Œcmd/root.go æ–‡ä»¶ï¼š
var RootCmd = &amp;cobra.Command{
    Use:   â€œcobra_exp1â€,
    Short: â€œA brief description of your applicationâ€,
    Long: 
}</p>

<p>func Execute() {
    if err := RootCmd.Execute(); err != nil {
        fmt.Println(err)
        os.Exit(-1)
    }
}</p>

<p>æˆ‘ä»¬çœ‹åˆ° Execute() å‡½æ•°ä¸­è°ƒç”¨ RootCmd.Execute()ï¼ŒRootCmd æ˜¯å¼€å§‹è®²ç»„æˆ Command ç»“æ„çš„ä¸€ä¸ªå®ä¾‹ã€‚</p>

<p>åœ¨ä½ é¡¹ç›®çš„ç›®å½•ä¸‹ï¼Œè¿è¡Œä¸‹é¢è¿™äº›å‘½ä»¤ï¼š
cobra add serve
cobra add config
cobra add create -p â€˜configCmdâ€™
è¿™æ ·ä»¥åï¼Œä½ å°±å¯ä»¥è¿è¡Œä¸Šé¢é‚£äº› app serve ä¹‹ç±»çš„å‘½ä»¤äº†ã€‚é¡¹ç›®ç›®å½•å¦‚ä¸‹ï¼š
â–¾ app/
  â–¾ cmd/
      serve.go
      config.go
      create.go
    main.go</p>

<p>ç°åœ¨æˆ‘ä»¬æœ‰äº†ä¸‰ä¸ªå­å‘½ä»¤ï¼Œå¹¶ä¸”éƒ½å¯ä»¥ä½¿ç”¨ï¼Œç„¶ååªè¦æ·»åŠ å‘½ä»¤é€»è¾‘å°±èƒ½çœŸæ­£ç”¨äº†ã€‚</p>

<p>Flag
cobra æœ‰ä¸¤ç§ flagï¼Œä¸€ä¸ªæ˜¯å…¨å±€å˜é‡ï¼Œä¸€ä¸ªæ˜¯å±€éƒ¨å˜é‡ã€‚å…¨å±€ä»€ä¹ˆæ„æ€å‘¢ï¼Œå°±æ˜¯æ‰€ä»¥å­å‘½ä»¤éƒ½å¯ä»¥ç”¨ã€‚å±€éƒ¨çš„åªæœ‰è‡ªå·±èƒ½ç”¨ã€‚å…ˆçœ‹å…¨å±€çš„</p>

<p>RootCmd.PersistentFlags().StringVar(&amp;cfgFile, â€œconfigâ€, â€œâ€, â€œconfig file (default is $HOME/.cobra_exp1.yaml)â€)
åœ¨çœ‹å±€éƒ¨çš„ï¼š</p>

<p>RootCmd.Flags().BoolP(â€œtoggleâ€, â€œtâ€, false, â€œHelp message for toggleâ€)
åŒºåˆ«å°±åœ¨ RootCmd åé¢çš„æ˜¯ Flags è¿˜æ˜¯ PersistentFlagsã€‚</p>

<p>ä½¿ç”¨æ ‡å¿—
æ ‡å¿—æä¾›ä¿®é¥°ç¬¦æ§åˆ¶åŠ¨ä½œå‘½ä»¤å¦‚ä½•æ“ä½œ</p>

<p>ç»™å‘½ä»¤åˆ†é…ä¸€ä¸ªæ ‡å¿—
å½“æ ‡å¿—å®šä¹‰å¥½äº†ï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ä¸ªå˜é‡æ¥å…³è”æ ‡å¿—</p>

<p>var Verbose bool
var Source string
æŒä¹…æ ‡å¿—
â€˜æŒä¹…â€™è¡¨ç¤ºæ¯ä¸ªåœ¨é‚£ä¸ªå‘½ä»¤ä¸‹çš„å‘½ä»¤éƒ½å°†èƒ½åˆ†é…åˆ°è¿™ä¸ªæ ‡å¿—ã€‚å¯¹äºå…¨å±€æ ‡å¿—ï¼Œâ€™æŒä¹…â€™çš„æ ‡å¿—ç»‘å®šåœ¨rootä¸Šã€‚</p>

<p>å±€éƒ¨æ ‡å¿—
Cobraé»˜è®¤åªåœ¨ç›®æ ‡å‘½ä»¤ä¸Šè§£ææ ‡å¿—ï¼Œçˆ¶å‘½ä»¤å¿½ç•¥ä»»ä½•å±€éƒ¨æ ‡å¿—ã€‚é€šè¿‡æ‰“å¼€Command.TraverseChildren Cobraå°†ä¼šåœ¨æ‰§è¡Œä»»æ„ç›®æ ‡å‘½ä»¤å‰è§£ææ ‡å¿—</p>

<p>command := cobra.Command{
  Use: â€œprint [OPTIONS] [COMMANDS]â€,
  TraverseChildren: true,
}
ç»‘å®šæ ‡å¿—ä¸é…ç½®
ä½ åŒæ ·å¯ä»¥é€šè¿‡viperç»‘å®šæ ‡å¿—ï¼š</p>

<p>var author string</p>

<p>func init() {
  rootCmd.PersistentFlags().StringVar(&amp;author, â€œauthorâ€, â€œYOUR NAMEâ€, â€œAuthor name for copyright attributionâ€)
  viper.BindPFlag(â€œauthorâ€, rootCmd.PersistentFlags().Lookup(â€œauthorâ€))
}
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæ°¸ä¹…çš„æ ‡è®° author è¢«viperç»‘å®š, æ³¨æ„, å½“ç”¨æˆ·æ²¡æœ‰ç»™â€“authoræä¾›å€¼ï¼Œ authorä¸ä¼šè¢«èµ‹å€¼ã€‚</p>

<p>å¿…é¡»çš„æ ‡è®°
æ ‡è®°é»˜è®¤æ˜¯å¯é€‰çš„ï¼Œå¦‚æœä½ å¸Œæœ›å½“ä¸€ä¸ªæ ‡è®°æ²¡æœ‰è®¾ç½®æ—¶ï¼Œå‘½ä»¤è¡ŒæŠ¥é”™ï¼Œä½ å¯ä»¥æ ‡è®°å®ƒä¸ºå¿…é¡»çš„</p>

<p>rootCmd.Flags().StringVarP(&amp;Region, â€œregionâ€, â€œrâ€, â€œâ€, â€œAWS region (required)â€)
rootCmd.MarkFlagRequired(â€œregionâ€)
ä½ç½®å’Œè‡ªå®šä¹‰å‚æ•°
éªŒè¯ä½ç½®å‚æ•°å¯ä»¥é€šè¿‡ Commandçš„Argså­—æ®µã€‚</p>

<p>å†…ç½®ä¸‹åˆ—éªŒè¯æ–¹æ³•</p>

<p>NoArgs - å¦‚æœæœ‰ä»»ä½•å‚æ•°ï¼Œå‘½ä»¤è¡Œå°†ä¼šæŠ¥é”™ã€‚
ArbitraryArgs - å‘½ä»¤è¡Œå°†ä¼šæ¥æ”¶ä»»ä½•å‚æ•°.
OnlyValidArgs - å¦‚æœæœ‰å¦‚ä½•å‚æ•°ä¸å±äºCommandçš„ValidArgså­—æ®µï¼Œå‘½ä»¤è¡Œå°†ä¼šæŠ¥é”™ã€‚
MinimumNArgs(int) - å¦‚æœå‚æ•°ä¸ªæ•°å°‘äºNä¸ªï¼Œå‘½ä»¤è¡Œå°†ä¼šæŠ¥é”™ã€‚
MaximumNArgs(int) - å¦‚æœå‚æ•°ä¸ªæ•°å¤šä½™Nä¸ªï¼Œå‘½ä»¤è¡Œå°†ä¼šæŠ¥é”™ã€‚
ExactArgs(int) - å¦‚æœå‚æ•°ä¸ªæ•°ä¸èƒ½ç­‰äºNä¸ªï¼Œå‘½ä»¤è¡Œå°†ä¼šæŠ¥é”™ã€‚
RangeArgs(min, max) - å¦‚æœå‚æ•°ä¸ªæ•°ä¸åœ¨minå’Œmaxä¹‹é—´, å‘½ä»¤è¡Œå°†ä¼šæŠ¥é”™.
ä¸€ä¸ªè®¾ç½®è‡ªå®šä¹‰éªŒè¯çš„ä¾‹å­</p>

<p>var cmd = &amp;cobra.Command{
  Short: â€œhelloâ€,
  Args: func(cmd *cobra.Command, args []string) error {
    if len(args) &lt; 1 {
      return errors.New(â€œrequires at least one argâ€)
    }
    if myapp.IsValidColor(args[0]) {
      return nil
    }
    return fmt.Errorf(â€œinvalid color specified: %sâ€, args[0])
  },
  Run: func(cmd *cobra.Command, args []string) {
    fmt.Println(â€œHello, World!â€)
  },
}</p>

<p>è¿è¡Œå‰å’Œè¿è¡Œåé’©å­
åœ¨å‘½ä»¤è¿è¡Œå‰æˆ–è¿è¡Œåï¼Œå†è¿è¡Œæ–¹æ³•éå¸¸å®¹æ˜“ã€‚PersistentPreRunå’ŒPreRunæ–¹æ³•å°†ä¼šåœ¨Runä¹‹å‰æ‰§è¡Œã€‚PersistentPostRunå’ŒPostRunæ–¹æ³•å°†ä¼šåœ¨Runä¹‹åæ‰§è¡Œã€‚Persistent*Runæ–¹æ³•ä¼šè¢«å­å‘½ä»¤ç»§æ‰¿ï¼Œå¦‚æœå®ƒä»¬è‡ªå·±æ²¡æœ‰å®šä¹‰çš„è¯ã€‚è¿™äº›æ–¹æ³•å°†æŒ‰ç…§ä¸‹é¢çš„å±æ€§æ‰§è¡Œï¼š</p>

<p>PersistentPreRun
PreRun
Run
PostRun
PersistentPostRun</p>

<p>ç”Ÿæˆå‘½ä»¤çš„æ–‡æ¡£
Cobra å¯ä»¥åŸºäºå­å‘½ä»¤ï¼Œæ ‡è®°ï¼Œç­‰ç”Ÿæˆæ–‡æ¡£ã€‚ä»¥ä»¥ä¸‹æ ¼å¼ï¼š</p>

<p>Markdown
ReStructured Text
Man Page
ç”Ÿæˆbash-completion
Cobra å¯ä»¥ç”Ÿæˆä¸€ä¸ªbash-completionæ–‡ä»¶ã€‚å¦‚æœä½ ç»™å‘½ä»¤æ·»åŠ æ›´å¤šä¿¡æ¯ï¼Œè¿™äº›completionså¯ä»¥éå¸¸å¼ºå¤§å’Œçµæ´»ã€‚</p>

<p>https://github.com/spf13/cobra/blob/master/bash_completions.md</p>

<p>You can also configure the bash aliases for the commands and they will also support completions.</p>

<p>alias aliasname=origcommand
complete -o default -F __start_origcommand aliasname</p>

<h1 id="and-now-when-you-run-aliasname-completion-will-make">and now when you run <code class="language-plaintext highlighter-rouge">aliasname</code> completion will make</h1>
<h1 id="suggestions-as-it-did-for-origcommand">suggestions as it did for <code class="language-plaintext highlighter-rouge">origcommand</code>.</h1>

<p>$) aliasname <tab><tab>
completion     firstcommand   secondcommand</tab></tab></p>

<p>cobraç¨‹åºåªèƒ½åœ¨GOPATHä¹‹ä¸‹ä½¿ç”¨ï¼Œæ‰€ä»¥é¦–å…ˆä½ éœ€è¦è¿›å…¥åˆ°GOPATHçš„srcç›®å½•ä¹‹ä¸‹ï¼Œåœ¨è¯¥ç›®å½•ä¸‹ï¼Œè¾“å…¥:(å¦åˆ™è¦è¾“å…¥åŒ…å)</p>

<p>$GOPATH/src/$ cobra init demo
åœ¨ä½ çš„å½“å‰ç›®å½•ä¸‹ï¼Œåº”è¯¥å·²ç»ç”Ÿæˆäº†ä¸€ä¸ªdemoæ–‡ä»¶å¤¹:</p>

<p>demo
â”œâ”€â”€ cmd
â”‚   â””â”€â”€ root.go
â”œâ”€â”€ LICENSE
â””â”€â”€ main.go</p>

<p>$ cobra add test
1
æ‰§è¡Œå®Œæˆåï¼Œç°åœ¨æˆ‘ä»¬çš„demoç»“æ„åº”è¯¥æ˜¯:</p>

<p>.
â”œâ”€â”€ cmd
â”‚   â”œâ”€â”€ root.go
â”‚   â””â”€â”€ test.go
â”œâ”€â”€ LICENSE
â””â”€â”€ main.go
å¯ä»¥çœ‹åˆ°ï¼Œåœ¨cmdç›®å½•ä¸‹ï¼Œå·²ç»ç”Ÿæˆäº†ä¸€ä¸ªä¸æˆ‘ä»¬å‘½ä»¤åŒåçš„goæ–‡ä»¶</p>

<p>åœ¨initä¸­æœ‰ä¸€å¥ RootCmd.AddCommand(testCmd) è¿™ä¸ªRootCmdæ˜¯ä»€ä¹ˆï¼Ÿæ‰“å¼€root.goï¼Œä½ ä¼šå‘ç°RootCmdå…¶å®å°±æ˜¯æˆ‘ä»¬çš„æ ¹å‘½ä»¤ã€‚æˆ‘ç›¸ä¿¡æœºæ™ºçš„åŒå­¦å·²ç»çŒœå‡ºæ¥æˆ‘ä»¬æ·»åŠ å­å‘½ä»¤çš„å­å‘½ä»¤çš„æ–¹æ³•äº†ã€‚</p>

<p>æ·»åŠ å‚æ•°
æˆ‘ç›¸ä¿¡ä»initå‡½æ•°ä¸­çš„æ³¨é‡Šä¸­ï¼Œä½ å·²ç»å¾—åˆ°äº†è¶³å¤Ÿå¤šçš„ä¿¡æ¯æ¥è‡ªå·±æ“ä½œæ·»åŠ flagï¼Œä½†æˆ‘è¿˜æ˜¯æƒ³è¦å•°å—¦ä¸¤å¥ã€‚é¦–å…ˆæ˜¯persistentå‚æ•°ï¼Œå½“ä½ çš„å‚æ•°ä½œä¸ºpersistent flagå­˜åœ¨æ—¶ï¼Œå¦‚æ³¨é‡Šæ‰€è¨€ï¼Œåœ¨å…¶æ‰€æœ‰çš„å­å‘½ä»¤ä¹‹ä¸‹è¯¥å‚æ•°éƒ½æ˜¯å¯è§çš„ã€‚è€Œlocal flagåˆ™åªèƒ½åœ¨è¯¥å‘½ä»¤è°ƒç”¨æ—¶æ‰§è¡Œã€‚å¯ä»¥åšä¸€ä¸ªç®€å•çš„æµ‹è¯•ï¼Œåœ¨test.goçš„initå‡½æ•°ä¸­ï¼Œæ·»åŠ å¦‚ä¸‹å†…å®¹:</p>

<p>testCmd.PersistentFlags().String(â€œfooâ€, â€œâ€, â€œA help for fooâ€)
testCmd.Flags().String(â€œfoolocalâ€, â€œâ€, â€œA help for fooâ€)
ç°åœ¨åœ¨å‘½ä»¤è¡Œ go run main.go test -h å¾—åˆ°å¦‚ä¸‹ç»“æœ:</p>

<p>è·å–å‚æ•°å€¼
åœ¨çŸ¥é“äº†å¦‚ä½•è®¾ç½®å‚æ•°åï¼Œæˆ‘ä»¬çš„ä¸‹ä¸€æ­¥å½“ç„¶ä¾¿æ˜¯éœ€è¦åœ¨è¿è¡Œæ—¶è·å–è¯¥å‚æ•°çš„å€¼</p>

<p>æˆ‘ä»¬åº”è¯¥åœ¨Runè¿™é‡Œæ¥è·å–å‚æ•°å¹¶æ‰§è¡Œæˆ‘ä»¬çš„å‘½ä»¤åŠŸèƒ½ã€‚è·å–å‚æ•°å…¶å®ä¹Ÿå¹¶ä¸å¤æ‚ã€‚ä»¥testCmd.Flags().StringP(â€œaaaâ€, â€œaâ€, â€œâ€, â€œtestâ€)æ­¤ä¸ºä¾‹ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨Runå‡½æ•°é‡Œæ·»åŠ ï¼š</p>

<p>str := testCmd.Flags().GetString(â€œaaaâ€)
è¿™æ ·ä¾¿å¯ä»¥è·å–åˆ°è¯¥å‚æ•°çš„å€¼äº†ï¼Œå…¶ä½™ç±»å‹å‚æ•°è·å–ä¹Ÿæ˜¯åŒç†ã€‚</p>

<p>ç”Ÿæˆæ–‡æŒ¡
https://github.com/spf13/cobra/blob/master/doc/md_docs.md</p>

<p>ç”Ÿæˆæ–‡æ¡£
åœ¨root.goä¸­å¢åŠ 
func Get()*cobra.Command{
  return rootCmd
}
main.go ä¸­import
â€œgithub.com/spf13/cobra/docâ€</p>

<p>åœ¨mainä¸­å¢åŠ 
  err := doc.GenMarkdownTree(cmd.Get(), â€œ./â€)
  if err != nil {
    log.Fatal(err)
  }</p>

<p>$ go build main.go
../../../spf13/cobra/doc/man_docs.go:27:2: cannot find package â€œgithub.com/cpuguy83/go-md2man/md2manâ€ in any of:
        /usr/local/go/src/github.com/cpuguy83/go-md2man/md2man (from $GOROOT)
        /Users/didi/goLang/src/github.com/cpuguy83/go-md2man/md2man (from $GOPATH)
        /Users/didi/PhpstormProjects/go/src/github.com/cpuguy83/go-md2man/md2man</p>

<p>$ go get github.com/cpuguy83/go-md2man/md2man</p>

<p>$ ./main</p>

<p>ç”Ÿæˆ3ä¸ªæ–‡ä»¶
â”œâ”€â”€ gen.md
â”œâ”€â”€ gen_serve.md
â”œâ”€â”€ gen_serve_create.md
â”œâ”€â”€ gen_serve_create_grandchild.md</p>

:ET