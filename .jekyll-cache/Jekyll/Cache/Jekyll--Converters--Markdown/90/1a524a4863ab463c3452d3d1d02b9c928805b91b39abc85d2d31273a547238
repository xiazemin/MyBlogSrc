I"<p>MySQL 5.5/5.6/5.7三个大版本
在MySQL上述三个大版本中，默认时间戳(Timestamp)类型的取值范围为’1970-01-01 00:00:01’ UTC 至’2038-01-19 03:14:07’ UTC，数据精确到秒级别，该取值范围包含约22亿个数值，因此在MySQL内部使用4个字节INT类型来存放时间戳数据：
1、在存储时间戳数据时，先将本地时区时间转换为UTC时区时间，再将UTC时区时间转换为INT格式的毫秒值(使用UNIX_TIMESTAMP函数)，然后存放到数据库中。
2、在读取时间戳数据时，先将INT格式的毫秒值转换为UTC时区时间(使用FROM_UNIXTIME函数)，然后再转换为本地时区时间，最后返回给客户端。
<!-- more --></p>

<p>在MySQL 5.6.4及之后版本，可以将时间戳类型数据最高精确微秒(百万分之一秒)，数据类型定义为timestamp(N),N取值范围为0-6，默认为0，如需要精确到毫秒则设置为Timestamp(3)，如需要精确到微秒则设置为timestamp(6)，数据精度提高的代价是其内部存储空间的变大，但仍未改变时间戳类型的最小和最大取值范围。</p>

<p>时间戳类型引发的异常
当MySQL参数time_zone=system时，查询timestamp字段会调用系统时区做时区转换，而由于系统时区存在全局锁问题，在多并发大数据量访问时会导致线程上下文频繁切换，CPU使用率暴涨，系统响应变慢设置假死。</p>

<p>时间戳类型使用建议
在只关心数据最后更新时间的情况下，建议将时间戳列定义为TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP；</p>

<p>在关心创建时间和更新时间的情况下，建议将更新时间设置为时间戳字段，将创建时间定义为DAETIME 或 TIMESTAMP DEFAULT ‘0000-00-00 00:00:00’，并在插入记录时显式指定创建时间；</p>

<p>建议在表中只定义单个时间戳列，并显式定义DEFAULT 和 ON UPDATE属性；</p>

<p>虽然在MySQL中可以对时间戳字段赋值或更新，但建议仅在必要的情况下对时间戳列进行显式插入和更新；</p>

<p>建议将time_zone参数设置为system外的值，如中国地区服务器设置为’+8:00’；</p>

<p>建议将MySQL线下测试版本和线上生产版本保持一致。</p>

<p>timestamp 虽然有上限限制，但是它保存的是时间戳，可以不用去考虑时区的问题，如果是需要处理与时区相关的需求， 解决 2038 限制的时候，建议将 timestamp改为整数类型，用来保存时间戳，在程序中再进行转换（这个方案没有实施过，仅仅是建议，慎用！！）
如果不需要考虑时区问题，直接用 datatime类型替换 timestamp即可，因为datatime的取值范围大很多</p>

<p>https://blog.csdn.net/weter_drop/article/details/89924451</p>
:ET