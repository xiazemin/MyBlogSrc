I"¾	<!-- more -->
<p>void session_write_close ( void )</p>

<p>End the current session and store session data.</p>

<p>Session data is usually stored after your script terminated without the need to call session_write_close(), but as session data is locked to prevent concurrent writes only one script may operate on a session at any time. When using framesets together with sessions you will experience the frames loading one by one due to this locking. You can reduce the time needed to load all the frames by ending the session as soon as all changes to session variables are done.
ä¹Ÿå°±æ˜¯è¯´sessionæ˜¯æœ‰é”çš„ï¼Œä¸ºé˜²æ­¢å¹¶å‘çš„å†™ä¼šè¯æ•°æ®,phpè‡ªå¸¦çš„çš„æ–‡ä»¶ä¿å­˜ä¼šè¯æ•°æ®æ˜¯åŠ äº†ä¸€ä¸ªäº’æ–¥é”ï¼ˆåœ¨session_start()çš„æ—¶å€™ï¼‰ã€‚ 
ç¨‹åºæ‰§è¡Œsession_start()ï¼Œæ­¤æ—¶å½“å‰ç¨‹åºå°±å¼€å§‹æŒæœ‰é”ã€‚ 
ç¨‹åºç»“æŸï¼Œæ­¤æ—¶ç¨‹åºè‡ªåŠ¨é‡Šæ”¾Sessionçš„é”ã€‚</p>

<p>å¦‚æœåŒä¸€ä¸ªå®¢æˆ·ç«¯åŒæ—¶å¹¶å‘å‘é€å¤šä¸ªè¯·æ±‚ï¼ˆå¦‚ajaxåœ¨é¡µé¢åŒæ—¶å‘é€å¤šä¸ªè¯·æ±‚ï¼‰ï¼Œä¸”è„šæœ¬æ‰§è¡Œæ—¶é—´è¾ƒé•¿ï¼Œå°±ä¼šå¯¼è‡´sessionæ–‡ä»¶é˜»å¡ï¼Œå½±å“æ€§èƒ½ã€‚å› ä¸ºå¯¹äºæ¯ä¸ªè¯·æ±‚ï¼ŒPHPæ‰§è¡Œsession_start()ï¼Œå°±ä¼šå–å¾—æ–‡ä»¶ç‹¬å é”ï¼Œåªæœ‰åœ¨è¯¥è¯·æ±‚å¤„ç†ç»“æŸåï¼Œæ‰ä¼šé‡Šæ”¾ç‹¬å é”ã€‚è¿™æ ·ï¼ŒåŒæ—¶å¤šä¸ªè¯·æ±‚å°±ä¼šå¼•èµ·é˜»å¡ã€‚è§£å†³æ–¹æ¡ˆå¦‚ä¸‹ï¼š 
ä¿®æ”¹ä¼šè¯å˜é‡åï¼Œç«‹å³ä½¿ç”¨session_write_close()æ¥ä¿å­˜ä¼šè¯æ•°æ®å¹¶é‡Šæ”¾æ–‡ä»¶é”ã€‚
session_start(); <br />
$_SESSION[â€˜testâ€™] = â€˜testâ€™;
session_write_close();</p>

<p>(PHP 5 &gt;= 5.3.3, PHP 7)
fastcgi_finish_request â€” å†²åˆ·(flush)æ‰€æœ‰å“åº”çš„æ•°æ®ç»™å®¢æˆ·ç«¯
å¦‚æœæœ‰é”çš„è¯ä¼šä½¿å¼‚æ­¥ä½œç”¨å¤±æ•ˆ</p>

<p>There are some pitfalls  you should be aware of when using this function.</p>

<p>The script will still occupy a FPM process after fastcgi_finish_request(). So using it excessively for long running tasks may occupy all your FPM threads up to pm.max_children. This will lead to gateway errors on the webserver.</p>

<p>Another important thing is session handling. Sessions are locked as long as theyâ€™re active (see the documentation for session_write_close()). This means subsequent requests will block until the session is closed.</p>

<p>You should therefore call session_write_close() as soon as possible (even before fastcgi_finish_request()) to allow subsequent requests and a good user experience.</p>

<p>This also applies for all other locking techniques as flock or database locks for example. As long as a lock is active subsequent requests might bock.</p>

:ET