I"‘k<p>go-simplejsonï¼Œç”¨æ¥å°è£…ä¸è§£æåŒ¿åçš„JSONï¼Œè¯´ç™½äº†å°±æ˜¯ç”¨mapæˆ–è€…sliceç­‰æ¥è§£æJSON,ç”¨çš„Golangè‡ªå¸¦çš„encoding/jsonåº“å»åšçš„è§£æ
<!-- more -->
#JSON value
ä¸€ä¸ªå®Œæ•´çš„JSONåº”è¯¥åŒ…å«ä¸€ä¸ªvalueï¼Œè¿™ä¸ªvalueçš„ç±»å‹å¯èƒ½æ˜¯nullï¼Œtrueï¼Œfalseï¼Œnumberï¼Œstringï¼Œ arrayä»¥åŠ objectå…±6ç§ã€‚è€Œarrayå’Œobjectè¿˜æœ‰å¯èƒ½åŒ…å«å­valueç»“æ„ã€‚è¿™äº›ç±»å‹çš„å€¼æ˜ å°„åˆ°Golangå½“ä¸­ï¼Œä¾¿æ˜¯nil, bool, bool, int64/float64, string, []interface{}, map[string]interface{}ï¼Œç”¨ä¸€ä¸ªunionç»“æ„ä¾¿å¯ä»¥æå®šã€‚æ³¨æ„è¿™é‡Œçš„numberæœ‰å¯ä»¥è½¬æ¢æˆæ•´æ•°æˆ–è€…æ˜¯æµ®ç‚¹æ•°ï¼Œåœ¨JavaScriptä¸­ï¼Œå…¨éƒ¨ç”¨64ä½åŒç²¾åº¦æµ®ç‚¹æ•°å‚¨å­˜ï¼Œæ‰€ä»¥æœ€å¤§çš„ç²¾ç¡®æ•´æ•°ä¹Ÿå°±æ˜¯éè§„çº¦æ•°æ˜¯å°¾æ•°éƒ¨åˆ†2^53 - 1ï¼Œå·²ç»è¿œè¿œå¤§äºint32äº†ï¼Œæ‰€ä»¥è¿™é‡Œå°†æ•´æ•°æ˜ å°„æˆäº†int64è€Œä¸æ˜¯intï¼Œå› ä¸ºåœ¨éƒ¨åˆ†æœºå™¨ä¸Šå¯èƒ½æº¢å‡ºï¼Œä¸¥æ ¼çš„åŒºåˆ†ä¸€ä¸ªIEEE-754æ ¼å¼çš„æ•´æ•°å’Œæµ®ç‚¹æ•°å¹¶ä¸æ˜¯ä¸€ä»¶è½»æ¾çš„äº‹æƒ…</p>

<p>å®šä¹‰ä¸€ä¸ªç»“æ„æ¥ä¿å­˜ä¸€ä¸ªJSONçš„valueï¼š</p>

<p>type struct Value {
  value interface{}
}</p>

<p>ç»“æ„ä¸­çš„valueå­—æ®µä¿å­˜è¿™ä¸ªJSONValueçš„å®é™…å€¼ï¼Œé€šè¿‡ç±»å‹åˆ¤å®šæ¥ç¡®å®šå…¶ç±»å‹ã€‚å› æ­¤ä¼šæœ‰å¾ˆå¤šçš„åˆ¤å®šï¼Œèµ‹å€¼ï¼Œä»¥åŠå–å€¼å‡½æ•°ï¼Œæ¯”å¦‚é’ˆå¯¹ä¸€ä¸ªstringç±»å‹çš„Valueéœ€è¦æœ‰åˆ¤å®šæ˜¯å¦ä¸ºstringçš„æ“ä½œIsString()ï¼Œèµ‹å€¼AsString()ï¼Œä»¥åŠè·å–çœŸå®å€¼çš„æ“ä½œString()ï¼š</p>

<p>// åˆ¤å®šæ˜¯å¦ä¸ºstringï¼Œå¦‚æœæ˜¯ï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›false
func (v *Value) IsString() bool {
  if _, ok := v.value.(string); ok {
    return true
  }
  return false
}</p>

<p>// å°†ä¸€ä¸ªValueèµ‹å€¼ä¸ºä¸€ä¸ªstring
func (v *Value) AsString(value string) {
  v.value = value
}</p>

<p>// ä»ä¸€ä¸ªstringç±»å‹çš„Valueä¸­å–å‡ºStringå€¼
func (v *Value) String() string {
  if value, ok := v.value.(string); ok {
    return value
  }
  // å¦‚æœä¸æ˜¯ä¸€ä¸ªstringç±»å‹ï¼Œåˆ™æŠ¥é”™ï¼Œæ‰€ä»¥éœ€è¦å…ˆåˆ¤å®šæ˜¯å¦ä¸ºstringç±»å‹
  panic(â€œnot a string valueâ€)
}</p>

<p>#JSON parser
å¯¹äºstring, true, false, null, numberè¿™æ ·çš„å€¼ï¼Œéƒ½å±äºå­—é¢é‡ï¼Œå³æ²¡æœ‰æ·±å±‚ç»“æ„ï¼Œå¯å–ç›´æ¥è¯»å–ï¼Œå¹¶ä¸”ä¸­é—´ä¸å¯èƒ½è¢«ç©ºç™½å­—ç¬¦åˆ‡æ–­ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥è¯»å–ã€‚è€Œå¯¹äºä¸€ä¸ªarrayæˆ–è€…objectï¼Œåˆ™æ˜¯ä¸€ä¸ªå¤šå±‚çš„æ ‘çŠ¶ç»“æ„ã€‚æœ€ç›´æ¥çš„æƒ³æ³•è‚¯å®šæ˜¯ç”¨é€’å½’ï¼Œä½†æ˜¯å¤§å®¶éƒ½çŸ¥é“è¿™æ˜¯ä¸å¯è¡Œçš„ï¼Œå› ä¸ºåœ¨è§£æå¤§JSONçš„æ—¶å€™å¾ˆå¯èƒ½æ ˆæº¢å‡ºäº†ï¼Œæ‰€ä»¥åªèƒ½ç”¨æ ˆ+è¿­ä»£çš„åŠæ³•ã€‚</p>

<p>ASTåˆ†æçš„æ—¶å€™é¦–å…ˆè¦åˆ†æTokenï¼Œç„¶åå†åˆ†æASTï¼Œåœ¨è§£æJSONçš„æ—¶å€™ä¹Ÿåº”è¯¥è¿™æ ·ï¼Œè™½ç„¶Tokenæ¯”è¾ƒå°‘ï¼šåªæœ‰å‡ ä¸ªå­—é¢é‡ä»¥åŠ{, [, :, ], }å‡ ä¸ªç•Œå®šç¬¦ã€‚</p>

<p>å› ä¸ºJSONæ˜¯ä¸€æ£µæ ‘ï¼Œå…¶è§£æè¿‡ç¨‹æ˜¯ä»æ ‘æ ¹ä¸€ç›´éå†åˆ°å„ä¸ªå¶èŠ‚ç‚¹å†è¿”å›æ ‘æ ¹çš„è¿‡ç¨‹ã€‚è‡ªç„¶å°±ä¼šæ¶‰åŠåˆ°æ ˆçš„å‹å…¥åŠå¼¹å‡ºæ“ä½œã€‚å…·ä½“æ¥è®²ï¼Œå°±æ˜¯åœ¨é‡åˆ°arrayå’Œobjectçš„å­èŠ‚ç‚¹çš„æ—¶å€™è¦å‹å…¥æ ˆï¼Œé‡åˆ°ä¸€ä¸ªvalueçš„ç»“æŸç¬¦çš„æ—¶å€™è¦å¼¹å‡ºæ ˆã€‚åŒæ—¶è¿˜è¦ä¿å­˜æ ˆç»“ç‚¹å¯¹åº”çš„Valueä»¥åŠå…¶çŠ¶æ€ä¿¡æ¯ã€‚</p>

<p>ä¸€ä¸ªæ ˆç»“ç‚¹ç»“æ„ï¼š</p>

<p>type struct state {
  state int
  value *Value
  parent *state
}</p>

<p>stateè¡¨ç¤ºå½“å‰æ ˆèŠ‚ç‚¹çš„çŠ¶æ€ï¼Œvalueè¡¨ç¤ºå…¶æ‰€ä»£è¡¨çš„å€¼parentè¡¨ç¤ºå…¶çˆ¶èŠ‚ç‚¹ï¼Œæ ¹èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¸ºnilã€‚å½“è¦å‹å…¥æ ˆæ—¶ï¼Œåªéœ€è¦æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°†å…¶parentè®¾ç½®ä¸ºå½“å‰èŠ‚ç‚¹å³å¯ï¼Œè¦å¼¹å‡ºæ—¶ï¼Œå°†å½“å‰ç»“ç‚¹è®¾ç½®ä¸ºå½“å‰ç»“ç‚¹çš„parentã€‚å¦‚æœå½“å‰èŠ‚ç‚¹ä¸ºnilï¼Œåˆ™è¡¨ç¤ºéå†ç»“æŸï¼ŒJSONè‡ªèº«ä¹Ÿåº”è¯¥ç»“æŸï¼Œé™¤äº†ç©ºç™½å­—ç¬¦å¤–ï¼Œä¸åº”è¯¥è¿˜åŒ…å«ä»»ä½•å­—ç¬¦ã€‚</p>

<p>ä¸€ä¸ªèŠ‚ç‚¹å¯èƒ½çš„çŠ¶æ€æœ‰ï¼š</p>

<p>const (
    // start of a value
    stateNone = iota
    stateString
    // after [ must be a value or ]
    stateArrayValueOrEnd
    // after a value, must be a , or ]
    stateArrayEndOrComma
    // after a {, must be a key string or }
    stateObjectKeyOrEnd
    // after a key string must be a :
    stateObjectColon
    // after a : must be a value
    // after a value, must be , or }
    stateObjectEndOrComma
    // after a , must be key string
    stateObjectKey
)</p>

<p>å¯¹äºçŠ¶æ€stateArrayValueOrEndè¡¨ç¤ºå½“å‰æ ˆèŠ‚ç‚¹é‡åˆ°äº†ä¸€ä¸ªarrayçš„èµ·å§‹æ ‡å¿—[ï¼Œåœ¨ç­‰å¾…ä¸€ä¸ªå­Valueæˆ–è€…ä¸€ä¸ªarrayçš„ç»“æŸç¬¦]ï¼Œè€ŒçŠ¶æ€stateArrayEndOrCommaè¡¨ç¤ºä¸€ä¸ªarrayå·²ç»é‡åˆ°äº†å­Valueï¼Œåœ¨ç­‰å¾…ç»“æŸç¬¦]æˆ–è€…Valueçš„åˆ†éš”ç¬¦,ã€‚å› æ­¤ï¼Œåœ¨è§£æä¸€ä¸ªæ•°ç»„çš„æ—¶å€™ï¼Œå®Œæ•´çš„æ ˆæ“ä½œè¿‡ç¨‹æ˜¯ï¼šé‡åˆ°[ï¼Œå°†å½“å‰ç»“ç‚¹çš„çŠ¶æ€è®¾ç½®ä¸ºstateArrayValueOrEndï¼Œç„¶åè¿‡æ»¤ç©ºç™½å­—ç¬¦ï¼Œåˆ¤å®šç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯]è¿˜æ˜¯å…¶å®ƒå­—ç¬¦ï¼Œå¦‚æœæ˜¯]ï¼Œåˆ™arrayç»“æŸï¼Œå¼¹å‡ºæ ˆï¼Œå¦‚æœä¸æ˜¯ï¼Œåˆ™å°†è‡ªèº«çŠ¶æ€ä¿®æ”¹ä¸ºstateArrayEndOrCommaï¼Œå¹¶å‹å…¥ä¸€ä¸ªæ–°æ ˆç»“ç‚¹ï¼Œå°†å…¶çŠ¶æ€è®¾ç½®ä¸ºstateNoneï¼Œé‡æ–°å¼€å§‹è§£æï¼Œæ­¤ç»“ç‚¹è§£æå®Œæˆä¹‹åï¼Œå¼¹å‡ºæ­¤ç»“ç‚¹ï¼Œåˆ¤å®šæ˜¯,è¿˜æ˜¯]ï¼Œå¦‚æœæ˜¯]ï¼Œåˆ™ç»“æŸå¼¹å‡ºï¼Œå¦‚æœæ˜¯,åˆ™ä¸æ”¹å˜è‡ªèº«çŠ¶æ€ï¼Œå¹¶é‡æ–°ä¸€ä¸ªæ–°æ ˆç»“ç‚¹ï¼Œå¼€å§‹æ–°çš„å¾ªç¯ã€‚å®Œäº‹çš„çŠ¶æ€æœºå¦‚ä¸‹ï¼š
	<img src="https://xiazemin.github.io/MyBlog/img/json_state_machine.webp" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>é¦–å…ˆåˆå§‹åŒ–ä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼ŒçŠ¶æ€è®¾ç½®ä¸ºstateNoneï¼Œç„¶ååˆ¤æ–­ç¬¬ä¸€ä¸ªéç©ºå­—ç¬¦ï¼Œå¦‚æœæ˜¯t/f/n/[-0-9]ï¼Œåˆ™ç›´æ¥è§£æå­—é¢é‡ï¼Œç„¶åå¼¹å‡ºï¼Œå¦‚æœæ˜¯[ï¼Œåˆ™å°†çŠ¶æ€è®¾ç½®ä¸ºstateArrayValueOrEndï¼Œç„¶ååˆ¤å®šç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œå¦‚æœæ˜¯]ï¼Œåˆ™ç»“æŸå¼¹å‡ºï¼Œå¦åˆ™å‹å…¥æ–°æ ˆï¼Œå¹¶å°†è‡ªèº«çŠ¶æ€è®¾ç½®ä¸ºstateArrayEndOrCommaï¼Œå¼€å§‹æ–°çš„å¾ªç¯ï¼Œå¦‚æœæ˜¯{ï¼Œåˆ™å°†çŠ¶æ€è®¾ç½®ä¸ºstateObjectKeyOrEndï¼Œå¦‚æœä¸‹ä¸€ä¸ªéç©ºå­—ç¬¦ä¸º}ï¼Œåˆ™ç»“æŸå¼¹å‡ºï¼Œå¦åˆ™è§£ækeyï¼Œå®Œæˆä¹‹åï¼Œå‹å…¥æ–°æ ˆï¼Œå¹¶å°†è‡ªèº«çŠ¶æ€è®¾ç½®ä¸ºstateObjectEndOrCommaã€‚
</code></pre></div></div>

<p>æ¯”è¾ƒç‰¹æ®Šçš„æ˜¯stateStringï¼ŒæŒ‰é“ç†å…¶ä¹Ÿæ˜¯ä¸€ä¸ªå­—é¢é‡ï¼Œä¸éœ€è¦åˆ°ä¸€ä¸ªæ–°çš„å¾ªç¯é‡Œé¢å»è§£æã€‚ä½†æ˜¯å› ä¸ºä¸€ä¸ªobjectçš„keyä¹Ÿæ˜¯ä¸€ä¸ªstringï¼Œä¸ºäº†å¤ç”¨ä»£ç ï¼Œå¹¶é¿å…è°ƒç”¨å‡½æ•°äº§ç”Ÿçš„æ€§èƒ½å¼€é”€ï¼Œå°†stringç±»å‹å’Œobjectçš„keyå½“ä½œåŒä¸€ç±»å‹æ¥å¤„ç†ï¼Œå…·ä½“å¦‚ä¸‹ï¼š</p>

<p>root := &amp;state{&amp;Value{nil}, stateNone, nil}
curr := root
for {
  // ignore whitespace
  // check curr is nil or not
  switch curr.state {
    case stateNone:
      switch data[offset] {
        case â€˜â€â€™:
          // go to new loop
          curr.state = stateString
          continue
      }
    case stateObjectKey, stateString:
      // parse string
      if curr.state == stateObjectKey {
        // create new stack node
      } else {
        // pop stack
      }
  }
}</p>

<p>æ­¤å¤–æ¯”è¾ƒç‰¹æ®Šçš„æ˜¯åœ¨è§£æå®Œä¸€ä¸ªobjectçš„keyä¹‹åï¼Œç«‹å³å‹å…¥äº†ä¸€ä¸ªæ–°æ ˆç»“ç‚¹ï¼Œå¹¶å°†å…¶çŠ¶æ€è®¾ç½®ä¸ºstateObjectColonï¼ŒåŒæ—¶å°†è‡ªèº«çš„çŠ¶æ€è®¾ç½®ä¸ºstateObjectEndOrCommaï¼Œåœ¨è§£æå®Œcolonä¹‹åå†è¿™ä¸ªèŠ‚ç‚¹çš„çŠ¶æ€è®¾ç½®ä¸ºstateNoneï¼Œå¼€å§‹æ–°çš„å¾ªç¯ï¼Œå…·ä½“æ¥è¯´ï¼š</p>

<p>if curr.state == stateObjectKey {
  curr.state = stateObjectEndOrComma
  curr = &amp;state{&amp;Value{nil}, stateObjectColon, nil}
  continue
}</p>

<p>è¿™æ˜¯å› ä¸ºåœ¨:ä¹‹å‰å’Œä¹‹åéƒ½å¯èƒ½æœ‰ç©ºç™½å­—ç¬¦ï¼Œè¿™é‡Œæ˜¯ä¸ºäº†å¤ç”¨ä»£ç é€»è¾‘ï¼šå³åœ¨æ¯ä¸€æ¬¡è¿­ä»£å¼€å§‹ä¹‹æ—¶éƒ½æŠŠæ‰€æœ‰çš„ç©ºç™½è¿‡æ»¤æ‰ã€‚</p>

<p>for {
  LOOP_WS:
  for ; offset &lt; len(data); offset++ {
    switch data[offset] {
    case â€˜\tâ€™, â€˜\râ€™, â€˜\nâ€™, â€˜ â€˜:
      continue
    default:
      break LOOP_WS
  }
  // do staff
}</p>

<p>åœ¨è¿‡æ»¤æ‰ç©ºç™½åï¼Œå¦‚æœå½“å‰æ ˆä¸ºnilï¼Œåˆ™ä¸åº”è¯¥æœ‰å­—ç¬¦å­˜åœ¨ï¼Œæ•´ä¸ªè§£æç»“æŸï¼Œå¦åˆ™ä¸€å®šæœ‰å­—ç¬¦ï¼Œå¹¶ä¸”éœ€è¦è¿›è¡Œè§£æï¼š</p>

<p>for {
  // ignore whitespace
  if curr == nil {
    if offset == len(data) {
      return
    } else {
      // unexpected char data[offset] at offset
    }
  } else if offset == len(data) {
    // unexpected EOF at offset
  }
  // do staff
}</p>

<p>#JSONè§£æåŸºæœ¬åŸç†
    ç°åœ¨ï¼Œå‡è®¾æˆ‘ä»¬æ²¡æœ‰ä»»ä½•ç°æˆçš„JSONè§£æåº“å¯ç”¨ï¼Œæˆ‘ä»¬è¦è‡ªå·±å®ŒæˆJSONçš„è§£æå·¥ä½œã€‚JSONè§£æçš„å·¥ä½œä¸»è¦åˆ†ä¸€ä¸‹å‡ æ­¥ï¼š</p>

<p>è¯æ³•åˆ†æï¼šè¿™ä¸ªè¿‡ç¨‹æŠŠè¾“å…¥çš„JSONå­—ç¬¦ä¸²åˆ†è§£ä¸ºä¸€ç³»åˆ—è¯æ³•å•å…ƒï¼ˆtokenï¼‰ã€‚æ¯”å¦‚ä»¥ä¸‹JSONå­—ç¬¦ä¸²ï¼š
{
    â€œdateâ€ : 20160517,
    â€œidâ€ : 1
}
 ç»è¿‡è¯æ³•åˆ†æåï¼Œä¼šè¢«åˆ†è§£ä¸ºä»¥ä¸‹tokenï¼šâ€œ{â€ã€ â€dateâ€œã€ â€œ:â€ã€ â€œ20160517â€ã€ â€œ,â€ã€ â€œidâ€ã€ â€œ:â€ã€ â€œ1â€ã€ â€œ}â€ã€‚</p>

<p>è¯­æ³•åˆ†æï¼šè¿™ä¸€è¿‡ç¨‹çš„è¾“å…¥æ˜¯ä¸Šä¸€æ­¥å¾—åˆ°çš„tokenåºåˆ—ã€‚è¯­æ³•åˆ†æè¿™ä¸€é˜¶æ®µå®Œæˆçš„å·¥ä½œæ˜¯æŠŠtokenæ„é€ æˆæŠ½è±¡è¯­æ³•å•å…ƒã€‚å¯¹äºJSONçš„è§£æï¼Œè¿™é‡Œçš„æŠ½è±¡è¯­æ³•å¯¹è±¡å°±ç±»ä¼¼äºorg.jsonåŒ…ä¸­çš„JSONObjectå’ŒJSONArrayç­‰ã€‚æœ‰äº†æŠ½è±¡è¯­æ³•å¯¹è±¡ï¼Œæˆ‘ä»¬å°±å¯ä»¥è¿›ä¸€æ­¥æŠŠå®ƒâ€œæ˜ å°„åˆ°â€Javaæ•°æ®ç±»å‹ã€‚</p>

<ol>
  <li>è¯æ³•åˆ†æ
 JSONå­—ç¬¦ä¸²ä¸­ï¼Œä¸€å…±æœ‰å‡ ç§tokenå‘¢ï¼Ÿæ ¹æ®http://www.json.org/å¯¹JSONæ ¼å¼çš„ç›¸å…³å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠtokenåˆ†ä¸ºä»¥ä¸‹ç±»å‹ï¼š</li>
</ol>

<p>STRINGï¼ˆå­—ç¬¦ä¸²å­—é¢é‡ï¼‰
NUMBERï¼ˆæ•°å­—å­—é¢é‡ï¼‰
NULLï¼ˆnullï¼‰
START_ARRAYï¼ˆ[ï¼‰
END_ARRAYï¼ˆ]ï¼‰
START_OBJï¼ˆ{ï¼‰
END_OBJï¼ˆ}ï¼‰
COMMAï¼ˆ,ï¼‰
COLONï¼ˆ:ï¼‰
BOOLEANï¼ˆtrueæˆ–è€…falseï¼‰
END_DOCï¼ˆè¡¨ç¤ºJSONæ•°æ®çš„ç»“æŸï¼‰
    æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªæšä¸¾ç±»å‹æ¥è¡¨ç¤ºä¸åŒçš„tokenç±»å‹ï¼š</p>

<p>public enum TokenType {
    START_OBJ, END_OBJ, START_ARRAY, END_ARRAY, NULL, NUMBER, STRING, BOOLEAN, COLON, COMMA, END_DOC
}</p>

<p>ï¼Œè¯æ³•åˆ†æå™¨é€šå¸¸è¢«ç§°ä¸ºlexeræˆ–æ˜¯tokenizerã€‚æˆ‘ä»¬å¯ä»¥ä½¿ç”¨DFAï¼ˆç¡®å®šæœ‰é™çŠ¶æ€è‡ªåŠ¨æœºï¼‰æ¥å®ç°tokenizerï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨ä½¿ç”¨Javaçš„regexåŒ…ã€‚</p>

<p>å®ç°è¯æ³•åˆ†æå™¨ï¼ˆtokenizerï¼‰å’Œè¯­æ³•åˆ†æå™¨ï¼ˆparserï¼‰çš„ä¾æ®éƒ½æ˜¯JSONæ–‡æ³•ï¼Œå®Œæ•´çš„JSONæ–‡æ³•å¦‚ä¸‹</p>

<p>object = {} | { members }
members = pair | pair , members
pair = string : value
array = [] | [ elements ]
elements = value  | value , elements
value = string | number | object | array | true | false | null
string = â€œâ€ | â€œ chars â€œ
chars = char | char chars
char = any-Unicode-character-except-â€œ-or--or- control-character | " | \ | \/ | \b | \f | \n | \r | \t | \u four-hex-digits
number = int | int frac | int exp | int frac exp
int = digit | digit1-9 digits  | - digit | - digit1-9 digits
frac = . digits
exp = e digits
digits = digit | digit digits
e = e | e+ | e-  | E | E+ | E-</p>

<ol>
  <li>è¯­æ³•åˆ†æ
 ç»è¿‡å‰ä¸€æ­¥çš„è¯æ³•åˆ†æï¼Œæˆ‘ä»¬å·²ç»å¾—åˆ°äº†ä¸€ä¸ªtokenåºåˆ—ï¼Œç°åœ¨è®©æˆ‘ä»¬æ¥ç”¨è¿™ä¸ªåºåˆ—æ„é€ å‡ºç±»ä¼¼äºorg.jsonåŒ…çš„JSONObjectä¸JSONArrayå¯¹è±¡ã€‚ç°åœ¨æˆ‘ä»¬çš„ä»»åŠ¡å°±æ˜¯ç¼–å†™ä¸€ä¸ªè¯­æ³•åˆ†æå™¨ï¼ˆparserï¼‰ï¼Œä»¥è¯æ³•åˆ†æå¾—åˆ°çš„tokenåºåˆ—ä¸ºè¾“å…¥ï¼Œäº§ç”ŸJSONObjectæˆ–æ˜¯JSONArrayæŠ½è±¡è¯­æ³•å¯¹è±¡ã€‚è¯­æ³•åˆ†æçš„ä¾æ®åŒæ ·æ˜¯ä¸Šé¢æˆ‘ä»¬è´´å‡ºçš„JSONæ–‡æ³•ã€‚
 object = {} | { members }
members = pair | pair , members
pair = string : value
array = [] | [ elements ]
elements = value  | value , elements
value = string | number | object | array | true | false | null</li>
</ol>

<p>JSONçš„ä¼˜åŠ¿é™¤äº†æ–‡æ³•å¾ˆç®€å•ä¹‹å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªå¾ˆé‡è¦çš„åœ°æ–¹æ˜¯ï¼Œæˆ‘ä»¬é€ä¸ªå­—ç¬¦åœ°è§£æJSONï¼Œåœ¨ä¸è€ƒè™‘é”™è¯¯å¤„ç†çš„æƒ…å†µä¸‹ï¼Œç”šè‡³éƒ½ä¸éœ€è¦å‰ç»ï¼ä¸¾ä¸ªä¾‹å­ï¼Œåœ¨JSONè§£æçš„ä¸€å¼€å§‹ï¼Œå¦‚æœå‘ç°æ˜¯å­—ç¬¦â€™nâ€™ï¼Œå¯ä»¥ç«‹é©¬æ–­å®šæ˜¯nullï¼›æ˜¯â€™{â€˜ï¼Œå°±æ˜¯å¯¹è±¡ã€‚è¿™ç»™æˆ‘ä»¬è§£æå™¨çš„ç¼–å†™å¸¦æ¥äº†å¾ˆå¤§çš„æ–¹ä¾¿ã€‚å…¶å®ä¸ç®¡æ˜¯JSONã€XMLè¿˜æ˜¯YAMLï¼Œå…¶æ ¸å¿ƒéƒ½æ˜¯è¦æç»˜ä¸€ç§æ ‘çŠ¶ç±»å‹çš„ç»“æ„ã€‚åŸå› æ˜¯ç”Ÿæ´»ä¸­çš„å¤§éƒ¨åˆ†ä¿¡æ¯éƒ½æ˜¯ä»¥è¿™ç§å½¢å¼ä¿å­˜çš„ã€‚æœ‰æ ‘ï¼Œå°±ä¼šæœ‰ç»“ç‚¹ã€‚è€Œä¸åŒçš„æ ‡è®°è¯­è¨€ï¼Œè¿™ä¸ªç»“ç‚¹é‡ŒåŒ…å«çš„ä¸œè¥¿ä¹Ÿå°±ä¸åŒã€‚ä½†æ˜¯è¿™ç§æ ‘çŠ¶çš„ç»“æ„æ˜¯åŸºæœ¬ç›¸åŒçš„ã€‚æŠŠæºå­—ç¬¦ä¸²è½¬æ¢æˆæˆ‘ä»¬å®šä¹‰å¥½çš„æ•°æ®ç»“æ„çš„è¿‡ç¨‹ï¼Œä¹Ÿå°±æ˜¯æ‰€è°“çš„è§£æã€‚é‚£ä¹ˆè§£æçš„éš¾ç‚¹åœ¨å“ªé‡Œå‘¢ï¼Ÿå¦‚æœä¸€ä¸ªJSONå­—ç¬¦ä¸²é‡Œçš„å†…å®¹ä»…ä»…æ˜¯â€œtrueâ€å››ä¸ªå­—ç¬¦ï¼Œä¸€æ¬¡strcmpå³å¯å®Œæˆï¼Œä½ è¿˜è§‰å¾—éš¾å—ï¼Ÿæ˜¯ä»»æ„æ•°é‡çš„ç©ºæ ¼å—ï¼Ÿè²Œä¼¼ä¹Ÿä¸æ˜¯ã€‚ä¸çŸ¥é“é¢˜ä¸»åˆå­¦ç¼–ç¨‹æ—¶æœ‰æ²¡æœ‰å†™è¿‡é‚£ç§â€œç»Ÿè®¡è¾“å…¥ä¸­ç©ºæ ¼çš„æ•°é‡â€çš„ç¨‹åºã€‚å¦‚æœæœ‰ï¼Œå…¶å®æ’é™¤ç©ºæ ¼çš„åŸç†å·®ä¸å¤šã€‚
ä½œè€…ï¼šçŸ¥ä¹ç”¨æˆ·
é“¾æ¥ï¼šhttps://www.zhihu.com/question/24640264/answer/80500016
æ¥æºï¼šçŸ¥ä¹
è‘—ä½œæƒå½’ä½œè€…æ‰€æœ‰ã€‚å•†ä¸šè½¬è½½è¯·è”ç³»ä½œè€…è·å¾—æˆæƒï¼Œéå•†ä¸šè½¬è½½è¯·æ³¨æ˜å‡ºå¤„ã€‚</p>

<p>æˆ‘ä»¬å†™ä¸€ä¸ªJSONè§£æå™¨çš„ç›®çš„æ˜¯è®©æ‚ä¹±çš„å­—ç¬¦ä¸²å˜æˆC/Java/Pythonâ€¦ç­‰è¯­è¨€èƒ½å¤Ÿè¯†åˆ«çš„æ•°æ®ç»“æ„ã€‚æˆ‘ä»¬æ‰€åšçš„å·¥ä½œä»…ä»…æ˜¯â€œä¿å­˜â€ï¼Œæ²¡æœ‰â€œè§£é‡Šâ€ï¼Œæ›´ä¸æ˜¯â€œç¼–è¯‘â€ã€‚å¤–åŠ å‰é¢è¯´çš„æ ¹æœ¬ä¸éœ€è¦å‰ç»ä¸€ä¸ªå­—ç¬¦çš„ç‰¹æ€§ï¼Œæˆ‘ä»¬ç¼–å†™JSON Parserå…¶å®è¿è¯æ³•åˆ†æéƒ½ä¸ç”¨ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å…ˆå®šä¹‰å¥½ä¸€ä¸ªJSONæ•°æ®ç»“æ„çš„ç»“ç‚¹ç±»å‹ã€‚struct json_node {
    enum {
        NUMBER,
        STRING,
        ARRAY,
        OBJECT,
        TRUE,
        FALSE,
        NUL,
        UNKNOWN
    } type;
    char <em>name;
    union {
        double number;
        struct json_node *child_head;
        char *val_str;
    };
};å®šä¹‰å¥½äº†è¿™ä¸ªç»“æ„ä½“ï¼Œæˆ‘ä»¬çš„å·¥ä½œå…¶å®å°±å·²ç»å®Œæˆä¸€åŠäº†ã€‚æ ¹æ®ä¸Šé¢å®Œæ•´å®šä¹‰çš„æ–‡æ³•ï¼Œå†æ¥å†™è§£é‡ŠåŸºæœ¬ç±»å‹çš„ä»£ç ã€‚struct json_node *
parse_json(void)
{
    struct json_node *res = malloc(sizeof(struct json_node));
    char ch = getchar();
    switch (ch) {
    case â€˜tâ€™:
        while (isalpha(ch)) {
            ch = getchar();
        }
        res-&gt;type = TRUE;
        break;
    /</em> å¯¹äºnullå’Œfalseä¹Ÿä¸€æ · <em>/
    case â€˜"â€™:
        res-&gt;type = STRING;
        /</em> å¯»æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸æ˜¯è½¬ä¹‰å­—ç¬¦çš„åŒå¼•å· â€œ <em>/
        break;
    case â€˜+â€™:
    case â€˜-â€˜:
    case â€˜1â€™:
    /</em> 1-9 <em>/
        res-&gt;type = NUMBER;
        /</em> ç¼“å†²åŒºå­˜å‚¨å­—ç¬¦ç›´åˆ°åœæ­¢ï¼Œç„¶åç”¨ç³»ç»Ÿåº“å‡½æ•°è½¬æ¢ */
    default:
        res-&gt;type = UNKNOWN;
        break;
    }
    return res;
}</p>

<p>ç¼–å†™ä¸€ä¸ªJSONè§£æå™¨å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œå®ƒçš„è¾“å…¥æ˜¯ä¸€ä¸ªè¡¨ç¤ºJSONçš„å­—ç¬¦ä¸²ï¼Œè¾“å‡ºæ˜¯ç»“æ„åŒ–çš„å¯¹åº”åˆ°è¯­è¨€æœ¬èº«çš„æ•°æ®ç»“æ„ã€‚</p>

<p>å’ŒXMLç›¸æ¯”ï¼ŒJSONæœ¬èº«ç»“æ„éå¸¸ç®€å•ï¼Œå¹¶ä¸”ä»…æœ‰å‡ ç§æ•°æ®ç±»å‹ï¼Œä»¥Javaä¸ºä¾‹ï¼Œå¯¹åº”çš„æ•°æ®ç»“æ„æ˜¯ï¼š</p>

<p>â€œstringâ€ï¼šJavaçš„Stringï¼›
numberï¼šJavaçš„Longæˆ–Doubleï¼›
true/falseï¼šJavaçš„Booleanï¼›
nullï¼šJavaçš„nullï¼›
[array]ï¼šJavaçš„List<object>æˆ–Object[]ï¼›
{â€œkeyâ€:â€valueâ€}ï¼šJavaçš„Map&lt;String, Object&gt;ã€‚
è§£æJSONå’Œè§£æXMLç±»ä¼¼ï¼Œæœ€ç»ˆéƒ½æ˜¯è§£æä¸ºå†…å­˜çš„ä¸€ä¸ªå¯¹è±¡ã€‚å‡ºäºæ•ˆç‡è€ƒè™‘ï¼Œä½¿ç”¨æµçš„æ–¹å¼å‡ ä¹æ˜¯å”¯ä¸€é€‰æ‹©ï¼Œä¹Ÿå°±æ˜¯è§£æå™¨åªä»å¤´æ‰«æä¸€éJSONå­—ç¬¦ä¸²ï¼Œå°±å®Œæ•´åœ°è§£æå‡ºå¯¹åº”çš„æ•°æ®ç»“æ„ã€‚</object></p>

<p>æœ¬è´¨ä¸Šè§£æå™¨å°±æ˜¯ä¸€ä¸ªçŠ¶æ€æœºï¼Œåªè¦æŒ‰ç…§JSONå®šä¹‰çš„æ ¼å¼ï¼ˆå‚è€ƒhttp://www.json.orgï¼Œæ­£ç¡®å®ç°çŠ¶æ€è½¬ç§»å³å¯ã€‚ä½†æ˜¯ä¸ºäº†ç®€åŒ–ä»£ç ï¼Œæˆ‘ä»¬ä¹Ÿæ²¡å¿…è¦å®Œæ•´åœ°å®ç°ä¸€ä¸ªå­—ç¬¦ä¸€ä¸ªå­—ç¬¦çš„çŠ¶æ€è½¬ç§»ã€‚</p>

<p>è§£æå™¨çš„è¾“å…¥åº”è¯¥æ˜¯ä¸€ä¸ªå­—ç¬¦æµï¼Œæ‰€ä»¥ï¼Œç¬¬ä¸€æ­¥æ˜¯è·å¾—Readerï¼Œä»¥ä¾¿èƒ½ä¸æ–­åœ°è¯»å…¥ä¸‹ä¸€ä¸ªå­—ç¬¦ã€‚</p>

<p>åœ¨è§£æçš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸è¦æ ¹æ®ä¸‹ä¸€ä¸ªå­—ç¬¦æ¥å†³å®šçŠ¶æ€è·³è½¬ï¼Œæ­¤æ—¶åˆæ¶‰åŠåˆ°å›é€€çš„é—®é¢˜ï¼Œå°±æ˜¯æŸäº›æ—¶å€™ä¸èƒ½ç”¨next()å–ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œè€Œæ˜¯ç”¨peek()å–ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œä½†å­—ç¬¦æµçš„æŒ‡é’ˆä¸ç§»åŠ¨ã€‚æ‰€ä»¥ï¼ŒReaderæ¥å£ä¸èƒ½æ»¡è¶³è¿™ä¸ªéœ€æ±‚ï¼Œåº”å½“è¿›ä¸€æ­¥å°è£…ä¸€ä¸ªCharReaderï¼Œå®ƒå¯ä»¥å®ç°ï¼š</p>

<p>char next()ï¼šè¯»å–ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œç§»åŠ¨ReaderæŒ‡é’ˆï¼›
char peek()ï¼šè¯»å–ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œä¸ç§»åŠ¨ReaderæŒ‡é’ˆï¼›
String next(int size)ï¼šè¯»å–æŒ‡å®šçš„Nä¸ªå­—ç¬¦å¹¶ç§»åŠ¨æŒ‡é’ˆï¼›
boolean hasMore()ï¼šåˆ¤æ–­æµæ˜¯å¦ç»“æŸã€‚
JSONè§£ææ¯”å…¶ä»–æ–‡æœ¬è§£æè¦ç®€å•çš„åœ°æ–¹åœ¨äºï¼Œä»»ä½•JSONæ•°æ®ç±»å‹ï¼Œåªéœ€è¦æ ¹æ®ä¸‹ä¸€ä¸ªå­—ç¬¦å³å¯ç¡®å®šï¼Œä»”ç»†æ€»ç»“å¯ä»¥å‘ç°ï¼Œå¦‚æœpeek()è¿”å›çš„å­—ç¬¦æ˜¯æŸä¸ªå­—ç¬¦ï¼Œå°±å¯ä»¥æœŸæœ›è¯»å–çš„æ•°æ®ç±»å‹ï¼š</p>

<p>{ï¼šæœŸå¾…ä¸€ä¸ªJSON objectï¼›
:ï¼šæœŸå¾…ä¸€ä¸ªJSON objectçš„valueï¼›
,ï¼šæœŸå¾…ä¸€ä¸ªJSON objectçš„ä¸‹ä¸€ç»„key-valueï¼Œæˆ–è€…ä¸€ä¸ªJSON arrayçš„ä¸‹ä¸€ä¸ªå…ƒç´ ï¼›
[ï¼šæœŸå¾…ä¸€ä¸ªJSON arrayï¼›
tï¼šæœŸå¾…ä¸€ä¸ªtrueï¼›
fï¼šæœŸå¾…ä¸€ä¸ªfalseï¼›
nï¼šæœŸå¾…ä¸€ä¸ªnullï¼›
â€œï¼šæœŸå¾…ä¸€ä¸ªstringï¼›
0~9ï¼šæœŸå¾…ä¸€ä¸ªnumberã€‚
ä½†æ˜¯å•ä¸ªå­—ç¬¦è¦åŒ¹é…çš„çŠ¶æ€å¤ªå¤šäº†ï¼Œéœ€è¦è¿›ä¸€æ­¥æŠŠå­—ç¬¦æµå˜ä¸ºTokenï¼Œå¯ä»¥æ€»ç»“å‡ºå¦‚ä¸‹å‡ ç§Tokenï¼š</p>

<p>END_DOCUMENTï¼šJSONæ–‡æ¡£ç»“æŸï¼›
BEGIN_OBJECTï¼šå¼€å§‹ä¸€ä¸ªJSON objectï¼›
END_OBJECTï¼šç»“æŸä¸€ä¸ªJSON objectï¼›
BEGIN_ARRAYï¼šå¼€å§‹ä¸€ä¸ªJSON arrayï¼›
END_ARRAYï¼šç»“æŸä¸€ä¸ªJSON arrayï¼›
SEP_COLONï¼šè¯»å–ä¸€ä¸ªå†’å·ï¼›
SEP_COMMAï¼šè¯»å–ä¸€ä¸ªé€—å·ï¼›
STRINGï¼šä¸€ä¸ªStringï¼›
BOOLEANï¼šä¸€ä¸ªtrueæˆ–falseï¼›
NUMBERï¼šä¸€ä¸ªnumberï¼›
NULLï¼šä¸€ä¸ªnullã€‚
ç„¶åï¼Œå°†CharReaderè¿›ä¸€æ­¥å°è£…ä¸ºTokenReaderï¼Œæä¾›ä»¥ä¸‹æ¥å£ï¼š</p>

<p>Token readNextToken()ï¼šè¯»å–ä¸‹ä¸€ä¸ªTokenï¼›
boolean readBoolean()ï¼šè¯»å–ä¸€ä¸ªbooleanï¼›
Number readNumber()ï¼šè¯»å–ä¸€ä¸ªnumberï¼›
String readString()ï¼šè¯»å–ä¸€ä¸ªstringï¼›
void readNull()ï¼šè¯»å–ä¸€ä¸ªnullã€‚
ç”±äºJSONçš„Objectå’ŒArrayå¯ä»¥åµŒå¥—ï¼Œåœ¨è¯»å–è¿‡ç¨‹ä¸­ï¼Œä½¿ç”¨ä¸€ä¸ªæ ˆæ¥å­˜å‚¨Objectå’ŒArrayæ˜¯å¿…é¡»çš„ã€‚æ¯å½“æˆ‘ä»¬è¯»åˆ°ä¸€ä¸ªBEGIN_OBJECTæ—¶ï¼Œå°±åˆ›å»ºä¸€ä¸ªMapå¹¶å‹æ ˆï¼›æ¯å½“è¯»åˆ°ä¸€ä¸ªBEGIN_ARRAYæ—¶ï¼Œå°±åˆ›å»ºä¸€ä¸ªListå¹¶å‹æ ˆï¼›æ¯å½“è¯»åˆ°ä¸€ä¸ªEND_OBJECTå’ŒEND_ARRAYæ—¶ï¼Œå°±å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œå¹¶æ ¹æ®æ–°çš„æ ˆé¡¶å…ƒç´ åˆ¤æ–­æ˜¯å¦å‹æ ˆã€‚æ­¤å¤–ï¼Œè¯»åˆ°Objectçš„Keyä¹Ÿå¿…é¡»å‹æ ˆï¼Œè¯»åˆ°åé¢çš„Valueåå°†Key-Valueå‹å…¥æ ˆé¡¶çš„Mapã€‚</p>

<p>å¦‚æœè¯»åˆ°END_DOCUMENTæ—¶ï¼Œæ ˆæ°å¥½åªå‰©ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œåˆ™è¯»å–æ­£ç¡®ï¼Œå°†è¯¥å…ƒç´ è¿”å›ï¼Œè¯»å–ç»“æŸã€‚å¦‚æœæ ˆå‰©ä¸‹ä¸æ­¢ä¸€ä¸ªå…ƒç´ ï¼Œåˆ™JSONæ–‡æ¡£æ ¼å¼ä¸æ­£ç¡®ã€‚</p>

<table>
  <tbody>
    <tr>
      <td>æœ€åï¼ŒJsonReaderçš„æ ¸å¿ƒè§£æä»£ç parse()å°±æ˜¯è´Ÿè´£ä»TokenReaderä¸­ä¸æ–­è¯»å–Tokenï¼Œæ ¹æ®å½“å‰çŠ¶æ€æ“ä½œï¼Œç„¶åè®¾å®šä¸‹ä¸€ä¸ªTokenæœŸæœ›çš„çŠ¶æ€ï¼Œå¦‚æœä¸æœŸæœ›çŠ¶æ€ä¸ç¬¦ï¼Œåˆ™JSONçš„æ ¼å¼æ— æ•ˆã€‚èµ·å§‹çŠ¶æ€è¢«è®¾å®šä¸ºSTATUS_EXPECT_SINGLE_VALUE</td>
      <td>STATUS_EXPECT_BEGIN_OBJECT</td>
      <td>STATUS_EXPECT_BEGIN_ARRAYï¼Œå³æœŸæœ›è¯»å–åˆ°å•ä¸ªvalueã€{æˆ–[ã€‚å¾ªç¯çš„é€€å‡ºç‚¹æ˜¯è¯»å–åˆ°END_DOCUMENTæ—¶ã€‚</td>
    </tr>
  </tbody>
</table>

<p>public class JsonReader {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TokenReader reader;

public Object parse() {
    Stack stack = new Stack();
    int status = STATUS_EXPECT_SINGLE_VALUE | STATUS_EXPECT_BEGIN_OBJECT | STATUS_EXPECT_BEGIN_ARRAY;
    for (;;) {
        Token currentToken = reader.readNextToken();
        switch (currentToken) {
        case BOOLEAN:
            if (hasStatus(STATUS_EXPECT_SINGLE_VALUE)) {
                // single boolean:
                Boolean bool = reader.readBoolean();
                stack.push(StackValue.newJsonSingle(bool));
                status = STATUS_EXPECT_END_DOCUMENT;
                continue;
            }
            if (hasStatus(STATUS_EXPECT_OBJECT_VALUE)) {
                Boolean bool = reader.readBoolean();
                String key = stack.pop(StackValue.TYPE_OBJECT_KEY).valueAsKey();
                stack.peek(StackValue.TYPE_OBJECT).valueAsObject().put(key, bool);
                status = STATUS_EXPECT_COMMA | STATUS_EXPECT_END_OBJECT;
                continue;
            }
            if (hasStatus(STATUS_EXPECT_ARRAY_VALUE)) {
                Boolean bool = reader.readBoolean();
                stack.peek(StackValue.TYPE_ARRAY).valueAsArray().add(bool);
                status = STATUS_EXPECT_COMMA | STATUS_EXPECT_END_ARRAY;
                continue;
            }
            throw new JsonParseException("Unexpected boolean.", reader.reader.readed);

        case NULL:
            if (hasStatus(STATUS_EXPECT_SINGLE_VALUE)) {
                // single null:
                reader.readNull();
                stack.push(StackValue.newJsonSingle(null));
                status = STATUS_EXPECT_END_DOCUMENT;
                continue;
            }
            if (hasStatus(STATUS_EXPECT_OBJECT_VALUE)) {
                reader.readNull();
                String key = stack.pop(StackValue.TYPE_OBJECT_KEY).valueAsKey();
                stack.peek(StackValue.TYPE_OBJECT).valueAsObject().put(key, null);
                status = STATUS_EXPECT_COMMA | STATUS_EXPECT_END_OBJECT;
                continue;
            }
            if (hasStatus(STATUS_EXPECT_ARRAY_VALUE)) {
                reader.readNull();
                stack.peek(StackValue.TYPE_ARRAY).valueAsArray().add(null);
                status = STATUS_EXPECT_COMMA | STATUS_EXPECT_END_ARRAY;
                continue;
            }
            throw new JsonParseException("Unexpected null.", reader.reader.readed);

        case NUMBER:
            if (hasStatus(STATUS_EXPECT_SINGLE_VALUE)) {
                // single number:
                Number number = reader.readNumber();
                stack.push(StackValue.newJsonSingle(number));
                status = STATUS_EXPECT_END_DOCUMENT;
                continue;
            }
            if (hasStatus(STATUS_EXPECT_OBJECT_VALUE)) {
                Number number = reader.readNumber();
                String key = stack.pop(StackValue.TYPE_OBJECT_KEY).valueAsKey();
                stack.peek(StackValue.TYPE_OBJECT).valueAsObject().put(key, number);
                status = STATUS_EXPECT_COMMA | STATUS_EXPECT_END_OBJECT;
                continue;
            }
            if (hasStatus(STATUS_EXPECT_ARRAY_VALUE)) {
                Number number = reader.readNumber();
                stack.peek(StackValue.TYPE_ARRAY).valueAsArray().add(number);
                status = STATUS_EXPECT_COMMA | STATUS_EXPECT_END_ARRAY;
                continue;
            }
            throw new JsonParseException("Unexpected number.", reader.reader.readed);

        case STRING:
            if (hasStatus(STATUS_EXPECT_SINGLE_VALUE)) {
                // single string:
                String str = reader.readString();
                stack.push(StackValue.newJsonSingle(str));
                status = STATUS_EXPECT_END_DOCUMENT;
                continue;
            }
            if (hasStatus(STATUS_EXPECT_OBJECT_KEY)) {
                String str = reader.readString();
                stack.push(StackValue.newJsonObjectKey(str));
                status = STATUS_EXPECT_COLON;
                continue;
            }
            if (hasStatus(STATUS_EXPECT_OBJECT_VALUE)) {
                String str = reader.readString();
                String key = stack.pop(StackValue.TYPE_OBJECT_KEY).valueAsKey();
                stack.peek(StackValue.TYPE_OBJECT).valueAsObject().put(key, str);
                status = STATUS_EXPECT_COMMA | STATUS_EXPECT_END_OBJECT;
                continue;
            }
            if (hasStatus(STATUS_EXPECT_ARRAY_VALUE)) {
                String str = reader.readString();
                stack.peek(StackValue.TYPE_ARRAY).valueAsArray().add(str);
                status = STATUS_EXPECT_COMMA | STATUS_EXPECT_END_ARRAY;
                continue;
            }
            throw new JsonParseException("Unexpected char \'\"\'.", reader.reader.readed);

        case SEP_COLON: // :
            if (status == STATUS_EXPECT_COLON) {
                status = STATUS_EXPECT_OBJECT_VALUE | STATUS_EXPECT_BEGIN_OBJECT | STATUS_EXPECT_BEGIN_ARRAY;
                continue;
            }
            throw new JsonParseException("Unexpected char \':\'.", reader.reader.readed);

        case SEP_COMMA: // ,
            if (hasStatus(STATUS_EXPECT_COMMA)) {
                if (hasStatus(STATUS_EXPECT_END_OBJECT)) {
                    status = STATUS_EXPECT_OBJECT_KEY;
                    continue;
                }
                if (hasStatus(STATUS_EXPECT_END_ARRAY)) {
                    status = STATUS_EXPECT_ARRAY_VALUE | STATUS_EXPECT_BEGIN_ARRAY | STATUS_EXPECT_BEGIN_OBJECT;
                    continue;
                }
            }
            throw new JsonParseException("Unexpected char \',\'.", reader.reader.readed);

        case END_ARRAY:
            if (hasStatus(STATUS_EXPECT_END_ARRAY)) {
                StackValue array = stack.pop(StackValue.TYPE_ARRAY);
                if (stack.isEmpty()) {
                    stack.push(array);
                    status = STATUS_EXPECT_END_DOCUMENT;
                    continue;
                }
                int type = stack.getTopValueType();
                if (type == StackValue.TYPE_OBJECT_KEY) {
                    // key: [ CURRENT ] ,}
                    String key = stack.pop(StackValue.TYPE_OBJECT_KEY).valueAsKey();
                    stack.peek(StackValue.TYPE_OBJECT).valueAsObject().put(key, array.value);
                    status = STATUS_EXPECT_COMMA | STATUS_EXPECT_END_OBJECT;
                    continue;
                }
                if (type == StackValue.TYPE_ARRAY) {
                    // xx, xx, [CURRENT] ,]
                    stack.peek(StackValue.TYPE_ARRAY).valueAsArray().add(array.value);
                    status = STATUS_EXPECT_COMMA | STATUS_EXPECT_END_ARRAY;
                    continue;
                }
            }
            throw new JsonParseException("Unexpected char: \']\'.", reader.reader.readed);

        case END_OBJECT:
            if (hasStatus(STATUS_EXPECT_END_OBJECT)) {
                StackValue object = stack.pop(StackValue.TYPE_OBJECT);
                if (stack.isEmpty()) {
                    // root object:
                    stack.push(object);
                    status = STATUS_EXPECT_END_DOCUMENT;
                    continue;
                }
                int type = stack.getTopValueType();
                if (type == StackValue.TYPE_OBJECT_KEY) {
                    String key = stack.pop(StackValue.TYPE_OBJECT_KEY).valueAsKey();
                    stack.peek(StackValue.TYPE_OBJECT).valueAsObject().put(key, object.value);
                    status = STATUS_EXPECT_COMMA | STATUS_EXPECT_END_OBJECT;
                    continue;
                }
                if (type == StackValue.TYPE_ARRAY) {
                    stack.peek(StackValue.TYPE_ARRAY).valueAsArray().add(object.value);
                    status = STATUS_EXPECT_COMMA | STATUS_EXPECT_END_ARRAY;
                    continue;
                }
            }
            throw new JsonParseException("Unexpected char: \'}\'.", reader.reader.readed);

        case END_DOCUMENT:
            if (hasStatus(STATUS_EXPECT_END_DOCUMENT)) {
                StackValue v = stack.pop();
                if (stack.isEmpty()) {
                    return v.value;
                }
            }
            throw new JsonParseException("Unexpected EOF.", reader.reader.readed);

        case BEGIN_ARRAY:
            if (hasStatus(STATUS_EXPECT_BEGIN_ARRAY)) {
                stack.push(StackValue.newJsonArray(this.jsonArrayFactory.createJsonArray()));
                status = STATUS_EXPECT_ARRAY_VALUE | STATUS_EXPECT_BEGIN_OBJECT | STATUS_EXPECT_BEGIN_ARRAY | STATUS_EXPECT_END_ARRAY;
                continue;
            }
            throw new JsonParseException("Unexpected char: \'[\'.", reader.reader.readed);

        case BEGIN_OBJECT:
            if (hasStatus(STATUS_EXPECT_BEGIN_OBJECT)) {
                stack.push(StackValue.newJsonObject(this.jsonObjectFactory.createJsonObject()));
                status = STATUS_EXPECT_OBJECT_KEY | STATUS_EXPECT_BEGIN_OBJECT | STATUS_EXPECT_END_OBJECT;
                continue;
            }
            throw new JsonParseException("Unexpected char: \'{\'.", reader.reader.readed);
        }
    }
} }
</code></pre></div></div>
:ET