I"M<p>https://doc.oschina.net/grpc?t=60133
https://chai2010.cn/advanced-go-programming-book/ch4-rpc/ch4-05-grpc-hack.html
https://blog.didiyun.com/index.php/2018/12/12/grpc-golang-1/</p>

<p>gRPCæ˜¯ç”±Googleä¸»å¯¼å¼€å‘çš„RPCæ¡†æ¶ï¼Œä½¿ç”¨HTTP/2åè®®å¹¶ç”¨ProtoBufä½œä¸ºåºåˆ—åŒ–å·¥å…·ã€‚å…¶å®¢æˆ·ç«¯æä¾›Objective-Cã€Javaæ¥å£ï¼ŒæœåŠ¡å™¨ä¾§åˆ™æœ‰Javaã€Golangã€C++ç­‰æ¥å£ï¼Œä»è€Œä¸ºç§»åŠ¨ç«¯ï¼ˆiOS/Androiï¼‰åˆ°æœåŠ¡å™¨ç«¯é€šè®¯æä¾›äº†ä¸€ç§è§£å†³æ–¹æ¡ˆã€‚ å½“ç„¶åœ¨å½“ä¸‹çš„ç¯å¢ƒä¸‹ï¼Œè¿™ç§è§£å†³æ–¹æ¡ˆæ›´çƒ­é—¨çš„æ–¹å¼æ˜¯RESTFull APIæ¥å£ã€‚è¯¥æ–¹å¼éœ€è¦è‡ªå·±å»é€‰æ‹©ç¼–ç æ–¹å¼ã€æœåŠ¡å™¨æ¶æ„ã€è‡ªå·±æ­å»ºæ¡†æ¶ï¼ˆJSON-RPCï¼‰ã€‚gRPCå®˜æ–¹å¯¹RESTçš„å£°éŸ³æ˜¯ï¼š</p>

<p>å’ŒRESTä¸€æ ·éµå¾ªHTTPåè®®(æ˜ç¡®çš„è¯´æ˜¯HTTP/2)ï¼Œä½†æ˜¯gRPCæä¾›äº†å…¨åŒå·¥æµ
å’Œä¼ ç»Ÿçš„RESTä¸åŒçš„æ˜¯gRPCä½¿ç”¨äº†é™æ€è·¯å¾„ï¼Œä»è€Œæé«˜æ€§èƒ½
ç”¨ä¸€äº›æ ¼å¼åŒ–çš„é”™è¯¯ç ä»£æ›¿äº†HTTPçš„çŠ¶æ€ç æ›´å¥½çš„æ ‡ç¤ºé”™è¯¯
è‡³äºæ˜¯å¦è¦é€‰æ‹©ç”¨gRPCã€‚å¯¹äºå·²ç»æœ‰ä¸€å¥—æ–¹æ¡ˆçš„å›¢é˜Ÿï¼Œå¯ä»¥å‚è€ƒä¸‹ã€‚å¦‚æœæ˜¯ä»å¤´æ¥åšï¼Œå¯ä»¥è€ƒè™‘ä¸‹gRPCæä¾›çš„ä»å®¢æˆ·ç«¯åˆ°æœåŠ¡å™¨çš„æ•´å¥—è§£å†³æ–¹æ¡ˆï¼Œè¿™æ ·ä¸ç”¨å®¢æˆ·ç«¯å»å®ç°httpçš„è¯·æ±‚ä¼šè¯ï¼ŒJSONç­‰çš„è§£æï¼ŒæœåŠ¡å™¨ç«¯ä¹Ÿæœ‰ç°æˆçš„æ¡†æ¶ç”¨ã€‚ä»15å¹´3æœˆåˆ°ç°åœ¨gRPCä¹Ÿå‘å±•äº†ä¸€å¹´äº†ï¼Œæ…¢æ…¢è¶‹äºæˆç†Ÿã€‚ä¸‹é¢æˆ‘ä»¬å°±ä»¥gRPCçš„Golangç‰ˆæœ¬çœ‹ä¸‹å…¶åœ¨golangä¸Šé¢çš„è¡¨ç°ã€‚è‡³äºæœåŠ¡ç«¯çš„RPCï¼Œæ„Ÿè§‰golangæ ‡å‡†åº“çš„RPCæ¡†æ¶åŸºæœ¬å¤Ÿç”¨äº†,æ²¡å¿…è¦å†å»ç”¨å¦ä¸€å¥—æ–¹æ¡ˆã€‚
<!-- more --></p>
<ol>
  <li>å®‰è£…protobuf
è™½ç„¶gRPCä¹Ÿæ”¯æŒprotobuf2.xï¼Œä½†æ˜¯å»ºè®®è¿˜æ˜¯ä½¿ç”¨protobuf3.xï¼Œå°½ç®¡è¿˜æ²¡æœ‰æ­£å¼ç‰ˆæœ¬ï¼Œä¸è¿‡golangç‰ˆæœ¬åŸºæœ¬æ²¡æœ‰ä»€ä¹ˆé—®é¢˜ï¼Œå¦å¤–3.xå®˜æ–¹æ”¯æŒäº†Objective-Cï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ä»¬ä½¿ç”¨gRPCçš„åˆè¡·ï¼šæä¾›ä¸€ä¸ªç§»åŠ¨ç«¯åˆ°æœåŠ¡å™¨çš„è§£å†³æ–¹æ¡ˆã€‚å»åˆ°Protocol Buffersä¸‹è½½æœ€æ–°ç‰ˆæœ¬ï¼ˆVersion3.0.0 beta2ï¼‰ï¼Œç„¶åè§£å‹åˆ°æœ¬åœ°ã€‚æœ¬åœ°éœ€è¦å·²ç»å®‰è£…å¥½autoconf automake libtool.rpmç³»åˆ—ï¼ˆfedora/centos/redheatï¼‰å¯ä»¥ç”¨yumå®‰è£…ã€‚Macä¸Šå¯ä»¥ç”¨brewè¿›è¡Œå®‰è£…</li>
</ol>

<p>brew install autoconf automake libtool
ç„¶åæ‰§è¡Œ</p>

<p>./configure â€“prefix=your_pb_install_path
æ¥ç€</p>

<p>make 
make install
set your_pb_install_path to your $PATH
æ£€æŸ¥æ˜¯å¦å®‰è£…å®Œæˆ</p>

<p>protoc â€“version
libprotoc 3.0.0
ç„¶åå®‰è£…golang protobufç›´æ¥ä½¿ç”¨golangçš„getå³å¯</p>

<p>go get -u github.com/golang/protobuf/proto // golang protobuf åº“
go get -u github.com/golang/protobuf/protoc-gen-go //protoc â€“go_out å·¥å…·</p>
<ol>
  <li>å®‰è£…gRPC-go
gRPC-goå¯ä»¥é€šè¿‡golang çš„getå‘½ä»¤ç›´æ¥å®‰è£…ï¼Œéå¸¸æ–¹ä¾¿ã€‚</li>
</ol>

<p>go get google.golang.org/grpc
è¿™é‡Œå¤§å®¶å¯èƒ½æ¯”è¾ƒå¥‡æ€ªï¼Œä¸ºä»€ä¹ˆgRPC-goåœ¨githubçš„åœ°å€æ˜¯â€https://github.com/grpc/grpc-goâ€,ä½†æ˜¯ä¸ºä»€ä¹ˆè¦ç”¨â€œgoogle.golang.org/grpcâ€è¿›è¡Œå®‰è£…å‘¢ï¼Ÿåº”è¯¥grpcåŸæœ¬æ˜¯googleå†…éƒ¨çš„é¡¹ç›®ï¼Œå½’å±golangï¼Œå°±æ”¾åœ¨äº†google.golang.orgä¸‹é¢äº†ï¼Œåæ¥å¯¹å¤–å¼€æ”¾ï¼Œåˆå°†å…¶è¿ç§»åˆ°githubä¸Šé¢äº†ï¼Œåˆå› ä¸ºgolangæ¯”è¾ƒå‘çˆ¹çš„importè·¯å¾„è§„åˆ™ï¼Œæ‰€ä»¥å°±éƒ½æ²¡æœ‰æ”¹è·¯å¾„åäº†ã€‚</p>

<p>å…ˆçœ‹PBçš„æè¿°ï¼š</p>

<p>syntax = â€œproto3â€;</p>

<p>option objc_class_prefix = â€œHLWâ€;</p>

<p>package helloworld;</p>

<p>// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}</p>

<p>// The request message containing the userâ€™s name.
message HelloRequest {
  string name = 1;
}</p>

<p>// The response message containing the greetings
message HelloReply {
  string message = 1;
}
è¿™é‡Œå®šä¹‰äº†ä¸€ä¸ªæœåŠ¡Greeterï¼Œå…¶ä¸­æœ‰ä¸ªAPI SayHelloã€‚å…¶æ¥å—å‚æ•°ä¸ºHelloRequestç±»å‹ï¼Œè¿”å›HelloReplyç±»å‹ã€‚è¿™é‡ŒHelloRequestå’ŒHelloReplyå°±æ˜¯æ™®é€šçš„PBå®šä¹‰</p>

<p>æœåŠ¡å®šä¹‰ä¸ºï¼š</p>

<p>// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}
serviceå®šä¹‰äº†ä¸€ä¸ªserverã€‚å…¶ä¸­çš„æ¥å£å¯ä»¥æ˜¯å››ç§ç±»å‹</p>

<p>rpc GetFeature(Point) returns (Feature) {}
ç±»ä¼¼æ™®é€šçš„å‡½æ•°è°ƒç”¨ï¼Œå®¢æˆ·ç«¯å‘é€è¯·æ±‚Pointåˆ°æœåŠ¡å™¨ï¼ŒæœåŠ¡å™¨è¿”å›ç›¸åº”Feature.
rpc ListFeatures(Rectangle) returns (stream Feature) {}
å®¢æˆ·ç«¯å‘èµ·ä¸€æ¬¡è¯·æ±‚ï¼ŒæœåŠ¡å™¨ç«¯è¿”å›ä¸€ä¸ªæµå¼æ•°æ®ï¼Œæ¯”å¦‚ä¸€ä¸ªæ•°ç»„ä¸­çš„é€ä¸ªå…ƒç´ 
rpc RecordRoute(stream Point) returns (RouteSummary) {}
å®¢æˆ·ç«¯å‘èµ·çš„è¯·æ±‚æ˜¯ä¸€ä¸ªæµå¼çš„æ•°æ®ï¼Œæ¯”å¦‚æ•°ç»„ä¸­çš„é€ä¸ªå…ƒç´ ï¼ŒæœåŠ¡å™¨è¿”å›ä¸€ä¸ªç›¸åº”
rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
å®¢æˆ·ç«¯å‘èµ·çš„è¯·æ±‚æ˜¯ä¸€ä¸ªæµå¼æ•°æ®ï¼Œæ¯”å¦‚æ•°ç»„ä¸­çš„é€ä¸ªå…ƒç´ ï¼ŒäºŒæœåŠ¡å™¨è¿”å›çš„ä¹Ÿæ˜¯ä¸€ä¸ªç±»ä¼¼çš„æ•°æ®ç»“æ„
åé¢ä¸‰ç§å¯ä»¥å‚è€ƒå®˜æ–¹çš„route_guideç¤ºä¾‹ã€‚</p>

<p>ä½¿ç”¨protocå‘½ä»¤ç”Ÿæˆç›¸å…³æ–‡ä»¶ï¼š</p>

<p>protoc â€“go_out=plugins=grpc:. helloworld.proto
ls
helloworld.pb.go    helloworld.proto
ç”Ÿæˆå¯¹åº”çš„pb.goæ–‡ä»¶ã€‚è¿™é‡Œç”¨äº†pluginsé€‰é¡¹ï¼Œæä¾›å¯¹grpcçš„æ”¯æŒï¼Œå¦åˆ™ä¸ä¼šç”ŸæˆServiceçš„æ¥å£ã€‚</p>

<p>3.2 æœåŠ¡å™¨ç«¯ç¨‹åº
ç„¶åç¼–è¾‘æœåŠ¡å™¨ç«¯ç¨‹åºï¼š</p>

<p>package main</p>

<p>import (
    â€œlogâ€
    â€œnetâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pb "your_path_to_gen_pb_dir/helloworld"
"golang.org/x/net/context"
"google.golang.org/grpc" )
</code></pre></div></div>

<p>const (
    port = â€œ:50051â€
)</p>

<p>// server is used to implement helloworld.GreeterServer.
type server struct{}</p>

<p>// SayHello implements helloworld.GreeterServer
func (s <em>server) SayHello(ctx context.Context, in *pb.HelloRequest) (</em>pb.HelloReply, error) {
    return &amp;pb.HelloReply{Message: â€œHello â€œ + in.Name}, nil
}</p>

<p>func main() {
    lis, err := net.Listen(â€œtcpâ€, port)
    if err != nil {
        log.Fatalf(â€œfailed to listen: %vâ€, err)
    }
    s := grpc.NewServer()
    pb.RegisterGreeterServer(s, &amp;server{})
    s.Serve(lis)
}
è¿™é‡Œé¦–å…ˆå®šä¹‰ä¸€ä¸ªserverç»“æ„ï¼Œç„¶åå®ç°SayHelloçš„æ¥å£ï¼Œå…¶å®šä¹‰åœ¨â€œyour_path_to_gen_pb_dir/helloworldâ€</p>

<p>SayHello(context.Context, <em>HelloRequest) (</em>HelloReply, error)
ç„¶åè°ƒç”¨grpc.NewServer() åˆ›å»ºä¸€ä¸ªserver sã€‚æ¥ç€æ³¨å†Œè¿™ä¸ªserver såˆ°ç»“æ„serverä¸Šé¢ pb.RegisterGreeterServer(s, &amp;server{}) æœ€åå°†åˆ›å»ºçš„net.Listenerä¼ ç»™s.Serve()ã€‚å°±å¯ä»¥å¼€å§‹ç›‘å¬å¹¶æœåŠ¡äº†ï¼Œç±»ä¼¼HTTPçš„ListenAndServeã€‚</p>

<p>3.3 å®¢æˆ·ç«¯ç¨‹åº
å®¢æˆ·ç«¯ç¨‹åºï¼š</p>

<p>package main</p>

<p>import (
    â€œlogâ€
    â€œosâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pb "your_path_to_gen_pb_dir/helloworld"
"golang.org/x/net/context"
"google.golang.org/grpc" )
</code></pre></div></div>

<p>const (
    address     = â€œlocalhost:50051â€
    defaultName = â€œworldâ€
)</p>

<p>func main() {
    // Set up a connection to the server.
    conn, err := grpc.Dial(address, grpc.WithInsecure())
    if err != nil {
        log.Fatalf(â€œdid not connect: %vâ€, err)
    }
    defer conn.Close()
    c := pb.NewGreeterClient(conn)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Contact the server and print out its response.
name := defaultName
if len(os.Args) &gt; 1 {
    name = os.Args[1]
}
r, err := c.SayHello(context.Background(), &amp;pb.HelloRequest{Name: name})
if err != nil {
    log.Fatalf("could not greet: %v", err)
}
log.Printf("Greeting: %s", r.Message) } è¿™é‡Œé€šè¿‡pb.NewGreeterClient()ä¼ å…¥ä¸€ä¸ªconnåˆ›å»ºä¸€ä¸ªclientï¼Œç„¶åç›´æ¥è°ƒç”¨clientä¸Šé¢å¯¹åº”çš„æœåŠ¡å™¨çš„æ¥å£
</code></pre></div></div>

<p>SayHello(context.Context, <em>HelloRequest) (</em>HelloReply, error)
æ¥å£ï¼Œè¿”å›*HelloReply å¯¹è±¡ã€‚</p>

<p>å…ˆè¿è¡ŒæœåŠ¡å™¨ï¼Œåœ¨è¿è¡Œå®¢æˆ·ç«¯ï¼Œå¯ä»¥çœ‹åˆ°ã€‚</p>

<p>./greeter_server &amp;</p>

<p>./greeter_client
2016/03/10 21:42:19 Greeting: Hello world</p>

<p>grpcï¼Œå®ƒæ˜¯åŸºäºprotobuf è¿™ä¸ªç”±google æ¨å‡ºæ¥ï¼Œå·ç§°æ¯”json æ›´æ–¹ä¾¿ã€æ›´å¿«é€Ÿã€æ›´ç®€çŸ­çš„ä¸€ç§æ²Ÿé€šæ ¼å¼ã€‚</p>

<p>grpc å…¶å®é‡ç‚¹å¾ˆç®€å•ï¼Œå°±æ˜¯ä½ å®šä¹‰å‡ºæ¥çš„ä¸œè¥¿ï¼Œä¸åªä»£è¡¨æ ¼å¼ï¼Œä¹Ÿä»£è¡¨ä½ ä¼ºæœå™¨çš„æ¥å£ï¼Œæ‰€ä»¥ä¸ç®¡åœ¨client ç«¯æˆ–server ç«¯ï¼Œåªè¦éµç…§è¿™ä¸ªgrpc æ ¼å¼ä¸‹å»å®ä½œï¼Œapi å°±æ¥èµ·æ¥ï¼Œä¹Ÿçœå»ä¹‹å‰ç”¨restful api ï¼Œserver ç«¯è¦å†™ä¸€å †router ï¼Œä¹Ÿä¸ç”¨å¦å¤–å†™æ–‡ä»¶ï¼Œåˆšå¥½ç¬¦åˆä¸€å¥è¯ã€ç¨‹å¼ç å³æ–‡ä»¶ã€ï¼Œå¤§å®¶éµç…§grpc çš„å¥‘çº¦å„è‡ªå»å®ä½œã€‚</p>

<p>å†å¼€å§‹ä»‹ç»ä¹‹å‰ï¼Œæœ‰ä¸€äº›åŸºç¡€å·¥å…·è¦å…ˆå®‰è£…ï¼Œé¦–å…ˆæ‰§è¡Œä¸‹é¢æŒ‡ä»¤ï¼Œå®‰è£…grpc</p>

<p>go get -u google.golang.org/grpc</p>

<p>å†æ¥å®‰è£…</p>

<p>go get -u github.com/golang/protobuf/protoc-gen-go</p>

<p>grpc å®£å‘Š
æ¥ä¸‹æ¥å°±èƒ½æ¥ä»‹ç»æ­£é¢˜ï¼Œæˆ‘ä»¬æ¥ä»‹ç»ä¸€ä¸‹ï¼ŒåŸºç¡€çš„grpc æ ¼å¼å®£å‘Š</p>

<p>//é€™é‚Šä½¿ç”¨ proto3 çš„æ ¼å¼ ä¹Ÿå°±æ˜¯ protobuf ç¬¬ä¸‰ç‰ˆçš„æ„æ€ï¼Œè¦æ³¨æ„ï¼Œç¬¬äºŒç‰ˆè·Ÿç¬¬ä¸‰ç‰ˆæœ‰ä¸€äº›èªæ³•ä¸Šçš„å·®ç•°å–”
syntax = â€œproto3â€;</p>

<p>package example;</p>

<p>//å®šç¾©äº†ä¸€å€‹ EchoServer
service EchoServer {
    rpc Echo (EchoRequest) returns(EchoReply){}
}</p>

<p>//å®šç¾©äº† Echo Server EchoRequest
message EchoRequest {
    string message = 1;
}</p>

<p>//å®šç¾©äº† Echo Response
//é€™è£¡å¤šå›å‚³äº†ä¸€å€‹ å«åš unixtime
message EchoReply {
    string message = 1;
    int64 unixtime = 2;
}
ä¸Šé¢è¿™æ ·å°±æ˜¯ä¸€ä¸ªç®€æ˜“çš„grpcçš„å®£å‘Šï¼Œæ›´å¤šå‹åˆ«ä¸Šå¯ä»¥å‚é˜…å®˜ç½‘</p>

<p>æ¥ä¸‹æ¥ï¼Œåœ¨ä½ æ’°å†™è¿™åªæ¡£æ¡ˆçš„åœ°æ–¹ï¼Œæ‰§è¡Œ</p>

<p>protoc â€“go_out=plugins=grpc:. *.proto</p>

<p>å°±ä¼šçœ‹åˆ°äº§ç”Ÿå‡ºä¸€ä¸ªå¦ä¸€ä¸ªæœ‰å¸¦pb.go çš„æ¡£æ¡ˆï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬åˆ†åˆ«æ¥å®ä½œclient ã€server ç«¯</p>

<p>grpcå®¢æˆ·
func main() {
	conn, err := grpc.Dial(â€œlocalhost:9999â€, grpc.WithInsecure())
	if err != nil {
		log.Fatalf(â€œé€£ç·šå¤±æ•—ï¼š%vâ€, err)
	}
	defer conn.Close()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c := pb.NewEchoClient(conn)

r, err := c.Echo(context.Background(), &amp;pb.EchoRequest{Msg: "HI HI HI HI"})
if err != nil {
	log.Fatalf("ç„¡æ³•åŸ·è¡Œ Plus å‡½å¼ï¼š%v", err)
}
log.Printf("å›å‚³çµæœï¼š%s , æ™‚é–“:%d", r.Msg, r.Unixtime)
</code></pre></div></div>

<p>}
grpcæœåŠ¡å™¨</p>

<p>type EchoServer struct{}</p>

<p>func (e *EchoServer) Echo(ctx context.Context, req *pb.EchoRequest) (resp *pb.EchoReply, err error) {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log.Printf("receive client request, client send:%s\n", req.Msg)
return &amp;pb.EchoReply{
	Msg:      req.Msg,
	Unixtime: time.Now().Unix(),
}, nil
</code></pre></div></div>

<p>}</p>

<p>func main() {
	apiListener, err := net.Listen(â€œtcpâ€, â€œ:9999â€)
	if err != nil {
		log.Println(err)
		return
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// è¨»å†Š grpc
es := &amp;EchoServer{}

grpc := grpc.NewServer()
//pb.Re(grpc, es)
pb.RegisterEchoServer(grpc, es)

reflection.Register(grpc)
if err := grpc.Serve(apiListener); err != nil {
	log.Fatal(" grpc.Serve Error: ", err)
	return
} } æœ€ååªè¦å…ˆå¯åŠ¨grpc serverï¼Œå†æ‰§è¡Œgrpc client ï¼Œå°±èƒ½çœ‹åˆ°æœ‰ç›¸å¯¹åº”çš„è®¯æ¯è¿æ¥ä¸Šäº†ã€‚
</code></pre></div></div>

<p>grpcæ˜¯ä¸€ä¸ªé€šç”¨çš„rpcæ¡†æ¶ï¼Œç”¨googleå®ç°ï¼Œå½“ç„¶ä¹Ÿæœ‰goè¯­è¨€çš„ç‰ˆæœ¬ã€‚åœ¨å·¥ä½œä¸­ä¸»è¦ç”¨åˆ°è¿™ä¸ªåº“ï¼Œæ‰€ä»¥çœ‹çœ‹æºç åŠ å¼ºè‡ªå·±å¯¹æ¡†æ¶çš„äº†è§£ã€‚ç›®å‰æ¥è¯´ä¸»è¦åˆ†æçš„éƒ½ä»¥goç‰ˆæœ¬ä¸ºä¸»(å¹¶æ²¡æœ‰çœ‹å…¶ä»–è¯­è¨€ç‰ˆæœ¬).ç”±äºä¸ªäººæ°´å¹³æœ‰é™ï¼Œä»£ç ä¸­çš„æœ‰äº›æ€æƒ³ä¹Ÿæ˜¯ä¸ªäººæ£æµ‹ï¼Œéš¾å…æœ‰äº›é”™è¯¯ï¼Œå¦‚æœå‘ç°é”™è¯¯ï¼Œè¿˜æœ›å¸®å¿™æŒ‡å‡ºã€‚</p>

<p>2 æºç ç›®å½•æµè§ˆ
grpcä½¿ç”¨protobufï¼ˆgoogleçš„åºåˆ—åŒ–æ¡†æ¶ï¼‰ä½œä¸ºé€šä¿¡åè®®ï¼Œåº•å±‚ä¸Šä½¿ç”¨http2ä½œä¸ºå…¶ä¼ è¾“åè®®ï¼Œgrpcæºç ä¸­è‡ªå·±å®ç°äº†http2çš„æœåŠ¡ç«¯è·Ÿå®¢æˆ·ç«¯ï¼Œè€Œå¹¶æ²¡æœ‰ç”¨net/httpåŒ…ã€‚http2æœ‰å¾ˆå¤šç‰¹æ€§èƒ½å¤Ÿé«˜æ•ˆçš„ä¼ è¾“æ•°æ®ï¼Œå…·ä½“ç‰¹ç‚¹å¯ä»¥çœ‹ç›¸å…³é“¾æ¥è¯¦ç»†äº†è§£ã€‚</p>

<p>çœ‹åå­—å¤§æ¦‚èƒ½çœ‹å‡ºè¿™äº›ç›®å½•ä¸­ä»£ç æ˜¯å“ªäº›å…³ç³»ï¼Œdocumentationç›®å½•æ˜¯å­˜æ”¾ä¸€äº›æ–‡æ¡£ï¼Œbenchmarkæ˜¯å‹æµ‹ï¼Œcredentialsæ˜¯éªŒè¯ï¼Œexamplesæ˜¯ä¾‹å­ï¼Œgrpclbæ˜¯è´Ÿè½½å‡è¡¡ï¼Œgrpclogæ˜¯æ—¥å¿—,healthæ˜¯æœåŠ¡å¥åº·æ£€æŸ¥,metadataæ˜¯å…ƒæ•°æ®(ç”¨æˆ·å®¢æˆ·ç«¯ç»™æœåŠ¡ç«¯ä¼ é€ä¸€äº›ç‰¹æ®Šæ•°æ®ï¼Œå…·ä½“å¯ä»¥çœ‹ç›¸å…³é“¾æ¥),namingç›®å½•æ˜¯æä¾›åå­—æœåŠ¡éœ€è¦å®ç°çš„æ¥å£(ç›¸å½“äºä¸€ä¸ªdns),statsæ˜¯ç»Ÿè®¡ä¿¡æ¯,transport ä¼ è¾“å±‚å®ç°(ä¸»è¦æ˜¯http2çš„å®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯æ—¶å®ç°, ä¸ä¼šè¯¦ç»†è¯´è¿™ä¸ªç›®å½•),è¿˜æœ‰å…¶ä»–ä¸€äº›æ¯”è¾ƒæ— å…³ç´§è¦çš„ç›®å½•å°±ä¸ä¸€ä¸€ä»‹ç»äº†ã€‚</p>

<p>3 å®¢æˆ·ç«¯
åœ¨exampleç›®å½•ä¸­æœ‰ä¸¤ä¸ªæ¯”è¾ƒç®€å•çš„ä¾‹å­ï¼Œå°±å…ˆä»è¿™é‡Œå…¥æ‰‹å§ï¼Œ</p>

<p>func main() {
  // Set up a connection to the server.
  //å»ºç«‹ä¸€ä¸ªé“¾æ¥
  conn, err := grpc.Dial(address, grpc.WithInsecure())
  if err != nil {
    log.Fatalf(â€œdid not connect: %vâ€, err)
  }
  defer conn.Close()
  c := pb.NewGreeterClient(conn)</p>

<p>// Contact the server and print out its response.
  name := defaultName
  if len(os.Args) &gt; 1 {
    name = os.Args[1]
  }
  //è°ƒç”¨å‡½æ•°
  r, err := c.SayHello(context.Background(), &amp;pb.HelloRequest{Name: name})
  if err != nil {
    log.Fatalf(â€œcould not greet: %vâ€, err)
  }
  log.Printf(â€œGreeting: %sâ€, r.Message)
}
grcp.WithInsecureå‚æ•°æ˜¯åœ¨é“¾æ¥httpsæœåŠ¡ç«¯æ—¶ä¸ç”¨æ£€æŸ¥æœåŠ¡ç«¯çš„è¯ä¹¦(è¦æ˜¯ä½ ç›¸ä¿¡æœåŠ¡ç«¯å°±ä¸ç”¨æ£€æŸ¥).Dialå‡½æ•°å¯¹æœåŠ¡ç«¯å»ºç«‹ä¸€ä¸ªè¿æ¥ï¼Œ grpc.Dialå‡½æ•°:</p>

<p>func DialContext(ctx context.Context, target string, opts â€¦DialOption) (conn <em>ClientConn, err error) {
  cc := &amp;ClientConn{
    target: target,
    conns:  make(map[Address]</em>addrConn),
  }
  cc.ctx, cc.cancel = context.WithCancel(context.Background())
  defer func() {
    select {
    case &lt;-ctx.Done():
      conn, err = nil, ctx.Err()
    default:
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if err != nil {
  cc.Close()
}   }()
</code></pre></div></div>

<p>//è®¾ç½®grpcçš„å„ç§é€‰é¡¹
  for _, opt := range opts {
    opt(&amp;cc.dopts)
  }</p>

<p>// Set defaults.
  if cc.dopts.codec == nil {
    //é»˜è®¤ç”¨protobufç¼–è§£ç 
    cc.dopts.codec = protoCodec{}
  }
  if cc.dopts.bs == nil {
    cc.dopts.bs = DefaultBackoffConfig
  }
  creds := cc.dopts.copts.TransportCredentials
  //éªŒè¯ä¿¡æ¯
  if creds != nil &amp;&amp; creds.Info().ServerName != â€œâ€ {
    cc.authority = creds.Info().ServerName
  } else {
    colonPos := strings.LastIndex(target, â€œ:â€)
    if colonPos == -1 {
      colonPos = len(target)
    }
    cc.authority = target[:colonPos]
  }
  var ok bool
  waitC := make(chan error, 1)
  //å¯åŠ¨ä¸€ä¸ªgoroutineå¯åŠ¨åå­—æœåŠ¡å™¨(ç±»ä¼¼dns)
  go func() {
    var addrs []Address
    if cc.dopts.balancer == nil {
      // Connect to target directly if balancer is nil.
      // å¦‚æœæ²¡è®¾ç½®è´Ÿè½½å‡è¡¡å™¨ï¼Œåˆ™ç›´æ¥è¿æ¥
      addrs = append(addrs, Address{Addr: target})
    } else {
      var credsClone credentials.TransportCredentials
      if creds != nil {
        credsClone = creds.Clone()
      }
      config := BalancerConfig{
        DialCreds: credsClone,
      }
      //å¯åŠ¨è´Ÿè½½å‡è¡¡æœåŠ¡
      if err := cc.dopts.balancer.Start(target, config); err != nil {
        waitC &lt;- err
        return
      }
      ch := cc.dopts.balancer.Notify()
      if ch == nil {
        // There is no name resolver installed.
        addrs = append(addrs, Address{Addr: target})
      } else {
        addrs, ok = &lt;-ch
        if !ok || len(addrs) == 0 {
          waitC &lt;- errNoAddr
          return
        }
      }
    }
    for _, a := range addrs {
      //ç»™æ¯ä¸ªåœ°å€ä¸€ä¸ªconnï¼Œè¿æ¥æ± 
      if err := cc.resetAddrConn(a, false, nil); err != nil {
        waitC &lt;- err
        return
      }
    }
    close(waitC)
  }()
  var timeoutCh &lt;-chan time.Time
  if cc.dopts.timeout &gt; 0 {
    timeoutCh = time.After(cc.dopts.timeout)
  }
  select {
  case &lt;-ctx.Done():
    return nil, ctx.Err()
  case err := &lt;-waitC:
    if err != nil {
      return nil, err
    }
  case &lt;-timeoutCh:
    return nil, ErrClientConnTimeout
  }
  // If balancer is nil or balancer.Notify() is nil, ok will be false here.
  // The lbWatcher goroutine will not be created.
  if ok {
    go cc.lbWatcher()
  }
  return cc, nil
}
é€šè¿‡dialè¿™ä¸ªå‡½æ•°ï¼Œgrpcå·²ç»å»ºç«‹äº†åˆ°æœåŠ¡ç«¯çš„è¿æ¥ï¼Œå¯åŠ¨äº†è‡ªå®šä¹‰è´Ÿè½½å¹³è¡¡ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰. pb.NewGreeterClientè¿™è¡Œä»£ç æ˜¯é€šè¿‡protocå·¥å…·è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œå®ƒåŒ…ä¸€ä¸ªgrpcè¿æ¥åŒ…è£¹åœ¨ä¸€ä¸ªstructå†…æ–¹ä¾¿è°ƒç”¨ç”Ÿæˆçš„å®¢æˆ·ç«¯grpcè°ƒç”¨ä»£ç ã€‚æ¥ä¸‹æ¥grpcå®¢æˆ·ç«¯è°ƒç”¨SayHelloå‘æœåŠ¡å™¨å‘é€rpcè¯·æ±‚ã€‚</p>

<p>func (c <em>greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts â€¦grpc.CallOption) (</em>HelloReply, error) {
  out := new(HelloReply)
  //è°ƒç”¨å®é™…çš„å‘é€è¯·æ±‚å‡½æ•°
  err := grpc.Invoke(ctx, â€œ/helloworld.Greeter/SayHelloâ€, in, out, c.cc, optsâ€¦)
  if err != nil {
    return nil, err
  }
  return out, nil
}</p>

<p>//æœ€åä¸»è¦æ˜¯invokeå‡½æ•°
func invoke(ctx context.Context, method string, args, reply interface{}, cc <em>ClientConn, opts â€¦CallOption) (e error) {
  c := defaultCallInfo
  for _, o := range opts {
    //è°ƒç”¨ä¹‹å‰çš„hook
    if err := o.before(&amp;c); err != nil {
      return toRPCErr(err)
    }
  }
  defer func() {
    for _, o := range opts {
      //æ‰§è¡Œå®Œåçš„hook
      o.after(&amp;c)
    }
  }()
  //traceç›¸å…³ä»£ç 
  if EnableTracing {
    c.traceInfo.tr = trace.New(â€œgrpc.Sent.â€+methodFamily(method), method)
    defer c.traceInfo.tr.Finish()
    c.traceInfo.firstLine.client = true
    if deadline, ok := ctx.Deadline(); ok {
      c.traceInfo.firstLine.deadline = deadline.Sub(time.Now())
    }
    c.traceInfo.tr.LazyLog(&amp;c.traceInfo.firstLine, false)
    // TODO(dsymonds): Arrange for c.traceInfo.firstLine.remoteAddr to be set.
    defer func() {
      if e != nil {
        c.traceInfo.tr.LazyLog(&amp;fmtStringer{â€œ%vâ€, []interface{}{e}}, true)
        c.traceInfo.tr.SetError()
      }
    }()
  }
  //ç»Ÿè®¡ç›¸å…³ä»£ç 
  if stats.On() {
    ctx = stats.TagRPC(ctx, &amp;stats.RPCTagInfo{FullMethodName: method})
    begin := &amp;stats.Begin{
      Client:    true,
      BeginTime: time.Now(),
      FailFast:  c.failFast,
    }
    stats.HandleRPC(ctx, begin)
  }
  defer func() {
    //ç»“æŸåçš„ç»Ÿè®¡ç›¸å…³ä»£ç 
    if stats.On() {
      end := &amp;stats.End{
        Client:  true,
        EndTime: time.Now(),
        Error:   e,
      }
      stats.HandleRPC(ctx, end)
    }
  }()
  topts := &amp;transport.Options{
    Last:  true,
    Delay: false,
  }
  for {
    var (
      err    error
      t      transport.ClientTransport
      stream *transport.Stream
      // Record the put handler from Balancer.Get(â€¦). It is called once the
      // RPC has completed or failed.
      put func()
    )
    // TODO(zhaoq): Need a formal spec of fail-fast.
    //ä¼ è¾“å±‚çš„é…ç½®
    callHdr := &amp;transport.CallHdr{
      Host:   cc.authority,
      Method: method,
    }
    if cc.dopts.cp != nil {
      callHdr.SendCompress = cc.dopts.cp.Type()
    }
    gopts := BalancerGetOptions{
      BlockingWait: !c.failFast,
    }
    //å¾—åˆ°ä¼ è¾“æˆè¿æ¥ï¼Œåœ¨http2ä¸­ä¸€ä¸ªä¼ è¾“å•ä½æ˜¯ä¸€ä¸ªæµã€‚
    t, put, err = cc.getTransport(ctx, gopts)
    if err != nil {
      // TODO(zhaoq): Probably revisit the error handling.
      if _, ok := err.(</em>rpcError); ok {
        return err
      }
      if err == errConnClosing || err == errConnUnavailable {
        if c.failFast {
          return Errorf(codes.Unavailable, â€œ%vâ€, err)
        }
        continue
      }
      // All the other errors are treated as Internal errors.
      return Errorf(codes.Internal, â€œ%vâ€, err)
    }
    if c.traceInfo.tr != nil {
      c.traceInfo.tr.LazyLog(&amp;payload{sent: true, msg: args}, true)
    }
    // å‘é€è¯·æ±‚
    stream, err = sendRequest(ctx, cc.dopts.codec, cc.dopts.cp, callHdr, t, args, topts)
    if err != nil {
      if put != nil {
        put()
        put = nil
      }
      // Retry a non-failfast RPC when
      // i) there is a connection error; or
      // ii) the server started to drain before this RPC was initiated.
      // åœ¨è¿™ä¸¤ç§æƒ…å†µä¸‹é‡è¯•ï¼Œ1 é“¾æ¥é”™è¯¯ 2 åœ¨rpcåˆå§‹åŒ–ä¹‹å‰æœåŠ¡ç«¯å·²ç»å¼€å§‹æœåŠ¡
      if _, ok := err.(transport.ConnectionError); ok || err == transport.ErrStreamDrain {
        if c.failFast {
          return toRPCErr(err)
        }
        continue
      }
      return toRPCErr(err)
    }
    //æ”¶æ¶ˆæ¯
    err = recvResponse(ctx, cc.dopts, t, &amp;c, stream, reply)
    if err != nil {
      if put != nil {
        put()
        put = nil
      }
      if _, ok := err.(transport.ConnectionError); ok || err == transport.ErrStreamDrain {
        if c.failFast {
          return toRPCErr(err)
        }
        continue
      }
      return toRPCErr(err)
    }
    if c.traceInfo.tr != nil {
      c.traceInfo.tr.LazyLog(&amp;payload{sent: false, msg: reply}, true)
    }
    //å…³é—­ä¸€ä¸ªhttp2æµ
    t.CloseStream(stream, nil)
    if put != nil {
      put()
      put = nil
    }
    //Errorfä¼šåˆ¤æ–­è¿”å›ååˆ†ok
    return Errorf(stream.StatusCode(), â€œ%sâ€, stream.StatusDesc())
  }
}
åœ¨è¿™ä¸ªå‡½æ•°æœ€ä¸»è¦æ˜¯ä¸¤ä¸ªå‡½æ•°ï¼Œä¸€ä¸ªæ˜¯sendRequest,ä¸€ä¸ªæ˜¯recvResponse,é¦–å…ˆçœ‹çœ‹sendRequestå‡½æ•°ï¼š</p>

<p>func sendRequest(ctx context.Context, codec Codec, compressor Compressor, callHdr *transport.CallHdr, t transport.ClientTransport, args interface{}, opts *transport.Options) (_ *transport.Stream, err error) {
  // åˆ›å»ºä¸€ä¸ªhttp2æµ
  stream, err := t.NewStream(ctx, callHdr)
  if err != nil {
    return nil, err
  }
  defer func() {
    if err != nil {
      // If err is connection error, t will be closed, no need to close stream here.
      if _, ok := err.(transport.ConnectionError); !ok {
        t.CloseStream(stream, err)
      }
    }
  }()
  var (
    cbuf       *bytes.Buffer
    outPayload *stats.OutPayload
  )
  //å‹ç¼©ä¸ä¸ºç©º
  if compressor != nil {
    cbuf = new(bytes.Buffer)
  }
  //ç»Ÿè®¡
  if stats.On() {
    outPayload = &amp;stats.OutPayload{
      Client: true,
    }
  }
  //ç¼–ç å¹¶å‹ç¼©æ•°æ®
  outBuf, err := encode(codec, args, compressor, cbuf, outPayload)
  if err != nil {
    return nil, Errorf(codes.Internal, â€œgrpc: %vâ€, err)
  }
  //å†™å…¥æµ
  err = t.Write(stream, outBuf, opts)
  if err == nil &amp;&amp; outPayload != nil {
    outPayload.SentTime = time.Now()
    stats.HandleRPC(ctx, outPayload)
  }
  // t.NewStream(â€¦) could lead to an early rejection of the RPC (e.g., the service/method
  // does not exist.) so that t.Write could get io.EOF from wait(â€¦). Leave the following
  // recvResponse to get the final status.
  if err != nil &amp;&amp; err != io.EOF {
    return nil, err
  }
  // Sent successfully.
  return stream, nil
}
å¯ä»¥çœ‹åˆ°è¿™ä¸ªå‡½æ•°ç›¸å½“ç®€å•ï¼Œåšäº†ä¸¤ä»¶äº‹æƒ…ï¼Œç¼–ç å‹ç¼©æ•°æ®å¹¶å‘é€.å†æ¥çœ‹çœ‹recvResponseå‡½æ•°ï¼š</p>

<p>func recvResponse(ctx context.Context, dopts dialOptions, t transport.ClientTransport, c *callInfo, stream *transport.Stream, reply interface{}) (err error) {
  // Try to acquire header metadata from the server if there is any.
  defer func() {
    if err != nil {
      if _, ok := err.(transport.ConnectionError); !ok {
        t.CloseStream(stream, err)
      }
    }
  }()
  c.headerMD, err = stream.Header()
  if err != nil {
    return
  }
  p := &amp;parser{r: stream}
  var inPayload *stats.InPayload
  if stats.On() {
    inPayload = &amp;stats.InPayload{
      Client: true,
    }
  }
  for {
    //ä¸€ç›´è¯»åˆ°æµå…³é—­
    if err = recv(p, dopts.codec, stream, dopts.dc, reply, math.MaxInt32, inPayload); err != nil {
      if err == io.EOF {
        break
      }
      return
    }
  }
  if inPayload != nil &amp;&amp; err == io.EOF &amp;&amp; stream.StatusCode() == codes.OK {
    // TODO in the current implementation, inTrailer may be handled before inPayload in some cases.
    // Fix the order if necessary.
    stats.HandleRPC(ctx, inPayload)
  }
  c.trailerMD = stream.Trailer()
  return nil
}</p>

<p>func recv(p *parser, c Codec, s *transport.Stream, dc Decompressor, m interface{}, maxMsgSize int, inPayload *stats.InPayload) error {
  //æ¥å—æ•°æ®
  pf, d, err := p.recvMsg(maxMsgSize)
  if err != nil {
    return err
  }
  if inPayload != nil {
    inPayload.WireLength = len(d)
  }
  if err := checkRecvPayload(pf, s.RecvCompress(), dc); err != nil {
    return err
  }
  if pf == compressionMade {
    //è§£å‹
    d, err = dc.Do(bytes.NewReader(d))
    if err != nil {
      return Errorf(codes.Internal, â€œgrpc: failed to decompress the received message %vâ€, err)
    }
  }
  if len(d) &gt; maxMsgSize {
    // TODO: Revisit the error code. Currently keep it consistent with java
    // implementation.
    return Errorf(codes.Internal, â€œgrpc: received a message of %d bytes exceeding %d limitâ€, len(d), maxMsgSize)
  }
  //æ•°æ®è§£ç 
  if err := c.Unmarshal(d, m); err != nil {
    return Errorf(codes.Internal, â€œgrpc: failed to unmarshal the received message %vâ€, err)
  }
  if inPayload != nil {
    inPayload.RecvTime = time.Now()
    inPayload.Payload = m
    // TODO truncate large payload.
    inPayload.Data = d
    inPayload.Length = len(d)
  }
  return nil
}
è¿™é‡Œå¯ä»¥çœ‹åˆ°ä¸€ä¸ªrecvResponå¯èƒ½ä¼šå¤„ç†å¤šä¸ªè¿”å›ï¼Œä½†æ˜¯ç¡®å®åœ¨åŒä¸€ä¸ªforå¾ªç¯ä¸­å¤„ç†çš„ï¼Œæœ‰ç‚¹å¥‡æ€ªã€‚å®¢æˆ·ç«¯ä»£ç å¤§æ¦‚å°±æ˜¯è¿™ä¸ªæµç¨‹ã€‚ä»£ç æ¥è¯´ä¸ç®—å¤ªå¤æ‚ã€‚ï¼ˆä¸»è¦ä¸é’»è¿›http2çš„å®ç°,åˆšå¼€å§‹æˆ‘å°±å»çœ‹http2ï¼Œä¸€å¤´é›¾æ°´ï¼‰ å…¶ä¸­è¿˜æœ‰é‡è¦çš„åœ°æ–¹å°±æ˜¯è´Ÿè½½å‡è¡¡ï¼Œé€šè¿‡å®ƒæˆ‘ä»¬å¯ä»¥æ ¹æ®ç®—æ³•è‡ªåŠ¨é€‰æ‹©è¦è¿æ¥çš„ipè·Ÿåœ°å€ï¼Œè¿˜æœ‰éªŒè¯çš„ä½¿ç”¨ï¼Œæ”¾åˆ°ä¸‹ä¸€ç¯‡å§</p>

<p>4 ç›¸å…³é“¾æ¥
https://github.com/grpc/grpc/blob/master/doc/load-balancing.md è´Ÿè½½å‡è¡¡
https://www.gitbook.com/book/ye11ow/http2-explained/details ä»‹ç»http2çš„ä¹¦ç±ï¼Œå†™çš„éå¸¸å¥½
http://www.grpc.io/docs/guides/concepts.html#metadata metadataä»‹ç»,åœ¨æºç çš„Documentationç›®å½•æœ‰metadataçš„è¯¦ç»†ä»‹ç»</p>

<p>golangç‰ˆæœ¬grpcæœåŠ¡ç«¯</p>

<p>2 æ³¨å†Œæµç¨‹
æƒ³è±¡ä¸€ä¸ªrpcçš„æµç¨‹, å®¢æˆ·ç«¯æŒ‡æ˜ä¸€ä¸ªå‡½æ•°çš„å‡½æ•°åè·Ÿå‚æ•°ï¼ŒæœåŠ¡ç«¯æ‰¾åˆ°è¿™ä¸ªå‡½æ•°ï¼Œç„¶åæŠŠå‚æ•°åº”ç”¨åˆ°è¿™ä¸ªå‡½æ•°ä¸Šã€‚æ‰€ä»¥ä¸€ä¸ªæ³¨å†ŒæœåŠ¡æµç¨‹ï¼Œå°±æ˜¯å‘Šè¯‰grpcè®©æ”¶åˆ°ä¸€ä¸ªrpcè°ƒç”¨çš„æ—¶å€™ï¼Œå¦‚ä½•æ‰¾åˆ°æˆ‘ä»¬çš„å‡½æ•°ã€‚çœ‹ä¸€ä¸ªæœ€ç®€å•çš„æœåŠ¡ç«¯ç¨‹åº.</p>

<p>type server struct{}
func (s <em>server) SayHello(ctx context.Context, in *pb.HelloRequest) (</em>pb.HelloReply, error) {
  return &amp;pb.HelloReply{Message: â€œHello â€œ + in.Name}, nil
}
func main() {
  lis, err := net.Listen(â€œtcpâ€, port)
  if err != nil {
    log.Fatalf(â€œfailed to listen: %vâ€, err)
  }
  s := grpc.NewServer()
  pb.RegisterGreeterServer(s, &amp;server{})
  reflection.Register(s)
  if err := s.Serve(lis); err != nil {
    log.Fatalf(â€œfailed to serve: %vâ€, err)
  }
}
ä¸€èˆ¬çš„æµç¨‹æ˜¯å…ˆå®šä¹‰ä¸ªprotoæ–‡ä»¶ï¼Œç„¶åæ ¹æ®protocå·¥å…·ç”Ÿæˆgoçš„grpcä»£ç ï¼Œè¿™é‡Œçš„SayHelloå‡½æ•°æ˜¯ä½ protoæ–‡ä»¶ä¸­å£°æ˜çš„å‡½æ•°ã€‚ç„¶åä½ å®ç°ä½ å£°æ˜çš„æ¥å£ï¼Œç„¶åå†æ³¨å†Œåˆ°serverä¸­ï¼Œå°±å¯ä»¥ä¾›å®¢æˆ·ç«¯è°ƒç”¨äº†ã€‚ åœ¨grpcæ³¨å†Œçš„è¿‡ç¨‹ä¸­æœ‰å‡ ä¸ªæ¦‚å¿µ:</p>

<p>Server
grpc Service
ServiceDesc
è‡ªå·±çš„service
è‡ªå·±çš„serviceå¾ˆç®€å•ï¼Œå°±æ˜¯ä¸Šé¢çš„serverç»“æ„ä½“ï¼Œè¿™ä¸ªç»“æ„å®ç°äº†ç›¸åº”çš„interfaceã€‚servicedescç›¸å½“äºæ˜¯ä¸€ä¸ªæ ¹æ®protoæ–‡ä»¶æ¥æè¿°ä½ serveréœ€è¦å®ç°çš„åŠŸèƒ½çš„ç»“æ„ã€‚grpc service, ä½ protoæ–‡ä»¶å¯èƒ½ä¼šå£°æ˜å¤šä¸ªserviceï¼Œä½ çš„Serverä¹Ÿå¯ä»¥æ³¨å†Œå¤šä¸ªserviceã€‚Server åŸåˆ™ä¸Šæ¥è¯´åªéœ€è¦ä¸€ä¸ªserverï¼Œä¸€ä¸ªserverä¸‹æœ‰å¤šä¸ªserviceï¼Œä¸€ä¸ªserviceä¸‹æœ‰å¤šä¸ªæ–¹æ³•ã€‚ æˆ‘ä»¬çœ‹ä¸‹RegisterGreeterServerè¿™ä¸ªæ–¹æ³•</p>

<p>/æè¿°ä¸€ä¸ªserviceå…·æœ‰å“ªäº›æ–¹æ³•
var _Greeter_serviceDesc = grpc.ServiceDesc{
  ServiceName: â€œhelloworld.Greeterâ€,
  HandlerType: (<em>GreeterServer)(nil),
  Methods: []grpc.MethodDesc{
    {
      MethodName: â€œSayHelloâ€,
      Handler:    _Greeter_SayHello_Handler,
    },
  },
  Streams:  []grpc.StreamDesc{},
  Metadata: â€œhelloworld.protoâ€,
}
func RegisterGreeterServer(s *grpc.Server, srv GreeterServer) {
  s.RegisterService(&amp;_Greeter_serviceDesc, srv)
}
func (s *Server) RegisterService(sd *ServiceDesc, ss interface{}) {
  ht := reflect.TypeOf(sd.HandlerType).Elem()
  st := reflect.TypeOf(ss)
  //åˆ¤æ–­æ˜¯å¦å®ç°ç›¸åº”çš„æ¥å£
  if !st.Implements(ht) {
    grpclog.Fatalf(â€œgrpc: Server.RegisterService found the handler of type %v that does not satisfy %vâ€, st, ht)
  }
  s.register(sd, ss)
}
func (s *Server) register(sd *ServiceDesc, ss interface{}) {
  s.mu.Lock()
  defer s.mu.Unlock()
  s.printf(â€œRegisterService(%q)â€, sd.ServiceName)
  if _, ok := s.m[sd.ServiceName]; ok {
    grpclog.Fatalf(â€œgrpc: Server.RegisterService found duplicate service registration for %qâ€, sd.ServiceName)
  }
  //åˆå§‹åŒ–ä¸€ä¸ªæœåŠ¡
  srv := &amp;service{
    server: ss,
    md:     make(map[string]</em>MethodDesc),
    sd:     make(map[string]*StreamDesc),
    mdata:  sd.Metadata,
  }
  //æ ¹æ®åå­—æ˜ å°„æ–¹æ³•
  for i := range sd.Methods {
    d := &amp;sd.Methods[i]
    srv.md[d.MethodName] = d
  }
  for i := range sd.Streams {
    d := &amp;sd.Streams[i]
    srv.sd[d.StreamName] = d
  }
  æŠŠæœåŠ¡æ³¨å†Œåˆ°serverä¸­
  s.m[sd.ServiceName] = srv
}
å…¶å®æ ¹æ®è¿™ä¸ªæ³¨å†Œåå­—ï¼Œæˆ‘ä»¬å·²ç»èƒ½å¤Ÿå¤§æ¦‚çŒœåˆ°å½“å®¢æˆ·ç«¯çš„è¯·æ±‚åˆ°æ¥æ—¶å¦‚ä½•æ‰¾åˆ°æˆ‘ä»¬çš„æ–¹æ³•ã€‚é¦–å…ˆæ ¹æ®service nameæ‰¾åˆ°ç›¸åº”çš„serviceå†æ ¹æ®æ–¹æ³•åæ‰¾åˆ°ç›¸åº”çš„æ–¹æ³•ï¼Œç„¶åæ‹¿åˆ°æˆ‘ä»¬è‡ªå®šä¹‰çš„ç»“æ„è°ƒç”¨è¿™ä¸ªæ–¹æ³•ã€‚</p>

<p>3 è°ƒç”¨æµç¨‹
æ³¨å†Œæµç¨‹çœ‹å®Œäº†ï¼Œæ¥ä¸‹æ¥å†æ¥çœ‹ä¸‹è®©ä¸€ä¸ªè¯·æ±‚åˆ°è¾¾æœåŠ¡ç«¯çš„æ—¶å€™æ˜¯å¦‚ä½•å¤„ç†ã€‚ åœ¨Serverä¸­çš„Serveæ–¹æ³•ä¸­ï¼ŒæœåŠ¡ç«¯é€šè¿‡ç›‘å¬è¯·æ±‚çš„åˆ°æ¥ï¼Œé€šè¿‡forå¾ªç¯ä¸æ–­æ¥å—åˆ°æ¥çš„è¿æ¥ã€‚</p>

<p>//å»æ‰ä¸€äº›é”™è¯¯å¤„ç†çš„ä»£ç åï¼Œååˆ†ç®€æ´
  func (s *Server) Serve(lis net.Listener) error {
    â€¦â€¦â€¦.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
  rawConn, err := lis.Accept()
  .............

  // Start a new goroutine to deal with rawConn
  // so we don't stall this Accept loop goroutine.
  go s.handleRawConn(rawConn)
}   } //æœ€åé€šè¿‡http2åˆ›å»ºä¸€ä¸ªstreamï¼Œæ¥æ”¶å–æ¶ˆæ¯
</code></pre></div></div>

<p>func (s *Server) serveStreams(st transport.ServerTransport) {
  defer s.removeConn(st)
  defer st.Close()
  var wg sync.WaitGroup
  st.HandleStreams(func(stream *transport.Stream) {
    wg.Add(1)
    go func() {
      defer wg.Done()
      s.handleStream(st, stream, s.traceInfo(st, stream))
    }()
  }, func(ctx context.Context, method string) context.Context {
    if !EnableTracing {
      return ctx
    }
    tr := trace.New(â€œgrpc.Recv.â€+methodFamily(method), method)
    return trace.NewContext(ctx, tr)
  })
  wg.Wait()
}</p>

<p>func (s *Server) handleStream(t transport.ServerTransport, stream *transport.Stream, trInfo *traceInfo) {
  sm := stream.Method()
  if sm != â€œâ€ &amp;&amp; sm[0] == â€˜/â€™ {
    sm = sm[1:]
  }
  pos := strings.LastIndex(sm, â€œ/â€)</p>

<p>â€¦â€¦â€¦â€¦
    //ä»è¿™é‡Œåˆ°æœåŠ¡å’Œæ³¨å†Œçš„æ–¹æ³•
  service := sm[:pos]
  method := sm[pos+1:]
  srv, ok := s.m[service]</p>

<p>â€¦â€¦â€¦â€¦â€¦..</p>

<p>// Unary RPC or Streaming RPC?
  if md, ok := srv.md[method]; ok {
    s.processUnaryRPC(t, stream, srv, md, trInfo)
    return
  }
  if sd, ok := srv.sd[method]; ok {
    s.processStreamingRPC(t, stream, srv, sd, trInfo)
    return
  }</p>

<p>â€¦â€¦â€¦..</p>

<p>}</p>

<p>//æ¥ä¸‹æ¥æ˜¯æœ€ä¸»è¦çš„å¤„ç†å‡½æ•°
func (s *Server) processUnaryRPC(t transport.ServerTransport, stream *transport.Stream, srv *service, md *MethodDesc, trInfo *traceInfo) (err error) {
  if stats.On() {
    begin := &amp;stats.Begin{
      BeginTime: time.Now(),
    }
    stats.HandleRPC(stream.Context(), begin)
  }
  defer func() {
    if stats.On() {
      end := &amp;stats.End{
        EndTime: time.Now(),
      }
      if err != nil &amp;&amp; err != io.EOF {
        end.Error = toRPCErr(err)
      }
      stats.HandleRPC(stream.Context(), end)
    }
  }()
  if trInfo != nil {
    defer trInfo.tr.Finish()
    trInfo.firstLine.client = false
    trInfo.tr.LazyLog(&amp;trInfo.firstLine, false)
    defer func() {
      if err != nil &amp;&amp; err != io.EOF {
        trInfo.tr.LazyLog(&amp;fmtStringer{â€œ%vâ€, []interface{}{err}}, true)
        trInfo.tr.SetError()
      }
    }()
  }
  if s.opts.cp != nil {
    // NOTE: this needs to be ahead of all handling, https://github.com/grpc/grpc-go/issues/686.
    stream.SetSendCompress(s.opts.cp.Type())
  }
  p := &amp;parser{r: stream}
  for {
    pf, req, err := p.recvMsg(s.opts.maxMsgSize)
    if err == io.EOF {
      // The entire stream is done (for unary RPC only).
      return err
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.............

if err := checkRecvPayload(pf, stream.RecvCompress(), s.opts.dc); err != nil {
  switch err := err.(type) {
  case *rpcError:
    if e := t.WriteStatus(stream, err.code, err.desc); e != nil {
      grpclog.Printf("grpc: Server.processUnaryRPC failed to write status %v", e)
    }
    return err
  default:
    if e := t.WriteStatus(stream, codes.Internal, err.Error()); e != nil {
      grpclog.Printf("grpc: Server.processUnaryRPC failed to write status %v", e)
    }
    // TODO checkRecvPayload always return RPC error. Add a return here if necessary.
  }
}
var inPayload *stats.InPayload
if stats.On() {
  inPayload = &amp;stats.InPayload{
    RecvTime: time.Now(),
  }
}
statusCode := codes.OK
statusDesc := ""
//dfå‡½æ•°ä¸»è¦ç”¨äºè¯»å–http2è¯·æ±‚å¹¶ååºåˆ—åŒ–åˆ°vä¸­(ç›¸å½“äºä¸€ä¸ªè§£åŒ…çš„æ“ä½œ)
df := func(v interface{}) error {
  if inPayload != nil {
    inPayload.WireLength = len(req)
  }
  if pf == compressionMade {
    var err error
    req, err = s.opts.dc.Do(bytes.NewReader(req))
    if err != nil {
      if err := t.WriteStatus(stream, codes.Internal, err.Error()); err != nil {
        grpclog.Printf("grpc: Server.processUnaryRPC failed to write status %v", err)
      }
      return Errorf(codes.Internal, err.Error())
    }
  }
  if len(req) &gt; s.opts.maxMsgSize {
    // TODO: Revisit the error code. Currently keep it consistent with
    // java implementation.
    statusCode = codes.Internal
    statusDesc = fmt.Sprintf("grpc: server received a message of %d bytes exceeding %d limit", len(req), s.opts.maxMsgSize)
  }
  if err := s.opts.codec.Unmarshal(req, v); err != nil {
    return err
  }
  if inPayload != nil {
    inPayload.Payload = v
    inPayload.Data = req
    inPayload.Length = len(req)
    stats.HandleRPC(stream.Context(), inPayload)
  }
  if trInfo != nil {
    trInfo.tr.LazyLog(&amp;payload{sent: false, msg: v}, true)
  }
  return nil
}
//è¿™äº›æˆ‘ä»¬æ³¨å†Œçš„å‡½æ•°
reply, appErr := md.Handler(srv.server, stream.Context(), df, s.opts.unaryInt)

.....................

opts := &amp;transport.Options{
  Last:  true,
  Delay: false,
}
//å‘ç»“æœå‘é€å‡ºå»
if err := s.sendResponse(t, stream, reply, s.opts.cp, opts); err != nil {
  switch err := err.(type) {
  case transport.ConnectionError:
    // Nothing to do here.
  case transport.StreamError:
    statusCode = err.Code
    statusDesc = err.Desc
  default:
    statusCode = codes.Unknown
    statusDesc = err.Error()
  }
  return err
}
if trInfo != nil {
  trInfo.tr.LazyLog(&amp;payload{sent: true, msg: reply}, true)
}
errWrite := t.WriteStatus(stream, statusCode, statusDesc)
if statusCode != codes.OK {
  return Errorf(statusCode, statusDesc)
}
return errWrite   } } grpcæœåŠ¡ç«¯çš„åŸºæœ¬æµç¨‹å°±æ˜¯è¿™æ ·äº†ï¼Œæˆ‘åªæ˜¯çœ‹çš„ä¸€ä¸ªåŸºæœ¬æµç¨‹ï¼Œå†æ²¡é‡åˆ°é—®é¢˜æ—¶ï¼ŒåŸºæœ¬ä¸Šä¸ä¼šå†çœ‹grpcæºç äº†ã€‚ç›®å‰å…¬å¸é¡¹ç›®ä¸­åœ¨ä½¿ç”¨grpcï¼Œç­‰æœ‰äº†å‘ï¼Œæˆ‘å†æ¥æ€»ç»“å§
</code></pre></div></div>

<p>4 æ€»ç»“
grpcä¸­æœ‰å¾ˆå¤šæˆ‘æ¯”è¾ƒå–œæ¬¢çš„ç‚¹ï¼Œä¸€ä¸ªæ˜¯grpcseverçš„é…ç½®é€šè¿‡ä¼ é€’å‡½æ•°æ¥ä¿®æ”¹ï¼Œè¿™æ ·åˆä¸ç”¨å–å›ä¹‹å‰çš„è®¾ç½®ï¼Œåˆå¯ä»¥åªä¿®æ”¹å…¶ä¸­ä¸€ä¸ªå€¼,æ¯”è¾ƒç²¾å·§ï¼Œ-0- åŸè°…æˆ‘è§è¯†ä¸å¤šã€‚è¿˜æœ‰å°±æ˜¯é”™è¯¯çš„å¤„ç†ï¼Œcontextçš„ä½¿ç”¨ï¼Œtraceçš„ä½¿ç”¨ã€‚ ä¸å¾—ä¸åæ§½ä¸€ä¸‹ï¼Œgolangçš„ä»£ç çœ‹èµ·æ¥çœŸä¸å¤Ÿç¾ï¼Œè™½ç„¶ç®€å•ï¼Œä½†æ˜¯å†™èµ·æ¥ä¸å¤Ÿä¼˜ç¾ï¼Œæºç çš„é”™è¯¯å¤„ç†çœ‹èµ·æ¥ä¹Ÿæ˜¯ä¹±ç³Ÿç³Ÿçš„ã€‚</p>
:ET