I"	j<p>http://xiaorui.cc/2020/02/11/go1-14%e5%9f%ba%e4%ba%8enetpoll%e4%bc%98%e5%8c%96timer%e5%ae%9a%e6%97%b6%e5%99%a8%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86/
golang1.14ç‰ˆçš„rcå·²ç»å‘å¸ƒæœ‰äº›æ—¥å­äº†ï¼Œåœ¨å®˜æ–¹go1.14çš„ä»‹ç»é‡Œæœ‰è¯´ä¼˜åŒ–äº†timerå®šæ—¶å™¨ã€‚golangçš„å®šæ—¶å™¨å·²ç»ç»å†äº†å‡ ç‰ˆçš„ä¼˜åŒ–ï¼Œä½†åœ¨ä¾èµ–å®šæ—¶å™¨çš„é«˜æ€§èƒ½åœºæ™¯ï¼Œè¿˜æ˜¯æˆä¸ºä¸€ä¸ªå¤§çš„æ€§èƒ½æ€æ‰‹ã€‚
<!-- more -->
go1.13å’Œgo1.14çš„åŒºåˆ«ï¼Ÿ</p>

<p>åºŸè¯ä¸å¤šè¯´ï¼Œæ¥å¥½å¥½ä»‹ç»ä¸‹å®šæ—¶å™¨åœ¨go 1.13 å’Œ go1.14ä¸­çš„åŒºåˆ«ï¼Ÿ</p>

<p>golangåœ¨1.10ç‰ˆæœ¬ä¹‹å‰æ˜¯ç”±ä¸€ä¸ªç‹¬ç«‹çš„timerprocé€šè¿‡å°é¡¶å †å’Œfutexsleepæ¥ç®¡ç†å®šæ—¶ä»»åŠ¡ã€‚1.10ä¹‹åé‡‡ç”¨çš„æ–¹æ¡ˆæ˜¯æŠŠç‹¬ç«‹çš„timerprocå’Œå°é¡¶å †åˆ†æˆæœ€å¤š64ä¸ªtimerprocåç¨‹å’Œå››å‰å †ï¼Œç”¨æ¥ä¼‘çœ å°±è¿‘æ—¶é—´çš„æ–¹æ³•è¿˜æ˜¯ä¾èµ–futex timeoutæœºåˆ¶ã€‚é»˜è®¤timerprocæ•°é‡ä¼šè·ŸGOMAXPROCSä¸€è‡´çš„ï¼Œä½†æœ€å¤§ä¹Ÿå°±64ä¸ªï¼Œå› ä¸ºä¼šè¢«64å–æ‘¸ã€‚</p>

<p>é‚£ä¹ˆç®€å•è¯´go1.14ç‰ˆçš„timeræ˜¯å¦‚ä½•ä¼˜åŒ–æ€§èƒ½ï¼Ÿé¦–å…ˆæŠŠå­˜æ”¾å®šæ—¶äº‹ä»¶çš„å››å‰å †æ”¾åˆ°pç»“æ„ä¸­ï¼Œå¦å¤–å–æ¶ˆäº†timerprocåç¨‹ï¼Œè½¬è€Œä½¿ç”¨netpollçš„epoll waitæ¥åšå°±è¿‘æ—¶é—´çš„ä¼‘çœ ç­‰å¾…ã€‚åœ¨æ¯æ¬¡runtime.scheduleè°ƒåº¦æ—¶éƒ½æ£€æŸ¥è¿è¡Œåˆ°æœŸçš„å®šæ—¶å™¨ã€‚</p>

<p>å¿«é€Ÿæµè§ˆgo1.13çš„å®šæ—¶å™¨å®ç°åŸç†</p>

<p>åœ¨è¿™é‡Œç®€å•çš„è¿‡ä¸€égo1.13ç‰ˆå®šæ—¶å™¨çš„å®ç°ï¼Œå†ç»†èŠ‚å¯ä»¥çœ‹ä¸‹æˆ‘å†™è¿‡çš„æ–‡ç« ã€‚</p>

<p>ä¸ç®¡æ˜¯NewTimerã€NewTickerã€Afterç­‰å…¶å®è°ƒç”¨çš„éƒ½æ˜¯addTimeræ¥æ–°å¢å®šæ—¶ä»»åŠ¡ï¼ŒassignBucketç»™å½“å‰åç¨‹åˆ†é…ä¸€ä¸ªtimerBucketã€‚goåˆå§‹åŒ–æ—¶ä¼šé¢„å…ˆå®ä¾‹åŒ–é•¿åº¦64çš„timersæ•°ç»„ï¼Œé€šè¿‡åç¨‹çš„pè·Ÿ64å–æ‘¸æ¥åˆ†é…timerBucketã€‚å¦‚æœæ–°çš„å®šæ—¶ä»»åŠ¡è¾ƒæ–°ï¼Œé‚£ä¹ˆä½¿ç”¨notewakeupæ¥æ¿€æ´»å”¤é†’timerprocçš„futexç­‰å¾…ã€‚å¦‚æœå‘ç°æ²¡æœ‰å®ä¾‹åŒ–timerprocï¼Œåˆ™å¯åŠ¨ã€‚</p>

<p>// xiaorui.cc</p>

<p>const timersLen = 64</p>

<p>var timers [timersLen]struct {
    timersBucket
}</p>

<p>func addtimer(t *timer) {
    tb := t.assignBucket()
    lock(&amp;tb.lock)
    ok := tb.addtimerLocked(t)
    unlock(&amp;tb.lock)
    ,,,
}</p>

<p>func (t *timer) assignBucket() *timersBucket {
    id := uint8(getg().m.p.ptr().id) % timersLen
    t.tb = &amp;timers[id].timersBucket
    return t.tb
}</p>

<p>func (tb *timersBucket) addtimerLocked(t *timer) bool {
    t.i = len(tb.t)
    tb.t = append(tb.t, t)
    if !siftupTimer(tb.t, t.i) {
        return false
    }
    if t.i == 0 {
        if tb.sleeping &amp;&amp; tb.sleepUntil &gt; t.when {
            tb.sleeping = false
            notewakeup(&amp;tb.waitnote)
        }
        ,,,
        if !tb.created {
            tb.created = true
            go timerproc(tb)
        }
    }
    return true
}
timerprocåç¨‹è¿è¡Œæ—¶ä¼šä»å †é¡¶æ‹¿timerï¼Œç„¶ååˆ¤æ–­æ˜¯å¦åˆ°æœŸï¼Œåˆ°æœŸåˆ™ç›´æ¥æ‰§è¡Œï¼Œå½“bucketæ— ä»»åŠ¡æ—¶ï¼Œè°ƒç”¨runtime.goparkunlockæ¥ä¼‘çœ è¯¥åç¨‹ã€‚å½“è‡³å°‘æœ‰ä¸€ä¸ªtimerä»»åŠ¡æ—¶ï¼Œåˆ™é€šè¿‡notetsleepgä¼ å…¥ä¸‹æ¬¡çš„åˆ°æœŸæ—¶é—´æ¥è¿›è¡Œä¼‘çœ ã€‚å€¼å¾—ä¸€è¯´çš„æ˜¯notetsleepgä¼šè°ƒç”¨entersyscallblockè§¦å‘handoffpï¼Œè¿™ä¸ªé—®é¢˜æˆ‘ä»¬åœ¨æ–‡ç« åæœ‰è¯´æ˜ã€‚</p>

<p>// xiaorui.cc</p>

<p>func timerproc(tb *timersBucket) {
    tb.gp = getg()
    for {
        lock(&amp;tb.lock)
        now := nanotime()
        delta := int64(-1)
        for {
            t := tb.t[0]
            delta = t.when - now
            if delta &gt; 0 {
               break
            }
            arg := t.arg
            seq := t.seq
            unlock(&amp;tb.lock)
            ,,,
            f(arg, seq)
            lock(&amp;tb.lock)
        }
        if delta &lt; 0 || faketime &gt; 0 {
            // No timers left - put goroutine to sleep.
            goparkunlock(&amp;tb.lock, waitReasonTimerGoroutineIdle, traceEvGoBlock, 1)
            continue
        }
     }
     ,,,
     tb.sleepUntil = now + delta
     unlock(&amp;tb.lock)
     notetsleepg(&amp;tb.waitnote, delta)
}
timerprocçš„notetsleepgç”¨æ¥ä¼‘çœ ï¼ŒaddTimerLockedçš„notewakeupç”¨æ¥å”¤é†’ã€‚</p>

<p>// xiaorui.cc</p>

<p>// notetsleepg -&gt; notetsleep_internal -&gt; futexsleep
func futexsleep(addr *uint32, val uint32, ns int64) {
    var ts timespec
    ts.setNsec(ns) 
    futex(unsafe.Pointer(addr), _FUTEX_WAIT_PRIVATE, val, unsafe.Pointer(&amp;ts), nil, 0)
}</p>

<p>// notewakeup -&gt; futexwakeup
func futexwakeup(addr *uint32, cnt uint32) {
    ret := futex(unsafe.Pointer(addr), _FUTEX_WAKE_PRIVATE, cnt, nil, nil, 0)
    ,,,
}
æºç åˆ†ægo1.14 timer</p>

<p>åœ¨struct pä¸­å®šä¹‰äº†timerç›¸å…³å­—æ®µï¼Œtimersæ•°ç»„ç”¨æ¥åšå››å‰å †æ•°æ®ç»“æ„ã€‚</p>

<p>// xiaorui.cc</p>

<p>type p struct {
        // ä¿æŠ¤timerså †è¯»å†™å®‰å…¨
        timersLock mutex</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // å­˜æ”¾å®šæ—¶å™¨ä»»åŠ¡
    timers []*timer

    ,,, } å®šæ—¶å™¨timerç»“æ„çš„å®šä¹‰.
</code></pre></div></div>

<p>// xiaorui.cc</p>

<p>type timer struct {
    pp puintptr  // pçš„ä½ç½®</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>when   int64 // åˆ°æœŸæ—¶é—´
period int64 // å‘¨æœŸæ—¶é—´ï¼Œé€‚åˆticker
f      func(interface{}, uintptr) // å›è°ƒæ–¹æ³•
arg    interface{}  // å‚æ•°
seq    uintptr  // åºå·

nextwhen int64 // ä¸‹æ¬¡çš„åˆ°æœŸæ—¶é—´
status uint32 // çŠ¶æ€ } å¦‚ä½•å¢åŠ å®šæ—¶ä»»åŠ¡çš„ï¼Ÿ
</code></pre></div></div>

<p>æˆ‘ä»¬è°ƒç”¨NewTimerã€Afterã€AfterFuncæ—¶ä¼šæ„å»ºruntimeTimerå®šæ—¶ç»“æ„ï¼Œç„¶åé€šè¿‡runttime.startTimeræ¥æ’å…¥åˆ°æ—¶é—´å †é‡Œã€‚å¦å¤–åœ¨ä¿®æ”¹ï¼Œé‡ç½®å®šæ—¶å™¨çš„é€»è¾‘éƒ½ä¼šå°è¯•è°ƒç”¨wakeNetPolleræ¥å”¤é†’netpollerã€‚</p>

<p>æ³¨æ„ï¼Œtime/sleep.goé‡Œçš„runtimeTimerè·Ÿruntimeçš„timerç»“æ„æ˜¯ä¸€è‡´çš„ã€‚</p>

<p>// xiaorui.cc</p>

<p>time/sleep.go</p>

<p>func NewTimer(d Duration) *Timer {
    c := make(chan Time, 1)
    t := &amp;Timer{
        C: c,
        r: runtimeTimer{
            when: when(d),
            f:    sendTime,
            arg:  c,
        },
    }
    startTimer(&amp;t.r)
    return t
}</p>

<p>func After(d Duration) &lt;-chan Time {
    return NewTimer(d).C
}</p>

<p>func AfterFunc(d Duration, f func()) *Timer {
    t := &amp;Timer{
        r: runtimeTimer{
            when: when(d),
            f:    goFunc,
            arg:  f,
        },
    }
    startTimer(&amp;t.r)
    return t
}</p>

<p>func goFunc(arg interface{}, seq uintptr) {
    go arg.(func())()
}</p>

<p>func sendTime(c interface{}, seq uintptr) {
    select {
    case c.(chan Time) &lt;- Now():
    default:
    }
}
ä¸‹é¢æ˜¯å…·ä½“æ“ä½œå®šæ—¶å™¨æ·»åŠ çš„è¿‡ç¨‹ï¼Œtime/sleep.goå¯ä»¥ç†è§£ä¸ºåº”ç”¨å±‚å®šæ—¶å™¨çš„å°è£…ï¼Œruntime/time.goæ˜¯å®šæ—¶å™¨è°ƒåº¦çš„å°è£…ã€‚</p>

<p>// xiaorui.cc</p>

<p>// é€šè¿‡linkåšæ–¹æ³•æ˜ å°„ï¼Œç®€å•è¯´time/sleep.goé‡Œè°ƒç”¨çš„time.startTimerå…¶å®æ˜¯runtimeåŒ…é‡Œçš„ã€‚
//go:linkname startTimer time.startTimer
func startTimer(t *timer) {
    addtimer(t)
}</p>

<p>// æŠŠå®šæ—¶ä»»åŠ¡æ”¾åˆ°å½“å‰gå…³è”çš„Pé‡Œã€‚
func addtimer(t *timer) {
    if t.when &lt; 0 {
        t.when = maxWhen
    }
    t.status = timerWaiting  // çŠ¶æ€ä¸ºç­‰å¾…ä¸­</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>addInitializedTimer(t) }
</code></pre></div></div>

<p>// åŠ é”æ¥æ¸…ç†ä»»åŠ¡ï¼Œå¹¶ä¸”å¢åŠ å®šæ—¶ä»»åŠ¡ï¼Œæœ€åæ ¹æ®æ—¶é—´å°±è¿‘æ¥å”¤é†’netpoll
func addInitializedTimer(t *timer) {
    when := t.when</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pp := getg().m.p.ptr()
lock(&amp;pp.timersLock)
ok := cleantimers(pp) &amp;&amp; doaddtimer(pp, t)
unlock(&amp;pp.timersLock)
if !ok {
    badTimer()
}

wakeNetPoller(when) } å½“æ–°æ·»åŠ çš„å®šæ—¶ä»»åŠ¡whenå°äºnetpollç­‰å¾…çš„æ—¶é—´ï¼Œé‚£ä¹ˆwakeNetPollerä¼šæ¿€æ´»NetPollçš„ç­‰å¾…ã€‚æ¿€æ´»çš„æ–¹æ³•å¾ˆç®€å•ï¼Œåœ¨findrunnableé‡Œçš„æœ€åä¼šä½¿ç”¨è¶…æ—¶é˜»å¡çš„æ–¹æ³•è°ƒç”¨epollwaitï¼Œè¿™æ ·æ—¢å¯ç›‘æ§äº†epfdçº¢é»‘æ ‘ä¸Šçš„fdï¼Œåˆå¯å…¼é¡¾æœ€è¿‘çš„å®šæ—¶ä»»åŠ¡çš„ç­‰å¾…ã€‚
</code></pre></div></div>

<p>// xiaorui.cc</p>

<p>var (
    epfd int32 = -1 // epoll descriptor
    netpollBreakRd, netpollBreakWr uintptr // ç”¨æ¥ç»™netpollä¸­æ–­
)</p>

<p>// åˆå§‹åŒ–å…¨å±€çš„epfdåŠbreakçš„ä¸¤ä¸ªè¯»å†™ç®¡é“
func netpollinit() {
    epfd = epollcreate1(_EPOLL_CLOEXEC)
    ,,,
    r, w, errno := nonblockingPipe() // rä¸ºç®¡é“çš„è¯»ç«¯ï¼Œwä¸ºå†™ç«¯
    ,,,
    errno = epollctl(epfd, _EPOLL_CTL_ADD, r, &amp;ev)  // æŠŠç®¡é“çš„rç«¯åŠ åˆ°epfdé‡Œè¿›è¡Œç›‘å¬
    ,,,
    netpollBreakRd = uintptr(r)
    netpollBreakWr = uintptr(w)
}</p>

<p>// å”¤é†’æ­£åœ¨netpollä¼‘çœ çš„çº¿ç¨‹ï¼Œå‰ææ˜¯whençš„å€¼å°äºpollUntilæ—¶é—´ã€‚
func wakeNetPoller(when int64) {
    if atomic.Load64(&amp;sched.lastpoll) == 0 {
        pollerPollUntil := int64(atomic.Load64(&amp;sched.pollUntil))
        if pollerPollUntil == 0 || pollerPollUntil &gt; when {
            netpollBreak()
        }
    }
}</p>

<p>// netpollBreakWræ˜¯ä¸€ä¸ªç®¡é“ï¼Œç”¨writeç»™netpollBreakWrå†™æ•°æ®ï¼Œè¿™æ ·netpollè‡ªç„¶å°±å¯è¢«å”¤é†’ã€‚
func netpollBreak() {
    for {
        var b byte
        n := write(netpollBreakWr, unsafe.Pointer(&amp;b), 1)
        if n == 1 {
            break
        }
        if n == -_EINTR {
            continue
        }
        if n == -_EAGAIN {
            return
        }
        println(â€œruntime: netpollBreak write failed withâ€, -n)
        throw(â€œruntime: netpollBreak write failedâ€)
    }
}
å¢åŠ å’Œä¿®æ”¹çš„é€»è¾‘å¤§åŒå°å¼‚ï¼Œä½†æ˜¯åˆ é™¤ä¸ä¸€æ ·ï¼Œåˆ é™¤æ›´å¤šçš„æ˜¯æ ‡è®°timerç»“æ„ä¸­çš„statusä¸ºtimerDeletedçŠ¶æ€ï¼Œè¿™æ ·å½“checkTimers</p>

<p>// xiaorui.cc</p>

<p>// time/sleep.goçš„stopTimerç”¨çš„æ˜¯runtime.stopTimeræ–¹æ³•
//go:linkname stopTimer time.stopTimer
func stopTimer(t *timer) bool {
    return deltimer(t)
}</p>

<p>func deltimer(t *timer) bool {
    for {
        switch s := atomic.Load(&amp;t.status); s {
        case timerWaiting, timerModifiedLater:
            // åŸå­æ›´æ–°ä¸ºåˆ é™¤
            if atomic.Cas(&amp;t.status, s, timerDeleted) {
                atomic.Xadd(&amp;tpp.deletedTimers, 1)
                return true
            }
        ,,,
        // å·²ç»è¢«åˆ é™¤
        case timerDeleted, timerRemoving, timerRemoved:
            return false
,,,</p>

<p>// runtime/proc.go checkTimers -&gt; runtime/time.go runtimer
func runtimer(pp *p, now int64) int64 {
    for {
        t := pp.timers[0]
        ,,,
        switch s := atomic.Load(&amp;t.status); s {
        case timerWaiting:
            runOneTimer(p, t, now)  // æ‰§è¡Œ
        case timerDeleted:
            continue
    ,,,
    }
}
ä¸‹é¢æ˜¯æ£€æµ‹å’Œæ‰§è¡Œå®šæ—¶å™¨çš„å…¥å£</p>

<p>ç¬¬ä¸€ï¼Œé€šè¿‡findrunnableæ‰¾ä»»åŠ¡æ—¶ä¼šæ£€æŸ¥timeräº‹ä»¶ã€‚å‡½æ•°åˆšå¼€å§‹æ—¶ä¼šä½¿ç”¨checkTimersæ£€æµ‹è¿è¡Œæœ¬pçš„å®šæ—¶ä»»åŠ¡ï¼Œåé¢å†å·ä»»åŠ¡æ—¶ä¸ä»…å·å…¶ä»–pçš„runqï¼Œè€Œä¸”è¿˜å·å…¶ä»–påˆ°æœŸçš„timersï¼Œå…·ä½“ä½¿ç”¨çš„æ˜¯checkTimersæ–¹æ³•ã€‚</p>

<p>// xiaorui.cc</p>

<p>func findrunnable() (gp *g, inheritTime bool) {
    <em>g</em> := getg()</p>

<p>top:
    <em>p</em> := <em>g</em>.m.p.ptr()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// æ£€æµ‹è¿è¡Œæœ¬pçš„å®šæ—¶ä»»åŠ¡
now, pollUntil, _ := checkTimers(_p_, 0)


// ä»æœ¬pä¸­è·å–goroutine
if gp, inheritTime := runqget(_p_); gp != nil {
    return gp, inheritTime
}

// ä»å…¨å±€pä¸­è·å–goroutine
if sched.runqsize != 0 {
    lock(&amp;sched.lock)
    gp := globrunqget(_p_, 0)
    unlock(&amp;sched.lock)
    if gp != nil {
        return gp, false
    }
}

// éé˜»å¡çš„è½®è¯¢ç½‘ç»œäº‹ä»¶
if netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; 0 &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != 0 {
    if list := netpoll(0); !list.empty() { // non-blocking
        gp := list.pop()
        injectglist(&amp;list)  // æŠŠè¢«å”¤é†’è·Ÿfdå…³è”çš„goroutineæ”¾åˆ°runqé‡Œã€‚
        casgstatus(gp, _Gwaiting, _Grunnable)
        if trace.enabled {
            traceGoUnpark(gp, 0)
        }
        return gp, false
    }
}


// ä»å…¶ä»–på·ä»»åŠ¡, éå†4ä¸‹, å…ˆä»å…¶ä»–çš„pçš„runqå·ï¼Œå†ä»å…¶ä»–pçš„timerså·.
procs := uint32(gomaxprocs)
for i := 0; i &lt; 4; i++ {
    for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
        // å·å…¶ä»–pçš„runq
        if gp := runqsteal(_p_, p2, stealRunNextG); gp != nil {
            return gp, false
        }

        // ç»§ç»­å·å…¶ä»–pçš„timers
        if i &gt; 2 &amp;&amp; shouldStealTimers(p2) {
            tnow, w, ran := checkTimers(p2, now)  // æ‰§è¡Œå·²ç»åˆ°æœŸçš„å®šæ—¶ä»»åŠ¡
        }
    }
}

// å¸¦è¶…æ—¶çš„netpollé˜»å¡è°ƒç”¨
if netpollinited() &amp;&amp; (atomic.Load(&amp;netpollWaiters) &gt; 0 || pollUntil != 0) &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, 0) != 0 {
    list := netpoll(delta) // block until new work is available
    ,,,
} } netpollè¿™é‡Œåˆ†ä¸ºé˜»å¡å’Œéé˜»å¡æ–¹æ³•ï¼Œå½“delayå°äºåˆ™æ˜¯é˜»å¡æ¨¡å¼ï¼Œç­‰äº0ä¸ºéé˜»å¡æ¨¡å¼ï¼Œå¤§äº0æ˜¯è¶…æ—¶æ¨¡å¼ã€‚delayçš„æ—¶é—´ä¸ºçº³ç§’ï¼Œepoll waitçš„è¶…æ—¶æ—¶é—´å•ä½ä¸ºæ¯«ç§’ï¼Œä¸ºäº†é¿å…è¿‡åº¦çš„ç³»ç»Ÿè°ƒç”¨ï¼Œåšäº†ä¸€äº›ç²’åº¦ä¸Šçš„åˆå¹¶ã€‚
</code></pre></div></div>

<p>å¦å¤–ï¼Œgolangä¸ºäº†å°½é‡è§„é¿epollçš„æƒŠç¾¤é—®é¢˜ï¼Œæ‰€ä»¥åŒä¸€æ—¶é—´åªä¼šæœ‰ä¸€ä¸ªåç¨‹é™·å…¥epoll waitä¼‘çœ ã€‚</p>

<p>// xiaorui.cc</p>

<p>// netpoll checks for ready network connections.
// Returns list of goroutines that become runnable.
// delay &lt; 0: blocks indefinitely
// delay == 0: does not block, just polls
// delay &gt; 0: block for up to that many nanoseconds
func netpoll(delay int64) gList {
    if epfd == -1 {  // epfdä¸ºå…¨å±€å¯¹è±¡ï¼Œnetpollinitæ—¶å°±ä¼šåˆå§‹åŒ–
        return gList{}
    }
    var waitms int32
    if delay &lt; 0 {
        waitms = -1
    } else if delay == 0 {
        waitms = 0
    } else if delay &lt; 1e6 { // 1ms
        waitms = 1
    } else if delay &lt; 1e15 { // 11.574 å¤©
        waitms = int32(delay / 1e6) // æœ€å¤§ 1s
    } else {
        // An arbitrary cap on how long to wait for a timer.
        // 1e9 ms == ~11.5 days.
        waitms = 1e9  // 1s
    }
    var events [128]epollevent
retry:
    n := epollwait(epfd, &amp;events[0], int32(len(events)), waitms)
    ,,,
    for i := int32(0); i &lt; n; i++ {
        ,,,
        // å¦‚æœfdä¸ºç”¨æ¥ä¸­æ–­çš„netpollBreakRdåˆ™continueã€‚
        if *(**uintptr)(unsafe.Pointer(&amp;ev.data)) == &amp;netpollBreakRd {
            var tmp [16]byte
            read(int32(netpollBreakRd), noescape(unsafe.Pointer(&amp;tmp[0])), int32(len(tmp)))
        }
        continue
    }
    ,,,
}
epollwaitå‡½æ•°çš„å®ç°æ˜¯æ±‡ç¼–ã€‚</p>

<p>// xiaorui.cc</p>

<p>// int32 runtimeÂ·epollwait(int32 epfd, EpollEvent *ev, int32 nev, int32 timeout);
TEXT runtimeÂ·epollwait(SB),NOSPLIT,$0
    MOVL    epfd+0(FP), DI
    MOVQ    ev+8(FP), SI
    MOVL    nev+16(FP), DX
    MOVL    timeout+20(FP), R10
    MOVQ    $0, R8
    MOVL    $SYS_epoll_pwait, AX
    SYSCALL
    MOVL    AX, ret+24(FP)
    RET
ç¬¬äºŒï¼Œåœ¨go runtimeçš„pmgè°ƒåº¦æ¨¡å‹ä¸‹ï¼Œå½“ä¸€ä¸ªmæ‰§è¡Œå®Œä¸€ä¸ªGçš„åç¨‹è°ƒåº¦åï¼Œè°ƒç”¨runtime.scheduleæ–¹æ³•æ¥å¯»æ‰¾å¯ç”¨çš„goroutineå¹¶æ‰§è¡Œã€‚è¿™é‡Œå…³é”®çš„æ–¹æ³•ä¹Ÿæ˜¯checkTimersã€‚</p>

<p>// xiaorui.cc</p>

<p>func schedule() {
    ,,,
    pp := <em>g</em>.m.p.ptr()
    checkTimers(pp, 0)
    ,,,
    if gp == nil {
       gp, inheritTime = findrunnable() // blocks until work is available
    }
    ,,,
}
é‚£ä¹ˆcheckTimersæ˜¯åšä»€ä¹ˆçš„ï¼Ÿ</p>

<p>checkTimersè¯¥å‡½æ•°åªæ£€æŸ¥ä¼ é€’è¿›æ¥çš„pï¼Œé€šè¿‡runtimeræ¥è¿è¡Œåˆ°æœŸçš„å®šæ—¶ä»»åŠ¡ï¼Œå¹¶ä¸”è¿”å›ä¸‹ä¸€æ¬¡åˆ°æœŸçš„æ—¶é—´åŠæ˜¯å¦æœ‰å®šæ—¶ä»»åŠ¡åˆ°æœŸã€‚</p>

<p>// xiaorui.cc</p>

<p>func checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) {
    â€¦
    lock(&amp;pp.timersLock)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rnow = now
if len(pp.timers) &gt; 0 {
    if rnow == 0 {
        rnow = nanotime()
    }
    for len(pp.timers) &gt; 0 {

        // å°è¯•æ‰§è¡Œä»»åŠ¡
        if tw := runtimer(pp, rnow); tw != 0 {
            if tw &gt; 0 {
                pollUntil = tw
            }
            break
        }
        ran = true
    }
}

unlock(&amp;pp.timersLock)

return rnow, pollUntil, ran } runtimeréå†å †é¡¶çš„ä»»åŠ¡æ—¶é—´æ˜¯å¦åˆ°æœŸï¼Œå¦‚åˆ°æœŸå›è°ƒæ‰§è¡Œï¼Œå¦‚æ˜¯å‘¨æœŸæ€§ä¼šé‡æ–°ã€‚
</code></pre></div></div>

<p>// xiaorui.cc</p>

<p>//go:systemstack
func runtimer(pp *p, now int64) int64 {
        for {
                t := pp.timers[0] // è·å–å››å‰å †çš„å †é¡¶
                ,,,
                switch s := atomic.Load(&amp;t.status); s {
                case timerWaiting:
                        if t.when &gt; now {
                                // Not ready to run.
                                return t.when
                        }
                        // åŸå­ä¿®æ”¹å®šæ—¶ä»»åŠ¡çš„çŠ¶æ€
                        if !atomic.Cas(&amp;t.status, s, timerRunning) {
                                continue
                        }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    runOneTimer(pp, t, now)
                    return 0 ,,,
</code></pre></div></div>

<p>// ç›´æ¥æ‰§è¡Œè¯¥å®šæ—¶ä»»åŠ¡ï¼Œå¦‚æœæ˜¯å‘¨æœŸæ€§ä»»åŠ¡ä¼šé‡æ–°å…¥é˜Ÿã€‚
func runOneTimer(pp *p, t *timer, now int64) {
        (â€¦)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    f := t.f
    arg := t.arg
    seq := t.seq

    // å¦‚æœæ˜¯ period &gt; 0 åˆ™è¯´æ˜æ­¤æ—¶ timer ä¸º tickerï¼Œéœ€è¦å†æ¬¡è§¦å‘
    if t.period &gt; 0 {
            delta := t.when - now
            t.when += t.period * (1 + -delta/t.period)
            if !siftdownTimer(pp.timers, 0) {  // è°ƒæ•´å †
                    panic(...)
            }
            // åŸå­é‡ç½®çŠ¶æ€ä¸ºtiemrWaiting
            if !atomic.Cas(&amp;t.status, timerRunning, timerWaiting) {
                    panic(...)
            }
    } else { // å¦åˆ™ä¸ºä¸€æ¬¡æ€§ timer
            // ä»å †ä¸­ç§»é™¤
            if !dodeltimer0(pp) {
                    panic(...)
            }
            if !atomic.Cas(&amp;t.status, timerRunning, timerNoStatus) {
                    panic(...)
            }
    }

    ,,,

    unlock(&amp;pp.timersLock)

    f(arg, seq)  // å›è°ƒæ‰§è¡Œå®šæ—¶ä»»åŠ¡ä¸­çš„æ–¹æ³•
    lock(&amp;pp.timersLock)

    ,,, } å€Ÿç”¨go pprofçš„å›¾å¯ä»¥æ˜æ˜¾çš„è·Ÿè¸ªå®šæ—¶å‡½æ•°çš„è°ƒç”¨è¿‡ç¨‹ã€‚
</code></pre></div></div>

<p>é€šè¿‡straceåˆ†ægo1.14çš„å˜åŒ–</p>

<p>å†™ä¸ªè„šæœ¬å¤§é‡çš„åˆ›å»ºå‘¨æœŸè¾ƒé•¿çš„å®šæ—¶å™¨ï¼Œä½†æ¯ç»„æ–°çš„å®šæ—¶å™¨è¦æ¯”ä¸Šæ¬¡å°ï¼Œæœ€å°çš„ç­‰å¾…æ—¶é—´ä¸º5ç§’ã€‚</p>

<p>ä¸‹é¢æ˜¯go1.13å®šæ—¶å™¨çš„è¡¨ç°ï¼Œé€šè¿‡straceå¯ä»¥çœ‹åˆ°ç©ºé—²æœŸå‡ºç°å¤šä¸ªçº¿ç¨‹æŒ‚åœ¨futexç³»ç»Ÿè°ƒç”¨ä¸Šã€‚futexä¸»è¦æœ‰ä¸¤ä¸ªflagï¼ŒFUTEX_WAIT_PRIVATEä¸ºä¼‘çœ ï¼ŒFUTEX_WAIT_PRIVATEä¸ºå”¤é†’ï¼Œfutexçš„ç¬¬å››ä¸ªå‚æ•°ä¸ºè¶…æ—¶æ—¶é—´ã€‚</p>

<p>// xiaorui.cc</p>

<p>[pid 21518] 09:14:34 futex(0xc0000ba4c8, FUTEX_WAIT_PRIVATE, 0, NULL &lt;unfinished â€¦&gt;
[pid 21517] 09:14:34 futex(0xc00033a4c8, FUTEX_WAIT_PRIVATE, 0, NULL &lt;unfinished â€¦&gt;
[pid 21516] 09:14:34 futex(0xc0000aa4c8, FUTEX_WAIT_PRIVATE, 0, NULL &lt;unfinished â€¦&gt;
[pid 21496] 09:14:34 futex(0x96bb20, FUTEX_WAKE_PRIVATE, 1 &lt;unfinished â€¦&gt;
[pid 21493] 09:14:34 futex(0x96bb40, FUTEX_WAIT_PRIVATE, 0, {4, 939313694} &lt;unfinished â€¦&gt;
[pid 21496] 09:14:34 &lt;â€¦ futex resumed&gt; ) = 0 &lt;0.000021&gt;
[pid 21496] 09:14:34 futex(0xc0000ba148, FUTEX_WAIT_PRIVATE, 0, NULL &lt;unfinished â€¦&gt;</p>

<p>// ç­‰å¾…äº†å°†è¿‘5ç§’åè¢«å”¤é†’.</p>

<p>[pid 21491] 09:14:34 futex(0x967d30, FUTEX_WAIT_PRIVATE, 0, {60, 0} &lt;unfinished â€¦&gt;
[pid 21493] 09:14:39 futex(0x967d30, FUTEX_WAKE_PRIVATE, 1) = 1 &lt;0.000013&gt;
[pid 21491] 09:14:39 &lt;â€¦ futex resumed&gt; ) = 0 &lt;4.937629&gt;
[pid 21493] 09:14:39 futex(0xc0000ba148, FUTEX_WAKE_PRIVATE, 1 &lt;unfinished â€¦&gt;
[pid 21496] 09:14:39 &lt;â€¦ futex resumed&gt; ) = 0 &lt;4.939627&gt;
[pid 21493] 09:14:39 futex(0xc0000aa4c8, FUTEX_WAKE_PRIVATE, 1 &lt;unfinished â€¦&gt;
[pid 21516] 09:14:39 &lt;â€¦ futex resumed&gt; ) = 0 &lt;4.939849&gt;
ä¸‹é¢æ˜¯go1.14çš„å®šæ—¶å™¨è¡¨ç°ï¼Œå¯ä»¥çœ‹åˆ°åªæœ‰ä¸€ä¸ªçº¿ç¨‹é™·å…¥epoll_pwaitè¶…æ—¶ä¼‘çœ ï¼Œepoll waitçš„æ—¶é—´å•ä½æ˜¯æ¯«ç§’ï¼Œé‚£ä¹ˆ4877å°†è¿‘5sã€‚</p>

<p>// xiaorui.cc</p>

<p>[pid 22039] 09:16:42 epoll_pwait(3, {{EPOLLIN, {u32=10005312, u64=10005312}}}, 128, 4877, NULL) = 1 &lt;0.000004&gt;</p>

<p>// ç­‰å¾…äº†5s â€¦</p>

<p>[pid 22039] 09:16:47 &lt;â€¦ epoll_pwait resumed&gt; {}, 128, 4876, NULL) = 0 &lt;4.877084&gt;
[pid 22039] 09:16:47 epoll_pwait(3,  &lt;unfinished â€¦&gt;
[pid 22039] 09:16:47 &lt;â€¦ epoll_pwait resumed&gt; {}, 128, 0, NULL) = 0 &lt;0.000029&gt;
[pid 22040] 09:16:47 epoll_pwait(3,  &lt;unfinished â€¦&gt;
go1.14æ€§èƒ½ä¼˜åŒ–</p>

<p>æ€§èƒ½æ€ä¹ˆå°±æé«˜äº†ï¼Ÿ ğŸ˜…</p>

<p>é”ç«äº‰å†²çªå‡å°‘ï¼Ÿgo1.14è™½ç„¶æŠŠtimersæ”¾åˆ°äº†pç»“æ„ä¸­ï¼Œä½†æœ¬pæ“ä½œå †ä¾ç„¶ä¹Ÿéœ€è¦åŠ é”ã€‚å› ä¸º1.14çš„findrunnableæ–¹æ³•ä¼šå·å…¶ä»–pçš„timersä»»åŠ¡ï¼Œä¸ºäº†å†™å®‰å…¨å¿…ç„¶æ˜¯åŠ é”çš„ã€‚å¦å¤–ï¼Œ1.13çš„é”çš„ç²’åº¦èŒƒå›´è·Ÿ1.14æ˜¯å·®ä¸å¤šçš„ï¼Œæ¯ä¸ªtimerprocæœ‰æŒ‡å®šçš„timerså’Œlockï¼Œæœ€å¤§æ‹†åˆ†64ã€‚å¯ä»¥æƒ³è±¡æ“ä½œtimersç»“æ„çš„é”è²Œä¼¼æ²¡å‡å°‘ã€‚</p>

<p>ä½†é—®é¢˜æ¥äº†ï¼Œgo1.13ä¼šæœ‰æ›´å¤šçš„çº¿ç¨‹å»å¤„ç†timerprocæ“ä½œnotetsleepgï¼Œç»§è€Œå¼•å‘entersyscallblockè°ƒç”¨ï¼Œè¯¥æ–¹æ³•ä¼šä¸»åŠ¨è§£ç»‘handoffpã€‚é‚£ä¹ˆå½“ä¸‹ä¸€ä¸ªå®šæ—¶äº‹ä»¶åˆ°æ¥æ—¶ï¼Œåˆå°è¯•å»pmgç»‘å®šï¼Œç»‘å®šæ—¶æœ‰æ¶‰åŠåˆ°sched.locké”ã€‚</p>

<p>é€šè¿‡ä¸‹é¢çš„ç³»ç»Ÿè°ƒç”¨ç»Ÿè®¡æ•°æ®æ¥çœ‹ï¼Œgo1.13ä¸å•æ˜¯futexç™¾åˆ†æ¯”å¤§ï¼Œè€Œä¸”è¿˜ç›¸å½“çš„è€—æ—¶ã€‚</p>

<p>// xiaorui.cc</p>

<p>go1.13</p>

<p>% time     seconds  usecs/call     calls    errors syscall
â€”â€” â€”â€”â€”â€“ â€”â€”â€”â€“ â€”â€”â€” â€”â€”â€” â€”â€”â€”â€”â€”-
 79.37  114.646338        6223     18422      5370 futex
 18.88   27.277894        1190     22919           nanosleep
  1.75    2.521039           0  15031115           clock_gettime</p>

<p>go1.14</p>

<p>% time     seconds  usecs/call     calls    errors syscall
â€”â€” â€”â€”â€”â€“ â€”â€”â€”â€“ â€”â€”â€” â€”â€”â€” â€”â€”â€”â€”â€”-
 53.74   24.281933         242    100240     96899 futex
 43.02   19.437270         295     65827         3 nanosleep
  2.76    1.246966           0  10975847           clock_gettime
  0.44    0.197550          17     11900           epoll_pwait
runtimeè°ƒåº¦å¼€é”€ï¼Ÿgo1.13æœ€å¤šå¯ä»¥å¼€åˆ°GOMAXPROCSæ•°é‡çš„timerprocåç¨‹ï¼Œå½“ç„¶ä¸è¶…è¿‡64ã€‚ä½†æˆ‘ä»¬è¦çŸ¥é“timerprocè‡ªèº«å°±æ˜¯åç¨‹ï¼Œä¹Ÿéœ€è¦runtime pmgçš„è°ƒåº¦ã€‚åè€Œgo 1.14æŠŠæ£€æŸ¥åˆ°æœŸå®šæ—¶ä»»åŠ¡çš„å·¥ä½œäº¤ç»™äº†runtime.scheduleï¼Œä¸éœ€è¦é¢å¤–çš„è°ƒåº¦ï¼Œæ¯æ¬¡runtime.scheduleå’Œfindrunableæ—¶ç›´æ¥è¿è¡Œåˆ°æœŸçš„å®šæ—¶ä»»åŠ¡ã€‚</p>

<p>çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ï¼Ÿæ–°æ·»åŠ çš„å®šæ—¶ä»»åŠ¡çš„åˆ°æœŸæ—¶é—´æ›´å°æ—¶ï¼Œä¸ç®¡æ˜¯ä½¿ç”¨futexè¿˜æ˜¯epoll_waitç³»ç»Ÿè°ƒç”¨éƒ½ä¼šè¢«å”¤é†’é‡æ–°ä¼‘çœ ï¼Œè¢«å”¤é†’çš„çº¿ç¨‹ä¼šäº§ç”Ÿä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚ä½†ç”±äºgo1.14æ²¡æœ‰timerprocçš„å­˜åœ¨ï¼Œæ–°å®šæ—¶ä»»åŠ¡å¯ç›´æ¥æ’å…¥æˆ–å¤šæ¬¡æ’å…¥åå†è€ƒè™‘æ˜¯å¦ä¼‘çœ ã€‚</p>

<p>ç»“è®ºï¼Œgolang 1.13çš„å®šæ—¶å™¨åœ¨ä»»åŠ¡ç¹å¤šæ—¶ï¼Œå¿…ç„¶ä¼šé€ æˆæ›´å¤šçš„ä¸Šçº¿æ–‡åˆ‡æ¢åŠruntime pmgè°ƒåº¦ï¼Œè€Œgolang 1.14åšäº†æ›´å¥½çš„ä¼˜åŒ–ã€‚</p>

<p>é€šè¿‡prometheusç›‘æ§å¯ä»¥çœ‹åˆ°ä¸¤ä¸ªç‰ˆæœ¬cpuçš„ä½¿ç”¨ç‡å¯¹æ¯”ï¼Œgo1.14è¦æ¯”go1.13æ˜¯èŠ‚çœäº†ä¸€äº›èµ„æºã€‚</p>

<p>golang timer æ€§èƒ½ä¼˜åŒ–
åŠ å…¥go tool pprofçš„æ€§èƒ½è¡¨ç°ï¼Œå¯ä»¥çœ‹åˆ°æ–°ä»»åŠ¡çš„æ·»åŠ ç¡®å®å¿«äº†ã€‚</p>

<p>golang å®šæ—¶å™¨
golang timer
1.13 vs 1.14æ€§èƒ½å¯¹æ¯”ï¼Ÿ</p>

<p>è¿™æ˜¯å®˜æ–¹ç»™å‡ºçš„go1.14 vs 1.13å®šæ—¶å™¨æ€§èƒ½æµ‹è¯•ï¼Œçœ‹ç»“æœéšç€gomaxprocsçš„å¢å¤šï¼Œæ€§èƒ½è¡¨ç°ä¹Ÿè¶Šæ¥è¶Šå¥½ã€‚ å®˜æ–¹æ²¡æœ‰æä¾›ååŠæ®µæµ‹è¯•çš„æ–¹æ³•ã€‚</p>

<p>https://github.com/golang/go/commit/76f4fd8a5251b4f63ea14a3c1e2fe2e78eb74f81</p>

<p>Below are relevant benchmark results for various GOMAXPROCS values
on linux/amd64:</p>

<p>context package:</p>

<p>name                                     old time/op  new time/op  delta
WithTimeout/concurrency=40      4.92Âµs Â± 0%  5.17Âµs Â± 1%  +5.07%  (p=0.000 n=9+9)
WithTimeout/concurrency=4000    6.03Âµs Â± 1%  6.49Âµs Â± 0%  +7.63%  (p=0.000 n=8+10)
WithTimeout/concurrency=400000  8.58Âµs Â± 7%  9.02Âµs Â± 4%  +5.02%  (p=0.019 n=10+10)</p>

<p>name                                     old time/op  new time/op  delta
WithTimeout/concurrency=40-2      3.70Âµs Â± 1%  2.78Âµs Â± 4%  -24.90%  (p=0.000 n=8+9)
WithTimeout/concurrency=4000-2    4.49Âµs Â± 4%  3.67Âµs Â± 5%  -18.26%  (p=0.000 n=10+10)
WithTimeout/concurrency=400000-2  6.16Âµs Â±10%  5.15Âµs Â±13%  -16.30%  (p=0.000 n=10+10)</p>

<p>name                                     old time/op  new time/op  delta
WithTimeout/concurrency=40-4      3.58Âµs Â± 1%  2.64Âµs Â± 2%  -26.13%  (p=0.000 n=9+10)
WithTimeout/concurrency=4000-4    4.17Âµs Â± 0%  3.32Âµs Â± 1%  -20.36%  (p=0.000 n=10+10)
WithTimeout/concurrency=400000-4  5.57Âµs Â± 9%  4.83Âµs Â±10%  -13.27%  (p=0.001 n=10+10)</p>

<p>time package:</p>

<p>name                     old time/op  new time/op  delta
AfterFunc                6.15ms Â± 3%  6.07ms Â± 2%     ~     (p=0.133 n=10+9)
AfterFunc-2              3.43ms Â± 1%  3.56ms Â± 1%   +3.91%  (p=0.000 n=10+9)
AfterFunc-4              5.04ms Â± 2%  2.36ms Â± 0%  -53.20%  (p=0.000 n=10+9)
After                    6.54ms Â± 2%  6.49ms Â± 3%     ~     (p=0.393 n=10+10)
After-2                  3.68ms Â± 1%  3.87ms Â± 0%   +5.14%  (p=0.000 n=9+9)
After-4                  6.66ms Â± 1%  2.87ms Â± 1%  -56.89%  (p=0.000 n=10+10)
Stop                      698Âµs Â± 2%   689Âµs Â± 1%   -1.26%  (p=0.011 n=10+10)
Stop-2                    729Âµs Â± 2%   434Âµs Â± 3%  -40.49%  (p=0.000 n=10+10)
Stop-4                    837Âµs Â± 3%   333Âµs Â± 2%  -60.20%  (p=0.000 n=10+10)
SimultaneousAfterFunc     694Âµs Â± 1%   692Âµs Â± 7%     ~     (p=0.481 n=10+10)
SimultaneousAfterFunc-2   714Âµs Â± 3%   569Âµs Â± 2%  -20.33%  (p=0.000 n=10+10)
SimultaneousAfterFunc-4   782Âµs Â± 2%   386Âµs Â± 2%  -50.67%  (p=0.000 n=10+10)
StartStop                 267Âµs Â± 3%   274Âµs Â± 0%   +2.64%  (p=0.000 n=8+9)
StartStop-2               238Âµs Â± 2%   140Âµs Â± 3%  -40.95%  (p=0.000 n=10+8)
StartStop-4               320Âµs Â± 1%   125Âµs Â± 1%  -61.02%  (p=0.000 n=9+9)
Reset                    75.0Âµs Â± 1%  77.5Âµs Â± 2%   +3.38%  (p=0.000 n=10+10)
Reset-2                   150Âµs Â± 2%    40Âµs Â± 5%  -73.09%  (p=0.000 n=10+9)
Reset-4                   226Âµs Â± 1%    33Âµs Â± 1%  -85.42%  (p=0.000 n=10+10)
Sleep                     857Âµs Â± 6%   878Âµs Â± 9%     ~     (p=0.079 n=10+9)
Sleep-2                   617Âµs Â± 4%   585Âµs Â± 2%   -5.21%  (p=0.000 n=10+10)
Sleep-4                   689Âµs Â± 3%   465Âµs Â± 4%  -32.53%  (p=0.000 n=10+10)
Ticker                   55.9ms Â± 2%  55.9ms Â± 2%     ~     (p=0.971 n=10+10)
Ticker-2                 28.7ms Â± 2%  28.1ms Â± 1%   -2.06%  (p=0.000 n=10+10)
Ticker-4                 14.6ms Â± 0%  13.6ms Â± 1%   -6.80%  (p=0.000 n=9+10)
æ€»ç»“:</p>

<p>go1.14çš„å®šæ—¶å™¨è™½ç„¶åšäº†ä¸å°‘æ€§èƒ½ä¼˜åŒ–ï¼Œè®©è¿™ä¸ªæ‰€è°“çš„æ€§èƒ½æ€æ‰‹ä¹Ÿå¾—ä»¥â€å–˜æ¯â€ï¼Œä½†ä»è®¾è®¡æ¨¡å‹ä¸Šæ¥è¯´ï¼Œè¿˜æ˜¯è·Ÿç²—ç²¾åº¦çš„æ—¶é—´è½®æœ‰æ€§èƒ½å·®è·ã€‚</p>

<p>golang æ—¶é—´è½®</p>

:ET