I"œF<p>1ã€zend_hash_num_elements è·å–æ•°ç»„å…ƒç´ ä¸ªæ•°ã€‚å®å®šä¹‰å¦‚ä¸‹ï¼š
1 #define zend_hash_num_elements(ht) <br />
2     (ht)-&gt;nNumOfElements
2ã€ZEND_HASH_FOREACH_KEY_VAL éå†æ•°ç»„é”®å€¼ã€‚ä½¿ç”¨æ–¹æ³•ï¼š
1 ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL_P(array), num_key, string_key, entry) {
2             // code
3 } ZEND_HASH_FOREACH_END();
ã€€ZEND_HASH_FOREACH_KEY_VALæ˜¯ä¸ªå®å‡½æ•°ï¼š
1 #define ZEND_HASH_FOREACH_KEY_VAL(ht, _h, _key, _val) <br />
2     ZEND_HASH_FOREACH(ht, 0); <br />
3     _h = _p-&gt;h; <br />
4     _key = _p-&gt;key; <br />
5     _val = _z;
ã€€  ç»§ç»­å±•å¼€ ZEND_HASH_FOREACHï¼š</p>

<p>å¤åˆ¶ä»£ç 
1 #define ZEND_HASH_FOREACH(_ht, indirect) do { <br />
2         Bucket *_p = (_ht)-&gt;arData; <br />
3         Bucket *_end = _p + (_ht)-&gt;nNumUsed; <br />
4         for (; _p != _end; _p++) { <br />
5             zval *_z = &amp;_p-&gt;val; <br />
6             if (indirect &amp;&amp; Z_TYPE_P(_z) == IS_INDIRECT) { <br />
7                 _z = Z_INDIRECT_P(_z); <br />
8             } <br />
9             if (UNEXPECTED(Z_TYPE_P(_z) == IS_UNDEF)) continue;
å¤åˆ¶ä»£ç 
ZEND_HASH_FOREACH_ENDå±•å¼€ï¼š
1 #define ZEND_HASH_FOREACH_END() <br />
2         } <br />
3     } while (0)</p>

<p>ZEND_HASH_FOREACH_KEY_VAL(Z_ARRVAL_P(array), num_key, string_key, entry) {
             // code
} ZEND_HASH_FOREACH_END();
å®Œå…¨å±•å¼€ï¼š
å¤åˆ¶ä»£ç 
 1 do { 
 2     Bucket *_p = (_ht)-&gt;arData;  // Z_ARRVAL_P(array) â€”&gt; ht â€”&gt; _ht
 3     Bucket *_end = _p + (_ht)-&gt;nNumUsed;  // èµ·å§‹åœ°å€+åç§»åœ°å€
 4     for (; _p != _end; _p++) { 
 5         zval *_z = &amp;_p-&gt;val; 
 6         if (indirect &amp;&amp; Z_TYPE_P(_z) == IS_INDIRECT) { 
 7             _z = Z_INDIRECT_P(_z); 
 8         } 
 9         if (UNEXPECTED(Z_TYPE_P(_z) == IS_UNDEF)) continue;
10         _h = _p-&gt;h;  // zend_ulong num_key â€”&gt; _h
11         _key = _p-&gt;key; // zend_string *string_key â€”&gt; _key
12         _val = _z; // zval *entry â€”&gt; _val
13         {
14            //code
15         } 
16     } 
17 } while (0)
å¤åˆ¶ä»£ç </p>

<!-- more -->
<p>https://www.cnblogs.com/natian-ws/p/9105338.html
Â Â Â Â Â Â æ•°ç»„
æœ¬èŠ‚æˆ‘ä»¬è®²ä¸€ä¸‹phpçš„æ•°ç»„ï¼Œåœ¨phpä¸­ï¼Œæ•°ç»„ä½¿ç”¨HashTableå®ç°çš„ã€‚æœ¬èŠ‚ä¸­æˆ‘ä»¬å…ˆè¯¦ç»†çš„ä»‹ç»ä¸€ä¸‹HashTableï¼Œç„¶åå†è®²è®²å¦‚ä½•ä½¿ç”¨HastTable</p>

<p>1.1Â Â Â Â Â å˜é•¿ç»“æ„ä½“
æ‰€è°“çš„å˜é•¿ç»“æ„ä½“ï¼Œå…¶å®æ˜¯æˆ‘ä»¬Cè¯­è¨€ç»“æ„ä½“çš„ä¸€ç§ç‰¹æ®Šç”¨æ³•ï¼Œå¹¶æ²¡æœ‰ä»€ä¹ˆæ–°å¥‡ä¹‹å¤„ã€‚æˆ‘ä»¬å…ˆæ¥çœ‹ä¸€ä¸‹å˜é•¿ç»“æ„ä½“çš„ä¸€ç§é€šç”¨å®šä¹‰æ–¹æ³•ã€‚</p>

<p>typedef struct bucket {</p>

<p>Â Â Â  int n;</p>

<p>Â Â Â  char key[30];</p>

<p>Â Â Â  char value[1];</p>

<p>} Bucket;</p>

<p>æˆ‘ä»¬å®šä¹‰äº†ä¸€ä¸ªç»“æ„ä½“Bucketï¼Œæˆ‘ä»¬å¸Œæœ›ç”¨è¿™ä¸ªç»“æ„ä½“å­˜æ”¾å­¦ç”Ÿçš„ä¸ªäººç®€ä»‹ã€‚å…¶ä¸­keyç”¨æ¥å­˜åœ¨å­¦ç”Ÿçš„å§“åï¼Œvalueç”¨æ¥å­˜æ”¾å­¦ç”Ÿçš„ç®€ä»‹ã€‚å¤§å®¶å¯èƒ½å¾ˆå¥½å¥‡ï¼Œæˆ‘ä»¬çš„valueå£°æ˜äº†é•¿åº¦ä¸º1. 1ä¸ªcharèƒ½å­˜å¤šå°‘ä¿¡æ¯å‘€ï¼Ÿ</p>

<p>Â Â Â Â Â Â Â Â  å…¶å®ï¼Œå¯¹äºå˜é•¿ç»“æ„ä½“ï¼Œæˆ‘ä»¬åœ¨ä½¿ç”¨çš„ä½¿ç”¨ä¸èƒ½ç›´æ¥å®šä¹‰å˜é‡ï¼Œä¾‹å¦‚ï¼šBucket bucket; æ‚¨è¦æ˜¯è¿™æ ·ä½¿ç”¨ï¼Œvalueè‚¯å®šå­˜å‚¨ä¸äº†å¤šå°‘ä¿¡æ¯ã€‚å¯¹äºå˜é•¿ç»“æ„ä½“ï¼Œæˆ‘ä»¬åœ¨ä½¿ç”¨çš„æ—¶å€™éœ€è¦å…ˆå£°æ˜ä¸€ä¸ªå˜é•¿ç»“æ„ä½“çš„æŒ‡é’ˆï¼Œç„¶åé€šè¿‡mallocå‡½æ•°åˆ†é…å‡½æ•°ç©ºé—´ï¼Œæˆ‘ä»¬éœ€è¦ç”¨åˆ°çš„ç©ºé—´é•¿åº¦æ˜¯å¤šå°‘ï¼Œæˆ‘ä»¬å°±å¯ä»¥mallocå¤šå°‘ã€‚é€šç”¨çš„ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š</p>

<p>Bucket* pBucket;</p>

<p>pBucket = malloc(sizeof(Bucket)+ n *sizeof(char));</p>

<p>å…¶ä¸­nå°±æ˜¯ä½ è¦ä½¿ç”¨valueçš„é•¿åº¦ã€‚å¦‚æœè¿™æ ·ä½¿ç”¨çš„è¯ï¼ŒvalueæŒ‡å‘çš„å­—ç¬¦ä¸²ä¸ä¹…å˜é•¿äº†å—ï¼</p>

<p>Â </p>

<p>1.2Â Â Â Â Â Hashtableç®€ä»‹
æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹HashTableçš„å®šä¹‰</p>

<p>struct _hashtable;</p>

<p>Â </p>

<p>typedef struct bucket {</p>

<p>Â Â Â  ulong h;//å½“å…ƒç´ æ˜¯æ•°å­—ç´¢å¼•æ—¶ä½¿ç”¨</p>

<p>Â  Â Â uint nKeyLength;//å½“ä½¿ç”¨å­—ç¬¦ä¸²ç´¢å¼•æ—¶ï¼Œè¿™ä¸ªå˜é‡è¡¨ç¤ºç´¢å¼•çš„é•¿åº¦ï¼Œç´¢å¼•ï¼ˆå­—ç¬¦ä¸²ï¼‰ä¿å­˜åœ¨æœ€åä¸€ä¸ªå…ƒç´ aKey</p>

<p>Â Â Â  void *pData;//ç”¨æ¥æŒ‡å‘ä¿å­˜çš„æ•°æ®ï¼Œå¦‚æœä¿å­˜çš„æ•°æ®æ˜¯æŒ‡é’ˆçš„è¯ï¼ŒpDataPtrå°±æŒ‡å‘è¿™ä¸ªæ•°æ®ï¼ŒpDataæŒ‡å‘pDataPtr</p>

<p>Â Â Â  void *pDataPtr;</p>

<p>Â Â Â  struct bucket *pListNext;//ä¸Šä¸€ä¸ªå…ƒç´ </p>

<p>Â Â Â  struct bucket *pListLast;//ä¸‹ä¸€ä¸ªå…ƒç´ </p>

<p>Â Â Â  struct bucket *pNext;//æŒ‡å‘ä¸‹ä¸€ä¸ªbucketçš„æŒ‡é’ˆ</p>

<p>Â Â Â  struct bucket *pLast;//æŒ‡å‘ä¸Šä¸€ä¸ªbucketçš„æŒ‡é’ˆ</p>

<p>Â Â Â  char arKey[1];//å¿…é¡»æ”¾åœ¨æœ€åï¼Œä¸»è¦æ˜¯ä¸ºäº†å®ç°å˜é•¿ç»“æ„ä½“</p>

<p>} Bucket;</p>

<p>Â </p>

<p>typedef struct _hashtable {</p>

<p>Â Â  Â uint nTableSize; Â Â Â  Â Â Â  Â Â Â  //å“ˆå¸Œè¡¨çš„å¤§å°</p>

<p>Â Â Â  uint nTableMask; Â Â Â  Â Â Â  Â Â Â  //æ•°å€¼ä¸Šç­‰äºnTableSize- 1</p>

<p>Â Â Â  uint nNumOfElements; Â Â Â  Â Â Â  //è®°å½•äº†å½“å‰HashTableä¸­ä¿å­˜çš„è®°å½•æ•°</p>

<p>Â Â Â  ulong nNextFreeElement;Â  Â Â Â  //æŒ‡å‘ä¸‹ä¸€ä¸ªç©ºé—²çš„Bucket</p>

<p>Â Â Â  Bucket *pInternalPointer;Â Â Â //è¿™ä¸ªå˜é‡ç”¨äºæ•°ç»„åè½¬</p>

<p>Â Â Â  Bucket *pListHead;Â Â Â  Â Â Â  Â Â Â //æŒ‡å‘Bucketçš„å¤´</p>

<p>Â Â Â  Bucket *pListTail;Â Â Â  Â Â Â  Â Â Â //æŒ‡å‘Bucketçš„å°¾</p>

<p>Â Â Â  Bucket **arBuckets;</p>

<p>Â Â Â  dtor_func_t pDestructor; Â Â Â  //å‡½æ•°æŒ‡é’ˆï¼Œæ•°ç»„å¢åˆ æ”¹æŸ¥æ—¶è‡ªåŠ¨è°ƒç”¨ï¼Œç”¨äºæŸäº›æ¸…ç†æ“ä½œ</p>

<p>Â Â Â  zend_bool persistent; Â Â Â  Â Â Â  //æ˜¯å¦æŒä¹…</p>

<p>Â Â Â  unsigned char nApplyCount;</p>

<p>Â Â Â  zend_bool bApplyProtection;Â  //å’ŒnApplyCountä¸€èµ·èµ·ä½œç”¨ï¼Œé˜²æ­¢æ•°ç»„éå†æ—¶æ— é™é€’å½’</p>

<p>#if ZEND_DEBUG</p>

<p>Â Â Â  int inconsistent;</p>

<p>#endif</p>

<p>} HashTable;</p>

<p>å¸Œæœ›å¤§å®¶èƒ½å¥½å¥½çœ‹çœ‹ä¸Šé¢çš„å®šä¹‰ï¼Œæœ‰äº›ä¸œè¥¿æˆ‘å°†å‡ºæ¥åè€Œä¼šè¯´ä¸æ˜ç™½ï¼Œä¸å¦‚å¤§å®¶çœ‹çœ‹ä»£ç æµ…æ˜¾æ˜äº†ã€‚PHPçš„æ•°ç»„ï¼Œå…¶å®æ˜¯ä¸€ä¸ªå¸¦æœ‰å¤´ç»“ç‚¹çš„åŒå‘é“¾è¡¨ï¼Œå…¶ä¸­HashTableæ˜¯å¤´ï¼ŒBucketå­˜å‚¨å…·ä½“çš„ç»“ç‚¹ä¿¡æ¯ã€‚</p>

<p>1.3Â Â Â Â Â HashTableå†…éƒ¨å‡½æ•°åˆ†æ
1.3.1Â Â Â Â å®HASH_PROTECT_RECURSION
#defineHASH_PROTECT_RECURSION(ht)Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â \</p>

<p>Â Â Â  if ((ht)-&gt;bApplyProtection) {Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â \</p>

<p>Â Â Â Â Â Â Â  if ((ht)-&gt;nApplyCount++ &gt;= 3){Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â \</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  zend_error(E_ERROR, â€œNestinglevel too deep - recursive dependency?â€); \</p>

<p>Â Â Â Â Â Â Â  }Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â \</p>

<p>Â Â Â  }</p>

<p>è¿™ä¸ªå®ä¸»è¦ç”¨æ¥é˜²æ­¢å¾ªç¯å¼•ç”¨ã€‚</p>

<p>1.3.2Â Â Â Â å®ZEND_HASH_IF_FULL_DO_RESIZE
#defineZEND_HASH_IF_FULL_DO_RESIZE(ht)Â Â Â Â Â Â Â Â Â Â Â Â \</p>

<p>Â Â Â  if ((ht)-&gt;nNumOfElements &gt;(ht)-&gt;nTableSize) {Â  \</p>

<p>Â Â Â Â Â Â Â  zend_hash_do_resize(ht);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  \</p>

<p>Â Â Â  }</p>

<p>Â Â Â Â Â Â Â Â  è¿™ä¸ªå®çš„ä½œç”¨æ˜¯æ£€æŸ¥ç›®å‰HashTableä¸­çš„å…ƒç´ ä¸ªæ•°æ˜¯å¦å¤§äºäº†æ€»çš„HashTableçš„å¤§å°ï¼Œå¦‚æœä¸ªæ•°å¤§äºäº†HashTableçš„å¤§å°ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±é‡æ–°åˆ†é…ç©ºé—´ã€‚æˆ‘ä»¬çœ‹ä¸€ä¸‹zend_hash_do_resize</p>

<p>static int zend_hash_do_resize(HashTable*ht)</p>

<p>{</p>

<p>Â Â Â  Bucket **t;</p>

<p>Â Â Â  IS_CONSISTENT(ht);</p>

<p>Â Â Â  if ((ht-&gt;nTableSizeÂ«1)&gt;0){Â Â Â /* Letâ€™s double the table size */</p>

<p>Â Â Â Â Â Â Â  t = (Bucket**) perealloc_recoverable(ht-&gt;arBuckets,</p>

<p>(ht-&gt;nTableSizeÂ«1)* sizeof(Bucket*), ht-&gt;persistent);</p>

<p>Â Â Â  Â Â Â Â if (t){</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  HANDLE_BLOCK_INTERRUPTIONS();</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  ht-&gt;arBuckets = t;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  ht-&gt;nTableSize = (ht-&gt;nTableSizeÂ«1);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  ht-&gt;nTableMask = ht-&gt;nTableSize-1;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  zend_hash_rehash(ht);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  HANDLE_UNBLOCK_INTERRUPTIONS();</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  return SUCCESS;</p>

<p>Â Â Â Â Â Â Â  }</p>

<p>Â Â Â Â Â Â Â  return FAILURE;</p>

<p>Â Â Â  }</p>

<p>Â Â Â  return SUCCESS;</p>

<p>}Â Â </p>

<p>Â Â Â Â Â Â Â Â  ä»ä¸Šé¢çš„ä»£ç ä¸­æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼ŒHashTableåœ¨åˆ†é…ç©ºé—´çš„æ—¶å€™ï¼Œæ–°åˆ†é…çš„ç©ºé—´ç­‰äºåŸæœ‰ç©ºé—´çš„2å€ã€‚</p>

<p>1.3.3Â Â Â Â å‡½æ•°Â _zend_hash_init
è¿™ä¸ªå‡½æ•°æ˜¯ç”¨æ¥åˆå§‹åŒ–HashTableçš„ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹ä»£ç ï¼š</p>

<p>ZEND_API int _zend_hash_init(HashTable*ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)</p>

<p>{</p>

<p>Â Â Â  uint i = 3; //HashTableçš„å¤§å°é»˜è®¤æ— 2çš„3æ¬¡æ–¹</p>

<p>Â Â Â  Bucket **tmp;</p>

<p>Â </p>

<p>Â Â Â  SET_INCONSISTENT(HT_OK);</p>

<p>Â </p>

<p>Â Â Â  if (nSize&gt;=0x80000000){</p>

<p>Â Â Â Â Â Â Â  ht-&gt;nTableSize = 0x80000000;</p>

<p>Â Â Â  } else{</p>

<p>Â Â Â Â Â Â Â  while ((1U Â«Â i)&lt; nSize){</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  i++;</p>

<p>Â Â Â Â Â Â Â  }</p>

<p>Â Â Â Â Â Â Â  ht-&gt;nTableSize = 1 Â«Â i;</p>

<p>Â Â Â  }</p>

<p>Â </p>

<p>Â Â Â  ht-&gt;nTableMask = ht-&gt;nTableSize-1;</p>

<p>Â Â Â  ht-&gt;pDestructor = pDestructor;</p>

<p>Â Â Â  ht-&gt;arBuckets =NULL;</p>

<p>Â Â Â  ht-&gt;pListHead =NULL;</p>

<p>Â Â Â  ht-&gt;pListTail =NULL;</p>

<p>Â Â Â  ht-&gt;nNumOfElements = 0;</p>

<p>Â Â Â  ht-&gt;nNextFreeElement = 0;</p>

<p>Â Â Â  ht-&gt;pInternalPointer = NULL;</p>

<p>Â Â Â  ht-&gt;persistent = persistent;</p>

<p>Â Â Â  ht-&gt;nApplyCount =0;</p>

<p>Â Â Â  ht-&gt;bApplyProtection = 1;</p>

<p>Â Â Â </p>

<p>Â Â Â  /* Uses ecalloc() so that Bucket* == NULL */</p>

<p>Â Â Â  if (persistent){</p>

<p>Â Â Â Â Â Â Â  tmp = (Bucket <em>*) calloc(ht-&gt;nTableSize,sizeof(Bucket</em>));</p>

<p>Â Â Â Â Â Â Â  if (!tmp){</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  return FAILURE;</p>

<p>Â Â Â Â Â Â Â  }</p>

<p>Â Â Â Â Â Â Â  ht-&gt;arBuckets = tmp;</p>

<p>Â Â Â  } else{</p>

<p>Â Â Â Â Â Â Â  tmp = (Bucket <em>*) ecalloc_rel(ht-&gt;nTableSize,sizeof(Bucket</em>));</p>

<p>Â Â Â Â Â Â Â  if (tmp){</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  ht-&gt;arBuckets = tmp;</p>

<p>Â Â Â Â Â Â Â  }</p>

<p>Â Â Â  }</p>

<p>Â Â Â </p>

<p>Â Â Â  return SUCCESS;</p>

<p>}</p>

<p>å¯ä»¥çœ‹å‡ºï¼ŒHashTableçš„å¤§å°è¢«åˆå§‹åŒ–ä¸º2çš„næ¬¡æ–¹ï¼Œå¦å¤–æˆ‘ä»¬çœ‹åˆ°æœ‰ä¸¤ç§å†…å­˜æ–¹å¼ï¼Œä¸€ç§æ˜¯callocï¼Œä¸€ç§æ˜¯ecalloc_relï¼Œè¿™ä¸¤ä¸­å†…å­˜åˆ†é…æ–¹å¼æˆ‘ä»¬ç»†è®²äº†ï¼Œæœ‰å…´è¶£çš„è¯å¤§å®¶å¯ä»¥è‡ªå·±æŸ¥ä¸€æŸ¥ã€‚</p>

<p>1.3.4Â Â Â Â å‡½æ•°_zend_hash_add_or_update
è¿™ä¸ªå‡½æ•°å‘HashTableä¸­æ·»åŠ æˆ–è€…ä¿®æ”¹å…ƒç´ ä¿¡æ¯</p>

<p>ZEND_API int _zend_hash_add_or_update(HashTable<em>ht,constchar *arKey, uint nKeyLength,void</em>pData, uint nDataSize,void**pDest,int flag ZEND_FILE_LINE_DC)</p>

<p>{</p>

<p>Â Â Â  ulong h;</p>

<p>Â Â Â  uint nIndex;</p>

<p>Â Â Â  Bucket *p;</p>

<p>Â </p>

<p>Â Â Â  IS_CONSISTENT(ht);</p>

<p>Â </p>

<p>Â Â Â  if (nKeyLength&lt;=0){</p>

<p>#if ZEND_DEBUG</p>

<p>Â Â Â Â Â Â Â  ZEND_PUTS(â€œzend_hash_update: Canâ€™t put inempty key\nâ€);</p>

<p>#endif</p>

<p>Â Â Â Â Â Â Â  return FAILURE;</p>

<p>Â Â Â  }</p>

<p>Â </p>

<p>Â Â Â  h = zend_inline_hash_func(arKey, nKeyLength);</p>

<p>Â Â Â  nIndex = h &amp; ht-&gt;nTableMask;</p>

<p>Â </p>

<p>Â Â Â  p = ht-&gt;arBuckets[nIndex];</p>

<p>Â Â Â  while (p!=NULL){</p>

<p>Â Â Â Â Â Â Â  if ((p-&gt;h== h)&amp;&amp;(p-&gt;nKeyLength== nKeyLength)){</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  if (!memcmp(p-&gt;arKey, arKey, nKeyLength)){</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (flag &amp; HASH_ADD){</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return FAILURE;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  HANDLE_BLOCK_INTERRUPTIONS();</p>

<p>#if ZEND_DEBUG</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (p-&gt;pData == pData){</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ZEND_PUTS(â€œFatal error in zend_hash_update:p-&gt;pData == pData\nâ€);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  HANDLE_UNBLOCK_INTERRUPTIONS();</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return FAILURE;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }</p>

<p>#endif</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (ht-&gt;pDestructor){</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  ht-&gt;pDestructor(p-&gt;pData);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  UPDATE_DATA(ht, p, pData, nDataSize);</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  if (pDest) {</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  *pDest = p-&gt;pData;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  }</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  HANDLE_UNBLOCK_INTERRUPTIONS();</p>

<p>Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  return SUCCESS;</p>

<p>Â Â Â Â Â Â Â Â Â Â Â  }</p>

<p>Â Â Â Â Â Â Â  }</p>

<p>Â Â Â Â Â Â Â  p = p-&gt;pNext;</p>

<p>Â Â Â  }</p>

<p>Â Â Â </p>

<p>Â Â Â  p = (Bucket*) pemalloc(sizeof(Bucket)-1 + nKeyLength, ht-&gt;persistent);</p>

<p>Â Â Â  if (!p){</p>

<p>Â Â Â Â Â Â Â  return FAILURE;</p>

<p>Â Â Â  }</p>

<p>Â Â Â  memcpy(p-&gt;arKey, arKey, nKeyLength);</p>

<p>Â Â Â  p-&gt;nKeyLength = nKeyLength;</p>

<p>Â Â Â  INIT_DATA(ht, p, pData, nDataSize);</p>

<p>Â Â Â  p-&gt;h = h;</p>

<p>Â Â Â  CONNECT_TO_BUCKET_DLLIST(p, ht-&gt;arBuckets[nIndex]);</p>

<p>Â Â Â  if (pDest){</p>

<p>Â Â Â Â Â Â Â  *pDest = p-&gt;pData;</p>

<p>Â Â Â  }</p>

<p>Â </p>

<p>Â Â Â  HANDLE_BLOCK_INTERRUPTIONS();</p>

<p>Â Â Â  CONNECT_TO_GLOBAL_DLLIST(p, ht);</p>

<p>Â Â Â  ht-&gt;arBuckets[nIndex]= p;</p>

<p>Â Â Â  HANDLE_UNBLOCK_INTERRUPTIONS();</p>

<p>Â </p>

<p>Â Â Â  ht-&gt;nNumOfElements++;</p>

<p>Â Â Â  ZEND_HASH_IF_FULL_DO_RESIZE(ht);Â Â Â Â Â Â Â /* If the Hash table is full, resize it */</p>

<p>Â Â Â  return SUCCESS;</p>

<p>}</p>

<p>1.3.5Â Â Â Â å®CONNECT_TO_BUCKET_DLLIST
#define CONNECT_TO_BUCKET_DLLIST(element, list_head)Â Â Â Â Â Â Â  \</p>

<p>Â Â Â  (element)-&gt;pNext= (list_head);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  \</p>

<p>Â Â Â  (element)-&gt;pLast= NULL;Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  \</p>

<p>Â Â Â  if((element)-&gt;pNext) {Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  \</p>

<p>Â  Â Â Â Â Â Â (element)-&gt;pNext-&gt;pLast =(element);Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  \</p>

<p>Â Â Â  }</p>

<p>è¿™ä¸ªå®æ˜¯å°†bucketåŠ å…¥åˆ°bucketé“¾è¡¨ä¸­</p>

<p>1.3.6Â Â Â Â å…¶ä»–å‡½æ•°æˆ–è€…å®å®šä¹‰
æˆ‘ä»¬åªæ˜¯ç®€å•çš„ä»‹ç»ä¸€ä¸‹HashTableï¼Œå¦‚æœä½ æƒ³ç»†è‡´çš„äº†è§£HashTableçš„è¯ï¼Œå»ºè®®æ‚¨çœ‹çœ‹phpçš„æºä»£ç ï¼Œå…³äºHashTableçš„ä»£ç åœ¨Zend/zend_hash.h å’ŒZend/zend_hash.cä¸­ã€‚</p>

<p>zend_hash_add_empty_elementÂ ç»™å‡½æ•°å¢åŠ ä¸€ä¸ªç©ºå…ƒç´ </p>

<p>zend_hash_del_key_or_indexÂ æ ¹æ®ç´¢å¼•åˆ é™¤å…ƒç´ </p>

<p>zend_hash_reverse_applyÂ Â åå‘éå†HashTable</p>

<p>zend_hash_copyÂ Â æ‹·è´</p>

<p>_zend_hash_mergeÂ Â åˆå¹¶</p>

<p>zend_hash_findÂ Â å­—ç¬¦ä¸²ç´¢å¼•æ–¹å¼æŸ¥æ‰¾</p>

<p>zend_hash_index_findÂ Â æ•°å€¼ç´¢å¼•æ–¹æ³•æŸ¥æ‰¾</p>

<p>zend_hash_quick_findÂ Â ä¸Šé¢ä¸¤ä¸ªå‡½æ•°çš„å°è£…</p>

<p>zend_hash_existsÂ Â æ˜¯å¦å­˜åœ¨ç´¢å¼•</p>

<p>zend_hash_index_existsÂ Â æ˜¯å¦å­˜åœ¨ç´¢å¼•</p>

<p>zend_hash_quick_existsÂ Â ä¸Šé¢ä¸¤ä¸ªæ–¹æ³•çš„å°è£…</p>

<p>1.4Â Â Â Â Â Cæ‰©å±•å¸¸ç”¨HashTableå‡½æ•°
è™½ç„¶HashTableçœ‹èµ·æ¥æœ‰ç‚¹å¤æ‚ï¼Œä½†æ˜¯ä½¿ç”¨å´æ˜¯å¾ˆæ–¹ä¾¿çš„ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢çš„å‡½æ•°å¯¹HashTableè¿›è¡Œåˆå§‹åŒ–å’Œèµ‹å€¼ã€‚</p>

<p>2005 å¹´åœ°æ–¹é™¢æ ¡æ‹›ç”Ÿäººæ•°</p>

<p>PHPè¯­æ³•</p>

<p>Cè¯­æ³•</p>

<p>æ„ä¹‰</p>

<p>$arr = array()</p>

<p>array_init(arr);</p>

<p>åˆå§‹åŒ–æ•°ç»„</p>

<p>$arr[] = NULL;</p>

<p>add_next_index_null(arr);</p>

<p>Â </p>

<p>$arr[] = 42;</p>

<p>add_next_index_long(arr, 42);</p>

<p>Â </p>

<p>$arr[] = true;</p>

<p>add_next_index_bool(arr, 1);</p>

<p>Â </p>

<p>$arr[] = 3.14;</p>

<p>add_next_index_double(3.14);</p>

<p>Â </p>

<p>$arr[] = â€˜fooâ€™;</p>

<p>add_next_index_string(arr, â€œfooâ€, 1);</p>

<p>1çš„æ„æ€è¿›è¡Œå­—ç¬¦ä¸²æ‹·è´</p>

<p>$arr[] = $myvar;</p>

<p>add_next_index_zval(arr, myvar);</p>

<p>Â </p>

<p>$arr[0] = NULL;</p>

<p>add_index_null(arr, 0);</p>

<p>Â </p>

<p>$arr[1] = 42;</p>

<p>add_index_long(arr, 1, 42);</p>

<p>Â </p>

<p>$arr[2] = true;</p>

<p>add_index_bool(arr, 2, 1);</p>

<p>Â </p>

<p>$arr[3] = 3.14;</p>

<p>add_index_double(arr, 3, 3,14);</p>

<p>Â </p>

<p>$arr[4] = â€˜fooâ€™;</p>

<p>add_index_string(arr, 4, â€œfooâ€, 1);</p>

<p>Â </p>

<p>$arr[5] = $myvar;</p>

<p>add_index_zval(arr, 5, myvar);</p>

<p>Â </p>

<p>$arr[â€œabcâ€] = NULL;</p>

<p>add_assoc_null(arr, â€œabcâ€);</p>

<p>Â </p>

<p>$arr[â€œdefâ€] = 711;</p>

<p>add_assoc_long(arr, â€œdefâ€, 711);</p>

<p>Â </p>

<p>$arr[â€œghiâ€] = true;</p>

<p>add_assoc_bool(arr, ghiâ€, 1);</p>

<p>Â </p>

<p>$arr[â€œjklâ€] = 1.44;</p>

<p>add_assoc_double(arr, â€œjklâ€, 1.44);</p>

<p>Â </p>

<p>$arr[â€œmnoâ€] = â€˜bazâ€™;</p>

<p>add_assoc_string(arr, â€œmnoâ€, â€œbazâ€, 1);</p>

<p>Â </p>

<p>$arr[â€˜pqrâ€™] = $myvar;</p>

<p>add_assoc_zval(arr, â€œpqrâ€, myvar);</p>

<p>Â </p>

<p>1.5Â Â Â Â Â ä»»åŠ¡å’Œå®éªŒ
è¯´äº†è¿™ä¹ˆå¤šï¼Œæˆ‘ä»¬å®éªŒä¸€ä¸‹ã€‚</p>

<p>ä»»åŠ¡ï¼šè¿”å›ä¸€ä¸ªæ•°ç»„ï¼Œæ•°ç»„ä¸­çš„æ•°æ®å¦‚ä¸‹ï¼š</p>

<p>Array</p>

<p>(</p>

<p>Â Â Â [0] =&gt; for test</p>

<p>Â Â Â [42] =&gt; 123</p>

<p>Â Â Â [for test. for test.] =&gt; 1</p>

<p>Â Â Â [array] =&gt; Array</p>

<p>Â Â Â Â Â Â Â (</p>

<p>Â Â Â Â Â Â Â Â Â Â Â [0] =&gt; 3.34</p>

<p>Â Â Â Â Â Â Â )</p>

<p>)</p>

<p>ä»£ç å®ç°ï¼š</p>

<p>PHP_FUNCTION(test)</p>

<p>{</p>

<p>Â Â Â  zval* t;</p>

<p>Â </p>

<p>Â Â Â  array_init(return_value);</p>

<p>Â Â Â  add_next_index_string(return_value,â€for testâ€,1);</p>

<p>Â Â Â  add_index_long(return_value,42,123);</p>

<p>Â Â Â  add_assoc_double(return_value,â€for test. for test.â€,1.0);</p>

<p>Â Â Â </p>

<p>Â Â Â  ALLOC_INIT_ZVAL(t);</p>

<p>Â Â Â  array_init(t);</p>

<p>Â Â Â  add_next_index_double(t,3.34);</p>

<p>Â </p>

<p>Â Â Â  add_assoc_zval(return_value,â€arrayâ€, t);</p>

<p>}</p>

<p>å¾ˆç®€å•å§ï¼Œè¿˜è®°å¾—return_valueå—ï¼Ÿ</p>

<p>https://blog.csdn.net/niujiaming0819/article/details/8568587</p>

:ET