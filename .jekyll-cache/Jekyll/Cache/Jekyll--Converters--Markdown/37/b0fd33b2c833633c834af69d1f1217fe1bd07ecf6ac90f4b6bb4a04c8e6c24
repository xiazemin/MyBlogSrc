I"ş><p>å‰è¨€: tcmalloc ä¸ Go
ä»¥å‰ C++æœåŠ¡ä¸Šçº¿ï¼Œé‡åˆ°æ€§èƒ½ä¼˜åŒ–ä¸€å®šä¼šæ¶‰åŠ Google å¤§åé¼é¼çš„ tcmallocã€‚</p>

<p>ç›¸æ¯” glibcï¼Œtcmalloc åœ¨å¤šçº¿ç¨‹ä¸‹æœ‰å·¨å¤§çš„ä¼˜åŠ¿ï¼š</p>

<p>vs tcmalloc
å…¶ä¸­ä½¿ç”¨çš„å°±æ˜¯å†…å­˜æ± æŠ€æœ¯ã€‚å¦‚æœæƒ³äº†è§£ tcmalloc çš„ç»†èŠ‚ï¼Œç›—ä¸€å¼ å›¾è§£ TCMallocä¸­æ¯”è¾ƒç»å…¸çš„ç»“æ„å›¾ï¼š</p>

<p>å›¾è§£ TCMalloc
ä½œä¸º Google çš„å¾—æ„ä¹‹ä½œï¼ŒGolangè‡ªç„¶ä¹Ÿç”¨ä¸Šäº† tcmalloc çš„å†…å­˜æ± 03 æŠ€æœ¯ã€‚å› æ­¤æˆ‘ä»¬æ™®é€šä½¿ç”¨ Golang æ—¶ï¼Œæ— éœ€å…³æ³¨å†…å­˜åˆ†é…çš„æ€§èƒ½é—®é¢˜ã€‚
<!-- more --></p>
<ol>
  <li>å…³äº map ä½ éœ€è¦äº†è§£çš„
æ—¢ç„¶ Go æœ¬èº«å†…å­˜å·²ç»åšäº† tcmalloc çš„ç®¡ç†ï¼Œé‚£å®ç°ç¼“å­˜æˆ‘ä»¬èƒ½æƒ³åˆ°çš„å°±æ˜¯ map äº†ï¼Œæ˜¯å§ï¼Ÿï¼ˆä½†ä»”ç»†æƒ³æƒ³ï¼Œmap ä¸éœ€è¦åŠ é”å—ï¼Ÿä¸åŠ é”ç”¨ sync.Map æ›´å¥½å—ï¼‰</li>
</ol>

<p>å‘ 1: ä¸ºä»€ä¹ˆä¸ç”¨ sync.Map
2020-05-09 è¡¥å……ï¼šå¤šä½åŒå­¦ä¹Ÿæåˆ°äº†ï¼Œbigcache è¿™ä¸ªæµ‹è¯•å¹¶ä¸å…¬å¹³ã€‚æŸ¥äº†ä¸‹ issuesï¼Œmap+lock å’Œ sync.Map çš„æœ‰äººåšè¿‡æµ‹è¯•ï¼Œæ€§èƒ½ç¡®å®ä½ä¸€äº›ï¼ˆå•é”çš„æƒ…å†µï¼‰ https://github.com/golang/go/issues/28938#issuecomment-441737879ä½†å¦‚æœæ˜¯ shards map+lock å’Œ sync.Mapï¼Œåœ¨ä¸åŒçš„è¯»å†™æ¯”ï¼ˆæ¯”å¦‚è¯»å¤šå†™å°‘ï¼Œå½“è¶…æ—¶æ‰æ›´æ–°ï¼‰æ—¶ï¼Œè¿™å—å°±ä¸å¥½åˆ¤æ–­å“ªç§å®ç°æ›´ä¼˜äº†ï¼Œæœ‰å…´è¶£çš„åŒå­¦å¯ä»¥å°è¯•æ·±æŒ–ä¸‹ï¼ˆè€Œä¸” doyenli ä¹Ÿæåˆ°ï¼Œsync.Map å†…éƒ¨æ˜¯ append only çš„ï¼‰
ç”¨è¿‡ map çš„åŒå­¦åº”è¯¥ä¼šçŸ¥é“ï¼Œmap å¹¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚å¤šä¸ªåç¨‹åŒæ­¥æ›´æ–° map æ—¶ï¼Œä¼šæœ‰æ¦‚ç‡å¯¼è‡´ç¨‹åº core æ‰ã€‚</p>

<p>é‚£æˆ‘ä»¬ä¸ºä»€ä¹ˆä¸ç”¨sync.Mapï¼Ÿå½“ç„¶ä¸æ˜¯å› ä¸º go ç‰ˆæœ¬å¤ªè€ä¸æ”¯æŒè¿™ç§è‚¤æµ…åŸå› ã€‚</p>

<p>https://github.com/allegro/bigcache-bench é‡Œæœ‰å¼ å¯¹æ¯”æ•°æ®ï¼Œçº¯å†™ map æ˜¯æ¯” sync.Map è¦å¿«å¾ˆå¤šï¼Œè¯»ä¹Ÿæœ‰ä¸€å®šä¼˜åŠ¿ã€‚è€ƒè™‘åˆ°å¤šæ•°åœºæ™¯ä¸‹è¯»å¤šå†™å°‘ï¼Œæˆ‘ä»¬åªéœ€å¯¹ map åŠ ä¸ªè¯»å†™é”ï¼Œå¼‚æ­¥å†™çš„é—®é¢˜å°±æå®šäº†ï¼ˆè¿˜ä¸æŸå¤±å¤ªå¤šæ€§èƒ½ï¼‰ã€‚</p>

<p>map vs sync.Map
é™¤äº†è¯»å†™é”ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä½¿ç”¨ shard map çš„åˆ†å¸ƒå¼é”æ¥ç»§ç»­æé«˜å¹¶å‘ï¼ˆåé¢ bigcache éƒ¨åˆ†ä¼šä»‹ç»ï¼‰ï¼Œæ‰€ä»¥ä½ çœ‹æœ€ç»ˆçš„ cache åº“é‡Œï¼Œå¤§å®¶éƒ½æ²¡ç”¨ sync.Mapï¼Œè€Œæ˜¯ç”¨map+è¯»å†™é”æ¥å®ç°å­˜å‚¨ã€‚</p>

<p>å‘ 2: ç”¨ map åšå†…å­˜æ± å°±å¯ä»¥äº†ï¼Ÿ
å¹¶ä¸èƒ½ã€‚map å­˜å‚¨ keys ä¹Ÿæ˜¯æœ‰é™åˆ¶çš„ï¼Œå½“ map ä¸­ keys æ•°é‡è¶…è¿‡åƒä¸‡çº§ï¼Œæœ‰å¯èƒ½é€ æˆæ€§èƒ½ç“¶é¢ˆã€‚</p>

<p>è¿™ä¸ªæ˜¯æˆ‘åœ¨ä¹‹å‰ä¸šåŠ¡ä¸­å®é™…é‡åˆ°çš„æƒ…å†µï¼Œå½“æ—¶æœåŠ¡é‡Œç”¨äº† GroupCache åšç¼“å­˜ï¼Œå¯¼è‡´éƒ¨åˆ†çº¿ä¸Šè¯·æ±‚ä¼šè¶…æ—¶(0.08%å·¦å³çš„è¶…æ—¶ç‡)ã€‚æˆ‘ä»¬å…ˆæš‚æ—¶æ”¾ä¸‹è¿™ä¸ªé—®é¢˜ï¼Œå¼„æ¸…åŸå› å†æ¥ä»‹ç»è¿™é‡Œçš„å·®å¼‚ã€‚</p>

<p>æ‰¾äº†ä¸‹èµ„æ–™ï¼Œå‘ç° 2014 å¹´ Go æœ‰ä¸ª issue æåˆ° Large maps cause significant GC pauses çš„é—®é¢˜ã€‚ç®€å•æ¥è¯´å°±æ˜¯å½“ map ä¸­å­˜åœ¨å¤§é‡ keys æ—¶ï¼ŒGC æ‰«æ map äº§ç”Ÿçš„åœé¡¿å°†ä¸èƒ½å¿½ç•¥ã€‚</p>

<p>å¥½æ¶ˆæ¯æ˜¯ 2015 å¹´ Go å¼€å‘è€…å·²ç»å¯¹ map ä¸­æ— æŒ‡é’ˆçš„æƒ…å†µè¿›è¡Œäº†ä¼˜åŒ–ï¼š</p>

<p>GC ignore maps with no pointers
æˆ‘ä»¬å‚è€ƒå…¶ä¸­çš„ä»£ç ï¼Œå†™ä¸ªGC æµ‹è¯•ç¨‹åºéªŒè¯ä¸‹ï¼š</p>

<p>package main</p>

<p>import (
  â€œfmtâ€
  â€œosâ€
  â€œruntimeâ€
  â€œtimeâ€
)</p>

<p>// Results of this program on my machine:
//
// for t in 1 2 3 4 5; do go run maps.go $t; done
//
// Higher parallelism does help, to some extent:
//
// for t in 1 2 3 4 5; do GOMAXPROCS=8 go run maps.go $t; done
//
// Output(go 1.14):
// With map[int32]<em>int32, GC took 456.159324ms
// With map[int32]int32, GC took 10.644116ms
// With map shards ([]map[int32]</em>int32), GC took 383.296446ms
// With map shards ([]map[int32]int32), GC took 1.023655ms
// With a plain slice ([]main.t), GC took 172.776Âµs</p>

<p>func main() {
  const N = 5e7 // 5000w</p>

<p>if len(os.Args) != 2 {
    fmt.Printf(â€œusage: %s [1 2 3 4]\n(number selects the test)\nâ€, os.Args[0])
    return
  }</p>

<p>switch os.Args[1] {
  case â€œ1â€:
    // Big map with a pointer in the value
    m := make(map[int32]<em>int32)
    for i := 0; i &lt; N; i++ {
      n := int32(i)
      m[n] = &amp;n
    }
    runtime.GC()
    fmt.Printf(â€œWith %T, GC took %s\nâ€, m, timeGC())
    _ = m[0] // Preserve m until here, hopefully
  case â€œ2â€:
    // Big map, no pointer in the value
    m := make(map[int32]int32)
    for i := 0; i &lt; N; i++ {
      n := int32(i)
      m[n] = n
    }
    runtime.GC()
    fmt.Printf(â€œWith %T, GC took %s\nâ€, m, timeGC())
    _ = m[0]
  case â€œ3â€:
    // Split the map into 100 shards
    shards := make([]map[int32]</em>int32, 100)
    for i := range shards {
      shards[i] = make(map[int32]*int32)
    }
    for i := 0; i &lt; N; i++ {
      n := int32(i)
      shards[i%100][n] = &amp;n
    }
    runtime.GC()
    fmt.Printf(â€œWith map shards (%T), GC took %s\nâ€, shards, timeGC())
    _ = shards[0][0]
  case â€œ4â€:
    // Split the map into 100 shards
    shards := make([]map[int32]int32, 100)
    for i := range shards {
      shards[i] = make(map[int32]int32)
    }
    for i := 0; i &lt; N; i++ {
      n := int32(i)
      shards[i%100][n] = n
    }
    runtime.GC()
    fmt.Printf(â€œWith map shards (%T), GC took %s\nâ€, shards, timeGC())
    _ = shards[0][0]
  case â€œ5â€:
    // A slice, just for comparison to show that
    // merely holding onto millions of int32s is fine
    // if theyâ€™re in a slice.
    type t struct {
      p, q int32
    }
    var s []t
    for i := 0; i &lt; N; i++ {
      n := int32(i)
      s = append(s, t{n, n})
    }
    runtime.GC()
    fmt.Printf(â€œWith a plain slice (%T), GC took %s\nâ€, s, timeGC())
    _ = s[0]
  }
}</p>

<p>func timeGC() time.Duration {
  start := time.Now()
  runtime.GC()
  return time.Since(start)
}
ä»£ç ä¸­ä¸€å…±æµ‹è¯•äº† 5 ç§æƒ…å†µï¼Œå†™å…¥5000wçš„ keys åï¼Œä¸»åŠ¨è§¦å‘ 2 æ¬¡ GC æ¥æµ‹é‡è€—æ—¶ï¼š</p>

<p>[1] With map[int32]<em>int32, GC took 456.159324ms
[2] With map[int32]int32, GC took 10.644116ms
[3] With map shards ([]map[int32]</em>int32), GC took 383.296446ms
[4] With map shards ([]map[int32]int32), GC took 1.023655ms
[5] With a plain slice ([]main.t), GC took 172.776Âµs
å¯ä»¥çœ‹åˆ°ï¼Œå½“ map ä¸­æ²¡æœ‰æŒ‡é’ˆæ—¶ï¼Œæ‰«æåœé¡¿æ—¶é—´å¤§çº¦åœ¨ 10ms å·¦å³ï¼Œè€ŒåŒ…å«æŒ‡é’ˆint32æ—¶åˆ™ä¼šæ‰©å¤§ 45 å€ã€‚</p>

<p>å…ˆçœ‹ 5 çš„æ•°æ®ï¼Œå•çº¯çš„ slice é€Ÿåº¦é£å¿«ï¼ŒåŸºæœ¬æ²¡æœ‰ GC æ¶ˆè€—ã€‚è€Œ map shards å°±æœ‰ç‚¹è€äººå¯»å‘³äº†ï¼Œä¸ºä»€ä¹ˆæˆ‘ä»¬æ²¡æœ‰å¯¹ map åŠ é”ï¼Œåˆ† shard å GC æ—¶é—´è¿˜æ˜¯ç¼©çŸ­äº†å‘¢ï¼Ÿè¯´å¥½çš„å°†é”åˆ†å¸ƒå¼åŒ–ï¼Œæ‰èƒ½æé«˜æ€§èƒ½å‘¢ï¼Ÿ</p>

<p>å‘ 3: shards map èƒ½æé«˜æ€§èƒ½çš„å…ƒå‡¶(åŸå› )
è¦äº†è§£ shards map æ€§èƒ½å˜åŒ–çš„åŸå› ï¼Œéœ€è¦å…ˆå¼„æ¸…æ¥š Golang GC çš„æœºåˆ¶ã€‚æˆ‘ä»¬å…ˆåŠ ä¸ŠGODEBUG=gctrace=1è§‚å¯Ÿä¸‹ map é‡ŒåŒ…å«æŒ‡é’ˆä¸æ²¡æœ‰æŒ‡é’ˆçš„ gc å·®å¼‚ï¼š</p>

<p>map[]*int: gc 11 @11.688s 2%: 0.004+436+0.004 ms clock, 0.055+0/1306/3899+0.049 ms cpu, 1762-&gt;1762-&gt;1220 MB, 3195 MB goal, 12 P (forced)map[]int: gc 10 @9.357s 0%: 0.003+14+0.004 ms clock, 0.046+0/14/13+0.054 ms cpu, 1183-&gt;1183-&gt;746 MB, 2147 MB goal, 12 P (forced)</p>

<p>è¾“å‡ºå„å­—æ®µå«ä¹‰å¯ä»¥çœ‹GODEBUG ä¹‹ gctrace å¹²è´§è§£æï¼Œè¿™é‡Œæˆ‘ä»¬åªå…³æ³¨ cpu é‡Œ 0.055+0/1306/3899+0.049 ms cpu è¿™æ®µçš„è§£é‡Šï¼š</p>

<p>Mark Prepare (STW) - 0.055 è¡¨ç¤ºæ•´ä¸ªè¿›ç¨‹åœ¨ mark é˜¶æ®µ STW åœé¡¿æ—¶é—´
Marking - 0/1306/3899 ä¸‰æ®µä¿¡æ¯ï¼Œå…¶ä¸­ 0 æ˜¯ mutator assist å ç”¨æ—¶é—´ï¼Œ1306 æ˜¯ dedicated mark workers+fractional mark worker å ç”¨çš„æ—¶é—´ï¼Œ3899 æ˜¯ idle mark workers å ç”¨çš„æ—¶é—´ï¼ˆè™½ç„¶è¢«æ‹†åˆ†ä¸º 3 ç§ä¸åŒçš„ gc workerï¼Œè¿‡ç¨‹ä¸­è¢«æ‰«æçš„ P è¿˜æ˜¯ä¼šæš‚åœçš„ï¼Œå¦å¤–æ³¨æ„è¿™é‡Œæ—¶é—´æ˜¯æ‰€æœ‰ P æ¶ˆè€—æ—¶é—´çš„æ€»å’Œï¼‰
Mark Termination (STW) - 0.049 è¡¨ç¤ºæ•´ä¸ªè¿›ç¨‹åœ¨ markTermination é˜¶æ®µ STW åœé¡¿æ—¶é—´
åªæœ‰ Mark çš„å‰åä¸¤ä¸ªé˜¶æ®µä¼šå¯¼è‡´ Stop-The-World(STW)ï¼Œä¸­é—´ Marking è¿‡ç¨‹æ˜¯å¹¶è¡Œçš„ã€‚è¿™é‡Œ 1306ms æ˜¯å› ä¸ºæˆ‘ä»¬å¯åŠ¨äº† 12 ä¸ª Pï¼Œ1306ms å’Œ 3899ms æ˜¯æ‰€æœ‰ P æ¶ˆè€—æ—¶é—´çš„ç»¼åˆã€‚è™½ç„¶è¯´æ˜¯ Marking æ˜¯å¹¶è¡Œï¼Œä½†è¢«æ‰«æåˆ°çš„ P è¿˜æ˜¯ä¼šè¢«æš‚åœçš„ã€‚å› æ­¤è¿™ä¸ªæ—¶é—´æœ€ç»ˆåæ˜ åˆ°ä¸šåŠ¡ç¨‹åºä¸Šï¼Œå°±æ˜¯æŸä¸ª P å¤„ç†çš„è¯·æ±‚ï¼Œåœ¨ GC æ—¶è€—æ—¶çªå¢ï¼ˆä¸ç¨³å®šï¼‰ï¼Œä¸èƒ½è¢«ç®€å•çš„å¿½ç•¥</p>

<p>é‚£å›åˆ°ä¸Šé¢çš„é—®é¢˜äº†ï¼Œshards map çš„æ€§èƒ½åˆæ˜¯å¦‚ä½•å¾—åˆ°æå‡ï¼ˆè¿‘ 10 å€ï¼‰çš„ï¼Ÿ</p>

<p>// With map[int32]int32, GC took 11.285541ms
gc 1 @0.001s 7%: 0.010+2.1+0.012 ms clock, 0.12+0.99/2.1/1.2+0.15 ms cpu, 4-&gt;6-&gt;6 MB, 5 MB goal, 12 P
â€¦
gc 8 @2.374s 0%: 0.003+3.9+0.018 ms clock, 0.042+0.31/6.7/3.1+0.21 ms cpu, 649-&gt;649-&gt;537 MB, 650 MB goal, 12 P
gc 9 @4.834s 0%: 0.003+7.5+0.021 ms clock, 0.040+0/14/5.1+0.25 ms cpu, 1298-&gt;1298-&gt;1073 MB, 1299 MB goal, 12 P
gc 10 @9.188s 0%: 0.003+26+0.004 ms clock, 0.045+0/26/0.35+0.053 ms cpu, 1183-&gt;1183-&gt;746 MB, 2147 MB goal, 12 P (forced)
gc 11 @9.221s 0%: 0.018+9.4+0.003 ms clock, 0.22+0/17/5.0+0.043 ms cpu, 746-&gt;746-&gt;746 MB, 1492 MB goal, 12 P (forced)</p>

<p>// With map shards ([]map[int32]int32), GC took 1.017494ms
gc 1 @0.001s 7%: 0.010+2.9+0.048 ms clock, 0.12+0.26/3.6/4.1+0.57 ms cpu, 4-&gt;7-&gt;6 MB, 5 MB goal, 12 P
â€¦
gc 12 @3.924s 0%: 0.003+3.2+0.004 ms clock, 0.040+1.2/7.5/14+0.048 ms cpu, 822-&gt;827-&gt;658 MB, 840 MB goal, 12 P
gc 13 @8.096s 0%: 0.003+6.1+0.004 ms clock, 0.044+6.0/14/32+0.053 ms cpu, 1290-&gt;1290-&gt;945 MB, 1317 MB goal, 12 P
gc 14 @11.619s 0%: 0.003+1.2+0.004 ms clock, 0.045+0/2.5/3.7+0.056 ms cpu, 1684-&gt;1684-&gt;1064 MB, 1891 MB goal, 12 P (forced)
gc 15 @11.628s 0%: 0.003+0.91+0.004 ms clock, 0.038+0/2.3/3.6+0.057 ms cpu, 1064-&gt;1064-&gt;1064 MB, 2128 MB goal, 12 P (forced)
ä»å€’æ•°ç¬¬ä¸‰è½®å†…å­˜æœ€å¤§çš„æ—¶å€™çœ‹ï¼ŒGC worker çš„è€—æ—¶éƒ½æ˜¯æ¥è¿‘çš„ï¼›å”¯ä¸€å·®å¼‚è¾ƒå¤§çš„ï¼Œæ˜¯ markTermination é˜¶æ®µçš„ STW æ—¶é—´ï¼Œshard æ–¹å¼ä¸‹å°‘äº† 1/10ï¼Œå› æ­¤æ¨æµ‹å’Œè¯¥é˜¶æ®µå¾—åˆ°ä¼˜åŒ–æœ‰å…³ã€‚</p>

<p>è‡³äºè¿™ä¸ªæ—¶é—´ä¸ºä»€ä¹ˆèƒ½å‡å°‘ï¼Œæˆ‘ä¹Ÿä¸æ¸…æ¥šä¸ºä»€ä¹ˆï¼ˆè¿™ä¸ªå‘æŒ–å¾—å¤ªæ·±ï¼Œåªèƒ½ä»¥åæ‰¾åˆ°èµ„æ–™å†æ¥å¡«â€¦)</p>

<ol>
  <li>GroupCache
è¨€å½’æ­£ä¼ ï¼ˆä¼—äººï¼šä»€ä¹ˆï¼Ÿï¼å‰é¢å†™è¿™ä¹ˆå¤šä½ è¿˜æ²¡è¿›å…¥æ­£æ–‡ã€‚æˆ‘ï¼šå’³..å’³..ï¼‰ï¼Œæˆ‘ä»¬æ€»ç»“ä¸‹ç”¨ map å®ç°å†…å­˜æ± çš„è¦ç‚¹ï¼š</li>
</ol>

<p>å†…å­˜æ± ç”¨ map ä¸ç”¨ sync.Mapï¼›map è¦åŠ è¯»å†™é”
map å°½é‡å­˜éæŒ‡é’ˆ(key å’Œ value éƒ½ä¸åŒ…å«æŒ‡é’ˆ)
map é‡Œå­˜æ”¾æŒ‡é’ˆï¼Œéœ€è¦æ³¨æ„ keys è¿‡å¤šä¼šå¸¦æ¥çš„ GC åœé¡¿é—®é¢˜
ä½¿ç”¨ shards map
ç„¶åæˆ‘ä»¬çœ‹çœ‹GroupCache çš„å®ç°æ–¹æ³•ï¼Œè¿™ä¸ªå®šä¹‰åœ¨ lru/lru.go é‡Œï¼š</p>

<p>// Cache is an LRU cache. It is not safe for concurrent access.
type Cache struct {
  cache map[interface{}]*list.Element
}
ä» cache çš„å®šä¹‰å¯ä»¥çœ‹å‡ºï¼Œè¿™æ˜¯æˆ‘ä»¬è¯´çš„ map é‡ŒåŒ…å«æŒ‡é’ˆçš„æƒ…å†µï¼Œè€Œä¸”è¿˜æ˜¯ä¸åˆ† shards çš„ã€‚æ‰€ä»¥å¦‚æœä½ å•æœº GroupCache é‡Œ keys è¿‡å¤šï¼Œè¿˜æ˜¯è¦æ³¨æ„ä¸‹ç”¨æ³•çš„ã€‚</p>

<p>æ³¨ï¼šæˆªæ­¢ç›®å‰ 1.14ï¼Œmap é‡ŒåŒ…å«æŒ‡é’ˆæ—¶ idle worker è€—æ—¶é—®é¢˜è¿˜æœªæœ‰ç»“è®ºï¼Œæœ‰å…´è¶£å¯ä»¥å‚è€ƒ 10ms-26ms latency from GC in go1.14rc1, possibly due to â€˜GC (idle)â€™ work é‡Œé¢çš„ä¾‹å­å’Œç°è±¡ã€‚</p>

<ol>
  <li>BigCache
ç›¸æ¯”åˆ†å¸ƒå¼åœºæ™¯çš„ GroupCacheï¼Œå¦‚æœä½ æœ¬åœ°ä¾ç„¶æœ‰åƒä¸‡çº§çš„ keysï¼Œé‚£æ¨èä½ ç”¨ bigcacheã€‚æ— æ•°ç»éªŒè¯æ˜ï¼Œè¶…å¤§ map çš„å†…å­˜æ± å¯¼è‡´çš„ GC å»¶è¿Ÿï¼Œæ˜¯å¯ä»¥é€šè¿‡åˆ‡ bigcache è§£å†³çš„ã€‚é‚£ bigcache åˆ°åº•æ€ä¹ˆåšåˆ°çš„ï¼Ÿ</li>
</ol>

<p>ç®€å•æ¥è¯´ï¼šshards map + map[uint]uint + []byte + free link = BigCache
å®šä¹‰ shards cacheï¼Œé¿å…é”ç²’åº¦è¿‡å¤§
map é‡Œåªå­˜æ”¾ uint é¿å…æŒ‡é’ˆ
å®ç°ä¸€ä¸ª queue ç»“æ„ï¼ˆå®é™…æ˜¯[]byteï¼Œé€šè¿‡ uint ä¸‹æ ‡è¿½åŠ åˆ†é…ï¼‰
é‡‡ç”¨ free é“¾æœºåˆ¶ï¼Œåˆ é™¤ä¿ç•™ç©ºæ´æœ€åä¸€èµ·å›æ”¶ï¼ˆè¿™å—é€»è¾‘è¿˜è›®å¤æ‚çš„ï¼Œå…ˆç•™ä¸ªä¸å¤§ä¸å°çš„å‘å§â€¦ï¼‰
å…¶å†…å­˜æ± å®šä¹‰å¦‚ä¸‹ï¼š</p>

<p>type cacheShard struct {
  hashmap     map[uint64]uint32        // keyåœ¨entriesä¸­çš„ä½ç½®
  entries     queue.BytesQueue         // å®é™…æ˜¯[]byteï¼Œæ–°æ•°æ®æ¥äº†åcopyåˆ°å°¾éƒ¨
}
è¿™æ · GC å°±å˜æˆäº†map æ— æŒ‡é’ˆ+[]byte ç»“æ„çš„æ‰«æé—®é¢˜äº†ï¼Œå› æ­¤æ€§èƒ½ä¼šé«˜å‡ºå¾ˆå¤šã€‚</p>

<p>å‘ 4: ä¸¤ç§æ–¹å¼(GroupCache å’Œ BigCache)å¯¹å…·ä½“ä¸šåŠ¡åˆ°åº•æœ‰å¤šå¤§å½±å“ï¼Ÿ
ä¸Šé¢åªæ˜¯ map å®ç°å†…å­˜æ± çš„æ¨¡æ‹Ÿåˆ†æï¼Œä»¥åŠä¸¤ç§å…¸å‹ Cache åº“çš„å¯¹æ¯”ã€‚å¦‚æœä½ ä¹Ÿå’Œæˆ‘ä¸€æ ·ï¼Œé—®è‡ªå·±â€œå…·ä½“ä¸¤ç§ Cache å¯¹ä¸šåŠ¡æœ‰å¤šå¤§å½±å“å‘¢â€ï¼Ÿé‚£åªèƒ½å¾ˆé«˜å…´çš„å¯¹ä½ è¯´ï¼šæ¬¢è¿æ¥åˆ°å‘åº• -_-</p>

<p>æˆ‘ä»¬çº¿ä¸Šå¤§æ¦‚éœ€è¦å•æœºç¼“å­˜ 1000 ä¸‡å·¦å³çš„ keysã€‚é¦–å…ˆæˆ‘å°è¯•æ¨¡æ‹Ÿä¸šåŠ¡ï¼Œå‘ä¸¤ç§ Cache ä¸­æ’å…¥ 1000w æ•°æ®æ¥æµ‹è¯• GC åœé¡¿ã€‚ç„¶è€Œå› ä¸ºå®éªŒä»£ç æˆ–å…¶ä»–æœªçŸ¥çš„å‘ï¼Œæœ€åè®¤ä¸ºè¿™ä¸ªæ–¹æ³•ä¸å¤ªå¯ä¾§
æœ€åè®¨è®ºï¼Œè§‰å¾—è¿˜æ˜¯ç”¨è€åŠæ³•ï¼Œç”¨ Prometheus çš„ histogram ç»Ÿè®¡è€—æ—¶åˆ†å¸ƒã€‚æˆ‘ä»¬å…ˆç»Ÿè®¡åº•å±‚å­˜å‚¨ï¼ˆRedisï¼‰çš„è€—æ—¶åˆ†å¸ƒï¼Œç„¶åå†åˆ†åˆ«ç»Ÿè®¡ BigCache å’Œ GroupCache åœ¨å†™å…¥ 500w æ•°æ®åçš„å®é™…æƒ…å†µã€‚åˆ†æç»“è®ºå¯çŸ¥ï¼š</p>

<p>40ms ä»¥ä¸Šè¯·æ±‚
ä» redis æ•°æ®çœ‹ï¼Œ40ms ä»¥ä¸Šè¯·æ±‚å æ¯”0.08%ï¼›BigCache çš„ 40ms ä»¥ä¸Šè¯·æ±‚å 0.04%ï¼ˆå³ç›¸åæœ‰ä¸€åŠä»¥ä¸Šè¶…æ—¶è¯·æ±‚è¢« Cache æŒ¡ä½äº†ï¼‰ GroupCache åˆ™æ˜¯0.2%ï¼Œå°†è¿™ç§é•¿æ—¶é—´è¯·æ±‚æ”¾å¤§äº†1å€å¤šï¼ˆæ¨æµ‹å’Œ map çš„é”æœºåˆ¶æœ‰å…³ï¼‰</p>

<p>10ms-40ms è¯·æ±‚
redis æœ¬èº«è¿™ä¸ªåŒºé—´æ®µè¯·æ±‚å æ¯”24.11%ï¼›BigCache åˆ™åªæœ‰15.51%ï¼Œç›¸å½“äºæŒ¡æ‰äº†33%å·¦å³çš„é«˜å»¶è¿Ÿè¯·æ±‚ï¼ˆè¯æ˜åŠ çƒ­ç‚¹ Cache è¿˜æ˜¯æœ‰ä½œç”¨çš„ï¼‰ GroupCache è¿™ä¸ªåŒºé—´æ®µè¯·æ±‚å æ¯”21.55%ï¼Œä¹Ÿæ¯”ç›´æ¥ç”¨ redis æ¥å¾—å¥½</p>

<p>è¯¦ç»†æ•°æ®åˆ†å¸ƒï¼š
redis     [  0.1] 0.00%
redis     [  0.5] 0.38%
redis     [    1] 3.48%
redis     [    5] 71.94%
redis     [   10] 22.90%
redis     [   20] 1.21%
redis     [   40] 0.07%
redis     [ +Inf] 0.01%</p>

<p>bigcache  [  0.1] 0.40%
bigcache  [  0.5] 16.16%
bigcache  [    1] 14.82%
bigcache  [    5] 53.07%
bigcache  [   10] 14.85%
bigcache  [   20] 0.66%
bigcache  [   40] 0.03%
bigcache  [ +Inf] 0.01%</p>

<p>groupcache[  0.1] 0.24%
groupcache[  0.5] 9.59%
groupcache[    1] 9.69%
groupcache[    5] 58.74%
groupcache[   10] 19.10%
groupcache[   20] 2.45%
groupcache[   40] 0.17%
groupcache[ +Inf] 0.03%
ç„¶è€Œæˆ‘ä»¬æµ‹å®Œåªèƒ½å¤§è‡´çŸ¥é“ï¼šæœ¬åœ°ä½¿ç”¨ GroupCache åœ¨ 500w é‡çº§çš„ keys ä¸‹ï¼Œè¿˜æ˜¯ä¸å¦‚ BigCache ç¨³å®šçš„ï¼ˆå“ªæ€• GroupCache å®ç°äº† LRU æ·˜æ±°ï¼Œä½†å®é™…ä¸Šå› ä¸ºæœ‰ Hot/Main Cache çš„å­˜åœ¨ï¼Œå†…å­˜åˆ©ç”¨æ•ˆç‡ä¸Šä¸å¦‚ BigCacheï¼‰</p>

<p>åˆ†å¸ƒå¼æƒ…å†µä¸‹ï¼ŒGroupCache å’Œ BigCache ç›¸æ¯”åˆæœ‰å¤šå°‘å·®è·ï¼Œè¿™ä¸ªå°±åªèƒ½æŒ–å‘ç­‰å¤§å®¶ä¸€èµ·è·³äº†ã€‚</p>

<ol>
  <li>å¯¹è±¡æ± ä¸é›¶æ‹·è´
åœ¨å®é™…ä¸šåŠ¡ä¸­ï¼Œå¾€å¾€ map ä¸­å¹¶ä¸ä¼šå­˜å‚¨ 5000w çº§çš„ keysã€‚å¦‚æœæˆ‘ä»¬åªæœ‰ 50w çš„ keysï¼ŒGC åœé¡¿å°±ä¼šéª¤å‡åˆ° 4ms å·¦å³ï¼ˆå…¶é—´ gc worker è¿˜ä¼šå¹¶è¡Œå·¥ä½œï¼Œé¿å… STWï¼‰ã€‚</li>
</ol>

<p>ä¾‹å¦‚æ— æï¼ˆè…¾è®¯å†…éƒ¨çš„ä¸€ä¸ªé…ç½®æœåŠ¡ï¼‰è¿™ç±»é…ç½®æœåŠ¡ï¼ˆæˆ–å…¶ä»–é«˜é¢‘æ•°æ®æŸ¥è¯¢åœºæ™¯ï¼‰ï¼Œå¾€å¾€éœ€è¦ Get(key) è·å–å¯¹åº”çš„ç»“æ„åŒ–æ•°æ®ã€‚è€Œä» BigCacheï¼ŒCPU æ¶ˆè€—å‘ç°ï¼ˆå¦‚å›¾ï¼‰ï¼Œç›¸æ¯”ç½‘ç»œ IO å’Œ Protobuf è§£æï¼ŒGet å ç”¨0.78%ã€Set å ç”¨0.9%ï¼ŒåŸºæœ¬å¯ä»¥å¿½ç•¥ï¼š</p>

<p>CPU profile
å› æ­¤ä¼˜åŒ–çš„æ€è·¯ä¹Ÿå¾ˆæ˜ç¡®ï¼Œæˆ‘ä»¬å‚è€ƒ GroupCache çš„ lru å®ç°ï¼Œå°† JSON æå‰è§£æå¥½ï¼Œåœ¨ä¸šåŠ¡ä¾§ Get æ—¶ç›´æ¥è¿”å› struct çš„æŒ‡é’ˆå³å¯ã€‚å…·ä½“æµç¨‹ä¸å¤æ‚ï¼Œç›´æ¥ ppt æˆªå›¾ï¼š</p>

<p>zero-copy
æˆ‘ä»¬æŠŠæ¥å£è®¾è®¡æˆæ³¨å†Œçš„æ–¹å¼ï¼ˆæ³¨å†Œéœ€è¦è§£æ JSON æ•°æ®çš„ç»“æ„ï¼‰ï¼Œç„¶åå† Get æ—¶è¿”å›è¯¥ç»“æ„çš„æŒ‡é’ˆå®ç°é›¶æ‹·è´ã€‚ä¸‹é¢ benchmark å¯ä»¥åæ˜ æ€§èƒ½å·®å¼‚å’Œå†…å­˜åˆ†é…æƒ…å†µï¼ˆClient_Get æ˜¯å®æ—¶ JSON è§£æï¼ŒFilter_Get æ˜¯ä¼˜åŒ–çš„å¯¹è±¡æ±  APIï¼‰ï¼Œå¯ä»¥åˆ‡å®çœ‹åˆ°0 allocs/opï¼š</p>

<p>goos: linux
goarch: amd64
pkg: open-wuji/go-sdk/wujiclient
BenchmarkClient_Get-8              1000000        1154 ns/op           1.00 hits        87 B/op        3 allocs/op
BenchmarkFilter_Get-8              4899364         302 ns/op           1.00 hits         7 B/op        1 allocs/op
BenchmarkClient_GetParallel-8      8383149         162 ns/op           1.00 hits        80 B/op        2 allocs/op
BenchmarkFilter_GetParallel-8     13053680        91.4 ns/op           1.00 hits         0 B/op        0 allocs/op
PASS
ok    open-wuji/go-sdk/wujiclient 93.494s
Success: Benchmarks passed.
ç›®å‰æ— æå°šæœªå¯¹å¤–å¼€æºã€‚å¯¹å…·ä½“å®ç°æ„Ÿå…´è¶£çš„åŒå­¦ï¼Œå¯ä»¥çœ‹ gist ä¸­filter API çš„å®ç°ä»£ç </p>

<p>https://mp.weixin.qq.com/s/SWfPV6tUC5olZgIdVabd3A</p>
:ET