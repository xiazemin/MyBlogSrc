I"É:<p>reflect åŒ…å®ç°å…·æœ‰ä¸¤ä¸ªåŸºç¡€ unsafe æ“ä½œå†…å­˜å¯¹é½å’Œ runtime åŒ…çš„å˜é‡ã€‚</p>

<p>runtime å˜é‡
runtime å˜é‡æ˜¯ reflect çš„å®ç°åŸºç¡€ï¼ŒåŸºäº unsafe åŒ…æ“ä½œ runtime å˜é‡å®ç° reflect åŠŸèƒ½ã€‚
https://gocn.vip/topics/10233
<!-- more -->
é¦–å…ˆæˆ‘ä»¬æŒ‰ç…§ go çš„è§„åˆ™å…ˆç®€å•çš„å®šä¹‰ä¸€ä¸ªå˜é‡ç±»å‹ Valueï¼ŒValue æœ‰ä¸¤ä¸ªç±»å‹æˆå‘˜å±æ€§ typ å’Œ ptrï¼Œtyp æ˜¯ç±»å‹è¡¨ç¤ºè¿™ä¸ªå˜é‡æ˜¯ä»€ä¹ˆå¯¹è±¡ï¼Œptr æ˜¯ä¸€ä¸ªåœ°å€æŒ‡å‘è¿™ä¸ªå˜é‡çš„åœ°å€ã€‚</p>

<p>// å¦‚æœçœ‹reflectæˆ–runtimeæºç ä¼šå‘ç°ä¸¤è€…ç›¸è¯†ï¼Œåªä¸è¿‡è¢«æˆ‘åˆ äº†ä¸å°‘å±æ€§ã€‚
type Value struct {
    typ Type
    ptr uintptr
}</p>

<p>type Type interface {
    Name() string         // by all type
    Index(int) Value      // by Slice Array
    MapIndex(value) Value // by Map
    Send(Value)           // By Chan
}
å½“æˆ‘ä»¬å»æ“ä½œä¸€ä¸ªå˜é‡æ—¶å°±æŒ‰ç…§ Type ç±»å‹æ¥æ“ä½œï¼Œè€Œæ“ä½œå¯¹è±¡çš„æ•°æ®å°±åœ¨å†…å­˜çš„ ptr ä½ç½®ã€‚</p>

<p>å˜é‡ç±»å‹ Type å®šä¹‰çš„æ˜¯ä¸€ä¸ªæ¥å£ï¼Œå› ä¸ºä¸åŒç±»å‹æœ‰ä¸åŒçš„æ“ä½œæ–¹æ³•ï¼Œä¾‹å¦‚ Map çš„è·å–/è®¾ç½®å€¼ï¼ŒSlice å’Œ Array çš„è·å–ä¸€ä¸ªç´¢å¼•ï¼ŒChan å…·æœ‰å‘é€å’Œæ¥å®ä¸€ä¸ªå¯¹è±¡ï¼ŒStruct å¯ä»¥è·å¾—ä¸€ä¸ªç»“æ„ä½“å±æ€§ï¼Œå±æ€§å…·æœ‰ tagï¼Œè¿™æ ·ä¸åŒçš„ç±»å‹å°±å…·æœ‰ä¸åŒç‹¬ç‰¹çš„æ“ä½œæ–¹æ³•ï¼Œå¦‚æœ Map ç±»å‹è°ƒç”¨ Index æ–¹æ³•æ— æ³•å®ç°å°±ä¼š panic äº†ã€‚</p>

<p>ç†è§£å˜é‡æœ¬è´¨å°±æ˜¯ä¸€ä¸ªæ•°æ®åœ°å€å’Œä¸€ä¸ªç±»å‹æ•°æ®ç»„æˆï¼Œç„¶ååŸºäºè€…ä¸¤ä¸ªå˜é‡æ¥æ“ä½œå°±æ˜¯ reflectã€‚</p>

<p>reflect example
ä¸€ä¸ª reflect ç®€å•çš„ä¾‹å­ï¼Œreflect.TypeOfå’Œreflect.ValueOfæ–¹æ³•å°†ä¸€ä¸ª runtime ç±»å‹å’Œå˜é‡è½¬æ¢æˆ reflect ç±»å‹å’Œå˜é‡ï¼Œä¾èµ– unsafe æ“ä½œå†…å­˜å¯¹é½æ¥å¼ºåˆ¶è½¬æ¢ï¼Œreflect ç±»å‹å’Œå˜é‡å’Œ runtime ä¸­ä¸€æ ·çš„ï¼Œå°±å¯ä»¥å®ç°è‡ªç”±æ“ä½œäº†ã€‚</p>

<p>æœ€åreflect.Valueè°ƒç”¨Interface()æ–¹æ³•å°†å˜é‡ä» reflect çŠ¶æ€è½¬æ¢å›æ¥æˆ runtime çŠ¶æ€äº†ã€‚</p>

<p>package main</p>

<p>import (
    â€œfmtâ€
    â€œreflectâ€
)</p>

<p>type Student struct {
    Name string
    Age  int
}</p>

<p>func main() {
    s := new(Student)
    fmt.Println(reflect.TypeOf(s))
    fmt.Println(reflect.TypeOf(s).Elem())
    fmt.Println(reflect.TypeOf(*s))</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v := reflect.ValueOf(s).Elem()
v.Field(0).SetString("66")
fmt.Printf("%#v\n", v.Interface()) } reflect Type å…ˆä» reflect/type.go ç®€å•çš„æŠ„ä¸€ç‚¹ä»£ç æ¥ã€‚rtype å¯¹è±¡å°±æ˜¯ Type æ¥å£çš„ç®€åŒ–å®ç°ï¼Œkind å°±æ˜¯è¿™ä¸ªç±»å‹çš„ç±»å‹ï¼Œç„¶åå…¶ä»–ç»„åˆç±»å‹ (Ptrã€Sliceã€Map ç­‰) å°±é¢å¤–æ·»åŠ äº†ä¸€äº›å±æ€§å’Œæ–¹æ³•ã€‚
</code></pre></div></div>

<p>type rtype struct {
    size    uintptr
    ptrdata uintptr
    kind    uint8
    â€¦
}
ptrType æ˜¯æŒ‡é’ˆç±»å‹çš„å®šä¹‰ï¼Œå±æ€§ rtype å°±æ˜¯æŒ‡é’ˆçš„ç±»å‹ï¼Œelem å°±æ˜¯æŒ‡é’ˆæŒ‡å‘çš„ç±»å‹ï¼Œé‚£ä¹ˆä¸€ä¸ª Ptr Type è°ƒç”¨ Elem è·å¾—æŒ‡é’ˆçš„ç±»å‹å°±è¿”å›äº† elem å€¼ã€‚</p>

<p>// ptrType represents a pointer type.
type ptrType struct {
    rtype
    elem *rtype // pointer element (pointed at) type
}
structType æ˜¯æŒ‡é’ˆç±»å‹çš„å®šä¹‰ï¼Œrtype æ˜¯ç»“æ„ä½“ç±»å‹çš„åŸºç¡€ä¿¡æ¯ï¼ŒpkgPath å°±æ˜¯ç»“æ„ä½“çš„åç§°ï¼Œå½“ä¸€ä¸ªç»“æ„ä½“è°ƒç”¨ Name æ–¹æ³•æ—¶å°±è¿”å›äº† pkgPathï¼Œå¦‚æœæ˜¯ç»“æ„ä½“æŒ‡é’ˆè°ƒç”¨ Name æ–¹æ³•å°±æ²¡æœ‰è¿”å›æ•°æ®ï¼Œå› ä¸ºæ²¡æœ‰ pkgPath éœ€è¦å…ˆ Elem ä¸€æ¬¡è½¬æ¢æˆç»“æ„ä½“ç±»å‹ï¼Œè€Œç»“æ„ä½“ç±»å‹çš„ Fieldã€FieldByIndexã€FieldByNameã€FieldByNameFunc æ–¹æ³•å°±å¯¹è±¡ç»“æ„ä½“ç±»å‹ fields ä¿¡æ¯è¿›è¡Œå˜é‡æ“ä½œäº†ã€‚</p>

<p>è€Œåœ¨ç»“æ„ä½“å±æ€§ structField ä¸­ï¼Œnameã€typ åˆ†åˆ«è®°å½•è¿™ä¸ªå±æ€§çš„åç§°å’Œç±»å‹ï¼ŒoffsetEmbed æ˜¯å±æ€§åç§»ä½ç½®ã€‚</p>

<p>// structType represents a struct type.
type structType struct {
    rtype
    pkgPath name
    fields  []structField // sorted by offset
}</p>

<p>// Struct field
type structField struct {
    name        name    // name is always non-empty
    typ         *rtype  // type of field
    offsetEmbed uintptr // byte offset of fieldÂ«1 | isEmbedded
}
chanType æ˜¯ chan ç±»å‹çš„ ing æœ‰ï¼Œrtype æ˜¯ chan æœ¬èº«ï¼Œelem æ˜¯ chan æ“ä½œå¯¹è±¡çš„ç±»å‹å’ŒæŒ‡é’ˆæŒ‡å‘ç›¸è¯†ï¼Œdir å°±æ˜¯ chan çš„åå‘è¿›ã€å‡ºã€è¿›å‡ºã€‚</p>

<p>// chanType represents a channel type.
type chanType struct {
    rtype
    elem *rtype  // channel element type
    dir  uintptr // channel direction (ChanDir)
}
sliceType æ˜¯åˆ‡ç‰‡ç±»å‹å®šä¹‰ï¼Œåˆ‡ç‰‡ç±»å‹ rtype æ˜¯æœ¬èº«ä¿¡æ¯ï¼Œelem å°±æ˜¯åˆ‡ç‰‡æ“ä½œçš„å¯¹è±¡ç±»å‹ã€‚</p>

<p>// sliceType represents a slice type.
type sliceType struct {
    rtype
    elem *rtype // slice element type
}
arrayType æ˜¯æ•°ç»„ç±»å‹ï¼Œåœ¨åˆ‡ç‰‡ä¸Šé¢å¤–å¤šäº†ä¸¤ä¸ªå±æ€§ï¼Œslice æ˜¯æ•°ç»„è½¬æ¢æˆåˆ‡ç‰‡çš„ç±»å‹ï¼Œé¢„å…ˆé™æ€å®šä¹‰å¥½äº†ï¼Œè€Œ len æ˜¯æ•°ç»„é•¿åº¦ã€‚</p>

<p>// arrayType represents a fixed array type.
type arrayType struct {
    rtype
    elem  *rtype // array element type
    slice *rtype // slice type
    len   uintptr
}
ä¸Šè¿° example è®²è¿°äº†éƒ¨åˆ†ç±»å‹çš„å®šä¹‰ï¼Œå®Œæ•´æŸ¥çœ‹æºç  reflect.type.goã€‚</p>

<p>methodã€interfaceã€map æš‚æœªå®Œå…¨çœ‹å®Œï¼Œæ‡‚åŸç†åæ²¡å¿…è¦çœ‹æ²¡æœ‰å‡ è¡Œä½¿ç”¨ç›¸å…³çŸ¥è¯†ã€‚</p>

<p>reflect Kind
reflect.Kind æ˜¯å®šä¹‰åå°„ç±»å‹å¸¸é‡ï¼Œæ˜¯ç±»å‹çš„æ ‡è¯†ã€‚rtype çš„ kind å±æ€§å°±æ˜¯æŒ‡ reflect.Kindã€‚</p>

<p>// A Kind represents the specific kind of type that a Type represents.
// The zero Kind is not a valid kind.
type Kind uint</p>

<p>const (
    Invalid Kind = iota
    Bool
    Int
    Int8
    Int16
    Int32
    Int64
    Uint
    Uint8
    Uint16
    Uint32
    Uint64
    Uintptr
    Float32
    Float64
    Complex64
    Complex128
    Array
    Chan
    Func
    Interface
    Map
    Ptr
    Slice
    String
    Struct
    UnsafePointer
)
reflect Type method
Kind æ–¹æ³•æ³¨é‡Šè¯´æ˜è¿”å› kind å€¼å°±æ˜¯ rtype.kindï¼Œç±»å‹æ˜¯ reflect.Kind æ˜¯ go ä¸­ç±»å‹çš„ä¸»è¦åˆ†ç±»,æ˜¯ iota å®šä¹‰çš„ç±»å‹å¸¸é‡ã€‚</p>

<p>// Kind returns the specific kind of this type.
Kind() Kind
å˜é‡å®ç°çš„æ–¹æ³•å®šä¹‰åœ¨ç±»å‹è¿ç»­åé¢çš„ä¸€å—å†…å­˜ä¸­ï¼Œå¯ä»¥ unsafe è¯»åˆ°ä¸€ä¸ªç±»å‹çš„å…¨éƒ¨æ–¹æ³•ï¼Œå°±å¯ä»¥å®ç° Implements æ–¹æ³•åˆ¤æ–­æ˜¯å¦å®ç°äº†ä¸€ä¸ªæ¥å£äº†ã€‚</p>

<p>// Implements reports whether the type implements the interface type u.
Implements(u Type) bool
ChanDir æ–¹æ³•å¾ˆç®€å•å°±è¿”å› chanType.dir,æ³¨é‡Šè¯´å¦‚æœä¸æ˜¯ Chan ç±»å‹ panic äº†ï¼Œç±»å‹ä¸ chan å°±æ²¡æœ‰ dir è¿™ä¸ªå±æ€§æ— æ³•å¤„ç†å°± panic äº†ï¼Œåœ¨è°ƒç”¨å‰ä¸€èˆ¬éƒ½æ˜ç¡®äº† Kind æ˜¯ Chanã€‚</p>

<p>// ChanDir returns a channel typeâ€™s direction.
// It panics if the typeâ€™s Kind is not Chan.
ChanDir() ChanDir
Elem æ–¹æ³•å…¨ç§°æ˜¯ elementï¼Œå°±æ˜¯æŒ‡å…ƒç´ ç±»å‹ä¹Ÿå¯ä»¥å«æŒ‡å‘ç±»å‹ï¼Œæ³¨é‡Šè¦æ±‚ Kind å¿…é¡»æ˜¯ Arrayã€Chanã€Mapã€Ptrã€Slice ç±»å‹å¦åœ¨å°± panicï¼Œå’Œ Chan çš„ ChanDir æ–¹æ³•ä¸€æ ·ï¼Œåªæœ‰è¿™ 5 ä¸ªç±»å‹æ‰æœ‰ elem å±æ€§ã€‚</p>

<p>æŸ¥çœ‹å‰é¢å®šä¹‰å°±å¯ä»¥çŸ¥é“ Arryã€Sliceã€Ptrã€Chan çš„ elem å°±æ˜¯æŒ‡å‘çš„å¯¹è±¡çš„ç±»å‹ï¼Œmap æ˜¯å€¼çš„ç±»å‹ï¼Œä¾‹å¦‚ä»¥ä¸‹ç±»å‹ Elem å Kind éƒ½æ˜¯ Intã€‚</p>

<p>[20]int
[]int
*int
chan int
map[string]int
// Elem returns a typeâ€™s element type.
// It panics if the typeâ€™s Kind is not Array, Chan, Map, Ptr, or Slice.
Elem() Type
Field å’Œ NumField æ–¹æ³•æ˜¯è·å¾—ç»“æ„ä½“çš„æŒ‡å®šç´¢å¼•çš„å±æ€§å’Œç»“æ„ä½“å±æ€§æ•°é‡ï¼Œæ³¨é‡Šä¸€æ ·æœ‰è¯´æ˜è¦æ±‚ Kind æ˜¯ Struct ç±»å‹å¦åœ¨ panicï¼Œå› ä¸ºå°±ç»“æ„ä½“ç±»å‹æ‰æœ‰ [] StructField èƒ½å®ç°è¿™äº›æ–¹æ³•ã€‚</p>

<p>æ ¹æ®å‰é¢ structType å®šä¹‰ä¸¤ä¸ªæ–¹æ³•çš„å®ç°æ€è·¯å°±æ˜¯ typ.fields[i] è½¬æ¢ä¸€ä¸‹å’Œ len(typ.fields).</p>

<p>// Field returns a struct typeâ€™s iâ€™th field.
// It panics if the typeâ€™s Kind is not Struct.
// It panics if i is not in the range [0, NumField()).
Field(i int) StructField
// NumField returns a struct typeâ€™s field count.
// It panics if the typeâ€™s Kind is not Struct.
NumField() int
NumIn å’Œ In æ–¹æ³•æ˜¯ Func Kind ç‹¬æœ‰çš„æ–¹æ³•ï¼ŒNumIn è¿”å›è¿™ä¸ª Func å…·æœ‰å¤šä¸ªå…¥å‚ï¼Œå¯¹äºè¿”å›å‚æ•°å°±æ˜¯ NumOutï¼›In æ–¹æ³•æ˜¯è·å¾—è¿™ä¸ª Func æŒ‡å®šç¬¬ i å‚æ•°çš„ç±»å‹ã€‚</p>

<p>// NumIn returns a function typeâ€™s input parameter count.
// It panics if the typeâ€™s Kind is not Func.
NumIn() int
    // In returns the type of a function typeâ€™s iâ€™th input parameter.
// It panics if the typeâ€™s Kind is not Func.
// It panics if i is not in the range [0, NumIn()).
In(i int) Type
Key æ–¹æ³•æ˜¯ Map Kind ç‹¬æœ‰æ–¹æ³•ï¼Œè¿”å› map é”®çš„ç±»å‹ã€‚</p>

<p>// Key returns a map typeâ€™s key type.
// It panics if the typeâ€™s Kind is not Map.
Key() Type
Len æ–¹æ³•æ˜¯ Array Kind ç‹¬æœ‰æ–¹æ³•ï¼Œè¿”å› Array å®šä¹‰çš„é•¿åº¦ã€‚</p>

<p>// Len returns an array typeâ€™s length.
// It panics if the typeâ€™s Kind is not Array.
Len() int
ä¸Šè¿°è¯´æ˜ reflect.Type çš„éƒ¨åˆ†æ–¹æ³•å®ç°åŸç†ï¼Œå‰©ä½™æ–¹æ³•åŸç†ç±»ä¼¼ï¼Œå°±æ˜¯æ“ä½œ rtype çš„å±æ€§ï¼Œéƒ¨åˆ† Kind ç±»å‹æ˜¯å…·æœ‰ç‹¬æœ‰æ–¹æ³•å¯ä»¥è°ƒç”¨ã€‚</p>

<p>reflect.Value Method
åå°„ Value å¯¹è±¡å®šä¹‰äº†ä¸‰ä¸ªå±æ€§ ç±»å‹ã€æ•°æ®ä½ç½®ã€flagï¼Œæ•°æ®å†…å­˜ä½ç½®å°±åœ¨ ptr ä½ç½®ï¼Œæ“ä½œæ–¹æ³•å°±éœ€è¦ä¾é  typ ç±»å‹æ¥åˆ¤æ–­æ•°æ®ç±»å‹æ“ä½œäº†ã€‚</p>

<p>Type æ˜¯é™æ€æ•°æ®ï¼Œè€Œ Value æ˜¯åŠ¨æ€æ•°æ®ï¼ŒValue çš„å¾ˆå¤šæ–¹æ³•å…·ä½“å€¼æ˜¯å’Œæ•°æ®ç›¸å…³çš„ã€‚</p>

<p>type Value struct {
    typ *rtype
    ptr unsafe.Pointer
    flag
}
é€šç”¨æ–¹æ³•
é€šç”¨æ–¹æ³•æ˜¯æŒ‡æ‰€æœ‰ç±»å‹å…·æœ‰çš„æ–¹æ³•ï¼Œä»…è¯´æ˜æ ¹æ® Type å’Œ Value å®šä¹‰å®ç°è¿™ä¸ªæ–¹æ³•å¤§æ¦‚çš„æ€è·¯ï¼Œå…·ä½“å®ç°ä»£ç å¹¶ä¸ä¸€æ ·,ä»¥æºç ä¸ºå‡†ã€‚</p>

<p>Type æ–¹æ³•è¿”å›è¿™ä¸ªå€¼çš„ç±»å‹ï¼Œå¤§è‡´æ€è·¯å°±æ˜¯è¿”å› v.typï¼Œå…·ä½“å®ç°è¿˜æœ‰ä¸€äº›é¢å¤–å¤„ç†ã€‚</p>

<p>func (v Value) Type() Type
Kind æ–¹æ³•å®ç°å¤§è‡´æ€è·¯å°±æ˜¯è¿”å› v.typ.kindã€‚</p>

<p>// Kind returns vâ€™s Kind. If v is the zero Value (IsValid returns false),
//  Kind returns Invalid.
func (v Value) Kind() Kind
Interface æ³•æ€è·¯å°±æ˜¯è¿”å› v.ptr å€¼è½¬æ¢æˆä¸€ä¸ª interface{}å˜é‡ï¼Œè¿™æ ·å°±ä» reflect.Value é‡æ–°è½¬æ¢ä¼šå˜é‡äº†ã€‚</p>

<p>// Interface returns vâ€™s current value as an interface{}.
// It is equivalent to:
//  var i interface{} = (vâ€™s underlying value)
// It panics if the Value was obtained by accessing unexported struct fields.
func (v Value) Interface() (i interface{})
Convert æ–¹æ³•æ€è·¯å°±æ˜¯ v.ptr å€¼è½¬æ¢æˆå‚æ•° t çš„ç±»å‹ï¼Œå®ç°è§„åˆ™æ˜¯Conversions è¯­æ³•æ–‡æ¡£ é•œåƒåœ°å€ã€‚</p>

<p>// Convert returns the value v converted to type t. If the usual Go conversion rules do not allow conversion of the value v to type t, Convert panics.
func (v Value) Convert(t Type) Value
Set æ–¹æ³•å®ç°å°±æ˜¯è®¾ç½® v.ptr=x.ptrï¼Œè¦æ±‚ v å’Œ x çš„ç±»å‹æ˜¯ä¸€æ ·çš„ã€‚</p>

<p>åŒæ—¶è¦è¿™ä¸ª Value æ˜¯ CanSetï¼Œå¦‚æœå°†ä¸€ä¸ª int è½¬æ¢æˆ reflect.Valueï¼Œå‡½æ•°ä¼ é€’çš„æ˜¯ä¸€ä¸ªå€¼çš„å‰¯æœ¬ï¼Œé‚£ä¹ˆå†å¯¹ int è®¾ç½®æ–°çš„å€¼å°±æ— æ•ˆäº†ï¼ŒCanSet è¿”å›å°±æ˜¯ falseï¼Œéœ€è¦ä¼ é€’*int è¿™æ ·çš„æŒ‡é’ˆç±»å‹æ‰èƒ½æœ‰æ•ˆè®¾ç½®</p>

<p>// Set assigns x to the value v. It panics if CanSet returns false. As in Go, xâ€™s value must be assignable to vâ€™s type.
func (v Value) Set(x Value)
SetBool æ–¹æ³•æ˜¯è®¾ç½® bool Kind çš„å€¼ï¼Œå‰ç½®è¦æ±‚ Kind æ˜¯ä¸€æ ·çš„ï¼Œç±»å‹è¿˜æœ‰ SetIntã€SetString ç­‰æ–¹æ³•ã€‚</p>

<p>// SetBool sets vâ€™s underlying value. It panics if vâ€™s Kind is not Bool or if CanSet() is false.
func (v Value) SetBool(x bool)
Method è¿”å›è¿™ä¸ªå€¼çš„æŒ‡å®šç´¢å¼•æ–¹æ³•ã€‚</p>

<p>// Method returns a function value corresponding to vâ€™s iâ€™th method.
// The arguments to a Call on the returned function should not include
// a receiver; the returned function will always use v as the receiver.
// Method panics if i is out of range or if v is a nil interface value.
func (v Value) Method(i int) Value
ç‹¬æœ‰æ–¹æ³•
Len æ–¹æ³•è¿”å›æ•°æ®æ•°æ®ï¼Œæ³¨é‡Šè¯´æ˜è¦æ±‚æ˜¯ Array, Chan, Map, Slice, or Stringï¼Œå‰å››ä¸ªè¿”å›å°±æ˜¯æ•°æ®é‡ï¼Œè€Œ String Kind è¿”å›å­—ç¬¦ä¸²é•¿åº¦ã€‚</p>

<p>// It panics if vâ€™s Kind is not Array, Chan, Map, Slice, or String.
func (v Value) Len() int
IsNil æ–¹æ³•åˆ¤æ–­æŒ‡é’ˆæ˜¯å¦æ˜¯ç©º,åœ¨ go çš„å®ç°ä¸­ chanã€funcã€interfaceã€mapã€pointerã€slice åº•å±‚æ‰æ˜¯æŒ‡é’ˆç±»å‹ï¼Œæ‰èƒ½åˆ¤æ–­ IsNil å¦åœ¨ panicï¼Œåˆ¤æ–­è¿™äº›æŒ‡é’ˆç±»å‹çš„ ptr æ˜¯å¦ä¸º 0ï¼Œåœ¨ go ä»£ç ç¼–å†™ä¸­ä¹Ÿåªæœ‰è¿™å‡ ç§ç±»å‹å¯ä»¥i==nilè¿™æ ·çš„æ¯”è¾ƒã€‚</p>

<p>åœ¨ go1.13 ä¸­æ–°å¢äº† IsZero æ–¹æ³•ï¼Œåˆ¤æ–­æ˜¯å¦æ˜¯ç©ºå€¼ï¼Œé‡Œé¢è¿™äº›æŒ‡é’ˆç±»å‹ä¼šåˆ¤æ–­ IsNilï¼Œå…¶ä»–ç±»å‹å°±æ˜¯åˆ¤æ–­æ•°æ®å€¼æ˜¯ä¸æ˜¯é›¶å€¼é‚£æ ·ã€‚</p>

<p>// IsNil reports whether its argument v is nil. The argument must be
// a chan, func, interface, map, pointer, or slice value; if it is
// not, IsNil panics. Note that IsNil is not always equivalent to a
// regular comparison with nil in Go. For example, if v was created
// by calling ValueOf with an uninitialized interface variable i,
// i==nil will be true but v.IsNil will panic as v will be the zero Value.
func (v Value) IsNil() bool
Index æ–¹æ³•è·å–æŒ‡å®šç±»å‹çš„ç´¢å¼•ï¼Œå°± Arrayã€Sliceã€String å¯ä»¥æ‰§è¡Œï¼Œå¦åœ¨ panicï¼Œåœ¨ ptr æŒ‡å‘çš„ä½ç½®è¿›è¡Œä¸€ä¸ªè®¡ç®—å¾—åˆ°çš„åç§»ä½ç½®è·å¾—åˆ°ç´¢å¼•çš„å€¼ã€‚</p>

<p>// Index returns vâ€™s iâ€™th element. It panics if vâ€™s Kind is not Array, Slice, or String or i is out of range.
func (v Value) Index(i int) Value
Field æ–¹æ³•æ˜¯è¿”å›ç»“æ„ä½“æŒ‡å®šç´¢å¼•çš„å€¼ï¼Œè¦æ±‚ Kind æ˜¯ Structï¼Œé€šè¿‡æŒ‡å®šç´¢å¼•çš„åç§»æ¥è·å¾—è¿™ä¸ªå€¼çš„åœ°å€ï¼Œç„¶åç±»å‹é‡Œé¢è·å¾—åˆ°ç±»å‹ï¼Œæœ€åè¿”å›ç´¢å¼•çš„å€¼ã€‚</p>

<p>// Field returns the iâ€™th field of the struct v. It panics if vâ€™s Kind is not Struct or i is out of range.
func (v Value) Field(i int) Value
Elem æ–¹æ³•æ˜¯è¿”å› Ptr å’Œ Interface Kind æŒ‡å‘å€¼ï¼Œä¸ºäº†è§£é™¤å¼•ç”¨ã€‚</p>

<p>ä¸ºä»€ä¹ˆ Value.Elem æ–¹æ³•æ²¡æœ‰äº† Sliceã€Map ç­‰ç±»å‹ï¼Ÿ å…·ä½“é¢å¤–ç‹¬ç«‹çš„æ“ä½œæ–¹æ³• Indexã€MapIndex ç­‰ã€‚</p>

<p>// Elem returns the value that the interface v contains or that the pointer v points to. 
// It panics if vâ€™s Kind is not Interface or Ptr. It returns the zero Value if v is nil.
func (v Value) Elem() Value
MapIndex å’Œ MapKeys æ˜¯ Map Kind ç‹¬æœ‰çš„æ–¹æ³•ï¼Œè·å–åˆ° map çš„ç´¢å¼•å€¼å’Œå…¨éƒ¨é”®ï¼Œé€šè¿‡ typ æä¾›çš„ç±»å‹å’Œ ptr åœ°å€è¿›è¡Œå¤æ‚çš„ map æ“ä½œã€‚</p>

<p>// MapIndex returns the value associated with key in the map v.
// It panics if vâ€™s Kind is not Map.
// It returns the zero Value if key is not found in the map or if v represents a nil map.
// As in Go, the keyâ€™s value must be assignable to the mapâ€™s key type.
func (v Value) MapIndex(key Value) Value
// MapKeys returns a slice containing all the keys present in the map,
// in unspecified order.
// It panics if vâ€™s Kind is not Map.
// It returns an empty slice if v represents a nil map.
func (v Value) MapKeys() []Value</p>

<p>Send æ–¹æ³•æ˜¯ Chan Kind ç‹¬æœ‰æ–¹æ³•ï¼Œç»™ chan æ”¾ä¸€ä¸ªæ•°æ®è¿›å»ã€‚</p>

<p>func (v Value) Send(x Value)
end
ä»¥ä¸Šè®²è¿°äº† reflect åº“çš„åŸç†å°±æ˜¯æ“ä½œ runtime å˜é‡ï¼Œè€Œ runtime å˜é‡å°±æ˜¯ä¸€ä¸ªç±»å‹åŠ åœ°å€ã€‚</p>

<p>æœ¬æ–‡å¹¶æ²¡æœ‰å®Œæ•´åˆ†æ reflect åº“ï¼Œé€šè¿‡è¿™äº›åŸç†å°±å¯ä»¥å¤§æ¦‚ç†è§£è¿™äº›æ–¹æ³•çš„ä½œç”¨å’Œæ“ä½œäº†ï¼Œå…·ä½“è¯·å‚è€ƒæºç ã€‚</p>
:ET