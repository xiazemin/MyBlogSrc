I"È;<p>å®šä¹‰äºsrc/runtime/runtime2.go:</p>

<p>G: Gourtines, æ¯ä¸ªGoroutineå¯¹åº”ä¸€ä¸ªGç»“æ„ä½“ï¼ŒGä¿å­˜Goroutineçš„è¿è¡Œå †æ ˆï¼Œå³å¹¶å‘ä»»åŠ¡çŠ¶æ€ã€‚Gå¹¶éæ‰§è¡Œä½“ï¼Œæ¯ä¸ªGéœ€è¦ç»‘å®šåˆ°Pæ‰èƒ½è¢«è°ƒåº¦æ‰§è¡Œã€‚
P: Processors, å¯¹Gæ¥è¯´ï¼ŒPç›¸å½“äºCPUæ ¸ï¼ŒGåªæœ‰ç»‘å®šåˆ°P(åœ¨Pçš„local runqä¸­)æ‰èƒ½è¢«è°ƒåº¦ã€‚å¯¹Mæ¥è¯´ï¼ŒPæä¾›äº†ç›¸å…³çš„æ‰§è¡Œç¯å¢ƒ(Context)ï¼Œå¦‚å†…å­˜åˆ†é…çŠ¶æ€(mcache)ï¼Œä»»åŠ¡é˜Ÿåˆ—(G)ç­‰
M: Machine, OSçº¿ç¨‹æŠ½è±¡ï¼Œè´Ÿè´£è°ƒåº¦ä»»åŠ¡ï¼Œå’ŒæŸä¸ªPç»‘å®šï¼Œä»Pçš„runqä¸­ä¸æ–­å–å‡ºGï¼Œåˆ‡æ¢å †æ ˆå¹¶æ‰§è¡Œï¼ŒMæœ¬èº«ä¸å…·å¤‡æ‰§è¡ŒçŠ¶æ€ï¼Œåœ¨éœ€è¦ä»»åŠ¡åˆ‡æ¢æ—¶ï¼ŒMå°†å †æ ˆçŠ¶æ€å†™å›Gï¼Œä»»ä½•å…¶å®ƒMéƒ½èƒ½æ®æ­¤æ¢å¤æ‰§è¡Œã€‚
Go1.1ä¹‹å‰åªæœ‰G-Mæ¨¡å‹ï¼Œæ²¡æœ‰Pï¼ŒDmitry Vyukovåœ¨Scalable Go Scheduler Design Docæå‡ºè¯¥æ¨¡å‹åœ¨å¹¶å‘ä¼¸ç¼©æ€§æ–¹é¢çš„é—®é¢˜ï¼Œå¹¶é€šè¿‡åŠ å…¥P(Processors)æ¥æ”¹è¿›è¯¥é—®é¢˜ã€‚
<!-- more -->
è¡¥å……è¯´æ˜:</p>

<p>Pçš„ä¸ªæ•°ç”±GOMAXPROCSæŒ‡å®šï¼Œæ˜¯å›ºå®šçš„ï¼Œå› æ­¤é™åˆ¶æœ€å¤§å¹¶å‘æ•°
Mçš„ä¸ªæ•°æ˜¯ä¸å®šçš„ï¼Œç”±Go Runtimeè°ƒæ•´ï¼Œé»˜è®¤æœ€å¤§é™åˆ¶ä¸º10000ä¸ª
è°ƒåº¦æµç¨‹
åœ¨Mä¸Pç»‘å®šåï¼ŒMä¼šä¸æ–­ä»Pçš„Localé˜Ÿåˆ—(runq)ä¸­å–å‡ºG(æ— é”æ“ä½œ)ï¼Œåˆ‡æ¢åˆ°Gçš„å †æ ˆå¹¶æ‰§è¡Œï¼Œå½“Pçš„Localé˜Ÿåˆ—ä¸­æ²¡æœ‰Gæ—¶ï¼Œå†ä»Globalé˜Ÿåˆ—ä¸­è¿”å›ä¸€ä¸ªG(æœ‰é”æ“ä½œï¼Œå› æ­¤å®é™…è¿˜ä¼šä»Globalé˜Ÿåˆ—æ‰¹é‡è½¬ç§»ä¸€æ‰¹Gåˆ°P Localé˜Ÿåˆ—)ï¼Œå½“Globalé˜Ÿåˆ—ä¸­ä¹Ÿæ²¡æœ‰å¾…è¿è¡Œçš„Gæ—¶ï¼Œåˆ™å°è¯•ä»å…¶å®ƒçš„Pçªƒå–(steal)éƒ¨åˆ†Gæ¥æ‰§è¡Œï¼Œæºä»£ç å¦‚ä¸‹:</p>

<p>// go1.9.1  src/runtime/proc.go
// çœç•¥äº†GCæ£€æŸ¥ç­‰å…¶å®ƒç»†èŠ‚ï¼Œåªä¿ç•™äº†ä¸»è¦æµç¨‹
// g:       Gç»“æ„ä½“å®šä¹‰
// sched:   Globalé˜Ÿåˆ—
// è·å–ä¸€ä¸ªå¾…æ‰§è¡Œçš„G
func findrunnable() (gp *g, inheritTime bool) {
    // è·å–å½“å‰çš„Gå¯¹è±¡
    <em>g</em> := getg()</p>

<p>top:
    // è·å–å½“å‰På¯¹è±¡
    <em>p</em> := <em>g</em>.m.p.ptr()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 1. å°è¯•ä»Pçš„Localé˜Ÿåˆ—ä¸­å–å¾—G ä¼˜å…ˆ_p_.runnext ç„¶åå†ä»Localé˜Ÿåˆ—ä¸­å–
if gp, inheritTime := runqget(_p_); gp != nil {
    return gp, inheritTime
}

// 2. å°è¯•ä»Globalé˜Ÿåˆ—ä¸­å–å¾—G
if sched.runqsize != 0 {
    lock(&amp;sched.lock)
    // globrunqgetä»Globalé˜Ÿåˆ—ä¸­è·å–G å¹¶è½¬ç§»ä¸€æ‰¹Gåˆ°_p_çš„Localé˜Ÿåˆ—
    gp := globrunqget(_p_, 0)
    unlock(&amp;sched.lock)
    if gp != nil {
        return gp, false
    }
}

// 3. æ£€æŸ¥netpollä»»åŠ¡
if netpollinited() &amp;&amp; sched.lastpoll != 0 {
    if gp := netpoll(false); gp != nil { // non-blocking
        // netpollè¿”å›çš„æ˜¯Gé“¾è¡¨ï¼Œå°†å…¶å®ƒGæ”¾å›Globalé˜Ÿåˆ—
        injectglist(gp.schedlink.ptr())
        casgstatus(gp, _Gwaiting, _Grunnable)
        if trace.enabled {
            traceGoUnpark(gp, 0)
        }
        return gp, false
    }
}

// 4. å°è¯•ä»å…¶å®ƒPçªƒå–ä»»åŠ¡
procs := uint32(gomaxprocs)
if atomic.Load(&amp;sched.npidle) == procs-1 {
    goto stop
}
if !_g_.m.spinning {
    _g_.m.spinning = true
    atomic.Xadd(&amp;sched.nmspinning, 1)
}
for i := 0; i &lt; 4; i++ {
    // éšæœºPçš„éå†é¡ºåº
    for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
        if sched.gcwaiting != 0 {
            goto top
        }
        stealRunNextG := i &gt; 2 // first look for ready queues with more than 1 g
        // runqstealæ‰§è¡Œå®é™…çš„stealå·¥ä½œï¼Œä»ç›®æ ‡Pçš„Localé˜Ÿåˆ—è½¬ç§»ä¸€èˆ¬çš„Gè¿‡æ¥
        // stealRunNextGæŒ‡æ˜¯å¦stealç›®æ ‡Pçš„p.runnext G
        if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {
            return gp, false
        }
    }
}
... } å½“æ²¡æœ‰Gå¯è¢«æ‰§è¡Œæ—¶ï¼ŒMä¼šä¸Pè§£ç»‘ï¼Œç„¶åè¿›å…¥ä¼‘çœ (idle)çŠ¶æ€ã€‚
</code></pre></div></div>

<p>ç”¨æˆ·æ€é˜»å¡/å”¤é†’
å½“Goroutineå› ä¸ºChannelæ“ä½œè€Œé˜»å¡(é€šè¿‡gopark)æ—¶ï¼Œå¯¹åº”çš„Gä¼šè¢«æ”¾ç½®åˆ°æŸä¸ªwaité˜Ÿåˆ—(å¦‚channelçš„waitq)ï¼Œè¯¥Gçš„çŠ¶æ€ç”±_Gruningå˜ä¸º_Gwaittingï¼Œè€ŒMä¼šè·³è¿‡è¯¥Gå°è¯•è·å–å¹¶æ‰§è¡Œä¸‹ä¸€ä¸ªGã€‚</p>

<p>å½“é˜»å¡çš„Gè¢«G2å”¤é†’(é€šè¿‡goready)æ—¶(æ¯”å¦‚channelå¯è¯»/å†™)ï¼ŒGä¼šå°è¯•åŠ å…¥G2æ‰€åœ¨Pçš„runnextï¼Œç„¶åå†æ˜¯P Localé˜Ÿåˆ—å’ŒGlobalé˜Ÿåˆ—ã€‚</p>

<p>syscall
å½“Gè¢«é˜»å¡åœ¨æŸä¸ªç³»ç»Ÿè°ƒç”¨ä¸Šæ—¶ï¼Œæ­¤æ—¶Gä¼šé˜»å¡åœ¨_GsyscallçŠ¶æ€ï¼ŒMä¹Ÿå¤„äºblock on syscallçŠ¶æ€ï¼Œæ­¤æ—¶ä»ç„¶å¯è¢«æŠ¢å è°ƒåº¦: æ‰§è¡Œè¯¥Gçš„Mä¼šä¸Pè§£ç»‘ï¼Œè€ŒPåˆ™å°è¯•ä¸å…¶å®ƒidleçš„Mç»‘å®šï¼Œç»§ç»­æ‰§è¡Œå…¶å®ƒGã€‚å¦‚æœæ²¡æœ‰å…¶å®ƒidleçš„Mï¼Œä½†é˜Ÿåˆ—ä¸­ä»ç„¶æœ‰Géœ€è¦æ‰§è¡Œï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„Mã€‚</p>

<p>å½“ç³»ç»Ÿè°ƒç”¨å®Œæˆåï¼ŒGä¼šé‡æ–°å°è¯•è·å–ä¸€ä¸ªidleçš„Pï¼Œå¹¶æ¢å¤æ‰§è¡Œï¼Œå¦‚æœæ²¡æœ‰idleçš„Pï¼ŒGå°†åŠ å…¥åˆ°Globalé˜Ÿåˆ—ã€‚</p>

<p>ç³»ç»Ÿè°ƒç”¨èƒ½è¢«è°ƒåº¦çš„å…³é”®æœ‰ä¸¤ç‚¹:</p>

<p>runtime/syscallåŒ…ä¸­ï¼Œå°†ç³»ç»Ÿè°ƒç”¨åˆ†ä¸ºSysCallå’ŒRawSysCallï¼Œå‰è€…å’Œåè€…çš„åŒºåˆ«æ˜¯å‰è€…ä¼šåœ¨ç³»ç»Ÿè°ƒç”¨å‰ååˆ†åˆ«è°ƒç”¨entersyscallå’Œexitsyscall(ä½äºsrc/runtime/proc.go)ï¼Œåšä¸€äº›ç°åœºä¿å­˜å’Œæ¢å¤æ“ä½œï¼Œè¿™æ ·æ‰èƒ½ä½¿På®‰å…¨åœ°ä¸Mè§£ç»‘ï¼Œå¹¶åœ¨å…¶å®ƒMä¸Šç»§ç»­æ‰§è¡Œå…¶å®ƒGã€‚æŸäº›ç³»ç»Ÿè°ƒç”¨æœ¬èº«å¯ä»¥ç¡®å®šä¼šé•¿æ—¶é—´é˜»å¡(æ¯”å¦‚é”)ï¼Œä¼šè°ƒç”¨entersyscallblockåœ¨å‘èµ·ç³»ç»Ÿè°ƒç”¨å‰ç›´æ¥è®©På’ŒMè§£ç»‘(handoffp)ã€‚</p>

<p>å¦ä¸€ä¸ªå…³é”®ç‚¹æ˜¯sysmonï¼Œå®ƒè´Ÿè´£æ£€æŸ¥æ‰€æœ‰ç³»ç»Ÿè°ƒç”¨çš„æ‰§è¡Œæ—¶é—´ï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦handoffpã€‚</p>

<p>sysmon
sysmonæ˜¯ä¸€ä¸ªç”±runtimeå¯åŠ¨çš„Mï¼Œä¹Ÿå«ç›‘æ§çº¿ç¨‹ï¼Œå®ƒæ— éœ€Pä¹Ÿå¯ä»¥è¿è¡Œï¼Œå®ƒæ¯20us~10mså”¤é†’ä¸€æ¬¡ï¼Œä¸»è¦æ‰§è¡Œ:</p>

<p>é‡Šæ”¾é—²ç½®è¶…è¿‡5åˆ†é’Ÿçš„spanç‰©ç†å†…å­˜ï¼›
å¦‚æœè¶…è¿‡2åˆ†é’Ÿæ²¡æœ‰åƒåœ¾å›æ”¶ï¼Œå¼ºåˆ¶æ‰§è¡Œï¼›
å°†é•¿æ—¶é—´æœªå¤„ç†çš„netpollç»“æœæ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—ï¼›
å‘é•¿æ—¶é—´è¿è¡Œçš„Gä»»åŠ¡å‘å‡ºæŠ¢å è°ƒåº¦ï¼›
æ”¶å›å› syscallé•¿æ—¶é—´é˜»å¡çš„Pï¼›
å…¥å£åœ¨src/runtime/proc.go:sysmonå‡½æ•°ï¼Œå®ƒé€šè¿‡retakeå®ç°å¯¹syscallå’Œé•¿æ—¶é—´è¿è¡Œçš„Gè¿›è¡Œè°ƒåº¦:</p>

<p>func retake(now int64) uint32 {
    n := 0
    for i := int32(0); i &lt; gomaxprocs; i++ {
        <em>p</em> := allp[i]
        if <em>p</em> == nil {
            continue
        }
        pd := &amp;<em>p</em>.sysmontick
        s := <em>p</em>.status
        if s == <em>Psyscall {
            // Retake P from syscall if itâ€™s there for more than 1 sysmon tick (at least 20us).
            t := int64(_p</em>.syscalltick)
            if int64(pd.syscalltick) != t {
                pd.syscalltick = uint32(t)
                pd.syscallwhen = now
                continue
            }
            // å¦‚æœå½“å‰P Localé˜Ÿåˆ—æ²¡æœ‰å…¶å®ƒGï¼Œå½“å‰æœ‰å…¶å®ƒPå¤„äºIdleçŠ¶æ€ï¼Œå¹¶ä¸”syscallæ‰§è¡Œäº‹ä»¶ä¸è¶…è¿‡10msï¼Œåˆ™ä¸ç”¨è§£ç»‘å½“å‰P(handoffp)
            if runqempty(<em>p</em>) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; 0 &amp;&amp; pd.syscallwhen+10<em>1000</em>1000 &gt; now {
                continue
            }
            // handoffp
            incidlelocked(-1)
            if atomic.Cas(&amp;<em>p</em>.status, s, <em>Pidle) {
                if trace.enabled {
                    traceGoSysBlock(_p</em>)
                    traceProcStop(<em>p</em>)
                }
                n++
                <em>p</em>.syscalltick++
                handoffp(<em>p</em>)
            }
            incidlelocked(1)
        } else if s == <em>Prunning {
            // Preempt G if itâ€™s running for too long.
            t := int64(_p</em>.schedtick)
            if int64(pd.schedtick) != t {
                pd.schedtick = uint32(t)
                pd.schedwhen = now
                continue
            }
            // å¦‚æœå½“å‰Gæ‰§è¡Œæ—¶é—´è¶…è¿‡10msï¼Œåˆ™æŠ¢å (preemptone)
            if pd.schedwhen+forcePreemptNS &gt; now {
                continue
            }
            // æ‰§è¡ŒæŠ¢å 
            preemptone(<em>p</em>)
        }
    }
    return uint32(n)
}
æŠ¢å å¼è°ƒåº¦
å½“æŸä¸ªgoroutineæ‰§è¡Œè¶…è¿‡10msï¼Œsysmonä¼šå‘å…¶å‘èµ·æŠ¢å è°ƒåº¦è¯·æ±‚ï¼Œç”±äºGoè°ƒåº¦ä¸åƒOSè°ƒåº¦é‚£æ ·æœ‰æ—¶é—´ç‰‡çš„æ¦‚å¿µï¼Œå› æ­¤å®é™…æŠ¢å æœºåˆ¶è¦å¼±å¾ˆå¤š: Goä¸­çš„æŠ¢å å®é™…ä¸Šæ˜¯ä¸ºGè®¾ç½®æŠ¢å æ ‡è®°(g.stackguard0)ï¼Œå½“Gè°ƒç”¨æŸå‡½æ•°æ—¶(æ›´ç¡®åˆ‡è¯´ï¼Œåœ¨é€šè¿‡newstackåˆ†é…å‡½æ•°æ ˆæ—¶)ï¼Œè¢«ç¼–è¯‘å™¨å®‰æ’çš„æŒ‡ä»¤ä¼šæ£€æŸ¥è¿™ä¸ªæ ‡è®°ï¼Œå¹¶ä¸”å°†å½“å‰Gä»¥runtime.Gochedçš„æ–¹å¼æš‚åœï¼Œå¹¶åŠ å…¥åˆ°å…¨å±€é˜Ÿåˆ—ã€‚æºä»£ç å¦‚ä¸‹:</p>

<p>// src/runtime/stack.go
// Called from runtimeÂ·morestack when more stack is needed.
// Allocate larger stack and relocate to new stack.
// Stack growth is multiplicative, for constant amortized cost.
func newstack(ctxt unsafe.Pointer) {
    â€¦
    // gpä¸ºå½“å‰G
    preempt := atomic.Loaduintptr(&amp;gp.stackguard0) == stackPreempt
    if preempt {
        â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // Act like goroutine called runtime.Gosched.
    // GçŠ¶æ€ç”±_Gwaitingå˜ä¸º _Grunning è¿™æ˜¯ä¸ºäº†èƒ½ä»¥Goschedçš„æ–¹å¼æš‚åœGo
    casgstatus(gp, _Gwaiting, _Grunning)
    gopreempt_m(gp) // never return
} }
</code></pre></div></div>

<p>// ä»¥gochedçš„æ–¹å¼å°†Gé‡æ–°æ”¾å…¥
func goschedImpl(gp *g) {
    status := readgstatus(gp)
    // ç”±Runningå˜ä¸ºRunnable
    casgstatus(gp, _Grunning, _Grunnable)
    // ä¸Mè§£é™¤ç»‘å®š
    dropg()
    lock(&amp;sched.lock)
    // å°†Gæ”¾å…¥Globalé˜Ÿåˆ—
    globrunqput(gp)
    unlock(&amp;sched.lock)
    // é‡æ–°è°ƒåº¦
    schedule()
}</p>

<p>func gopreempt_m(gp *g) {
    if trace.enabled {
        traceGoPreempt()
    }
    goschedImpl(gp)
}
netpoll
å‰é¢çš„findrunnableï¼ŒGçš„è·å–é™¤äº†p.runnextï¼Œp.runqå’Œsched.runqå¤–ï¼Œè¿˜æœ‰ä¸€ä¸­Gä»netpollä¸­è·å–ï¼Œnetpollæ˜¯Goé’ˆå¯¹ç½‘ç»œIOçš„ä¸€ç§ä¼˜åŒ–ï¼Œæœ¬è´¨ä¸Šä¸ºäº†é¿å…ç½‘ç»œIOé™·å…¥ç³»ç»Ÿè°ƒç”¨ä¹‹ä¸­ï¼Œè¿™æ ·ä½¿å¾—å³ä¾¿Gå‘èµ·ç½‘ç»œI/Oæ“ä½œä¹Ÿä¸ä¼šå¯¼è‡´Mè¢«é˜»å¡ï¼ˆä»…é˜»å¡Gï¼‰ï¼Œä»è€Œä¸ä¼šå¯¼è‡´å¤§é‡Mè¢«åˆ›å»ºå‡ºæ¥ã€‚</p>

<p>Gåˆ›å»ºæµç¨‹
Gç»“æ„ä½“ä¼šå¤ç”¨ï¼Œå¯¹å¯å¤ç”¨çš„Gç®¡ç†ç±»ä¼¼äºå¾…è¿è¡Œçš„Gç®¡ç†ï¼Œä¹Ÿæœ‰Localé˜Ÿåˆ—(p.gfree)å’ŒGlobalé˜Ÿåˆ—(sched.gfree)ä¹‹åˆ†ï¼Œè·å–ç®—æ³•å·®ä¸å¤šï¼Œä¼˜å…ˆä»p.gfreeä¸­è·å–(æ— é”æ“ä½œ)ï¼Œå¦åˆ™ä»sched.gfreeä¸­è·å–å¹¶æ‰¹é‡è½¬ç§»ä¸€éƒ¨åˆ†(æœ‰é”æ“ä½œ)ï¼Œæºä»£ç å‚è€ƒsrc/runtime/proc.go:gfgetå‡½æ•°ã€‚</p>

<p>ä»Goroutineçš„è§’åº¦æ¥çœ‹ï¼Œé€šè¿‡go func()åˆ›å»ºæ—¶ï¼Œä¼šä»å½“å‰é—²ç½®çš„Gé˜Ÿåˆ—å–å¾—å¯å¤ç”¨çš„Gï¼Œå¦‚æœæ²¡æœ‰åˆ™é€šè¿‡malgæ–°å»ºä¸€ä¸ªGï¼Œç„¶å:</p>

<p>å°è¯•å°†Gæ·»åŠ åˆ°å½“å‰Pçš„runnextä¸­ï¼Œä½œä¸ºä¸‹ä¸€ä¸ªæ‰§è¡Œçš„G
å¦åˆ™æ”¾åˆ°Localé˜Ÿåˆ—runqä¸­(æ— é”)
å¦‚æœä»¥ä¸Šæ“ä½œéƒ½å¤±è´¥ï¼Œåˆ™æ·»åŠ åˆ°Globalé˜Ÿåˆ—sched.runqä¸­(æœ‰é”æ“ä½œï¼Œå› æ­¤ä¹Ÿä¼šé¡ºä¾¿å°†å½“P.runqä¸­ä¸€åŠçš„Gè½¬ç§»åˆ°sched.runq)
Gçš„å‡ ç§æš‚åœæ–¹å¼:
gosched: å°†å½“å‰çš„Gæš‚åœï¼Œä¿å­˜å †æ ˆçŠ¶æ€ï¼Œä»¥_GRunnableçŠ¶æ€æ”¾å…¥Globalé˜Ÿåˆ—ä¸­ï¼Œè®©å½“å‰Mç»§ç»­æ‰§è¡Œå…¶å®ƒä»»åŠ¡ã€‚æ— éœ€å¯¹Gè¿›è¡Œå”¤é†’æ“ä½œï¼Œå› ä¸ºæ€»ä¼šæœ‰Mä»Globalé˜Ÿåˆ—å–å¾—å¹¶æ‰§è¡Œè¯¥Gã€‚æŠ¢å è°ƒåº¦å³ä½¿ç”¨è¯¥æ–¹å¼ã€‚
gopark: ä¸gochedçš„æœ€å¤§åŒºåˆ«åœ¨äºgoparkæ²¡æœ‰å°†Gæ”¾å›æ‰§è¡Œé˜Ÿåˆ—ï¼Œè€Œæ˜¯ä½äºæŸä¸ªç­‰å¾…é˜Ÿåˆ—ä¸­(å¦‚channelçš„waitqï¼Œæ­¤æ—¶GçŠ¶æ€ä¸º_Gwaitting)ï¼Œå› æ­¤Gå¿…é¡»è¢«æ‰‹åŠ¨å”¤é†’(é€šè¿‡goready)ï¼Œå¦åˆ™ä¼šä¸¢å¤±ä»»åŠ¡ã€‚åº”ç”¨å±‚é˜»å¡é€šå¸¸ä½¿ç”¨è¿™ç§æ–¹å¼ã€‚
notesleep: æ—¢ä¸è®©å‡ºMï¼Œä¹Ÿä¸è®©Gå’ŒPé‡æ–°è°ƒåº¦ï¼Œç›´æ¥è®©çº¿ç¨‹ä¼‘çœ ç›´åˆ°è¢«å”¤é†’(notewakeup)ï¼Œè¯¥æ–¹å¼æ›´å¿«ï¼Œé€šå¸¸ç”¨äºgcMarkï¼Œstopmè¿™ç±»è‡ªæ—‹åœºæ™¯
notesleepg: é˜»å¡Gå’ŒMï¼Œæ”¾é£Pï¼ŒPå¯ä»¥å’Œå…¶å®ƒMç»‘å®šç»§ç»­æ‰§è¡Œï¼Œæ¯”å¦‚å¯èƒ½é˜»å¡çš„ç³»ç»Ÿè°ƒç”¨ä¼šä¸»åŠ¨è°ƒç”¨entersyscallblockï¼Œåˆ™ä¼šè§¦å‘ notesleepg
goexit: ç«‹å³ç»ˆæ­¢Gä»»åŠ¡ï¼Œä¸ç®¡å…¶å¤„äºè°ƒç”¨å †æ ˆçš„å“ªä¸ªå±‚æ¬¡ï¼Œåœ¨ç»ˆæ­¢å‰ï¼Œç¡®ä¿æ‰€æœ‰deferæ­£ç¡®æ‰§è¡Œã€‚
Goè°ƒåº¦å™¨çš„æŸ¥çœ‹æ–¹æ³•
ç¤ºä¾‹ç¨‹åºï¼Œå¯¹æ¯”cgo sleepå’Œtime.sleepç³»ç»Ÿè°ƒç”¨æƒ…å†µ:</p>

<p>// #include <unistd.h>
import "C"</unistd.h></p>

<p>func main() {
    var wg sync.WaitGroup
    wg.Add(1000)
    for i := 0; i &lt; 1000; i++ {
        go func() {
            C.sleep(1)                     // æµ‹è¯•1
            // time.Sleep(time.Second)     // æµ‹è¯•2
            wg.Done()
        }()
    }
    wg.Wait()
    println(â€œdone!â€)
    time.Sleep(time.Second * 3)
}
é€šè¿‡GODEBUGè¿è¡Œæ—¶ç¯å¢ƒå˜é‡çš„schedtrace=1000å‚æ•°ï¼Œå¯ä»¥æ¯éš”1000msæŸ¥çœ‹ä¸€æ¬¡è°ƒåº¦å™¨çŠ¶æ€:</p>

<p>$ GODEBUG=schedtrace=1000 ./test</p>

<p>// æµ‹è¯•1è¾“å‡ºç»“æœ
SCHED 0ms: gomaxprocs=4 idleprocs=2 threads=1003 spinningthreads=2 idlethreads=32 runqueue=0 [0 0 0 0]
done!
SCHED 1001ms: gomaxprocs=4 idleprocs=4 threads=1003 spinningthreads=0 idlethreads=1000 runqueue=0 [0 0 0 0]
SCHED 2001ms: gomaxprocs=4 idleprocs=4 threads=1003 spinningthreads=0 idlethreads=1000 runqueue=0 [0 0 0 0]
SCHED 3010ms: gomaxprocs=4 idleprocs=4 threads=1003 spinningthreads=0 idlethreads=1000 runqueue=0 [0 0 0 0]</p>

<p>// æµ‹è¯•2è¾“å‡ºç»“æœ
SCHED 0ms: gomaxprocs=4 idleprocs=2 threads=6 spinningthreads=1 idlethreads=2 runqueue=129 [0 128 0 0]
done!
SCHED 1009ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 2010ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
SCHED 3019ms: gomaxprocs=4 idleprocs=4 threads=6 spinningthreads=0 idlethreads=3 runqueue=0 [0 0 0 0]
å…¶ä¸­schedtraceæ—¥å¿—æ¯ä¸€è¡Œçš„å­—æ®µæ„ä¹‰:</p>

<p>SCHEDï¼šè°ƒè¯•ä¿¡æ¯è¾“å‡ºæ ‡å¿—å­—ç¬¦ä¸²ï¼Œä»£è¡¨æœ¬è¡Œæ˜¯goroutine schedulerçš„è¾“å‡ºï¼›
1001msï¼šå³ä»ç¨‹åºå¯åŠ¨åˆ°è¾“å‡ºè¿™è¡Œæ—¥å¿—çš„æ—¶é—´ï¼›
gomaxprocs: Pçš„æ•°é‡ï¼›
idleprocs: å¤„äºidleçŠ¶æ€çš„Pçš„æ•°é‡ï¼›é€šè¿‡gomaxprocså’Œidleprocsçš„å·®å€¼ï¼Œæˆ‘ä»¬å°±å¯çŸ¥é“æ‰§è¡Œgoä»£ç çš„Pçš„æ•°é‡ï¼›
threads: os threadsçš„æ•°é‡ï¼ŒåŒ…å«schedulerä½¿ç”¨çš„mæ•°é‡ï¼ŒåŠ ä¸Šruntimeè‡ªç”¨çš„ç±»ä¼¼sysmonè¿™æ ·çš„threadçš„æ•°é‡ï¼›
spinningthreads: å¤„äºè‡ªæ—‹çŠ¶æ€çš„os threadæ•°é‡ï¼›
idlethread: å¤„äºidleçŠ¶æ€çš„os threadçš„æ•°é‡ï¼›
runqueueï¼š go schedulerå…¨å±€é˜Ÿåˆ—ä¸­Gçš„æ•°é‡ï¼›
[0 0 0 0]: åˆ†åˆ«ä¸º4ä¸ªPçš„local queueä¸­çš„Gçš„æ•°é‡ã€‚
å¯ä»¥çœ‹å‡ºï¼Œtime.Sleepå¹¶æ²¡æœ‰ä½¿ç”¨ç³»ç»Ÿè°ƒç”¨ï¼Œè€Œæ˜¯è¿›è¡Œäº†ç±»ä¼¼netpollç±»ä¼¼çš„ä¼˜åŒ–ï¼Œä½¿å¾—ä»…ä»…æ˜¯Gé˜»å¡ï¼ŒMä¸ä¼šé˜»å¡ï¼Œè€Œåœ¨ä½¿ç”¨cgo sleepçš„æƒ…å†µä¸‹ï¼Œå¯ä»¥çœ‹åˆ°å¤§é‡çš„é—²ç½®Mã€‚</p>

<p>é€šè¿‡è¿è¡Œæ—¶ç¯å¢ƒå˜é‡GODEBUGçš„schedtraceå‚æ•°å¯å®šæ—¶æŸ¥çœ‹è°ƒåº¦å™¨çŠ¶æ€:</p>

<p>// æ¯1000msæ‰“å°ä¸€æ¬¡
$GODEBUG=schedtrace=1000 godoc -http=:6060
SCHED 0ms: gomaxprocs=4 idleprocs=3 threads=3 spinningthreads=0 idlethreads=0 runqueue=0 [0 0 0 0]
SCHED 1001ms: gomaxprocs=4 idleprocs=0 threads=9 spinningthreads=0 idlethreads=3 runqueue=2 [8 14 5 2]
SCHED 2006ms: gomaxprocs=4 idleprocs=0 threads=25 spinningthreads=0 idlethreads=19 runqueue=12 [0 0 4 0]
SCHED 3006ms: gomaxprocs=4 idleprocs=0 threads=26 spinningthreads=0 idlethreads=8 runqueue=2 [0 1 1 0]
â€¦
GODEBUGè¿˜å¯ä½¿ç”¨GODEBUG=â€schedtrace=1000,scheddetail=1â€é€‰é¡¹æ¥æŸ¥çœ‹æ¯ä¸ªG,P,Mçš„è°ƒåº¦çŠ¶æ€ï¼Œæ‰“å‡ºçš„ä¿¡æ¯éå¸¸è¯¦å°½å¤æ‚ï¼Œå¹³æ—¶åº”è¯¥æ˜¯ç”¨ä¸åˆ°ã€‚å…³äºGoè°ƒè¯•å¯å‚è€ƒDmitry Vyukovå¤§ç‰›çš„Debugging performance issues in Go programsã€‚</p>

<p>æ€»ç»“
å†å›å¤´æ¥çœ‹ï¼ŒGo ä¸ºä»€ä¹ˆè¦ä½¿ç”¨GPMï¼Ÿè€Œä¸æ˜¯åƒå¤§å¤šæ•°è°ƒåº¦å™¨ä¸€æ ·åªæœ‰ä¸¤å±‚å…³ç³»GMï¼Œç›´æ¥ç”¨M(OSçº¿ç¨‹)çš„æ•°é‡æ¥é™åˆ¶å¹¶å‘èƒ½åŠ›ã€‚æˆ‘ç²—æµ…çš„ç†è§£æ˜¯ä¸ºäº†æ›´å¥½åœ°å¤„ç†syscallï¼Œå½“æŸä¸ªMé™·å…¥ç³»ç»Ÿè°ƒç”¨æ—¶ï¼ŒPåˆ™â€æŠ›å¦»å¼ƒå­â€ï¼Œä¸Mè§£ç»‘ï¼Œè®©é˜»å¡çš„Må’ŒGç­‰å¾…è¢«OSå”¤é†’ï¼Œè€ŒPåˆ™å¸¦ç€local queueå‰©ä¸‹çš„Gå»æ‰¾ä¸€ä¸ª(æˆ–æ–°å»ºä¸€ä¸ª)idleçš„Mï¼Œå½“é˜»å¡çš„Mè¢«å”¤é†’æ—¶ï¼Œå®ƒä¼šå°è¯•ç»™Gæ‰¾ä¸€ä¸ªæ–°çš„å½’å®¿(idleçš„Pï¼Œæˆ–æ‰”åˆ°global queueï¼Œç­‰å¾…è¢«é¢†å…»)</p>
:ET