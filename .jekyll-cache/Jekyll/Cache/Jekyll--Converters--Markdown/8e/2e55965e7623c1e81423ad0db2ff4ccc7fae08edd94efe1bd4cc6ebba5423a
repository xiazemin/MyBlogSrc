I"Ï*<p>åœ¨æœ‰äº›åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨go generateï¼š</p>

<p>yaccï¼šä» .y æ–‡ä»¶ç”Ÿæˆ .go æ–‡ä»¶ã€‚
protobufsï¼šä» protocol buffer å®šä¹‰æ–‡ä»¶ï¼ˆ.protoï¼‰ç”Ÿæˆ .pb.go æ–‡ä»¶ã€‚
Unicodeï¼šä» UnicodeData.txt ç”Ÿæˆ Unicode è¡¨ã€‚
HTMLï¼šå°† HTML æ–‡ä»¶åµŒå…¥åˆ° go æºç  ã€‚
bindataï¼šå°†å½¢å¦‚ JPEG è¿™æ ·çš„æ–‡ä»¶è½¬æˆ go ä»£ç ä¸­çš„å­—èŠ‚æ•°ç»„ã€‚</p>

<p>Generateå‘½ä»¤è¯´æ˜
æ—©åœ¨Go1.4ç‰ˆæœ¬å®ç°ï¼Œæ‰€ä»¥ä½ ç°åœ¨å¯ä»¥çœ‹åˆ°Goæºç ä¸­å¤§é‡å«æœ‰çš„è¯¥å‘½ä»¤ä½¿ç”¨ã€‚</p>

<p>å¦‚ï¼šåœ¨unicodeåŒ…ä¸­ç”Ÿäº§Unicodeè¡¨ï¼Œä¸ºencoding/gobåˆ›å»ºæœ‰æ•ˆçš„ç¼–è§£ç æ–¹æ³•ï¼Œåœ¨timeåŒ…ä¸­åˆ›å»ºæ—¶åŒºæ•°æ®ç­‰ç­‰</p>

<p>go generateç”¨äºä¸€é”®å¼æ‰¹é‡æ‰§è¡Œä»»ä½•å‘½ä»¤ï¼Œåˆ›å»ºæˆ–æ›´æ–°Goæ–‡ä»¶æˆ–è€…è¾“å‡ºç»“æœã€‚</p>

<p>Generate å‘½ä»¤å’Œå…¶ä»–go buildã€go getã€go testç­‰æ²¡åŠæ¯›é’±å…³ç³»ã€‚éœ€ç‰¹å®šæ‰§è¡Œï¼Œå‘½ä»¤å¦‚ä¸‹ï¼š
go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.goâ€¦ | packages]
å‚æ•°è¯´æ˜ï¼š</p>

<p>-run æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…å‘½ä»¤è¡Œï¼Œä»…æ‰§è¡ŒåŒ¹é…çš„å‘½ä»¤
-v æ‰“å°å·²è¢«æ£€ç´¢å¤„ç†çš„æ–‡ä»¶ã€‚
-n æ‰“å°å‡ºå°†è¢«æ‰§è¡Œçš„å‘½ä»¤ï¼Œæ­¤æ—¶å°†ä¸çœŸå®æ‰§è¡Œå‘½ä»¤
-x æ‰“å°å·²æ‰§è¡Œçš„å‘½ä»¤
æ‰§è¡Œä¸¾ä¾‹ï¼š</p>
<h1 id="æ‰“å°å½“å‰ç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶å°†è¢«æ‰§è¡Œçš„å‘½ä»¤">æ‰“å°å½“å‰ç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶ï¼Œå°†è¢«æ‰§è¡Œçš„å‘½ä»¤</h1>
<p>go generate -n ./â€¦</p>
<h1 id="å¯¹åŒ…ä¸‹æ‰€æœ‰goæ–‡ä»¶è¿›è¡Œå¤„ç†">å¯¹åŒ…ä¸‹æ‰€æœ‰Goæ–‡ä»¶è¿›è¡Œå¤„ç†</h1>
<p>go generate github.com/ysqi/repo</p>
<h1 id="æ‰“å°åŒ…ä¸‹æ‰€æœ‰æ–‡ä»¶å°†è¢«æ‰§è¡Œçš„å‘½ä»¤">æ‰“å°åŒ…ä¸‹æ‰€æœ‰æ–‡ä»¶ï¼Œå°†è¢«æ‰§è¡Œçš„å‘½ä»¤</h1>
<p>go generate -n runtime
å¦‚ä½•ä½¿ç”¨Generateå‘½ä»¤
éœ€åœ¨çš„ä»£ç ä¸­é…ç½®generateæ ‡è®°ï¼Œåˆ™åœ¨æ‰§è¡Œgo generateæ—¶å¯è¢«æ£€æµ‹åˆ°ã€‚go generateæ‰§è¡Œæ—¶ï¼Œå®é™…åœ¨æ‰«æå¦‚ä¸‹å†…å®¹ï¼š</p>

<p>1
//go:generate command argumentâ€¦
generateå‘½ä»¤ä¸æ˜¯è§£ææ–‡ä»¶ï¼Œè€Œæ˜¯é€è¡ŒåŒ¹é…ä»¥//go:generate å¼€å¤´çš„è¡Œ(å‰é¢ä¸è¦æœ‰ç©ºæ ¼)ã€‚æ•…å‘½ä»¤å¯ä»¥å†™åœ¨ä»»ä½•ä½ç½®ï¼Œä¹Ÿå¯å­˜åœ¨å¤šä¸ªå‘½ä»¤è¡Œã€‚</p>

<p>//go:generate åè·Ÿéšå…·ä½“çš„å‘½ä»¤ã€‚å‘½ä»¤ä¸ºå¯æ‰§è¡Œç¨‹åºï¼Œå½¢åŒåœ¨Shellä¸‹æ‰§è¡Œã€‚æ‰€ä»¥å‘½ä»¤æ˜¯åœ¨ç¯å¢ƒå˜é‡ä¸­å­˜åœ¨ï¼Œä¹Ÿå¯æ˜¯å®Œæ•´è·¯å¾„ã€‚å¦‚ï¼š
package main
import â€œfmtâ€
//go:generate echo hello
//go:generate go run main.go
//go:generate  echo file=$GOFILE pkg=$GOPACKAGE
func main() {
	fmt.Println(â€œmain funcâ€)
}
æ‰§è¡Œï¼š
$ go generate
hello
man func
file=main.go pkg=main
åœ¨æ‰§è¡Œgo generateæ—¶å°†ä¼šåŠ å…¥äº›ä¿¡æ¯åˆ°ç¯å¢ƒå˜é‡ï¼Œå¯åœ¨å‘½ä»¤ç¨‹åºä¸­ä½¿ç”¨ã€‚
$GOARCH
	æ¶æ„ (arm, amd64, etc.)
$GOOS
	OS (linux, windows, etc.)
$GOFILE
	å½“å‰å¤„ç†ä¸­çš„æ–‡ä»¶å
$GOLINE
	å½“å‰å‘½ä»¤åœ¨æ–‡ä»¶ä¸­çš„è¡Œå·
$GOPACKAGE
    å½“å‰å¤„ç†æ–‡ä»¶çš„åŒ…å
$DOLLAR
	å›ºå®šçš„â€$â€,ä¸æ¸…æ¥šç”¨é€”
åŒæ—¶è¯¥å‘½ä»¤æ˜¯åœ¨æ‰€å¤„ç†æ–‡ä»¶çš„ç›®å½•ä¸‹æ‰§è¡Œï¼Œæ•…åˆ©ç”¨ä¸Šè¿°ä¿¡æ¯å’Œå½“å‰ç›®å½•ï¼Œè¾¹å¯è·å¾—ä¸°å¯Œçš„DIYåŠŸèƒ½ã€‚
<!-- more -->
https://godoc.org/golang.org/x/tools/cmd/stringer
 æœ€ç»ˆè°ƒç”¨ä¸ºï¼š
//go:generate  myenumstr -type Status
è‡ªåŠ¨ç”Ÿæˆå¦‚ä¸‹ä»£ç ï¼š
package user
import â€œfmtâ€
func (c Status) String() string {
	switch c {
	case Offline:
		return â€œOfflineâ€
	case Online:
		return â€œOnlineâ€
	case Disable:
		return â€œDisableâ€
	case Deleted:
		return â€œDeletedâ€
	}
	return fmt.Sprintf(â€œStatus(%d)â€, c)
}
ä¸šåŠ¡é€»è¾‘
è¯¥å¦‚ä½•å®ç°å‘¢ï¼Ÿå®é™…æˆ‘ä»¬éœ€è¦è·å¾—ä¸‰é¡¹:</p>

<p>åŒ…åï¼šuserï¼Œè¯¥æ–‡ä»¶å°†å­˜æ”¾åœ¨å½“å‰ç›®å½•ï¼Œéœ€è¦çŸ¥æ™“åŒ…åç§°
ç±»å‹åï¼šStatusï¼Œå‚æ•°ä¼ é€’
æ‰€æœ‰åŒç±»å‹var: Offlineï¼ŒOnlineï¼ŒDisableï¼ŒDeleted
å†ç”Ÿæˆä»£ç åå°†å…¶ä¿å­˜åˆ°å½“å‰ç›®å½•ï¼ŒåŒæ—¶è¿›è¡Œgofmtã€‚</p>

<p>å…·ä½“å®ç°
1.é€šè¿‡ç¯å¢ƒå˜é‡è·å–åŒ…åç§°
pkgName = os.Getenv(â€œGOPACKAGEâ€)
2.è·å–å½“å‰ç›®å½•åŒ…ä¿¡æ¯ è¿™é‡Œåˆ©ç”¨Goå†…ç½®çš„åº“go/buildè§£æç›®å½•ï¼Œåˆ™å¯ä»¥è·å¾—è¯¥æ–‡ä»¶å¤¹ä¸‹åŒ…ä¿¡æ¯ã€‚
var err error
pkgInfo, err = build.ImportDir(â€œ.â€, 0)
if err != nil {
	log.Fatal(err)
}
è‡³æ­¤ä¾¿èƒ½è·å¾—ç›®å½•ä¸‹æ‰€æœ‰Goæ–‡ä»¶pkgInfo.GoFilesï¼Œç”¨äºè¯­æ³•æ ‘è§£æã€‚</p>

<p>3.è§£æGoæ–‡ä»¶è¯­æ³•æ ‘ï¼Œæå–Statusç›¸å…³ä¿¡æ¯ã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæˆ‘ä»¬çº¦å®šæ‰€å®šä¹‰çš„æšä¸¾ä¿¡æ¯å®é™…åº”è¯¥å…¨éƒ¨æ˜¯Constã€‚éœ€ä»è¯­æ³•æ ‘ä¸­ æå–å‡ºæ‰€æœ‰çš„Constï¼Œå¹¶åˆ¤æ–­ç±»å‹æ˜¯å¦ç¬¦åˆæ¡ä»¶ã€‚</p>

<p>è¿™é‡Œåˆ©ç”¨çš„æ˜¯Goçš„è¯­æ³•æ ‘åº“go/ast(abstract syntax tree)å’Œè§£æåº“go/parserï¼Œè¯­æ³•æ ‘æ˜¯æŒ‰è¯­å¥å—()å½¢æˆæ ‘ç»“æ„ã€‚ä»ä¸­è¿‡æ»¤constè¯­å¥å—
fset := token.NewFileSet()
//è§£ægoæ–‡ä»¶
f, err := parser.ParseFile(fset, gofile, nil, 0)
if err != nil {
	log.Fatal(err)
}
//éå†æ¯ä¸ªæ ‘èŠ‚ç‚¹
ast.Inspect(f, func(n ast.Node) bool {
	decl, ok := n.(<em>ast.GenDecl)
	if !ok || decl.Tok != token.CONST {
		return true
	}
	//â€¦
}
å†å¾ªç¯constè¯­å¥å—ä¸­æœ€å°éƒ¨åˆ†ï¼š
for _, spec := range decl.Specs {}
å¯¹æ¯å°éƒ¨åˆ†åˆ¤æ–­ï¼Œå¹¶è·å¾—å¯¹åº”çš„Typeï¼Œå¦‚æœTypeä¸ºç©ºåˆ™åŒä¸Šä¸€è¡Œçš„ä¸€è‡´ã€‚
// Const ä»£ç å—
const (
	Offline Status = iota
	Online
	Disable
	Deleted
)
è¡Œå†…å®¹
vspec := spec.(</em>ast.ValueSpec) 
if vspec.Type == nil &amp;&amp; len(vspec.Values) &gt;0 {
	// æ’é™¤ v = 1 è¿™ç§ç»“æ„
	typ = â€œâ€
	continue
}
//å¦‚æœTypeä¸ä¸ºç©ºï¼Œåˆ™ç¡®è®¤typ
if vspec.Type != nil {
	ident, ok := vspec.Type.(<em>ast.Ident)
	if !ok {
		continue
	}
	typ = ident.Name
}
ä½†æˆ‘ä»¬åªéœ€è¦è·å¾—ç¬¦åˆè¦æ±‚çš„Typeï¼Œè·å¾—ç¬¦åˆè¦æ±‚çš„Constä¿¡æ¯ï¼š
consts, ok := typesMap[typ]
if !ok {
	continue
}
for _, n := range vspec.Names {
	consts = append(consts, n.Name)
}
typesMap[typ] = consts
è¿™é‡Œçš„typesMapæ˜¯æ ¹æ®ç¨‹åºå…¥å‚å»ºç«‹ï¼š
var ( 
	typeNames = flag.String(â€œtypeâ€, â€œâ€, â€œâ€)
)
types := strings.Split(</em>typeNames, â€œ,â€)
typesMap := make(map[string][]string, len(types))
for _, v := range types {
	typesMap[strings.TrimSpace(v)] = []string{}
}
4.æ ¹æ®æ”¶é›†çš„Constï¼Œç”ŸæˆStringå‡½æ•°</p>

<p>ä½¿ç”¨æ¨¡æ¿ç”Ÿæˆå†…å®¹ï¼ŒåŒæ—¶è¿›è¡Œgofmt
func genString(types map[string][]string) []byte {
	const strTmp = `
	package {{.pkg}}
	import â€œfmtâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{\{range $typ,$consts :=.types}\}
func (c {\{$typ}\}) String() string{
	switch c { {\{range $consts}\}
		case {\{.}\}:return "{\{.}\}"{\{end}\}
	}
	return fmt.Sprintf("Status(%d)", c)	
}
{\{end}\}
`
pkgName := os.Getenv("GOPACKAGE")
if pkgName == "" {
	pkgName = pkgInfo.Name
}
data := map[string]interface{}{
	"pkg":   pkgName,
	"types": types,
}
//åˆ©ç”¨æ¨¡æ¿åº“ï¼Œç”Ÿæˆä»£ç æ–‡ä»¶
t, err := template.New("").Parse(strTmp)
if err != nil {
	log.Fatal(err)
}
buff := bytes.NewBufferString("")
err = t.Execute(buff, data)
if err != nil {
	log.Fatal(err)
}
//è¿›è¡Œæ ¼å¼åŒ–
src, err := format.Source(buff.Bytes())
if err != nil {
	log.Fatal(err)
}
return src } 5.ä¿å­˜ä»£ç åˆ°æ–‡ä»¶ å°†æ–‡ä»¶ç›´æ¥ä¿å­˜åˆ°å½“å‰ç›®å½•ä¸‹ï¼Œæ–‡ä»¶åå·²â€_stringâ€ç»“å°¾ src := genString(consts)  outputName := "" if outputName == "" {
types := strings.Split(*typeNames, ",")
baseName := fmt.Sprintf("%s_string.go", types[0])
outputName = filepath.Join(".", strings.ToLower(baseName)) } err := ioutil.WriteFile(outputName, src, 0644) if err != nil {
log.Fatalf(err) } 6.åœ¨status.goæºæ–‡ä»¶é…ç½®æ ‡è®° //go:generate myenumstr -type Status è¿è¡Œgo generateï¼Œå‡ºç°é”™è¯¯ï¼š user/status.go:5: running "myenumstr": exec: "myenumstr": executable file not found in $PATH æ­¤æ—¶éœ€è¦å°†myenumstr.go install go install github.com/ysqi/string/myenumstr.go å®‰è£…åï¼Œæˆ‘ä»¬å¯ä»¥åœ¨status.goä½¿ç”¨ä¸¤ç§æ–¹å¼è°ƒç”¨ï¼š //go:generate myenumstr -type Status //go:generate go run github.com/ysqi/string/myenumstr.go -type Status è‡³æ­¤å†™å®Œï¼Œå®Œæ•´ä»£ç å¦‚ä¸‹ï¼š
</code></pre></div></div>

<p>æºä»£ç -user.go
package user
type Status int
//go:generate myenumstr -type Status,Color
const (
	Offline Status = iota
	Online
	Disable
	Deleted
)
type Color int
const (
	Write Color = iota
	Red
	Blue
)
æºä»£ç -myenumstr.go
package main
import (
	â€œbytesâ€
	â€œflagâ€
	â€œfmtâ€
	â€œgo/astâ€
	â€œgo/buildâ€
	â€œgo/formatâ€
	â€œgo/parserâ€
	â€œgo/tokenâ€
	â€œio/ioutilâ€
	â€œlogâ€
	â€œosâ€
	â€œpath/filepathâ€
	â€œstringsâ€
	â€œtext/templateâ€
)
var (
	pkgInfo <em>build.Package
)
var (
	typeNames = flag.String(â€œtypeâ€, â€œâ€, â€œå¿…å¡«ï¼Œé€—å·è¿æ¥çš„å¤šä¸ªTypeåâ€)
)
func main() {
	flag.Parse()
	if len(</em>typeNames) == 0 {
		log.Fatal(â€œ-type å¿…å¡«â€)
	}
	consts := getConsts()
	src := genString(consts)
	//ä¿å­˜åˆ°æ–‡ä»¶
	outputName := â€œâ€
	if outputName == â€œâ€ {
		types := strings.Split(<em>typeNames, â€œ,â€)
		baseName := fmt.Sprintf(â€œ%s_string.goâ€, types[0])
		outputName = filepath.Join(â€œ.â€, strings.ToLower(baseName))
	}
	err := ioutil.WriteFile(outputName, src, 0644)
	if err != nil {
		log.Fatalf(â€œwriting output: %sâ€, err)
	}
}
func getConsts() map[string][]string {
	//è·å¾—å¾…å¤„ç†çš„Type
	types := strings.Split(</em>typeNames, â€œ,â€)
	typesMap := make(map[string][]string, len(types))
	for _, v := range types {
		typesMap[strings.TrimSpace(v)] = []string{}
	}
	//è§£æå½“å‰ç›®å½•ä¸‹åŒ…ä¿¡æ¯
	var err error
	pkgInfo, err = build.ImportDir(â€œ.â€, 0)
	if err != nil {
		log.Fatal(err)
	}
	fset := token.NewFileSet()
	for _, file := range pkgInfo.GoFiles {
		f, err := parser.ParseFile(fset, file, nil, 0)
		if err != nil {
			log.Fatal(err)
		}
		typ := â€œâ€
		ast.Inspect(f, func(n ast.Node) bool {
			decl, ok := n.(<em>ast.GenDecl)
			// åªéœ€è¦const
			if !ok || decl.Tok != token.CONST {
				return true
			}
			for _, spec := range decl.Specs {
				vspec := spec.(</em>ast.ValueSpec)
				if vspec.Type == nil &amp;&amp; len(vspec.Values) &gt; 0 {
					// æ’é™¤ v = 1 è¿™ç§ç»“æ„
					typ = â€œâ€
					continue
				}
				//å¦‚æœTypeä¸ä¸ºç©ºï¼Œåˆ™ç¡®è®¤typ
				if vspec.Type != nil {
					ident, ok := vspec.Type.(*ast.Ident)
					if !ok {
						continue
					}
					typ = ident.Name
				}
				//typæ˜¯å¦æ˜¯éœ€å¤„ç†çš„ç±»å‹
				consts, ok := typesMap[typ]
				if !ok {
					continue
				}
				//å°†æ‰€æœ‰constå˜é‡åä¿å­˜
				for _, n := range vspec.Names {
					consts = append(consts, n.Name)
				}
				typesMap[typ] = consts
			}
			return true
		})
	}
	return typesMap
}
func genString(types map[string][]string) []byte {
	const strTmp = `
	package {{.pkg}}
	import â€œfmtâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{\{range $typ,$consts :=.types}\}
func (c {\{$typ}\}) String() string{
	switch c { {\{range $consts}\}
		case {\{.}\}:return "{\{.}\}"{\{end}\}
	}
	return fmt.Sprintf("Status(%d)", c)	
}
{\{end}\}
`
pkgName := os.Getenv("GOPACKAGE")
if pkgName == "" {
	pkgName = pkgInfo.Name
}
data := map[string]interface{}{
	"pkg":   pkgName,
	"types": types,
}
//åˆ©ç”¨æ¨¡æ¿åº“ï¼Œç”Ÿæˆä»£ç æ–‡ä»¶
t, err := template.New("").Parse(strTmp)
if err != nil {
	log.Fatal(err)
}
buff := bytes.NewBufferString("")
err = t.Execute(buff, data)
if err != nil {
	log.Fatal(err)
}
//æ ¼å¼åŒ–
src, err := format.Source(buff.Bytes())
if err != nil {
	log.Fatal(err)
}
return src }
</code></pre></div></div>
:ET