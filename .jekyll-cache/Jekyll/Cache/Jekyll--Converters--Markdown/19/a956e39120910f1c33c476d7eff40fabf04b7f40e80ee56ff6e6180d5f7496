I"šî<p>Go åŸºäº I/O multiplexing å’Œ goroutine æ„å»ºäº†ä¸€ä¸ªç®€æ´è€Œé«˜æ€§èƒ½çš„åŸç”Ÿç½‘ç»œæ¨¡å‹(åŸºäº Go çš„ I/O å¤šè·¯å¤ç”¨ netpoll)ï¼Œæä¾›äº† goroutine-per-connection è¿™æ ·ç®€å•çš„ç½‘ç»œç¼–ç¨‹æ¨¡å¼ã€‚åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œå¼€å‘è€…ä½¿ç”¨çš„æ˜¯åŒæ­¥çš„æ¨¡å¼å»ç¼–å†™å¼‚æ­¥çš„é€»è¾‘ï¼Œæå¤§åœ°é™ä½äº†å¼€å‘è€…ç¼–å†™ç½‘ç»œåº”ç”¨æ—¶çš„å¿ƒæ™ºè´Ÿæ‹…ï¼Œä¸”å€ŸåŠ©äº Go runtime scheduler å¯¹ goroutines çš„é«˜æ•ˆè°ƒåº¦ï¼Œè¿™ä¸ªåŸç”Ÿç½‘ç»œæ¨¡å‹ä¸è®ºä»é€‚ç”¨æ€§è¿˜æ˜¯æ€§èƒ½ä¸Šéƒ½è¶³ä»¥æ»¡è¶³ç»å¤§éƒ¨åˆ†çš„åº”ç”¨åœºæ™¯ã€‚</p>

<p>ç„¶è€Œï¼Œåœ¨å·¥ç¨‹æ€§ä¸Šèƒ½åšåˆ°å¦‚æ­¤é«˜çš„æ™®é€‚æ€§å’Œå…¼å®¹æ€§ï¼Œæœ€ç»ˆæš´éœ²ç»™å¼€å‘è€…æä¾›æ¥å£/æ¨¡å¼å¦‚æ­¤ç®€æ´ï¼Œå…¶åº•å±‚å¿…ç„¶æ˜¯åŸºäºéå¸¸å¤æ‚çš„å°è£…ï¼Œåšäº†å¾ˆå¤šå–èˆï¼Œä¹Ÿæœ‰å¯èƒ½æ”¾å¼ƒäº†ä¸€äº›ã€æè‡´ã€çš„è®¾è®¡å’Œç†å¿µã€‚äº‹å®ä¸Šnetpollåº•å±‚å°±æ˜¯åŸºäº epoll/kqueue/iocp è¿™äº›ç³»ç»Ÿè°ƒç”¨æ¥åšå°è£…çš„ï¼Œæœ€ç»ˆæš´éœ²å‡º goroutine-per-connection è¿™æ ·çš„æç®€çš„å¼€å‘æ¨¡å¼ç»™ä½¿ç”¨è€…ã€‚</p>

<p>Go netpoll åœ¨ä¸åŒçš„æ“ä½œç³»ç»Ÿï¼Œå…¶åº•å±‚ä½¿ç”¨çš„ I/O å¤šè·¯å¤ç”¨æŠ€æœ¯ä¹Ÿä¸ä¸€æ ·ï¼Œå¯ä»¥ä» Go æºç ç›®å½•ç»“æ„å’Œå¯¹åº”ä»£ç æ–‡ä»¶äº†è§£ Go åœ¨ä¸åŒå¹³å°ä¸‹çš„ç½‘ç»œ I/O æ¨¡å¼çš„å®ç°ã€‚æ¯”å¦‚ï¼Œåœ¨ Linux ç³»ç»Ÿä¸‹åŸºäº epollï¼ŒfreeBSD ç³»ç»Ÿä¸‹åŸºäº kqueueï¼Œä»¥åŠ Windows ç³»ç»Ÿä¸‹åŸºäº iocpã€‚</p>

<p>æœ¬æ–‡å°†åŸºäº Linux å¹³å°æ¥è§£æ Go netpoll ä¹‹ I/O å¤šè·¯å¤ç”¨çš„åº•å±‚æ˜¯å¦‚ä½•åŸºäº epoll å°è£…å®ç°çš„ï¼Œä»æºç å±‚å±‚æ¨è¿›ï¼Œå…¨é¢è€Œæ·±åº¦åœ°è§£æ Go netpoll çš„è®¾è®¡ç†å¿µå’Œå®ç°åŸç†ï¼Œä»¥åŠ Go æ˜¯å¦‚ä½•åˆ©ç”¨netpollæ¥æ„å»ºå®ƒçš„åŸç”Ÿç½‘ç»œæ¨¡å‹çš„ã€‚ä¸»è¦æ¶‰åŠåˆ°çš„ä¸€äº›æ¦‚å¿µï¼šI/O æ¨¡å¼ã€ç”¨æˆ·/å†…æ ¸ç©ºé—´ã€epollã€Linux æºç ã€goroutine scheduler ç­‰ç­‰ï¼Œ
<!-- more -->
ç”¨æˆ·ç©ºé—´ä¸å†…æ ¸ç©ºé—´
ç°åœ¨æ“ä½œç³»ç»Ÿéƒ½æ˜¯é‡‡ç”¨è™šæ‹Ÿå­˜å‚¨å™¨ï¼Œé‚£ä¹ˆå¯¹ 32 ä½æ“ä½œç³»ç»Ÿè€Œè¨€ï¼Œå®ƒçš„å¯»å€ç©ºé—´ï¼ˆè™šæ‹Ÿå­˜å‚¨ç©ºé—´ï¼‰ä¸º 4Gï¼ˆ2 çš„ 32 æ¬¡æ–¹ï¼‰ã€‚æ“ä½œç³»ç»Ÿçš„æ ¸å¿ƒæ˜¯å†…æ ¸ï¼Œç‹¬ç«‹äºæ™®é€šçš„åº”ç”¨ç¨‹åºï¼Œå¯ä»¥è®¿é—®å—ä¿æŠ¤çš„å†…å­˜ç©ºé—´ï¼Œä¹Ÿæœ‰è®¿é—®åº•å±‚ç¡¬ä»¶è®¾å¤‡çš„æ‰€æœ‰æƒé™ã€‚ä¸ºäº†ä¿è¯ç”¨æˆ·è¿›ç¨‹ä¸èƒ½ç›´æ¥æ“ä½œå†…æ ¸ï¼ˆkernelï¼‰ï¼Œä¿è¯å†…æ ¸çš„å®‰å…¨ï¼Œæ“å¿ƒç³»ç»Ÿå°†è™šæ‹Ÿç©ºé—´åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†ä¸ºå†…æ ¸ç©ºé—´ï¼Œä¸€éƒ¨åˆ†ä¸ºç”¨æˆ·ç©ºé—´ã€‚é’ˆå¯¹ Linux æ“ä½œç³»ç»Ÿè€Œè¨€ï¼Œå°†æœ€é«˜çš„ 1G å­—èŠ‚ï¼ˆä»è™šæ‹Ÿåœ°å€ 0xC0000000 åˆ° 0xFFFFFFFFï¼‰ï¼Œä¾›å†…æ ¸ä½¿ç”¨ï¼Œç§°ä¸ºå†…æ ¸ç©ºé—´ï¼Œè€Œå°†è¾ƒä½çš„ 3G å­—èŠ‚ï¼ˆä»è™šæ‹Ÿåœ°å€ 0x00000000 åˆ° 0xBFFFFFFFï¼‰ï¼Œä¾›å„ä¸ªè¿›ç¨‹ä½¿ç”¨ï¼Œç§°ä¸ºç”¨æˆ·ç©ºé—´ã€‚</p>

<p>I/O å¤šè·¯å¤ç”¨
åœ¨ç¥ä½œã€ŠUNIX ç½‘ç»œç¼–ç¨‹ã€‹é‡Œï¼Œæ€»ç»“å½’çº³äº† 5 ç§ I/O æ¨¡å‹ï¼ŒåŒ…æ‹¬åŒæ­¥å’Œå¼‚æ­¥ I/Oï¼š</p>

<p>é˜»å¡ I/O (Blocking I/O)
éé˜»å¡ I/O (Nonblocking I/O)
I/O å¤šè·¯å¤ç”¨ (I/O multiplexing)
ä¿¡å·é©±åŠ¨ I/O (Signal driven I/O)
å¼‚æ­¥ I/O (Asynchronous I/O)
æ“ä½œç³»ç»Ÿä¸Šçš„ I/O æ˜¯ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„æ•°æ®äº¤äº’ï¼Œå› æ­¤ I/O æ“ä½œé€šå¸¸åŒ…å«ä»¥ä¸‹ä¸¤ä¸ªæ­¥éª¤ï¼š</p>

<p>ç­‰å¾…ç½‘ç»œæ•°æ®åˆ°è¾¾ç½‘å¡(è¯»å°±ç»ª)/ç­‰å¾…ç½‘å¡å¯å†™(å†™å°±ç»ª) â€“&gt; è¯»å–/å†™å…¥åˆ°å†…æ ¸ç¼“å†²åŒº
ä»å†…æ ¸ç¼“å†²åŒºå¤åˆ¶æ•°æ® â€“&gt; ç”¨æˆ·ç©ºé—´(è¯»)/ä»ç”¨æˆ·ç©ºé—´å¤åˆ¶æ•°æ® -&gt; å†…æ ¸ç¼“å†²åŒº(å†™)
è€Œåˆ¤å®šä¸€ä¸ª I/O æ¨¡å‹æ˜¯åŒæ­¥è¿˜æ˜¯å¼‚æ­¥ï¼Œä¸»è¦çœ‹ç¬¬äºŒæ­¥ï¼šæ•°æ®åœ¨ç”¨æˆ·å’Œå†…æ ¸ç©ºé—´ä¹‹é—´å¤åˆ¶çš„æ—¶å€™æ˜¯ä¸æ˜¯ä¼šé˜»å¡å½“å‰è¿›ç¨‹ï¼Œå¦‚æœä¼šï¼Œåˆ™æ˜¯åŒæ­¥ I/Oï¼Œå¦åˆ™ï¼Œå°±æ˜¯å¼‚æ­¥ I/Oã€‚åŸºäºè¿™ä¸ªåŸåˆ™ï¼Œè¿™ 5 ç§ I/O æ¨¡å‹ä¸­åªæœ‰ä¸€ç§å¼‚æ­¥ I/O æ¨¡å‹ï¼šAsynchronous I/Oï¼Œå…¶ä½™éƒ½æ˜¯åŒæ­¥ I/O æ¨¡å‹</p>

<p>æ‰€è°“ I/O å¤šè·¯å¤ç”¨æŒ‡çš„å°±æ˜¯ select/poll/epoll è¿™ä¸€ç³»åˆ—çš„å¤šè·¯é€‰æ‹©å™¨ï¼šæ”¯æŒå•ä¸€çº¿ç¨‹åŒæ—¶ç›‘å¬å¤šä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼ˆI/O äº‹ä»¶ï¼‰ï¼Œé˜»å¡ç­‰å¾…ï¼Œå¹¶åœ¨å…¶ä¸­æŸä¸ªæ–‡ä»¶æè¿°ç¬¦å¯è¯»å†™æ—¶æ”¶åˆ°é€šçŸ¥ã€‚ I/O å¤ç”¨å…¶å®å¤ç”¨çš„ä¸æ˜¯ I/O è¿æ¥ï¼Œè€Œæ˜¯å¤ç”¨çº¿ç¨‹ï¼Œè®©ä¸€ä¸ª thread of control èƒ½å¤Ÿå¤„ç†å¤šä¸ªè¿æ¥ï¼ˆI/O äº‹ä»¶ï¼‰ã€‚</p>

<p>select &amp; poll
#include &lt;sys/select.h&gt;</p>

<p>/* According to earlier standards */
#include &lt;sys/time.h&gt;
#include &lt;sys/types.h&gt;
#include <unistd.h></unistd.h></p>

<p>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</p>

<p>// å’Œ select ç´§å¯†ç»“åˆçš„å››ä¸ªå®ï¼š
void FD_CLR(int fd, fd_set *set);
int FD_ISSET(int fd, fd_set *set);
void FD_SET(int fd, fd_set *set);
void FD_ZERO(fd_set *set);
select æ˜¯ epoll ä¹‹å‰ Linux ä½¿ç”¨çš„ I/O äº‹ä»¶é©±åŠ¨æŠ€æœ¯ã€‚</p>

<p>ç†è§£ select çš„å…³é”®åœ¨äºç†è§£ fd_setï¼Œä¸ºè¯´æ˜æ–¹ä¾¿ï¼Œå– fd_set é•¿åº¦ä¸º 1 å­—èŠ‚ï¼Œfd_set ä¸­çš„æ¯ä¸€ bit å¯ä»¥å¯¹åº”ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ fdï¼Œåˆ™ 1 å­—èŠ‚é•¿çš„ fd_set æœ€å¤§å¯ä»¥å¯¹åº” 8 ä¸ª fdã€‚select çš„è°ƒç”¨è¿‡ç¨‹å¦‚ä¸‹ï¼š</p>

<p>æ‰§è¡Œ FD_ZERO(&amp;set), åˆ™ set ç”¨ä½è¡¨ç¤ºæ˜¯ 0000,0000
è‹¥ fdï¼5, æ‰§è¡Œ FD_SET(fd, &amp;set); å set å˜ä¸º 0001,0000(ç¬¬ 5 ä½ç½®ä¸º 1)
å†åŠ å…¥ fdï¼2, fd=1ï¼Œåˆ™ set å˜ä¸º 0001,0011
æ‰§è¡Œ select(6, &amp;set, 0, 0, 0) é˜»å¡ç­‰å¾…
è‹¥ fd=1, fd=2 ä¸Šéƒ½å‘ç”Ÿå¯è¯»äº‹ä»¶ï¼Œåˆ™ select è¿”å›ï¼Œæ­¤æ—¶ set å˜ä¸º 0000,0011 (æ³¨æ„ï¼šæ²¡æœ‰äº‹ä»¶å‘ç”Ÿçš„ fd=5 è¢«æ¸…ç©º)
åŸºäºä¸Šé¢çš„è°ƒç”¨è¿‡ç¨‹ï¼Œå¯ä»¥å¾—å‡º select çš„ç‰¹ç‚¹ï¼š</p>

<p>å¯ç›‘æ§çš„æ–‡ä»¶æè¿°ç¬¦ä¸ªæ•°å–å†³äº sizeof(fd_set) çš„å€¼ã€‚å‡è®¾æœåŠ¡å™¨ä¸Š sizeof(fd_set)ï¼512ï¼Œæ¯ bit è¡¨ç¤ºä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œåˆ™æœåŠ¡å™¨ä¸Šæ”¯æŒçš„æœ€å¤§æ–‡ä»¶æè¿°ç¬¦æ˜¯ 512*8=4096ã€‚fd_set çš„å¤§å°è°ƒæ•´å¯å‚è€ƒ ã€åŸåˆ›ã€‘æŠ€æœ¯ç³»åˆ—ä¹‹ ç½‘ç»œæ¨¡å‹ï¼ˆäºŒï¼‰ ä¸­çš„æ¨¡å‹ 2ï¼Œå¯ä»¥æœ‰æ•ˆçªç ´ select å¯ç›‘æ§çš„æ–‡ä»¶æè¿°ç¬¦ä¸Šé™
å°† fd åŠ å…¥ select ç›‘æ§é›†çš„åŒæ—¶ï¼Œè¿˜è¦å†ä½¿ç”¨ä¸€ä¸ªæ•°æ®ç»“æ„ array ä¿å­˜æ”¾åˆ° select ç›‘æ§é›†ä¸­çš„ fdï¼Œä¸€æ˜¯ç”¨äºåœ¨ select è¿”å›åï¼Œarray ä½œä¸ºæºæ•°æ®å’Œ fd_set è¿›è¡Œ FD_ISSET åˆ¤æ–­ã€‚äºŒæ˜¯ select è¿”å›åä¼šæŠŠä»¥å‰åŠ å…¥çš„ä½†å¹¶æ— äº‹ä»¶å‘ç”Ÿçš„ fd æ¸…ç©ºï¼Œåˆ™æ¯æ¬¡å¼€å§‹ select å‰éƒ½è¦é‡æ–°ä» array å–å¾— fd é€ä¸€åŠ å…¥ï¼ˆFD_ZERO æœ€å…ˆï¼‰ï¼Œæ‰«æ array çš„åŒæ—¶å–å¾— fd æœ€å¤§å€¼ maxfdï¼Œç”¨äº select çš„ç¬¬ä¸€ä¸ªå‚æ•°
å¯è§ select æ¨¡å‹å¿…é¡»åœ¨ select å‰å¾ªç¯ arrayï¼ˆåŠ  fdï¼Œå– maxfdï¼‰ï¼Œselect è¿”å›åå¾ªç¯ arrayï¼ˆFD_ISSET åˆ¤æ–­æ˜¯å¦æœ‰äº‹ä»¶å‘ç”Ÿï¼‰
æ‰€ä»¥ï¼Œselect æœ‰å¦‚ä¸‹çš„ç¼ºç‚¹ï¼š</p>

<p>æœ€å¤§å¹¶å‘æ•°é™åˆ¶ï¼šä½¿ç”¨ 32 ä¸ªæ•´æ•°çš„ 32 ä½ï¼Œå³ 32*32=1024 æ¥æ ‡è¯† fdï¼Œè™½ç„¶å¯ä¿®æ”¹ï¼Œä½†æ˜¯æœ‰ä»¥ä¸‹ç¬¬ 2, 3 ç‚¹çš„ç“¶é¢ˆ
æ¯æ¬¡è°ƒç”¨ selectï¼Œéƒ½éœ€è¦æŠŠ fd é›†åˆä»ç”¨æˆ·æ€æ‹·è´åˆ°å†…æ ¸æ€ï¼Œè¿™ä¸ªå¼€é”€åœ¨ fd å¾ˆå¤šæ—¶ä¼šå¾ˆå¤§
æ€§èƒ½è¡°å‡ä¸¥é‡ï¼šæ¯æ¬¡ kernel éƒ½éœ€è¦çº¿æ€§æ‰«ææ•´ä¸ª fd_setï¼Œæ‰€ä»¥éšç€ç›‘æ§çš„æè¿°ç¬¦ fd æ•°é‡å¢é•¿ï¼Œå…¶ I/O æ€§èƒ½ä¼šçº¿æ€§ä¸‹é™
poll çš„å®ç°å’Œ select éå¸¸ç›¸ä¼¼ï¼Œåªæ˜¯æè¿° fd é›†åˆçš„æ–¹å¼ä¸åŒï¼Œpoll ä½¿ç”¨ pollfd ç»“æ„è€Œä¸æ˜¯ select çš„ fd_set ç»“æ„ï¼Œpoll è§£å†³äº†æœ€å¤§æ–‡ä»¶æè¿°ç¬¦æ•°é‡é™åˆ¶çš„é—®é¢˜ï¼Œä½†æ˜¯åŒæ ·éœ€è¦ä»ç”¨æˆ·æ€æ‹·è´æ‰€æœ‰çš„ fd åˆ°å†…æ ¸æ€ï¼Œä¹Ÿéœ€è¦çº¿æ€§éå†æ‰€æœ‰çš„ fd é›†åˆï¼Œæ‰€ä»¥å®ƒå’Œ select åªæ˜¯å®ç°ç»†èŠ‚ä¸Šçš„åŒºåˆ†ï¼Œå¹¶æ²¡æœ‰æœ¬è´¨ä¸Šçš„åŒºåˆ«ã€‚</p>

<p>epoll
epoll æ˜¯ Linux kernel 2.6 ä¹‹åå¼•å…¥çš„æ–° I/O äº‹ä»¶é©±åŠ¨æŠ€æœ¯ï¼ŒI/O å¤šè·¯å¤ç”¨çš„æ ¸å¿ƒè®¾è®¡æ˜¯ 1 ä¸ªçº¿ç¨‹å¤„ç†æ‰€æœ‰è¿æ¥çš„ç­‰å¾…æ¶ˆæ¯å‡†å¤‡å¥½I/O äº‹ä»¶ï¼Œè¿™ä¸€ç‚¹ä¸Š epoll å’Œ select&amp;poll æ˜¯å¤§åŒå°å¼‚çš„ã€‚ä½† select&amp;poll é¢„ä¼°é”™è¯¯äº†ä¸€ä»¶äº‹ï¼Œå½“æ•°åä¸‡å¹¶å‘è¿æ¥å­˜åœ¨æ—¶ï¼Œå¯èƒ½æ¯ä¸€æ¯«ç§’åªæœ‰æ•°ç™¾ä¸ªæ´»è·ƒçš„è¿æ¥ï¼ŒåŒæ—¶å…¶ä½™æ•°åä¸‡è¿æ¥åœ¨è¿™ä¸€æ¯«ç§’æ˜¯éæ´»è·ƒçš„ã€‚select&amp;poll çš„ä½¿ç”¨æ–¹æ³•æ˜¯è¿™æ ·çš„ï¼šè¿”å›çš„æ´»è·ƒè¿æ¥ == selectï¼ˆå…¨éƒ¨å¾…ç›‘æ§çš„è¿æ¥ï¼‰ã€‚</p>

<p>ä»€ä¹ˆæ—¶å€™ä¼šè°ƒç”¨ select&amp;poll å‘¢ï¼Ÿåœ¨ä½ è®¤ä¸ºéœ€è¦æ‰¾å‡ºæœ‰æŠ¥æ–‡åˆ°è¾¾çš„æ´»è·ƒè¿æ¥æ—¶ï¼Œå°±åº”è¯¥è°ƒç”¨ã€‚æ‰€ä»¥ï¼Œselect&amp;poll åœ¨é«˜å¹¶å‘æ—¶æ˜¯ä¼šè¢«é¢‘ç¹è°ƒç”¨çš„ã€‚è¿™æ ·ï¼Œè¿™ä¸ªé¢‘ç¹è°ƒç”¨çš„æ–¹æ³•å°±å¾ˆæœ‰å¿…è¦çœ‹çœ‹å®ƒæ˜¯å¦æœ‰æ•ˆç‡ï¼Œå› ä¸ºï¼Œå®ƒçš„è½»å¾®æ•ˆç‡æŸå¤±éƒ½ä¼šè¢«é«˜é¢‘äºŒå­—æ‰€æ”¾å¤§ã€‚å®ƒæœ‰æ•ˆç‡æŸå¤±å—ï¼Ÿæ˜¾è€Œæ˜“è§ï¼Œå…¨éƒ¨å¾…ç›‘æ§è¿æ¥æ˜¯æ•°ä»¥åä¸‡è®¡çš„ï¼Œè¿”å›çš„åªæ˜¯æ•°ç™¾ä¸ªæ´»è·ƒè¿æ¥ï¼Œè¿™æœ¬èº«å°±æ˜¯æ— æ•ˆç‡çš„è¡¨ç°ã€‚è¢«æ”¾å¤§åå°±ä¼šå‘ç°ï¼Œå¤„ç†å¹¶å‘ä¸Šä¸‡ä¸ªè¿æ¥æ—¶ï¼Œselect&amp;poll å°±å®Œå…¨åŠ›ä¸ä»å¿ƒäº†ã€‚è¿™ä¸ªæ—¶å€™å°±è¯¥ epoll ä¸Šåœºäº†ï¼Œepoll é€šè¿‡ä¸€äº›æ–°çš„è®¾è®¡å’Œä¼˜åŒ–ï¼ŒåŸºæœ¬ä¸Šè§£å†³äº† select&amp;poll çš„é—®é¢˜ã€‚</p>

<p>epoll çš„ API éå¸¸ç®€æ´ï¼Œæ¶‰åŠåˆ°çš„åªæœ‰ 3 ä¸ªç³»ç»Ÿè°ƒç”¨ï¼š</p>

<p>#include &lt;sys/epoll.h&gt;<br />
int epoll_create(int size); // int epoll_create1(int flags);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
å…¶ä¸­ï¼Œepoll_create åˆ›å»ºä¸€ä¸ª epoll å®ä¾‹å¹¶è¿”å› epollfdï¼›epoll_ctl æ³¨å†Œ file descriptor ç­‰å¾…çš„ I/O äº‹ä»¶(æ¯”å¦‚ EPOLLINã€EPOLLOUT ç­‰) åˆ° epoll å®ä¾‹ä¸Šï¼›epoll_wait åˆ™æ˜¯é˜»å¡ç›‘å¬ epoll å®ä¾‹ä¸Šæ‰€æœ‰çš„ file descriptor çš„ I/O äº‹ä»¶ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªç”¨æˆ·ç©ºé—´ä¸Šçš„ä¸€å—å†…å­˜åœ°å€ (events æ•°ç»„)ï¼Œkernel ä¼šåœ¨æœ‰ I/O äº‹ä»¶å‘ç”Ÿçš„æ—¶å€™æŠŠæ–‡ä»¶æè¿°ç¬¦åˆ—è¡¨å¤åˆ¶åˆ°è¿™å—å†…å­˜åœ°å€ä¸Šï¼Œç„¶å epoll_wait è§£é™¤é˜»å¡å¹¶è¿”å›ï¼Œæœ€åç”¨æˆ·ç©ºé—´ä¸Šçš„ç¨‹åºå°±å¯ä»¥å¯¹ç›¸åº”çš„ fd è¿›è¡Œè¯»å†™äº†ï¼š</p>

<p>#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
epoll çš„å·¥ä½œåŸç†å¦‚ä¸‹ï¼š
<img src="https://xiazemin.github.io/MyBlog/img/epoll-principle.png" />
ä¸ select&amp;poll ç›¸æ¯”ï¼Œepoll åˆ†æ¸…äº†é«˜é¢‘è°ƒç”¨å’Œä½é¢‘è°ƒç”¨ã€‚ä¾‹å¦‚ï¼Œepoll_ctl ç›¸å¯¹æ¥è¯´å°±æ˜¯ä¸å¤ªé¢‘ç¹è¢«è°ƒç”¨çš„ï¼Œè€Œ epoll_wait åˆ™æ˜¯éå¸¸é¢‘ç¹è¢«è°ƒç”¨çš„ã€‚æ‰€ä»¥ epoll åˆ©ç”¨ epoll_ctl æ¥æ’å…¥æˆ–è€…åˆ é™¤ä¸€ä¸ª fdï¼Œå®ç°ç”¨æˆ·æ€åˆ°å†…æ ¸æ€çš„æ•°æ®æ‹·è´ï¼Œè¿™ç¡®ä¿äº†æ¯ä¸€ä¸ª fd åœ¨å…¶ç”Ÿå‘½å‘¨æœŸåªéœ€è¦è¢«æ‹·è´ä¸€æ¬¡ï¼Œè€Œä¸æ˜¯æ¯æ¬¡è°ƒç”¨ epoll_wait çš„æ—¶å€™éƒ½æ‹·è´ä¸€æ¬¡ã€‚ epoll_wait åˆ™è¢«è®¾è®¡æˆå‡ ä¹æ²¡æœ‰å…¥å‚çš„è°ƒç”¨ï¼Œç›¸æ¯” select&amp;poll éœ€è¦æŠŠå…¨éƒ¨ç›‘å¬çš„ fd é›†åˆä»ç”¨æˆ·æ€æ‹·è´è‡³å†…æ ¸æ€çš„åšæ³•ï¼Œepoll çš„æ•ˆç‡å°±é«˜å‡ºäº†ä¸€å¤§æˆªã€‚</unistd.h></p>

<p>åœ¨å®ç°ä¸Š epoll é‡‡ç”¨çº¢é»‘æ ‘æ¥å­˜å‚¨æ‰€æœ‰ç›‘å¬çš„ fdï¼Œè€Œçº¢é»‘æ ‘æœ¬èº«æ’å…¥å’Œåˆ é™¤æ€§èƒ½æ¯”è¾ƒç¨³å®šï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)ã€‚é€šè¿‡ epoll_ctl å‡½æ•°æ·»åŠ è¿›æ¥çš„ fd éƒ½ä¼šè¢«æ”¾åœ¨çº¢é»‘æ ‘çš„æŸä¸ªèŠ‚ç‚¹å†…ï¼Œæ‰€ä»¥ï¼Œé‡å¤æ·»åŠ æ˜¯æ²¡æœ‰ç”¨çš„ã€‚å½“æŠŠ fd æ·»åŠ è¿›æ¥çš„æ—¶å€™æ—¶å€™ä¼šå®Œæˆå…³é”®çš„ä¸€æ­¥ï¼šè¯¥ fd éƒ½ä¼šä¸ç›¸åº”çš„è®¾å¤‡ï¼ˆç½‘å¡ï¼‰é©±åŠ¨ç¨‹åºå»ºç«‹å›è°ƒå…³ç³»ï¼Œä¹Ÿå°±æ˜¯åœ¨å†…æ ¸ä¸­æ–­å¤„ç†ç¨‹åºä¸ºå®ƒæ³¨å†Œä¸€ä¸ªå›è°ƒå‡½æ•°ï¼Œåœ¨ fd ç›¸åº”çš„äº‹ä»¶è§¦å‘ï¼ˆä¸­æ–­ï¼‰ä¹‹åï¼ˆè®¾å¤‡å°±ç»ªäº†ï¼‰ï¼Œå†…æ ¸å°±ä¼šè°ƒç”¨è¿™ä¸ªå›è°ƒå‡½æ•°ï¼Œè¯¥å›è°ƒå‡½æ•°åœ¨å†…æ ¸ä¸­è¢«ç§°ä¸ºï¼šep_poll_callbackï¼Œè¿™ä¸ªå›è°ƒå‡½æ•°å…¶å®å°±æ˜¯æŠŠè¿™ä¸ª fd æ·»åŠ åˆ° rdllist è¿™ä¸ªåŒå‘é“¾è¡¨ï¼ˆå°±ç»ªé“¾è¡¨ï¼‰ä¸­ã€‚epoll_wait å®é™…ä¸Šå°±æ˜¯å»æ£€æŸ¥ rdlist åŒå‘é“¾è¡¨ä¸­æ˜¯å¦æœ‰å°±ç»ªçš„ fdï¼Œå½“ rdlist ä¸ºç©ºï¼ˆæ— å°±ç»ª fdï¼‰æ—¶æŒ‚èµ·å½“å‰è¿›ç¨‹ï¼Œç›´åˆ° rdlist éç©ºæ—¶è¿›ç¨‹æ‰è¢«å”¤é†’å¹¶è¿”å›ã€‚</p>

<p>ç›¸æ¯”äº select&amp;poll è°ƒç”¨æ—¶ä¼šå°†å…¨éƒ¨ç›‘å¬çš„ fd ä»ç”¨æˆ·æ€ç©ºé—´æ‹·è´è‡³å†…æ ¸æ€ç©ºé—´å¹¶çº¿æ€§æ‰«æä¸€éæ‰¾å‡ºå°±ç»ªçš„ fd å†è¿”å›åˆ°ç”¨æˆ·æ€ï¼Œepoll_wait åˆ™æ˜¯ç›´æ¥è¿”å›å·²å°±ç»ª fdï¼Œå› æ­¤ epoll çš„ I/O æ€§èƒ½ä¸ä¼šåƒ select&amp;poll é‚£æ ·éšç€ç›‘å¬çš„ fd æ•°é‡å¢åŠ è€Œå‡ºç°çº¿æ€§è¡°å‡ï¼Œæ˜¯ä¸€ä¸ªéå¸¸é«˜æ•ˆçš„ I/O äº‹ä»¶é©±åŠ¨æŠ€æœ¯ã€‚</p>

<p>ç”±äºä½¿ç”¨ epoll çš„ I/O å¤šè·¯å¤ç”¨éœ€è¦ç”¨æˆ·è¿›ç¨‹è‡ªå·±è´Ÿè´£ I/O è¯»å†™ï¼Œä»ç”¨æˆ·è¿›ç¨‹çš„è§’åº¦çœ‹ï¼Œè¯»å†™è¿‡ç¨‹æ˜¯é˜»å¡çš„ï¼Œæ‰€ä»¥ select&amp;poll&amp;epoll æœ¬è´¨ä¸Šéƒ½æ˜¯åŒæ­¥ I/O æ¨¡å‹ï¼Œè€Œåƒ Windows çš„ IOCP è¿™ä¸€ç±»çš„å¼‚æ­¥ I/Oï¼Œåªéœ€è¦åœ¨è°ƒç”¨ WSARecv æˆ– WSASend æ–¹æ³•è¯»å†™æ•°æ®çš„æ—¶å€™æŠŠç”¨æˆ·ç©ºé—´çš„å†…å­˜ buffer æäº¤ç»™ kernelï¼Œkernel è´Ÿè´£æ•°æ®åœ¨ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´æ‹·è´ï¼Œå®Œæˆä¹‹åå°±ä¼šé€šçŸ¥ç”¨æˆ·è¿›ç¨‹ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¸éœ€è¦ç”¨æˆ·è¿›ç¨‹å‚ä¸ï¼Œæ‰€ä»¥æ˜¯çœŸæ­£çš„å¼‚æ­¥ I/Oã€‚</p>

<p>å»¶ä¼¸
å¦å¤–ï¼Œæˆ‘çœ‹åˆ°æœ‰äº›æ–‡ç« è¯´ epoll ä¹‹æ‰€ä»¥æ€§èƒ½é«˜æ˜¯å› ä¸ºåˆ©ç”¨äº† Linux çš„ mmap å†…å­˜æ˜ å°„è®©å†…æ ¸å’Œç”¨æˆ·è¿›ç¨‹å…±äº«äº†ä¸€ç‰‡ç‰©ç†å†…å­˜ï¼Œç”¨æ¥å­˜æ”¾å°±ç»ª fd åˆ—è¡¨å’Œå®ƒä»¬çš„æ•°æ® bufferï¼Œæ‰€ä»¥ç”¨æˆ·è¿›ç¨‹åœ¨ epoll_waitè¿”å›ä¹‹åç”¨æˆ·è¿›ç¨‹å°±å¯ä»¥ç›´æ¥ä»å…±äº«å†…å­˜é‚£é‡Œè¯»å–/å†™å…¥æ•°æ®äº†ï¼Œè¿™è®©æˆ‘å¾ˆç–‘æƒ‘ï¼Œå› ä¸ºé¦–å…ˆçœ‹epoll_waitçš„å‡½æ•°å£°æ˜ï¼š</p>

<p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
ç¬¬äºŒä¸ªå‚æ•°ï¼šå°±ç»ªäº‹ä»¶åˆ—è¡¨ï¼Œæ˜¯éœ€è¦åœ¨ç”¨æˆ·ç©ºé—´åˆ†é…å†…å­˜ç„¶åå†ä¼ ç»™epoll_waitçš„ï¼Œå¦‚æœå†…æ ¸ä¼šç”¨ mmap è®¾ç½®å…±äº«å†…å­˜ï¼Œç›´æ¥ä¼ é€’ä¸€ä¸ªæŒ‡é’ˆè¿›å»å°±è¡Œäº†ï¼Œæ ¹æœ¬ä¸éœ€è¦åœ¨ç”¨æˆ·æ€åˆ†é…å†…å­˜ï¼Œå¤šæ­¤ä¸€ä¸¾ã€‚å…¶æ¬¡ï¼Œå†…æ ¸å’Œç”¨æˆ·è¿›ç¨‹é€šè¿‡ mmap å…±äº«å†…å­˜æ˜¯ä¸€ä»¶æåº¦å±é™©çš„äº‹æƒ…ï¼Œå†…æ ¸æ— æ³•ç¡®å®šè¿™å—å…±äº«å†…å­˜ä»€ä¹ˆæ—¶å€™ä¼šè¢«å›æ”¶ï¼Œè€Œä¸”è¿™æ ·ä¹Ÿä¼šèµ‹äºˆç”¨æˆ·è¿›ç¨‹ç›´æ¥æ“ä½œå†…æ ¸æ•°æ®çš„æƒé™å’Œå…¥å£ï¼Œéå¸¸å®¹æ˜“å‡ºç°å¤§çš„ç³»ç»Ÿæ¼æ´ï¼Œå› æ­¤ä¸€èˆ¬æå°‘ä¼šè¿™ä¹ˆåšã€‚æ‰€ä»¥æˆ‘å¾ˆæ€€ç–‘ epoll æ˜¯ä¸æ˜¯çœŸçš„åœ¨ Linux kernel é‡Œç”¨äº† mmapï¼Œæˆ‘å°±å»çœ‹äº†ä¸‹æœ€æ–°ç‰ˆæœ¬ï¼ˆ5.3.9ï¼‰çš„ Linux kernel æºç ï¼š</p>

<p>/*</p>
<ul>
  <li>Implement the event wait interface for the eventpoll file. It is the kernel</li>
  <li>
    <p>part of the user space epoll_wait(2).
 */
static int do_epoll_wait(int epfd, struct epoll_event __user *events,
          int maxevents, int timeout)
{
 // â€¦</p>

    <p>/* Time to fish for events â€¦ */
 error = ep_poll(ep, events, maxevents, timeout);
}</p>
  </li>
</ul>

<p>// å¦‚æœ epoll_wait å…¥å‚æ—¶è®¾å®š timeout == 0, é‚£ä¹ˆç›´æ¥é€šè¿‡ ep_events_available åˆ¤æ–­å½“å‰æ˜¯å¦æœ‰ç”¨æˆ·æ„Ÿå…´è¶£çš„äº‹ä»¶å‘ç”Ÿï¼Œå¦‚æœæœ‰åˆ™é€šè¿‡ ep_send_events è¿›è¡Œå¤„ç†
// å¦‚æœè®¾ç½® timeout &gt; 0ï¼Œå¹¶ä¸”å½“å‰æ²¡æœ‰ç”¨æˆ·å…³æ³¨çš„äº‹ä»¶å‘ç”Ÿï¼Œåˆ™è¿›è¡Œä¼‘çœ ï¼Œå¹¶æ·»åŠ åˆ° ep-&gt;wq ç­‰å¾…é˜Ÿåˆ—çš„å¤´éƒ¨ï¼›å¯¹ç­‰å¾…äº‹ä»¶æè¿°ç¬¦è®¾ç½® WQ_FLAG_EXCLUSIVE æ ‡å¿—
// ep_poll è¢«äº‹ä»¶å”¤é†’åä¼šé‡æ–°æ£€æŸ¥æ˜¯å¦æœ‰å…³æ³¨äº‹ä»¶ï¼Œå¦‚æœå¯¹åº”çš„äº‹ä»¶å·²ç»è¢«æŠ¢èµ°ï¼Œé‚£ä¹ˆ ep_poll ä¼šç»§ç»­ä¼‘çœ ç­‰å¾…
static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events, int maxevents, long timeout)
{
	// â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>send_events:
/*
 * Try to transfer events to user space. In case we get 0 events and
 * there's still timeout left over, we go trying again in search of
 * more luck.
 */
  
// å¦‚æœä¸€åˆ‡æ­£å¸¸, æœ‰ event å‘ç”Ÿ, å°±å¼€å§‹å‡†å¤‡æ•°æ® copy ç»™ç”¨æˆ·ç©ºé—´äº†
// å¦‚æœæœ‰å°±ç»ªçš„äº‹ä»¶å‘ç”Ÿï¼Œé‚£ä¹ˆå°±è°ƒç”¨ ep_send_events å°†å°±ç»ªçš„äº‹ä»¶ copy åˆ°ç”¨æˆ·æ€å†…å­˜ä¸­ï¼Œ
// ç„¶åè¿”å›åˆ°ç”¨æˆ·æ€ï¼Œå¦åˆ™åˆ¤æ–­æ˜¯å¦è¶…æ—¶ï¼Œå¦‚æœæ²¡æœ‰è¶…æ—¶å°±ç»§ç»­ç­‰å¾…å°±ç»ªäº‹ä»¶å‘ç”Ÿï¼Œå¦‚æœè¶…æ—¶å°±è¿”å›ç”¨æˆ·æ€ã€‚
// ä» ep_poll å‡½æ•°çš„å®ç°å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœæœ‰å°±ç»ªäº‹ä»¶å‘ç”Ÿï¼Œåˆ™è°ƒç”¨ ep_send_events å‡½æ•°åšè¿›ä¸€æ­¥å¤„ç†
if (!res &amp;&amp; eavail &amp;&amp;
		!(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)
	goto fetch_events;
  
// ... }
</code></pre></div></div>

<p>// ep_send_events å‡½æ•°æ˜¯ç”¨æ¥å‘ç”¨æˆ·ç©ºé—´æ‹·è´å°±ç»ª fd åˆ—è¡¨çš„ï¼Œå®ƒå°†ç”¨æˆ·ä¼ å…¥çš„å°±ç»ª fd åˆ—è¡¨å†…å­˜ç®€å•å°è£…åˆ°
// ep_send_events_data ç»“æ„ä¸­ï¼Œç„¶åè°ƒç”¨ ep_scan_ready_list å°†å°±ç»ªé˜Ÿåˆ—ä¸­çš„äº‹ä»¶å†™å…¥ç”¨æˆ·ç©ºé—´çš„å†…å­˜ï¼›
// ç”¨æˆ·è¿›ç¨‹å°±å¯ä»¥è®¿é—®åˆ°è¿™äº›æ•°æ®è¿›è¡Œå¤„ç†
static int ep_send_events(struct eventpoll *ep,
				struct epoll_event __user *events, int maxevents)
{
	struct ep_send_events_data esed;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>esed.maxevents = maxevents;
esed.events = events;
// è°ƒç”¨ ep_scan_ready_list å‡½æ•°æ£€æŸ¥ epoll å®ä¾‹ eventpoll ä¸­çš„ rdllist å°±ç»ªé“¾è¡¨ï¼Œ
// å¹¶æ³¨å†Œä¸€ä¸ªå›è°ƒå‡½æ•° ep_send_events_procï¼Œå¦‚æœæœ‰å°±ç»ª fdï¼Œåˆ™è°ƒç”¨ ep_send_events_proc è¿›è¡Œå¤„ç†
ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, 0, false);
return esed.res; }
</code></pre></div></div>

<p>// è°ƒç”¨ ep_scan_ready_list çš„æ—¶å€™ä¼šä¼ é€’æŒ‡å‘ ep_send_events_proc å‡½æ•°çš„å‡½æ•°æŒ‡é’ˆä½œä¸ºå›è°ƒå‡½æ•°ï¼Œ
// ä¸€æ—¦æœ‰å°±ç»ª fdï¼Œå°±ä¼šè°ƒç”¨ ep_send_events_proc å‡½æ•°
static __poll_t ep_send_events_proc(struct eventpoll *ep, struct list_head *head, void *priv)
{
	// â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * If the event mask intersect the caller-requested one,
 * deliver the event to userspace. Again, ep_scan_ready_list()
 * is holding ep-&gt;mtx, so no operations coming from userspace
 * can change the item.
 */
revents = ep_item_poll(epi, &amp;pt, 1);
// å¦‚æœ revents ä¸º 0ï¼Œè¯´æ˜æ²¡æœ‰å°±ç»ªçš„äº‹ä»¶ï¼Œè·³è¿‡ï¼Œå¦åˆ™å°±å°†å°±ç»ªäº‹ä»¶æ‹·è´åˆ°ç”¨æˆ·æ€å†…å­˜ä¸­
if (!revents)
	continue;
// å°†å½“å‰å°±ç»ªçš„äº‹ä»¶å’Œç”¨æˆ·è¿›ç¨‹ä¼ å…¥çš„æ•°æ®éƒ½é€šè¿‡ __put_user æ‹·è´å›ç”¨æˆ·ç©ºé—´,   // ä¹Ÿå°±æ˜¯è°ƒç”¨ epoll_wait ä¹‹æ—¶ç”¨æˆ·è¿›ç¨‹ä¼ å…¥çš„ fd åˆ—è¡¨çš„å†…å­˜
if (__put_user(revents, &amp;uevent-&gt;events) || __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) {
	list_add(&amp;epi-&gt;rdllink, head);
	ep_pm_stay_awake(epi);
	if (!esed-&gt;res)
		esed-&gt;res = -EFAULT;
	return 0;
}
  
// ... } ä»do_epoll_waitå¼€å§‹å±‚å±‚è·³è½¬ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆæ¸…æ¥šåœ°çœ‹åˆ°æœ€åå†…æ ¸æ˜¯é€šè¿‡__put_userå‡½æ•°æŠŠå°±ç»ª fd åˆ—è¡¨å’Œäº‹ä»¶è¿”å›åˆ°ç”¨æˆ·ç©ºé—´ï¼Œè€Œ__put_useræ­£æ˜¯å†…æ ¸ç”¨æ¥æ‹·è´æ•°æ®åˆ°ç”¨æˆ·ç©ºé—´çš„æ ‡å‡†å‡½æ•°ã€‚æ­¤å¤–ï¼Œæˆ‘å¹¶æ²¡æœ‰åœ¨ Linux kernel çš„æºç ä¸­å’Œ epoll ç›¸å…³çš„ä»£ç é‡Œæ‰¾åˆ° mmap ç³»ç»Ÿè°ƒç”¨åšå†…å­˜æ˜ å°„çš„é€»è¾‘ï¼Œæ‰€ä»¥åŸºæœ¬å¯ä»¥å¾—å‡ºç»“è®ºï¼šepoll åœ¨ Linux kernel é‡Œå¹¶æ²¡æœ‰ä½¿ç”¨ mmap æ¥åšç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„å†…å­˜å…±äº«ï¼Œæ‰€ä»¥é‚£äº›è¯´ epoll ä½¿ç”¨äº† mmap çš„æ–‡ç« éƒ½æ˜¯è¯¯è§£ã€‚
</code></pre></div></div>

<p>Non-blocking I/O
ä»€ä¹ˆå«éé˜»å¡ I/Oï¼Œé¡¾åæ€ä¹‰å°±æ˜¯ï¼šæ‰€æœ‰ I/O æ“ä½œéƒ½æ˜¯ç«‹åˆ»è¿”å›è€Œä¸ä¼šé˜»å¡å½“å‰ç”¨æˆ·è¿›ç¨‹ã€‚I/O å¤šè·¯å¤ç”¨é€šå¸¸æƒ…å†µä¸‹éœ€è¦å’Œéé˜»å¡ I/O æ­é…ä½¿ç”¨ï¼Œå¦åˆ™å¯èƒ½ä¼šäº§ç”Ÿæ„æƒ³ä¸åˆ°çš„é—®é¢˜ã€‚æ¯”å¦‚ï¼Œepoll çš„ ET(è¾¹ç¼˜è§¦å‘) æ¨¡å¼ä¸‹ï¼Œå¦‚æœä¸ä½¿ç”¨éé˜»å¡ I/Oï¼Œæœ‰æå¤§çš„æ¦‚ç‡ä¼šå¯¼è‡´é˜»å¡ event-loop çº¿ç¨‹ï¼Œä»è€Œé™ä½ååé‡ï¼Œç”šè‡³å¯¼è‡´ bugã€‚</p>

<p>Linux ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ fcntl ç³»ç»Ÿè°ƒç”¨æ¥è®¾ç½® O_NONBLOCKæ ‡å¿—ä½ï¼Œä»è€ŒæŠŠ socket è®¾ç½®æˆ non-blockingã€‚å½“å¯¹ä¸€ä¸ª non-blocking socket æ‰§è¡Œè¯»æ“ä½œæ—¶ï¼Œæµç¨‹æ˜¯è¿™ä¸ªæ ·å­ï¼š
å½“ç”¨æˆ·è¿›ç¨‹å‘å‡º read æ“ä½œæ—¶ï¼Œå¦‚æœ kernel ä¸­çš„æ•°æ®è¿˜æ²¡æœ‰å‡†å¤‡å¥½ï¼Œé‚£ä¹ˆå®ƒå¹¶ä¸ä¼š block ç”¨æˆ·è¿›ç¨‹ï¼Œè€Œæ˜¯ç«‹åˆ»è¿”å›ä¸€ä¸ª EAGAIN errorã€‚ä»ç”¨æˆ·è¿›ç¨‹è§’åº¦è®² ï¼Œå®ƒå‘èµ·ä¸€ä¸ª read æ“ä½œåï¼Œå¹¶ä¸éœ€è¦ç­‰å¾…ï¼Œè€Œæ˜¯é©¬ä¸Šå°±å¾—åˆ°äº†ä¸€ä¸ªç»“æœã€‚ç”¨æˆ·è¿›ç¨‹åˆ¤æ–­ç»“æœæ˜¯ä¸€ä¸ª error æ—¶ï¼Œå®ƒå°±çŸ¥é“æ•°æ®è¿˜æ²¡æœ‰å‡†å¤‡å¥½ï¼Œäºæ˜¯å®ƒå¯ä»¥å†æ¬¡å‘é€ read æ“ä½œã€‚ä¸€æ—¦ kernel ä¸­çš„æ•°æ®å‡†å¤‡å¥½äº†ï¼Œå¹¶ä¸”åˆå†æ¬¡æ”¶åˆ°äº†ç”¨æˆ·è¿›ç¨‹çš„ system callï¼Œé‚£ä¹ˆå®ƒé©¬ä¸Šå°±å°†æ•°æ®æ‹·è´åˆ°äº†ç”¨æˆ·å†…å­˜ï¼Œç„¶åè¿”å›ã€‚</p>

<p>æ‰€ä»¥ï¼Œnon-blocking I/O çš„ç‰¹ç‚¹æ˜¯ç”¨æˆ·è¿›ç¨‹éœ€è¦ä¸æ–­çš„ä¸»åŠ¨è¯¢é—® kernel æ•°æ®å¥½äº†æ²¡æœ‰ã€‚</p>

<p>Go netpoll
ä¸€ä¸ªå…¸å‹çš„ Go TCP server:</p>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œnetâ€
)</p>

<p>func main() {
	listen, err := net.Listen(â€œtcpâ€, â€œ:8888â€)
	if err != nil {
		fmt.Println(â€œlisten error: â€œ, err)
		return
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
	conn, err := listen.Accept()
	if err != nil {
		fmt.Println("accept error: ", err)
		break
	}

	// start a new goroutine to handle the new connection
	go HandleConn(conn)
} } func HandleConn(conn net.Conn) {
defer conn.Close()
packet := make([]byte, 1024)
for {
	// å¦‚æœæ²¡æœ‰å¯è¯»æ•°æ®ï¼Œä¹Ÿå°±æ˜¯è¯» buffer ä¸ºç©ºï¼Œåˆ™é˜»å¡
	_, _ = conn.Read(packet)
	// åŒç†ï¼Œä¸å¯å†™åˆ™é˜»å¡
	_, _ = conn.Write(packet)
} } ä¸Šé¢æ˜¯ä¸€ä¸ªåŸºäº Go åŸç”Ÿç½‘ç»œæ¨¡å‹ï¼ˆåŸºäº netpollï¼‰ç¼–å†™çš„ä¸€ä¸ª TCP serverï¼Œæ¨¡å¼æ˜¯ goroutine-per-connectionï¼Œåœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œå¼€å‘è€…ä½¿ç”¨çš„æ˜¯åŒæ­¥çš„æ¨¡å¼å»ç¼–å†™å¼‚æ­¥çš„é€»è¾‘è€Œä¸”å¯¹äºå¼€å‘è€…æ¥è¯´ I/O æ˜¯å¦é˜»å¡æ˜¯æ— æ„ŸçŸ¥çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å¼€å‘è€…æ— éœ€è€ƒè™‘ goroutines ç”šè‡³æ›´åº•å±‚çš„çº¿ç¨‹ã€è¿›ç¨‹çš„è°ƒåº¦å’Œä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚è€Œ Go netpoll æœ€åº•å±‚çš„äº‹ä»¶é©±åŠ¨æŠ€æœ¯è‚¯å®šæ˜¯åŸºäº epoll/kqueue/iocp è¿™ä¸€ç±»çš„ I/O äº‹ä»¶é©±åŠ¨æŠ€æœ¯ï¼Œåªä¸è¿‡æ˜¯æŠŠè¿™äº›è°ƒåº¦å’Œä¸Šä¸‹æ–‡åˆ‡æ¢çš„å·¥ä½œè½¬ç§»åˆ°äº† runtime çš„ Go schedulerï¼Œè®©å®ƒæ¥è´Ÿè´£è°ƒåº¦ goroutinesï¼Œä»è€Œæå¤§åœ°é™ä½äº†ç¨‹åºå‘˜çš„å¿ƒæ™ºè´Ÿæ‹…ï¼
</code></pre></div></div>

<p>Go netpoll æ ¸å¿ƒ</p>

<p>Go netpoll é€šè¿‡åœ¨åº•å±‚å¯¹ epoll/kqueue/iocp çš„å°è£…ï¼Œä»è€Œå®ç°äº†ä½¿ç”¨åŒæ­¥ç¼–ç¨‹æ¨¡å¼è¾¾åˆ°å¼‚æ­¥æ‰§è¡Œçš„æ•ˆæœã€‚æ€»ç»“æ¥è¯´ï¼Œæ‰€æœ‰çš„ç½‘ç»œæ“ä½œéƒ½ä»¥ç½‘ç»œæè¿°ç¬¦ netFD ä¸ºä¸­å¿ƒå®ç°ã€‚netFD ä¸åº•å±‚ PollDesc ç»“æ„ç»‘å®šï¼Œå½“åœ¨ä¸€ä¸ª netFD ä¸Šè¯»å†™é‡åˆ° EAGAIN é”™è¯¯æ—¶ï¼Œå°±å°†å½“å‰ goroutine å­˜å‚¨åˆ°è¿™ä¸ª netFD å¯¹åº”çš„ PollDesc ä¸­ï¼ŒåŒæ—¶è°ƒç”¨ gopark æŠŠå½“å‰ goroutine ç»™ park ä½ï¼Œç›´åˆ°è¿™ä¸ª netFD ä¸Šå†æ¬¡å‘ç”Ÿè¯»å†™äº‹ä»¶ï¼Œæ‰å°†æ­¤ goroutine ç»™ ready æ¿€æ´»é‡æ–°è¿è¡Œã€‚æ˜¾ç„¶ï¼Œåœ¨åº•å±‚é€šçŸ¥ goroutine å†æ¬¡å‘ç”Ÿè¯»å†™ç­‰äº‹ä»¶çš„æ–¹å¼å°±æ˜¯ epoll/kqueue/iocp ç­‰äº‹ä»¶é©±åŠ¨æœºåˆ¶ã€‚</p>

<p>æ¥ä¸‹æ¥æˆ‘ä»¬é€šè¿‡åˆ†ææœ€æ–°çš„ Go æºç ï¼ˆv1.13.4ï¼‰ï¼Œè§£è¯»ä¸€ä¸‹æ•´ä¸ª netpoll çš„è¿è¡Œæµç¨‹ã€‚</p>

<p>ä¸Šé¢çš„ç¤ºä¾‹ä»£ç ä¸­ç›¸å…³çš„åœ¨æºç é‡Œçš„å‡ ä¸ªæ•°æ®ç»“æ„å’Œæ–¹æ³•ï¼š</p>

<p>// TCPListener is a TCP network listener. Clients should typically
// use variables of type Listener instead of assuming TCP.
type TCPListener struct {
	fd *netFD
	lc ListenConfig
}</p>

<p>// Accept implements the Accept method in the Listener interface; it
// waits for the next call and returns a generic Conn.
func (l *TCPListener) Accept() (Conn, error) {
	if !l.ok() {
		return nil, syscall.EINVAL
	}
	c, err := l.accept()
	if err != nil {
		return nil, &amp;OpError{Op: â€œacceptâ€, Net: l.fd.net, Source: nil, Addr: l.fd.laddr, Err: err}
	}
	return c, nil
}</p>

<p>func (ln <em>TCPListener) accept() (</em>TCPConn, error) {
	fd, err := ln.fd.accept()
	if err != nil {
		return nil, err
	}
	tc := newTCPConn(fd)
	if ln.lc.KeepAlive &gt;= 0 {
		setKeepAlive(fd, true)
		ka := ln.lc.KeepAlive
		if ln.lc.KeepAlive == 0 {
			ka = defaultTCPKeepAlive
		}
		setKeepAlivePeriod(fd, ka)
	}
	return tc, nil
}</p>

<p>// TCPConn is an implementation of the Conn interface for TCP network
// connections.
type TCPConn struct {
	conn
}</p>

<p>// Conn
type conn struct {
	fd *netFD
}</p>

<p>type conn struct {
	fd *netFD
}</p>

<p>func (c *conn) ok() bool { return c != nil &amp;&amp; c.fd != nil }</p>

<p>// Implementation of the Conn interface.</p>

<p>// Read implements the Conn Read method.
func (c *conn) Read(b []byte) (int, error) {
	if !c.ok() {
		return 0, syscall.EINVAL
	}
	n, err := c.fd.Read(b)
	if err != nil &amp;&amp; err != io.EOF {
		err = &amp;OpError{Op: â€œreadâ€, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
	}
	return n, err
}</p>

<p>// Write implements the Conn Write method.
func (c *conn) Write(b []byte) (int, error) {
	if !c.ok() {
		return 0, syscall.EINVAL
	}
	n, err := c.fd.Write(b)
	if err != nil {
		err = &amp;OpError{Op: â€œwriteâ€, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
	}
	return n, err
}
netFD
net.Listen(â€œtcpâ€, â€œ:8888â€) æ–¹æ³•è¿”å›äº†ä¸€ä¸ª *TCPListenerï¼Œå®ƒæ˜¯ä¸€ä¸ªå®ç°äº† net.Listener æ¥å£çš„ structï¼Œè€Œé€šè¿‡ listen.Accept() æ¥æ”¶çš„æ–°è¿æ¥ *TCPConn åˆ™æ˜¯ä¸€ä¸ªå®ç°äº† net.Conn æ¥å£çš„ structï¼Œå®ƒå†…åµŒäº† net.conn structã€‚ä»”ç»†é˜…è¯»ä¸Šé¢çš„æºç å¯ä»¥å‘ç°ï¼Œä¸ç®¡æ˜¯ Listener çš„ Accept è¿˜æ˜¯ Conn çš„ Read/Write æ–¹æ³•ï¼Œéƒ½æ˜¯åŸºäºä¸€ä¸ª netFD çš„æ•°æ®ç»“æ„çš„æ“ä½œï¼ŒnetFD æ˜¯ä¸€ä¸ªç½‘ç»œæè¿°ç¬¦ï¼Œç±»ä¼¼äº Linux çš„æ–‡ä»¶æè¿°ç¬¦çš„æ¦‚å¿µï¼ŒnetFD ä¸­åŒ…å«ä¸€ä¸ª poll.FD æ•°æ®ç»“æ„ï¼Œè€Œ poll.FD ä¸­åŒ…å«ä¸¤ä¸ªé‡è¦çš„æ•°æ®ç»“æ„ Sysfd å’Œ pollDescï¼Œå‰è€…æ˜¯çœŸæ­£çš„ç³»ç»Ÿæ–‡ä»¶æè¿°ç¬¦ï¼Œåè€…å¯¹æ˜¯åº•å±‚äº‹ä»¶é©±åŠ¨çš„å°è£…ï¼Œæ‰€æœ‰çš„è¯»å†™è¶…æ—¶ç­‰æ“ä½œéƒ½æ˜¯é€šè¿‡è°ƒç”¨åè€…çš„å¯¹åº”æ–¹æ³•å®ç°çš„ã€‚</p>

<p>netFDå’Œpoll.FDçš„æºç ï¼š</p>

<p>// Network file descriptor.
type netFD struct {
	pfd poll.FD</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// immutable until Close
family      int
sotype      int
isConnected bool // handshake completed or use of association with peer
net         string
laddr       Addr
raddr       Addr }
</code></pre></div></div>

<p>// FD is a file descriptor. The net and os packages use this type as a
// field of a larger type representing a network connection or OS file.
type FD struct {
	// Lock sysfd and serialize access to Read and Write methods.
	fdmu fdMutex</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// System file descriptor. Immutable until Close.
Sysfd int

// I/O poller.
pd pollDesc

// Writev cache.
iovecs *[]syscall.Iovec

// Semaphore signaled when file is closed.
csema uint32

// Non-zero if this file has been set to blocking mode.
isBlocking uint32

// Whether this is a streaming descriptor, as opposed to a
// packet-based descriptor like a UDP socket. Immutable.
IsStream bool

// Whether a zero byte read indicates EOF. This is false for a
// message based socket connection.
ZeroReadIsEOF bool

// Whether this is a file rather than a network socket.
isFile bool } pollDesc å‰é¢æåˆ°äº† pollDesc æ˜¯åº•å±‚äº‹ä»¶é©±åŠ¨çš„å°è£…ï¼ŒnetFD é€šè¿‡å®ƒæ¥å®Œæˆå„ç§ I/O ç›¸å…³çš„æ“ä½œï¼Œå®ƒçš„å®šä¹‰å¦‚ä¸‹ï¼š
</code></pre></div></div>

<p>type pollDesc struct {
	runtimeCtx uintptr
}
è¿™é‡Œçš„ struct åªåŒ…å«äº†ä¸€ä¸ªæŒ‡é’ˆï¼Œè€Œé€šè¿‡ pollDesc çš„ init æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°å®ƒå…·ä½“çš„å®šä¹‰æ˜¯åœ¨runtime.pollDescè¿™é‡Œï¼š</p>

<p>func (pd *pollDesc) init(fd *FD) error {
	serverInit.Do(runtime_pollServerInit)
	ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))
	if errno != 0 {
		if ctx != 0 {
			runtime_pollUnblock(ctx)
			runtime_pollClose(ctx)
		}
		return syscall.Errno(errno)
	}
	pd.runtimeCtx = ctx
	return nil
}</p>

<p>// Network poller descriptor.
//
// No heap pointers.
//
//go:notinheap
type pollDesc struct {
	link *pollDesc // in pollcache, protected by pollcache.lock</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.
// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.
// pollReset, pollWait, pollWaitCanceled and runtimeÂ·netpollready (IO readiness notification)
// proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated
// in a lock-free way by all operations.
// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),
// that will blow up when GC starts moving objects.
lock    mutex // protects the following fields
fd      uintptr
closing bool
everr   bool    // marks event scanning error happened
user    uint32  // user settable cookie
rseq    uintptr // protects from stale read timers
rg      uintptr // pdReady, pdWait, G waiting for read or nil
rt      timer   // read deadline timer (set if rt.f != nil)
rd      int64   // read deadline
wseq    uintptr // protects from stale write timers
wg      uintptr // pdReady, pdWait, G waiting for write or nil
wt      timer   // write deadline timer
wd      int64   // write deadline } runtime.pollDescåŒ…å«è‡ªèº«ç±»å‹çš„ä¸€ä¸ªæŒ‡é’ˆï¼Œç”¨æ¥ä¿å­˜ä¸‹ä¸€ä¸ªruntime.pollDescçš„åœ°å€ï¼Œä»¥æ­¤æ¥å®ç°é“¾è¡¨ï¼Œå¯ä»¥å‡å°‘æ•°æ®ç»“æ„çš„å¤§å°ï¼Œæ‰€æœ‰çš„runtime.pollDescä¿å­˜åœ¨runtime.pollCacheç»“æ„ä¸­ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š
</code></pre></div></div>

<p>type pollCache struct {
   lock  mutex
   first *pollDesc
   // PollDesc objects must be type-stable,
   // because we can get ready notification from epoll/kqueue
   // after the descriptor is closed/reused.
   // Stale notifications are detected using seq variable,
   // seq is incremented when deadlines are changed or descriptor is reused.
}
net.Listen
è°ƒç”¨ net.Listenä¹‹åï¼Œåº•å±‚ä¼šé€šè¿‡ Linux çš„ç³»ç»Ÿè°ƒç”¨socket æ–¹æ³•åˆ›å»ºä¸€ä¸ª fd åˆ†é…ç»™ listenerï¼Œå¹¶ç”¨ä»¥æ¥åˆå§‹åŒ– listener çš„ netFDï¼Œæ¥ç€è°ƒç”¨ netFD çš„listenStreamæ–¹æ³•å®Œæˆå¯¹ socket çš„ bind&amp;listen æ“ä½œä»¥åŠå¯¹ netFD çš„åˆå§‹åŒ–ï¼ˆä¸»è¦æ˜¯å¯¹ netFD é‡Œçš„ pollDesc çš„åˆå§‹åŒ–ï¼‰ï¼Œç›¸å…³æºç å¦‚ä¸‹ï¼š</p>

<p>// è°ƒç”¨ linux ç³»ç»Ÿè°ƒç”¨ socket åˆ›å»º listener fd å¹¶è®¾ç½®ä¸ºä¸ºé˜»å¡ I/O	
s, err := socketFunc(family, sotype|syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC, proto)
// On Linux the SOCK_NONBLOCK and SOCK_CLOEXEC flags were
// introduced in 2.6.27 kernel and on FreeBSD both flags were
// introduced in 10 kernel. If we get an EINVAL error on Linux
// or EPROTONOSUPPORT error on FreeBSD, fall back to using
// socket without them.</p>

<p>socketFunc        func(int, int, int) (int, error)  = syscall.Socket</p>

<p>// ç”¨ä¸Šé¢åˆ›å»ºçš„ listener fd åˆå§‹åŒ– listener netFD
if fd, err = newFD(s, family, sotype, net); err != nil {
	poll.CloseFunc(s)
	return nil, err
}</p>

<p>// å¯¹ listener fd è¿›è¡Œ bind&amp;listen æ“ä½œï¼Œå¹¶ä¸”è°ƒç”¨ init æ–¹æ³•å®Œæˆåˆå§‹åŒ–
func (fd *netFD) listenStream(laddr sockaddr, backlog int, ctrlFn func(string, string, syscall.RawConn) error) error {
	// â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å®Œæˆç»‘å®šæ“ä½œ
if err = syscall.Bind(fd.pfd.Sysfd, lsa); err != nil {
	return os.NewSyscallError("bind", err)
}
  
// å®Œæˆç›‘å¬æ“ä½œ
if err = listenFunc(fd.pfd.Sysfd, backlog); err != nil {
	return os.NewSyscallError("listen", err)
}
  
// è°ƒç”¨ initï¼Œå†…éƒ¨ä¼šè°ƒç”¨ poll.FD.Initï¼Œæœ€åè°ƒç”¨ pollDesc.init
if err = fd.init(); err != nil {
	return err
}
lsa, _ = syscall.Getsockname(fd.pfd.Sysfd)
fd.setAddr(fd.addrFunc()(lsa), nil)
return nil }
</code></pre></div></div>

<p>// ä½¿ç”¨ sync.Once æ¥ç¡®ä¿ä¸€ä¸ª listener åªæŒæœ‰ä¸€ä¸ª epoll å®ä¾‹
var serverInit sync.Once</p>

<p>// netFD.init ä¼šè°ƒç”¨ poll.FD.Init å¹¶æœ€ç»ˆè°ƒç”¨åˆ° pollDesc.initï¼Œ
// å®ƒä¼šåˆ›å»º epoll å®ä¾‹å¹¶æŠŠ listener fd åŠ å…¥ç›‘å¬é˜Ÿåˆ—
func (pd *pollDesc) init(fd *FD) error {
  // runtime_pollServerInit å†…éƒ¨è°ƒç”¨äº† netpollinit æ¥åˆ›å»º epoll å®ä¾‹
	serverInit.Do(runtime_pollServerInit)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// runtime_pollOpen å†…éƒ¨è°ƒç”¨äº† netpollopen æ¥å°† listener fd æ³¨å†Œåˆ° 
// epoll å®ä¾‹ä¸­ï¼Œå¦å¤–ï¼Œå®ƒä¼šåˆå§‹åŒ–ä¸€ä¸ª pollDesc å¹¶è¿”å›
ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))
if errno != 0 {
	if ctx != 0 {
		runtime_pollUnblock(ctx)
		runtime_pollClose(ctx)
	}
	return syscall.Errno(errno)
}
// æŠŠçœŸæ­£åˆå§‹åŒ–å®Œæˆçš„ pollDesc å®ä¾‹èµ‹å€¼ç»™å½“å‰çš„ pollDesc ä»£è¡¨è‡ªèº«çš„æŒ‡é’ˆï¼Œ
// åç»­ä½¿ç”¨ç›´æ¥é€šè¿‡è¯¥æŒ‡é’ˆæ“ä½œ
pd.runtimeCtx = ctx
return nil }
</code></pre></div></div>

<p>// netpollopen ä¼šè¢« runtime_pollOpenï¼Œæ³¨å†Œ fd åˆ° epoll å®ä¾‹ï¼Œ
// åŒæ—¶ä¼šåˆ©ç”¨ä¸‡èƒ½æŒ‡é’ˆæŠŠ pollDesc ä¿å­˜åˆ° epollevent çš„ä¸€ä¸ª 8 ä½çš„å­—èŠ‚æ•°ç»„ data é‡Œ
func netpollopen(fd uintptr, pd *pollDesc) int32 {
	var ev epollevent
	ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET
	*(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd
	return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;ev)
}
æˆ‘ä»¬å‰é¢æåˆ°çš„ epoll çš„ä¸‰ä¸ªåŸºæœ¬è°ƒç”¨ï¼ŒGo åœ¨æºç é‡Œå®ç°äº†å¯¹é‚£ä¸‰ä¸ªè°ƒç”¨çš„å°è£…ï¼š</p>

<p>#include &lt;sys/epoll.h&gt;<br />
int epoll_create(int size);<br />
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);<br />
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p>

<p>// Go å¯¹ä¸Šé¢ä¸‰ä¸ªè°ƒç”¨çš„å°è£…
func netpollinit()
func netpollopen(fd uintptr, pd *pollDesc) int32
func netpoll(block bool) gList
netFD å°±æ˜¯é€šè¿‡è¿™ä¸‰ä¸ªå°è£…æ¥å¯¹ epoll è¿›è¡Œåˆ›å»ºå®ä¾‹ã€æ³¨å†Œ fd å’Œç­‰å¾…äº‹ä»¶æ“ä½œçš„ã€‚</p>

<p>Listener.Accept()
netpoll accept socket çš„å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š</p>

<p>æœåŠ¡ç«¯çš„ netFD åœ¨listenæ—¶ä¼šåˆ›å»º epoll çš„å®ä¾‹ï¼Œå¹¶å°† listenerFD åŠ å…¥ epoll çš„äº‹ä»¶é˜Ÿåˆ—
netFD åœ¨acceptæ—¶å°†è¿”å›çš„ connFD ä¹ŸåŠ å…¥ epoll çš„äº‹ä»¶é˜Ÿåˆ—
netFD åœ¨è¯»å†™æ—¶å‡ºç°syscall.EAGAINé”™è¯¯ï¼Œé€šè¿‡ pollDesc çš„ waitRead æ–¹æ³•å°†å½“å‰çš„ goroutine park ä½ï¼Œç›´åˆ° readyï¼Œä» pollDesc çš„waitReadä¸­è¿”å›
Listener.Accept()æ¥æ”¶æ¥è‡ªå®¢æˆ·ç«¯çš„æ–°è¿æ¥ï¼Œå…·ä½“è¿˜æ˜¯è°ƒç”¨netFD.acceptæ–¹æ³•æ¥å®Œæˆè¿™ä¸ªåŠŸèƒ½ï¼š</p>

<p>// Accept implements the Accept method in the Listener interface; it
// waits for the next call and returns a generic Conn.
func (l *TCPListener) Accept() (Conn, error) {
	if !l.ok() {
		return nil, syscall.EINVAL
	}
	c, err := l.accept()
	if err != nil {
		return nil, &amp;OpError{Op: â€œacceptâ€, Net: l.fd.net, Source: nil, Addr: l.fd.laddr, Err: err}
	}
	return c, nil
}</p>

<p>func (ln <em>TCPListener) accept() (</em>TCPConn, error) {
	fd, err := ln.fd.accept()
	if err != nil {
		return nil, err
	}
	tc := newTCPConn(fd)
	if ln.lc.KeepAlive &gt;= 0 {
		setKeepAlive(fd, true)
		ka := ln.lc.KeepAlive
		if ln.lc.KeepAlive == 0 {
			ka = defaultTCPKeepAlive
		}
		setKeepAlivePeriod(fd, ka)
	}
	return tc, nil
}
è€ŒnetFD.acceptæ–¹æ³•é‡Œå†è°ƒç”¨poll.FD.Acceptï¼Œæœ€åä¼šä½¿ç”¨ Linux çš„ç³»ç»Ÿè°ƒç”¨acceptæ¥å®Œæˆæ–°è¿æ¥çš„æ¥æ”¶ï¼Œå¹¶ä¸”ä¼šæŠŠ accept çš„ socket è®¾ç½®æˆéé˜»å¡ I/O æ¨¡å¼ï¼š</p>

<p>// Accept wraps the accept network call.
func (fd *FD) Accept() (int, syscall.Sockaddr, string, error) {
	if err := fd.readLock(); err != nil {
		return -1, nil, â€œâ€, err
	}
	defer fd.readUnlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if err := fd.pd.prepareRead(fd.isFile); err != nil {
	return -1, nil, "", err
}
for {
	// ä½¿ç”¨ linux ç³»ç»Ÿè°ƒç”¨ accept æ¥æ”¶æ–°è¿æ¥ï¼Œåˆ›å»ºå¯¹åº”çš„ socket
	s, rsa, errcall, err := accept(fd.Sysfd)
	// å› ä¸º listener fd åœ¨åˆ›å»ºçš„æ—¶å€™å·²ç»è®¾ç½®æˆéé˜»å¡çš„äº†ï¼Œ
	// æ‰€ä»¥ accept æ–¹æ³•ä¼šç›´æ¥è¿”å›ï¼Œä¸ç®¡æœ‰æ²¡æœ‰æ–°è¿æ¥åˆ°æ¥ï¼›å¦‚æœ err == nil åˆ™è¡¨ç¤ºæ­£å¸¸å»ºç«‹æ–°è¿æ¥ï¼Œç›´æ¥è¿”å›
	if err == nil {
		return s, rsa, "", err
	}
	// å¦‚æœ err != nilï¼Œåˆ™åˆ¤æ–­ err == syscall.EAGAINï¼Œç¬¦åˆæ¡ä»¶åˆ™è¿›å…¥ pollDesc.waitRead æ–¹æ³•
	switch err {
	case syscall.EAGAIN:
		if fd.pd.pollable() {
			// å¦‚æœå½“å‰æ²¡æœ‰å‘ç”ŸæœŸå¾…çš„ I/O äº‹ä»¶ï¼Œé‚£ä¹ˆ waitRead ä¼šé€šè¿‡ park goroutine è®©é€»è¾‘ block åœ¨è¿™é‡Œ
			if err = fd.pd.waitRead(fd.isFile); err == nil {
				continue
			}
		}
	case syscall.ECONNABORTED:
		// This means that a socket on the listen
		// queue was closed before we Accept()ed it;
		// it's a silly error, so try again.
		continue
	}
	return -1, nil, errcall, err
} }
</code></pre></div></div>

<p>// ä½¿ç”¨ linux çš„ accept ç³»ç»Ÿè°ƒç”¨æ¥æ”¶æ–°è¿æ¥å¹¶æŠŠè¿™ä¸ª socket fd è®¾ç½®æˆéé˜»å¡ I/O
ns, sa, err := Accept4Func(s, syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC)
// On Linux the accept4 system call was introduced in 2.6.28
// kernel and on FreeBSD it was introduced in 10 kernel. If we
// get an ENOSYS error on both Linux and FreeBSD, or EINVAL
// error on Linux, fall back to using accept.</p>

<p>// Accept4Func is used to hook the accept4 call.
var Accept4Func func(int, int) (int, syscall.Sockaddr, error) = syscall.Accept4
pollDesc.waitReadæ–¹æ³•ä¸»è¦è´Ÿè´£æ£€æµ‹å½“å‰è¿™ä¸ª pollDesc çš„ä¸Šå±‚ netFD å¯¹åº”çš„ fd æ˜¯å¦æœ‰ã€æœŸå¾…çš„ã€I/O äº‹ä»¶å‘ç”Ÿï¼Œå¦‚æœæœ‰å°±ç›´æ¥è¿”å›ï¼Œå¦åˆ™å°± park ä½å½“å‰çš„ goroutine å¹¶æŒç»­ç­‰å¾…ç›´è‡³å¯¹åº”çš„ fd ä¸Šå‘ç”Ÿå¯è¯»/å¯å†™æˆ–è€…å…¶ä»–ã€æœŸå¾…çš„ã€I/O äº‹ä»¶ä¸ºæ­¢ï¼Œç„¶åå®ƒå°±ä¼šè¿”å›åˆ°å¤–å±‚çš„ for å¾ªç¯ï¼Œè®© goroutine ç»§ç»­æ‰§è¡Œé€»è¾‘ã€‚</p>

<p>Conn.Read/Conn.Write
æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹Conn.Readæ–¹æ³•æ˜¯å¦‚ä½•å®ç°çš„ï¼ŒåŸç†å…¶å®å’Œ Listener.Accept æ˜¯ä¸€æ ·çš„ï¼Œå…·ä½“è°ƒç”¨é“¾è¿˜æ˜¯é¦–å…ˆè°ƒç”¨ conn çš„netFD.Read ï¼Œç„¶åå†…éƒ¨å†è°ƒç”¨ poll.FD.Readï¼Œæœ€åä½¿ç”¨ Linux çš„ç³»ç»Ÿè°ƒç”¨ read: syscall.Readå®Œæˆæ•°æ®è¯»å–ï¼š</p>

<p>// Implementation of the Conn interface.</p>

<p>// Read implements the Conn Read method.
func (c *conn) Read(b []byte) (int, error) {
	if !c.ok() {
		return 0, syscall.EINVAL
	}
	n, err := c.fd.Read(b)
	if err != nil &amp;&amp; err != io.EOF {
		err = &amp;OpError{Op: â€œreadâ€, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
	}
	return n, err
}</p>

<p>func (fd *netFD) Read(p []byte) (n int, err error) {
	n, err = fd.pfd.Read(p)
	runtime.KeepAlive(fd)
	return n, wrapSyscallError(â€œreadâ€, err)
}</p>

<p>// Read implements io.Reader.
func (fd *FD) Read(p []byte) (int, error) {
	if err := fd.readLock(); err != nil {
		return 0, err
	}
	defer fd.readUnlock()
	if len(p) == 0 {
		// If the caller wanted a zero byte read, return immediately
		// without trying (but after acquiring the readLock).
		// Otherwise syscall.Read returns 0, nil which looks like
		// io.EOF.
		// TODO(bradfitz): make it wait for readability? (Issue 15735)
		return 0, nil
	}
	if err := fd.pd.prepareRead(fd.isFile); err != nil {
		return 0, err
	}
	if fd.IsStream &amp;&amp; len(p) &gt; maxRW {
		p = p[:maxRW]
	}
	for {
		// å°è¯•ä»è¯¥ socket è¯»å–æ•°æ®ï¼Œå› ä¸º socket åœ¨è¢« listener accept çš„æ—¶å€™è®¾ç½®æˆ
		// äº†éé˜»å¡ I/Oï¼Œæ‰€ä»¥è¿™é‡ŒåŒæ ·ä¹Ÿæ˜¯ç›´æ¥è¿”å›ï¼Œä¸ç®¡æœ‰æ²¡æœ‰å¯è¯»çš„æ•°æ®
		n, err := syscall.Read(fd.Sysfd, p)
		if err != nil {
			n = 0
			// err == syscall.EAGAIN è¡¨ç¤ºå½“å‰æ²¡æœ‰æœŸå¾…çš„ I/O äº‹ä»¶å‘ç”Ÿï¼Œä¹Ÿå°±æ˜¯ socket ä¸å¯è¯»
			if err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() {
				// å¦‚æœå½“å‰æ²¡æœ‰å‘ç”ŸæœŸå¾…çš„ I/O äº‹ä»¶ï¼Œé‚£ä¹ˆ waitRead 
				// ä¼šé€šè¿‡ park goroutine è®©é€»è¾‘ block åœ¨è¿™é‡Œ
				if err = fd.pd.waitRead(fd.isFile); err == nil {
					continue
				}
			}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		// On MacOS we can see EINTR here if the user
		// pressed ^Z.  See issue #22838.
		if runtime.GOOS == "darwin" &amp;&amp; err == syscall.EINTR {
			continue
		}
	}
	err = fd.eofError(n, err)
	return n, err
} } conn.Writeå’Œconn.Readçš„åŸç†æ˜¯ä¸€è‡´çš„ï¼Œå®ƒä¹Ÿæ˜¯é€šè¿‡ç±»ä¼¼ pollDesc.waitReadçš„pollDesc.waitWriteæ¥ park ä½ goroutine ç›´è‡³æœŸå¾…çš„ I/O äº‹ä»¶å‘ç”Ÿæ‰è¿”å›ï¼Œè€Œ pollDesc.waitWriteçš„å†…éƒ¨å®ç°åŸç†å’ŒpollDesc.waitReadæ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯åŸºäºruntime_pollWaitï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚
</code></pre></div></div>

<p>pollDesc.waitRead
pollDesc.waitReadå†…éƒ¨è°ƒç”¨äº† runtime_pollWaitæ¥è¾¾æˆæ—  I/O äº‹ä»¶æ—¶ park ä½ goroutine çš„ç›®çš„ï¼š</p>

<p>//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait
func poll_runtime_pollWait(pd *pollDesc, mode int) int {
	err := netpollcheckerr(pd, int32(mode))
	if err != 0 {
		return err
	}
	// As for now only Solaris, illumos, and AIX use level-triggered IO.
	if GOOS == â€œsolarisâ€ || GOOS == â€œillumosâ€ || GOOS == â€œaixâ€ {
		netpollarm(pd, mode)
	}
	// è¿›å…¥ netpollblock å¹¶ä¸”åˆ¤æ–­æ˜¯å¦æœ‰æœŸå¾…çš„ I/O äº‹ä»¶å‘ç”Ÿï¼Œ
	// è¿™é‡Œçš„ for å¾ªç¯æ˜¯ä¸ºäº†ä¸€ç›´ç­‰åˆ° io ready
	for !netpollblock(pd, int32(mode), false) {
		err = netpollcheckerr(pd, int32(mode))
		if err != 0 {
			return err
		}
		// Can happen if timeout has fired and unblocked us,
		// but before we had a chance to run, timeout has been reset.
		// Pretend it has not happened and retry.
	}
	return 0
}</p>

<p>// returns true if IO is ready, or false if timedout or closed
// waitio - wait only for completed IO, ignore errors
func netpollblock(pd *pollDesc, mode int32, waitio bool) bool {
	// gpp ä¿å­˜çš„æ˜¯ goroutine çš„æ•°æ®ç»“æ„ gï¼Œè¿™é‡Œä¼šæ ¹æ® mode çš„å€¼å†³å®šæ˜¯ rg è¿˜æ˜¯ wg
	// åé¢è°ƒç”¨ gopark ä¹‹åï¼Œä¼šæŠŠå½“å‰çš„ goroutine çš„æŠ½è±¡æ•°æ®ç»“æ„ g å­˜å…¥ gpp è¿™ä¸ªæŒ‡é’ˆ
	gpp := &amp;pd.rg
	if mode == â€˜wâ€™ {
		gpp = &amp;pd.wg
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// set the gpp semaphore to WAIT
// è¿™ä¸ª for å¾ªç¯æ˜¯ä¸ºäº†ç­‰å¾… io ready æˆ–è€… io wait
for {
	old := *gpp
	// gpp == pdReady è¡¨ç¤ºæ­¤æ—¶å·²æœ‰æœŸå¾…çš„ I/O äº‹ä»¶å‘ç”Ÿï¼Œ
	// å¯ä»¥ç›´æ¥è¿”å› unblock å½“å‰ goroutine å¹¶æ‰§è¡Œå“åº”çš„ I/O æ“ä½œ
	if old == pdReady {
		*gpp = 0
		return true
	}
	if old != 0 {
		throw("runtime: double wait")
	}
	// å¦‚æœæ²¡æœ‰æœŸå¾…çš„ I/O äº‹ä»¶å‘ç”Ÿï¼Œåˆ™é€šè¿‡åŸå­æ“ä½œæŠŠ gpp çš„å€¼ç½®ä¸º pdWait å¹¶é€€å‡º for å¾ªç¯
	if atomic.Casuintptr(gpp, 0, pdWait) {
		break
	}
}

// need to recheck error states after setting gpp to WAIT
// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl
// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg
  
// waitio æ­¤æ—¶æ˜¯ falseï¼Œnetpollcheckerr æ–¹æ³•ä¼šæ£€æŸ¥å½“å‰ pollDesc å¯¹åº”çš„ fd æ˜¯å¦æ˜¯æ­£å¸¸çš„ï¼Œ
// é€šå¸¸æ¥è¯´  netpollcheckerr(pd, mode) == 0 æ˜¯æˆç«‹çš„ï¼Œæ‰€ä»¥è¿™é‡Œä¼šæ‰§è¡Œ gopark 
// æŠŠå½“å‰ goroutine ç»™ park ä½ï¼Œç›´è‡³å¯¹åº”çš„ fd ä¸Šå‘ç”Ÿå¯è¯»/å¯å†™æˆ–è€…å…¶ä»–ã€æœŸå¾…çš„ã€I/O äº‹ä»¶ä¸ºæ­¢ï¼Œ
// ç„¶å unpark è¿”å›ï¼Œåœ¨ gopark å†…éƒ¨ä¼šæŠŠå½“å‰ goroutine çš„æŠ½è±¡æ•°æ®ç»“æ„ g å­˜å…¥
// gpp(pollDesc.rg/pollDesc.wg) æŒ‡é’ˆé‡Œï¼Œä»¥ä¾¿åœ¨åé¢çš„ netpoll å‡½æ•°å–å‡º pollDesc ä¹‹åï¼Œ
// æŠŠ g æ·»åŠ åˆ°é“¾è¡¨é‡Œè¿”å›ï¼Œæ¥ç€é‡æ–°è°ƒåº¦ goroutine
if waitio || netpollcheckerr(pd, mode) == 0 {
	// æ³¨å†Œ netpollblockcommit å›è°ƒç»™ goparkï¼Œåœ¨ gopark å†…éƒ¨ä¼šæ‰§è¡Œå®ƒï¼Œä¿å­˜å½“å‰ goroutine åˆ° gpp
	gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5)
}
// be careful to not lose concurrent READY notification
old := atomic.Xchguintptr(gpp, 0)
if old &gt; pdWait {
	throw("runtime: corrupted polldesc")
}
return old == pdReady }
</code></pre></div></div>

<p>// gopark ä¼šåœä½å½“å‰çš„ goroutine å¹¶ä¸”è°ƒç”¨ä¼ é€’è¿›æ¥çš„å›è°ƒå‡½æ•° unlockfï¼Œä»ä¸Šé¢çš„æºç æˆ‘ä»¬å¯ä»¥çŸ¥é“è¿™ä¸ªå‡½æ•°æ˜¯
// netpollblockcommit
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {
	if reason != waitReasonSleep {
		checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy
	}
	mp := acquirem()
	gp := mp.curg
	status := readgstatus(gp)
	if status != _Grunning &amp;&amp; status != _Gscanrunning {
		throw(â€œgopark: bad g statusâ€)
	}
	mp.waitlock = lock
	mp.waitunlockf = unlockf
	gp.waitreason = reason
	mp.waittraceev = traceEv
	mp.waittraceskip = traceskip
	releasem(mp)
	// canâ€™t do anything that might move the G between Ms here.
  // gopark æœ€ç»ˆä¼šè°ƒç”¨ park_mï¼Œåœ¨è¿™ä¸ªå‡½æ•°å†…éƒ¨ä¼šè°ƒç”¨ unlockfï¼Œä¹Ÿå°±æ˜¯ netpollblockcommitï¼Œ
	// ç„¶åä¼šæŠŠå½“å‰çš„ goroutineï¼Œä¹Ÿå°±æ˜¯ g æ•°æ®ç»“æ„ä¿å­˜åˆ° pollDesc çš„ rg æˆ–è€… wg æŒ‡é’ˆé‡Œ
	mcall(park_m)
}</p>

<p>// park continuation on g0.
func park_m(gp *g) {
	<em>g</em> := getg()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if trace.enabled {
	traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)
}

casgstatus(gp, _Grunning, _Gwaiting)
dropg()

if fn := _g_.m.waitunlockf; fn != nil {
	// è°ƒç”¨ netpollblockcommitï¼ŒæŠŠå½“å‰çš„ goroutineï¼Œ
	// ä¹Ÿå°±æ˜¯ g æ•°æ®ç»“æ„ä¿å­˜åˆ° pollDesc çš„ rg æˆ–è€… wg æŒ‡é’ˆé‡Œ
	ok := fn(gp, _g_.m.waitlock)
	_g_.m.waitunlockf = nil
	_g_.m.waitlock = nil
	if !ok {
		if trace.enabled {
			traceGoUnpark(gp, 2)
		}
		casgstatus(gp, _Gwaiting, _Grunnable)
		execute(gp, true) // Schedule it back, never returns.
	}
}
schedule() }
</code></pre></div></div>

<p>// netpollblockcommit åœ¨ gopark å‡½æ•°é‡Œè¢«è°ƒç”¨
func netpollblockcommit(gp <em>g, gpp unsafe.Pointer) bool {
	// é€šè¿‡åŸå­æ“ä½œæŠŠå½“å‰ goroutine æŠ½è±¡çš„æ•°æ®ç»“æ„ gï¼Œä¹Ÿå°±æ˜¯è¿™é‡Œçš„å‚æ•° gp å­˜å…¥ gpp æŒ‡é’ˆï¼Œ
	// æ­¤æ—¶ gpp çš„å€¼æ˜¯ pollDesc çš„ rg æˆ–è€… wg æŒ‡é’ˆ
	r := atomic.Casuintptr((</em>uintptr)(gpp), pdWait, uintptr(unsafe.Pointer(gp)))
	if r {
		// Bump the count of goroutines waiting for the poller.
		// The scheduler uses this to decide whether to block
		// waiting for the poller if there is nothing else to do.
		atomic.Xadd(&amp;netpollWaiters, 1)
	}
	return r
}
netpoll
å‰é¢å·²ç»ä»æºç çš„è§’åº¦åˆ†æå®Œäº† netpoll æ˜¯å¦‚ä½•é€šè¿‡ park goroutine ä»è€Œè¾¾åˆ°é˜»å¡ Accept/Read/Write çš„æ•ˆæœï¼Œè€Œé€šè¿‡è°ƒç”¨ goparkï¼Œgoroutine ä¼šè¢«æ”¾ç½®åœ¨æŸä¸ªç­‰å¾…é˜Ÿåˆ—ä¸­(å¦‚ channel çš„ waitq ï¼Œæ­¤æ—¶ G çš„çŠ¶æ€ç”±_Grunningä¸º_Gwaitting)ï¼Œå› æ­¤ G å¿…é¡»è¢«æ‰‹åŠ¨å”¤é†’(é€šè¿‡ goready )ï¼Œå¦åˆ™ä¼šä¸¢å¤±ä»»åŠ¡ï¼Œåº”ç”¨å±‚é˜»å¡é€šå¸¸ä½¿ç”¨è¿™ç§æ–¹å¼ã€‚</p>

<p>æ‰€ä»¥ï¼Œæœ€åè¿˜æœ‰ä¸€ä¸ªéå¸¸å…³é”®çš„é—®é¢˜æ˜¯ï¼šå½“ I/O äº‹ä»¶å‘ç”Ÿä¹‹åï¼Œnetpoll æ˜¯é€šè¿‡ä»€ä¹ˆæ–¹å¼å”¤é†’é‚£äº›åœ¨ I/O wait çš„ goroutine çš„ï¼Ÿç­”æ¡ˆæ˜¯é€šè¿‡ epoll_waitï¼Œåœ¨ Go æºç ä¸­çš„ src/runtime/netpoll_epoll.goæ–‡ä»¶ä¸­æœ‰ä¸€ä¸ª func netpoll(block bool) gList æ–¹æ³•ï¼Œå®ƒä¼šå†…éƒ¨è°ƒç”¨epoll_waitè·å–å°±ç»ªçš„ fd åˆ—è¡¨ï¼Œå¹¶å°†æ¯ä¸ª fd å¯¹åº”çš„ goroutine æ·»åŠ åˆ°é“¾è¡¨è¿”å›ï¼š</p>

<p>// polls for ready network connections
// returns list of goroutines that become runnable
func netpoll(block bool) gList {
	if epfd == -1 {
		return gList{}
	}
	waitms := int32(-1)
	// æ˜¯å¦ä»¥é˜»å¡æ¨¡å¼è°ƒç”¨ epoll_wait
	if !block {
		waitms = 0
	}
	var events [128]epollevent
retry:
	// è·å–å°±ç»ªçš„ fd åˆ—è¡¨
	n := epollwait(epfd, &amp;events[0], int32(len(events)), waitms)
	if n &lt; 0 {
		if n != -_EINTR {
			println(â€œruntime: epollwait on fdâ€, epfd, â€œfailed withâ€, -n)
			throw(â€œruntime: netpoll failedâ€)
		}
		goto retry
	}
	// toRun æ˜¯ä¸€ä¸ª g çš„é“¾è¡¨ï¼Œå­˜å‚¨è¦æ¢å¤çš„ goroutinesï¼Œæœ€åè¿”å›ç»™è°ƒç”¨æ–¹
	var toRun gList
	for i := int32(0); i &lt; n; i++ {
		ev := &amp;events[i]
		if ev.events == 0 {
			continue
		}
		var mode int32
		// åˆ¤æ–­å‘ç”Ÿçš„äº‹ä»¶ç±»å‹ï¼Œè¯»ç±»å‹æˆ–è€…å†™ç±»å‹
		if ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {
			mode += â€˜râ€™
		}
		if ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {
			mode += â€˜wâ€™
		}
		if mode != 0 {
			// å–å‡ºä¿å­˜åœ¨ epollevent é‡Œçš„ pollDesc
			pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))
			pd.everr = false
			if ev.events == _EPOLLERR {
				pd.everr = true
			}
			// è°ƒç”¨ netpollreadyï¼Œä¼ å…¥å°±ç»ª fd çš„ pollDescï¼ŒæŠŠ fd å¯¹åº”çš„ goroutine æ·»åŠ åˆ°é“¾è¡¨ toRun ä¸­
			netpollready(&amp;toRun, pd, mode)
		}
	}
	if block &amp;&amp; toRun.empty() {
		goto retry
	}
	return toRun
}</p>

<p>// netpollready è°ƒç”¨ netpollunblock è¿”å›å°±ç»ª fd å¯¹åº”çš„ goroutine çš„æŠ½è±¡æ•°æ®ç»“æ„ g
func netpollready(toRun *gList, pd *pollDesc, mode int32) {
	var rg, wg *g
	if mode == â€˜râ€™ || mode == â€˜râ€™+â€™wâ€™ {
		rg = netpollunblock(pd, â€˜râ€™, true)
	}
	if mode == â€˜wâ€™ || mode == â€˜râ€™+â€™wâ€™ {
		wg = netpollunblock(pd, â€˜wâ€™, true)
	}
	if rg != nil {
		toRun.push(rg)
	}
	if wg != nil {
		toRun.push(wg)
	}
}</p>

<p>// netpollunblock ä¼šä¾æ®ä¼ å…¥çš„ mode å†³å®šä» pollDesc çš„ rg æˆ–è€… wg å–å‡ºå½“æ—¶ gopark ä¹‹æ—¶å­˜å…¥çš„
// goroutine æŠ½è±¡æ•°æ®ç»“æ„ g å¹¶è¿”å›
func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g {
	// mode == â€˜râ€™ ä»£è¡¨å½“æ—¶ gopark æ˜¯ä¸ºäº†ç­‰å¾…è¯»äº‹ä»¶ï¼Œè€Œ mode == â€˜wâ€™ åˆ™ä»£è¡¨æ˜¯ç­‰å¾…å†™äº‹ä»¶
	gpp := &amp;pd.rg
	if mode == â€˜wâ€™ {
		gpp = &amp;pd.wg
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
	// å–å‡º gpp å­˜å‚¨çš„ g
	old := *gpp
	if old == pdReady {
		return nil
	}
	if old == 0 &amp;&amp; !ioready {
		// Only set READY for ioready. runtime_pollWait
		// will check for timeout/cancel before waiting.
		return nil
	}
	var new uintptr
	if ioready {
		new = pdReady
	}
	// é‡ç½® pollDesc çš„ rg æˆ–è€… wg
	if atomic.Casuintptr(gpp, old, new) {
		if old == pdReady || old == pdWait {
			old = 0
		}
		// é€šè¿‡ä¸‡èƒ½æŒ‡é’ˆè¿˜åŸæˆ g å¹¶è¿”å›
		return (*g)(unsafe.Pointer(old))
	}
} } è€Œ Go åœ¨å¤šç§åœºæ™¯ä¸‹éƒ½å¯èƒ½ä¼šè°ƒç”¨netpollæ£€æŸ¥æ–‡ä»¶æè¿°ç¬¦çŠ¶æ€ã€‚å¯»æ‰¾åˆ° I/O å°±ç»ªçš„ socket fdï¼Œå¹¶æ‰¾åˆ°è¿™äº› socket fd å¯¹åº”çš„è½®è¯¢å™¨ä¸­é™„å¸¦çš„ä¿¡æ¯ï¼Œæ ¹æ®è¿™äº›ä¿¡æ¯å°†ä¹‹å‰ç­‰å¾…è¿™äº› socket fd å°±ç»ªçš„ goroutine çŠ¶æ€ä¿®æ”¹ä¸º _Grunnableã€‚æ‰§è¡Œå®Œnetpollä¹‹åï¼Œä¼šè¿”å›ä¸€ä¸ªå°±ç»ª fd åˆ—è¡¨å¯¹åº”çš„ goroutine åˆ—è¡¨ï¼Œæ¥ä¸‹æ¥å°†å°±ç»ªçš„ goroutine åŠ å…¥åˆ°è°ƒåº¦é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…è°ƒåº¦è¿è¡Œã€‚
</code></pre></div></div>

<p>é¦–å…ˆï¼Œåœ¨ Go runtime scheduler æ­£å¸¸è°ƒåº¦ goroutine ä¹‹æ—¶å°±æœ‰å¯èƒ½ä¼šè°ƒç”¨netpollè·å–åˆ°å·²å°±ç»ªçš„ fd å¯¹åº”çš„ goroutine æ¥è°ƒåº¦æ‰§è¡Œï¼š</p>

<p>// One round of scheduler: find a runnable goroutine and execute it.
// Never returns.
func schedule() {
	// â€¦</p>

<p>if gp == nil {
		gp, inheritTime = findrunnable() // blocks until work is available
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ... }
</code></pre></div></div>

<p>// Finds a runnable goroutine to execute.
// Tries to steal from other Pâ€™s, get g from global queue, poll network.
func findrunnable() (gp *g, inheritTime bool) {
  // â€¦</p>

<p>// Poll network.
	// This netpoll is only an optimization before we resort to stealing.
	// We can safely skip it if there are no waiters or a thread is blocked
	// in netpoll already. If there is any kind of logical race with that
	// blocked thread (e.g. it has already returned from netpoll, but does
	// not set lastpoll yet), this thread will do blocking netpoll below
	// anyway.
	if netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; 0 &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != 0 {
		if list := netpoll(false); !list.empty() { // non-blocking
			gp := list.pop()
			injectglist(&amp;list)
			casgstatus(gp, _Gwaiting, _Grunnable)
			if trace.enabled {
				traceGoUnpark(gp, 0)
			}
			return gp, false
		}
	}</p>

<p>// â€¦
}
Go scheduler çš„æ ¸å¿ƒæ–¹æ³•scheduleé‡Œä¼šè°ƒç”¨ä¸€ä¸ªå«findrunable()çš„æ–¹æ³•è·å–å¯è¿è¡Œçš„ goroutine æ¥æ‰§è¡Œï¼Œè€Œåœ¨ findrunable()æ–¹æ³•é‡Œå°±è°ƒç”¨äº†netpollè·å–å·²å°±ç»ªçš„ fd åˆ—è¡¨å¯¹åº”çš„ goroutine åˆ—è¡¨ã€‚</p>

<p>å¦å¤–ï¼Œ sysmonç›‘æ§çº¿ç¨‹ä¹Ÿå¯èƒ½ä¼šè°ƒç”¨åˆ°netpollï¼š</p>

<p>// Always runs without a P, so write barriers are not allowed.
//
//go:nowritebarrierrec
func sysmon() {
		// â€¦
		now := nanotime()
		if netpollinited() &amp;&amp; lastpoll != 0 &amp;&amp; lastpoll+10<em>1000</em>1000 &lt; now {
			atomic.Cas64(&amp;sched.lastpoll, uint64(lastpoll), uint64(now))
			// ä»¥éé˜»å¡çš„æ–¹å¼è°ƒç”¨ netpoll è·å–å°±ç»ª fd åˆ—è¡¨
			list := netpoll(false) // non-blocking - returns list of goroutines
			if !list.empty() {
				// Need to decrement number of idle locked Mâ€™s
				// (pretending that one more is running) before injectglist.
				// Otherwise it can lead to the following situation:
				// injectglist grabs all Pâ€™s but before it starts Mâ€™s to run the Pâ€™s,
				// another M returns from syscall, finishes running its G,
				// observes that there is no work to do and no other running Mâ€™s
				// and reports deadlock.
				incidlelocked(-1)
				// å°†å…¶æ’å…¥è°ƒåº¦å™¨çš„runnableåˆ—è¡¨ä¸­ï¼ˆå…¨å±€ï¼‰ï¼Œç­‰å¾…è¢«è°ƒåº¦æ‰§è¡Œ
				injectglist(&amp;list)
				incidlelocked(1)
			}
		}
		// retake Pâ€™s blocked in syscalls
		// and preempt long running Gâ€™s
		if retake(now) != 0 {
			idle = 0
		} else {
			idle++
		}
		// check if we need to force a GC
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != 0 {
			lock(&amp;forcegc.lock)
			forcegc.idle = 0
			var list gList
			list.push(forcegc.g)
			injectglist(&amp;list)
			unlock(&amp;forcegc.lock)
		}
		if debug.schedtrace &gt; 0 &amp;&amp; lasttrace+int64(debug.schedtrace)*1000000 &lt;= now {
			lasttrace = now
			schedtrace(debug.scheddetail &gt; 0)
		}
	}
}
Go runtime åœ¨ç¨‹åºå¯åŠ¨çš„æ—¶å€™ä¼šåˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„ M ä½œä¸ºç›‘æ§çº¿ç¨‹ï¼Œå«sysmonï¼Œè¿™ä¸ªçº¿ç¨‹ä¸ºç³»ç»Ÿçº§çš„ daemon çº¿ç¨‹ï¼Œæ— éœ€ P å³å¯è¿è¡Œï¼Œsysmonæ¯ 20us~10ms è¿è¡Œä¸€æ¬¡ã€‚sysmonä¸­ä»¥è½®è¯¢çš„æ–¹å¼æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼ˆå¦‚ä¸Šé¢çš„ä»£ç æ‰€ç¤ºï¼‰ï¼š</p>

<p>ä»¥éé˜»å¡çš„æ–¹å¼è°ƒç”¨runtime.netpollï¼Œä»ä¸­æ‰¾å‡ºèƒ½ä»ç½‘ç»œ I/O ä¸­å”¤é†’çš„ Gï¼Œå¹¶è°ƒç”¨injectglistï¼Œå°†å…¶æ’å…¥è°ƒåº¦å™¨çš„ runnable åˆ—è¡¨ä¸­ï¼ˆå…¨å±€ï¼‰ï¼Œè°ƒåº¦è§¦å‘æ—¶ï¼Œæœ‰å¯èƒ½ä»è¿™ä¸ªå…¨å±€ runnable åˆ—è¡¨è·å– Gã€‚ç„¶åå†å¾ªç¯è°ƒç”¨startmï¼Œç›´åˆ°æ‰€æœ‰ P éƒ½ä¸å¤„äº _Pidle çŠ¶æ€ã€‚
è°ƒç”¨retakeï¼ŒæŠ¢å é•¿æ—¶é—´å¤„äº_PsyscallçŠ¶æ€çš„ Pã€‚
ç»¼ä¸Šï¼ŒGo å€ŸåŠ©äº epoll/kqueue/iocp å’Œ runtime scheduler ç­‰çš„å¸®åŠ©ï¼Œè®¾è®¡å‡ºäº†è‡ªå·±çš„ I/O å¤šè·¯å¤ç”¨ netpollï¼ŒæˆåŠŸåœ°è®© Listener.Accept/conn.Read/conn.Writeç­‰æ–¹æ³•ä»å¼€å‘è€…çš„è§’åº¦çœ‹æ¥æ˜¯åŒæ­¥æ¨¡å¼ã€‚</p>

<p>Go netpoll çš„ä»·å€¼
é€šè¿‡å‰é¢å¯¹æºç çš„åˆ†æï¼Œæˆ‘ä»¬ç°åœ¨çŸ¥é“ Go netpoll ä¾æ‰˜äº runtime schedulerï¼Œä¸ºå¼€å‘è€…æä¾›äº†ä¸€ç§å¼ºå¤§çš„åŒæ­¥ç½‘ç»œç¼–ç¨‹æ¨¡å¼ï¼›ç„¶è€Œï¼ŒGo netpoll å­˜åœ¨çš„æ„ä¹‰å´è¿œä¸æ­¢äºæ­¤ï¼ŒGo netpoll I/O å¤šè·¯å¤ç”¨æ­é… Non-blocking I/O è€Œæ‰“é€ å‡ºæ¥çš„è¿™ä¸ªåŸç”Ÿç½‘ç»œæ¨¡å‹ï¼Œå®ƒæœ€å¤§çš„ä»·å€¼æ˜¯æŠŠç½‘ç»œ I/O çš„æ§åˆ¶æƒç‰¢ç‰¢æŒæ¡åœ¨ Go è‡ªå·±çš„ runtime é‡Œï¼Œå…³äºè¿™ä¸€ç‚¹æˆ‘ä»¬éœ€è¦ä» Go çš„ runtime scheduler è¯´èµ·ï¼ŒGo çš„ G-P-M è°ƒåº¦æ¨¡å‹å¦‚ä¸‹ï¼š</p>

<p>G åœ¨è¿è¡Œè¿‡ç¨‹ä¸­å¦‚æœè¢«é˜»å¡åœ¨æŸä¸ª system call æ“ä½œä¸Šï¼Œé‚£ä¹ˆä¸å…‰ G ä¼šé˜»å¡ï¼Œæ‰§è¡Œè¯¥ G çš„ M ä¹Ÿä¼šè§£ç»‘ P(å®è´¨æ˜¯è¢« sysmon æŠ¢èµ°äº†)ï¼Œä¸ G ä¸€èµ·è¿›å…¥ sleep çŠ¶æ€ã€‚å¦‚æœæ­¤æ—¶æœ‰ idle çš„ Mï¼Œåˆ™ P ä¸å…¶ç»‘å®šç»§ç»­æ‰§è¡Œå…¶ä»– Gï¼›å¦‚æœæ²¡æœ‰ idle Mï¼Œä½†ä»ç„¶æœ‰å…¶ä»– G è¦å»æ‰§è¡Œï¼Œé‚£ä¹ˆå°±ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ Mã€‚å½“é˜»å¡åœ¨ system call ä¸Šçš„ G å®Œæˆ syscall è°ƒç”¨åï¼ŒG ä¼šå»å°è¯•è·å–ä¸€ä¸ªå¯ç”¨çš„ Pï¼Œå¦‚æœæ²¡æœ‰å¯ç”¨çš„ Pï¼Œé‚£ä¹ˆ G ä¼šè¢«æ ‡è®°ä¸º_Grunnableå¹¶æŠŠå®ƒæ”¾å…¥å…¨å±€çš„ runqueue ä¸­ç­‰å¾…è°ƒåº¦ï¼Œä¹‹å‰çš„é‚£ä¸ª sleep çš„ M å°†å†æ¬¡è¿›å…¥ sleepã€‚</p>

<p>ç°åœ¨æ¸…æ¥šä¸ºä»€ä¹ˆ netpoll ä¸ºä»€ä¹ˆä¸€å®šè¦ä½¿ç”¨éé˜»å¡ I/O äº†å§ï¼Ÿå°±æ˜¯ä¸ºäº†é¿å…è®©æ“ä½œç½‘ç»œ I/O çš„ goroutine é™·å…¥åˆ°ç³»ç»Ÿè°ƒç”¨ä»è€Œè¿›å…¥å†…æ ¸æ€ï¼Œå› ä¸ºä¸€æ—¦è¿›å…¥å†…æ ¸æ€ï¼Œæ•´ä¸ªç¨‹åºçš„æ§åˆ¶æƒå°±ä¼šå‘ç”Ÿè½¬ç§»(åˆ°å†…æ ¸)ï¼Œä¸å†å±äºç”¨æˆ·è¿›ç¨‹äº†ï¼Œé‚£ä¹ˆä¹Ÿå°±æ— æ³•å€ŸåŠ©äº Go å¼ºå¤§çš„ runtime scheduler æ¥è°ƒåº¦ä¸šåŠ¡ç¨‹åºçš„å¹¶å‘äº†ï¼›è€Œæœ‰äº† netpoll ä¹‹åï¼Œå€ŸåŠ©äºéé˜»å¡ I/O ï¼ŒG å°±å†ä¹Ÿä¸ä¼šå› ä¸ºç³»ç»Ÿè°ƒç”¨çš„è¯»å†™è€Œé™·å…¥å†…æ ¸æ€ï¼Œå½“ G è¢«é˜»å¡åœ¨æŸä¸ª network I/O æ“ä½œä¸Šæ—¶ï¼Œå®é™…ä¸Šå®ƒä¸æ˜¯å› ä¸ºé™·å…¥å†…æ ¸æ€è¢«é˜»å¡ä½äº†ï¼Œè€Œæ˜¯è¢« Go runtime è°ƒç”¨ gopark ç»™ park ä½äº†ï¼Œæ­¤æ—¶ G ä¼šè¢«æ”¾ç½®åˆ°æŸä¸ª wait queue ä¸­ï¼Œè€Œ M ä¼šå°è¯•è¿è¡Œä¸‹ä¸€ä¸ª_Grunnableçš„ Gï¼Œå¦‚æœæ­¤æ—¶æ²¡æœ‰_Grunnableçš„ G ä¾› M è¿è¡Œï¼Œé‚£ä¹ˆ M å°†è§£ç»‘ Pï¼Œå¹¶è¿›å…¥ sleep çŠ¶æ€ã€‚å½“ I/O availableï¼Œåœ¨ wait queue ä¸­çš„ G ä¼šè¢«å”¤é†’ï¼Œæ ‡è®°ä¸º_Grunnableï¼Œæ”¾å…¥æŸä¸ªå¯ç”¨çš„ P çš„ local é˜Ÿåˆ—ä¸­ï¼Œç»‘å®šä¸€ä¸ª M æ¢å¤æ‰§è¡Œã€‚</p>

<p>Go netpoll çš„é—®é¢˜
Go netpoll çš„è®¾è®¡ä¸å¯è°“ä¸ç²¾å·§ã€æ€§èƒ½ä¹Ÿä¸å¯è°“ä¸é«˜æ•ˆï¼Œé…åˆ goroutine å†™ç½‘ç»œç¨‹åºæ˜¯çœŸçš„çˆ½ï¼šç®€æ´é«˜æ•ˆã€‚ç„¶è€Œï¼Œæ²¡æœ‰ä»»ä½•ä¸€ç§è®¾è®¡å’Œæ¶æ„æ˜¯å®Œç¾çš„ï¼Œgoroutine-per-connectionè¿™ç§æ¨¡å¼è™½ç„¶ç®€å•é«˜æ•ˆï¼Œä½†æ˜¯åœ¨æŸäº›æç«¯çš„åœºæ™¯ä¸‹ä¹Ÿä¼šæš´éœ²å‡ºé—®é¢˜ï¼šgoroutine è™½ç„¶éå¸¸è½»é‡ï¼Œå®ƒçš„è‡ªå®šä¹‰æ ˆå†…å­˜åˆå§‹å€¼ä»…ä¸º 2KBï¼Œåé¢æŒ‰éœ€æ‰©å®¹ï¼›æµ·é‡è¿æ¥çš„ä¸šåŠ¡åœºæ™¯ä¸‹ï¼Œgoroutine-per-connectionï¼Œæ­¤æ—¶ goroutine æ•°é‡ä»¥åŠæ¶ˆè€—çš„èµ„æºå°±ä¼šå‘ˆçº¿æ€§è¶‹åŠ¿æš´æ¶¨ï¼Œé¦–å…ˆç»™ Go runtime scheduler é€ æˆæå¤§çš„å‹åŠ›å’Œä¾µå ç³»ç»Ÿèµ„æºï¼Œç„¶åèµ„æºè¢«ä¾µå åˆåè¿‡æ¥å½±å“ runtime çš„è°ƒåº¦ï¼Œå¯¼è‡´æ€§èƒ½å¤§å¹…ä¸‹é™ã€‚</p>

<p>Reactor æ¨¡å¼
ç›®å‰åœ¨ Linux å¹³å°ä¸‹æ„å»ºçš„é«˜æ€§èƒ½ç½‘ç»œç¨‹åºä¸­ï¼Œå¤§éƒ½ä½¿ç”¨ Reactor æ¨¡å¼ï¼Œæ¯”å¦‚ nettyã€libeventã€libevã€ACEï¼ŒPOE(Perl)ã€Twisted(Python)ç­‰ã€‚</p>

<p>Reactor æ¨¡å¼æœ¬è´¨ä¸ŠæŒ‡çš„æ˜¯ä½¿ç”¨I/O å¤šè·¯å¤ç”¨(I/O multiplexing) + éé˜»å¡ I/O(non-blocking I/O)çš„æ¨¡å¼ã€‚</p>

<p>é€šå¸¸è®¾ç½®ä¸€ä¸ªä¸»çº¿ç¨‹è´Ÿè´£åš event-loop äº‹ä»¶å¾ªç¯å’Œ I/O è¯»å†™ï¼Œé€šè¿‡ select/poll/epoll_wait ç­‰ç³»ç»Ÿè°ƒç”¨ç›‘å¬ I/O äº‹ä»¶ï¼Œä¸šåŠ¡é€»è¾‘æäº¤ç»™å…¶ä»–å·¥ä½œçº¿ç¨‹å»åšã€‚è€Œæ‰€è°“ã€éé˜»å¡ I/Oã€çš„æ ¸å¿ƒæ€æƒ³æ˜¯æŒ‡é¿å…é˜»å¡åœ¨ read() æˆ–è€… write() æˆ–è€…å…¶ä»–çš„ I/O ç³»ç»Ÿè°ƒç”¨ä¸Šï¼Œè¿™æ ·å¯ä»¥æœ€å¤§é™åº¦çš„å¤ç”¨ event-loop çº¿ç¨‹ï¼Œè®©ä¸€ä¸ªçº¿ç¨‹èƒ½æœåŠ¡äºå¤šä¸ª socketsã€‚åœ¨ Reactor æ¨¡å¼ä¸­ï¼ŒI/O çº¿ç¨‹åªèƒ½é˜»å¡åœ¨ I/O multiplexing å‡½æ•°ä¸Šï¼ˆselect/poll/epoll_waitï¼‰ã€‚</p>

<p>Reactor æ¨¡å¼é€šå¸¸çš„å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š</p>

<p>Server ç«¯å®Œæˆåœ¨bind&amp;listenä¹‹åï¼Œå°† listenfd æ³¨å†Œåˆ° epollfd ä¸­ï¼Œæœ€åè¿›å…¥ event-loop äº‹ä»¶å¾ªç¯ã€‚å¾ªç¯è¿‡ç¨‹ä¸­ä¼šè°ƒç”¨select/poll/epoll_waité˜»å¡ç­‰å¾…ï¼Œè‹¥æœ‰åœ¨ listenfd ä¸Šçš„æ–°è¿æ¥äº‹ä»¶åˆ™è§£é™¤é˜»å¡è¿”å›ï¼Œå¹¶è°ƒç”¨socket.acceptæ¥æ”¶æ–°è¿æ¥ connfdï¼Œå¹¶å°† connfd åŠ å…¥åˆ° epollfd çš„ I/O å¤ç”¨ï¼ˆç›‘å¬ï¼‰é˜Ÿåˆ—ã€‚
å½“ connfd ä¸Šå‘ç”Ÿå¯è¯»/å¯å†™äº‹ä»¶ä¹Ÿä¼šè§£é™¤select/poll/epoll_waitçš„é˜»å¡ç­‰å¾…ï¼Œç„¶åè¿›è¡Œ I/O è¯»å†™æ“ä½œï¼Œè¿™é‡Œè¯»å†™ I/O éƒ½æ˜¯éé˜»å¡ I/Oï¼Œè¿™æ ·æ‰ä¸ä¼šé˜»å¡ event-loop çš„ä¸‹ä¸€ä¸ªå¾ªç¯ã€‚ç„¶è€Œï¼Œè¿™æ ·å®¹æ˜“å‰²è£‚ä¸šåŠ¡é€»è¾‘ï¼Œä¸æ˜“ç†è§£å’Œç»´æŠ¤ã€‚
è°ƒç”¨readè¯»å–æ•°æ®ä¹‹åè¿›è¡Œè§£ç å¹¶æ”¾å…¥é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…å·¥ä½œçº¿ç¨‹å¤„ç†ã€‚
å·¥ä½œçº¿ç¨‹å¤„ç†å®Œæ•°æ®ä¹‹åï¼Œè¿”å›åˆ° event-loop çº¿ç¨‹ï¼Œç”±è¿™ä¸ªçº¿ç¨‹è´Ÿè´£è°ƒç”¨writeæŠŠæ•°æ®å†™å› clientã€‚
accept è¿æ¥ä»¥åŠ conn ä¸Šçš„è¯»å†™æ“ä½œè‹¥æ˜¯åœ¨ä¸»çº¿ç¨‹å®Œæˆï¼Œåˆ™è¦æ±‚æ˜¯éé˜»å¡ I/Oï¼Œå› ä¸º Reactor æ¨¡å¼ä¸€æ¡æœ€é‡è¦çš„åŸåˆ™å°±æ˜¯ï¼šI/O æ“ä½œä¸èƒ½é˜»å¡ event-loop äº‹ä»¶å¾ªç¯ã€‚å®é™…ä¸Š event loop å¯èƒ½ä¹Ÿå¯ä»¥æ˜¯å¤šçº¿ç¨‹çš„ï¼Œåªæ˜¯ä¸€ä¸ªçº¿ç¨‹é‡Œåªæœ‰ä¸€ä¸ª select/poll/epoll_waitã€‚</p>

<p>ä¸Šé¢æåˆ°äº† Go netpoll åœ¨æŸäº›åœºæ™¯ä¸‹å¯èƒ½å› ä¸ºåˆ›å»ºå¤ªå¤šçš„ goroutine è€Œè¿‡å¤šåœ°æ¶ˆè€—ç³»ç»Ÿèµ„æºï¼Œè€Œåœ¨ç°å®ä¸–ç•Œçš„ç½‘ç»œä¸šåŠ¡ä¸­ï¼ŒæœåŠ¡å™¨æŒæœ‰çš„æµ·é‡è¿æ¥ä¸­åœ¨æçŸ­çš„æ—¶é—´çª—å£å†…åªæœ‰æå°‘æ•°æ˜¯ active è€Œå¤§å¤šæ•°åˆ™æ˜¯ idleï¼Œå°±åƒè¿™æ ·ï¼ˆéçœŸå®æ•°æ®ï¼Œä»…ä»…æ˜¯ä¸ºäº†æ¯”å–»ï¼‰ï¼š</p>

<p>é‚£ä¹ˆä¸ºæ¯ä¸€ä¸ªè¿æ¥æŒ‡æ´¾ä¸€ä¸ª goroutine å°±æ˜¾å¾—å¤ªè¿‡å¥¢ä¾ˆäº†ï¼Œè€Œ Reactor æ¨¡å¼è¿™ç§åˆ©ç”¨ I/O å¤šè·¯å¤ç”¨è¿›è€Œåªéœ€è¦ä½¿ç”¨å°‘é‡çº¿ç¨‹å³å¯ç®¡ç†æµ·é‡è¿æ¥çš„è®¾è®¡å°±å¯ä»¥åœ¨è¿™æ ·ç½‘ç»œä¸šåŠ¡ä¸­å¤§æ˜¾èº«æ‰‹äº†ï¼š</p>

<p>åœ¨ç»å¤§éƒ¨åˆ†åº”ç”¨åœºæ™¯ä¸‹ï¼Œæˆ‘æ¨èå¤§å®¶è¿˜æ˜¯éµå¾ª Go çš„ best practicesï¼Œä»¥è¿™ç§ netpoll æ¨¡å¼æ¥æ„å»ºè‡ªå·±çš„ç½‘ç»œåº”ç”¨ã€‚ç„¶è€Œï¼Œåœ¨æŸäº›æåº¦è¿½æ±‚æ€§èƒ½ã€å‹æ¦¨ç³»ç»Ÿèµ„æºä»¥åŠæŠ€æœ¯æ ˆå¿…é¡»æ˜¯åŸç”Ÿ Go ï¼ˆä¸è€ƒè™‘ C/C++ å†™ä¸­é—´å±‚è€Œ Go å†™ä¸šåŠ¡å±‚ï¼‰çš„ä¸šåŠ¡åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘è‡ªå·±æ„å»º Reactor ç½‘ç»œæ¨¡å‹ã€‚</p>

<p>gnet
gnet æ˜¯ä¸€ä¸ªåŸºäºäº‹ä»¶é©±åŠ¨çš„é«˜æ€§èƒ½å’Œè½»é‡çº§ç½‘ç»œæ¡†æ¶ï¼Œæ”¯æŒå¤šç§åè®®ï¼šTCP/UDP/Unix-Socketã€‚å®ƒç›´æ¥ä½¿ç”¨ epoll å’Œ kqueue ç³»ç»Ÿè°ƒç”¨è€Œéæ ‡å‡† Golang ç½‘ç»œåŒ…ï¼šnet æ¥æ„å»ºç½‘ç»œåº”ç”¨ï¼Œå®ƒçš„å·¥ä½œåŸç†ç±»ä¼¼ä¸¤ä¸ªå¼€æºçš„ç½‘ç»œåº“ï¼šnetty å’Œ libuvã€‚</p>

<p>gnet çš„äº®ç‚¹åœ¨äºå®ƒæ˜¯ä¸€ä¸ªé«˜æ€§èƒ½ã€è½»é‡çº§ã€éé˜»å¡çš„çº¯ Go å®ç°çš„ä¼ è¾“å±‚ï¼ˆTCP/UDP/Unix-Socketï¼‰ç½‘ç»œæ¡†æ¶ï¼Œå¼€å‘è€…å¯ä»¥ä½¿ç”¨ gnet æ¥å®ç°è‡ªå·±çš„åº”ç”¨å±‚ç½‘ç»œåè®®ï¼Œä»è€Œæ„å»ºå‡ºè‡ªå·±çš„åº”ç”¨å±‚ç½‘ç»œåº”ç”¨ï¼šæ¯”å¦‚åœ¨ gnet ä¸Šå®ç° HTTP åè®®å°±å¯ä»¥åˆ›å»ºå‡ºä¸€ä¸ª HTTP æœåŠ¡å™¨ æˆ–è€… Web å¼€å‘æ¡†æ¶ï¼Œå®ç° Redis åè®®å°±å¯ä»¥åˆ›å»ºå‡ºè‡ªå·±çš„ Redis æœåŠ¡å™¨ç­‰ç­‰ã€‚</p>

<p>gnetï¼Œåœ¨æŸäº›æç«¯çš„ç½‘ç»œä¸šåŠ¡åœºæ™¯ï¼Œæ¯”å¦‚æµ·é‡è¿æ¥ã€é«˜é¢‘åˆ›å»ºé”€æ¯è¿æ¥ç­‰ç­‰åœºæ™¯ï¼Œgnet åœ¨æ€§èƒ½å’Œèµ„æºå ç”¨ä¸Šéƒ½è¿œè¶… Go åŸç”Ÿçš„ net åŒ…ï¼ˆåŸºäº netpollï¼‰ã€‚</p>

<p>gnetå·²ç»å®ç°äº†Multi-Reactorså’ŒMulti-Reactors + Goroutine Poolä¸¤ç§ç½‘ç»œæ¨¡å‹ï¼Œä¹Ÿå¾—ç›Šäºè¿™äº›ç½‘ç»œæ¨¡å‹ï¼Œä½¿å¾—gnetæˆä¸ºä¸€ä¸ªé«˜æ€§èƒ½å’Œä½æŸè€—çš„ Go ç½‘ç»œæ¡†æ¶ï¼š</p>

<p>ğŸš€ åŠŸèƒ½
 é«˜æ€§èƒ½ çš„åŸºäºå¤šçº¿ç¨‹/Go ç¨‹ç½‘ç»œæ¨¡å‹çš„ event-loop äº‹ä»¶é©±åŠ¨
 å†…ç½® Round-Robin è½®è¯¢è´Ÿè½½å‡è¡¡ç®—æ³•
 å†…ç½® goroutine æ± ï¼Œç”±å¼€æºåº“ ants æä¾›æ”¯æŒ
 å†…ç½® bytes å†…å­˜æ± ï¼Œç”±å¼€æºåº“ pool æä¾›æ”¯æŒ
 ç®€æ´çš„ APIs
 åŸºäº Ring-Buffer çš„é«˜æ•ˆå†…å­˜åˆ©ç”¨
 æ”¯æŒå¤šç§ç½‘ç»œåè®®ï¼šTCPã€UDPã€Unix Sockets
 æ”¯æŒä¸¤ç§äº‹ä»¶é©±åŠ¨æœºåˆ¶ï¼šLinux é‡Œçš„ epoll ä»¥åŠ FreeBSD é‡Œçš„ kqueue
 æ”¯æŒå¼‚æ­¥å†™æ“ä½œ
 çµæ´»çš„äº‹ä»¶å®šæ—¶å™¨
 SO_REUSEPORT ç«¯å£é‡ç”¨
 å†…ç½®å¤šç§ç¼–è§£ç å™¨ï¼Œæ”¯æŒå¯¹ TCP æ•°æ®æµåˆ†åŒ…ï¼šLineBasedFrameCodec, DelimiterBasedFrameCodec, FixedLengthFrameCodec å’Œ LengthFieldBasedFrameCodecï¼Œå‚è€ƒè‡ª netty codecï¼Œè€Œä¸”æ”¯æŒè‡ªå®šåˆ¶ç¼–è§£ç å™¨
 æ”¯æŒ Windows å¹³å°ï¼ŒåŸºäº IOCP äº‹ä»¶é©±åŠ¨æœºåˆ¶ Go æ ‡å‡†ç½‘ç»œåº“
 åŠ å…¥æ›´å¤šçš„è´Ÿè½½å‡è¡¡ç®—æ³•ï¼šéšæœºã€æœ€å°‘è¿æ¥ã€ä¸€è‡´æ€§å“ˆå¸Œç­‰ç­‰
 æ”¯æŒ TLS
 å®ç° gnet å®¢æˆ·ç«¯
å‚è€ƒ
Linux I/Oæ¨¡å¼åŠ selectã€pollã€epollè¯¦è§£
IOå¤šè·¯å¤ç”¨ä¸Goç½‘ç»œåº“çš„å®ç°
èŠèŠ Linux IO
Go è°ƒåº¦æ¨¡å‹
linux ç”¨æˆ·ç©ºé—´ä¸å†…æ ¸ç©ºé—´â€”â€”é«˜ç«¯å†…å­˜è¯¦è§£
Goroutine å¹¶å‘è°ƒåº¦æ¨¡å‹æ·±åº¦è§£æä¹‹æ‰‹æ’¸ä¸€ä¸ªé«˜æ€§èƒ½åç¨‹æ± 
Goè¯­è¨€å®ç°(2)ï¼šè°ƒåº¦
å…³äºselectå‡½æ•°ä¸­timevalå’Œfd_seté‡æ–°è®¾ç½®çš„é—®é¢˜
ä¹Ÿè°ˆgoroutineè°ƒåº¦å™¨</p>

<p>https://github.com/panjf2000/gnet</p>
:ET