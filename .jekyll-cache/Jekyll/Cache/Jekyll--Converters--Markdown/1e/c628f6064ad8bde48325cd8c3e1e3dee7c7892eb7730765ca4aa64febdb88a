I"Ù<p>go-eventæ˜¯ä¸€ä¸ªåœ¨Dockeré¡¹ç›®ä¸­ä½¿ç”¨åˆ°çš„ä¸€ä¸ªäº‹ä»¶åˆ†å‘ç»„ä»¶ï¼Œå®ç°äº†å¸¸è§„çš„å¹¿æ’­ï¼Œé˜Ÿåˆ—ç­‰äº‹ä»¶åˆ†å‘æ¨¡å‹ï¼Œä»£ç ç®€æ´æ˜äº†ï¼Œä¹Ÿé€‚åˆåˆå­¦è€…å¯¹Goè¯­è¨€çš„å…¥é—¨ï¼Œå¯¹channelç”¨æ¥åŒæ­¥ï¼Œé€šä¿¡ä¹Ÿä¼šåŠ æ·±ç†è§£ã€‚</p>

<p>æ ¸å¿ƒæ•°æ®ç»“æ„
Event</p>

<p>type Event interface{}
Eventè¢«å°è£…ä¸ºä¸€ä¸ªç©ºæ¥å£ï¼Œæ¥å—ä»»æ„ç±»å‹ã€‚åœ¨go-eventsè¡¨ç¤ºä¸€ä¸ªå¯ä»¥è¢«åˆ†å‘çš„äº‹ä»¶ã€‚</p>

<p>interface{}çš„åº•å±‚ç±»ä¼¼äºcè¯­è¨€ä¸­çš„void<em>,ä½†æ¯”void</em>å¼ºå¤§å¾ˆå¤šï¼Œæ¯”å¦‚interface{}ä¿å­˜äº†æŒ‡å‘å¯¹è±¡çš„æŒ‡é’ˆå’Œç±»å‹ï¼Œè€Œcç¨‹åºå‘˜ä½¿ç”¨void*æ—¶ï¼Œå¿…é¡»è‡ªå·±å»ä¿è¯å¯¹è±¡çš„ç±»å‹æ˜¯æ­£ç¡®çš„ï¼‰</p>

<p>Sink</p>

<p>type Sink interface {
    Write(event Event) error
    Close() error
}
Sinkæ˜¯ä¸€ä¸ªç”¨æ¥åˆ†å‘äº‹ä»¶ï¼ˆEventï¼‰çš„ç»“æ„ã€‚å¯ä»¥å½“ä½œäº‹ä»¶çš„å¤„ç†è€…ï¼Œä½¿ç”¨æ¥å£çš„æ–¹å¼å£°æ˜ã€‚åªè¦å¯¹è±¡å®ç°äº†è¿™ä¸¤ä¸ªæ–¹æ³•ï¼Œå°±å¯ä»¥è¢«å½“ä½œä¸€ä¸ªSinkã€‚
æ ¸å‹æ–¹æ³•</p>

<p>Write(event Event) error</p>

<p>å®šä¹‰äº†äº‹ä»¶å¦‚ä½•è¢«åˆ†å‘çš„ç­–ç•¥ã€‚
Close() error</p>

<p>å½“Sinkè¢«å…³é—­çš„å¤„ç†ç­–ç•¥ã€‚
https://studygolang.com/articles/30112
<!-- more --></p>

<p>go-eventæ ¸å¿ƒå°±æ˜¯å›´ç»•Sinkåšæ–‡ç« ï¼Œdockerå®˜æ–¹ç»™å‡ºäº†ä¸€ä¸ªhttpçš„ä¾‹å­ï¼Œå°±æ˜¯å½“è°ƒç”¨Writeæ—¶ï¼Œå‘èµ·ä¸€æ¬¡postè¯·æ±‚ã€‚ï¼š</p>

<p>func (h *httpSink) Write(event Event) error {
    p, err := json.Marshal(event)
    if err != nil {
        return err
    }
    body := bytes.NewReader(p)
    resp, err := h.client.Post(h.url, â€œapplication/jsonâ€, body)
    if err != nil {
        return err
    }
    defer resp.Body.Close()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if resp.Status != 200 {
    return errors.New("unexpected status")
}

return nil }
</code></pre></div></div>

<p>// implement (*httpSink).Close()
å®ç°æ¨¡å‹
åˆ°æ­¤ä¸ºæ­¢ï¼Œsinkå®šä¹‰äº†äº‹ä»¶åˆ†å‘çš„åŸºæœ¬å•ä½ã€‚åœ¨go-eventä¸­ï¼Œå°è£…äº†å¹¿æ’­ï¼Œæ¶ˆæ¯é˜Ÿåˆ—ä¸¤ç§æ¶ˆæ¯åˆ†å‘çš„æ¨¡å‹ï¼Œå…·ä½“æ¥è¯´ï¼Œå°±æ˜¯å®ç°äº†Sinkæ¥å£çš„ä¸¤ä¸ªç»“æ„ä½“ã€‚</p>

<p>Boadcaster
type Broadcaster struct {
    sinks   []Sink //æ‰€åŒ…å«çš„Sink
    events  chan Event// åŒæ­¥Eventçš„channel
    adds    chan configureRequest //addså’Œremoveå¿…é¡»ä¿è¯thread-safeï¼Œæ‰€ä»¥é‡‡ç”¨channelåŒæ­¥
    removes chan configureRequest</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>shutdown chan struct{}
closed   chan struct{}
once     sync.Once } Boardcasterç”±å¤šä¸ªSinkç»„æˆï¼Œå½“Boardcasteræ¥æ”¶åˆ°ä¸€ä¸ªäº‹ä»¶æ—¶ï¼Œä¼šè°ƒç”¨è‡ªèº«åŒ…å«çš„æ‰€æœ‰Sinkçš„Write()æ–¹æ³• go-eventsè®¾è®¡ä¹‹åˆå°±å®ç°åç¨‹ä¹‹é—´çš„æ¶ˆæ¯åˆ†å‘ï¼Œéœ€è¦ä¿è¯thread-safeï¼Œæ‰€ä»¥å¯¹eventçš„å¤„ç†ï¼Œæ·»åŠ ï¼Œç§»é™¤Sinkéƒ½ä½¿ç”¨ç®¡é“æ¥é€šä¿¡ã€‚è¿™ä¹Ÿæ˜¯Goçš„ä¸€ä¸ªä½¿ç”¨åŸåˆ™ï¼š
</code></pre></div></div>

<p>ä½¿ç”¨é€šä¿¡æ¥å…±äº«å†…å­˜,è€Œä¸æ˜¯é€šè¿‡å…±äº«å†…å­˜æ¥é€šä¿¡</p>

<p>åœ¨Broadcasterä¸­æ‰€æœ‰çš„ä¸´ç•Œèµ„æº(sinks,event)éƒ½é€šè¿‡è‡ªèº«çš„run()å‡½æ•°ç»Ÿä¸€ç®¡ç†ï¼Œå¤–ç•Œåˆ™é€šè¿‡ç›¸åº”çš„channel åŒæ­¥ç»™Broadcaster
ä¾‹å¦‚Write()</p>

<p>func (b *Broadcaster) Write(event Event) error {
    select {
    case b.events &lt;- event:
    case &lt;-b.closed:
        return ErrSinkClosed
    }
    return nil
}
å¯ä»¥çœ‹åˆ°å¢å‡sinkéƒ½æ˜¯é€šè¿‡å‘å¯¹åº”çš„channelå†™å…¥æ•°æ®è¿›è¡Œçš„ã€‚</p>

<p>func (b *Broadcaster) Add(sink Sink) error {
    return b.configure(b.adds, sink) //  will be block until ch can be writen
}</p>

<p>func (b *Broadcaster) configure(ch chan configureRequest, sink Sink) error {
    response := make(chan error, 1)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
    select {
    case ch &lt;- configureRequest{
        sink:     sink,
        response: response}:
        ch = nil // ï¼Ÿ
    case err := &lt;-response: 
        return err
    case &lt;-b.closed:
        return ErrSinkClosed
    }
} } æ ¸å¿ƒrunå‡½æ•°çš„å®ç°,ç›‘å¬Boardcastç®¡é“ä¸Šçš„ç›¸åº”äº‹ä»¶ï¼Œå¹¶ä½œå‡ºå¤„ç†ã€‚
</code></pre></div></div>

<p>func (b *Broadcaster) run() {
    defer close(b.closed)
    //å°†removeå°è£…äº†ä¸€ä¸‹ï¼Œå› ä¸ºä¸‹é¢ä¸¤å¤„éƒ½ä¼šç”¨åˆ°
    remove := func(target Sink) {
        for i, sink := range b.sinks {
            if sink == target {
                b.sinks = append(b.sinks[:i], b.sinks[i+1:]â€¦)
                break
            }
        }
    }
    // è½®è®­å¤„ç†channelä¸Šçš„äº‹ä»¶
    for {
        select {
        case event := &lt;-b.events: //æœ‰äº‹ä»¶åˆ°æ¥ï¼Œè¿›è¡Œå¹¿æ’­
            for _, sink := range b.sinks {
                if err := sink.Write(event); err != nil {
                    if err == ErrSinkClosed {
                        // remove closed sinks
                        remove(sink)
                        continue
                    }
                    logrus.WithField(â€œeventâ€, event).WithField(â€œevents.sinkâ€, sink).WithError(err).
                        Errorf(â€œbroadcaster: dropping eventâ€)
                }
            }
        case request := &lt;-b.adds: //å¢åŠ sinkäº‹ä»¶
            // while we have to iterate for add/remove, common iteration for
            // send is faster against slice.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        var found bool
        for _, sink := range b.sinks {
            if request.sink == sink {
                found = true
                break
            }
        }

        if !found {
            b.sinks = append(b.sinks, request.sink)
        }
        // b.sinks[request.sink] = struct{}{}
        request.response &lt;- nil // å”¤é†’é˜»å¡çš„configureï¼ˆï¼‰å‡½æ•°
        
    case request := &lt;-b.removes://åˆ é™¤sinkäº‹ä»¶
        remove(request.sink)
        request.response &lt;- nil
    case &lt;-b.shutdown:
        // close all the underlying sinks
        for _, sink := range b.sinks {
            if err := sink.Close(); err != nil &amp;&amp; err != ErrSinkClosed {
                logrus.WithField("events.sink", sink).WithError(err).
                    Errorf("broadcaster: closing sink failed")
            }
        }
        return
    }
} } queue queueä½¿ç”¨contaienr/listå®ç°äº†å…¸å‹çš„ç”Ÿäº§æ¶ˆè´¹è€…æ¨¡å‹
</code></pre></div></div>

<p>type Queue struct {
    dst    Sink
    events *list.List
    cond   *sync.Cond 
    mu     sync.Mutex
    closed bool
}
æ ¸å¿ƒå‡½æ•°run(),åœ¨é˜Ÿåˆ—ä¸­å–å‡ºä¸‹ä¸€ä¸ªeventï¼Œäº¤ç»™è‡ªèº«çš„sinkå¤„ç†ï¼Œåœ¨æ²¡æœ‰äº‹ä»¶é˜Ÿåˆ—çš„æƒ…å†µä¸‹ï¼Œeq.next()æ€»æ˜¯é˜»å¡çš„(ä½¿ç”¨æ¡ä»¶å˜é‡è¿›è¡ŒåŒæ­¥)</p>

<p>func (eq *Queue) run() {
    for {
        event := eq.next()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if event == nil {
        return // nil block means event queue is closed.
    }

    if err := eq.dst.Write(event); err != nil {
        logrus.WithFields(logrus.Fields{
            "event": event,
            "sink":  eq.dst,
        }).WithError(err).Debug("eventqueue: dropped event")
    }
} } ç”Ÿäº§è€…:q.next() æ¶ˆè´¹è€…:write()
</code></pre></div></div>

<p>func (eq *Queue) Write(event Event) error {
    eq.mu.Lock()
    defer eq.mu.Unlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if eq.closed {
    return ErrSinkClosed
}

eq.events.PushBack(event)
eq.cond.Signal() // signal waiters

return nil }
</code></pre></div></div>

<p>func (eq *Queue) next() Event {
    eq.mu.Lock()
    defer eq.mu.Unlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for eq.events.Len() &lt; 1 {
    if eq.closed {
        eq.cond.Broadcast()
        return nil
    }

    eq.cond.Wait()
}

front := eq.events.Front()
block := front.Value.(Event)
eq.events.Remove(front)

return block }
</code></pre></div></div>

:ET