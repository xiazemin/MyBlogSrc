I"Ü<p>selectä¸ºgolangæä¾›äº†å¤šè·¯IOå¤ç”¨æœºåˆ¶ï¼Œå’Œå…¶ä»–IOå¤ç”¨ä¸€æ ·ï¼Œç”¨äºæ£€æµ‹æ˜¯å¦æœ‰è¯»å†™äº‹ä»¶æ˜¯å¦readyã€‚
golang çš„ select çš„åŠŸèƒ½å’Œ select, poll, epoll ç›¸ä¼¼ï¼Œ å°±æ˜¯ç›‘å¬ IO æ“ä½œï¼Œå½“ IO æ“ä½œå‘ç”Ÿæ—¶ï¼Œè§¦å‘ç›¸åº”çš„åŠ¨ä½œã€‚</p>

<p>select å’Œ switch æ˜¯ Goè¯­è¨€ä¸­è¿›è¡Œåˆ†æ”¯æ“ä½œçš„ä¸¤ä¸ªæ–¹å¼ï¼Œå„æœ‰å„çš„åº”ç”¨åœºæ™¯ã€‚</p>

<p>select
selectåªèƒ½åº”ç”¨äºchannelçš„æ“ä½œï¼Œæ—¢å¯ä»¥ç”¨äºchannelçš„æ•°æ®æ¥æ”¶ï¼Œä¹Ÿå¯ä»¥ç”¨äºchannelçš„æ•°æ®å‘é€ã€‚</p>

<p>å¦‚æœselectçš„å¤šä¸ªåˆ†æ”¯éƒ½æ»¡è¶³æ¡ä»¶ï¼Œåˆ™ä¼šéšæœºçš„é€‰å–å…¶ä¸­ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„åˆ†æ”¯ï¼Œ å¦‚è¯­è¨€è§„èŒƒä¸­æ‰€è¯´ï¼š</p>

<p>If multiple cases can proceed, a uniform pseudo-random choice is made to decide which single communication will execute.</p>

<p>ï½€caseï½€è¯­å¥çš„è¡¨è¾¾å¼å¯ä»¥ä¸ºä¸€ä¸ªå˜é‡æˆ–è€…ä¸¤ä¸ªå˜é‡èµ‹å€¼ã€‚</p>

<p>æœ‰defaultè¯­å¥ã€‚
<!-- more -->
å®ç°åŸç†
golangå®ç°selectçš„æ—¶å€™ï¼Œå®é™…ä¸Šä¸ºæ¯ä¸€ä¸ªcaseè¯­å¥å®šä¹‰äº†ä¸€ä¸ªæ•°æ®ç»“æ„ï¼Œselectè¯­å¥å—æ‰§è¡Œçš„æ—¶å€™ï¼Œå®é™…ä¸Šå¯ä»¥ç±»æ¯”æˆå¯¹ä¸€ä¸ªcaseæ•°ç»„å¤„ç†çš„ä»£ç å—ï¼ˆæˆ–è€…å‡½æ•°ï¼‰ï¼Œç„¶åç¨‹åºæµç¨‹è½¬åˆ°é€‰ä¸­çš„caseå—ã€‚</p>

<p>caseæ•°æ®ç»“æ„
æºç åŒ…src/runtime/select.go:scaseå®šä¹‰äº†è¡¨ç¤ºcaseè¯­å¥çš„æ•°æ®ç»“æ„ï¼š
type scase struct {
    c           *hchan         // chan
    kind        uint16
    elem        unsafe.Pointer // data element
}
ã€€ã€€scase.cè¡¨ç¤ºå½“å‰caseè¯­å¥æ“ä½œçš„chanæŒ‡é’ˆï¼Œè¿™ä¹Ÿè¡¨æ˜ä¸€ä¸ªcaseåªèƒ½ç›‘å¬ä¸€ä¸ªchanã€‚</p>

<p>ã€€ã€€scase.kindè¡¨ç¤ºå½“å‰çš„chanæ˜¯å¯è¯»è¿˜æ˜¯å¯å†™channelæˆ–è€…æ˜¯defaultã€‚ä¸‰ç§ç±»å‹åˆ†åˆ«ç”±å¸¸é‡å®šä¹‰ï¼š</p>

<p>caseRecvï¼šcaseè¯­å¥ä¸­å°è¯•è¯»å–scase.cä¸­çš„æ•°æ®ï¼›
caseSendï¼šcaseè¯­å¥ä¸­å°è¯•å‘scase.cä¸­å†™å…¥æ•°æ®ï¼›
caseDefaultï¼š defaultè¯­å¥
ã€€ã€€scase.elemè¡¨ç¤ºç¼“å†²åŒºåœ°å€ï¼Œè·Ÿæ®scase.kindä¸åŒï¼Œæœ‰ä¸åŒçš„ç”¨é€”ï¼š</p>

<p>scase.kind == caseRecv ï¼š scase.elemè¡¨ç¤ºè¯»å‡ºchannelçš„æ•°æ®å­˜æ”¾åœ°å€ï¼›
scase.kind == caseSend ï¼š scase.elemè¡¨ç¤ºå°†è¦å†™å…¥channelçš„æ•°æ®å­˜æ”¾åœ°å€ï¼›
selectå®ç°é€»è¾‘
æºç åŒ…src/runtime/select.go:selectgo()å®šä¹‰äº†selecté€‰æ‹©caseçš„å‡½æ•°ï¼š
// selectgo implements the select statement.
//
// *sel is on the current goroutineâ€™s stack (regardless of any
// escaping in selectgo).
//
// selectgo returns the index of the chosen scase, which matches the
// ordinal position of its respective select{recv,send,default} call.
func selectgo(sel *hselect) int {<br />
}
ã€€ã€€å…¶ä¸­æ•°æ®ç»“æ„hselectå¦‚ä¸‹ï¼š
// Select statement header.
// Known to compiler.
// Changes here must also be made in src/cmd/internal/gc/select.goâ€™s selecttype.
type hselect struct {
    tcase     uint16   // total count of scase[]
    ncase     uint16   // currently filled scase[]
    pollorder *uint16  // case poll order
    lockorder *uint16  // channel lock order
    scase     [1]scase // one per case (in order of appearance)
}
hselect.tcaseå­˜çš„æ˜¯scaseæ€»æ•°ã€‚</p>

<p>hselect.pollorderæ˜¯ä¿å­˜scaseçš„éšæœºåçš„åºåˆ—ã€‚ä»¥è¾¾åˆ°éšæœºæ£€æµ‹caseçš„ç›®çš„ã€‚</p>

<p>hselect.lockorderæ˜¯ä¿å­˜çš„channelåœ°å€ã€‚æ‰€æœ‰caseè¯­å¥ä¸­channelåºåˆ—ï¼Œä»¥è¾¾åˆ°å»é‡é˜²æ­¢å¯¹channelåŠ é”æ—¶é‡å¤åŠ é”çš„ç›®çš„ã€‚</p>

<p>selectgoè¿”å›intï¼Œè¡¨ç¤ºé€‰ä¸­çš„scaseï¼Œä¹Ÿå°±æ˜¯readyçš„channel indexã€‚</p>

<p>è¯¥å‡½æ•°æ‰§è¡Œé€»è¾‘å¤§è‡´å¦‚ä¸‹ï¼š</p>

<ol>
  <li>
    <p>é”å®šscaseè¯­å¥ä¸­æ‰€æœ‰çš„channel</p>
  </li>
  <li>
    <p>æŒ‰ç…§éšæœºé¡ºåºæ£€æµ‹scaseä¸­çš„channelæ˜¯å¦ready</p>
  </li>
</ol>

<p>ã€€ã€€2.1 å¦‚æœcaseå¯è¯»ï¼Œåˆ™è¯»å–channelä¸­æ•°æ®ï¼Œè§£é”æ‰€æœ‰çš„channelï¼Œç„¶åè¿”å›(case index)</p>

<p>ã€€ã€€2.2 å¦‚æœcaseå¯å†™ï¼Œåˆ™å°†æ•°æ®å†™å…¥channelï¼Œè§£é”æ‰€æœ‰çš„channelï¼Œç„¶åè¿”å›(case index)</p>

<p>ã€€ã€€2.3 æ‰€æœ‰caseéƒ½æœªreadyï¼Œåˆ™è§£é”æ‰€æœ‰çš„channelï¼Œç„¶åè¿”å›ï¼ˆdefault indexï¼‰</p>

<ol>
  <li>æ‰€æœ‰caseéƒ½æœªreadyï¼Œä¸”æ²¡æœ‰defaultè¯­å¥</li>
</ol>

<p>ã€€ã€€ 3.1 å°†å½“å‰åç¨‹åŠ å…¥åˆ°æ‰€æœ‰channelçš„ç­‰å¾…é˜Ÿåˆ—</p>

<p>ã€€ã€€3.2 å½“å°†åç¨‹è½¬å…¥é˜»å¡ï¼Œç­‰å¾…è¢«å”¤é†’</p>

<ol>
  <li>å”¤é†’åè¿”å›channelå¯¹åº”çš„case index</li>
</ol>

<p>ã€€ã€€4.1 å¦‚æœæ˜¯è¯»æ“ä½œï¼Œè§£é”æ‰€æœ‰çš„channelï¼Œç„¶åè¿”å›(case index)</p>

<p>ã€€ã€€4.2 å¦‚æœæ˜¯å†™æ“ä½œï¼Œè§£é”æ‰€æœ‰çš„channelï¼Œç„¶åè¿”å›(case index)</p>

<p>ä¸€ã€switchè¯­å¥
switchè¯­å¥æä¾›äº†ä¸€ä¸ªå¤šåˆ†æ”¯æ¡ä»¶æ‰§è¡Œçš„æ–¹æ³•ã€‚æ¯ä¸€ä¸ªcaseå¯ä»¥æºå¸¦ä¸€ä¸ªè¡¨è¾¾å¼æˆ–ä¸€ä¸ªç±»å‹è¯´æ˜ç¬¦ã€‚å‰è€…åˆå¯è¢«ç®€ç§°ä¸ºcaseè¡¨è¾¾å¼ã€‚å› æ­¤ï¼ŒGoè¯­è¨€çš„switchè¯­å¥åˆåˆ†ä¸ºè¡¨è¾¾å¼switchè¯­å¥å’Œç±»å‹switchè¯­å¥ã€‚
1ã€è¡¨è¾¾å¼switchè¯­å¥
Goä¼šä¾ç…§ä»ä¸Šè‡³ä¸‹çš„é¡ºåºå¯¹æ¯ä¸€æ¡caseè¯­å¥ä¸­caseè¡¨è¾¾å¼è¿›è¡Œæ±‚å€¼ï¼Œåªè¦è¢«å‘ç°å…¶è¡¨è¾¾å¼ä¸switchè¡¨è¾¾å¼çš„ç»“æœç›¸åŒï¼Œè¯¥caseè¯­å¥å°±ä¼šè¢«é€‰ä¸­ã€‚å…¶ä½™çš„caseè¯­å¥ä¼šè¢«å¿½ç•¥ã€‚
2ã€ç±»å‹switchè¯­å¥
ç±»å‹switchè¯­å¥ä¸ä¸€èˆ¬å½¢å¼æœ‰ä¸¤ç‚¹å·®åˆ«ã€‚ç¬¬ä¸€ç‚¹ï¼Œç´§éšcaseå…³é”®å­—çš„ä¸æ˜¯è¡¨è¾¾å¼ï¼Œè€Œæ˜¯ç±»å‹è¯´æ˜ç¬¦ã€‚ç±»å‹è¯´æ˜ç¬¦ç”±è‹¥å¹²ä¸ªç±»å‹å­—é¢é‡ç»„æˆï¼Œä¸”å¤šä¸ªç±»å‹å­—é¢é‡ä¹‹é—´ç”±è‹±æ–‡é€—å·åˆ†éš”ã€‚ç¬¬äºŒç‚¹ï¼Œå®ƒçš„switchè¡¨è¾¾å¼æ˜¯éå¸¸ç‰¹æ®Šçš„ã€‚è¿™ç§ç‰¹æ®Šçš„è¡¨è¾¾å¼ä¹Ÿèµ·åˆ°äº†ç±»å‹æ–­è¨€çš„ä½œç”¨ï¼Œä½†å…¶è¡¨ç°å½¢å¼å¾ˆç‰¹æ®Šï¼Œå¦‚ï¼šv.(type) , å…¶ä¸­vå¿…é¡»ä»£è¡¨ä¸€ä¸ªæ¥å£ç±»å‹çš„å€¼ã€‚è¯¥ç±»è¡¨è¾¾å¼åªèƒ½å‡ºç°åœ¨ç±»å‹switchè¯­å¥ä¸­ï¼Œä¸”åªèƒ½å……å½“switchè¡¨è¾¾å¼ã€‚</p>

<p>case int, int8, int16, int32, int64: 
 fmt.Println(â€œA signed integer:%d. The type is %T. \nâ€, v, i)</p>

<p>æœ€åè¯´ä¸€ä¸‹fallthroughã€‚å®ƒæ—¢æ˜¯ä¸€ä¸ªå…³é”®å­—ï¼Œåˆå¯ä»¥ä»£è¡¨ä¸€æ¡è¯­å¥ã€‚fallthroughè¯­å¥å¯è¢«åŒ…å«åœ¨è¡¨è¾¾å¼switchè¯­å¥ä¸­çš„caseè¯­å¥ä¸­ã€‚å®ƒçš„ä½œç”¨æ˜¯ä½¿æ§åˆ¶æƒæµè½¬åˆ°ä¸‹ä¸€ä¸ªcaseã€‚ä¸è¿‡è¦æ³¨æ„fallthroughè¯­å¥ä»…èƒ½ä½œä¸ºcaseè¯­å¥ä¸­çš„æœ€åä¸€æ¡è¯­å¥å‡ºç°ã€‚å¹¶ä¸”ï¼ŒåŒ…å«å®ƒçš„caseè¯­å¥ä¸æ˜¯å…¶æ‰€å±switchè¯­å¥çš„æœ€åä¸€æ¡caseè¯­å¥ã€‚</p>

:ET