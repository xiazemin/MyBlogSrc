I"™(<p>https://www.cnblogs.com/FireworksEasyCool/p/12750339.html
gRPCä¸­TLSè®¤è¯å’Œè‡ªå®šä¹‰æ–¹æ³•è®¤è¯ï¼Œæœ€åè¿˜ç®€å•ä»‹ç»äº†gRPCæ‹¦æˆªå™¨çš„ä½¿ç”¨ã€‚gRPCè‡ªèº«åªèƒ½è®¾ç½®ä¸€ä¸ªæ‹¦æˆªå™¨ï¼Œæ‰€æœ‰é€»è¾‘éƒ½å†™ä¸€èµ·ä¼šæ¯”è¾ƒä¹±ã€‚æœ¬ç¯‡ç®€å•ä»‹ç»go-grpc-middlewareçš„ä½¿ç”¨ï¼ŒåŒ…æ‹¬grpc_zapã€grpc_authå’Œgrpc_recoveryã€‚</p>

<p>go-grpc-middlewareç®€ä»‹
go-grpc-middlewareå°è£…äº†è®¤è¯ï¼ˆauthï¼‰, æ—¥å¿—ï¼ˆ loggingï¼‰, æ¶ˆæ¯ï¼ˆmessageï¼‰, éªŒè¯ï¼ˆvalidationï¼‰, é‡è¯•ï¼ˆretriesï¼‰ å’Œç›‘æ§ï¼ˆretriesï¼‰ç­‰æ‹¦æˆªå™¨ã€‚</p>

<p>å®‰è£… go get github.com/grpc-ecosystem/go-grpc-middleware
<!-- more -->
ä½¿ç”¨
import â€œgithub.com/grpc-ecosystem/go-grpc-middlewareâ€
myServer := grpc.NewServer(
    grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
        grpc_ctxtags.StreamServerInterceptor(),
        grpc_opentracing.StreamServerInterceptor(),
        grpc_prometheus.StreamServerInterceptor,
        grpc_zap.StreamServerInterceptor(zapLogger),
        grpc_auth.StreamServerInterceptor(myAuthFunction),
        grpc_recovery.StreamServerInterceptor(),
    )),
    grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
        grpc_ctxtags.UnaryServerInterceptor(),
        grpc_opentracing.UnaryServerInterceptor(),
        grpc_prometheus.UnaryServerInterceptor,
        grpc_zap.UnaryServerInterceptor(zapLogger),
        grpc_auth.UnaryServerInterceptor(myAuthFunction),
        grpc_recovery.UnaryServerInterceptor(),
    )),
)
grpc.StreamInterceptorä¸­æ·»åŠ æµå¼RPCçš„æ‹¦æˆªå™¨ã€‚
grpc.UnaryInterceptorä¸­æ·»åŠ ç®€å•RPCçš„æ‹¦æˆªå™¨ã€‚</p>

<p>grpc_zapæ—¥å¿—è®°å½•
1.åˆ›å»ºzap.Loggerå®ä¾‹</p>

<p>func ZapInterceptor() *zap.Logger {
	logger, err := zap.NewDevelopment()
	if err != nil {
		log.Fatalf(â€œfailed to initialize zap logger: %vâ€, err)
	}
	grpc_zap.ReplaceGrpcLogger(logger)
	return logger
}
2.æŠŠzapæ‹¦æˆªå™¨æ·»åŠ åˆ°æœåŠ¡ç«¯</p>

<p>grpcServer := grpc.NewServer(
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
		)),
	)
3.æ—¥å¿—åˆ†æ</p>

<p>å„ä¸ªå­—æ®µä»£è¡¨çš„æ„æ€å¦‚ä¸‹ï¼š</p>

<p>{
	  â€œlevelâ€: â€œinfoâ€,						// string  zap log levels
	  â€œmsgâ€: â€œfinished unary callâ€,					// string  log message</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  "grpc.code": "OK",						// string  grpc status code
  "grpc.method": "Ping",					/ string  method name
  "grpc.service": "mwitkow.testproto.TestService",              // string  full name of the called service
  "grpc.start_time": "2006-01-02T15:04:05Z07:00",               // string  RFC3339 representation of the start time
  "grpc.request.deadline": "2006-01-02T15:04:05Z07:00",         // string  RFC3339 deadline of the current request if supplied
  "grpc.request.value": "something",				// string  value on the request
  "grpc.time_ms": 1.345,					// float32 run time of the call in ms

  "peer.address": {
    "IP": "127.0.0.1",						// string  IP address of calling party
    "Port": 60216,						// int     port call is coming in on
    "Zone": ""							// string  peer zone for caller
  },
  "span.kind": "server",					// string  client | server
  "system": "grpc",						// string

  "custom_field": "custom_value",				// string  user defined field
  "custom_tags.int": 1337,					// int     user defined tag on the ctx
  "custom_tags.string": "something"				// string  user defined tag on the ctx } 4.æŠŠæ—¥å¿—å†™åˆ°æ–‡ä»¶ä¸­
</code></pre></div></div>

<p>ä¸Šé¢æ—¥å¿—æ˜¯åœ¨æ§åˆ¶å°è¾“å‡ºçš„ï¼Œç°åœ¨æˆ‘ä»¬æŠŠæ—¥å¿—å†™åˆ°æ–‡ä»¶ä¸­ï¼Œä¿®æ”¹ZapInterceptoræ–¹æ³•ã€‚</p>

<p>import (
	grpc_zap â€œgithub.com/grpc-ecosystem/go-grpc-middleware/logging/zapâ€
	â€œgo.uber.org/zapâ€
	â€œgo.uber.org/zap/zapcoreâ€
	â€œgopkg.in/natefinch/lumberjack.v2â€
)</p>

<p>// ZapInterceptor è¿”å›zap.loggerå®ä¾‹(æŠŠæ—¥å¿—å†™åˆ°æ–‡ä»¶ä¸­)
func ZapInterceptor() *zap.Logger {
	w := zapcore.AddSync(&amp;lumberjack.Logger{
		Filename:  â€œlog/debug.logâ€,
		MaxSize:   1024, //MB
		LocalTime: true,
	})</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>config := zap.NewProductionEncoderConfig()
config.EncodeTime = zapcore.ISO8601TimeEncoder
core := zapcore.NewCore(
	zapcore.NewJSONEncoder(config),
	w,
	zap.NewAtomicLevel(),
)

logger := zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1))
grpc_zap.ReplaceGrpcLogger(logger)
return logger } grpc_authè®¤è¯ go-grpc-middlewareä¸­çš„grpc_authé»˜è®¤ä½¿ç”¨authorizationè®¤è¯æ–¹å¼ï¼Œä»¥authorizationä¸ºå¤´éƒ¨ï¼ŒåŒ…æ‹¬basic, bearerå½¢å¼ç­‰ã€‚ä¸‹é¢ä»‹ç»bearer tokenè®¤è¯ã€‚bearerå…è®¸ä½¿ç”¨access keyï¼ˆå¦‚JSON Web Token (JWT)ï¼‰è¿›è¡Œè®¿é—®ã€‚
</code></pre></div></div>

<p>1.æ–°å»ºgrpc_authæœåŠ¡ç«¯æ‹¦æˆªå™¨</p>

<p>// TokenInfo ç”¨æˆ·ä¿¡æ¯
type TokenInfo struct {
	ID    string
	Roles []string
}</p>

<p>// AuthInterceptor è®¤è¯æ‹¦æˆªå™¨ï¼Œå¯¹ä»¥authorizationä¸ºå¤´éƒ¨ï¼Œå½¢å¼ä¸º<code class="language-plaintext highlighter-rouge">bearer token</code>çš„Tokenè¿›è¡ŒéªŒè¯
func AuthInterceptor(ctx context.Context) (context.Context, error) {
	token, err := grpc_auth.AuthFromMD(ctx, â€œbearerâ€)
	if err != nil {
		return nil, err
	}
	tokenInfo, err := parseToken(token)
	if err != nil {
		return nil, grpc.Errorf(codes.Unauthenticated, â€œ %vâ€, err)
	}
	//ä½¿ç”¨context.WithValueæ·»åŠ äº†å€¼åï¼Œå¯ä»¥ç”¨Value(key)æ–¹æ³•è·å–å€¼
	newCtx := context.WithValue(ctx, tokenInfo.ID, tokenInfo)
	//log.Println(newCtx.Value(tokenInfo.ID))
	return newCtx, nil
}</p>

<p>//è§£ætokenï¼Œå¹¶è¿›è¡ŒéªŒè¯
func parseToken(token string) (TokenInfo, error) {
	var tokenInfo TokenInfo
	if token == â€œgrpc.auth.tokenâ€ {
		tokenInfo.ID = â€œ1â€
		tokenInfo.Roles = []string{â€œadminâ€}
		return tokenInfo, nil
	}
	return tokenInfo, errors.New(â€œTokenæ— æ•ˆ: bearer â€œ + token)
}</p>

<p>//ä»tokenä¸­è·å–ç”¨æˆ·å”¯ä¸€æ ‡è¯†
func userClaimFromToken(tokenInfo TokenInfo) string {
	return tokenInfo.ID
}
ä»£ç ä¸­çš„å¯¹tokenè¿›è¡Œç®€å•éªŒè¯å¹¶è¿”å›æ¨¡æ‹Ÿæ•°æ®ã€‚</p>

<p>2.å®¢æˆ·ç«¯è¯·æ±‚æ·»åŠ bearer token</p>

<p>å®ç°å’Œä¸Šç¯‡çš„è‡ªå®šä¹‰è®¤è¯æ–¹æ³•å¤§åŒå°å¼‚ã€‚gRPC ä¸­é»˜è®¤å®šä¹‰äº† PerRPCCredentialsï¼Œæ˜¯æä¾›ç”¨äºè‡ªå®šä¹‰è®¤è¯çš„æ¥å£ï¼Œå®ƒçš„ä½œç”¨æ˜¯å°†æ‰€éœ€çš„å®‰å…¨è®¤è¯ä¿¡æ¯æ·»åŠ åˆ°æ¯ä¸ªRPCæ–¹æ³•çš„ä¸Šä¸‹æ–‡ä¸­ã€‚å…¶åŒ…å« 2 ä¸ªæ–¹æ³•ï¼š</p>

<p>GetRequestMetadataï¼šè·å–å½“å‰è¯·æ±‚è®¤è¯æ‰€éœ€çš„å…ƒæ•°æ®
RequireTransportSecurityï¼šæ˜¯å¦éœ€è¦åŸºäº TLS è®¤è¯è¿›è¡Œå®‰å…¨ä¼ è¾“
æ¥ä¸‹æ¥æˆ‘ä»¬å®ç°è¿™ä¸¤ä¸ªæ–¹æ³•</p>

<p>// Token tokenè®¤è¯
type Token struct {
	Value string
}</p>

<p>const headerAuthorize string = â€œauthorizationâ€</p>

<p>// GetRequestMetadata è·å–å½“å‰è¯·æ±‚è®¤è¯æ‰€éœ€çš„å…ƒæ•°æ®
func (t *Token) GetRequestMetadata(ctx context.Context, uri â€¦string) (map[string]string, error) {
	return map[string]string{headerAuthorize: t.Value}, nil
}</p>

<p>// RequireTransportSecurity æ˜¯å¦éœ€è¦åŸºäº TLS è®¤è¯è¿›è¡Œå®‰å…¨ä¼ è¾“
func (t *Token) RequireTransportSecurity() bool {
	return true
}
æ³¨æ„ï¼šè¿™é‡Œè¦ä»¥authorizationä¸ºå¤´éƒ¨ï¼Œå’ŒæœåŠ¡ç«¯å¯¹åº”ã€‚</p>

<p>å‘é€è¯·æ±‚æ—¶æ·»åŠ token</p>

<p>//ä»è¾“å…¥çš„è¯ä¹¦æ–‡ä»¶ä¸­ä¸ºå®¢æˆ·ç«¯æ„é€ TLSå‡­è¯
	creds, err := credentials.NewClientTLSFromFile(â€œ../tls/server.pemâ€, â€œgo-grpc-exampleâ€)
	if err != nil {
		log.Fatalf(â€œFailed to create TLS credentials %vâ€, err)
	}
	//æ„å»ºToken
	token := auth.Token{
		Value: â€œbearer grpc.auth.tokenâ€,
	}
	// è¿æ¥æœåŠ¡å™¨
	conn, err := grpc.Dial(Address, grpc.WithTransportCredentials(creds), grpc.WithPerRPCCredentials(&amp;token))
æ³¨æ„ï¼šTokenä¸­çš„Valueçš„å½¢å¼è¦ä»¥bearer tokenå€¼å½¢å¼ã€‚å› ä¸ºæˆ‘ä»¬æœåŠ¡ç«¯ä½¿ç”¨äº†bearer tokenéªŒè¯æ–¹å¼ã€‚</p>

<p>3.æŠŠgrpc_authæ‹¦æˆªå™¨æ·»åŠ åˆ°æœåŠ¡ç«¯</p>

<p>grpcServer := grpc.NewServer(cred.TLSInterceptor(),
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
	        grpc_auth.StreamServerInterceptor(auth.AuthInterceptor),
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		    grpc_auth.UnaryServerInterceptor(auth.AuthInterceptor),
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
		)),
	)
å†™åˆ°è¿™é‡Œï¼ŒæœåŠ¡ç«¯éƒ½ä¼šæ‹¦æˆªè¯·æ±‚å¹¶è¿›è¡Œbearer tokenéªŒè¯ï¼Œä½¿ç”¨bearer tokenæ˜¯è§„èŒƒäº†ä¸HTTPè¯·æ±‚çš„å¯¹æ¥ï¼Œæ¯•ç«ŸgRPCä¹Ÿå¯ä»¥åŒæ—¶æ”¯æŒHTTPè¯·æ±‚ã€‚</p>

<p>grpc_recoveryæ¢å¤
æŠŠgRPCä¸­çš„panicè½¬æˆerrorï¼Œä»è€Œæ¢å¤ç¨‹åºã€‚</p>

<p>1.ç›´æ¥æŠŠgrpc_recoveryæ‹¦æˆªå™¨æ·»åŠ åˆ°æœåŠ¡ç«¯</p>

<p>æœ€ç®€å•ä½¿ç”¨æ–¹å¼</p>

<p>grpcServer := grpc.NewServer(cred.TLSInterceptor(),
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
	        grpc_auth.StreamServerInterceptor(auth.AuthInterceptor),
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
			grpc_recovery.StreamServerInterceptor,
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		    grpc_auth.UnaryServerInterceptor(auth.AuthInterceptor),
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
            grpc_recovery.UnaryServerInterceptor(),
		)),
	)
2.è‡ªå®šä¹‰é”™è¯¯è¿”å›</p>

<p>å½“panicæ—¶å€™ï¼Œè‡ªå®šä¹‰é”™è¯¯ç å¹¶è¿”å›ã€‚</p>

<p>// RecoveryInterceptor panicæ—¶è¿”å›Unknowné”™è¯¯å—
func RecoveryInterceptor() grpc_recovery.Option {
	return grpc_recovery.WithRecoveryHandler(func(p interface{}) (err error) {
		return grpc.Errorf(codes.Unknown, â€œpanic triggered: %vâ€, p)
	})
}
æ·»åŠ grpc_recoveryæ‹¦æˆªå™¨åˆ°æœåŠ¡ç«¯</p>

<p>grpcServer := grpc.NewServer(cred.TLSInterceptor(),
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
	        grpc_auth.StreamServerInterceptor(auth.AuthInterceptor),
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
			grpc_recovery.StreamServerInterceptor(recovery.RecoveryInterceptor()),
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		    grpc_auth.UnaryServerInterceptor(auth.AuthInterceptor),
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
            grpc_recovery.UnaryServerInterceptor(recovery.RecoveryInterceptor()),
		)),
	)
æ€»ç»“
æœ¬ç¯‡ä»‹ç»äº†go-grpc-middlewareä¸­çš„grpc_zapã€grpc_authå’Œgrpc_recoveryæ‹¦æˆªå™¨çš„ä½¿ç”¨ã€‚go-grpc-middlewareä¸­å…¶ä»–æ‹¦æˆªå™¨å¯å‚è€ƒGitHubå­¦ä¹ ä½¿ç”¨ã€‚</p>

<p>æ•™ç¨‹æºç åœ°å€ï¼šhttps://github.com/Bingjian-Zhu/go-grpc-example</p>
:ET