I"Ô<p>he status variables have the following meanings.</p>

<p>Aborted_clients</p>

<p>The number of connections that were aborted because the client died without closing the connection properly. See Section B.3.2.10, â€œCommunication Errors and Aborted Connectionsâ€.</p>

<p>Aborted_connects</p>

<p>The number of failed attempts to connect to the MySQL server. See Section B.3.2.10, â€œCommunication Errors and Aborted Connectionsâ€.</p>

<p>For additional connection-related information, check the Connection_errors_xxx status variables and the host_cache table.</p>

<p>Binlog_cache_disk_use</p>

<p>The number of transactions that used the temporary binary log cache but that exceeded the value of binlog_cache_size and used a temporary file to store statements from the transaction.</p>

<p>The number of nontransactional statements that caused the binary log transaction cache to be written to disk is tracked separately in the Binlog_stmt_cache_disk_use status variable.</p>

<p>Binlog_cache_use</p>

<p>The number of transactions that used the binary log cache.</p>

<p>Binlog_stmt_cache_disk_use</p>

<p>The number of nontransaction statements that used the binary log statement cache but that exceeded the value of binlog_stmt_cache_size and used a temporary file to store those statements.</p>

<p>Binlog_stmt_cache_use</p>

<p>The number of nontransactional statements that used the binary log statement cache.</p>

<p>Bytes_received</p>

<p>The number of bytes received from all clients.</p>

<p>Bytes_sent</p>

<p>The number of bytes sent to all clients.</p>

<p>Com_xxx</p>

<p>The Com_xxx statement counter variables indicate the number of times each xxx statement has been executed. There is one status variable for each type of statement. For example, Com_delete and Com_update count DELETE and UPDATE statements, respectively. Com_delete_multi and Com_update_multi are similar but apply to DELETE and UPDATE statements that use multiple-table syntax.</p>

<p>If a query result is returned from query cache, the server increments the Qcache_hits status variable, not Com_select. See Section 8.10.3.4, â€œQuery Cache Status and Maintenanceâ€.</p>

<p>All Com_stmt_xxx variables are increased even if a prepared statement argument is unknown or an error occurred during execution. In other words, their values correspond to the number of requests issued, not to the number of requests successfully completed.</p>

<p>The Com_stmt_xxx status variables are as follows:</p>

<p>Com_stmt_prepare</p>

<p>Com_stmt_execute</p>

<p>Com_stmt_fetch</p>

<p>Com_stmt_send_long_data</p>

<p>Com_stmt_reset</p>

<p>Com_stmt_close</p>

<p>Those variables stand for prepared statement commands. Their names refer to the COM_xxx command set used in the network layer. In other words, their values increase whenever prepared statement API calls such as mysql_stmt_prepare(), mysql_stmt_execute(), and so forth are executed. However, Com_stmt_prepare, Com_stmt_execute and Com_stmt_close also increase for PREPARE, EXECUTE, or DEALLOCATE PREPARE, respectively. Additionally, the values of the older statement counter variables Com_prepare_sql, Com_execute_sql, and Com_dealloc_sql increase for the PREPARE, EXECUTE, and DEALLOCATE PREPARE statements. Com_stmt_fetch stands for the total number of network round-trips issued when fetching from cursors.</p>

<p>Com_stmt_reprepare indicates the number of times statements were automatically reprepared by the server after metadata changes to tables or views referred to by the statement. A reprepare operation increments Com_stmt_reprepare, and also Com_stmt_prepare.</p>

<p>Compression</p>

<p>Whether the client connection uses compression in the client/server protocol.</p>

<p>Connection_errors_xxx</p>

<p>These variables provide information about errors that occur during the client connection process. They are global only and represent error counts aggregated across connections from all hosts. These variables track errors not accounted for by the host cache (see Section 5.1.11.2, â€œDNS Lookups and the Host Cacheâ€), such as errors that are not associated with TCP connections, occur very early in the connection process (even before an IP address is known), or are not specific to any particular IP address (such as out-of-memory conditions).</p>

<p>Connection_errors_accept</p>

<p>The number of errors that occurred during calls to accept() on the listening port.</p>

<p>Connection_errors_internal</p>

<p>The number of connections refused due to internal errors in the server, such as failure to start a new thread or an out-of-memory condition.</p>

<p>Connection_errors_max_connections</p>

<p>The number of connections refused because the server max_connections limit was reached.</p>

<p>Connection_errors_peer_address</p>

<p>The number of errors that occurred while searching for connecting client IP addresses.</p>

<p>Connection_errors_select</p>

<p>The number of errors that occurred during calls to select() or poll() on the listening port. (Failure of this operation does not necessarily means a client connection was rejected.)</p>

<p>Connection_errors_tcpwrap</p>

<p>The number of connections refused by the libwrap library.</p>

<p>Connections</p>

<p>The number of connection attempts (successful or not) to the MySQL server.</p>

<p>Created_tmp_disk_tables</p>

<p>The number of internal on-disk temporary tables created by the server while executing statements.</p>

<p>You can compare the number of internal on-disk temporary tables created to the total number of internal temporary tables created by comparing Created_tmp_disk_tables and Created_tmp_tables values.</p>

<p>See also Section 8.4.4, â€œInternal Temporary Table Use in MySQLâ€.</p>

<p>Created_tmp_files</p>

<p>How many temporary files mysqld has created.</p>

<p>Created_tmp_tables</p>

<p>The number of internal temporary tables created by the server while executing statements.</p>

<p>You can compare the number of internal on-disk temporary tables created to the total number of internal temporary tables created by comparing Created_tmp_disk_tables and Created_tmp_tables values.</p>

<p>See also Section 8.4.4, â€œInternal Temporary Table Use in MySQLâ€.</p>

<p>Each invocation of the SHOW STATUS statement uses an internal temporary table and increments the global Created_tmp_tables value.</p>

<p>Delayed_errors</p>

<p>The number of rows written with INSERT DELAYED for which some error occurred (probably duplicate key).</p>

<p>This status variable is deprecated (because DELAYED inserts are deprecated); expect it to be removed in a future release.</p>

<p>Delayed_insert_threads</p>

<p>The number of INSERT DELAYED handler threads in use for nontransactional tables.</p>

<p>This status variable is deprecated (because DELAYED inserts are deprecated); expect it to be removed in a future release.</p>

<p>Delayed_writes</p>

<p>The number of INSERT DELAYED rows written to nontransactional tables.</p>

<p>This status variable is deprecated (because DELAYED inserts are deprecated); expect it to be removed in a future release.</p>

<p>Flush_commands</p>

<p>The number of times the server flushes tables, whether because a user executed a FLUSH TABLES statement or due to internal server operation. It is also incremented by receipt of a COM_REFRESH packet. This is in contrast to Com_flush, which indicates how many FLUSH statements have been executed, whether FLUSH TABLES, FLUSH LOGS, and so forth.</p>

<p>Handler_commit</p>

<p>The number of internal COMMIT statements.</p>

<p>Handler_delete</p>

<p>The number of times that rows have been deleted from tables.</p>

<p>Handler_external_lock</p>

<p>The server increments this variable for each call to its external_lock() function, which generally occurs at the beginning and end of access to a table instance. There might be differences among storage engines. This variable can be used, for example, to discover for a statement that accesses a partitioned table how many partitions were pruned before locking occurred: Check how much the counter increased for the statement, subtract 2 (2 calls for the table itself), then divide by 2 to get the number of partitions locked.</p>

<p>Handler_mrr_init</p>

<p>The number of times the server uses a storage engineâ€™s own Multi-Range Read implementation for table access.</p>

<p>Handler_prepare</p>

<p>A counter for the prepare phase of two-phase commit operations.</p>

<p>Handler_read_first</p>

<p>The number of times the first entry in an index was read. If this value is high, it suggests that the server is doing a lot of full index scans (for example, SELECT col1 FROM foo, assuming that col1 is indexed).</p>

<p>Handler_read_key</p>

<p>The number of requests to read a row based on a key. If this value is high, it is a good indication that your tables are properly indexed for your queries.</p>

<p>Handler_read_last</p>

<p>The number of requests to read the last key in an index. With ORDER BY, the server issues a first-key request followed by several next-key requests, whereas with ORDER BY DESC, the server issues a last-key request followed by several previous-key requests.</p>

<p>Handler_read_next</p>

<p>The number of requests to read the next row in key order. This value is incremented if you are querying an index column with a range constraint or if you are doing an index scan.</p>

<p>Handler_read_prev</p>

<p>The number of requests to read the previous row in key order. This read method is mainly used to optimize ORDER BY â€¦ DESC.</p>

<p>Handler_read_rnd</p>

<p>The number of requests to read a row based on a fixed position. This value is high if you are doing a lot of queries that require sorting of the result. You probably have a lot of queries that require MySQL to scan entire tables or you have joins that do not use keys properly.</p>

<p>Handler_read_rnd_next</p>

<p>The number of requests to read the next row in the data file. This value is high if you are doing a lot of table scans. Generally this suggests that your tables are not properly indexed or that your queries are not written to take advantage of the indexes you have.</p>

<p>Handler_rollback</p>

<p>The number of requests for a storage engine to perform a rollback operation.</p>

<p>Handler_savepoint</p>

<p>The number of requests for a storage engine to place a savepoint.</p>

<p>Handler_savepoint_rollback</p>

<p>The number of requests for a storage engine to roll back to a savepoint.</p>

<p>Handler_update</p>

<p>The number of requests to update a row in a table.</p>

<p>Handler_write</p>

<p>The number of requests to insert a row in a table.</p>

<p>Innodb_available_undo_logs</p>

<p>The total number of available InnoDB rollback segments. Supplements the innodb_rollback_segments system variable, which defines the number of active rollback segments.</p>

<p>Innodb_buffer_pool_dump_status</p>

<p>The progress of an operation to record the pages held in the InnoDB buffer pool, triggered by the setting of innodb_buffer_pool_dump_at_shutdown or innodb_buffer_pool_dump_now.</p>

<p>For related information and examples, see Section 14.8.3.5, â€œSaving and Restoring the Buffer Pool Stateâ€.</p>

<p>Innodb_buffer_pool_load_status</p>

<p>The progress of an operation to warm up the InnoDB buffer pool by reading in a set of pages corresponding to an earlier point in time, triggered by the setting of innodb_buffer_pool_load_at_startup or innodb_buffer_pool_load_now. If the operation introduces too much overhead, you can cancel it by setting innodb_buffer_pool_load_abort.</p>

<p>For related information and examples, see Section 14.8.3.5, â€œSaving and Restoring the Buffer Pool Stateâ€.</p>

<p>Innodb_buffer_pool_bytes_data</p>

<p>The total number of bytes in the InnoDB buffer pool containing data. The number includes both dirty and clean pages. For more accurate memory usage calculations than with Innodb_buffer_pool_pages_data, when compressed tables cause the buffer pool to hold pages of different sizes.</p>

<p>Innodb_buffer_pool_pages_data</p>

<p>The number of pages in the InnoDB buffer pool containing data. The number includes both dirty and clean pages. When using compressed tables, the reported Innodb_buffer_pool_pages_data value may be larger than Innodb_buffer_pool_pages_total (Bug #59550).</p>

<p>Innodb_buffer_pool_bytes_dirty</p>

<p>The total current number of bytes held in dirty pages in the InnoDB buffer pool. For more accurate memory usage calculations than with Innodb_buffer_pool_pages_dirty, when compressed tables cause the buffer pool to hold pages of different sizes.</p>

<p>Innodb_buffer_pool_pages_dirty</p>

<p>The current number of dirty pages in the InnoDB buffer pool.</p>

<p>Innodb_buffer_pool_pages_flushed</p>

<p>The number of requests to flush pages from the InnoDB buffer pool.</p>

<p>Innodb_buffer_pool_pages_free</p>

<p>The number of free pages in the InnoDB buffer pool.</p>

<p>Innodb_buffer_pool_pages_latched</p>

<p>The number of latched pages in the InnoDB buffer pool. These are pages currently being read or written, or that cannot be flushed or removed for some other reason. Calculation of this variable is expensive, so it is available only when the UNIV_DEBUG system is defined at server build time.</p>

<p>Innodb_buffer_pool_pages_misc</p>

<p>The number of pages in the InnoDB buffer pool that are busy because they have been allocated for administrative overhead, such as row locks or the adaptive hash index. This value can also be calculated as Innodb_buffer_pool_pages_total âˆ’ Innodb_buffer_pool_pages_free âˆ’ Innodb_buffer_pool_pages_data. When using compressed tables, Innodb_buffer_pool_pages_misc may report an out-of-bounds value (Bug #59550).</p>

<p>Innodb_buffer_pool_pages_total</p>

<p>The total size of the InnoDB buffer pool, in pages. When using compressed tables, the reported Innodb_buffer_pool_pages_data value may be larger than Innodb_buffer_pool_pages_total (Bug #59550)</p>

<p>Innodb_buffer_pool_read_ahead</p>

<p>The number of pages read into the InnoDB buffer pool by the read-ahead background thread.</p>

<p>Innodb_buffer_pool_read_ahead_evicted</p>

<p>The number of pages read into the InnoDB buffer pool by the read-ahead background thread that were subsequently evicted without having been accessed by queries.</p>

<p>Innodb_buffer_pool_read_ahead_rnd</p>

<p>The number of â€œrandomâ€ read-aheads initiated by InnoDB. This happens when a query scans a large portion of a table but in random order.</p>

<p>Innodb_buffer_pool_read_requests</p>

<p>The number of logical read requests.</p>

<p>Innodb_buffer_pool_reads</p>

<p>The number of logical reads that InnoDB could not satisfy from the buffer pool, and had to read directly from disk.</p>

<p>Innodb_buffer_pool_wait_free</p>

<p>Normally, writes to the InnoDB buffer pool happen in the background. When InnoDB needs to read or create a page and no clean pages are available, InnoDB flushes some dirty pages first and waits for that operation to finish. This counter counts instances of these waits. If innodb_buffer_pool_size has been set properly, this value should be small.</p>

<p>Innodb_buffer_pool_write_requests</p>

<p>The number of writes done to the InnoDB buffer pool.</p>

<p>Innodb_data_fsyncs</p>

<p>The number of fsync() operations so far. The frequency of fsync() calls is influenced by the setting of the innodb_flush_method configuration option.</p>

<p>Innodb_data_pending_fsyncs</p>

<p>The current number of pending fsync() operations. The frequency of fsync() calls is influenced by the setting of the innodb_flush_method configuration option.</p>

<p>Innodb_data_pending_reads</p>

<p>The current number of pending reads.</p>

<p>Innodb_data_pending_writes</p>

<p>The current number of pending writes.</p>

<p>Innodb_data_read</p>

<p>The amount of data read since the server was started (in bytes).</p>

<p>Innodb_data_reads</p>

<p>The total number of data reads (OS file reads).</p>

<p>Innodb_data_writes</p>

<p>The total number of data writes.</p>

<p>Innodb_data_written</p>

<p>The amount of data written so far, in bytes.</p>

<p>Innodb_dblwr_pages_written</p>

<p>The number of pages that have been written to the doublewrite buffer. See Section 14.12.1, â€œInnoDB Disk I/Oâ€.</p>

<p>Innodb_dblwr_writes</p>

<p>The number of doublewrite operations that have been performed. See Section 14.12.1, â€œInnoDB Disk I/Oâ€.</p>

<p>Innodb_have_atomic_builtins</p>

<p>Indicates whether the server was built with atomic instructions.</p>

<p>Innodb_log_waits</p>

<p>The number of times that the log buffer was too small and a wait was required for it to be flushed before continuing.</p>

<p>Innodb_log_write_requests</p>

<p>The number of write requests for the InnoDB redo log.</p>

<p>Innodb_log_writes</p>

<p>The number of physical writes to the InnoDB redo log file.</p>

<p>Innodb_num_open_files</p>

<p>The number of files InnoDB currently holds open.</p>

<p>Innodb_os_log_fsyncs</p>

<p>The number of fsync() writes done to the InnoDB redo log files.</p>

<p>Innodb_os_log_pending_fsyncs</p>

<p>The number of pending fsync() operations for the InnoDB redo log files.</p>

<p>Innodb_os_log_pending_writes</p>

<p>The number of pending writes to the InnoDB redo log files.</p>

<p>Innodb_os_log_written</p>

<p>The number of bytes written to the InnoDB redo log files.</p>

<p>Innodb_page_size</p>

<p>InnoDB page size (default 16KB). Many values are counted in pages; the page size enables them to be easily converted to bytes.</p>

<p>Innodb_pages_created</p>

<p>The number of pages created by operations on InnoDB tables.</p>

<p>Innodb_pages_read</p>

<p>The number of pages read from the InnoDB buffer pool by operations on InnoDB tables.</p>

<p>Innodb_pages_written</p>

<p>The number of pages written by operations on InnoDB tables.</p>

<p>Innodb_row_lock_current_waits</p>

<p>The number of row locks currently being waited for by operations on InnoDB tables.</p>

<p>Innodb_row_lock_time</p>

<p>The total time spent in acquiring row locks for InnoDB tables, in milliseconds.</p>

<p>Innodb_row_lock_time_avg</p>

<p>The average time to acquire a row lock for InnoDB tables, in milliseconds.</p>

<p>Innodb_row_lock_time_max</p>

<p>The maximum time to acquire a row lock for InnoDB tables, in milliseconds.</p>

<p>Innodb_row_lock_waits</p>

<p>The number of times operations on InnoDB tables had to wait for a row lock.</p>

<p>Innodb_rows_deleted</p>

<p>The number of rows deleted from InnoDB tables.</p>

<p>Innodb_rows_inserted</p>

<p>The number of rows inserted into InnoDB tables.</p>

<p>Innodb_rows_read</p>

<p>The number of rows read from InnoDB tables.</p>

<p>Innodb_rows_updated</p>

<p>The number of rows updated in InnoDB tables.</p>

<p>Innodb_truncated_status_writes</p>

<p>The number of times output from the SHOW ENGINE INNODB STATUS statement has been truncated.</p>

<p>Key_blocks_not_flushed</p>

<p>The number of key blocks in the MyISAM key cache that have changed but have not yet been flushed to disk.</p>

<p>Key_blocks_unused</p>

<p>The number of unused blocks in the MyISAM key cache. You can use this value to determine how much of the key cache is in use; see the discussion of key_buffer_size in Section 5.1.7, â€œServer System Variablesâ€.</p>

<p>Key_blocks_used</p>

<p>The number of used blocks in the MyISAM key cache. This value is a high-water mark that indicates the maximum number of blocks that have ever been in use at one time.</p>

<p>Key_read_requests</p>

<p>The number of requests to read a key block from the MyISAM key cache.</p>

<p>Key_reads</p>

<p>The number of physical reads of a key block from disk into the MyISAM key cache. If Key_reads is large, then your key_buffer_size value is probably too small. The cache miss rate can be calculated as Key_reads/Key_read_requests.</p>

<p>Key_write_requests</p>

<p>The number of requests to write a key block to the MyISAM key cache.</p>

<p>Key_writes</p>

<p>The number of physical writes of a key block from the MyISAM key cache to disk.</p>

<p>Last_query_cost</p>

<p>The total cost of the last compiled query as computed by the query optimizer. This is useful for comparing the cost of different query plans for the same query. The default value of 0 means that no query has been compiled yet. The default value is 0. Last_query_cost has session scope.</p>

<p>Last_query_cost can be computed accurately only for simple, â€œflatâ€ queries, but not for complex queries such as those containing subqueries or UNION. For the latter, the value is set to 0.</p>

<p>Last_query_partial_plans</p>

<p>The number of iterations the query optimizer made in execution plan construction for the previous query. Last_query_cost has session scope.</p>

<p>Max_used_connections</p>

<p>The maximum number of connections that have been in use simultaneously since the server started.</p>

<p>Not_flushed_delayed_rows</p>

<p>The number of rows waiting to be written to nontransactional tables in INSERT DELAYED queues.</p>

<p>This status variable is deprecated (because DELAYED inserts are deprecated); expect it to be removed in a future release.</p>

<p>Open_files</p>

<p>The number of files that are open. This count includes regular files opened by the server. It does not include other types of files such as sockets or pipes. Also, the count does not include files that storage engines open using their own internal functions rather than asking the server level to do so.</p>

<p>Open_streams</p>

<p>The number of streams that are open (used mainly for logging).</p>

<p>Open_table_definitions</p>

<p>The number of cached .frm files.</p>

<p>Open_tables</p>

<p>The number of tables that are open.</p>

<p>Opened_files</p>

<p>The number of files that have been opened with my_open() (a mysys library function). Parts of the server that open files without using this function do not increment the count.</p>

<p>Opened_table_definitions</p>

<p>The number of .frm files that have been cached.</p>

<p>Opened_tables</p>

<p>The number of tables that have been opened. If Opened_tables is big, your table_open_cache value is probably too small.</p>

<p>Performance_schema_xxx</p>

<p>Performance Schema status variables are listed in Section 22.16, â€œPerformance Schema Status Variablesâ€. These variables provide information about instrumentation that could not be loaded or created due to memory constraints.</p>

<p>Prepared_stmt_count</p>

<p>The current number of prepared statements. (The maximum number of statements is given by the max_prepared_stmt_count system variable.)</p>

<p>Qcache_free_blocks</p>

<p>The number of free memory blocks in the query cache.</p>

<p>Qcache_free_memory</p>

<p>The amount of free memory for the query cache.</p>

<p>Qcache_hits</p>

<p>The number of query cache hits.</p>

<p>The discussion at the beginning of this section indicates how to relate this statement-counting status variable to other such variables.</p>

<p>Qcache_inserts</p>

<p>The number of queries added to the query cache.</p>

<p>Qcache_lowmem_prunes</p>

<p>The number of queries that were deleted from the query cache because of low memory.</p>

<p>Qcache_not_cached</p>

<p>The number of noncached queries (not cacheable, or not cached due to the query_cache_type setting).</p>

<p>Qcache_queries_in_cache</p>

<p>The number of queries registered in the query cache.</p>

<p>Qcache_total_blocks</p>

<p>The total number of blocks in the query cache.</p>

<p>Queries</p>

<p>The number of statements executed by the server. This variable includes statements executed within stored programs, unlike the Questions variable. It does not count COM_PING or COM_STATISTICS commands.</p>

<p>The discussion at the beginning of this section indicates how to relate this statement-counting status variable to other such variables.</p>

<p>Questions</p>

<p>The number of statements executed by the server. This includes only statements sent to the server by clients and not statements executed within stored programs, unlike the Queries variable. This variable does not count COM_PING, COM_STATISTICS, COM_STMT_PREPARE, COM_STMT_CLOSE, or COM_STMT_RESET commands.</p>

<p>The discussion at the beginning of this section indicates how to relate this statement-counting status variable to other such variables.</p>

<p>Rpl_semi_sync_master_clients</p>

<p>The number of semisynchronous replicas.</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_net_avg_wait_time</p>

<p>The average time in microseconds the source waited for a replica reply.</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_net_wait_time</p>

<p>The total time in microseconds the source waited for replica replies.</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_net_waits</p>

<p>The total number of times the source waited for replica replies.</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_no_times</p>

<p>The number of times the source turned off semisynchronous replication.</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_no_tx</p>

<p>The number of commits that were not acknowledged successfully by a replica.</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_status</p>

<p>Whether semisynchronous replication currently is operational on the source. The value is ON if the plugin has been enabled and a commit acknowledgment has occurred. It is OFF if the plugin is not enabled or the source has fallen back to asynchronous replication due to commit acknowledgment timeout.</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_timefunc_failures</p>

<p>The number of times the source failed when calling time functions such as gettimeofday().</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_tx_avg_wait_time</p>

<p>The average time in microseconds the source waited for each transaction.</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_tx_wait_time</p>

<p>The total time in microseconds the source waited for transactions.</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_tx_waits</p>

<p>The total number of times the source waited for transactions.</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_wait_pos_backtraverse</p>

<p>The total number of times the source waited for an event with binary coordinates lower than events waited for previously. This can occur when the order in which transactions start waiting for a reply is different from the order in which their binary log events are written.</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_wait_sessions</p>

<p>The number of sessions currently waiting for replica replies.</p>

<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_master_yes_tx</p>

<p>The number of commits that were acknowledged successfully by a replica.</p>

<p>This variable is available only if the master-side semisynchronous replication plugin is installed.</p>

<p>Rpl_semi_sync_slave_status</p>

<p>Whether semisynchronous replication currently is operational on the replica. This is ON if the plugin has been enabled and the replica I/O thread is running, OFF otherwise.</p>

<p>This variable is available only if the replica-side semisynchronous replication plugin is installed.</p>

<p>Rsa_public_key</p>

<p>This variable is available if MySQL was compiled using OpenSSL (see Section 6.3.4, â€œSSL Library-Dependent Capabilitiesâ€). Its value is the public key used by the sha256_password authentication plugin for RSA key pair-based password exchange. The value is nonempty only if the server successfully initializes the private and public keys in the files named by the sha256_password_private_key_path and sha256_password_public_key_path system variables. The value of Rsa_public_key comes from the latter file.</p>

<p>For information about sha256_password, see Section 6.4.1.4, â€œSHA-256 Pluggable Authenticationâ€.</p>

<p>Select_full_join</p>

<p>The number of joins that perform table scans because they do not use indexes. If this value is not 0, you should carefully check the indexes of your tables.</p>

<p>Select_full_range_join</p>

<p>The number of joins that used a range search on a reference table.</p>

<p>Select_range</p>

<p>The number of joins that used ranges on the first table. This is normally not a critical issue even if the value is quite large.</p>

<p>Select_range_check</p>

<p>The number of joins without keys that check for key usage after each row. If this is not 0, you should carefully check the indexes of your tables.</p>

<p>Select_scan</p>

<p>The number of joins that did a full scan of the first table.</p>

<p>Slave_heartbeat_period</p>

<p>Shows the replication heartbeat interval (in seconds) on a replica.</p>

<p>Slave_last_heartbeat</p>

<p>Shows when the most recent heartbeat signal was received by a replica, as a TIMESTAMP value.</p>

<p>Slave_open_temp_tables</p>

<p>The number of temporary tables that the replica SQL thread currently has open. If the value is greater than zero, it is not safe to shut down the replica; see Section 17.4.1.29, â€œReplication and Temporary Tablesâ€.</p>

<p>Slave_received_heartbeats</p>

<p>This counter increments with each replication heartbeat received by a replica since the last time that the replica was restarted or reset, or a CHANGE MASTER TO statement was issued.</p>

<p>Slave_retried_transactions</p>

<p>The total number of times since startup that the replica SQL thread has retried transactions.</p>

<p>Slave_rows_last_search_algorithm_used</p>

<p>The search algorithm that was most recently used by this replica to locate rows for row-based replication. The result shows whether the replica used indexes, a table scan, or hashing as the search algorithm for the last transaction executed on any channel.</p>

<p>The method used depends on the setting for the slave_rows_search_algorithms system variable, and the keys that are available on the relevant table.</p>

<p>This variable is available only for debug builds of MySQL.</p>

<p>Slave_running</p>

<p>This is ON if this server is a replica that is connected to a replication source, and both the I/O and SQL threads are running; otherwise, it is OFF.</p>

<p>Slow_launch_threads</p>

<p>The number of threads that have taken more than slow_launch_time seconds to create.</p>

<p>Slow_queries</p>

<p>The number of queries that have taken more than long_query_time seconds. This counter increments regardless of whether the slow query log is enabled. For information about that log, see Section 5.4.5, â€œThe Slow Query Logâ€.</p>

<p>Sort_merge_passes</p>

<p>The number of merge passes that the sort algorithm has had to do. If this value is large, you should consider increasing the value of the sort_buffer_size system variable.</p>

<p>Sort_range</p>

<p>The number of sorts that were done using ranges.</p>

<p>Sort_rows</p>

<p>The number of sorted rows.</p>

<p>Sort_scan</p>

<p>The number of sorts that were done by scanning the table.</p>

<p>Ssl_accept_renegotiates</p>

<p>The number of negotiates needed to establish the connection.</p>

<p>Ssl_accepts</p>

<p>The number of accepted SSL connections.</p>

<p>Ssl_callback_cache_hits</p>

<p>The number of callback cache hits.</p>

<p>Ssl_cipher</p>

<p>The current encryption cipher (empty for unencrypted connections).</p>

<p>Ssl_cipher_list</p>

<p>The list of possible SSL ciphers (empty for non-SSL connections).</p>

<p>Ssl_client_connects</p>

<p>The number of SSL connection attempts to an SSL-enabled source.</p>

<p>Ssl_connect_renegotiates</p>

<p>The number of negotiates needed to establish the connection to an SSL-enabled source.</p>

<p>Ssl_ctx_verify_depth</p>

<p>The SSL context verification depth (how many certificates in the chain are tested).</p>

<p>Ssl_ctx_verify_mode</p>

<p>The SSL context verification mode.</p>

<p>Ssl_default_timeout</p>

<p>The default SSL timeout.</p>

<p>Ssl_finished_accepts</p>

<p>The number of successful SSL connections to the server.</p>

<p>Ssl_finished_connects</p>

<p>The number of successful replica connections to an SSL-enabled source.</p>

<p>Ssl_server_not_after</p>

<p>The last date for which the SSL certificate is valid. To check SSL certificate expiration information, use this statement:</p>

<p>mysql&gt; SHOW STATUS LIKE â€˜Ssl_server_not%â€™;
+â€”â€”â€”â€”â€”â€”â€”â€“+â€”â€”â€”â€”â€”â€”â€”â€”â€“+
| Variable_name         | Value                    |
+â€”â€”â€”â€”â€”â€”â€”â€“+â€”â€”â€”â€”â€”â€”â€”â€”â€“+
| Ssl_server_not_after  | Apr 28 14:16:39 2025 GMT |
| Ssl_server_not_before | May  1 14:16:39 2015 GMT |
+â€”â€”â€”â€”â€”â€”â€”â€“+â€”â€”â€”â€”â€”â€”â€”â€”â€“+
In MySQL 5.6, the value is empty unless the connection uses SSL.</p>

<p>Ssl_server_not_before</p>

<p>The first date for which the SSL certificate is valid.</p>

<p>In MySQL 5.6, the value is empty unless the connection uses SSL.</p>

<p>Ssl_session_cache_hits</p>

<p>The number of SSL session cache hits.</p>

<p>Ssl_session_cache_misses</p>

<p>The number of SSL session cache misses.</p>

<p>Ssl_session_cache_mode</p>

<p>The SSL session cache mode.</p>

<p>Ssl_session_cache_overflows</p>

<p>The number of SSL session cache overflows.</p>

<p>Ssl_session_cache_size</p>

<p>The SSL session cache size.</p>

<p>Ssl_session_cache_timeouts</p>

<p>The number of SSL session cache timeouts.</p>

<p>Ssl_sessions_reused</p>

<p>How many SSL connections were reused from the cache.</p>

<p>Ssl_used_session_cache_entries</p>

<p>How many SSL session cache entries were used.</p>

<p>Ssl_verify_depth</p>

<p>The verification depth for replication SSL connections.</p>

<p>Ssl_verify_mode</p>

<p>The verification mode used by the server for a connection that uses SSL. The value is a bitmask; bits are defined in the openssl/ssl.h header file:</p>

<h1 id="define-ssl_verify_none-----------------0x00">define SSL_VERIFY_NONE                 0x00</h1>
<h1 id="define-ssl_verify_peer-----------------0x01">define SSL_VERIFY_PEER                 0x01</h1>
<h1 id="define-ssl_verify_fail_if_no_peer_cert-0x02">define SSL_VERIFY_FAIL_IF_NO_PEER_CERT 0x02</h1>
<h1 id="define-ssl_verify_client_once----------0x04">define SSL_VERIFY_CLIENT_ONCE          0x04</h1>
<p>SSL_VERIFY_PEER indicates that the server asks for a client certificate. If the client supplies one, the server performs verification and proceeds only if verification is successful. SSL_VERIFY_CLIENT_ONCE indicates that a request for the client certificate is done only in the initial handshake.</p>

<p>Ssl_version</p>

<p>The SSL protocol version of the connection (for example, TLSv1). If the connection is not encrypted, the value is empty.</p>

<p>Table_locks_immediate</p>

<p>The number of times that a request for a table lock could be granted immediately.</p>

<p>Table_locks_waited</p>

<p>The number of times that a request for a table lock could not be granted immediately and a wait was needed. If this is high and you have performance problems, you should first optimize your queries, and then either split your table or tables or use replication.</p>

<p>Table_open_cache_hits</p>

<p>The number of hits for open tables cache lookups.</p>

<p>Table_open_cache_misses</p>

<p>The number of misses for open tables cache lookups.</p>

<p>Table_open_cache_overflows</p>

<p>The number of overflows for the open tables cache. This is the number of times, after a table is opened or closed, a cache instance has an unused entry and the size of the instance is larger than table_open_cache / table_open_cache_instances.</p>

<p>Tc_log_max_pages_used</p>

<p>For the memory-mapped implementation of the log that is used by mysqld when it acts as the transaction coordinator for recovery of internal XA transactions, this variable indicates the largest number of pages used for the log since the server started. If the product of Tc_log_max_pages_used and Tc_log_page_size is always significantly less than the log size, the size is larger than necessary and can be reduced. (The size is set by the â€“log-tc-size option. This variable is unused: It is unneeded for binary log-based recovery, and the memory-mapped recovery log method is not used unless the number of storage engines that are capable of two-phase commit and that support XA transactions is greater than one. (InnoDB is the only applicable engine.)</p>

<p>Tc_log_page_size</p>

<p>The page size used for the memory-mapped implementation of the XA recovery log. The default value is determined using getpagesize(). This variable is unused for the same reasons as described for Tc_log_max_pages_used.</p>

<p>Tc_log_page_waits</p>

<p>For the memory-mapped implementation of the recovery log, this variable increments each time the server was not able to commit a transaction and had to wait for a free page in the log. If this value is large, you might want to increase the log size (with the â€“log-tc-size option). For binary log-based recovery, this variable increments each time the binary log cannot be closed because there are two-phase commits in progress. (The close operation waits until all such transactions are finished.)</p>

<p>Threads_cached</p>

<p>The number of threads in the thread cache.</p>

<p>Threads_connected</p>

<p>The number of currently open connections.</p>

<p>Threads_created</p>

<p>The number of threads created to handle connections. If Threads_created is big, you may want to increase the thread_cache_size value. The cache miss rate can be calculated as Threads_created/Connections.</p>

<p>Threads_running</p>

<p>The number of threads that are not sleeping.</p>

<p>Uptime</p>

<p>The number of seconds that the server has been up.</p>

<p>Uptime_since_flush_status</p>

<p>The number of seconds since the most recent FLUSH STATUS statement.</p>

<p>https://dev.mysql.com/doc/refman/5.6/en/server-status-variables.html
<!-- more -->
mysql æ”¯æŒä¸‰ç§è¿æ¥æ–¹å¼</p>

<p>socket
named pipe
shared memory
named pipe å’Œ shared memory åªèƒ½åœ¨æœ¬åœ°è¿æ¥æ•°æ®åº“ï¼Œé€‚ç”¨åœºæ™¯è¾ƒå°‘</p>

<p>thread_cache
å‚æ•° thread_cache_size æ§åˆ¶äº† thread_cache çš„å¤§å°ï¼Œ è®¾ä¸º0æ—¶å…³é—­ thread_cacheï¼Œä¸ç¼“å­˜ç©ºé—²thread</p>

<p>mysql&gt; show status like â€˜Threads%â€™;
+â€”â€”â€”â€”â€”â€”-+â€”â€”-+
| Variable_name     | Value |
+â€”â€”â€”â€”â€”â€”-+â€”â€”-+
| Threads_cached    | 1     |
| Threads_connected | 1     |
| Threads_created   | 2     |
| Threads_running   | 1     |
+â€”â€”â€”â€”â€”â€”-+â€”â€”-+
4 rows in set (0.02 sec)</p>

<p>Threads_cachedï¼šç¼“å­˜çš„ threadï¼Œæ–°è¿æ¥å»ºç«‹æ—¶ï¼Œä¼˜å…ˆä½¿ç”¨cacheä¸­çš„thread</p>

<p>Threads_connectedï¼šå·²è¿æ¥çš„ thread</p>

<p>Threads_createdï¼šå»ºç«‹çš„ thread æ•°é‡</p>

<p>Threads_runningï¼šrunningçŠ¶æ€çš„ thread æ•°é‡</p>

<p>Threads_created = Threads_cached + Threads_connected</p>

<p>Threads_running &lt;= Threads_connected</p>

<p>MySQL å»ºç«‹æ–°è¿æ¥éå¸¸æ¶ˆè€—èµ„æºï¼Œé¢‘ç¹ä½¿ç”¨çŸ­è¿æ¥ï¼Œåˆæ²¡æœ‰å…¶ä»–ç»„ä»¶å®ç°è¿æ¥æ± æ—¶ï¼Œå¯ä»¥é€‚å½“æé«˜ thread_cache_sizeï¼Œé™ä½æ–°å»ºè¿æ¥çš„å¼€é”€</p>

<p>.æ¯ä¸ªè¿æ¥çš„é™åˆ¶
é™¤äº†å‚æ•° max_user_connections é™åˆ¶æ¯ä¸ªç”¨æˆ·çš„æœ€å¤§è¿æ¥æ•°ï¼Œè¿˜å¯ä»¥å¯¹æ¯ä¸ªç”¨æˆ·åˆ¶å®šæ›´ç»†è‡´çš„é™åˆ¶</p>

<p>ä»¥ä¸‹å››ä¸ªé™åˆ¶ä¿å­˜åœ¨mysql.userè¡¨ä¸­</p>

<p>MAX_QUERIES_PER_HOUR æ¯å°æ—¶æœ€å¤§è¯·æ±‚æ•°ï¼ˆè¯­å¥æ•°é‡ï¼‰
MAX_UPDATES_PER_HOUR æ¯å°æ—¶æœ€å¤§æ›´æ–°æ•°ï¼ˆæ›´æ–°è¯­å¥çš„æ•°é‡ï¼‰
MAX_CONNECTIONS_PER_HOUR æ¯å°æ—¶æœ€å¤§è¿æ¥æ•°
MAX_USER_CONNECTIONS è¿™ä¸ªç”¨æˆ·çš„æœ€å¤§è¿æ¥æ•°</p>

<p>http://mysql.taobao.org/monthly/2018/02/07/</p>

<p>å®¢æˆ·è´­ä¹°çš„DBè¿æ¥æ•°æ˜¯è¿™ä¸ªã€‚max_connectionsï¼Œå…è®¸åŒæ—¶è¿æ¥DBçš„å®¢æˆ·ç«¯çš„æœ€å¤§çº¿ç¨‹æ•°ã€‚å¦‚æœå®¢æˆ·ç«¯çš„è¿æ¥æ•°è¶…è¿‡äº†max_connections,åº”ç”¨å°±ä¼šæ”¶åˆ°â€œtoo many connectionsâ€çš„é”™è¯¯ã€‚</p>

<p>å·²ç»åˆ›å»ºçš„è¿æ¥æ•°
Threads_createdæ˜¯ä¸ºå¤„ç†è¿æ¥è€Œåˆ›å»ºçš„çº¿ç¨‹æ•°ã€‚å†æ˜ç¡®ä¸€ç‚¹æ¥è¯´æ˜¯è¿æ¥åˆ°DBçš„ï¼Œå®¢æˆ·ç«¯çš„çº¿ç¨‹æ•°ã€‚å®ƒåŒ…å«Threads_runningã€‚ å¦‚æœThreads_createdå¾ˆå¤§ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´thread_cache_sizeã€‚
çº¿ç¨‹cacheå‘½ä¸­ç‡=Threads_created/Connectionsï¼Œcacheå‘½ä¸­ç‡å½“ç„¶è¶Šå¤§è¶Šå¥½ï¼Œå¦‚æœå‘½ä¸­ç‡è¾ƒä½ï¼Œå¯ä»¥è€ƒè™‘å¢åŠ thread_cache_sizeã€‚</p>

<p>https://developer.aliyun.com/article/683460</p>

<p>çº¿ç¨‹çš„çŠ¶æ€ä¿¡æ¯ï¼š</p>

<p>å·²ç»åˆ›å»ºçš„è¿æ¥æ•°
Threads_createdæ˜¯ä¸ºå¤„ç†è¿æ¥è€Œåˆ›å»ºçš„çº¿ç¨‹æ•°ã€‚å†æ˜ç¡®ä¸€ç‚¹æ¥è¯´æ˜¯è¿æ¥åˆ°DBçš„ï¼Œå®¢æˆ·ç«¯çš„çº¿ç¨‹æ•°ã€‚å®ƒåŒ…å«Threads_runningã€‚ å¦‚æœThreads_createdå¾ˆå¤§ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´thread_cache_sizeã€‚</p>

<p>çº¿ç¨‹cacheå‘½ä¸­ç‡=Threads_created/Connectionsï¼Œcacheå‘½ä¸­ç‡å½“ç„¶è¶Šå¤§è¶Šå¥½ï¼Œå¦‚æœå‘½ä¸­ç‡è¾ƒä½ï¼Œå¯ä»¥è€ƒè™‘å¢åŠ thread_cache_sizeã€‚</p>

<p>å·²ç»è¿æ¥çš„è¿æ¥æ•°
Thread_connectedå½“å‰æ‰“å¼€çš„è¿æ¥æ•°ã€‚</p>

<p>æ´»è·ƒè¿æ¥æ•°
Threads_runningå®˜æ–¹çš„è¯´æ³•æ˜¯â€œæ²¡æœ‰sleepçš„çº¿ç¨‹æ•°â€ã€‚é¡¾åæ€ä¹‰æ˜¯ï¼šåœ¨DBç«¯æ­£åœ¨æ‰§è¡Œçš„å®¢æˆ·ç«¯çº¿ç¨‹æ€»æ•°ã€‚Serverç«¯ä¿æŒè¿™äº›è¿æ¥åŒæ—¶å®¢æˆ·ç«¯ç­‰å¾…å›å¤ã€‚æœ‰äº›çº¿ç¨‹å¯èƒ½æ¶ˆè€—CPUæˆ–è€…IOï¼Œæœ‰äº›çº¿ç¨‹å¯èƒ½å•¥ä¹Ÿæ²¡åšå•çº¯ç­‰è¡¨é”æˆ–è¡Œé”é‡Šæ”¾ã€‚å½“DBæ‰§è¡Œå®Œè¿™ä¸ªçº¿ç¨‹ï¼Œå®¢æˆ·ç«¯æ”¶åˆ°å›å¤ï¼Œçº¿ç¨‹çš„çŠ¶æ€å°±ä¼šä»â€runningâ€ å˜æˆ â€œconnectedâ€.</p>

<p>å¦‚æœå‘ç°æ´»è·ƒé“¾æ¥æ•°çªç„¶å¢é«˜ï¼Œé€šå¸¸æ˜¯ä»¥ä¸‹åŸå› ï¼š</p>

<p>åº”ç”¨ç¼“å­˜å¤±æ•ˆ
çªå‘æµé‡</p>

<p>https://cloud.tencent.com/developer/article/1816132</p>

<p>æŸ¥çœ‹processlistè¿™ä¸ªè¡¨ï¼Œè¡¨ç»“æ„
IDï¼šçº¿ç¨‹IDï¼Œè¿™ä¸ªä¿¡æ¯å¯¹ç»Ÿè®¡æ¥è¯´æ²¡æœ‰å¤ªå¤§ä½œç”¨</p>

<p>USERï¼šè¿æ¥ä½¿ç”¨çš„è´¦å·ï¼Œè¿™ä¸ªæ˜¯ä¸€ä¸ªç»Ÿè®¡ç»´åº¦ï¼Œç”¨äºç»Ÿè®¡æ¥è‡ªæ¯ä¸ªè´¦å·çš„è¿æ¥æ•°</p>

<p>HOSTï¼šè¿æ¥å®¢æˆ·ç«¯çš„IP/hostname+ç½‘ç»œç«¯å£å·ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªç»Ÿè®¡ç»´åº¦ï¼Œç”¨äºç¡®å®šå‘èµ·è¿æ¥çš„å®¢æˆ·ç«¯</p>

<p>DBï¼šè¿æ¥ä½¿ç”¨çš„default databaseï¼ŒDBé€šå¸¸å¯¹åº”å…·ä½“æœåŠ¡ï¼Œå¯ä»¥ç”¨äºåˆ¤æ–­æœåŠ¡çš„è¿æ¥åˆ†å¸ƒï¼Œè¿™ç®—ä¸€ä¸ªç»Ÿè®¡ç»´åº¦</p>

<p>COMMANDï¼šè¿æ¥çš„åŠ¨ä½œï¼Œå®é™…ä¸Šæ˜¯è¯´è¿æ¥å¤„äºå“ªä¸ªé˜¶æ®µï¼Œå¸¸è§çš„æœ‰Sleepã€Queryã€Connectã€Statisticsç­‰ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªç»Ÿè®¡ç»´åº¦ï¼Œä¸»è¦ç”¨äºåˆ¤æ–­è¿æ¥æ˜¯å¦å¤„äºç©ºé—²çŠ¶æ€</p>

<p>TIMEï¼šè¿æ¥å¤„äºå½“å‰çŠ¶æ€çš„æ—¶é—´ï¼Œå•ä½æ˜¯sï¼Œè¿™ä¸ªåœ¨åé¢è¿›è¡Œåˆ†æï¼Œæš‚ä¸ç®—åœ¨è¿æ¥çŠ¶æ€çš„ç»Ÿè®¡ç»´åº¦ä¸­</p>

<p>STATEï¼šè¿æ¥çš„çŠ¶æ€ï¼Œè¡¨ç¤ºå½“å‰MySQlè¿æ¥æ­£åœ¨åšä»€ä¹ˆæ“ä½œï¼Œè¿™ç®—ä¸€ä¸ªç»Ÿè®¡ç»´åº¦ï¼Œå¯èƒ½çš„å€¼ä¹Ÿæ¯”è¾ƒå¤šï¼Œè¯¦ç»†å¯ä»¥æŸ¥é˜…å®˜æ–¹æ–‡æ¡£</p>

<p>INFOï¼šè¿æ¥æ­£åœ¨æ‰§è¡Œçš„SQLï¼Œè¿™ä¸ªåœ¨ä¸‹ä¸€èŠ‚åˆ†æï¼Œæš‚ä¸ç®—åœ¨è¿æ¥çŠ¶æ€çš„ç»Ÿè®¡ç»´åº¦ä¸­</p>

<p>https://dbaplus.cn/news-11-1396-1.html</p>

<p>mysql -uroot -h127.0.0.1 -eâ€use svc_t; show processlist;â€ |grep -v Sleep |wc -l
show status like â€˜Table%â€™;
mysql -uroot -h127.0.0.1 -eâ€use svc_t;show status like â€˜Table%â€™;â€
mysql -uroot -h127.0.0.1 -eâ€use svc_t;show status like â€˜%lock%â€™;â€
mysql -uroot -h127.0.0.1 -eâ€use svc_t;SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; â€œ
mysql -uroot -h127.0.0.1 -eâ€use svc_t;SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;  â€œ
mysql -uroot -h127.0.0.1 -eâ€use svc_t;show variables like â€˜%timeout%â€™; â€œ</p>

<p>åå°çº¿ç¨‹
é»˜è®¤æƒ…å†µä¸‹ï¼ŒInnoDB å­˜å‚¨å¼•æ“æœ‰ 13 ä¸ªåå°çº¿ç¨‹ï¼š</p>

<p>ä¸€ä¸ª master çº¿ç¨‹</p>

<p>ä¸€ä¸ªé”ç›‘æ§çº¿ç¨‹</p>

<p>ä¸€ä¸ªé”™è¯¯ç›‘æ§çº¿ç¨‹</p>

<p>åä¸ª IO çº¿ç¨‹</p>

<p>æ’å…¥ç¼“å­˜çº¿ç¨‹</p>

<p>æ—¥å¿—çº¿ç¨‹</p>

<p>è¯»çº¿ç¨‹ï¼ˆé»˜è®¤ 4 ä¸ªï¼‰</p>

<p>å†™çº¿ç¨‹ï¼ˆé»˜è®¤ 4 ä¸ªï¼‰</p>

<p>å†…å­˜æ± 
InnoDB å­˜å‚¨å¼•æ“çš„å†…å­˜æ± åŒ…å«ï¼šç¼“å†²æ± ã€æ—¥å¿—ç¼“å­˜æ± ã€é¢å¤–å†…å­˜æ± ã€‚è¿™äº›å†…å­˜çš„å¤§å°åˆ†åˆ«ç”±é…ç½®æ–‡ä»¶ä¸­çš„å‚æ•°å†³å®šã€‚å…¶ä¸­å æ¯”æœ€å¤§çš„æ˜¯ç¼“å†²æ± ï¼Œé‡Œé¢åŒ…å«äº†æ•°æ®ç¼“å­˜é¡µã€ç´¢å¼•ã€æ’å…¥ç¼“å­˜ã€è‡ªé€‚åº”å“ˆå¸Œç´¢å¼•ã€é”ä¿¡æ¯å’Œæ•°æ®å­—å…¸ã€‚InnoDB ä¼šåœ¨è¯»å–æ•°æ®åº“æ•°æ®çš„æ—¶å€™ï¼Œå°†æ•°æ®ç¼“å­˜åˆ°ç¼“å†²æ± ä¸­ï¼Œè€Œåœ¨ä¿®æ”¹æ•°æ®çš„æ—¶å€™ï¼Œä¼šå…ˆæŠŠç¼“å†²æ± ä¸­çš„æ•°æ®ä¿®æ”¹æ‰ï¼Œä¸€æ—¦ä¿®æ”¹è¿‡çš„æ•°æ®é¡µå°±ä¼šè¢«æ ‡è®°ä¸ºè„é¡µï¼Œè€Œè„é¡µåˆ™ä¼šè¢« master çº¿ç¨‹æŒ‰ç…§ä¸€å®šçš„é¢‘ç‡åˆ·æ–°åˆ°ç£ç›˜ä¸­ã€‚æ—¥å¿—ç¼“å­˜åˆ™æ˜¯ç¼“å­˜äº†redo-log ä¿¡æ¯ï¼Œç„¶åå†åˆ·æ–°åˆ° redo-log æ–‡ä»¶ä¸­ã€‚é¢å¤–å†…å­˜æ± åˆ™æ˜¯åœ¨å¯¹ä¸€äº›æ•°æ®ç»“æ„æœ¬èº«åˆ†é…å†…å­˜æ—¶ä¼šä»é¢å¤–å†…å­˜æ± ä¸­ç”³è¯·å†…å­˜ï¼Œå½“è¯¥åŒºåŸŸå†…å­˜ä¸è¶³åˆ™ä¼šåˆ°ç¼“å†²æ± ä¸­ç”³è¯·ã€‚</p>

<p>Master Thread
InnoDB å­˜å‚¨å¼•æ“çš„ä¸»è¦å·¥ä½œéƒ½åœ¨ä¸€ä¸ªå•ç‹¬çš„ Master Thread ä¸­å®Œæˆï¼Œå…¶å†…éƒ¨ç”±å››ä¸ªå¾ªç¯ä½“æ„æˆï¼šä¸»å¾ªç¯ï¼ˆ loop ï¼‰ã€åå°å¾ªç¯ï¼ˆ background loop ï¼‰ã€åˆ·æ–°å¾ªç¯ï¼ˆ flush loop ï¼‰ã€æš‚åœå¾ªç¯ï¼ˆ suspend loop ï¼‰
https://www.pianshen.com/article/476679761/</p>

<p>ä¸€ã€å…³äºä¸€ä¸ªSQLçš„ç®€å•çš„å·¥ä½œè¿‡ç¨‹
1ã€å·¥ä½œå‰ææè¿°
ã€€ã€€1ã€å¯åŠ¨MySQLï¼Œåœ¨å†…å­˜ä¸­åˆ†é…ä¸€ä¸ªå¤§ç©ºé—´innodb_buffer_pool(è¿˜æœ‰log_buffer)
ã€€ã€€2ã€å¤šç”¨æˆ·çº¿ç¨‹è¿æ¥MySQLï¼Œä»å†…å­˜åˆ†é…ç”¨æˆ·å·¥ä½œç©ºé—´(å…¶ä¸­æ’åºç©ºé—´)
ã€€ã€€3ã€ç£ç›˜ä¸Šæœ‰æ•°æ®åº“æ–‡ä»¶ã€ib_logfileã€tmpç›®å½•ã€undo
2ã€SQLçš„ç®€æ˜“æµç¨‹
ã€€ã€€1ã€DQLæ“ä½œ
ã€€ã€€ã€€ã€€1ã€é¦–å…ˆè¿›è¡Œå†…å­˜è¯»
ã€€ã€€ã€€ã€€2ã€å¦‚æœbuffer poolä¸­æ²¡æœ‰æ‰€éœ€æ•°æ®ï¼Œå°±è¿›è¡Œç‰©ç†è¯»
ã€€ã€€ã€€ã€€3ã€ç‰©ç†è¯»æ•°æ®è¯»å…¥buffer poolï¼Œå†è¿”å›ç»™ç”¨æˆ·å·¥ä½œç©ºé—´
ã€€ã€€2ã€DMLæ“ä½œ(ä¾‹update)
ã€€ã€€ã€€ã€€1ã€å†…å­˜è¯»ï¼Œç„¶åè¿›è¡Œç‰©ç†è¯»ï¼Œè¯»å–æ‰€éœ€ä¿®æ”¹çš„æ•°æ®è¡Œ
ã€€ã€€ã€€ã€€2ã€ä»ç£ç›˜è°ƒå…¥undoé¡µåˆ°buffer poolä¸­
ã€€ã€€ã€€ã€€3ã€ä¿®æ”¹å‰çš„æ•°æ®å­˜å…¥undoé¡µé‡Œï¼Œäº§ç”Ÿredo
ã€€ã€€ã€€ã€€4ã€ä¿®æ”¹æ•°æ®è¡Œ(buffer poolä¸­æ•°æ®é¡µæˆè„é¡µ)ï¼Œäº§ç”Ÿredo
ã€€ã€€ã€€ã€€5ã€ç”Ÿæˆçš„redoå…ˆæ˜¯å­˜äºç”¨æˆ·å·¥ä½œç©ºé—´ï¼Œæ‹©æœºæ‹·å…¥log_bufferä¸­
ã€€ã€€ã€€ã€€6ã€logçº¿ç¨‹ä¸æ–­çš„å°†log_bufferä¸­çš„è®°å½•å†™å…¥redo logfileä¸­
ã€€ã€€ã€€ã€€7ã€ä¿®æ”¹å®Œæ‰€æœ‰æ•°æ®è¡Œï¼Œæäº¤äº‹åŠ¡ï¼Œåˆ»æ„å†è§¦å‘ä¸€ä¸‹logçº¿ç¨‹
ã€€ã€€ã€€ã€€8ã€å¾…log_bufferä¸­çš„ç›¸å…³ä¿¡æ¯éƒ½å†™å®Œï¼Œå“åº”äº‹åŠ¡æäº¤æˆåŠŸ
ã€€ã€€è‡³æ­¤ï¼Œæ—¥å¿—å†™å…¥ç£ç›˜ï¼Œå†…å­˜è„å—è¿˜åœ¨buffer poolä¸­(åå°å‘¨æœŸå†™å…¥ç£ç›˜ï¼Œé‡Šæ”¾buffer poolç©ºé—´)ã€‚
ã€€ã€€
ã€€ã€€MySQLçš„å·¥ä½œæœºåˆ¶æ˜¯å•è¿›ç¨‹å¤šçº¿ç¨‹ï¼šIOçº¿ç¨‹=ä¸€ä¸ªlogçº¿ç¨‹+å››ä¸ªreadçº¿ç¨‹+å››ä¸ªwriteçº¿ç¨‹
ã€€ã€€
ã€€ã€€1ã€è¯»æ“ä½œï¼šinnodb_read_io_threads
ã€€ã€€1ã€å‘èµ·è€…ï¼šç”¨æˆ·çº¿ç¨‹å‘èµ·è¯»è¯·æ±‚
ã€€ã€€2ã€å®Œæˆè€…ï¼šè¯»çº¿ç¨‹æ‰§è¡Œè¯·æ±‚é˜Ÿåˆ—ä¸­çš„è¯»è¯·æ±‚æ“ä½œ
ã€€ã€€3ã€å¦‚ä½•è°ƒæ•´è¯»çº¿ç¨‹çš„æ•°é‡
ã€€ã€€2ã€å†™æ“ä½œï¼šinnodb_write_io_threads
ã€€ã€€1ã€å‘èµ·è€…ï¼špage_cleanerçº¿ç¨‹å‘èµ·
ã€€ã€€2ã€å®Œæˆè€…ï¼šå†™çº¿ç¨‹æ‰§è¡Œè¯·æ±‚é˜Ÿåˆ—ä¸­çš„å†™è¯·æ±‚æ“ä½œ
ã€€ã€€3ã€å¦‚ä½•è°ƒæ•´å†™çº¿ç¨‹çš„æ•°é‡
ã€€ã€€https://www.cnblogs.com/geaozhang/p/7214257.html
ã€€ã€€
ã€€ã€€
 Killing Threads (PROCESSLIST, KILL)
 Killing threads (KILL)
Once youâ€™ve identified the problem thread, you can use the KILL command to kill it. There are basic two variations on the KILL command.</p>

<h1 id="kill-the-entire-connection">Kill the entire connection.</h1>
<p>KILL thread_id;
KILL CONNECTION thread_id;</p>

<h1 id="terminate-the-currently-executing-statement-but-leave-the-connection-intact">Terminate the currently executing statement, but leave the connection intact.</h1>
<p>KILL QUERY thread_id;
https://oracle-base.com/articles/mysql/mysql-killing-threads</p>

<p>27.12.21.5 The processlist Table
ID</p>

<p>The connection identifier. This is the same value displayed in the Id column of the SHOW PROCESSLIST statement, displayed in the PROCESSLIST_ID column of the Performance Schema threads table, and returned by the CONNECTION_ID() function within the thread.</p>

<p>USER</p>

<p>The MySQL user who issued the statement. A value of system user refers to a nonclient thread spawned by the server to handle tasks internally, for example, a delayed-row handler thread or an I/O or SQL thread used on replica hosts. For system user, there is no host specified in the Host column. unauthenticated user refers to a thread that has become associated with a client connection but for which authentication of the client user has not yet occurred. event_scheduler refers to the thread that monitors scheduled events (see Section 25.4, â€œUsing the Event Schedulerâ€).</p>

<p>Note
A USER value of system user is distinct from the SYSTEM_USER privilege. The former designates internal threads. The latter distinguishes the system user and regular user account categories (see Section 6.2.11, â€œAccount Categoriesâ€).</p>

<p>HOST</p>

<p>The host name of the client issuing the statement (except for system user, for which there is no host). The host name for TCP/IP connections is reported in host_name:client_port format to make it easier to determine which client is doing what.</p>

<p>DB</p>

<p>The default database for the thread, or NULL if none has been selected.</p>

<p>COMMAND</p>

<p>The type of command the thread is executing on behalf of the client, or Sleep if the session is idle. For descriptions of thread commands, see Section 8.14, â€œExamining Server Thread (Process) Informationâ€. The value of this column corresponds to the COM_xxx commands of the client/server protocol and Com_xxx status variables. See Section 5.1.10, â€œServer Status Variablesâ€</p>

<p>TIME</p>

<p>The time in seconds that the thread has been in its current state. For a replica SQL thread, the value is the number of seconds between the timestamp of the last replicated event and the real time of the replica host. See Section 17.2.3, â€œReplication Threadsâ€.</p>

<p>STATE</p>

<p>An action, event, or state that indicates what the thread is doing. For descriptions of STATE values, see Section 8.14, â€œExamining Server Thread (Process) Informationâ€.</p>

<p>Most states correspond to very quick operations. If a thread stays in a given state for many seconds, there might be a problem that needs to be investigated.</p>

<p>INFO</p>

<p>The statement the thread is executing, or NULL if it is executing no statement. The statement might be the one sent to the server, or an innermost statement if the statement executes other statements. For example, if a CALL statement executes a stored procedure that is executing a SELECT statement, the INFO value shows the SELECT statement.</p>

<p>https://docs.oracle.com/cd/E17952_01/mysql-8.0-en/performance-schema-processlist-table.html#function_connection-id
https://docs.oracle.com/cd/E17952_01/mysql-8.0-en/performance-schema-processlist-table.html</p>

<p>å¼€å¯æ•°æ®åº“çš„eventæ‰§è¡Œè°ƒåº¦</p>

<blockquote>
  <p>æŸ¥çœ‹æ˜¯å¦å¼€å¯å®šæ—¶å™¨</p>
</blockquote>

<p>mysql&gt; show variables like â€˜%event_scheduler%â€™;
+â€”â€”â€”â€”â€”â€“+â€”â€”-+
| Variable_name   | Value |
+â€”â€”â€”â€”â€”â€“+â€”â€”-+
| event_scheduler | OFF   |
+â€”â€”â€”â€”â€”â€“+â€”â€”-+
https://www.cnblogs.com/geaozhang/p/6821692.html</p>

<p>How to share mysql connection between http goroutines?
The database/sql package manages the connection pooling automatically for you.</p>

<p>sql.Open(..) returns a handle which represents a connection pool, not a single connection. The database/sql package automatically opens a new connection if all connections in the pool are busy.</p>

<p>Applied to your code this means, that you just need to share the db-handle and use it in the HTTP handlers:</p>

<p>https://stackoverflow.com/questions/17376207/how-to-share-mysql-connection-between-http-goroutines</p>

<p>In Go 1.1 or newer, you can use db.SetMaxIdleConns(N) to limit the number of idle connections in the pool. This doesnâ€™t limit the pool size, though.
In Go 1.2.1 or newer, you can use db.SetMaxOpenConns(N) to limit the number of total open connections to the database. Unfortunately, a deadlock bug (fix) prevents db.SetMaxOpenConns(N) from safely being used in 1.2.</p>

<p>http://go-database-sql.org/connection-pool.html
SetMaxOpenConnsç”¨äºè®¾ç½®æœ€å¤§æ‰“å¼€çš„è¿æ¥æ•°ï¼Œé»˜è®¤å€¼ä¸º0è¡¨ç¤ºä¸é™åˆ¶ã€‚
SetMaxIdleConnsç”¨äºè®¾ç½®é—²ç½®çš„è¿æ¥æ•°ã€‚</p>

<p>è®¾ç½®æœ€å¤§çš„è¿æ¥æ•°ï¼Œå¯ä»¥é¿å…å¹¶å‘å¤ªé«˜å¯¼è‡´è¿æ¥mysqlå‡ºç°too many connectionsçš„é”™è¯¯ã€‚è®¾ç½®é—²ç½®çš„è¿æ¥æ•°åˆ™å½“å¼€å¯çš„ä¸€ä¸ªè¿æ¥ä½¿ç”¨å®Œæˆåå¯ä»¥æ”¾åœ¨æ± é‡Œç­‰å€™ä¸‹ä¸€æ¬¡ä½¿ç”¨ã€‚</p>

<p>https://cloud.tencent.com/developer/article/1071721
http://hopehook.com/blog/golang_db_pool</p>

<p>MySQLçš„MaxIdleConnsä¸åˆç†ï¼Œä¼šå˜æˆçŸ­è¿æ¥
æ˜¯æˆ‘ä»¬Go MySQLå®¢æˆ·ç«¯æœ€é‡è¦çš„é…ç½®ã€‚</p>

<p>maxIdleCount æœ€å¤§ç©ºé—²è¿æ¥æ•°ï¼Œé»˜è®¤ä¸é…ç½®ï¼Œæ˜¯2ä¸ªæœ€å¤§ç©ºé—²è¿æ¥</p>

<p>maxOpen æœ€å¤§è¿æ¥æ•°ï¼Œé»˜è®¤ä¸é…ç½®ï¼Œæ˜¯ä¸é™åˆ¶æœ€å¤§è¿æ¥æ•°</p>

<p>maxLifetime è¿æ¥æœ€å¤§å­˜æ´»æ—¶é—´</p>

<p>maxIdleTime ç©ºé—²è¿æ¥æœ€å¤§å­˜æ´»æ—¶é—´
å½“çªå‘æµé‡æƒ…å†µä¸‹ï¼Œç”±äºè¯·æ±‚é‡çº§è¿‡å¤§ï¼Œè¶…è¿‡äº†æœ€å¤§ç©ºé—²è¿æ¥æ•°çš„è´Ÿè½½ï¼Œé‚£ä¹ˆæ–°çš„è¿æ¥åœ¨æ”¾å…¥è¿æ¥æ± çš„æ—¶å€™ï¼Œä¼šè¢«å…³é—­ï¼Œå°†è¿æ¥å˜æˆçŸ­è¿æ¥ï¼Œå¯¼è‡´æœåŠ¡æ€§èƒ½è¿›ä¸€æ­¥æ¶åŒ–ã€‚ä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œä¸‹é¢åˆ—ä¸¾äº†ï¼Œå¯ä»¥ä¼˜åŒ–çš„æªæ–½ã€‚</p>

<p>æå‰å°†maxIdleConnsè®¾å¤§ï¼Œé¿å…å‡ºç°çŸ­è¿æ¥</p>

<p>åšå¥½mysqlè¯»å†™åˆ†ç¦»</p>

<p>æå‡mysqlçš„ååé‡ï¼šç²¾ç®€è¿”å›å­—æ®µï¼Œæ²¡å¿…è¦çš„å­—æ®µä¸è¦è¿”å›ï¼Œèƒ½å¤Ÿå¤Ÿå¿«å¤ç”¨è¿æ¥</p>

<p>ååé‡çš„åŒ…å°½é‡ä¸è¦å¤ªå¤§ï¼Œé¿å…åˆ†åŒ…</p>

<p>ä¼˜åŒ–è¿æ¥æ± ï¼Œå½“å®¢æˆ·ç«¯åˆ°MySQLçš„è¿æ¥æ•°å¤§äºæœ€å¤§ç©ºé—²è¿æ¥çš„æ—¶å€™ï¼Œå…³é—­èƒ½å¤Ÿåšä¸€ä¸‹å»¶è¿Ÿï¼ˆå®˜æ–¹ä¸æ”¯æŒï¼Œä¼°è®¡åªèƒ½è‡ªå·±å®ç°ï¼‰</p>

<p>è¯»è¯·æ±‚çš„æœ€å¥½ä¸è¦æ”¾MySQLé‡Œï¼Œå°½é‡æ”¾redisé‡Œ
https://blog.51cto.com/u_15127567/2714595
https://developpaper.com/golang-connection-pool-you-must-understand/</p>
:ET