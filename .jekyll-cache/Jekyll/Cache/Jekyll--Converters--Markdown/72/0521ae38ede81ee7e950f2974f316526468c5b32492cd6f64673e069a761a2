I"ó<p>å¦‚ä½•ç”¨charles æŠ“æˆ‘ä»¬è‡ªå·±goä»£ç çš„è¯·æ±‚åŒ…ï¼Ÿ
æˆ‘ä»¬å¯ä»¥ç”¨charles æŠ“æ‰‹æœºä¸Šçš„åŒ…ï¼Œå› ä¸ºæ‰‹æœºå®‰è£…è¯ä¹¦ï¼Œä¸”åˆ¶å®šäº†ä»£ç†åœ°å€ä¸ºcharles çš„ä»£ç†åœ°å€ã€‚æˆ‘ä»¬å¯ä»¥ç”¨charlesæŠ“æµè§ˆå™¨åŒ…ï¼Œå› ä¸ºæˆ‘ä»¬é…ç½®äº†æµè§ˆå™¨çš„hhtpï¼Œhttps ä»£ç†ã€‚</p>

<p>æˆ‘ä»¬æ‰‹å†™çš„httpå®¢æˆ·ç«¯æ€ä¹ˆæŠ“åŒ…å‘¢ï¼Œè¿™å°±éœ€è¦httpproxyï¼Œgoé‡Œé¢å®ç°å¦‚ä¸‹</p>

<p>import (
	â€œnet/httpâ€
	u â€œnet/urlâ€
)</p>

<p>// http GET ä»£ç†
func HttpGetFromProxy(url,proxyURL string) (*http.Response,error) {
	req,_ := http.NewRequest(â€œGETâ€,url,nil)
	proxy,err := u.Parse(â€œhttp://127.0.0.1:8888â€)//charles ä»£ç†ç«¯å£
	if err != nil {
		return nil,err
	}
	client := &amp;http.Client{
		Transport: &amp;http.Transport{
			Proxy : http.ProxyURL(proxy),},}
	return client.Do(req)
}
<!-- more -->
åå‘ä»£ç†å¦‚ä½•å®ç°å‘¢
goè¯­è¨€è‡ªå¸¦åŒ…ReverseProxy å®ç°äº†proxyçš„åŠŸèƒ½ã€‚</p>

<p>ä½†æˆ‘å¸Œæœ›proxyè¿›ç¨‹èƒ½å¤Ÿåœ¨ä»£ç†çš„åŒæ—¶ï¼Œå®Œæ•´çš„æŠŠè¯·æ±‚å’Œè¯·æ±‚ä½“è®°å½•åœ¨æ—¥å¿—é‡Œã€‚</p>

<p>ä»…ä½¿ç”¨ReverseProxy åŒ…çš„è¯ï¼Œuriè®°å½•æ²¡é—®é¢˜ï¼Œä½†bodyåªèƒ½è¢«è¯»å–ä¸€æ¬¡ï¼Œproxyå°†bodyè®°å½•åœ¨æ—¥å¿—ï¼Œé‚£ä¹ˆbackendå°±æ²¡åŠæ³•å†è¯»bodyäº†ã€‚</p>

<p>å› æ­¤éœ€è¦proxyè¿›ç¨‹è¯»è¿‡ä¸€æ¬¡bodyä¹‹åï¼ŒæŠŠæ•°æ®é‡æ–°å†™å›å»ï¼Œç•™ç»™backendè¯»å–ã€‚</p>

<p>func (h *handle) ServeHTTP(w http.ResponseWriter, r *http.Request) {
        backend, err := url.Parse(â€œhttp://â€ + h.backendHost)
        if err != nil {
                return
        }
        body, err := ioutil.ReadAll(r.Body)
        defer r.Body.Close()
        if err != nil {
                log.Println(err.Error())
                return
        }
        r.Body = ioutil.NopCloser(bytes.NewBuffer(body))
        proxy := httputil.NewSingleHostReverseProxy(backend)
}</p>
:ET