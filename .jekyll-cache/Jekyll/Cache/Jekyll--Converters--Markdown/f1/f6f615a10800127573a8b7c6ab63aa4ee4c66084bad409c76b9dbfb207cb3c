I"è,<p>https://golang.org/pkg/net/http/httptest/
https://ieftimov.com/post/testing-in-go-testing-http-servers/
https://ieftimov.com/post/testing-in-go-subtests/</p>

<p>net/http/httptestå°±æ˜¯åŸç”Ÿåº“é‡Œé¢æä¾›MockæœåŠ¡çš„åŒ…ï¼Œä½¿ç”¨å®ƒä¸ç”¨çœŸæ­£çš„å¯åŠ¨ä¸€ä¸ªhttp serverï¼ˆäº¦æˆ–è€…è¯·æ±‚ä»»æ„çš„serverï¼‰ï¼Œè€Œä¸”åˆ›å»ºæ–¹æ³•éå¸¸ç®€å•ã€‚
<!-- more -->
Golang testingåŸºç¡€
Goæä¾›äº†ä¸€ä¸ªtestingåŒ…æ¥å†™å•å…ƒæµ‹è¯•ã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸ªæ–‡ä»¶å«person.goï¼Œé‚£ä¹ˆæˆ‘ä»¬çš„æµ‹è¯•æ–‡ä»¶å°±éœ€è¦æ˜æ˜ä¸ºperson_test.goï¼š</p>

<p>package person</p>

<p>import (
    â€œtestingâ€
)</p>

<p>func TestPublishUnreachable(t *testing.T) {
    api := â€œhttp://localhost:8090â€
    _, err := GetInfo(api)
    if err != nil {
        t.Errorf(â€œGetInfo() return an errorâ€)
    }
}</p>

<p>æ³¨ï¼š</p>
<blockquote>
  <p>æµ‹è¯•å‡½æ•°ä»¥Test*å¼€å¤´ã€‚</p>
</blockquote>

<blockquote>
  <p>æµ‹è¯•å‡½æ•°å°†*testing.Tä½œä¸ºå‚æ•°ï¼Œå¯ä»¥åœ¨å¤±è´¥çš„æƒ…å†µä¸‹ä½¿ç”¨Errorf()æ–¹æ³•ã€‚</p>
</blockquote>

<blockquote>
  <p>åœ¨åŒ…å†…ä½¿ç”¨go test -væ¥è¿è¡Œå•å…ƒæµ‹è¯•ã€‚</p>
</blockquote>

<p>è¿™ä¸ªå•å…ƒæµ‹è¯•å°†ä¼šå¤±è´¥ï¼Œå› ä¸ºæˆ‘ä»¬è¿˜æ²¡æœ‰å®ç°GetInfo()æ–¹æ³•ï¼Œä¸‹é¢æ˜¯person.goæ–‡ä»¶ï¼š</p>

<p>package person</p>

<p>import (
    â€œnet/httpâ€
    â€œfmtâ€
)</p>

<p>const (
    ADDRESS = â€œshanghaiâ€
)</p>

<p>type Person struct {
    Name string <code class="language-plaintext highlighter-rouge">json:"name"</code>
    Address string <code class="language-plaintext highlighter-rouge">json:"address"</code>
    Age int <code class="language-plaintext highlighter-rouge">json:"age"</code>
}</p>

<p>func GetInfo(api string) ([]Person, error) {
    url := fmt.Sprintf(â€œ%s/person?addr=%sâ€, api, ADDRESS)
    resp, err := http.Get(url)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if err != nil {
    return []Person{}, err
}
 
if resp.StatusCode != http.StatusOK {
    return []Person{}, fmt.Errorf("get info didnâ€™t respond 200 OK: %s", resp.Status)
}
 
return nil, nil }
</code></pre></div></div>

<p>å½“ç„¶è¿è¡Œgo testä¹Ÿä¼šè¿”å›ä¸€ä¸ªé”™è¯¯ï¼Œå› ä¸ºè¯·æ±‚åœ°å€çš„é—®é¢˜ï¼Œè¯·æ±‚çš„å¹¶ä¸æ˜¯ä¸€ä¸ªå®é™…ä¸Šçš„http serverï¼Œé‚£ä¹ˆè‡ªç„¶ä¹Ÿä¸ä¼šæœ‰æ­£å¸¸çš„è¿”å›ã€‚</p>

<p>ä¸‰ã€Golang httptest
ä¸Šé¢ä¸€ä¸ªä¾‹å­å¾ˆæœ‰ç”¨ï¼Œä½†æ˜¯å¦‚ä½•å»å‘é€ä¸€ä¸ªçœŸæ­£çš„http requestè€Œä¸å»çœŸæ­£çš„å¯åŠ¨ä¸€ä¸ªhttp serverï¼ˆäº¦æˆ–è€…è¯·æ±‚ä»»æ„çš„serverï¼‰ï¼Ÿç­”æ¡ˆæ˜¯ä½¿ç”¨Go çš„httpteståŒ…ï¼Œè¿™ä¸ªåŒ…å¯ä»¥éå¸¸ç®€å•çš„åˆ›å»ºä¸€ä¸ªæµ‹è¯•çš„http serverï¼Œé‚£ä¹ˆä¸‹é¢æˆ‘ä»¬å°†å±•ç¤ºä¸€ä¸‹å®Œæ•´çš„ä»£ç ï¼Œå¹¶è§£é‡Šä¸€ä¸‹æ•´ä½“çš„æµ‹è¯•æµç¨‹ï¼š</p>

<p>person.goï¼š</p>

<p>package person</p>

<p>import (
    â€œnet/httpâ€
    â€œfmtâ€
    â€œio/ioutilâ€
    â€œencoding/jsonâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/astaxie/beego/logs" )
</code></pre></div></div>

<p>const (
    ADDRESS = â€œshanghaiâ€
)</p>

<p>type Person struct {
    Name string <code class="language-plaintext highlighter-rouge">json:"name"</code>
    Address string <code class="language-plaintext highlighter-rouge">json:"address"</code>
    Age int <code class="language-plaintext highlighter-rouge">json:"age"</code>
}</p>

<p>func GetInfo(api string) ([]Person, error) {
    url := fmt.Sprintf(â€œ%s/person?addr=%sâ€, api, ADDRESS)
    resp, err := http.Get(url)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defer resp.Body.Close()
 
if err != nil {
    return []Person{}, err
}
 
if resp.StatusCode != http.StatusOK {
    return []Person{}, fmt.Errorf("get info didnâ€™t respond 200 OK: %s", resp.Status)
}
 
bodyBytes, _ := ioutil.ReadAll(resp.Body)
personList := make([]Person,0)
err = json.Unmarshal(bodyBytes, &amp;personList)
if err != nil {
    logs.Error("decode data fail")
    return []Person{}, fmt.Errorf("decode data fail")
}
 
return personList, nil }
</code></pre></div></div>

<p>person_test.goï¼š</p>

<p>package person</p>

<p>import (
    â€œtestingâ€
    â€œnet/http/httptestâ€
    â€œnet/httpâ€
    â€œfmtâ€
    â€œencoding/jsonâ€
)</p>

<p>var personResponse = []Person{
              {
                Name : â€œwahahaâ€,
                Address : â€œshanghaiâ€,
                Age : 20,
              },
                      {
                Name : â€œlebaishiâ€,
                Address : â€œshanghaiâ€,
                Age : 10,
              },
             }</p>

<p>var personResponseBytes, _ = json.Marshal(personResponse)</p>

<p>func TestPublishWrongResponseStatus(t *testing.T) {
    ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
        w.Write(personResponseBytes)
        if r.Method != â€œGETâ€{
            t.Errorf(â€œExpected â€˜GETâ€™ request, got â€˜%sâ€™â€, r.Method)
        }
        if r.URL.EscapedPath() != â€œ/personâ€ {
            t.Errorf(â€œExpected request to â€˜/personâ€™, got â€˜%sâ€™â€, r.URL.EscapedPath())
        }
        r.ParseForm()
        topic := r.Form.Get(â€œaddrâ€)
        if topic != â€œshanghaiâ€ {
            t.Errorf(â€œExpected request to have â€˜addr=shanghaiâ€™, got: â€˜%sâ€™â€, topic)
        }
    }))</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defer ts.Close()
api := ts.URL
fmt.Println("url:", api)
resp, _ := GetInfo(api)
 
fmt.Println("reps:", resp) }
</code></pre></div></div>

<p>è§£é‡Šä¸€ä¸‹ï¼š</p>
<blockquote>
  <p>æˆ‘ä»¬é€šè¿‡httptest.NewServeråˆ›å»ºäº†ä¸€ä¸ªæµ‹è¯•çš„http server</p>
</blockquote>

<blockquote>
  <p>è¯»è¯·æ±‚è®¾ç½®é€šè¿‡å˜é‡r *http.Requestï¼Œå†™å˜é‡ï¼ˆä¹Ÿå°±æ˜¯è¿”å›å€¼ï¼‰é€šè¿‡w http.ResponseWriter</p>
</blockquote>

<blockquote>
  <p>é€šè¿‡ts.URLæ¥è·å–è¯·æ±‚çš„URLï¼ˆä¸€èˆ¬éƒ½æ˜¯<a href="http://ip:port">http://ip:port</a>ï¼‰</p>
</blockquote>

<blockquote>
  <p>é€šè¿‡r.Methodæ¥è·å–è¯·æ±‚çš„æ–¹æ³•ï¼Œæ¥æµ‹è¯•åˆ¤æ–­æˆ‘ä»¬çš„è¯·æ±‚æ–¹æ³•æ˜¯å¦æ­£ç¡®</p>
</blockquote>

<blockquote>
  <p>è·å–è¯·æ±‚è·¯å¾„ï¼šr.URL.EscapedPath()ï¼Œæœ¬ä¾‹ä¸­çš„è¯·æ±‚è·¯å¾„å°±æ˜¯â€/personâ€</p>
</blockquote>

<blockquote>
  <p>è·å–è¯·æ±‚å‚æ•°ï¼šr.ParseFormï¼Œr.Form.Get(â€œaddrâ€)</p>
</blockquote>

<blockquote>
  <p>è®¾ç½®è¿”å›çš„çŠ¶æ€ç ï¼šw.WriteHeader(http.StatusOK)</p>
</blockquote>

<blockquote>
  <p>è®¾ç½®è¿”å›çš„å†…å®¹ï¼ˆè¿™å°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„ç»“æœï¼‰ï¼šw.Write(personResponseBytes)ï¼Œæ³¨æ„w.Write()æ¥æ”¶çš„å‚æ•°æ˜¯[]byteï¼Œå› æ­¤éœ€è¦å°†objectå¯¹è±¡åˆ—è¡¨é€šè¿‡json.Marshal(personResponse)è½¬æ¢æˆå­—èŠ‚ã€‚</p>
</blockquote>

<p>ç»¼ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸å‘é€httptestæ¥æ¨¡æ‹Ÿå‡ºhttpserverå’Œè¿”å›å€¼æ¥è¿›è¡Œè‡ªå·±ä»£ç çš„æµ‹è¯•äº†</p>

<p>æˆ‘ä»¬åœ¨å†™å®Œæ¥å£ä¹‹åéƒ½éœ€è¦å¯¹æ¥å£è¿›è¡Œæµ‹è¯•ï¼Œåœ¨ golang æ ‡å‡†åº“ä¸­æä¾› httptest åŒ…æ¥è¾…åŠ©æµ‹è¯•ã€‚</p>

<p>å› ä¸ºæ¥å£éƒ½æ˜¯éœ€è¦ IP åœ°å€æˆ–åŸŸåæ¥è®¿é—®ï¼Œhttptest åŒ…ä¸­é»˜è®¤å®šä¹‰äº†æœåŠ¡åœ°å€</p>

<p>const DefaultRemoteAddr = â€œ1.2.3.4â€
é‡è¦çš„æ–¹æ³•
NewRequest(è¯·æ±‚ä½“)
NewRequest æ–¹æ³•ç”¨æ¥åˆ›å»ºä¸€ä¸ª http çš„è¯·æ±‚ä½“ã€‚</p>

<p>æ–¹æ³•å®šä¹‰ï¼š</p>

<p>func NewRequest(method, target string, body io.Reader) *http.Request
method å‚æ•°è¡¨ç¤ºæµ‹è¯•çš„æ¥å£çš„ HTTP æ–¹æ³•ã€‚
target å‚æ•°è¡¨ç¤ºæ¥å£å®šä¹‰çš„è·¯ç”±ã€‚
body å‚æ•°è¡¨ç¤ºè¯·æ±‚ä½“ã€‚
NewRecorder(å“åº”ä½“)
æ–¹æ³•å®šä¹‰ï¼š</p>

<p>func NewRecorder() *ResponseRecorder
NewRecorder æ–¹æ³•ç”¨æ¥åˆ›å»º http çš„å“åº”ä½“ã€‚è¿”å›çš„ç±»å‹æ˜¯ *httptest.ResponseRecorder ï¼ŒåŒ…å«æ¥å£è¿”å›ä¿¡æ¯ï¼Œç­‰ä»·äº http.ResponseWriterã€‚</p>

<p>ResponseRecorderç±»å‹å®šä¹‰ï¼š</p>

<p>type ResponseRecorder struct {
        // http å“åº”ç .
        Code int
        // å¤´éƒ¨ä¿¡æ¯
        HeaderMap http.Header
        // è¿”å›çš„ Body
        Body *bytes.Buffer
        // æ˜¯å¦è°ƒç”¨ Flush æ–¹æ³•
        Flushed bool
}
NewServer(httpæœåŠ¡)
æ–¹æ³•å®šä¹‰ï¼š</p>

<p>func NewServer(handler http.Handler) *Server
NewServer æ–¹æ³•ç”¨æ¥åˆ›å»ºå’Œå¯åŠ¨æ–°çš„æœåŠ¡ã€‚åŒç±»çš„è¿˜æœ‰ NewTLSServerï¼Œç”¨æ¥åˆ›å»ºå¸¦ SSL çš„æœåŠ¡ã€‚</p>

<p>type Server struct {
        URL      string // æœåŠ¡åœ°å€
        Listener net.Listener
        // TLS é…ç½®ä¿¡æ¯
        TLS *tls.Config
        Config *http.Server
}
æµ‹è¯• next/http åº“åˆ›å»ºçš„æ¥å£
è¯·æ±‚æ¥å£å®šä¹‰ï¼š</p>

<p>func testAPI(w http.ResponseWriter, r *http.Request){}
æµ‹è¯•æ–¹æ³•å®šä¹‰ï¼š</p>

<p>func Test_testApi(t *testing.T) {
    tests := []struct {
        name string
    }{
        {
            name: â€œtest apiâ€,
        },
    }
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            ts := httptest.NewServer(http.HandlerFunc(testAPI))
            defer ts.Close()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        params := struct{
            "params" string 
        }{
            "params": "paramsBody"
        }
        paramsByte, _ := json.Marshal(params)

        resp, err := http.Post(ts.URL, "application/json", bytes.NewBuffer(paramsByte))
        if err != nil {
            t.Error(err)
        }
        defer resp.Body.Close()

        t.Log(resp.StatusCode)
        if resp.StatusCode != http.StatusCreated &amp;&amp; resp.StatusCode != http.StatusOK {
            body, _ := ioutil.ReadAll(resp.Body)
            t.Error(string(body))
        }
    })
} } æµ‹è¯•æ—¶é€šè¿‡ httptest.NewServer åˆ›å»ºä¸€ä¸ª testAPI æ¥å£çš„æœåŠ¡ã€‚ç„¶åé€šè¿‡ http.Post æ–¹æ³•æ¥è°ƒç”¨æˆ‘ä»¬åˆ›å»ºçš„æœåŠ¡ï¼Œè¾¾åˆ°æ¥å£æµ‹è¯•æ—¶è¯·æ±‚çš„ç›®çš„ã€‚ç„¶ååˆ¤æ–­æ¥å£è¿”å›çš„ä¿¡æ¯æ˜¯å¦æ­£ç¡®ã€‚
</code></pre></div></div>

<p>æµ‹è¯• Gin æ¡†æ¶çš„æ¥å£
è¯·æ±‚æ¥å£å®šä¹‰ï¼š</p>

<p>func testAPI(ctx *gin.Context){}
æµ‹è¯•æ–¹æ³•å®šä¹‰ï¼š</p>

<p>func Test_testAPI(t *testing.T) {
    // å®šä¹‰è·¯ç”±
    router := gin.Default()
    router.POST(â€œ/testâ€, testAPI)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tests := []struct {
    name string
want string
}{
    {
        name: "test api",
        want: "ok",
    },
}
for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) {
        params := struct{
            "params" string 
        }{
            "params": "paramsBody"
        }
        paramsByte, _ := json.Marshal(params)
        w := httptest.NewRecorder()
        req := httptest.NewRequest("POST", "/test", bytes.NewBuffer(paramsByte))
        setup.api.router.ServeHTTP(w, req)

        assert.Equal(t, http.StatusOK, w.Code)

        result, _ := ioutil.ReadAll(w.Body)
        var ret string
        if err := json.Unmarshal(result, &amp;ret); err != nil {
            t.Error(err)
        }
        assert.Equal(t, tt.want, ret)
    })
} } æµ‹è¯•æ—¶éœ€è¦å®šä¹‰å¥½ gin çš„è·¯ç”±ï¼Œç„¶ååˆ›å»º httptest.NewRecorder å’Œ httptest.NewRequest å¯¹è±¡ï¼Œå¹¶è°ƒç”¨ gin è·¯ç”±çš„ ServeHTTP æ–¹æ³•æ¥æ‰§è¡Œæ¥å£ã€‚
</code></pre></div></div>

<p>ServeHTTP æ˜¯ *gin.Engine å®ç°äº† http.Handler æ¥å£ã€‚é€šè¿‡è¿™ç§æ–¹å¼è¾¾åˆ°è¯·æ±‚æ¥å£ç›®çš„ã€‚ç„¶ååˆ¤æ–­æ¥å£è¿”å›çš„ä¿¡æ¯æ˜¯å¦æ­£ç¡®ã€‚</p>

<p>å°ç»“
æ¥å£çš„æµ‹è¯•åœ¨å¼€å‘å½“ä¸­æ˜¯ååˆ†é‡è¦ï¼Œæˆ‘è¿™é‡Œä»‹ç»äº†ä½¿ç”¨ net/http å’Œ gin åˆ›å»ºæ¥å£çš„æµ‹è¯•ç”¨ä¾‹ã€‚</p>

<p>é€šè¿‡ httptest åŒ…èƒ½æ–¹ä¾¿çš„å¯¹æ¥å£è¿›è¡Œå•å…ƒæµ‹è¯•ï¼Œè€Œä¸éœ€è¦å•ç‹¬çš„èµ·ä¸€ä¸ªæœåŠ¡æ¥è¿›è¡Œæµ‹è¯•ã€‚</p>

<p>https://dave.cheney.net/2020/03/01/are-large-slices-more-expensive-than-smaller-ones</p>

:ET