I"Gÿ<p>â€ƒä¼ é€æ–‡ä»¶æè¿°ç¬¦æ˜¯é«˜å¹¶å‘ç½‘ç»œæœåŠ¡ç¼–ç¨‹çš„ä¸€ç§å¸¸è§å®ç°æ–¹å¼ã€‚Nebula é«˜æ€§èƒ½é€šç”¨ç½‘ç»œæ¡†æ¶å³é‡‡ç”¨äº†UNIXåŸŸå¥—æ¥å­—ä¼ é€’æ–‡ä»¶æè¿°ç¬¦è®¾è®¡å’Œå®ç°
â€ƒhttps://github.com/Bwar/Nebula
<!-- more -->
 åœ¨Unix åŸŸå¥—æ¥å­—æ¦‚è¿°ä¸€èŠ‚ä¸­ä»‹ç»äº†ä»€ä¹ˆæ˜¯ Unix åŠç›¸å…³å‡½æ•°ï¼Œæœ¬æ–‡å°†ç»§ç»­ä»‹ç» Unix åŸŸå¥—æ¥å­—åœ¨è¿›ç¨‹é—´ä¼ é€’æè¿°ç¬¦çš„åº”ç”¨ã€‚
        åœ¨è¿›ç¨‹é—´ä¼ é€’æ‰“å¼€çš„æè¿°ç¬¦æ—¶é€šå¸¸ä¼šé‡‡ç”¨å¦‚ä¸‹ä¸¤ç§æ–¹æ³•ï¼š
        ï¼ˆ1ï¼‰fork è°ƒç”¨è¿”å›åï¼Œå­è¿›ç¨‹è‡ªåŠ¨å…±äº«çˆ¶è¿›ç¨‹çš„æ‰€æœ‰æ‰“å¼€çš„æè¿°ç¬¦ã€‚
        ï¼ˆ2ï¼‰exec è°ƒç”¨æ‰§è¡Œåï¼Œæ‰€æœ‰æè¿°ç¬¦é€šå¸¸ä¿æŒæ‰“å¼€çŠ¶æ€ä¸å˜ã€‚
        ç¬¬ä¸€ç§æ–¹æ³•ä¸­ï¼Œè¿›ç¨‹å…ˆæ‰“å¼€ä¸€ä¸ªæè¿°ç¬¦ï¼Œå†è°ƒç”¨ forkï¼Œä¹‹åçˆ¶è¿›ç¨‹å…³é—­è¿™ä¸ªæè¿°ç¬¦ï¼Œå­è¿›ç¨‹åˆ™å¤„ç†è¯¥æè¿°ç¬¦ã€‚è¿™æ ·ä¸€ä¸ªæ‰“å¼€çš„æè¿°ç¬¦å°±ä»çˆ¶è¿›ç¨‹ä¼ é€’åˆ°å­è¿›ç¨‹ã€‚ä¸è¿‡æœ‰æ—¶å€™å¯èƒ½æƒ³è®©å­è¿›ç¨‹æ‰“å¼€ä¸€ä¸ªæè¿°ç¬¦å¹¶æŠŠä»–ä¼ é€’ç»™çˆ¶è¿›ç¨‹ã€‚
        ä½¿ç”¨ Unix åŸŸå¥—æ¥å­—ï¼Œå¯ä»¥ä»ä¸€ä¸ªè¿›ç¨‹å‘ä»»ä¸€å…¶ä»–è¿›ç¨‹ä¼ é€’æ‰“å¼€çš„æè¿°ç¬¦ï¼Œè€Œæ— éœ€è¿™ä¸¤ä¸ªè¿›ç¨‹ä¹‹é—´å­˜åœ¨äº²ç¼˜å…³ç³»ã€‚è¿™ç§æŠ€æœ¯è¦æ±‚é¦–å…ˆåœ¨è¿™ä¸¤ä¸ªè¿›ç¨‹ä¹‹é—´åˆ›å»ºä¸€ä¸ª Unix åŸŸå¥—æ¥å­—ï¼Œç„¶åä½¿ç”¨ sendmsg è·¨è¿™ä¸ªå¥—æ¥å­—å‘é€ä¸€ä¸ªç‰¹æ®Šæ¶ˆæ¯ã€‚è¯¥æ¶ˆæ¯ç”±å†…æ ¸æ¥ä¸“é—¨å¤„ç†ï¼Œä¼šæŠŠæ‰“å¼€çš„æè¿°ç¬¦ä»å‘é€è¿›ç¨‹ä¼ é€’åˆ°æ¥æ”¶è¿›ç¨‹ã€‚
        ä½¿ç”¨ Unix åŸŸå¥—æ¥å­—åœ¨ä¸¤ä¸ªè¿›ç¨‹ä¹‹é—´ä¼ é€’æè¿°ç¬¦æ¶‰åŠçš„æ­¥éª¤å¦‚ä¸‹ã€‚
        ï¼ˆ1ï¼‰åˆ›å»ºä¸€ä¸ªå­—èŠ‚æµæˆ–æ•°æ®æŠ¥çš„ Unix åŸŸå¥—æ¥å­—ã€‚å¦‚æœç›®æ ‡æ˜¯è®©å­è¿›ç¨‹å°†æ‰“å¼€çš„æè¿°ç¬¦ä¼ é€’å›çˆ¶è¿›ç¨‹ï¼Œåˆ™çˆ¶è¿›ç¨‹å¯ä»¥é¢„å…ˆè°ƒç”¨ socketpair å‡½æ•°åˆ›å»ºä¸€ä¸ªå¯ç”¨äºåœ¨çˆ¶å­è¿›ç¨‹ä¹‹é—´äº¤æ¢æè¿°ç¬¦çš„æµç®¡é“ã€‚å¦‚æœè¿›ç¨‹é—´æ²¡æœ‰äº²ç¼˜å…³ç³»ï¼Œåˆ™æœåŠ¡å™¨è¿›ç¨‹å¿…é¡»å…ˆåˆ›å»ºä¸€ä¸ª Unix åŸŸå­—èŠ‚æµå¥—æ¥å­—ï¼ˆä¹Ÿå¯ä»¥æ˜¯ Unix åŸŸæ•°æ®æŠ¥å¥—æ¥å­—ï¼Œä¸è¿‡è¿™æ²¡ä»€ä¹ˆå¥½å¤„ï¼Œè€Œä¸”æ•°æ®æŠ¥è¿˜å­˜åœ¨è¢«ä¸¢å¼ƒçš„å¯èƒ½æ€§ï¼‰ï¼Œç„¶å bind ä¸€ä¸ªè·¯å¾„ååˆ°è¯¥å¥—æ¥å­—ï¼Œä»¥å…è®¸å®¢æˆ·è¿›ç¨‹ connect åˆ°å¥—æ¥å­—ï¼Œå‘é€ä¸€ä¸ªæ‰“å¼€æŸä¸ªæè¿°ç¬¦çš„è¯·æ±‚ã€‚
        ï¼ˆ2ï¼‰å‘é€è¿›ç¨‹é€šè¿‡è°ƒç”¨è¿”å›æè¿°ç¬¦çš„ä»»ä¸€ Unix å‡½æ•°ï¼ˆå¦‚ openã€pipeã€mkfifoã€socket å’Œ acceptï¼Œå¯ä»¥åœ¨è¿›ç¨‹ä¹‹é—´ä¼ é€’çš„æè¿°ç¬¦ä¸é™ç±»å‹ï¼‰æ‰“å¼€ä¸€ä¸ªæè¿°ç¬¦ã€‚
        ï¼ˆ3ï¼‰å‘é€è¿›ç¨‹åˆ›å»ºä¸€ä¸ª msghdr ç»“æ„ï¼Œå…¶ä¸­å«æœ‰å¾…ä¼ é€’çš„æè¿°ç¬¦ã€‚POSIX è§„å®šæè¿°ç¬¦ä½œä¸ºè¾…åŠ©æ•°æ®ï¼ˆmsghdr ç»“æ„çš„ msg_control æˆå‘˜ï¼Œè§è¾…åŠ©æ•°æ®ï¼‰å‘é€ã€‚å‘é€è¿›ç¨‹è°ƒç”¨ sendmsg è·¨æ¥è‡ªæ­¥éª¤ 1 çš„ Unix åŸŸå¥—æ¥å­—å‘é€è¯¥æè¿°ç¬¦ã€‚è‡³æ­¤ï¼Œç§°è¿™ä¸ªæè¿°ç¬¦â€œåœ¨é£è¡Œä¸­ï¼ˆin flightï¼‰â€ã€‚å³ä½¿å‘é€è¿›ç¨‹åœ¨è°ƒç”¨ sendmsg ä¹‹åä½†åœ¨æ¥æ”¶è¿›ç¨‹è°ƒç”¨ recvmsg ä¹‹å‰å…³é—­äº†è¯¥æè¿°ç¬¦ï¼Œå¯¹äºæ¥æ”¶è¿›ç¨‹å®ƒä»ç„¶ä¿æŒæ‰“å¼€çŠ¶æ€ã€‚å‘é€ä¸€ä¸ªæè¿°ç¬¦ä¼šä½¿è¯¥æè¿°ç¬¦çš„å¼•ç”¨è®¡æ•°åŠ ä¸€ã€‚
        ï¼ˆ4ï¼‰æ¥æ”¶è¿›ç¨‹è°ƒç”¨ recvmsg åœ¨æ¥è‡ªæ­¥éª¤ 1 çš„ Unix åŸŸå¥—æ¥å­—ä¸Šæ¥æ”¶è¿™ä¸ªæè¿°ç¬¦ã€‚è¿™ä¸ªæè¿°ç¬¦åœ¨æ¥æ”¶è¿›ç¨‹ä¸­çš„æè¿°ç¬¦å·ä¸åŒäºå®ƒåœ¨å‘é€è¿›ç¨‹ä¸­çš„æè¿°ç¬¦å·æ˜¯æ­£å¸¸çš„ï¼Œå› ä¸ºä¼ é€’ä¸€ä¸ªæè¿°ç¬¦å¹¶ä¸æ˜¯ä¼ é€’ä¸€ä¸ªæè¿°ç¬¦å·ï¼Œè€Œæ˜¯æ¶‰åŠåœ¨æ¥æ”¶è¿›ç¨‹ä¸­åˆ›å»ºä¸€ä¸ªæ–°çš„æè¿°ç¬¦ï¼Œè¯¥æè¿°ç¬¦å’Œå‘é€è¿›ç¨‹ä¸­é£è¡Œå‰çš„é‚£ä¸ªæè¿°ç¬¦æŒ‡å‘å†…æ ¸ä¸­ç›¸åŒçš„æ–‡ä»¶è¡¨é¡¹ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    å‚è€ƒæ–‡çŒ®ï¼š1ï¼‰ ã€ŠUnixç½‘ç»œç¼–ç¨‹ã€‹
    2ï¼‰  http://book.51cto.com/art/200912/168560.htm
</code></pre></div></div>

<p>æœ€è¿‘å­¦ä¹ äº†ä½¿ç”¨UnixåŸŸå¥—æ¥å­—åœ¨è¿›ç¨‹é—´ä¼ é€’æ–‡ä»¶æè¿°ç¬¦ï¼Œä»¿ç…§å‚è€ƒèµ„æ–™ï¼Œè‡ªå·±ä¹Ÿå†™äº†ç®€å•çš„ç¨‹åºæ¥å®è·µè¿™ç§æŠ€æœ¯ã€‚</p>

<p>å…¶ä»–ä¸å¤šè¯´äº†ï¼Œå…·ä½“ç†è®ºçŸ¥è¯†å‚è§å‚è€ƒèµ„æ–™ï¼Œå¼€å§‹æˆ‘è‡ªå·±çš„ç¨‹åºä»‹ç»ï¼ˆåœ¨OpenSolaris 2009.06å¹³å°ä¸Šæµ‹è¯•ï¼‰ï¼š</p>

<p>1  ç¨‹åºä½œç”¨è¯´æ˜ï¼šçˆ¶è¿›ç¨‹ï¼Œå­è¿›ç¨‹ä»¥åŠå¦å¤–ä¸€ä¸ªè¿›ç¨‹å‘åŒä¸€ä¸ªæ–‡ä»¶çš„æ–‡ä»¶æè¿°ç¬¦å‘è¿™ä¸ªæ–‡ä»¶ä¸­å†™å†…å®¹ã€‚
   å…·ä½“å¦‚ä¸‹ï¼š
   1ï¼‰çˆ¶è¿›ç¨‹æŒ‡å®šè¦æ‰“å¼€çš„æ–‡ä»¶åï¼Œæ‰“å¼€æƒé™ï¼Œæ‰“å¼€æ¨¡å¼ï¼›
   2ï¼‰forkä¸€ä¸ªå­è¿›ç¨‹ï¼›
   3ï¼‰å­è¿›ç¨‹è°ƒç”¨execlå‡½æ•°æ¥æ‰§è¡Œç¨‹åºopenfileï¼šè¯¥æ–°ç¨‹åºå–å¾—æŒ‡å®šæ–‡ä»¶çš„æ–‡ä»¶æè¿°ç¬¦ï¼›å‘æŒ‡å®šæ–‡ä»¶ä¸­å†™å…¥â€œopenfileprog write testâ€ï¼›å‘çˆ¶è¿›ç¨‹è¿”å›è¯¥æ–‡ä»¶æè¿°ç¬¦ï¼›
   4ï¼‰çˆ¶è¿›ç¨‹æ”¶åˆ°è¯¥æ–‡ä»¶æè¿°ç¬¦åï¼Œå‘æ–‡ä»¶ä¸­å†™â€œparaent process write pppâ€ï¼›
   5ï¼‰çˆ¶è¿›ç¨‹ä½œä¸ºserverç«¯å»ºç«‹åŸŸsocketç­‰å¾…å®¢æˆ·ç«¯è¿›ç¨‹è¿æ¥ï¼›
   6ï¼‰å®¢æˆ·ç«¯è¿›ç¨‹è¿æ¥çˆ¶è¿›ç¨‹ï¼›
   7ï¼‰çˆ¶è¿›ç¨‹å‘è¯¥å®¢æˆ·ç«¯è¿›ç¨‹è¿”å›ä»å­è¿›ç¨‹å¾—åˆ°çš„æ–‡ä»¶æè¿°ç¬¦ï¼›
   8ï¼‰å®¢æˆ·ç«¯è¿›ç¨‹æ”¶åˆ°è¯¥æ–‡ä»¶æè¿°ç¬¦åä½¿ç”¨å®ƒåœ¨æ–‡ä»¶ä¸­å†™â€œthis is client process cccâ€ï¼›</p>

<p>å…¶ä¸­çˆ¶å­è¿›ç¨‹ä¼ é€’æ–‡ä»¶æè¿°ç¬¦é€šè¿‡å»ºç«‹çš„ä¸€å¯¹å¥—æ¥å­—ç®¡é“ï¼Œçˆ¶è¿›ç¨‹å’Œå®¢æˆ·ç«¯è¿›ç¨‹ä¼ é€’æ–‡ä»¶æè¿°ç¬¦é€šè¿‡UnixåŸŸå¥—æ¥å­—ã€‚</p>

<p>2 å…·ä½“ä»£ç è¯´æ˜ï¼š</p>

<p>1ï¼‰ é¦–å…ˆçœ‹openfileç¨‹åºï¼Œè¿™æ—¶å­è¿›ç¨‹é€šè¿‡è°ƒç”¨execlæ‰§è¡Œçš„ã€‚è°ƒç”¨æ–¹æ³•å¦‚ä¸‹ï¼š
  execl(â€œ./openfileprogâ€, â€œopenfileprogâ€, permit, mode, argsockfd, (char *)NULL);
å…¶ä¸­å‚æ•°1ï¼š openfileç¨‹åºè·¯å¾„ï¼›
   å‚æ•°2ï¼š openfileç¨‹åºåï¼›
   å‚æ•°3ï¼š å¾…æ‰“å¼€æ–‡ä»¶çš„æƒé™ï¼›
   å‚æ•°4ï¼š å¾…æ‰“å¼€æ–‡ä»¶æ¨¡å¼ï¼›
   å‚æ•°5ï¼š çˆ¶è¿›ç¨‹å»ºç«‹çš„ä¸€å¯¹å¥—æ¥å­—ç®¡é“çš„å…¶ä¸­ä¹‹ä¸€ï¼›</p>

<p>ä½œä¸ºopenfileç¨‹åºï¼Œä¸»è¦æŒ‰ç…§execlä¼ çš„å‚æ•°ï¼Œæ‰“å¼€æŒ‡å®šæ–‡ä»¶ï¼Œå–å¾—æ–‡ä»¶æè¿°ç¬¦ï¼›å‘è¯¥æ–‡ä»¶ä¸­å†™å…¥å†…å®¹ï¼›ç„¶åè°ƒç”¨func_send_fdå‡½æ•°é€šè¿‡argsockfdæŠŠå–å¾—çš„æ–‡ä»¶æè¿°ç¬¦ä¼ ç»™çˆ¶è¿›ç¨‹ã€‚è¯¥ç¨‹åºä»£ç å¦‚ä¸‹ï¼š</p>

<p>int main(int argc, char <em>argv[]) /</em> openfileprog <em>/
{
 int i, fd, ret;
 ssize_t size;
 size_t buflen;
 char data[10];
 char buf[] = â€œopenfileprog write test\nâ€; /</em> å‘æ–‡ä»¶ä¸­å†™å…¥çš„å†…å®¹ <em>/
        /</em> execl(â€œ./openfileprogâ€, permit, mode, argsockfd, (char *)NULL); */
  fd = -1;
 if((fd = open(â€œ./fileâ€, atoi(argv[1]), atoi(argv[2]))) &lt; 0)
 {
  printf(â€œin openfileprog, open failed\nâ€);
  exit(-1);
 }</p>

<p>size = -1;
 buflen = sizeof(buf);
 if((size = write(fd, buf, buflen)) &lt;= 0)
 {
  printf(â€œin openfileprog, write failed\nâ€);
 }</p>

<p>/* æŠŠè®¾å®šçš„dataä¿¡æ¯ä¹Ÿä¼ ç»™çˆ¶è¿›ç¨‹ */
 ret = â€˜aâ€™;
 for(i = 0; i &lt; sizeof(data); i++, ret++)
 {
  data[i] = ret;
 }
 data[sizeof(data) - 1] = â€˜\0â€™;</p>

<p>ret = -1;
 if(0 &gt; (ret = func_send_fd(atoi(argv[3]), fd, data, 10)))
 {
  printf(â€œin openfileprog, func_send_fd failed\nâ€);
 }</p>

<p>close(fd);</p>

<p>return 0; 
}</p>

<p>func_send_fdå‡½æ•°è´Ÿè´£æŠŠå–å¾—çš„æ–‡ä»¶æè¿°ç¬¦ä¼ å‡ºå»ï¼š</p>

<p>int func_send_fd(int send_sock, int send_fd, void *data, int bytes)
{
    struct msghdr msghead; 
 struct iovec passdata[1];
 int ret;</p>

<p>/* å¡«å……msgheadç»“æ„ */
 msghead.msg_accrights = (caddr_t)&amp;send_fd;
 msghead.msg_accrightslen = sizeof(send_fd);</p>

<p>msghead.msg_name = NULL;
 msghead.msg_namelen = 0;
 passdata[0].iov_base = data;
 passdata[0].iov_len = bytes;</p>

<p>msghead.msg_iov = passdata;
 msghead.msg_iovlen = 1;</p>

<p>/* å‘é€ä¿¡æ¯ */
 if(0 &gt; (ret = sendmsg(send_sock, &amp;msghead, 0)))
 {
  printf(â€œin func_send, send_fd is %d, sendsock is %d, sendmsg failed,errno is %d\nâ€, send_fd,send_sock,errno);
  return -1;
 }</p>

<p>return ret;
}</p>

<p>åœ¨ä¸Šè¿°ä¸¤ä¸ªå‡½æ•°ä¹‹å‰ï¼ŒåŠ ä¸Šä»¥ä¸‹å¿…è¦å¤´æ–‡ä»¶å’Œå®ï¼š</p>

<p>#include
#include
#include
#include
#include
#include
#include
#define SLEEPTIME  3
#define ARGLEN     20</p>

<p>ä»¥ä¸Šä½œä¸ºä¸€ä¸ªcæ–‡ä»¶ã€‚</p>

<p>2ï¼‰ç„¶åçœ‹çˆ¶è¿›ç¨‹ä»£ç </p>

<p>ä¸‹é¢æ˜¯çˆ¶è¿›ç¨‹ç¨‹åºï¼š</p>

<p>int main(int argc, char *argv)
{
 int status,sockfd[2];
 char permit[ARGLEN];
 char mode[ARGLEN];
 char argsockfd[ARGLEN];
 int recvfd;
 char data[20];
 int bytes;
 int ret,i;
 ssize_t size;
 int buflen;
 pid_t pid,chldpid;</p>

<p>/* ä»¥ä¸‹å‡ è¡Œæ˜¯ä½¿ç”¨åŸŸå¥—æ¥å­—å¿…è¦å˜é‡ */
 int fdsock, fdaccept;
 struct sockaddr_un addr_server; <br />
 int len; <br />
 const char path[] = â€œ/export/home/temp/test/other_prog/fengxianzhongâ€;</p>

<p>/* ä»¥ä¸‹æ˜¯çˆ¶è¿›ç¨‹å†™å…¥æ–‡ä»¶çš„å†…å®¹ */  <br />
 char buf[] = â€œparaent process write ppp\nâ€;</p>

<p>/* çˆ¶è¿›ç¨‹åŒæ—¶å‘å¤„ç†å‘clientå‘é€çš„æ•°æ® */
 char datasend[] = â€œsend by myopen\nâ€;</p>

<p>memset(permit, â€˜\0â€™, sizeof(permit));
 memset(mode, â€˜\0â€™, sizeof(mode));
 memset(argsockfd, â€˜\0â€™, sizeof(argsockfd));
 memset(data, â€˜\0â€™, sizeof(data));</p>

<p>printf(â€œnow it is parent process,now will fork a child process\nâ€);
 sleep(SLEEPTIME);</p>

<p>/* è®¾ç½®æ–‡ä»¶æƒé™å’Œæ‰“å¼€æ¨¡å¼ */ 
snprintf(permit, sizeof(permit), â€œ%dâ€,PERMIT);
 snprintf(mode, sizeof(mode), â€œ%dâ€,MODE); 
 // printf(â€œin myopen %s, %s\nâ€, permit, mode);</p>

<p>/* å»ºç«‹å’Œå­è¿›ç¨‹é€šä¿¡çš„socketå¥—æ¥å­—ç®¡é“ */
 ret = socketpair(AF_UNIX,SOCK_STREAM,0,sockfd);
 if(0 &gt; ret)
 {
  printf(â€œsocketpair failed,errno is %d \nâ€,errno);
 }</p>

<p>/* fork å­è¿›ç¨‹ <em>/
 if(0 == (chldpid = fork())) /</em> child process */
 {
  printf(â€œnow it is child process, sendsock is %d\nâ€,sockfd[1]);
  close(sockfd[0]);
  snprintf(argsockfd, sizeof(argsockfd), â€œ%dâ€, sockfd[1]);</p>

<p>/* å­è¿›ç¨‹ä¸­æ‰§è¡Œæ–°ç¨‹åºopenfile */
  execl(â€œ./openfileprogâ€, â€œopenfileprogâ€, permit, mode, argsockfd, (char *)NULL);
  printf(â€œexecl failed, perimit is %s, mode is %s\nâ€,permit, mode);
  exit(-1);
 }</p>

<p>/* paraent process start to write the file opened by child process */</p>

<p>printf(â€œnow it is parent process\nâ€);
 close(sockfd[1]);
 bytes = sizeof(data);</p>

<p>/* ç­‰å¾…å­è¿›ç¨‹ç»“æŸ <em>/
 pid = wait(&amp;status);
 if((status = WEXITSTATUS(status)) == 0) /</em> child process terminate */
 {
  printf(â€œchild %d process terminate,now parent will write file â€¦\nâ€,pid);
 }</p>

<p>/* ä»å­è¿›ç¨‹å–å¾—æ–‡ä»¶æè¿°ç¬¦ <em>/
 recvfd = -1;
 // printf(â€œrecv sock is %d\nâ€, sockfd[0]);
 ret = func_recv_fd(sockfd[0], &amp;recvfd, data, bytes);
 if(ret &lt; 0)
 {
  printf(â€œparaent recv failed\nâ€);
 }
 /</em>
 else
 {
  printf(â€œfd %d paraent recv %d bytes data is %s\nâ€, recvfd,strlen(data),data);
 }
 */</p>

<p>/* å‘æ–‡ä»¶å†™å…¥æ•°æ®  */
 size = -1;
 buflen = sizeof(buf);</p>

<p>if((size = write(recvfd, buf, buflen)) &lt;= 0)
 {
  printf(â€œin openfileprog, write failed\nâ€);
 }</p>

<p>/* çˆ¶è¿›ç¨‹ä½œä¸ºserverå»ºç«‹åŸŸå¥—æ¥å­—ï¼Œç­‰å¾…clientè¿æ¥ */
  printf(â€œparent write over! Accept other process â€¦â€¦\nâ€);</p>

<p>fdsock = socket(AF_UNIX, SOCK_STREAM, 0);
 if(-1 == fdsock)
 {
  printf(â€œmyopen creat socket error!errno is %d\nâ€, errno);
 }</p>

<p>unlink(path);</p>

<p>memset(&amp;addr_server, 0, sizeof(addr_server));
 addr_server.sun_family = AF_UNIX;
 strcpy(addr_server.sun_path, path);
 len = sizeof(struct sockaddr_un);</p>

<p>ret = bind(fdsock, (struct sockaddr*)&amp;addr_server, len);
 if(-1 == ret)
 {
  printf(â€œin myopen bind error, errorno is %d\nâ€,errno);
  close(fdsock);
  unlink(path);
 }</p>

<p>ret = listen(fdsock,1);
 if(-1 == ret)
 {
  printf(â€œin myopen listen error, errorno is %d\nâ€,errno);
  close(fdsock);
  unlink(path);
 }</p>

<p>fdaccept = accept(fdsock, (struct sockaddr*)&amp;addr_server, &amp;len);
 if(-1 == ret)
 {
  printf(â€œin myopen accept error, errorno is %d\nâ€,errno);
  close(fdsock);
  unlink(path);
 }</p>

<p>/* å‘å·²ç»è¿æ¥çš„clientä¼ é€’è¯¥æ–‡ä»¶æè¿°ç¬¦ */
 ret = func_send_fd(fdaccept, recvfd, datasend, sizeof(datasend));
 if(0 &gt; ret)
 {
  printf(â€œin myopen, func_send_fd failed\nâ€);
 }</p>

<p>printf(â€œsend fd over! Will sleep 10s \nâ€);</p>

<p>sleep(10);</p>

<p>exit(0);</p>

<p>}</p>

<p>func_recv_fdå‡½æ•°è´Ÿè´£ä»å­è¿›ç¨‹æ¥å—æ–‡ä»¶æè¿°ç¬¦ï¼š</p>

<p>int func_recv_fd(int recv_sock, int *recvfd, void *data, int bytes)
{
 struct msghdr msghead; 
 struct iovec passdata[1];
 int ret;
 int temp;
 int newfd;</p>

<p>struct cmsghdr  *msgptr1;</p>

<p>struct cmsghdr  *msgptr = NULL;</p>

<p>memset(&amp;msghead, 0, sizeof(msghead));</p>

<p>/* åŒfunc_send_fd ï¼Œå¡«å……æ‰€éœ€è¦çš„ç»“æ„ */
 msghead.msg_accrights = (caddr_t)&amp;newfd;
 msghead.msg_accrightslen = sizeof(recvfd);</p>

<p>msghead.msg_name = NULL;
 msghead.msg_namelen = 0;
 passdata[0].iov_base = data;
 passdata[0].iov_len = bytes;</p>

<p>msghead.msg_iov = passdata;
 msghead.msg_iovlen = 1;</p>

<p>/* æ¥æ”¶ä¿¡æ¯ï¼ˆæ–‡ä»¶æè¿°ç¬¦ ï¼‰*/
 if(0 &gt; (ret = recvmsg(recv_sock, &amp;msghead, 0)))
 {
  printf(â€œin func_recv_fd, recvmsg failed\nâ€);
  return -1;
 }</p>

<p>if(msghead.msg_accrightslen == sizeof(recvfd))
 {
  <em>recvfd = newfd;  /</em> æ–‡ä»¶æè¿°ç¬¦ */
 }</p>

<p>return ret;
}</p>

<p>å…¶ä¸­çˆ¶è¿›ç¨‹å‘clientè¿›ç¨‹å‘é€æ–‡ä»¶æè¿°ç¬¦ä¹Ÿä½¿ç”¨äº†func_send_fdå‡½æ•°ï¼Œè¯¥å‡½æ•°åœ¨æ­¤cæ–‡ä»¶ä¸­é‡æ–°å†™äº†ä¸€éï¼›å…¶å®æ²¡æœ‰å¿…è¦è¿™æ ·é‡å¤ã€‚æˆ‘ä»¬å¯ä»¥æŠŠå®ƒä½œä¸ºä¸€ä¸ªåº“æ¥ä½¿ç”¨ï¼›ä¸è¿‡è¿™é‡Œæš‚ä¸”è¿™æ ·ä½¿ç”¨ã€‚å‡½æ•°ä»£ç å‚è€ƒä¸Šé¢æ‰€å†™çš„ã€‚</p>

<p>åœ¨è¿™ä¸ªcæ–‡ä»¶ä¸­è¿˜è¦åŠ å…¥ä»¥ä¸‹å¤´æ–‡ä»¶å’Œå®å®šä¹‰ï¼š</p>

<p>#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
#define SLEEPTIME  3
#define ARGLEN     20
#define MODE       S_IRUSR | S_IWUSR | S_IXUSR | S_IRGRP | S_IROTH    /* -rwxrâ€“râ€“ <em>/
#define PERMIT     O_RDWR | O_APPEND | O_CREAT                         /</em> if the file not exit ,creat it , data written to it append */</p>

<p>3ï¼‰æœ€åçœ‹clientè¿›ç¨‹ä»£ç ï¼š</p>

<p>int main()
{
 int sockfd, recvfd,ret;</p>

<p>struct sockaddr_un addr_client; <br />
 int length,buflen; 
 char data[10]; 
 ssize_t size;
 const char path[] = â€œ/export/home/temp/test/other_prog/fengxianzhongâ€; <br />
 char buf[] = â€œthis is client process ccc\nâ€ ;</p>

<p>sockfd = socket(AF_UNIX, SOCK_STREAM, 0);
 if(-1 == sockfd)
 {
  printf(â€œclient creat socket error!errno is %d\nâ€, errno);
 }</p>

<p>addr_client.sun_family = AF_UNIX;
    strcpy(addr_client.sun_path, path);
    length = sizeof(addr_client.sun_family) + sizeof(addr_client.sun_path);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ret = connect(sockfd, (struct sockaddr*)&amp;addr_client, length);  if(-1 == ret)  {   printf("in client connect error, errorno is %d\n",errno);   close(sockfd);    }
</code></pre></div></div>

<p>ret = func_recv_fd(sockfd, &amp;recvfd, data, sizeof(data));
 if(-1 == ret)
 {
  printf(â€œin client func_recv_fd failed\nâ€);
  close(sockfd);<br />
 }</p>

<p>size = -1;
 buflen = sizeof(buf);</p>

<p>if((size = write(recvfd, buf, buflen)) &lt;= 0)
 {
  printf(â€œin openfileprog, write failed\nâ€);
 }</p>

<p>printf(â€œclient write over!\nâ€);</p>

<p>exit(0);
}</p>

<p>å…¶ä¸­åŒæ ·è°ƒç”¨äº†func_recv_fdå‡½æ•°ã€‚åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¯¹å®ƒçš„å¤„ç†åŒfunc_send_fdå‡½æ•°ã€‚</p>

<p>ä¸è¦å¿˜äº†å†åŠ ä¸Šä»¥ä¸‹å¤´æ–‡ä»¶å’Œå®å®šä¹‰ï¼š
#include
#include
#include
#include
#include
#include
#include
#include
#include
#include
#define SLEEPTIME  3
#define ARGLEN     20</p>

<p>ä»¥ä¸Š3ä¸ªéƒ¨åˆ†ä»£ç åˆ†åˆ«ä½œä¸º3ä¸ªcæ–‡ä»¶ç¼–è¯‘å³å¯ã€‚</p>

<p>æ€»ç»“ï¼šä¸Šé¢çš„å‡½æ•°å¦‚func_recv_fdï¼Œfunc_send_fdä»£ç è¢«é‡å¤ä½¿ç”¨äº†ï¼Œè¿™æ ·æ˜¾å¾—å¾ˆå¤šä½™ã€‚å°±åƒä¸Šé¢æ‰€è¯´çš„å¯ä»¥ä½¿ç”¨å…¶ä»–æ–¹æ³•æ¥é¿å…å¦‚æ­¤é‡å¤ã€‚ä½†æ˜¯æˆ‘è¿™é‡Œé‡ç‚¹å®è·µæ–‡ä»¶æè¿°ç¬¦çš„ä¼ é€’ï¼Œå…¶ä½™çš„ï¼Œå°±ä¸å»å¤šè¿½ç©¶äº†ã€‚</p>

<p>å‚è€ƒèµ„æ–™ä¸­ä»¥ä¸‹å‡ æ®µè¯å€¼å¾—æˆ‘ä»¬å»ç†è§£ï¼š</p>

<p>è¿›ç¨‹å¯ä»¥ç”¨ä»»ä½•è¿”å›æè¿°ç¬¦çš„UNIXå‡½æ•°æ‰“å¼€ä¸€ä¸ªæè¿°ç¬¦ï¼šä¾‹å¦‚open()ã€pipe()ã€mkfifo()ã€socket()æˆ–è€…accept()ã€‚å¯ä»¥åœ¨è¿›ç¨‹é—´ä¼ é€’ä»»ä½•ç±»å‹çš„æè¿°ç¬¦ã€‚
ï¼ˆ3ï¼‰å‘é€è¿›ç¨‹å»ºç«‹ä¸€ä¸ªmsghdrç»“æ„ï¼Œå…¶ä¸­åŒ…å«è¦ä¼ é€’çš„æè¿°ç¬¦ã€‚åœ¨POSIXä¸­è¯´æ˜è¯¥æè¿°ç¬¦ä½œä¸ºè¾…åŠ©æ•°æ®å‘é€ï¼Œä½†è€çš„å®ç°ä½¿ç”¨msg_accrightæˆå‘˜ã€‚ï¼ˆè¿™é‡Œï¼Œåœ¨Opensolarisä¸Šï¼Œæˆ‘ä½¿ç”¨çš„å°±æ˜¯è€çš„æˆå‘˜ï¼‰å‘é€è¿›ç¨‹è°ƒç”¨sendmsg()é€šè¿‡ç¬¬ä¸€éƒ¨å¾—åˆ°çš„UNIXåŸŸå¥—æ¥å­—å‘å‡ºå¥—æ¥å­—ã€‚è¿™æ—¶è¿™ä¸ªæè¿°ç¬¦æ˜¯åœ¨é£è¡Œä¸­çš„ã€‚å³ä½¿åœ¨å‘é€è¿›ç¨‹è°ƒç”¨sendmsg()ä¹‹åï¼Œä½†åœ¨æ¥å—è¿›ç¨‹è°ƒç”¨recvmsg()ä¹‹å‰å°†æè¿°ç¬¦å…³é—­ï¼Œå®ƒä»ä¼šä¸ºæ¥æ”¶è¿›ç¨‹ä¿æŒæ‰“å¼€çŠ¶æ€ã€‚æè¿°ç¬¦çš„å‘é€å¯¼è‡´å®ƒçš„è®¿é—®ç»Ÿè®¡æ•°åŠ 1ã€‚</p>

<p>ï¼ˆ4ï¼‰æ¥æ”¶è¿›ç¨‹è°ƒç”¨recvmsg()åœ¨UNIXåŸŸå¥—æ¥å­—ä¸Šæ¥æ”¶å¥—æ¥å­—ã€‚é€šå¸¸æ¥æ”¶è¿›ç¨‹æ”¶åˆ°çš„æè¿°ç¬¦çš„ç¼–å·å’Œå‘é€è¿›ç¨‹ä¸­çš„æè¿°ç¬¦çš„ç¼–å·ä¸åŒï¼Œä½†è¿™æ²¡æœ‰é—®é¢˜ã€‚ä¼ é€’æè¿°ç¬¦ä¸æ˜¯ä¼ é€’æè¿°ç¬¦çš„ç¼–å·ï¼Œè€Œæ˜¯åœ¨æ¥æ”¶è¿›ç¨‹ä¸­å»ºç«‹ä¸€ä¸ªæ–°çš„æè¿°ç¬¦ï¼ŒæŒ‡å‘å†…æ ¸çš„æ–‡ä»¶è¡¨ä¸­ä¸å‘é€è¿›ç¨‹å‘é€çš„æè¿°ç¬¦ç›¸åŒçš„é¡¹ã€‚</p>

<ol>
  <li>TCPæœåŠ¡å™¨ç¨‹åºè®¾è®¡èŒƒå¼
â€ƒâ€ƒå¼€å‘ä¸€ä¸ªæœåŠ¡å™¨ç¨‹åºï¼Œæœ‰è¾ƒå¤šçš„çš„ç¨‹åºè®¾è®¡èŒƒå¼å¯ä¾›é€‰æ‹©ï¼Œä¸åŒèŒƒå¼æœ‰å…¶è‡ªèº«çš„ç‰¹ç‚¹å’Œå®ç”¨èŒƒå›´ï¼Œæ˜äº†ä¸åŒèŒƒå¼çš„ç‰¹æ€§æœ‰åŠ©äºæˆ‘ä»¬æœåŠ¡å™¨ç¨‹åºçš„å¼€å‘ã€‚å¸¸è§çš„TCPæœåŠ¡å™¨ç¨‹åºè®¾è®¡èŒƒå¼æœ‰ä»¥ä¸‹å‡ ç§ï¼š</li>
</ol>

<p>è¿­ä»£æœåŠ¡å™¨
å¹¶å‘æœåŠ¡å™¨ï¼Œæ¯ä¸ªå®¢æˆ·è¯·æ±‚forkä¸€ä¸ªå­è¿›ç¨‹
é¢„å…ˆæ´¾ç”Ÿå­è¿›ç¨‹ï¼Œæ¯ä¸ªå­è¿›ç¨‹æ— ä¿æŠ¤åœ°è°ƒç”¨accept
é¢„å…ˆæ´¾ç”Ÿå­è¿›ç¨‹,ä½¿ç”¨æ–‡ä»¶ä¸Šé”ä¿æŠ¤accept
é¢„å…ˆæ´¾ç”Ÿå­è¿›ç¨‹,ä½¿ç”¨çº¿ç¨‹äº’æ–¥é”ä¸Šé”ä¿æŠ¤accept
é¢„å…ˆæ´¾ç”Ÿå­è¿›ç¨‹ï¼Œçˆ¶è¿›ç¨‹å‘å­è¿›ç¨‹ä¼ é€’å¥—æ¥å­—æè¿°ç¬¦
å¹¶å‘æœåŠ¡å™¨ï¼Œæ¯ä¸ªå®¢æˆ·ç«¯è¯·æ±‚åˆ›å»ºä¸€ä¸ªçº¿ç¨‹
é¢„å…ˆåˆ›å»ºçº¿ç¨‹æœåŠ¡å™¨ï¼Œä½¿ç”¨äº’æ–¥é”ä¸Šé”ä¿æŠ¤accept
é¢„å…ˆåˆ›å»ºçº¿ç¨‹æœåŠ¡å™¨ï¼Œç”±ä¸»çº¿ç¨‹è°ƒç”¨accept
â€ƒâ€ƒå½“ç³»ç»Ÿè´Ÿè½½è¾ƒè½»æ—¶ï¼Œä¼ ç»Ÿçš„å¹¶å‘æœåŠ¡å™¨ç¨‹åºæ¨¡å‹å°±å¤Ÿäº†ã€‚ç›¸å¯¹äºä¼ ç»Ÿçš„æ¯ä¸ªå®¢æˆ·ä¸€æ¬¡forkè®¾è®¡ï¼Œé¢„å…ˆåˆ›å»ºä¸€ä¸ªè¿›ç¨‹æ± æˆ–çº¿ç¨‹æ± å¯ä»¥å‡å°‘è¿›ç¨‹æ§åˆ¶CPUæ—¶é—´ï¼Œå¤§çº¦å¯å‡å°‘10å€ä»¥ä¸Šã€‚</p>

<p>â€ƒâ€ƒæŸäº›å®ç°å…è®¸å¤šä¸ªå­è¿›ç¨‹æˆ–çº¿ç¨‹é˜»å¡åœ¨acceptä¸Šï¼Œç„¶è€Œåœ¨å¦ä¸€äº›å®ç°ä¸­ï¼Œæˆ‘ä»¬å¿…é¡»ä½¿ç”¨æ–‡ä»¶é”ã€çº¿ç¨‹äº’æ–¥é”æˆ–å…¶ä»–ç±»å‹çš„é”æ¥ç¡®ä¿æ¯æ¬¡åªæœ‰ä¸€ä¸ªå­è¿›ç¨‹æˆ–çº¿ç¨‹åœ¨acceptã€‚</p>

<p>â€ƒâ€ƒä¸€èˆ¬æ¥è®²ï¼Œæ‰€æœ‰å­è¿›ç¨‹æˆ–çº¿ç¨‹éƒ½è°ƒç”¨acceptè¦æ¯”çˆ¶è¿›ç¨‹æˆ–ä¸»çº¿ç¨‹è°ƒç”¨acceptåå°†æè¿°å­—ä¼ é€’ä¸ªå­è¿›ç¨‹æˆ–çº¿ç¨‹æ¥å¾—å¿«ä¸”ç®€å•ã€‚</p>

<ol>
  <li>Nebula ä¸ºä»€ä¹ˆé‡‡ç”¨ä¼ é€’æ–‡ä»¶æè¿°ç¬¦æ–¹å¼ï¼Ÿ
â€ƒâ€ƒNebulaæ¡†æ¶æ˜¯é¢„å…ˆåˆ›å»ºå¤šè¿›ç¨‹ï¼Œç”±Managerä¸»è¿›ç¨‹acceptåä¼ é€’æ–‡ä»¶æè¿°ç¬¦åˆ°Workerå­è¿›ç¨‹çš„æœåŠ¡æ¨¡å‹ï¼ˆNebulaè¿›ç¨‹æ¨¡å‹ï¼‰ã€‚ä¸ºä»€ä¹ˆä¸é‡‡ç”¨åƒnginxé‚£æ ·å¤šçº¿ç¨‹ç”±å­çº¿ç¨‹ä½¿ç”¨äº’æ–¥é”ä¸Šé”ä¿æŠ¤acceptçš„æœåŠ¡æ¨¡å‹ï¼Ÿè€Œä¸”è¿™ç§æœåŠ¡æ¨¡å‹çš„å®ç°æ¯”ä¼ é€’æ–‡ä»¶æè¿°ç¬¦æ¥å¾—è¿˜ç®€å•ä¸€äº›ã€‚</li>
</ol>

<p>â€ƒâ€ƒNebulaæ¡†æ¶é‡‡ç”¨æ— é”è®¾è®¡ï¼Œè¿›ç¨‹ä¹‹å‰å®Œå…¨ä¸å…±äº«æ•°æ®ï¼Œä¸å­˜åœ¨éœ€è¦äº’æ–¥è®¿é—®çš„åœ°æ–¹ã€‚æ²¡é”™ï¼Œä¼šå­˜åœ¨æ•°æ®å¤šå‰¯æœ¬é—®é¢˜ï¼Œä½†è¿™äº›å¤šå‰¯æœ¬å¾€å¾€åªæ˜¯äº›é…ç½®æ•°æ®ï¼Œå ç”¨ä¸äº†å¤ªå¤§å†…å­˜ï¼Œä¸åŠ é”è§£é”å¸¦æ¥çš„ä»£ç å¤æ‚åº¦åŠé”å¼€é”€ç›¸æ¯”è¿™ç‚¹å†…å­˜ä»£ä»·æ›´åˆ’ç®—ä¹Ÿæ›´ç®€å•ã€‚</p>

<p>â€ƒâ€ƒåŒä¸€ä¸ªNebulaæœåŠ¡çš„å·¥ä½œè¿›ç¨‹é—´ä¸ç›¸äº’é€šä¿¡ï¼Œé‡‡ç”¨è¿›ç¨‹å’Œçº¿ç¨‹å¹¶æ— å¤ªå¤§å·®å¼‚ï¼Œä¹‹æ‰€ä»¥é‡‡ç”¨è¿›ç¨‹è€Œä¸æ˜¯çº¿ç¨‹çš„æœ€é‡è¦è€ƒè™‘æ˜¯Nebulaæ˜¯å‡ºäºç¨³å®šæ€§å’Œå®¹é”™æ€§è€ƒè™‘ã€‚Nebulaæ˜¯é€šç”¨æ¡†æ¶ï¼Œå®Œå…¨ä¸šåŠ¡æ— å…³ï¼Œä¸šåŠ¡éƒ½æ˜¯é€šè¿‡åŠ¨æ€åŠ è½½çš„æ–¹å¼æˆ–é€šè¿‡å°†Nebulaé“¾æ¥è¿›ä¸šåŠ¡Serverçš„æ–¹å¼æ¥å®ç°ã€‚Nebulaæ¡†æ¶æ— æ³•é¢„çŸ¥ä¸šåŠ¡ä»£ç çš„è´¨é‡ï¼Œä½†å¯ä»¥ä¿è¯åœ¨æœåŠ¡å› ä¸šåŠ¡ä»£ç å¯¼è‡´coredumpæˆ–å…¶ä»–æƒ…å†µæ—¶ï¼Œæ¡†æ¶å¯ä»¥å®æ—¶ç›‘æ§åˆ°å¹¶ç«‹åˆ»æ‹‰èµ·æœåŠ¡è¿›ç¨‹ï¼Œæœ€å¤§ç¨‹åº¦ä¿éšœæœåŠ¡å¯ç”¨æ€§ã€‚</p>

<p>â€ƒâ€ƒå†³å®šNebulaé‡‡ç”¨ä¼ é€’æ–‡ä»¶æè¿°ç¬¦æ–¹å¼çš„æœ€é‡è¦ä¸€ç‚¹æ˜¯ï¼šNebulaå®šä½æ˜¯é«˜æ€§èƒ½åˆ†å¸ƒå¼æœåŠ¡é›†ç¾¤è§£å†³æ–¹æ¡ˆçš„åŸºç¡€é€šä¿¡æ¡†æ¶ï¼Œå…¶è®¾è®¡æ›´å¤šè¦ä¸ºæ„å»ºåˆ†å¸ƒå¼æœåŠ¡é›†ç¾¤è€Œè€ƒè™‘ã€‚é›†ç¾¤ä¸åŒæœåŠ¡èŠ‚ç‚¹ä¹‹é—´é€šè¿‡TCPé€šä¿¡ï¼Œè€Œæ‰€æœ‰é€»è¾‘éƒ½æ˜¯Workerè¿›ç¨‹è´Ÿè´£ï¼Œè¿™æ„å‘³ç€èŠ‚ç‚¹ä¹‹é—´é€šä¿¡éœ€è¦æŒ‡å®šåˆ°Workerè¿›ç¨‹ï¼Œè€Œå¦‚æœé‡‡ç”¨å­è¿›ç¨‹ç«äº‰acceptçš„æ–¹å¼æ— æ³•ä¿è¯æŒ‡å®šçš„å­è¿›ç¨‹è·å¾—èµ„æºï¼Œé‚£ä¹ˆç¬¬ä¸€ä¸ªé€šä¿¡æ•°æ®åŒ…å°†ä¼šè·¯ç”±é”™è¯¯ã€‚é‡‡ç”¨ä¼ é€’æ–‡ä»¶æè¿°ç¬¦æ–¹å¼å¯ä»¥å¾ˆå®Œç¾åœ°è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œè€Œä¸”ä¼ é€’æ–‡ä»¶æè¿°ç¬¦ä¹Ÿéå¸¸é«˜æ•ˆã€‚</p>

<ol>
  <li>æ–‡ä»¶æè¿°ç¬¦ä¼ é€’å‡½æ•°å’Œæ•°æ®ç»“æ„
â€ƒâ€ƒæ–‡ä»¶æè¿°ç¬¦ä¼ é€’é€šè¿‡è°ƒç”¨sendmsg()å‡½æ•°å‘é€ï¼Œè°ƒç”¨recvmsg()å‡½æ•°æ¥æ”¶ï¼š</li>
</ol>

<p>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;</p>

<p>ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
â€ƒâ€ƒè¿™ä¸¤ä¸ªå‡½æ•°ä¸sendtoå’Œrecvfromå‡½æ•°ç›¸ä¼¼ï¼Œåªä¸è¿‡å¯ä»¥ä¼ è¾“æ›´å¤æ‚çš„æ•°æ®ç»“æ„ï¼Œä¸ä»…å¯ä»¥ä¼ è¾“ä¸€èˆ¬æ•°æ®ï¼Œè¿˜å¯ä»¥ä¼ è¾“é¢å¤–çš„æ•°æ®ï¼Œå³æ–‡ä»¶æè¿°ç¬¦ã€‚ä¸‹é¢æ¥çœ‹ç»“æ„ä½“msghdråŠå…¶ç›¸å…³ç»“æ„ä½“ ï¼š</p>

<p>struct msghdr {
    void         <em>msg_name;       /</em> optional address <em>/
    socklen_t     msg_namelen;    /</em> size of address <em>/
    struct iovec *msg_iov;        /</em> scatter/gather array <em>/
    size_t        msg_iovlen;     /</em> # elements in msg_iov <em>/
    void         *msg_control;    /</em> ancillary data, see below <em>/
    size_t        msg_controllen; /</em> ancillary data buffer len <em>/
    int           msg_flags;      /</em> flags on received message */
};</p>

<p>/* iovecç»“æ„ä½“ <em>/
struct iovec {
    void  *iov_base;    /</em> Starting address <em>/
    size_t iov_len;     /</em> Number of bytes to transfer */
};</p>

<p>/* cmsghdrç»“æ„ä½“ <em>/
struct cmsghdr {
    socklen_t cmsg_len;    /</em> data byte count, including header <em>/
    int       cmsg_level;  /</em> originating protocol <em>/
    int       cmsg_type;   /</em> protocol-specific type <em>/
    /</em> followed by unsigned char cmsg_data[]; */
};
â€ƒâ€ƒmsghdrç»“æ„æˆå‘˜è¯´æ˜ï¼š</p>

<p>msg_name ï¼šå³å¯¹ç­‰æ–¹çš„åœ°å€æŒ‡é’ˆï¼Œä¸å…³å¿ƒæ—¶è®¾ä¸ºNULLå³å¯.
msg_namelenï¼šåœ°å€é•¿åº¦ï¼Œä¸å…³å¿ƒæ—¶è®¾ç½®ä¸º0å³å¯.
msg_iovï¼šç»“æ„ä½“iovecæŒ‡é’ˆ; iovecçš„æˆå‘˜iov_base å¯ä»¥è®¤ä¸ºæ˜¯ä¼ è¾“æ­£å¸¸æ•°æ®æ—¶çš„bufï¼Œiov_len æ˜¯buf çš„å¤§å°ã€‚
msg_iovlenï¼šiovecç±»å‹çš„å…ƒç´ çš„ä¸ªæ•°ï¼Œæ¯ä¸€ä¸ªç¼“å†²åŒºçš„èµ·å§‹åœ°å€å’Œå¤§å°ç”±iovecç±»å‹è‡ªåŒ…å«ã€‚å½“æœ‰nä¸ªiovecç»“æ„ä½“æ—¶ï¼Œæ­¤å€¼ä¸ºnã€‚
msg_controlï¼šæ˜¯ä¸€ä¸ªæŒ‡å‘cmsghdr ç»“æ„ä½“çš„æŒ‡é’ˆï¼Œç”¨æ¥å‘é€æˆ–æ¥æ”¶æ§åˆ¶ä¿¡æ¯ã€‚
msg_controllen ï¼šæ§åˆ¶ä¿¡æ¯æ‰€å ç”¨çš„å­—èŠ‚æ•°ã€‚æ³¨æ„ï¼Œmsg_controllenä¸å‰é¢çš„msg_iovlenä¸åŒï¼Œmsg_iovlenæ˜¯æŒ‡çš„ç”±æˆå‘˜msg_iovæ‰€æŒ‡å‘çš„iovecå‹çš„æ•°ç»„çš„å…ƒç´ ä¸ªæ•°ï¼Œè€Œmsg_controllenï¼Œåˆ™æ˜¯æ‰€æœ‰æ§åˆ¶ä¿¡æ¯æ‰€å ç”¨çš„æ€»çš„å­—èŠ‚æ•°ã€‚
msg_flags ï¼š ç”¨æ¥æè¿°æ¥å—åˆ°çš„æ¶ˆæ¯çš„æ€§è´¨ï¼Œç”±è°ƒç”¨recvmsgæ—¶ä¼ å…¥çš„flagså‚æ•°è®¾ç½®ã€‚
â€ƒâ€ƒä¸ºäº†å¯¹é½ï¼Œå¯èƒ½å­˜åœ¨ä¸€äº›å¡«å……å­—èŠ‚ï¼Œè·Ÿä¸åŒç³»ç»Ÿçš„å®ç°æœ‰å…³æ§åˆ¶ä¿¡æ¯çš„æ•°æ®éƒ¨åˆ†ï¼Œæ˜¯ç›´æ¥å­˜å‚¨åœ¨cmsghdrç»“æ„ä½“çš„cmsg_typeä¹‹åçš„ã€‚ä½†ä¸­é—´å¯èƒ½æœ‰ä¸€äº›ç”±äºå¯¹é½äº§ç”Ÿçš„å¡«å……å­—èŠ‚ï¼Œç”±äºè¿™äº›å¡«å……æ•°æ®çš„å­˜åœ¨ï¼Œå¯¹äºè¿™äº›æ§åˆ¶æ•°æ®çš„è®¿é—®ï¼Œå¿…é¡»ä½¿ç”¨Linuxæä¾›çš„ä¸€äº›ä¸“ç”¨å®æ¥å®Œæˆï¼š</p>

<p>#include &lt;sys/socket.h&gt;</p>

<p>/* è¿”å›msghæ‰€æŒ‡å‘çš„msghdrç±»å‹çš„ç¼“å†²åŒºä¸­çš„ç¬¬ä¸€ä¸ªcmsghdrç»“æ„ä½“çš„æŒ‡é’ˆã€‚*/
struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *msgh);</p>

<p>/* è¿”å›ä¼ å…¥çš„cmsghdrç±»å‹çš„æŒ‡é’ˆçš„ä¸‹ä¸€ä¸ªcmsghdrç»“æ„ä½“çš„æŒ‡é’ˆã€‚ */
struct cmsghdr *CMSG_NXTHDR(struct msghdr *msgh, struct cmsghdr *cmsg);</p>

<p>/* æ ¹æ®ä¼ å…¥çš„lengthå¤§å°,è¿”å›ä¸€ä¸ªåŒ…å«äº†æ·»åŠ å¯¹é½ä½œç”¨çš„å¡«å……æ•°æ®åçš„å¤§å°ã€‚ */
size_t CMSG_ALIGN(size_t length);</p>

<p>/* ä¼ å…¥çš„å‚æ•°lengthæŒ‡çš„æ˜¯ä¸€ä¸ªæ§åˆ¶ä¿¡æ¯å…ƒç´ (å³ä¸€ä¸ªcmsghdrç»“æ„ä½“)åé¢æ•°æ®éƒ¨åˆ†çš„å­—èŠ‚æ•°,è¿”å›çš„æ˜¯è¿™ä¸ªæ§åˆ¶ä¿¡æ¯çš„æ€»çš„å­—èŠ‚æ•°,å³åŒ…å«äº†å¤´éƒ¨(å³cmsghdrå„æˆå‘˜)ã€æ•°æ®éƒ¨åˆ†å’Œå¡«å……æ•°æ®çš„æ€»å’Œã€‚*/
size_t CMSG_SPACE(size_t length);</p>

<p>/* æ ¹æ®ä¼ å…¥çš„cmsghdræŒ‡é’ˆå‚æ•°ï¼Œè¿”å›å…¶åé¢æ•°æ®éƒ¨åˆ†çš„æŒ‡é’ˆã€‚*/
size_t CMSG_LEN(size_t length);</p>

<p>/* ä¼ å…¥çš„å‚æ•°æ˜¯ä¸€ä¸ªæ§åˆ¶ä¿¡æ¯ä¸­çš„æ•°æ®éƒ¨åˆ†çš„å¤§å°ï¼Œè¿”å›çš„æ˜¯è¿™ä¸ªæ ¹æ®è¿™ä¸ªæ•°æ®éƒ¨åˆ†å¤§å°ï¼Œéœ€è¦é…ç½®çš„cmsghdrç»“æ„ä½“ä¸­cmsg_lenæˆå‘˜çš„å€¼ã€‚è¿™ä¸ªå¤§å°å°†ä¸ºå¯¹é½æ·»åŠ çš„å¡«å……æ•°æ®ä¹ŸåŒ…å«åœ¨å†…ã€‚*/
unsigned char *CMSG_DATA(struct cmsghdr *cmsg);</p>
<ol>
  <li>æ–‡ä»¶æè¿°ç¬¦ä¼ é€’è¦ç‚¹
â€ƒâ€ƒsendmsgæä¾›äº†å¯ä»¥ä¼ é€’æ§åˆ¶ä¿¡æ¯çš„åŠŸèƒ½ï¼Œè¦å®ç°çš„ä¼ é€’æè¿°ç¬¦è¿™ä¸€åŠŸèƒ½å¿…é¡»è¦ç”¨åˆ°è¿™ä¸ªæ§åˆ¶ä¿¡æ¯ã€‚åœ¨msghdrå˜é‡çš„cmsghdræˆå‘˜ä¸­ï¼Œç”±æ§åˆ¶å¤´cmsg_levelå’Œcmsg_typeæ¥è®¾ç½®ä¼ é€’æ–‡ä»¶æè¿°ç¬¦è¿™ä¸€å±æ€§ï¼Œå¹¶å°†è¦ä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦ä½œä¸ºæ•°æ®éƒ¨åˆ†ï¼Œä¿å­˜åœ¨cmsghdrå˜é‡çš„åé¢ã€‚è¿™æ ·å°±å¯ä»¥å®ç°ä¼ é€’æ–‡ä»¶æè¿°ç¬¦è¿™ä¸€åŠŸèƒ½ï¼Œè¿™ç§æƒ…å†µæ˜¯ä¸éœ€è¦ä½¿ç”¨msg_iovæ¥ä¼ é€’æ•°æ®çš„ã€‚</li>
</ol>

<p>â€ƒâ€ƒå…·ä½“åœ°è¯´ï¼Œä¸ºmsghdrçš„æˆå‘˜msg_controlåˆ†é…ä¸€ä¸ªcmsghdrçš„ç©ºé—´ï¼Œå°†è¯¥cmsghdrç»“æ„çš„cmsg_levelè®¾ç½®ä¸ºSOL_SOCKETï¼Œcmsg_typeè®¾ç½®ä¸ºSCM_RIGHTSï¼Œå¹¶å°†è¦ä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦ä½œä¸ºæ•°æ®éƒ¨åˆ†ï¼Œè°ƒç”¨sendmsgå³å¯ã€‚å…¶ä¸­SCMè¡¨ç¤ºsocket-level control messageï¼ŒSCM_RIGHTSè¡¨ç¤ºæˆ‘ä»¬è¦ä¼ é€’è®¿é—®æƒé™ã€‚</p>

<p>â€ƒâ€ƒè·Ÿå‘é€éƒ¨åˆ†ä¸€æ ·ï¼Œä¸ºæ§åˆ¶ä¿¡æ¯é…ç½®å¥½å±æ€§ï¼Œå¹¶åœ¨å…¶ååˆ†é…ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦çš„æ•°æ®éƒ¨åˆ†åï¼Œåœ¨æˆåŠŸè°ƒç”¨recvmsgåï¼Œæ§åˆ¶ä¿¡æ¯çš„æ•°æ®éƒ¨åˆ†å°±æ˜¯åœ¨æ¥æ”¶è¿›ç¨‹ä¸­çš„æ–°çš„æ–‡ä»¶æè¿°ç¬¦äº†ï¼Œæ¥æ”¶è¿›ç¨‹å¯ç›´æ¥å¯¹è¯¥æ–‡ä»¶æè¿°ç¬¦è¿›è¡Œæ“ä½œã€‚</p>

<p>â€ƒâ€ƒæ–‡ä»¶æè¿°ç¬¦ä¼ é€’å¹¶ä¸æ˜¯å°†æ–‡ä»¶æè¿°ç¬¦æ•°å­—ä¼ é€’ï¼Œè€Œæ˜¯æ–‡ä»¶æè¿°ç¬¦å¯¹åº”æ•°æ®ç»“æ„ã€‚åœ¨ä¸»è¿›ç¨‹acceptçš„åˆ°çš„æ–‡ä»¶æè¿°ç¬¦7ä¼ é€’åˆ°å­è¿›ç¨‹åæ–‡ä»¶æè¿°ç¬¦æœ‰å¯èƒ½æ˜¯7ï¼Œæ›´æœ‰å¯èƒ½æ˜¯7ä»¥å¤–çš„å…¶ä»–æ•°å€¼ï¼Œä½†æ— è®ºæ˜¯ä»€ä¹ˆæ•°å€¼å¹¶ä¸é‡è¦ï¼Œé‡è¦çš„æ˜¯ä¼ é€’ä¹‹åçš„è¿æ¥è·Ÿä¼ é€’ä¹‹å‰çš„è¿æ¥æ˜¯åŒä¸€ä¸ªè¿æ¥ã€‚</p>

<p>â€ƒâ€ƒé€šå¸¸åœ¨å®Œæˆæ–‡ä»¶æè¿°ç¬¦ä¼ é€’åï¼Œæ¥æ”¶è¿›ç¨‹æ¥ç®¡æ–‡ä»¶æè¿°ç¬¦ï¼Œå‘é€è¿›ç¨‹åˆ™åº”è°ƒç”¨closeå…³é—­å·²ä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦ã€‚å‘é€è¿›ç¨‹å…³é—­æè¿°ç¬¦å¹¶ä¸é€ æˆå…³é—­è¯¥æ–‡ä»¶æˆ–è®¾å¤‡ï¼Œå› ä¸ºè¯¥æè¿°ç¬¦å¯¹åº”çš„æ–‡ä»¶ä»è¢«è§†ä¸ºç”±æ¥æ”¶è€…è¿›ç¨‹æ‰“å¼€ï¼ˆå³ä½¿æ¥æ”¶è¿›ç¨‹å°šæœªæ¥æ”¶åˆ°è¯¥æè¿°ç¬¦ï¼‰ã€‚</p>

<p>â€ƒâ€ƒæ–‡ä»¶æè¿°ç¬¦ä¼ é€’å¯ç»ç”±åŸºäºSTREAMSçš„ç®¡é“ï¼Œä¹Ÿå¯ç»ç”±UNIXåŸŸå¥—æ¥å­—ã€‚ä¸¤ç§æ–¹å¼åœ¨ã€ŠUNIXç½‘ç»œç¼–ç¨‹ã€‹ä¸­å‡æœ‰æè¿°ï¼ŒNebulaé‡‡ç”¨çš„UNIXåŸŸå¥—æ¥å­—ä¼ é€’æ–‡ä»¶æè¿°ç¬¦ã€‚</p>

<p>â€ƒâ€ƒåˆ›å»ºç”¨äºä¼ é€’æ–‡ä»¶æè¿°ç¬¦çš„UNIXåŸŸå¥—æ¥å­—ç”¨åˆ°socketpairå‡½æ•°ï¼š</p>

<p>#include &lt;sys/types.h&gt;<br />
#include &lt;sys/socket.h&gt;</p>

<p>int socketpair(int d, int type, int protocol, int sv[2]);<br />
â€ƒâ€ƒä¼ å…¥çš„å‚æ•°svä¸ºä¸€ä¸ªæ•´å‹æ•°ç»„ï¼Œæœ‰ä¸¤ä¸ªå…ƒç´ ã€‚å½“è°ƒç”¨æˆåŠŸåï¼Œè¿™ä¸ªæ•°ç»„çš„ä¸¤ä¸ªå…ƒç´ å³ä¸º2ä¸ªæ–‡ä»¶æè¿°ç¬¦ã€‚ä¸€å¯¹è¿æ¥èµ·æ¥çš„UnixåŒ¿ååŸŸå¥—æ¥å­—å°±å»ºç«‹èµ·æ¥äº†ï¼Œå®ƒä»¬å°±åƒä¸€ä¸ªå…¨åŒå·¥çš„ç®¡é“ï¼Œæ¯ä¸€ç«¯éƒ½æ—¢å¯è¯»ä¹Ÿå¯å†™ã€‚</p>

<ol>
  <li>Nebulaæ¡†æ¶ä¸­ä¼ é€’æ–‡ä»¶æè¿°ç¬¦çš„å®ç°
â€ƒâ€ƒNebulaæ¡†æ¶çš„æ–‡ä»¶æè¿°ç¬¦å±äºSocketChannelçš„åŸºæœ¬å±æ€§ï¼Œæ–‡ä»¶æè¿°ç¬¦ä¼ é€’æ–¹æ³•æ˜¯SocketChannelçš„é™æ€æ–¹æ³•ã€‚</li>
</ol>

<p>æ–‡ä»¶æè¿°ç¬¦ä¼ é€’æ–¹æ³•å£°æ˜ï¼š</p>

<p>static int SendChannelFd(int iSocketFd, int iSendFd, int iCodecType, std::shared_ptr<NetLogger> pLogger);
static int RecvChannelFd(int iSocketFd, int&amp; iRecvFd, int&amp; iCodecType, std::shared_ptr<NetLogger> pLogger);
æ–‡ä»¶æè¿°ç¬¦å‘é€æ–¹æ³•å®ç°ï¼š</NetLogger></NetLogger></p>

<p>/**</p>
<ul>
  <li>@brief å‘é€æ–‡ä»¶æè¿°ç¬¦</li>
  <li>@param iSocketFd ç”±socketpair()åˆ›å»ºçš„UNIXåŸŸå¥—æ¥å­—ï¼Œç”¨äºä¼ é€’æ–‡ä»¶æè¿°ç¬¦</li>
  <li>@param iSendFd å¾…å‘é€çš„æ–‡ä»¶æè¿°ç¬¦</li>
  <li>@param iCodecType é€šä¿¡é€šé“ç¼–è§£ç ç±»å‹</li>
  <li>@param pLogger æ—¥å¿—ç±»æŒ‡é’ˆ</li>
  <li>
    <p>@return errno é”™è¯¯ç 
*/
int SocketChannel::SendChannelFd(int iSocketFd, int iSendFd, int iCodecType, std::shared_ptr<NetLogger> pLogger)
{
  ssize_t             n;
  struct iovec        iov[1];
  struct msghdr       msg;
  tagChannelCtx stCh;
  int iError = 0;</NetLogger></p>

    <p>stCh.iFd = iSendFd;
  stCh.iCodecType = iCodecType;</p>

    <p>union
  {
      struct cmsghdr  cm;
      char            space[CMSG_SPACE(sizeof(int))];
  } cmsg;</p>

    <p>if (stCh.iFd == -1)
  {
      msg.msg_control = NULL;
      msg.msg_controllen = 0;</p>

    <p>}
  else
  {
      msg.msg_control = (caddr_t) &amp;cmsg;
      msg.msg_controllen = sizeof(cmsg);</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  memset(&amp;cmsg, 0, sizeof(cmsg));

  cmsg.cm.cmsg_len = CMSG_LEN(sizeof(int));
  cmsg.cm.cmsg_level = SOL_SOCKET;
  cmsg.cm.cmsg_type = SCM_RIGHTS;

  *(int *) CMSG_DATA(&amp;cmsg.cm) = stCh.iFd;   }
</code></pre></div>    </div>

    <p>msg.msg_flags = 0;</p>

    <p>iov[0].iov_base = (char*)&amp;stCh;
  iov[0].iov_len = sizeof(tagChannelCtx);</p>

    <p>msg.msg_name = NULL;
  msg.msg_namelen = 0;
  msg.msg_iov = iov;
  msg.msg_iovlen = 1;</p>

    <p>n = sendmsg(iSocketFd, &amp;msg, 0);</p>

    <p>if (n == -1)
  {
      pLogger-&gt;WriteLog(neb::Logger::ERROR, <strong>FILE</strong>, <strong>LINE</strong>, <strong>FUNCTION</strong>, â€œsendmsg() failed, errno %dâ€, errno);
      iError = (errno == 0) ? ERR_TRANSFER_FD : errno;
      return(iError);
  }</p>

    <p>return(ERR_OK);
}
æ–‡ä»¶æè¿°ç¬¦æ¥æ”¶æ–¹æ³•å®ç°ï¼š</p>
  </li>
</ul>

<p>/**</p>
<ul>
  <li>@brief æ¥æ”¶æ–‡ä»¶æè¿°ç¬¦</li>
  <li>@param iSocketFd ç”±socketpair()åˆ›å»ºçš„UNIXåŸŸå¥—æ¥å­—ï¼Œç”¨äºä¼ é€’æ–‡ä»¶æè¿°ç¬¦</li>
  <li>@param iRecvFd æ¥æ”¶åˆ°çš„æ–‡ä»¶æè¿°ç¬¦</li>
  <li>@param iCodecType æ¥æ”¶åˆ°çš„é€šä¿¡é€šé“ç¼–è§£ç ç±»å‹</li>
  <li>@param pLogger æ—¥å¿—ç±»æŒ‡é’ˆ</li>
  <li>
    <p>@return errno é”™è¯¯ç 
*/
int SocketChannel::RecvChannelFd(int iSocketFd, int&amp; iRecvFd, int&amp; iCodecType, std::shared_ptr<NetLogger> pLogger)
{
  ssize_t             n;
  struct iovec        iov[1];
  struct msghdr       msg;
  tagChannelCtx stCh;
  int iError = 0;</NetLogger></p>

    <p>union {
      struct cmsghdr  cm;
      char            space[CMSG_SPACE(sizeof(int))];
  } cmsg;</p>

    <p>iov[0].iov_base = (char*)&amp;stCh;
  iov[0].iov_len = sizeof(tagChannelCtx);</p>

    <p>msg.msg_name = NULL;
  msg.msg_namelen = 0;
  msg.msg_iov = iov;
  msg.msg_iovlen = 1;</p>

    <p>msg.msg_control = (caddr_t) &amp;cmsg;
  msg.msg_controllen = sizeof(cmsg);</p>

    <p>n = recvmsg(iSocketFd, &amp;msg, 0);</p>

    <p>if (n == -1) {
      pLogger-&gt;WriteLog(neb::Logger::ERROR, <strong>FILE</strong>, <strong>LINE</strong>, <strong>FUNCTION</strong>, â€œrecvmsg() failed, errno %dâ€, errno);
      iError = (errno == 0) ? ERR_TRANSFER_FD : errno;
      return(iError);
  }</p>

    <p>if (n == 0) {
      pLogger-&gt;WriteLog(neb::Logger::ERROR, <strong>FILE</strong>, <strong>LINE</strong>, <strong>FUNCTION</strong>, â€œrecvmsg() return zero, errno %dâ€, errno);
      iError = (errno == 0) ? ERR_TRANSFER_FD : errno;
      return(ERR_CHANNEL_EOF);
  }</p>

    <p>if ((size_t) n &lt; sizeof(tagChannelCtx))
  {
      pLogger-&gt;WriteLog(neb::Logger::ERROR, <strong>FILE</strong>, <strong>LINE</strong>, <strong>FUNCTION</strong>, â€œrrecvmsg() returned not enough data: %z, errno %dâ€, n, errno);
      iError = (errno == 0) ? ERR_TRANSFER_FD : errno;
      return(iError);
  }</p>

    <p>if (cmsg.cm.cmsg_len &lt; (socklen_t) CMSG_LEN(sizeof(int)))
  {
      pLogger-&gt;WriteLog(neb::Logger::ERROR, <strong>FILE</strong>, <strong>LINE</strong>, <strong>FUNCTION</strong>, â€œrecvmsg() returned too small ancillary dataâ€);
      iError = (errno == 0) ? ERR_TRANSFER_FD : errno;
      return(iError);
  }</p>

    <p>if (cmsg.cm.cmsg_level != SOL_SOCKET || cmsg.cm.cmsg_type != SCM_RIGHTS)
  {
      pLogger-&gt;WriteLog(neb::Logger::ERROR, <strong>FILE</strong>, <strong>LINE</strong>, <strong>FUNCTION</strong>,
                      â€œrecvmsg() returned invalid ancillary data level %d or type %dâ€, cmsg.cm.cmsg_level, cmsg.cm.cmsg_type);
      iError = (errno == 0) ? ERR_TRANSFER_FD : errno;
      return(iError);
  }</p>

    <p>stCh.iFd = *(int *) CMSG_DATA(&amp;cmsg.cm);</p>

    <p>if (msg.msg_flags &amp; (MSG_TRUNC|MSG_CTRUNC))
  {
      pLogger-&gt;WriteLog(neb::Logger::ERROR, <strong>FILE</strong>, <strong>LINE</strong>, <strong>FUNCTION</strong>, â€œrecvmsg() truncated dataâ€);
      iError = (errno == 0) ? ERR_TRANSFER_FD : errno;
      return(iError);
  }</p>

    <p>iRecvFd = stCh.iFd;
  iCodecType = stCh.iCodecType;</p>

    <p>return(ERR_OK);
}
Managerè¿›ç¨‹çš„void Manager::CreateWorker()æ–¹æ³•åˆ›å»ºç”¨äºä¼ é€’æ–‡ä»¶æè¿°ç¬¦çš„UNIXåŸŸå¥—æ¥å­—ï¼š</p>
  </li>
</ul>

<p>int iControlFds[2];
int iDataFds[2];
if (socketpair(PF_UNIX, SOCK_STREAM, 0, iControlFds) &lt; 0)
{
    LOG4_ERROR(â€œerror %d: %sâ€, errno, strerror_r(errno, m_szErrBuff, 1024));
}
if (socketpair(PF_UNIX, SOCK_STREAM, 0, iDataFds) &lt; 0)
{
    LOG4_ERROR(â€œerror %d: %sâ€, errno, strerror_r(errno, m_szErrBuff, 1024));
}
Managerè¿›ç¨‹å‘é€æ–‡ä»¶æè¿°ç¬¦ï¼š</p>

<p>int iCodec = m_stManagerInfo.eCodec;    // å°†ç¼–è§£ç æ–¹å¼å’Œæ–‡ä»¶æè¿°ç¬¦ä¸€åŒå‘é€ç»™Workerè¿›ç¨‹
int iErrno = SocketChannel::SendChannelFd(worker_pid_fd.second, iAcceptFd, iCodec, m_pLogger);
if (iErrno == 0)
{
    AddWorkerLoad(worker_pid_fd.first);
}
else
{
    LOG4_ERROR(â€œerror %d: %sâ€, iErrno, strerror_r(iErrno, m_szErrBuff, 1024));
}
close(iAcceptFd);   // å‘é€å®Œæ¯•ï¼Œå…³é—­æ–‡ä»¶æè¿°ç¬¦
Workerè¿›ç¨‹æ¥æ”¶æ–‡ä»¶æè¿°ç¬¦ï¼š</p>

<p>int iAcceptFd = -1;
int iCodec = 0;     // è¿™é‡Œçš„ç¼–è§£ç æ–¹å¼åœ¨RecvChannelFdæ–¹æ³•ä¸­è·å¾—
int iErrno = SocketChannel::RecvChannelFd(m_stWorkerInfo.iManagerDataFd, iAcceptFd, iCodec, m_pLogger);
â€ƒâ€ƒè‡³æ­¤ï¼ŒNebulaæ¡†æ¶çš„æ–‡ä»¶æè¿°ç¬¦ä¼ é€’åˆ†äº«å®Œæ¯•ï¼Œä¸‹é¢å†çœ‹çœ‹nginxä¸­çš„æ–‡ä»¶æè¿°ç¬¦ä¼ é€’å®ç°ã€‚</p>

<ol>
  <li>Nginxæ–‡ä»¶æè¿°ç¬¦ä¼ é€’ä»£ç å®ç°
â€ƒâ€ƒNginxçš„æ–‡ä»¶æè¿°ç¬¦ä¼ é€’ä»£ç åœ¨os/unix/ngx_channel.cæ–‡ä»¶ä¸­ã€‚</li>
</ol>

<p>nginxä¸­å‘é€æ–‡ä»¶æè¿°ç¬¦ä»£ç ï¼š</p>

<p>ngx_int_t
ngx_write_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size,
    ngx_log_t *log)
{
    ssize_t             n;
    ngx_err_t           err;
    struct iovec        iov[1];
    struct msghdr       msg;</p>

<p>#if (NGX_HAVE_MSGHDR_MSG_CONTROL)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>union {
    struct cmsghdr  cm;
    char            space[CMSG_SPACE(sizeof(int))];
} cmsg;

if (ch-&gt;fd == -1) {
    msg.msg_control = NULL;
    msg.msg_controllen = 0;

} else {
    msg.msg_control = (caddr_t) &amp;cmsg;
    msg.msg_controllen = sizeof(cmsg);

    ngx_memzero(&amp;cmsg, sizeof(cmsg));

    cmsg.cm.cmsg_len = CMSG_LEN(sizeof(int));
    cmsg.cm.cmsg_level = SOL_SOCKET;
    cmsg.cm.cmsg_type = SCM_RIGHTS;

    /*
     * We have to use ngx_memcpy() instead of simple
     *   *(int *) CMSG_DATA(&amp;cmsg.cm) = ch-&gt;fd;
     * because some gcc 4.4 with -O2/3/s optimization issues the warning:
     *   dereferencing type-punned pointer will break strict-aliasing rules
     *
     * Fortunately, gcc with -O1 compiles this ngx_memcpy()
     * in the same simple assignment as in the code above
     */

    ngx_memcpy(CMSG_DATA(&amp;cmsg.cm), &amp;ch-&gt;fd, sizeof(int));
}

msg.msg_flags = 0;
</code></pre></div></div>

<p>#else</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (ch-&gt;fd == -1) {
    msg.msg_accrights = NULL;
    msg.msg_accrightslen = 0;

} else {
    msg.msg_accrights = (caddr_t) &amp;ch-&gt;fd;
    msg.msg_accrightslen = sizeof(int);
}
</code></pre></div></div>

<p>#endif</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iov[0].iov_base = (char *) ch;
iov[0].iov_len = size;

msg.msg_name = NULL;
msg.msg_namelen = 0;
msg.msg_iov = iov;
msg.msg_iovlen = 1;

n = sendmsg(s, &amp;msg, 0);

if (n == -1) {
    err = ngx_errno;
    if (err == NGX_EAGAIN) {
        return NGX_AGAIN;
    }

    ngx_log_error(NGX_LOG_ALERT, log, err, "sendmsg() failed");
    return NGX_ERROR;
}

return NGX_OK; } nginxä¸­æ¥æ”¶æ–‡ä»¶æè¿°ç¬¦ä»£ç ï¼š
</code></pre></div></div>

<p>ngx_int_t
ngx_read_channel(ngx_socket_t s, ngx_channel_t *ch, size_t size, ngx_log_t *log)
{
    ssize_t             n;
    ngx_err_t           err;
    struct iovec        iov[1];
    struct msghdr       msg;</p>

<p>#if (NGX_HAVE_MSGHDR_MSG_CONTROL)
    union {
        struct cmsghdr  cm;
        char            space[CMSG_SPACE(sizeof(int))];
    } cmsg;
#else
    int                 fd;
#endif</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iov[0].iov_base = (char *) ch;
iov[0].iov_len = size;

msg.msg_name = NULL;
msg.msg_namelen = 0;
msg.msg_iov = iov;
msg.msg_iovlen = 1;
</code></pre></div></div>

<p>#if (NGX_HAVE_MSGHDR_MSG_CONTROL)
    msg.msg_control = (caddr_t) &amp;cmsg;
    msg.msg_controllen = sizeof(cmsg);
#else
    msg.msg_accrights = (caddr_t) &amp;fd;
    msg.msg_accrightslen = sizeof(int);
#endif</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n = recvmsg(s, &amp;msg, 0);

if (n == -1) {
    err = ngx_errno;
    if (err == NGX_EAGAIN) {
        return NGX_AGAIN;
    }

    ngx_log_error(NGX_LOG_ALERT, log, err, "recvmsg() failed");
    return NGX_ERROR;
}

if (n == 0) {
    ngx_log_debug0(NGX_LOG_DEBUG_CORE, log, 0, "recvmsg() returned zero");
    return NGX_ERROR;
}

if ((size_t) n &lt; sizeof(ngx_channel_t)) {
    ngx_log_error(NGX_LOG_ALERT, log, 0,
                  "recvmsg() returned not enough data: %z", n);
    return NGX_ERROR;
}
</code></pre></div></div>

<p>#if (NGX_HAVE_MSGHDR_MSG_CONTROL)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (ch-&gt;command == NGX_CMD_OPEN_CHANNEL) {

    if (cmsg.cm.cmsg_len &lt; (socklen_t) CMSG_LEN(sizeof(int))) {
        ngx_log_error(NGX_LOG_ALERT, log, 0,
                      "recvmsg() returned too small ancillary data");
        return NGX_ERROR;
    }

    if (cmsg.cm.cmsg_level != SOL_SOCKET || cmsg.cm.cmsg_type != SCM_RIGHTS)
    {
        ngx_log_error(NGX_LOG_ALERT, log, 0,
                      "recvmsg() returned invalid ancillary data "
                      "level %d or type %d",
                      cmsg.cm.cmsg_level, cmsg.cm.cmsg_type);
        return NGX_ERROR;
    }

    /* ch-&gt;fd = *(int *) CMSG_DATA(&amp;cmsg.cm); */

    ngx_memcpy(&amp;ch-&gt;fd, CMSG_DATA(&amp;cmsg.cm), sizeof(int));
}

if (msg.msg_flags &amp; (MSG_TRUNC|MSG_CTRUNC)) {
    ngx_log_error(NGX_LOG_ALERT, log, 0,
                  "recvmsg() truncated data");
}
</code></pre></div></div>

<p>#else</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (ch-&gt;command == NGX_CMD_OPEN_CHANNEL) {
    if (msg.msg_accrightslen != sizeof(int)) {
        ngx_log_error(NGX_LOG_ALERT, log, 0,
                      "recvmsg() returned no ancillary data");
        return NGX_ERROR;
    }

    ch-&gt;fd = fd;
}
</code></pre></div></div>

<p>#endif</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return n; }
</code></pre></div></div>

<p>Unix åŸŸå¥—æ¥å­—æ˜¯ä¸€ç§clientå’Œserveråœ¨å•ä¸»æœºä¸Šçš„ IPC æ–¹æ³•ã€‚Unix åŸŸå¥—æ¥å­—ä¸è¿è¡Œåè®®å¤„ç†ï¼Œä¸é¡»è¦åŠ å…¥æˆ–åˆ é™¤ç½‘ç»œæŠ¥å¤´ï¼Œæ— éœ€éªŒè¯å’Œï¼Œä¸äº§ç”Ÿé¡ºåºå·ï¼Œæ— éœ€å‘é€ç¡®è®¤æŠ¥æ–‡ï¼Œæ¯”å› ç‰¹ç½‘åŸŸå¥—æ¥å­—çš„æ•ˆç‡æ›´é«˜ã€‚Unix åŸŸå¥—æ¥å­—æä¾›å­—èŠ‚æµï¼ˆç±»ä¼¼äº TCPï¼‰å’Œæ•°æ®æŠ¥ï¼ˆç±»ä¼¼äº UDPï¼‰ä¸¤ç§æ¥å£ï¼ŒUNIXåŸŸæ•°æ®æŠ¥æœåŠ¡æ˜¯å¯é çš„ï¼Œæ—¢ä¸ä¼šä¸¢å¤±æ¶ˆæ¯ä¹Ÿä¸ä¼šä¼ é€’å‡ºé”™ã€‚UNIXåŸŸå¥—æ¥å­—æ˜¯å¥—æ¥å­—å’Œç®¡é“ä¹‹é—´çš„æ··åˆç‰©ã€‚</p>

<p>Unix åŸŸå¥—æ¥å­—ç¼–ç¨‹
åœ°å€ç»“æ„ï¼š</p>

<p>struct sockaddr_un{
sa_family_t sun_family; /* AF_UNIX <em>/
char sun_path[108]; /</em> pathname */
};
å­˜æ”¾åœ¨ sun_path æ•°ç»„ä¸­çš„è·¯å¾„åå¿…é¡»ä»¥ç©ºå­—ç¬¦ç»“å°¾ã€‚ä»¥ä¸‹æ˜¯æŠŠä¸€ä¸ªè·¯å¾„åç»‘å®šåˆ° Unix åŸŸå¥—æ¥å­—ä¸Šå®ç°çš„ç¨‹åºï¼š</p>

<p>/* åˆ›å»ºä¸€ä¸ªUnixåŸŸå¥—æ¥å­—ï¼Œå¹¶bindä¸€ä¸ªè·¯å¾„å */
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stddef.h></stddef.h></stdlib.h></unistd.h></stdio.h></string.h></p>

<p>extern void err_sys(const char *, â€¦);
extern void err_quit(const char *, â€¦);
int main(int argc, char **argv)
{
    int sockfd, size;
    socklen_t len;
    struct sockaddr_un addr1, addr2;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(argc != 2)
    err_quit("usage: %s &lt;pathname&gt;", argv[0]);
 
bzero(&amp;addr1, sizeof(addr1));
addr1.sun_family = AF_UNIX;
 
strncpy(addr1.sun_path, argv[1], sizeof(addr1.sun_path)-1);
 
/* åˆ›å»ºä¸€ä¸ªUnixåŸŸå¥—æ¥å­— */
if( (sockfd = socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0)
    err_sys("socket error");
 
/* è‹¥è·¯å¾„ååœ¨æ–‡ä»¶ç³»ç»Ÿå·²å­˜åœ¨ï¼Œåˆ™bindä¼šå‡ºé”™ï¼›æ‰€ä»¥å…ˆè°ƒç”¨unlinkåˆ é™¤è¦ç»‘å®šçš„è·¯å¾„åï¼Œé˜²æ­¢bindå‡ºé”™ */
unlink(argv[1]);
 
/* å°†è·¯å¾„åbindç»‘å®šåˆ°è¯¥å¥—æ¥å­—ä¸Š */
size = offsetof(struct sockaddr_un, sun_path) + strlen(addr1.sun_path);
if(bind(sockfd, (struct sockaddr *)&amp;addr1, size) &lt; 0)
    err_sys("bind error");
 
/* æ˜¾ç¤ºå·²ç»‘å®šçš„è·¯å¾„å */
len = sizeof(addr2);
getsockname(sockfd, (struct sockaddr *)&amp;addr2, &amp;len);
printf("bound name = %s, returned len = %d\n", addr2.sun_path, len);
 
exit(0); } $ ./main /tmp/sock bound name = /tmp/sock, returned len = 12
</code></pre></div></div>

<p>/<em>å½“è¯¥è·¯å¾„åå­˜åœ¨ï¼Œä¸”ä¸ä½¿ç”¨unlinkå‡½æ•°æ—¶ï¼Œä¼šå‡ºç°ä¸‹é¢æç¤º</em>/
$ ./main /tmp/sock
bind error: Address already in use
ä¸ºäº†åˆ›å»ºä¸€å¯¹éå‘½åçš„ï¼Œç›¸äº’è¿æ¥çš„ UNXI åŸŸå¥—æ¥å­—ï¼Œç”¨æˆ·èƒ½å¤Ÿä½¿ç”¨socketopairå‡½æ•°ã€‚äº‹å®ä¸Šç°ä¾‹å¦‚ä»¥ä¸‹ï¼š</p>

<p>#include &lt;sys/socket.h&gt;
int socketpair(int domain, int type, int protocol, int sockfd[2]);
/* è¿”å›å€¼ï¼šè‹¥æˆåŠŸåˆ™è¿”å›0ï¼Œå‡ºé”™åˆ™è¿”å›-1 <em>/
/</em> è¯´æ˜</p>
<ul>
  <li>åƒæ•° domain å¿…é¡»æ˜¯ AF_LOCAL æˆ– AF_UNIXï¼Œprotocol å¿…é¡»ä¸º 0ï¼Œtype èƒ½å¤Ÿæ˜¯ SOCK_STREAM æˆ– SOCK_DGRAMï¼Œæ–°åˆ›å»ºçš„ä¸¤ä¸ªå¥—æ¥å­—æå†™å™è¿°ç¬¦ä½œä¸ºsockfd[0]å’Œsockfd[1]è¿”å›ï¼›
Unix åŸŸå¥—æ¥å­—å‡½æ•°
ä¸å› ç‰¹ç½‘åŸŸå¥—æ¥å­—ç›¸æ¯”ï¼ŒUnix åŸŸå¥—æ¥å­—æœ‰ä¸‹é¢çš„å·®åˆ«ï¼š</li>
</ul>

<p>ç”± bind åˆ›å»ºçš„è·¯å¾„åé»˜è®¤è¨ªé—®æƒé™åº”ä¸º 0777ï¼Œå¹¶æŒ‰å½“å‰ umask å€¼è¿›è¡Œæ”¹åŠ¨ï¼›
è·¯å¾„åå¿…é¡»æ˜¯ä¸€ä¸ªç»å¯¹è·¯å¾„åï¼Œé¿å…ä½¿ç”¨ç›¸å¯¹è·¯å¾„åã€‚ç”±äºå®ƒçš„è§£æä¾èµ–äºè°ƒç”¨è€…çš„å½“å‰å·¥ä½œæ–‡ä»¶å¤¹ï¼Œè‹¥serverç»‘å®šçš„æ˜¯ä¸€ä¸ªç›¸å¯¹è·¯å¾„åï¼Œåˆ™clientå’Œserverå¿…é¡»åœ¨åŒæ ·çš„æ–‡ä»¶å¤¹æ‰å¹²æ­£å¸¸å·¥ä½œï¼›
åœ¨ connect è°ƒç”¨ä¸­æŒ‡å®šçš„è·¯å¾„åå¿…é¡»æ˜¯ä¸€ä¸ªå½“å‰ç»‘å®šåœ¨æŸä¸ªå·²æ‰“å¼€çš„ Unix åŸŸå¥—æ¥å­—ä¸Šçš„è·¯å¾„åï¼Œå¹¶ä¸”å¥—æ¥å­—ç±»å‹å¿…é¡»ä¸€è‡´ï¼›
è°ƒç”¨ connect è¿æ¥ä¸€ä¸ª Unix åŸŸå¥—æ¥å­—æ¶‰åŠçš„æƒé™æ¸¬è¯•ç­‰ä»·äºè°ƒç”¨ open ä»¥ä»…ä»…å†™æ–¹å¼è¨ªé—®å¯¹åº”çš„è·¯å¾„åï¼›
Unix åŸŸå­—èŠ‚æµå¥—æ¥å­—ç±»ä¼¼äº TCP å¥—æ¥å­—ï¼šå®ƒä»¬éƒ½ä¸ºè¿›ç¨‹æä¾›ä¸€ä¸ªæ— è®°å½•è¾¹ç•Œçš„å­—èŠ‚æµæ¥å£ï¼›
åœ¨ Unix åŸŸå­—èŠ‚æµå¥—æ¥å­—ä¸­ï¼Œè‹¥ connect è°ƒç”¨æ—¶å‘ç°ç›‘å¬å¥—æ¥å­—çš„é˜Ÿåˆ—å·²æ»¡ï¼Œåˆ™é©¬ä¸Šè¿”å› ECONNREFUSED é”™è¯¯ã€‚è€Œ TCP å¥—æ¥å­—é‡åˆ°è¿™æ ·çš„æƒ…å†µï¼ŒTCP ç›‘å¬å¥—æ¥å­—å¿½ç•¥è¿™äº›åˆ°è¾¾çš„ SYN è¿æ¥è¯·æ±‚ï¼ŒTCP clientåˆ™ä¼šé‡å‘æ•°æ¬¡ SYN æŠ¥æ–‡æ®µï¼›
Unix åŸŸæ•°æ®æŠ¥å¥—æ¥å­—ç±»ä¼¼äº UDP å¥—æ¥å­—ï¼šå®ƒä»¬éƒ½æä¾›ä¸€ä¸ªä¿ç•™è®°å½•è¾¹ç•Œçš„ä¸å¯é æ•°æ®æŠ¥ï¼›
ä¸ºä¸€ä¸ªæœªç»‘å®šè·¯å¾„åçš„ Unix å¥—æ¥å­—å‘é€æ•°æ®æ—¶ï¼Œä¸ä¼šè‡ªå·±ä¸»åŠ¨ç»™è¯¥å¥—æ¥å­—ç»‘å®šä¸€ä¸ªè·¯å¾„åã€‚è€Œ UDP å¥—æ¥å­—åœ¨ç»™ä¸€ä¸ªæœªç»‘å®šçš„ UDP å¥—æ¥å­—å‘é€æ•°æ®æ—¶ï¼Œä¼šè‡ªå·±ä¸»åŠ¨ä¸ºå…¶ç»‘å®šä¸€ä¸ªæš‚æ—¶portï¼›
Unix åŸŸå­—èŠ‚æµç¼–ç¨‹
serverç¨‹åºï¼š</p>

<p>#include &lt;sys/socket.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;sys/un.h&gt;
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <stddef.h>
#include <signal.h>
#include <errno.h></errno.h></signal.h></stddef.h></stdlib.h></unistd.h></stdio.h></string.h></p>

<p>#define QLEN 1024
typedef void Sigfunc(int);</p>

<p>extern void err_sys(const char *, â€¦);
extern void err_quit(const char *, â€¦);
extern void str_echo(int);
static Sigfunc *MySignal(int signo, Sigfunc *func);
static Sigfunc *M_signal(int signo, Sigfunc *func);
static void sig_chld(int);</p>

<p>int main(int argc, char **argv)
{
    int sockfd, conndfd, size;
    socklen_t len;
    pid_t childpid;
    struct sockaddr_un cliaddr, servaddr;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(argc != 2)
    err_quit("usage: %s &lt;pathname&gt;", argv[0]);
 
bzero(&amp;servaddr, sizeof(servaddr));
servaddr.sun_family = AF_UNIX;
 
strcpy(servaddr.sun_path, argv[1]);
 
/* åˆ›å»ºä¸€ä¸ªUnixåŸŸå¥—æ¥å­— */
if( (sockfd = socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0)
    err_sys("socket error");
 
/* è‹¥è·¯å¾„ååœ¨æ–‡ä»¶ç³»ç»Ÿå·²å­˜åœ¨ï¼Œåˆ™bindä¼šå‡ºé”™ï¼›æ‰€ä»¥å…ˆè°ƒç”¨unlinkåˆ é™¤è¦ç»‘å®šçš„è·¯å¾„åï¼Œé˜²æ­¢bindå‡ºé”™ */
unlink(argv[1]);
 
/* å°†è·¯å¾„åbindç»‘å®šåˆ°è¯¥å¥—æ¥å­—ä¸Š */
size = offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path);
if(bind(sockfd, (struct sockaddr *)&amp;servaddr, size) &lt; 0)
    err_sys("bind error");
 
/* ç›‘å¬å¥—æ¥å­— */
if(listen(sockfd, QLEN) &lt; 0)
{
    close(sockfd);
    err_sys("listen error");
}
 
/* ä¿¡å·å¤„ç† */
MySignal(SIGCHLD, sig_chld);
 
for( ; ;)
{
    len = sizeof(cliaddr);
    if( (conndfd = accept(sockfd, (struct sockaddr *)&amp;cliaddr, &amp;len)) &lt; 0)
    {
        if(errno == EINTR)
            continue;
        else
            err_sys("accept error");
    }
}
 
if( (childpid = fork()) == 0)
{
    close(sockfd);
    str_echo(conndfd);
    exit(0);
}
close(conndfd); }
</code></pre></div></div>

<p>void sig_chld(int signo)
{
    pid_t pid;
    int stat;
    while( (pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0)
        printf(â€œchild %d terminated\nâ€, pid);
    return;
}
static Sigfunc *MySignal(int signo, Sigfunc *func)
{
    Sigfunc *sigfunc;
    if( (sigfunc = M_signal(signo, func)) == SIG_ERR)
        err_sys(â€œsignal errorâ€);
    return (sigfunc);
}</p>

<p>static Sigfunc *M_signal(int signo, Sigfunc *func)
{
    struct sigaction act, oact;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* è®¾ç½®ä¿¡å·å¤„ç†å‡½æ•° */
act.sa_handler = func;
/* åˆå§‹åŒ–ä¿¡å·é›† */
sigemptyset(&amp;act.sa_mask);
act.sa_flags = 0;
if(signo == SIGALRM)
{/* è‹¥æ˜¯SIGALRMä¿¡å·ï¼Œåˆ™ç³»ç»Ÿä¸ä¼šè‡ªå·±ä¸»åŠ¨é‡æ–°å¯åŠ¨ */ #ifdef SA_INTERRUPT
    act.sa_flags |= SA_INTERRUPT; #endif
}
else
{/* å…¶ä½™ä¿¡å·è®¾ç½®ä¸ºç³»ç»Ÿä¼šè‡ªå·±ä¸»åŠ¨é‡æ–°å¯åŠ¨ */ #ifdef SA_RESTART
    act.sa_flags |= SA_RESTART; #endif
}
/* è°ƒç”¨ sigaction å‡½æ•° */
if(sigaction(signo, &amp;act, &amp;oact) &lt; 0)
    return(SIG_ERR);
return(oact.sa_handler); } clientç¨‹åºï¼š
</code></pre></div></div>

<p>#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h></errno.h></stdlib.h></unistd.h></stdio.h></string.h></p>

<p>extern void err_sys(const char *, â€¦);
extern void err_quit(const char *, â€¦);
extern void str_cli(FILE *, int);</p>

<p>int
main(int argc, char **argv)
{
	int					sockfd;
	struct sockaddr_un	servaddr;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if(argc != 2)
    err_quit("usage: %s &lt;pathname&gt;", argv[0]);
if( (sockfd = socket(AF_UNIX, SOCK_STREAM, 0)) &lt; 0)
    err_sys("socket error");
 
bzero(&amp;servaddr, sizeof(servaddr));
servaddr.sun_family = AF_UNIX;
strcpy(servaddr.sun_path, argv[1]);
 
int err;
err = connect(sockfd, (struct sockaddr *) &amp;servaddr, sizeof(servaddr));
if( err &lt; 0)
    err_sys("connect error");
 
str_cli(stdin, sockfd);		/* do it all */
 
exit(0); } åƒè€ƒèµ„æ–™ï¼š
</code></pre></div></div>

<p>ã€ŠUnix ç½‘ç»œç¼–ç¨‹ã€‹</p>

<p>ä¸€ã€UNIX Domain Socket IPC</p>

<p>socket APIåŸæœ¬æ˜¯ä¸ºç½‘ç»œé€šè®¯è®¾è®¡çš„ï¼Œä½†åæ¥åœ¨socketçš„æ¡†æ¶ä¸Šå‘å±•å‡ºä¸€ç§IPCæœºåˆ¶ï¼Œå°±æ˜¯UNIX Domain Socketã€‚è™½ç„¶ç½‘ç»œsocketä¹Ÿå¯ç”¨äºåŒä¸€å°ä¸»æœºçš„è¿›ç¨‹é—´é€šè®¯ï¼ˆé€šè¿‡loopbackåœ°å€127.0.0.1ï¼‰ï¼Œä½†æ˜¯UNIX Domain Socketç”¨äºIPCæ›´æœ‰æ•ˆç‡ï¼šä¸éœ€è¦ç»è¿‡ç½‘ç»œåè®®æ ˆï¼Œä¸éœ€è¦æ‰“åŒ…æ‹†åŒ…ã€è®¡ç®—æ ¡éªŒå’Œã€ç»´æŠ¤åºå·å’Œåº”ç­”ç­‰ï¼Œåªæ˜¯å°†åº”ç”¨å±‚æ•°æ®ä»ä¸€ä¸ªè¿›ç¨‹æ‹·è´åˆ°å¦ä¸€ä¸ªè¿›ç¨‹ã€‚UNIXåŸŸå¥—æ¥å­—ä¸TCPå¥—æ¥å­—ç›¸æ¯”è¾ƒï¼Œåœ¨åŒä¸€å°ä¸»æœºçš„ä¼ è¾“é€Ÿåº¦å‰è€…æ˜¯åè€…çš„ä¸¤å€ã€‚è¿™æ˜¯å› ä¸ºï¼ŒIPCæœºåˆ¶æœ¬è´¨ä¸Šæ˜¯å¯é çš„é€šè®¯ï¼Œè€Œç½‘ç»œåè®®æ˜¯ä¸ºä¸å¯é çš„é€šè®¯è®¾è®¡çš„ã€‚UNIX Domain Socketä¹Ÿæä¾›é¢å‘æµå’Œé¢å‘æ•°æ®åŒ…ä¸¤ç§APIæ¥å£ï¼Œç±»ä¼¼äºTCPå’ŒUDPï¼Œä½†æ˜¯é¢å‘æ¶ˆæ¯çš„UNIXDomain Socketä¹Ÿæ˜¯å¯é çš„ï¼Œæ¶ˆæ¯æ—¢ä¸ä¼šä¸¢å¤±ä¹Ÿä¸ä¼šé¡ºåºé”™ä¹±ã€‚</p>

<p>ä½¿ç”¨UNIX Domain Socketçš„è¿‡ç¨‹å’Œç½‘ç»œsocketååˆ†ç›¸ä¼¼ï¼Œä¹Ÿè¦å…ˆè°ƒç”¨socket()åˆ›å»ºä¸€ä¸ªsocketæ–‡ä»¶æè¿°ç¬¦ï¼Œaddress familyæŒ‡å®šä¸ºAF_UNIXï¼Œtypeå¯ä»¥é€‰æ‹©SOCK_DGRAMæˆ–SOCK_STREAMï¼Œprotocolå‚æ•°ä»ç„¶æŒ‡å®šä¸º0å³å¯ã€‚</p>

<p>UNIX Domain Socketä¸ç½‘ç»œsocketç¼–ç¨‹æœ€æ˜æ˜¾çš„ä¸åŒåœ¨äºåœ°å€æ ¼å¼ä¸åŒï¼Œç”¨ç»“æ„ä½“sockaddr_unè¡¨ç¤ºï¼Œç½‘ç»œç¼–ç¨‹çš„socketåœ°å€æ˜¯IPåœ°å€åŠ ç«¯å£å·ï¼Œè€ŒUNIX Domain Socketçš„åœ°å€æ˜¯ä¸€ä¸ªsocketç±»å‹çš„æ–‡ä»¶åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„è·¯å¾„ï¼Œè¿™ä¸ªsocketæ–‡ä»¶ç”±bind()è°ƒç”¨åˆ›å»ºï¼Œå¦‚æœè°ƒç”¨bind()æ—¶è¯¥æ–‡ä»¶å·²å­˜åœ¨ï¼Œåˆ™bind()é”™è¯¯è¿”å›ã€‚</p>

<p>#define UNIX_PATH_MAX    108</p>

<p>struct sockaddr_un {
sa_family_t  sun_family;               /* AF_UNIX <em>/
char sun_path[UNIX_PATH_MAX];  /</em> pathname */
};
äºŒã€å›å°„/å®¢æˆ·æœåŠ¡å™¨ç¨‹åº</p>

<p>é€šä¿¡çš„æµç¨‹è·Ÿå‰é¢è¯´è¿‡çš„tcp/udp æ˜¯ç±»ä¼¼çš„ã€‚ä¸‹é¢ç›´æ¥æ¥çœ‹æœåŠ¡å™¨serv.cç¨‹åºï¼š</p>

<p>#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<errno.h>
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;
#include<string.h>
#include&lt;sys/un.h&gt;</string.h></errno.h></unistd.h></stdlib.h></stdio.h></p>

<p>#define ERR_EXIT(m) <br />
    do { <br />
        perror(m); <br />
        exit(EXIT_FAILURE); <br />
    } while (0)</p>

<p>void echo_ser(int conn)
{
    char recvbuf[1024];
    int n;
    while (1)
    {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    memset(recvbuf, 0, sizeof(recvbuf));
    n = read(conn, recvbuf, sizeof(recvbuf));
    if (n == -1)
    {
        if (n == EINTR)
            continue;
 
        ERR_EXIT("read error");
    }
 
    else if (n == 0)
    {
        printf("client close\n");
        break;
    }
 
    fputs(recvbuf, stdout);
    write(conn, recvbuf, strlen(recvbuf));
}
 
close(conn); }
</code></pre></div></div>

<p>/* unix domain socketä¸TCPå¥—æ¥å­—ç›¸æ¯”è¾ƒï¼Œåœ¨åŒä¸€å°ä¸»æœºçš„ä¼ è¾“é€Ÿåº¦å‰è€…æ˜¯åè€…çš„ä¸¤å€ã€‚*/
int main(void)
{
    int listenfd;
    if ((listenfd = socket(PF_UNIX, SOCK_STREAM, 0)) &lt; 0)
        ERR_EXIT(â€œsocket errorâ€);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unlink("/tmp/test socket"); //åœ°å€å¤ç”¨
struct sockaddr_un servaddr;
memset(&amp;servaddr, 0, sizeof(servaddr));
servaddr.sun_family = AF_UNIX;
strcpy(servaddr.sun_path, "/tmp/test socket");
 
if (bind(listenfd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0)
    ERR_EXIT("bind error");
 
if (listen(listenfd, SOMAXCONN) &lt; 0)
    ERR_EXIT("listen error");
 
int conn;
pid_t pid;
 
while (1)
{
 
    conn = accept(listenfd, NULL, NULL);
    if (conn == -1)
    {
 
        if (conn == EINTR)
            continue;
        ERR_EXIT("accept error");
    }
 
    pid = fork();
    if (pid == -1)
        ERR_EXIT("fork error");
    if (pid == 0)
    {
        close(listenfd);
        echo_ser(conn);
        exit(EXIT_SUCCESS);
    }
 
    close(conn);
}
 
return 0; } å®¢æˆ·ç«¯ç¨‹åºcli.cç¨‹åºï¼š
</code></pre></div></div>

<p>#include<stdio.h>
#include<stdlib.h>
#include<unistd.h></unistd.h></stdlib.h></stdio.h></p>

<p>#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<errno.h>
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;
#include<string.h>
#include&lt;sys/un.h&gt;</string.h></errno.h></unistd.h></stdlib.h></stdio.h></p>

<p>#define ERR_EXIT(m) <br />
    do { <br />
        perror(m); <br />
        exit(EXIT_FAILURE); <br />
    } while (0)</p>

<p>void echo_cli(int conn)
{
    char sendbuf[1024] = {0};
    char recvbuf[1024] = {0};
    while (fgets(sendbuf, sizeof(sendbuf), stdin) != NULL)
    {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    write(conn, sendbuf, strlen(sendbuf));
    read(conn, recvbuf, sizeof(recvbuf));
    fputs(recvbuf, stdout);
    memset(recvbuf, 0, sizeof(recvbuf));
    memset(sendbuf, 0, sizeof(sendbuf));
}
 
close(conn); }
</code></pre></div></div>

<p>int main(void)
{
    int sock;
    if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) &lt; 0)
        ERR_EXIT(â€œsocket errorâ€);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct sockaddr_un servaddr;
memset(&amp;servaddr, 0, sizeof(servaddr));
servaddr.sun_family = AF_UNIX;
strcpy(servaddr.sun_path, "/tmp/test socket");
 
if (connect(sock, (struct sockaddr *)&amp;servaddr, sizeof(servaddr)) &lt; 0)
    ERR_EXIT("connect error");
 
echo_cli(sock);
 
return 0; } server ä½¿ç”¨fork çš„å½¢å¼æ¥æ¥å—å¤šä¸ªè¿æ¥ï¼Œserverè°ƒç”¨bind ä¼šåˆ›å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
</code></pre></div></div>

<p>huangcheng@ubuntu:/tmp$ ls -l test\ socket
srwxr-xr-x 1 huangcheng huangcheng 0 2013-08-02 19:30 test socket
å³æ–‡ä»¶ç±»å‹ä¸ºsï¼Œè¡¨ç¤ºSOCKETæ–‡ä»¶ï¼Œä¸FIFOï¼ˆå‘½åç®¡é“ï¼‰æ–‡ä»¶ï¼Œç±»å‹ä¸ºpï¼Œç±»ä¼¼ï¼Œéƒ½è¡¨ç¤ºå†…æ ¸çš„ä¸€æ¡é€šé“ï¼Œè¯»å†™æ–‡ä»¶å®é™…æ˜¯åœ¨è¯»å†™å†…æ ¸é€šé“ã€‚ç¨‹åºä¸­è°ƒç”¨unlink æ˜¯ä¸ºäº†åœ¨å¼€å§‹æ‰§è¡Œç¨‹åºæ—¶åˆ é™¤ä»¥å‰åˆ›å»ºçš„æ–‡ä»¶ï¼Œä»¥ä¾¿åœ¨é‡å¯æœåŠ¡å™¨æ—¶ä¸ä¼šæç¤ºaddress in useã€‚å…¶ä»–æ–¹é¢ä¸ä»¥å‰è¯´è¿‡çš„å›å°„å®¢æˆ·æœåŠ¡å™¨ç¨‹åºæ²¡å¤šå¤§åŒºåˆ«ï¼Œä¸å†èµ˜è¿°ã€‚
ä¸‰ã€UNIXåŸŸå¥—æ¥å­—ç¼–ç¨‹æ³¨æ„ç‚¹</p>

<p>1ã€bindæˆåŠŸå°†ä¼šåˆ›å»ºä¸€ä¸ªæ–‡ä»¶ï¼Œæƒé™ä¸ºï¼š0777 &amp; ~umask
2ã€sun_pathæœ€å¥½ç”¨ä¸€ä¸ªç»å¯¹è·¯å¾„ã€‚
3ã€UNIXåŸŸåè®®æ”¯æŒæµå¼å¥—æ¥å£ä¸æŠ¥å¼å¥—æ¥å£ã€‚
4ã€UNIXåŸŸæµå¼å¥—æ¥å­—connectå‘ç°ç›‘å¬é˜Ÿåˆ—æ»¡æ—¶ï¼Œä¼šç«‹åˆ»è¿”å›ä¸€ä¸ªECONNREFUSEDï¼Œè¿™å’ŒTCPä¸åŒï¼Œå¦‚æœç›‘å¬é˜Ÿåˆ—æ»¡ï¼Œä¼šå¿½ç•¥åˆ°æ¥çš„SYNï¼Œè¿™å¯¼è‡´å¯¹æ–¹é‡ä¼ SYNã€‚</p>

<p>å››ã€socketpair å‡½æ•°</p>

<p>åŠŸèƒ½ï¼šåˆ›å»ºä¸€ä¸ªå…¨åŒå·¥çš„æµç®¡é“</p>

<p>int socketpair(int domain, int type, int protocol, int sv[2]);
å‚æ•°ï¼š
domainï¼š åè®®å®¶æ—
typeï¼š å¥—æ¥å­—ç±»å‹
protocolï¼šåè®®ç±»å‹
svï¼šè¿”å›å¥—æ¥å­—å¯¹
è¿”å›å€¼ï¼šæˆåŠŸè¿”å›0ï¼›å¤±è´¥è¿”å›-1</p>

<p>å®é™…ä¸Šsocketpair å‡½æ•°è·Ÿpipe å‡½æ•°æ˜¯ç±»ä¼¼çš„ï¼Œä¹Ÿåªèƒ½åœ¨åŒä¸ªä¸»æœºä¸Šå…·æœ‰äº²ç¼˜å…³ç³»çš„è¿›ç¨‹é—´é€šä¿¡ï¼Œä½†pipe åˆ›å»ºçš„åŒ¿åç®¡é“æ˜¯åŠåŒå·¥çš„ï¼Œè€Œsocketpair å¯ä»¥è®¤ä¸ºæ˜¯åˆ›å»ºä¸€ä¸ªå…¨åŒå·¥çš„ç®¡é“ã€‚</p>

<p>å¯ä»¥ä½¿ç”¨socketpair åˆ›å»ºè¿”å›çš„å¥—æ¥å­—å¯¹è¿›è¡Œçˆ¶å­è¿›ç¨‹é€šä¿¡ï¼š</p>

<p>#include<stdio.h>
#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include<unistd.h>
#include<stdlib.h>
#include<errno.h>
#include&lt;arpa/inet.h&gt;
#include&lt;netinet/in.h&gt;
#include<string.h></string.h></errno.h></stdlib.h></unistd.h></stdio.h></p>

<p>#define ERR_EXIT(m) <br />
    do { <br />
        perror(m); <br />
        exit(EXIT_FAILURE); <br />
    } while (0)</p>

<p>int main(void)
{
    int sockfds[2];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (socketpair(PF_UNIX, SOCK_STREAM, 0, sockfds) &lt; 0)
    ERR_EXIT("sockpair");
 
pid_t pid;
pid = fork();
if (pid == -1)
    ERR_EXIT("fork");
 
if (pid &gt; 0)
{
    int val = 0;
    close(sockfds[1]);
    while (1)
    {
 
        ++val;
        printf(" sending data: %d\n", val);
        write(sockfds[0], &amp;val, sizeof(val));
        read(sockfds[0], &amp;val, sizeof(val));
        printf("recv data : %d\n", val);
        sleep(1);
    }
 
}
 
else if (pid == 0)
{
 
    int val;
    close(sockfds[0]);
    while (1)
    {
 
        read(sockfds[1], &amp;val, sizeof(val));
        ++val;
        write(sockfds[1], &amp;val, sizeof(val));
    }
}
 
return 0; } è¾“å‡ºå¦‚ä¸‹ï¼š
</code></pre></div></div>

<p>huangcheng@ubuntu:~$ ./a.out
 sending data: 1
recv data : 2
 sending data: 3
recv data : 4
 sending data: 5
recv data : 6
 sending data: 7
recv data : 8
 sending data: 9
recv data : 10
 sending data: 11
recv data : 12
 sending data: 13
â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦..
å³çˆ¶è¿›ç¨‹æŒæœ‰sockfds[0] å¥—æ¥å­—è¿›è¡Œè¯»å†™ï¼Œè€Œå­è¿›ç¨‹æŒæœ‰sockfds[1] å¥—æ¥å­—è¿›è¡Œè¯»å†™ã€‚</p>

<p>åœ¨å‰é¢æˆ‘ä»¬ä»‹ç»äº†UNIXåŸŸå¥—æ¥å­—ç¼–ç¨‹ï¼Œæ›´é‡è¦çš„ä¸€ç‚¹æ˜¯UNIXåŸŸå¥—æ¥å­—å¯ä»¥åœ¨åŒä¸€å°ä¸»æœºä¸Šå„è¿›ç¨‹ä¹‹é—´ä¼ é€’æ–‡ä»¶æè¿°ç¬¦ã€‚</p>

<p>ä¸‹é¢å…ˆæ¥çœ‹ä¸¤ä¸ªå‡½æ•°ï¼š</p>

<p>#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
å®ƒä»¬ä¸sendto å’Œ recvfrom å‡½æ•°ç›¸ä¼¼ï¼Œåªä¸è¿‡å¯ä»¥ä¼ è¾“æ›´å¤æ‚çš„æ•°æ®ç»“æ„ï¼Œä¸ä»…å¯ä»¥ä¼ è¾“ä¸€èˆ¬æ•°æ®ï¼Œè¿˜å¯ä»¥ä¼ è¾“é¢å¤–çš„æ•°æ®ï¼Œå³æ–‡ä»¶æè¿°ç¬¦ã€‚ä¸‹é¢æ¥çœ‹ç»“æ„ä½“msghdr ï¼š</p>

<p>struct msghdr {
    void         <em>msg_name;       /</em> optional address <em>/
    socklen_t     msg_namelen;    /</em> size of address <em>/
    struct iovec *msg_iov;        /</em> scatter/gather array <em>/
    size_t        msg_iovlen;     /</em> # elements in msg_iov <em>/
    void         *msg_control;    /</em> ancillary data, see below <em>/
    size_t        msg_controllen; /</em> ancillary data buffer len <em>/
    int           msg_flags;      /</em> flags on received message */
};
å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š</p>

<p>1ã€msg_name ï¼šå³å¯¹ç­‰æ–¹çš„åœ°å€æŒ‡é’ˆï¼Œä¸å…³å¿ƒæ—¶è®¾ä¸ºNULLå³å¯ï¼›</p>

<p>2ã€msg_namelenï¼šåœ°å€é•¿åº¦ï¼Œä¸å…³å¿ƒæ—¶è®¾ç½®ä¸º0å³å¯ï¼›</p>

<p>3ã€msg_iovï¼šæ˜¯ç»“æ„ä½“iovec çš„æŒ‡é’ˆã€‚</p>

<p>struct iovec {
    void  <em>iov_base;    /</em> Starting address <em>/
    size_t iov_len;     /</em> Number of bytes to transfer */
};
æˆå‘˜iov_base å¯ä»¥è®¤ä¸ºæ˜¯ä¼ è¾“æ­£å¸¸æ•°æ®æ—¶çš„bufï¼Œiov_len æ˜¯buf çš„å¤§å°ã€‚</p>

<p>4ã€msg_iovlenï¼šå½“æœ‰nä¸ªiovec ç»“æ„ä½“æ—¶ï¼Œæ­¤å€¼ä¸ºnï¼›</p>

<p>5ã€msg_controlï¼šæ˜¯ä¸€ä¸ªæŒ‡å‘cmsghdr ç»“æ„ä½“çš„æŒ‡é’ˆ</p>

<p>struct cmsghdr {
    socklen_t cmsg_len;    /* data byte count, including header <em>/
    int       cmsg_level;  /</em> originating protocol <em>/
    int       cmsg_type;   /</em> protocol-specific type <em>/
    /</em> followed by unsigned char cmsg_data[]; */
};
6ã€msg_controllen ï¼šå‚è§ä¸‹å›¾ï¼Œå³cmsghdr ç»“æ„ä½“å¯èƒ½ä¸æ­¢ä¸€ä¸ªï¼›</p>

<p>7ã€flags ï¼š ä¸€èˆ¬è®¾ç½®ä¸º0å³å¯ï¼›</p>

<p>ä¸ºäº†å¯¹é½ï¼Œå¯èƒ½å­˜åœ¨ä¸€äº›å¡«å……å­—èŠ‚ï¼Œè·Ÿæ¯ä¸ªç³»ç»Ÿçš„å®ç°æœ‰å…³ï¼Œä½†æˆ‘ä»¬ä¸å¿…å…³å¿ƒï¼Œå¯ä»¥é€šè¿‡ä¸€äº›å‡½æ•°å®æ¥è·å–ç›¸å…³çš„å€¼ï¼Œå¦‚ä¸‹ï¼š</p>

<p>#include &lt;sys/socket.h&gt;</p>

<p>struct cmsghdr *CMSG_FIRSTHDR(struct msghdr *msgh);
struct cmsghdr *CMSG_NXTHDR(struct msghdr *msgh, struct cmsghdr *cmsg);
size_t CMSG_ALIGN(size_t length);
size_t CMSG_SPACE(size_t length);
size_t CMSG_LEN(size_t length);
unsigned char *CMSG_DATA(struct cmsghdr *cmsg);
ä¸‹é¢é€šè¿‡å°è£…ä¸¤ä¸ªå‡½æ•°ï¼Œsend_fd å’Œ recv_fd æ¥è¿›ä¸€æ­¥è®¤è¯†è¿™äº›å‡½æ•°å®çš„ä½œç”¨ï¼š
void send_fd(int sock_fd, int send_fd)
{
    int ret;
    struct msghdr msg;
    struct cmsghdr *p_cmsg;
    struct iovec vec;
    char cmsgbuf[CMSG_SPACE(sizeof(send_fd))];
    int *p_fds;
    char sendchar = 0;
    msg.msg_control = cmsgbuf;
    msg.msg_controllen = sizeof(cmsgbuf);
    p_cmsg = CMSG_FIRSTHDR(&amp;msg);
    p_cmsg-&gt;cmsg_level = SOL_SOCKET;
    p_cmsg-&gt;cmsg_type = SCM_RIGHTS;
    p_cmsg-&gt;cmsg_len = CMSG_LEN(sizeof(send_fd));
    p_fds = (int *)CMSG_DATA(p_cmsg);
    *p_fds = send_fd; // é€šè¿‡ä¼ é€’è¾…åŠ©æ•°æ®çš„æ–¹å¼ä¼ é€’æ–‡ä»¶æè¿°ç¬¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msg.msg_name = NULL;
msg.msg_namelen = 0;
msg.msg_iov = &amp;vec;
msg.msg_iovlen = 1; //ä¸»è¦ç›®çš„ä¸æ˜¯ä¼ é€’æ•°æ®ï¼Œæ•…åªä¼ 1ä¸ªå­—ç¬¦
msg.msg_flags = 0;
 
vec.iov_base = &amp;sendchar;
vec.iov_len = sizeof(sendchar);
ret = sendmsg(sock_fd, &amp;msg, 0);
if (ret != 1)
    ERR_EXIT("sendmsg"); }
</code></pre></div></div>

<p>int recv_fd(const int sock_fd)
{
    int ret;
    struct msghdr msg;
    char recvchar;
    struct iovec vec;
    int recv_fd;
    char cmsgbuf[CMSG_SPACE(sizeof(recv_fd))];
    struct cmsghdr *p_cmsg;
    int *p_fd;
    vec.iov_base = &amp;recvchar;
    vec.iov_len = sizeof(recvchar);
    msg.msg_name = NULL;
    msg.msg_namelen = 0;
    msg.msg_iov = &amp;vec;
    msg.msg_iovlen = 1;
    msg.msg_control = cmsgbuf;
    msg.msg_controllen = sizeof(cmsgbuf);
    msg.msg_flags = 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p_fd = (int *)CMSG_DATA(CMSG_FIRSTHDR(&amp;msg));
*p_fd = -1;
ret = recvmsg(sock_fd, &amp;msg, 0);
if (ret != 1)
    ERR_EXIT("recvmsg");
 
p_cmsg = CMSG_FIRSTHDR(&amp;msg);
if (p_cmsg == NULL)
    ERR_EXIT("no passed fd");
 
p_fd = (int *)CMSG_DATA(p_cmsg);
recv_fd = *p_fd;
if (recv_fd == -1)
    ERR_EXIT("no passed fd");
 
return recv_fd; } æ¥è§£é‡Šä¸€ä¸‹send_fd å‡½æ•°ï¼š
</code></pre></div></div>

<p>msg.msg_name = NULL;
msg.msg_namelen = 0;
msg.msg_iov = &amp;vec;
msg.msg_iovlen = 1; //ä¸»è¦ç›®çš„ä¸æ˜¯ä¼ é€’æ•°æ®ï¼Œæ•…åªä¼ 1ä¸ªå­—ç¬¦
msg.msg_flags = 0;</p>

<p>vec.iov_base = &amp;sendchar;
vec.iov_len = sizeof(sendchar);
è¿™å‡ è¡Œä¸­éœ€è¦æ³¨æ„çš„æ˜¯æˆ‘ä»¬ç°åœ¨çš„ç›®çš„ä¸æ˜¯ä¼ è¾“æ­£å¸¸æ•°æ®ï¼Œè€Œæ˜¯ä¸ºäº†ä¼ é€’æ–‡ä»¶æè¿°ç¬¦ï¼Œæ‰€ä»¥åªå®šä¹‰ä¸€ä¸ª1å­—èŠ‚çš„charï¼Œå…¶ä½™å‚ç…§å‰é¢å¯¹å‚æ•°çš„è§£é‡Šå¯ä»¥ç†è§£ã€‚</p>

<p>ç°åœ¨æˆ‘ä»¬åªæœ‰ä¸€ä¸ªcmsghdr ç»“æ„ä½“ï¼ŒæŠŠéœ€è¦ä¼ é€’çš„æ–‡ä»¶æè¿°ç¬¦send_fd é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯éœ€è¦ä¼ è¾“çš„é¢å¤–æ•°æ®å¤§å°ï¼Œå½“ä½œå‚æ•°ä¼ ç»™CMSG_SPACE å®ï¼Œå¯ä»¥å¾—åˆ°æ•´ä¸ªç»“æ„ä½“çš„å¤§å°ï¼ŒåŒ…æ‹¬ä¸€äº›å¡«å……å­—èŠ‚ï¼Œå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œä¹Ÿå³</p>

<p>char cmsgbuf[CMSG_SPACE(sizeof(send_fd))]; 
ä¹Ÿå°±å¯ä»¥è¿›ä¸€æ­¥å¾—å‡ºä»¥ä¸‹ä¸¤è¡Œï¼š</p>

<p>msg.msg_control = cmsgbuf;
msg.msg_controllen = sizeof(cmsgbuf);
æ¥ç€ï¼Œéœ€è¦å¡«å……cmsghdr ç»“æ„ä½“ï¼Œä¼ å…¥msghdr æŒ‡é’ˆï¼ŒCMSG_FIRSTHDRå®å¯ä»¥å¾—åˆ°é¦–ä¸ªcmsghdr ç»“æ„ä½“çš„æŒ‡é’ˆï¼Œå³</p>

<p>p_cmsg = CMSG_FIRSTHDR(&amp;msg);
ç„¶åä½¿ç”¨æŒ‡é’ˆæ¥å¡«å……å„å­—æ®µï¼Œå¦‚ä¸‹ï¼š</p>

<p>p_cmsg-&gt;cmsg_level = SOL_SOCKET;
p_cmsg-&gt;cmsg_type = SCM_RIGHTS;
p_cmsg-&gt;cmsg_len = CMSG_LEN(sizeof(send_fd));
ä¼ å…¥send_fd çš„å¤§å°ï¼ŒCMSG_LENå®å¯ä»¥å¾—åˆ°cmsg_len å­—æ®µçš„å¤§å°ã€‚</p>

<p>æœ€åï¼Œä¼ å…¥ç»“æ„ä½“æŒ‡é’ˆ p_cmsg ï¼Œå®CMSG_DATA å¯ä»¥å¾—åˆ°å‡†å¤‡å­˜æ”¾send_fd çš„ä½ç½®æŒ‡é’ˆï¼Œå°†send_fd æ”¾è¿›å»ï¼Œå¦‚ä¸‹ï¼š</p>

<p>p_fds = (int*)CMSG_DATA(p_cmsg);
*p_fds = send_fd; // é€šè¿‡ä¼ é€’è¾…åŠ©æ•°æ®çš„æ–¹å¼ä¼ é€’æ–‡ä»¶æè¿°ç¬¦
recv_fd å‡½æ•°å°±ç±»ä¼¼äº†ï¼Œä¸å†èµ˜è¿°ã€‚</p>

<p>å¯ä»¥å†™ä¸ªå°ç¨‹åºæµ‹è¯•ä¸€ä¸‹ï¼š</p>

<p>#include <unistd.h>
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;sys/un.h&gt;
#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <fcntl.h></fcntl.h></string.h></errno.h></stdio.h></stdlib.h></unistd.h></p>

<p>#define ERR_EXIT(m) <br />
        do <br />
        { <br />
                perror(m); <br />
                exit(EXIT_FAILURE); <br />
        } while(0)</p>

<p>int main(void)
{
    int sockfds[2];
    /* åªæœ‰unixåŸŸåè®®æ‰èƒ½åœ¨è¿›ç¨‹é—´ä¼ é€’æ–‡ä»¶æè¿°ç¬¦ï¼Œå¦‚æœæƒ³è¦åœ¨æ²¡æœ‰äº²ç¼˜å…³ç³»çš„è¿›ç¨‹é—´
     * ä¼ é€’ï¼Œåˆ™ä¸èƒ½ç”¨socketpairå‡½æ•°ï¼Œè¦ç”¨socket()å‡½æ•° */
    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sockfds) &lt; 0)
        ERR_EXIT(â€œsocketpairâ€);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pid_t pid;
pid = fork();
if (pid == -1)
    ERR_EXIT("fork");
/* å¦‚æœæ˜¯çˆ¶è¿›ç¨‹æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œå­è¿›ç¨‹å¯ä»¥å…±äº«
 * è¿™é‡Œæ¼”ç¤ºçš„æ˜¯å­è¿›ç¨‹æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦é€šè¿‡å°è£…çš„å‡½æ•°ä¼ ç»™çˆ¶è¿›ç¨‹ */
if (pid &gt; 0)
{
    close(sockfds[1]);
    int fd = recv_fd(sockfds[0]);
    char buf[1024] = {0};
    read(fd, buf, sizeof(buf));
    printf("buf=%s\n", buf);
}
else if (pid == 0)
{
    close(sockfds[0]);
    int fd;
    fd = open("test.txt", O_RDONLY);
    if (fd == -1);
    send_fd(sockfds[1], fd);
}
return 0; } æˆ‘ä»¬çŸ¥é“ï¼Œçˆ¶è¿›ç¨‹åœ¨fork ä¹‹å‰æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œå­è¿›ç¨‹æ˜¯å¯ä»¥å…±äº«çš„ï¼Œä½†æ˜¯å­è¿›ç¨‹æ‰“å¼€çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œçˆ¶è¿›ç¨‹æ˜¯ä¸èƒ½å…±äº«çš„ï¼Œä¸Šè¿°ç¨‹åºå°±æ˜¯ä¸¾ä¾‹åœ¨å­è¿›ç¨‹ä¸­æ‰“å¼€äº†ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œç„¶åé€šè¿‡send_fd å‡½æ•°å°†æ–‡ä»¶æè¿°ç¬¦ä¼ é€’ç»™çˆ¶è¿›ç¨‹ï¼Œçˆ¶è¿›ç¨‹å¯ä»¥é€šè¿‡recv_fd å‡½æ•°æ¥æ”¶åˆ°è¿™ä¸ªæ–‡ä»¶æè¿°ç¬¦ã€‚å…ˆå»ºç«‹ä¸€ä¸ªæ–‡ä»¶test.txt åè¾“å…¥å‡ ä¸ªå­—ç¬¦ï¼Œç„¶åè¿è¡Œç¨‹åºï¼Œè¾“å‡ºå¦‚ä¸‹ï¼š
</code></pre></div></div>

<p>huangcheng@ubuntu:~$ cat test.txt
ctthuangcheng
huangcheng@ubuntu:~$ ./a.out
buf=ctthuangcheng</p>

<p>huangcheng@ubuntu:~$
è¯æ˜çˆ¶è¿›ç¨‹ç¡®å®å¯ä»¥æ‰“å¼€test.txt æ–‡ä»¶ã€‚
æœ€åæé†’ä¸€ç‚¹ï¼Œåªæœ‰unixåŸŸåè®®æ‰èƒ½åœ¨æœ¬æœºè¿›ç¨‹é—´ä¼ é€’æ–‡ä»¶æè¿°ç¬¦ï¼Œå¦‚æœæƒ³è¦åœ¨æ²¡æœ‰äº²ç¼˜å…³ç³»çš„è¿›ç¨‹é—´ä¼ é€’ï¼Œåˆ™ä¸èƒ½ç”¨socketpairå‡½æ•°ï¼Œè¦ç”¨socket()å‡½æ•° æ‰è¡Œã€‚</p>
:ET