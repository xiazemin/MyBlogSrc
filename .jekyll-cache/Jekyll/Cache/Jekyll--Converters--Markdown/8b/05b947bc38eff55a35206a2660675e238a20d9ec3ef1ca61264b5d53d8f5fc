I"á(<p>https://github.com/bramp/antlr4-grammars
https://github.com/bramp/antlr4-grammars/tree/master/xml
https://github.com/bramp/antlr4-grammars/blob/master/json/json_test.go
å®‰è£…
$curl -O  https://www.antlr.org/download/antlr-4.8-complete.jar
$java jar  /Users/antlr-4.8-complete.jar
é”™è¯¯: æ‰¾ä¸åˆ°æˆ–æ— æ³•åŠ è½½ä¸»ç±» jar
æ³¨æ„å‘½ä»¤æ˜¯java -jar
$java -jar /Users/antlr-4.8-complete.jar
ANTLR Parser Generator  Version 4.8
 -o <em>__              specify output directory where all output is generated
 -lib __</em>            specify location of grammars, tokens files
 -atn                generate rule augmented transition network diagrams
 -encoding <em>__       specify grammar file encoding; e.g., euc-jp
 -message-format __</em> specify output style for messages in antlr, gnu, vs2005
 -long-messages      show exception details when available for errors and warnings
 -listener           generate parse tree listener (default)
 -no-listener        donâ€™t generate parse tree listener
 -visitor            generate parse tree visitor
 -no-visitor         donâ€™t generate parse tree visitor (default)
 -package ___        specify a package/namespace for the generated code
 -depend             generate file dependencies
 -D<option>=value    set/override a grammar-level option
 -Werror             treat warnings as errors
 -XdbgST             launch StringTemplate visualizer on generated code
 -XdbgSTWait         wait for STViz to close before continuing
 -Xforce-atn         use the ATN simulator for all predictions
 -Xlog               dump lots of logging info to antlr-timestamp.log
 -Xexact-output-dir  all output goes into -o dir regardless of paths/package
 https://www.jianshu.com/p/7969d076183f
 https://www.jianshu.com/p/b4714b98389d
 https://abcdabcd987.com/notes-on-antlr4/
<!-- more -->
https://blog.gopheracademy.com/advent-2017/parsing-with-antlr4-and-go/
https://github.com/antlr/antlr4/tree/master/runtime/Go/antlr</option></p>

<p>$java -jar ../calc/antlr-4.8-complete.jar
ANTLR Parser Generator  Version 4.8
 -o <em>__              specify output directory where all output is generated
 -lib __</em>            specify location of grammars, tokens files</p>

<p>æ³¨æ„4.5.1è¿™ä¸ªåŒ…æœ‰é—®é¢˜
$java -jar antlr-4.5.1-complete.jar
é”™è¯¯: æ‰¾ä¸åˆ°æˆ–æ— æ³•åŠ è½½ä¸»ç±» org.antlr.v4.Tool
$java -jar /Users/didi/PhpstormProjects/c/json-parser/antlr/antlr-4.5.1-complete.jar
é”™è¯¯: æ‰¾ä¸åˆ°æˆ–æ— æ³•åŠ è½½ä¸»ç±» org.antlr.v4.Tool</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Calc.g4
grammar Calc;

// Tokens
MUL: '*';
DIV: '/';
ADD: '+';
SUB: '-';
NUMBER: [0-9]+;
WHITESPACE: [ \r\n\t]+ -&gt; skip;

// Rules
start : expression EOF;

expression
   : expression op=('*'|'/') expression # MulDiv
   | expression op=('+'|'-') expression # AddSub
   | NUMBER                             # Number
   ;
</code></pre></div></div>
<p>ç”Ÿæˆä»£ç 
$java -jar ../calc/antlr-4.8-complete.jar -Dlanguage=Go -o parser Calc.g4</p>

<p>$tree
.
|<strong>__Calc.g4
|</strong><strong>parser
| |</strong><strong>Calc.interp
| |</strong><strong>Calc.tokens
| |</strong><strong>calc_base_listener.go
| |</strong><strong>calc_lexer.go
| |</strong><strong>calc_listener.go
| |</strong><strong>calc_parser.go
| |</strong><strong>CalcLexer.interp
| |</strong>__CalcLexer.tokens</p>

<p>$go mod init github.com/xiazemin/json-parser/antlr/antlr4go
go: creating new go.mod: module github.com/xiazemin/json-parser/antlr/antlr4go</p>

<p>https://www.antlr.org/download.html
$go get github.com/antlr/antlr4/runtime/Go/antlr</p>

<p>// example1.go
package main</p>

<p>import (
â€œfmtâ€
â€œgithub.com/antlr/antlr4/runtime/Go/antlrâ€</p>

<p>â€./parserâ€
)</p>

<p>func main() {
	// Setup the input
	is := antlr.NewInputStream(â€œ1 + 2 * 3â€)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Create the Lexer
lexer := parser.NewCalcLexer(is)

// Read all tokens
for {
	t := lexer.NextToken()
	if t.GetTokenType() == antlr.TokenEOF {
		break
	}
	fmt.Printf("%s (%q)\n",
		lexer.SymbolicNames[t.GetTokenType()], t.GetText())
} }
</code></pre></div></div>

<p>package main</p>

<p>import â€œgithub.com/xiazemin/json-parser/antlr/antlr4go/parserâ€</p>

<p>// example2.go
package main</p>

<p>import (
â€œgithub.com/xiazemin/json-parser/antlr/antlr4go/parserâ€
â€œgithub.com/antlr/antlr4/runtime/Go/antlrâ€
)</p>

<p>type calcListener struct {
	*parser.BaseCalcListener
}</p>

<p>func main() {
	// Setup the input
	is := antlr.NewInputStream(â€œ1 + 2 * 3â€)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Create the Lexer
lexer := parser.NewCalcLexer(is)
stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)

// Create the Parser
p := parser.NewCalcParser(stream)

// Finally parse the expression
antlr.ParseTreeWalkerDefault.Walk(&amp;calcListener{}, p.Start()) }
</code></pre></div></div>

<p>package main</p>

<p>import (
	â€œfmtâ€
	â€œgithub.com/antlr/antlr4/runtime/Go/antlrâ€
	â€œgithub.com/xiazemin/json-parser/antlr/antlr4go/parserâ€
	â€œstrconvâ€
)</p>

<p>type calcListener struct {
	*parser.BaseCalcListener</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stack []int }
</code></pre></div></div>

<p>func (l *calcListener) push(i int) {
	l.stack = append(l.stack, i)
}</p>

<p>func (l *calcListener) pop() int {
	if len(l.stack) &lt; 1 {
		panic(â€œstack is empty unable to popâ€)
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Get the last value from the stack.
result := l.stack[len(l.stack)-1]

// Remove the last element from the stack.
l.stack = l.stack[:len(l.stack)-1]

return result }
</code></pre></div></div>

<p>func (l *calcListener) ExitMulDiv(c *parser.MulDivContext) {
	right, left := l.pop(), l.pop()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>switch c.GetOp().GetTokenType() {
case parser.CalcParserMUL:
	l.push(left * right)
case parser.CalcParserDIV:
	l.push(left / right)
default:
	panic(fmt.Sprintf("unexpected op: %s", c.GetOp().GetText()))
} }
</code></pre></div></div>

<p>func (l *calcListener) ExitAddSub(c *parser.AddSubContext) {
	right, left := l.pop(), l.pop()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>switch c.GetOp().GetTokenType() {
case parser.CalcParserADD:
	l.push(left + right)
case parser.CalcParserSUB:
	l.push(left - right)
default:
	panic(fmt.Sprintf("unexpected op: %s", c.GetOp().GetText()))
} }
</code></pre></div></div>

<p>func (l *calcListener) ExitNumber(c *parser.NumberContext) {
	i, err := strconv.Atoi(c.GetText())
	if err != nil {
		panic(err.Error())
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l.push(i) }
</code></pre></div></div>

<p>// calc takes a string expression and returns the evaluated result.
func calc(input string) int {
	// Setup the input
	is := antlr.NewInputStream(input)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Create the Lexer
lexer := parser.NewCalcLexer(is)
stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)

// Create the Parser
p := parser.NewCalcParser(stream)

// Finally parse the expression (by walking the tree)
var listener calcListener
antlr.ParseTreeWalkerDefault.Walk(&amp;listener, p.Start())

return listener.pop() }
</code></pre></div></div>

<p>func main()  {
   print(calc(â€œ1+2*3-4+5â€))
}</p>

<p>package main
import (
â€œbramp.net/antlr4/jsonâ€ // The parser
â€œgithub.com/antlr/antlr4/runtime/Go/antlrâ€
)</p>

<p>type exampleListener struct {
// https://godoc.org/bramp.net/antlr4/json#BaseJSONListener
*json.BaseJSONListener
}</p>

<p>func main() {
// Setup the input
is := antlr.NewInputStream(<code class="language-plaintext highlighter-rouge">
		{
			"example": "json",
			"with": ["an", "array"]
		}</code>)</p>

<p>// Create the JSON Lexer
lexer := json.NewJSONLexer(is)
stream := antlr.NewCommonTokenStream(lexer, antlr.TokenDefaultChannel)</p>

<p>// Create the JSON Parser
p := json.NewJSONParser(stream)</p>

<p>// Finally walk the tree
antlr.ParseTreeWalkerDefault.Walk(&amp;exampleListener{}, p.Json())
}</p>

<p>https://github.com/antlr/antlr4/blob/master/doc/grammars.md
https://zhuanlan.zhihu.com/p/47179842
https://github.com/thesues/antlr-calc-golang-example</p>

<p>https://blog.gopheracademy.com/advent-2017/parsing-with-antlr4-and-go/
https://liangshuang.name/2017/08/20/antlr/
https://github.com/antlr/antlr4/tree/master/runtime/Go/antlr</p>

<p>$export GOPROXY=https://goproxy.io
$go  run example1.go
build command-line-arguments: cannot load github.com/antlr/antlr4/runtime/Go/antlr: module github.com/antlr/antlr4/runtime/Go/antlr: Get https://goproxy.io/github.com/antlr/antlr4/runtime/%21go/antlr/@v/list: x509: certificate has expired or is not yet valid</p>

<p>$ GOPROXY=â€https://goproxy.cnâ€
$cd ../parser/
$go mod init github.com/xiazemin/json-parser/antlr/antlr4go/parser
go: creating new go.mod: module github.com/xiazemin/json-parser/antlr/antlr4go/parser</p>

<p>$cd exp1
replace github.com/xiazemin/json-parser/antlr/antlr4go/parser =&gt; ../parser</p>

<p>$go run example1.go
NUMBER (â€œ1â€)
ADD (â€œ+â€)
NUMBER (â€œ2â€)
MUL (â€œ*â€)
NUMBER (â€œ3â€)</p>

<p>$go mod edit -replace github.com/xiazemin/json-parser/antlr/antlr4go/parser=../parser</p>

<p>$go run example2.go
go: finding github.com/antlr/antlr4 latest</p>
<h1 id="command-line-arguments">command-line-arguments</h1>
<p>./example2.go:6:1: syntax error: non-declaration statement outside function body</p>

<p>$go mod init github.com/xiazemin/json-parser/antlr/antlr4go
go: creating new go.mod: module github.com/xiazemin/json-parser/antlr/antlr4go
$go mod edit -replace github.com/xiazemin/json-parser/antlr/antlr4go/parser=../parser
$go run example3.go
go: finding github.com/antlr/antlr4 latest
8</p>

<p>$go run example4.go
go: finding github.com/antlr/antlr4 latest
go: finding bramp.net/antlr4 latest
go: downloading bramp.net/antlr4 v0.0.0-20190812013724-3751fbacda98
go: extracting bramp.net/antlr4 v0.0.0-20190812013724-3751fbacda98
https://blog.gopheracademy.com/advent-2017/parsing-with-antlr4-and-go/</p>
:ET