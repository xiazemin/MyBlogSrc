I"š<p>net/http/httptraceä¸»è¦æ˜¯ç”¨äºè¿½è¸ªå®¢æˆ·ç«¯çš„ Request è¯·æ±‚è¿‡ç¨‹ä¸­å‘ç”Ÿçš„å„ç§äº‹ä»¶åŠè¡Œä¸ºï¼Œåœ¨æ ‡å‡†åº“ net/http/httptrace/trace.go ä¸­å®šä¹‰äº†ä¸€ä¸ªå« ClientTrace çš„ç»“æ„ä½“ï¼Œå®ƒåŒ…å«äº†ä¸€ç³»åˆ—çš„é’©å­å‡½æ•° hooks ä½œä¸ºæˆå‘˜å˜é‡
<!-- more -->
// ClientTrace is a set of hooks to run at various stages of an outgoing HTTP request. 
type ClientTrace struct {
    GetConn func(hostPort string)
    GotConn func(GotConnInfo)
    PutIdleConn func(err error)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GotFirstResponseByte func()
Got100Continue func()

DNSStart func(DNSStartInfo)
DNSDone func(DNSDoneInfo)

ConnectStart func(network, addr string)
ConnectDone func(network, addr string, err error)

TLSHandshakeStart func()
TLSHandshakeDone func(tls.ConnectionState, error)
WroteHeaders func()
Wait100Continue func()
WroteRequest func(WroteRequestInfo) }
</code></pre></div></div>

<p>race.go è¿˜æä¾›äº†ä¸€ä¸ª WithClientTrace() åŒ…å‡½æ•°ï¼Œç”¨æ¥æŠŠ ClientTrace ç»“æ„ä½“ä¸­çš„é’©å­éƒ½ä¿å­˜ï¼ˆæ³¨å†Œï¼‰åˆ° Context ä¸­å»ï¼ˆå› ä¸º Context æä¾› key/value å­˜å‚¨å˜›ï¼‰ï¼Œ
key å°±æ˜¯ä¸€ä¸ªå« clientEventContextKey çš„ç©ºç»“æ„ä½“ï¼Œvalue æ˜¯ nettrace åŒ…ä¸­çš„ Trace ç»“æ„ä½“ï¼Œè¿™ä¸ªç»“æ„ä½“ä½œç”¨è·Ÿ ClientTrace ä¸€æ ·ï¼Œéƒ½æ˜¯åŒ…å«äº†ä¸€å † hook å‡½æ•°ä½œä¸ºæˆå‘˜ï¼Œ
åœ¨è¿™é‡Œå®ƒçš„ç›®çš„åªæ˜¯å°è£…ä¸‹ ClientTrace ä¸­çš„ hook å‡½æ•°ã€‚æœ€ç»ˆï¼Œ WithClientTrace() ä¼šè¿”å›ä¸€ä¸ª contextï¼Œå®ƒä¿å­˜äº†ä¸Šè¿°çš„ hook å‡½æ•°ã€‚
type clientEventContextKey struct{}
func WithClientTrace(ctx context.Context, trace *ClientTrace) context.Context {
    if trace == nil {
        panic(â€œnil traceâ€)
    }
    old := ContextClientTrace(ctx)
    trace.compose(old)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctx = context.WithValue(ctx, clientEventContextKey{}, trace)
if trace.hasNetHooks() {
    nt := &amp;nettrace.Trace{
        ConnectStart: trace.ConnectStart,
        ConnectDone:  trace.ConnectDone,
    }
    if trace.DNSStart != nil {
        nt.DNSStart = func(name string) {
            trace.DNSStart(DNSStartInfo{Host: name})
        }
    }
    if trace.DNSDone != nil {
        ...
    }
    ctx = context.WithValue(ctx, nettrace.TraceKey{}, nt)
}
return ctx }
</code></pre></div></div>

<p>é€šè¿‡ ContextClientTrace() çš„å‡½æ•°ï¼Œå¯ä»¥æŠŠ ClientTrace ä» Context ä¸­å–å‡ºæ¥ã€‚
// ContextClientTrace returns the ClientTrace associated with the
// provided context. If none, it returns nil.
func ContextClientTrace(ctx context.Context) <em>ClientTrace {
    trace, _ := ctx.Value(clientEventContextKey{}).(</em>ClientTrace)
    return trace
}</p>

<p>ç°åœ¨ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œæœ‰äº† WithClientTrace()ï¼Œæˆ‘ä»¬å°±å¯ä»¥æŠŠé’©å­å‡½æ•°ä¿å­˜åœ¨ Context ä¸­äº†ï¼Œç°åœ¨ï¼Œæˆ‘ä»¬è¦æŠŠè¿™äº›é’©å­å‡½æ•°æŒ‚åˆ° Request ä¸­å»ï¼Œè¯¥æ€ä¹ˆå¼„ï¼Ÿ
å¾ˆç®€å•ï¼Œé€šè¿‡ Request.WithContext() æŠŠåˆšæ‰èµ‹å€¼å¥½çš„ Context ä¿å­˜åˆ° Request ä¸­å°±å¯ä»¥äº†ã€‚
ç°åœ¨ Request æœ‰äº†è¿™äº›é’©å­å‡½æ•°ï¼Œé‚£ä¹ˆä»€ä¹ˆæ—¶å€™ä¼šè¢«è°ƒç”¨å‘¢ï¼Ÿ å½“ç„¶ä¼š http.Client.Do(req) çš„æ—¶å€™å•¦ã€‚
æ¥ä¸‹æ¥æˆ‘ä»¬é€šè¿‡ä¸€æ®µå®é™…çš„ä»£ç çœ‹çœ‹æ•´ä¸ªæµç¨‹ï¼š
package main</p>

<p>import (
    â€œfmtâ€
    â€œlogâ€
    â€œnet/httpâ€
    â€œnet/http/httptraceâ€
)</p>

<p>// transport is an http.RoundTripper that keeps track of the in-flight
// request and implements hooks to report HTTP tracing events.
type transport struct {
    current *http.Request
}</p>

<p>// RoundTrip wraps http.DefaultTransport.RoundTrip to keep track
// of the current request.
func (t <em>transport) RoundTrip(req *http.Request) (</em>http.Response, error) {
    t.current = req
    return http.DefaultTransport.RoundTrip(req)
}</p>

<p>// GotConn prints whether the connection has been used previously
// for the current request.
func (t *transport) GotConn(info httptrace.GotConnInfo) {
    fmt.Printf(â€œConnection reused for %v? %v\nâ€, t.current.URL, info.Reused)
}</p>

<p>func main() {
    t := &amp;transport{}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>req, _ := http.NewRequest("GET", "https://google.com", nil)
trace := &amp;httptrace.ClientTrace{
    GotConn: t.GotConn,
}
req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))

client := &amp;http.Client{Transport: t}
if _, err := client.Do(req); err != nil {
    log.Fatal(err)
} }
</code></pre></div></div>

<p>æ‰€æœ‰çš„é’©å­çš„è°ƒç”¨ï¼Œæœ€ç»ˆéƒ½ä¼šåœ¨ client.Do(req) é‡Œé¢æ‰§è¡Œï¼Œæˆ‘ä»¬çœ‹çœ‹æ˜¯æ€ä¹ˆæ‰§è¡Œçš„ã€‚
æ³¨æ„åˆ°è¿™é‡Œçš„ transport ç»“æ„ä½“ï¼Œå®ƒå…¶å®æ˜¯ RoundTripper æ¥å£ç±»å‹ï¼ˆåœ¨ client.go ä¸­å£°æ˜ï¼‰çš„ä¸€ä¸ª implementerï¼Œè¿™ä¸ª RoundTripper å®é™…åªæœ‰ä¸€ä¸ªæ–¹æ³•ï¼š
// RoundTripper is an interface representing the ability to execute a
// single HTTP transaction, obtaining the Response for a given Request.
type RoundTripper interface {
    // RoundTrip executes a single HTTP transaction, returning
    // a Response for the provided Request.
    RoundTrip(<em>Request) (</em>Response, error)
}</p>

<p>åœ¨ client.Do() ä¸­ï¼Œä¼šè°ƒç”¨ client.send()ï¼Œå¦‚ä¸‹ï¼š
 resp, didTimeout, err = c.send(req, deadline)</p>

<p>c.send() å†…éƒ¨ï¼š
// didTimeout is non-nil only if err != nil.
func (c *Client) send(req *Request, deadline time.Time) (resp *Response, didTimeout func() bool, err error) {
    â€¦
    resp, didTimeout, err = send(req, c.transport(), deadline)
    â€¦
    return resp, nil, nil
}</p>

<p>send() å†…éƒ¨ï¼š
func send(ireq *Request, rt RoundTripper, deadline time.Time) (resp *Response, didTimeout func() bool, err error) {
    â€¦
    resp, err = rt.RoundTrip(req)
    â€¦
}</p>

<p>å¯è§ï¼Œæœ€ç»ˆè°ƒç”¨äº† rt.RoundTrip() å‡½æ•°ã€‚ä¹Ÿå°±æ˜¯ä¸Šè¿° main.go ä¸­ transport å®ç°çš„ RoundTrip() å‡½æ•°ã€‚
åœ¨ rt.RoundTrip() é‡Œé¢ï¼ŒæŠŠ req èµ‹ç»™äº† DefaultTransport.RoundTrip(req)ï¼Œ
è¿™ä¸ª DefaultTransport æ˜¯åŒ…æä¾›çš„ä¸€ä¸ª RoundTripper çš„é»˜è®¤å®ç°ï¼Œ
var DefaultTransport RoundTripper = &amp;Transport{
    Proxy: ProxyFromEnvironment,
    DialContext: (&amp;net.Dialer{
        Timeout:   30 * time.Second,
        KeepAlive: 30 * time.Second,
        DualStack: true,
    }).DialContext,
    MaxIdleConns:          100,
    IdleConnTimeout:       90 * time.Second,
    TLSHandshakeTimeout:   10 * time.Second,
    ExpectContinueTimeout: 1 * time.Second,
}</p>

<p>ç„¶åï¼Œåœ¨å®ƒçš„ RoundTrip() å‡½æ•°é‡Œé¢æœ€ç»ˆä¼šè°ƒç”¨ä¸Šè¿°çš„é’©å­å‡½æ•°ã€‚
// RoundTrip implements the RoundTripper interface.
//
// For higher-level HTTP client support (such as handling of cookies
// and redirects), see Get, Post, and the Client type.
func (t <em>Transport) RoundTrip(req *Request) (</em>Response, error) {
    t.nextProtoOnce.Do(t.onceSetNextProtoDefaults)
    ctx := req.Context()
    trace := httptrace.ContextClientTrace(ctx)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
    treq := &amp;transportRequest{Request: req, trace: trace}
    cm, err := t.connectMethodForRequest(treq)
    ...
    pconn, err := t.getConn(treq, cm)
} }
</code></pre></div></div>

<p>è§£æï¼š
é€šè¿‡è°ƒç”¨ httptrace.ContextClientTrace(ctx) æŠŠ context ä¸­çš„é’©å­å‡½æ•°éƒ½å–å‡ºæ¥ï¼Œå†åœ¨ t.getConn() ä¸­è°ƒç”¨é’©å­å‡½æ•°ï¼Œ</p>

:ET