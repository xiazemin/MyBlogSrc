I"‡]<p>https://github.com/go-validator/validator
è¿™ä¸ªåŒ…æ€ä¹ˆç”¨çš„
type NewUserRequest struct {
	Username string <code class="language-plaintext highlighter-rouge">validate:"min=3,max=40,regexp=^[a-zA-Z]*$"</code>
	Name string     <code class="language-plaintext highlighter-rouge">validate:"nonzero"</code>
	Age int         <code class="language-plaintext highlighter-rouge">validate:"min=21"</code>
	Password string <code class="language-plaintext highlighter-rouge">validate:"min=8"</code>
}</p>

<p>nur := NewUserRequest{Username: â€œsomethingâ€, Age: 20}
if errs := validator.Validate(nur); errs != nil {
	// values not valid, deal with errors here
}
ä½¿ç”¨validateä½œä¸º tag çš„åå­—ï¼Œç„¶åä»¥é€—å·åˆ†éš”éªŒè¯é€»è¾‘ï¼Œç„¶åå¯¹äºè¿™æ ·çš„ struct å€¼ï¼Œè°ƒç”¨validator.Validate(nur)éªŒè¯
æœ¬åŒ…æœ‰ 6 ä¸ªå†…ç½®çš„éªŒè¯å‡½æ•°ï¼Œå¹¶ä¸”å¯ä»¥æ‰‹åŠ¨æ·»åŠ è‡ªå®šä¹‰çš„éªŒè¯å‡½æ•°
æˆ‘ä»¬åœ¨å®šä¹‰ struct çš„æ—¶å€™å¯ä»¥ä½¿ç”¨validateä½œä¸º tag çš„åå­—æ·»åŠ ä¸€äº›éªŒè¯è§„åˆ™ï¼Œç„¶åä½¿ç”¨validator.Validate(nur)éªŒè¯æ•°æ®æ˜¯å¦æ»¡è¶³æˆ‘ä»¬å®šä¹‰çš„è§„åˆ™ï¼Œå¦‚æœä¸æ»¡è¶³çš„è¯ï¼Œå°±ä¼šè¿”å› err
<!-- more -->
æ˜¾ç„¶ç¬¬ä¸€æ­¥å°±æ˜¯ï¼Œä½¿ç”¨reflectå°†æ¯ä¸ª field çš„ tag å–å‡ºæ¥ï¼Œæˆ‘ä»¬è§„å®šä½ å¿…é¡»ä½¿ç”¨ validate ä½œä¸º tag çš„åå­—ï¼Œè¿™æ ·æˆ‘ä»¬å°±èƒ½æ‹¿åˆ°è§„åˆ™äº†</p>

<p>ç„¶åæˆ‘ä»¬è§„å®šå¤šä¸ªè§„åˆ™ä½¿ç”¨é€—å·åˆ†éš”ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¯¹äºä¸€ä¸ª fieldï¼Œå¯ä»¥æ‹¿åˆ°ä¸€ç»„è§„åˆ™äº†ï¼ˆå¯ä»¥æ˜¯ 0 ä¸ªï¼Œ1 ä¸ªï¼Œä»»æ„å¤šä¸ªï¼‰</p>

<p>æ¥ä¸‹æ¥å°±æ˜¯éå†è·å–åˆ°çš„è§„åˆ™ï¼Œæ‰§è¡Œå½“å‰è§„åˆ™å¯¹äºå½“å‰å€¼çš„æ ¡éªŒï¼Œå¾ˆæ˜¾ç„¶ï¼Œè¿™é‡Œæœ‰è¿™å‡ ä¸ªå› ç´ ï¼šfield çš„å€¼ + è§„åˆ™</p>

<p>åœ¨æœ¬åŒ…é‡Œé¢ï¼Œä»–æŠŠè§„åˆ™è§£é‡Šä¸ºä¸€ä¸ªå‡½æ•°ï¼Œæ‰€ä»¥è¿˜éœ€è¦æœ‰å‡½æ•°çš„å‚æ•°ï¼ˆè¿™é‡Œè„‘æ´å¼€å¤§ä¸€ç‚¹ï¼šå…¶å®ä¸ä»…ä»…å¯ä»¥æ˜¯å‡½æ•°ï¼Œå¯ä»¥è‡ªå®šä¹‰è¯­è¨€ï¼Ÿä½†æ˜¯æˆæœ¬å¤ªå¤§ï¼šå¼€å‘æˆæœ¬å’Œç”¨æˆ·å­¦ä¹ æˆæœ¬ï¼›åŒä¸€ä¸ª field çš„ä¸åŒè§„åˆ™ä¹‹é—´å¯ä»¥ç›¸äº’ä½œç”¨ï¼Ÿï¼‰</p>

<p>okï¼Œæ‰€ä»¥ç°åœ¨ä¸€ä¸ªè§„åˆ™æœ‰è¿™ä¹ˆå‡ ä¸ªå› ç´ ï¼šfield å€¼ + è§„åˆ™å‡½æ•° + è§„åˆ™å‚æ•°</p>

<p>é‚£æ¥ä¸‹æ¥å°±å¾ˆå¥½åŠäº†ï¼Œå°±æ˜¯è°ƒç”¨è¿™ä¸ªç»™å®šçš„è§„åˆ™å‡½æ•°ï¼Œå‚æ•°æ˜¯ field å€¼ + ç»™å®šçš„è§„åˆ™å‚æ•°ï¼Œçœ‹çœ‹åˆä¸åˆæ³•ï¼Œä¹Ÿå°±æ˜¯è¿”å›ä¸€ä¸ª error</p>

<p>ç”šè‡³æˆ‘ä»¬åˆ°è¿™é‡Œå·²ç»å¯ä»¥çŒœå‡ºè§„åˆ™å‡½æ•°çš„å‡½æ•°ç­¾åäº†ï¼šfunc(v interface{}, param string) errorï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ field å€¼ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯è§„åˆ™å‚æ•°</p>

<p>å…·ä½“ä»£ç è¯¦è§£
1 éå†
ä½¿ç”¨åŒ…çš„å…¥å£æ˜¯ validator.Validateï¼Œä¹Ÿå°±æ˜¯func (mv *Validator) Validate(v interface{}) error</p>

<p>sv := reflect.ValueOf(v)
st := reflect.TypeOf(v)
è¿™ä¸ªæ–¹æ³•é‡Œé¢ä½¿ç”¨reflectåŒ…éå†reflect.Type.NumField()ï¼Œç„¶åä½¿ç”¨reflect.Type.Field(i).Tagè·å¾—äº†å„ä¸ª field çš„ tag</p>

<p>å½“ç„¶åœ¨å¤„ç†åå°„çš„æ—¶å€™ï¼Œæœ‰ä¸€äº›æ³¨æ„äº‹é¡¹ï¼š</p>

<p>å¯¹äº reflect.Value.Kind() ä¸ºæŒ‡é’ˆçš„å¤„ç†æ–¹å¼ï¼Œé€’å½’ .Elem().Interface()</p>

<p>if sv.Kind() == reflect.Ptr &amp;&amp; !sv.IsNil() {
	return mv.Validate(sv.Elem().Interface()) // é€’å½’
}
å¹¶ä¸”è¿™é‡Œçš„éªŒè¯åªæ”¯æŒç»“æ„ä½“ï¼š</p>

<p>reflect.Value.Kind() éœ€è¦æ˜¯ reflect.Struct æˆ–è€… reflect.Interface</p>

<p>if sv.Kind() != reflect.Struct &amp;&amp; sv.Kind() != reflect.Interface {
	return ErrUnsupported
}
okï¼Œç„¶åæ¥ä¸‹æ¥å°±æ˜¯éå†æ‰€æœ‰çš„ field è¿›è¡ŒéªŒè¯äº†ï¼Œæ‰€æœ‰çš„éªŒè¯è§„åˆ™éƒ½æ²¡æœ‰è¿”å› errï¼Œé‚£ä¹ˆå°±è¿”å› nil</p>

<p>2 æ¯ä¸ª field çš„å¤„ç†
é¦–å…ˆï¼Œåªæ”¯æŒ exported çš„å­—æ®µï¼š</p>

<p>if !unicode.IsUpper(rune(st.Field(i).Name[0])) {
	continue
}
å¤„ç† field ä»ç„¶æ˜¯æŒ‡é’ˆï¼š</p>

<p>å¯¹äº reflect.Value.Field(i).Kind() ä¸ºæŒ‡é’ˆçš„å¤„ç†æ–¹å¼ï¼Œä¸€ç›´å– .Elem()</p>

<p>f := sv.Field(i)
for f.Kind() == reflect.Ptr &amp;&amp; !f.IsNil() {
	f = f.Elem()
}
ç„¶åè·å– tag çš„å€¼ï¼ˆå…¶å®è¿™é‡Œæˆ‘è®¤ä¸ºåº”è¯¥ç”¨ lookupï¼‰</p>

<p>tag := st.Field(i).Tag.Get(mv.tagName)
è·³è¿‡ -</p>

<p>if tag == â€œ-â€œ {
	continue
}
ç„¶åç”¨è§„åˆ™å»éªŒè¯ï¼Œä»£ç ï¼š err := mv.Valid(f.Interface(), tag)</p>

<p>ç„¶åéªŒè¯ TODOï¼Œä»£ç  mv.deepValidateCollection(f, fname, m)</p>

<p>ç»“æŸï¼Œè¿”å› err æˆ–è€… nil</p>

<p>3 å¤„ç†æ¯ä¸ª tag ä¸ä¸ºç©ºçš„ field
è°ƒç”¨func (mv *Validator) Valid(val interface{}, tags string)</p>

<p>è¿™ä¸ªå‡½æ•°æ˜¯å¹²å˜›çš„å‘¢ï¼šè¿™ä¸ªå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸è¦æ±‚æ˜¯ struct äº†ï¼Œæ ¹æ®æä¾›çš„ tag è¿›è¡ŒéªŒè¯</p>

<p>è·³è¿‡ -</p>

<p>v := reflect.ValueOf(val)
å¤„ç†æŒ‡é’ˆï¼šå¯¹äº reflect.Value.Kind() ä¸ºæŒ‡é’ˆçš„å¤„ç†æ–¹å¼ï¼Œé€’å½’ .Elem().Interface()</p>

<p>if v.Kind() == reflect.Ptr &amp;&amp; !v.IsNil() {
	return mv.Valid(v.Elem().Interface(), tags)
}
ç„¶åè°ƒç”¨func (mv *Validator) validateVar(v interface{}, tag string) errorå¤„ç†</p>

<p>switch v.Kind() {
case reflect.Invalid:
	err = mv.validateVar(nil, tags)
default:
	err = mv.validateVar(val, tags)
}
åœ¨ validateVar ä¸­ï¼šé¦–å…ˆå°† tag è§£æä¸º n ä¸ªè§„åˆ™ï¼ˆæ¯ä¸ªè§„åˆ™åŒ…æ‹¬å‡½æ•°ï¼Œå‡½æ•°åç§°ï¼Œå‚æ•°ï¼‰ï¼Œç„¶åéå†è°ƒç”¨è¿™äº›è§„åˆ™</p>

<p>for _, t := range tags {
	if err := t.Fn(v, t.Param); err != nil {
		errs = append(errs, err)
	}
}
4 å¤„ç†æ‰€æœ‰çš„ field
è°ƒç”¨func (mv *Validator) deepValidateCollection(f reflect.Value, fname string, m ErrorMap)</p>

<p>åˆšåˆšå¤„ç†äº†æ‰€æœ‰ tag ä¸ä¸ºç©ºçš„ fieldï¼Œä½†æ˜¯è¿˜éœ€è¦å¤„ç†æ‰€æœ‰çš„ fieldï¼Œæ¯”å¦‚ []AxxxStructè¿™ä¸ª field çš„ tag å°±æ˜¯ç©ºï¼Œä½†æ˜¯ä»–é‡Œé¢çš„AxxxStructçš„ tag ä¸ä¸ºç©º</p>

<p>è¿™ä¸ªæ–¹æ³•çš„æœ€åä¸€ä¸ªå‚æ•°ä¸€ä¸ª err çš„ mapï¼Œä»¥åœ¨é€’å½’çš„è¿‡ç¨‹ä¸­æ‹¿åˆ°æ‰€æœ‰çš„ error</p>

<p>åœ¨è¿™ä¸ªå‡½æ•°é‡Œé¢ï¼Œéœ€è¦å¤„ç†ä¸‰ç§æƒ…å½¢ï¼š</p>

<p>4.1 structï¼Œinterfaceï¼Œptr
è°ƒç”¨func (mv *Validator) Validate(v interface{}) errorï¼Œå·²ç»åœ¨ä¸Šé¢è®²è¿‡äº†ï¼Œå°±æ˜¯å…¥å£å‡½æ•°</p>

<p>ç›¸å½“äºï¼šstruct çš„ struct çš„ structï¼Œé€’å½’è°ƒç”¨ Validate å»å¤„ç†</p>

<p>4.2 arrayï¼Œslice
å¯¹äºæ¯ä¸ªå…ƒç´ é€’å½’è°ƒç”¨ deepValidateCollection</p>

<p>4.3 map
å¯¹äº key å’Œ map é€’å½’è°ƒç”¨ deepValidateCollection</p>

<p>ä»£ç è¯¦è§£æ³¨é‡Š
diff â€“git validator.go validator.go
index a23f3ee..d1ed91c 100644
â€” validator.go
+++ validator.go
@@ -1,369 +1,401 @@
 // Package validator implements value validations
 //
 // Copyright 2014 Roberto Teixeira <a href="mailto:robteix@robteix.com">robteix@robteix.com</a>
 //
 // Licensed under the Apache License, Version 2.0 (the â€œLicenseâ€);
 // you may not use this file except in compliance with the License.
 // You may obtain a copy of the License at
 //
 //    http://www.apache.org/licenses/LICENSE-2.0
 //
 // Unless required by applicable law or agreed to in writing, software
 // distributed under the License is distributed on an â€œAS ISâ€ BASIS,
 // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 // See the License for the specific language governing permissions and
 // limitations under the License.</p>

<p>package validator</p>

<p>import (
        â€œerrorsâ€
        â€œfmtâ€
        â€œreflectâ€
        â€œregexpâ€
        â€œstringsâ€
        â€œunicodeâ€
 )</p>

<p>// TextErr is an error that also implements the TextMarshaller interface for
 // serializing out to various plain text encodings. Packages creating their
 // own custom errors should use TextErr if theyâ€™re intending to use serializing
 // formats like json, msgpack etc.
 type TextErr struct {
        Err error
 }</p>

<p>// Error implements the error interface.
 func (t TextErr) Error() string {
        return t.Err.Error()
 }</p>

<p>// MarshalText implements the TextMarshaller
 func (t TextErr) MarshalText() ([]byte, error) {
        return []byte(t.Err.Error()), nil
 }</p>

<p>var (
        // ErrZeroValue is the error returned when variable has zero valud
        // and nonzero was specified
        ErrZeroValue = TextErr{errors.New(â€œzero valueâ€)}
        // ErrMin is the error returned when variable is less than mininum
        // value specified
        ErrMin = TextErr{errors.New(â€œless than minâ€)}
        // ErrMax is the error returned when variable is more than
        // maximum specified
        ErrMax = TextErr{errors.New(â€œgreater than maxâ€)}
        // ErrLen is the error returned when length is not equal to
        // param specified
        ErrLen = TextErr{errors.New(â€œinvalid lengthâ€)}
        // ErrRegexp is the error returned when the value does not
        // match the provided regular expression parameter
        ErrRegexp = TextErr{errors.New(â€œregular expression mismatchâ€)}
        // ErrUnsupported is the error error returned when a validation rule
        // is used with an unsupported variable type
        ErrUnsupported = TextErr{errors.New(â€œunsupported typeâ€)}
        // ErrBadParameter is the error returned when an invalid parameter
        // is provided to a validation rule (e.g. a string where an int was
        // expected (max=foo,len=bar) or missing a parameter when one is required (len=))
        ErrBadParameter = TextErr{errors.New(â€œbad parameterâ€)}
        // ErrUnknownTag is the error returned when an unknown tag is found
        ErrUnknownTag = TextErr{errors.New(â€œunknown tagâ€)}
        // ErrInvalid is the error returned when variable is invalid
        // (normally a nil pointer)
        ErrInvalid = TextErr{errors.New(â€œinvalid valueâ€)}
 )</p>

<p>// ErrorMap is a map which contains all errors from validating a struct.
 type ErrorMap map[string]ErrorArray</p>

<p>// ErrorMap implements the Error interface so we can check error against nil.
 // The returned error is if existent the first error which was added to the map.
 func (err ErrorMap) Error() string {
        for k, errs := range err {
                if len(errs) &gt; 0 {
                        return fmt.Sprintf(â€œ%s: %sâ€, k, errs.Error())
                }
        }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    return ""  }
</code></pre></div></div>

<p>// ErrorArray is a slice of errors returned by the Validate function.
 type ErrorArray []error</p>

<p>// ErrorArray implements the Error interface and returns the first error as
 // string if existent.
 func (err ErrorArray) Error() string {
        if len(err) &gt; 0 {
                return err[0].Error()
        }
        return â€œâ€
 }</p>

<p>+// ä¸Šé¢è‡ªå®šä¹‰äº†ä¸‰ä¸ªerrorï¼š TextErr ErrorMap ErrorArray
+
 // ValidationFunc is a function that receives the value of a
 // field and a parameter used for the respective validation tag.
 type ValidationFunc func(v interface{}, param string) error</p>

<p>// Validator implements a validator
 type Validator struct {
        // Tag name being used.</p>
<ul>
  <li>// å–fieldçš„å“ªä¸ªtagå»éªŒè¯ï¼Œé»˜è®¤æ˜¯validate
tagName string
// validationFuncs is a map of ValidationFuncs indexed
// by their name.</li>
  <li>// éªŒè¯å‡½æ•°
validationFuncs map[string]ValidationFunc
 }</li>
</ul>

<p>// Helper validator so users can use the
 // functions directly from the package
+// é»˜è®¤éªŒè¯å™¨ï¼Œtagæ˜¯validateï¼ŒéªŒè¯å‡½æ•°æœ‰å†…ç½®çš„5ä¸ªï¼šnonzero len min max regexp
 var defaultValidator = NewValidator()</p>

<p>// NewValidator creates a new Validator
 func NewValidator() *Validator {
        return &amp;Validator{
                tagName: â€œvalidateâ€,
                validationFuncs: map[string]ValidationFunc{
                        â€œnonzeroâ€: nonzero,
                        â€œlenâ€:     length,
                        â€œminâ€:     min,
                        â€œmaxâ€:     max,
                        â€œregexpâ€:  regex,
                },
        }
 }</p>

<p>// SetTag allows you to change the tag name used in structs
+// åˆ‡æ¢éªŒè¯æ‰€ä½¿ç”¨çš„tag
 func SetTag(tag string) {
        defaultValidator.SetTag(tag)
 }</p>

<p>// SetTag allows you to change the tag name used in structs
 func (mv *Validator) SetTag(tag string) {
        mv.tagName = tag
 }</p>

<p>// WithTag creates a new Validator with the new tag name. It is
 // useful to chain-call with Validate so we donâ€™t change the tag
 // name permanently: validator.WithTag(â€œfooâ€).Validate(t)
+// å’ŒSetTagä¸€æ ·ï¼Œæ˜¯é“¾å¼è°ƒç”¨ï¼Œå¹¶ä¸”ä¸ä¼šæ”¹å˜åŸæ¥çš„éªŒè¯å™¨çš„tagå€¼
 func WithTag(tag string) *Validator {
        return defaultValidator.WithTag(tag)
 }</p>

<p>// WithTag creates a new Validator with the new tag name. It is
 // useful to chain-call with Validate so we donâ€™t change the tag
 // name permanently: validator.WithTag(â€œfooâ€).Validate(t)
 func (mv *Validator) WithTag(tag string) *Validator {
        v := mv.copy()
        v.SetTag(tag)
        return v
 }</p>

<p>// Copy a validator
+// å…‹éš†éªŒè¯å™¨
 func (mv *Validator) copy() *Validator {
        newFuncs := map[string]ValidationFunc{}
        for k, f := range mv.validationFuncs {
                newFuncs[k] = f
        }
        return &amp;Validator{
                tagName:         mv.tagName,
                validationFuncs: newFuncs,
        }
 }</p>

<p>// SetValidationFunc sets the function to be used for a given
 // validation constraint. Calling this function with nil vf
 // is the same as removing the constraint function from the list.
+// æ·»åŠ è‡ªå®šä¹‰çš„éªŒè¯å‡½æ•°ï¼Œæˆ–è€…åˆ é™¤æŸä¸€ä¸ªéªŒè¯å‡½æ•°ï¼ˆå‡½æ•°ä¸ºnilçš„æƒ…å†µï¼‰
 func SetValidationFunc(name string, vf ValidationFunc) error {
        return defaultValidator.SetValidationFunc(name, vf)
 }</p>

<p>// SetValidationFunc sets the function to be used for a given
 // validation constraint. Calling this function with nil vf
 // is the same as removing the constraint function from the list.
 func (mv *Validator) SetValidationFunc(name string, vf ValidationFunc) error {
        if name == â€œâ€ {
                return errors.New(â€œname cannot be emptyâ€)
        }
        if vf == nil {
                delete(mv.validationFuncs, name)
                return nil
        }
        mv.validationFuncs[name] = vf
        return nil
 }</p>

<p>// Validate validates the fields of a struct based
 // on â€˜validatorâ€™ tags and returns errors found indexed
 // by the field name.
+//
+// åŸºäº validator çš„tagå¯¹structè¿›è¡Œæ ¡éªŒ
 func Validate(v interface{}) error {
        return defaultValidator.Validate(v)
 }</p>

<p>// Validate validates the fields of a struct based
 // on â€˜validatorâ€™ tags and returns errors found indexed
 // by the field name.
 func (mv *Validator) Validate(v interface{}) error {
        sv := reflect.ValueOf(v)
        st := reflect.TypeOf(v)
+</p>
<ul>
  <li>// å¯¹äº reflect.Value.Kind() ä¸ºæŒ‡é’ˆçš„å¤„ç†æ–¹å¼ï¼Œé€’å½’ .Elem().Interface()
if sv.Kind() == reflect.Ptr &amp;&amp; !sv.IsNil() {
        return mv.Validate(sv.Elem().Interface())
}
+</li>
  <li>
    <p>// reflect.Value.Kind() éœ€è¦æ˜¯ reflect.Struct æˆ–è€… reflect.Interface
if sv.Kind() != reflect.Struct &amp;&amp; sv.Kind() != reflect.Interface {
        return ErrUnsupported
}</p>
  </li>
  <li>nfields := sv.NumField()
m := make(ErrorMap)</li>
  <li>for i := 0; i &lt; nfields; i++ {</li>
  <li>// éå† field</li>
  <li>// reflect.Type.NumField()</li>
  <li>for i := 0; i &lt; sv.NumField(); i++ {</li>
  <li>// reflect.Type.Field(i)</li>
  <li>//                      .Name
fname := st.Field(i).Name
if !unicode.IsUpper(rune(fname[0])) {</li>
  <li>
    <p>// åªå¤„ç†exportedçš„field
continue
                }</p>
  </li>
  <li>// å¯¹äº reflect.Value.Field(i).Kind() ä¸ºæŒ‡é’ˆçš„å¤„ç†æ–¹å¼ï¼Œä¸€ç›´å– .Elem()
f := sv.Field(i)</li>
  <li>// deal with pointers
for f.Kind() == reflect.Ptr &amp;&amp; !f.IsNil() {
        f = f.Elem()
}</li>
  <li>// è·å–tagï¼š reflect.Type.Field(i).Tag.Get(name)
tag := st.Field(i).Tag.Get(mv.tagName)
if tag == â€œ-â€œ {</li>
  <li>
    <p>// è·³è¿‡ <code class="language-plaintext highlighter-rouge">-</code>
continue
                }
                var errs ErrorArray</p>
  </li>
  <li>// å¤„ç†tagä¸ä¸ºç©ºçš„
if tag != â€œâ€ {</li>
  <li>
    <p>// reflect.Value.Field(i).Interface() å¯¹åº”çš„fieldçš„å€¼ ï¼Œä»¥åŠtagçš„åå­—ï¼Œä½¿ç”¨.Validè¿›è¡Œæ ¡éªŒ
err := mv.Valid(f.Interface(), tag)
if errors, ok := err.(ErrorArray); ok {
        errs = errors
} else {
        if err != nil {
                errs = ErrorArray{err}
        }
}
                }</p>
  </li>
  <li>
    <p>// TODO
mv.deepValidateCollection(f, fname, m) // no-op if field is not a struct, interface, array, slice or map</p>

    <p>if len(errs) &gt; 0 {
        m[st.Field(i).Name] = errs
}
        }</p>
  </li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if len(m) &gt; 0 {
            return m
    }
    return nil  }
</code></pre></div></div>

<p>func (mv *Validator) deepValidateCollection(f reflect.Value, fname string, m ErrorMap) {
        switch f.Kind() {
        case reflect.Struct, reflect.Interface, reflect.Ptr:</p>
<ul>
  <li>// structçš„structçš„structï¼Œé€’å½’è°ƒç”¨Validateå»å¤„ç†
e := mv.Validate(f.Interface())
if e, ok := e.(ErrorMap); ok &amp;&amp; len(e) &gt; 0 {
        for j, k := range e {
                m[fname+â€.â€+j] = k
        }
}
        case reflect.Array, reflect.Slice:</li>
  <li>// å¯¹äºæ¯ä¸ªå…ƒç´ é€’å½’è°ƒç”¨deepValidateCollection
for i := 0; i &lt; f.Len(); i++ {
        mv.deepValidateCollection(f.Index(i), fmt.Sprintf(â€œ%s[%d]â€, fname, i), m)
}
        case reflect.Map:</li>
  <li>// å¯¹äºkeyå’Œmapé€’å½’è°ƒç”¨deepValidateCollection
for _, key := range f.MapKeys() {
        mv.deepValidateCollection(key, fmt.Sprintf(â€œ%s<a href="key">%+v</a>â€, fname, key.Interface()), m) // validate the map key
        value := f.MapIndex(key)
        mv.deepValidateCollection(value, fmt.Sprintf(â€œ%s<a href="value">%+v</a>â€, fname, key.Interface()), m)
}
        }
 }</li>
</ul>

<p>// Valid validates a value based on the provided
 // tags and returns errors found or nil.
+// è¿™ä¸ªéªŒè¯çš„èŒƒå›´æ›´å¤§ï¼Œå¯ä»¥åœ¨æ‰€æœ‰ç±»å‹ä¸ŠéªŒè¯ï¼Œå¹¶ä¸”å¯ä»¥æŒ‡å®štagçš„å€¼
 func Valid(val interface{}, tags string) error {
        return defaultValidator.Valid(val, tags)
 }</p>

<p>// Valid validates a value based on the provided
 // tags and returns errors found or nil.
 func (mv *Validator) Valid(val interface{}, tags string) error {
        if tags == â€œ-â€œ {</p>
<ul>
  <li>// è·³è¿‡ -
return nil
        }
        v := reflect.ValueOf(val)</li>
  <li>// å¯¹äº reflect.Value.Kind() ä¸ºæŒ‡é’ˆçš„å¤„ç†æ–¹å¼ï¼Œé€’å½’ .Elem().Interface()
if v.Kind() == reflect.Ptr &amp;&amp; !v.IsNil() {
        return mv.Valid(v.Elem().Interface(), tags)
}
var err error
switch v.Kind() {
case reflect.Invalid:
        err = mv.validateVar(nil, tags)
default:
        err = mv.validateVar(val, tags)
}
return err
 }</li>
</ul>

<p>// validateVar validates one single variable
 func (mv *Validator) validateVar(v interface{}, tag string) error {
        tags, err := mv.parseTags(tag)
        if err != nil {
                // unknown tag found, give up.
                return err
        }
        errs := make(ErrorArray, 0, len(tags))
        for _, t := range tags {
                if err := t.Fn(v, t.Param); err != nil {
                        errs = append(errs, err)
                }
        }
        if len(errs) &gt; 0 {
                return errs
        }
        return nil
 }</p>

<p>// tag represents one of the tag items
+// ä¸€ä¸ªtagè®¡ç®—å¼ï¼Œæœ‰åå­—ï¼Œå‡½æ•°ï¼Œå‚æ•°
 type tag struct {
        Name  string         // name of the tag
        Fn    ValidationFunc // validation function to call
        Param string         // parameter to send to the validation function
 }</p>

<p>// separate by no escaped commas
 var sepPattern *regexp.Regexp = regexp.MustCompile(<code class="language-plaintext highlighter-rouge">((?:^|[^\\])(?:\\\\)*),</code>)</p>

<p>func splitUnescapedComma(str string) []string {
        ret := []string{}
        indexes := sepPattern.FindAllStringIndex(str, -1)
        last := 0
        for _, is := range indexes {
                ret = append(ret, str[last:is[1]-1])
                last = is[1]
        }
        ret = append(ret, str[last:])
        return ret
 }</p>

<p>// parseTags parses all individual tags found within a struct tag.
 func (mv *Validator) parseTags(t string) ([]tag, error) {
        tl := splitUnescapedComma(t)</p>
<ul>
  <li>
    <p>fmt.Printf(â€œtl %v\nâ€, tl)
tags := make([]tag, 0, len(tl))
for _, i := range tl {
        i = strings.Replace(i, <code class="language-plaintext highlighter-rouge">\,</code>, â€œ,â€, -1)
        tg := tag{}
        v := strings.SplitN(i, â€œ=â€, 2)
        tg.Name = strings.Trim(v[0], â€œ â€œ)
        if tg.Name == â€œâ€ {
                return []tag{}, ErrUnknownTag
        }
        if len(v) &gt; 1 {
                tg.Param = strings.Trim(v[1], â€œ â€œ)
        }
        var found bool
        if tg.Fn, found = mv.validationFuncs[tg.Name]; !found {
                return []tag{}, ErrUnknownTag
        }
        tags = append(tags, tg)</p>

    <p>}
return tags, nil
 }</p>
  </li>
</ul>

<p>ä»å­—æ®µæ ¡éªŒçš„éœ€æ±‚æ¥è®²ï¼Œæ— è®ºæˆ‘ä»¬é‡‡ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢è¿˜æ˜¯å¹¿åº¦ä¼˜å…ˆæœç´¢æ¥å¯¹è¿™æ£µç»“æ„ä½“æ ‘æ¥è¿›è¡Œéå†ï¼Œéƒ½æ˜¯å¯ä»¥çš„ã€‚</p>

<p>é€šè¿‡golangçš„structTagæ¥é…ç½®éªŒè¯å™¨
type Class struct {
    Cid       int64  <code class="language-plaintext highlighter-rouge">validate:"required||integer=10000,_"</code>
    Cname     string <code class="language-plaintext highlighter-rouge">validate:"required||string=1,5||unique"</code>
    BeginTime string <code class="language-plaintext highlighter-rouge">validate:"required||datetime=H:i"</code>
}</p>

<p>type Student struct {
    Uid          int64    <code class="language-plaintext highlighter-rouge">validate:"required||integer=10000,_"</code>
    Name         string   <code class="language-plaintext highlighter-rouge">validate:"required||string=1,5"</code>
    Age          int64    <code class="language-plaintext highlighter-rouge">validate:"required||integer=10,30"</code>
    Sex          string   <code class="language-plaintext highlighter-rouge">validate:"required||in=male,female"</code>
    Email        string   <code class="language-plaintext highlighter-rouge">validate:"email||user||vm"</code>
    PersonalPage string   <code class="language-plaintext highlighter-rouge">validate:"url"</code>
    Hobby        []string <code class="language-plaintext highlighter-rouge">validate:"array=_,2||unique||in=swimming,running,drawing"</code>
    CreateTime   string   <code class="language-plaintext highlighter-rouge">validate:"datetime"</code>
    Class        []Class  <code class="language-plaintext highlighter-rouge">validate:"array=1,3"</code>
}
required åˆ¤æ–­å­—æ®µå¯¹åº”çš„å€¼æ˜¯å¦æ˜¯å¯¹åº”ç±»å‹çš„é›¶å€¼
integer è¡¨ç¤ºå­—æ®µç±»å‹æ˜¯å¦æ˜¯æ•´æ•°ç±»å‹ï¼Œå¦‚æœintegeråè¾¹ä¸æ¥=?,?ï¼Œé‚£ä¹ˆè¡¨ç¤ºåªåˆ¤æ–­æ˜¯å¦æ˜¯æ•´æ•°ç±»å‹ï¼Œå¦‚æœåè¾¹æ¥=?,?ï¼Œé‚£ä¹ˆæœ‰å››ç§å†™æ³•
(1). integer=10 è¡¨ç¤ºå­—æ®µå€¼ = 10
(2). integer=_ ,10 è¡¨ç¤ºå­—æ®µå€¼ &lt;= 10ï¼Œå­—æ®µå€¼æœ€å°å€¼ä¸ºå­—æ®µå¯¹åº”ç±»å‹çš„æœ€å°å€¼(æ¯”å¦‚å­—æ®µå¯¹åº”ç±»å‹ä¸ºint8ï¼Œé‚£ä¹ˆæœ€å°ä¸ºâˆ’128)ï¼Œæœ€å¤§å€¼ä¸º10
(3). integer=10, _ è¡¨ç¤ºå­—æ®µå€¼ &gt;= 10ï¼Œå­—æ®µå€¼æœ€å°å€¼ä¸º10ï¼Œæœ€å¤§å€¼ä¸ºå­—æ®µå¯¹åº”ç±»å‹çš„æœ€å¤§å€¼(æ¯”å¦‚å­—æ®µå¯¹åº”ç±»å‹ä¸ºint8ï¼Œé‚£ä¹ˆæœ€å¤§ä¸º127)
(4). integer=1,20 è¡¨ç¤ºå­—æ®µå€¼ &gt;=1 å¹¶ä¸” &lt;= 20
arrayã€string åŒ integerï¼Œarray=?,? è¡¨ç¤ºå…ƒç´ ä¸ªæ•°èŒƒå›´ï¼Œstring=?,? è¡¨ç¤ºå­—ç¬¦ä¸²é•¿åº¦èŒƒå›´
email è¡¨ç¤ºå­—æ®µå€¼æ˜¯å¦æ˜¯åˆæ³•çš„emailåœ°å€
url è¡¨ç¤ºå­—æ®µå€¼æ˜¯å¦æ˜¯åˆæ³•çš„urlåœ°å€
in è¡¨ç¤ºå­—æ®µå€¼åœ¨inæŒ‡å®šçš„å€¼ä¸­ï¼Œæ¯”å¦‚ Hobby å­—æ®µä¸­ï¼Œin=swimming,running,drawingï¼Œè¡¨ç¤º Hobby å­—æ®µçš„å€¼ï¼Œåªèƒ½æ˜¯swimming,running,drawingä¸­çš„ä¸€ä¸ªæˆ–å¤šä¸ª
datetime è¡¨ç¤ºå­—æ®µå€¼ç¬¦åˆæ—¥æœŸç±»å‹ï¼Œå¦‚æœdatetimeåè¾¹ä¸æ¥=?ï¼Œé‚£ä¹ˆé»˜è®¤ä¸ºY-m-d H:i:sï¼Œå¦åˆ™éªŒè¯å™¨ä¼šæŒ‰ç…§æŒ‡å®šæ ¼å¼åˆ¤æ–­ï¼Œæ¯”å¦‚ datetime=Y-mã€datetime=Y/m/d H:i:sç­‰ï¼Œå¯ä»¥æ˜¯Y m d H i s çš„éšæ„æ‹¼æ¥
unique è¡¨ç¤ºå­—æ®µå€¼å”¯ä¸€ï¼Œæ¯”å¦‚ Hobby å­—æ®µçš„ uniqueï¼Œè¡¨ç¤º Hobby å­—æ®µå€¼å”¯ä¸€ï¼ŒClass ä¸­ï¼ŒCname å­—æ®µçš„ uniqueï¼Œè¡¨ç¤º Cname å­—æ®µå€¼å”¯ä¸€</p>

:ET