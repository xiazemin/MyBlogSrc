I"‡<p>https://jiajunhuang.com/articles/2020_04_22-golang_context.md.html
<!-- more -->
Golangä¸­ä½¿ç”¨contextä½œä¸ºgoroutineä¹‹é—´çš„æ§åˆ¶å™¨ï¼Œä¾‹å¦‚ï¼š</p>

<p>package main</p>

<p>import (
	â€œcontextâ€
	â€œlogâ€
	â€œtimeâ€
)</p>

<p>func UseContext(ctx context.Context) {
	for {
		select {
		case &lt;-ctx.Done():
			log.Printf(â€œcontext is done with error %sâ€, ctx.Err())
			return
		default:
			log.Printf(â€œnothing just loopâ€¦â€)
			time.Sleep(time.Second * time.Duration(1))
		}
	}
}</p>

<p>func main() {
	ctx, cancel := context.WithCancel(context.Background())
	go UseContext(ctx)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>time.Sleep(time.Second * time.Duration(1))
cancel()
time.Sleep(time.Second * time.Duration(2)) } è¿™æ ·å°±å¯ä»¥åœ¨ main å‡½æ•°é‡Œå‘ŠçŸ¥ UseContext æ‰€åœ¨çš„goroutineï¼Œä¸»å‡½æ•°å·²ç»æƒ³è¦é€€å‡ºäº†ã€‚å½“ç„¶ï¼Œå¹¶ä¸æ˜¯ä»€ä¹ˆå¾ˆç¥å¥‡çš„æ–¹æ³•ï¼Œ ä¹Ÿå°±æ˜¯ç›¸å½“äºmainå‡½æ•°é‡Œä¼ é€’ä¸€ä¸ªå˜é‡ï¼Œè€ŒUseContexté‡Œä¸æ–­çš„å»æ£€æŸ¥å˜é‡è€Œå·²ï¼Œåªä¸è¿‡åœ¨Golangé‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯chanelæ¥å®ç°ã€‚
</code></pre></div></div>

<p>æ¥çœ‹çœ‹ context æ˜¯å•¥ï¼ŒåŸæ¥æ˜¯ä¸ªæ¥å£ï¼š</p>

<p>type Context interface {
	Deadline() (deadline time.Time, ok bool)
	Done() &lt;-chan struct{}
	Err() error
	Value(key interface{}) interface{}
}
æ—¢ç„¶æ˜¯æ¥å£ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¾—æ¥æ‰¾ä¸€ä¸ªå…·ä½“çš„å®ç°æ¥çœ‹çœ‹ï¼Œæ¯”å¦‚ context.Background()ï¼š</p>

<p>func Background() Context {
	return background
}</p>

<p>// but what is background? itâ€™s:
var (
	background = new(emptyCtx)
	todo       = new(emptyCtx)
)
åŸæ¥æ˜¯ä¸€ä¸ª emptyCtx å®ä¾‹ã€‚é‚£ WithCancel() æ˜¯å’‹å®ç°çš„å‘¢ï¼Ÿ</p>

<p>// WithCancel returns a copy of parent with a new Done channel. The returned
// contextâ€™s Done channel is closed when the returned cancel function is called
// or when the parent contextâ€™s Done channel is closed, whichever happens first.
//
// Canceling this context releases resources associated with it, so code should
// call cancel as soon as the operations running in this Context complete.
func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
	c := newCancelCtx(parent)
	propagateCancel(parent, &amp;c)
	return &amp;c, func() { c.cancel(true, Canceled) }
}</p>

<p>// A cancelCtx can be canceled. When canceled, it also cancels any children
// that implement canceler.
type cancelCtx struct {
	Context</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mu       sync.Mutex            // protects following fields
done     chan struct{}         // created lazily, closed by first cancel call
children map[canceler]struct{} // set to nil by the first cancel call
err      error                 // set to non-nil by the first cancel call } å¯ä»¥çœ‹å‡ºæ¥ï¼Œdoneæ˜¯ä¸€ä¸ªchannelï¼Œæˆ‘ä»¬åœ¨ UseContext é‡Œï¼Œé€šè¿‡selectæ¥æ£€æµ‹ctxæ˜¯å¦å·²ç»å…³é—­ï¼Œå…¶å®å°±æ˜¯çœ‹doneè¿™ä¸ªchannel æ˜¯å¦å…³é—­äº†ã€‚ä¸ä¿¡å¯ä»¥çœ‹çœ‹ cancel çš„å®ç°ï¼š
</code></pre></div></div>

<p>// cancel closes c.done, cancels each of câ€™s children, and, if
// removeFromParent is true, removes c from its parentâ€™s children.
func (c *cancelCtx) cancel(removeFromParent bool, err error) {
	if err == nil {
		panic(â€œcontext: internal error: missing cancel errorâ€)
	}
	c.mu.Lock()
	if c.err != nil {
		c.mu.Unlock()
		return // already canceled
	}
	c.err = err
	if c.done == nil {
		c.done = closedchan
	} else {
		close(c.done) // NOTE(jiajun): here it is :)
	}
	for child := range c.children {
		// NOTE: acquiring the childâ€™s lock while holding parentâ€™s lock.
		child.cancel(false, err)
	}
	c.children = nil
	c.mu.Unlock()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if removeFromParent {
	removeChild(c.Context, c)
} } ç§ï¼Œè°ƒç”¨cancelçš„æ—¶å€™å°±æ˜¯è°ƒç”¨äº† close(c.done)ï¼Œç„¶åä¸‹ä¸€æ¬¡å¾ªç¯çš„æ—¶å€™ï¼ŒUseContext å°±èƒ½æ£€æµ‹åˆ°ctxå·²ç»å…³é—­äº†ã€‚
</code></pre></div></div>

<p>æ€»ç»“
è¿™ç¯‡åšå®¢é‡Œæˆ‘ä»¬çœ‹åˆ°äº†contextæ˜¯æ€ä¹ˆå®ç°çš„ï¼Œè¯»è€…å¦‚æœæœ‰å…´è¶£çš„è¯ï¼Œå¯ä»¥çœ‹çœ‹Contextä¸­çš„ä¼ å€¼å’Œå–å€¼æ˜¯æ€ä¹ˆå®ç°çš„ï¼Œä»¥åŠæ€è€ƒä¸€ä¸‹ æ˜¯å¦æœ‰æ›´å¥½çš„å®ç°æ–¹æ¡ˆã€‚</p>
:ET