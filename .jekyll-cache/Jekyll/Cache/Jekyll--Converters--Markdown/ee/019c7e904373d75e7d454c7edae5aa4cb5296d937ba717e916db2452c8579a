I"<p>goçš„è°ƒåº¦å™¨åªè¦å®ç°åœ¨ runtime åŒ…ä¸­ï¼Œè·¯å¾„ä¸ºï¼š ./src/runtime/proc.go æ–‡ä»¶ä¸­ã€‚
<!-- more -->
goè¯­è¨€å…¶å®æ˜¯åœ¨æ“ä½œç³»ç»Ÿæä¾›çš„å†…æ ¸çº¿ç¨‹ä¹‹ä¸Šæ­å»ºäº†ä¸€ä¸ªç‰¹æœ‰å¾— ã€ä¸¤çº§çº¿ç¨‹ã€‘æ¨¡å‹ã€‚ä¸‹é¢å†è¯´ä¸¤çº§çº¿ç¨‹æ¨¡å‹å‰ï¼Œæœ‰ä¸‰ä¸ªå¿…çŸ¥çš„æ ¸å¿ƒå…ƒç´ ã€‚(Gã€Mã€P)</p>

<p>Gï¼šGoroutineçš„ç¼©å†™ï¼Œä¸€ä¸ªGä»£è¡¨äº†å¯¹ä¸€æ®µéœ€è¦è¢«æ‰§è¡Œçš„Goè¯­è¨€ä»£ç çš„å°è£…
Mï¼šMachineçš„ç¼©å†™ï¼Œä¸€ä¸ªMä»£è¡¨äº†ä¸€ä¸ªå†…æ ¸çº¿ç¨‹
Pï¼šProcessorçš„ç¼©å†™ï¼Œä¸€ä¸ªPä»£è¡¨äº†Mæ‰€éœ€çš„ä¸Šä¸‹æ–‡ç¯å¢ƒ
ç®€å•çš„æ¥è¯´ï¼Œä¸€ä¸ªGçš„æ‰§è¡Œéœ€è¦Må’ŒPçš„æ”¯æŒã€‚ä¸€ä¸ªMåœ¨ä¸ä¸€ä¸ªPå…³è”ä¹‹åå½¢æˆäº†ä¸€ä¸ªæœ‰æ•ˆçš„Gè¿è¡Œç¯å¢ƒã€å†…æ ¸çº¿ç¨‹ + ä¸Šä¸‹æ–‡ç¯å¢ƒã€‘ã€‚æ¯ä¸ªPéƒ½ä¼šåŒ…å«ä¸€ä¸ªå¯è¿è¡Œçš„Gçš„é˜Ÿåˆ— (runq )ã€‚</p>

<p>å¥½äº†ä¸‹é¢æˆ‘ä»¬æ¥å…·ä½“çš„çœ‹çœ‹ Gã€Mã€P</p>

<p>M (machine)ï¼š
Mæ˜¯machineçš„å¤´æ–‡å­—, åœ¨å½“å‰ç‰ˆæœ¬çš„golangä¸­ç­‰åŒäºç³»ç»Ÿçº¿ç¨‹.
Må¯ä»¥è¿è¡Œä¸¤ç§ä»£ç :</p>

<p>goä»£ç , å³goroutine, Mè¿è¡Œgoä»£ç éœ€è¦ä¸€ä¸ªP
åŸç”Ÿä»£ç , ä¾‹å¦‚é˜»å¡çš„syscall, Mè¿è¡ŒåŸç”Ÿä»£ç ä¸éœ€è¦P
Mä¼šä»è¿è¡Œé˜Ÿåˆ—ä¸­å–å‡ºG, ç„¶åè¿è¡ŒG, å¦‚æœGè¿è¡Œå®Œæ¯•æˆ–è€…è¿›å…¥ä¼‘çœ çŠ¶æ€, åˆ™ä»è¿è¡Œé˜Ÿåˆ—ä¸­å–å‡ºä¸‹ä¸€ä¸ªGè¿è¡Œ, å‘¨è€Œå¤å§‹ã€‚
æœ‰æ—¶å€™Géœ€è¦è°ƒç”¨ä¸€äº›æ— æ³•é¿å…é˜»å¡çš„åŸç”Ÿä»£ç , è¿™æ—¶Mä¼šé‡Šæ”¾æŒæœ‰çš„På¹¶è¿›å…¥é˜»å¡çŠ¶æ€, å…¶ä»–Mä¼šå–å¾—è¿™ä¸ªPå¹¶ç»§ç»­è¿è¡Œé˜Ÿåˆ—ä¸­çš„G.
goéœ€è¦ä¿è¯æœ‰è¶³å¤Ÿçš„Må¯ä»¥è¿è¡ŒG, ä¸è®©CPUé—²ç€, ä¹Ÿéœ€è¦ä¿è¯Mçš„æ•°é‡ä¸èƒ½è¿‡å¤šã€‚é€šå¸¸åˆ›å»ºä¸€ä¸ªMçš„åŸå› æ˜¯ç”±äºæ²¡æœ‰è¶³å¤Ÿçš„Mæ¥å…³è”På¹¶è¿è¡Œå…¶ä¸­å¯è¿è¡Œçš„Gã€‚è€Œä¸”è¿è¡Œæ—¶ç³»ç»Ÿæ‰§è¡Œç³»ç»Ÿç›‘æ§çš„æ—¶å€™ï¼Œæˆ–è€…GCçš„æ—¶å€™ä¹Ÿä¼šåˆ›å»ºMã€‚</p>

<p>Mçš„ç»“æ„ä½“å®šä¹‰ï¼š(åœ¨ ./src/runtime/runtime2.go æ–‡ä»¶ä¸­)</p>

<p>// M ç»“æ„ä½“
type m struct {
    /*
        1.  æ‰€æœ‰è°ƒç”¨æ ˆçš„Goroutine,è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒç‰¹æ®Šçš„Goroutineã€‚
        2.  æ™®é€šçš„Goroutineæ ˆæ˜¯åœ¨Heapåˆ†é…çš„å¯å¢é•¿çš„stack,è€Œg0çš„stackæ˜¯Må¯¹åº”çš„çº¿ç¨‹æ ˆã€‚
        3.  æ‰€æœ‰è°ƒåº¦ç›¸å…³ä»£ç ,ä¼šå…ˆåˆ‡æ¢åˆ°è¯¥Goroutineçš„æ ˆå†æ‰§è¡Œã€‚
    */
	g0      *g     // goroutine with scheduling stack
	morebuf gobuf  // gobuf arg to morestack
	divmod  uint32 // div/mod denominator for arm - known to liblink</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Fields not known to debuggers.
procid        uint64       // for debuggers, but offset not hard-coded
gsignal       *g           // signal-handling g
goSigStack    gsignalStack // Go-allocated signal handling stack
sigmask       sigset       // storage for saved signal mask
tls           [6]uintptr   // thread-local storage (for x86 extern register)
mstartfn      func()       // 
 
curg          *g       //   M æ­£åœ¨è¿è¡Œçš„ç»“æ„ä½“G
caughtsig     guintptr // goroutine running during fatal signal
p             puintptr // attached p for executing go code (nil if not executing go code)
nextp         puintptr
id            int32
mallocing     int32
throwing      int32
preemptoff    string // if != "", keep curg running on this m
locks         int32
softfloat     int32
dying         int32
profilehz     int32
helpgc        int32
spinning      bool // m is out of work and is actively looking for work
blocked       bool // m is blocked on a note
inwb          bool // m is executing a write barrier
newSigstack   bool // minit on C thread called sigaltstack
printlock     int8
incgo         bool // m is executing a cgo call
fastrand      uint32
ncgocall      uint64      // number of cgo calls in total
ncgo          int32       // number of cgo calls currently in progress
cgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily
cgoCallers    *cgoCallers // cgo traceback if crashing in cgo call
park          note
alllink       *m // on allm
schedlink     muintptr
mcache        *mcache
lockedg       *g          // è¡¨ç¤ºä¸å½“å‰Mé”å®šé‚£ä¸ªg
createstack   [32]uintptr // stack that created this thread.
freglo        [16]uint32  // d[i] lsb and f[i]
freghi        [16]uint32  // d[i] msb and f[i+16]
fflag         uint32      // floating point compare flags
locked        uint32      // tracking for lockosthread
nextwaitm     uintptr     // next m waiting for lock
needextram    bool
traceback     uint8
waitunlockf   unsafe.Pointer // todo go func(*g, unsafe.pointer) bool
waitlock      unsafe.Pointer
waittraceev   byte
waittraceskip int
startingtrace bool
syscalltick   uint32
thread        uintptr // thread handle
 
// these are here because they are too large to be on the stack
// of low-level NOSPLIT functions.
libcall   libcall
libcallpc uintptr // for cpu profiler
libcallsp uintptr
libcallg  guintptr
syscall   libcall // stores syscall parameters on windows
 
mOS } Mçš„å­—æ®µä¼—å¤šï¼Œå…¶ä¸­æœ€é‡è¦çš„ä¸ºä¸‹é¢å››ä¸ªï¼š
</code></pre></div></div>

<p>g0: Goè¿è¡Œæ—¶ç³»ç»Ÿåœ¨å¯åŠ¨ä¹‹åˆåˆ›å»ºçš„ï¼Œç”¨äºæ‰§è¡Œä¸€äº›è¿è¡Œæ—¶ä»»åŠ¡ã€‚</p>

<p>mstartfnï¼šè¡¨ç¤ºMçš„èµ·å§‹å‡½æ•°ã€‚å…¶å®å°±æ˜¯æˆ‘ä»¬ go è¯­å¥æºå¸¦çš„é‚£ä¸ªå‡½æ•°å•¦ã€‚</p>

<p>curgï¼šå­˜æ”¾å½“å‰æ­£åœ¨è¿è¡Œçš„Gçš„æŒ‡é’ˆã€‚</p>

<p>pï¼šæŒ‡å‘å½“å‰ä¸Må…³è”çš„é‚£ä¸ªPã€‚</p>

<p>nextpï¼šç”¨äºæš‚å­˜äºå½“å‰Mæœ‰æ½œåœ¨å…³è”çš„Pã€‚ ï¼ˆé¢„è”ï¼‰å½“Mé‡æ–°å¯åŠ¨æ—¶ï¼Œå³ç”¨é¢„è”çš„è¿™ä¸ªPåšå…³è”å•¦</p>

<p>spinningï¼šè¡¨ç¤ºå½“å‰Mæ˜¯å¦æ­£åœ¨å¯»æ‰¾Gã€‚åœ¨å¯»æ‰¾è¿‡ç¨‹ä¸­Må¤„äºè‡ªæ—‹çŠ¶æ€ã€‚</p>

<p>lockedgï¼šè¡¨ç¤ºä¸å½“å‰Mé”å®šçš„é‚£ä¸ªGã€‚è¿è¡Œæ—¶ç³»ç»Ÿä¼šæŠŠ ä¸€ä¸ªM å’Œä¸€ä¸ªGé”å®šï¼Œä¸€æ—¦é”å®šå°±åªèƒ½åŒæ–¹ç›¸äº’ä½œç”¨ï¼Œä¸æ¥å—ç¬¬ä¸‰è€…ã€‚</p>

<p>Må¹¶æ²¡æœ‰åƒGå’ŒPä¸€æ ·çš„çŠ¶æ€æ ‡è®°, ä½†å¯ä»¥è®¤ä¸ºä¸€ä¸ªMæœ‰ä»¥ä¸‹çš„çŠ¶æ€:</p>

<p>è‡ªæ—‹ä¸­(spinning): Mæ­£åœ¨ä»è¿è¡Œé˜Ÿåˆ—è·å–G, è¿™æ—¶å€™Mä¼šæ‹¥æœ‰ä¸€ä¸ªP
æ‰§è¡Œgoä»£ç ä¸­: Mæ­£åœ¨æ‰§è¡Œgoä»£ç , è¿™æ—¶å€™Mä¼šæ‹¥æœ‰ä¸€ä¸ªP
æ‰§è¡ŒåŸç”Ÿä»£ç ä¸­: Mæ­£åœ¨æ‰§è¡ŒåŸç”Ÿä»£ç æˆ–è€…é˜»å¡çš„syscall, è¿™æ—¶Må¹¶ä¸æ‹¥æœ‰P
ä¼‘çœ ä¸­: Må‘ç°æ— å¾…è¿è¡Œçš„Gæ—¶ä¼šè¿›å…¥ä¼‘çœ , å¹¶æ·»åŠ åˆ°ç©ºé—²Mé“¾è¡¨ä¸­, è¿™æ—¶Må¹¶ä¸æ‹¥æœ‰P
è‡ªæ—‹ä¸­(spinning)è¿™ä¸ªçŠ¶æ€éå¸¸é‡è¦, æ˜¯å¦éœ€è¦å”¤é†’æˆ–è€…åˆ›å»ºæ–°çš„Må–å†³äºå½“å‰è‡ªæ—‹ä¸­çš„Mçš„æ•°é‡ã€‚</p>

<p>Måœ¨è¢«åˆ›å»ºä¹‹åˆä¼šè¢«åŠ å…¥åˆ°å…¨å±€çš„Måˆ—è¡¨ ã€runtime.allmã€‘Â ã€‚æ¥ç€ï¼ŒMçš„èµ·å§‹å‡½æ•°ï¼ˆmstartfnï¼‰å’Œå‡†å¤‡å…³è”çš„Pï¼ˆpï¼‰éƒ½ä¼šè¢«è®¾ç½®ã€‚æœ€åï¼Œè¿è¡Œæ—¶ç³»ç»Ÿä¼šä¸ºMä¸“é—¨åˆ›å»ºä¸€ä¸ªæ–°çš„å†…æ ¸çº¿ç¨‹å¹¶ä¸ä¹‹å…³è”ã€‚è¿™æ—¶å€™è¿™ä¸ªæ–°çš„Må°±ä¸ºæ‰§è¡ŒGåšå¥½äº†å‡†å¤‡ã€‚å…¶ä¸­èµ·å§‹å‡½æ•°ï¼ˆmstartfnï¼‰ä»…å½“è¿è¡Œæ—¶ç³»ç»Ÿè¦ç”¨æ­¤Mæ‰§è¡Œç³»ç»Ÿç›‘æ§æˆ–è€…åƒåœ¾å›æ”¶ç­‰ä»»åŠ¡çš„æ—¶å€™æ‰ä¼šè¢«è®¾ç½®ã€‚å…¨å±€Måˆ—è¡¨çš„ä½œç”¨æ˜¯è¿è¡Œæ—¶ç³»ç»Ÿåœ¨éœ€è¦çš„æ—¶å€™ä¼šé€šè¿‡å®ƒè·å–åˆ°æ‰€æœ‰çš„Mçš„ä¿¡æ¯ï¼ŒåŒæ—¶é˜²æ­¢Mè¢«gcã€‚</p>

<p>åœ¨æ–°çš„Mè¢«åˆ›å»ºåå›è¥¿å®‰åšä¸€ç•ªåˆå§‹åŒ–å·¥ä½œã€‚å…¶ä¸­åŒ…æ‹¬äº†å¯¹è‡ªèº«æ‰€æŒçš„æ ˆç©ºé—´ä»¥åŠä¿¡å·åšå¤„ç†çš„åˆå§‹åŒ–ã€‚åœ¨ä¸Šè¿°åˆå§‹åŒ–å®Œæˆå mstartfn å‡½æ•°å°±ä¼šè¢«æ‰§è¡Œ (å¦‚æœå­˜åœ¨çš„è¯)ã€‚ã€æ³¨æ„ã€‘ï¼šå¦‚æœmstartfn ä»£è¡¨çš„æ˜¯ç³»ç»Ÿç›‘æ§ä»»åŠ¡çš„è¯ï¼Œé‚£ä¹ˆè¯¥Mä¼šä¸€ç›´åœ¨æ‰§è¡Œmstartfn è€Œä¸ä¼šæœ‰åç»­çš„æµç¨‹ã€‚å¦åˆ™ mstartfn æ‰§è¡Œå®Œåï¼Œå½“å‰Må°†ä¼šä¸é‚£ä¸ªå‡†å¤‡ä¸ä¹‹å…³è”çš„På®Œæˆå…³è”ã€‚è‡³æ­¤ï¼Œä¸€ä¸ªå¹¶å‘æ‰§è¡Œç¯å¢ƒæ‰çœŸæ­£å®Œæˆã€‚ä¹‹åå°±æ˜¯Må¼€å§‹å¯»æ‰¾å¯è¿è¡Œçš„Gå¹¶è¿è¡Œä¹‹ã€‚</p>

<p>è¿è¡Œæ—¶ç³»ç»Ÿç®¡è¾–çš„Mä¼šåœ¨GCä»»åŠ¡æ‰§è¡Œçš„æ—¶å€™è¢«åœæ­¢ï¼Œè¿™æ—¶å€™ç³»ç»Ÿä¼šå¯¹Mçš„å±æ€§åšæŸäº›å¿…è¦çš„é‡ç½®å¹¶æŠŠMæ”¾ç½®å…¥è°ƒåº¦å™¨çš„ç©ºé—²Måˆ—è¡¨ã€‚ã€å¾ˆé‡è¦ã€‘å› ä¸ºåœ¨éœ€è¦ä¸€ä¸ªæœªè¢«ä½¿ç”¨çš„Mæ—¶ï¼Œè¿è¡Œæ—¶ç³»ç»Ÿä¼šå…ˆå»è¿™ä¸ªç©ºé—²åˆ—è¡¨è·å–Mã€‚(åªæœ‰éƒ½æ²¡æœ‰çš„æ—¶å€™æ‰ä¼šåˆ›å»ºM)</p>

<p>Mæœ¬èº«æ˜¯æ— çŠ¶æ€çš„ã€‚Mæ˜¯å¦æœ‰ç©ºé—²ä»…ä»¥å®ƒæ˜¯å¦å­˜åœ¨äºè°ƒåº¦å™¨çš„ç©ºé—²Måˆ—è¡¨ ã€runtime.sched.midleã€‘Â  ä¸­ä¸ºä¾æ®Â (ç©ºé—²åˆ—è¡¨ä¸æ˜¯é‚£ä¸ªå…¨å±€åˆ—è¡¨å“¦)ã€‚</p>

<p>å•ä¸ªGoç¨‹åºæ‰€ä½¿ç”¨çš„Mçš„æœ€å¤§æ•°é‡æ˜¯å¯ä»¥è¢«è®¾ç½®çš„ã€‚åœ¨æˆ‘ä»¬ä½¿ç”¨å‘½ä»¤è¿è¡ŒGoç¨‹åºæ—¶å€™ï¼Œæœ‰ä¸€ä¸ªå¼•å¯¼ç¨‹åºå…ˆä¼šè¢«å¯åŠ¨çš„ã€‚åœ¨è¿™ä¸ªæ­Œå¼•å¯¼ç¨‹åºä¸­ä¼šä¸ºGoç¨‹åºçš„è¿è¡Œç®€å†å¿…è¦çš„ç¯å¢ƒã€‚å¼•å¯¼ç¨‹åºå¯¹Mçš„æ•°é‡è¿›è¡Œåˆå§‹åŒ–è®¾ç½®ï¼Œé»˜è®¤æ˜¯ æœ€å¤§å€¼ 1W ã€å³æ˜¯è¯´ï¼Œä¸€ä¸ªGoç¨‹åºæœ€å¤šå¯ä»¥ä½¿ç”¨1Wä¸ªMï¼Œå³ï¼šç†æƒ³çŠ¶æ€ä¸‹ï¼Œå¯ä»¥åŒæ—¶æœ‰1Wä¸ªå†…æ ¸çº¿ç¨‹è¢«åŒæ—¶è¿è¡Œã€‘ã€‚ä½¿ç”¨ runtime/debug.SetMaxThreads() å‡½æ•°è®¾ç½®ã€‚</p>

<p>P (process)ï¼š
Pæ˜¯processçš„å¤´æ–‡å­—, ä»£è¡¨Mè¿è¡ŒGæ‰€éœ€è¦çš„èµ„æºã€‚
ä¸€äº›è®²è§£åç¨‹çš„æ–‡ç« æŠŠPç†è§£ä¸ºcpuæ ¸å¿ƒ, å…¶å®è¿™æ˜¯é”™è¯¯çš„.
è™½ç„¶Pçš„æ•°é‡é»˜è®¤ç­‰äºcpuæ ¸å¿ƒæ•°, ä½†å¯ä»¥é€šè¿‡ç¯å¢ƒå˜é‡GOMAXPROCä¿®æ”¹, åœ¨å®é™…è¿è¡Œæ—¶Pè·Ÿcpuæ ¸å¿ƒå¹¶æ— ä»»ä½•å…³è”ã€‚</p>

<p>Pä¹Ÿå¯ä»¥ç†è§£ä¸ºæ§åˆ¶goä»£ç çš„å¹¶è¡Œåº¦çš„æœºåˆ¶,
å¦‚æœPçš„æ•°é‡ç­‰äº1, ä»£è¡¨å½“å‰æœ€å¤šåªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹(M)æ‰§è¡Œgoä»£ç ,
å¦‚æœPçš„æ•°é‡ç­‰äº2, ä»£è¡¨å½“å‰æœ€å¤šåªèƒ½æœ‰ä¸¤ä¸ªçº¿ç¨‹(M)æ‰§è¡Œgoä»£ç .
æ‰§è¡ŒåŸç”Ÿä»£ç çš„çº¿ç¨‹æ•°é‡ä¸å—Pæ§åˆ¶ã€‚</p>

<p>å› ä¸ºåŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ªçº¿ç¨‹(M)å¯ä»¥æ‹¥æœ‰Pï¼Œ Pä¸­çš„æ•°æ®éƒ½æ˜¯é”è‡ªç”±(lock free)çš„, è¯»å†™è¿™äº›æ•°æ®çš„æ•ˆç‡ä¼šéå¸¸çš„é«˜ã€‚</p>

<p>Pæ˜¯ä½¿Gèƒ½å¤Ÿåœ¨Mä¸­è¿è¡Œçš„å…³é”®ã€‚Goè¿è¡Œæ—¶ç³»ç»Ÿé€‚å½“åœ°è®©Pä¸ä¸åŒçš„Må»ºç«‹æˆ–è€…æ–­å¼€è”ç³»ï¼Œä»¥ä½¿å¾—Pä¸­çš„é‚£äº›å¯è¿è¡Œçš„Gèƒ½å¤Ÿåœ¨éœ€è¦çš„æ—¶å€™åŠæ—¶è·å¾—è¿è¡Œæ—¶æœºã€‚</p>

<p>Pçš„ç»“æ„ä½“å®šä¹‰ï¼š(åœ¨ ./src/runtime/runtime2.go æ–‡ä»¶ä¸­)</p>

<p>type p struct {
	lock mutex</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id          int32
status      uint32 // one of pidle/prunning/...
link        puintptr
schedtick   uint32     // incremented on every scheduler call
syscalltick uint32     // incremented on every system call
sysmontick  sysmontick // last tick observed by sysmon
m           muintptr   // back-link to associated m (nil if idle)
mcache      *mcache
racectx     uintptr
 
deferpool    [5][]*_defer // pool of available defer structs of different sizes (see panic.go)
deferpoolbuf [5][32]*_defer
 
// Cache of goroutine ids, amortizes accesses to runtimeÂ·sched.goidgen.
goidcache    uint64
goidcacheend uint64
 
// Queue of runnable goroutines. Accessed without lock.
runqhead uint32
runqtail uint32
runq     [256]guintptr
// runnext, if non-nil, is a runnable G that was ready'd by
// the current G and should be run next instead of what's in
// runq if there's time remaining in the running G's time
// slice. It will inherit the time left in the current time
// slice. If a set of goroutines is locked in a
// communicate-and-wait pattern, this schedules that set as a
// unit and eliminates the (potentially large) scheduling
// latency that otherwise arises from adding the ready'd
// goroutines to the end of the run queue.
runnext guintptr
 
// Available G's (status == Gdead)
gfree    *g
gfreecnt int32
 
sudogcache []*sudog
sudogbuf   [128]*sudog
 
tracebuf traceBufPtr
 
// traceSweep indicates the sweep events should be traced.
// This is used to defer the sweep start event until a span
// has actually been swept.
traceSweep bool
// traceSwept and traceReclaimed track the number of bytes
// swept and reclaimed by sweeping in the current sweep loop.
traceSwept, traceReclaimed uintptr
 
palloc persistentAlloc // per-P to avoid mutex
 
// Per-P GC state
gcAssistTime     int64 // Nanoseconds in assistAlloc
gcBgMarkWorker   guintptr
gcMarkWorkerMode gcMarkWorkerMode
 
// gcw is this P's GC work buffer cache. The work buffer is
// filled by write barriers, drained by mutator assists, and
// disposed on certain GC state transitions.
gcw gcWork
 
runSafePointFn uint32 // if 1, run sched.safePointFn at next safe point
 
pad [sys.CacheLineSize]byte } é€šè¿‡runtime.GOMAXPROCSå‡½æ•°æˆ‘ä»¬å¯ä»¥æ”¹å˜å•ä¸ªGoç¨‹åºå¯ä»¥é—´æ‹¥æœ‰çš„Pçš„æœ€å¤§æ•°é‡ã€‚
</code></pre></div></div>

<p>Pçš„æœ€å¤§æ•°é‡ç›¸å½“äºæ˜¯å¯¹å¯ä»¥è¢«å¹¶å‘æ‰§è¡Œçš„ç”¨æˆ·çº§çš„Gçš„æ•°é‡ä½œå‡ºé™åˆ¶ã€‚</p>

<p>æ¯ä¸€ä¸ªPéƒ½å¿…é¡»å…³è”ä¸€ä¸ªMæ‰èƒ½ä½¿å…¶ä¸­çš„Gå¾—ä»¥è¿è¡Œã€‚
ã€æ³¨æ„ã€‘ï¼šè¿è¡Œæ—¶ç³»ç»Ÿä¼šå°†Mä¸å…³è”çš„Påˆ†ç¦»å¼€æ¥ã€‚ä½†æ˜¯å¦‚æœè¯¥Pçš„å¯è¿è¡Œé˜Ÿåˆ—ä¸­è¿˜æœ‰æœªè¿è¡Œçš„Gï¼Œé‚£ä¹ˆè¿è¡Œæ—¶ç³»ç»Ÿå°±ä¼šæ‰¾åˆ°ä¸€ä¸ªç©ºçš„M ï¼ˆåœ¨è°ƒåº¦å™¨çš„ç©ºé—²é˜Ÿåˆ—ä¸­çš„Mï¼‰Â æˆ–è€…åˆ›å»ºä¸€ä¸ªç©ºçš„Mï¼Œå¹¶ä¸è¯¥På…³è”èµ·æ¥ï¼ˆä¸ºäº†è¿è¡ŒGè€Œåšå‡†å¤‡ï¼‰ã€‚</p>

<p>runtime.GOMAXPROCSå‡½æ•°è®¾ç½®çš„åªä¼šå½±å“Pçš„æ•°é‡ï¼Œä½†æ˜¯å¯¹M ï¼ˆå†…æ ¸çº¿ç¨‹ï¼‰çš„æ•°é‡ä¸ä¼šå½±å“ï¼Œæ‰€ä»¥runtime.GOMAXPROCS å¹¶ä¸æ˜¯æ§åˆ¶çº¿ç¨‹æ•°ï¼Œåªèƒ½è¯´æ˜¯å½±å“ä¸Šä¸‹æ–‡ç¯å¢ƒPçš„æ•°ç›®ã€‚</p>

<p>åœ¨Goç¨‹åºå¼€å§‹è¿è¡Œæ—¶ï¼Œä¼šå…ˆç”±å¼•å¯¼ç¨‹åºå¯¹Måšäº†æ•°é‡ä¸Šçš„é™åˆ¶ï¼ŒåŠå¯¹Påšäº†é™åˆ¶ï¼ŒPçš„æ•°é‡é»˜è®¤ä¸º1ã€‚æ‰€ä»¥æˆ‘ä»¬æ— è®ºåœ¨ç¨‹åºä¸­ä½¿ç”¨goå…³é”®å­—å¯ç”¨å¤šå°‘goroutineï¼Œå®ƒä»¬éƒ½ä¼šè¢«å¡åˆ°ä¸€ä¸ªPçš„å¯è¿è¡ŒGé˜Ÿåˆ—ä¸­ã€‚</p>

<p>åœ¨ç¡®è®¤Pçš„æœ€å¤§æ•°é‡åï¼Œè¿è¡Œæ—¶ç³»ç»Ÿä¼šæ ¹æ®è¿™ä¸ªæ•°å€¼åˆå§‹åŒ–å…¨å±€çš„Påˆ—è¡¨ ã€runtime.allpã€‘ï¼Œç±»ä¼¼å…¨å±€Måˆ—è¡¨ï¼Œå…¶ä¸­åŒ…å«äº†æ‰€æœ‰ è¿è¡Œæ—¶ç³»ç»Ÿåˆ›å»ºçš„æ‰€æœ‰Pã€‚éšåï¼Œè¿è¡Œæ—¶ç³»ç»Ÿä¼šæŠŠè°ƒåº¦å™¨çš„å¯è¿è¡ŒGé˜Ÿåˆ—ã€runtime.sched.runqã€‘ä¸­çš„æ‰€æœ‰Gå‡åŒ€çš„æ”¾å…¥å…¨å±€çš„Påˆ—è¡¨ä¸­çš„å„ä¸ªPçš„å¯æ‰§è¡ŒGé˜Ÿåˆ—å½“ä¸­ã€‚åˆ°è¿™é‡Œä¸ºæ­¢ï¼Œè¿è¡Œæ—¶ç³»ç»Ÿéœ€è¦ç”¨åˆ°çš„æ‰€æœ‰Péƒ½å‡†å¤‡å°±ç»ªäº†ã€‚</p>

<p>ç±»ä¼¼Mçš„ç©ºé—²åˆ—è¡¨ï¼Œè°ƒåº¦å™¨ä¹Ÿå­˜åœ¨ä¸€ä¸ªPçš„ç©ºé—²åˆ—è¡¨ã€runtime.sched.pidleã€‘ï¼Œå½“ä¸€ä¸ªPä¸å†ä¸ä»»ä½•Må…³è”çš„æ—¶å€™ï¼Œè¿è¡Œæ—¶ç³»ç»Ÿå°±ä¼šæŠŠè¯¥Pæ”¾å…¥è¿™ä¸ªåˆ—è¡¨ä¸­ï¼Œè€Œä¸€ä¸ªç©ºé—²çš„På…³è”äº†æŸä¸ªMä¹‹åä¼šè¢«ä»è¿™ä¸ªåˆ—è¡¨ä¸­å–å‡ºã€æ³¨æ„ï¼šå°±ç®—ä¸€ä¸ªPåŠ å…¥äº†ç©ºé—²é˜Ÿåˆ—ï¼Œä½†æ˜¯å®ƒçš„å¯è¿è¡ŒGé˜Ÿåˆ—ä¸ä¸€å®šä¸ºç©ºã€‘</p>

<p>å’ŒMä¸åŒPæ˜¯æœ‰çŠ¶æ€çš„ï¼šï¼ˆäº”ç§ï¼‰</p>

<p>Pidleï¼šå½“å‰Pæœªå’Œä»»ä½•Må…³è”</p>

<p>Prunningï¼šå½“å‰Pæ­£åœ¨å’ŒæŸä¸ªMå…³è”</p>

<p>Psyscallï¼šå½“å‰Pä¸­çš„è¢«è¿è¡Œçš„é‚£ä¸ªGæ­£åœ¨è¿›è¡Œç³»ç»Ÿè°ƒç”¨</p>

<p>Pgcstopï¼šè¿è¡Œæ—¶ç³»ç»Ÿæ­£åœ¨è¿›è¡Œgcã€‚ï¼ˆè¿è¡Œæ—¶ç³»ç»Ÿåœ¨gcæ—¶ä¼šè¯•å›¾æŠŠå…¨å±€Påˆ—è¡¨ä¸­çš„Péƒ½å¤„äºæ­¤çŠ¶æ€ï¼‰</p>

<p>Pdeadï¼šå½“å‰På·²ç»ä¸å†è¢«ä½¿ç”¨ã€‚ï¼ˆåœ¨è°ƒç”¨runtime.GOMAXPROCSå‡å°‘Pçš„æ•°é‡æ—¶ï¼Œå¤šä½™çš„På°±å¤„äºæ­¤çŠ¶æ€ï¼‰</p>

<p>Pçš„åˆå§‹çŠ¶æ€å°±æ˜¯ä¸ºPgcstopï¼Œå¤„äºè¿™ä¸ªçŠ¶æ€å¾ˆçŸ­æš‚ï¼Œåœ¨åˆå§‹åŒ–å’Œå¡«å……Pä¸­çš„Gé˜Ÿåˆ—ä¹‹åï¼Œè¿è¡Œæ—¶ç³»ç»Ÿä¼šå°†å…¶çŠ¶æ€ç½®ä¸ºPidleå¹¶æ”¾å…¥è°ƒåº¦å™¨çš„ç©ºé—²Påˆ—è¡¨ ï¼ˆruntime.sched.pidleï¼‰ä¸­ã€‚å…¶ä¸­çš„Pä¼šç”±è°ƒåº¦å™¨æ ¹æ®å®é™…æƒ…å†µè¿›è¡Œå–ç”¨ã€‚ä¸‹å›¾æ˜¯Påœ¨å„ä¸ªçŠ¶æ€å»ºçš„æµè½¬æƒ…å†µï¼š</p>

<p>ä»ä¸Šå›¾ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œé™¤äº†Pdeadä¹‹å¤–çš„å…¶ä»–çŠ¶æ€çš„Péƒ½ä¼šåœ¨è¿è¡Œæ—¶ç³»ç»Ÿæ¬²è¿›è¡ŒGCæ˜¯è¢«æŒ‡ä¸ºPgcstopã€‚åœ¨gcç»“æŸåçŠ¶æ€ä¸ä¼šå›å¤åˆ°ä¹‹å‰çš„çŠ¶æ€çš„ï¼Œè€Œæ˜¯éƒ½ç»Ÿä¸€ç›´æ¥è½¬åˆ°äº†Pidle ã€è¿™æ„å‘³ç€ï¼Œä»–ä»¬éƒ½éœ€è¦è¢«é‡æ–°è°ƒåº¦ã€‘ã€‚ã€æ³¨æ„ã€‘ï¼šé™¤äº†Pgcstop çŠ¶æ€çš„Pï¼Œå…¶ä»–çŠ¶æ€çš„Péƒ½ä¼šåœ¨ è°ƒç”¨runtime.GOMAXPROCS å‡½æ•°å»å‡å°‘Pæ•°ç›®æ—¶ï¼Œè¢«è®¤ä¸ºæ˜¯å¤šä½™çš„Pè€ŒçŠ¶æ€è½¬ä¸ºPdeadï¼Œè¿™æ—¶å€™å…¶å¸¦çš„å¯è¿è¡ŒGçš„é˜Ÿåˆ—ä¸­çš„Géƒ½ä¼šè¢«è½¬ç§»åˆ° è°ƒåº¦å™¨çš„å¯è¿è¡ŒGé˜Ÿåˆ—ä¸­ï¼Œå®ƒçš„è‡ªç”±Gé˜Ÿåˆ— ã€gfreeã€‘ä¹Ÿæ˜¯ä¸€æ ·è¢«ç§»åˆ°è°ƒåº¦å™¨çš„è‡ªç”±åˆ—è¡¨ ã€runtime.sched.gfreeã€‘ä¸­ã€‚</p>

<p>ã€æ³¨æ„ã€‘ï¼šæ¯ä¸ªPä¸­éƒ½æœ‰ä¸€ä¸ªå¯è¿è¡ŒGé˜Ÿåˆ—åŠè‡ªç”±Gé˜Ÿåˆ—ã€‚è‡ªç”±Gé˜Ÿåˆ—åŒ…å«äº†å¾ˆå¤šå·²ç»å®Œæˆçš„Gï¼Œéšç€è¢«è¿è¡Œå®Œæˆçš„Gçš„ç§¯æ”’åˆ°ä¸€å®šç¨‹åº¦åï¼Œè¿è¡Œæ—¶ç³»ç»Ÿä¼šæŠŠå…¶ä¸­çš„éƒ¨åˆ†Gè½¬ç§»çš„è°ƒåº¦å™¨çš„è‡ªç”±Gé˜Ÿåˆ— ã€runtime.sched.gfreeã€‘ä¸­ã€‚</p>

<p>ã€æ³¨æ„ã€‘ï¼šå½“æˆ‘ä»¬æ¯æ¬¡ç”¨ goå…³é”®å­— å¯ç”¨ä¸€ä¸ªGçš„æ—¶å€™ï¼Œè¿è¡Œæ—¶ç³»ç»Ÿéƒ½ä¼šå…ˆä»Pçš„è‡ªç”±Gé˜Ÿåˆ—è·å–ä¸€ä¸ªGæ¥å°è£…æˆ‘ä»¬æä¾›çš„å‡½æ•° (go å…³é”®å­—åé¢çš„å‡½æ•°) ï¼Œå¦‚æœå‘ç°Pä¸­çš„è‡ªç”±Gè¿‡å°‘æ—¶ï¼Œä¼šä»è°ƒåº¦å™¨çš„è‡ªç”±Gé˜Ÿåˆ—ä¸­ç§»ä¸€äº›Gè¿‡æ¥ï¼Œåªæœ‰è¿è°ƒåº¦å™¨çš„è‡ªç”±Gåˆ—è¡¨éƒ½å¼¹å°½ç²®ç»çš„æ—¶å€™ï¼Œæ‰ä¼šå»åˆ›å»ºæ–°çš„Gã€‚</p>

<p>G (goroutine)ï¼š
Gæ˜¯goroutineçš„å¤´æ–‡å­—, goroutineå¯ä»¥è§£é‡Šä¸ºå—ç®¡ç†çš„è½»é‡çº¿ç¨‹, goroutineä½¿ç”¨goå…³é”®è¯åˆ›å»ºã€‚</p>

<p>ä¸¾ä¾‹æ¥è¯´,Â Â func main() { go other() },Â  è¿™æ®µä»£ç åˆ›å»ºäº†ä¸¤ä¸ªgoroutineã€‚
ä¸€ä¸ªæ˜¯main, å¦ä¸€ä¸ªæ˜¯other, ã€æ³¨æ„ã€‘ï¼šmainæœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªgoroutineã€‚</p>

<p>goroutineçš„æ–°å»º, ä¼‘çœ , æ¢å¤, åœæ­¢éƒ½å—åˆ°goè¿è¡Œæ—¶çš„ç®¡ç†ã€‚
goroutineæ‰§è¡Œå¼‚æ­¥æ“ä½œæ—¶ä¼šè¿›å…¥ä¼‘çœ çŠ¶æ€, å¾…æ“ä½œå®Œæˆåå†æ¢å¤, æ— éœ€å ç”¨ç³»ç»Ÿçº¿ç¨‹ã€‚
goroutineæ–°å»ºæˆ–æ¢å¤æ—¶ä¼šæ·»åŠ åˆ°è¿è¡Œé˜Ÿåˆ—, ç­‰å¾…Må–å‡ºå¹¶è¿è¡Œã€‚</p>

<p>Gçš„ç»“æ„ä½“å®šä¹‰ï¼š(åœ¨ ./src/runtime/runtime2.go æ–‡ä»¶ä¸­)</p>

<p>type g struct {
	// Stack parameters.
	// stack describes the actual stack memory: [stack.lo, stack.hi).
	// stackguard0 is the stack pointer compared in the Go stack growth prologue.
	// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
	// stackguard1 is the stack pointer compared in the C stack growth prologue.
	// It is stack.lo+StackGuard on g0 and gsignal stacks.
	// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
	stack       stack   // offset known to runtime/cgo   æè¿°äº†çœŸå®çš„æ ˆå†…å­˜ï¼ŒåŒ…æ‹¬ä¸Šä¸‹ç•Œ
	stackguard0 uintptr // offset known to liblink
	stackguard1 uintptr // offset known to liblink</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_panic         *_panic // innermost panic - offset known to liblink
_defer         *_defer // innermost defer
m              *m      // current m; offset known to arm liblink   å½“å‰è¿è¡ŒGçš„M
sched          gobuf    //  goroutineåˆ‡æ¢æ—¶ï¼Œç”¨äºä¿å­˜gçš„ä¸Šä¸‹æ–‡
syscallsp      uintptr        // if status==Gsyscall, syscallsp = sched.sp to use during gc
syscallpc      uintptr        // if status==Gsyscall, syscallpc = sched.pc to use during gc
stktopsp       uintptr        // expected sp at top of stack, to check in traceback
param          unsafe.Pointer // passed parameter on wakeup   ç”¨äºä¼ é€’å‚æ•°ï¼Œç¡çœ æ—¶å…¶ä»–goroutineå¯ä»¥è®¾ç½®paramï¼Œå”¤é†’æ—¶è¯¥goroutineå¯ä»¥è·å–
atomicstatus   uint32
stackLock      uint32 // sigprof/scang lock; TODO: fold in to atomicstatus
goid           int64    // goroutineçš„ID
waitsince      int64  // approx time when the g become blocked   gè¢«é˜»å¡çš„å¤§ä½“æ—¶é—´
waitreason     string // if status==Gwaiting
schedlink      guintptr
preempt        bool     // preemption signal, duplicates stackguard0 = stackpreempt
paniconfault   bool     // panic (instead of crash) on unexpected fault address
preemptscan    bool     // preempted g does scan for gc
gcscandone     bool     // g has scanned stack; protected by _Gscan bit in status
gcscanvalid    bool     // false at start of gc cycle, true if G has not run since last scan; TODO: remove?
throwsplit     bool     // must not split stack
raceignore     int8     // ignore race detection events
sysblocktraced bool     // StartTrace has emitted EvGoInSyscall about this goroutine
sysexitticks   int64    // cputicks when syscall has returned (for tracing)
traceseq       uint64   // trace event sequencer
tracelastp     puintptr // last P emitted an event for this goroutine
lockedm        *m       // Gè¢«é”å®šåªåœ¨è¿™ä¸ªmä¸Šè¿è¡Œ
sig            uint32
writebuf       []byte
sigcode0       uintptr
sigcode1       uintptr
sigpc          uintptr
gopc           uintptr // pc of go statement that created this goroutine
startpc        uintptr // pc of goroutine function
racectx        uintptr
waiting        *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order
cgoCtxt        []uintptr      // cgo traceback context
labels         unsafe.Pointer // profiler labels
timer          *timer         // cached timer for time.Sleep
 
// Per-G GC state
 
// gcAssistBytes is this G's GC assist credit in terms of
// bytes allocated. If this is positive, then the G has credit
// to allocate gcAssistBytes bytes without assisting. If this
// is negative, then the G must correct this by performing
// scan work. We track this in bytes to make it fast to update
// and check for debt in the malloc hot path. The assist ratio
// determines how this corresponds to scan work debt.
gcAssistBytes int64 }
</code></pre></div></div>

<p>// ç”¨äºä¿å­˜Gåˆ‡æ¢æ—¶ä¸Šä¸‹æ–‡çš„ç¼“å­˜ç»“æ„ä½“
type gobuf struct {
	// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
	//
	// ctxt is unusual with respect to GC: it may be a
	// heap-allocated funcval so write require a write barrier,
	// but gobuf needs to be cleared from assembly. We take
	// advantage of the fact that the only path that uses a
	// non-nil ctxt is morestack. As a result, gogo is the only
	// place where it may not already be nil, so gogo uses an
	// explicit write barrier. Everywhere else that resets the
	// gobuf asserts that ctxt is already nil.
	sp   uintptr     // å½“å‰çš„æ ˆæŒ‡é’ˆ
	pc   uintptr     // è®¡æ•°å™¨
	g    guintptr    // gè‡ªèº«
	ctxt unsafe.Pointer // this has to be a pointer so that gc scans it
	ret  sys.Uintreg
	lr   uintptr
	bp   uintptr // for GOEXPERIMENT=framepointer
}
ä¸‹é¢æˆ‘ä»¬æ¥è®²è®²Gã€‚Goè¯­è¨€çš„ç¼–è¯‘å™¨ä¼šæŠŠæˆ‘ä»¬ç¼–å†™çš„goè¯­å¥ç¼–ç¨‹ä¸€ä¸ªè¿è¡Œæ—¶ç³»ç»Ÿçš„å‡½æ•°è°ƒç”¨ï¼Œå¹¶æŠŠgoè¯­å¥ä¸­é‚£ä¸ªå‡½æ•°åŠå…¶å‚æ•°éƒ½ä½œä¸ºå‚æ•°ä¼ é€’ç»™è¿™ä¸ªè¿è¡Œæ—¶ç³»ç»Ÿå‡½æ•°ä¸­ã€‚</p>

<p>è¿è¡Œæ—¶ç³»ç»Ÿåœ¨æ¥åˆ°è¿™æ ·ä¸€ä¸ªè°ƒç”¨åï¼Œä¼šå…ˆæ£€æŸ¥ä¸€ä¸‹goå‡½æ•°åŠå…¶å‚æ•°çš„åˆæ³•æ€§ï¼Œç´§æ¥ç€ä¼šè¯•å›¾ä»æœ¬åœ°Pçš„è‡ªç”±Gé˜Ÿåˆ—ä¸­(æˆ–è€…è°ƒåº¦å™¨çš„è‡ªç”±Gé˜Ÿåˆ—)ä¸­è·å–ä¸€ä¸ªå¯ç”¨çš„è‡ªç”±G ï¼ˆPä¸­æœ‰è®²è¿°äº†ï¼‰ï¼Œå¦‚æœæ²¡æœ‰åˆ™æ–°åˆ›å»ºä¸€ä¸ªGã€‚ç±»ä¼¼Må’ŒPï¼ŒGåœ¨è¿è¡Œæ—¶ç³»ç»Ÿä¸­ä¹Ÿæœ‰å…¨å±€çš„Gåˆ—è¡¨ã€runtime.allgã€‘ï¼Œé‚£äº›æ–°å»ºçš„Gä¼šå…ˆæ”¾åˆ°è¿™ä¸ªå…¨å±€çš„Gåˆ—è¡¨ä¸­ï¼Œå…¶åˆ—è¡¨çš„ä½œç”¨ä¹Ÿæ˜¯é›†ä¸­æ”¾ç½®äº†å½“å‰è¿è¡Œæ—¶ç³»ç»Ÿä¸­ç»™æ‰€æœ‰çš„Gçš„æŒ‡é’ˆã€‚åœ¨ç”¨è‡ªç”±Gå°è£…goçš„å‡½æ•°æ—¶ï¼Œè¿è¡Œæ—¶ç³»ç»Ÿéƒ½ä¼šå¯¹è¿™ä¸ªGåšä¸€æ¬¡åˆå§‹åŒ–ã€‚</p>

<p>åˆå§‹åŒ–ï¼šåŒ…å«äº†è¢«å…³è”çš„goå…³é”®å­—åçš„å‡½æ•°åŠå½“å‰Gçš„çŠ¶æ€æœºGçš„IDç­‰ç­‰ã€‚åœ¨Gè¢«åˆå§‹åŒ–å®Œæˆåå°±ä¼šè¢«æ”¾ç½®åˆ°å½“å‰æœ¬åœ°çš„Pçš„å¯è¿è¡Œé˜Ÿåˆ—ä¸­ã€‚åªè¦æ—¶æœºæˆç†Ÿï¼Œè°ƒåº¦å™¨ä¼šç«‹å³å°½å¿ƒè¿™ä¸ªGçš„è°ƒåº¦è¿è¡Œã€‚</p>

<p>Gçš„å„ç§çŠ¶æ€ï¼š</p>

<p>Gidleï¼šGè¢«åˆ›å»ºä½†è¿˜æœªå®Œå…¨è¢«åˆå§‹åŒ–ã€‚</p>

<p>Grunnableï¼šå½“å‰Gä¸ºå¯è¿è¡Œçš„ï¼Œæ­£åœ¨ç­‰å¾…è¢«è¿è¡Œã€‚</p>

<p>Grunningï¼šå½“å‰Gæ­£åœ¨è¢«è¿è¡Œã€‚</p>

<p>Gsyscallï¼šå½“å‰Gæ­£åœ¨è¢«ç³»ç»Ÿè°ƒç”¨</p>

<p>Gwaitingï¼šå½“å‰Gæ­£åœ¨å› æŸä¸ªåŸå› è€Œç­‰å¾…</p>

<p>Gdeadï¼šå½“å‰Gå®Œæˆäº†è¿è¡Œ</p>

<p>æ­£åœ¨è¢«åˆå§‹åŒ–è¿›è¡Œä¸­çš„Gæ˜¯å¤„äºGrunnableçŠ¶æ€çš„ã€‚ä¸€ä¸ªGçœŸæ­£è¢«ä½¿ç”¨æ˜¯åœ¨çŠ¶æ€ä¸ºGrunnableä¹‹åã€‚Gçš„ç”Ÿå‘½å‘¨æœŸåŠçŠ¶æ€å˜åŒ–å¦‚å›¾ï¼š</p>

<p>å›¾ä¸Šæœ‰ä¸€æ­¥æ˜¯äº‹ä»¶åˆ°æ¥ï¼Œé‚£ä¹ˆGåœ¨è¿è¡Œè¿‡ç¨‹ä¸­ï¼Œæ˜¯å¦ç­‰å¾…æŸä¸ªäº‹ä»¶ä»¥åŠç­‰å¾…ä»€ä¹ˆæ ·çš„äº‹ä»¶ï¼Ÿå®Œå…¨ç”±èµ·å°è£…çš„goå…³é”®å­—åçš„å‡½æ•°å†³å®šã€‚ï¼ˆå¦‚ï¼šç­‰å¾…chanä¸­çš„å€¼ã€æ¶‰åŠç½‘ç»œI/Oã€time.Timerã€time.Sleepç­‰ç­‰äº‹ä»¶ï¼‰</p>

<p>Gé€€å‡ºç³»ç»Ÿè°ƒç”¨ï¼ŒåŠå…¶å¤æ‚ï¼šè¿è¡Œæ—¶ç³»ç»Ÿå…ˆä¼šå°è¯•ç›´æ¥è¿è¡Œå½“å‰Gï¼Œä»…å½“æ— æ³•è¢«è¿è¡Œæ—¶æ‰ä¼šè½¬æˆGrunnableå¹¶æ”¾ç½®å…¥è°ƒåº¦å™¨çš„è‡ªç”±Gåˆ—è¡¨ä¸­ã€‚</p>

<p>æœ€åï¼Œå·²ç»æ˜¯GdeadçŠ¶æ€çš„Gæ˜¯å¯ä»¥è¢«é‡æ–°åˆå§‹åŒ–å¹¶ä½¿ç”¨çš„ã€‚è€Œå¯¹æ¯”è¿›å…¥PdeadçŠ¶æ€çš„Pç­‰å¾…çš„å‘½è¿åªæœ‰è¢«é”€æ¯ã€‚å¤„äºGdeadçš„Gä¼šè¢«æ”¾ç½®åˆ°æœ¬åœ°Pæˆ–è€…è°ƒåº¦å™¨çš„è‡ªç”±Gåˆ—è¡¨ä¸­ã€‚</p>

<p>è‡³æ­¤ï¼ŒGã€Mã€Pçš„åˆæ­¥æè¿°å·²ç»å®Œæ¯•ï¼Œä¸‹é¢æˆ‘ä»¬æ¥çœ‹ä¸€çœ‹ä¸€äº›æ ¸å¿ƒçš„é˜Ÿåˆ—ï¼š</p>

<p>Gã€Mã€Pçš„å®¹å™¨
ä¸­æ–‡å	æºç çš„åç§°	ä½œç”¨åŸŸ	ç®€è¦è¯´æ˜
å…¨å±€Måˆ—è¡¨	runtime.allm	è¿è¡Œæ—¶ç³»ç»Ÿ	å­˜æ”¾æ‰€æœ‰M
å…¨å±€Påˆ—è¡¨	runtime.allp	è¿è¡Œæ—¶ç³»ç»Ÿ	å­˜æ”¾æ‰€æœ‰P
å…¨å±€Gåˆ—è¡¨	runtime.allg	è¿è¡Œæ—¶ç³»ç»Ÿ	å­˜æ”¾æ‰€æœ‰G
è°ƒåº¦å™¨ä¸­çš„ç©ºé—²Måˆ—è¡¨	runtime.sched.midle	è°ƒåº¦å™¨	å­˜æ”¾ç©ºé—²M
è°ƒåº¦å™¨ä¸­çš„ç©ºé—²Påˆ—è¡¨	runtime.sched.pidle	è°ƒåº¦å™¨	å­˜æ”¾ç©ºé—²P
è°ƒåº¦å™¨ä¸­çš„å¯è¿è¡ŒGé˜Ÿåˆ—	runtime.sched.runq	è°ƒåº¦å™¨	å­˜æ”¾å¯è¿è¡ŒG
è°ƒåº¦å™¨ä¸­é‚£ä¸ªçš„è‡ªç”±Gåˆ—è¡¨	runtime.sched.gfree	è°ƒåº¦å™¨	å­˜æ”¾è‡ªç”±G
Pçš„å¯è¿è¡ŒGé˜Ÿåˆ—	runq	æœ¬åœ°P	å­˜æ”¾å½“å‰Pä¸­çš„å¯è¿è¡ŒG
Pä¸­çš„è‡ªç”±Gåˆ—è¡¨	gfree	æœ¬åœ°P	å­˜æ”¾å½“å‰Pä¸­çš„è‡ªç”±G
Â ä¸‰ä¸ªå…¨å±€çš„åˆ—è¡¨ä¸»è¦ä¸ºäº†ç»Ÿè®¡è¿è¡Œæ—¶ç³»ç»Ÿçš„çš„æ‰€æœ‰Gã€Mã€Pã€‚æˆ‘ä»¬ä¸»è¦å…³å¿ƒå‰©ä¸‹çš„è¿™äº›å®¹å™¨ï¼Œå°¤å…¶æ˜¯å’ŒGç›¸å…³çš„å››ä¸ªã€‚
åœ¨è¿è¡Œæ—¶ç³»ç»Ÿåˆ›å»ºçš„Géƒ½ä¼šè¢«ä¿å­˜åœ¨å…¨å±€çš„Gåˆ—è¡¨ä¸­ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼šä»Gsyscallè½¬å‡ºæ¥çš„Gï¼Œéƒ½ä¼šè¢«æ”¾ç½®åˆ°è°ƒåº¦å™¨çš„å¯è¿è¡ŒGé˜Ÿåˆ—ä¸­ã€‚è€Œè¢«è¿è¡Œæ—¶ç³»ç»Ÿåˆå§‹åŒ–çš„Gä¼šè¢«æ”¾ç½®åˆ°æœ¬åœ°Pçš„å¯è¿è¡Œåˆ—è¡¨ä¸­ã€‚ä»Gwaitingè½¬å‡ºæ¥çš„Gï¼Œé™¤äº†å› ç½‘ç»œI/Oé™·å…¥ç­‰å¾…çš„Gä¹‹å¤–ï¼Œéƒ½ä¼šè¢«æ”¾ç½®åˆ°æœ¬åœ°Pçš„å¯è¿è¡ŒGé˜Ÿåˆ—ä¸­ã€‚è½¬æˆGdeadçŠ¶æ€çš„Gä¼šå…ˆè¢«æ”¾ç½®åˆ°æœ¬åœ°Pçš„è‡ªç”±Gåˆ—è¡¨ ï¼ˆä¸Šé¢çš„æè¿°å¯ä»¥çŸ¥é“è¿™ä¸€ç‚¹ï¼‰ã€‚è°ƒåº¦å™¨ä¸­çš„ä¸Gã€Mã€Pç›¸å…³çš„åˆ—è¡¨å…¶å®åªæ˜¯èµ·äº†ä¸€ä¸ªæš‚å­˜çš„ä½œç”¨ã€‚</p>

<p>ä¸€å¥è¯æ¦‚æ‹¬ä¸‰è€…å…³ç³»ï¼š</p>

<p>Géœ€è¦ç»‘å®šåœ¨Mä¸Šæ‰èƒ½è¿è¡Œï¼›
Méœ€è¦ç»‘å®šPæ‰èƒ½è¿è¡Œï¼›
ä¸‹é¢æˆ‘ä»¬çœ‹ä¸€çœ‹ä¸‰è€…åŠå†…æ ¸è°ƒåº¦å®ä½“ã€KSEã€‘çš„å…³ç³»ï¼š</p>

<p>Â </p>

<p>ç»¼ä¸Šæ‰€è¿°ï¼Œä¸€ä¸ªGçš„æ‰§è¡Œéœ€è¦Må’ŒPçš„æ”¯æŒã€‚ä¸€ä¸ªMåœ¨äºä¸€ä¸ªPå…³è”ä¹‹åå°±å½¢æˆä¸€ä¸ªæœ‰æ•ˆçš„Gè¿è¡Œç¯å¢ƒ ã€å†…æ ¸çº¿ç¨‹ +Â  ä¸Šä¸‹æ–‡ç¯å¢ƒã€‘ã€‚æ¯ä¸ªPéƒ½å«æœ‰ä¸€ä¸ª å¯è¿è¡ŒGçš„é˜Ÿåˆ—ã€runqã€‘ã€‚é˜Ÿåˆ—ä¸­çš„Gä¼šè¢«ä¸€æ¬¡ä¼ é€’ç»™æœ¬åœ°På…³è”çš„Må¹¶ä¸”è·å¾—è¿è¡Œæ—¶æœºã€‚</p>

<p>ç”±ä¸Šå›¾å¯ä»¥çœ‹å‡º M ä¸ KSE æ€»æ˜¯ ä¸€å¯¹ä¸€ çš„ã€‚ä¸€ä¸ªMèƒ½ä¸”ä»…èƒ½ä»£è¡¨ä¸€ä¸ªå†…æ ¸çº¿ç¨‹ã€‚</p>

<p>ä¸€ä¸ªMçš„ç”Ÿå‘½å‘¨æœŸå†…ï¼Œå®ƒä¼šä¸”ä»…ä¼šä¸ä¸€ä¸ªKSEäº§ç”Ÿå…³è”ã€‚Mä¸Pä»¥åŠPä¸Gä¹‹é—´çš„å…³è”æ˜¯å¤šå˜çš„ï¼Œæ€»æ˜¯ä¼šéšç€å®é™…è°ƒåº¦çš„è¿‡ç¨‹è€Œæ”¹å˜ã€‚å…¶ä¸­ï¼Œ M ä¸ P æ€»æ˜¯ä¸€å¯¹ä¸€ï¼ŒP ä¸ G æ€»æ˜¯ ä¸€å¯¹å¤šï¼Œ è€Œ ä¸€ä¸ª G æœ€ç»ˆç”± ä¸€ä¸ª M æ¥è´Ÿè´£è¿è¡Œã€‚</p>

<p>ä¸Šè¿°æˆ‘ä»¬è®²çš„è¿è¡Œæ—¶ç³»ç»Ÿå…¶å®å°±æ˜¯æˆ‘ä»¬ä¸‹é¢è¦è¯´çš„è°ƒåº¦å™¨ã€‚
æˆ‘ä»¬å†æ¥å›é¡¾ä¸‹Gã€Mã€P ä¸­çš„ä¸»è¦æˆå‘˜ï¼š</p>

<p>Gé‡Œé¢æ¯”è¾ƒé‡è¦çš„æˆå‘˜ï¼š
stack: å½“å‰gä½¿ç”¨çš„æ ˆç©ºé—´, æœ‰loå’Œhiä¸¤ä¸ªæˆå‘˜
stackguard0: æ£€æŸ¥æ ˆç©ºé—´æ˜¯å¦è¶³å¤Ÿçš„å€¼, ä½äºè¿™ä¸ªå€¼ä¼šæ‰©å¼ æ ˆ, 0æ˜¯goä»£ç ä½¿ç”¨çš„
stackguard1: æ£€æŸ¥æ ˆç©ºé—´æ˜¯å¦è¶³å¤Ÿçš„å€¼, ä½äºè¿™ä¸ªå€¼ä¼šæ‰©å¼ æ ˆ, 1æ˜¯åŸç”Ÿä»£ç ä½¿ç”¨çš„
m: å½“å‰gå¯¹åº”çš„m
sched: gçš„è°ƒåº¦æ•°æ®, å½“gä¸­æ–­æ—¶ä¼šä¿å­˜å½“å‰çš„pcå’Œrspç­‰å€¼åˆ°è¿™é‡Œ, æ¢å¤è¿è¡Œæ—¶ä¼šä½¿ç”¨è¿™é‡Œçš„å€¼
atomicstatus: gçš„å½“å‰çŠ¶æ€
schedlink: ä¸‹ä¸€ä¸ªg, å½“gåœ¨é“¾è¡¨ç»“æ„ä¸­ä¼šä½¿ç”¨
preempt: gæ˜¯å¦è¢«æŠ¢å ä¸­
lockedm: gæ˜¯å¦è¦æ±‚è¦å›åˆ°è¿™ä¸ªMæ‰§è¡Œ, æœ‰çš„æ—¶å€™gä¸­æ–­äº†æ¢å¤ä¼šè¦æ±‚ä½¿ç”¨åŸæ¥çš„Mæ‰§è¡Œ
Mé‡Œé¢æ¯”è¾ƒé‡è¦çš„æˆå‘˜ï¼š
g0: ç”¨äºè°ƒåº¦çš„ç‰¹æ®Šg, è°ƒåº¦å’Œæ‰§è¡Œç³»ç»Ÿè°ƒç”¨æ—¶ä¼šåˆ‡æ¢åˆ°è¿™ä¸ªg
curg: å½“å‰è¿è¡Œçš„g
p: å½“å‰æ‹¥æœ‰çš„P
nextp: å”¤é†’Mæ—¶, Mä¼šæ‹¥æœ‰è¿™ä¸ªP
park: Mä¼‘çœ æ—¶ä½¿ç”¨çš„ä¿¡å·é‡, å”¤é†’Mæ—¶ä¼šé€šè¿‡å®ƒå”¤é†’
schedlink: ä¸‹ä¸€ä¸ªm, å½“måœ¨é“¾è¡¨ç»“æ„ä¸­ä¼šä½¿ç”¨
mcache: åˆ†é…å†…å­˜æ—¶ä½¿ç”¨çš„æœ¬åœ°åˆ†é…å™¨, å’Œp.mcacheä¸€æ ·(æ‹¥æœ‰Pæ—¶ä¼šå¤åˆ¶è¿‡æ¥)
lockedg: lockedmçš„å¯¹åº”å€¼
Pé‡Œé¢æ¯”è¾ƒé‡è¦çš„æˆå‘˜ï¼š
status: pçš„å½“å‰çŠ¶æ€
link: ä¸‹ä¸€ä¸ªp, å½“påœ¨é“¾è¡¨ç»“æ„ä¸­ä¼šä½¿ç”¨
m: æ‹¥æœ‰è¿™ä¸ªPçš„M
mcache: åˆ†é…å†…å­˜æ—¶ä½¿ç”¨çš„æœ¬åœ°åˆ†é…å™¨
runqhead: æœ¬åœ°è¿è¡Œé˜Ÿåˆ—çš„å‡ºé˜Ÿåºå·
runqtail: æœ¬åœ°è¿è¡Œé˜Ÿåˆ—çš„å…¥é˜Ÿåºå·
runq: æœ¬åœ°è¿è¡Œé˜Ÿåˆ—çš„æ•°ç»„, å¯ä»¥ä¿å­˜256ä¸ªG
gfree: Gçš„è‡ªç”±åˆ—è¡¨, ä¿å­˜å˜ä¸º_Gdeadåå¯ä»¥å¤ç”¨çš„Gå®ä¾‹
gcBgMarkWorker: åå°GCçš„workerå‡½æ•°, å¦‚æœå®ƒå­˜åœ¨Mä¼šä¼˜å…ˆæ‰§è¡Œå®ƒ
gcw: GCçš„æœ¬åœ°å·¥ä½œé˜Ÿåˆ—, è¯¦ç»†å°†åœ¨ä¸‹ä¸€ç¯‡(GCç¯‡)åˆ†æ
è°ƒåº¦å™¨æ¶‰åŠåˆ°çš„ç»“æ„ä½“é™¤äº†ä¸Šé¢çš„Gã€Mã€P ä¹‹å¤–ï¼Œè¿˜æœ‰ä»¥ä¸‹ï¼Œæ¯”å¦‚å…¨å±€çš„è°ƒåº¦å™¨ï¼š</p>

<p>type schedt struct {
	// accessed atomically. keep at top to ensure alignment on 32-bit systems.
     // ä¸‹é¢ä¸¤ä¸ªå˜é‡éœ€ä»¥åŸå­è®¿é—®è®¿é—®ã€‚ä¿æŒåœ¨ struct é¡¶éƒ¨ï¼Œç¡®ä¿å…¶åœ¨ 32 ä½ç³»ç»Ÿä¸Šå¯ä»¥å¯¹é½
	goidgen  uint64
	lastpoll uint64</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lock mutex

// å½“ä¿®æ”¹ nmidleï¼Œnmidlelockedï¼Œnmsysï¼Œnmfreed è¿™äº›æ•°å€¼æ—¶
// éœ€è¦è®°å¾—è°ƒç”¨ checkdead
 
midle        muintptr // idle m's waiting for work   ç©ºé—²çš„M é˜Ÿåˆ—ã€‚
nmidle       int32    // number of idle m's waiting for work  å½“å‰ç­‰å¾…å·¥ä½œçš„ç©ºé—² m è®¡æ•°
nmidlelocked int32    // number of locked m's waiting for work  å½“å‰ç­‰å¾…å·¥ä½œçš„è¢« lock çš„ m è®¡æ•°
mcount       int32    // number of m's that have been created  å·²ç»åˆ›å»ºçš„ m æ•°é‡
maxmcount    int32    // maximum number of m's allowed (or die)   å…è®¸åˆ›å»ºçš„æœ€å¤§çš„ m æ•°é‡
 
ngsys uint32 // number of system goroutines; updated atomically  ç³»ç»Ÿ goroutine çš„æ•°é‡ï¼Œ åŸå­æ“ä½œ
 
pidle      puintptr // idle p's   ç©ºé—²çš„ p é˜Ÿåˆ—
npidle     uint32
nmspinning uint32 // See "Worker thread parking/unparking" comment in proc.go.
 
// Global runnable queue.
 // å…¨å±€çš„å¯è¿è¡Œ g é˜Ÿåˆ—
runqhead guintptr       // é˜Ÿå¤´åœ°å€
runqtail guintptr       // é˜Ÿå°¾åœ°å€ 
runqsize int32          // é˜Ÿåˆ—å®½åº¦  
 
// Global cache of dead G's.
// dead G çš„å…¨å±€ç¼“
gflock       mutex
gfreeStack   *g        // æ ˆä¸­è‡ªç”±g ï¼Ÿ
gfreeNoStack *g        // å †ä¸­è‡ªç”±g ï¼Ÿ   
ngfree       int32
 
// Central cache of sudog structs.
// sudog ç»“æ„çš„é›†ä¸­ç¼“å­˜
sudoglock  mutex
sudogcache *sudog
 
// Central pool of available defer structs of different sizes.
// ä¸åŒå¤§å°çš„å¯ç”¨çš„ defer struct çš„é›†ä¸­ç¼“å­˜æ± 
deferlock mutex
deferpool [5]*_defer
 
gcwaiting  uint32 // gc is waiting to run  gc ç­‰å¾…è¿è¡ŒçŠ¶æ€ã€‚ ä½œä¸ºgcä»»åŠ¡è¢«æ‰§è¡ŒæœŸé—´çš„è¾…åŠ©æ ‡è®°ã€åœæ­¢è®¡æ•°å’Œé€šçŸ¥æœºåˆ¶
stopwait   int32
stopnote   note
sysmonwait uint32  // ä½œä¸º ç³»ç»Ÿæ£€æµ‹ä»»åŠ¡è¢«æ‰§è¡ŒæœŸé—´çš„åœæ­¢è®¡æ•°å’Œé€šçŸ¥æœºåˆ¶
sysmonnote note
 
// safepointFn should be called on each P at the next GC
// safepoint if p.runSafePointFn is set.
// åº”åœ¨ä¸‹ä¸€ä¸ªGCä¸Šçš„æ¯ä¸ªPä¸Šè°ƒç”¨safepointFn
// å¦‚æœè®¾ç½®äº†p.runSafePointFnï¼Œåˆ™ä¸ºsafepointã€‚
safePointFn   func(*p)
safePointWait int32
safePointNote note
 
profilehz int32 // cpu profiling rate   CPUåˆ†æç‡
 
procresizetime int64 // nanotime() of last change to gomaxprocs   ä¸Šæ¬¡ä¿®æ”¹ gomaxprocs çš„çº³ç§’æ—¶é—´
totaltime      int64 // âˆ«gomaxprocs dt up to procresizetime } å…¨å±€è°ƒåº¦å™¨ï¼Œå…¨å±€åªæœ‰ä¸€ä¸ªschedtç±»å‹çš„å®ä¾‹ã€‚
</code></pre></div></div>

<p>sudoG ç»“æ„ä½“ï¼š</p>

<p>// sudog ä»£è¡¨åœ¨ç­‰å¾…åˆ—è¡¨é‡Œçš„ gï¼Œæ¯”å¦‚å‘ channel å‘é€/æ¥æ”¶å†…å®¹æ—¶
// ä¹‹æ‰€ä»¥éœ€è¦ sudog æ˜¯å› ä¸º g å’ŒåŒæ­¥å¯¹è±¡ä¹‹é—´çš„å…³ç³»æ˜¯å¤šå¯¹å¤šçš„
// ä¸€ä¸ª g å¯èƒ½ä¼šåœ¨å¤šä¸ªç­‰å¾…é˜Ÿåˆ—ä¸­ï¼Œæ‰€ä»¥ä¸€ä¸ª g å¯èƒ½è¢«æ‰“åŒ…ä¸ºå¤šä¸ª sudog
// å¤šä¸ª g ä¹Ÿå¯ä»¥ç­‰å¾…åœ¨åŒä¸€ä¸ªåŒæ­¥å¯¹è±¡ä¸Š
// å› æ­¤å¯¹äºä¸€ä¸ªåŒæ­¥å¯¹è±¡å°±ä¼šæœ‰å¾ˆå¤š sudog äº†
// sudog æ˜¯ä»ä¸€ä¸ªç‰¹æ®Šçš„æ± ä¸­è¿›è¡Œåˆ†é…çš„ã€‚ç”¨ acquireSudog å’Œ releaseSudog æ¥åˆ†é…å’Œé‡Šæ”¾ sudog</p>

<p>type sudog struct {
	// The following fields are protected by the hchan.lock of the
	// channel this sudog is blocking on. shrinkstack depends on
	// this for sudogs involved in channel ops.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g          *g
selectdone *uint32 // CAS to 1 to win select race (may point to stack)
next       *sudog
prev       *sudog
elem       unsafe.Pointer // data element (may point to stack)
 
// The following fields are never accessed concurrently.
// For channels, waitlink is only accessed by g.
// For semaphores, all fields (including the ones above)
// are only accessed when holding a semaRoot lock.
 
acquiretime int64
releasetime int64
ticket      uint32
parent      *sudog // semaRoot binary tree
waitlink    *sudog // g.waiting list or semaRoot
waittail    *sudog // semaRoot
c           *hchan // channel } Â 
</code></pre></div></div>

<p>é‚£ä¹ˆgoroutineçš„å…¥å£æ˜¯æ€ä¹ˆæ ·çš„å‘¢ï¼Ÿé¦–å…ˆï¼Œæˆ‘ä»¬ä»goroutineæ˜¯å¦‚ä½•è¢«åˆ›å»ºçš„è¯´èµ·ï¼Œåˆ›å»ºgoroutineçš„å‡½æ•°ä¸ºï¼šnewproc å‡½æ•° (åœ¨Â ./src/runtime/proc.go æ–‡ä»¶ä¸­)ï¼Œå³ï¼šä½¿ç”¨goå‘½ä»¤åˆ›å»ºgoroutineæ—¶, goä¼šæŠŠgoå‘½ä»¤ç¼–è¯‘ä¸ºå¯¹runtime.newprocçš„è°ƒç”¨ã€‚</p>

<p>// Create a new g running fn with siz bytes of arguments.
// Put it on the queue of gâ€™s waiting to run.
// The compiler turns a go statement into a call to this.
// Cannot split the stack because it assumes that the arguments
// are available sequentially after &amp;fn; they would not be
// copied if a stack split occurred.</p>

<p>// æ ¹æ® å‚æ•° fn å’Œ siz åˆ›å»ºä¸€ä¸ª g
// å¹¶æŠŠå®ƒæ”¾ç½®å…¥ è‡ªç”±gé˜Ÿåˆ—ä¸­ç­‰å¾…å”¤é†’
// ç¼–è¯‘å™¨ç¿»è¯‘ä¸€ä¸ª go è¡¨è¾¾å¼æ—¶ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°
// æ— æ³•æ‹†åˆ†å †æ ˆï¼Œå› ä¸ºå®ƒå‡è®¾å‚æ•°åœ¨ &amp;fn ä¹‹åé¡ºåºå¯ç”¨; å¦‚æœå‘ç”Ÿå †æ ˆæ‹†åˆ†ï¼Œåˆ™ä¸ä¼šå¤åˆ¶å®ƒä»¬ã€‚</p>

<p>//    æ–°å»ºä¸€ä¸ªgoroutineï¼Œ
//    ç”¨fn + PtrSize è·å–ç¬¬ä¸€ä¸ªå‚æ•°çš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯argp
//    ç”¨siz - 8 è·å–pcåœ°å€</p>

<p>//go:nosplit
func newproc(siz int32, fn *funcval) {
    // add æ˜¯ä¸€ä¸ªæŒ‡é’ˆè¿ç®—ï¼Œè·³è¿‡å‡½æ•°æŒ‡é’ˆ
    // æŠŠæ ˆä¸Šçš„å‚æ•°èµ·å§‹åœ°å€æ‰¾åˆ°
	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// getcallerpcè¿”å›çš„æ˜¯ è°ƒç”¨å‡½æ•°ä¹‹åçš„é‚£æ¡ç¨‹åºæŒ‡ä»¤çš„åœ°å€ï¼Œ
// å³calleeå‡½æ•°è¿”å›æ—¶è¦æ‰§è¡Œçš„ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€
pc := getcallerpc(unsafe.Pointer(&amp;siz))

// ç”¨g0çš„æ ˆåˆ›å»ºGå¯¹è±¡
systemstack(func() {
	newproc1(fn, (*uint8)(argp), siz, 0, pc)
}) }
</code></pre></div></div>

<p>// ç»“æ„ä½“ funcval
// funcval æ˜¯ä¸€ä¸ªå˜é•¿ç»“æ„ï¼Œç¬¬ä¸€ä¸ªæˆå‘˜æ˜¯å‡½æ•°æŒ‡é’ˆ
// æ‰€ä»¥ä¸Šé¢çš„ add æ˜¯è·³è¿‡è¿™ä¸ª fn
type funcval struct {
	fn uintptr
	// variable-size, fn-specific data here   è¿™é‡Œçš„å¯å˜å¤§å°ï¼Œç‰¹å®šäºfnçš„æ•°æ®
}
runtime.newprocå‡½æ•°ä¸­åªåšäº†ä¸‰ä»¶äº‹ï¼š</p>

<p>è®¡ç®—é¢å¤–å‚æ•°çš„åœ°å€ argp
è·å–è°ƒç”¨ç«¯çš„åœ°å€(è¿”å›åœ°å€)Â pc
ä½¿ç”¨systemstackè°ƒç”¨ newproc1 å‡½æ•°
systemstackÂ ä¼šåˆ‡æ¢å½“å‰çš„ g åˆ° g0, å¹¶ä¸”ä½¿ç”¨g0çš„æ ˆç©ºé—´, ç„¶åè°ƒç”¨ä¼ å…¥çš„å‡½æ•°, å†åˆ‡æ¢å›åŸæ¥çš„gå’ŒåŸæ¥çš„æ ˆç©ºé—´ã€‚
åˆ‡æ¢åˆ°g0åä¼šå‡è£…è¿”å›åœ°å€æ˜¯mstart, è¿™æ ·tracebackçš„æ—¶å€™å¯ä»¥åœ¨mstartåœæ­¢ã€‚
è¿™é‡Œä¼ ç»™systemstackçš„æ˜¯ä¸€ä¸ªé—­åŒ…, è°ƒç”¨æ—¶ä¼šæŠŠé—­åŒ…çš„åœ°å€æ”¾åˆ°å¯„å­˜å™¨rdx, å…·ä½“å¯ä»¥å‚è€ƒä¸Šé¢å¯¹é—­åŒ…çš„åˆ†æã€‚</p>

<p>ä¸‹é¢æˆ‘ä»¬åœ¨ä¸»è¦æ¥çœ‹çœ‹Â  newproc1 å‡½æ•°åšäº†ä»€ä¹ˆï¼š</p>

<p>// Create a new g running fn with narg bytes of arguments starting
// at argp and returning nret bytes of results.  callerpc is the
// address of the go statement that created this. The new g is put
// on the queue of gâ€™s waiting to run.</p>

<p>// æ ¹æ®å‡½æ•°å‚æ•°å’Œå‡½æ•°åœ°å€ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„Gï¼Œç„¶åå°†è¿™ä¸ªGåŠ å…¥é˜Ÿåˆ—ç­‰å¾…è¿è¡Œ
func newproc1(fn *funcval, argp *uint8, narg int32, nret int32, callerpc uintptr) *g {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å…ˆè·å– å½“å‰ gï¼Œå…¶å®è¿™é‡Œè·å–åˆ°çš„æ˜¯ g0
_g_ := getg()

// åˆ¤æ–­ä¸‹ func çš„å®ç°æ˜¯å¦ä¸ºç©º
if fn == nil {
	_g_.m.throwing = -1 // do not dump full stacks
	throw("go of nil func value")
}

// è®¾ç½®gå¯¹åº”çš„mçš„locks++, ç¦æ­¢æŠ¢å 
_g_.m.locks++ // disable preemption because it can be holding p in a local var   ç¦ç”¨æŠ¢å ï¼Œå› ä¸ºå®ƒå¯ä»¥åœ¨æœ¬åœ°varä¸­ä¿å­˜p
siz := narg + nret
siz = (siz + 7) &amp;^ 7
 
// We could allocate a larger initial stack if necessary.
// Not worth it: this is almost always an error.
// 4*sizeof(uintreg): extra space added below
// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).
if siz &gt;= _StackMin-4*sys.RegSize-sys.RegSize {
	throw("newproc: function arguments too large for new goroutine")
}
 
_p_ := _g_.m.p.ptr()
newg := gfget(_p_)
if newg == nil {
	newg = malg(_StackMin)
	casgstatus(newg, _Gidle, _Gdead)
	allgadd(newg) // publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.
}
if newg.stack.hi == 0 {
	throw("newproc1: newg missing stack")
}
 
if readgstatus(newg) != _Gdead {
	throw("newproc1: new g is not Gdead")
}
 
totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame
totalSize += -totalSize &amp; (sys.SpAlign - 1)                  // align to spAlign
sp := newg.stack.hi - totalSize
spArg := sp
if usesLR {
	// caller's LR
	*(*uintptr)(unsafe.Pointer(sp)) = 0
	prepGoExitFrame(sp)
	spArg += sys.MinFrameSize
}
if narg &gt; 0 {
	memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg))
	// This is a stack-to-stack copy. If write barriers
	// are enabled and the source stack is grey (the
	// destination is always black), then perform a
	// barrier copy. We do this *after* the memmove
	// because the destination stack may have garbage on
	// it.
	if writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone {
		f := findfunc(fn.fn)
		stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))
		// We're in the prologue, so it's always stack map index 0.
		bv := stackmapdata(stkmap, 0)
		bulkBarrierBitmap(spArg, spArg, uintptr(narg), 0, bv.bytedata)
	}
}
 
memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))
newg.sched.sp = sp
newg.stktopsp = sp
newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function
newg.sched.g = guintptr(unsafe.Pointer(newg))
gostartcallfn(&amp;newg.sched, fn)
newg.gopc = callerpc
newg.startpc = fn.fn
if _g_.m.curg != nil {
	newg.labels = _g_.m.curg.labels
}
if isSystemGoroutine(newg) {
	atomic.Xadd(&amp;sched.ngsys, +1)
}
newg.gcscanvalid = false
casgstatus(newg, _Gdead, _Grunnable)
 
if _p_.goidcache == _p_.goidcacheend {
	// Sched.goidgen is the last allocated id,
	// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
	// At startup sched.goidgen=0, so main goroutine receives goid=1.
	_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)
	_p_.goidcache -= _GoidCacheBatch - 1
	_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch
}
newg.goid = int64(_p_.goidcache)
_p_.goidcache++
if raceenabled {
	newg.racectx = racegostart(callerpc)
}
if trace.enabled {
	traceGoCreate(newg, newg.startpc)
}
runqput(_p_, newg, true)
 
if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 &amp;&amp; mainStarted {
	wakep()
}
_g_.m.locks--
if _g_.m.locks == 0 &amp;&amp; _g_.preempt { // restore the preemption request in case we've cleared it in newstack
	_g_.stackguard0 = stackPreempt
}
return newg } å…ˆå¤§è‡´çœ‹ä¸‹newproc1 å‡½æ•°é€»è¾‘æµç¨‹ï¼š
</code></pre></div></div>

<p>newproc1 â€“&gt; newg
newg[gfget] â€“&gt; nil{is nil?}
nil â€“&gt;|yes|E[init stack]
nil â€“&gt;|no|C[malg]
C â€“&gt; D[set g status=&gt; idle-&gt;dead]
D â€“&gt; allgadd
E â€“&gt; G[set g status=&gt; dead-&gt; runnable]
allgadd â€“&gt; G
G â€“&gt; runqput
runtime.newproc1çš„å¤„ç†å¦‚ä¸‹:</p>

<p>è°ƒç”¨getgè·å–å½“å‰çš„g, ä¼šç¼–è¯‘ä¸ºè¯»å–FSå¯„å­˜å™¨(TLS), è¿™é‡Œä¼šè·å–åˆ°g0
è®¾ç½®gå¯¹åº”çš„mçš„locks++, ç¦æ­¢æŠ¢å 
è·å–mæ‹¥æœ‰çš„p
æ–°å»ºä¸€ä¸ªg
é¦–å…ˆè°ƒç”¨gfgetä»p.gfreeè·å–g, å¦‚æœä¹‹å‰æœ‰gè¢«å›æ”¶åœ¨è¿™é‡Œå°±å¯ä»¥å¤ç”¨
è·å–ä¸åˆ°æ—¶è°ƒç”¨malgåˆ†é…ä¸€ä¸ªg, åˆå§‹çš„æ ˆç©ºé—´å¤§å°æ˜¯2K
éœ€è¦å…ˆè®¾ç½®gçš„çŠ¶æ€ä¸ºå·²ä¸­æ­¢(_Gdead), è¿™æ ·gcä¸ä¼šå»æ‰«æè¿™ä¸ªgçš„æœªåˆå§‹åŒ–çš„æ ˆ
æŠŠå‚æ•°å¤åˆ¶åˆ°gçš„æ ˆä¸Š
æŠŠè¿”å›åœ°å€å¤åˆ¶åˆ°gçš„æ ˆä¸Š, è¿™é‡Œçš„è¿”å›åœ°å€æ˜¯goexit, è¡¨ç¤ºè°ƒç”¨å®Œç›®æ ‡å‡½æ•°åä¼šè°ƒç”¨goexit
è®¾ç½®gçš„è°ƒåº¦æ•°æ®(sched)
è®¾ç½®sched.spç­‰äºå‚æ•°+è¿”å›åœ°å€åçš„rspåœ°å€
è®¾ç½®sched.pcç­‰äºç›®æ ‡å‡½æ•°çš„åœ°å€, æŸ¥çœ‹gostartcallfnå’Œgostartcall
è®¾ç½®sched.gç­‰äºg
è®¾ç½®gçš„çŠ¶æ€ä¸ºå¾…è¿è¡Œ(_Grunnable)
è°ƒç”¨runqputæŠŠgæ”¾åˆ°è¿è¡Œé˜Ÿåˆ—
é¦–å…ˆéšæœºæŠŠgæ”¾åˆ°p.runnext, å¦‚æœæ”¾åˆ°runnextåˆ™å…¥é˜ŸåŸæ¥åœ¨runnextçš„g
ç„¶åå°è¯•æŠŠgæ”¾åˆ°Pçš„â€æœ¬åœ°è¿è¡Œé˜Ÿåˆ—â€
å¦‚æœæœ¬åœ°è¿è¡Œé˜Ÿåˆ—æ»¡äº†åˆ™è°ƒç”¨runqputslowæŠŠgæ”¾åˆ°â€å…¨å±€è¿è¡Œé˜Ÿåˆ—â€
runqputslowä¼šæŠŠæœ¬åœ°è¿è¡Œé˜Ÿåˆ—ä¸­ä¸€åŠçš„gæ”¾åˆ°å…¨å±€è¿è¡Œé˜Ÿåˆ—, è¿™æ ·ä¸‹æ¬¡å°±å¯ä»¥ç»§ç»­ç”¨å¿«é€Ÿçš„æœ¬åœ°è¿è¡Œé˜Ÿåˆ—äº†
å¦‚æœå½“å‰æœ‰ç©ºé—²çš„P, ä½†æ˜¯æ— è‡ªæ—‹çš„M(nmspinningç­‰äº0), å¹¶ä¸”ä¸»å‡½æ•°å·²æ‰§è¡Œåˆ™å”¤é†’æˆ–æ–°å»ºä¸€ä¸ªM
è¿™ä¸€æ­¥éå¸¸é‡è¦, ç”¨äºä¿è¯å½“å‰æœ‰è¶³å¤Ÿçš„Mè¿è¡ŒG, å…·ä½“è¯·æŸ¥çœ‹ä¸Šé¢çš„â€ç©ºé—²Mé“¾è¡¨â€
å”¤é†’æˆ–æ–°å»ºä¸€ä¸ªMä¼šé€šè¿‡wakepå‡½æ•°
é¦–å…ˆäº¤æ¢nmspinningåˆ°1, æˆåŠŸå†ç»§ç»­, å¤šä¸ªçº¿ç¨‹åŒæ—¶æ‰§è¡Œwakepåªæœ‰ä¸€ä¸ªä¼šç»§ç»­
è°ƒç”¨startmå‡½æ•°
è°ƒç”¨pidlegetä»â€ç©ºé—²Pé“¾è¡¨â€è·å–ä¸€ä¸ªç©ºé—²çš„P
è°ƒç”¨mgetä»â€ç©ºé—²Mé“¾è¡¨â€è·å–ä¸€ä¸ªç©ºé—²çš„M
å¦‚æœæ²¡æœ‰ç©ºé—²çš„M, åˆ™è°ƒç”¨newmæ–°å»ºä¸€ä¸ªM
newmä¼šæ–°å»ºä¸€ä¸ªmçš„å®ä¾‹, mçš„å®ä¾‹åŒ…å«ä¸€ä¸ªg0, ç„¶åè°ƒç”¨newosprocåŠ¨ä¸€ä¸ªç³»ç»Ÿçº¿ç¨‹
newosprocä¼šè°ƒç”¨syscall cloneåˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹
çº¿ç¨‹åˆ›å»ºåä¼šè®¾ç½®TLS, è®¾ç½®TLSä¸­å½“å‰çš„gä¸ºg0, ç„¶åæ‰§è¡Œmstart
è°ƒç”¨notewakeup(&amp;mp.park)å”¤é†’çº¿ç¨‹</p>
:ET