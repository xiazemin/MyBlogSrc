I"Êd<p>Go åŸºäº I/O multiplexing å’Œ goroutine scheduler æ„å»ºäº†ä¸€ä¸ªç®€æ´è€Œé«˜æ€§èƒ½çš„åŸç”Ÿç½‘ç»œæ¨¡å‹(åŸºäº Go çš„ I/O å¤šè·¯å¤ç”¨ netpoller )ï¼Œæä¾›äº† goroutine-per-connection è¿™æ ·ç®€å•çš„ç½‘ç»œç¼–ç¨‹æ¨¡å¼ã€‚åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œå¼€å‘è€…ä½¿ç”¨çš„æ˜¯åŒæ­¥çš„æ¨¡å¼å»ç¼–å†™å¼‚æ­¥çš„é€»è¾‘ï¼Œæå¤§åœ°é™ä½äº†å¼€å‘è€…ç¼–å†™ç½‘ç»œåº”ç”¨æ—¶çš„å¿ƒæ™ºè´Ÿæ‹…ï¼Œä¸”å€ŸåŠ©äº Go runtime scheduler å¯¹ goroutines çš„é«˜æ•ˆè°ƒåº¦ï¼Œè¿™ä¸ªåŸç”Ÿç½‘ç»œæ¨¡å‹ä¸è®ºä»é€‚ç”¨æ€§è¿˜æ˜¯æ€§èƒ½ä¸Šéƒ½è¶³ä»¥æ»¡è¶³ç»å¤§éƒ¨åˆ†çš„åº”ç”¨åœºæ™¯ã€‚</p>

<p>ç„¶è€Œï¼Œåœ¨å·¥ç¨‹æ€§ä¸Šèƒ½åšåˆ°å¦‚æ­¤é«˜çš„æ™®é€‚æ€§å’Œå…¼å®¹æ€§ï¼Œæœ€ç»ˆæš´éœ²ç»™å¼€å‘è€…æä¾›æ¥å£/æ¨¡å¼å¦‚æ­¤ç®€æ´ï¼Œå…¶åº•å±‚å¿…ç„¶æ˜¯åŸºäºéå¸¸å¤æ‚çš„å°è£…ï¼Œåšäº†å¾ˆå¤šå–èˆï¼Œä¹Ÿæœ‰å¯èƒ½æ”¾å¼ƒäº†ä¸€äº›è¿½æ±‚æè‡´æ€§èƒ½çš„è®¾è®¡å’Œç†å¿µã€‚äº‹å®ä¸Š Go netpoller åº•å±‚å°±æ˜¯åŸºäº epoll/kqueue/iocp è¿™äº› I/O å¤šè·¯å¤ç”¨æŠ€æœ¯æ¥åšå°è£…çš„ï¼Œæœ€ç»ˆæš´éœ²å‡º goroutine-per-connection è¿™æ ·çš„æç®€çš„å¼€å‘æ¨¡å¼ç»™ä½¿ç”¨è€…ã€‚</p>

<p>Go netpoller åœ¨ä¸åŒçš„æ“ä½œç³»ç»Ÿï¼Œå…¶åº•å±‚ä½¿ç”¨çš„ I/O å¤šè·¯å¤ç”¨æŠ€æœ¯ä¹Ÿä¸ä¸€æ ·ï¼Œå¯ä»¥ä» Go æºç ç›®å½•ç»“æ„å’Œå¯¹åº”ä»£ç æ–‡ä»¶äº†è§£ Go åœ¨ä¸åŒå¹³å°ä¸‹çš„ç½‘ç»œ I/O æ¨¡å¼çš„å®ç°ã€‚æ¯”å¦‚ï¼Œåœ¨ Linux ç³»ç»Ÿä¸‹åŸºäº epollï¼ŒfreeBSD ç³»ç»Ÿä¸‹åŸºäº kqueueï¼Œä»¥åŠ Windows ç³»ç»Ÿä¸‹åŸºäº iocpã€‚</p>

<p>æœ¬æ–‡å°†åŸºäº Linux å¹³å°æ¥è§£æ Go netpoller ä¹‹ I/O å¤šè·¯å¤ç”¨çš„åº•å±‚æ˜¯å¦‚ä½•åŸºäº epoll å°è£…å®ç°çš„ï¼Œä»æºç å±‚å±‚æ¨è¿›ï¼Œå…¨é¢è€Œæ·±åº¦åœ°è§£æ Go netpoller çš„è®¾è®¡ç†å¿µå’Œå®ç°åŸç†ï¼Œä»¥åŠ Go æ˜¯å¦‚ä½•åˆ©ç”¨ netpoller æ¥æ„å»ºå®ƒçš„åŸç”Ÿç½‘ç»œæ¨¡å‹çš„ã€‚ä¸»è¦æ¶‰åŠåˆ°çš„ä¸€äº›æ¦‚å¿µï¼šI/O æ¨¡å‹ã€ç”¨æˆ·/å†…æ ¸ç©ºé—´ã€epollã€Linux æºç ã€goroutine scheduler ç­‰ç­‰ï¼Œæˆ‘ä¼šå°½é‡ç®€å•åœ°è®²è§£ï¼Œå¦‚æœæœ‰å¯¹ç›¸å…³æ¦‚å¿µä¸ç†Ÿæ‚‰çš„åŒå­¦ï¼Œè¿˜æ˜¯å¸Œæœ›èƒ½æå‰ç†Ÿæ‚‰ä¸€ä¸‹ã€‚</p>

<p>ç”¨æˆ·ç©ºé—´ä¸å†…æ ¸ç©ºé—´
ç°ä»£æ“ä½œç³»ç»Ÿéƒ½æ˜¯é‡‡ç”¨è™šæ‹Ÿå­˜å‚¨å™¨ï¼Œé‚£ä¹ˆå¯¹ 32 ä½æ“ä½œç³»ç»Ÿè€Œè¨€ï¼Œå®ƒçš„å¯»å€ç©ºé—´ï¼ˆè™šæ‹Ÿå­˜å‚¨ç©ºé—´ï¼‰ä¸º 4Gï¼ˆ2 çš„ 32 æ¬¡æ–¹ï¼‰ã€‚æ“ä½œç³»ç»Ÿçš„æ ¸å¿ƒæ˜¯å†…æ ¸ï¼Œç‹¬ç«‹äºæ™®é€šçš„åº”ç”¨ç¨‹åºï¼Œå¯ä»¥è®¿é—®å—ä¿æŠ¤çš„å†…å­˜ç©ºé—´ï¼Œä¹Ÿæœ‰è®¿é—®åº•å±‚ç¡¬ä»¶è®¾å¤‡çš„æ‰€æœ‰æƒé™ã€‚ä¸ºäº†ä¿è¯ç”¨æˆ·è¿›ç¨‹ä¸èƒ½ç›´æ¥æ“ä½œå†…æ ¸ï¼ˆkernelï¼‰ï¼Œä¿è¯å†…æ ¸çš„å®‰å…¨ï¼Œæ“å¿ƒç³»ç»Ÿå°†è™šæ‹Ÿç©ºé—´åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†ä¸ºå†…æ ¸ç©ºé—´ï¼Œä¸€éƒ¨åˆ†ä¸ºç”¨æˆ·ç©ºé—´ã€‚é’ˆå¯¹ Linux æ“ä½œç³»ç»Ÿè€Œè¨€ï¼Œå°†æœ€é«˜çš„ 1G å­—èŠ‚ï¼ˆä»è™šæ‹Ÿåœ°å€ 0xC0000000 åˆ° 0xFFFFFFFFï¼‰ï¼Œä¾›å†…æ ¸ä½¿ç”¨ï¼Œç§°ä¸ºå†…æ ¸ç©ºé—´ï¼Œè€Œå°†è¾ƒä½çš„ 3G å­—èŠ‚ï¼ˆä»è™šæ‹Ÿåœ°å€ 0x00000000 åˆ° 0xBFFFFFFFï¼‰ï¼Œä¾›å„ä¸ªè¿›ç¨‹ä½¿ç”¨ï¼Œç§°ä¸ºç”¨æˆ·ç©ºé—´ã€‚</p>

<p>ç°ä»£çš„ç½‘ç»œæœåŠ¡çš„ä¸»æµå·²ç»å®Œæˆä» CPU å¯†é›†å‹åˆ° IO å¯†é›†å‹çš„è½¬å˜ï¼Œæ‰€ä»¥æœåŠ¡ç«¯ç¨‹åºå¯¹ I/O çš„å¤„ç†å¿…ä¸å¯å°‘ï¼Œè€Œä¸€æ—¦æ“ä½œ I/O åˆ™å¿…å®šè¦åœ¨ç”¨æˆ·æ€å’Œå†…æ ¸æ€ä¹‹é—´æ¥å›åˆ‡æ¢ã€‚</p>

<p>I/O æ¨¡å‹
åœ¨ç¥ä½œã€ŠUNIX ç½‘ç»œç¼–ç¨‹ã€‹é‡Œï¼Œæ€»ç»“å½’çº³äº† 5 ç§ I/O æ¨¡å‹ï¼ŒåŒ…æ‹¬åŒæ­¥å’Œå¼‚æ­¥ I/Oï¼š</p>

<p>é˜»å¡ I/O (Blocking I/O)
éé˜»å¡ I/O (Nonblocking I/O)
I/O å¤šè·¯å¤ç”¨ (I/O multiplexing)
ä¿¡å·é©±åŠ¨ I/O (Signal driven I/O)
å¼‚æ­¥ I/O (Asynchronous I/O)
æ“ä½œç³»ç»Ÿä¸Šçš„ I/O æ˜¯ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„æ•°æ®äº¤äº’ï¼Œå› æ­¤ I/O æ“ä½œé€šå¸¸åŒ…å«ä»¥ä¸‹ä¸¤ä¸ªæ­¥éª¤ï¼š</p>

<p>ç­‰å¾…ç½‘ç»œæ•°æ®åˆ°è¾¾ç½‘å¡(è¯»å°±ç»ª)/ç­‰å¾…ç½‘å¡å¯å†™(å†™å°±ç»ª) â€“&gt; è¯»å–/å†™å…¥åˆ°å†…æ ¸ç¼“å†²åŒº
ä»å†…æ ¸ç¼“å†²åŒºå¤åˆ¶æ•°æ® â€“&gt; ç”¨æˆ·ç©ºé—´(è¯»)/ä»ç”¨æˆ·ç©ºé—´å¤åˆ¶æ•°æ® -&gt; å†…æ ¸ç¼“å†²åŒº(å†™)
è€Œåˆ¤å®šä¸€ä¸ª I/O æ¨¡å‹æ˜¯åŒæ­¥è¿˜æ˜¯å¼‚æ­¥ï¼Œä¸»è¦çœ‹ç¬¬äºŒæ­¥ï¼šæ•°æ®åœ¨ç”¨æˆ·å’Œå†…æ ¸ç©ºé—´ä¹‹é—´å¤åˆ¶çš„æ—¶å€™æ˜¯ä¸æ˜¯ä¼šé˜»å¡å½“å‰è¿›ç¨‹ï¼Œå¦‚æœä¼šï¼Œåˆ™æ˜¯åŒæ­¥ I/Oï¼Œå¦åˆ™ï¼Œå°±æ˜¯å¼‚æ­¥ I/Oã€‚åŸºäºè¿™ä¸ªåŸåˆ™ï¼Œè¿™ 5 ç§ I/O æ¨¡å‹ä¸­åªæœ‰ä¸€ç§å¼‚æ­¥ I/O æ¨¡å‹ï¼šAsynchronous I/Oï¼Œå…¶ä½™éƒ½æ˜¯åŒæ­¥ I/O æ¨¡å‹ã€‚</p>

<p>è¿™ 5 ç§ I/O æ¨¡å‹çš„å¯¹æ¯”å¦‚ä¸‹ï¼š</p>

<p>Non-blocking I/O
ä»€ä¹ˆå«éé˜»å¡ I/Oï¼Œé¡¾åæ€ä¹‰å°±æ˜¯ï¼šæ‰€æœ‰ I/O æ“ä½œéƒ½æ˜¯ç«‹åˆ»è¿”å›è€Œä¸ä¼šé˜»å¡å½“å‰ç”¨æˆ·è¿›ç¨‹ã€‚I/O å¤šè·¯å¤ç”¨é€šå¸¸æƒ…å†µä¸‹éœ€è¦å’Œéé˜»å¡ I/O æ­é…ä½¿ç”¨ï¼Œå¦åˆ™å¯èƒ½ä¼šäº§ç”Ÿæ„æƒ³ä¸åˆ°çš„é—®é¢˜ã€‚æ¯”å¦‚ï¼Œepoll çš„ ET(è¾¹ç¼˜è§¦å‘) æ¨¡å¼ä¸‹ï¼Œå¦‚æœä¸ä½¿ç”¨éé˜»å¡ I/Oï¼Œæœ‰æå¤§çš„æ¦‚ç‡ä¼šå¯¼è‡´é˜»å¡ event-loop çº¿ç¨‹ï¼Œä»è€Œé™ä½ååé‡ï¼Œç”šè‡³å¯¼è‡´ bugã€‚</p>

<p>Linux ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ fcntl ç³»ç»Ÿè°ƒç”¨æ¥è®¾ç½® O_NONBLOCK æ ‡å¿—ä½ï¼Œä»è€ŒæŠŠ socket è®¾ç½®æˆ Non-blockingã€‚å½“å¯¹ä¸€ä¸ª Non-blocking socket æ‰§è¡Œè¯»æ“ä½œæ—¶ï¼Œæµç¨‹æ˜¯è¿™ä¸ªæ ·å­ï¼š</p>

<p>å½“ç”¨æˆ·è¿›ç¨‹å‘å‡º read æ“ä½œæ—¶ï¼Œå¦‚æœ kernel ä¸­çš„æ•°æ®è¿˜æ²¡æœ‰å‡†å¤‡å¥½ï¼Œé‚£ä¹ˆå®ƒå¹¶ä¸ä¼š block ç”¨æˆ·è¿›ç¨‹ï¼Œè€Œæ˜¯ç«‹åˆ»è¿”å›ä¸€ä¸ª EAGAIN errorã€‚ä»ç”¨æˆ·è¿›ç¨‹è§’åº¦è®² ï¼Œå®ƒå‘èµ·ä¸€ä¸ª read æ“ä½œåï¼Œå¹¶ä¸éœ€è¦ç­‰å¾…ï¼Œè€Œæ˜¯é©¬ä¸Šå°±å¾—åˆ°äº†ä¸€ä¸ªç»“æœã€‚ç”¨æˆ·è¿›ç¨‹åˆ¤æ–­ç»“æœæ˜¯ä¸€ä¸ª error æ—¶ï¼Œå®ƒå°±çŸ¥é“æ•°æ®è¿˜æ²¡æœ‰å‡†å¤‡å¥½ï¼Œäºæ˜¯å®ƒå¯ä»¥å†æ¬¡å‘é€ read æ“ä½œã€‚ä¸€æ—¦ kernel ä¸­çš„æ•°æ®å‡†å¤‡å¥½äº†ï¼Œå¹¶ä¸”åˆå†æ¬¡æ”¶åˆ°äº†ç”¨æˆ·è¿›ç¨‹çš„ system callï¼Œé‚£ä¹ˆå®ƒé©¬ä¸Šå°±å°†æ•°æ®æ‹·è´åˆ°äº†ç”¨æˆ·å†…å­˜ï¼Œç„¶åè¿”å›ã€‚</p>

<p>æ‰€ä»¥ï¼ŒNon-blocking I/O çš„ç‰¹ç‚¹æ˜¯ç”¨æˆ·è¿›ç¨‹éœ€è¦ä¸æ–­çš„ä¸»åŠ¨è¯¢é—® kernel æ•°æ®å¥½äº†æ²¡æœ‰ã€‚ä¸‹ä¸€èŠ‚æˆ‘ä»¬è¦è®²çš„ I/O å¤šè·¯å¤ç”¨éœ€è¦å’Œ Non-blocking I/O é…åˆæ‰èƒ½å‘æŒ¥å‡ºæœ€å¤§çš„å¨åŠ›ï¼</p>

<p>I/O å¤šè·¯å¤ç”¨
æ‰€è°“ I/O å¤šè·¯å¤ç”¨æŒ‡çš„å°±æ˜¯ select/poll/epoll è¿™ä¸€ç³»åˆ—çš„å¤šè·¯é€‰æ‹©å™¨ï¼šæ”¯æŒå•ä¸€çº¿ç¨‹åŒæ—¶ç›‘å¬å¤šä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼ˆI/O äº‹ä»¶ï¼‰ï¼Œé˜»å¡ç­‰å¾…ï¼Œå¹¶åœ¨å…¶ä¸­æŸä¸ªæ–‡ä»¶æè¿°ç¬¦å¯è¯»å†™æ—¶æ”¶åˆ°é€šçŸ¥ã€‚ I/O å¤ç”¨å…¶å®å¤ç”¨çš„ä¸æ˜¯ I/O è¿æ¥ï¼Œè€Œæ˜¯å¤ç”¨çº¿ç¨‹ï¼Œè®©ä¸€ä¸ª thread of control èƒ½å¤Ÿå¤„ç†å¤šä¸ªè¿æ¥ï¼ˆI/O äº‹ä»¶ï¼‰ã€‚</p>

<p>select &amp; poll
 1#include &lt;sys/select.h&gt;
 2
 3/* According to earlier standards */
 4#include &lt;sys/time.h&gt;
 5#include &lt;sys/types.h&gt;
 6#include <unistd.h>
 7
 8int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
 9
10// å’Œ select ç´§å¯†ç»“åˆçš„å››ä¸ªå®ï¼š
11void FD_CLR(int fd, fd_set *set);
12int FD_ISSET(int fd, fd_set *set);
13void FD_SET(int fd, fd_set *set);
14void FD_ZERO(fd_set *set);
select æ˜¯ epoll ä¹‹å‰ Linux ä½¿ç”¨çš„ I/O äº‹ä»¶é©±åŠ¨æŠ€æœ¯ã€‚</unistd.h></p>

<p>ç†è§£ select çš„å…³é”®åœ¨äºç†è§£ fd_setï¼Œä¸ºè¯´æ˜æ–¹ä¾¿ï¼Œå– fd_set é•¿åº¦ä¸º 1 å­—èŠ‚ï¼Œfd_set ä¸­çš„æ¯ä¸€ bit å¯ä»¥å¯¹åº”ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ fdï¼Œåˆ™ 1 å­—èŠ‚é•¿çš„ fd_set æœ€å¤§å¯ä»¥å¯¹åº” 8 ä¸ª fdã€‚select çš„è°ƒç”¨è¿‡ç¨‹å¦‚ä¸‹ï¼š</p>

<p>æ‰§è¡Œ FD_ZERO(&amp;set), åˆ™ set ç”¨ä½è¡¨ç¤ºæ˜¯ 0000,0000
è‹¥ fdï¼5, æ‰§è¡Œ FD_SET(fd, &amp;set); å set å˜ä¸º 0001,0000(ç¬¬ 5 ä½ç½®ä¸º 1)
å†åŠ å…¥ fdï¼2, fd=1ï¼Œåˆ™ set å˜ä¸º 0001,0011
æ‰§è¡Œ select(6, &amp;set, 0, 0, 0) é˜»å¡ç­‰å¾…
è‹¥ fd=1, fd=2 ä¸Šéƒ½å‘ç”Ÿå¯è¯»äº‹ä»¶ï¼Œåˆ™ select è¿”å›ï¼Œæ­¤æ—¶ set å˜ä¸º 0000,0011 (æ³¨æ„ï¼šæ²¡æœ‰äº‹ä»¶å‘ç”Ÿçš„ fd=5 è¢«æ¸…ç©º)
åŸºäºä¸Šé¢çš„è°ƒç”¨è¿‡ç¨‹ï¼Œå¯ä»¥å¾—å‡º select çš„ç‰¹ç‚¹ï¼š</p>

<p>å¯ç›‘æ§çš„æ–‡ä»¶æè¿°ç¬¦ä¸ªæ•°å–å†³äº sizeof(fd_set) çš„å€¼ã€‚å‡è®¾æœåŠ¡å™¨ä¸Š sizeof(fd_set)ï¼512ï¼Œæ¯ bit è¡¨ç¤ºä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œåˆ™æœåŠ¡å™¨ä¸Šæ”¯æŒçš„æœ€å¤§æ–‡ä»¶æè¿°ç¬¦æ˜¯ 512*8=4096ã€‚fd_set çš„å¤§å°è°ƒæ•´å¯å‚è€ƒ ã€åŸåˆ›ã€‘æŠ€æœ¯ç³»åˆ—ä¹‹ ç½‘ç»œæ¨¡å‹ï¼ˆäºŒï¼‰ ä¸­çš„æ¨¡å‹ 2ï¼Œå¯ä»¥æœ‰æ•ˆçªç ´ select å¯ç›‘æ§çš„æ–‡ä»¶æè¿°ç¬¦ä¸Šé™
å°† fd åŠ å…¥ select ç›‘æ§é›†çš„åŒæ—¶ï¼Œè¿˜è¦å†ä½¿ç”¨ä¸€ä¸ªæ•°æ®ç»“æ„ array ä¿å­˜æ”¾åˆ° select ç›‘æ§é›†ä¸­çš„ fdï¼Œä¸€æ˜¯ç”¨äºåœ¨ select è¿”å›åï¼Œarray ä½œä¸ºæºæ•°æ®å’Œ fd_set è¿›è¡Œ FD_ISSET åˆ¤æ–­ã€‚äºŒæ˜¯ select è¿”å›åä¼šæŠŠä»¥å‰åŠ å…¥çš„ä½†å¹¶æ— äº‹ä»¶å‘ç”Ÿçš„ fd æ¸…ç©ºï¼Œåˆ™æ¯æ¬¡å¼€å§‹ select å‰éƒ½è¦é‡æ–°ä» array å–å¾— fd é€ä¸€åŠ å…¥ï¼ˆFD_ZERO æœ€å…ˆï¼‰ï¼Œæ‰«æ array çš„åŒæ—¶å–å¾— fd æœ€å¤§å€¼ maxfdï¼Œç”¨äº select çš„ç¬¬ä¸€ä¸ªå‚æ•°
å¯è§ select æ¨¡å‹å¿…é¡»åœ¨ select å‰å¾ªç¯ arrayï¼ˆåŠ  fdï¼Œå– maxfdï¼‰ï¼Œselect è¿”å›åå¾ªç¯ arrayï¼ˆFD_ISSET åˆ¤æ–­æ˜¯å¦æœ‰äº‹ä»¶å‘ç”Ÿï¼‰
æ‰€ä»¥ï¼Œselect æœ‰å¦‚ä¸‹çš„ç¼ºç‚¹ï¼š</p>

<p>æœ€å¤§å¹¶å‘æ•°é™åˆ¶ï¼šä½¿ç”¨ 32 ä¸ªæ•´æ•°çš„ 32 ä½ï¼Œå³ 32*32=1024 æ¥æ ‡è¯† fdï¼Œè™½ç„¶å¯ä¿®æ”¹ï¼Œä½†æ˜¯æœ‰ä»¥ä¸‹ç¬¬ 2, 3 ç‚¹çš„ç“¶é¢ˆ
æ¯æ¬¡è°ƒç”¨ selectï¼Œéƒ½éœ€è¦æŠŠ fd é›†åˆä»ç”¨æˆ·æ€æ‹·è´åˆ°å†…æ ¸æ€ï¼Œè¿™ä¸ªå¼€é”€åœ¨ fd å¾ˆå¤šæ—¶ä¼šå¾ˆå¤§
æ€§èƒ½è¡°å‡ä¸¥é‡ï¼šæ¯æ¬¡ kernel éƒ½éœ€è¦çº¿æ€§æ‰«ææ•´ä¸ª fd_setï¼Œæ‰€ä»¥éšç€ç›‘æ§çš„æè¿°ç¬¦ fd æ•°é‡å¢é•¿ï¼Œå…¶ I/O æ€§èƒ½ä¼šçº¿æ€§ä¸‹é™
poll çš„å®ç°å’Œ select éå¸¸ç›¸ä¼¼ï¼Œåªæ˜¯æè¿° fd é›†åˆçš„æ–¹å¼ä¸åŒï¼Œpoll ä½¿ç”¨ pollfd ç»“æ„è€Œä¸æ˜¯ select çš„ fd_set ç»“æ„ï¼Œpoll è§£å†³äº†æœ€å¤§æ–‡ä»¶æè¿°ç¬¦æ•°é‡é™åˆ¶çš„é—®é¢˜ï¼Œä½†æ˜¯åŒæ ·éœ€è¦ä»ç”¨æˆ·æ€æ‹·è´æ‰€æœ‰çš„ fd åˆ°å†…æ ¸æ€ï¼Œä¹Ÿéœ€è¦çº¿æ€§éå†æ‰€æœ‰çš„ fd é›†åˆï¼Œæ‰€ä»¥å®ƒå’Œ select åªæ˜¯å®ç°ç»†èŠ‚ä¸Šçš„åŒºåˆ†ï¼Œå¹¶æ²¡æœ‰æœ¬è´¨ä¸Šçš„åŒºåˆ«ã€‚</p>

<p>epoll
epoll æ˜¯ Linux kernel 2.6 ä¹‹åå¼•å…¥çš„æ–° I/O äº‹ä»¶é©±åŠ¨æŠ€æœ¯ï¼ŒI/O å¤šè·¯å¤ç”¨çš„æ ¸å¿ƒè®¾è®¡æ˜¯ 1 ä¸ªçº¿ç¨‹å¤„ç†æ‰€æœ‰è¿æ¥çš„ ç­‰å¾…æ¶ˆæ¯å‡†å¤‡å¥½ I/O äº‹ä»¶ï¼Œè¿™ä¸€ç‚¹ä¸Š epoll å’Œ select&amp;poll æ˜¯å¤§åŒå°å¼‚çš„ã€‚ä½† select&amp;poll é”™è¯¯é¢„ä¼°äº†ä¸€ä»¶äº‹ï¼Œå½“æ•°åä¸‡å¹¶å‘è¿æ¥å­˜åœ¨æ—¶ï¼Œå¯èƒ½æ¯ä¸€æ¯«ç§’åªæœ‰æ•°ç™¾ä¸ªæ´»è·ƒçš„è¿æ¥ï¼ŒåŒæ—¶å…¶ä½™æ•°åä¸‡è¿æ¥åœ¨è¿™ä¸€æ¯«ç§’æ˜¯éæ´»è·ƒçš„ã€‚select&amp;poll çš„ä½¿ç”¨æ–¹æ³•æ˜¯è¿™æ ·çš„ï¼š è¿”å›çš„æ´»è·ƒè¿æ¥ == select(å…¨éƒ¨å¾…ç›‘æ§çš„è¿æ¥) ã€‚</p>

<p>ä»€ä¹ˆæ—¶å€™ä¼šè°ƒç”¨ select&amp;poll å‘¢ï¼Ÿåœ¨ä½ è®¤ä¸ºéœ€è¦æ‰¾å‡ºæœ‰æŠ¥æ–‡åˆ°è¾¾çš„æ´»è·ƒè¿æ¥æ—¶ï¼Œå°±åº”è¯¥è°ƒç”¨ã€‚æ‰€ä»¥ï¼Œselect&amp;poll åœ¨é«˜å¹¶å‘æ—¶æ˜¯ä¼šè¢«é¢‘ç¹è°ƒç”¨çš„ã€‚è¿™æ ·ï¼Œè¿™ä¸ªé¢‘ç¹è°ƒç”¨çš„æ–¹æ³•å°±å¾ˆæœ‰å¿…è¦çœ‹çœ‹å®ƒæ˜¯å¦æœ‰æ•ˆç‡ï¼Œå› ä¸ºï¼Œå®ƒçš„è½»å¾®æ•ˆç‡æŸå¤±éƒ½ä¼šè¢« é«˜é¢‘ äºŒå­—æ‰€æ”¾å¤§ã€‚å®ƒæœ‰æ•ˆç‡æŸå¤±å—ï¼Ÿæ˜¾è€Œæ˜“è§ï¼Œå…¨éƒ¨å¾…ç›‘æ§è¿æ¥æ˜¯æ•°ä»¥åä¸‡è®¡çš„ï¼Œè¿”å›çš„åªæ˜¯æ•°ç™¾ä¸ªæ´»è·ƒè¿æ¥ï¼Œè¿™æœ¬èº«å°±æ˜¯æ— æ•ˆç‡çš„è¡¨ç°ã€‚è¢«æ”¾å¤§åå°±ä¼šå‘ç°ï¼Œå¤„ç†å¹¶å‘ä¸Šä¸‡ä¸ªè¿æ¥æ—¶ï¼Œselect&amp;poll å°±å®Œå…¨åŠ›ä¸ä»å¿ƒäº†ã€‚è¿™ä¸ªæ—¶å€™å°±è¯¥ epoll ä¸Šåœºäº†ï¼Œepoll é€šè¿‡ä¸€äº›æ–°çš„è®¾è®¡å’Œä¼˜åŒ–ï¼ŒåŸºæœ¬ä¸Šè§£å†³äº† select&amp;poll çš„é—®é¢˜ã€‚</p>

<p>epoll çš„ API éå¸¸ç®€æ´ï¼Œæ¶‰åŠåˆ°çš„åªæœ‰ 3 ä¸ªç³»ç»Ÿè°ƒç”¨ï¼š</p>

<p>1#include &lt;sys/epoll.h&gt;<br />
2int epoll_create(int size); // int epoll_create1(int flags);
3int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
4int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
å…¶ä¸­ï¼Œepoll_create åˆ›å»ºä¸€ä¸ª epoll å®ä¾‹å¹¶è¿”å› epollfdï¼›epoll_ctl æ³¨å†Œ file descriptor ç­‰å¾…çš„ I/O äº‹ä»¶(æ¯”å¦‚ EPOLLINã€EPOLLOUT ç­‰) åˆ° epoll å®ä¾‹ä¸Šï¼›epoll_wait åˆ™æ˜¯é˜»å¡ç›‘å¬ epoll å®ä¾‹ä¸Šæ‰€æœ‰çš„ file descriptor çš„ I/O äº‹ä»¶ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ªç”¨æˆ·ç©ºé—´ä¸Šçš„ä¸€å—å†…å­˜åœ°å€ (events æ•°ç»„)ï¼Œkernel ä¼šåœ¨æœ‰ I/O äº‹ä»¶å‘ç”Ÿçš„æ—¶å€™æŠŠæ–‡ä»¶æè¿°ç¬¦åˆ—è¡¨å¤åˆ¶åˆ°è¿™å—å†…å­˜åœ°å€ä¸Šï¼Œç„¶å epoll_wait è§£é™¤é˜»å¡å¹¶è¿”å›ï¼Œæœ€åç”¨æˆ·ç©ºé—´ä¸Šçš„ç¨‹åºå°±å¯ä»¥å¯¹ç›¸åº”çš„ fd è¿›è¡Œè¯»å†™äº†ï¼š</p>

<p>1#include <unistd.h>
2ssize_t read(int fd, void *buf, size_t count);
3ssize_t write(int fd, const void *buf, size_t count);
epoll çš„å·¥ä½œåŸç†å¦‚ä¸‹ï¼š</unistd.h></p>

<p>ä¸ select&amp;poll ç›¸æ¯”ï¼Œepoll åˆ†æ¸…äº†é«˜é¢‘è°ƒç”¨å’Œä½é¢‘è°ƒç”¨ã€‚ä¾‹å¦‚ï¼Œepoll_ctl ç›¸å¯¹æ¥è¯´å°±æ˜¯éé¢‘ç¹è°ƒç”¨çš„ï¼Œè€Œ epoll_wait åˆ™æ˜¯ä¼šè¢«é«˜é¢‘è°ƒç”¨çš„ã€‚æ‰€ä»¥ epoll åˆ©ç”¨ epoll_ctl æ¥æ’å…¥æˆ–è€…åˆ é™¤ä¸€ä¸ª fdï¼Œå®ç°ç”¨æˆ·æ€åˆ°å†…æ ¸æ€çš„æ•°æ®æ‹·è´ï¼Œè¿™ç¡®ä¿äº†æ¯ä¸€ä¸ª fd åœ¨å…¶ç”Ÿå‘½å‘¨æœŸåªéœ€è¦è¢«æ‹·è´ä¸€æ¬¡ï¼Œè€Œä¸æ˜¯æ¯æ¬¡è°ƒç”¨ epoll_wait çš„æ—¶å€™éƒ½æ‹·è´ä¸€æ¬¡ã€‚ epoll_wait åˆ™è¢«è®¾è®¡æˆå‡ ä¹æ²¡æœ‰å…¥å‚çš„è°ƒç”¨ï¼Œç›¸æ¯” select&amp;poll éœ€è¦æŠŠå…¨éƒ¨ç›‘å¬çš„ fd é›†åˆä»ç”¨æˆ·æ€æ‹·è´è‡³å†…æ ¸æ€çš„åšæ³•ï¼Œepoll çš„æ•ˆç‡å°±é«˜å‡ºäº†ä¸€å¤§æˆªã€‚</p>

<p>åœ¨å®ç°ä¸Š epoll é‡‡ç”¨çº¢é»‘æ ‘æ¥å­˜å‚¨æ‰€æœ‰ç›‘å¬çš„ fdï¼Œè€Œçº¢é»‘æ ‘æœ¬èº«æ’å…¥å’Œåˆ é™¤æ€§èƒ½æ¯”è¾ƒç¨³å®šï¼Œæ—¶é—´å¤æ‚åº¦ O(logN)ã€‚é€šè¿‡ epoll_ctl å‡½æ•°æ·»åŠ è¿›æ¥çš„ fd éƒ½ä¼šè¢«æ”¾åœ¨çº¢é»‘æ ‘çš„æŸä¸ªèŠ‚ç‚¹å†…ï¼Œæ‰€ä»¥ï¼Œé‡å¤æ·»åŠ æ˜¯æ²¡æœ‰ç”¨çš„ã€‚å½“æŠŠ fd æ·»åŠ è¿›æ¥çš„æ—¶å€™æ—¶å€™ä¼šå®Œæˆå…³é”®çš„ä¸€æ­¥ï¼šè¯¥ fd ä¼šä¸ç›¸åº”çš„è®¾å¤‡ï¼ˆç½‘å¡ï¼‰é©±åŠ¨ç¨‹åºå»ºç«‹å›è°ƒå…³ç³»ï¼Œä¹Ÿå°±æ˜¯åœ¨å†…æ ¸ä¸­æ–­å¤„ç†ç¨‹åºä¸ºå®ƒæ³¨å†Œä¸€ä¸ªå›è°ƒå‡½æ•°ï¼Œåœ¨ fd ç›¸åº”çš„äº‹ä»¶è§¦å‘ï¼ˆä¸­æ–­ï¼‰ä¹‹åï¼ˆè®¾å¤‡å°±ç»ªäº†ï¼‰ï¼Œå†…æ ¸å°±ä¼šè°ƒç”¨è¿™ä¸ªå›è°ƒå‡½æ•°ï¼Œè¯¥å›è°ƒå‡½æ•°åœ¨å†…æ ¸ä¸­è¢«ç§°ä¸ºï¼š ep_poll_callback ï¼Œè¿™ä¸ªå›è°ƒå‡½æ•°å…¶å®å°±æ˜¯æŠŠè¿™ä¸ª fd æ·»åŠ åˆ° rdllist è¿™ä¸ªåŒå‘é“¾è¡¨ï¼ˆå°±ç»ªé“¾è¡¨ï¼‰ä¸­ã€‚epoll_wait å®é™…ä¸Šå°±æ˜¯å»æ£€æŸ¥ rdllist åŒå‘é“¾è¡¨ä¸­æ˜¯å¦æœ‰å°±ç»ªçš„ fdï¼Œå½“ rdllist ä¸ºç©ºï¼ˆæ— å°±ç»ª fdï¼‰æ—¶æŒ‚èµ·å½“å‰è¿›ç¨‹ï¼Œç›´åˆ° rdllist éç©ºæ—¶è¿›ç¨‹æ‰è¢«å”¤é†’å¹¶è¿”å›ã€‚</p>

<p>ç›¸æ¯”äº select&amp;poll è°ƒç”¨æ—¶ä¼šå°†å…¨éƒ¨ç›‘å¬çš„ fd ä»ç”¨æˆ·æ€ç©ºé—´æ‹·è´è‡³å†…æ ¸æ€ç©ºé—´å¹¶çº¿æ€§æ‰«æä¸€éæ‰¾å‡ºå°±ç»ªçš„ fd å†è¿”å›åˆ°ç”¨æˆ·æ€ï¼Œepoll_wait åˆ™æ˜¯ç›´æ¥è¿”å›å·²å°±ç»ª fdï¼Œå› æ­¤ epoll çš„ I/O æ€§èƒ½ä¸ä¼šåƒ select&amp;poll é‚£æ ·éšç€ç›‘å¬çš„ fd æ•°é‡å¢åŠ è€Œå‡ºç°çº¿æ€§è¡°å‡ï¼Œæ˜¯ä¸€ä¸ªéå¸¸é«˜æ•ˆçš„ I/O äº‹ä»¶é©±åŠ¨æŠ€æœ¯ã€‚</p>

<p>ç”±äºä½¿ç”¨ epoll çš„ I/O å¤šè·¯å¤ç”¨éœ€è¦ç”¨æˆ·è¿›ç¨‹è‡ªå·±è´Ÿè´£ I/O è¯»å†™ï¼Œä»ç”¨æˆ·è¿›ç¨‹çš„è§’åº¦çœ‹ï¼Œè¯»å†™è¿‡ç¨‹æ˜¯é˜»å¡çš„ï¼Œæ‰€ä»¥ select&amp;poll&amp;epoll æœ¬è´¨ä¸Šéƒ½æ˜¯åŒæ­¥ I/O æ¨¡å‹ï¼Œè€Œåƒ Windows çš„ IOCP è¿™ä¸€ç±»çš„å¼‚æ­¥ I/Oï¼Œåªéœ€è¦åœ¨è°ƒç”¨ WSARecv æˆ– WSASend æ–¹æ³•è¯»å†™æ•°æ®çš„æ—¶å€™æŠŠç”¨æˆ·ç©ºé—´çš„å†…å­˜ buffer æäº¤ç»™ kernelï¼Œkernel è´Ÿè´£æ•°æ®åœ¨ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´æ‹·è´ï¼Œå®Œæˆä¹‹åå°±ä¼šé€šçŸ¥ç”¨æˆ·è¿›ç¨‹ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¸éœ€è¦ç”¨æˆ·è¿›ç¨‹å‚ä¸ï¼Œæ‰€ä»¥æ˜¯çœŸæ­£çš„å¼‚æ­¥ I/Oã€‚</p>

<p>å»¶ä¼¸
å¦å¤–ï¼Œæˆ‘çœ‹åˆ°æœ‰äº›æ–‡ç« è¯´ epoll ä¹‹æ‰€ä»¥æ€§èƒ½é«˜æ˜¯å› ä¸ºåˆ©ç”¨äº† Linux çš„ mmap å†…å­˜æ˜ å°„è®©å†…æ ¸å’Œç”¨æˆ·è¿›ç¨‹å…±äº«äº†ä¸€ç‰‡ç‰©ç†å†…å­˜ï¼Œç”¨æ¥å­˜æ”¾å°±ç»ª fd åˆ—è¡¨å’Œå®ƒä»¬çš„æ•°æ® bufferï¼Œæ‰€ä»¥ç”¨æˆ·è¿›ç¨‹åœ¨ epoll_wait è¿”å›ä¹‹åç”¨æˆ·è¿›ç¨‹å°±å¯ä»¥ç›´æ¥ä»å…±äº«å†…å­˜é‚£é‡Œè¯»å–/å†™å…¥æ•°æ®äº†ï¼Œè¿™è®©æˆ‘å¾ˆç–‘æƒ‘ï¼Œå› ä¸ºé¦–å…ˆçœ‹ epoll_wait çš„å‡½æ•°å£°æ˜ï¼š</p>

<p>1int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
ç¬¬äºŒä¸ªå‚æ•°ï¼šå°±ç»ªäº‹ä»¶åˆ—è¡¨ï¼Œæ˜¯éœ€è¦åœ¨ç”¨æˆ·ç©ºé—´åˆ†é…å†…å­˜ç„¶åå†ä¼ ç»™ epoll_wait çš„ï¼Œå¦‚æœå†…æ ¸ä¼šç”¨ mmap è®¾ç½®å…±äº«å†…å­˜ï¼Œç›´æ¥ä¼ é€’ä¸€ä¸ªæŒ‡é’ˆè¿›å»å°±è¡Œäº†ï¼Œæ ¹æœ¬ä¸éœ€è¦åœ¨ç”¨æˆ·æ€åˆ†é…å†…å­˜ï¼Œå¤šæ­¤ä¸€ä¸¾ã€‚å…¶æ¬¡ï¼Œå†…æ ¸å’Œç”¨æˆ·è¿›ç¨‹é€šè¿‡ mmap å…±äº«å†…å­˜æ˜¯ä¸€ä»¶æåº¦å±é™©çš„äº‹æƒ…ï¼Œå†…æ ¸æ— æ³•ç¡®å®šè¿™å—å…±äº«å†…å­˜ä»€ä¹ˆæ—¶å€™ä¼šè¢«å›æ”¶ï¼Œè€Œä¸”è¿™æ ·ä¹Ÿä¼šèµ‹äºˆç”¨æˆ·è¿›ç¨‹ç›´æ¥æ“ä½œå†…æ ¸æ•°æ®çš„æƒé™å’Œå…¥å£ï¼Œéå¸¸å®¹æ˜“å‡ºç°å¤§çš„ç³»ç»Ÿæ¼æ´ï¼Œå› æ­¤ä¸€èˆ¬æå°‘ä¼šè¿™ä¹ˆåšã€‚æ‰€ä»¥æˆ‘å¾ˆæ€€ç–‘ epoll æ˜¯ä¸æ˜¯çœŸçš„åœ¨ Linux kernel é‡Œç”¨äº† mmapï¼Œæˆ‘å°±å»çœ‹äº†ä¸‹æœ€æ–°ç‰ˆæœ¬ï¼ˆ5.3.9ï¼‰çš„ Linux kernel æºç ï¼š</p>

<p>1/*
 2 * Implement the event wait interface for the eventpoll file. It is the kernel
 3 * part of the user space epoll_wait(2).
 4 <em>/
 5static int do_epoll_wait(int epfd, struct epoll_event __user *events,
 6			 int maxevents, int timeout)
 7{
 8	â€¦
 9<br />
10	/</em> Time to fish for events â€¦ <em>/
11	error = ep_poll(ep, events, maxevents, timeout);
12}
13
14// å¦‚æœ epoll_wait å…¥å‚æ—¶è®¾å®š timeout == 0, é‚£ä¹ˆç›´æ¥é€šè¿‡ ep_events_available åˆ¤æ–­å½“å‰æ˜¯å¦æœ‰ç”¨æˆ·æ„Ÿå…´è¶£çš„äº‹ä»¶å‘ç”Ÿï¼Œå¦‚æœæœ‰åˆ™é€šè¿‡ ep_send_events è¿›è¡Œå¤„ç†
15// å¦‚æœè®¾ç½® timeout &gt; 0ï¼Œå¹¶ä¸”å½“å‰æ²¡æœ‰ç”¨æˆ·å…³æ³¨çš„äº‹ä»¶å‘ç”Ÿï¼Œåˆ™è¿›è¡Œä¼‘çœ ï¼Œå¹¶æ·»åŠ åˆ° ep-&gt;wq ç­‰å¾…é˜Ÿåˆ—çš„å¤´éƒ¨ï¼›å¯¹ç­‰å¾…äº‹ä»¶æè¿°ç¬¦è®¾ç½® WQ_FLAG_EXCLUSIVE æ ‡å¿—
16// ep_poll è¢«äº‹ä»¶å”¤é†’åä¼šé‡æ–°æ£€æŸ¥æ˜¯å¦æœ‰å…³æ³¨äº‹ä»¶ï¼Œå¦‚æœå¯¹åº”çš„äº‹ä»¶å·²ç»è¢«æŠ¢èµ°ï¼Œé‚£ä¹ˆ ep_poll ä¼šç»§ç»­ä¼‘çœ ç­‰å¾…
17static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events, int maxevents, long timeout)
18{
19	â€¦
20<br />
21	send_events:
22	/</em>
23	 * Try to transfer events to user space. In case we get 0 events and
24	 * thereâ€™s still timeout left over, we go trying again in search of
25	 * more luck.
26	 <em>/
27<br />
28	// å¦‚æœä¸€åˆ‡æ­£å¸¸, æœ‰ event å‘ç”Ÿ, å°±å¼€å§‹å‡†å¤‡æ•°æ® copy ç»™ç”¨æˆ·ç©ºé—´äº†
29	// å¦‚æœæœ‰å°±ç»ªçš„äº‹ä»¶å‘ç”Ÿï¼Œé‚£ä¹ˆå°±è°ƒç”¨ ep_send_events å°†å°±ç»ªçš„äº‹ä»¶ copy åˆ°ç”¨æˆ·æ€å†…å­˜ä¸­ï¼Œ
30	// ç„¶åè¿”å›åˆ°ç”¨æˆ·æ€ï¼Œå¦åˆ™åˆ¤æ–­æ˜¯å¦è¶…æ—¶ï¼Œå¦‚æœæ²¡æœ‰è¶…æ—¶å°±ç»§ç»­ç­‰å¾…å°±ç»ªäº‹ä»¶å‘ç”Ÿï¼Œå¦‚æœè¶…æ—¶å°±è¿”å›ç”¨æˆ·æ€ã€‚
31	// ä» ep_poll å‡½æ•°çš„å®ç°å¯ä»¥çœ‹åˆ°ï¼Œå¦‚æœæœ‰å°±ç»ªäº‹ä»¶å‘ç”Ÿï¼Œåˆ™è°ƒç”¨ ep_send_events å‡½æ•°åšè¿›ä¸€æ­¥å¤„ç†
32	if (!res &amp;&amp; eavail &amp;&amp;
33			!(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)
34		goto fetch_events;
35<br />
36	â€¦
37}
38
39// ep_send_events å‡½æ•°æ˜¯ç”¨æ¥å‘ç”¨æˆ·ç©ºé—´æ‹·è´å°±ç»ª fd åˆ—è¡¨çš„ï¼Œå®ƒå°†ç”¨æˆ·ä¼ å…¥çš„å°±ç»ª fd åˆ—è¡¨å†…å­˜ç®€å•å°è£…åˆ°
40// ep_send_events_data ç»“æ„ä¸­ï¼Œç„¶åè°ƒç”¨ ep_scan_ready_list å°†å°±ç»ªé˜Ÿåˆ—ä¸­çš„äº‹ä»¶å†™å…¥ç”¨æˆ·ç©ºé—´çš„å†…å­˜ï¼›
41// ç”¨æˆ·è¿›ç¨‹å°±å¯ä»¥è®¿é—®åˆ°è¿™äº›æ•°æ®è¿›è¡Œå¤„ç†
42static int ep_send_events(struct eventpoll *ep,
43				struct epoll_event __user *events, int maxevents)
44{
45	struct ep_send_events_data esed;
46
47	esed.maxevents = maxevents;
48	esed.events = events;
49	// è°ƒç”¨ ep_scan_ready_list å‡½æ•°æ£€æŸ¥ epoll å®ä¾‹ eventpoll ä¸­çš„ rdllist å°±ç»ªé“¾è¡¨ï¼Œ
50	// å¹¶æ³¨å†Œä¸€ä¸ªå›è°ƒå‡½æ•° ep_send_events_procï¼Œå¦‚æœæœ‰å°±ç»ª fdï¼Œåˆ™è°ƒç”¨ ep_send_events_proc è¿›è¡Œå¤„ç†
51	ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, 0, false);
52	return esed.res;
53}
54
55// è°ƒç”¨ ep_scan_ready_list çš„æ—¶å€™ä¼šä¼ é€’æŒ‡å‘ ep_send_events_proc å‡½æ•°çš„å‡½æ•°æŒ‡é’ˆä½œä¸ºå›è°ƒå‡½æ•°ï¼Œ
56// ä¸€æ—¦æœ‰å°±ç»ª fdï¼Œå°±ä¼šè°ƒç”¨ ep_send_events_proc å‡½æ•°
57static __poll_t ep_send_events_proc(struct eventpoll *ep, struct list_head *head, void *priv)
58{
59	â€¦
60<br />
61	/</em>
62	 * If the event mask intersect the caller-requested one,
63	 * deliver the event to userspace. Again, ep_scan_ready_list()
64	 * is holding ep-&gt;mtx, so no operations coming from userspace
65	 * can change the item.
66	 */
67	revents = ep_item_poll(epi, &amp;pt, 1);
68	// å¦‚æœ revents ä¸º 0ï¼Œè¯´æ˜æ²¡æœ‰å°±ç»ªçš„äº‹ä»¶ï¼Œè·³è¿‡ï¼Œå¦åˆ™å°±å°†å°±ç»ªäº‹ä»¶æ‹·è´åˆ°ç”¨æˆ·æ€å†…å­˜ä¸­
69	if (!revents)
70		continue;
71	// å°†å½“å‰å°±ç»ªçš„äº‹ä»¶å’Œç”¨æˆ·è¿›ç¨‹ä¼ å…¥çš„æ•°æ®éƒ½é€šè¿‡ __put_user æ‹·è´å›ç”¨æˆ·ç©ºé—´,
72	// ä¹Ÿå°±æ˜¯è°ƒç”¨ epoll_wait ä¹‹æ—¶ç”¨æˆ·è¿›ç¨‹ä¼ å…¥çš„ fd åˆ—è¡¨çš„å†…å­˜
73	if (__put_user(revents, &amp;uevent-&gt;events) || __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) {
74		list_add(&amp;epi-&gt;rdllink, head);
75		ep_pm_stay_awake(epi);
76		if (!esed-&gt;res)
77			esed-&gt;res = -EFAULT;
78		return 0;
79	}
80<br />
81	â€¦
82}
ä» do_epoll_wait å¼€å§‹å±‚å±‚è·³è½¬ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆæ¸…æ¥šåœ°çœ‹åˆ°æœ€åå†…æ ¸æ˜¯é€šè¿‡ __put_user å‡½æ•°æŠŠå°±ç»ª fd åˆ—è¡¨å’Œäº‹ä»¶è¿”å›åˆ°ç”¨æˆ·ç©ºé—´ï¼Œè€Œ __put_user æ­£æ˜¯å†…æ ¸ç”¨æ¥æ‹·è´æ•°æ®åˆ°ç”¨æˆ·ç©ºé—´çš„æ ‡å‡†å‡½æ•°ã€‚æ­¤å¤–ï¼Œæˆ‘å¹¶æ²¡æœ‰åœ¨ Linux kernel çš„æºç ä¸­å’Œ epoll ç›¸å…³çš„ä»£ç é‡Œæ‰¾åˆ° mmap ç³»ç»Ÿè°ƒç”¨åšå†…å­˜æ˜ å°„çš„é€»è¾‘ï¼Œæ‰€ä»¥åŸºæœ¬å¯ä»¥å¾—å‡ºç»“è®ºï¼šepoll åœ¨ Linux kernel é‡Œå¹¶æ²¡æœ‰ä½¿ç”¨ mmap æ¥åšç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´çš„å†…å­˜å…±äº«ï¼Œæ‰€ä»¥é‚£äº›è¯´ epoll ä½¿ç”¨äº† mmap çš„æ–‡ç« éƒ½æ˜¯è¯¯è§£ã€‚</p>

<p>Go netpoller æ ¸å¿ƒ
Go netpoller åŸºæœ¬åŸç†</p>

<p>Go netpoller é€šè¿‡åœ¨åº•å±‚å¯¹ epoll/kqueue/iocp çš„å°è£…ï¼Œä»è€Œå®ç°äº†ä½¿ç”¨åŒæ­¥ç¼–ç¨‹æ¨¡å¼è¾¾åˆ°å¼‚æ­¥æ‰§è¡Œçš„æ•ˆæœã€‚æ€»ç»“æ¥è¯´ï¼Œæ‰€æœ‰çš„ç½‘ç»œæ“ä½œéƒ½ä»¥ç½‘ç»œæè¿°ç¬¦ netFD ä¸ºä¸­å¿ƒå®ç°ã€‚netFD ä¸åº•å±‚ PollDesc ç»“æ„ç»‘å®šï¼Œå½“åœ¨ä¸€ä¸ª netFD ä¸Šè¯»å†™é‡åˆ° EAGAIN é”™è¯¯æ—¶ï¼Œå°±å°†å½“å‰ goroutine å­˜å‚¨åˆ°è¿™ä¸ª netFD å¯¹åº”çš„ PollDesc ä¸­ï¼ŒåŒæ—¶è°ƒç”¨ gopark æŠŠå½“å‰ goroutine ç»™ park ä½ï¼Œç›´åˆ°è¿™ä¸ª netFD ä¸Šå†æ¬¡å‘ç”Ÿè¯»å†™äº‹ä»¶ï¼Œæ‰å°†æ­¤ goroutine ç»™ ready æ¿€æ´»é‡æ–°è¿è¡Œã€‚æ˜¾ç„¶ï¼Œåœ¨åº•å±‚é€šçŸ¥ goroutine å†æ¬¡å‘ç”Ÿè¯»å†™ç­‰äº‹ä»¶çš„æ–¹å¼å°±æ˜¯ epoll/kqueue/iocp ç­‰äº‹ä»¶é©±åŠ¨æœºåˆ¶ã€‚</p>

<p>æ€»æ‰€å‘¨çŸ¥ï¼ŒGo æ˜¯ä¸€é—¨è·¨å¹³å°çš„ç¼–ç¨‹è¯­è¨€ï¼Œè€Œä¸åŒå¹³å°é’ˆå¯¹ç‰¹å®šçš„åŠŸèƒ½æœ‰ä¸ç”¨çš„å®ç°ï¼Œè¿™å½“ç„¶ä¹ŸåŒ…æ‹¬äº† I/O å¤šè·¯å¤ç”¨æŠ€æœ¯ï¼Œæ¯”å¦‚ Linux é‡Œçš„ I/O å¤šè·¯å¤ç”¨æœ‰ selectã€poll å’Œ epollï¼Œè€Œ freeBSD æˆ–è€… MacOS é‡Œåˆ™æ˜¯ kqueueï¼Œè€Œ Windows é‡Œåˆ™æ˜¯åŸºäºå¼‚æ­¥ I/O å®ç°çš„ iocpï¼Œç­‰ç­‰ï¼›å› æ­¤ï¼ŒGo ä¸ºäº†å®ç°åº•å±‚ I/O å¤šè·¯å¤ç”¨çš„è·¨å¹³å°ï¼Œåˆ†åˆ«åŸºäºä¸Šè¿°çš„è¿™äº›ä¸åŒå¹³å°çš„ç³»ç»Ÿè°ƒç”¨å®ç°äº†å¤šç‰ˆæœ¬çš„ netpollersï¼Œå…·ä½“çš„æºç è·¯å¾„å¦‚ä¸‹ï¼š</p>

<p>src/runtime/netpoll_epoll.go
src/runtime/netpoll_kqueue.go
src/runtime/netpoll_solaris.go
src/runtime/netpoll_windows.go
src/runtime/netpoll_aix.go
src/runtime/netpoll_fake.go
æœ¬æ–‡çš„è§£æåŸºäº epoll ç‰ˆæœ¬ï¼Œå¦‚æœè¯»è€…å¯¹å…¶ä»–å¹³å°çš„ netpoller åº•å±‚å®ç°æ„Ÿå…´è¶£ï¼Œå¯ä»¥åœ¨é˜…è¯»å®Œæœ¬æ–‡åè‡ªè¡Œç¿»é˜…å…¶ä»– netpoller æºç ï¼Œæ‰€æœ‰å®ç°ç‰ˆæœ¬çš„æœºåˆ¶å’ŒåŸç†åŸºæœ¬ç±»ä¼¼ï¼Œæ‰€ä»¥äº†è§£äº† epoll ç‰ˆæœ¬çš„å®ç°åå†å»å­¦ä¹ å…¶ä»–ç‰ˆæœ¬å®ç°åº”è¯¥æ²¡ä»€ä¹ˆéšœç¢ã€‚</p>

<p>æ¥ä¸‹æ¥è®©æˆ‘ä»¬é€šè¿‡åˆ†ææœ€æ–°çš„ Go æºç ï¼ˆv1.15.3ï¼‰ï¼Œå…¨é¢å‰–æä¸€ä¸‹æ•´ä¸ª Go netpoller çš„è¿è¡Œæœºåˆ¶å’Œæµç¨‹ã€‚</p>

<p>æ•°æ®ç»“æ„
netFD
net.Listen(â€œtcpâ€, â€œ:8888â€) æ–¹æ³•è¿”å›äº†ä¸€ä¸ª *TCPListenerï¼Œå®ƒæ˜¯ä¸€ä¸ªå®ç°äº† net.Listener æ¥å£çš„ structï¼Œè€Œé€šè¿‡ listener.Accept() æ¥æ”¶çš„æ–°è¿æ¥ *TCPConn åˆ™æ˜¯ä¸€ä¸ªå®ç°äº† net.Conn æ¥å£çš„ structï¼Œå®ƒå†…åµŒäº† net.conn structã€‚ä»”ç»†é˜…è¯»ä¸Šé¢çš„æºç å¯ä»¥å‘ç°ï¼Œä¸ç®¡æ˜¯ Listener çš„ Accept è¿˜æ˜¯ Conn çš„ Read/Write æ–¹æ³•ï¼Œéƒ½æ˜¯åŸºäºä¸€ä¸ª netFD çš„æ•°æ®ç»“æ„çš„æ“ä½œï¼Œ netFD æ˜¯ä¸€ä¸ªç½‘ç»œæè¿°ç¬¦ï¼Œç±»ä¼¼äº Linux çš„æ–‡ä»¶æè¿°ç¬¦çš„æ¦‚å¿µï¼ŒnetFD ä¸­åŒ…å«ä¸€ä¸ª poll.FD æ•°æ®ç»“æ„ï¼Œè€Œ poll.FD ä¸­åŒ…å«ä¸¤ä¸ªé‡è¦çš„æ•°æ®ç»“æ„ Sysfd å’Œ pollDescï¼Œå‰è€…æ˜¯çœŸæ­£çš„ç³»ç»Ÿæ–‡ä»¶æè¿°ç¬¦ï¼Œåè€…å¯¹æ˜¯åº•å±‚äº‹ä»¶é©±åŠ¨çš„å°è£…ï¼Œæ‰€æœ‰çš„è¯»å†™è¶…æ—¶ç­‰æ“ä½œéƒ½æ˜¯é€šè¿‡è°ƒç”¨åè€…çš„å¯¹åº”æ–¹æ³•å®ç°çš„ã€‚</p>

<p>netFD å’Œ poll.FD çš„æºç ï¼š</p>

<p>1// Network file descriptor.
 2type netFD struct {
 3	pfd poll.FD
 4
 5	// immutable until Close
 6	family      int
 7	sotype      int
 8	isConnected bool // handshake completed or use of association with peer
 9	net         string
10	laddr       Addr
11	raddr       Addr
12}
13
14// FD is a file descriptor. The net and os packages use this type as a
15// field of a larger type representing a network connection or OS file.
16type FD struct {
17	// Lock sysfd and serialize access to Read and Write methods.
18	fdmu fdMutex
19
20	// System file descriptor. Immutable until Close.
21	Sysfd int
22
23	// I/O poller.
24	pd pollDesc
25
26	// Writev cache.
27	iovecs *[]syscall.Iovec
28
29	// Semaphore signaled when file is closed.
30	csema uint32
31
32	// Non-zero if this file has been set to blocking mode.
33	isBlocking uint32
34
35	// Whether this is a streaming descriptor, as opposed to a
36	// packet-based descriptor like a UDP socket. Immutable.
37	IsStream bool
38
39	// Whether a zero byte read indicates EOF. This is false for a
40	// message based socket connection.
41	ZeroReadIsEOF bool
42
43	// Whether this is a file rather than a network socket.
44	isFile bool
45}
pollDesc
å‰é¢æåˆ°äº† pollDesc æ˜¯åº•å±‚äº‹ä»¶é©±åŠ¨çš„å°è£…ï¼ŒnetFD é€šè¿‡å®ƒæ¥å®Œæˆå„ç§ I/O ç›¸å…³çš„æ“ä½œï¼Œå®ƒçš„å®šä¹‰å¦‚ä¸‹ï¼š</p>

<p>1type pollDesc struct {
2	runtimeCtx uintptr
3}
è¿™é‡Œçš„ struct åªåŒ…å«äº†ä¸€ä¸ªæŒ‡é’ˆï¼Œè€Œé€šè¿‡ pollDesc çš„ init æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾åˆ°å®ƒå…·ä½“çš„å®šä¹‰æ˜¯åœ¨ runtime.pollDesc è¿™é‡Œï¼š</p>

<p>1func (pd *pollDesc) init(fd *FD) error {
 2	serverInit.Do(runtime_pollServerInit)
 3	ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))
 4	if errno != 0 {
 5		if ctx != 0 {
 6			runtime_pollUnblock(ctx)
 7			runtime_pollClose(ctx)
 8		}
 9		return syscall.Errno(errno)
10	}
11	pd.runtimeCtx = ctx
12	return nil
13}
14
15// Network poller descriptor.
16//
17// No heap pointers.
18//
19//go:notinheap
20type pollDesc struct {
21	link *pollDesc // in pollcache, protected by pollcache.lock
22
23	// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.
24	// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.
25	// pollReset, pollWait, pollWaitCanceled and runtimeÂ·netpollready (IO readiness notification)
26	// proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated
27	// in a lock-free way by all operations.
28	// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),
29	// that will blow up when GC starts moving objects.
30	lock    mutex // protects the following fields
31	fd      uintptr
32	closing bool
33	everr   bool    // marks event scanning error happened
34	user    uint32  // user settable cookie
35	rseq    uintptr // protects from stale read timers
36	rg      uintptr // pdReady, pdWait, G waiting for read or nil
37	rt      timer   // read deadline timer (set if rt.f != nil)
38	rd      int64   // read deadline
39	wseq    uintptr // protects from stale write timers
40	wg      uintptr // pdReady, pdWait, G waiting for write or nil
41	wt      timer   // write deadline timer
42	wd      int64   // write deadline
43}
è¿™é‡Œé‡ç‚¹å…³æ³¨é‡Œé¢çš„ rg å’Œ wgï¼Œè¿™é‡Œä¸¤ä¸ª uintptr â€œä¸‡èƒ½æŒ‡é’ˆâ€ç±»å‹ï¼Œå–å€¼åˆ†åˆ«å¯èƒ½æ˜¯ pdReadyã€pdWaitã€ç­‰å¾… file descriptor å°±ç»ªçš„ goroutine ä¹Ÿå°±æ˜¯ g æ•°æ®ç»“æ„ä»¥åŠ nilï¼Œå®ƒä»¬æ˜¯å®ç°å”¤é†’ goroutine çš„å…³é”®ã€‚</p>

<p>runtime.pollDesc åŒ…å«è‡ªèº«ç±»å‹çš„ä¸€ä¸ªæŒ‡é’ˆï¼Œç”¨æ¥ä¿å­˜ä¸‹ä¸€ä¸ª runtime.pollDesc çš„åœ°å€ï¼Œä»¥æ­¤æ¥å®ç°é“¾è¡¨ï¼Œå¯ä»¥å‡å°‘æ•°æ®ç»“æ„çš„å¤§å°ï¼Œæ‰€æœ‰çš„ runtime.pollDesc ä¿å­˜åœ¨ runtime.pollCache ç»“æ„ä¸­ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š</p>

<p>1type pollCache struct {
2	lock  mutex
3	first *pollDesc
4	// PollDesc objects must be type-stable,
5	// because we can get ready notification from epoll/kqueue
6	// after the descriptor is closed/reused.
7	// Stale notifications are detected using seq variable,
8	// seq is incremented when deadlines are changed or descriptor is reused.
9}
å› ä¸º runtime.pollCache æ˜¯ä¸€ä¸ªåœ¨ runtime åŒ…é‡Œçš„å…¨å±€å˜é‡ï¼Œå› æ­¤éœ€è¦ç”¨ä¸€ä¸ªäº’æ–¥é”æ¥é¿å… data race é—®é¢˜ï¼Œä»å®ƒçš„åå­—ä¹Ÿèƒ½çœ‹å‡ºè¿™æ˜¯ä¸€ä¸ªç”¨äºç¼“å­˜çš„æ•°æ®ç»“æ„ï¼Œä¹Ÿå°±æ˜¯ç”¨æ¥æé«˜æ€§èƒ½çš„ï¼Œå…·ä½“å¦‚ä½•å®ç°å‘¢ï¼Ÿ</p>

<p>1const pollBlockSize = 4 * 1024
 2
 3func (c <em>pollCache) alloc() *pollDesc {
 4	lock(&amp;c.lock)
 5	if c.first == nil {
 6		const pdSize = unsafe.Sizeof(pollDesc{})
 7		n := pollBlockSize / pdSize
 8		if n == 0 {
 9			n = 1
10		}
11		// Must be in non-GC memory because can be referenced
12		// only from epoll/kqueue internals.
13		mem := persistentalloc(n</em>pdSize, 0, &amp;memstats.other_sys)
14		for i := uintptr(0); i &lt; n; i++ {
15			pd := (<em>pollDesc)(add(mem, i</em>pdSize))
16			pd.link = c.first
17			c.first = pd
18		}
19	}
20	pd := c.first
21	c.first = pd.link
22	lockInit(&amp;pd.lock, lockRankPollDesc)
23	unlock(&amp;c.lock)
24	return pd
25}
Go runtime ä¼šåœ¨è°ƒç”¨ poll_runtime_pollOpen å¾€ epoll å®ä¾‹æ³¨å†Œ fd ä¹‹æ—¶é¦–æ¬¡è°ƒç”¨ runtime.pollCache.allocæ–¹æ³•æ—¶æ‰¹é‡åˆå§‹åŒ–å¤§å° 4KB çš„ runtime.pollDesc ç»“æ„ä½“çš„é“¾è¡¨ï¼Œåˆå§‹åŒ–è¿‡ç¨‹ä¸­ä¼šè°ƒç”¨ runtime.persistentalloc æ¥ä¸ºè¿™äº›æ•°æ®ç»“æ„åˆ†é…ä¸ä¼šè¢« GC å›æ”¶çš„å†…å­˜ï¼Œç¡®ä¿è¿™äº›æ•°æ®ç»“æ„åªèƒ½è¢« epollå’Œkqueue åœ¨å†…æ ¸ç©ºé—´å»å¼•ç”¨ã€‚</p>

<p>å†å¾€åæ¯æ¬¡è°ƒç”¨è¿™ä¸ªæ–¹æ³•åˆ™ä¼šå…ˆåˆ¤æ–­é“¾è¡¨å¤´æ˜¯å¦å·²ç»åˆ†é…è¿‡å€¼äº†ï¼Œè‹¥æ˜¯ï¼Œåˆ™ç›´æ¥è¿”å›è¡¨å¤´è¿™ä¸ª pollDescï¼Œè¿™ç§æ‰¹é‡åˆå§‹åŒ–æ•°æ®è¿›è¡Œç¼“å­˜è€Œåæ¯æ¬¡éƒ½ç›´æ¥ä»ç¼“å­˜å–æ•°æ®çš„æ–¹å¼æ˜¯ä¸€ç§å¾ˆå¸¸è§çš„æ€§èƒ½ä¼˜åŒ–æ‰‹æ®µï¼Œåœ¨è¿™é‡Œè¿™ç§æ–¹å¼å¯ä»¥æœ‰æ•ˆåœ°æå‡ netpoller çš„ååé‡ã€‚</p>

<p>Go runtime ä¼šåœ¨å…³é—­ pollDesc ä¹‹æ—¶è°ƒç”¨ runtime.pollCache.free é‡Šæ”¾å†…å­˜ï¼š</p>

<p>1func (c *pollCache) free(pd *pollDesc) {
2	lock(&amp;c.lock)
3	pd.link = c.first
4	c.first = pd
5	unlock(&amp;c.lock)
6}
å®ç°åŸç†
ä½¿ç”¨ Go ç¼–å†™ä¸€ä¸ªå…¸å‹çš„ TCP echo server:</p>

<p>1package main
 2
 3import (
 4	â€œlogâ€
 5	â€œnetâ€
 6)
 7
 8func main() {
 9	listen, err := net.Listen(â€œtcpâ€, â€œ:8888â€)
10	if err != nil {
11		log.Println(â€œlisten error: â€œ, err)
12		return
13	}
14
15	for {
16		conn, err := listen.Accept()
17		if err != nil {
18			log.Println(â€œaccept error: â€œ, err)
19			break
20		}
21
22		// start a new goroutine to handle the new connection.
23		go HandleConn(conn)
24	}
25}
26
27func HandleConn(conn net.Conn) {
28	defer conn.Close()
29	packet := make([]byte, 1024)
30	for {
31		// block here if socket is not available for reading data.
32		n, err := conn.Read(packet)
33		if err != nil {
34			log.Println(â€œread socket error: â€œ, err)
35			return
36		}
37
38		// same as above, block here if socket is not available for writing.
39		_, _ = conn.Write(packet[:n])
40	}
41}
ä¸Šé¢æ˜¯ä¸€ä¸ªåŸºäº Go åŸç”Ÿç½‘ç»œæ¨¡å‹ï¼ˆåŸºäº netpollerï¼‰ç¼–å†™çš„ä¸€ä¸ª TCP serverï¼Œæ¨¡å¼æ˜¯ goroutine-per-connection ï¼Œåœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼Œå¼€å‘è€…ä½¿ç”¨çš„æ˜¯åŒæ­¥çš„æ¨¡å¼å»ç¼–å†™å¼‚æ­¥çš„é€»è¾‘è€Œä¸”å¯¹äºå¼€å‘è€…æ¥è¯´ I/O æ˜¯å¦é˜»å¡æ˜¯æ— æ„ŸçŸ¥çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å¼€å‘è€…æ— éœ€è€ƒè™‘ goroutines ç”šè‡³æ›´åº•å±‚çš„çº¿ç¨‹ã€è¿›ç¨‹çš„è°ƒåº¦å’Œä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚è€Œ Go netpoller æœ€åº•å±‚çš„äº‹ä»¶é©±åŠ¨æŠ€æœ¯è‚¯å®šæ˜¯åŸºäº epoll/kqueue/iocp è¿™ä¸€ç±»çš„ I/O äº‹ä»¶é©±åŠ¨æŠ€æœ¯ï¼Œåªä¸è¿‡æ˜¯æŠŠè¿™äº›è°ƒåº¦å’Œä¸Šä¸‹æ–‡åˆ‡æ¢çš„å·¥ä½œè½¬ç§»åˆ°äº† runtime çš„ Go schedulerï¼Œè®©å®ƒæ¥è´Ÿè´£è°ƒåº¦ goroutinesï¼Œä»è€Œæå¤§åœ°é™ä½äº†ç¨‹åºå‘˜çš„å¿ƒæ™ºè´Ÿæ‹…ï¼</p>

<p>Go çš„è¿™ç§åŒæ­¥æ¨¡å¼çš„ç½‘ç»œæœåŠ¡å™¨çš„åŸºæœ¬æ¶æ„é€šå¸¸å¦‚ä¸‹ï¼š</p>

<p>ä¸Šé¢çš„ç¤ºä¾‹ä»£ç ä¸­ç›¸å…³çš„åœ¨æºç é‡Œçš„å‡ ä¸ªæ•°æ®ç»“æ„å’Œæ–¹æ³•ï¼š</p>

<p>1// TCPListener is a TCP network listener. Clients should typically
 2// use variables of type Listener instead of assuming TCP.
 3type TCPListener struct {
 4	fd <em>netFD
 5	lc ListenConfig
 6}
 7
 8// Accept implements the Accept method in the Listener interface; it
 9// waits for the next call and returns a generic Conn.
10func (l *TCPListener) Accept() (Conn, error) {
11	if !l.ok() {
12		return nil, syscall.EINVAL
13	}
14	c, err := l.accept()
15	if err != nil {
16		return nil, &amp;OpError{Op: â€œacceptâ€, Net: l.fd.net, Source: nil, Addr: l.fd.laddr, Err: err}
17	}
18	return c, nil
19}
20
21func (ln *TCPListener) accept() (</em>TCPConn, error) {
22	fd, err := ln.fd.accept()
23	if err != nil {
24		return nil, err
25	}
26	tc := newTCPConn(fd)
27	if ln.lc.KeepAlive &gt;= 0 {
28		setKeepAlive(fd, true)
29		ka := ln.lc.KeepAlive
30		if ln.lc.KeepAlive == 0 {
31			ka = defaultTCPKeepAlive
32		}
33		setKeepAlivePeriod(fd, ka)
34	}
35	return tc, nil
36}
37
38// TCPConn is an implementation of the Conn interface for TCP network
39// connections.
40type TCPConn struct {
41	conn
42}
43
44// Conn
45type conn struct {
46	fd *netFD
47}
48
49type conn struct {
50	fd *netFD
51}
52
53func (c *conn) ok() bool { return c != nil &amp;&amp; c.fd != nil }
54
55// Implementation of the Conn interface.
56
57// Read implements the Conn Read method.
58func (c *conn) Read(b []byte) (int, error) {
59	if !c.ok() {
60		return 0, syscall.EINVAL
61	}
62	n, err := c.fd.Read(b)
63	if err != nil &amp;&amp; err != io.EOF {
64		err = &amp;OpError{Op: â€œreadâ€, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
65	}
66	return n, err
67}
68
69// Write implements the Conn Write method.
70func (c *conn) Write(b []byte) (int, error) {
71	if !c.ok() {
72		return 0, syscall.EINVAL
73	}
74	n, err := c.fd.Write(b)
75	if err != nil {
76		err = &amp;OpError{Op: â€œwriteâ€, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
77	}
78	return n, err
79}
net.Listen
è°ƒç”¨ net.Listen ä¹‹åï¼Œåº•å±‚ä¼šé€šè¿‡ Linux çš„ç³»ç»Ÿè°ƒç”¨ socket æ–¹æ³•åˆ›å»ºä¸€ä¸ª fd åˆ†é…ç»™ listenerï¼Œå¹¶ç”¨ä»¥æ¥åˆå§‹åŒ– listener çš„ netFD ï¼Œæ¥ç€è°ƒç”¨ netFD çš„ listenStream æ–¹æ³•å®Œæˆå¯¹ socket çš„ bind&amp;listen æ“ä½œä»¥åŠå¯¹ netFD çš„åˆå§‹åŒ–ï¼ˆä¸»è¦æ˜¯å¯¹ netFD é‡Œçš„ pollDesc çš„åˆå§‹åŒ–ï¼‰ï¼Œè°ƒç”¨é“¾æ˜¯ runtime.runtime_pollServerInit â€“&gt; runtime.poll_runtime_pollServerInit â€“&gt; runtime.netpollGenericInitï¼Œä¸»è¦åšçš„äº‹æƒ…æ˜¯ï¼š</p>

<p>è°ƒç”¨ epollcreate1 åˆ›å»ºä¸€ä¸ª epoll å®ä¾‹ epfdï¼Œä½œä¸ºæ•´ä¸ª runtime çš„å”¯ä¸€ event-loop ä½¿ç”¨ï¼›
è°ƒç”¨ runtime.nonblockingPipe åˆ›å»ºä¸€ä¸ªç”¨äºå’Œ epoll å®ä¾‹é€šä¿¡çš„ç®¡é“ï¼Œè¿™é‡Œä¸ºä»€ä¹ˆä¸ç”¨æ›´æ–°ä¸”æ›´è½»é‡çš„ eventfd å‘¢ï¼Ÿæˆ‘ä¸ªäººçŒœæµ‹æ˜¯ä¸ºäº†å…¼å®¹æ›´å¤šä»¥åŠæ›´è€çš„ç³»ç»Ÿç‰ˆæœ¬ï¼›
å°† netpollBreakRd é€šçŸ¥ä¿¡å·é‡å°è£…æˆ epollevent äº‹ä»¶ç»“æ„ä½“æ³¨å†Œè¿› epoll å®ä¾‹ã€‚
ç›¸å…³æºç å¦‚ä¸‹ï¼š</p>

<p>1// è°ƒç”¨ linux ç³»ç»Ÿè°ƒç”¨ socket åˆ›å»º listener fd å¹¶è®¾ç½®ä¸ºä¸ºé˜»å¡ I/O
  2s, err := socketFunc(family, sotype|syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC, proto)
  3// On Linux the SOCK_NONBLOCK and SOCK_CLOEXEC flags were
  4// introduced in 2.6.27 kernel and on FreeBSD both flags were
  5// introduced in 10 kernel. If we get an EINVAL error on Linux
  6// or EPROTONOSUPPORT error on FreeBSD, fall back to using
  7// socket without them.
  8
  9socketFunc        func(int, int, int) (int, error)  = syscall.Socket
 10
 11// ç”¨ä¸Šé¢åˆ›å»ºçš„ listener fd åˆå§‹åŒ– listener netFD
 12if fd, err = newFD(s, family, sotype, net); err != nil {
 13	poll.CloseFunc(s)
 14	return nil, err
 15}
 16
 17// å¯¹ listener fd è¿›è¡Œ bind&amp;listen æ“ä½œï¼Œå¹¶ä¸”è°ƒç”¨ init æ–¹æ³•å®Œæˆåˆå§‹åŒ–
 18func (fd *netFD) listenStream(laddr sockaddr, backlog int, ctrlFn func(string, string, syscall.RawConn) error) error {
 19	â€¦
 20<br />
 21	// å®Œæˆç»‘å®šæ“ä½œ
 22	if err = syscall.Bind(fd.pfd.Sysfd, lsa); err != nil {
 23		return os.NewSyscallError(â€œbindâ€, err)
 24	}
 25<br />
 26	// å®Œæˆç›‘å¬æ“ä½œ
 27	if err = listenFunc(fd.pfd.Sysfd, backlog); err != nil {
 28		return os.NewSyscallError(â€œlistenâ€, err)
 29	}
 30<br />
 31	// è°ƒç”¨ initï¼Œå†…éƒ¨ä¼šè°ƒç”¨ poll.FD.Initï¼Œæœ€åè°ƒç”¨ pollDesc.init
 32	if err = fd.init(); err != nil {
 33		return err
 34	}
 35	lsa, _ = syscall.Getsockname(fd.pfd.Sysfd)
 36	fd.setAddr(fd.addrFunc()(lsa), nil)
 37	return nil
 38}
 39
 40// ä½¿ç”¨ sync.Once æ¥ç¡®ä¿ä¸€ä¸ª listener åªæŒæœ‰ä¸€ä¸ª epoll å®ä¾‹
 41var serverInit sync.Once
 42
 43// netFD.init ä¼šè°ƒç”¨ poll.FD.Init å¹¶æœ€ç»ˆè°ƒç”¨åˆ° pollDesc.initï¼Œ
 44// å®ƒä¼šåˆ›å»º epoll å®ä¾‹å¹¶æŠŠ listener fd åŠ å…¥ç›‘å¬é˜Ÿåˆ—
 45func (pd *pollDesc) init(fd *FD) error {
 46	// runtime_pollServerInit é€šè¿‡ <code class="language-plaintext highlighter-rouge">go:linkname</code> é“¾æ¥åˆ°å…·ä½“çš„å®ç°å‡½æ•° poll_runtime_pollServerInitï¼Œ
 47	// æ¥ç€å†è°ƒç”¨ netpollGenericInitï¼Œç„¶åä¼šæ ¹æ®ä¸åŒçš„ç³»ç»Ÿå¹³å°å»è°ƒç”¨ç‰¹å®šçš„ netpollinit æ¥åˆ›å»º epoll å®ä¾‹
 48	serverInit.Do(runtime_pollServerInit)
 49<br />
 50	// runtime_pollOpen å†…éƒ¨è°ƒç”¨äº† netpollopen æ¥å°† listener fd æ³¨å†Œåˆ° 
 51	// epoll å®ä¾‹ä¸­ï¼Œå¦å¤–ï¼Œå®ƒä¼šåˆå§‹åŒ–ä¸€ä¸ª pollDesc å¹¶è¿”å›
 52	ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))
 53	if errno != 0 {
 54		if ctx != 0 {
 55			runtime_pollUnblock(ctx)
 56			runtime_pollClose(ctx)
 57		}
 58		return syscall.Errno(errno)
 59	}
 60	// æŠŠçœŸæ­£åˆå§‹åŒ–å®Œæˆçš„ pollDesc å®ä¾‹èµ‹å€¼ç»™å½“å‰çš„ pollDesc ä»£è¡¨è‡ªèº«çš„æŒ‡é’ˆï¼Œ
 61	// åç»­ä½¿ç”¨ç›´æ¥é€šè¿‡è¯¥æŒ‡é’ˆæ“ä½œ
 62	pd.runtimeCtx = ctx
 63	return nil
 64}
 65
 66var (
 67	// å…¨å±€å”¯ä¸€çš„ epoll fdï¼Œåªåœ¨ listener fd åˆå§‹åŒ–ä¹‹æ—¶è¢«æŒ‡å®šä¸€æ¬¡
 68	epfd int32 = -1 // epoll descriptor
 69)
 70
 71// netpollinit ä¼šåˆ›å»ºä¸€ä¸ª epoll å®ä¾‹ï¼Œç„¶åæŠŠ epoll fd èµ‹å€¼ç»™ epfdï¼Œ
 72// åç»­ listener ä»¥åŠå®ƒ accept çš„æ‰€æœ‰ sockets æœ‰å…³ epoll çš„æ“ä½œéƒ½æ˜¯åŸºäºè¿™ä¸ªå…¨å±€çš„ epfd
 73func netpollinit() {
 74	epfd = epollcreate1(_EPOLL_CLOEXEC)
 75	if epfd &lt; 0 {
 76		epfd = epollcreate(1024)
 77		if epfd &lt; 0 {
 78			println(â€œruntime: epollcreate failed withâ€, -epfd)
 79			throw(â€œruntime: netpollinit failedâ€)
 80		}
 81		closeonexec(epfd)
 82	}
 83	r, w, errno := nonblockingPipe()
 84	if errno != 0 {
 85		println(â€œruntime: pipe failed withâ€, -errno)
 86		throw(â€œruntime: pipe failedâ€)
 87	}
 88	ev := epollevent{
 89		events: _EPOLLIN,
 90	}
 91	*(<strong>uintptr)(unsafe.Pointer(&amp;ev.data)) = &amp;netpollBreakRd
 92	errno = epollctl(epfd, _EPOLL_CTL_ADD, r, &amp;ev)
 93	if errno != 0 {
 94		println(â€œruntime: epollctl failed withâ€, -errno)
 95		throw(â€œruntime: epollctl failedâ€)
 96	}
 97	netpollBreakRd = uintptr(r)
 98	netpollBreakWr = uintptr(w)
 99}
100
101// netpollopen ä¼šè¢« runtime_pollOpen è°ƒç”¨ï¼Œæ³¨å†Œ fd åˆ° epoll å®ä¾‹ï¼Œ
102// æ³¨æ„è¿™é‡Œä½¿ç”¨çš„æ˜¯ epoll çš„ ET æ¨¡å¼ï¼ŒåŒæ—¶ä¼šåˆ©ç”¨ä¸‡èƒ½æŒ‡é’ˆæŠŠ pollDesc ä¿å­˜åˆ° epollevent çš„ä¸€ä¸ª 8 ä½çš„å­—èŠ‚æ•°ç»„ data é‡Œ
103func netpollopen(fd uintptr, pd *pollDesc) int32 {
104	var ev epollevent
105	ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET
106	*(</strong>pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd
107	return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;ev)
108}
æˆ‘ä»¬å‰é¢æåˆ°çš„ epoll çš„ä¸‰ä¸ªåŸºæœ¬è°ƒç”¨ï¼ŒGo åœ¨æºç é‡Œå®ç°äº†å¯¹é‚£ä¸‰ä¸ªè°ƒç”¨çš„å°è£…ï¼š</p>

<p>1#include &lt;sys/epoll.h&gt;<br />
2int epoll_create(int size);<br />
3int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);<br />
4int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
5
6// Go å¯¹ä¸Šé¢ä¸‰ä¸ªè°ƒç”¨çš„å°è£…
7func netpollinit()
8func netpollopen(fd uintptr, pd *pollDesc) int32
9func netpoll(block bool) gList
netFD å°±æ˜¯é€šè¿‡è¿™ä¸‰ä¸ªå°è£…æ¥å¯¹ epoll è¿›è¡Œåˆ›å»ºå®ä¾‹ã€æ³¨å†Œ fd å’Œç­‰å¾…äº‹ä»¶æ“ä½œçš„ã€‚</p>

<p>Listener.Accept()
netpoll accept socket çš„å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š</p>

<p>æœåŠ¡ç«¯çš„ netFD åœ¨ listen æ—¶ä¼šåˆ›å»º epoll çš„å®ä¾‹ï¼Œå¹¶å°† listenerFD åŠ å…¥ epoll çš„äº‹ä»¶é˜Ÿåˆ—
netFD åœ¨ accept æ—¶å°†è¿”å›çš„ connFD ä¹ŸåŠ å…¥ epoll çš„äº‹ä»¶é˜Ÿåˆ—
netFD åœ¨è¯»å†™æ—¶å‡ºç° syscall.EAGAIN é”™è¯¯ï¼Œé€šè¿‡ pollDesc çš„ waitRead æ–¹æ³•å°†å½“å‰çš„ goroutine park ä½ï¼Œç›´åˆ° readyï¼Œä» pollDesc çš„ waitRead ä¸­è¿”å›
Listener.Accept() æ¥æ”¶æ¥è‡ªå®¢æˆ·ç«¯çš„æ–°è¿æ¥ï¼Œå…·ä½“è¿˜æ˜¯è°ƒç”¨ netFD.accept æ–¹æ³•æ¥å®Œæˆè¿™ä¸ªåŠŸèƒ½ï¼š</p>

<p>1// Accept implements the Accept method in the Listener interface; it
 2// waits for the next call and returns a generic Conn.
 3func (l <em>TCPListener) Accept() (Conn, error) {
 4	if !l.ok() {
 5		return nil, syscall.EINVAL
 6	}
 7	c, err := l.accept()
 8	if err != nil {
 9		return nil, &amp;OpError{Op: â€œacceptâ€, Net: l.fd.net, Source: nil, Addr: l.fd.laddr, Err: err}
10	}
11	return c, nil
12}
13
14func (ln *TCPListener) accept() (</em>TCPConn, error) {
15	fd, err := ln.fd.accept()
16	if err != nil {
17		return nil, err
18	}
19	tc := newTCPConn(fd)
20	if ln.lc.KeepAlive &gt;= 0 {
21		setKeepAlive(fd, true)
22		ka := ln.lc.KeepAlive
23		if ln.lc.KeepAlive == 0 {
24			ka = defaultTCPKeepAlive
25		}
26		setKeepAlivePeriod(fd, ka)
27	}
28	return tc, nil
29}
30
31func (fd *netFD) accept() (netfd *netFD, err error) {
32	// è°ƒç”¨ poll.FD çš„ Accept æ–¹æ³•æ¥å—æ–°çš„ socket è¿æ¥ï¼Œè¿”å› socket çš„ fd
33	d, rsa, errcall, err := fd.pfd.Accept()
34	if err != nil {
35		if errcall != â€œâ€ {
36			err = wrapSyscallError(errcall, err)
37		}
38		return nil, err
39	}
40	// ä»¥ socket fd æ„é€ ä¸€ä¸ªæ–°çš„ netFDï¼Œä»£è¡¨è¿™ä¸ªæ–°çš„ socket
41	if netfd, err = newFD(d, fd.family, fd.sotype, fd.net); err != nil {
42		poll.CloseFunc(d)
43		return nil, err
44	}
45	// è°ƒç”¨ netFD çš„ init æ–¹æ³•å®Œæˆåˆå§‹åŒ–
46	if err = netfd.init(); err != nil {
47		fd.Close()
48		return nil, err
49	}
50	lsa, _ := syscall.Getsockname(netfd.pfd.Sysfd)
51	netfd.setAddr(netfd.addrFunc()(lsa), netfd.addrFunc()(rsa))
52	return netfd, nil
53}
netFD.accept æ–¹æ³•é‡Œä¼šå†è°ƒç”¨ poll.FD.Accept ï¼Œæœ€åä¼šä½¿ç”¨ Linux çš„ç³»ç»Ÿè°ƒç”¨ accept æ¥å®Œæˆæ–°è¿æ¥çš„æ¥æ”¶ï¼Œå¹¶ä¸”ä¼šæŠŠ accept çš„ socket è®¾ç½®æˆéé˜»å¡ I/O æ¨¡å¼ï¼š</p>

<p>1// Accept wraps the accept network call.
 2func (fd *FD) Accept() (int, syscall.Sockaddr, string, error) {
 3	if err := fd.readLock(); err != nil {
 4		return -1, nil, â€œâ€, err
 5	}
 6	defer fd.readUnlock()
 7
 8	if err := fd.pd.prepareRead(fd.isFile); err != nil {
 9		return -1, nil, â€œâ€, err
10	}
11	for {
12		// ä½¿ç”¨ linux ç³»ç»Ÿè°ƒç”¨ accept æ¥æ”¶æ–°è¿æ¥ï¼Œåˆ›å»ºå¯¹åº”çš„ socket
13		s, rsa, errcall, err := accept(fd.Sysfd)
14		// å› ä¸º listener fd åœ¨åˆ›å»ºçš„æ—¶å€™å·²ç»è®¾ç½®æˆéé˜»å¡çš„äº†ï¼Œ
15		// æ‰€ä»¥ accept æ–¹æ³•ä¼šç›´æ¥è¿”å›ï¼Œä¸ç®¡æœ‰æ²¡æœ‰æ–°è¿æ¥åˆ°æ¥ï¼›å¦‚æœ err == nil åˆ™è¡¨ç¤ºæ­£å¸¸å»ºç«‹æ–°è¿æ¥ï¼Œç›´æ¥è¿”å›
16		if err == nil {
17			return s, rsa, â€œâ€, err
18		}
19		// å¦‚æœ err != nilï¼Œåˆ™åˆ¤æ–­ err == syscall.EAGAINï¼Œç¬¦åˆæ¡ä»¶åˆ™è¿›å…¥ pollDesc.waitRead æ–¹æ³•
20		switch err {
21		case syscall.EAGAIN:
22			if fd.pd.pollable() {
23				// å¦‚æœå½“å‰æ²¡æœ‰å‘ç”ŸæœŸå¾…çš„ I/O äº‹ä»¶ï¼Œé‚£ä¹ˆ waitRead ä¼šé€šè¿‡ park goroutine è®©é€»è¾‘ block åœ¨è¿™é‡Œ
24				if err = fd.pd.waitRead(fd.isFile); err == nil {
25					continue
26				}
27			}
28		case syscall.ECONNABORTED:
29			// This means that a socket on the listen
30			// queue was closed before we Accept()ed it;
31			// itâ€™s a silly error, so try again.
32			continue
33		}
34		return -1, nil, errcall, err
35	}
36}
37
38// ä½¿ç”¨ linux çš„ accept ç³»ç»Ÿè°ƒç”¨æ¥æ”¶æ–°è¿æ¥å¹¶æŠŠè¿™ä¸ª socket fd è®¾ç½®æˆéé˜»å¡ I/O
39ns, sa, err := Accept4Func(s, syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC)
40// On Linux the accept4 system call was introduced in 2.6.28
41// kernel and on FreeBSD it was introduced in 10 kernel. If we
42// get an ENOSYS error on both Linux and FreeBSD, or EINVAL
43// error on Linux, fall back to using accept.
44
45// Accept4Func is used to hook the accept4 call.
46var Accept4Func func(int, int) (int, syscall.Sockaddr, error) = syscall.Accept4
pollDesc.waitRead æ–¹æ³•ä¸»è¦è´Ÿè´£æ£€æµ‹å½“å‰è¿™ä¸ª pollDesc çš„ä¸Šå±‚ netFD å¯¹åº”çš„ fd æ˜¯å¦æœ‰ã€æœŸå¾…çš„ã€I/O äº‹ä»¶å‘ç”Ÿï¼Œå¦‚æœæœ‰å°±ç›´æ¥è¿”å›ï¼Œå¦åˆ™å°± park ä½å½“å‰çš„ goroutine å¹¶æŒç»­ç­‰å¾…ç›´è‡³å¯¹åº”çš„ fd ä¸Šå‘ç”Ÿå¯è¯»/å¯å†™æˆ–è€…å…¶ä»–ã€æœŸå¾…çš„ã€I/O äº‹ä»¶ä¸ºæ­¢ï¼Œç„¶åå®ƒå°±ä¼šè¿”å›åˆ°å¤–å±‚çš„ for å¾ªç¯ï¼Œè®© goroutine ç»§ç»­æ‰§è¡Œé€»è¾‘ã€‚</p>

<p>poll.FD.Accept() è¿”å›ä¹‹åï¼Œä¼šæ„é€ ä¸€ä¸ªå¯¹åº”è¿™ä¸ªæ–° socket çš„ netFDï¼Œç„¶åè°ƒç”¨ init() æ–¹æ³•å®Œæˆåˆå§‹åŒ–ï¼Œè¿™ä¸ª init è¿‡ç¨‹å’Œå‰é¢ net.Listen() æ˜¯ä¸€æ ·çš„ï¼Œè°ƒç”¨é“¾ï¼šnetFD.init() â€“&gt; poll.FD.Init() â€“&gt; poll.pollDesc.init()ï¼Œæœ€ç»ˆåˆä¼šèµ°åˆ°è¿™é‡Œï¼š</p>

<p>1var serverInit sync.Once
 2
 3func (pd *pollDesc) init(fd *FD) error {
 4	serverInit.Do(runtime_pollServerInit)
 5	ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))
 6	if errno != 0 {
 7		if ctx != 0 {
 8			runtime_pollUnblock(ctx)
 9			runtime_pollClose(ctx)
10		}
11		return syscall.Errno(errno)
12	}
13	pd.runtimeCtx = ctx
14	return nil
15}
ç„¶åæŠŠè¿™ä¸ª socket fd æ³¨å†Œåˆ° listener çš„ epoll å®ä¾‹çš„äº‹ä»¶é˜Ÿåˆ—ä¸­å»ï¼Œç­‰å¾… I/O äº‹ä»¶ã€‚</p>

<p>Conn.Read/Conn.Write
æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹ Conn.Read æ–¹æ³•æ˜¯å¦‚ä½•å®ç°çš„ï¼ŒåŸç†å…¶å®å’Œ Listener.Accept æ˜¯ä¸€æ ·çš„ï¼Œå…·ä½“è°ƒç”¨é“¾è¿˜æ˜¯é¦–å…ˆè°ƒç”¨ conn çš„ netFD.Read ï¼Œç„¶åå†…éƒ¨å†è°ƒç”¨ poll.FD.Read ï¼Œæœ€åä½¿ç”¨ Linux çš„ç³»ç»Ÿè°ƒç”¨ read: syscall.Read å®Œæˆæ•°æ®è¯»å–ï¼š</p>

<p>1// Implementation of the Conn interface.
 2
 3// Read implements the Conn Read method.
 4func (c *conn) Read(b []byte) (int, error) {
 5	if !c.ok() {
 6		return 0, syscall.EINVAL
 7	}
 8	n, err := c.fd.Read(b)
 9	if err != nil &amp;&amp; err != io.EOF {
10		err = &amp;OpError{Op: â€œreadâ€, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}
11	}
12	return n, err
13}
14
15func (fd *netFD) Read(p []byte) (n int, err error) {
16	n, err = fd.pfd.Read(p)
17	runtime.KeepAlive(fd)
18	return n, wrapSyscallError(â€œreadâ€, err)
19}
20
21// Read implements io.Reader.
22func (fd *FD) Read(p []byte) (int, error) {
23	if err := fd.readLock(); err != nil {
24		return 0, err
25	}
26	defer fd.readUnlock()
27	if len(p) == 0 {
28		// If the caller wanted a zero byte read, return immediately
29		// without trying (but after acquiring the readLock).
30		// Otherwise syscall.Read returns 0, nil which looks like
31		// io.EOF.
32		// TODO(bradfitz): make it wait for readability? (Issue 15735)
33		return 0, nil
34	}
35	if err := fd.pd.prepareRead(fd.isFile); err != nil {
36		return 0, err
37	}
38	if fd.IsStream &amp;&amp; len(p) &gt; maxRW {
39		p = p[:maxRW]
40	}
41	for {
42		// å°è¯•ä»è¯¥ socket è¯»å–æ•°æ®ï¼Œå› ä¸º socket åœ¨è¢« listener accept çš„æ—¶å€™è®¾ç½®æˆ
43		// äº†éé˜»å¡ I/Oï¼Œæ‰€ä»¥è¿™é‡ŒåŒæ ·ä¹Ÿæ˜¯ç›´æ¥è¿”å›ï¼Œä¸ç®¡æœ‰æ²¡æœ‰å¯è¯»çš„æ•°æ®
44		n, err := syscall.Read(fd.Sysfd, p)
45		if err != nil {
46			n = 0
47			// err == syscall.EAGAIN è¡¨ç¤ºå½“å‰æ²¡æœ‰æœŸå¾…çš„ I/O äº‹ä»¶å‘ç”Ÿï¼Œä¹Ÿå°±æ˜¯ socket ä¸å¯è¯»
48			if err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() {
49				// å¦‚æœå½“å‰æ²¡æœ‰å‘ç”ŸæœŸå¾…çš„ I/O äº‹ä»¶ï¼Œé‚£ä¹ˆ waitRead
50				// ä¼šé€šè¿‡ park goroutine è®©é€»è¾‘ block åœ¨è¿™é‡Œ
51				if err = fd.pd.waitRead(fd.isFile); err == nil {
52					continue
53				}
54			}
55
56			// On MacOS we can see EINTR here if the user
57			// pressed ^Z.  See issue #22838.
58			if runtime.GOOS == â€œdarwinâ€ &amp;&amp; err == syscall.EINTR {
59				continue
60			}
61		}
62		err = fd.eofError(n, err)
63		return n, err
64	}
65}
conn.Write å’Œ conn.Read çš„åŸç†æ˜¯ä¸€è‡´çš„ï¼Œå®ƒä¹Ÿæ˜¯é€šè¿‡ç±»ä¼¼ pollDesc.waitRead çš„ pollDesc.waitWrite æ¥ park ä½ goroutine ç›´è‡³æœŸå¾…çš„ I/O äº‹ä»¶å‘ç”Ÿæ‰è¿”å›æ¢å¤æ‰§è¡Œã€‚</p>

<p>pollDesc.waitRead/pollDesc.waitWrite
pollDesc.waitRead å†…éƒ¨è°ƒç”¨äº† poll.runtime_pollWait â€“&gt; runtime.poll_runtime_pollWait æ¥è¾¾æˆæ—  I/O äº‹ä»¶æ—¶ park ä½ goroutine çš„ç›®çš„ï¼š</p>

<p>1//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait
  2func poll_runtime_pollWait(pd <em>pollDesc, mode int) int {
  3	err := netpollcheckerr(pd, int32(mode))
  4	if err != pollNoError {
  5		return err
  6	}
  7	// As for now only Solaris, illumos, and AIX use level-triggered IO.
  8	if GOOS == â€œsolarisâ€ || GOOS == â€œillumosâ€ || GOOS == â€œaixâ€ {
  9		netpollarm(pd, mode)
 10	}
 11	// è¿›å…¥ netpollblock å¹¶ä¸”åˆ¤æ–­æ˜¯å¦æœ‰æœŸå¾…çš„ I/O äº‹ä»¶å‘ç”Ÿï¼Œ
 12	// è¿™é‡Œçš„ for å¾ªç¯æ˜¯ä¸ºäº†ä¸€ç›´ç­‰åˆ° io ready
 13	for !netpollblock(pd, int32(mode), false) {
 14		err = netpollcheckerr(pd, int32(mode))
 15		if err != 0 {
 16			return err
 17		}
 18		// Can happen if timeout has fired and unblocked us,
 19		// but before we had a chance to run, timeout has been reset.
 20		// Pretend it has not happened and retry.
 21	}
 22	return 0
 23}
 24
 25// returns true if IO is ready, or false if timedout or closed
 26// waitio - wait only for completed IO, ignore errors
 27func netpollblock(pd *pollDesc, mode int32, waitio bool) bool {
 28	// gpp ä¿å­˜çš„æ˜¯ goroutine çš„æ•°æ®ç»“æ„ gï¼Œè¿™é‡Œä¼šæ ¹æ® mode çš„å€¼å†³å®šæ˜¯ rg è¿˜æ˜¯ wgï¼Œ
 29	// å‰é¢æåˆ°è¿‡ï¼Œrg å’Œ wg æ˜¯ç”¨æ¥ä¿å­˜ç­‰å¾… I/O å°±ç»ªçš„ gorouine çš„ï¼Œåé¢è°ƒç”¨ gopark ä¹‹åï¼Œ
 30	// ä¼šæŠŠå½“å‰çš„ goroutine çš„æŠ½è±¡æ•°æ®ç»“æ„ g å­˜å…¥ gpp è¿™ä¸ªæŒ‡é’ˆï¼Œä¹Ÿå°±æ˜¯ rg æˆ–è€… wg
 31	gpp := &amp;pd.rg
 32	if mode == â€˜wâ€™ {
 33		gpp = &amp;pd.wg
 34	}
 35
 36	// set the gpp semaphore to WAIT
 37	// è¿™ä¸ª for å¾ªç¯æ˜¯ä¸ºäº†ç­‰å¾… io ready æˆ–è€… io wait
 38	for {
 39		old := *gpp
 40		// gpp == pdReady è¡¨ç¤ºæ­¤æ—¶å·²æœ‰æœŸå¾…çš„ I/O äº‹ä»¶å‘ç”Ÿï¼Œ
 41		// å¯ä»¥ç›´æ¥è¿”å› unblock å½“å‰ goroutine å¹¶æ‰§è¡Œå“åº”çš„ I/O æ“ä½œ
 42		if old == pdReady {
 43			*gpp = 0
 44			return true
 45		}
 46		if old != 0 {
 47			throw(â€œruntime: double waitâ€)
 48		}
 49		// å¦‚æœæ²¡æœ‰æœŸå¾…çš„ I/O äº‹ä»¶å‘ç”Ÿï¼Œåˆ™é€šè¿‡åŸå­æ“ä½œæŠŠ gpp çš„å€¼ç½®ä¸º pdWait å¹¶é€€å‡º for å¾ªç¯
 50		if atomic.Casuintptr(gpp, 0, pdWait) {
 51			break
 52		}
 53	}
 54
 55	// need to recheck error states after setting gpp to WAIT
 56	// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl
 57	// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg
 58
 59	// waitio æ­¤æ—¶æ˜¯ falseï¼Œnetpollcheckerr æ–¹æ³•ä¼šæ£€æŸ¥å½“å‰ pollDesc å¯¹åº”çš„ fd æ˜¯å¦æ˜¯æ­£å¸¸çš„ï¼Œ
 60	// é€šå¸¸æ¥è¯´  netpollcheckerr(pd, mode) == 0 æ˜¯æˆç«‹çš„ï¼Œæ‰€ä»¥è¿™é‡Œä¼šæ‰§è¡Œ gopark
 61	// æŠŠå½“å‰ goroutine ç»™ park ä½ï¼Œç›´è‡³å¯¹åº”çš„ fd ä¸Šå‘ç”Ÿå¯è¯»/å¯å†™æˆ–è€…å…¶ä»–ã€æœŸå¾…çš„ã€I/O äº‹ä»¶ä¸ºæ­¢ï¼Œ
 62	// ç„¶å unpark è¿”å›ï¼Œåœ¨ gopark å†…éƒ¨ä¼šæŠŠå½“å‰ goroutine çš„æŠ½è±¡æ•°æ®ç»“æ„ g å­˜å…¥
 63	// gpp(pollDesc.rg/pollDesc.wg) æŒ‡é’ˆé‡Œï¼Œä»¥ä¾¿åœ¨åé¢çš„ netpoll å‡½æ•°å–å‡º pollDesc ä¹‹åï¼Œ
 64	// æŠŠ g æ·»åŠ åˆ°é“¾è¡¨é‡Œè¿”å›ï¼Œæ¥ç€é‡æ–°è°ƒåº¦ goroutine
 65	if waitio || netpollcheckerr(pd, mode) == 0 {
 66		// æ³¨å†Œ netpollblockcommit å›è°ƒç»™ goparkï¼Œåœ¨ gopark å†…éƒ¨ä¼šæ‰§è¡Œå®ƒï¼Œä¿å­˜å½“å‰ goroutine åˆ° gpp
 67		gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5)
 68	}
 69	// be careful to not lose concurrent READY notification
 70	old := atomic.Xchguintptr(gpp, 0)
 71	if old &gt; pdWait {
 72		throw(â€œruntime: corrupted polldescâ€)
 73	}
 74	return old == pdReady
 75}
 76
 77// gopark ä¼šåœä½å½“å‰çš„ goroutine å¹¶ä¸”è°ƒç”¨ä¼ é€’è¿›æ¥çš„å›è°ƒå‡½æ•° unlockfï¼Œä»ä¸Šé¢çš„æºç æˆ‘ä»¬å¯ä»¥çŸ¥é“è¿™ä¸ªå‡½æ•°æ˜¯
 78// netpollblockcommit
 79func gopark(unlockf func(</em>g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {
 80	if reason != waitReasonSleep {
 81		checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy
 82	}
 83	mp := acquirem()
 84	gp := mp.curg
 85	status := readgstatus(gp)
 86	if status != <em>Grunning &amp;&amp; status != _Gscanrunning {
 87		throw(â€œgopark: bad g statusâ€)
 88	}
 89	mp.waitlock = lock
 90	mp.waitunlockf = unlockf
 91	gp.waitreason = reason
 92	mp.waittraceev = traceEv
 93	mp.waittraceskip = traceskip
 94	releasem(mp)
 95	// canâ€™t do anything that might move the G between Ms here.
 96	// gopark æœ€ç»ˆä¼šè°ƒç”¨ park_mï¼Œåœ¨è¿™ä¸ªå‡½æ•°å†…éƒ¨ä¼šè°ƒç”¨ unlockfï¼Œä¹Ÿå°±æ˜¯ netpollblockcommitï¼Œ
 97	// ç„¶åä¼šæŠŠå½“å‰çš„ goroutineï¼Œä¹Ÿå°±æ˜¯ g æ•°æ®ç»“æ„ä¿å­˜åˆ° pollDesc çš„ rg æˆ–è€… wg æŒ‡é’ˆé‡Œ
 98	mcall(park_m)
 99}
100
101// park continuation on g0.
102func park_m(gp *g) {
103	_g</em> := getg()
104
105	if trace.enabled {
106		traceGoPark(<em>g</em>.m.waittraceev, <em>g</em>.m.waittraceskip)
107	}
108
109	casgstatus(gp, <em>Grunning, _Gwaiting)
110	dropg()
111
112	if fn := _g</em>.m.waitunlockf; fn != nil {
113		// è°ƒç”¨ netpollblockcommitï¼ŒæŠŠå½“å‰çš„ goroutineï¼Œ
114		// ä¹Ÿå°±æ˜¯ g æ•°æ®ç»“æ„ä¿å­˜åˆ° pollDesc çš„ rg æˆ–è€… wg æŒ‡é’ˆé‡Œ
115		ok := fn(gp, <em>g</em>.m.waitlock)
116		<em>g</em>.m.waitunlockf = nil
117		<em>g</em>.m.waitlock = nil
118		if !ok {
119			if trace.enabled {
120				traceGoUnpark(gp, 2)
121			}
122			casgstatus(gp, _Gwaiting, _Grunnable)
123			execute(gp, true) // Schedule it back, never returns.
124		}
125	}
126	schedule()
127}
128
129// netpollblockcommit åœ¨ gopark å‡½æ•°é‡Œè¢«è°ƒç”¨
130func netpollblockcommit(gp <em>g, gpp unsafe.Pointer) bool {
131	// é€šè¿‡åŸå­æ“ä½œæŠŠå½“å‰ goroutine æŠ½è±¡çš„æ•°æ®ç»“æ„ gï¼Œä¹Ÿå°±æ˜¯è¿™é‡Œçš„å‚æ•° gp å­˜å…¥ gpp æŒ‡é’ˆï¼Œ
132	// æ­¤æ—¶ gpp çš„å€¼æ˜¯ pollDesc çš„ rg æˆ–è€… wg æŒ‡é’ˆ
133	r := atomic.Casuintptr((</em>uintptr)(gpp), pdWait, uintptr(unsafe.Pointer(gp)))
134	if r {
135		// Bump the count of goroutines waiting for the poller.
136		// The scheduler uses this to decide whether to block
137		// waiting for the poller if there is nothing else to do.
138		atomic.Xadd(&amp;netpollWaiters, 1)
139	}
140	return r
141}
pollDesc.waitWrite çš„å†…éƒ¨å®ç°åŸç†å’Œ pollDesc.waitRead æ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯åŸºäº poll.runtime_pollWait â€“&gt; runtime.poll_runtime_pollWaitï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚</p>

<p>netpoll
å‰é¢å·²ç»ä»æºç çš„å±‚é¢åˆ†æå®Œäº† netpoll æ˜¯å¦‚ä½•é€šè¿‡ park goroutine ä»è€Œè¾¾åˆ°é˜»å¡ Accept/Read/Write çš„æ•ˆæœï¼Œè€Œé€šè¿‡è°ƒç”¨ goparkï¼Œgoroutine ä¼šè¢«æ”¾ç½®åœ¨æŸä¸ªç­‰å¾…é˜Ÿåˆ—ä¸­ï¼Œè¿™é‡Œæ˜¯æ”¾åˆ°äº† epoll çš„ â€œinterest listâ€ é‡Œï¼Œåº•å±‚æ•°æ®ç»“æ„æ˜¯ç”±çº¢é»‘æ ‘å®ç°çš„ eventpoll.rbrï¼Œæ­¤æ—¶ G çš„çŠ¶æ€ç”± _Grunningä¸º_Gwaitting ï¼Œå› æ­¤ G å¿…é¡»è¢«æ‰‹åŠ¨å”¤é†’(é€šè¿‡ goready )ï¼Œå¦åˆ™ä¼šä¸¢å¤±ä»»åŠ¡ï¼Œåº”ç”¨å±‚é˜»å¡é€šå¸¸ä½¿ç”¨è¿™ç§æ–¹å¼ã€‚</p>

<p>æ‰€ä»¥æˆ‘ä»¬ç°åœ¨å¯ä»¥æ¥ä»æ•´ä½“çš„å±‚é¢æ¥æ¦‚æ‹¬ Go çš„ç½‘ç»œä¸šåŠ¡ goroutine æ˜¯å¦‚ä½•è¢«è§„åˆ’è°ƒåº¦çš„äº†ï¼š</p>

<p>é¦–å…ˆï¼Œclient è¿æ¥ server çš„æ—¶å€™ï¼Œlistener é€šè¿‡ accept è°ƒç”¨æ¥æ”¶æ–° connectionï¼Œæ¯ä¸€ä¸ªæ–° connection éƒ½å¯åŠ¨ä¸€ä¸ª goroutine å¤„ç†ï¼Œaccept è°ƒç”¨ä¼šæŠŠè¯¥ connection çš„ fd è¿å¸¦æ‰€åœ¨çš„ goroutine ä¸Šä¸‹æ–‡ä¿¡æ¯å°è£…æ³¨å†Œåˆ° epoll çš„ç›‘å¬åˆ—è¡¨é‡Œå»ï¼Œå½“ goroutine è°ƒç”¨ conn.Read æˆ–è€… conn.Write ç­‰éœ€è¦é˜»å¡ç­‰å¾…çš„å‡½æ•°æ—¶ï¼Œä¼šè¢« gopark ç»™å°å­˜èµ·æ¥å¹¶ä½¿ä¹‹ä¼‘çœ ï¼Œè®© P å»æ‰§è¡Œæœ¬åœ°è°ƒåº¦é˜Ÿåˆ—é‡Œçš„ä¸‹ä¸€ä¸ªå¯æ‰§è¡Œçš„ goroutineï¼Œå¾€å Go scheduler ä¼šåœ¨å¾ªç¯è°ƒåº¦çš„ runtime.schedule() å‡½æ•°ä»¥åŠ sysmon ç›‘æ§çº¿ç¨‹ä¸­è°ƒç”¨ runtime.netpoll ä»¥è·å–å¯è¿è¡Œçš„ goroutine åˆ—è¡¨å¹¶é€šè¿‡è°ƒç”¨ injectglist æŠŠå‰©ä¸‹çš„ g æ”¾å…¥å…¨å±€è°ƒåº¦é˜Ÿåˆ—æˆ–è€…å½“å‰ P æœ¬åœ°è°ƒåº¦é˜Ÿåˆ—å»é‡æ–°æ‰§è¡Œã€‚</p>

<p>é‚£ä¹ˆå½“ I/O äº‹ä»¶å‘ç”Ÿä¹‹åï¼Œnetpoller æ˜¯é€šè¿‡ä»€ä¹ˆæ–¹å¼å”¤é†’é‚£äº›åœ¨ I/O wait çš„ goroutine çš„ï¼Ÿç­”æ¡ˆæ˜¯é€šè¿‡ runtime.netpollã€‚</p>

<p>runtime.netpoll çš„æ ¸å¿ƒé€»è¾‘æ˜¯ï¼š</p>

<p>æ ¹æ®è°ƒç”¨æ–¹çš„å…¥å‚ delayï¼Œè®¾ç½®å¯¹åº”çš„è°ƒç”¨ epollwait çš„ timeout å€¼ï¼›
è°ƒç”¨ epollwait ç­‰å¾…å‘ç”Ÿäº†å¯è¯»/å¯å†™äº‹ä»¶çš„ fdï¼›
å¾ªç¯ epollwait è¿”å›çš„äº‹ä»¶åˆ—è¡¨ï¼Œå¤„ç†å¯¹åº”çš„äº‹ä»¶ç±»å‹ï¼Œ ç»„è£…å¯è¿è¡Œçš„ goroutine é“¾è¡¨å¹¶è¿”å›ã€‚
  1// netpoll checks for ready network connections.
  2// Returns list of goroutines that become runnable.
  3// delay &lt; 0: blocks indefinitely
  4// delay == 0: does not block, just polls
  5// delay &gt; 0: block for up to that many nanoseconds
  6func netpoll(delay int64) gList {
  7	if epfd == -1 {
  8		return gList{}
  9	}
 10
 11	// æ ¹æ®ç‰¹å®šçš„è§„åˆ™æŠŠ delay å€¼è½¬æ¢ä¸º epollwait çš„ timeout å€¼
 12	var waitms int32
 13	if delay &lt; 0 {
 14		waitms = -1
 15	} else if delay == 0 {
 16		waitms = 0
 17	} else if delay &lt; 1e6 {
 18		waitms = 1
 19	} else if delay &lt; 1e15 {
 20		waitms = int32(delay / 1e6)
 21	} else {
 22		// An arbitrary cap on how long to wait for a timer.
 23		// 1e9 ms == ~11.5 days.
 24		waitms = 1e9
 25	}
 26	var events [128]epollevent
 27retry:
 28	// è¶…æ—¶ç­‰å¾…å°±ç»ªçš„ fd è¯»å†™äº‹ä»¶
 29	n := epollwait(epfd, &amp;events[0], int32(len(events)), waitms)
 30	if n &lt; 0 {
 31		if n != -_EINTR {
 32			println(â€œruntime: epollwait on fdâ€, epfd, â€œfailed withâ€, -n)
 33			throw(â€œruntime: netpoll failedâ€)
 34		}
 35		// If a timed sleep was interrupted, just return to
 36		// recalculate how long we should sleep now.
 37		if waitms &gt; 0 {
 38			return gList{}
 39		}
 40		goto retry
 41	}
 42
 43	// toRun æ˜¯ä¸€ä¸ª g çš„é“¾è¡¨ï¼Œå­˜å‚¨è¦æ¢å¤çš„ goroutinesï¼Œæœ€åè¿”å›ç»™è°ƒç”¨æ–¹
 44	var toRun gList
 45	for i := int32(0); i &lt; n; i++ {
 46		ev := &amp;events[i]
 47		if ev.events == 0 {
 48			continue
 49		}
 50
 51		// Go scheduler åœ¨è°ƒç”¨ findrunnable() å¯»æ‰¾ goroutine å»æ‰§è¡Œçš„æ—¶å€™ï¼Œ
 52		// åœ¨è°ƒç”¨ netpoll ä¹‹æ—¶ä¼šæ£€æŸ¥å½“å‰æ˜¯å¦æœ‰å…¶ä»–çº¿ç¨‹åŒæ­¥é˜»å¡åœ¨ netpollï¼Œ
 53		// è‹¥æ˜¯ï¼Œåˆ™è°ƒç”¨ netpollBreak æ¥å”¤é†’é‚£ä¸ªçº¿ç¨‹ï¼Œé¿å…å®ƒé•¿æ—¶é—´é˜»å¡
 54		if <em>(<strong>uintptr)(unsafe.Pointer(&amp;ev.data)) == &amp;netpollBreakRd {
 55			if ev.events != _EPOLLIN {
 56				println(â€œruntime: netpoll: break fd ready forâ€, ev.events)
 57				throw(â€œruntime: netpoll: break fd ready for something unexpectedâ€)
 58			}
 59			if delay != 0 {
 60				// netpollBreak could be picked up by a
 61				// nonblocking poll. Only read the byte
 62				// if blocking.
 63				var tmp [16]byte
 64				read(int32(netpollBreakRd), noescape(unsafe.Pointer(&amp;tmp[0])), int32(len(tmp)))
 65				atomic.Store(&amp;netpollWakeSig, 0)
 66			}
 67			continue
 68		}
 69
 70		// åˆ¤æ–­å‘ç”Ÿçš„äº‹ä»¶ç±»å‹ï¼Œè¯»ç±»å‹æˆ–è€…å†™ç±»å‹ç­‰ï¼Œç„¶åç»™ mode å¤åˆ¶ç›¸åº”çš„å€¼ï¼Œ
 71		// mode ç”¨æ¥å†³å®šä» pollDesc é‡Œçš„ rg è¿˜æ˜¯ wg é‡Œå–å‡º goroutine
 72		var mode int32
 73		if ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {
 74			mode += â€˜râ€™
 75		}
 76		if ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {
 77			mode += â€˜wâ€™
 78		}
 79		if mode != 0 {
 80			// å–å‡ºä¿å­˜åœ¨ epollevent é‡Œçš„ pollDesc
 81			pd := *(</strong>pollDesc)(unsafe.Pointer(&amp;ev.data))
 82			pd.everr = false
 83			if ev.events == _EPOLLERR {
 84				pd.everr = true
 85			}
 86			// è°ƒç”¨ netpollreadyï¼Œä¼ å…¥å°±ç»ª fd çš„ pollDescï¼Œ
 87			// æŠŠ fd å¯¹åº”çš„ goroutine æ·»åŠ åˆ°é“¾è¡¨ toRun ä¸­
 88			netpollready(&amp;toRun, pd, mode)
 89		}
 90	}
 91	return toRun
 92}
 93
 94// netpollready è°ƒç”¨ netpollunblock è¿”å›å°±ç»ª fd å¯¹åº”çš„ goroutine çš„æŠ½è±¡æ•°æ®ç»“æ„ g
 95func netpollready(toRun *gList, pd *pollDesc, mode int32) {
 96	var rg, wg *g
 97	if mode == â€˜râ€™ || mode == â€˜râ€™+â€™wâ€™ {
 98		rg = netpollunblock(pd, â€˜râ€™, true)
 99	}
100	if mode == â€˜wâ€™ || mode == â€˜râ€™+â€™wâ€™ {
101		wg = netpollunblock(pd, â€˜wâ€™, true)
102	}
103	if rg != nil {
104		toRun.push(rg)
105	}
106	if wg != nil {
107		toRun.push(wg)
108	}
109}
110
111// netpollunblock ä¼šä¾æ®ä¼ å…¥çš„ mode å†³å®šä» pollDesc çš„ rg æˆ–è€… wg å–å‡ºå½“æ—¶ gopark ä¹‹æ—¶å­˜å…¥çš„
112// goroutine æŠ½è±¡æ•°æ®ç»“æ„ g å¹¶è¿”å›
113func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g {
114	// mode == â€˜râ€™ ä»£è¡¨å½“æ—¶ gopark æ˜¯ä¸ºäº†ç­‰å¾…è¯»äº‹ä»¶ï¼Œè€Œ mode == â€˜wâ€™ åˆ™ä»£è¡¨æ˜¯ç­‰å¾…å†™äº‹ä»¶
115	gpp := &amp;pd.rg
116	if mode == â€˜wâ€™ {
117		gpp = &amp;pd.wg
118	}
119
120	for {
121		// å–å‡º gpp å­˜å‚¨çš„ g
122		old := *gpp
123		if old == pdReady {
124			return nil
125		}
126		if old == 0 &amp;&amp; !ioready {
127			// Only set READY for ioready. runtime_pollWait
128			// will check for timeout/cancel before waiting.
129			return nil
130		}
131		var new uintptr
132		if ioready {
133			new = pdReady
134		}
135		// é‡ç½® pollDesc çš„ rg æˆ–è€… wg
136		if atomic.Casuintptr(gpp, old, new) {
137			// å¦‚æœè¯¥ goroutine è¿˜æ˜¯å¿…é¡»ç­‰å¾…ï¼Œåˆ™è¿”å› nil
138			if old == pdWait {
139				old = 0
140			}
141			// é€šè¿‡ä¸‡èƒ½æŒ‡é’ˆè¿˜åŸæˆ g å¹¶è¿”å›
142			return (</em>g)(unsafe.Pointer(old))
143		}
144	}
145}
146
147// netpollBreak å¾€é€šä¿¡ç®¡é“é‡Œå†™å…¥ä¿¡å·å»å”¤é†’ epollwait
148func netpollBreak() {
149	// é€šè¿‡ CAS é¿å…é‡å¤çš„å”¤é†’ä¿¡å·è¢«å†™å…¥ç®¡é“ï¼Œ
150	// ä»è€Œå‡å°‘ç³»ç»Ÿè°ƒç”¨å¹¶èŠ‚çœä¸€äº›ç³»ç»Ÿèµ„æº
151	if atomic.Cas(&amp;netpollWakeSig, 0, 1) {
152		for {
153			var b byte
154			n := write(netpollBreakWr, unsafe.Pointer(&amp;b), 1)
155			if n == 1 {
156				break
157			}
158			if n == -_EINTR {
159				continue
160			}
161			if n == -_EAGAIN {
162				return
163			}
164			println(â€œruntime: netpollBreak write failed withâ€, -n)
165			throw(â€œruntime: netpollBreak write failedâ€)
166		}
167	}
168}
Go åœ¨å¤šç§åœºæ™¯ä¸‹éƒ½å¯èƒ½ä¼šè°ƒç”¨ netpoll æ£€æŸ¥æ–‡ä»¶æè¿°ç¬¦çŠ¶æ€ï¼Œnetpoll é‡Œä¼šè°ƒç”¨ epoll_wait ä» epoll çš„ eventpoll.rdllist å°±ç»ªåŒå‘é“¾è¡¨è¿”å›ï¼Œä»è€Œå¾—åˆ° I/O å°±ç»ªçš„ socket fd åˆ—è¡¨ï¼Œå¹¶æ ¹æ®å–å‡ºæœ€åˆè°ƒç”¨ epoll_ctl æ—¶ä¿å­˜çš„ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼Œæ¢å¤ gã€‚æ‰€ä»¥æ‰§è¡Œå®Œnetpoll ä¹‹åï¼Œä¼šè¿”å›ä¸€ä¸ªå°±ç»ª fd åˆ—è¡¨å¯¹åº”çš„ goroutine é“¾è¡¨ï¼Œæ¥ä¸‹æ¥å°†å°±ç»ªçš„ goroutine é€šè¿‡è°ƒç”¨ injectglist åŠ å…¥åˆ°å…¨å±€è°ƒåº¦é˜Ÿåˆ—æˆ–è€… P çš„æœ¬åœ°è°ƒåº¦é˜Ÿåˆ—ä¸­ï¼Œå¯åŠ¨ M ç»‘å®š P å»æ‰§è¡Œã€‚</p>

<p>å…·ä½“è°ƒç”¨ netpoll çš„åœ°æ–¹ï¼Œé¦–å…ˆåœ¨ Go runtime scheduler å¾ªç¯è°ƒåº¦ goroutines ä¹‹æ—¶å°±æœ‰å¯èƒ½ä¼šè°ƒç”¨ netpoll è·å–åˆ°å·²å°±ç»ªçš„ fd å¯¹åº”çš„ goroutine æ¥è°ƒåº¦æ‰§è¡Œã€‚</p>

<p>é¦–å…ˆ Go scheduler çš„æ ¸å¿ƒæ–¹æ³• runtime.schedule() é‡Œä¼šè°ƒç”¨ä¸€ä¸ªå« runtime.findrunable() çš„æ–¹æ³•è·å–å¯è¿è¡Œçš„ goroutine æ¥æ‰§è¡Œï¼Œè€Œåœ¨ runtime.findrunable() æ–¹æ³•é‡Œå°±è°ƒç”¨äº† runtime.netpoll è·å–å·²å°±ç»ªçš„ fd åˆ—è¡¨å¯¹åº”çš„ goroutine åˆ—è¡¨ï¼š</p>

<p>1// One round of scheduler: find a runnable goroutine and execute it.
 2// Never returns.
 3func schedule() {
 4	â€¦
 5<br />
 6  if gp == nil {
 7		gp, inheritTime = findrunnable() // blocks until work is available
 8	}
 9<br />
10	â€¦
11}
12
13// Finds a runnable goroutine to execute.
14// Tries to steal from other Pâ€™s, get g from global queue, poll network.
15func findrunnable() (gp *g, inheritTime bool) {
16  â€¦
17<br />
18  // Poll network.
19	if netpollinited() &amp;&amp; (atomic.Load(&amp;netpollWaiters) &gt; 0 || pollUntil != 0) &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, 0) != 0 {
20		atomic.Store64(&amp;sched.pollUntil, uint64(pollUntil))
21		if <em>g</em>.m.p != 0 {
22			throw(â€œfindrunnable: netpoll with pâ€)
23		}
24		if <em>g</em>.m.spinning {
25			throw(â€œfindrunnable: netpoll with spinningâ€)
26		}
27		if faketime != 0 {
28			// When using fake time, just poll.
29			delta = 0
30		}
31		list := netpoll(delta) // åŒæ­¥é˜»å¡è°ƒç”¨ netpollï¼Œç›´è‡³æœ‰å¯ç”¨çš„ goroutine
32		atomic.Store64(&amp;sched.pollUntil, 0)
33		atomic.Store64(&amp;sched.lastpoll, uint64(nanotime()))
34		if faketime != 0 &amp;&amp; list.empty() {
35			// Using fake time and nothing is ready; stop M.
36			// When all Mâ€™s stop, checkdead will call timejump.
37			stopm()
38			goto top
39		}
40		lock(&amp;sched.lock)
41		<em>p</em> = pidleget() // æŸ¥æ‰¾æ˜¯å¦æœ‰ç©ºé—²çš„ P å¯ä»¥æ¥å°±ç»ªçš„ goroutine
42		unlock(&amp;sched.lock)
43		if <em>p</em> == nil {
44			injectglist(&amp;list) // å¦‚æœå½“å‰æ²¡æœ‰ç©ºé—²çš„ Pï¼Œåˆ™æŠŠå°±ç»ªçš„ goroutine æ”¾å…¥å…¨å±€è°ƒåº¦é˜Ÿåˆ—ç­‰å¾…è¢«æ‰§è¡Œ
45		} else {
46			// å¦‚æœå½“å‰æœ‰ç©ºé—²çš„ Pï¼Œåˆ™ pop å‡ºä¸€ä¸ª gï¼Œè¿”å›ç»™è°ƒåº¦å™¨å»æ‰§è¡Œï¼Œ
47			// å¹¶é€šè¿‡è°ƒç”¨ injectglist æŠŠå‰©ä¸‹çš„ g æ”¾å…¥å…¨å±€è°ƒåº¦é˜Ÿåˆ—æˆ–è€…å½“å‰ P æœ¬åœ°è°ƒåº¦é˜Ÿåˆ—
48			acquirep(<em>p</em>)
49			if !list.empty() {
50				gp := list.pop()
51				injectglist(&amp;list)
52				casgstatus(gp, <em>Gwaiting, _Grunnable)
53				if trace.enabled {
54					traceGoUnpark(gp, 0)
55				}
56				return gp, false
57			}
58			if wasSpinning {
59				_g</em>.m.spinning = true
60				atomic.Xadd(&amp;sched.nmspinning, 1)
61			}
62			goto top
63		}
64	} else if pollUntil != 0 &amp;&amp; netpollinited() {
65		pollerPollUntil := int64(atomic.Load64(&amp;sched.pollUntil))
66		if pollerPollUntil == 0 || pollerPollUntil &gt; pollUntil {
67			netpollBreak()
68		}
69	}
70	stopm()
71	goto top
72}
å¦å¤–ï¼Œ sysmon ç›‘æ§çº¿ç¨‹ä¼šåœ¨å¾ªç¯è¿‡ç¨‹ä¸­æ£€æŸ¥è·ç¦»ä¸Šä¸€æ¬¡ runtime.netpoll è¢«è°ƒç”¨æ˜¯å¦è¶…è¿‡äº† 10msï¼Œè‹¥æ˜¯åˆ™ä¼šå»è°ƒç”¨å®ƒæ‹¿åˆ°å¯è¿è¡Œçš„ goroutine åˆ—è¡¨å¹¶é€šè¿‡è°ƒç”¨ injectglist æŠŠ g åˆ—è¡¨æ”¾å…¥å…¨å±€è°ƒåº¦é˜Ÿåˆ—æˆ–è€…å½“å‰ P æœ¬åœ°è°ƒåº¦é˜Ÿåˆ—ç­‰å¾…è¢«æ‰§è¡Œï¼š</p>

<p>1// Always runs without a P, so write barriers are not allowed.
 2//
 3//go:nowritebarrierrec
 4func sysmon() {
 5		â€¦
 6<br />
 7		// poll network if not polled for more than 10ms
 8		lastpoll := int64(atomic.Load64(&amp;sched.lastpoll))
 9		if netpollinited() &amp;&amp; lastpoll != 0 &amp;&amp; lastpoll+10<em>1000</em>1000 &lt; now {
10			atomic.Cas64(&amp;sched.lastpoll, uint64(lastpoll), uint64(now))
11			list := netpoll(0) // non-blocking - returns list of goroutines
12			if !list.empty() {
13				// Need to decrement number of idle locked Mâ€™s
14				// (pretending that one more is running) before injectglist.
15				// Otherwise it can lead to the following situation:
16				// injectglist grabs all Pâ€™s but before it starts Mâ€™s to run the Pâ€™s,
17				// another M returns from syscall, finishes running its G,
18				// observes that there is no work to do and no other running Mâ€™s
19				// and reports deadlock.
20				incidlelocked(-1)
21				injectglist(&amp;list)
22				incidlelocked(1)
23			}
24		}
25<br />
26  â€¦
27}
Go runtime åœ¨ç¨‹åºå¯åŠ¨çš„æ—¶å€™ä¼šåˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„ M ä½œä¸ºç›‘æ§çº¿ç¨‹ï¼Œå« sysmon ï¼Œè¿™ä¸ªçº¿ç¨‹ä¸ºç³»ç»Ÿçº§çš„ daemon çº¿ç¨‹ï¼Œæ— éœ€ P å³å¯è¿è¡Œï¼Œ sysmon æ¯ 20us~10ms è¿è¡Œä¸€æ¬¡ã€‚ sysmon ä¸­ä»¥è½®è¯¢çš„æ–¹å¼æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼ˆå¦‚ä¸Šé¢çš„ä»£ç æ‰€ç¤ºï¼‰ï¼š</p>

<p>ä»¥éé˜»å¡çš„æ–¹å¼è°ƒç”¨ runtime.netpoll ï¼Œä»ä¸­æ‰¾å‡ºèƒ½ä»ç½‘ç»œ I/O ä¸­å”¤é†’çš„ g åˆ—è¡¨ï¼Œå¹¶é€šè¿‡è°ƒç”¨ injectglist æŠŠ g åˆ—è¡¨æ”¾å…¥å…¨å±€è°ƒåº¦é˜Ÿåˆ—æˆ–è€…å½“å‰ P æœ¬åœ°è°ƒåº¦é˜Ÿåˆ—ç­‰å¾…è¢«æ‰§è¡Œï¼Œè°ƒåº¦è§¦å‘æ—¶ï¼Œæœ‰å¯èƒ½ä»è¿™ä¸ªå…¨å±€ runnable è°ƒåº¦é˜Ÿåˆ—è·å– gã€‚ç„¶åå†å¾ªç¯è°ƒç”¨ startm ï¼Œç›´åˆ°æ‰€æœ‰ P éƒ½ä¸å¤„äº _Pidle çŠ¶æ€ã€‚
è°ƒç”¨ retake ï¼ŒæŠ¢å é•¿æ—¶é—´å¤„äº _Psyscall çŠ¶æ€çš„ Pã€‚
ç»¼ä¸Šï¼ŒGo å€ŸåŠ©äº epoll/kqueue/iocp å’Œ runtime scheduler ç­‰çš„å¸®åŠ©ï¼Œè®¾è®¡å‡ºäº†è‡ªå·±çš„ I/O å¤šè·¯å¤ç”¨ netpollerï¼ŒæˆåŠŸåœ°è®© Listener.Accept / conn.Read / conn.Write ç­‰æ–¹æ³•ä»å¼€å‘è€…çš„è§’åº¦çœ‹æ¥æ˜¯åŒæ­¥æ¨¡å¼ã€‚</p>

<p>Go netpoller çš„ä»·å€¼
é€šè¿‡å‰é¢å¯¹æºç çš„åˆ†æï¼Œæˆ‘ä»¬ç°åœ¨çŸ¥é“ Go netpoller ä¾æ‰˜äº runtime schedulerï¼Œä¸ºå¼€å‘è€…æä¾›äº†ä¸€ç§å¼ºå¤§çš„åŒæ­¥ç½‘ç»œç¼–ç¨‹æ¨¡å¼ï¼›ç„¶è€Œï¼ŒGo netpoller å­˜åœ¨çš„æ„ä¹‰å´è¿œä¸æ­¢äºæ­¤ï¼ŒGo netpoller I/O å¤šè·¯å¤ç”¨æ­é… Non-blocking I/O è€Œæ‰“é€ å‡ºæ¥çš„è¿™ä¸ªåŸç”Ÿç½‘ç»œæ¨¡å‹ï¼Œå®ƒæœ€å¤§çš„ä»·å€¼æ˜¯æŠŠç½‘ç»œ I/O çš„æ§åˆ¶æƒç‰¢ç‰¢æŒæ¡åœ¨ Go è‡ªå·±çš„ runtime é‡Œï¼Œå…³äºè¿™ä¸€ç‚¹æˆ‘ä»¬éœ€è¦ä» Go çš„ runtime scheduler è¯´èµ·ï¼ŒGo çš„ G-P-M è°ƒåº¦æ¨¡å‹å¦‚ä¸‹ï¼š</p>

<p>G åœ¨è¿è¡Œè¿‡ç¨‹ä¸­å¦‚æœè¢«é˜»å¡åœ¨æŸä¸ª system call æ“ä½œä¸Šï¼Œé‚£ä¹ˆä¸å…‰ G ä¼šé˜»å¡ï¼Œæ‰§è¡Œè¯¥ G çš„ M ä¹Ÿä¼šè§£ç»‘ P(å®è´¨æ˜¯è¢« sysmon æŠ¢èµ°äº†)ï¼Œä¸ G ä¸€èµ·è¿›å…¥ sleep çŠ¶æ€ã€‚å¦‚æœæ­¤æ—¶æœ‰ idle çš„ Mï¼Œåˆ™ P ä¸å…¶ç»‘å®šç»§ç»­æ‰§è¡Œå…¶ä»– Gï¼›å¦‚æœæ²¡æœ‰ idle Mï¼Œä½†ä»ç„¶æœ‰å…¶ä»– G è¦å»æ‰§è¡Œï¼Œé‚£ä¹ˆå°±ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ Mã€‚å½“é˜»å¡åœ¨ system call ä¸Šçš„ G å®Œæˆ syscall è°ƒç”¨åï¼ŒG ä¼šå»å°è¯•è·å–ä¸€ä¸ªå¯ç”¨çš„ Pï¼Œå¦‚æœæ²¡æœ‰å¯ç”¨çš„ Pï¼Œé‚£ä¹ˆ G ä¼šè¢«æ ‡è®°ä¸º _Grunnable å¹¶æŠŠå®ƒæ”¾å…¥å…¨å±€çš„ runqueue ä¸­ç­‰å¾…è°ƒåº¦ï¼Œä¹‹å‰çš„é‚£ä¸ª sleep çš„ M å°†å†æ¬¡è¿›å…¥ sleepã€‚</p>

<p>ç°åœ¨æ¸…æ¥šä¸ºä»€ä¹ˆ netpoll ä¸ºä»€ä¹ˆä¸€å®šè¦ä½¿ç”¨éé˜»å¡ I/O äº†å§ï¼Ÿå°±æ˜¯ä¸ºäº†é¿å…è®©æ“ä½œç½‘ç»œ I/O çš„ goroutine é™·å…¥åˆ°ç³»ç»Ÿè°ƒç”¨ä»è€Œè¿›å…¥å†…æ ¸æ€ï¼Œå› ä¸ºä¸€æ—¦è¿›å…¥å†…æ ¸æ€ï¼Œæ•´ä¸ªç¨‹åºçš„æ§åˆ¶æƒå°±ä¼šå‘ç”Ÿè½¬ç§»(åˆ°å†…æ ¸)ï¼Œä¸å†å±äºç”¨æˆ·è¿›ç¨‹äº†ï¼Œé‚£ä¹ˆä¹Ÿå°±æ— æ³•å€ŸåŠ©äº Go å¼ºå¤§çš„ runtime scheduler æ¥è°ƒåº¦ä¸šåŠ¡ç¨‹åºçš„å¹¶å‘äº†ï¼›è€Œæœ‰äº† netpoll ä¹‹åï¼Œå€ŸåŠ©äºéé˜»å¡ I/O ï¼ŒG å°±å†ä¹Ÿä¸ä¼šå› ä¸ºç³»ç»Ÿè°ƒç”¨çš„è¯»å†™è€Œ (é•¿æ—¶é—´) é™·å…¥å†…æ ¸æ€ï¼Œå½“ G è¢«é˜»å¡åœ¨æŸä¸ª network I/O æ“ä½œä¸Šæ—¶ï¼Œå®é™…ä¸Šå®ƒä¸æ˜¯å› ä¸ºé™·å…¥å†…æ ¸æ€è¢«é˜»å¡ä½äº†ï¼Œè€Œæ˜¯è¢« Go runtime è°ƒç”¨ gopark ç»™ park ä½äº†ï¼Œæ­¤æ—¶ G ä¼šè¢«æ”¾ç½®åˆ°æŸä¸ª wait queue ä¸­ï¼Œè€Œ M ä¼šå°è¯•è¿è¡Œä¸‹ä¸€ä¸ª _Grunnable çš„ Gï¼Œå¦‚æœæ­¤æ—¶æ²¡æœ‰ _Grunnable çš„ G ä¾› M è¿è¡Œï¼Œé‚£ä¹ˆ M å°†è§£ç»‘ Pï¼Œå¹¶è¿›å…¥ sleep çŠ¶æ€ã€‚å½“ I/O availableï¼Œåœ¨ epoll çš„ eventpoll.rdr ä¸­ç­‰å¾…çš„ G ä¼šè¢«æ”¾åˆ° eventpoll.rdllist é“¾è¡¨é‡Œå¹¶é€šè¿‡ netpoll ä¸­çš„ epoll_wait ç³»ç»Ÿè°ƒç”¨è¿”å›æ”¾ç½®åˆ°å…¨å±€è°ƒåº¦é˜Ÿåˆ—æˆ–è€… P çš„æœ¬åœ°è°ƒåº¦é˜Ÿåˆ—ï¼Œæ ‡è®°ä¸º _Grunnable ï¼Œç­‰å¾… P ç»‘å®š M æ¢å¤æ‰§è¡Œã€‚</p>

<p>Goroutine çš„è°ƒåº¦
è¿™ä¸€å°èŠ‚ä¸»è¦æ˜¯è®²å¤„ç†ç½‘ç»œ I/O çš„ goroutines é˜»å¡ä¹‹åï¼ŒGo scheduler å…·ä½“æ˜¯å¦‚ä½•åƒå‰é¢å‡ ä¸ªç« èŠ‚æ‰€è¯´çš„é‚£æ ·ï¼Œé¿å…è®©æ“ä½œç½‘ç»œ I/O çš„ goroutine é™·å…¥åˆ°ç³»ç»Ÿè°ƒç”¨ä»è€Œè¿›å…¥å†…æ ¸æ€çš„ï¼Œè€Œæ˜¯å°å­˜ goroutine ç„¶åè®©å‡º CPU çš„ä½¿ç”¨æƒä»è€Œä»¤ P å¯ä»¥å»è°ƒåº¦æœ¬åœ°è°ƒåº¦é˜Ÿåˆ—é‡Œçš„ä¸‹ä¸€ä¸ª goroutine çš„ã€‚</p>

<p>æ¸©é¦¨æç¤ºï¼šè¿™ä¸€å°èŠ‚å±äºå»¶ä¼¸é˜…è¯»ï¼Œæ¶‰åŠåˆ°çš„çŸ¥è¯†ç‚¹æ›´åç³»ç»Ÿåº•å±‚ï¼Œéœ€è¦æœ‰ä¸€å®šçš„æ±‡ç¼–è¯­è¨€åŸºç¡€æ‰èƒ½é€šè¯»ï¼Œå¦å¤–ï¼Œè¿™ä¸€èŠ‚å¯¹ Go scheduler çš„è®²è§£ä»…ä»…æ¶‰åŠæ ¸å¿ƒçš„ä¸€éƒ¨åˆ†ï¼Œä¸ä¼šæŠŠæ•´ä¸ªè°ƒåº¦å™¨éƒ½è®²ä¸€éï¼ˆäº‹å®ä¸Šå¦‚æœçœŸè¦è§£æ Go scheduler çš„è¯ææ€•é‡å¼€ä¸€ç¯‡å‡ ä¸‡å­—çš„æ–‡ç« æ‰èƒ½åŸºæœ¬è®²æ¸…æ¥šã€‚ã€‚ã€‚ï¼‰ï¼Œæ‰€ä»¥ä¹Ÿè¦æ±‚è¯»è€…å¯¹ Go çš„å¹¶å‘è°ƒåº¦å™¨æœ‰è¶³å¤Ÿçš„äº†è§£ï¼Œå› æ­¤è¿™ä¸€èŠ‚å¯èƒ½ä¼šç¨æ˜¾æ·±å¥¥ã€‚å½“ç„¶è¿™ä¸€èŠ‚ä¹Ÿå¯é€‰æ‹©ä¸è¯»ï¼Œå› ä¸ºé€šè¿‡å‰é¢çš„æ•´ä¸ªè§£æï¼Œæˆ‘ç›¸ä¿¡è¯»è€…åº”è¯¥å·²ç»èƒ½å¤ŸåŸºæœ¬æŒæ¡ Go netpoller å¤„ç†ç½‘ç»œ I/O çš„æ ¸å¿ƒç»†èŠ‚äº†ï¼Œä»¥åŠèƒ½ä»å®è§‚å±‚é¢äº†è§£ netpoller å¯¹ä¸šåŠ¡ goroutines çš„åŸºæœ¬è°ƒåº¦äº†ã€‚è€Œè¿™ä¸€èŠ‚ä¸»è¦æ˜¯é€šè¿‡å¯¹ goroutines è°ƒåº¦ç»†èŠ‚çš„å‰–æï¼Œèƒ½å¤ŸåŠ æ·±è¯»è€…å¯¹æ•´ä¸ª Go netpoller çš„å½»åº•ç†è§£ï¼Œæ¥ä¸Šå‰é¢å‡ ä¸ªç« èŠ‚ï¼Œå½¢æˆä¸€ä¸ªå®Œæ•´çš„é—­ç¯ã€‚å¦‚æœå¯¹è°ƒåº¦çš„åº•å±‚ç»†èŠ‚æ²¡å…´è¶£çš„è¯è¿™ä¹Ÿå¯ä»¥ç›´æ¥è·³è¿‡è¿™ä¸€èŠ‚ï¼Œå¯¹ç†è§£ Go netpoller çš„åŸºæœ¬åŸç†å½±å“ä¸å¤§ï¼Œä¸è¿‡è¿˜æ˜¯å»ºè®®æœ‰æ¡ä»¶çš„è¯»è€…å¯ä»¥çœ‹çœ‹ã€‚</p>

<p>ä»æºç å¯çŸ¥ï¼ŒGo scheduler çš„è°ƒåº¦ goroutine è¿‡ç¨‹ä¸­æ‰€è°ƒç”¨çš„æ ¸å¿ƒå‡½æ•°é“¾å¦‚ä¸‹ï¼š</p>

<p>1runtime.schedule â€“&gt; runtime.execute â€“&gt; runtime.gogo â€“&gt; goroutine code â€“&gt; runtime.goexit â€“&gt; runtime.goexit1 â€“&gt; runtime.mcall â€“&gt; runtime.goexit0 â€“&gt; runtime.schedule
Go scheduler ä¼šä¸æ–­å¾ªç¯è°ƒç”¨ runtime.schedule() å»è°ƒåº¦ goroutinesï¼Œè€Œæ¯ä¸ª goroutine æ‰§è¡Œå®Œæˆå¹¶é€€å‡ºä¹‹åï¼Œä¼šå†æ¬¡è°ƒç”¨ runtime.schedule()ï¼Œä½¿å¾—è°ƒåº¦å™¨å›åˆ°è°ƒåº¦å¾ªç¯å»æ‰§è¡Œå…¶ä»–çš„ goroutineï¼Œä¸æ–­å¾ªç¯ï¼Œæ°¸ä¸åœæ­‡ã€‚</p>

<p>å½“æˆ‘ä»¬ä½¿ç”¨ go å…³é”®å­—å¯åŠ¨ä¸€ä¸ªæ–° goroutine æ—¶ï¼Œæœ€ç»ˆä¼šè°ƒç”¨ runtime.newproc â€“&gt; runtime.newproc1ï¼Œæ¥å¾—åˆ° gï¼Œruntime.newproc1 ä¼šå…ˆä» P çš„ gfree ç¼“å­˜é“¾è¡¨ä¸­æŸ¥æ‰¾å¯ç”¨çš„ gï¼Œè‹¥ç¼“å­˜æœªç”Ÿæ•ˆï¼Œåˆ™ä¼šæ–°åˆ›å»º g ç»™å½“å‰çš„ä¸šåŠ¡å‡½æ•°ï¼Œæœ€åè¿™ä¸ª g ä¼šè¢«ä¼ ç»™ runtime.gogo å»çœŸæ­£æ‰§è¡Œã€‚</p>

<p>è¿™é‡Œé¦–å…ˆéœ€è¦äº†è§£ä¸€ä¸ª gobuf çš„ç»“æ„ä½“ï¼Œå®ƒç”¨æ¥ä¿å­˜ goroutine çš„è°ƒåº¦ä¿¡æ¯ï¼Œæ˜¯ runtime.gogo çš„å…¥å‚ï¼š</p>

<p>1// gobuf å­˜å‚¨ goroutine è°ƒåº¦ä¸Šä¸‹æ–‡ä¿¡æ¯çš„ç»“æ„ä½“
 2type gobuf struct {
 3	// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
 4	//
 5	// ctxt is unusual with respect to GC: it may be a
 6	// heap-allocated funcval, so GC needs to track it, but it
 7	// needs to be set and cleared from assembly, where itâ€™s
 8	// difficult to have write barriers. However, ctxt is really a
 9	// saved, live register, and we only ever exchange it between
10	// the real register and the gobuf. Hence, we treat it as a
11	// root during stack scanning, which means assembly that saves
12	// and restores it doesnâ€™t need write barriers. Itâ€™s still
13	// typed as a pointer so that any other writes from Go get
14	// write barriers.
15	sp   uintptr  // Stack Pointer æ ˆæŒ‡é’ˆ
16	pc   uintptr  // Program Counter ç¨‹åºè®¡æ•°å™¨
17	g    guintptr // æŒæœ‰å½“å‰ gobuf çš„ goroutine
18	ctxt unsafe.Pointer
19	ret  sys.Uintreg
20	lr   uintptr
21	bp   uintptr // for GOEXPERIMENT=framepointer
22}
æ‰§è¡Œ runtime.execute()ï¼Œè¿›è€Œè°ƒç”¨ runtime.gogoï¼š</p>

<p>1func execute(gp *g, inheritTime bool) {
 2	<em>g</em> := getg()
 3
 4	// Assign gp.m before entering <em>Grunning so running Gs have an
 5	// M.
 6	_g</em>.m.curg = gp
 7	gp.m = <em>g</em>.m
 8	casgstatus(gp, <em>Grunnable, _Grunning)
 9	gp.waitsince = 0
10	gp.preempt = false
11	gp.stackguard0 = gp.stack.lo + _StackGuard
12	if !inheritTime {
13		_g</em>.m.p.ptr().schedtick++
14	}
15
16	// Check whether the profiler needs to be turned on or off.
17	hz := sched.profilehz
18	if <em>g</em>.m.profilehz != hz {
19		setThreadCPUProfiler(hz)
20	}
21
22	if trace.enabled {
23		// GoSysExit has to happen when we have a P, but before GoStart.
24		// So we emit it here.
25		if gp.syscallsp != 0 &amp;&amp; gp.sysblocktraced {
26			traceGoSysExit(gp.sysexitticks)
27		}
28		traceGoStart()
29	}
30	// gp.sched å°±æ˜¯ gobuf
31	gogo(&amp;gp.sched)
32}
è¿™é‡Œè¿˜éœ€è¦äº†è§£ä¸€ä¸ªæ¦‚å¿µï¼šg0ï¼ŒGo G-P-M è°ƒåº¦æ¨¡å‹ä¸­ï¼Œg ä»£è¡¨ goroutineï¼Œè€Œå®é™…ä¸Šä¸€å…±æœ‰ä¸‰ç§ gï¼š</p>

<p>æ‰§è¡Œç”¨æˆ·ä»£ç çš„ gï¼›
æ‰§è¡Œè°ƒåº¦å™¨ä»£ç çš„ gï¼Œä¹Ÿå³æ˜¯ g0ï¼›
æ‰§è¡Œ runtime.main åˆå§‹åŒ–å·¥ä½œçš„ main goroutineï¼›
ç¬¬ä¸€ç§ g å°±æ˜¯ä½¿ç”¨ go å…³é”®å­—å¯åŠ¨çš„ goroutineï¼Œä¹Ÿæ˜¯æˆ‘ä»¬æ¥è§¦æœ€å¤šçš„ä¸€ç±» gï¼›ç¬¬ä¸‰ç§ g æ˜¯è°ƒåº¦å™¨å¯åŠ¨ä¹‹åç”¨æ¥æ‰§è¡Œçš„ä¸€ç³»åˆ—åˆå§‹åŒ–å·¥ä½œçš„ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºå¯åŠ¨ sysmon ç›‘æ§çº¿ç¨‹ã€å†…å­˜åˆå§‹åŒ–å’Œå¯åŠ¨ GC ç­‰ç­‰å·¥ä½œï¼›ç¬¬äºŒç§ g å« g0ï¼Œç”¨æ¥æ‰§è¡Œè°ƒåº¦å™¨ä»£ç ï¼Œg0 åœ¨åº•å±‚å’Œå…¶ä»– g æ˜¯ä¸€æ ·çš„æ•°æ®ç»“æ„ï¼Œä½†æ˜¯æ€§è´¨ä¸Šæœ‰å¾ˆå¤§çš„åŒºåˆ«ï¼Œé¦–å…ˆ g0 çš„æ ˆå¤§å°æ˜¯å›ºå®šçš„ï¼Œæ¯”å¦‚åœ¨ Linux æˆ–è€…å…¶ä»– Unix-like çš„ç³»ç»Ÿä¸Šä¸€èˆ¬æ˜¯å›ºå®š 8MBï¼Œä¸èƒ½åŠ¨æ€ä¼¸ç¼©ï¼Œè€Œæ™®é€šçš„ g åˆå§‹æ ˆå¤§å°æ˜¯ 2KBï¼Œå¯æŒ‰éœ€æ‰©å±•ï¼Œg0 å…¶å®å°±æ˜¯çº¿ç¨‹æ ˆï¼Œæˆ‘ä»¬çŸ¥é“æ¯ä¸ªçº¿ç¨‹è¢«åˆ›å»ºå‡ºæ¥ä¹‹æ—¶éƒ½éœ€è¦æ“ä½œç³»ç»Ÿä¸ºä¹‹åˆ†é…ä¸€ä¸ªåˆå§‹å›ºå®šçš„çº¿ç¨‹æ ˆï¼Œå°±æ˜¯å‰é¢è¯´çš„ 8MB å¤§å°çš„æ ˆï¼Œg0 æ ˆå°±ä»£è¡¨äº†è¿™ä¸ªçº¿ç¨‹æ ˆï¼Œå› æ­¤æ¯ä¸€ä¸ª m éƒ½éœ€è¦ç»‘å®šä¸€ä¸ª g0 æ¥æ‰§è¡Œè°ƒåº¦å™¨ä»£ç ï¼Œç„¶åè·³è½¬åˆ°æ‰§è¡Œç”¨æˆ·ä»£ç çš„åœ°æ–¹ã€‚</p>

<p>runtime.gogo æ˜¯çœŸæ­£å»æ‰§è¡Œ goroutine ä»£ç çš„å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ç”±æ±‡ç¼–å®ç°ï¼Œä¸ºä»€ä¹ˆéœ€è¦ç”¨æ±‡ç¼–ï¼Ÿå› ä¸º gogo çš„å·¥ä½œæ˜¯å®Œæˆçº¿ç¨‹ M ä¸Šçš„å †æ ˆåˆ‡æ¢ï¼šä»ç³»ç»Ÿå †æ ˆ g0 åˆ‡æ¢æˆ goroutine gpï¼Œä¹Ÿå°±æ˜¯ CPU ä½¿ç”¨æƒå’Œå †æ ˆçš„åˆ‡æ¢ï¼Œè¿™ç§åˆ‡æ¢æœ¬è´¨ä¸Šæ˜¯å¯¹ CPU çš„ PCã€SP ç­‰å¯„å­˜å™¨å’Œå †æ ˆæŒ‡é’ˆçš„æ›´æ–°ï¼Œè€Œè¿™ä¸€ç±»ç²¾åº¦çš„åº•å±‚æ“ä½œåˆ«è¯´æ˜¯ Goï¼Œå°±ç®—æ˜¯æœ€è´´è¿‘åº•å±‚çš„ C ä¹Ÿæ— æ³•åšåˆ°ï¼Œè¿™ç§ç¨‹åº¦çš„æ“ä½œå·²è¶…å‡ºæ‰€æœ‰é«˜çº§è¯­è¨€çš„èŒƒç•´ï¼Œå› æ­¤åªèƒ½å€ŸåŠ©äºæ±‡ç¼–æ¥å®ç°ã€‚</p>

<p>runtime.gogo åœ¨ä¸åŒçš„ CPU æ¶æ„å¹³å°ä¸Šçš„å®ç°å„ä¸ç›¸åŒï¼Œä½†æ˜¯æ ¸å¿ƒåŸç†æ®Šé€”åŒå½’ï¼Œæˆ‘ä»¬è¿™é‡Œé€‰ç”¨ amd64 æ¶æ„çš„æ±‡ç¼–å®ç°æ¥åˆ†æï¼Œæˆ‘ä¼šåœ¨å…³é”®çš„åœ°æ–¹åŠ ä¸Šè§£é‡Šï¼š</p>

<p>1// func gogo(buf *gobuf)
 2// restore state from Gobuf; longjmp
 3TEXT runtimeÂ·gogo(SB), NOSPLIT, $16-8
 4	// å°†ç¬¬ä¸€ä¸ª FP ä¼ªå¯„å­˜å™¨æ‰€æŒ‡å‘çš„ gobuf çš„ç¬¬ä¸€ä¸ªå‚æ•°å­˜å…¥ BX å¯„å­˜å™¨, 
 5	// gobuf çš„ä¸€ä¸ªå‚æ•°å³æ˜¯ SP æŒ‡é’ˆ
 6	MOVQ	buf+0(FP), BX
 7	MOVQ	gobuf_g(BX), DX  // å°† gp.sched.g ä¿å­˜åˆ° DX å¯„å­˜å™¨
 8	MOVQ	0(DX), CX		// make sure g != nil
 9
10	// å°† tls (thread local storage) ä¿å­˜åˆ° CX å¯„å­˜å™¨ï¼Œç„¶åæŠŠ gp.sched.g æ”¾åˆ° tls[0]ï¼Œ
11	// è¿™æ ·ä»¥åè°ƒç”¨ getg() ä¹‹æ—¶å°±å¯ä»¥é€šè¿‡ TLS ç›´æ¥è·å–åˆ°å½“å‰ goroutine çš„ g ç»“æ„ä½“å®ä¾‹ï¼Œ
12	// è¿›è€Œå¯ä»¥å¾—åˆ° g æ‰€åœ¨çš„ m å’Œ pï¼ŒTLS é‡Œä¸€å¼€å§‹å­˜å‚¨çš„æ˜¯ç³»ç»Ÿå †æ ˆ g0 çš„åœ°å€
13	get_tls(CX)
14	MOVQ	DX, g(CX)
15
16	// ä¸‹é¢çš„æŒ‡ä»¤åˆ™æ˜¯å¯¹å‡½æ•°æ ˆçš„ BP/SP å¯„å­˜å™¨(æŒ‡é’ˆ)çš„å­˜å–ï¼Œ
17	// æœ€åè¿›å…¥åˆ°æŒ‡å®šçš„ä»£ç åŒºåŸŸï¼Œæ‰§è¡Œå‡½æ•°æ ˆå¸§
18	MOVQ	gobuf_sp(BX), SP	// restore SP
19	MOVQ	gobuf_ret(BX), AX
20	MOVQ	gobuf_ctxt(BX), DX
21	MOVQ	gobuf_bp(BX), BP
22
23	// è¿™é‡Œæ˜¯åœ¨æ¸…ç©º gp.schedï¼Œå› ä¸ºå‰é¢å·²ç»æŠŠ gobuf é‡Œçš„å­—æ®µå€¼éƒ½å­˜å…¥äº†å¯„å­˜å™¨ï¼Œ
24	// æ‰€ä»¥ gp.sched å°±å¯ä»¥æå‰æ¸…ç©ºäº†ï¼Œä¸éœ€è¦ç­‰åˆ°åé¢ GC æ¥å›æ”¶ï¼Œå‡è½» GC çš„è´Ÿæ‹…
25	MOVQ	$0, gobuf_sp(BX)	// clear to help garbage collector
26	MOVQ	$0, gobuf_ret(BX)
27	MOVQ	$0, gobuf_ctxt(BX)
28	MOVQ	$0, gobuf_bp(BX)
29
30	// æŠŠ gp.sched.pc å€¼æ”¾å…¥ BX å¯„å­˜å™¨
31	// PC æŒ‡é’ˆæŒ‡å‘ gogo é€€å‡ºæ—¶éœ€è¦æ‰§è¡Œçš„å‡½æ•°åœ°å€
32	MOVQ	gobuf_pc(BX), BX
33	// ç”¨ BX å¯„å­˜å™¨é‡Œçš„å€¼å»ä¿®æ”¹ CPU çš„ IP å¯„å­˜å™¨ï¼Œ
34	// è¿™æ ·å°±å¯ä»¥æ ¹æ® CS:IP å¯„å­˜å™¨çš„æ®µåœ°å€+åç§»é‡è·³è½¬åˆ° BX å¯„å­˜å™¨é‡Œçš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯ gp.sched.pc
35	JMP	BX
runtime.gogo å‡½æ•°æ¥æ”¶ gp.sched è¿™ä¸ª gobuf ç»“æ„ä½“å®ä¾‹ï¼Œå…¶ä¸­ä¿å­˜äº†å‡½æ•°æ ˆå¯„å­˜å™¨ SP/PC/BPï¼Œå¦‚æœç†Ÿæ‚‰æ“ä½œç³»ç»ŸåŸç†çš„è¯å¯ä»¥çŸ¥é“è¿™äº›å¯„å­˜å™¨æ˜¯ CPU è¿›è¡Œå‡½æ•°è°ƒç”¨å’Œè¿”å›æ—¶åˆ‡æ¢å¯¹åº”çš„å‡½æ•°æ ˆå¸§æ‰€éœ€çš„å¯„å­˜å™¨ï¼Œè€Œ goroutine çš„æ‰§è¡Œå’Œå‡½æ•°è°ƒç”¨çš„åŸç†æ˜¯ä¸€è‡´çš„ï¼Œä¹Ÿæ˜¯ CPU å¯„å­˜å™¨çš„åˆ‡æ¢è¿‡ç¨‹ï¼Œæ‰€ä»¥è¿™é‡Œçš„å‡ ä¸ªå¯„å­˜å™¨å½“å‰å­˜çš„å°±æ˜¯ G çš„å‡½æ•°æ‰§è¡Œæ ˆï¼Œå½“ goroutine åœ¨å¤„ç†ç½‘ç»œ I/O ä¹‹æ—¶ï¼Œå¦‚æœæ°å¥½å¤„äº I/O å°±ç»ªçš„çŠ¶æ€çš„è¯ï¼Œåˆ™æ­£å¸¸å®Œæˆ runtime.gogoï¼Œå¹¶åœ¨æœ€åè·³è½¬åˆ°ç‰¹å®šçš„åœ°å€ï¼Œé‚£ä¹ˆè¿™ä¸ªåœ°å€æ˜¯å“ªé‡Œå‘¢ï¼Ÿ</p>

<p>æˆ‘ä»¬çŸ¥é“ CPU æ‰§è¡Œå‡½æ•°çš„æ—¶å€™éœ€è¦çŸ¥é“å‡½æ•°åœ¨å†…å­˜é‡Œçš„ä»£ç æ®µåœ°å€å’Œåç§»é‡ï¼Œç„¶åæ‰èƒ½å»å–æ¥å‡½æ•°æ ˆæ‰§è¡Œï¼Œè€Œå…¸å‹çš„æä¾›ä»£ç æ®µåœ°å€å’Œåç§»é‡çš„å¯„å­˜å™¨å°±æ˜¯ CS å’Œ IP å¯„å­˜å™¨ï¼Œè€Œ JMP BX æŒ‡ä»¤åˆ™æ˜¯ç”¨ BX å¯„å­˜å™¨å»æ›´æ–° IP å¯„å­˜å™¨ï¼Œè€Œ BX å¯„å­˜å™¨é‡Œçš„å€¼æ˜¯ gp.sched.pcï¼Œé‚£ä¹ˆè¿™ä¸ª PC æŒ‡é’ˆç©¶ç«Ÿæ˜¯æŒ‡å‘å“ªé‡Œå‘¢ï¼Ÿè®©æˆ‘ä»¬æ¥çœ‹å¦ä¸€å¤„æºç ã€‚</p>

<p>ä¼—æ‰€å‘¨çŸ¥ï¼Œå¯åŠ¨ä¸€ä¸ªæ–°çš„ goroutine æ˜¯é€šè¿‡ go å…³é”®å­—æ¥å®Œæˆçš„ï¼Œè€Œ go compiler ä¼šåœ¨ç¼–è¯‘æœŸé—´åˆ©ç”¨ cmd/compile/internal/gc.state.stmt å’Œ cmd/compile/internal/gc.state.call è¿™ä¸¤ä¸ªå‡½æ•°å°† go å…³é”®å­—ç¿»è¯‘æˆ runtime.newproc å‡½æ•°è°ƒç”¨ï¼Œè€Œ runtime.newproc æ¥æ”¶äº†å‡½æ•°æŒ‡é’ˆå’Œå…¶å¤§å°ä¹‹åï¼Œä¼šè·å– goroutine å’Œè°ƒç”¨å¤„çš„ç¨‹åºè®¡æ•°å™¨ï¼Œæ¥ç€å†è°ƒç”¨ runtime.newproc1ï¼š</p>

<p>1// Create a new g in state <em>Grunnable, starting at fn, with narg bytes
 2// of arguments starting at argp. callerpc is the address of the go
 3// statement that created this. The caller is responsible for adding
 4// the new g to the scheduler.
 5//
 6// This must run on the system stack because itâ€™s the continuation of
 7// newproc, which cannot split the stack.
 8//
 9//go:systemstack
10func newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g {
11  â€¦
12<br />
13  memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))
14	newg.sched.sp = sp
15	newg.stktopsp = sp
16	// æŠŠ goexit å‡½æ•°åœ°å€å­˜å…¥ gobuf çš„ PC æŒ‡é’ˆé‡Œ
17	newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function
18	newg.sched.g = guintptr(unsafe.Pointer(newg))
19	gostartcallfn(&amp;newg.sched, fn)
20	newg.gopc = callerpc
21	newg.ancestors = saveAncestors(callergp)
22	newg.startpc = fn.fn
23	if _g</em>.m.curg != nil {
24		newg.labels = <em>g</em>.m.curg.labels
25	}
26	if isSystemGoroutine(newg, false) {
27		atomic.Xadd(&amp;sched.ngsys, +1)
28	}
29	casgstatus(newg, _Gdead, _Grunnable)
30<br />
31  â€¦
32}
è¿™é‡Œå¯ä»¥çœ‹åˆ°ï¼Œnewg.sched.pc è¢«è®¾ç½®äº† runtime.goexit çš„å‡½æ•°åœ°å€ï¼Œnewg å°±æ˜¯åé¢ runtime.gogo æ‰§è¡Œçš„ goroutineï¼Œå› æ­¤ runtime.gogo æœ€åçš„æ±‡ç¼–æŒ‡ä»¤ JMP BXæ˜¯è·³è½¬åˆ°äº† runtime.goexitï¼Œè®©æˆ‘ä»¬æ¥ç»§ç»­çœ‹çœ‹è¿™ä¸ªå‡½æ•°åšäº†ä»€ä¹ˆï¼š</p>

<p>1// The top-most function running on a goroutine
 2// returns to goexit+PCQuantum. Defined as ABIInternal
 3// so as to make it identifiable to traceback (this
 4// function it used as a sentinel; traceback wants to
 5// see the func PC, not a wrapper PC).
 6TEXT runtimeÂ·goexit<ABIInternal>(SB),NOSPLIT,$0-0
 7	BYTE	$0x90	// NOP
 8	CALL	runtimeÂ·goexit1(SB)	// does not return
 9	// traceback from goexit1 must hit code range of goexit
10	BYTE	$0x90	// NOP
è¿™ä¸ªå‡½æ•°ä¹Ÿæ˜¯æ±‡ç¼–å®ç°çš„ï¼Œä½†æ˜¯éå¸¸ç®€å•ï¼Œå°±æ˜¯ç›´æ¥è°ƒç”¨ runtimeÂ·goexit1ï¼š</ABIInternal></p>

<p>1// Finishes execution of the current goroutine.
 2func goexit1() {
 3	if raceenabled {
 4		racegoend()
 5	}
 6	if trace.enabled {
 7		traceGoEnd()
 8	}
 9	mcall(goexit0)
10}
è°ƒç”¨ runtime.mcallå‡½æ•°ï¼š</p>

<p>1// func mcall(fn func(*g))
 2// Switch to m-&gt;g0â€™s stack, call fn(g).
 3// Fn must never return. It should gogo(&amp;g-&gt;sched)
 4// to keep running g.
 5
 6// åˆ‡æ¢å› g0 çš„ç³»ç»Ÿå †æ ˆï¼Œæ‰§è¡Œ fn(g)
 7TEXT runtimeÂ·mcall(SB), NOSPLIT, $0-8
 8	// å–å…¥å‚ funcval å¯¹è±¡çš„æŒ‡é’ˆå­˜å…¥ DI å¯„å­˜å™¨ï¼Œæ­¤æ—¶ fn.fn æ˜¯ goexit0 çš„åœ°å€
 9	MOVQ	fn+0(FP), DI
10
11	get_tls(CX)
12	MOVQ	g(CX), AX	// save state in g-&gt;sched
13	MOVQ	0(SP), BX	// callerâ€™s PC
14	MOVQ	BX, (g_sched+gobuf_pc)(AX)
15	LEAQ	fn+0(FP), BX	// callerâ€™s SP
16	MOVQ	BX, (g_sched+gobuf_sp)(AX)
17	MOVQ	AX, (g_sched+gobuf_g)(AX)
18	MOVQ	BP, (g_sched+gobuf_bp)(AX)
19
20	// switch to m-&gt;g0 &amp; its stack, call fn
21	MOVQ	g(CX), BX
22	MOVQ	g_m(BX), BX
23
24	// æŠŠ g0 çš„æ ˆæŒ‡é’ˆå­˜å…¥ SI å¯„å­˜å™¨ï¼Œåé¢éœ€è¦ç”¨åˆ°
25	MOVQ	m_g0(BX), SI
26	CMPQ	SI, AX	// if g == m-&gt;g0 call badmcall
27	JNE	3(PC)
28	MOVQ	$runtimeÂ·badmcall(SB), AX
29	JMP	AX
30
31	// è¿™ä¸¤ä¸ªæŒ‡ä»¤æ˜¯æŠŠ g0 åœ°å€å­˜å…¥åˆ° TLS é‡Œï¼Œ
32	// ç„¶åä» SI å¯„å­˜å™¨å–å‡º g0 çš„æ ˆæŒ‡é’ˆï¼Œ
33	// æ›¿æ¢æ‰ SP å¯„å­˜å™¨é‡Œå­˜çš„å½“å‰ g çš„æ ˆæŒ‡é’ˆ
34	MOVQ	SI, g(CX)	// g = m-&gt;g0
35	MOVQ	(g_sched+gobuf_sp)(SI), SP	// sp = m-&gt;g0-&gt;sched.sp
36
37	PUSHQ	AX
38	MOVQ	DI, DX
39
40	// å…¥å£å¤„çš„ç¬¬ä¸€ä¸ªæŒ‡ä»¤å·²ç»æŠŠ funcval å®ä¾‹å¯¹è±¡çš„æŒ‡é’ˆå­˜å…¥äº† DI å¯„å­˜å™¨ï¼Œ
41	// 0(DI) è¡¨ç¤ºå–å‡º DI çš„ç¬¬ä¸€ä¸ªæˆå‘˜ï¼Œå³ goexit0 å‡½æ•°åœ°å€ï¼Œå†å­˜å…¥ DI
42	MOVQ	0(DI), DI
43	CALL	DI // è°ƒç”¨ DI å¯„å­˜å™¨é‡Œçš„åœ°å€ï¼Œå³ goexit0
44	POPQ	AX
45	MOVQ	$runtimeÂ·badmcall2(SB), AX
46	JMP	AX
47	RET
å¯ä»¥çœ‹åˆ° runtime.mcall å‡½æ•°çš„ä¸»è¦é€»è¾‘æ˜¯ä»å½“å‰ goroutine åˆ‡æ¢å› g0 çš„ç³»ç»Ÿå †æ ˆï¼Œç„¶åè°ƒç”¨ fn(g)ï¼Œæ­¤å¤„çš„ g å³æ˜¯å½“å‰è¿è¡Œçš„ goroutineï¼Œè¿™ä¸ªæ–¹æ³•ä¼šä¿å­˜å½“å‰è¿è¡Œçš„ G çš„ PC/SP åˆ° g-&gt;sched é‡Œï¼Œä»¥ä¾¿è¯¥ G å¯ä»¥åœ¨ä»¥åè¢«é‡æ–°æ¢å¤æ‰§è¡Œï¼Œå› ä¸ºä¹Ÿæ¶‰åŠåˆ°å¯„å­˜å™¨å’Œå †æ ˆæŒ‡é’ˆçš„æ“ä½œï¼Œæ‰€ä»¥ä¹Ÿéœ€è¦ä½¿ç”¨æ±‡ç¼–å®ç°ï¼Œè¯¥å‡½æ•°æœ€åä¼šåœ¨ g0 ç³»ç»Ÿå †æ ˆä¸‹æ‰§è¡Œ runtime.goexit0:</p>

<p>1func goexit0(gp *g) {
 2	<em>g</em> := getg()
 3
 4	casgstatus(gp, <em>Grunning, _Gdead)
 5	if isSystemGoroutine(gp, false) {
 6		atomic.Xadd(&amp;sched.ngsys, -1)
 7	}
 8	gp.m = nil
 9	locked := gp.lockedm != 0
10	gp.lockedm = 0
11	_g</em>.m.lockedg = 0
12	gp.preemptStop = false
13	gp.paniconfault = false
14	gp.<em>defer = nil // should be true already but just in case.
15	gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.
16	gp.writebuf = nil
17	gp.waitreason = 0
18	gp.param = nil
19	gp.labels = nil
20	gp.timer = nil
21
22	if gcBlackenEnabled != 0 &amp;&amp; gp.gcAssistBytes &gt; 0 {
23		// Flush assist credit to the global pool. This gives
24		// better information to pacing if the application is
25		// rapidly creating an exiting goroutines.
26		scanCredit := int64(gcController.assistWorkPerByte * float64(gp.gcAssistBytes))
27		atomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)
28		gp.gcAssistBytes = 0
29	}
30
31	dropg()
32
33	if GOARCH == â€œwasmâ€ { // no threads yet on wasm
34		gfput(_g</em>.m.p.ptr(), gp)
35		schedule() // never returns
36	}
37
38	if <em>g</em>.m.lockedInt != 0 {
39		print(â€œinvalid m-&gt;lockedInt = â€œ, <em>g</em>.m.lockedInt, â€œ\nâ€)
40		throw(â€œinternal lockOSThread errorâ€)
41	}
42	gfput(<em>g</em>.m.p.ptr(), gp)
43	if locked {
44		// The goroutine may have locked this thread because
45		// it put it in an unusual kernel state. Kill it
46		// rather than returning it to the thread pool.
47
48		// Return to mstart, which will release the P and exit
49		// the thread.
50		if GOOS != â€œplan9â€ { // See golang.org/issue/22227.
51			gogo(&amp;<em>g</em>.m.g0.sched)
52		} else {
53			// Clear lockedExt on plan9 since we may end up re-using
54			// this thread.
55			<em>g</em>.m.lockedExt = 0
56		}
57	}
58	schedule()
59}
runtime.goexit0 çš„ä¸»è¦å·¥ä½œæ˜¯å°±æ˜¯</p>

<p>åˆ©ç”¨ CAS æ“ä½œæŠŠ g çš„çŠ¶æ€ä» _Grunning æ›´æ–°ä¸º _Gdeadï¼›
å¯¹ g åšä¸€äº›æ¸…ç†æ“ä½œï¼ŒæŠŠä¸€äº›å­—æ®µå€¼ç½®ç©ºï¼›
è°ƒç”¨ runtime.dropg è§£ç»‘ g å’Œ mï¼›
æŠŠ g æ”¾å…¥ p å­˜å‚¨ g çš„ gfree é“¾è¡¨ä½œä¸ºç¼“å­˜ï¼Œåç»­å¦‚æœéœ€è¦å¯åŠ¨æ–°çš„ goroutine åˆ™å¯ä»¥ç›´æ¥ä»é“¾è¡¨é‡Œå–è€Œä¸ç”¨é‡æ–°åˆå§‹åŒ–åˆ†é…å†…å­˜ã€‚
æœ€åï¼Œè°ƒç”¨ runtime.schedule() å†æ¬¡è¿›å…¥è°ƒåº¦å¾ªç¯å»è°ƒåº¦æ–°çš„ goroutinesï¼Œæ°¸ä¸åœæ­‡ã€‚
å¦ä¸€æ–¹é¢ï¼Œå¦‚æœ goroutine å¤„äº I/O ä¸å¯ç”¨çŠ¶æ€ï¼Œæˆ‘ä»¬å‰é¢å·²ç»åˆ†æè¿‡ netpoller åˆ©ç”¨éé˜»å¡ I/O + I/O å¤šè·¯å¤ç”¨é¿å…äº†é™·å…¥ç³»ç»Ÿè°ƒç”¨ï¼Œæ‰€ä»¥æ­¤æ—¶ä¼šè°ƒç”¨ runtime.gopark å¹¶æŠŠ goroutine æš‚æ—¶å°å­˜åœ¨ç”¨æˆ·æ€ç©ºé—´ï¼Œå¹¶ä¼‘çœ å½“å‰çš„ goroutineï¼Œå› æ­¤ä¸ä¼šé˜»å¡ runtime.gogo çš„æ±‡ç¼–æ‰§è¡Œï¼Œè€Œæ˜¯é€šè¿‡ runtime.mcall è°ƒç”¨ runtime.park_mï¼š</p>

<p>1func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {
 2	if reason != waitReasonSleep {
 3		checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy
 4	}
 5	mp := acquirem()
 6	gp := mp.curg
 7	status := readgstatus(gp)
 8	if status != <em>Grunning &amp;&amp; status != _Gscanrunning {
 9		throw(â€œgopark: bad g statusâ€)
10	}
11	mp.waitlock = lock
12	mp.waitunlockf = unlockf
13	gp.waitreason = reason
14	mp.waittraceev = traceEv
15	mp.waittraceskip = traceskip
16	releasem(mp)
17	// canâ€™t do anything that might move the G between Ms here.
18	mcall(park_m)
19}
20
21func park_m(gp *g) {
22	_g</em> := getg()
23
24	if trace.enabled {
25		traceGoPark(<em>g</em>.m.waittraceev, <em>g</em>.m.waittraceskip)
26	}
27
28	casgstatus(gp, <em>Grunning, _Gwaiting)
29	dropg()
30
31	if fn := _g</em>.m.waitunlockf; fn != nil {
32		ok := fn(gp, <em>g</em>.m.waitlock)
33		<em>g</em>.m.waitunlockf = nil
34		<em>g</em>.m.waitlock = nil
35		if !ok {
36			if trace.enabled {
37				traceGoUnpark(gp, 2)
38			}
39			casgstatus(gp, _Gwaiting, _Grunnable)
40			execute(gp, true) // Schedule it back, never returns.
41		}
42	}
43	schedule()
44}
runtime.mcall æ–¹æ³•æˆ‘ä»¬åœ¨å‰é¢å·²ç»ä»‹ç»è¿‡ï¼Œå®ƒä¸»è¦çš„å·¥ä½œå°±æ˜¯æ˜¯ä»å½“å‰ goroutine åˆ‡æ¢å› g0 çš„ç³»ç»Ÿå †æ ˆï¼Œç„¶åè°ƒç”¨ fn(g)ï¼Œè€Œæ­¤æ—¶ runtime.mcall è°ƒç”¨æ‰§è¡Œçš„æ˜¯ runtime.park_mï¼Œè¿™ä¸ªæ–¹æ³•é‡Œä¼šåˆ©ç”¨ CAS æŠŠå½“å‰è¿è¡Œçš„ goroutine â€“ gp çš„çŠ¶æ€ ä» _Grunning åˆ‡æ¢åˆ° _Gwaitingï¼Œè¡¨æ˜è¯¥ goroutine å·²è¿›å…¥åˆ°ç­‰å¾…å”¤é†’çŠ¶æ€ï¼Œæ­¤æ—¶å°å­˜å’Œä¼‘çœ  G çš„æ“ä½œå°±å®Œæˆäº†ï¼Œåªéœ€ç­‰å¾…å°±ç»ªä¹‹åè¢«é‡æ–°å”¤é†’æ‰§è¡Œå³å¯ã€‚æœ€åè°ƒç”¨ runtime.schedule() å†æ¬¡è¿›å…¥è°ƒåº¦å¾ªç¯ï¼Œå»æ‰§è¡Œä¸‹ä¸€ä¸ª goroutineï¼Œå……åˆ†åˆ©ç”¨ CPUã€‚</p>

<p>è‡³æ­¤ï¼Œæˆ‘ä»¬å®Œæˆäº†å¯¹ Go netpoller åŸç†å‰–æçš„æ•´ä¸ªé—­ç¯ã€‚</p>

<p>Go netpoller çš„é—®é¢˜
Go netpoller çš„è®¾è®¡ä¸å¯è°“ä¸ç²¾å·§ã€æ€§èƒ½ä¹Ÿä¸å¯è°“ä¸é«˜ï¼Œé…åˆ goroutine å¼€å‘ç½‘ç»œåº”ç”¨çš„æ—¶å€™å°±ä¸€ä¸ªå­—ï¼šçˆ½ã€‚å› æ­¤ Go çš„ç½‘ç»œç¼–ç¨‹æ¨¡å¼æ˜¯åŠå…¶ç®€æ´é«˜æ•ˆçš„ï¼Œç„¶è€Œï¼Œæ²¡æœ‰ä»»ä½•ä¸€ç§è®¾è®¡å’Œæ¶æ„æ˜¯å®Œç¾çš„ï¼Œ goroutine-per-connection è¿™ç§æ¨¡å¼è™½ç„¶ç®€å•é«˜æ•ˆï¼Œä½†æ˜¯åœ¨æŸäº›æç«¯çš„åœºæ™¯ä¸‹ä¹Ÿä¼šæš´éœ²å‡ºé—®é¢˜ï¼šgoroutine è™½ç„¶éå¸¸è½»é‡ï¼Œå®ƒçš„è‡ªå®šä¹‰æ ˆå†…å­˜åˆå§‹å€¼ä»…ä¸º 2KBï¼Œåé¢æŒ‰éœ€æ‰©å®¹ï¼›æµ·é‡è¿æ¥çš„ä¸šåŠ¡åœºæ™¯ä¸‹ï¼Œ goroutine-per-connection ï¼Œæ­¤æ—¶ goroutine æ•°é‡ä»¥åŠæ¶ˆè€—çš„èµ„æºå°±ä¼šå‘ˆçº¿æ€§è¶‹åŠ¿æš´æ¶¨ï¼Œè™½ç„¶ Go scheduler å†…éƒ¨åšäº† g çš„ç¼“å­˜é“¾è¡¨ï¼Œå¯ä»¥ä¸€å®šç¨‹åº¦ä¸Šç¼“è§£é«˜é¢‘åˆ›å»ºé”€æ¯ goroutine çš„å‹åŠ›ï¼Œä½†æ˜¯å¯¹äºç¬æ—¶æ€§æš´æ¶¨çš„é•¿è¿æ¥åœºæ™¯å°±æ— èƒ½ä¸ºåŠ›äº†ï¼Œå¤§é‡çš„ goroutines ä¼šè¢«ä¸æ–­åˆ›å»ºå‡ºæ¥ï¼Œä»è€Œå¯¹ Go runtime scheduler é€ æˆæå¤§çš„è°ƒåº¦å‹åŠ›å’Œä¾µå ç³»ç»Ÿèµ„æºï¼Œç„¶åèµ„æºè¢«ä¾µå åˆåè¿‡æ¥å½±å“ Go scheduler çš„è°ƒåº¦ï¼Œè¿›è€Œå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚</p>

<p>Reactor ç½‘ç»œæ¨¡å‹
ç›®å‰ Linux å¹³å°ä¸Šä¸»æµçš„é«˜æ€§èƒ½ç½‘ç»œåº“/æ¡†æ¶ä¸­ï¼Œå¤§éƒ½é‡‡ç”¨ Reactor æ¨¡å¼ï¼Œæ¯”å¦‚ nettyã€libeventã€libevã€ACEï¼ŒPOE(Perl)ã€Twisted(Python)ç­‰ã€‚</p>

<p>Reactor æ¨¡å¼æœ¬è´¨ä¸ŠæŒ‡çš„æ˜¯ä½¿ç”¨ I/O å¤šè·¯å¤ç”¨(I/O multiplexing) + éé˜»å¡ I/O(non-blocking I/O) çš„æ¨¡å¼ã€‚</p>

<p>é€šå¸¸è®¾ç½®ä¸€ä¸ªä¸»çº¿ç¨‹è´Ÿè´£åš event-loop äº‹ä»¶å¾ªç¯å’Œ I/O è¯»å†™ï¼Œé€šè¿‡ select/poll/epoll_wait ç­‰ç³»ç»Ÿè°ƒç”¨ç›‘å¬ I/O äº‹ä»¶ï¼Œä¸šåŠ¡é€»è¾‘æäº¤ç»™å…¶ä»–å·¥ä½œçº¿ç¨‹å»åšã€‚è€Œæ‰€è°“ã€éé˜»å¡ I/Oã€çš„æ ¸å¿ƒæ€æƒ³æ˜¯æŒ‡é¿å…é˜»å¡åœ¨ read() æˆ–è€… write() æˆ–è€…å…¶ä»–çš„ I/O ç³»ç»Ÿè°ƒç”¨ä¸Šï¼Œè¿™æ ·å¯ä»¥æœ€å¤§é™åº¦çš„å¤ç”¨ event-loop çº¿ç¨‹ï¼Œè®©ä¸€ä¸ªçº¿ç¨‹èƒ½æœåŠ¡äºå¤šä¸ª socketsã€‚åœ¨ Reactor æ¨¡å¼ä¸­ï¼ŒI/O çº¿ç¨‹åªèƒ½é˜»å¡åœ¨ I/O multiplexing å‡½æ•°ä¸Šï¼ˆselect/poll/epoll_waitï¼‰ã€‚</p>

<p>Reactor æ¨¡å¼çš„åŸºæœ¬å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š</p>

<p>Server ç«¯å®Œæˆåœ¨ bind&amp;listen ä¹‹åï¼Œå°† listenfd æ³¨å†Œåˆ° epollfd ä¸­ï¼Œæœ€åè¿›å…¥ event-loop äº‹ä»¶å¾ªç¯ã€‚å¾ªç¯è¿‡ç¨‹ä¸­ä¼šè°ƒç”¨ select/poll/epoll_wait é˜»å¡ç­‰å¾…ï¼Œè‹¥æœ‰åœ¨ listenfd ä¸Šçš„æ–°è¿æ¥äº‹ä»¶åˆ™è§£é™¤é˜»å¡è¿”å›ï¼Œå¹¶è°ƒç”¨ socket.accept æ¥æ”¶æ–°è¿æ¥ connfdï¼Œå¹¶å°† connfd åŠ å…¥åˆ° epollfd çš„ I/O å¤ç”¨ï¼ˆç›‘å¬ï¼‰é˜Ÿåˆ—ã€‚
å½“ connfd ä¸Šå‘ç”Ÿå¯è¯»/å¯å†™äº‹ä»¶ä¹Ÿä¼šè§£é™¤ select/poll/epoll_wait çš„é˜»å¡ç­‰å¾…ï¼Œç„¶åè¿›è¡Œ I/O è¯»å†™æ“ä½œï¼Œè¿™é‡Œè¯»å†™ I/O éƒ½æ˜¯éé˜»å¡ I/Oï¼Œè¿™æ ·æ‰ä¸ä¼šé˜»å¡ event-loop çš„ä¸‹ä¸€ä¸ªå¾ªç¯ã€‚ç„¶è€Œï¼Œè¿™æ ·å®¹æ˜“å‰²è£‚ä¸šåŠ¡é€»è¾‘ï¼Œä¸æ˜“ç†è§£å’Œç»´æŠ¤ã€‚
è°ƒç”¨ read è¯»å–æ•°æ®ä¹‹åè¿›è¡Œè§£ç å¹¶æ”¾å…¥é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…å·¥ä½œçº¿ç¨‹å¤„ç†ã€‚
å·¥ä½œçº¿ç¨‹å¤„ç†å®Œæ•°æ®ä¹‹åï¼Œè¿”å›åˆ° event-loop çº¿ç¨‹ï¼Œç”±è¿™ä¸ªçº¿ç¨‹è´Ÿè´£è°ƒç”¨ write æŠŠæ•°æ®å†™å› clientã€‚
accept è¿æ¥ä»¥åŠ conn ä¸Šçš„è¯»å†™æ“ä½œè‹¥æ˜¯åœ¨ä¸»çº¿ç¨‹å®Œæˆï¼Œåˆ™è¦æ±‚æ˜¯éé˜»å¡ I/Oï¼Œå› ä¸º Reactor æ¨¡å¼ä¸€æ¡æœ€é‡è¦çš„åŸåˆ™å°±æ˜¯ï¼šI/O æ“ä½œä¸èƒ½é˜»å¡ event-loop äº‹ä»¶å¾ªç¯ã€‚å®é™…ä¸Š event loop å¯èƒ½ä¹Ÿå¯ä»¥æ˜¯å¤šçº¿ç¨‹çš„ï¼Œåªæ˜¯ä¸€ä¸ªçº¿ç¨‹é‡Œåªæœ‰ä¸€ä¸ª select/poll/epoll_waitã€‚</p>

<p>ä¸Šé¢æåˆ°äº† Go netpoller åœ¨æŸäº›åœºæ™¯ä¸‹å¯èƒ½å› ä¸ºåˆ›å»ºå¤ªå¤šçš„ goroutine è€Œè¿‡å¤šåœ°æ¶ˆè€—ç³»ç»Ÿèµ„æºï¼Œè€Œåœ¨ç°å®ä¸–ç•Œçš„ç½‘ç»œä¸šåŠ¡ä¸­ï¼ŒæœåŠ¡å™¨æŒæœ‰çš„æµ·é‡è¿æ¥ä¸­åœ¨æçŸ­çš„æ—¶é—´çª—å£å†…åªæœ‰æå°‘æ•°æ˜¯ active è€Œå¤§å¤šæ•°åˆ™æ˜¯ idleï¼Œå°±åƒè¿™æ ·ï¼ˆéçœŸå®æ•°æ®ï¼Œä»…ä»…æ˜¯ä¸ºäº†æ¯”å–»ï¼‰ï¼š</p>

<p>é‚£ä¹ˆä¸ºæ¯ä¸€ä¸ªè¿æ¥æŒ‡æ´¾ä¸€ä¸ª goroutine å°±æ˜¾å¾—å¤ªè¿‡å¥¢ä¾ˆäº†ï¼Œè€Œ Reactor æ¨¡å¼è¿™ç§åˆ©ç”¨ I/O å¤šè·¯å¤ç”¨è¿›è€Œåªéœ€è¦ä½¿ç”¨å°‘é‡çº¿ç¨‹å³å¯ç®¡ç†æµ·é‡è¿æ¥çš„è®¾è®¡å°±å¯ä»¥åœ¨è¿™æ ·ç½‘ç»œä¸šåŠ¡ä¸­å¤§æ˜¾èº«æ‰‹äº†ï¼š</p>

<p>MultiReactors.png</p>

<p>åœ¨ç»å¤§éƒ¨åˆ†åº”ç”¨åœºæ™¯ä¸‹ï¼Œæˆ‘æ¨èå¤§å®¶è¿˜æ˜¯éµå¾ª Go çš„ best practicesï¼Œä½¿ç”¨åŸç”Ÿçš„ Go ç½‘ç»œåº“æ¥æ„å»ºè‡ªå·±çš„ç½‘ç»œåº”ç”¨ã€‚ç„¶è€Œï¼Œåœ¨æŸäº›æåº¦è¿½æ±‚æ€§èƒ½ã€å‹æ¦¨ç³»ç»Ÿèµ„æºä»¥åŠæŠ€æœ¯æ ˆå¿…é¡»æ˜¯åŸç”Ÿ Go ï¼ˆä¸è€ƒè™‘ C/C++ å†™ä¸­é—´å±‚è€Œ Go å†™ä¸šåŠ¡å±‚ï¼‰çš„ä¸šåŠ¡åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘è‡ªå·±æ„å»º Reactor ç½‘ç»œæ¨¡å‹ã€‚</p>

<p>gnet
gnet æ˜¯ä¸€ä¸ªåŸºäºäº‹ä»¶é©±åŠ¨çš„é«˜æ€§èƒ½å’Œè½»é‡çº§ç½‘ç»œæ¡†æ¶ã€‚å®ƒç›´æ¥ä½¿ç”¨ epoll å’Œ kqueue ç³»ç»Ÿè°ƒç”¨è€Œéæ ‡å‡† Go ç½‘ç»œåŒ…ï¼šnet æ¥æ„å»ºç½‘ç»œåº”ç”¨ï¼Œå®ƒçš„å·¥ä½œåŸç†ç±»ä¼¼ä¸¤ä¸ªå¼€æºçš„ç½‘ç»œåº“ï¼šnetty å’Œ libuvï¼Œè¿™ä¹Ÿä½¿å¾—gnet è¾¾åˆ°äº†ä¸€ä¸ªè¿œè¶… Go net çš„æ€§èƒ½è¡¨ç°ã€‚</p>

<p>gnet è®¾è®¡å¼€å‘çš„åˆè¡·ä¸æ˜¯ä¸ºäº†å–ä»£ Go çš„æ ‡å‡†ç½‘ç»œåº“ï¼šnetï¼Œè€Œæ˜¯ä¸ºäº†åˆ›é€ å‡ºä¸€ä¸ªç±»ä¼¼äº Redisã€Haproxy èƒ½é«˜æ•ˆå¤„ç†ç½‘ç»œåŒ…çš„ Go è¯­è¨€ç½‘ç»œæœåŠ¡å™¨æ¡†æ¶ã€‚</p>

<p>gnet çš„å–ç‚¹åœ¨äºå®ƒæ˜¯ä¸€ä¸ªé«˜æ€§èƒ½ã€è½»é‡çº§ã€éé˜»å¡çš„çº¯ Go å®ç°çš„ä¼ è¾“å±‚ï¼ˆTCP/UDP/Unix Domain Socketï¼‰ç½‘ç»œæ¡†æ¶ï¼Œå¼€å‘è€…å¯ä»¥ä½¿ç”¨ gnet æ¥å®ç°è‡ªå·±çš„åº”ç”¨å±‚ç½‘ç»œåè®®(HTTPã€RPCã€Redisã€WebSocket ç­‰ç­‰)ï¼Œä»è€Œæ„å»ºå‡ºè‡ªå·±çš„åº”ç”¨å±‚ç½‘ç»œåº”ç”¨ï¼šæ¯”å¦‚åœ¨ gnet ä¸Šå®ç° HTTP åè®®å°±å¯ä»¥åˆ›å»ºå‡ºä¸€ä¸ª HTTP æœåŠ¡å™¨ æˆ–è€… Web å¼€å‘æ¡†æ¶ï¼Œå®ç° Redis åè®®å°±å¯ä»¥åˆ›å»ºå‡ºè‡ªå·±çš„ Redis æœåŠ¡å™¨ç­‰ç­‰ã€‚</p>

<p>gnetï¼Œåœ¨æŸäº›æç«¯çš„ç½‘ç»œä¸šåŠ¡åœºæ™¯ï¼Œæ¯”å¦‚æµ·é‡è¿æ¥ã€é«˜é¢‘çŸ­è¿æ¥ã€ç½‘ç»œå°åŒ…ç­‰ç­‰åœºæ™¯ï¼Œgnet åœ¨æ€§èƒ½å’Œèµ„æºå ç”¨ä¸Šéƒ½è¿œè¶… Go åŸç”Ÿçš„ net åŒ…ï¼ˆåŸºäº netpollerï¼‰ã€‚</p>

<p>gnet å·²ç»å®ç°äº† Multi-Reactors å’Œ Multi-Reactors + Goroutine Pool ä¸¤ç§ç½‘ç»œæ¨¡å‹ï¼Œä¹Ÿå¾—ç›Šäºè¿™äº›ç½‘ç»œæ¨¡å‹ï¼Œä½¿å¾— gnet æˆä¸ºä¸€ä¸ªé«˜æ€§èƒ½å’Œä½æŸè€—çš„ Go ç½‘ç»œæ¡†æ¶
<!-- more --></p>

<p>https://strikefreedom.top/go-netpoll-io-multiplexing-reactor</p>

<p>https://strikefreedom.top/reading-list</p>
:ET