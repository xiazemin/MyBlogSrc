I"<p>https://github.com/opencontainers/runc/tree/v1.0.0-rc6
å®¹å™¨è¿è¡Œæ—¶(Container Runtime)æ˜¯æŒ‡ç®¡ç†å®¹å™¨å’Œå®¹å™¨é•œåƒçš„è½¯ä»¶ã€‚å½“å‰ä¸šå†…æ¯”è¾ƒæœ‰åçš„æœ‰dockerï¼Œrktç­‰ã€‚å¦‚æœä¸åŒçš„è¿è¡Œæ—¶åªèƒ½æ”¯æŒå„è‡ªçš„å®¹å™¨ï¼Œé‚£ä¹ˆæ˜¾ç„¶ä¸åˆ©äºæ•´ä¸ªå®¹å™¨æŠ€æœ¯çš„å‘å±•ã€‚äºæ˜¯åœ¨2015å¹´6æœˆï¼Œç”±Dockerä»¥åŠå…¶ä»–å®¹å™¨é¢†åŸŸçš„é¢†å¯¼è€…å…±åŒå»ºç«‹äº†å›´ç»•å®¹å™¨æ ¼å¼å’Œè¿è¡Œæ—¶çš„å¼€æ”¾çš„å·¥ä¸šåŒ–æ ‡å‡†ï¼Œå³Open Container Initiative(OCI)ï¼ŒOCIå…·ä½“åŒ…å«ä¸¤ä¸ªæ ‡å‡†ï¼šè¿è¡Œæ—¶æ ‡å‡†(runtime-spec)å’Œå®¹å™¨é•œåƒæ ‡å‡†(image-spec)ã€‚ç®€å•æ¥è¯´ï¼Œå®¹å™¨é•œåƒæ ‡å‡†å®šä¹‰äº†å®¹å™¨é•œåƒçš„æ‰“åŒ…å½¢å¼(pack format)ï¼Œè€Œè¿è¡Œæ—¶æ ‡å‡†å®šä¹‰äº†å¦‚ä½•å»è¿è¡Œä¸€ä¸ªå®¹å™¨ã€‚</p>

<p>æœ¬æ–‡åŒ…å«ä»¥ä¸‹å†…å®¹ï¼š</p>

<p>runCçš„æ¦‚å¿µå’Œä½¿ç”¨
runCè¿è¡Œå®¹å™¨çš„åŸç†å‰–æ
æœ¬æ–‡ä¸åŒ…å«ä»¥ä¸‹å†…å®¹ï¼š</p>

<p>docker engineä½¿ç”¨runC
<!-- more -->
runCæ¦‚å¿µ
runCæ˜¯ä¸€ä¸ªéµå¾ªOCIæ ‡å‡†çš„ç”¨æ¥è¿è¡Œå®¹å™¨çš„å‘½ä»¤è¡Œå·¥å…·(CLI Tool)ï¼Œå®ƒä¹Ÿæ˜¯ä¸€ä¸ªRuntimeçš„å®ç°ã€‚å°½ç®¡ä½ å¯èƒ½å¯¹è¿™ä¸ªæ¦‚å¿µå¾ˆé™Œç”Ÿï¼Œä½†å®é™…ä¸Šï¼Œä½ çš„ç”µè„‘ä¸Šçš„dockeråº•å±‚å¯èƒ½æ­£åœ¨ä½¿ç”¨å®ƒã€‚è‡³å°‘åœ¨ç¬”è€…çš„ä¸»æœºä¸Šæ˜¯è¿™æ ·ã€‚</p>

<p>root@node-1:~# docker info
â€¦..
Runtimes: runc
Default Runtime: runc 
â€¦..
å®‰è£…runC
runCä¸ä»…å¯ä»¥è¢«docker engineä½¿ç”¨ï¼Œå®ƒä¹Ÿå¯ä»¥å•ç‹¬ä½¿ç”¨(å®ƒæœ¬èº«å°±æ˜¯å‘½ä»¤è¡Œå·¥å…·)ï¼Œä»¥ä¸‹ä½¿ç”¨æ­¥éª¤å®Œå…¨æ¥è‡ªrunCâ€™s README,å¦‚æœ</p>

<p>ä¾èµ–é¡¹
Go version 1.6æˆ–æ›´é«˜ç‰ˆæœ¬
libseccompåº“</p>

<p>yum install libseccomp-devel for CentOS
 apt-get install libseccomp-dev for Ubuntu
ä¸‹è½½ç¼–è¯‘</p>
<h1 id="åœ¨gopathsrcç›®å½•åˆ›å»ºgithubcomopencontainersç›®å½•">åœ¨GOPATH/srcç›®å½•åˆ›å»ºâ€™github.com/opencontainersâ€™ç›®å½•</h1>
<blockquote>
  <p>cd github.com/opencontainers
git clone https://github.com/opencontainers/runc
cd runc</p>
</blockquote>

<blockquote>
  <p>make
sudo make install
æˆ–è€…ä½¿ç”¨go getå®‰è£…</p>
</blockquote>

<h1 id="åœ¨gopathsrcç›®å½•åˆ›å»ºgithubcomç›®å½•">åœ¨GOPATH/srcç›®å½•åˆ›å»ºgithub.comç›®å½•</h1>
<blockquote>
  <p>go get github.com/opencontainers/runc
cd $GOPATH/src/github.com/opencontainers/runc
make
sudo make install
ä»¥ä¸Šæ­¥éª¤å®Œæˆåï¼ŒrunCå°†å®‰è£…åœ¨/usr/local/sbin/runcç›®å½•</p>
</blockquote>

<p>ä½¿ç”¨runC
åˆ›å»ºä¸€ä¸ªOCI Bundle
OCI Bundleæ˜¯æŒ‡æ»¡è¶³OCIæ ‡å‡†çš„ä¸€ç³»åˆ—æ–‡ä»¶ï¼Œè¿™äº›æ–‡ä»¶åŒ…å«äº†è¿è¡Œå®¹å™¨æ‰€éœ€è¦çš„æ‰€æœ‰æ•°æ®ï¼Œå®ƒä»¬å­˜æ”¾åœ¨ä¸€ä¸ªå…±åŒçš„ç›®å½•ï¼Œè¯¥ç›®å½•åŒ…å«ä»¥ä¸‹ä¸¤é¡¹ï¼š</p>

<p>config.jsonï¼šåŒ…å«å®¹å™¨è¿è¡Œçš„é…ç½®æ•°æ®
container çš„ root filesystem
å¦‚æœä¸»æœºä¸Šå®‰è£…äº†dockerï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨docker exportå‘½ä»¤å°†å·²æœ‰é•œåƒå¯¼å‡ºä¸ºOCI Bundleçš„æ ¼å¼</p>

<h1 id="create-the-top-most-bundle-directory">create the top most bundle directory</h1>
<blockquote>
  <p>mkdir /mycontainer
cd /mycontainer</p>
</blockquote>

<h1 id="create-the-rootfs-directory">create the rootfs directory</h1>
<blockquote>
  <p>mkdir rootfs</p>
</blockquote>

<h1 id="export-busybox-via-docker-into-the-rootfs-directory">export busybox via Docker into the rootfs directory</h1>
<blockquote>
  <p>docker export $(docker create busybox) | tar -C rootfs -xvf -
ls rootfs 
bin  dev  etc  home  proc  root  sys  tmp  usr  var
æœ‰äº†root filesystemï¼Œè¿˜éœ€è¦config.jsonï¼Œrunc specå¯ä»¥ç”Ÿæˆä¸€ä¸ªåŸºç¡€æ¨¡æ¿ï¼Œä¹‹åæˆ‘ä»¬å¯ä»¥åœ¨æ¨¡æ¿åŸºç¡€ä¸Šè¿›è¡Œä¿®æ”¹ã€‚</p>
</blockquote>

<blockquote>
  <p>runc spec
ls
config.json rootfs
ç”Ÿæˆçš„config.jsonæ¨¡æ¿æ¯”è¾ƒé•¿ï¼Œè¿™é‡Œæˆ‘å°†å®ƒprocessä¸­çš„arg å’Œ terminalè¿›è¡Œä¿®æ”¹</p>
</blockquote>

<p>{
    â€œprocessâ€: {
        â€œterminalâ€:falseï¼Œ     &lt;â€“  è¿™é‡Œæ”¹ä¸º true
        â€œuserâ€: {
            â€œuidâ€: 0,
            â€œgidâ€: 0
        },
        â€œargsâ€: [
            â€œshâ€               &lt;â€“ è¿™é‡Œæ”¹ä¸º â€œsleepâ€,â€5â€
        ],
        â€œenvâ€: [
            â€œPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binâ€,
            â€œTERM=xtermâ€<br />
        ],
        â€œcwdâ€: â€œ/â€,
    },
    â€œrootâ€: {
        â€œpathâ€: â€œrootfsâ€,
        â€œreadonlyâ€: true
    }, <br />
    â€œlinuxâ€: {
        â€œnamespacesâ€: [
            {
                â€œtypeâ€: â€œpidâ€
            },
            {
                â€œtypeâ€: â€œnetworkâ€
            },
            {
                â€œtypeâ€: â€œipcâ€
            },
            {
                â€œtypeâ€: â€œutsâ€
            },
            {
                â€œtypeâ€: â€œmountâ€
            }
        ],
    }
} 
config.json æ–‡ä»¶çš„å†…å®¹éƒ½æ˜¯ OCI Container Runtime çš„è®¢åˆ¶ï¼Œå…¶ä¸­æ¯ä¸€é¡¹å€¼éƒ½å¯ä»¥åœ¨Runtime Specæ‰¾åˆ°å…·ä½“å«ä¹‰ï¼ŒOCI Container Runtime æ”¯æŒå¤šç§å¹³å°ï¼Œå› æ­¤å…¶ Spec ä¹Ÿåˆ†ä¸ºé€šç”¨éƒ¨åˆ†ï¼ˆåœ¨config.mdä¸­æè¿°ï¼‰ä»¥åŠå¹³å°ç›¸å…³çš„éƒ¨åˆ†ï¼ˆå¦‚linuxå¹³å°ä¸Šå°±æ˜¯config-linuxï¼‰</p>

<p>process:æŒ‡å®šå®¹å™¨å¯åŠ¨åè¿è¡Œçš„è¿›ç¨‹è¿è¡Œç¯å¢ƒï¼Œå…¶ä¸­æœ€é‡è¦çš„çš„å­é¡¹å°±æ˜¯argsï¼Œå®ƒæŒ‡å®šè¦è¿è¡Œçš„å¯æ‰§è¡Œç¨‹åºï¼Œ åœ¨ä¸Šé¢çš„ä¿®æ”¹åçš„æ¨¡æ¿ä¸­ï¼Œæˆ‘ä»¬å°†å…¶æ”¹æˆäº†â€sleep 5â€
rootï¼šæŒ‡å®šå®¹å™¨çš„æ ¹æ–‡ä»¶ç³»ç»Ÿï¼Œå…¶ä¸­pathå­é¡¹æ˜¯æŒ‡å‘å‰é¢å¯¼å‡ºçš„ä¸­root filesystemçš„è·¯å¾„
linux: è¿™ä¸€é¡¹æ˜¯å¹³å°ç›¸å…³çš„ã€‚å…¶ä¸­namespacesè¡¨ç¤ºæ–°åˆ›å»ºçš„å®¹å™¨ä¼šé¢å¤–åˆ›å»ºæˆ–ä½¿ç”¨çš„namespaceçš„ç±»å‹
è¿è¡Œå®¹å™¨
ç°åœ¨æˆ‘ä»¬ä½¿ç”¨createå‘½ä»¤åˆ›å»ºå®¹å™¨</p>

<h1 id="run-as-root">run as root</h1>
<blockquote>
  <p>cd /mycontainer
runc create mycontainerid
ä½¿ç”¨listå‘½ä»¤æŸ¥çœ‹å®¹å™¨çŠ¶æ€ä¸ºcreated</p>
</blockquote>

<h1 id="view-the-container-is-created-and-in-the-created-state">view the container is created and in the â€œcreatedâ€ state</h1>
<blockquote>
  <p>runc list
ID              PID         STATUS      BUNDLE                           CREATED                          OWNER
mycontainerid   12068       created     /mycontainer   2018-12-25T19:45:37.346925609Z                      root 
ä½¿ç”¨startå‘½ä»¤æŸ¥çœ‹å®¹å™¨çŠ¶æ€</p>
</blockquote>

<h1 id="start-the-process-inside-the-container">start the process inside the container</h1>
<blockquote>
  <p>runc start mycontainerid
åœ¨5så†… ä½¿ç”¨listå‘½ä»¤æŸ¥çœ‹å®¹å™¨çŠ¶æ€ä¸ºrunning</p>
</blockquote>

<h1 id="within-5-seconds-view-that-the-container-is-running">within 5 seconds view that the container is running</h1>
<p>runc list
ID              PID         STATUS      BUNDLE                           CREATED                          OWNER
mycontainerid   12068       running     /mycontainer   2018-12-25T19:45:37.346925609Z                      root 
åœ¨5så ä½¿ç”¨listå‘½ä»¤æŸ¥çœ‹å®¹å™¨çŠ¶æ€ä¸ºstopped</p>

<h1 id="after-5-seconds-view-that-the-container-has-exited-and-is-now-in-the-stopped-state">after 5 seconds view that the container has exited and is now in the stopped state</h1>
<p>runc list
ID              PID         STATUS      BUNDLE                           CREATED                          OWNER
mycontainerid   0           stopped     /mycontainer   2018-12-25T19:45:37.346925609Z                       root 
ä½¿ç”¨deleteå‘½ä»¤å¯ä»¥åˆ é™¤å®¹å™¨</p>

<h1 id="now-delete-the-container">now delete the container</h1>
<p>runc delete mycontainerid
runC å®ç°
runCå¯ä»¥å¯åŠ¨å¹¶ç®¡ç†ç¬¦åˆOCIæ ‡å‡†çš„å®¹å™¨ã€‚ç®€å•åœ°è¯´ï¼ŒrunCéœ€è¦åˆ©ç”¨OCI bundleåˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„è¿è¡Œç¯å¢ƒï¼Œå¹¶æ‰§è¡ŒæŒ‡å®šçš„ç¨‹åºã€‚åœ¨Linuxå¹³å°ä¸Šï¼Œè¿™ä¸ªç¯å¢ƒå°±æ˜¯æŒ‡å„ç§ç±»å‹çš„Namespaceä»¥åŠCapabilityç­‰ç­‰é…ç½®</p>

<p>ä»£ç ç»“æ„
runCç”±Goè¯­è¨€å®ç°ï¼Œå½“å‰(2018.12)æœ€æ–°ç‰ˆæœ¬æ˜¯v1.0.0-rc6,ä»£ç çš„ç»“æ„å¯åˆ†ä¸ºä¸¤å¤§å—,ä¸€æ˜¯æ ¹ç›®å½•ä¸‹çš„goæ–‡ä»¶ï¼Œå¯¹åº”å„ä¸ªrunCå‘½ä»¤ï¼ŒäºŒæ˜¯è´Ÿè´£åˆ›å»º/å¯åŠ¨/ç®¡ç†å®¹å™¨çš„libcontainerï¼Œå¯ä»¥è¯´runCçš„æœ¬è´¨éƒ½åœ¨libcontainer
runc</p>

<p>runc create å®ç°åŸç† (ä¸Š)
ä»¥ä¸Šé¢çš„ä¾‹å­ä¸ºä¾‹ï¼Œä»¥â€™runc createâ€™è¿™æ¡å‘½ä»¤æ¥çœ‹runCæ˜¯å¦‚ä½•å®Œæˆä»æ— åˆ°æœ‰åˆ›å»ºå®¹å™¨ï¼Œå¹¶è¿è¡Œç”¨æˆ·æŒ‡å®šçš„ â€˜sleep 5â€™ è¿™ä¸ªè¿›ç¨‹çš„ã€‚</p>

<p>åˆ›å»ºå®¹å™¨ï¼Œè¿è¡Œ sleep 5 å°±æ˜¯æˆ‘ä»¬çš„ç›®æ ‡ï¼Œè¯·ç‰¢è®°
æœ¬æ–‡æ¶‰åŠçš„è°ƒç”¨å…³ç³»å¦‚ä¸‹ï¼Œå¯éšæ—¶ç¿»é˜…
 setupSpec(context)
 startContainer(context, spec, CT_ACT_CREATE, nil) 
   |- createContainer
      |- specconv.CreateLibcontainerConfig
      |- loadFactory(context)
         |- libcontainer.New(â€¦â€¦)
      |- factory.Create(id, config)
   |- runner.run(spec.Process)
      |- newProcess(*config, r.init) 
      |- r.container.Start(process)
         |- c.createExecFifo()
         |- c.start(process)
            |- c.newParentProcess(process)
            |- parent.start()
createå‘½ä»¤çš„å“åº”å…¥å£åœ¨ create.go, æˆ‘ä»¬ç›´æ¥å…³æ³¨å…¶æ³¨å†Œçš„Actionçš„å®ç°ï¼Œå½“è¾“å…¥runc create mycontaineridæ—¶ä¼šæ‰§è¡Œæ³¨å†Œçš„Actionï¼Œå¹¶ä¸”å‚æ•°å­˜æ”¾åœ¨Contextä¸­</p>

<p>/* run.go  <em>/
Action: func(context *cli.Context) error { 
  â€¦â€¦
  spec, err := setupSpec(context)   /</em> (sleep 5 åœ¨è¿™é‡Œ) */</p>

<p>status, err := startContainer(context, spec, CT_ACT_CREATE, nil) 
  â€¦..
}
setupSpecï¼šä»å‘½ä»¤è¡Œè¾“å…¥ä¸­æ‰¾åˆ°-b æŒ‡å®šçš„ OCI bundle ç›®å½•ï¼Œè‹¥æ²¡æœ‰æ­¤å‚æ•°ï¼Œåˆ™é»˜è®¤æ˜¯å½“å‰ç›®å½•ã€‚è¯»å–config.jsonæ–‡ä»¶ï¼Œå°†å…¶ä¸­çš„å†…å®¹è½¬æ¢ä¸ºGoçš„æ•°æ®ç»“æ„specs.Specï¼Œè¯¥ç»“æ„å®šä¹‰åœ¨æ–‡ä»¶ github.com/opencontainers/runtime-spec/specs-go/config.go,é‡Œé¢çš„å†…å®¹éƒ½æ˜¯OCIæ ‡å‡†æè¿°çš„ã€‚
sleep 5 åˆ°äº†å˜é‡ spec
startContainerï¼šå°è¯•åˆ›å»ºå¯åŠ¨å®¹å™¨ï¼Œæ³¨æ„è¿™é‡Œçš„ç¬¬ä¸‰ä¸ªå‚æ•°æ˜¯ CT_ACT_CREATE, è¡¨ç¤ºä»…åˆ›å»ºå®¹å™¨ã€‚æœ¬æ–‡ä½¿ç”¨linuxå¹³å°ï¼Œå› æ­¤å®é™…è°ƒç”¨çš„æ˜¯ utils_linux.go ä¸­çš„startContainer()ã€‚startContainer()æ ¹æ®ç”¨æˆ·å°†ç”¨æˆ·è¾“å…¥çš„ id å’Œåˆšæ‰çš„å¾—åˆ°çš„ spec ä½œä¸ºè¾“å…¥ï¼Œè°ƒç”¨ createContainer() æ–¹æ³•åˆ›å»ºå®¹å™¨ï¼Œå†é€šè¿‡ä¸€ä¸ªrunner.run()æ–¹æ³•å¯åŠ¨å®ƒ
/Ã— utils_linux.go Ã—/
func startContainer(context *cli.Context, spec *specs.Spec, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) {
    id := context.Args().First()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>container, err := createContainer(context, id, spec)

r := &amp;runner{
    container:       container,
    action:          action,
    init:            true,
    ......
}
return r.run(spec.Process) } è¿™é‡Œéœ€è¦å…ˆäº†è§£ä¸‹runCä¸­çš„å‡ ä¸ªé‡è¦æ•°æ®ç»“æ„çš„å…³ç³»
</code></pre></div></div>

<p>Container æ¥å£
åœ¨runCä¸­ï¼ŒContainerç”¨æ¥è¡¨ç¤ºä¸€ä¸ªå®¹å™¨å¯¹è±¡ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŠ½è±¡æ¥å£ï¼Œå®ƒå†…éƒ¨åŒ…å«äº†BaseContaineræ¥å£ã€‚ä»å…¶å†…éƒ¨çš„æ–¹æ³•çš„åå­—å°±å¯ä»¥çœ‹å‡ºï¼Œéƒ½æ˜¯ç®¡ç†å®¹å™¨çš„åŸºæœ¬æ“ä½œ</p>

<p>/* libcontainer/container.go <em>/
type BaseContainer interface {
    ID() string
    Status() (Status, error)
    State() (</em>State, error)
    Config() configs.Config
    Processes() ([]int, error)
    Stats() (*Stats, error)
    Set(config configs.Config) error
    Start(process *Process) (err error)
    Run(process *Process) (err error)
    Destroy() error
    Signal(s os.Signal, all bool) error
    Exec() error
}</p>

<p>/* libcontainer/container_linux.go */
type Container interface {
    BaseContainer</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Checkpoint(criuOpts *CriuOpts) error
Restore(process *Process, criuOpts *CriuOpts) error
Pause() error
Resume() error
NotifyOOM() (&lt;-chan struct{}, error)
NotifyMemoryPressure(level PressureLevel) (&lt;-chan struct{}, error) } æœ‰äº†æŠ½è±¡æ¥å£ï¼Œé‚£ä¹ˆä¸€å®šæœ‰å…·ä½“çš„å®ç°ï¼ŒlinuxContainer å°±æ˜¯ä¸€ä¸ªå®ç°ï¼Œæˆ–è€…è¯´ï¼Œå®ƒæ˜¯å½“å‰ç‰ˆæœ¬runCåœ¨linuxå¹³å°ä¸Šçš„å”¯ä¸€ä¸€ç§å®ç°ã€‚ä¸‹é¢æ˜¯å…¶å®šä¹‰ï¼Œå…¶ä¸­çš„ initPath éå¸¸å…³é”®
</code></pre></div></div>

<p>type linuxContainer struct {
    id                   string
    config               *configs.Config
    initPath             string
    initArgs             []string
    initProcess          parentProcess
    â€¦..
}
Factory æ¥å£
åœ¨runCä¸­ï¼Œæ‰€æœ‰çš„å®¹å™¨éƒ½æ˜¯ç”±å®¹å™¨å·¥å‚ï¼ˆFactoryï¼‰åˆ›å»ºçš„, Factory ä¹Ÿæ˜¯ä¸€ä¸ªæŠ½è±¡æ¥å£ï¼Œå®šä¹‰å¦‚ä¸‹ï¼Œå®ƒåªåŒ…å«äº†4ä¸ªæ–¹æ³•</p>

<p>type Factory interface {
    Create(id string, config *configs.Config) (Container, error)
    Load(id string) (Container, error)
    StartInitialization() error
    Type() string
}
linuxå¹³å°ä¸Šçš„å¯¹ Factory æ¥å£ä¹Ÿæœ‰ä¸€ä¸ªæ ‡å‡†å®ç°â€”LinuxFactory,å…¶ä¸­çš„ InitPath ä¹Ÿéå¸¸å…³é”®ï¼Œç¨åæˆ‘ä»¬ä¼šçœ‹åˆ°</p>

<p>// LinuxFactory implements the default factory interface for linux based systems.
type LinuxFactory struct {
    // InitPath is the path for calling the init responsibilities for spawning
    // a container.
    InitPath string
    â€¦â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// InitArgs are arguments for calling the init responsibilities for spawning
// a container.
InitArgs []string } æ‰€ä»¥ï¼Œå¯¹äºlinuxå¹³å°ï¼ŒFactory åˆ›å»º Container å®é™…ä¸Šå°±æ˜¯ LinuxFactory åˆ›å»º linuxContainer
</code></pre></div></div>

<p>å›åˆ°createContainer(),ä¸‹é¢æ˜¯å…¶å®ç°</p>

<p>func createContainer(context <em>cli.Context, id string, spec *specs.Spec) (libcontainer.Container, error) {
    /</em> 1. å°†é…ç½®å­˜æ”¾åˆ°config */
    rootlessCg, err := shouldUseRootlessCgroupManager(context)
    config, err := specconv.CreateLibcontainerConfig(&amp;specconv.CreateOpts{
        CgroupName:       id,
        UseSystemdCgroup: context.GlobalBool(â€œsystemd-cgroupâ€),
        NoPivotRoot:      context.Bool(â€œno-pivotâ€),
        NoNewKeyring:     context.Bool(â€œno-new-keyringâ€),
        Spec:             spec,                            <br />
        RootlessEUID:     os.Geteuid() != 0,
        RootlessCgroups:  rootlessCg,
    })</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* 2. åŠ è½½Factory */
factory, err := loadFactory(context)
if err != nil {
    return nil, err
}

/* 3. è°ƒç”¨Factoryçš„Create()æ–¹æ³• */
return factory.Create(id, config) } å¯ä»¥çœ‹åˆ°ï¼Œä¸Šé¢çš„ä»£ç å¤§ä½“ä¸Šåˆ†ä¸º
</code></pre></div></div>

<p>å°†é…ç½®å­˜æ”¾åˆ° config, æ•°æ®ç±»å‹æ˜¯ Config.config
åŠ è½½ Factoryï¼Œå®é™…è¿”å› LinuxFactory
è°ƒç”¨ Factory çš„Create()æ–¹æ³•
sleep 5 åˆ°äº†å˜é‡ config
ç¬¬1æ­¥å­˜æ”¾é…ç½®æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œæ— éæ˜¯å°†å·²æœ‰çš„ spec å’Œå…¶ä»–ä¸€äº›ç”¨æˆ·å‘½ä»¤è¡Œé€‰é¡¹é…ç½®æ¢æˆä¸€ä¸ªæ•°æ®ç»“æ„å­˜ä¸‹æ¥ã€‚è€Œç¬¬2éƒ¨åŠ è½½Factoryï¼Œåœ¨linuxä¸Šï¼Œå°±æ˜¯è¿”å›ä¸€ä¸ª LinuxFactory ç»“æ„ã€‚è€Œè¿™æ˜¯é€šè¿‡åœ¨å…¶å†…éƒ¨è°ƒç”¨ libcontainer.New()æ–¹æ³•å®ç°çš„</p>

<p>/* utils/utils_linux.go */
func loadFactory(context *cli.Context) (libcontainer.Factory, error) {
    â€¦..
    return libcontainer.New(abs, cgroupManager, intelRdtManager,
        libcontainer.CriuPath(context.GlobalString(â€œcriuâ€)),
        libcontainer.NewuidmapPath(newuidmap),
        libcontainer.NewgidmapPath(newgidmap))
}
libcontainer.New() æ–¹æ³•åœ¨linuxå¹³å°çš„å®ç°å¦‚ä¸‹ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œå®ƒçš„ç¡®ä¼šè¿”å›ä¸€ä¸ªLinuxFactoryï¼Œå¹¶ä¸”InitPathè®¾ç½®ä¸ºâ€/proc/self/exeâ€ï¼ŒInitArgsè®¾ç½®ä¸ºâ€initâ€</p>

<p>/* libcontainer/factory_linux.go <em>/
func New(root string, options â€¦func(</em>LinuxFactory) error) (Factory, error) {
    â€¦..
    l := &amp;LinuxFactory{
        â€¦..
        InitPath:  â€œ/proc/self/exeâ€,
        InitArgs:  []string{os.Args[0], â€œinitâ€},
    }
    â€¦â€¦
    return l, nil
}
å¾—åˆ°äº†å…·ä½“çš„ Factory å®ç°ï¼Œä¸‹ä¸€æ­¥å°±æ˜¯è°ƒç”¨å…¶Create()æ–¹æ³•,å¯¹ linux å¹³å°è€Œè¨€ï¼Œå°±æ˜¯ä¸‹é¢è¿™ä¸ªæ–¹æ³•ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œå®ƒä¼šå°† LinuxFactory ä¸Šè®°å½•çš„ InitPath å’Œ InitArgs èµ‹ç»™ linuxContainer å¹¶ä½œä¸ºç»“æœè¿”å›</p>

<p>func (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) {
    â€¦.
    c := &amp;linuxContainer{
        id:            id,  <br />
        config:        config,
        initPath:      l.InitPath,
        initArgs:      l.InitArgs,
    }
     â€¦..
    return c, nil
}
å›åˆ° startContainer() æ–¹æ³•ï¼Œå†å¾—åˆ° linuxContainer åï¼Œå°†åˆ›å»ºä¸€ä¸ª runner ç»“æ„,å¹¶è°ƒç”¨å…¶run()æ–¹æ³•</p>

<p>/* utils_linux.go */
func startContainer(context *cli.Context, spec *specs.Spec, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) {
    id := context.Args().First()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>container, err := createContainer(context, id, spec)

r := &amp;runner{
    container:       container,
    action:          action,
    init:            true,     
    ......
}
return r.run(spec.Process) } runner çš„ run() çš„å…¥å‚æ˜¯ spec.Process ç»“æ„ï¼Œæˆ‘ä»¬å¹¶ä¸éœ€è¦å…³æ³¨å®ƒçš„å®šä¹‰ï¼Œå› ä¸ºå®ƒçš„å†…å®¹éƒ½æ¥æºäº config.json æ–‡ä»¶ï¼Œspec.Process ä¸è¿‡æ˜¯å…¶ä¸­ Process éƒ¨åˆ†çš„ Go è¯­è¨€æ•°æ®çš„è¡¨ç¤ºã€‚run() æ–¹æ³•çš„å®ç°å¦‚ä¸‹ï¼š
</code></pre></div></div>

<p>func (r <em>runner) run(config *specs.Process) (int, error) { 
    â€¦â€¦
    process, err := newProcess(</em>config, r.init)                                  /*  ç¬¬1éƒ¨åˆ† <em>/
    â€¦â€¦
    switch r.action {
    case CT_ACT_CREATE:
        err = r.container.Start(process)   /</em> runc start <em>/                      /</em>  ç¬¬2éƒ¨åˆ† <em>/
    case CT_ACT_RESTORE:
        err = r.container.Restore(process, r.criuOpts) /</em> runc restore <em>/
    case CT_ACT_RUN:
        err = r.container.Run(process)     /</em> runc run */
    default:
        panic(â€œUnknown actionâ€)
    }
    â€¦â€¦
    return status, err
}
ä¸Šé¢çš„ run() å¯åˆ†ä¸ºä¸¤éƒ¨åˆ†</p>

<p>è°ƒç”¨ newProcess() æ–¹æ³•, ç”¨ spec.Process åˆ›å»º libcontainer.Process,æ³¨æ„ç¬¬äºŒä¸ªå‚æ•°æ˜¯ true ï¼Œè¡¨ç¤ºæ–°åˆ›å»ºçš„ process ä¼šä½œä¸ºæ–°åˆ›å»ºå®¹å™¨çš„ç¬¬ä¸€ä¸ª processã€‚
æ ¹æ® r.action çš„å€¼å†³å®šå¦‚ä½•æ“ä½œå¾—åˆ°çš„ libcontainer.Process
sleep 5 åˆ°äº†å˜é‡ process
libcontainer.Process ç»“æ„å®šä¹‰åœ¨ /libcontainer/process.go, å…¶ä¸­å¤§éƒ¨åˆ†å†…å®¹éƒ½æ¥è‡ª spec.Process</p>

<p>/* parent process <em>/
// Process specifies the configuration and IO for a process inside
// a container.
type Process struct {
    Args []string
    Env []string
    User string
    AdditionalGroups []string
    Cwd string
    Stdin io.Reader
    Stdout io.Writer
    Stderr io.Writer
    ExtraFiles []</em>os.File</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ConsoleWidth  uint16
ConsoleHeight uint16
Capabilities *configs.Capabilities
AppArmorProfile string
Label string
NoNewPrivileges *bool
Rlimits []configs.Rlimit
ConsoleSocket *os.File
Init bool

ops processOperations } æ¥ä¸‹æ¥å°±æ˜¯è¦ä½¿ç”¨ Start() æ–¹æ³•äº†
</code></pre></div></div>

<p>func (c *linuxContainer) Start(process *Process) error {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if process.Init {
    if err := c.createExecFifo(); err != nil {  /* 1.åˆ›å»ºfifo   */
        return err
    }
}
if err := c.start(process); err != nil {        /* 2. è°ƒç”¨start() */
    if process.Init {
        c.deleteExecFifo()
    }
    return err
}
return nil } Start() æ–¹æ³•ä¸»è¦å®Œæˆä¸¤ä»¶äº‹
</code></pre></div></div>

<p>åˆ›å»º fifo: åˆ›å»ºä¸€ä¸ªåä¸ºexec.fifoçš„ç®¡é“ï¼Œè¿™ä¸ªç®¡é“åé¢ä¼šç”¨åˆ°
è°ƒç”¨ start() æ–¹æ³•ï¼Œå¦‚ä¸‹
func (c <em>linuxContainer) start(process *Process) error {
    parent, err := c.newParentProcess(process) /</em>  1. åˆ›å»ºparentProcess */</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>err := parent.start();                     /*  2. å¯åŠ¨è¿™ä¸ªparentProcess */
......
</code></pre></div></div>

<p>start() ä¹Ÿå®Œæˆä¸¤ä»¶äº‹:</p>

<p>åˆ›å»ºä¸€ä¸ª ParentProcess
è°ƒç”¨è¿™ä¸ª ParentProcess çš„ start() æ–¹æ³•
sleep 5 åˆ°äº†å˜é‡ parent
é‚£ä¹ˆä»€ä¹ˆæ˜¯ parentProcess ? æ­£å¦‚å…¶åï¼ŒparentProcess ç±»ä¼¼äº linux ä¸­å¯ä»¥æ´¾ç”Ÿå‡ºå­è¿›ç¨‹çš„çˆ¶è¿›ç¨‹ï¼Œåœ¨runCä¸­ï¼ŒparentProcess æ˜¯ä¸€ä¸ªæŠ½è±¡æ¥å£ï¼Œå¦‚ä¸‹ï¼š</p>

<p>type parentProcess interface {
    // pid returns the pid for the running process.
    pid() int</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// start starts the process execution.
start() error

// send a SIGKILL to the process and wait for the exit.
terminate() error

// wait waits on the process returning the process state.
wait() (*os.ProcessState, error)

// startTime returns the process start time.
startTime() (uint64, error)

signal(os.Signal) error

externalDescriptors() []string

setExternalDescriptors(fds []string) } å®ƒæœ‰ä¸¤ä¸ªå®ç°ï¼Œåˆ†åˆ«ä¸º initProcess å’Œ setnsProcess ï¼Œå‰è€…ç”¨äºåˆ›å»ºå®¹å™¨å†…çš„ç¬¬ä¸€ä¸ªè¿›ç¨‹ï¼Œåè€…ç”¨äºåœ¨å·²æœ‰å®¹å™¨å†…åˆ›å»ºæ–°çš„è¿›ç¨‹ã€‚åœ¨æˆ‘ä»¬çš„åˆ›å»ºå®¹å™¨ä¾‹å­ä¸­ï¼Œp.Init = true ï¼Œæ‰€ä»¥ä¼šåˆ›å»º initProcess
</code></pre></div></div>

<p>func (c <em>linuxContainer) newParentProcess(p *Process) (parentProcess, error) {
    parentPipe, childPipe, err := utils.NewSockPair(â€œinitâ€)  /</em> 1.åˆ›å»º Socket Pair */</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd, err := c.commandTemplate(p, childPipe)              /* 2. åˆ›å»º *exec.Cmd */

if !p.Init {
    return c.newSetnsProcess(p, cmd, parentPipe, childPipe) 
}

if err := c.includeExecFifo(cmd); err != nil {           /* 3.æ‰“å¼€ä¹‹å‰åˆ›å»ºçš„fifo */
    return nil, newSystemErrorWithCause(err, "including execfifo in cmd.Exec setup")
}
return c.newInitProcess(p, cmd, parentPipe, childPipe)   /* 4.åˆ›å»º initProcess */ } newParentProcess() æ–¹æ³•åŠ¨ä½œæœ‰ 4 æ­¥ï¼Œå‰ 3 æ­¥éƒ½æ˜¯åœ¨ä¸ºç¬¬ 4 æ­¥åšå‡†å¤‡ï¼Œå³ç”Ÿæˆ initProcess
</code></pre></div></div>

<p>åˆ›å»ºä¸€å¯¹ SocketPair æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œç”Ÿæˆçš„ç»“æœä¼šæ”¾åˆ° initProcess
åˆ›å»º <em>exec.Cmd,ä»£ç å¦‚ä¸‹ï¼Œè¿™é‡Œè®¾ç½®äº† cmd è¦æ‰§è¡Œçš„å¯æ‰§è¡Œç¨‹åºå’Œå‚æ•°æ¥è‡ª c.initPathï¼Œå³æºè‡ª LinuxFactory çš„ â€œ/proc/self/exeâ€,å’Œ â€œinitâ€ ï¼Œè¿™è¡¨ç¤ºæ–°æ‰§è¡Œçš„ç¨‹åºå°±æ˜¯runCæœ¬èº«ï¼Œåªæ˜¯å‚æ•°å˜æˆäº† initï¼Œä¹‹ååˆå°†å¤–é¢åˆ›å»ºçš„ SocketPair çš„ä¸€ç«¯ childPipeæ”¾åˆ°äº†cmd.ExtraFiles ï¼ŒåŒæ—¶å°†_LIBCONTAINER_INITPIPE=%dåŠ å…¥cmd.Env,å…¶ä¸­ %dä¸ºæ–‡ä»¶æè¿°ç¬¦çš„æ•°å­—
func (c *linuxContainer) commandTemplate(p *Process, childPipe *os.File) (</em>exec.Cmd, error) {
    cmd := exec.Command(c.initPath, c.initArgs[1:]â€¦)
    cmd.Args[0] = c.initArgs[0]</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)
cmd.ExtraFiles = append(cmd.ExtraFiles, childPipe)
cmd.Env = append(cmd.Env,
    fmt.Sprintf("_LIBCONTAINER_INITPIPE=%d", stdioFdCount+len(cmd.ExtraFiles)-1),
)
......
return cmd, nil } includeExecFifo() æ–¹æ³•æ‰“å¼€ä¹‹å‰åˆ›å»ºçš„ fifoï¼Œä¹Ÿå°†å…¶ fd æ”¾åˆ° cmd.ExtraFiles ä¸­ï¼ŒåŒæ—¶å°†_LIBCONTAINER_FIFOFD=%dè®°å½•åˆ° cmd.Envã€‚ æœ€åå°±æ˜¯åˆ›å»º InitProcess äº†ï¼Œè¿™é‡Œé¦–å…ˆå°†_LIBCONTAINER_INITTYPE="standard"åŠ å…¥cmd.Envï¼Œç„¶åä» configs è¯»å–éœ€è¦æ–°çš„å®¹å™¨åˆ›å»ºçš„ Namespace çš„ç±»å‹ï¼Œå¹¶å°†å…¶æ‰“åŒ…åˆ°å˜é‡ data ä¸­å¤‡ç”¨ï¼Œæœ€åå†åˆ›å»º InitProcess è‡ªå·±ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œå°†ä¹‹å‰çš„ä¸€äº›èµ„æºå’Œå˜é‡éƒ½è”ç³»äº†èµ·æ¥ func (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, parentPipe, childPipe *os.File) (*initProcess, error) {
cmd.Env = append(cmd.Env, "_LIBCONTAINER_INITTYPE="+string(initStandard))
nsMaps := make(map[configs.NamespaceType]string)
for _, ns := range c.config.Namespaces {
    if ns.Path != "" {
        nsMaps[ns.Type] = ns.Path
    }
}
_, sharePidns := nsMaps[configs.NEWPID]
data, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)
if err != nil {
    return nil, err
}
return &amp;initProcess{
    cmd:             cmd,
    childPipe:       childPipe,
    parentPipe:      parentPipe,
    manager:         c.cgroupManager,
    intelRdtManager: c.intelRdtManager,
    config:          c.newInitConfig(p),
    container:       c,
    process:         p,          /*  sleep 5 åœ¨è¿™é‡Œ */
    bootstrapData:   data,
    sharePidns:      sharePidns,
}, nil } sleep 5 åœ¨ initProcess.process ä¸­ å›åˆ° linuxContainer çš„ start() æ–¹æ³•ï¼Œåˆ›å»ºå¥½äº† parent ï¼Œä¸‹ä¸€æ­¥å°±æ˜¯è°ƒç”¨å®ƒçš„ start() æ–¹æ³•äº†
</code></pre></div></div>

<p>func (c <em>linuxContainer) start(process *Process) error {
    parent, err := c.newParentProcess(process) /</em>  1. åˆ›å»ºparentProcess (å·²å®Œæˆ) */</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>err := parent.start();                     /*  2. å¯åŠ¨è¿™ä¸ªparentProcess */
......
</code></pre></div></div>

<p>å‰æ–‡è®²åˆ°ï¼ŒnewParentProcess() æ ¹æ®æºè‡ª config.json çš„é…ç½®ï¼Œæœ€ç»ˆç”Ÿæˆå˜é‡ initProcess ï¼Œè¿™ä¸ª initProcess åŒ…å«çš„ä¿¡æ¯ä¸»è¦æœ‰</p>

<p>cmd è®°å½•äº†è¦æ‰§è¡Œçš„å¯æ‰§è¡Œæ–‡ä»¶åï¼Œå³ â€œ/proc/self/exe initâ€ï¼Œæ³¨æ„ä¸è¦å’Œå®¹å™¨è¦æ‰§è¡Œçš„ sleep 5 æ··æ·†äº†
cmd.Env è®°å½•äº†åä¸º _LIBCONTAINER_FIFOFD=%d è®°å½•çš„å‘½åç®¡é“exec.fifo çš„æè¿°ç¬¦ï¼Œåä¸º_LIBCONTAINER_INITPIPE=%dè®°å½•äº†åˆ›å»ºçš„ SocketPair çš„ childPipe ä¸€ç«¯çš„æè¿°ç¬¦ï¼Œåä¸º_LIBCONTAINER_INITTYPE=â€standardâ€è®°å½•è¦åˆ›å»ºçš„å®¹å™¨ä¸­çš„è¿›ç¨‹æ˜¯åˆå§‹è¿›ç¨‹
initProcess çš„ bootstrapData è®°å½•äº†æ–°çš„å®¹å™¨è¦åˆ›å»ºå“ªäº›ç±»å‹çš„ Namespaceã€‚
/* libcontainer/container_linux.go <em>/
func (c *linuxContainer) start(process *Process) error {
    parent, err := c.newParentProcess(process) /</em>  1. åˆ›å»ºparentProcess (å·²å®Œæˆ) */</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>err := parent.start();                     /*  2. å¯åŠ¨è¿™ä¸ªparentProcess */
...... å‡†å¤‡å·¥ä½œå®Œæˆä¹‹åï¼Œå°±è¦è°ƒç”¨ start() æ–¹æ³•å¯åŠ¨ã€‚
</code></pre></div></div>

<p>æ³¨æ„: æ­¤æ—¶ sleep 5 çº¿ç´¢å­˜å‚¨åœ¨å˜é‡ parent ä¸­
runC createçš„å®ç°åŸç† (ä¸‹)
start() å‡½æ•°å®åœ¨å¤ªé•¿äº†ï¼Œå› æ­¤é€æ®µæ¥çœ‹</p>

<p>/* libcontainer/process_linux.go */
func (p *initProcess) start() error {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p.cmd.Start()                 
p.process.ops = p    
io.Copy(p.parentPipe, p.bootstrapData)

..... } p.cmd.Start() å¯åŠ¨ cmd ä¸­è®¾ç½®çš„è¦æ‰§è¡Œçš„å¯æ‰§è¡Œæ–‡ä»¶ /proc/self/exeï¼Œå‚æ•°æ˜¯ initï¼Œè¿™ä¸ªå‡½æ•°ä¼šå¯åŠ¨ä¸€ä¸ªæ–°çš„è¿›ç¨‹å»æ‰§è¡Œè¯¥å‘½ä»¤ï¼Œå¹¶ä¸”ä¸ä¼šé˜»å¡ã€‚ io.Copy å°† p.bootstrapData ä¸­çš„æ•°æ®é€šè¿‡ p.parentPipe å‘é€ç»™å­è¿›ç¨‹ /proc/self/exe æ­£æ˜¯runcç¨‹åºè‡ªå·±ï¼Œæ‰€ä»¥è¿™é‡Œç›¸å½“äºæ˜¯æ‰§è¡Œrunc initï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬è¾“å…¥çš„æ˜¯runc createå‘½ä»¤ï¼Œéšå«ç€åˆå»åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„å­è¿›ç¨‹å»æ‰§è¡Œrunc initã€‚ä¸ºä»€ä¹ˆè¦é¢å¤–é‡æ–°åˆ›å»ºä¸€ä¸ªè¿›ç¨‹å‘¢ï¼ŸåŸå› æ˜¯æˆ‘ä»¬åˆ›å»ºçš„å®¹å™¨å¾ˆå¯èƒ½éœ€è¦è¿è¡Œåœ¨ä¸€äº›ç‹¬ç«‹çš„ namespace ä¸­ï¼Œæ¯”å¦‚ user namespace,è¿™æ˜¯é€šè¿‡ setns() ç³»ç»Ÿè°ƒç”¨å®Œæˆçš„ï¼Œè€Œåœ¨setns man pageä¸­å†™äº†ä¸‹é¢ä¸€æ®µè¯
</code></pre></div></div>

<p>A multiâ€threaded process may not change user namespace with setns(). It is not permitted to use setns() to reenter the callerâ€™s current user namesâ€pace
å³å¤šçº¿ç¨‹çš„è¿›ç¨‹æ˜¯ä¸èƒ½é€šè¿‡ setns()æ”¹å˜user namespaceçš„ã€‚è€Œä¸å¹¸çš„æ˜¯ Go runtime æ˜¯å¤šçº¿ç¨‹çš„ã€‚é‚£æ€ä¹ˆåŠå‘¢ ï¼Ÿæ‰€ä»¥setns()å¿…é¡»è¦åœ¨Go runtime å¯åŠ¨ä¹‹å‰å°±è®¾ç½®å¥½,è¿™å°±è¦ç”¨åˆ°cgoäº†ï¼Œåœ¨Go runtime å¯åŠ¨å‰é¦–å…ˆæ‰§è¡ŒåµŒå…¥åœ¨å‰é¢çš„ C ä»£ç ã€‚</p>

<p>å…·ä½“çš„åšæ³•åœ¨nsenter READMEæè¿° åœ¨runc initå‘½ä»¤çš„å“åº”åœ¨æ–‡ä»¶ init.go å¼€å¤´ï¼Œå¯¼å…¥ nsenter åŒ…</p>

<p>/* init.go */
import (
    â€œosâ€
    â€œruntimeâ€</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/opencontainers/runc/libcontainer"
_ "github.com/opencontainers/runc/libcontainer/nsenter"
"github.com/urfave/cli" ) è€ŒnsenteråŒ…ä¸­å¼€å¤´é€šè¿‡ cgo åµŒå…¥äº†ä¸€æ®µ C ä»£ç , è°ƒç”¨ nsexec()
</code></pre></div></div>

<p>package nsenter
/*
/* nsenter.go */
#cgo CFLAGS: -Wall
extern void nsexec();
void <strong>attribute</strong>((constructor)) init(void) {
    nsexec();
}
*/
import â€œCâ€
æ¥ä¸‹æ¥ï¼Œè½®åˆ° nsexec() å®Œæˆä¸ºå®¹å™¨åˆ›å»ºæ–°çš„ namespace çš„å·¥ä½œäº†, nsexec() åŒæ ·å¾ˆé•¿ï¼Œé€æ®µæ¥çœ‹</p>

<p>/* libcontainer/nsenter/nsexec.c */
void nsexec(void)
{
    int pipenum;
    jmp_buf env;
    int sync_child_pipe[2], sync_grandchild_pipe[2];
    struct nlconfig_t config = { 0 };</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * If we don't have an init pipe, just return to the go routine.
 * We'll only get an init pipe for start or exec.
 */
pipenum = initpipe();
if (pipenum == -1)
    return;

/* Parse all of the netlink configuration. */
nl_parse(pipenum, &amp;config);
   
......     ä¸Šé¢è¿™æ®µ C ä»£ç ä¸­ï¼Œinitpipe() ä»ç¯å¢ƒä¸­è¯»å–çˆ¶è¿›ç¨‹ä¹‹å‰è®¾ç½®çš„pipe(_LIBCONTAINER_INITPIPEè®°å½•çš„çš„æ–‡ä»¶æè¿°ç¬¦)ï¼Œç„¶åè°ƒç”¨ nl_parse ä»è¿™ä¸ªç®¡é“ä¸­è¯»å–é…ç½®åˆ°å˜é‡ config ï¼Œé‚£ä¹ˆè°ä¼šå¾€è¿™ä¸ªç®¡é“å†™é…ç½®å‘¢ ? å½“ç„¶å°±æ˜¯runc createçˆ¶è¿›ç¨‹äº†ã€‚çˆ¶è¿›ç¨‹é€šè¿‡è¿™ä¸ªpipeï¼Œå°†æ–°å»ºå®¹å™¨çš„é…ç½®å‘ç»™å­è¿›ç¨‹ï¼Œè¿™ä¸ªè¿‡ç¨‹å¦‚ä¸‹å›¾æ‰€ç¤º:
</code></pre></div></div>

<p>ipc</p>

<p>å‘é€çš„å…·ä½“æ•°æ®åœ¨ linuxContainer çš„ bootstrapData() å‡½æ•°ä¸­å°è£…æˆnetlink msgæ ¼å¼çš„æ¶ˆæ¯ã€‚å¿½ç•¥å¤§éƒ¨åˆ†é…ç½®ï¼Œæœ¬æ–‡é‡ç‚¹å…³æ³¨namespaceçš„é…ç½®ï¼Œå³è¦åˆ›å»ºå“ªäº›ç±»å‹çš„namespaceï¼Œè¿™äº›éƒ½æ˜¯æºè‡ªæœ€åˆçš„config.jsonæ–‡ä»¶ã€‚</p>

<p>è‡³æ­¤ï¼Œå­è¿›ç¨‹å°±ä»çˆ¶è¿›ç¨‹å¤„å¾—åˆ°äº†namespaceçš„é…ç½®ï¼Œç»§ç»­å¾€ä¸‹ï¼Œ nsexec() åˆåˆ›å»ºäº†ä¸¤ä¸ªsocketpair,ä»æ³¨é‡Šä¸­äº†è§£åˆ°ï¼Œè¿™æ˜¯ä¸ºäº†å’Œå®ƒè‡ªå·±çš„å­è¿›ç¨‹å’Œå­™è¿›ç¨‹è¿›è¡Œé€šä¿¡ã€‚</p>

<p>void nsexec(void)
{
   â€¦..
    /* Pipe so we can tell the child when weâ€™ve finished setting up. */
    if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) &lt; 0)  //  sync_child_pipe is an out parameter
        bail(â€œfailed to setup sync pipe between parent and childâ€);</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 * We need a new socketpair to sync with grandchild so we don't have
 * race condition with child.
 */
if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) &lt; 0)
    bail("failed to setup sync pipe between parent and grandchild");
</code></pre></div></div>

<p>}
ç„¶åå°±è¯¥åˆ›å»ºnamespaceäº†ï¼Œçœ‹æ³¨é‡Šå¯çŸ¥è¿™é‡Œå…¶å®æœ‰è€ƒè™‘è¿‡ä¸‰ä¸ªæ–¹æ¡ˆ</p>

<p>first clone then clone
first unshare then clone
first clone then unshare
æœ€ç»ˆé‡‡ç”¨çš„æ˜¯æ–¹æ¡ˆ 3,å…¶ä¸­ç¼˜ç”±ç”±äºè€ƒè™‘å› ç´ å¤ªå¤šï¼Œæ‰€ä»¥å‡†å¤‡ä¹‹åå¦å†™ä¸€ç¯‡æ–‡ç« åˆ†æ</p>

<p>æ¥ä¸‹æ¥å°±æ˜¯ä¸€ä¸ªå¤§çš„ switch case ç¼–å†™çš„çŠ¶æ€æœº,å¤§ä½“ç»“æ„å¦‚ä¸‹ï¼Œå½“å‰è¿›ç¨‹é€šè¿‡clone()ç³»ç»Ÿè°ƒç”¨åˆ›å»ºå­è¿›ç¨‹ï¼Œå­è¿›ç¨‹åˆé€šè¿‡clone()ç³»ç»Ÿè°ƒç”¨åˆ›å»ºå­™è¿›ç¨‹ï¼Œè€Œå®é™…çš„åˆ›å»º/åŠ å…¥namespaceæ˜¯åœ¨å­è¿›ç¨‹å®Œæˆçš„</p>

<p>switch (setjmp(env)) {
  case JUMP_PARENT:{
           â€¦..
           clone_parent(&amp;env, JUMP_CHILD);
           â€¦..
       }
  case JUMP_CHILD:{
           â€¦â€¦
           if (config.namespaces)
                join_namespaces(config.namespaces);
           clone_parent(&amp;env, JUMP_INIT);
           â€¦â€¦
       }
  case JUMP_INIT:{
       }
æœ¬æ–‡ä¸å‡†å¤‡å±•å¼€åˆ†æè¿™ä¸ªçŠ¶æ€æœºäº†ï¼Œè€Œå°†è¿™ä¸ªçŠ¶æ€æœºçš„æµç¨‹ç”»åœ¨äº†ä¸‹é¢çš„æ—¶åºå›¾ä¸­ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ä»¥ä¸‹å‡ ç‚¹</p>

<p>namespacesåœ¨runc init 2å®Œæˆåˆ›å»º
runc init 1å’Œrunc init 2æœ€ç»ˆéƒ½ä¼šæ‰§è¡Œexit(0),ä½†runc init 3ä¸ä¼šï¼Œå®ƒä¼šç»§ç»­æ‰§è¡Œrunc initå‘½ä»¤çš„ååŠéƒ¨åˆ†ã€‚å› æ­¤æœ€ç»ˆåªä¼šå‰©ä¸‹runc createè¿›ç¨‹å’Œrunc init 3è¿›ç¨‹
runc</p>

<p>å†å›åˆ°runc createè¿›ç¨‹</p>

<p>func (p *initProcess) start() error {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p.cmd.Start()
p.process.ops = p
io.Copy(p.parentPipe, p.bootstrapData);

p.execSetns()
...... å†å‘ runc initå‘é€äº† bootstrapData æ•°æ®åï¼Œä¾¿è°ƒç”¨ execSetns() ç­‰å¾…runc init 1è¿›ç¨‹ç»ˆæ­¢ï¼Œä»ç®¡é“ä¸­å¾—åˆ°runc init 3çš„è¿›ç¨‹ pid,å°†è¯¥è¿›ç¨‹ä¿å­˜åœ¨ p.process.ops
</code></pre></div></div>

<p>/* libcontainer/process_linux.go */
func (p *initProcess) execSetns() error {
    status, err := p.cmd.Process.Wait()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var pid *pid
json.NewDecoder(p.parentPipe).Decode(&amp;pid)

process, err := os.FindProcess(pid.Pid)

p.cmd.Process = process
p.process.ops = p
return nil } ç»§ç»­ start()
</code></pre></div></div>

<p>func (p *initProcess) start() error {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...... 
p.execSetns()

fds, err := getPipeFds(p.pid())
p.setExternalDescriptors(fds)
p.createNetworkInterfaces()

p.sendConfig()

parseSync(p.parentPipe, func(sync *syncT) error {
    switch sync.Type {
    case procReady:
        .....
        writeSync(p.parentPipe, procRun);
        sentRun = true
    case procHooks:
        .....
        // Sync with child.
        err := writeSync(p.parentPipe, procResume); 
        sentResume = true
    }

    return nil
})
...... å¯ä»¥çœ‹åˆ°ï¼Œrunc createåˆå¼€å§‹é€šè¿‡pipeè¿›è¡ŒåŒå‘é€šä¿¡äº†ï¼Œé€šä¿¡çš„å¯¹ç«¯è‡ªç„¶å°±æ˜¯runc init 3è¿›ç¨‹äº†ï¼Œrunc init 3è¿›ç¨‹åœ¨æ‰§è¡Œå®ŒåµŒå…¥çš„ C ä»£ç å(å®é™…æ˜¯runc init 1æ‰§è¡Œçš„ï¼Œä½†runc init 3ä¹Ÿæ˜¯ç”±runc init 1é—´æ¥clone()å‡ºæ¥çš„)ï¼Œå› æ­¤å°†å¼€å§‹è¿è¡Œ Go runtimeï¼Œå¼€å§‹å“åº”initå‘½ä»¤
</code></pre></div></div>

<p>sleep 5 é€šè¿‡ p.sendConfig() å‘é€ç»™äº†runc initè¿›ç¨‹
initå‘½ä»¤é¦–å…ˆé€šè¿‡ libcontainer.New(â€œâ€) åˆ›å»ºäº†ä¸€ä¸ª LinuxFactory,è¿™ä¸ªæ–¹æ³•åœ¨ä¸Šç¯‡æ–‡ç« ä¸­åˆ†æè¿‡ï¼Œè¿™é‡Œä¸å†è§£é‡Šã€‚ç„¶åè°ƒç”¨ LinuxFactory çš„ StartInitialization() æ–¹æ³•ã€‚</p>

<p>/* libcontainer/factory_linux.go */
// StartInitialization loads a container by opening the pipe fd from the parent to read the configuration and state
// This is a low level implementation detail of the reexec and should not be consumed externally
func (l *LinuxFactory) StartInitialization() (err error) {
    var (
        pipefd, fifofd int
        envInitPipe    = os.Getenv(â€œ_LIBCONTAINER_INITPIPEâ€)<br />
        envFifoFd      = os.Getenv(â€œ_LIBCONTAINER_FIFOFDâ€)
    )</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Get the INITPIPE.
pipefd, err = strconv.Atoi(envInitPipe)

var (
    pipe = os.NewFile(uintptr(pipefd), "pipe")
    it   = initType(os.Getenv("_LIBCONTAINER_INITTYPE")) // // "standard" or "setns"
)

// Only init processes have FIFOFD.
fifofd = -1
if it == initStandard {
    if fifofd, err = strconv.Atoi(envFifoFd); err != nil {
        return fmt.Errorf("unable to convert _LIBCONTAINER_FIFOFD=%s to int: %s", envFifoFd, err)
    }
}

i, err := newContainerInit(it, pipe, consoleSocket, fifofd)

// If Init succeeds, syscall.Exec will not return, hence none of the defers will be called.
return i.Init() // } StartInitialization() æ–¹æ³•å°è¯•ä»ç¯å¢ƒä¸­è¯»å–ä¸€ç³»åˆ—_LIBCONTAINER_XXXå˜é‡çš„å€¼ï¼Œè¿˜æœ‰å°è±¡å—ï¼Ÿè¿™äº›å€¼å…¨æ˜¯åœ¨runc createå‘½ä»¤ä¸­æ‰“å¼€å’Œè®¾ç½®çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œrunc createé€šè¿‡ç¯å¢ƒå˜é‡ï¼Œå°†è¿™äº›å‚æ•°ä¼ ç»™äº†å­è¿›ç¨‹runc init 3
</code></pre></div></div>

<p>æ‹¿åˆ°è¿™äº›ç¯å¢ƒå˜é‡åï¼Œrunc init 3è°ƒç”¨ newContainerInit å‡½æ•°</p>

<p>/* libcontainer/init_linux.go */
func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd int) (initer, error) {
    var config *initConfig</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* read config from pipe (from runc process) */
son.NewDecoder(pipe).Decode(&amp;config); 
populateProcessEnvironment(config.Env);
switch t {
......
case initStandard:
    return &amp;linuxStandardInit{
        pipe:          pipe,
        consoleSocket: consoleSocket,
        parentPid:     unix.Getppid(),
        config:        config, // &lt;=== config
        fifoFd:        fifoFd,
    }, nil
}
return nil, fmt.Errorf("unknown init type %q", t) } newContainerInit() å‡½æ•°é¦–å…ˆå°è¯•ä» pipe è¯»å–é…ç½®å­˜æ”¾åˆ°å˜é‡ config ä¸­ï¼Œå†å­˜å‚¨åˆ°å˜é‡ linuxStandardInit ä¸­è¿”å›
</code></pre></div></div>

<p>runc create                    runc init 3
       |                               |
  p.sendConfig() â€” config â€“&gt;  NewContainerInit()
sleep 5 çº¿ç´¢åœ¨ initStandard.config ä¸­
å›åˆ° StartInitialization(),åœ¨å¾—åˆ° linuxStandardInit åï¼Œä¾¿è°ƒç”¨å…¶ Init()æ–¹æ³•äº†</p>

<p>/* init.go */
func (l *LinuxFactory) StartInitialization() (err error) {
    â€¦â€¦
    i, err := newContainerInit(it, pipe, consoleSocket, fifofd)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return i.Init()   } æœ¬æ–‡å¿½ç•¥æ‰ Init() æ–¹æ³•å‰é¢çš„ä¸€å¤§å †å…¶ä»–é…ç½®ï¼Œåªçœ‹å…¶æœ€å
</code></pre></div></div>

<p>func (l *linuxStandardInit) Init() error {
   â€¦â€¦
   name, err := exec.LookPath(l.config.Args[0])</p>

<p>syscall.Exec(name, l.config.Args[0:], os.Environ())
}
å¯ä»¥çœ‹åˆ°ï¼Œè¿™é‡Œç»ˆäºå¼€å§‹æ‰§è¡Œ ç”¨æˆ·æœ€åˆè®¾ç½®çš„ sleep 5 äº†</p>
:ET