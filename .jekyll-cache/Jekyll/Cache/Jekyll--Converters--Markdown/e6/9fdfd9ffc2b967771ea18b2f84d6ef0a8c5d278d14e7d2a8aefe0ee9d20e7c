I"ı<p>åœ¨httpè¯·æ±‚å½“ä¸­æˆ‘ä»¬å¯ä»¥è®¾ç½®headerç”¨æ¥ä¼ é€’æ•°æ®ï¼Œgrpcåº•å±‚é‡‡ç”¨http2åè®®ä¹Ÿæ˜¯æ”¯æŒä¼ é€’æ•°æ®çš„ï¼Œé‡‡ç”¨çš„æ˜¯metadataã€‚ Metadata å¯¹äº gRPC æœ¬èº«æ¥è¯´é€æ˜ï¼Œ å®ƒä½¿å¾— client å’Œ server èƒ½ä¸ºå¯¹æ–¹æä¾›æœ¬æ¬¡è°ƒç”¨çš„ä¿¡æ¯ã€‚å°±åƒä¸€æ¬¡ http è¯·æ±‚çš„ RequestHeader å’Œ ResponseHeaderï¼Œhttp header çš„ç”Ÿå‘½å‘¨æœŸæ˜¯ä¸€æ¬¡ http è¯·æ±‚ï¼Œ Metadata çš„ç”Ÿå‘½å‘¨æœŸåˆ™æ˜¯ä¸€æ¬¡ RPC è°ƒç”¨ã€‚
<!-- more -->
é¡¹ç›®æºä»£ç è·¯å¾„ï¼šgoogle.golang.org/grpc/metadata</p>

<p>é¡¹ç›®æ–‡æ¡£è·¯å¾„ï¼šhttps://github.com/grpc/grpc-go/blob/master/Documentation/grpc-metadata.md</p>

<p>1ã€åˆ›å»ºmetadata
MD ç±»å‹å®é™…ä¸Šæ˜¯mapï¼Œkeyæ˜¯stringï¼Œvalueæ˜¯stringç±»å‹çš„sliceã€‚</p>

<p>type MD map[string][]string</p>

<p>åˆ›å»ºçš„æ—¶å€™å¯ä»¥åƒåˆ›å»ºæ™®é€šçš„mapç±»å‹ä¸€æ ·ä½¿ç”¨newå…³é”®å­—è¿›è¡Œåˆ›å»ºï¼š</p>

<p>md := metadata.New(map[string]string{â€œkey1â€: â€œval1â€, â€œkey2â€: â€œval2â€})
1
æˆ–è€…ä½¿ç”¨Pairsåˆ›å»ºï¼Œç›¸åŒçš„keyå€¼ä¼šè¢«ç»„åˆæˆsliceã€‚
md := metadata.Pairs(
    â€œkey1â€, â€œval1â€,
    â€œkey1â€, â€œval1-2â€, // â€œkey1â€ will have map value []string{â€œval1â€, â€œval1-2â€}
    â€œkey2â€, â€œval2â€,
)
keyä¸åŒºåˆ†å¤§å°å†™ï¼Œä¼šè¢«ç»Ÿä¸€è½¬æˆå°å†™ã€‚
2ã€å‘é€metadata
md := metadata.Pairs(â€œkeyâ€, â€œvalâ€)
// æ–°å»ºä¸€ä¸ªæœ‰ metadata çš„ context
ctx := metadata.NewOutgoingContext(context.Background(), md)
// å•å‘ RPC
response, err := client.SomeRPC(ctx, someRequest)
3ã€æ¥æ”¶metadata
åˆ©ç”¨å‡½æ•° FromIncomingContextä»contextä¸­è·å–metadata:</p>

<p>func (s <em>server) SomeRPC(ctx context.Context, in *pb.SomeRequest) (</em>pb.SomeResponse, err) {
    md, ok := metadata.FromIncomingContext(ctx)
    // do something with metadata
}</p>

<p>https://blog.csdn.net/hjxzb/article/details/88980186</p>
:ET