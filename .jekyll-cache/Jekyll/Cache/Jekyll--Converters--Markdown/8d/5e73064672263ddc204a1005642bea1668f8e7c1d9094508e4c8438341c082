I"ã„<p>Kernelæä¾›äº†ä¸€ç»„å†…æ ¸æ€çš„socket APIï¼ŒåŸºæœ¬ä¸Šåœ¨ç”¨æˆ·æ€çš„sockt APIåœ¨å†…æ ¸ä¸­éƒ½æœ‰å¯¹åº”çš„APIã€‚ åœ¨net/socket.cä¸­å¯ä»¥çœ‹åˆ°å¦‚ä¸‹å¯¼å‡ºç¬¦å·ï¼š</p>

<p>EXPORT_SYMBOL(kernel_sendmsg);<br />
EXPORT_SYMBOL(kernel_recvmsg);<br />
EXPORT_SYMBOL(sock_create_kern);<br />
EXPORT_SYMBOL(sock_release);<br />
EXPORT_SYMBOL(kernel_bind);<br />
EXPORT_SYMBOL(kernel_listen);<br />
EXPORT_SYMBOL(kernel_accept);<br />
EXPORT_SYMBOL(kernel_connect);<br />
EXPORT_SYMBOL(kernel_getsockname);<br />
EXPORT_SYMBOL(kernel_getpeername);<br />
EXPORT_SYMBOL(kernel_getsockopt);<br />
EXPORT_SYMBOL(kernel_setsockopt);<br />
EXPORT_SYMBOL(kernel_sendpage);<br />
EXPORT_SYMBOL(kernel_sock_ioctl);<br />
EXPORT_SYMBOL(kernel_sock_shutdown);
<!-- more -->
struct socket
{
     socket_state  state; // socket state</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> short   type ; // socket type
 
 unsigned long  flags; // socket flags
 
 struct fasync_struct  *fasync_list;
 
 wait_queue_head_t wait;
 
 struct file *file;
 
 struct sock *sock;  // socketåœ¨ç½‘ç»œå±‚çš„è¡¨ç¤ºï¼›
 
 const struct proto_ops *ops;
</code></pre></div></div>

<p>}</p>

<p>struct socketç»“æ„ä½“çš„ç±»å‹
enum sock_type
{
   SOCK_STREAM = 1, // ç”¨äºä¸TCPå±‚ä¸­çš„tcpåè®®æ•°æ®çš„struct socket</p>

<p>SOCK_DGRAM  = 2, //ç”¨äºä¸TCPå±‚ä¸­çš„udpåè®®æ•°æ®çš„struct socket</p>

<p>SOCK_RAW    = 3, // raw struct socket</p>

<p>SOCK_RDM    = 4, //å¯é ä¼ è¾“æ¶ˆæ¯çš„struct socket</p>

<p>SOCK_SEQPACKET = 5,// sequential packet socket</p>

<p>SOCK_DCCP   = 6,</p>

<p>SOCK_PACKET = 10, //ä»dev levelä¸­è·å–æ•°æ®åŒ…çš„socket
};</p>

<p>struct socket ä¸­çš„flagså­—æ®µå–å€¼ï¼š
  #define SOCK_ASYNC_NOSPACE  0
  #define SOCK_ASYNC_WAITDATA 1
  #define SOCK_NOSPACE        2
  #define SOCK_PASSCRED       3
  #define SOCK_PASSSEC        4</p>

<p>æºç å‰–æï¼š</p>

<p>ä¸ºæ–¹ä¾¿å¤§å®¶ç†æ¸…æ€è·¯ï¼Œå…ˆä»‹ç»å‡ ä¸ªä¸­é—´å‡½æ•°ã€‚å»ºè®®ï¼šåƒè¿™äº›å¤§å‹è½¯ä»¶é¡¹ç›®ï¼Œå‡½æ•°å†…é€šå¸¸è¿˜ä¼šè°ƒç”¨ä¸€äº›å…¬ç”¨çš„åŸºç¡€ç±»çš„å·¥å…·å‡½æ•°ï¼Œæˆ‘ä»¬åœ¨é˜…è¯»æºç æ—¶ï¼Œåº”è¯¥å…ˆå¼„æ¸…æ¥šè¿™äº›å‡½æ•°ï¼Œè¿™æ ·å½“é˜…è¯»å¯¹åº”å‡½æ•°æ—¶ï¼Œèƒ½å¾ˆå¥½åœ°æŠŠæ¡è¯¥å‡½æ•°çš„å†…éƒ¨ç»†èŠ‚ã€‚</p>

<p>/<em>ä¸‹é¢ä¸¤ä¸ªå‡½æ•°å®ç°åœ°å€ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´åœ°å€ä¹‹é—´çš„ç›¸äº’ç§»åŠ¨</em>/
//ä»uaddræ‹·è´ulenå¤§å°çš„æ•°æ®åˆ°kaddr
static int move_addr_to_kernel(void *uaddr, int ulen, void *kaddr)
{
	int err;
	if(ulen&lt;0||ulen&gt;MAX_SOCK_ADDR)
		return -EINVAL;
	if(ulen==0)
		return 0;
	//æ£€æŸ¥ç”¨æˆ·ç©ºé—´çš„æŒ‡é’ˆæ‰€æŒ‡çš„æŒ‡å®šå¤§å°å­˜å‚¨å—æ˜¯å¦å¯è¯»
	if((err=verify_area(VERIFY_READ,uaddr,ulen))&lt;0)
		return err;
	memcpy_fromfs(kaddr,uaddr,ulen);//å®è´¨æ˜¯memcpyå‡½æ•°
	return 0;
}
//æ³¨æ„çš„æ˜¯ï¼Œä»å†…æ ¸æ‹·è´æ•°æ®åˆ°ç”¨æˆ·ç©ºé—´æ˜¯å€¼-ç»“æœå‚æ•°
//ulenè¿™ä¸ªæŒ‡å‘æŸä¸ªæ•´æ•°å˜é‡çš„æŒ‡é’ˆï¼Œå½“å‡½æ•°è¢«è°ƒç”¨çš„æ—¶å€™ï¼Œå®ƒå‘Šè¯‰å†…æ ¸éœ€è¦æ‹·è´å¤šå°‘
//å‡½æ•°è¿”å›æ—¶ï¼Œè¯¥å‚æ•°ä½œä¸ºä¸€ä¸ªç»“æœï¼Œå‘Šè¯‰è¿›ç¨‹ï¼Œå†…æ ¸å®é™…æ‹·è´äº†å¤šå°‘ä¿¡æ¯
static int move_addr_to_user(void *kaddr, int klen, void *uaddr, int *ulen)
{
	int err;
	int len;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//åˆ¤æ–­ulenæŒ‡å‘çš„å­˜å‚¨å—æ˜¯å¦å¯å†™ï¼Œå°±æ˜¯åˆ¤æ–­ulenæ˜¯å¦å¯ä½œä¸ºå·¦å€¼	
if((err=verify_area(VERIFY_WRITE,ulen,sizeof(*ulen)))&lt;0)
	return err;
len=get_fs_long(ulen);//len = *ulenï¼Œulenä½œä¸ºå€¼ä¼ å…¥ï¼Œå‘Šè¯‰è¦æ‹·è´å¤šå°‘æ•°æ®
if(len&gt;klen)
	len=klen;//ä¾›ä¸åº”æ±‚ï¼ŒæŒ‰ä¾›çš„ç®—ã€‚å®é™…æ‹·è´çš„æ•°æ®
if(len&lt;0 || len&gt; MAX_SOCK_ADDR)
	return -EINVAL;
if(len)
{
//åˆ¤æ–­uaddrç”¨æˆ·ç©ºé—´æ‰€æŒ‡çš„å­˜å‚¨å—æ˜¯å¦å¯å†™
	if((err=verify_area(VERIFY_WRITE,uaddr,len))&lt;0)
		return err;
	memcpy_tofs(uaddr,kaddr,len);//å®è´¨æ˜¯è°ƒç”¨memcpy
}
 	put_fs_long(len,ulen);//*ulen = lenï¼Œä½œä¸ºç»“æœè¿”å›ï¼Œå³å®é™…æ‹·è´äº†å¤šå°‘æ•°æ®
 	return 0; } ä¸‹é¢è¿™ä¸ªå‡½æ•°ä¸€çœ‹å°±çŸ¥é“ä»€ä¹ˆæ„æ€ static inline unsigned long get_user_long(const int *addr) {
return *addr; }
</code></pre></div></div>

<p>#define get_fs_long(addr) get_user_long((int *)(addr))</p>

<p>ä¸ºå¥—æ¥å­—åˆ†é…æ–‡ä»¶æè¿°ç¬¦ï¼Œå¥—æ¥å­—å…¶å®åŒæ™®é€šçš„æ–‡ä»¶æè¿°ç¬¦å·®ä¸å¤šï¼Œåˆ†é…æ–‡ä»¶æè¿°ç¬¦çš„åŒæ—¶éœ€è¦ä¸€ä¸ªfileç»“æ„ï¼Œfileç»“æ„ä¸­f_inodeå­—æ®µæŒ‡å‘inode(è¿™é‡Œçš„å½¢å‚)
/*</p>
<ul>
  <li>ä¸ºç½‘ç»œå¥—æ¥å­—åˆ†é…ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ 
 */</li>
</ul>

<p>static int get_fd(struct inode *inode)
{
	int fd;
	struct file *file;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 *	Find a file descriptor suitable for return to the user. 
 */
 
file = get_empty_filp();//åˆ†é…æ–‡ä»¶å¯¹è±¡ï¼Œæ–‡ä»¶æè¿°ç¬¦å¯¹åº”å®ä½“ï¼Œfileç»“æ„ä½“æŒ‡ç¤ºä¸€ä¸ªæ‰“å¼€çš„æ–‡ä»¶ï¼Œfilp:file pointer
if (!file) 
	return(-1);
//æ‰¾åˆ°å¯ç”¨çš„æ–‡ä»¶æè¿°ç¬¦
for (fd = 0; fd &lt; NR_OPEN; ++fd)
	if (!current-&gt;files-&gt;fd[fd]) 
		break;
//æ²¡æœ‰ç©ºé—²å¯ç”¨çš„æ–‡ä»¶æè¿°ç¬¦ï¼Œåˆ™é€€å‡º
if (fd == NR_OPEN) 
{
	file-&gt;f_count = 0;
	return(-1);
}
//åœ¨æ–‡ä»¶æè¿°ç¬¦é›†åˆä¸­åˆ é™¤ä¸€ä¸ªæ–°çš„æ–‡ä»¶æè¿°ç¬¦
FD_CLR(fd, Â¤t-&gt;files-&gt;close_on_exec);
	current-&gt;files-&gt;fd[fd] = file;//èµ‹å€¼ï¼ŒæŒ‚é’©
file-&gt;f_op = &amp;socket_file_ops;//æŒ‡å®šæ“ä½œå‡½æ•°é›†ï¼Œå®ç°äº†ç½‘ç»œæ“ä½œçš„æ™®é€šæ–‡ä»¶æ¥å£
file-&gt;f_mode = 3;//æƒé™
file-&gt;f_flags = O_RDWR;//æ ‡å¿—ï¼Œå¯è¯»å¯å†™
file-&gt;f_count = 1;//å¼•ç”¨è®¡æ•°
file-&gt;f_inode = inode;//ä¸æ–‡ä»¶inodeå»ºç«‹è”ç³»,inodeä¸ºå¯¹æ–‡ä»¶çš„ç´¢å¼•
if (inode) 
	inode-&gt;i_count++;//inodeçš„å¼•ç”¨è®¡æ•°ä¹Ÿè¦å¢1
file-&gt;f_pos = 0;//åç§»å€¼
return(fd); }
</code></pre></div></div>

<p>æ¯ä¸ªæ–‡ä»¶æè¿°ç¬¦éƒ½ä¸å¯¹åº”çš„inodeç»“æ„å…³è”ï¼Œé€šè¿‡æ–‡ä»¶æè¿°ç¬¦å¯ä»¥æ‰¾åˆ°fileç»“æ„ï¼Œé€šè¿‡fileç»“æ„å¯ä»¥æ‰¾åˆ°inodeï¼Œè€Œsocketç»“æ„åˆæ˜¯ä½œä¸ºinodeç»“æ„ä¸­çš„ä¸€ä¸ªå˜é‡ï¼Œåè¿‡æ¥ï¼Œinodeä¹Ÿæ˜¯ä½œä¸ºsocketç»“æ„çš„ä¸€ä¸ªå˜é‡ï¼Œåˆ†é…å¥—æ¥å­—æ—¶ï¼Œä¸¤è€…ä¹‹é—´éœ€è¦å»ºç«‹å…³è”ï¼Œè§sock_alloc()ã€‚
/*</p>
<ul>
  <li>é€šè¿‡inodeç»“æ„æŸ¥æ‰¾å¯¹åº”çš„socketç»“æ„
 */
inline struct socket *socki_lookup(struct inode *inode)
{
return &amp;inode-&gt;u.socket_i;//socketç»“æ„æ˜¯ä½œä¸ºinodeç»“æ„ä¸­çš„ä¸€ä¸ªå˜é‡
}</li>
</ul>

<p>/*</p>
<ul>
  <li>ç»™å®šæ–‡ä»¶æè¿°ç¬¦è¿”å›socketç»“æ„ä»¥åŠfileç»“æ„æŒ‡é’ˆ
 */</li>
</ul>

<p>static inline struct socket *sockfd_lookup(int fd, struct file **pfile)
{
	struct file *file;
	struct inode *inode;
	//æœ‰æ•ˆæ€§æ£€æŸ¥ï¼Œå¹¶ä»æ–‡ä»¶æè¿°ç¬¦ä¸­å¾—åˆ°å¯¹åº”çš„fileç»“æ„
	if (fd &lt; 0 || fd &gt;= NR_OPEN || !(file = current-&gt;files-&gt;fd[fd])) 
		return NULL;
	//å¾—åˆ°å¯¹åº”inodeç»“æ„
	inode = file-&gt;f_inode;
	if (!inode || !inode-&gt;i_sock)
		return NULL;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (pfile) 
	*pfile = file;//å‚æ•°è¿”å›fileç»“æ„æŒ‡é’ˆ
//è¿”å›inodeå¯¹åº”çš„socketç»“æ„
return socki_lookup(inode); } Â ä¸‹é¢å¼€å§‹socketç»“æ„çš„å¤„ç†äº† åˆ†é…ä¸€ä¸ªsocketç»“æ„
</code></pre></div></div>

<p>/*</p>
<ul>
  <li>åˆ†é…ä¸€ä¸ªsocketç»“æ„
 */</li>
</ul>

<p>struct socket *sock_alloc(void)
{
	struct inode * inode;
	struct socket * sock;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inode = get_empty_inode();//åˆ†é…ä¸€ä¸ªinodeå¯¹è±¡
if (!inode)
	return NULL;
//è·å¾—çš„inodeç»“æ„çš„åˆå§‹åŒ–
inode-&gt;i_mode = S_IFSOCK;
inode-&gt;i_sock = 1;
inode-&gt;i_uid = current-&gt;uid;
inode-&gt;i_gid = current-&gt;gid;
 
sock = &amp;inode-&gt;u.socket_i;
sock-&gt;state = SS_UNCONNECTED;
sock-&gt;flags = 0;
sock-&gt;ops = NULL;
sock-&gt;data = NULL;
sock-&gt;conn = NULL;
sock-&gt;iconn = NULL;
sock-&gt;next = NULL;
sock-&gt;wait = &amp;inode-&gt;i_wait;
sock-&gt;inode = inode;//å›ç»‘
sock-&gt;fasync_list = NULL;
sockets_in_use++;//ç³»ç»Ÿå½“å‰ä½¿ç”¨çš„å¥—æ¥å­—æ•°é‡åŠ 1
return sock; }
</code></pre></div></div>

<p>é‡Šæ”¾ï¼ˆå…³é—­ï¼‰å¥—æ¥å­—
/*</p>
<ul>
  <li>Release a socket.
 */
//é‡Šæ”¾å¯¹ç«¯çš„å¥—æ¥å­—
static inline void sock_release_peer(struct socket *peer)
{
peer-&gt;state = SS_DISCONNECTING;//çŠ¶æ€åˆ‡æ¢åˆ°æ­£åœ¨å¤„ç†å…³é—­è¿æ¥
wake_up_interruptible(peer-&gt;wait);//å”¤é†’æŒ‡å®šçš„æ³¨å†Œåœ¨ç­‰å¾…é˜Ÿåˆ—ä¸Šçš„è¿›ç¨‹
sock_wake_async(peer, 1);//å¼‚æ­¥å”¤é†’ï¼Œæ¶‰åŠåˆ°å¥—æ¥å­—çŠ¶æ€çš„æ”¹å˜ï¼Œéœ€è¦é€šçŸ¥ç›¸åº”è¿›ç¨‹è¿›è¡ŒæŸç§å¤„ç†
}</li>
</ul>

<p>/*</p>
<ul>
  <li>é‡Šæ”¾(å…³é—­)ä¸€ä¸ªå¥—æ¥å­—
 */</li>
</ul>

<p>void sock_release(struct socket *sock)
{
	int oldstate;
	struct socket *peersock, *nextsock;</p>

<p>//åªè¦å¥—æ¥å­—ä¸æ˜¯å‡ºäºæœªè¿æ¥çŠ¶æ€ï¼Œå°±å°†å…¶ç½®ä¸ºæ­£åœ¨å¤„ç†å…³é—­è¿æ¥çŠ¶æ€
	if ((oldstate = sock-&gt;state) != SS_UNCONNECTED)
		sock-&gt;state = SS_DISCONNECTING;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 *	Wake up anyone waiting for connections. 
 */ //iconnåªç”¨äºæœåŠ¡å™¨ç«¯ï¼Œè¡¨ç¤ºç­‰å¾…è¿æ¥ä½†å°šæœªå®Œæˆè¿æ¥çš„å®¢æˆ·ç«¯socketç»“æ„é“¾è¡¨
for (peersock = sock-&gt;iconn; peersock; peersock = nextsock) 
{
	nextsock = peersock-&gt;next;
	sock_release_peer(peersock);
}
 
/*
 * Wake up anyone we're connected to. First, we release the
 * protocol, to give it a chance to flush data, etc.
 */
//å¦‚æœè¯¥å¥—æ¥å­—å·²è¿æ¥ï¼ŒpeersockæŒ‡å‘å…¶è¿æ¥çš„æœåŠ¡å™¨ç«¯å¥—æ¥å­—
peersock = (oldstate == SS_CONNECTED) ? sock-&gt;conn : NULL;
//è½¬è°ƒç”¨releaseå‡½æ•°
if (sock-&gt;ops) 
	sock-&gt;ops-&gt;release(sock, peersock);
//é‡Šæ”¾å¯¹ç«¯å¥—æ¥å­—
if (peersock)
	sock_release_peer(peersock);
--sockets_in_use;	/* æ•°é‡å‡1 */
iput(SOCK_INODE(sock)); } socket ç»“æ„ /*  * Internal representation of a socket. not all the fields are used by  * all configurations:  *  *		server			client  * conn		client connected to	server connected to  * iconn	list of clients		-unused-  *		 awaiting connections  * wait		sleep for clients,	sleep for connection,  *		sleep for i/o		sleep for i/o  */  //è¯¥ç»“æ„è¡¨ç¤ºä¸€ä¸ªç½‘ç»œå¥—æ¥å­— struct socket {   short			type;		/* å¥—æ¥å­—æ‰€ç”¨çš„æµç±»å‹*/   socket_state		state;//å¥—æ¥å­—æ‰€å¤„çŠ¶æ€   long			flags;//æ ‡è¯†å­—æ®µï¼Œç›®å‰å°šæ— æ˜ç¡®ä½œç”¨   struct proto_ops	*ops;		/* æ“ä½œå‡½æ•°é›†æŒ‡é’ˆ	*/
/* dataä¿å­˜æŒ‡å‘â€˜ç§æœ‰'æ•°æ®ç»“æ„æŒ‡é’ˆï¼Œåœ¨ä¸åŒçš„åŸŸæŒ‡å‘ä¸åŒçš„æ•°æ®ç»“æ„		*/   //åœ¨INETåŸŸï¼ŒæŒ‡å‘sockç»“æ„ï¼ŒUNIXåŸŸæŒ‡å‘unix_proto_dataç»“æ„   void			*data;	   //ä¸‹é¢ä¸¤ä¸ªå­—æ®µåªç”¨äºUNIXåŸŸ   struct socket		*conn;		/* æŒ‡å‘å®¢æˆ·ç«¯è¿æ¥çš„æœåŠ¡å™¨ç«¯å¥—æ¥å­—	*/   struct socket		*iconn;		/* æŒ‡å‘æ­£ç­‰å¾…è¿æ¥çš„å®¢æˆ·ç«¯	*/   struct socket		*next;//é“¾è¡¨   struct wait_queue	**wait;		/* ç­‰å¾…é˜Ÿåˆ—	*/   struct inode		*inode;//inodeç»“æ„æŒ‡é’ˆ   struct fasync_struct  *fasync_list;	/* å¼‚æ­¥å”¤é†’é“¾è¡¨ç»“æ„	*/ };
</code></pre></div></div>

<p>åˆ›å»ºå¥—æ¥å­—socketï¼Œsocket
/*</p>
<ul>
  <li>ç³»ç»Ÿè°ƒç”¨ï¼Œåˆ›å»ºå¥—æ¥å­—socketã€‚æ¶‰åŠåˆ°socketç»“æ„çš„åˆ›å»º.
 */</li>
</ul>

<p>static int sock_socket(int family, int type, int protocol)
{
	int i, fd;
	struct socket *sock;
	struct proto_ops *ops;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* åŒ¹é…åº”ç”¨ç¨‹åºè°ƒç”¨socket()å‡½æ•°æ—¶æŒ‡å®šçš„åè®® */
for (i = 0; i &lt; NPROTO; ++i) 
{
	if (pops[i] == NULL) continue;
	if (pops[i]-&gt;family == family) 
		break;
}
//æ²¡æœ‰åŒ¹é…çš„åè®®ï¼Œåˆ™å‡ºé”™é€€å‡º
if (i == NPROTO) 
{
  		return -EINVAL;
}
 
ops = pops[i];
</code></pre></div></div>

<p>/*</p>
<ul>
  <li>Check that this is a type that we know how to manipulate and</li>
  <li>the protocol makes sense here. The family can still reject the</li>
  <li>protocol later.
 */
  //å¥—æ¥å­—ç±»å‹æ£€æŸ¥
if ((type != SOCK_STREAM &amp;&amp; type != SOCK_DGRAM &amp;&amp;
    type != SOCK_SEQPACKET &amp;&amp; type != SOCK_RAW &amp;&amp;
    type != SOCK_PACKET) || protocol &lt; 0)
        return(-EINVAL);</li>
</ul>

<p>/*</p>
<ul>
  <li>Allocate the socket and allow the family to set things up. if</li>
  <li>the protocol is 0, the family is instructed to select an appropriate</li>
  <li>
    <p>default.
 <em>/
//åˆ†é…å¥—æ¥å­—ç»“æ„
if (!(sock = sock_alloc())) 
{
    printk(â€œNET: sock_socket: no more sockets\nâ€);
    return(-ENOSR);	/</em> Was: EAGAIN, but we are out of
               system resources! */
}
//æŒ‡å®šå¯¹åº”ç±»å‹ï¼Œåè®®ï¼Œä»¥åŠæ“ä½œå‡½æ•°é›†
sock-&gt;type = type;
sock-&gt;ops = ops;
//åˆ†é…ä¸‹å±‚sockç»“æ„ï¼Œsockç»“æ„æ˜¯æ¯”socketç»“æ„æ›´åº•å±‚çš„è¡¨ç¤ºä¸€ä¸ªå¥—æ¥å­—çš„ç»“æ„
//å‰é¢åšæ–‡æœ‰è¯´æ˜:http://blog.csdn.net/wenqian1991/article/details/21740945
//socketæ˜¯é€šç”¨çš„å¥—æ¥å­—ç»“æ„ä½“ï¼Œè€Œsockä¸å…·ä½“ä½¿ç”¨çš„åè®®ç›¸å…³
if ((i = sock-&gt;ops-&gt;create(sock, protocol)) &lt; 0) 
{
    sock_release(sock);
    return(i);
}
//åˆ†é…ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦å¹¶åœ¨åé¢è¿”å›ç»™åº”ç”¨å±‚åºä½œä¸ºä»¥åçš„æ“ä½œå¥æŸ„
if ((fd = get_fd(SOCK_INODE(sock))) &lt; 0) 
{
    sock_release(sock);
    return(-EINVAL);
}</p>

    <p>return(fd);
}</p>
  </li>
</ul>

<p>ç»™socketç»‘å®šä¸€ä¸ªç«¯å£ï¼Œbind
/*</p>
<ul>
  <li>Bind a name to a socket. Nothing much to do here since itâ€™s</li>
  <li>the protocolâ€™s responsibility to handle the local address.
 *</li>
  <li>We move the socket address to kernel space before we call</li>
  <li>the protocol layer (having also checked the address is ok).
 */
 //å»ºè®®å¯¹äºç†è§£è¿™ç±»ç³»ç»Ÿè°ƒç”¨å‡½æ•°ï¼Œå…ˆçœ‹çœ‹åº”ç”¨å±‚çš„å¯¹åº”å‡½æ•°ï¼Œå¦‚bindï¼Œlistenç­‰
 //bindå‡½æ•°å¯¹åº”çš„BSDå±‚å‡½æ•°ï¼Œç”¨äºç»‘å®šä¸€ä¸ªæœ¬åœ°åœ°å€ï¼ŒæœåŠ¡å™¨ç«¯
 //umyaddrè¡¨ç¤ºéœ€è¦ç»‘å®šçš„åœ°å€ç»“æ„ï¼Œaddrlenè¡¨ç¤ºæ”¹åœ°å€ç»“æ„çš„é•¿åº¦
static int sock_bind(int fd, struct sockaddr *umyaddr, int addrlen)
{
struct socket *sock;
int i;
char address[MAX_SOCK_ADDR];
int err;
//å¥—æ¥å­—å‚æ•°æœ‰æ•ˆæ€§æ£€æŸ¥
if (fd &lt; 0 || fd &gt;= NR_OPEN || current-&gt;files-&gt;fd[fd] == NULL)
    return(-EBADF);
//è·å–fdå¯¹åº”çš„socketç»“æ„
if (!(sock = sockfd_lookup(fd, NULL))) 
    return(-ENOTSOCK);
//å°†åœ°å€ä»ç”¨æˆ·ç¼“å†²åŒºå¤åˆ¶åˆ°å†…æ ¸ç¼“å†²åŒº
if((err=move_addr_to_kernel(umyaddr,addrlen,address))&lt;0)
  	return err;
//è½¬è°ƒç”¨bindæŒ‡å‘çš„å‡½æ•°
if ((i = sock-&gt;ops-&gt;bind(sock, (struct sockaddr *)address, addrlen)) &lt; 0) 
{
    return(i);
}
return(0);
}</li>
</ul>

<p>ç›‘å¬å®¢æˆ·ç«¯è¯·æ±‚ï¼Œlisten
/*</p>
<ul>
  <li>Perform a listen. Basically, we allow the protocol to do anything</li>
  <li>necessary for a listen, and if that works, we mark the socket as</li>
  <li>ready for listening.
 */
//æœåŠ¡å™¨ç«¯ç›‘å¬å®¢æˆ·ç«¯çš„è¿æ¥è¯·æ±‚
//fdè¡¨ç¤ºbindåçš„å¥—æ¥å­—ï¼Œbacklogè¡¨ç¤ºæ’é˜Ÿçš„æœ€å¤§è¿æ¥ä¸ªæ•°
//listenå‡½æ•°æŠŠä¸€ä¸ªæœªè¿æ¥çš„å¥—æ¥å­—è½¬æ¢ä¸ºä¸€ä¸ªè¢«åŠ¨å¥—æ¥å­—ï¼Œ
//æŒ‡ç¤ºå†…æ ¸åº”æ¥å—è¯¥å¥—æ¥å­—çš„è¿æ¥è¯·æ±‚</li>
</ul>

<p>static int sock_listen(int fd, int backlog)
{
	struct socket *sock;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (fd &lt; 0 || fd &gt;= NR_OPEN || current-&gt;files-&gt;fd[fd] == NULL)
	return(-EBADF);
if (!(sock = sockfd_lookup(fd, NULL))) 
	return(-ENOTSOCK);
//å‰ææ˜¯æ²¡æœ‰å»ºç«‹è¿æ¥
if (sock-&gt;state != SS_UNCONNECTED) 
{
	return(-EINVAL);
}
//è°ƒç”¨åº•å±‚å®ç°å‡½æ•°
if (sock-&gt;ops &amp;&amp; sock-&gt;ops-&gt;listen)
	sock-&gt;ops-&gt;listen(sock, backlog);
sock-&gt;flags |= SO_ACCEPTCON;//è®¾ç½®æ ‡è¯†å­—æ®µ
return(0); }
</code></pre></div></div>

<p>æœåŠ¡å™¨æ¥æ”¶è¯·æ±‚ï¼Œaccept
/*</p>
<ul>
  <li>For accept, we attempt to create a new socket, set up the link</li>
  <li>with the client, wake up the client, then return the new</li>
  <li>connected fd. We collect the address of the connector in kernel</li>
  <li>space and move it to user at the very end. This is buggy because</li>
  <li>
    <p>we open the socket then return an error.
 */
//ç”¨äºæœåŠ¡å™¨æ¥æ”¶ä¸€ä¸ªå®¢æˆ·ç«¯çš„è¿æ¥è¯·æ±‚ï¼Œè¿™é‡Œæ˜¯å€¼-ç»“æœå‚æ•°ï¼Œä¹‹å‰æœ‰è¯´åˆ°
//fd ä¸ºç›‘å¬åå¥—æ¥å­—ã€‚æœ€åè¿”å›ä¸€ä¸ªè®°å½•äº†æœ¬åœ°ä¸ç›®çš„ç«¯ä¿¡æ¯çš„å¥—æ¥å­—
//upeer_sockaddrç”¨æ¥è¿”å›å·²è¿æ¥å®¢æˆ·çš„åè®®åœ°å€ï¼Œå¦‚æœå¯¹åè®®åœ°å€ä¸æ„Ÿå…´è¶£å°±NULL
static int sock_accept(int fd, struct sockaddr *upeer_sockaddr, int *upeer_addrlen)
{
struct file *file;
struct socket *sock, *newsock;
int i;
char address[MAX_SOCK_ADDR];
int len;</p>

    <p>if (fd &lt; 0 || fd &gt;= NR_OPEN || ((file = current-&gt;files-&gt;fd[fd]) == NULL))
    return(-EBADF);
  	if (!(sock = sockfd_lookup(fd, &amp;file))) 
    return(-ENOTSOCK);
if (sock-&gt;state != SS_UNCONNECTED)//socketå„ä¸ªçŠ¶æ€çš„æ¼”å˜æ˜¯ä¸€æ­¥ä¸€æ­¥æ¥çš„ 
{
    return(-EINVAL);
}
//è¿™æ˜¯tcpè¿æ¥ï¼Œå¾—æŒ‰æ­¥éª¤æ¥
if (!(sock-&gt;flags &amp; SO_ACCEPTCON))//æ²¡æœ‰listen
{
    return(-EINVAL);
}
//åˆ†é…ä¸€ä¸ªæ–°çš„å¥—æ¥å­—ï¼Œç”¨äºè¡¨ç¤ºåé¢å¯è¿›è¡Œé€šä¿¡çš„å¥—æ¥å­—
if (!(newsock = sock_alloc())) 
{
    printk(â€œNET: sock_accept: no more sockets\nâ€);
    return(-ENOSR);	/* Was: EAGAIN, but we are out of system
               resources! */
}
newsock-&gt;type = sock-&gt;type;
newsock-&gt;ops = sock-&gt;ops;
//å¥—æ¥å­—é‡å®šå‘ï¼Œç›®çš„æ˜¯åˆå§‹åŒ–æ–°çš„ç”¨äºæ•°æ®ä¼ é€çš„å¥—æ¥å­—
//ç»§æ‰¿äº†ç¬¬ä¸€å‚æ•°ä¼ æ¥çš„æœåŠ¡å™¨çš„IPå’Œç«¯å£å·ä¿¡æ¯
if ((i = sock-&gt;ops-&gt;dup(newsock, sock)) &lt; 0) 
{
    sock_release(newsock);
    return(i);
}
//è½¬è°ƒç”¨inet_acceptå‡½æ•°
i = newsock-&gt;ops-&gt;accept(sock, newsock, file-&gt;f_flags);
if ( i &lt; 0) 
{
    sock_release(newsock);
    return(i);
}
//åˆ†é…ä¸€ä¸ªæ–‡ä»¶æè¿°ç¬¦ï¼Œç”¨äºä»¥åçš„æ•°æ®ä¼ é€
if ((fd = get_fd(SOCK_INODE(newsock))) &lt; 0) 
{
    sock_release(newsock);
    return(-EINVAL);
}
//è¿”å›é€šä¿¡è¿œç«¯çš„åœ°å€
if (upeer_sockaddr)
{//å¾—åˆ°å®¢æˆ·ç«¯åœ°å€ï¼Œå¹¶å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´
    newsock-&gt;ops-&gt;getname(newsock, (struct sockaddr *)address, &amp;len, 1);
    move_addr_to_user(address,len, upeer_sockaddr, upeer_addrlen);
}
return(fd);
}</p>
  </li>
</ul>

<p>å®¢æˆ·ç«¯ä¸»åŠ¨å‘èµ·è¿æ¥è¯·æ±‚ï¼Œconnect
/*</p>
<ul>
  <li>é¦–å…ˆå°†è¦è¿æ¥çš„æºç«¯åœ°å€ä»ç”¨æˆ·ç¼“å†²åŒºå¤åˆ¶åˆ°å†…æ ¸ç¼“å†²åŒºï¼Œä¹‹åæ ¹æ®å¥—æ¥å­—ç›®å‰æ‰€å¤„çŠ¶æ€</li>
  <li>
    <p>é‡‡å–å¯¹åº”æªæ–½ï¼Œå¦‚æœçŠ¶æ€æœ‰æ•ˆï¼Œè½¬è°ƒç”¨connectå‡½æ•°
 */
 //è¿™æ˜¯å®¢æˆ·ç«¯ï¼Œè¡¨ç¤ºå®¢æˆ·ç«¯å‘æœåŠ¡å™¨ç«¯å‘é€è¿æ¥è¯·æ±‚
static int sock_connect(int fd, struct sockaddr *uservaddr, int addrlen)
{
struct socket *sock;
struct file *file;
int i;
char address[MAX_SOCK_ADDR];
int err;</p>

    <p>if (fd &lt; 0 || fd &gt;= NR_OPEN || (file=current-&gt;files-&gt;fd[fd]) == NULL)
    return(-EBADF);
if (!(sock = sockfd_lookup(fd, &amp;file)))
    return(-ENOTSOCK);</p>

    <p>if((err=move_addr_to_kernel(uservaddr,addrlen,address))&lt;0)
  	return err;
//æ ¹æ®çŠ¶æ€é‡‡å–å¯¹åº”æªæ–½
switch(sock-&gt;state) 
{
    case SS_UNCONNECTED:
        /* This is okâ€¦ continue with connect <em>/
        break;
    case SS_CONNECTED:
        /</em> Socket is already connected <em>/
        if(sock-&gt;type == SOCK_DGRAM) /</em> Hack for now - move this all into the protocol <em>/
            break;
        return -EISCONN;
    case SS_CONNECTING:
        /</em> Not yet connectedâ€¦ we will check this. */</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    /*
     *	FIXME:  for all protocols what happens if you start
     *	an async connect fork and both children connect. Clean
     *	this up in the protocols!
     */
    break;
default:
    return(-EINVAL); } i = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)address, addrlen, file-&gt;f_flags); if (i &lt; 0)  {
return(i); } return(0); } ä¸Šé¢å‡ ä¸ªå‡½æ•°åˆ™æ˜¯æˆ‘ä»¬åº”ç”¨ç¼–ç¨‹æ˜¯socketã€bindã€listenã€acceptã€connect å‡½æ•°å¯¹åº”çš„å†…æ ¸çš„ç³»ç»Ÿè°ƒç”¨å‡½æ•°ï¼Œå¯ä»¥çœ‹å‡ºï¼Œå¯¹åº”çš„sock_ å‡½æ•°å†…éƒ¨ä¹Ÿæ˜¯è½¬è°ƒç”¨äº†ä¸‹ä¸€å±‚çš„å‡½æ•°ã€‚ æ‰€æœ‰ç½‘ç»œè°ƒç”¨å‡½æ•°éƒ½å…·æœ‰å…±åŒçš„å…¥å£å‡½æ•° sys_socket /*
</code></pre></div>    </div>
  </li>
  <li>System call vectors. Since I (RIB) want to rewrite sockets as streams,</li>
  <li>we have this level of indirection. Not a lot of overhead, since more of</li>
  <li>the work is done via read/write/select directly.
 *</li>
  <li>Iâ€™m now expanding this up to a higher level to separate the assorted</li>
  <li>kernel/user space manipulations and global assumptions from the protocol</li>
  <li>layers proper - AC.
 <em>/
//æœ¬å‡½æ•°æ˜¯ç½‘ç»œæ ˆä¸“ç”¨æ“ä½œå‡½æ•°é›†çš„æ€»å…¥å£å‡½æ•°ï¼Œä¸»è¦æ˜¯å°†è¯·æ±‚åˆ†é…ï¼Œè°ƒç”¨å…·ä½“çš„åº•å±‚å‡½æ•°è¿›è¡Œå¤„ç†
asmlinkage int sys_socketcall(int call, unsigned long *args)
{
int er;
switch(call) 
{
    case SYS_SOCKET://socketå‡½æ•°
        er=verify_area(VERIFY_READ, args, 3 * sizeof(long));
        if(er)
            return er;
        return(sock_socket(get_fs_long(args+0),
            get_fs_long(args+1),//è¿”å›åœ°å€ä¸Šçš„å€¼
            get_fs_long(args+2)));
    case SYS_BIND://bindå‡½æ•°
        er=verify_area(VERIFY_READ, args, 3 * sizeof(long));
        if(er)
            return er;
        return(sock_bind(get_fs_long(args+0),
            (struct sockaddr *)get_fs_long(args+1),
            get_fs_long(args+2)));
    case SYS_CONNECT://connectå‡½æ•°
        er=verify_area(VERIFY_READ, args, 3 * sizeof(long));
        if(er)
            return er;
        return(sock_connect(get_fs_long(args+0),
            (struct sockaddr *)get_fs_long(args+1),
            get_fs_long(args+2)));
    case SYS_LISTEN://listenå‡½æ•°
        er=verify_area(VERIFY_READ, args, 2 * sizeof(long));
        if(er)
            return er;
        return(sock_listen(get_fs_long(args+0),
            get_fs_long(args+1)));
    case SYS_ACCEPT://acceptå‡½æ•°
        er=verify_area(VERIFY_READ, args, 3 * sizeof(long));
        if(er)
            return er;
        return(sock_accept(get_fs_long(args+0),
            (struct sockaddr *)get_fs_long(args+1),
            (int *)get_fs_long(args+2)));
    case SYS_GETSOCKNAME://getsocknameå‡½æ•°
        er=verify_area(VERIFY_READ, args, 3 * sizeof(long));
        if(er)
            return er;
        return(sock_getsockname(get_fs_long(args+0),
            (struct sockaddr *)get_fs_long(args+1),
            (int *)get_fs_long(args+2)));
    case SYS_GETPEERNAME://getpeernameå‡½æ•°
        er=verify_area(VERIFY_READ, args, 3 * sizeof(long));
        if(er)
            return er;
        return(sock_getpeername(get_fs_long(args+0),
            (struct sockaddr *)get_fs_long(args+1),
            (int *)get_fs_long(args+2)));
    case SYS_SOCKETPAIR://socketpairå‡½æ•°
        er=verify_area(VERIFY_READ, args, 4 * sizeof(long));
        if(er)
            return er;
        return(sock_socketpair(get_fs_long(args+0),
            get_fs_long(args+1),
            get_fs_long(args+2),
            (unsigned long *)get_fs_long(args+3)));
    case SYS_SEND://sendå‡½æ•°
        er=verify_area(VERIFY_READ, args, 4 * sizeof(unsigned long));
        if(er)
            return er;
        return(sock_send(get_fs_long(args+0),
            (void *)get_fs_long(args+1),
            get_fs_long(args+2),
            get_fs_long(args+3)));
    case SYS_SENDTO://sendtoå‡½æ•°
        er=verify_area(VERIFY_READ, args, 6 * sizeof(unsigned long));
        if(er)
            return er;
        return(sock_sendto(get_fs_long(args+0),
            (void *)get_fs_long(args+1),
            get_fs_long(args+2),
            get_fs_long(args+3),
            (struct sockaddr *)get_fs_long(args+4),
            get_fs_long(args+5)));
    case SYS_RECV://recvå‡½æ•°
        er=verify_area(VERIFY_READ, args, 4 * sizeof(unsigned long));
        if(er)
            return er;
        return(sock_recv(get_fs_long(args+0),
            (void *)get_fs_long(args+1),
            get_fs_long(args+2),
            get_fs_long(args+3)));
    case SYS_RECVFROM://recvfromå‡½æ•°
        er=verify_area(VERIFY_READ, args, 6 * sizeof(unsigned long));
        if(er)
            return er;
        return(sock_recvfrom(get_fs_long(args+0),
            (void *)get_fs_long(args+1),
            get_fs_long(args+2),
            get_fs_long(args+3),
            (struct sockaddr *)get_fs_long(args+4),
            (int *)get_fs_long(args+5)));
    case SYS_SHUTDOWN://shutdownå‡½æ•°
        er=verify_area(VERIFY_READ, args, 2</em> sizeof(unsigned long));
        if(er)
            return er;
        return(sock_shutdown(get_fs_long(args+0),
            get_fs_long(args+1)));
    case SYS_SETSOCKOPT://setsockoptå‡½æ•°
        er=verify_area(VERIFY_READ, args, 5<em>sizeof(unsigned long));
        if(er)
            return er;
        return(sock_setsockopt(get_fs_long(args+0),
            get_fs_long(args+1),
            get_fs_long(args+2),
            (char *)get_fs_long(args+3),
            get_fs_long(args+4)));
    case SYS_GETSOCKOPT://getsockoptå‡½æ•°
        er=verify_area(VERIFY_READ, args, 5</em>sizeof(unsigned long));
        if(er)
            return er;
        return(sock_getsockopt(get_fs_long(args+0),
            get_fs_long(args+1),
            get_fs_long(args+2),
            (char *)get_fs_long(args+3),
            (int *)get_fs_long(args+4)));
    default:
        return(-EINVAL);
}
}</li>
</ul>

<p>ä¸‹é¢å†çœ‹çœ‹socket.c å³BSD socketå±‚ä¸­çš„å…¶ä½™å‡½æ•°
/*</p>
<ul>
  <li>Sockets are not seekable.
 */</li>
</ul>

<p>static int sock_lseek(struct inode *inode, struct file *file, off_t offset, int whence)
{
	return(-ESPIPE);
}</p>

<p>/*</p>
<ul>
  <li>Read data from a socket. ubuf is a user mode pointer. We make sure the user</li>
  <li>area ubufâ€¦ubuf+size-1 is writable before asking the protocol.
 */</li>
</ul>

<p>static int sock_read(struct inode *inode, struct file *file, char *ubuf, int size)
{
	struct socket *sock;
	int err;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!(sock = socki_lookup(inode))) 
{
	printk("NET: sock_read: can't find socket for inode!\n");
	return(-EBADF);
}
if (sock-&gt;flags &amp; SO_ACCEPTCON) 
	return(-EINVAL);
 
if(size&lt;0)
	return -EINVAL;
if(size==0)
	return 0;
if ((err=verify_area(VERIFY_WRITE,ubuf,size))&lt;0)
  	return err;
return(sock-&gt;ops-&gt;read(sock, ubuf, size, (file-&gt;f_flags &amp; O_NONBLOCK))); }
</code></pre></div></div>

<p>/*</p>
<ul>
  <li>Write data to a socket. We verify that the user area ubuf..ubuf+size-1 is</li>
  <li>readable by the user process.
 */</li>
</ul>

<p>static int sock_write(struct inode *inode, struct file *file, char *ubuf, int size)
{
	struct socket *sock;
	int err;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!(sock = socki_lookup(inode))) 
{
	printk("NET: sock_write: can't find socket for inode!\n");
	return(-EBADF);
}
 
if (sock-&gt;flags &amp; SO_ACCEPTCON) 
	return(-EINVAL);

if(size&lt;0)
	return -EINVAL;
if(size==0)
	return 0;
	
if ((err=verify_area(VERIFY_READ,ubuf,size))&lt;0)
  	return err;
return(sock-&gt;ops-&gt;write(sock, ubuf, size,(file-&gt;f_flags &amp; O_NONBLOCK))); }
</code></pre></div></div>

<p>/*</p>
<ul>
  <li>You canâ€™t read directories from a socket!
 */</li>
</ul>

<p>static int sock_readdir(struct inode *inode, struct file *file, struct dirent *dirent,
	     int count)
{
	return(-EBADF);
}</p>

<p>/*</p>
<ul>
  <li>With an ioctl arg may well be a user mode pointer, but we donâ€™t know what to do</li>
  <li>with it - thats up to the protocol still.
 */</li>
</ul>

<p>int sock_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
	   unsigned long arg)
{
	struct socket *sock;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!(sock = socki_lookup(inode))) 
{
	printk("NET: sock_ioctl: can't find socket for inode!\n");
	return(-EBADF);
}
  	return(sock-&gt;ops-&gt;ioctl(sock, cmd, arg)); }
</code></pre></div></div>

<p>static int sock_select(struct inode *inode, struct file *file, int sel_type, select_table * wait)
{
	struct socket *sock;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!(sock = socki_lookup(inode))) 
{
	printk("NET: sock_select: can't find socket for inode!\n");
	return(0);
}
 
/*
 *	We can't return errors to select, so it's either yes or no. 
 */
 
if (sock-&gt;ops &amp;&amp; sock-&gt;ops-&gt;select)
	return(sock-&gt;ops-&gt;select(sock, sel_type, wait));
return(0); }
</code></pre></div></div>

<p>void sock_close(struct inode *inode, struct file *filp)
{
	struct socket *sock;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 *	It's possible the inode is NULL if we're closing an unfinished socket. 
 */
 
if (!inode) 
	return; //æ‰¾å¯¹inodeå¯¹åº”çš„socketç»“æ„
if (!(sock = socki_lookup(inode))) 
{
	printk("NET: sock_close: can't find socket for inode!\n");
	return;
}
sock_fasync(inode, filp, 0);//æ›´æ–°å¼‚æ­¥é€šçŸ¥åˆ—è¡¨
sock_release(sock);//é‡Šæ”¾å¥—æ¥å­— }
</code></pre></div></div>

<p>/*</p>
<ul>
  <li>
    <p>Update the socket async list
 */
//è¾“å…¥å‚æ•°onçš„å–å€¼å†³å®šæ˜¯åˆ†é…è¿˜æ˜¯é‡Šæ”¾ä¸€ä¸ªfasync_structç»“æ„ï¼Œè¯¥ç»“æ„ç”¨äºå¼‚æ­¥å”¤é†’
static int sock_fasync(struct inode *inode, struct file *filp, int on)
{
struct fasync_struct *fa, *fna=NULL, **prev;
struct socket *sock;
unsigned long flags;</p>

    <p>if (on)//åˆ†é…
{
    fna=(struct fasync_struct *)kmalloc(sizeof(struct fasync_struct), GFP_KERNEL);
    if(fna==NULL)
        return -ENOMEM;
}</p>

    <p>sock = socki_lookup(inode);</p>

    <p>prev=&amp;(sock-&gt;fasync_list);</p>

    <p>save_flags(flags);//ä¿å­˜å½“å‰çŠ¶æ€
cli();</p>

    <p>//ä»é“¾è¡¨ä¸­æ‰¾åˆ°ä¸fileç»“æ„å¯¹åº”çš„fasync_struct
for(fa=<em>prev; fa!=NULL; prev=&amp;fa-&gt;fa_next,fa=</em>prev)
    if(fa-&gt;fa_file==filp)
        break;</p>

    <p>if(on)//åˆ†é…åçš„å»ºç«‹è”ç³»
{
    //å¦‚æœå·²ç»æœ‰å¯¹åº”çš„fileç»“æ„ï¼Œåˆ™é‡Šæ”¾ä¹‹å‰åˆ›å»ºçš„
    if(fa!=NULL)
    {
        kfree_s(fna,sizeof(struct fasync_struct));
        restore_flags(flags);
        return 0;
    }
    //å¦‚æœæ²¡æœ‰ï¼Œåˆ™æŒ‚è½½è¿™ä¸ªæ–°åˆ›å»ºçš„ç»“æ„
    fna-&gt;fa_file=filp;
    fna-&gt;magic=FASYNC_MAGIC;
    fna-&gt;fa_next=sock-&gt;fasync_list;
    sock-&gt;fasync_list=fna;
}
//é‡Šæ”¾
else
{
    if(fa!=NULL)
    {
        *prev=fa-&gt;fa_next;
        kfree_s(fa,sizeof(struct fasync_struct));
    }
}
restore_flags(flags);//æ¢å¤çŠ¶æ€
return 0;
}</p>
  </li>
</ul>

<p>/*</p>
<ul>
  <li>å¼‚æ­¥å”¤é†’å‡½æ•°ï¼Œé€šè¿‡éå†socketç»“æ„ä¸­fasync_listå˜é‡æŒ‡å‘çš„é˜Ÿåˆ—ï¼Œ</li>
  <li>å¯¹é˜Ÿåˆ—ä¸­æ¯ä¸ªå…ƒç´ è°ƒç”¨kill_fasyncå‡½æ•°
 */
int sock_wake_async(struct socket *sock, int how)
{
 if (!sock || !sock-&gt;fasync_list)
     return -1;
 switch (how)
 {
     case 0:
         //kill_fasyncå‡½æ•°å³é€šè¿‡ç›¸åº”çš„è¿›ç¨‹å‘é€ä¿¡å·ã€‚è¿™å°±æ˜¯å¼‚æ­¥å”¤é†’åŠŸèƒ½
         kill_fasync(sock-&gt;fasync_list, SIGIO);
         break;
     case 1:
         if (!(sock-&gt;flags &amp; SO_WAITDATA))
             kill_fasync(sock-&gt;fasync_list, SIGIO);
         break;
     case 2:
         if (sock-&gt;flags &amp; SO_NOSPACE)
         {
             kill_fasync(sock-&gt;fasync_list, SIGIO);
             sock-&gt;flags &amp;= ~SO_NOSPACE;
         }
         break;
 }
 return 0;
}</li>
</ul>

<p>/*</p>
<ul>
  <li>åªç”¨äºUNIXåŸŸå(iconn,connåªç”¨äºUNIXåŸŸ)ï¼Œç”¨äºå¤„ç†ä¸€ä¸ªå®¢æˆ·ç«¯è¿æ¥è¯·æ±‚
 */</li>
</ul>

<p>int sock_awaitconn(struct socket *mysock, struct socket *servsock, int flags)
{
	struct socket *last;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*
 *	We must be listening
 */
 //æ£€æŸ¥æœåŠ¡å™¨ç«¯æ˜¯å¦æ˜¯å¤„äºç›‘å¬çŠ¶æ€ï¼Œå³å¯ä»¥è¿›è¡Œè¿æ¥
if (!(servsock-&gt;flags &amp; SO_ACCEPTCON)) 
{
	return(-EINVAL);
}
</code></pre></div></div>

  	/*
  	 *	Put ourselves on the serverâ€™s incomplete connection queue. 
  	 */
  	 //å°†æœ¬æ¬¡å®¢æˆ·ç«¯è¿æ¥çš„å¥—æ¥å­—æ’å…¥æœåŠ¡å™¨ç«¯ï¼Œsocketç»“æ„iconnå­—æ®µæŒ‡å‘çš„é“¾è¡¨
  	 //è¡¨ç¤ºå®¢æˆ·ç«¯æ­£ç­‰å¾…è¿æ¥
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysock-&gt;next = NULL;
cli();
if (!(last = servsock-&gt;iconn)) 
	servsock-&gt;iconn = mysock;
else 
{
	while (last-&gt;next) 
		last = last-&gt;next;
	last-&gt;next = mysock;
}
mysock-&gt;state = SS_CONNECTING;//æ­£åœ¨å¤„ç†è¿æ¥
mysock-&gt;conn = servsock;//å®¢æˆ·ç«¯è¿æ¥çš„æœåŠ¡å™¨ç«¯å¥—æ¥å­—
sti();
 
/*
 * Wake up server, then await connection. server will set state to
 * SS_CONNECTED if we're connected.
 */
 //å”¤é†’æœåŠ¡å™¨ç«¯è¿›ç¨‹ï¼Œä»¥å¤„ç†æœ¬åœ°å®¢æˆ·ç«¯è¿æ¥
wake_up_interruptible(servsock-&gt;wait);
sock_wake_async(servsock, 0);
 
//æ£€æŸ¥è¿æ¥çŠ¶æ€
if (mysock-&gt;state != SS_CONNECTED) 
{
	if (flags &amp; O_NONBLOCK)
		return -EINPROGRESS;
	//ç­‰å¾…æœåŠ¡å™¨ç«¯å¤„ç†æœ¬æ¬¡è¿æ¥
	interruptible_sleep_on(mysock-&gt;wait);
	
	//æ£€æŸ¥è¿æ¥çŠ¶æ€ï¼Œå¦‚æœä»ç„¶æ²¡æœ‰å»ºç«‹è¿æ¥
	if (mysock-&gt;state != SS_CONNECTED &amp;&amp;
	    mysock-&gt;state != SS_DISCONNECTING) 
	{
	/*åŸå› å¦‚ä¸‹
	 * if we're not connected we could have been
	 * 1) interrupted, so we need to remove ourselves
	 *    from the server list
	 * 2) rejected (mysock-&gt;conn == NULL), and have
	 *    already been removed from the list
	 */
	 //å¦‚æœè¢«å…¶ä»–ä¸­æ–­ï¼Œéœ€è¦ä¸»åŠ¨å°†æœ¬åœ°socketä»å¯¹æ–¹æœåŠ¡å™¨ä¸­iconnä¸­åˆ é™¤
		if (mysock-&gt;conn == servsock) 
		{
			cli();
			//æ‰¾åˆ°iconnä¸­çš„æœ¬åœ°socketç»“æ„
			if ((last = servsock-&gt;iconn) == mysock)
				servsock-&gt;iconn = mysock-&gt;next;
			else 
			{
				while (last-&gt;next != mysock) 
					last = last-&gt;next;
				last-&gt;next = mysock-&gt;next;
			}
			sti();
		}
		//è¢«æœåŠ¡å™¨æ‹’ç»ï¼Œæœ¬åœ°socketå·²ç»è¢«åˆ é™¤ï¼Œæ— éœ€æ‰‹åŠ¨åˆ é™¤
		return(mysock-&gt;conn ? -EINTR : -EACCES);//ä¸¤ç§åŸå› æƒ…å†µçš„è¿”å›
	}
}
return(0); } å…¶ä½™æ²¡æœ‰è´´å‡ºçš„å‡½æ•°ï¼Œä¹ŸåŸºæœ¬ä¸Šæ˜¯è¿™ä¹ˆä¸ªæµç¨‹ã€‚ socket.c æ–‡ä»¶ä¸­å‡½æ•°çš„å®ç°ç»å¤§å¤šæ•°éƒ½æ˜¯ç®€å•è°ƒç”¨ä¸‹å±‚å‡½æ•°ï¼Œè€Œè¿™äº›ä¸‹å±‚å‡½æ•°å°±æ˜¯af_inet.c æ–‡ä»¶ä¸­å®šä¹‰çš„å‡½æ•°ã€‚socket.c å¯¹åº” BSD socketå±‚ï¼Œæ–‡ä»¶af_inet.c åˆ™å¯¹åº”çš„æ˜¯INET socketå±‚ã€‚è¿™äº›ä¸Šä¸‹å±‚æ¬¡çš„è¡¨ç¤ºä»å‡½æ•°çš„åµŒå¥—è°ƒç”¨å…³ç³»ä¸Šä½“ç°å‡ºæ¥ã€‚
</code></pre></div></div>
:ET