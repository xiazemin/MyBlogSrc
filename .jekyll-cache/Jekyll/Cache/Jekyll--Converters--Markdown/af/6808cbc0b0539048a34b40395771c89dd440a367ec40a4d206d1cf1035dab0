I"#<p>å½“å‰å †æ ˆ:
log.Infof(â€œstack %sâ€, f, debug.Stack())
åŒ…è£¹äº†n := runtime.Stack(buf, false)</p>

<p>å…¨å±€å †æ ˆ:
buf := make([]byte, 1Â«16)
runtime.Stack(buf, true)
log.Infof(â€œ[start all stack]â€”â€”â€”â€”â€”-Â  %sÂ  Â â€”â€”â€”â€”â€”-[all stack end]â€, buf)
<!-- more -->
https://stackoverflow.com/questions/10742749/get-name-of-function-using-reflection</p>

<p>æˆ‘ä»¬çŸ¥é“åœ¨golangç¤¾åŒºé‡Œå¤šæ•°webæ¡†æ¶è‡ªå¸¦äº†panicåçš„recoveryåŠŸèƒ½ã€‚goçš„recoveryå¯ä»¥å½“æˆä¸€ä¸ªä¿æŠ¤æ–¹æ¡ˆï¼Œé¿å…å› ä¸ºå„ç§é”™è¯¯å¯¼è‡´è¿›ç¨‹æŒ‚æ‰ï¼Œä¸šåŠ¡å—åˆ°å½±å“ï¼Œç»§è€Œå½±å“kpiï¼Œæœ€åé’±å°‘äº†ï¼Œåª³å¦‡å°±ä¸ä¹æ„äº†ï¼Œä¸è®©ä½ è¿›å®¶é—¨â€¦</p>

<p>golang echoè¿™ä¸ªæ¡†æ¶ä¹Ÿæœ‰recoveryçš„åŠŸèƒ½ï¼Œä½†ä»–çš„é»˜è®¤æ–¹æ³•ç€å®å‘äººï¼Œè¯¥å‘ä¼šå¼•èµ·æˆ‘ä»¬æ ‡é¢˜ä¸­çš„æ‰€æè¿°çš„é«˜å»¶è¿Ÿå’Œé˜»å¡é—®é¢˜ã€‚ æ„Ÿè°¢å‰åŒäº‹å‘ç°çš„é—®é¢˜ @è¶£å¤´æ¡æ¶æ„å¸ˆå¾é¹</p>

<p>è¯¥æ–‡ç« åç»­ä»åœ¨ä¸æ–­çš„æ›´æ–°ä¿®æ”¹ä¸­ï¼Œ è¯·ç§»æ­¥åˆ°åŸæ–‡åœ°å€ http://xiaorui.cc/?p=6294</p>

<p>æºç è§£è¯»ï¼š</p>

<p>ä¸‹é¢æ˜¯å®˜æ–¹ç»™çš„ä¾‹å­ï¼Œåƒå…¶ä»–webæ¡†æ¶ä¸€æ ·ï¼ŒæŠŠrecoveryåšåˆ°äº†ä¸­é—´ä»¶é‡Œé¢ã€‚</p>

<p>// xiaorui.cc</p>

<p>package main</p>

<p>import (
  â€œnet/httpâ€
  â€œgithub.com/labstack/echo/v4â€
  â€œgithub.com/labstack/echo/v4/middlewareâ€
)</p>

<p>func main() {
  // Echo instance
  e := echo.New()</p>

<p>// Middleware
  e.Use(middleware.Recover())
 â€¦
é»˜è®¤çš„config.DisableStackAllä¸ºfalseï¼Œä¸‹é¢ä½¿ç”¨äº† ! ç¬¦å·ï¼Œè´Ÿè´Ÿå¾—æ­£ã€‚ç®€å•è¯´ï¼Œé»˜è®¤æ˜¯æ‰“å°æ‰€æœ‰çš„åç¨‹æ ˆï¼Œå½“ç„¶æœ€åçš„æ‰“å°ä¾èµ–stackSizeï¼Œbufå€¼ä¸º4KBå¤§å°ã€‚</p>

<p>// xiaorui.cc</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>			if r := recover(); r != nil {
				err, ok := r.(error)
				if !ok {
					err = fmt.Errorf("%v", r)
				}
				stack := make([]byte, config.StackSize)
				length := runtime.Stack(stack, !config.DisableStackAll)
				if !config.DisablePrintStack {
					c.Logger().Printf("[PANIC RECOVER] %v %s\n", err, stack[:length])
				}
				c.Error(err)
			} å½“all=falseæ—¶ï¼Œåªä¼šè·å–å½“å‰åç¨‹çš„å‡½æ•°è°ƒç”¨æ ˆä¿¡æ¯ï¼Œæ— éœ€åŠ é”ã€‚ä½†all=trueæ—¶ï¼Œæ„å‘³ç€è¦è·å–æ‰€æœ‰åç¨‹çš„æ ˆä¿¡æ¯ï¼Œåœ¨go runtimeçš„pmgè°ƒåº¦æ¨¡å‹ä¸‹ï¼Œä¸ºäº†ä¿è¯å¹¶å‘æ“ä½œå®‰å…¨ï¼Œè‡ªç„¶å°±éœ€è¦åœ¨stackæ–¹æ³•é‡ŒåŠ äº†é”ï¼Œä¸”é”çš„ç²’åº¦è¿˜ä¸å°ï¼Œç›´æ¥è°ƒç”¨stopTheWorldç”¨æ¥é˜»å¡GCçš„æ“ä½œã€‚
</code></pre></div></div>

<p>goroutineheaderæ–¹æ³•ç”¨æ¥è·å–åç¨‹çš„çŠ¶æ€ä¿¡æ¯ï¼Œæ¯”å¦‚ç­‰å¾…é”ï¼Œscanï¼Œå·²ç­‰å¾…æ—¶é—´ç­‰ã€‚allgsæ˜¯runtimeä¿å­˜çš„æ‰€æœ‰å·²åˆ›å»ºåç¨‹çš„å®¹å™¨ï¼Œå½“ç„¶ä¸ä¼šå»è¿½è¸ªå·²ç»æ¶ˆäº¡çš„åç¨‹ã€‚å¦å¤–ï¼Œä¸ºäº†ä¿æŠ¤allgsåˆ‡ç‰‡çš„å®‰å…¨ï¼Œè¿˜ä¼šå¯¹allglockåŠ é”ï¼Œåœ¨allgadd()åˆ›å»ºgoroutineå’Œcheckdead()æ£€æµ‹æ­»é”é‡Œä¼šäº§ç”Ÿé”ç«äº‰ã€‚</p>

<p>// xiaorui.cc</p>

<p>func Stack(buf []byte, all bool) int {
	if all {
		stopTheWorld(â€œstack traceâ€)
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n := 0
if len(buf) &gt; 0 {
	gp := getg()
	sp := getcallersp()
	pc := getcallerpc()
	systemstack(func() {
		g0 := getg()
		g0.m.traceback = 1
		g0.writebuf = buf[0:0:len(buf)]
		goroutineheader(gp)
		traceback(pc, sp, 0, gp)
		if all {
			tracebackothers(gp)
		}
		g0.m.traceback = 0
		n = len(g0.writebuf)
		g0.writebuf = nil
	})
}

if all {
	startTheWorld()
}
return n }
</code></pre></div></div>

<p>func tracebackothers(me *g) {
	g := getg()
	gp := g.m.curg
	if gp != nil &amp;&amp; gp != me {
		print(â€œ\nâ€)
		goroutineheader(gp)
		traceback(^uintptr(0), ^uintptr(0), 0, gp)
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lock(&amp;allglock)
for _, gp := range allgs {
	if gp == me || gp == g.m.curg || readgstatus(gp) == _Gdead || isSystemGoroutine(gp, false) &amp;&amp; level &lt; 2 {
		continue
	}
	print("\n")
	goroutineheader(gp)
	if gp.m != g.m &amp;&amp; readgstatus(gp)&amp;^_Gscan == _Grunning {
		print("\tgoroutine running on other thread; stack unavailable\n")
		printcreatedby(gp)
	} else {
		traceback(^uintptr(0), ^uintptr(0), 0, gp)
	}
}
unlock(&amp;allglock) }
</code></pre></div></div>

<p>func goroutineheader(gp *g) {
	// approx time the G is blocked, in minutes
	var waitfor int64
	if (gpstatus == _Gwaiting || gpstatus == _Gsyscall) &amp;&amp; gp.waitsince != 0 {
		waitfor = (nanotime() - gp.waitsince) / 60e9
	}
	print(â€œgoroutine â€œ, gp.goid, â€œ [â€, status)
	if isScan {
		print(â€œ (scan)â€)
	}
	if waitfor &gt;= 1 {
		print(â€œ, â€œ, waitfor, â€œ minutesâ€)
	}
â€¦
æˆ‘ä»¬å¯ä»¥è®¾æƒ³ä¸€ä¸‹ï¼Œåœ¨echoé‡ŒæŸä¸ªæ¥å£å¹¶å‘çš„å‡ºç°äº†recoveryçš„é—®é¢˜ï¼Œé‚£ä¹ˆéƒ½ä¼šèµ°ä¸Šé¢çš„åŠ é”çš„è¿‡ç¨‹ï¼Œè€Œä¸”è¿˜å¹¶å‘æ“ä½œï¼Œé‚£ä¹ˆåŠ¿å¿…ä¼šé€ æˆé˜»å¡å’Œé«˜æ—¶å»¶çš„é—®é¢˜ã€‚</p>

<p>å…¶ä»–webæ¡†æ¶çš„recoveryæºç ï¼š</p>

<p>è¿½äº†ä¸‹ginå’Œirisçš„recoveryæºç å®ç°ï¼Œéƒ½åªä¼ é€’éœ€è¦æ‰“å°çš„æ ˆå±‚æ•°ï¼Œç„¶åè°ƒç”¨runtime.Callerè·å–æ ˆçš„ä¿¡æ¯ã€‚https://github.com/gin-gonic/gin/blob/master/recovery.go</p>

<p>// xiaorui.cc</p>

<p>func stack(skip int) []byte {
	buf := new(bytes.Buffer) // the returned data
	// As we loop, we open files and read them. These variables record the currently
	// loaded file.
	var lines [][]byte
	var lastFile string
	for i := skip; ; i++ { // Skip the expected number of frames
		pc, file, line, ok := runtime.Caller(i)
		if !ok {
			break
		}
		// Print this much at least.  If we canâ€™t find the source, it wonâ€™t show.
		fmt.Fprintf(buf, â€œ%s:%d (0x%x)\nâ€, file, line, pc)
		if file != lastFile {
			data, err := ioutil.ReadFile(file)
			if err != nil {
				continue
			}
			lines = bytes.Split(data, []byte{â€˜\nâ€™})
			lastFile = file
		}
		fmt.Fprintf(buf, â€œ\t%s: %s\nâ€, function(pc), source(lines, line))
	}
	return buf.Bytes()
}
å…¶ä»–æ‰“å°åç¨‹çš„æ–¹æ³•ï¼Ÿ</p>

<p>debug.PrintStackå¯æ‰“å°å½“å‰åç¨‹çš„æ ˆä¿¡æ¯ï¼Œç›¸æ¯”ä¸Šé¢runtime.Stackå’Œruntime.Callerï¼Œè¯¥æ–¹æ³•åªèƒ½è¾“å‡ºåˆ°æ ‡å‡†é”™è¯¯è¾“å‡ºçš„fdä¸Šã€‚ä¸ºäº†èƒ½å®Œæ•´è¾“å‡ºæ ˆä¿¡æ¯ï¼Œè¿˜ç²¾ç»†çš„åšäº†bufçš„æ‰©å……é‡è¯•ã€‚ğŸ˜… å¦å¤–ï¼Œpprofä¹Ÿæä¾›äº†æ ˆçš„æ‰“å°ï¼Œpprof.Lookup(â€œgoroutineâ€)å°±å¯ä»¥æ‹¿åˆ°ã€‚</p>

<p>// xiaorui.cc</p>

<p>func PrintStack() {
	os.Stderr.Write(Stack())
}</p>

<p>func Stack() []byte {
	buf := make([]byte, 1024)
	for {
		n := runtime.Stack(buf, false)
		if n &lt; len(buf) {
			return buf[:n]
		}
		buf = make([]byte, 2*len(buf))
	}
}
è§£å†³æ–¹æ³•ï¼š</p>

<p>ä¿®æ”¹é»˜è®¤å€¼ï¼Œè®©recoveryåªæ‰“å°å½“å‰åç¨‹æ ˆä¿¡æ¯ï¼Œè¿™æ ·å°±é¿å…äº†åŠ é”çš„å„ç§æ“ä½œäº†ã€‚æ›´æ¨èçš„æ–¹æ³•æ˜¯è‡ªå®šä¹‰ä¸­é—´ä»¶æ¥å®ç°recoveryï¼Œruntime.Callerçš„æ€§èƒ½è¦ä¼˜äºruntime.Stackã€‚</p>

<p>http://xiaorui.cc/archives/6294</p>
:ET