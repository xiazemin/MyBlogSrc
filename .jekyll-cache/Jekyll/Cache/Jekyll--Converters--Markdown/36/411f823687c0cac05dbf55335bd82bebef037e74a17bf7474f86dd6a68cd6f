I"ôP<p>1ã€é¦–å…ˆä½¿ç”¨dockeråˆ›å»ºä¸€ä¸ªå®¹å™¨ï¼Œå¹¶è·å–è¯¥å®¹å™¨çš„network namespace
$ docker run -itd â€“name test ubuntu /bin/bash
$ docker ps
$ docker inspect â€“format â€˜{{ .State.Pid }}â€™ test
3656
ç”±ä¸Šå¯çŸ¥ï¼Œè¯¥å®¹å™¨çš„network namespaceåœ¨/proc/3656/ns/net</p>

<p>2ã€å¯åŠ¨ä¸€ä¸ªç¨‹åºï¼ŒåŠ å…¥è¯¥network namespaceï¼Œå¹¶ä¸”execä¸ºbashï¼ŒæŸ¥çœ‹è¿è¡Œæ•ˆæœ
#define _GNU_SOURCE
#include <fcntl.h>
#include <sched.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h></stdio.h></stdlib.h></unistd.h></sched.h></fcntl.h></p>

<p>#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE);<br />
                        } while (0)</p>

<p>int
main(int argc, char *argv[]) {
        int fd;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if (argc &lt; 3) {
            fprintf(stderr, "%s /proc/PID/ns/FILE cmd args...\n", argv[0]);
            exit(EXIT_FAILURE);
    }
 
    fd = open(argv[1], O_RDONLY);   // Get descriptor for namespace
    if (fd == -1)
            errExit("open");
 
    if (setns(fd, 0) == -1)         // Join that namespace
            errExit("setns");
 
    execvp(argv[2], &amp;argv[2]);      // Execute a command in namspace
    errExit("execvp"); } &lt;!-- more --&gt; # ./ns_exec /proc/3656/ns/net /bin/bash # ifconfig eth0      Link encap:Ethernet  HWaddr 02:42:ac:11:00:02 Linux kernelä¸ºå®¹å™¨æŠ€æœ¯æä¾›çš„åŸºç¡€è®¾æ–½ä¹‹ä¸€namespace(å¦ä¸€ä¸ªæ˜¯cgroups)ï¼ŒåŒ…æ‹¬uts/user/pid/mnt/ipc/netå…­ä¸ª(3.13.0çš„å†…æ ¸). è¿™ä¸œè¥¿ä¸»è¦ç”¨æ¥åšèµ„æºçš„éš”ç¦»ï¼Œæˆ‘æ„Ÿè§‰æœ¬è´¨ä¸Šæ˜¯å…¨å±€èµ„æºçš„æ˜ å°„ï¼Œæ˜ å°„ä¹‹é—´ç‹¬ç«‹äº†è‡ªç„¶éš”ç¦»äº†ã€‚ä¸»è¦æ¶‰åŠåˆ°çš„ä¸œè¥¿æ˜¯:
</code></pre></div></div>

<p>clone
setns
unshare
/proc/pid/ns, /proc/pid/uid_map, /proc/pid/gid_mapç­‰
å€¼å¾—æ³¨æ„çš„å‡ ä¸ªç‚¹:</p>

<p>ä¸åŒç‰ˆæœ¬çš„å†…æ ¸setnså’Œunshareå¯¹namespaceçš„æ”¯æŒä¸ä¸€æ ·ï¼Œè¾ƒè€çš„å†…æ ¸å¯èƒ½åªæ”¯æŒipc/net/utsä¸‰ä¸ªnamespace
æŸä¸ªè¿›ç¨‹åˆ›å»ºåå…¶pid namespaceå°±å›ºå®šäº†ï¼Œä½¿ç”¨setnså’Œunshareæ”¹å˜åï¼Œå…¶æœ¬èº«çš„pid namespaceä¸ä¼šæ”¹å˜ï¼Œåªæœ‰forkå‡ºçš„å­è¿›ç¨‹çš„pid namespaceæ”¹å˜(æ”¹å˜çš„æ˜¯æ¯ä¸ªè¿›ç¨‹çš„nsproxy-&gt;pid_namespace_for_children)
ç”¨setnsæ·»åŠ mnt namespaceåº”è¯¥æ”¾åœ¨å…¶ä»–namespaceä¹‹åï¼Œå¦åˆ™å¯èƒ½å‡ºç°æ— æ³•æ‰“å¼€/proc/pid/ns/â€¦çš„é”™è¯¯</p>

<p>// ä»£ç 1: å¼€ä¸€äº›æ–°çš„namespace(å¯åŠ¨æ–°å®¹å™¨)
#define _GNU_SOURCE
#include &lt;sys/wait.h&gt;
#include <sched.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h></unistd.h></stdlib.h></stdio.h></string.h></sched.h></p>

<p>#define errExit(msg)  do { perror(msg); exit(EXIT_FAILURE); <br />
} while (0)</p>

<p>/* Start function for cloned child */
static int childFunc(void *arg)
{
  const char *binary = â€œ/bin/bashâ€;
  char *const argv[] = {
    â€œ/bin/bashâ€,
    NULL
  };
  char *const envp[] = { NULL };</p>

<p>/* wrappers for execve */
  // has const char * as argument list
  // execl 
  // execle  =&gt; has envp
  // execlp  =&gt; need search PATH</p>

<p>// has char *const arr[] as argument list 
  // execv 
  // execvpe =&gt; need search PATH and has envp
  // execvp  =&gt; need search PATH</p>

<p>//int ret = execve(binary, argv, envp);
  int ret = execv(binary, argv);
  if (ret &lt; 0) {
    errExit(â€œexecve errorâ€);
  }
  return ret;
}</p>

<p>#define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */</p>

<p>int main(int argc, char <em>argv[])
{
  char *stack; 
  char *stackTop;               <br />
  pid_t pid;
  stack = malloc(STACK_SIZE);
  if (stack == NULL)
    errExit(â€œmallocâ€);
  stackTop = stack + STACK_SIZE;  /</em> Assume stack grows downward */</p>

<p>//pid = clone(childFunc, stackTop, CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | SIGCHLD, NULL);
  pid = clone(childFunc, stackTop, CLONE_NEWUTS | CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWIPC | SIGCHLD, NULL);
//pid = clone(childFunc, stackTop, CLONE_NEWUTS | //CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWIPC //| CLONE_NEWNET | SIGCHLD, NULL);
  if (pid == -1)
    errExit(â€œcloneâ€);
  printf(â€œclone() returned %ld\nâ€, (long) pid);</p>

<p>if (waitpid(pid, NULL, 0) == -1)<br />
    errExit(â€œwaitpidâ€);
  printf(â€œchild has terminated\nâ€);</p>

<p>exit(EXIT_SUCCESS);
}</p>

<p>/ ä»£ç 2: ä½¿ç”¨setnsåŠ å…¥æ–°è¿›ç¨‹
#define _GNU_SOURCE  // ?
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include &lt;sys/utsname.h&gt;
#include <unistd.h>
#include &lt;sys/types.h&gt;
#include <sched.h>
#include <fcntl.h>
#include <wait.h></wait.h></fcntl.h></sched.h></unistd.h></errno.h></stdlib.h></string.h></stdio.h></p>

<p>// mainly setns and unshare system calls</p>

<p>/* int setns(int fd, int nstype); */</p>

<p>// ä¸åŒç‰ˆæœ¬å†…æ ¸/proc/pid/nsä¸‹namespaceæ–‡ä»¶æƒ…å†µ
/*
   CLONE_NEWCGROUP (since Linux 4.6)
   fd must refer to a cgroup namespace.</p>

<p>CLONE_NEWIPC (since Linux 3.0)
   fd must refer to an IPC namespace.</p>

<p>CLONE_NEWNET (since Linux 3.0)
   fd must refer to a network namespace.</p>

<p>CLONE_NEWNS (since Linux 3.8)
   fd must refer to a mount namespace.</p>

<p>CLONE_NEWPID (since Linux 3.8)
   fd must refer to a descendant PID namespace.</p>

<p>CLONE_NEWUSER (since Linux 3.8)
   fd must refer to a user namespace.</p>

<p>CLONE_NEWUTS (since Linux 3.0)
   fd must refer to a UTS namespace.
   */</p>

<p>/* // ç‰¹æ®Šçš„pid namespace 
   CLONE_NEWPID behaves somewhat differently from the other nstype
values: reassociating the calling thread with a PID namespace changes
only the PID namespace that child processes of the caller will be
created in; it does not change the PID namespace of the caller
itself.  Reassociating with a PID namespace is allowed only if the
PID namespace specified by fd is a descendant (child, grandchild,
etc.)  of the PID namespace of the caller.  For further details on
PID namespaces, see pid_namespaces(7).
*/</p>

<p>/*
int unshare(int flags);
CLONE_FILES | CLONE_FS | CLONE_NEWCGROUP | CLONE_NEWIPC | CLONE_NEWNET 
| CLONE_NEWNS | CLONE_NEWPID | CLONE_NEWUSER | CLONE_NEWUTS | CLONE_SYSVSEM
*/</p>

<p>#define MAX_PROCPATH_LEN 1024</p>

<p>#define errorExit(msg) <br />
  do { fprintf(stderr, â€œ%s in file %s in line %d\nâ€, msg, <strong>FILE</strong>, <strong>LINE</strong>);<br />
    exit(EXIT_FAILURE); } while (0)</p>

<p>void printInfo();
int openAndSetns(const char *path);</p>

<p>int main(int argc, char *argv[])
{
  if (argc &lt; 2) {
    fprintf(stdout, â€œusage : execname pid(find namespaces of this process)\nâ€);
    return 0;
  }
  printInfo();</p>

<p>fprintf(stdout, â€œâ€”- setns for uts â€”-\nâ€);
  char uts[MAX_PROCPATH_LEN];
  snprintf(uts, MAX_PROCPATH_LEN, â€œ/proc/%s/ns/utsâ€, argv[1]);
  openAndSetns(uts);
  printInfo();</p>

<p>fprintf(stdout, â€œâ€”- setns for user â€”-\nâ€);
  char user[MAX_PROCPATH_LEN];
  snprintf(user, MAX_PROCPATH_LEN, â€œ/proc/%s/ns/userâ€, argv[1]);
  openAndSetns(user);
  printInfo();</p>

<p>// æ³¨æ„pid namespaceçš„ä¸åŒè¡Œä¸ºï¼Œåªæœ‰åç»­åˆ›å»ºçš„å­è¿›ç¨‹è¿›å…¥setnsè®¾ç½®
  // çš„æ–°çš„pid namespaceï¼Œæœ¬è¿›ç¨‹ä¸ä¼šæ”¹å˜
  fprintf(stdout, â€œâ€”- setns for pid â€”-\nâ€);
  char pidpath[MAX_PROCPATH_LEN];
  snprintf(pidpath, MAX_PROCPATH_LEN, â€œ/proc/%s/ns/pidâ€, argv[1]);
  openAndSetns(pidpath);
  printInfo();</p>

<p>fprintf(stdout, â€œâ€”- setns for ipc â€”-\nâ€);
  char ipc[MAX_PROCPATH_LEN];
  snprintf(ipc, MAX_PROCPATH_LEN, â€œ/proc/%s/ns/ipcâ€, argv[1]);
  openAndSetns(ipc);
  printInfo();</p>

<p>fprintf(stdout, â€œâ€”- setns for net â€”-\nâ€);
  char net[MAX_PROCPATH_LEN];
  snprintf(net, MAX_PROCPATH_LEN, â€œ/proc/%s/ns/netâ€, argv[1]);
  openAndSetns(net);
  printInfo();</p>

<p>// æ³¨æ„mnt namespaceéœ€è¦æ”¾åœ¨å…¶ä»–åé¢ï¼Œé¿å…mnt namespaceæ”¹å˜å
  // æ‰¾ä¸åˆ°/proc/pid/nsä¸‹çš„æ–‡ä»¶
  fprintf(stdout, â€œâ€”- setns for mount â€”-\nâ€);
  char mount[MAX_PROCPATH_LEN];
  snprintf(mount, MAX_PROCPATH_LEN, â€œ/proc/%s/ns/mntâ€, argv[1]);
  openAndSetns(mount);
  printInfo();</p>

<p>// æµ‹è¯•å­è¿›ç¨‹çš„pid namespace
  int ret = fork();
  if (-1 == ret) {
    errorExit(â€œfailed to forkâ€);
  } else if (ret == 0) {
    fprintf(stdout, â€œ<strong>**</strong><strong>\nâ€);
    fprintf(stdout, â€œin child process\nâ€);
    printInfo();
    fprintf(stdout, â€œ</strong><strong>**</strong>\nâ€);
    for (;;) {
      sleep(5);
    }
  } else {
    fprintf(stdout, â€œchild pid : %d\nâ€, ret);
  }
  for (;;) {
    sleep(5);
  }
  waitpid(ret, NULL, 0);
  return 0;
}</p>

<p>void printInfo()
{
  pid_t pid;
  struct utsname uts;
  uid_t uid;
  gid_t gid;
  // pid namespace 
  pid = getpid();
  // user namespace 
  uid = getuid();
  gid = getgid();
  // uts namespace 
  uname(&amp;uts);
  fprintf(stdout, â€œpid : %d\nâ€, pid);
  fprintf(stdout, â€œuid : %d\nâ€, uid);
  fprintf(stdout, â€œgid : %d\nâ€, gid);
  fprintf(stdout, â€œhostname : %s\nâ€, uts.nodename);
}</p>

<p>int openAndSetns(const char *path)
{
  int ret = open(path, O_RDONLY, 0);
  if (-1 == ret) {
    fprintf(stderr, â€œ%s\nâ€, strerror(errno));
    errorExit(â€œfailed to open fdâ€);
  }
  if (-1 == (ret = setns(ret, 0))) {
    fprintf(stderr, â€œ%s\nâ€, strerror(errno));
    errorExit(â€œfailed to setnsâ€);
  }
  return ret;
}</p>

<p>å†…æ ¸é‡Œnamespaceçš„å®ç°
(1) ä¸»è¦æ•°æ®ç»“æ„
æºç ä¸»è¦ä½ç½®:
// net_namespaceä¸ºå•¥ä¸é“¾æ¥ä¸ªå¤´æ–‡ä»¶åˆ°include/linuxâ€¦
include/net/net_namespace.h
include/linux/mnt_namespace.hä¸fs/mount.h
include/linux/ipc_namespace.h
include/linux/pid_namespace.h
include/linux/user_namespace.h
// è¿™ä¸ªå‘½åä¼°è®¡æ˜¯å†å²åŸå› â€¦
include/linux/utsname.h</p>

<p>å‡ ä¸ªnamespaceç»“æ„
æ³¨æ„å…¶ä»–namespaceéƒ½å†…åµŒäº†user_namespace
struct user_namespace {
  // uid_map 
    struct uid_gid_map  uid_map;
  // gid_map
    struct uid_gid_map  gid_map;
    struct uid_gid_map  projid_map;
    atomic_t        count;
  // çˆ¶user_namespace
    struct user_namespace   *parent;
    int         level;
    kuid_t          owner;
    kgid_t          group;
    struct ns_common    ns;
    unsigned long       flags;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Register of per-UID persistent keyrings for this namespace */ #ifdef CONFIG_PERSISTENT_KEYRINGS
struct key      *persistent_keyring_register;
struct rw_semaphore persistent_keyring_register_sem; #endif };
</code></pre></div></div>

<p>// uts_namespace
struct uts_namespace {
    struct kref kref;
    struct new_utsname name;
    struct user_namespace *user_ns;
    // å°è£…nsçš„ä¸€äº›é€šç”¨æ“ä½œé’©å­å‡½æ•°
    struct ns_common ns;
};</p>

<p>// pid_namespace 
struct pid_namespace {
    struct kref kref;
  // pidæ˜ å°„
    struct pidmap pidmap[PIDMAP_ENTRIES];
    struct rcu_head rcu;
    int last_pid;
    unsigned int nr_hashed;
  // pid_namespaceé‡Œé¢ï¼Œå­è¿›ç¨‹æŒ‚æ‰ä¼šç”±æ­¤è¿›ç¨‹rape
    struct task_struct <em>child_reaper;
    struct kmem_cache *pid_cachep;
    unsigned int level;
  // çˆ¶pid_namespace
    struct pid_namespace *parent;
  // å½“å‰namespaceåœ¨proc fsä¸­çš„ä½ç½®
#ifdef CONFIG_PROC_FS
    struct vfsmount *proc_mnt;
    struct dentry *proc_self;
    struct dentry *proc_thread_self;
#endif
#ifdef CONFIG_BSD_PROCESS_ACCT
    struct bsd_acct_struct *bacct;
#endif
  // pid_namespaceä¾èµ–user_namespace
    struct user_namespace *user_ns;
  // å·¥ä½œé˜Ÿåˆ—workqueueç›¸å…³
    struct work_struct proc_work;
    kgid_t pid_gid;
    int hide_pid;
    int reboot; /</em> group exit code if this pidns was rebooted */
  // å°è£…nsçš„ä¸€äº›é€šç”¨æ“ä½œé’©å­å‡½æ•°
    struct ns_common ns;
};</p>

<p>// mount namespace
struct mnt_namespace {
    atomic_t        count;
    struct ns_common    ns;
    // æ–°çš„mount namespaceçš„æ ¹æŒ‚è½½ç‚¹
    struct mount *  root;
    struct list_head    list;
    // å†…åµŒçš„user_namespace
    struct user_namespace   <em>user_ns;
    u64         seq;    /</em> Sequence number to prevent loops */
    wait_queue_head_t poll;
    u64 event;
};</p>

<p>struct ipc_namespace {
    atomic_t    count;
    struct ipc_ids  ids[3];</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int     sem_ctls[4];
int     used_sems;

unsigned int    msg_ctlmax;
unsigned int    msg_ctlmnb;
unsigned int    msg_ctlmni;
atomic_t    msg_bytes;
atomic_t    msg_hdrs;

size_t      shm_ctlmax;
size_t      shm_ctlall;
unsigned long   shm_tot;
int     shm_ctlmni;
/*
 * Defines whether IPC_RMID is forced for _all_ shm segments regardless
 * of shmctl()
 */
int     shm_rmid_forced;

struct notifier_block ipcns_nb;

/* The kern_mount of the mqueuefs sb.  We take a ref on it */
struct vfsmount *mq_mnt;

/* # queues in this ns, protected by mq_lock */
unsigned int    mq_queues_count;

/* next fields are set through sysctl */
unsigned int    mq_queues_max;   /* initialized to DFLT_QUEUESMAX */
unsigned int    mq_msg_max;      /* initialized to DFLT_MSGMAX */
unsigned int    mq_msgsize_max;  /* initialized to DFLT_MSGSIZEMAX */
unsigned int    mq_msg_default;
unsigned int    mq_msgsize_default;

/* user_ns which owns the ipc ns */
struct user_namespace *user_ns;

struct ns_common ns; };
</code></pre></div></div>

<p>struct net {
    atomic_t        passive;    /* To decided when the network
                         * namespace should be freed.
                         <em>/
    atomic_t        count;      /</em> To decided when the network
                         *  namespace should be shut down.
                         <em>/
#ifdef NETNS_REFCNT_DEBUG
    atomic_t        use_count;  /</em> To track references we
                         * destroy on demand
                         */
#endif
    spinlock_t      rules_mod_lock;</p>

<p>// net_namespaceé“¾è¡¨
    struct list_head    list;       /* list of network namespaces <em>/
    struct list_head    cleanup_list;   /</em> namespaces on death row <em>/
    struct list_head    exit_list;  /</em> Use only net_mutex */</p>

<p>// å†…åµŒçš„user_namespace
    struct user_namespace   <em>user_ns;   /</em> Owning user namespace */</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct ns_common    ns;

struct proc_dir_entry   *proc_net;
struct proc_dir_entry   *proc_net_stat; /*... çœç•¥ ...*/
</code></pre></div></div>

<p>(2) namespaceå¦‚ä½•äº§ç”Ÿå½±å“(ä»¥utså’Œpid namespaceä¸ºä¾‹)
uts_namespace, ä»¥unameç³»ç»Ÿè°ƒç”¨ä¸ºä¾‹
// syscall uname
SYSCALL_DEFINE1(uname, struct old_utsname __user *, name)
{
    int error = 0;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!name)
    return -EFAULT;

down_read(&amp;uts_sem);
// utsname()
if (copy_to_user(name, utsname(), sizeof(*name)))
    error = -EFAULT;
up_read(&amp;uts_sem);

if (!error &amp;&amp; override_release(name-&gt;release, sizeof(name-&gt;release)))
    error = -EFAULT;
if (!error &amp;&amp; override_architecture(name))
    error = -EFAULT;
return error; }
</code></pre></div></div>

<p>static inline struct new_utsname *utsname(void)
{
    // åˆ°å½“å‰è¿›ç¨‹uts namespaceä¸­æŸ¥æ‰¾utsname
    return &amp;current-&gt;nsproxy-&gt;uts_ns-&gt;name;
}</p>

<p>pid namespaceï¼Œä»¥getpidç³»ç»Ÿè°ƒç”¨ä¸ºä¾‹
/**</p>
<ul>
  <li>sys_getpid - return the thread group id of the current process
 *</li>
  <li>Note, despite the name, this returns the tgid not the pid.  The tgid and</li>
  <li>the pid are identical unless CLONE_THREAD was specified on clone() in</li>
  <li>which case the tgid is the same in all threads of the same group.
 *</li>
  <li>This is SMP safe as current-&gt;tgid does not change.
 */
SYSCALL_DEFINE0(getpid)
{
 return task_tgid_vnr(current);
}</li>
</ul>

<p>static inline pid_t task_tgid_vnr(struct task_struct *tsk)
{
    return pid_vnr(task_tgid(tsk));
}</p>

<p>pid_t pid_vnr(struct pid *pid)
{
    return pid_nr_ns(pid, task_active_pid_ns(current));
}
// ä»pid namespaceä¸­è·å–çœŸæ­£çš„pid number nr
pid_t pid_nr_ns(struct pid *pid, struct pid_namespace *ns)
{
    struct upid *upid; 
    pid_t nr = 0;
    if (pid &amp;&amp; ns-&gt;level &lt;= pid-&gt;level) {
        upid = &amp;pid-&gt;numbers[ns-&gt;level];
        if (upid-&gt;ns == ns)
            nr = upid-&gt;nr;
    }
    return nr;
}
EXPORT_SYMBOL_GPL(pid_nr_ns);</p>

<p>struct upid {
    /* Try to keep pid_chain in the same cacheline as nr for find_vpid */
  // çœŸæ­£çš„pid
    int nr;
  // pid_namespace
    struct pid_namespace *ns;
    struct hlist_node pid_chain;
};</p>

<p>// å¸¦æœ‰namespaceå’Œpid
struct pid
{
    atomic_t count;
    unsigned int level;
    /* lists of tasks that use this pid */
  // å¤šä¸ªçº¿ç¨‹å…±äº«ä¸€ä¸ªpid
    struct hlist_head tasks[PIDTYPE_MAX];
    struct rcu_head rcu;
    struct upid numbers[1];
};</p>

<p>setnsç³»ç»Ÿè°ƒç”¨çš„å®ç°
SYSCALL_DEFINE2(setns, int, fd, int, nstype)
{
    struct task_struct *tsk = current;
    struct nsproxy *new_nsproxy;
    struct file *file;
    struct ns_common *ns;
    int err;</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file = proc_ns_fget(fd);
if (IS_ERR(file))
    return PTR_ERR(file);

err = -EINVAL;
ns = get_proc_ns(file_inode(file));
if (nstype &amp;&amp; (ns-&gt;ops-&gt;type != nstype))
    goto out;
</code></pre></div></div>

<p>// ç›´æ¥ä¸ºå½“å‰è¿›ç¨‹åˆ›å»ºæ–°çš„nsproxyï¼Œç„¶åcopyå½“å‰è¿›ç¨‹çš„namespaceåˆ°
  // æ–°åˆ›å»ºçš„nsproxyï¼Œæœ€åè§†å¼•ç”¨æŠ€æœ¯æƒ…å†µå°†åŸæ¥çš„nsproxyæ”¾å›
  // kmem_cacheï¼Œæ˜¯å¦ä¸å¤ªé«˜æ•ˆï¼Ÿä¸èƒ½ç›´æ¥åœ¨åŸæ¥çš„nsproxyä¸Š
  // installæ–°çš„nsï¼Œæ²¡å˜çš„namespaceä¸éœ€è¦æ›´æ”¹?ä¸è¿‡è²Œä¼¼namespace
  // ä¸ä¼šç»å¸¸å˜åŒ–ï¼Œæ‰€ä»¥å¯¹æ€§èƒ½è¦æ±‚ä¹Ÿä¸éœ€è¦å¾ˆé«˜?
    new_nsproxy = create_new_namespaces(0, tsk, current_user_ns(), tsk-&gt;fs);
    if (IS_ERR(new_nsproxy)) {
        err = PTR_ERR(new_nsproxy);
        goto out;
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>err = ns-&gt;ops-&gt;install(new_nsproxy, ns);
if (err) {
    free_nsproxy(new_nsproxy);
    goto out;
}   // åˆ‡æ¢å½“å‰è¿›ç¨‹çš„nsproxyï¼Œå¹¶å¯èƒ½é‡Šæ”¾nsproxy
switch_task_namespaces(tsk, new_nsproxy); out:
fput(file);
return err; }
</code></pre></div></div>

<p>static struct nsproxy <em>create_new_namespaces(unsigned long flags,
    struct task_struct *tsk, struct user_namespace *user_ns,
    struct fs_struct *new_fs)
{
    struct nsproxy *new_nsp;
    int err;
    // åˆ›å»ºæ–°çš„nsproxy
    new_nsp = create_nsproxy();
    if (!new_nsp)
        return ERR_PTR(-ENOMEM);
    // åˆ†é…æ–°çš„mnt_namespace
    new_nsp-&gt;mnt_ns = copy_mnt_ns(flags, tsk-&gt;nsproxy-&gt;mnt_ns, user_ns, new_fs);
    if (IS_ERR(new_nsp-&gt;mnt_ns)) {
        err = PTR_ERR(new_nsp-&gt;mnt_ns);
        goto out_ns;
    }
    // åˆ†é…æ–°çš„uts namespace
    new_nsp-&gt;uts_ns = copy_utsname(flags, user_ns, tsk-&gt;nsproxy-&gt;uts_ns);
    if (IS_ERR(new_nsp-&gt;uts_ns)) {
        err = PTR_ERR(new_nsp-&gt;uts_ns);
        goto out_uts;
    }
    // åˆ†é…æ–°çš„ipc namespace
    new_nsp-&gt;ipc_ns = copy_ipcs(flags, user_ns, tsk-&gt;nsproxy-&gt;ipc_ns);
    if (IS_ERR(new_nsp-&gt;ipc_ns)) {
        err = PTR_ERR(new_nsp-&gt;ipc_ns);
        goto out_ipc;
    }
    // æ³¨æ„ä¸åŒäºå…¶ä»–namespace è¿™é‡Œæ”¹å˜çš„æ˜¯æ­¤è¿›ç¨‹çš„å­è¿›ç¨‹çš„pid namespace
    new_nsp-&gt;pid_ns_for_children =
        copy_pid_ns(flags, user_ns, tsk-&gt;nsproxy-&gt;pid_ns_for_children);
    if (IS_ERR(new_nsp-&gt;pid_ns_for_children)) {
        err = PTR_ERR(new_nsp-&gt;pid_ns_for_children);
        goto out_pid;
    }
    // åˆ†é…æ–°çš„net
    new_nsp-&gt;net_ns = copy_net_ns(flags, user_ns, tsk-&gt;nsproxy-&gt;net_ns);
    if (IS_ERR(new_nsp-&gt;net_ns)) {
        err = PTR_ERR(new_nsp-&gt;net_ns);
        goto out_net;
    }
    /</em>â€¦ çœç•¥ â€¦*/</p>

<p>unshareç³»ç»Ÿè°ƒç”¨çš„å®ç°
// unshareä¸»è¦ä¹Ÿæ˜¯ä½¿ç”¨create_new_nsproxyå’Œswitch_tasks_namespace
SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)
{
    struct fs_struct <em>fs, *new_fs = NULL;
    struct files_struct *fd, *new_fd = NULL;
    struct cred *new_cred = NULL;
    struct nsproxy *new_nsproxy = NULL;
    /</em>â€¦ çœç•¥ â€¦<em>/
    // å†…éƒ¨è°ƒç”¨äº†create_new_nsproxy
    err = unshare_nsproxy_namespaces(unshare_flags, &amp;new_nsproxy,
                     new_cred, new_fs);
    /</em>â€¦ çœç•¥ â€¦*/
    if (new_nsproxy)
       // åˆ‡æ¢å½“å‰è¿›ç¨‹çš„nsproxyåˆ°æ–°çš„nsproxyï¼Œ
       // å¹¶å¯èƒ½é‡Šæ”¾nsproxyï¼Œnsproxyæœ¬èº«ç»“æ„æ”¾å›kmem_cacheï¼Œ
       // è€Œnsproxyä¸­çš„uts/ipc/net/user/mntä»¥åŠåµŒå…¥å…¶ä»–
       // namespaceä¸­çš„user namespaceä¹Ÿä¼šæ ¹æ®å¼•ç”¨è®¡æ•°é‡Šæ”¾å›slab 
        switch_task_namespaces(current, new_nsproxy);</p>
:ET