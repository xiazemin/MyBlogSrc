I"‹&<p>https://github.com/gyuho/learn</p>

<p>åº•å±‚ä¾èµ– sync.Pool çš„åœºæ™¯</p>

<p>æœ‰ä¸€äº›å¼€æºåº“ï¼Œä¸ºäº†ä¼˜åŒ–æ€§èƒ½ï¼Œä½¿ç”¨äº†å®˜æ–¹æä¾›çš„ sync.Poolï¼Œæ¯”å¦‚æˆ‘ä»¬ä½¿ç”¨çš„ https://github.com/valyala/fasttemplate è¿™ä¸ªåº“ï¼Œæ¯å½“ä½ æ‰§è¡Œä¸‹é¢è¿™æ ·çš„ä»£ç çš„æ—¶å€™ï¼š</p>

<p>template := â€œhttp://{{host}}/?q={{query}}&amp;foo={{bar}}{{bar}}â€     t := fasttemplate.New(template, â€œ{{â€, â€œ}}â€)     s := t.ExecuteString(map[string]interface{}{         â€œhostâ€:  â€œgoogle.comâ€,         â€œqueryâ€: url.QueryEscape(â€œhello=worldâ€),         â€œbarâ€:   â€œfoobarâ€,     })     fmt.Printf(â€œ%sâ€, s) å¤åˆ¶ä»£ç 
å†…éƒ¨éƒ½ä¼šç”Ÿæˆä¸€ä¸ª fasttemplate.Template å¯¹è±¡ï¼Œå¹¶å¸¦æœ‰ä¸€ä¸ª byteBufferPool å­—æ®µï¼š</p>

<p>type Template struct {     template string     startTag string     endTag   string      texts          [][]byte     tags           []string     byteBufferPool bytebufferpool.Pool   ==== å°±æ˜¯è¿™ä¸ªå­—æ®µ } å¤åˆ¶ä»£ç 
byteBufferPool åº•å±‚å°±æ˜¯ç»è¿‡å°è£…çš„ sync.Poolï¼š</p>

<p>type Pool struct {     calls       [steps]uint64     calibrating uint64      defaultSize uint64     maxSize     uint64      pool sync.Pool } å¤åˆ¶ä»£ç 
è¿™ç§è®¾è®¡ä¼šå¸¦æ¥ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœä½¿ç”¨æ–¹æ¯æ¬¡è¯·æ±‚éƒ½ New ä¸€ä¸ª Template å¯¹è±¡ã€‚å¹¶è¿›è¡Œæ±‚å€¼ï¼Œæ¯”å¦‚æˆ‘ä»¬æœ€åˆçš„ç”¨æ³•ï¼Œåœ¨æ¯æ¬¡æ‹¿åˆ°äº†ç”¨æˆ·çš„è¯·æ±‚ä¹‹åï¼Œéƒ½ä¼šç”¨å‚æ•°å¡«å…¥åˆ°æ¨¡æ¿ï¼š</p>

<p>func fromTplToStr(tpl string, params map[string]interface{}) string {   tplVar := fasttemplate.New(tpl, <code class="language-plaintext highlighter-rouge">\{\{</code>, <code class="language-plaintext highlighter-rouge">\}\}</code>)   res := tplVar.ExecuteString(params)   return res } å¤åˆ¶ä»£ç 
åœ¨æ¨¡æ¿æ±‚å€¼çš„æ—¶å€™ï¼š</p>

<p>func (t *Template) ExecuteFuncString(f TagFunc) string {     bb := t.byteBufferPool.Get()     if _, err := t.ExecuteFunc(bb, f); err != nil {         panic(fmt.Sprintf(â€œunexpected error: %sâ€, err))     }     s := string(bb.Bytes())     bb.Reset()     t.byteBufferPool.Put(bb)     return s } å¤åˆ¶ä»£ç 
ä¼šå¯¹è¯¥ Template å¯¹è±¡çš„ byteBufferPool è¿›è¡Œ Getï¼Œåœ¨ä½¿ç”¨å®Œä¹‹åï¼ŒæŠŠ ByteBuffer Reset å†æ”¾å›åˆ°å¯¹è±¡æ± ä¸­ã€‚ä½†é—®é¢˜åœ¨äºï¼Œæˆ‘ä»¬çš„ Template å¯¹è±¡æœ¬èº«å¹¶æ²¡æœ‰è¿›è¡Œå¤ç”¨ï¼Œæ‰€ä»¥è¿™é‡Œçš„ byteBufferPool æœ¬èº«çš„ä½œç”¨å…¶å®å¹¶æ²¡æœ‰å‘æŒ¥å‡ºæ¥ã€‚
<!-- more -->
ç›¸åçš„ï¼Œå› ä¸ºæ¯ä¸€ä¸ªè¯·æ±‚éƒ½éœ€è¦æ–°ç”Ÿæˆä¸€</p>

<p>ä¸ª sync.Poolï¼Œåœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹ï¼Œæ‰§è¡Œæ—¶ä¼šå¡åœ¨ bb := t.byteBufferPool.Get() è¿™ä¸€å¥ä¸Šï¼Œé€šè¿‡å‹æµ‹å¯ä»¥æ¯”è¾ƒå¿«åœ°å‘ç°é—®é¢˜ï¼Œè¾¾åˆ°ä¸€å®š QPS å‹åŠ›æ—¶ï¼Œä¼šæœ‰å¤§é‡çš„ Goroutine å †ç§¯ï¼Œæ¯”å¦‚ä¸‹é¢æœ‰ 18910 ä¸ª G å †ç§¯åœ¨æŠ¢é”ä»£ç ä¸Šï¼š</p>

<p>goroutine profile: total 18910 18903 @ 0x102f20b 0x102f2b3 0x103fa4c 0x103f77d 0x10714df 0x1071d8f 0x1071d26 0x1071a5f 0x12feeb8 0x13005f0 0x13007c3 0x130107b 0x105c931 #   0x103f77c   sync.runtime_SemacquireMutex+0x3c                               /usr/local/go/src/runtime/sema.go:71 #   0x10714de   sync.(<em>Mutex).Lock+0xfe                                     /usr/local/go/src/sync/mutex.go:134 #   0x1071d8e   sync.(</em>Pool).pinSlow+0x3e                                   /usr/local/go/src/sync/pool.go:198 #   0x1071d25   sync.(<em>Pool).pin+0x55                                       /usr/local/go/src/sync/pool.go:191 #   0x1071a5e   sync.(</em>Pool).Get+0x2e                                       /usr/local/go/src/sync/pool.go:128 #   0x12feeb7   github.com/valyala/fasttemplate/vendor/github.com/valyala/bytebufferpool.(<em>Pool).Get+0x37   /Users/xargin/go/src/github.com/valyala/fasttemplate/vendor/github.com/valyala/bytebufferpool/pool.go:49 #   0x13005ef   github.com/valyala/fasttemplate.(</em>Template).ExecuteFuncString+0x3f              /Users/xargin/go/src/github.com/valyala/fasttemplate/template.go:278 #   0x13007c2   github.com/valyala/fasttemplate.(*Template).ExecuteString+0x52                  /Users/xargin/go/src/github.com/valyala/fasttemplate/template.go:299 #   0x130107a   main.loop.func1+0x3a                                        /Users/xargin/test/go/http/httptest.go:22 å¤åˆ¶ä»£ç 
æœ‰å¤§é‡çš„ Goroutine ä¼šé˜»å¡åœ¨è·å–é”ä¸Šï¼Œä¸ºä»€ä¹ˆå‘¢?ç»§ç»­çœ‹çœ‹ sync.Pool çš„ Get æµç¨‹ï¼š</p>

<p>func (p *Pool) Get() interface{} {     if race.Enabled {         race.Disable()     }     l := p.pin()     x := l.private     l.private = nil     runtime_procUnpin() å¤åˆ¶ä»£ç 
ç„¶åæ˜¯ pinï¼š</p>

<p>func (p *Pool) pin() *poolLocal {     pid := runtime_procPin()          s := atomic.LoadUintptr(&amp;p.localSize) // load-acquire     l := p.local                          // load-consume     if uintptr(pid) &lt; s {         return indexLocal(l, pid)     }     return p.pinSlow() } å¤åˆ¶ä»£ç 
å› ä¸ºæ¯ä¸€ä¸ªå¯¹è±¡çš„ sync.Pool éƒ½æ˜¯ç©ºçš„ï¼Œæ‰€ä»¥ pin çš„æµç¨‹ä¸€å®šä¼šèµ°åˆ° p.pinSlowï¼š</p>

<p>func (p *Pool) pinSlow() *poolLocal {     runtime_procUnpin()     allPoolsMu.Lock()     defer allPoolsMu.Unlock()     pid := runtime_procPin() å¤åˆ¶ä»£ç 
è€Œ pinSlow ä¸­ä¼šç”¨ allPoolsMu æ¥åŠ é”ï¼Œè¿™ä¸ª allPoolsMu ä¸»è¦æ˜¯ä¸ºäº†ä¿æŠ¤ allPools å˜é‡ï¼š</p>

<p>var (     allPoolsMu Mutex     allPools   []*Pool ) å¤åˆ¶ä»£ç 
åœ¨åŠ äº†é”çš„æƒ…å†µä¸‹ï¼Œä¼šæŠŠç”¨æˆ·æ–°ç”Ÿæˆçš„ sync.Pool å¯¹è±¡ append åˆ° allPools ä¸­ï¼š</p>

<p>if p.local == nil {         allPools = append(allPools, p)     } å¤åˆ¶ä»£ç 
æ ‡å‡†åº“çš„ sync.Pool ä¹‹æ‰€ä»¥è¦ç»´æŠ¤è¿™ä¹ˆä¸€ä¸ª allPools æ„å›¾ä¹Ÿæ¯”è¾ƒå®¹æ˜“æ¨æµ‹ï¼Œä¸»è¦æ˜¯ä¸ºäº† GC çš„æ—¶å€™å¯¹ pool è¿›è¡Œæ¸…ç†ï¼Œè¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆè¯´ä½¿ç”¨ sync.Pool åšå¯¹è±¡æ± æ—¶ï¼Œå…¶ä¸­çš„å¯¹è±¡æ´»ä¸è¿‡ä¸€ä¸ª GC å‘¨æœŸçš„åŸå› ã€‚sync.Pool æœ¬èº«ä¹Ÿæ˜¯ä¸ºäº†è§£å†³å¤§é‡ç”Ÿæˆä¸´æ—¶å¯¹è±¡å¯¹ GC é€ æˆçš„å‹åŠ›é—®é¢˜ã€‚</p>

<p>è¯´å®Œäº†æµç¨‹ï¼Œé—®é¢˜ä¹Ÿå°±æ¯”è¾ƒæ˜æ˜¾äº†ï¼Œæ¯ä¸€ä¸ªç”¨æˆ·è¯·æ±‚æœ€ç»ˆéƒ½éœ€è¦å»æŠ¢ä¸€æŠŠå…¨å±€é”ï¼Œé«˜å¹¶å‘åœºæ™¯ä¸‹å…¨å±€é”æ˜¯å¤§å¿Œã€‚ä½†æ˜¯è¿™ä¸ªå…¨å±€é”æ˜¯å› ä¸ºå¼€æºåº“é—´æ¥å¸¦æ¥çš„å…¨å±€é”é—®é¢˜ï¼Œé€šè¿‡çœ‹è‡ªå·±çš„ä»£ç å¹¶ä¸æ˜¯é‚£ä¹ˆå®¹æ˜“å‘ç°ã€‚</p>

<p>çŸ¥é“äº†é—®é¢˜ï¼Œæ”¹è¿›æ–¹æ¡ˆå…¶å®ä¹Ÿè¿˜å¥½å®ç°ï¼Œç¬¬ä¸€æ˜¯å¯ä»¥ä¿®æ”¹å¼€æºåº“ï¼Œå°† template çš„ sync.Pool ä½œä¸ºå…¨å±€å¯¹è±¡æ¥å¼•ç”¨ï¼Œè¿™æ ·å¤§éƒ¨åˆ† pool.Get ä¸ä¼šèµ°åˆ° pinSlow æµç¨‹ã€‚ç¬¬äºŒæ˜¯å¯¹ fasttemplate.Template å¯¹è±¡è¿›è¡Œå¤ç”¨ï¼Œé“ç†ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼Œå°±ä¸ä¼šæœ‰é‚£ä¹ˆå¤šçš„ sync.Pool å¯¹è±¡ç”Ÿæˆäº†ã€‚ä½†å‰é¢ä¹Ÿæåˆ°äº†ï¼Œè¿™ä¸ªæ˜¯ä¸ªé—´æ¥é—®é¢˜ï¼Œå¦‚æœå¼€å‘å·¥ä½œç¹å¿™ï¼Œä¸å¤ªå¯èƒ½æ‰€æœ‰çš„ä¾èµ–åº“æŠŠä»£ç å…¨çœ‹å®Œä¹‹åå†ä½¿ç”¨ï¼Œè¿™ç§æƒ…å†µä¸‹æ€ä¹ˆé¿å…çº¿ä¸Šçš„æ•…éšœå‘¢?</p>

<p>å‹æµ‹å°½é‡æ—©åšå‘—ã€‚</p>

<p>metrics ä¸ŠæŠ¥å’Œ log é”</p>

<p>è¿™ä¸¤ä¸ªæœ¬è´¨éƒ½æ˜¯ä¸€æ ·çš„é—®é¢˜ï¼Œå°±æ”¾åœ¨ä¸€èµ·äº†ã€‚</p>

<p>å…¬å¸ä¹‹å‰ metrics ä¸ŠæŠ¥ client éƒ½æ˜¯åŸºäº udp çš„ï¼Œå¤§å¤šæ•°åšçš„ç®€å•ç²—æš´ï¼Œå°±æ˜¯ä¸€ä¸ª clientï¼Œç”¨æˆ·ä¼ ä»€ä¹ˆå°±å†™ä»€ä¹ˆï¼Œæœ€ç»ˆä¸€å®šä¼šèµ°åˆ°ï¼š</p>

<p>func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error) {     â€”â€”â€”- åˆ¨å»æ— ç”¨ç»†èŠ‚     n, err := c.writeTo(b, addr)     â€”â€”â€”- åˆ¨å»æ— ç”¨ç»†èŠ‚     return n, err } å¤åˆ¶ä»£ç 
æˆ–è€…æ˜¯ï¼š</p>

<p>func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error) {      â€”â€”â€”- åˆ¨å»æ— ç”¨ç»†èŠ‚     n, err := c.writeTo(b, a)     â€”â€”â€”- åˆ¨å»æ— ç”¨ç»†èŠ‚     return n, err } å¤åˆ¶ä»£ç 
è°ƒç”¨çš„æ˜¯ï¼š</p>

<p>func (c *UDPConn) writeTo(b []byte, addr *UDPAddr) (int, error) {     â€”â€”â€”- åˆ¨å»æ— ç”¨ç»†èŠ‚     return c.fd.writeTo(b, sa) } å¤åˆ¶ä»£ç 
ç„¶åï¼š</p>

<p>func (fd *netFD) writeTo(p []byte, sa syscall.Sockaddr) (n int, err error) {     n, err = fd.pfd.WriteTo(p, sa)     runtime.KeepAlive(fd)     return n, wrapSyscallError(â€œsendtoâ€, err) } å¤åˆ¶ä»£ç 
ç„¶åæ˜¯ï¼š</p>

<p>func (fd *FD) WriteTo(p []byte, sa syscall.Sockaddr) (int, error) {     if err := fd.writeLock(); err != nil {  =========&gt; é‡ç‚¹åœ¨è¿™é‡Œ         return 0, err     }     defer fd.writeUnlock()      for {         err := syscall.Sendto(fd.Sysfd, p, 0, sa)         if err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() {             if err = fd.pd.waitWrite(fd.isFile); err == nil {                 continue             }         }         if err != nil {             return 0, err         }         return len(p), nil     } } å¤åˆ¶ä»£ç 
æœ¬è´¨ä¸Šï¼Œå°±æ˜¯åœ¨é«˜æˆæœ¬çš„ç½‘ç»œæ“ä½œä¸Šå¥—äº†ä¸€æŠŠå¤§çš„å†™é”ï¼ŒåŒæ ·åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹ä¼šå¯¼è‡´å¤§é‡çš„é”å†²çªï¼Œè¿›è€Œå¯¼è‡´å¤§é‡çš„ Goroutine å †ç§¯å’Œæ¥å£å»¶è¿Ÿã€‚</p>

<p>åŒæ ·çš„ï¼ŒçŸ¥é“äº†é—®é¢˜ï¼Œè§£å†³åŠæ³•ä¹Ÿå¾ˆç®€å•ã€‚å†çœ‹çœ‹æ—¥å¿—ç›¸å…³çš„ã€‚å› ä¸ºå…¬å¸ç›®å‰å¤§éƒ¨åˆ†æ—¥å¿—éƒ½æ˜¯ç›´æ¥å‘æ–‡ä»¶ç³»ç»Ÿå†™ï¼Œæœ¬è´¨ä¸ŠåŒä¸€ä¸ªæ—¶åˆ»æ“ä½œçš„æ˜¯åŒä¸€ä¸ªæ–‡ä»¶ï¼Œæœ€ç»ˆéƒ½ä¼šèµ°åˆ°ï¼š</p>

<p>func (f *File) Write(b []byte) (n int, err error) {     n, e := f.write(b)     return n, err }  func (f *File) write(b []byte) (n int, err error) {     n, err = f.pfd.Write(b)     runtime.KeepAlive(f)     return n, err } å¤åˆ¶ä»£ç 
ç„¶åï¼š</p>

<p>func (fd *FD) Write(p []byte) (int, error) {     if err := fd.writeLock(); err != nil { =========&gt; åˆæ˜¯ writeLock         return 0, err     }     defer fd.writeUnlock()     if err := fd.pd.prepareWrite(fd.isFile); err != nil {         return 0, err     }     var nn int     for {         â€”â€“ ç•¥å»ä¸ç›¸å…³å†…å®¹         n, err := syscall.Write(fd.Sysfd, p[nn:max])         â€”â€“ ç•¥å»æ— ç”¨å†…å®¹     } } å¤åˆ¶ä»£ç 
å’Œ UDP ç½‘ç»œ FD ä¸€æ ·æœ‰ writeLockï¼Œåœ¨ç³»ç»Ÿæ‰“æ—¥å¿—æ‰“å¾—å¾ˆå¤šçš„æƒ…å†µä¸‹ï¼Œè¿™ä¸ª writeLock ä¼šå¯¼è‡´å’Œ metrics ä¸ŠæŠ¥ä¸€æ ·çš„é—®é¢˜ã€‚</p>

<p>æ€»ç»“</p>

<p>ä¸Šé¢è¯´çš„å‡ ä¸ªé—®é¢˜å®é™…ä¸Šæœ¬è´¨éƒ½æ˜¯å¹¶å‘åœºæ™¯ä¸‹çš„ lock contention é—®é¢˜ï¼Œå…¨å±€å†™é”æ˜¯é«˜å¹¶å‘åœºæ™¯ä¸‹çš„æ€§èƒ½æ€æ‰‹ï¼Œä¸€æ—¦å¤§é‡çš„ Goroutine é˜»å¡åœ¨å†™é”ä¸Šï¼Œä¼šå¯¼è‡´ç³»ç»Ÿçš„å»¶è¿Ÿé£šå‡ï¼Œç›´è‡³æ¥å£è¶…æ—¶ã€‚åœ¨å¼€å‘ç³»ç»Ÿæ—¶ï¼Œæ¶‰åŠåˆ° sync.Poolã€å•ä¸ª FD çš„ä¿¡æ¯ä¸ŠæŠ¥ã€ä»¥åŠå†™æ—¥å¿—çš„åœºæ™¯æ—¶ï¼Œåº”è¯¥å¤šåŠ æ³¨æ„ã€‚æ—©åšå‹æµ‹ä¿å¹³å®‰</p>
:ET