I"<p>https://gocn.vip/topics/10078
在上文中，我们介绍了，从虚拟内存的角度，程序内存大致可以分为 5 个段text、data、bss、stack、heap
其中text段用于程序指令、文字、静态常量
data与bss段用于存储全局变量
stack段用于存储函数调用与函数内的变量，stack段的数据可以被 CPU 快速访问，stack段的大小在运行时是不能增加和减少的，销毁只是通过栈指针的移动来实现的。同时，这也是为什么程序有时候会报错 stack overflow 的原因。
stack段的内存分配是编译器实现的，我们无需关心。同时 stack 通常的大小是有限的。
因此对于大内存的分配，或者想手动创建或释放内存，就只能够对heap段进行操作，这就是俗称的动态分配内存。例如 c 语言中的malloc、calloc、free以及 C++ 中的new、delete
内存的分配属于操作系统级别的操作、因此不管是 cc++ 语言的分配，最后都需要调用操作系统的接口。以 linux 为例，malloc 代码可能调用了操作系统接口mmap分配内存
linux 操作系统提供的内存分配接口如下：
mmap/munmap 映射/释放 指定大小的内存.
brk/sbrk – 改变data段`结束的位置来扩展 heap 段的内存
madvise – 给操作系统建议如何管理内存
set_thread_area/get_thread_area – 操作线程本地存储空间
动态内存分配是操作系统为我们做的事情，其效率直接影响到运行在操作系统上的程序。对于一般的程序来说，例如 c 语言中实现的malloc,最后都是通过调用操作系统的接口来实现的。
动态内存的调度是一个艰难复杂的话题，其要实现的目标包括：
快速分配和释放
内存开销小
使用所有内存
避免碎片化
内存分配的算法包括了：
K&amp;R malloc
Region-based allocator
Buddy allocator
dlmalloc
slab allocator
同时，由于算法解决的目标等不同，还会有不同的变种，其他的目标包括：
内存开销小（例如 buddy 的元数据很大）
良好的内存位置
cpu 核心增加时，扩展性好
并发 malloc / free
GO 语言在进行动态内存分配时，实质调用了上面的操作系统接口。由于 Go 语言并没有调用 c 语言的malloc等函数来分配，组织内存，因此，其必须实现自己的内存组织和调度方式。
GO 语言借鉴了 TCMalloc(Thread-Caching Malloc) 的内存分配方式
<!-- more -->
TCMalloc(Thread-Caching Malloc)
TCMalloc 是一种内存分配算法，比 GNU C 库中的 malloc 要快 2 倍，正如其名字一样，其是对于每一个线程构建了缓存内存。
TCMalloc 解决了多线程时内存分配的锁竞争问题
TCMalloc 对于小对象的分配非常高效
TCMalloc 的核心思想是将内存划分为多个级别，以减少锁的粒度。在 TCMalloc 内部，内存管理分为两部分：小对象内存（thread memory）和大对象内存（page heap）。
小对象内存管理将内存页分成多个固定大小的可分配的 free 列表。因此，每个线程都会有一个无锁的小对象缓存，这使得在并行程序下分配小对象（&lt;= 32k）非常有效。下图的对象代表的是字节。</p>
:ET