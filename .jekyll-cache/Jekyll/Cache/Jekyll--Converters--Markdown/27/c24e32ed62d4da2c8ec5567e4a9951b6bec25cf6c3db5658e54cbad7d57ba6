I"œ<p>gqlgen æ˜¯ä¸€ä¸ªä½¿ç”¨ Go è¯­è¨€å®ç°çš„ç”¨äºå¿«é€Ÿåˆ›å»ºä¸¥æ ¼ç±»å‹çš„ graphql æœåŠ¡å™¨çš„åº“ã€‚
https://github.com/99designs/gqlgen
https://github.com/rongfengliang/gqlgen-demo
https://tutorialedge.net/golang/go-graphql-beginners-tutorial/
https://tutorialedge.net/golang/go-graphql-beginners-tutorial-part-2/
https://blog.csdn.net/liuyh73/article/details/85028977
https://blog.csdn.net/liuyh73/article/details/85010148
https://github.com/graph-gophers/graphql-go
https://github.com/vektah/gqlparser</p>

<p>https://github.com/Go-GraphQL-Group/GraphQL-Service
<!-- more -->
https://studygolang.com/articles/13825
https://www.ctolib.com/amp/99designs-gqlgen.html
https://github.com/Go-GraphQL-Group/SW-Crawler/tree/master/data
https://github.com/boltdb/bolt
https://graphql.org/learn/schema/</p>

<p>GraphQLä»‹ç»
All of the data you need, in one request</p>

<p>GraphQL is an open spec for a flexible API layer.</p>

<p>Ask exactly what you want.</p>

<p>GraphQLæ˜¯ä¸€ä¸ªç”¨äºAPIçš„æŸ¥è¯¢è¯­è¨€ã€‚GraphQLå¹¶æ²¡æœ‰å’Œç‰¹å®šæ•°æ®åº“æˆ–è€…å­˜å‚¨å¼•æ“ç»‘å®šï¼Œè€Œæ˜¯ä¾é ç°æœ‰çš„ä»£ç å’Œæ•°æ®æ”¯æ’‘ã€‚å’ŒRESTfulä¸åŒçš„æ˜¯ï¼ŒGraphQLä¼šåœ¨ä¸€ä¸ªè¯·æ±‚ä¸­è·å–æ‰€æœ‰æƒ³è¦çš„æ•°æ®ï¼Œæ¯”å¦‚æˆ‘ä»¬æƒ³è¦ä»æœåŠ¡å™¨è·å–id=1çš„ä¹¦ç±nameä¿¡æ¯å’Œid=2çš„æ–‡ç« çš„titleä¿¡æ¯ï¼Œåˆ™å¯¹äºGraphQLè¯·æ±‚ï¼Œæˆ‘ä»¬åªéœ€æŒ‰ç…§ä¸‹æ–¹è¯­æ³•æ¥å‘é€è¯·æ±‚å³å¯è·å¾—æƒ³è¦çš„ä¿¡æ¯ã€‚</p>

<p>query{
  book(id:â€1â€) {
    name
  },
  article(id:â€2â€) {
  	title
  }
}
1
2
3
4
5
6
7
8
ä½†æ˜¯ï¼Œå¯¹äºRESTful APIï¼Œæˆ‘ä»¬å°±ä¸å¾—ä¸æŒ‰ç…§ç±»ä¼¼äºhost:port/api/book/1/å’Œhost:port/api/article/2/çš„urlæ¥å‘æœåŠ¡å™¨å‘é€ä¸¤æ¬¡è¯·æ±‚ï¼Œç„¶åå¯¹è¿”å›çš„æ•°æ®è¿›è¡Œç­›é€‰å¾—åˆ°nameå’Œtitleå­—æ®µã€‚è¿™åªæ˜¯GraphQLå’ŒRESTfulçš„å…¶ä¸­ä¸€ä¸ªåŒºåˆ«ï¼Œæœ‰å…³ä¸¤è€…çš„æ¯”è¾ƒï¼Œè¯¦è§ä¼ é€é—¨ã€‚</p>

<p>GraphQLç›¸å…³æ–‡æ³•
åŸºäºGraphQLçš„æœåŠ¡æ„å»ºä¸»è¦æœ‰å››ä¸ªéƒ¨åˆ†ï¼šæ•°æ®å®šä¹‰ï¼ˆschemaï¼‰ã€æŸ¥è¯¢ï¼ˆqueryï¼‰ã€æ›´æ”¹ï¼ˆMutationï¼‰ã€æ•°æ®è§£æï¼ˆResolverï¼‰</p>

<p>æ•°æ®å®šä¹‰
Schema
gqlgen is a schema-first library â€” before writing code, you describe your API using the GraphQL Schema Definition Language. This usually goes into a file called schema.graphqlã€‚</p>

<p>é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰Schemaï¼ˆæ¨¡å‹ï¼‰ï¼Œåœ¨æ­¤æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬éœ€è¦å®šè¦å®šä¹‰å„ç§æ•°æ®ç±»å‹ã€‚Schema æ˜ç¡®äº†æœåŠ¡ç«¯æœ‰å“ªäº›å­—æ®µï¼ˆç”¨æˆ·è‡ªå®šä¹‰ç±»å‹ï¼‰å¯ä»¥ç”¨ï¼Œæ¯ä¸ªå­—æ®µçš„ç±»å‹å’Œå­å­—æ®µã€‚æ¯æ¬¡æŸ¥è¯¢æ—¶ï¼ŒæœåŠ¡å™¨å°±ä¼šæ ¹æ® Schema éªŒè¯å¹¶æ‰§è¡ŒæŸ¥è¯¢ã€‚</p>

<p>åœ¨Schemaæ–‡ä»¶ä¸­ï¼Œæœ‰4ä¸ªæ¯”è¾ƒç‰¹æ®Šçš„å…³é”®å­—ï¼š</p>

<p>schemaï¼Œæ ‡è¯†è¿™æ˜¯ä¸€ä¸ªGraphQL Schemaå®šä¹‰ï¼Œå…¶ä¸­åŒ…å«äº†ç”¨æˆ·å¯ä»¥è¿›è¡Œçš„ä¸‰ç§æ“ä½œï¼ˆå¯ä»¥çœç•¥ï¼‰
queryï¼Œå®šä¹‰æŸ¥è¯¢æ“ä½œï¼Œå¿…é¡»æœ‰
mutationï¼Œå®šä¹‰å˜æ›´æ“ä½œï¼Œå¯ä»¥çœç•¥
subscriptionï¼Œå®šä¹‰è®¢é˜…æ“ä½œï¼Œå¯ä»¥çœç•¥
schema {<br />
 query: Query
 mutation: Mutation
 subscription: Subscription
}
1
2
3
4
5
Type
Typeå…³é”®å­—æ˜¯ç”¨æ¥å®šä¹‰æŠ½è±¡æ•°æ®ç±»å‹ï¼Œç±»ä¼¼äºgolangä¸­çš„Typeä½†æ˜¯å¹¶ä¸ç›¸åŒã€‚åœ¨æ¯ä¸€ä¸ªè‡ªå®šä¹‰æ•°æ®ç±»å‹ä¸­ï¼Œå¯ä»¥æœ‰å¤šä¸ªFieldï¼ˆå­—æ®µï¼‰ï¼Œæ¯ä¸ªFieldå¯ä»¥å†æ¬¡æŒ‡å‘æŸä¸ªTypeã€‚</p>

<p>æ ‡é‡Scalar
Scalaræ˜¯è§£æåˆ°å•ä¸ªæ ‡é‡å¯¹è±¡çš„ç±»å‹ï¼Œæ— æ³•å†è¿›è¡Œæ¬¡çº§é€‰æ‹©ï¼ˆæ¬¡çº§é€‰æ‹©çš„å«ä¹‰åœ¨é˜…è¯»GraphQLæŸ¥è¯¢è¯­æ³•ä¹‹åä¼šæœ‰æ‰€äº†è§£ï¼‰ã€‚GraphQLä¸­åŒ…å«çš„æ ‡é‡æœ‰Stringï¼ŒIntï¼ŒFloatï¼ŒBooleanï¼ŒEnumï¼ŒIDã€‚</p>

<p>The ID scalar type represents a unique identifier, often used to refetch an object or as key for a cache.</p>

<h1 id="å®šä¹‰æ€§åˆ«æ ‡é‡">å®šä¹‰æ€§åˆ«æ ‡é‡</h1>
<p>enum Gender {
    MALE
    FEMALE
}
1
2
3
4
5
å¯¹è±¡Object
ä¸æˆ‘ä»¬åœ¨å…¶ä»–è¯­è¨€ä¸­å®šä¹‰å¯¹è±¡ç±»ä¼¼ï¼šä¸‹æ–¹Personè¿™ä¸ªè‡ªå®šä¹‰æ•°æ®ç±»å‹ä¸­åŒ…æ‹¬äº†idã€nameç­‰å­—æ®µã€‚</p>

<p>type People {
    name: String
    birth_year: String
    gender: String
}
1
2
3
4
5
ä¸Šè¿°Peopleç±»å‹ä¸­åªæœ‰æ ‡é‡å­—æ®µï¼Œæˆ‘ä»¬åŒæ ·å¯ä»¥ä½¿ç”¨è‡ªå®šä¹‰æ•°æ®ç±»å‹å­—æ®µï¼Œä¾‹å¦‚ï¼Œæˆ‘ä»¬å®šä¹‰äº†Filmæ•°æ®ç±»å‹ï¼Œæ¯ä¸€éƒ¨Filméƒ½æœ‰ä¸€ä¸ªdirectorå­—æ®µï¼š</p>

<p>type Film {
	name: string
	director: People
	â€¦
}
1
2
3
4
5
æ¥å£Interface
æ¥å£æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»å‹ï¼Œç›¸ä¿¡å­¦ä¹ è¿‡goå’Œjavaçš„è¯»è€…éƒ½ä¸é™Œç”Ÿï¼Œä¸‹é¢ç›´æ¥çœ‹å®šä¹‰ï¼š</p>

<p>type Human {	# å®ç°Humançš„Typeå¿…é¡»æœ‰è¿™ä¸¤ä¸ªå­—æ®µ
	age: Int
    name: String
}
type Programmer implements Human {
	age: Int			
    name: String		
    Hair: Int
    field: String
}
type Student implements Human {
	age: Int
    name: String
    id:	ID
    major: String
}</p>

<p>åˆ—è¡¨å’Œéç©º
å¯¹äºä¸Šé¢Peopleç±»å‹ä¸­çš„nameå­—æ®µï¼Œå‡å¦‚æˆ‘ä»¬æƒ³è¦è®©å…¶ä¸ä¸ºç©ºï¼Œåˆ™å¯ä»¥åœ¨æ•°æ®ç±»å‹åé¢æ·»åŠ æ„Ÿå¹å·!ï¼Œå¦‚æœæˆ‘ä»¬è¦æ–°å¢å­—æ®µå‚æ¼”ç”µå½±çš„åˆ—è¡¨filmsï¼Œåˆ™å¯ä»¥ä½¿ç”¨[]ã€‚</p>

<p>type People {
	name: String!
    birth_year: String
    gender: String
	films: [Film]
}</p>

<p>åŒæ ·ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹åˆ—è¡¨è¿›è¡Œéç©ºé™åˆ¶ï¼š</p>

<p>myField: [String!]</p>

<h1 id="è¡¨ç¤ºæ•°ç»„æœ¬èº«å¯ä»¥ä¸ºç©ºä½†æ˜¯å…¶ä¸èƒ½æœ‰ä»»ä½•æ§åˆ¶æˆå‘˜">è¡¨ç¤ºæ•°ç»„æœ¬èº«å¯ä»¥ä¸ºç©ºï¼Œä½†æ˜¯å…¶ä¸èƒ½æœ‰ä»»ä½•æ§åˆ¶æˆå‘˜</h1>
<p>myField: null # æœ‰æ•ˆ
myField: [] # æœ‰æ•ˆ
myField: [â€˜aâ€™, â€˜bâ€™] # æœ‰æ•ˆ
myField: [â€˜aâ€™, null, â€˜bâ€™] # é”™è¯¯</p>

<p>myField: [String]!</p>
<h1 id="è¿™è¡¨ç¤ºæ•°ç»„æœ¬èº«ä¸èƒ½ä¸ºç©ºä½†æ˜¯å…¶å¯ä»¥åŒ…å«ç©ºå€¼æˆå‘˜">è¿™è¡¨ç¤ºæ•°ç»„æœ¬èº«ä¸èƒ½ä¸ºç©ºï¼Œä½†æ˜¯å…¶å¯ä»¥åŒ…å«ç©ºå€¼æˆå‘˜ï¼š</h1>
<p>myField: null // é”™è¯¯
myField: [] // æœ‰æ•ˆ
myField: [â€˜aâ€™, â€˜bâ€™] // æœ‰æ•ˆ
myField: [â€˜aâ€™, null, â€˜bâ€™] // æœ‰æ•ˆ</p>

<p>è”åˆç±»å‹
è”åˆç±»å‹å’Œæ¥å£ååˆ†ç›¸ä¼¼ï¼Œä½†æ˜¯å®ƒå¹¶ä¸æŒ‡å®šç±»å‹ä¹‹é—´çš„ä»»ä½•å…±åŒå­—æ®µã€‚</p>

<p>union SearchResult = Person | Film
1
ä»»ä½•è¿”å›ä¸€ä¸ª SearchResult ç±»å‹çš„åœ°æ–¹ï¼Œéƒ½å¯èƒ½å¾—åˆ°ä¸€ä¸ª Person æˆ–è€… Filmã€‚æ³¨æ„ï¼Œè”åˆç±»å‹çš„æˆå‘˜éœ€è¦æ˜¯å…·ä½“å¯¹è±¡ç±»å‹ï¼›ä¸èƒ½ä½¿ç”¨æ¥å£æˆ–è€…å…¶ä»–è”åˆç±»å‹æ¥åˆ›é€ ä¸€ä¸ªè”åˆç±»å‹ã€‚</p>

<p>è¾“å…¥ç±»å‹Input
è¾“å…¥å¸¸å¸¸ç”¨äºå˜æ›´ï¼ˆmutationï¼‰ä¸­ï¼Œç±»ä¼¼äºpostè¯·æ±‚æ¥æ–°å»ºå¯¹è±¡ã€‚</p>

<p>input PersonInput {
	name: String
    birth_year: String
    gender: String
    films: [Film]
}
1
2
3
4
5
6
æ•°æ®æ“ä½œ
æŸ¥è¯¢ï¼ˆQueryï¼‰
å®šä¹‰æŸ¥è¯¢
åœ¨schemaä¸­ï¼Œå®šä¹‰æŸ¥è¯¢æ–¹æ³•å¦‚ä¸‹ï¼š</p>

<h1 id="å®šä¹‰peopleæŸ¥è¯¢æ–¹æ³•å‚æ•°ä¸ºå¿…å¡«å­—æ®µidè¿”å›æ•°æ®ç±»å‹ä¸ºpeople">å®šä¹‰peopleæŸ¥è¯¢æ–¹æ³•ï¼Œå‚æ•°ä¸ºå¿…å¡«å­—æ®µidï¼Œè¿”å›æ•°æ®ç±»å‹ä¸ºPeople</h1>
<p>type Query {
    people(id: ID!): People
}
1
2
3
4
ä¸‹é¢ä»‹ç»ä¸€ä¸‹å¦‚ä½•æŸ¥è¯¢ï¼š</p>

<p>å‚æ•°æŸ¥è¯¢
åœ¨ä¸‹å±æŸ¥è¯¢æ–¹æ³•ä¸­ï¼Œpeople()ä¸ºå®šä¹‰çš„æŸ¥è¯¢æ–¹æ³•</p>

<p>ä¸ºæŸ¥è¯¢èµ·åˆ«åï¼ˆAliasesï¼‰
å¦‚æœæˆ‘ä»¬å…ˆè¦å†ä¸€æ¬¡è¯·æ±‚ä¸­æŸ¥è¯¢ä¸¤ä¸ªpeopleï¼Œåˆ™ä¼šå‡ºç°ä¸‹æ–¹çš„é”™è¯¯ï¼š</p>

<p>å¯¹äºä¸Šè¿°æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨åˆ«åçš„æ–¹å¼æ¥è¿›è¡ŒæŸ¥è¯¢ï¼š</p>

<p>ä½¿ç”¨ç‰‡æ®µï¼ˆFragmentï¼‰
åœ¨ä¸Šé¢çš„people5å’Œpeople1çš„æŸ¥è¯¢ä¸­ï¼Œæˆ‘ä»¬å‘ç°ï¼Œä¸¤è€…éƒ½æŸ¥è¯¢äº†nameï¼Œæ­¤æ—¶åªæœ‰ä¸€ä¸ªå­—æ®µè¿˜å¥½ï¼Œå¦‚æœç›¸åŒå­—æ®µè¿‡å¤šæ—¶ï¼Œé‚£åº”è¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿè¿™ç§æƒ…å†µä¸‹æˆ‘ä»¬ä¾¿å¯ä»¥ä½¿ç”¨fragmentï¼š</p>

<p>ç‰‡æ®µçš„æ¦‚å¿µç»å¸¸ç”¨äºå°†å¤æ‚çš„åº”ç”¨æ•°æ®éœ€æ±‚åˆ†å‰²æˆå°å—ï¼Œç‰¹åˆ«æ˜¯ä½ è¦å°†å¤§é‡ä¸åŒç‰‡æ®µçš„ UI ç»„ä»¶ç»„åˆæˆä¸€ä¸ªåˆå§‹æ•°æ®è·å–çš„æ—¶å€™ã€‚</p>

<p>å®šä¹‰æ“ä½œåç§°
ä¸Šè¿°æ‰€æœ‰æŸ¥è¯¢ï¼Œæˆ‘ä»¬éƒ½ä½¿ç”¨äº†queryå…³é”®å­—ä½œä¸ºæŸ¥è¯¢æ ‡è¯†ï¼Œè™½ç„¶å¯ä»¥çœç•¥ï¼Œä½†ä¾ç„¶æ¨èè¿™ä¹ˆåŠ ä¸Šã€‚å®é™…ä¸Šï¼Œæˆ‘ä»¬è¿˜å¯ä»¥ä¸ºæˆ‘ä»¬çš„æŸ¥è¯¢å®šä¹‰åç§°ï¼Œè¿™å¯¹æˆ‘ä»¬åœ¨å¼€å‘è¿‡ç¨‹ä¸­å¯»æ‰¾å¯èƒ½å­˜åœ¨çš„æ¼æ´æä¾›å¸®åŠ©ã€‚ä¾‹å¦‚ï¼šå®šä¹‰ä¸€ä¸ªåç§°ä¸ºfilmQueryçš„æŸ¥è¯¢æ“ä½œ</p>

<p>query filmQuery{
  film(id:â€1â€){
    title
  }
}
1
2
3
4
5
åç»­å°†è¦è®²è¿°çš„mutationæ“ä½œä¹Ÿå¯ä»¥å®šä¹‰åç§°ã€‚</p>

<p>ä½¿ç”¨å˜é‡ï¼ˆVariableï¼‰
ä½¿ç”¨å˜é‡çš„æ­¥éª¤ï¼š</p>

<p>ä½¿ç”¨ $variableName æ›¿ä»£æŸ¥è¯¢ä¸­çš„é™æ€å€¼ã€‚
å£°æ˜ $variableName ä¸ºæŸ¥è¯¢æ¥å—çš„å˜é‡ä¹‹ä¸€ã€‚
å°† variableName: value é€šè¿‡ä¼ è¾“ä¸“ç”¨ï¼ˆé€šå¸¸æ˜¯ JSONï¼‰çš„åˆ†ç¦»çš„å˜é‡å­—å…¸ä¸­ã€‚</p>

<p>ä½¿ç”¨å˜é‡å¯ä»¥å¾ˆæ–¹ä¾¿çš„åœ¨å®¢æˆ·ç«¯æ„é€ æŸ¥è¯¢è¯­æ³•ï¼Œå®¢æˆ·ç«¯å¯ä»¥æ„é€ ä¸€ä¸ªå¤é€‰æ¡†ï¼Œä¸‹æ‹‰èœå•ç­‰æ–¹å¼æ¥è·å–åŠ¨æ€å‚æ•°ï¼Œç„¶åå°†åŠ¨æ€å‚æ•°æå–åˆ°æŸ¥è¯¢ä¹‹å¤–ï¼Œä½œä¸ºåˆ†ç¦»çš„å­—å…¸ä¼ è¿›å»ã€‚è€Œä¸ç”¨æ„å»ºä¸€ä¸ªå…¨æ–°çš„æŸ¥è¯¢ã€‚ï¼ˆä¸ºäº†å®‰å…¨èµ·è§ï¼Œæˆ‘ä»¬ä¸èƒ½ä½¿ç”¨ç”¨æˆ·æä¾›çš„å€¼æ¥è¿›è¡Œå­—ç¬¦ä¸²æ’å€¼æ„å»ºæŸ¥è¯¢ï¼‰</p>

<p>æˆ‘ä»¬ä¹Ÿå¯ä»¥ä½¿ç”¨é»˜è®¤å˜é‡ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š</p>

<p>query peopleQuery($id: ID = â€œ5â€){
    â€¦
}
1
2
3
å˜æ›´ï¼ˆMutationï¼‰
ä¸Šè¿°ä»‹ç»çš„å…¨éƒ¨éƒ½æ˜¯æŸ¥è¯¢æ“ä½œï¼ŒGraphQLä¹Ÿä¸ºæˆ‘ä»¬æä¾›äº†mutationå˜æ›´æ“ä½œï¼Œç”¨äºä¿®æ”¹æ•°æ®ã€‚</p>

<p>å®šä¹‰å˜æ›´</p>
<h1 id="å‚æ•°ä¸ºepisodeenumä»¥åŠä¸€ä¸ªinputç±»å‹çš„è¾“å…¥æ•°æ®è¿”å›ç±»å‹ä¸ºreview">å‚æ•°ä¸ºEpisodeï¼ˆEnumï¼‰ä»¥åŠä¸€ä¸ªInputç±»å‹çš„è¾“å…¥æ•°æ®ï¼Œè¿”å›ç±»å‹ä¸ºReview</h1>
<p>type Mutation {
    createReview(episode: Episode!, review: ReviewInput!): Review
}
1
2
3
4
æ›´æ–°æ•°æ®
å˜æ›´å’ŒæŸ¥è¯¢ä¸€æ ·éƒ½å¯ä»¥ä½¿ç”¨å˜é‡ä»¥åŠç‰‡æ®µç­‰ï¼š</p>

<p>æŸ¥è¯¢å­—æ®µæ—¶ï¼Œæ˜¯å¹¶è¡Œæ‰§è¡Œï¼Œè€Œå˜æ›´å­—æ®µæ—¶ï¼Œæ˜¯çº¿æ€§æ‰§è¡Œï¼Œä¸€ä¸ªæ¥ç€ä¸€ä¸ªã€‚</p>

<p>è®¢é˜…ï¼ˆSubscriptionï¼‰
è®¢é˜…ç”¨äºreal-timeå®æ—¶è¯·æ±‚ã€‚å…·ä½“ç”¨æ³•å¯ä»¥è‡ªè¡Œè°·æ­Œã€‚</p>

<p>æ•°æ®è§£æResolver
å½“ç”¨æˆ·è¯·æ±‚å‘é€åˆ°æœåŠ¡å™¨æ—¶ï¼ŒæœåŠ¡å™¨å¦‚ä½•è¿›è¡Œç›¸åº”å¹¶è¿”å›æ‰€éœ€æ•°æ®å‘¢ï¼Ÿä¸‹é¢ä»‹ç»ä¸€ä¸‹GraphQLçš„å“åº”è¿‡ç¨‹ï¼Œä»¥queryæŸ¥è¯¢ä¸ºä¾‹ï¼š</p>

<p>é¦–å…ˆï¼ŒGraphQLè§£ææ“ä½œç±»å‹å¾—çŸ¥ä¸ºqueryï¼ŒæŸ¥è¯¢æ–¹æ³•ä¸ºpeopleã€‚
ä¹‹åï¼Œä¼šå°è¯•è°ƒç”¨peopleè§£æï¼ˆResolverï¼‰å‡½æ•°ï¼Œåœ¨æ­¤è§£æå‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä¼šè°ƒç”¨å…¶ä»–å‡½æ•°ï¼ˆæ­¤å‡½æ•°é€šå¸¸éœ€è¦è‡ªå·±æ‰‹åŠ¨å®ç°ï¼‰ä»æ•°æ®åº“æŸ¥è¯¢idä¸º35çš„peopleå¯¹è±¡å¹¶è¿”å›ï¼Œç¬¬ä¸€å±‚è§£æç»“æŸã€‚
ä¹‹åå¯¹ç¬¬ä¸€å±‚è§£æçš„è¿”å›å€¼ï¼Œè¿›è¡Œç¬¬äºŒå±‚è§£æã€‚å½“å‰æŸ¥è¯¢å­—æ®µä¸ºnameï¼Œå’Œfilmsï¼Œ
titleä¸ºStringæ ‡é‡ç±»å‹æ•°æ®ï¼Œåˆ™ä¸å¿…å†æ·±å…¥è§£æ
filmsä¸ºFilmåˆ—è¡¨ç±»å‹ï¼Œè°ƒç”¨Filmè§£æï¼ˆResolverï¼‰å‡½æ•°ã€‚æŸ¥è¯¢å­—æ®µä¸ºtitleï¼Œç”±äºæ˜¯æ ‡é‡ç±»å‹ï¼Œåˆ™ä¸å¿…å†æ·±å…¥è§£æã€‚
â€¦â€¦
æœ€åå°†è§£æç»“æœæ•´åˆä¹‹åè¿”å›ç»™å®¢æˆ·ç«¯å³å¯ã€‚
ä¸Šè¿°è¿‡ç¨‹ä¸­å¤§éƒ¨åˆ†å‡½æ•°å…¶å®å¹¶ä¸éœ€è¦æ‰‹åŠ¨å®ç°ï¼Œè¿™äº›æ“ä½œå¯¹äºæˆ‘ä»¬æ¥è¯´ç›¸å½“äºé»‘ç›’çŠ¶æ€ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥ä¼šä»‹ç»å‡ ä¸ªå¸¸ç”¨çš„GraphQLç”Ÿæˆå·¥å…·ã€‚</p>

<p>å…³äºGraphQLçš„ç›¸å…³å†…å®¹å°±ä»‹ç»åˆ°è¿™é‡Œï¼Œå¦‚æœæƒ³æœ‰è¿›ä¸€æ­¥çš„äº†è§£ï¼Œå¯ä»¥å‰å¾€GraphQLå®˜ç½‘è¿›ä¸€æ­¥å­¦ä¹ ã€‚</p>

<p>GraphQLæ„å»ºå·¥å…·
ä»¥goè¯­è¨€ä¸ºä¾‹ï¼Œgraphqlæ„å»ºå·¥å…·æœ‰ï¼š</p>

<p>gqlgen
gophers
graphql-go
thunder
å…¶ä¸­gqlgenæ”¯æŒè¯­æ³•æœ€å¤šï¼Œæˆ‘çš„å¦ä¸€ç¯‡æ–‡ç« ä¸­ä»‹ç»äº†å¦‚ä½•ä½¿ç”¨gqlgenæ„å»ºgraphqlæœåŠ¡ã€‚</p>

<p>æ–‡ç« ç›®å½•
gqlgenå·¥å…·ä»‹ç»
graphqlæœåŠ¡æ‰§è¡Œæµç¨‹
server/server.go
graphql.go
GraphQL
ServeHTTP
generated.go
Query()
_Query()
_Query_people
_People
_People_films
_Film
resolver.go
å±æ€§åˆ†é¡µ
ä¿®æ”¹schema
æ–°å¢model
å°†modelåŠ å…¥åˆ°gqlgen.ymlä¸­
åˆ é™¤resolver.go
é‡æ–°ç”ŸæˆGraphQLéª¨æ¶
å®šä¹‰FilmConnection
æŸ¥è¯¢ç»“æœ
gqlgenå·¥å…·ä»‹ç»
gqlgen is a golang library for building graphql servers without any fuss. gqlgen is:</p>

<p>Schema first: You define your API using the graphql Schema Definition Language
Type safe: You should never see map[string]interface{} here.
Codegen: Let us generate the boring bits, so you can build your app quickly.
gqlgenæ˜¯ä¸€ä¸ªå¼€æºçš„GraphQL APIæœåŠ¡æ„å»ºå·¥å…·ï¼Œå…³äºGraphQLçš„ä»‹ç»å‚åŠ æˆ‘çš„å¦ä¸€ç¯‡æ–‡ç« GraphQLæ ¸å¿ƒæ¦‚å¿µã€‚ä¸‹é¢è¿›è¡Œé¡¹ç›®çš„æ„å»ºï¼Œä»¥æˆ‘çš„ä¸€æ¬¡ä½œä¸šï¼Œä½¿ç”¨GraphQLæ„å»ºæœåŠ¡å¹¶å¤åˆ¶SWAPIç•Œé¢ï¼ˆå°ç»„åˆä½œå¼€å‘ï¼‰ä¸ºä¾‹ï¼Œå®Œæ•´ä»£ç è¯¦è§Githubã€‚ç¬¬ä¸€æ¬¡ä½¿ç”¨GraphQLï¼Œé¡¹ç›®ç»“æ„è¿˜ä¸å¤Ÿå®Œå–„ã€‚</p>

<p>æ–‡ç« æ‰€ç”¨ä»£ç ä¸ºGraphQLdemo</p>

<p>ä¸‹è½½å®‰è£…gqlgenå·¥å…·ï¼š
$ go get github.com/99designs/gqlgen
1
åˆ›å»ºé¡¹ç›®æ–‡ä»¶å¤¹ï¼š
$ mkdir -p $GOPATH/src/github.com/[username]/[project-name]</p>
<h1 id="mkdir--p-gopathsrcgithubcomliuyh73graphqldemo-åç»­ä»‹ç»éƒ½ä»¥graphqldemoä¸ºä¾‹">mkdir -p $GOPATH/src/github.com/liuyh73/GraphQLdemo åç»­ä»‹ç»éƒ½ä»¥GraphQLdemoä¸ºä¾‹</h1>
<p>1
2
åœ¨é¡¹ç›®æ–‡ä»¶å¤¹æ ¹ç›®å½•ä¸‹ï¼Œåˆ›å»ºscripts/gqlgen.goï¼Œä¹¦å†™å†…å®¹å¦‚ä¸‹ï¼š
package main</p>

<p>import â€œgithub.com/99designs/gqlgen/cmdâ€</p>

<p>func main() {
	cmd.Execute()
}
ç”±æ–‡ç« å¼€å¤´ä»‹ç»å¯çŸ¥ï¼Œgqlgenæ˜¯schema-firståº“ï¼Œä½¿ç”¨GraphQLæ¥å®šä¹‰æˆ‘ä»¬çš„APIï¼Œæ‰€ä»¥ç°åœ¨åˆ›å»ºschemaï¼Œæ–‡ä»¶é€šå¸¸å‘½åä¸ºschema.graphqlï¼Œæ”¾åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹å³å¯ã€‚æ­¤éƒ¨åˆ†æ˜¯ç”±æˆ‘çš„å¦å¤–ä¸€ä½åŒå­¦å®Œæˆï¼Œå…·ä½“ä»‹ç»è¯¦è§APIDOCï¼Œä¸‹é¢å±•ç¤ºéƒ¨åˆ†ä»£ç ï¼š
type Query {
    people(id: ID!): People								# æŒ‡å®šidæŸ¥è¯¢people
    peoples (first: Int, after: ID): PeopleConnection!	# ç”¨æˆ·åˆ†é¡µæŸ¥è¯¢(åŠ såªæ˜¯ä¸ºäº†åŒºåˆ†)
}</p>

<p>type People {
    id: ID!
    name: String!
    birth_year: String
    eye_color: String
    gender: String
    hair_color: String
    height: String
    mass: String
    skin_color: String
    films: [Film]
}</p>

<p>type PeopleConnection {
    pageInfo: PageInfo!
    edges: [PeopleEdge!]
    totalCount: Int!
}</p>

<p>type PeopleEdge {
    node: People
    cursor: ID!
}</p>

<p>type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: ID!
    endCursor: ID!
}</p>

<p>type Film {
    id: ID!
    title: String!
    episode_id: Int
    opening_crawl: String
    director: String
    producer: String
    release_date: String
}</p>

<p>ç„¶åï¼Œå†é¡¹ç›®æ ¹ç›®å½•ä¸‹æ‰§è¡Œå‘½ä»¤ï¼šgo run scripts/gqlgen.go initï¼Œä¼šè‡ªåŠ¨ç”Ÿæˆä»¥ä¸‹æ–‡ä»¶</p>

<p>gqlgen.yml â€” The gqlgen config file, knobs for controlling the generated code.
generated.go â€” The GraphQL execution runtime, the bulk of the generated code.
models_gen.go â€” Generated models required to build the graph. Often you will override these with your own models. Still very useful for input types.
resolver.go â€” This is where your application code lives. generated.go will call into this to get the data the user has requested.
server/server.go â€” This is a minimal entry point that sets up an http.Handler to the generated GraphQL server.
è‡³æ­¤ï¼Œæˆ‘ä»¬çš„graphqlæœåŠ¡æ¶æ„å·²ç»æ„å»ºå®Œæ¯•ï¼Œä½†æ˜¯æˆ‘ä»¬ä¾ç„¶è¿˜æœ‰å¾ˆé•¿çš„è·¯è¦èµ°â€¦</p>

<p>graphqlæœåŠ¡æ‰§è¡Œæµç¨‹
åœ¨ä¸Šè¿°ç”Ÿæˆçš„æ–‡ä»¶ä¸­ï¼Œæˆ‘ä»¬éœ€è¦æ›´æ”¹çš„æ–‡ä»¶ä¸»è¦æ˜¯resolver.goï¼Œåœ¨ä»‹ç»æ­¤æ–‡ä»¶ä¹‹å‰ï¼Œæˆ‘ä»¬éœ€è¦äº†è§£ä»¥ä¸‹gengqlç”Ÿæˆçš„graphqlçš„æœåŠ¡çš„è¿è¡Œè¿‡ç¨‹ï¼š</p>

<p>é¦–å…ˆï¼Œä¿®æ”¹resolver.goæ–‡ä»¶ä¸‹çš„People()å‡½æ•°ï¼š
func (r <em>queryResolver) People(ctx context.Context, id string) (</em>People, error) {
	return &amp;people{}, nil	// æ›¿æ¢panicï¼ˆé¿å…è¿è¡Œè¿‡ç¨‹ä¸­é€€å‡ºï¼Œåˆ©äºæˆ‘ä»¬è§‚å¯Ÿæ‰§è¡Œè¿‡ç¨‹ï¼‰
}
1
2
3
å¯åŠ¨æœåŠ¡
go run server/server.go
1
è®¿é—®127.0.0.1:8080ï¼Œå¹¶è¿›è¡Œä¸€æ¬¡PeopleæŸ¥è¯¢ï¼š</p>

<p>ç”±ä¸Šå›¾å¯çŸ¥ï¼Œæˆ‘ä»¬çš„æŸ¥è¯¢æˆåŠŸå¾—åˆ°è¿”å›ç»“æœï¼Œå„ä¸ªå­—æ®µéƒ½ä¸ºç©ºã€‚ä¸‹é¢æˆ‘ä»¬æ¥è¯¦ç»†ä»‹ç»graphqlå†…éƒ¨æ˜¯å¦‚ä½•è¿›è¡ŒæŸ¥è¯¢çš„ã€‚</p>

<p>server/server.go
å¯ä»¥çœ‹åˆ°å¦‚ä¸‹ä»£ç ï¼š</p>

<p>http.Handle(â€œ/â€, handler.Playground(â€œGraphQL playgroundâ€, â€œ/queryâ€))
http.Handle(â€œ/queryâ€, handler.GraphQL(GraphQLdemo.NewExecutableSchema(GraphQLdemo.Config{Resolvers: &amp;GraphQLdemo.Resolver{}})))
1
2
å…¶ä¸­ç¬¬ä¸€è¡Œä»£ç æ˜¯æ ¹è·¯ç”±æ³¨å†Œï¼Œå³æˆ‘ä»¬è®¿é—®çš„127.0.0.1:8080çš„å¤„ç†å‡½æ•°ï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬ä¸åšå±•å¼€ã€‚</p>

<p>ä¸»è¦å…³æ³¨ç¬¬äºŒè¡Œä»£ç ï¼Œæ³¨å†Œqueryè·¯ç”±å¤„ç†å‡½æ•°ï¼Œä½¿ç”¨çš„æ˜¯gqlgen/handleråŒ…ä¸­çš„GrapgQLæœåŠ¡ï¼›å³é”®ç‚¹å‡»GraphQLè½¬åˆ°æ­¤å‡½æ•°çš„å®šä¹‰ã€‚</p>

<p>åœ¨æ­¤ä¹‹å‰ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆçœ‹ä¸€ä¸‹handler.GraphQL()çš„å‚æ•°ï¼š</p>

<p>GraphQLdemo.NewExecutableSchema(GraphQLdemo.Config{Resolvers: &amp;GraphQLdemo.Resolver{}})ã€‚
1
NewExecutableSchemaã€Configä»¥åŠResolverå®šä¹‰å¦‚ä¸‹ï¼š</p>

<p>// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &amp;executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}</p>

<p>type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}</p>

<p>type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}</p>

<p>type Resolver struct{}</p>

<p>func (r *Resolver) Query() QueryResolver {
	return &amp;queryResolver{r}
}
æ‰€ä»¥NewExecutableSchemaè°ƒç”¨è¿”å›ç»“æœä¸ºåŒ…å«äº†Resolverçš„executableSchemaå¯¹è±¡ã€‚executableSchemaå®ç°äº†ExecutableSchemaæ¥å£æ‰€å®šä¹‰çš„å‡½æ•°ã€‚è¿™äº›å‡½æ•°å°†åœ¨ä¹‹åçš„æŸ¥è¯¢è¿‡ç¨‹ä¸­è°ƒç”¨ï¼Œä¹‹åæˆ‘ä»¬å°†è¿›è¡Œéƒ¨åˆ†ä»‹ç»ã€‚</p>

<p>type ExecutableSchema interface {
	Schema() *ast.Schema</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Complexity(typeName, fieldName string, childComplexity int, args map[string]interface{}) (int, bool)
Query(ctx context.Context, op *ast.OperationDefinition) *Response
Mutation(ctx context.Context, op *ast.OperationDefinition) *Response
Subscription(ctx context.Context, op *ast.OperationDefinition) func() *Response }
</code></pre></div></div>

<p>ä¸‹é¢ä¾¿æ¥ä¾¿æ¥çœ‹ä»¥ä¸‹executableSchemaåˆ°åº•æ˜¯å¦‚ä½•ä½œç”¨çš„ã€‚</p>

<p>graphql.go
GraphQL
ä¸‹æ–¹ä»£ç å³ä¸ºGraphQLå‡½æ•°ï¼Œåœ¨æ­¤å‡½æ•°ä¸­cfgã€cacheæš‚ä¸”ä¸åšè€ƒè™‘ï¼Œæˆ‘ä»¬åªéœ€å…³æ³¨handlerå¯¹è±¡ã€‚</p>

<p>func GraphQL(exec graphql.ExecutableSchema, options â€¦Option) http.HandlerFunc {
	cfg := &amp;Config{
		cacheSize: DefaultCacheSize,
		upgrader: websocket.Upgrader{
			ReadBufferSize:  1024,
			WriteBufferSize: 1024,
		},
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _, option := range options {
	option(cfg)
}

var cache *lru.Cache
if cfg.cacheSize &gt; 0 {
	var err error
	cache, err = lru.New(DefaultCacheSize)
	if err != nil {
		// An error is only returned for non-positive cache size
		// and we already checked for that.
		panic("unexpected error creating cache: " + err.Error())
	}
}
if cfg.tracer == nil {
	cfg.tracer = &amp;graphql.NopTracer{}
}

handler := &amp;graphqlHandler{
	cfg:   cfg,
	cache: cache,
	exec:  exec,
}

return handler.ServeHTTP } handlerä¸ºgraphqlhandlerçš„å®ä¾‹ï¼Œå¹¶ä¸”graphqlhandlerå®ç°äº†ServeHTTPå‡½æ•°ï¼Œè¯¥å‡½æ•°å‚æ•°ä¸º(w http.ResponseWriter, r *http.Request)ï¼Œæ‰€ä»¥æ­¤å‡½æ•°å³ä¸ºhttp.HandlerFuncç±»å‹ï¼Œè¿™ä¹Ÿè§£é‡Šäº†http.Handle("/query", http.HandlerFunc)è·¯ç”±æ³¨å†Œçš„æ­£ç¡®æ€§ã€‚
</code></pre></div></div>

<p>ServeHTTP
åœ¨ServeHTTPå‡½æ•°ä¸­</p>

<p>func (gh *graphqlHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method == http.MethodOptions {
		w.Header().Set(â€œAllowâ€, â€œOPTIONS, GET, POSTâ€)
		w.WriteHeader(http.StatusOK)
		return
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if strings.Contains(r.Header.Get("Upgrade"), "websocket") {
	connectWs(gh.exec, w, r, gh.cfg)
	return
}

// æ­¤éƒ¨åˆ†ä»£ç è§£æè¯·æ±‚æ•°æ®ï¼Œå…¶ä¸­MethodPostå¯ä»¥å°†ä¸Šä¼ çš„æ•°æ®ï¼ˆvariablesï¼‰æ„å»ºä¸ºgraphqlè¯­æ³•
// reqParamså³ä¸ºè§£æåçš„è¯·æ±‚æ•°æ®
// type params struct {
//     Query         string                 `json:"query"`			// Queryè¯­æ³•
//     OperationName string                 `json:"operationName"`	// æ“ä½œåç§°
//     Variables     map[string]interface{} `json:"variables"`		// å˜é‡ï¼ˆæ’å…¥åˆ°è¯­æ³•ä¸­ï¼‰
// }

var reqParams params
switch r.Method {
case http.MethodGet:
	reqParams.Query = r.URL.Query().Get("query")
	reqParams.OperationName = r.URL.Query().Get("operationName")

	if variables := r.URL.Query().Get("variables"); variables != "" {
		if err := jsonDecode(strings.NewReader(variables), &amp;reqParams.Variables); err != nil {
			sendErrorf(w, http.StatusBadRequest, "variables could not be decoded")
			return
		}
	}
case http.MethodPost:
	if err := jsonDecode(r.Body, &amp;reqParams); err != nil {
		sendErrorf(w, http.StatusBadRequest, "json body could not be decoded: "+err.Error())
		return
	}
default:
	w.WriteHeader(http.StatusMethodNotAllowed)
	return
}
w.Header().Set("Content-Type", "application/json")

ctx := r.Context()

...
...
// æ­¤éƒ¨åˆ†ä»£ç å³ä¸ºåŒºåˆ†æ“ä½œç±»å‹Queryæˆ–Mutationï¼ˆå…¶ä¸­opä¸ºè§£æreqParamsåçš„*OperationDefinationå¯¹è±¡ï¼ŒåŒ…æ‹¬æ“ä½œç±»å‹ç­‰æ•°æ®ï¼‰
switch op.Operation {
case ast.Query:
	b, err := json.Marshal(gh.exec.Query(ctx, op))	// æ­¤å‡½æ•°è°ƒç”¨æ˜¯æˆ‘ä»¬æ‰€ç€é‡å…³æ³¨çš„ï¼ˆexecçš„ä½œç”¨ä¹Ÿåœ¨æ­¤ä½“ç°ï¼Œè°ƒç”¨Queryå‡½æ•°è¿›è¡ŒæŸ¥è¯¢æ“ä½œï¼‰
	if err != nil {
		panic(err)
	}
	w.Write(b)			// è¿”å›è¯·æ±‚å“åº”ç»“æœ
case ast.Mutation:
	b, err := json.Marshal(gh.exec.Mutation(ctx, op))	// æ­¤æ¬¡demoä¸­å¹¶æ²¡æœ‰ç”¨åˆ°Mutation
	if err != nil {
		panic(err)
	}
	w.Write(b)
default:
	sendErrorf(w, http.StatusBadRequest, "unsupported operation type")
} }
</code></pre></div></div>

<p>Ctrl+å³é”®è¿›å…¥gh.exec.Query(ctx, op)çš„Queryå‡½æ•°ã€‚</p>

<p>generated.go
Query()
çœ‹åˆ°ä¸‹æ–¹çš„å‡½æ•°ï¼ŒæœåŠ¡ç«¯åœ¨æ­¤å¼€å§‹çœŸæ­£çš„æŸ¥è¯¢æ“ä½œï¼Œæˆ‘ä»¬å°†ä¸€æ­¥ä¸€æ­¥è§‚å¯Ÿqueryçš„æ‰§è¡Œè¿‡ç¨‹ã€‚</p>

<p>func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	// executionContextæ˜¯ä¸€ä¸ªåˆ©ç”¨ä¸Šä¸‹æ–‡ä¿¡æ¯çš„æŸ¥è¯¢struct
	// type executionContext struct {
	//     *graphql.RequestContext		// è¯·æ±‚ä¸Šä¸‹æ–‡
	//     *executableSchema			// executableSchemaå¯¹è±¡
	// }
	// æ­¤ç±»å‹å®ç°äº†_Query()ç­‰ä¸€ç³»åˆ—æŸ¥è¯¢å‡½æ•°ï¼Œåé¢æˆ‘ä»¬å°†çœ‹åˆ°å…¶å¼ºå¤§ä¹‹å¤„
	ec := executionContext{graphql.GetRequestContext(ctx), e}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
	// å›è°ƒå‡½æ•°ä¸­è°ƒç”¨_Query()å‡½æ•°ï¼Œå¹¶ä¼ å…¥ä¸Šä¸‹æ–‡ï¼Œä¸€æ¬¡æŸ¥è¯¢é›†åˆ(è¿›å…¥æ­¤å‡½æ•°)
	data := ec._Query(ctx, op.SelectionSet)
	var buf bytes.Buffer
	data.MarshalGQL(&amp;buf)
	return buf.Bytes()
})
// è¿”å›æŸ¥è¯¢ç»“æœ
return &amp;graphql.Response{
	Data:       buf,
	Errors:     ec.Errors,
	Extensions: ec.Extensions} }
</code></pre></div></div>

<p>_Query()
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctx = graphql.WithResolverContext(ctx, &amp;graphql.ResolverContext{
	Object: "Query",
})

var wg sync.WaitGroup
out := graphql.NewOrderedMap(len(fields))
invalid := false
for i, field := range fields {
	out.Keys[i] = field.Alias

	switch field.Name {
	case "__typename":
		out.Values[i] = graphql.MarshalString("Query")
	case "people":	// è§£ææŸ¥è¯¢ï¼Œè‹¥ä¸ºPeopleæŸ¥è¯¢ï¼Œåˆ™è°ƒç”¨_Query_peopleè¿›ä¸€æ­¥è§£æ
		wg.Add(1)
		go func(i int, field graphql.CollectedField) {
			out.Values[i] = ec._Query_people(ctx, field)
			wg.Done()
		}(i, field)
	case "peoples": // è§£ææŸ¥è¯¢ï¼Œè‹¥ä¸ºPeoplesæŸ¥è¯¢ï¼Œåˆ™è°ƒç”¨_Query_peoplesè¿›ä¸€æ­¥è§£æ
		wg.Add(1)
		go func(i int, field graphql.CollectedField) {
			out.Values[i] = ec._Query_peoples(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
			wg.Done()
		}(i, field)
	case "__type":
		out.Values[i] = ec._Query___type(ctx, field)
	case "__schema":
		out.Values[i] = ec._Query___schema(ctx, field)
	default:
		panic("unknown field " + strconv.Quote(field.Name))
	}
}
wg.Wait()
if invalid {
	return graphql.Null
}
// è¿”å›æŸ¥è¯¢ç»“æœ
return out } _Query_people func (ec *executionContext) _Query_people(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
ctx = ec.Tracer.StartFieldExecution(ctx, field)
defer func() { ec.Tracer.EndFieldExecution(ctx) }()
rawArgs := field.ArgumentMap(ec.Variables)
args, err := field_Query_people_args(rawArgs)
if err != nil {
	ec.Error(ctx, err)
	return graphql.Null
}
rctx := &amp;graphql.ResolverContext{
	Object: "Query",
	Args:   args,
	Field:  field,
}
ctx = graphql.WithResolverContext(ctx, rctx)
ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {
	ctx = rctx // use context from middleware stack in children
	// æ­¤å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬éœ€è¦å…³æ³¨æ­¤å‡½æ•°ï¼ŒexecutionContextæ‹¥æœ‰executableSchemaçš„æ‰€æœ‰å­—æ®µï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨resolverså±æ€§çš„Query()æ–¹æ³•ã€‚
	// å›åˆ°æˆ‘ä»¬ä¹‹å‰ä»‹ç»å®šä¹‰executableSchemaçš„è¿‡ç¨‹ï¼ŒexecutableSchemaçš„resolverså±æ€§ä¸ºcfg.Resolversï¼Œè€Œcfg.Resolversä¸ºæˆ‘ä»¬åœ¨resolver.goæ–‡ä»¶ä¸­ç”Ÿæˆçš„Resolverç»“æ„ä½“ï¼ˆæ­¤ç»“æ„ä½“å®ç°Query()æ–¹æ³•ï¼‰ï¼Œå¹¶ä¸”Query()æ–¹æ³•è¿”å›queryResolverå¯¹è±¡ï¼š
	// type queryResolver struct{ *Resolver }

	// func (r *queryResolver) People(ctx context.Context, id string) (*People, error) {
	//	   return &amp;People{}, nil
	// }
	// func (r *queryResolver) Peoples(ctx context.Context, first *int, after *string) (PeopleConnection, error) {
	//     panic("not implemented")
	// }
	// è¿™å°±è¿›å…¥äº†resolver.goæ–‡ä»¶ï¼Œè¿™ä¹Ÿæ­£æ˜¯æˆ‘ä»¬éœ€è¦å®ç°çš„æŸ¥è¯¢å‡½æ•°ï¼ˆè®¿é—®æ•°æ®åº“ç­‰æ“ä½œå³åœ¨æ­¤è¿›è¡Œï¼‰
	return ec.resolvers.Query().People(rctx, args["id"].(string))
})

if resTmp == nil {
	return graphql.Null
}
res := resTmp.(*People)
rctx.Result = res
ctx = ec.Tracer.StartFieldChildExecution(ctx)

if res == nil {
	return graphql.Null
}
// å½“æˆ‘ä»¬è·å¾—æŸ¥è¯¢ç»“æœåï¼Œæˆ‘ä»¬éœ€è¦ç­›é€‰å‡ºç”¨æˆ·æ‰€éœ€è¦çš„å­—æ®µï¼Œè¿™ä¹Ÿæ­£æ˜¯GraphQLæ¯”è¾ƒå…³é”®çš„åœ°æ–¹
return ec._People(ctx, field.Selections, res) } _People func (ec *executionContext) _People(ctx context.Context, sel ast.SelectionSet, obj *People) graphql.Marshaler {
fields := graphql.CollectFields(ctx, sel, peopleImplementors)

out := graphql.NewOrderedMap(len(fields))
invalid := false
// éå†ç”¨æˆ·æŸ¥è¯¢fieldsï¼ˆå­—æ®µï¼‰
for i, field := range fields {
	out.Keys[i] = field.Alias

	switch field.Name {
	case "__typename":
		out.Values[i] = graphql.MarshalString("People")
	case "id":
		out.Values[i] = ec._People_id(ctx, field, obj)
		if out.Values[i] == graphql.Null {
			invalid = true
		}
	case "name":
		out.Values[i] = ec._People_name(ctx, field, obj)
		if out.Values[i] == graphql.Null {
			invalid = true
		}
	case "birth_year":
		out.Values[i] = ec._People_birth_year(ctx, field, obj)
	case "eye_color":
		out.Values[i] = ec._People_eye_color(ctx, field, obj)
	case "gender":
		out.Values[i] = ec._People_gender(ctx, field, obj)
	case "hair_color":
		out.Values[i] = ec._People_hair_color(ctx, field, obj)
	case "height":
		out.Values[i] = ec._People_height(ctx, field, obj)
	case "mass":
		out.Values[i] = ec._People_mass(ctx, field, obj)
	case "skin_color":
		out.Values[i] = ec._People_skin_color(ctx, field, obj)
	// ä»¥ä¸Šå­—æ®µéƒ½ä¸ºæ ‡é‡å­—æ®µï¼Œæ‰€ä»¥è°ƒç”¨å„è‡ªçš„æŸ¥è¯¢å‡½æ•°å³è¿”å›æœ€ç»ˆç»“æœ
	// åœ¨æ­¤æˆ‘ä»¬éœ€è¦å…³æ³¨filmså­—æ®µï¼Œç”±äºfilmsä¸ºè‡ªå®šä¹‰ç±»å‹Filmåˆ—è¡¨ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿˜éœ€è¿›è¡Œæ·±å±‚æ¬¡ç­›é€‰ï¼Œäº§çœ‹_People_filmså‡½æ•°
	case "films":
		out.Values[i] = ec._People_films(ctx, field, obj)
	default:
		panic("unknown field " + strconv.Quote(field.Name))
	}
}

if invalid {
	return graphql.Null
}
return out } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 _People_films func (ec *executionContext) _People_films(ctx context.Context, field graphql.CollectedField, obj *People) graphql.Marshaler {
...
...
for idx1 := range res {
	idx1 := idx1
	rctx := &amp;graphql.ResolverContext{
		Index:  &amp;idx1,
		Result: res[idx1],
	}
	ctx := graphql.WithResolverContext(ctx, rctx)
	f := func(idx1 int) {
		if !isLen1 {
			defer wg.Done()
		}
		arr1[idx1] = func() graphql.Marshaler {

			if res[idx1] == nil {
				return graphql.Null
			}
			// å½“æˆ‘ä»¬è·å¾—peopleä¸­filmsåˆ—è¡¨ï¼Œä»¥åŠæ‰€è¦æŸ¥è¯¢çš„filmå­—æ®µä¹‹åæˆ‘ä»¬è¿›ä¸€æ­¥è°ƒç”¨_Filmå‡½æ•°è¿›è¡Œç­›é€‰
			return ec._Film(ctx, field.Selections, res[idx1])
		}()
	}
	if isLen1 {
		f(idx1)
	} else {
		go f(idx1)
	}
}
wg.Wait()
return arr1 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 _Film func (ec *executionContext) _Film(ctx context.Context, sel ast.SelectionSet, obj *Film) graphql.Marshaler {
fields := graphql.CollectFields(ctx, sel, filmImplementors)

out := graphql.NewOrderedMap(len(fields))
invalid := false
// å­è¿‡ç¨‹ä¸_Peopleè°ƒç”¨ç±»ä¼¼ï¼Œè¿›è¡Œç­›é€‰ï¼Œå¦‚æœæœ‰å¿…è¦åˆ™éœ€è¦è¿›ä¸€æ­¥ç­›é€‰æ•°æ®
for i, field := range fields {
	out.Keys[i] = field.Alias

	switch field.Name {
	case "__typename":
		out.Values[i] = graphql.MarshalString("Film")
	case "id":
		out.Values[i] = ec._Film_id(ctx, field, obj)
		if out.Values[i] == graphql.Null {
			invalid = true
		}
	case "title":
		out.Values[i] = ec._Film_title(ctx, field, obj)
		if out.Values[i] == graphql.Null {
			invalid = true
		}
	case "episode_id":
		out.Values[i] = ec._Film_episode_id(ctx, field, obj)
	case "opening_crawl":
		out.Values[i] = ec._Film_opening_crawl(ctx, field, obj)
	case "director":
		out.Values[i] = ec._Film_director(ctx, field, obj)
	case "producer":
		out.Values[i] = ec._Film_producer(ctx, field, obj)
	case "release_date":
		out.Values[i] = ec._Film_release_date(ctx, field, obj)
	default:
		panic("unknown field " + strconv.Quote(field.Name))
	}
}

if invalid {
	return graphql.Null
}
return out } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 åˆ°æ­¤ï¼Œæˆ‘ä»¬çš„PeopleæŸ¥è¯¢æ‰€è¿›è¡Œçš„æ­¥éª¤å·²ç»ç»“æŸï¼Œä¹‹åæŒ‰ç…§å‡½æ•°è°ƒç”¨é¡ºåºä¾æ¬¡è¿”å›æŸ¥è¯¢å³å¯ï¼Œæœ€ç»ˆå¾—åˆ°è¯·æ±‚å“åº”æ•°æ®è¿›è¡Œè¿”å›ã€‚åŒæ ·æˆ‘ä»¬çš„Peoplesåˆ†é¡µæŸ¥è¯¢æ­¥éª¤äºæ­¤ç±»ä¼¼ï¼Œæ‰€ä»¥ä¸å†èµ˜è¿°ã€‚
</code></pre></div></div>

<p>resolver.go
ä¸‹é¢æˆ‘ä»¬ä¾¿éœ€è¦å®ç°resolver.goä¸­çš„Peopleå’ŒPeoplesæ–¹æ³•ï¼š</p>

<p>type queryResolver struct{ *Resolver }</p>

<p>func (r <em>queryResolver) People(ctx context.Context, id string) (</em>People, error) {
	return &amp;People{}, nil
}
func (r *queryResolver) Peoples(ctx context.Context, first *int, after *string) (PeopleConnection, error) {
	panic(â€œnot implementedâ€)
}
1
2
3
4
5
6
7
8
åœ¨æ­¤Demoä¸­ï¼Œæˆ‘ä½¿ç”¨boltdbæ•°æ®åº“æ¥å­˜å‚¨æ•°æ®ï¼Œæ•°æ®æ¥æºæ¥è‡ªThe Star Wars APIï¼Œå¯ä»¥æ ¹æ®APIçˆ¬å–ä¸‹æ¥ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥å»githubä¸Šä¸‹è½½ã€‚ç”±äºæˆ‘ä»¬åœ¨schemaä¸­å®šä¹‰çš„Peopleæ‰€å«å­—æ®µä¸æ•°æ®åº“ä¸­å­˜å‚¨å¹¶ä¸ä¸€è‡´ï¼Œæ‰€ä»¥å¯ä»¥è‡ªè¡Œä¹¦å†™è½¬åŒ–å‡½æ•°ï¼Œå°†ä»æ•°æ®åº“ä¸­è·å–åˆ°çš„æ•°æ®è½¬åŒ–ä¸ºæ‰€éœ€çš„Peopleç±»å‹ã€‚</p>

<p>ä¹‹åæˆ‘ä»¬å®ç°çš„Peopleå’ŒPeopleså‡½æ•°å¦‚ä¸‹ï¼š</p>

<p>func (r <em>queryResolver) People(ctx context.Context, id string) (</em>People, error) {
	// GetPeopleByIDå³ä½¿æˆ‘ä»¬è¦å®ç°çš„è·å–peopleçš„å‡½æ•°
	err, people := GetPeopleByID(id, nil)
	checkErr(err)
	return people, err
}</p>

<p>func (r <em>queryResolver) Peoples(ctx context.Context, first *int, after *string) (PeopleConnection, error) {
	from := -1
	if after != nil {
		b, err := base64.StdEncoding.DecodeString(</em>after)
		if err != nil {
			return PeopleConnection{}, err
		}
		i, err := strconv.Atoi(strings.TrimPrefix(string(b), â€œcursorâ€))
		if err != nil {
			return PeopleConnection{}, err
		}
		from = i
	}
	count := 0
	startID := â€œâ€
	hasPreviousPage := true
	hasNextPage := true
	// è·å–edges
	edges := []PeopleEdge{}
	db, err := bolt.Open(â€œ./data/data.dbâ€, 0600, nil)
	CheckErr(err)
	defer db.Close()
	db.View(func(tx *bolt.Tx) error {
		c := tx.Bucket([]byte(peopleBucket)).Cursor()</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	// åˆ¤æ–­æ˜¯å¦è¿˜æœ‰å‰å‘é¡µ
	k, v := c.First()
	if from == -1 || strconv.Itoa(from) == string(k) {
		startID = string(k)
		hasPreviousPage = false
	}

	if from == -1 {
		for k, _ := c.First(); k != nil; k, _ = c.Next() {
			_, people := GetPeopleByID(string(k), db)
			edges = append(edges, PeopleEdge{
				Node:   people,
				Cursor: encodeCursor(string(k)),
			})
			count++
			if count == *first {
				break
			}
		}
	} else {
		for k, _ := c.First(); k != nil; k, _ = c.Next() {
			if strconv.Itoa(from) == string(k) {
				k, _ = c.Next()
				startID = string(k)
			}
			if startID != "" {
				_, people := GetPeopleByID(string(k), db)
				edges = append(edges, PeopleEdge{
					Node:   people,
					Cursor: encodeCursor(string(k)),
				})
				count++
				if count == *first {
					break
				}
			}
		}
	}

	k, v = c.Next()
	if k == nil &amp;&amp; v == nil {
		hasNextPage = false
	}
	return nil
})
if count == 0 {
	return PeopleConnection{}, nil
}
// è·å–pageInfo
pageInfo := PageInfo{
	HasPreviousPage: hasPreviousPage,
	HasNextPage:     hasNextPage,
	StartCursor:     encodeCursor(startID),
	EndCursor:       encodeCursor(edges[count-1].Node.ID),
}

return PeopleConnection{
	PageInfo:   pageInfo,
	Edges:      edges,
	TotalCount: count,
}, nil } // ç¼–ç æ¸¸æ ‡ï¼ˆæ¸¸æ ‡æŒ‡å‘å½“å‰èŠ‚ç‚¹ï¼‰ func encodeCursor(k string) string {
i, _ := strconv.Atoi(k)
return base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("cursor%d", i))) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 é¡¹ç›®ç»“æ„å¦‚ä¸‹ï¼š
</code></pre></div></div>

<p>GraphQLdemo
â”‚  dbOp.go
â”‚  generated.go
â”‚  gqlgen.yml
â”‚  models_gen.go
â”‚  resolver.go
â”‚  schema.graphql
â”‚
â”œâ”€data
â”‚      data.db
â”‚
â”œâ”€scripts
â”‚      gqlgen.go
â”‚
â””â”€server
        server.go
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
æ­¤æ—¶åœ¨æ­¤æŸ¥è¯¢å¯å¾—åˆ°å¦‚ä¸‹ç»“æœï¼š</p>

<p>åˆ°æ­¤æ­¥éª¤ï¼Œæˆ‘ä»¬çš„åŠŸèƒ½åŸºæœ¬ä¸Šå·²ç»å®ç°ï¼Œä½†æ­¤æ—¶æˆ‘ä»¬ä¾ç„¶è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå¯¹äºPeopleæŸ¥è¯¢çš„filmsæ˜¯å¦å¯ä»¥åˆ†é¡µå‘¢ï¼Ÿç­”æ¡ˆæ˜¯å¦å®šçš„ï¼Œé‚£æˆ‘ä»¬åº”è¯¥æ€æ ·å®ç°å±æ€§åˆ†é¡µï¼Ÿ</p>

<p>å±æ€§åˆ†é¡µ
ä¿®æ”¹schema
æƒ³è¦è¿›è¡Œå±æ€§åˆ†é¡µï¼Œåˆ™è¯¥å±æ€§å¿…é¡»æ‹¥æœ‰ç±»ä¼¼äºPeople(Int, ID!):Peopleçš„æŸ¥è¯¢å‡½æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¿®æ”¹schemaä¸­Peopleçš„å®šä¹‰ï¼š</p>

<p>type People {
    id: ID!
    name: String!
    birth_year: String
    eye_color: String
    gender: String
    hair_color: String
    height: String
    mass: String
    skin_color: String
    films: [Film]	# æ­¤å­—æ®µå¯ä»¥ä¿ç•™ï¼Œæ— éœ€åˆ†é¡µæ—¶ä½¿ç”¨æ­¤å±æ€§å³å¯
    filmConnection(first: Int, after: ID): FilmConnection!	# æ­¤å±æ€§ç”¨äºfilmåˆ†é¡µæŸ¥è¯¢
}</p>
<h1 id="æ–°å¢å­—æ®µ">æ–°å¢å­—æ®µ</h1>
<p>type FilmConnection {
    pageInfo: PageInfo!
    edges: [FilmEdge!]
    totalCount: Int!
}</p>

<p>type FilmEdge {
    node: Film
    cursor: ID!
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
æ–°å¢model
åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸‹æ–°å»ºæ–‡ä»¶model.goï¼Œç”±äºschemaä¸­Peopleè¢«æˆ‘ä»¬ä¿®æ”¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ ¹æ®éœ€è¦å®šä¹‰Peopleï¼š</p>

<p>type People struct {
	ID        string  <code class="language-plaintext highlighter-rouge">json:"id"</code>
	Name      string  <code class="language-plaintext highlighter-rouge">json:"name"</code>
	BirthYear <em>string <code class="language-plaintext highlighter-rouge">json:"birth_year"</code>
	EyeColor  *string <code class="language-plaintext highlighter-rouge">json:"eye_color"</code>
	Gender    *string <code class="language-plaintext highlighter-rouge">json:"gender"</code>
	HairColor *string <code class="language-plaintext highlighter-rouge">json:"hair_color"</code>
	Height    *string <code class="language-plaintext highlighter-rouge">json:"height"</code>
	Mass      *string <code class="language-plaintext highlighter-rouge">json:"mass"</code>
	SkinColor *string <code class="language-plaintext highlighter-rouge">json:"skin_color"</code>
	Films     []</em>Film <code class="language-plaintext highlighter-rouge">json:"films"</code>
}
1
2
3
4
5
6
7
8
9
10
11
12
å°†modelåŠ å…¥åˆ°gqlgen.ymlä¸­
models:
  People:
    model: github.com/liuyh73/GraphQLdemo.People
1
2
3
åˆ é™¤resolver.go
åˆ é™¤ä¹‹å‰æ³¨æ„å¤‡ä»½ä¸€ä¸‹</p>

<p>é‡æ–°ç”ŸæˆGraphQLéª¨æ¶
$ go run scripts/gqlgen.go -v 
Unable to bind People.filmConnection to github.com/liuyh73/GraphQLdemo.People
  no method named filmConnection
  no field named filmConnection
  Adding resolver method
Unable to bind People.filmConnection to github.com/liuyh73/GraphQLdemo.People
  no method named filmConnection
  no field named filmConnection
  Adding resolver method
æŸ¥çœ‹é‡æ–°ç”Ÿæˆçš„resolver.goï¼Œå¢åŠ äº†å¦‚ä¸‹å®šä¹‰å’Œå‡½æ•°</p>

<p>func (r *Resolver) People() PeopleResolver {
	return &amp;peopleResolver{r}
}</p>

<p>type peopleResolver struct{ *Resolver }
// æ­¤å‡½æ•°ä¾¿æ˜¯æˆ‘ä»¬å®ç°filmsåˆ†é¡µçš„å…³é”®æ­¥éª¤
func (r *peopleResolver) FilmConnection(ctx context.Context, obj *People, first *int, after *string) (FilmConnection, error) {
	panic(â€œnot implementedâ€)
}
å°†ä¹‹å‰å¤‡ä»½çš„resolver.goä¸­çš„å‡½æ•°é‡æ–°ç²˜è´´åˆ°ç›¸åº”çš„ä½ç½®ã€‚</p>

<p>å®šä¹‰FilmConnection
// å…·ä½“æ“ä½œä¸Peopleç±»ä¼¼
func (r <em>peopleResolver) FilmConnection(ctx context.Context, obj *People, first *int, after *string) (FilmConnection, error) {
	from := -1
	if after != nil {
		b, err := base64.StdEncoding.DecodeString(</em>after)
		if err != nil {
			return FilmConnection{}, err
		}
		i, err := strconv.Atoi(strings.TrimPrefix(string(b), â€œcursorâ€))
		if err != nil {
			return FilmConnection{}, err
		}
		from = i
	}
	index := -1
	count := 0
	hasPreviousPage := false
	hasNextPage := true
	// è·å–edges
	edges := []FilmEdge{}
	for i, film := range obj.Films {
		if film.ID == strconv.Itoa(from) {
			index = i
			break
		}
	}
	if index &gt; 0 {
		hasPreviousPage = true
	}
	for i := index + 1; i &lt; len(obj.Films); i++ {
		edges = append(edges, FilmEdge{
			Node:   obj.Films[i],
			Cursor: encodeCursor(obj.Films[i].ID),
		})
		count++
		if count &gt;= *first {
			break
		}
	}
	if count &lt; *first {
		hasNextPage = false
	}
	if count == 0 {
		return FilmConnection{}, nil
	}
	// è·å–pageInfo
	pageInfo := PageInfo{
		HasPreviousPage: hasPreviousPage,
		HasNextPage:     hasNextPage,
		StartCursor:     encodeCursor(edges[0].Node.ID),
		EndCursor:       encodeCursor(edges[count-1].Node.ID),
	}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return FilmConnection{
	PageInfo:   pageInfo,
	Edges:      edges,
	TotalCount: count,
}, nil } æŸ¥è¯¢ç»“æœ
</code></pre></div></div>

<p>ä¸‹é¢æˆ‘ä»¬ä¾¿æ¥çœ‹çœ‹FilmConnectionåˆ°åº•æ˜¯ä»€ä¹ˆæ—¶å€™è¢«è°ƒç”¨çš„ã€‚
åŒæ ·è¿›å…¥generated.goæ–‡ä»¶ï¼Œæ­¤æ¬¡æˆ‘ä»¬ç›´æ¥å®šä½åˆ°_Peopleå‡½æ•°ï¼ˆ1168è¡Œï¼‰ï¼Œè§‚å¯Ÿä»¥ä¸‹ä»£ç ï¼š</p>

<p>case â€œfilmConnectionâ€:
    wg.Add(1)
    go func(i int, field graphql.CollectedField) {
        out.Values[i] = ec._People_filmConnection(ctx, field, obj)
        if out.Values[i] == graphql.Null {
            invalid = true
        }
        wg.Done()
    }(i, field)
è¿™æ˜¯æ–°å¢çš„caseï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬è¿›å…¥_People_filmConnectionï¼Œ</p>

<p>func (ec <em>executionContext) _People_filmConnection(ctx context.Context, field graphql.CollectedField, obj *People) graphql.Marshaler {
	ctx = ec.Tracer.StartFieldExecution(ctx, field)
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()
	rawArgs := field.ArgumentMap(ec.Variables)
	args, err := field_People_filmConnection_args(rawArgs)
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	rctx := &amp;graphql.ResolverContext{
		Object: â€œPeopleâ€,
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {
		ctx = rctx // use context from middleware stack in children
		// è¿™é‡Œä¾¿æ˜¯æˆ‘ä»¬è°ƒç”¨FilmConnectionçš„åœ°æ–¹
		return ec.resolvers.People().FilmConnection(rctx, obj, args[â€œfirstâ€].(</em>int), args[â€œafterâ€].(*string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, â€œmust not be nullâ€)
		}
		return graphql.Null
	}
	res := resTmp.(FilmConnection)
	rctx.Result = res
	ctx = ec.Tracer.StartFieldChildExecution(ctx)
	// è¿”å›ç­›é€‰ç»“æœ
	return ec._FilmConnection(ctx, field.Selections, &amp;res)
}</p>

:ET