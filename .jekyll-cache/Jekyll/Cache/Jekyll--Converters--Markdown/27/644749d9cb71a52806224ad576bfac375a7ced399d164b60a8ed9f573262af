I"†;<p>https://gocn.vip/topics/10396
Pool ç¿»è¯‘è¿‡æ¥å°±æ˜¯æ± å­ï¼Œä¸»è¦åŠŸèƒ½å°±æ˜¯: éœ€è¦ä½¿ç”¨æŸä¸ª Object çš„æ—¶å€™å¯ä»¥ä» Pool è·å–ï¼Œä½¿ç”¨å®Œæ¯•å†å½’è¿˜ï¼Œä»è€Œå‡å°‘åˆ›å»ºå’Œé”€æ¯ Object çš„å¼€é”€ã€‚</p>

<p>åƒä¸‡ä¸è¦æƒ³å½“ç„¶çš„è®¤ä¸º put è¿›å»çš„ Object å’Œ get å‡ºæ¥çš„ Object æœ‰ä»€ä¹ˆå…³ç³»ï¼ŒPool å­˜çš„ Object åœ¨ GC æ—¶ä¼šéƒ½æ¸…ç†æ‰
<!-- more -->
package main</p>

<p>import (
    â€œfmtâ€
    â€œsyncâ€
)</p>

<p>type Book struct {
    Name string
    Info map[string]string
}</p>

<p>func NewBook() interface{} {
    return &amp;Book{
        Name: â€œâ€,
        Info: make(map[string]string),
    }
}</p>

<p>func main() {
    // åˆ›å»ºpoolå¹¶å®šä¹‰åˆ›å»ºobjectçš„å‡½æ•°
    bookPool := sync.Pool{New:NewBook}</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ä»poolè·å–object
a := bookPool.Get().(*Book)
a.Name = "go"
a.Info["a"] = "b"

fmt.Println(a)

// æ”¾å›pool
bookPool.Put(a) } ç»“æ„å›¾
&lt;img src="https://xiazemin.github.io/MyBlog/img/syncpool.png"/&gt;

å®ç°ç»†èŠ‚ Pool å®ç°æºç æ˜¯è¿™ä¸¤ä¸ªæ–‡ä»¶ go/src/sync/pool.go, go/src/sync/poolqueue.go æ•°æ®ç»“æ„â€”â€”ä»ä¸‹å¾€ä¸Šè®²ä¸€ä¸‹ Pool åº•å±‚å­˜å‚¨æ˜¯å¦‚ä½•å®ç° eface // å­˜å‚¨å…ƒç´ çš„ç»“æ„ä½“ï¼Œç±»å‹æŒ‡é’ˆå’Œå€¼æŒ‡é’ˆ type eface struct {
    typ, val unsafe.Pointer } Pool åº•å±‚ç”¨ eface æ¥å­˜å‚¨å•ä¸ª Object, åŒ…æ‹¬ typ æŒ‡é’ˆ: Object çš„ç±»å‹ï¼Œval æŒ‡é’ˆ: Object çš„å€¼
</code></pre></div></div>

<p>poolDequeue
poolDequeue æ˜¯ä¸€ä¸ªæ— é”ã€å›ºå®šå¤§å°çš„å•ç”Ÿäº§ç«¯å¤šæ¶ˆè´¹ç«¯çš„ç¯å½¢é˜Ÿåˆ—ï¼Œå•ä¸€ producer å¯ä»¥åœ¨å¤´éƒ¨ push å’Œ pop(å¯èƒ½å’Œä¼ ç»Ÿé˜Ÿåˆ—å¤´éƒ¨åªèƒ½ push çš„å®šä¹‰ä¸åŒ)ï¼Œå¤š consumer å¯ä»¥åœ¨å°¾éƒ¨ pop</p>

<p>headTail:</p>

<p>[hhhhhhhh hhhhhhhh hhhhhhhh hhhhhhhh tttttttt tttttttt tttttttt tttttttt]</p>
<ol>
  <li>headTailè¡¨ç¤ºä¸‹æ ‡ï¼Œé«˜32ä½è¡¨ç¤ºå¤´ä¸‹æ ‡ï¼Œä½32ä½è¡¨ç¤ºå°¾ä¸‹æ ‡ï¼ŒpoolDequeueå®šä¹‰äº†ï¼Œhead tailçš„packå’Œunpackå‡½æ•°æ–¹ä¾¿è½¬åŒ–ï¼Œ
å®é™…ç”¨çš„æ—¶å€™éƒ½ä¼šmod ( len(vals) - 1 ) æ¥é˜²æ­¢æº¢å‡º</li>
  <li>headå’Œtailæ°¸è¿œåªç”¨32ä½è¡¨ç¤ºï¼Œæº¢å‡ºåä¼šä»0å¼€å§‹ï¼Œè¿™ä¹Ÿæ»¡è¶³å¾ªç¯é˜Ÿåˆ—çš„è®¾è®¡</li>
  <li>é˜Ÿåˆ—ä¸ºç©ºçš„æ¡ä»¶  tail == head</li>
  <li>é˜Ÿåˆ—æ»¡çš„æ¡ä»¶    (tail+uint32(len(d.vals)))&amp;(1Â«dequeueBits-1) == head tailåŠ ä¸Šé˜Ÿåˆ—é•¿åº¦å’Œheadç›¸ç­‰(å®é™…ä¸Šå°±æ˜¯é˜Ÿåˆ—å·²æœ‰çš„ç©ºé—´éƒ½æœ‰å€¼äº†,æ»¡äº†)
vals:</li>
</ol>

<p>1  poolDequeueæ˜¯è¢«poolChainä½¿ç”¨ï¼ŒpoolChainä½¿ç”¨poolDequeueæ—¶ 
a) åˆå§‹åŒ–valsé•¿åº¦ä¸º8ï¼Œvalsé•¿åº¦å¿…é¡»æ˜¯2çš„å¹‚ 
b) å½“é˜Ÿåˆ—æ»¡æ—¶ï¼Œvalsé•¿åº¦*2ï¼Œæœ€å¤§æ‰©å±•åˆ° dequeueLimit = (1 Â«Â 32) / 4 = (1 Â«Â 30)ï¼Œä¹‹åå°±ä¸ä¼šæ‰©å±•äº† 
2 ä¸ºä»€ä¹ˆvalsé•¿åº¦å¿…é¡»æ˜¯2çš„å¹‚ ?
è¿™æ˜¯å› ä¸ºgoçš„å†…å­˜ç®¡ç†ç­–ç•¥æ˜¯å°†å†…å­˜åˆ†ä¸º2çš„å¹‚å¤§å°çš„é“¾è¡¨ï¼Œç”³è¯·2çš„å¹‚å¤§å°çš„å†…å­˜å¯ä»¥æœ‰æ•ˆå‡å°åˆ†é…å†…å­˜çš„å¼€é”€ 
3 ä¸ºä»€ä¹ˆdequeueLimitæ˜¯(1 Â«Â 32) / 4 = 1 Â«Â 30 ?
a) dequeueLimit å¿…é¡»æ˜¯2çš„å¹‚(ä¸Šè¾¹è§£é‡Šè¿‡) 
b) headå’Œtailéƒ½æ˜¯32ä½ï¼Œæœ€å¤§æ˜¯1 Â«Â 31ï¼Œå¦‚æœéƒ½ç”¨çš„è¯ï¼Œheadå’Œtailå°±æ˜¯æ— ç¬¦å·æ•´å‹ï¼Œæ— ç¬¦å·æ•´å‹ä½¿ç”¨çš„æ—¶å€™ä¼šæœ‰å¾ˆå¤šä¸Šæº¢çš„é”™è¯¯ï¼Œè¿™ç±»é”™è¯¯æ˜¯ä¸å®¹æ˜“æ£€æµ‹çš„ï¼Œæ‰€ä»¥ç›¸æ¯”ä¹‹ä¸‹è¿˜ä¸å¦‚ç”¨31ä½æœ‰ç¬¦å·æ•´å‹ï¼Œæœ‰é”™å°±æŠ¥å‡ºæ¥ï¼Œç»“è®ºå‚è€ƒhttps://stackoverrun.com/cn/q/10770747 
type poolDequeue struct {
    headTail uint64</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vals []eface }
</code></pre></div></div>

<p>// poolDequeueæˆå‘˜å‡½æ•°
// è¿™é‡Œçš„åˆ é™¤æ“ä½œï¼Œæ˜¯å°†æŒ‡é’ˆç½®ç©ºï¼Œç„¶åè®©GCæ¥å›æ”¶å†…å­˜ç©ºé—´
unpack     å°†headTailåˆ†è§£ä¸ºheadå’Œtail
pack       å°†headå’Œtailç»„åˆæˆheadTail
pushHead   æ·»åŠ å…ƒç´ åˆ°é˜Ÿé¦–
popHead    è·å–å¹¶åˆ é™¤é˜Ÿé¦–å…ƒç´ 
popTail    è·å–å¹¶åˆ é™¤é˜Ÿå°¾å…ƒç´ 
PushHead   æ·»åŠ å…ƒç´ åˆ°é˜Ÿé¦–
PopHead    è·å–å¹¶åˆ é™¤é˜Ÿé¦–å…ƒç´ 
PopTail    è·å–å¹¶åˆ é™¤é˜Ÿå°¾å…ƒç´ 
poolChainElt
é“¾è¡¨çš„ä¸€ä¸ªèŠ‚ç‚¹ Node</p>

<p>type poolChainElt struct {
    poolDequeue</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// next and prev link to the adjacent poolChainElts in this
// poolChain.
//
// next is written atomically by the producer and read
// atomically by the consumer. It only transitions from nil to
// non-nil.
//
// prev is written atomically by the consumer and read
// atomically by the producer. It only transitions from
// non-nil to nil.
next, prev *poolChainElt } poolChain poolChain æ˜¯åŠ¨æ€ç‰ˆçš„ poolDequeue head(poolDequeue)[prev] --&gt; &lt;--- next[prev] ---&gt; &lt;---[next] tail(poolDequeue) åŠ¨æ€çš„é˜Ÿåˆ—ï¼Œé˜Ÿåˆ—æ¯ä¸ªèŠ‚ç‚¹åˆæ˜¯ä¸€ä¸ªç¯å½¢é˜Ÿåˆ— (poolDequeue)
</code></pre></div></div>

<p>type poolChain struct {
    // å¤´æŒ‡é’ˆï¼Œåªèƒ½å•ä¸€produceræ“ä½œ(push, pop)
    head *poolChainElt</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å°¾æŒ‡é’ˆï¼Œå¯ä»¥è¢«å¤šä¸ªconsumer popï¼Œå¿…é¡»æ˜¯åŸå­æ“ä½œ
tail *poolChainElt }
</code></pre></div></div>

<p>// poolChainæˆå‘˜å‡½æ•°
func (c *poolChain) pushHead(val interface{})
    1. å¦‚æœheadä¸ºnilï¼Œè¯´æ˜é˜Ÿåˆ—ç°åœ¨æ˜¯ç©ºçš„ï¼Œé‚£ä¹ˆæ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°†headå’Œtailéƒ½æŒ‡å‘è¿™ä¸ªèŠ‚ç‚¹
    2. å°†val pushåˆ°headçš„ç¯å½¢é˜Ÿåˆ—ä¸­ï¼Œå¦‚æœpushæˆåŠŸäº†ï¼Œå¯ä»¥è¿”å›äº†
    3. å¦‚æœæ²¡pushæˆåŠŸï¼Œåˆ™è¯´æ˜headçš„ç¯å½¢é˜Ÿåˆ—æ»¡äº†ï¼Œå°±å†åˆ›å»ºä¸€ä¸ªä¸¤å€headå¤§å°çš„èŠ‚ç‚¹[æœ€å¤§(1 Â«Â 32) / 4]ï¼Œ
        å°†æ–°èŠ‚ç‚¹ä½œä¸ºheadï¼Œå¹¶ä¸”å¤„ç†å¥½æ–°headå’Œæ—§headçš„nextï¼Œprevå…³ç³»
    4. å°†val pushåˆ°headçš„ç¯å½¢é˜Ÿåˆ—ä¸­</p>

<p>func (c *poolChain) popHead()
    1. å…ˆåœ¨headç¯å½¢é˜Ÿåˆ—ä¸­popHeadè¯•è¯•ï¼Œå¦‚æœç©ºäº†ï¼Œå½“å‰èŠ‚ç‚¹å°±æ²¡ç”¨äº†ï¼Œå°±åˆ æ‰å½“å‰èŠ‚ç‚¹ï¼Œå»prevèŠ‚ç‚¹å¹¶ä¸”æŠŠprevèŠ‚ç‚¹ä½œä¸ºæ–°headå†å–ä¸€å€¼é€’å½’ä¸‹å»ï¼Œ
        èƒ½å–åˆ°å°±è¿”å›ï¼Œå–ä¸åˆ°è¯´æ˜é˜Ÿåˆ—ç©ºäº†
func (c *poolChain) popTail()
    1. å¦‚æœtailä¸ºnilï¼Œè¯´æ˜é˜Ÿåˆ—æ˜¯ç©ºçš„ï¼Œç›´æ¥è¿”å›
    2. å¦‚æœtailénilï¼Œå°±å–å–è¯•è¯•ï¼Œæœ‰ä¸œè¥¿å°±è¿”å›
    3. å¦‚æœæ²¡å–å‡ºæ¥ä¸œè¥¿ï¼Œé‚£ä¹ˆè¯´æ˜tailèŠ‚ç‚¹æ²¡å­˜ä¸œè¥¿äº†ï¼Œé€’å½’å»prevèŠ‚ç‚¹ç¯å½¢é˜Ÿåˆ—ä¸­popTailï¼Œå¹¶ä¸”æŠŠprevèŠ‚ç‚¹ä½œä¸ºtailï¼Œèƒ½å–åˆ°å°±è¿”å›ï¼Œå–ä¸åˆ°å°±æ˜¯ç©ºäº†
poolLocal
poolLocal æ˜¯æ¯ä¸ªè°ƒåº¦å™¨ (P) å­˜ Object çš„ç»“æ„ä½“
private æ˜¯æ¯ä¸ªè°ƒåº¦å™¨ç§æœ‰çš„ï¼Œshared æ˜¯æ‰€æœ‰è°ƒåº¦å™¨å…¬æœ‰çš„ï¼Œæ¯ä¸ªè°ƒåº¦å™¨ pop æ—¶çš„é€»è¾‘æ˜¯: å…ˆçœ‹ privateï¼Œæ²¡æœ‰åœ¨çœ‹è‡ªå·±çš„ sharedï¼Œå†æ²¡æœ‰å°±å»å…¶ä»–è°ƒåº¦å™¨çš„ shared å·ï¼Œå†æ²¡æœ‰æ‰æ˜¯ç©º
pad æ˜¯é˜²æ­¢ä¼ªå…±äº«ï¼Œå‚è€ƒhttps://www.cnblogs.com/cyfonly/p/5800758.html</p>

<p>type poolLocal struct {
poolLocalInternal</p>

<p>// Prevents false sharing on widespread platforms with
// 128 mod (cache line size) = 0 .
pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte
}
// Local per-P Pool appendix. 
// å½“å‰è°ƒåº¦å™¨çš„å†…éƒ¨èµ„æº
type poolLocalInternal struct {
// å½“å‰è°ƒåº¦å™¨çš„ç§æœ‰èµ„æº
private interface{} // Can be used only by the respective P.
// æ‰€æœ‰è°ƒåº¦å™¨çš„å…¬æœ‰èµ„æº
shared  poolChain   // Local P can pushHead/popHead; any P can popTail.
}
ä¸»è¦å‡½æ•°
Put
Put adds x to the pool.</p>

<p>é¦–å…ˆå…³é—­ç«äº‰æ£€æµ‹ï¼Œç„¶åä¼šå°†å½“å‰ goroutine å›ºå®šåˆ°ä¸€ä¸ªè°ƒåº¦å™¨ (P) ä¸Šï¼Œä¸”ä¸å…è®¸æŠ¢å 
ä» Pool çš„ local ä¸­å–å‡ºæ¥å½“å‰ goroutine å›ºå®šåˆ°é‚£ä¸ªè°ƒåº¦å™¨ (P) å¯¹åº”çš„ poolLocal, æ²¡æœ‰å°±æ–°å»º
å…ˆåˆ¤æ–­è¿™ä¸ªå½“å‰è°ƒåº¦å™¨ (P) ä¸“å± poolLocalï¼Œç§æœ‰ç©ºé—´æ˜¯ä¸æ˜¯ç©ºçš„ï¼Œå¦‚æœæ˜¯æŠŠ x æ”¾åˆ°ç§æœ‰ç©ºé—´ï¼Œå¹¶æŠŠ x ç½® nil
åˆ¤æ–­ x æ˜¯å¦ä¸º nilï¼Œå¦‚æœä¸ä¸ºç©ºè¯´æ˜ç§æœ‰ç©ºé—´æ»¡äº†ï¼Œå°± push åˆ°è¯¥è°ƒåº¦å™¨ä¸“å± poolLocal çš„ shared head
å…è®¸æŠ¢å ï¼Œå¼€å¯ç«äº‰æ£€æµ‹
func (p *Pool) Put(x interface{}) {
    // å¦‚æœputè¿›æ¥çš„å€¼ä¸ºç©ºç›´æ¥è¿”å›
    if x == nil {
        return
    }
    // å…³é—­ç«äº‰æ£€æµ‹
    if race.Enabled {
        if fastrand()%4 == 0 {
            // Randomly drop x on floor.
            return
        }
        race.ReleaseMerge(poolRaceAddr(x))
        race.Disable()
    }
    // 
    l, _ := p.pin()
    if l.private == nil {
        l.private = x
        x = nil
    }
    if x != nil {
        l.shared.pushHead(x)
    }
    runtime_procUnpin()
    if race.Enabled {
        race.Enable()
    }
}
æŠŠå½“å‰çš„ goroutine å›ºå®šåˆ°è°ƒåº¦å™¨ (P)ï¼Œä¸å…è®¸æŠ¢å , è¿”å›è¯¥è°ƒåº¦å™¨ (P) å¯¹åº”çš„ poolLocal å’Œè°ƒåº¦å™¨ (P) ID è¿è¡Œæ—¶è°ƒåº¦å™¨çš„ä¸‰ä¸ªé‡è¦ç»„æˆéƒ¨åˆ† â€” çº¿ç¨‹ Mã€Goroutine G å’Œè°ƒåº¦å™¨ P(è´Ÿè´£è°ƒåº¦)</p>

<p>åˆ¤æ–­ pid æ˜¯å¦å°äº [] poolLocal çš„é•¿åº¦ï¼Œå°äºçš„è¯å°±åœ¨å–å‡º poolLocal[P] è¿”å›ï¼Œå¦åˆ™å°±å»æ‰§è¡Œ pinSlow å‡½æ•° Caller must call runtime_procUnpin() when done with the pool.</p>

<p>func (p <em>Pool) pin() (</em>poolLocal, int) {
    // å…³é—­æŠ¢å ï¼Œç­‰è¿™ä¸ªgoroutineå·¥ä½œå®Œï¼Œå…¶ä»–goroutineæ‰èƒ½è·å¾—æ—¶é—´ç‰‡å·¥ä½œ
    pid := runtime_procPin()
    // In pinSlow we store to local and then to localSize, here we load in opposite order.
    // Since weâ€™ve disabled preemption, GC cannot happen in between.
    // Thus here we must observe local at least as large localSize.
    // We can observe a newer/larger local, it is fine (we must observe its zero-initialized-ness).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s := atomic.LoadUintptr(&amp;p.localSize) // load-acquire
l := p.local                          // load-consume
if uintptr(pid) &lt; s {
    return indexLocal(l, pid), pid
}
return p.pinSlow() } å½“ goroutine å›ºå®šåˆ°çš„è°ƒåº¦å™¨ (P) æ²¡æœ‰ poolLocal æ—¶ï¼Œpins() å‡½æ•°å°±ä¼šè°ƒç”¨ pinSlow() æ¥é‡æ–°å›ºå®šåˆ°å…¶ä»–è°ƒåº¦å™¨ (P)ï¼Œ å¦‚æœæ–°å›ºå®šåˆ°çš„è°ƒåº¦å™¨ (P) è¿˜æ˜¯æ²¡æœ‰ poolLocalï¼Œå°±ç»™è¯¥è°ƒåº¦å™¨åˆ›å»ºä¸€ä¸ª poolLocal æ”¾åˆ° Pool çš„ local ä¸­
</code></pre></div></div>

<p>æ‰“å¼€æŠ¢å å¹¶ä¸” pool åŠ é”ç„¶åå…³é—­æŠ¢å ï¼Œè¿™é‡Œå¦‚æœä¸å…ˆæ‰“å¼€æŠ¢å çš„è¯ï¼Œå…¶ä»– goroutine å¦‚æœä¹‹å‰è·å¾—é”äº†ï¼Œä½†ä¸èƒ½è¿è¡Œï¼Œå½“å‰ goroutine åœ¨è·å–é”ï¼Œå°±ä¼šæ­»é”
å¦‚æœåˆ¤æ–­ pid å’Œ len([] poolLocal) çš„å…³ç³»ï¼Œå°äºå°±è¿”å› [PID] poolLocal
å¦‚æœæ­¤ Pool çš„ [] poolLocal æ˜¯ç©ºçš„ï¼Œå°±æŠŠ Pool åŠ åˆ° allPools ä¸­
è·å¾—å½“å‰ cpu çš„æ•°é‡ï¼Œåˆ›å»ºä¸€ä¸ª cpu æ•°é‡å¤§å°çš„ [] poolLocal
func (p <em>Pool) pinSlow() (</em>poolLocal, int) {
    runtime_procUnpin()
    allPoolsMu.Lock()
    defer allPoolsMu.Unlock()
    pid := runtime_procPin()
    // poolCleanup wonâ€™t be called while we are pinned.
    s := p.localSize
    l := p.local
    if uintptr(pid) &lt; s {
        return indexLocal(l, pid), pid
    }
    if p.local == nil {
        allPools = append(allPools, p)
    }
    // If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.
    size := runtime.GOMAXPROCS(0)
    local := make([]poolLocal, size)
    atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[0])) // store-release
    atomic.StoreUintptr(&amp;p.localSize, uintptr(size))         // store-release
    return &amp;local[pid], pid
}
Get
ä» Pool ä¸­è·å–å¯¹è±¡ï¼Œç„¶åè¿”å›ï¼Œå¦‚æœ Pool ä¸ºç©ºçš„å°±ç”¨ New æ¥åˆ›å»º ä¸è¦å‡è®¾ Put è¿›æ¥çš„å¯¹è±¡å’Œ Get å¾—åˆ°çš„å¯¹è±¡æœ‰ä»€ä¹ˆå…³ç³»</p>

<p>å…³æ‰ç«äº‰æ£€æµ‹
å°† goroutine å›ºå®šåˆ°ä¸€ä¸ªè°ƒåº¦å™¨ (P), å¹¶è·å–ä»–çš„ poolLocal å’Œ PID
åˆ¤æ–­è¯¥è°ƒåº¦å™¨ (P) çš„ poolLocal çš„ç§æœ‰ç©ºé—´æ˜¯ä¸æ˜¯ç©ºçš„ï¼Œå¦‚æœæ˜¯ç©ºçš„ï¼Œå°±ä»è¯¥è°ƒåº¦å™¨ (P) çš„ poolLocal shared ç©ºé—´å¤´ pop ä¸€ä¸‹çœ‹æœ‰æ²¡æœ‰
å¦‚æœæ²¡æœ‰ï¼Œå°±è¯´æ˜è¯¥è°ƒåº¦å™¨ (P) è‡ªå·±çš„ poolLocal æ²¡æœ‰å¯¹è±¡äº†ï¼Œå°±è°ƒç”¨ getSlow
func (p *Pool) Get() interface{} {
    if race.Enabled {
        race.Disable()
    }
    l, pid := p.pin()
    x := l.private
    l.private = nil
    if x == nil {
        // Try to pop the head of the local shard. We prefer
        // the head over the tail for temporal locality of
        // reuse.
        x, _ = l.shared.popHead()
        if x == nil {
            x = p.getSlow(pid)
        }
    }
    runtime_procUnpin()
    if race.Enabled {
        race.Enable()
        if x != nil {
            race.Acquire(poolRaceAddr(x))
        }
    }
    if x == nil &amp;&amp; p.New != nil {
        x = p.New()
    }
    return x
}
æ‡’è·å–å‡½æ•°</p>

<p>å–åˆ° Pool çš„ localSize å’Œ local
ç„¶åéå†å…¶ä»–è°ƒåº¦å™¨ (P) å¯¹åº”çš„ poolLocalï¼Œçœ‹çœ‹èƒ½ä¸èƒ½ä»å¯¹åº” poolLocal ä¸­çš„ shared tail ä¸­å–å‡ºå¯¹è±¡, å¦‚æœèƒ½å–åˆ°ï¼Œç›´æ¥è¿”å›
å¦‚æœå–ä¸åˆ°å°±åˆ° victim ä¸­æŸ¥è¯¢ï¼Œæœ‰å°±è¿”å›ï¼Œæ²¡æœ‰è°ƒç”¨ New åˆ›å»ºä¸€ä¸ªæ–°çš„ Object è¿”å›
func (p *Pool) getSlow(pid int) interface{} {
    // See the comment in pin regarding ordering of the loads.
    size := atomic.LoadUintptr(&amp;p.localSize) // load-acquire
    locals := p.local                        // load-consume
    // Try to steal one element from other procs.
    for i := 0; i &lt; int(size); i++ {
        l := indexLocal(locals, (pid+i+1)%int(size))
        if x, _ := l.shared.popTail(); x != nil {
            return x
        }
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Try the victim cache. We do this after attempting to steal
// from all primary caches because we want objects in the
// victim cache to age out if at all possible.
size = atomic.LoadUintptr(&amp;p.victimSize)
if uintptr(pid) &gt;= size {
    return nil
}
locals = p.victim
l := indexLocal(locals, pid)
if x := l.private; x != nil {
    l.private = nil
    return x
}
for i := 0; i &lt; int(size); i++ {
    l := indexLocal(locals, (pid+i)%int(size))
    if x, _ := l.shared.popTail(); x != nil {
        return x
    }
}

// Mark the victim cache as empty for future gets don't bother
// with it.
atomic.StoreUintptr(&amp;p.victimSize, 0)

return nil } é™„å½• pool.dot digraph {
bgcolor="#C6CFD532";

node [shape=record, fontsize="8", margin="0.04", height=0.2, color=gray]
edge [fontname="Inconsolata, Consolas", fontsize=10, arrowhead=normal]

pool [shape=record,label="{noCopy|&lt;local&gt;local|localSize|&lt;victim&gt;victim|victimSize|New}",xlabel="Pool"]
poolLocal[shape=record,label="{&lt;poolLocalInternal&gt;poolLocalInternal|pad}",xlabel="poolLocal"]
poolLocalInternal[shape=record,label="{private|&lt;shared&gt;shared}",xlabel="poolLocalInternal"]
poolChain[shape=record,label="{&lt;head&gt;head|&lt;tail&gt;tail}",xlabel="poolChain"]
poolChainElt[shape=record,label="{&lt;poolDequeue&gt;poolDequeue|next|prev}",xlabel="poolChainElt"]
poolDequeue[shape=record,label="{headTail|&lt;vals&gt;vals}",xlabel="poolDequeue"]
eface[shape=record,label="{typ|val}",xlabel="eface"]
victim[shape=record,label="GCçš„æ—¶å€™ï¼Œé¦–å…ˆæŠŠlocalä¸­æ¯ä¸ªå¤„ç†å™¨(P)å¯¹åº”çš„poolLocalèµ‹ç»™victimï¼Œç„¶åæ¸…ç©ºlocalï¼Œæ‰€ä»¥victimå°±æ˜¯ç¼“å­˜GCå‰çš„local",xlabel="victim"]

pool:local -&gt; poolLocal [label="localæŒ‡é’ˆæŒ‡å‘[]poolLocalé¦–åœ°å€",rankdir=LR]
poolLocal:poolLocalInternal -&gt; poolLocalInternal
poolLocalInternal:shared -&gt; poolChain[label="sharedæ˜¯ä¸€ä¸ªé˜Ÿåˆ—"]
poolChain:head -&gt; poolChainElt[label="headå’Œtailæ˜¯é˜Ÿåˆ—çš„æ”¶å°¾èŠ‚ç‚¹æŒ‡é’ˆ"]
poolChain:tail -&gt; poolChainElt
poolChainElt:poolDequeue -&gt; poolDequeue[label="poolDequeueæ˜¯ä¸€ä¸ªç¯å½¢é˜Ÿåˆ—"]
poolDequeue:vals -&gt; eface[label="efaceå­˜å‚¨Objectçš„ç»“æ„ä½“ï¼Œtypå’Œvalæ˜¯Objectçš„ç±»å‹å’Œå€¼æŒ‡é’ˆ"]
pool:victim -&gt; victim }
</code></pre></div></div>
:ET