I"‘<p>https://gocn.vip/topics/10553
æˆ‘ä»¬éƒ½çŸ¥é“Goçš„structé‡Œï¼Œå°å†™å­—æ®µæ˜¯éå¯¼å‡ºçš„ï¼Œå³ä¸å¯ä»åŒ…å¤–éƒ¨è®¿é—®ã€‚</p>

<p>ä½†éå¯¼å‡ºå­—æ®µåœ¨å¤–éƒ¨ä¹Ÿå¹¶ä¸æ˜¯æ²¡æœ‰åŠæ³•è®¿é—®ï¼Œä¹Ÿä¸æ˜¯ä¸å¯ä»¥ä¿®æ”¹ã€‚</p>

<p>ä»Šå¤©çœ‹ä¸‹reflectåŒ…å¦‚ä½•åœ¨åŒ…å¤–æ“ä½œéå¯¼å‡ºå­—æ®µã€‚</p>

<p>å–åœ°å€è®¿é—®
å…ˆæ¥çœ‹ç¬¬ä¸€ä¸ªå‡½æ•°NewAtï¼š</p>

<p>å¯¹äºç»“æ„ä½“ï¼Œé€šè¿‡å…¶åº•å±‚åœ°å€ï¼ˆæŒ‡é’ˆ pï¼‰å’Œç±»å‹ï¼Œè¿”å›æŒ‡å‘è¯¥ç»“æ„ä½“çš„ä¸€ä¸ªæŒ‡é’ˆï¼Œ</p>

<p>è¯¥å€¼æ˜¯å¯å¯»å€çš„ï¼ˆaddressableï¼‰ï¼Œå³å¯è®¿é—®è¯¥ç»“æ„ä½“</p>

<p>// reflect/value.go
// NewAt returns a Value representing a pointer to a value of the
// specified type, using p as that pointer.
func NewAt(typ Type, p unsafe.Pointer) Value {
  fl := flag(Ptr)
  t := typ.(*rtype)
  return Value{t.ptrTo(), p, fl}
}
æœ‰ä¸ªè¿™ä¸ªæ–¹æ³•ï¼Œå°±å¯ä»¥é€šè¿‡structçš„åå°„è·å–éå¯¼å‡ºå­—æ®µ
<!-- more -->
æ¯”å¦‚è®¿é—®ï¼Œå¯¹äºå¦‚ä¸‹å«æœ‰éå¯¼å‡ºå­—æ®µçš„ç»“æ„ä½“Example</p>

<p>package testData
type Example struct {
  a string
}
ä¾¿å¯ä»¥é€šè¿‡å¯¹ç»“æ„ä½“egå–åœ°å€çš„æ–¹å¼ï¼Œè·å–å…¶éå¯¼å‡ºå­—æ®µaçš„å†…å®¹</p>

<p>è¿™é‡ŒElemæ˜¯è·å–å…¶åº•å±‚æ•°æ®å¯¹è±¡çš„æ–¹å¼ï¼Œ</p>

<p>å¦‚æœçŸ¥é“ç±»å‹ï¼Œä¹Ÿå¯æ˜¾ç¤ºæŒ‡å®šè°ƒç”¨ï¼Œå¦‚reflect.value.Interface,reflect.value.Intâ€¦</p>

<p>var eg testData.Example
a:=GetStructPtrUnExportedField(&amp;eg, â€œaâ€).String()</p>

<p>func GetStructPtrUnExportedField(source interface{}, fieldName string) reflect.Value {
  // è·å–éå¯¼å‡ºå­—æ®µåå°„å¯¹è±¡
  v := reflect.ValueOf(source).Elem().FieldByName(fieldName)
  // æ„å»ºæŒ‡å‘è¯¥å­—æ®µçš„å¯å¯»å€ï¼ˆaddressableï¼‰åå°„å¯¹è±¡
  return reflect.NewAt(v.Type(), unsafe.Pointer(v.UnsafeAddr())).Elem()
}
è¿™é‡Œæ³¨æ„å¿…é¡»è¦å¯¹egå–åœ°å€, å¦åˆ™ä¼španic:</p>

<p>panic: reflect: call of reflect.Value.Elem on struct Value</p>

<p>å› ä¸ºreflect.Value.Eleméœ€è¦reflect.Valueç±»å‹å¿…é¡»æ˜¯interfaceæˆ–è€…ptr,</p>

<p>è¿™æ ·è·å–å…¶åº•å±‚çš„å€¼æ‰æœ‰æ„ä¹‰ï¼šè¦ä¹ˆè¿”å›interfaceåº•å±‚çš„å€¼æˆ–è€…ptræŒ‡å‘çš„å€¼</p>

<p>å…¶æ³¨é‡Šå¦‚ä¸‹ï¼š</p>

<p>// Elem returns the value that the interface v contains
// or that the pointer v points to.
// It panics if vâ€™s Kind is not Interface or Ptr.
// It returns the zero Value if v is nil.
func (v Value) Elem() Value {
å–åœ°å€ä¿®æ”¹
é‚£å¯ä»¥è®¿é—®äº†ï¼Œå¦‚ä½•ä¿®æ”¹å‘¢ï¼Ÿ</p>

<p>åˆ©ç”¨reflect.value.Setå°±å¯ä»¥ï¼š</p>

<p>ä¸Šè¾¹Elemè·å–åˆ°çš„åå°„å€¼æ˜¯å¯ä¿®æ”¹çš„ï¼ˆassignableï¼‰,çªç ´äº†éå¯¼å‡ºå­—æ®µä¸èƒ½ä»å¤–éƒ¨ä¿®æ”¹çš„é™åˆ¶</p>

<p>var eg testData.Example
err := SetStructPtrUnExportedStrField(&amp;eg, â€œaâ€, â€œtestâ€)</p>

<p>func SetStructPtrUnExportedStrField(source interface{}, fieldName string, fieldVal interface{}) (err error) {
  v := GetStructPtrUnExportedField(source, fieldName)
  rv := reflect.ValueOf(fieldVal)
  if v.Kind() != rv.Kind() {
    return fmt.Errorf(â€œinvalid kind: expected kind %v, got kind: %vâ€, v.Kind(), rv.Kind())
  }
  // ä¿®æ”¹éå¯¼å‡ºå­—æ®µå€¼
  v.Set(rv)
  return nil
}
è¿™é‡Œæ˜¯ä»¥åå°„å€¼æ¥ä¿®æ”¹éå¯¼å‡ºå­—æ®µå€¼ï¼Œå†…éƒ¨ç±»å‹é¡»ä¸€è‡´ã€‚ä¿®æ”¹åå†…å®¹ä¼šç›´æ¥ååº”åˆ°egä¸Š</p>

<p>ç±»ä¼¼çš„è¿˜æœ‰æŒ‡å®šç±»å‹çš„è®¾ç½®æ–¹æ³•å¦‚SetString,SetBoolâ€¦</p>

<p>éå–åœ°å€è®¿é—®
å½“ç„¶ä¸å–åœ°å€ä¹Ÿæ˜¯å¯ä»¥è®¿é—®éå¯¼å‡ºå­—æ®µçš„ã€‚</p>

<p>è¿™é‡Œç”¨åˆ°çš„ç¬¬äºŒä¸ªå‡½æ•°æ˜¯New:</p>

<p>åŸºäºæŒ‡å®šç±»å‹åˆ›å»ºä¸€ä¸ªå¯ä»¥è¡¨ç¤ºè¯¥ç±»å‹çš„æŒ‡é’ˆ</p>

<p>// New returns a Value representing a pointer to a new zero value
// for the specified type. That is, the returned Valueâ€™s Type is PtrTo(typ).
func New(typ Type) Value {
  if typ == nil {
    panic(â€œreflect: New(nil)â€)
  }
  t := typ.(*rtype)
  ptr := unsafe_New(t)
  fl := flag(Ptr)
  return Value{t.ptrTo(), ptr, fl}
}
å…·ä½“è®¿é—®ä»£ç å¦‚ä¸‹ï¼š</p>

<p>func GetStructUnExportedField(source interface{}, fieldName string) (accessableField, addressableSourceCopy reflect.Value) {
  v := reflect.ValueOf(source)
  // since source is not a ptr, get an addressable copy of source to modify it later
    addressableSourceCopy = reflect.New(v.Type()).Elem()
    // make a copy of source
  addressableSourceCopy.Set(v)
  accessableField = addressableSourceCopy.FieldByName(fieldName)
  accessableField = reflect.NewAt(accessableField.Type(), unsafe.Pointer(accessableField.UnsafeAddr())).Elem()
  return
}
è¿™æ ·å…¶å®æ˜¯å†…éƒ¨æ„é€ äº†ä¸€ä¸ªå¯¹è¯¥ç»“æ„å…¶å–åœ°å€çš„æŒ‡é’ˆï¼Œä»¥æ»¡è¶³åç»­è°ƒç”¨Elemæ—¶å¯å¯»å€!</p>

<p>éå–åœ°å€ä¿®æ”¹
éå–åœ°å€çš„æ–¹å¼è®¿é—®æ²¡æœ‰é—®é¢˜ï¼Œè¦è¿˜æƒ³ä¿®æ”¹å°±ä¸ä¼šååº”åˆ°åŸå§‹ç»“æ„ä½“ä¸Šäº†</p>

<p>æ¯•ç«Ÿæ˜¯å†…éƒ¨é‡æ–°æ‹·è´äº†ä¸€ä¸ªç»“æ„ä½“è¿›è¡Œçš„æ“ä½œã€‚</p>

<p>å…·ä½“æ“ä½œç±»ä¼¼å–åœ°å€ä¿®æ”¹çš„æ–¹å¼ï¼Œè¿™é‡Œä¸èµ˜è¿°äº†ã€‚</p>

<p>å®é™…ä½¿ç”¨ä¸­ï¼Œè¿˜æ˜¯é€šè¿‡NewAtè·å–å¯è¯»å†™çš„éå¯¼å‡ºå­—æ®µæ›´æ–¹ä¾¿ä¸€äº›ã€‚</p>
:ET