I"E±<p>åœ¨ Golang é‡Œé¢æœ‰ä¸‰ä¸ªåŸºæœ¬çš„æ¦‚å¿µï¼šG, M, Pã€‚</p>

<p>G: Goroutine æ‰§è¡Œçš„ä¸Šä¸‹æ–‡ç¯å¢ƒã€‚
M: æ“ä½œç³»ç»Ÿçº¿ç¨‹ã€‚
P: Processerã€‚è¿›ç¨‹è°ƒåº¦çš„å…³é”®ï¼Œè°ƒåº¦å™¨ï¼Œä¹Ÿå¯ä»¥è®¤ä¸ºçº¦ç­‰äº CPUã€‚
ä¸€ä¸ª Goroutine çš„è¿è¡Œéœ€è¦ G + P + M ä¸‰éƒ¨åˆ†ç»“åˆèµ·æ¥ã€‚å¥½ï¼Œå…ˆç®€å•ä»‹ç»åˆ°è¿™é‡Œï¼Œæ›´è¯¦ç»†çš„æ”¾åœ¨åé¢çš„æ–‡ç« é‡Œé¢æ¥è¯´ã€‚</p>

<ol>
  <li>é€ƒé€¸åˆ†æï¼ˆescape analysisï¼‰
å¯¹äºæ‰‹åŠ¨ç®¡ç†å†…å­˜çš„è¯­è¨€ï¼Œæ¯”å¦‚ C/C++ï¼Œæˆ‘ä»¬ä½¿ç”¨ malloc æˆ–è€… new ç”³è¯·çš„å˜é‡ä¼šè¢«åˆ†é…åˆ°å †ä¸Šã€‚ä½†æ˜¯ Golang å¹¶ä¸æ˜¯è¿™æ ·ï¼Œè™½ç„¶ Golang è¯­è¨€é‡Œé¢ä¹Ÿæœ‰ newã€‚Golang ç¼–è¯‘å™¨å†³å®šå˜é‡åº”è¯¥åˆ†é…åˆ°ä»€ä¹ˆåœ°æ–¹æ—¶ä¼šè¿›è¡Œé€ƒé€¸åˆ†æã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ã€‚
<!-- more -->
package main</li>
</ol>

<p>import ()</p>

<p>func foo() *int {
    var x int
    return &amp;x
}</p>

<p>func bar() int {
    x := new(int)
    *x = 1
    return *x
}</p>

<p>func main() {}</p>

<p>å°†ä¸Šé¢æ–‡ä»¶ä¿å­˜ä¸º escape.goï¼Œæ‰§è¡Œä¸‹é¢å‘½ä»¤
$ go run -gcflags â€˜-m -lâ€™ escape.go
./escape.go:6: moved to heap: x
./escape.go:7: &amp;x escape to heap
./escape.go:11: bar new(int) does not escape
ä¸Šé¢çš„æ„æ€æ˜¯ foo() ä¸­çš„ x æœ€ååœ¨å †ä¸Šåˆ†é…ï¼Œè€Œ bar() ä¸­çš„ x æœ€ååˆ†é…åœ¨äº†æ ˆä¸Šã€‚åœ¨å®˜ç½‘ (golang.org) FAQ ä¸Šæœ‰ä¸€ä¸ªå…³äºå˜é‡åˆ†é…çš„é—®é¢˜å¦‚ä¸‹ï¼š</p>

<p>How do I know whether a variable is allocated on the heap or the stack?
From a correctness standpoint, you donâ€™t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.</p>

<p>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that functionâ€™s stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p>

<p>In the current compilers, if a variable has its address taken, that variable is a candidate for allocation on the heap. However, a basic escape analysis recognizes some cases when such variables will not live past the return from the function and can reside on the stack.</p>

<p>ç®€å•ç¿»è¯‘ä¸€ä¸‹ã€‚</p>

<p>å¦‚ä½•å¾—çŸ¥å˜é‡æ˜¯åˆ†é…åœ¨æ ˆï¼ˆstackï¼‰ä¸Šè¿˜æ˜¯å †ï¼ˆheapï¼‰ä¸Šï¼Ÿ
å‡†ç¡®åœ°è¯´ï¼Œä½ å¹¶ä¸éœ€è¦çŸ¥é“ã€‚Golang ä¸­çš„å˜é‡åªè¦è¢«å¼•ç”¨å°±ä¸€ç›´ä¼šå­˜æ´»ï¼Œå­˜å‚¨åœ¨å †ä¸Šè¿˜æ˜¯æ ˆä¸Šç”±å†…éƒ¨å®ç°å†³å®šè€Œå’Œå…·ä½“çš„è¯­æ³•æ²¡æœ‰å…³ç³»ã€‚</p>

<p>çŸ¥é“å˜é‡çš„å­˜å‚¨ä½ç½®ç¡®å®å’Œæ•ˆç‡ç¼–ç¨‹æœ‰å…³ç³»ã€‚å¦‚æœå¯èƒ½ï¼ŒGolang ç¼–è¯‘å™¨ä¼šå°†å‡½æ•°çš„å±€éƒ¨å˜é‡åˆ†é…åˆ°å‡½æ•°æ ˆå¸§ï¼ˆstack frameï¼‰ä¸Šã€‚ç„¶è€Œï¼Œå¦‚æœç¼–è¯‘å™¨ä¸èƒ½ç¡®ä¿å˜é‡åœ¨å‡½æ•° return ä¹‹åä¸å†è¢«å¼•ç”¨ï¼Œç¼–è¯‘å™¨å°±ä¼šå°†å˜é‡åˆ†é…åˆ°å †ä¸Šã€‚è€Œä¸”ï¼Œå¦‚æœä¸€ä¸ªå±€éƒ¨å˜é‡éå¸¸å¤§ï¼Œé‚£ä¹ˆå®ƒä¹Ÿåº”è¯¥è¢«åˆ†é…åˆ°å †ä¸Šè€Œä¸æ˜¯æ ˆä¸Šã€‚</p>

<p>å½“å‰æƒ…å†µä¸‹ï¼Œå¦‚æœä¸€ä¸ªå˜é‡è¢«å–åœ°å€ï¼Œé‚£ä¹ˆå®ƒå°±æœ‰å¯èƒ½è¢«åˆ†é…åˆ°å †ä¸Šã€‚ç„¶è€Œï¼Œè¿˜è¦å¯¹è¿™äº›å˜é‡åšé€ƒé€¸åˆ†æï¼Œå¦‚æœå‡½æ•° return ä¹‹åï¼Œå˜é‡ä¸å†è¢«å¼•ç”¨ï¼Œåˆ™å°†å…¶åˆ†é…åˆ°æ ˆä¸Šã€‚</p>

<ol>
  <li>å…³é”®æ•°æ®ç»“æ„
å‡ ä¸ªå…³é”®çš„åœ°æ–¹ï¼š</li>
</ol>

<p>mcache: per-P cacheï¼Œå¯ä»¥è®¤ä¸ºæ˜¯ local cacheã€‚
mcentral: å…¨å±€ cacheï¼Œmcache ä¸å¤Ÿç”¨çš„æ—¶å€™å‘ mcentral ç”³è¯·ã€‚
mheap: å½“ mcentral ä¹Ÿä¸å¤Ÿç”¨çš„æ—¶å€™ï¼Œé€šè¿‡ mheap å‘æ“ä½œç³»ç»Ÿç”³è¯·ã€‚
å¯ä»¥å°†å…¶çœ‹æˆå¤šçº§å†…å­˜åˆ†é…å™¨ã€‚</p>

<p>2.1 mcache
æˆ‘ä»¬çŸ¥é“æ¯ä¸ª Gorontine çš„è¿è¡Œéƒ½æ˜¯ç»‘å®šåˆ°ä¸€ä¸ª P ä¸Šé¢ï¼Œmcache æ˜¯æ¯ä¸ª P çš„ cacheã€‚è¿™ä¹ˆåšçš„å¥½å¤„æ˜¯åˆ†é…å†…å­˜æ—¶ä¸éœ€è¦åŠ é”ã€‚mcache ç»“æ„å¦‚ä¸‹ã€‚
// Per-thread (in Go, per-P) cache for small objects.
// No locking needed because it is per-thread (per-P).
type mcache struct {
    // The following members are accessed on every malloc,
    // so they are grouped here for better caching.
    next_sample int32   // trigger heap sample after allocating this many bytes
    local_scan  uintptr // bytes of scannable heap allocated</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å°å¯¹è±¡åˆ†é…å™¨ï¼Œå°äº 16 byte çš„å°å¯¹è±¡éƒ½ä¼šé€šè¿‡ tiny æ¥åˆ†é…ã€‚
tiny             uintptr
tinyoffset       uintptr
local_tinyallocs uintptr // number of tiny allocs not counted in other stats

// The rest is not accessed on every malloc.
alloc [_NumSizeClasses]*mspan // spans to allocate from

stackcache [_NumStackOrders]stackfreelist

// Local allocator stats, flushed during GC.
local_nlookup    uintptr                  // number of pointer lookups
local_largefree  uintptr                  // bytes freed for large objects (&gt;maxsmallsize)
local_nlargefree uintptr                  // number of frees for large objects (&gt;maxsmallsize)
local_nsmallfree [_NumSizeClasses]uintptr // number of frees for small objects (&lt;=maxsmallsize) } æˆ‘ä»¬å¯ä»¥æš‚æ—¶åªå…³æ³¨ alloc [_NumSizeClasses]*mspanï¼Œè¿™æ˜¯ä¸€ä¸ªå¤§å°ä¸º 67 çš„æŒ‡é’ˆï¼ˆæŒ‡é’ˆæŒ‡å‘ mspan ï¼‰æ•°ç»„ï¼ˆ_NumSizeClasses = 67ï¼‰ï¼Œæ¯ä¸ªæ•°ç»„å…ƒç´ ç”¨æ¥åŒ…å«ç‰¹å®šå¤§å°çš„å—ã€‚å½“è¦åˆ†é…å†…å­˜å¤§å°æ—¶ï¼Œä¸º object åœ¨ alloc æ•°ç»„ä¸­é€‰æ‹©åˆé€‚çš„å…ƒç´ æ¥åˆ†é…ã€‚67 ç§å—å¤§å°ä¸º 0ï¼Œ8 byte, 16 byte, â€¦ ï¼Œè¿™ä¸ªå’Œ tcmalloc ç¨æœ‰åŒºåˆ«ã€‚ //file: sizeclasses.go var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768} è¿™é‡Œä»”ç»†æƒ³æœ‰ä¸ªå°é—®é¢˜ï¼Œä¸Šé¢çš„ alloc ç±»ä¼¼å†…å­˜æ± çš„ freelist æ•°ç»„æˆ–è€…é“¾è¡¨ï¼Œæ­£å¸¸å®ç°æ¯ä¸ªæ•°ç»„å…ƒç´ æ˜¯ä¸€ä¸ªé“¾è¡¨ï¼Œé“¾è¡¨ç”±ç‰¹å®šå¤§å°çš„å—ä¸²èµ·æ¥ã€‚ä½†æ˜¯è¿™é‡Œç»Ÿä¸€ä½¿ç”¨äº† mspan ç»“æ„ï¼Œé‚£ä¹ˆåªæœ‰ä¸€ç§å¯èƒ½ï¼Œå°±æ˜¯ mspan ä¸­è®°å½•äº†éœ€è¦åˆ†é…çš„å—å¤§å°ã€‚æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ mspan çš„ç»“æ„ã€‚
</code></pre></div></div>

<p>2.2 mspan
span åœ¨ tcmalloc ä¸­ä½œä¸ºä¸€ç§ç®¡ç†å†…å­˜çš„åŸºæœ¬å•ä½è€Œå­˜åœ¨ã€‚Golang çš„ mspan çš„ç»“æ„å¦‚ä¸‹ï¼Œçœç•¥äº†éƒ¨åˆ†å†…å®¹ã€‚
type mspan struct {
    next *mspan     // next span in list, or nil if none
    prev *mspan     // previous span in list, or nil if none
    list *mSpanList // For debugging. TODO: Remove.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>startAddr     uintptr   // address of first byte of span aka s.base()
npages        uintptr   // number of pages in span
stackfreelist gclinkptr // list of free stacks, avoids overloading freelist
// freeindex is the slot index between 0 and nelems at which to begin scanning
// for the next free object in this span.
freeindex uintptr
// TODO: Look up nelems from sizeclass and remove this field if it
// helps performance.
nelems uintptr // number of object in the span.
...
// ç”¨ä½å›¾æ¥ç®¡ç†å¯ç”¨çš„ free objectï¼Œ1 è¡¨ç¤ºå¯ç”¨
allocCache uint64

...
sizeclass   uint8      // size class
...
elemsize    uintptr    // computed from sizeclass or from npages
... } ä»ä¸Šé¢çš„ç»“æ„å¯ä»¥çœ‹å‡ºï¼š
</code></pre></div></div>

<p>next, prev: æŒ‡é’ˆåŸŸï¼Œå› ä¸º mspan ä¸€èˆ¬éƒ½æ˜¯ä»¥é“¾è¡¨å½¢å¼ä½¿ç”¨ã€‚
npages: mspan çš„å¤§å°ä¸º page å¤§å°çš„æ•´æ•°å€ã€‚
sizeclass: 0 ~ _NumSizeClasses ä¹‹é—´çš„ä¸€ä¸ªå€¼ï¼Œè¿™ä¸ªè§£é‡Šäº†æˆ‘ä»¬çš„ç–‘é—®ã€‚æ¯”å¦‚ï¼Œsizeclass = 3ï¼Œé‚£ä¹ˆè¿™ä¸ª mspan è¢«åˆ†å‰²æˆ 32 byte çš„å—ã€‚
elemsize: é€šè¿‡ sizeclass æˆ–è€… npages å¯ä»¥è®¡ç®—å‡ºæ¥ã€‚æ¯”å¦‚ sizeclass = 3, elemsize = 32 byteã€‚å¯¹äºå¤§äº 32Kb çš„å†…å­˜åˆ†é…ï¼Œéƒ½æ˜¯åˆ†é…æ•´æ•°é¡µï¼Œelemsize = page_size * npagesã€‚
nelems: span ä¸­åŒ…å—çš„æ€»æ•°ç›®ã€‚
freeindex: 0 ~ nelemes-1ï¼Œè¡¨ç¤ºåˆ†é…åˆ°ç¬¬å‡ ä¸ªå—ã€‚
2.3 mcentral
ä¸Šé¢è¯´åˆ°å½“ mcache ä¸å¤Ÿç”¨çš„æ—¶å€™ï¼Œä¼šä» mcentral ç”³è¯·ã€‚é‚£æˆ‘ä»¬ä¸‹é¢å°±æ¥ä»‹ç»ä¸€ä¸‹ mcentralã€‚
type mcentral struct {
    lock      mutex
    sizeclass int32
    nonempty  mSpanList // list of spans with a free object, ie a nonempty free list
    empty     mSpanList // list of spans with no free objects (or cached in an mcache)
}</p>

<p>type mSpanList struct {
    first *mspan
    last  *mspan
}
mcentral åˆ†æï¼š</p>

<p>sizeclass: ä¹Ÿæœ‰æˆå‘˜ sizeclassï¼Œé‚£ä¹ˆ mcentral æ˜¯ä¸æ˜¯ä¹Ÿæœ‰ 67 ä¸ªå‘¢ï¼Ÿæ˜¯çš„ã€‚
lock: å› ä¸ºä¼šæœ‰å¤šä¸ª P è¿‡æ¥ç«äº‰ã€‚
nonempty: mspan çš„åŒå‘é“¾è¡¨ï¼Œå½“å‰ mcentral ä¸­å¯ç”¨çš„ mspan listã€‚
empty: å·²ç»è¢«ä½¿ç”¨çš„ï¼Œå¯ä»¥è®¤ä¸ºæ˜¯ä¸€ç§å¯¹æ‰€æœ‰ mspan çš„ trackã€‚
é—®é¢˜æ¥äº†ï¼Œmcentral å­˜åœ¨äºä»€ä¹ˆåœ°æ–¹ï¼Ÿè™½ç„¶åœ¨ä¸Šé¢æˆ‘ä»¬å°† mcentral å’Œ mheap ä½œä¸ºä¸¤ä¸ªéƒ¨åˆ†æ¥è®²ï¼Œä½†æ˜¯ä½œä¸ºå…¨å±€çš„ç»“æ„ï¼Œè¿™ä¸¤éƒ¨åˆ†æ˜¯å¯ä»¥å®šä¹‰åœ¨ä¸€èµ·çš„ã€‚å®é™…ä¸Šä¹Ÿæ˜¯è¿™æ ·ï¼Œmcentral åŒ…å«åœ¨ mheap ä¸­ã€‚</p>

<p>2.4 mheap
Golang ä¸­çš„ mheap ç»“æ„å®šä¹‰å¦‚ä¸‹ã€‚
type mheap struct {
    lock      mutex
    free      [_MaxMHeapList]mSpanList // free lists of given length
    freelarge mSpanList                // free lists length &gt;= _MaxMHeapList
    busy      [_MaxMHeapList]mSpanList // busy lists of large objects of given length
    busylarge mSpanList                // busy lists of large objects length &gt;= _MaxMHeapList
    sweepgen  uint32                   // sweep generation, see comment in mspan
    sweepdone uint32                   // all spans are swept</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// allspans is a slice of all mspans ever created. Each mspan
// appears exactly once.
//
// The memory for allspans is manually managed and can be
// reallocated and move as the heap grows.
//
// In general, allspans is protected by mheap_.lock, which
// prevents concurrent access as well as freeing the backing
// store. Accesses during STW might not hold the lock, but
// must ensure that allocation cannot happen around the
// access (since that may free the backing store).
allspans []*mspan // all spans out there

// spans is a lookup table to map virtual address page IDs to *mspan.
// For allocated spans, their pages map to the span itself.
// For free spans, only the lowest and highest pages map to the span itself.
// Internal pages map to an arbitrary span.
// For pages that have never been allocated, spans entries are nil.
//
// This is backed by a reserved region of the address space so
// it can grow without moving. The memory up to len(spans) is
// mapped. cap(spans) indicates the total reserved memory.
spans []*mspan

// sweepSpans contains two mspan stacks: one of swept in-use
// spans, and one of unswept in-use spans. These two trade
// roles on each GC cycle. Since the sweepgen increases by 2
// on each cycle, this means the swept spans are in
// sweepSpans[sweepgen/2%2] and the unswept spans are in
// sweepSpans[1-sweepgen/2%2]. Sweeping pops spans from the
// unswept stack and pushes spans that are still in-use on the
// swept stack. Likewise, allocating an in-use span pushes it
// on the swept stack.
sweepSpans [2]gcSweepBuf

_ uint32 // align uint64 fields on 32-bit for atomics

// Proportional sweep
pagesInUse        uint64  // pages of spans in stats _MSpanInUse; R/W with mheap.lock
spanBytesAlloc    uint64  // bytes of spans allocated this cycle; updated atomically
pagesSwept        uint64  // pages swept this cycle; updated atomically
sweepPagesPerByte float64 // proportional sweep ratio; written with lock, read without
// TODO(austin): pagesInUse should be a uintptr, but the 386
// compiler can't 8-byte align fields.

// Malloc stats.
largefree  uint64                  // bytes freed for large objects (&gt;maxsmallsize)
nlargefree uint64                  // number of frees for large objects (&gt;maxsmallsize)
nsmallfree [_NumSizeClasses]uint64 // number of frees for small objects (&lt;=maxsmallsize)

// range of addresses we might see in the heap
bitmap         uintptr // Points to one byte past the end of the bitmap
bitmap_mapped  uintptr
arena_start    uintptr
arena_used     uintptr // always mHeap_Map{Bits,Spans} before updating
arena_end      uintptr
arena_reserved bool

// central free lists for small size classes.
// the padding makes sure that the MCentrals are
// spaced CacheLineSize bytes apart, so that each MCentral.lock
// gets its own cache line.
central [_NumSizeClasses]struct {
    mcentral mcentral
    pad      [sys.CacheLineSize]byte
}

spanalloc             fixalloc // allocator for span*
cachealloc            fixalloc // allocator for mcache*
specialfinalizeralloc fixalloc // allocator for specialfinalizer*
specialprofilealloc   fixalloc // allocator for specialprofile*
speciallock           mutex    // lock for special record allocators. }
</code></pre></div></div>

<p>var mheap_ mheap
mheap_ æ˜¯ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œä¼šåœ¨ç³»ç»Ÿåˆå§‹åŒ–çš„æ—¶å€™åˆå§‹åŒ–ï¼ˆåœ¨å‡½æ•° mallocinit() ä¸­ï¼‰ã€‚æˆ‘ä»¬å…ˆçœ‹ä¸€ä¸‹ mheap å…·ä½“ç»“æ„ã€‚</p>

<p>allspans []*mspan: æ‰€æœ‰çš„ spans éƒ½æ˜¯é€šè¿‡ mheap_ ç”³è¯·ï¼Œæ‰€æœ‰ç”³è¯·è¿‡çš„ mspan éƒ½ä¼šè®°å½•åœ¨ allspansã€‚ç»“æ„ä½“ä¸­çš„ lock å°±æ˜¯ç”¨æ¥ä¿è¯å¹¶å‘å®‰å…¨çš„ã€‚æ³¨é‡Šä¸­æœ‰å…³äº STW çš„è¯´æ˜ï¼Œè¿™ä¸ªä¹‹åä¼šåœ¨ Golang çš„ GC æ–‡ç« ä¸­ç»†è¯´ã€‚</p>

<p>central [_NumSizeClasses]â€¦: è¿™ä¸ªå°±æ˜¯ä¹‹å‰ä»‹ç»çš„ mcentral ï¼Œæ¯ç§å¤§å°çš„å—å¯¹åº”ä¸€ä¸ª mcentralã€‚mcentral ä¸Šé¢ä»‹ç»è¿‡äº†ã€‚pad å¯ä»¥è®¤ä¸ºæ˜¯ä¸€ä¸ªå­—èŠ‚å¡«å……ï¼Œä¸ºäº†é¿å…ä¼ªå…±äº«ï¼ˆfalse sharingï¼‰é—®é¢˜çš„ã€‚False Sharing å¯ä»¥å‚è€ƒ False Sharing - wikipediaï¼Œè¿™é‡Œå°±ä¸ç»†è¯´äº†ã€‚</p>

<p>sweepgen, sweepdone: GC ç›¸å…³ã€‚ï¼ˆGolang çš„ GC ç­–ç•¥æ˜¯ Mark &amp; Sweep, è¿™é‡Œæ˜¯ç”¨æ¥è¡¨ç¤º sweep çš„ï¼Œè¿™é‡Œå°±ä¸å†æ·±å…¥äº†ã€‚ï¼‰</p>

<p>free [_MaxMHeapList]mSpanList: è¿™æ˜¯ä¸€ä¸ª SpanList æ•°ç»„ï¼Œæ¯ä¸ª SpanList é‡Œé¢çš„ mspan ç”± 1 ~ 127 (_MaxMHeapList - 1) ä¸ª page ç»„æˆã€‚æ¯”å¦‚ free[3] æ˜¯ç”±åŒ…å« 3 ä¸ª page çš„ mspan ç»„æˆçš„é“¾è¡¨ã€‚free è¡¨ç¤ºçš„æ˜¯ free listï¼Œä¹Ÿå°±æ˜¯æœªåˆ†é…çš„ã€‚å¯¹åº”çš„è¿˜æœ‰ busy listã€‚</p>

<p>freelarge mSpanList: mspan ç»„æˆçš„é“¾è¡¨ï¼Œæ¯ä¸ªå…ƒç´ ï¼ˆä¹Ÿå°±æ˜¯ mspanï¼‰çš„ page ä¸ªæ•°å¤§äº 127ã€‚å¯¹åº”çš„è¿˜æœ‰ busylargeã€‚</p>

<p>spans []*mspan: è®°å½• arena åŒºåŸŸé¡µå·ï¼ˆpage numberï¼‰å’Œ mspan çš„æ˜ å°„å…³ç³»ã€‚</p>

<p>arena_start, arena_end, arena_used: è¦è§£é‡Šè¿™å‡ ä¸ªå˜é‡ä¹‹å‰è¦è§£é‡Šä¸€ä¸‹ arenaã€‚arena æ˜¯ Golang ä¸­ç”¨äºåˆ†é…å†…å­˜çš„è¿ç»­è™šæ‹Ÿåœ°å€åŒºåŸŸã€‚ç”± mheap ç®¡ç†ï¼Œå †ä¸Šç”³è¯·çš„æ‰€æœ‰å†…å­˜éƒ½æ¥è‡ª arenaã€‚é‚£ä¹ˆå¦‚ä½•æ ‡å¿—å†…å­˜å¯ç”¨å‘¢ï¼Ÿæ“ä½œç³»ç»Ÿçš„å¸¸è§åšæ³•ç”¨ä¸¤ç§ï¼šä¸€ç§æ˜¯ç”¨é“¾è¡¨å°†æ‰€æœ‰çš„å¯ç”¨å†…å­˜éƒ½ä¸²èµ·æ¥ï¼›å¦ä¸€ç§æ˜¯ä½¿ç”¨ä½å›¾æ¥æ ‡å¿—å†…å­˜å—æ˜¯å¦å¯ç”¨ã€‚ç»“åˆä¸Šé¢ä¸€æ¡ spansï¼Œå†…å­˜çš„å¸ƒå±€æ˜¯ä¸‹é¢è¿™æ ·çš„ã€‚
+â€”â€”â€”â€”â€”â€”â€”â€“+â€”â€”â€”â€”â€”â€”â€”+â€”â€”â€”â€”â€”â€”â€”â€“+
|    spans              |    bitmap           |   arena               |
+â€”â€”â€”â€”â€”â€”â€”â€“+â€”â€”â€”â€”â€”â€”â€”+â€”â€”â€”â€”â€”â€”â€”â€“+
spanalloc, cachealloc fixalloc: fixalloc æ˜¯ free-listï¼Œç”¨æ¥åˆ†é…ç‰¹å®šå¤§å°çš„å—ã€‚</p>

<p>å‰©ä¸‹çš„æ˜¯ä¸€äº›ç»Ÿè®¡ä¿¡æ¯å’Œ GC ç›¸å…³çš„ä¿¡æ¯ï¼Œè¿™é‡Œæš‚ä¸”æŒ‰ä½ä¸è¡¨ï¼Œä»¥åä¸“é—¨æ‹¿å‡ºæ¥è¯´ã€‚</p>

<ol>
  <li>
    <p>åˆå§‹åŒ–
åœ¨ç³»ç»Ÿåˆå§‹åŒ–é˜¶æ®µï¼Œä¸Šé¢ä»‹ç»çš„å‡ ä¸ªç»“æ„ä¼šè¢«è¿›è¡Œåˆå§‹åŒ–ï¼Œæˆ‘ä»¬ç›´æ¥çœ‹ä¸€ä¸‹åˆå§‹åŒ–ä»£ç ï¼šmallocinit()ã€‚
func mallocinit() {
 //ä¸€äº›ç³»ç»Ÿæ£€æµ‹ä»£ç ï¼Œç•¥å»
 var p, bitmapSize, spansSize, pSize, limit uintptr
 var reserved bool</p>

    <p>// limit = runtime.memlimit();
 // See https://golang.org/issue/5049
 // TODO(rsc): Fix after 1.1.
 limit = 0</p>

    <p>//ç³»ç»ŸæŒ‡é’ˆå¤§å° PtrSize = 8ï¼Œè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ª 64 ä½ç³»ç»Ÿã€‚
 if sys.PtrSize == 8 &amp;&amp; (limit == 0 || limit &gt; 1Â«30) {
     //è¿™é‡Œçš„ arenaSize, bitmapSize, spansSize åˆ†åˆ«å¯¹åº” mheap é‚£ä¸€å°èŠ‚é‡Œé¢æåˆ° arena åŒºå¤§å°ï¼Œbitmap åŒºå¤§å°ï¼Œspans åŒºå¤§å°ã€‚
     arenaSize := round(_MaxMem, _PageSize)
     bitmapSize = arenaSize / (sys.PtrSize * 8 / 2)
     spansSize = arenaSize / _PageSize * sys.PtrSize
     spansSize = round(spansSize, _PageSize)
     //å°è¯•ä»ä¸åŒåœ°å€å¼€å§‹ç”³è¯·
     for i := 0; i &lt;= 0x7f; i++ {
         switch {
         case GOARCH == â€œarm64â€ &amp;&amp; GOOS == â€œdarwinâ€:
             p = uintptr(i)Â«40 | uintptrMask&amp;(0x0013Â«28)
         case GOARCH == â€œarm64â€:
             p = uintptr(i)Â«40 | uintptrMask&amp;(0x0040Â«32)
         default:
             p = uintptr(i)Â«40 | uintptrMask&amp;(0x00c0Â«32)
         }
         pSize = bitmapSize + spansSize + arenaSize + _PageSize
         //å‘ OS ç”³è¯·å¤§å°ä¸º pSize çš„è¿ç»­çš„è™šæ‹Ÿåœ°å€ç©ºé—´
         p = uintptr(sysReserve(unsafe.Pointer(p), pSize, &amp;reserved))
         if p != 0 {
             break
         }
     }
 }
 //è¿™é‡Œæ˜¯ 32 ä½ç³»ç»Ÿä»£ç å¯¹åº”çš„æ“ä½œï¼Œç•¥å»ã€‚
 â€¦</p>

    <p>p1 := round(p, _PageSize)</p>

    <p>spansStart := p1
 mheap_.bitmap = p1 + spansSize + bitmapSize
 if sys.PtrSize == 4 {
     // Set arena_start such that we can accept memory
     // reservations located anywhere in the 4GB virtual space.
     mheap_.arena_start = 0
 } else {
     mheap_.arena_start = p1 + (spansSize + bitmapSize)
 }
 mheap_.arena_end = p + pSize
 mheap_.arena_used = p1 + (spansSize + bitmapSize)
 mheap_.arena_reserved = reserved</p>

    <p>if mheap_.arena_start&amp;(<em>PageSize-1) != 0 {
     println(â€œbad pagesizeâ€, hex(p), hex(p1), hex(spansSize), hex(bitmapSize), hex(_PageSize), â€œstartâ€, hex(mheap</em>.arena_start))
     throw(â€œmisrounded allocation in mallocinitâ€)
 }</p>

    <p>// Initialize the rest of the allocator.
 mheap_.init(spansStart, spansSize)
 <em>g</em> := getg()
 <em>g</em>.m.mcache = allocmcache()
}
ä¸Šé¢å¯¹ä»£ç åšäº†ç®€å•çš„æ³¨é‡Šï¼Œä¸‹é¢è¯¦ç»†è§£è¯´å…¶ä¸­çš„éƒ¨åˆ†åŠŸèƒ½å‡½æ•°ã€‚</p>
  </li>
</ol>

<p>3.1 arena ç›¸å…³
arena ç›¸å…³åœ°å€çš„å¤§å°åˆå§‹åŒ–ä»£ç å¦‚ä¸‹ã€‚
arenaSize := round(_MaxMem, _PageSize)
bitmapSize = arenaSize / (sys.PtrSize * 8 / 2)
spansSize = arenaSize / _PageSize * sys.PtrSize
spansSize = round(spansSize, _PageSize)</p>

<p>_MaxMem = uintptr(1Â«_MHeapMap_TotalBits - 1)
é¦–å…ˆè§£é‡Šä¸€ä¸‹å˜é‡ _MaxMem ï¼Œé‡Œé¢è¿˜æœ‰ä¸€ä¸ªå˜é‡å°±ä¸å†åˆ—å‡ºæ¥äº†ã€‚ç®€å•æ¥è¯´ _MaxMem å°±æ˜¯ç³»ç»Ÿä¸º arena åŒºåˆ†é…çš„å¤§å°ï¼š64 ä½ç³»ç»Ÿåˆ†é… 512 Gï¼›å¯¹äº Windows 64 ä½ç³»ç»Ÿï¼Œarena åŒºåˆ†é… 32 Gã€‚round æ˜¯ä¸€ä¸ªå¯¹é½æ“ä½œï¼Œå‘ä¸Šå– _PageSize çš„å€æ•°ã€‚å®ç°ä¹Ÿå¾ˆæœ‰æ„æ€ï¼Œä»£ç å¦‚ä¸‹ã€‚
// round n up to a multiple of a.  a must be a power of 2.
func round(n, a uintptr) uintptr {
    return (n + a - 1) &amp;^ (a - 1)
}
bitmap ç”¨ä¸¤ä¸ª bit è¡¨ç¤ºä¸€ä¸ªå­—çš„å¯ç”¨çŠ¶æ€ï¼Œé‚£ä¹ˆç®—ä¸‹æ¥ bitmap çš„å¤§å°ä¸º 16 Gã€‚è¯»è¿‡ Golang æºç çš„åŒå­¦ä¼šå‘ç°å…¶å®è¿™æ®µä»£ç çš„æ³¨é‡Šé‡Œå†™çš„ bitmap çš„å¤§å°ä¸º 32 Gã€‚å…¶å®æ˜¯è¿™æ®µæ³¨é‡Šå¾ˆä¹…æ²¡æœ‰æ›´æ–°äº†ï¼Œä¹‹å‰æ˜¯ç”¨ 4 ä¸ª bit æ¥è¡¨ç¤ºä¸€ä¸ªå­—çš„å¯ç”¨çŠ¶æ€ï¼Œè¿™çœŸæ˜¯ä¸€ä¸ªæ‚²ä¼¤çš„æ•…äº‹å•Šã€‚</p>

<p>spans è®°å½•çš„ arena åŒºçš„å—é¡µå·å’Œå¯¹åº”çš„ mspan æŒ‡é’ˆçš„å¯¹åº”å…³ç³»ã€‚æ¯”å¦‚ arena åŒºå†…å­˜åœ°å€ xï¼Œå¯¹åº”çš„é¡µå·å°±æ˜¯ page_num = (x - arena_start) / page_sizeï¼Œé‚£ä¹ˆ spans å°±ä¼šè®°å½• spans[page_num] = xã€‚å¦‚æœ arena ä¸º 512 Gçš„è¯ï¼Œspans åŒºçš„å¤§å°ä¸º 512 G / 8K * 8 = 512 Mã€‚è¿™é‡Œå€¼å¾—æ³¨æ„çš„æ˜¯ Golang çš„å†…å­˜ç®¡ç†è™šæ‹Ÿåœ°å€é¡µå¤§å°ä¸º 8kã€‚
_PageSize = 1 Â«Â _PageShift</p>

<p>_PageShift = 13
æ‰€ä»¥è¿™ä¸€æ®µè¿ç»­çš„çš„è™šæ‹Ÿå†…å­˜å¸ƒå±€ï¼ˆ64 ä½ï¼‰å¦‚ä¸‹ï¼š
+â€”â€”â€”â€”â€”â€”â€”â€“+â€”â€”â€”â€”â€”â€”â€”+â€”â€”â€”â€”â€”â€”â€”â€“+
|    spans 512M         |    bitmap 16G       |   arena 512           |
+â€”â€”â€”â€”â€”â€”â€”â€“+â€”â€”â€”â€”â€”â€”â€”+â€”â€”â€”â€”â€”â€”â€”â€“+
3.2 è™šæ‹Ÿåœ°å€ç”³è¯·
ä¸»è¦æ˜¯ä¸‹é¢è¿™æ®µä»£ç ã€‚
//å°è¯•ä»ä¸åŒåœ°å€å¼€å§‹ç”³è¯·
for i := 0; i &lt;= 0x7f; i++ {
    switch {
    case GOARCH == â€œarm64â€ &amp;&amp; GOOS == â€œdarwinâ€:
        p = uintptr(i)Â«40 | uintptrMask&amp;(0x0013Â«28)
    case GOARCH == â€œarm64â€:
        p = uintptr(i)Â«40 | uintptrMask&amp;(0x0040Â«32)
    default:
        p = uintptr(i)Â«40 | uintptrMask&amp;(0x00c0Â«32)
    }
    pSize = bitmapSize + spansSize + arenaSize + _PageSize
    //å‘ OS ç”³è¯·å¤§å°ä¸º pSize çš„è¿ç»­çš„è™šæ‹Ÿåœ°å€ç©ºé—´
    p = uintptr(sysReserve(unsafe.Pointer(p), pSize, &amp;reserved))
    if p != 0 {
        break
    }
}
åˆå§‹åŒ–çš„æ—¶å€™ï¼ŒGolang å‘æ“ä½œç³»ç»Ÿç”³è¯·ä¸€æ®µè¿ç»­çš„åœ°å€ç©ºé—´ï¼Œå°±æ˜¯ä¸Šé¢çš„ spans + bitmap + arenaã€‚p å°±æ˜¯è¿™æ®µè¿ç»­åœ°å€ç©ºé—´çš„å¼€å§‹åœ°å€ï¼Œä¸åŒå¹³å°çš„ p å–å€¼ä¸ä¸€æ ·ã€‚åƒ OS ç”³è¯·çš„æ—¶å€™è§†ä¸åŒçš„ OS ç‰ˆæœ¬ï¼Œè°ƒç”¨ä¸åŒçš„ç³»ç»Ÿè°ƒç”¨ï¼Œæ¯”å¦‚ Unix ç³»ç»Ÿè°ƒç”¨ mmap (mmap æƒ³æ“ä½œç³»ç»Ÿå†…æ ¸ç”³è¯·æ–°çš„è™šæ‹Ÿåœ°å€åŒºé—´ï¼Œå¯æŒ‡å®šèµ·å§‹åœ°å€å’Œé•¿åº¦)ï¼ŒWindows ç³»ç»Ÿè°ƒç”¨ VirtualAlloc ï¼ˆç±»ä¼¼ mmapï¼‰ã€‚
//bsd
func sysReserve(v unsafe.Pointer, n uintptr, reserved *bool) unsafe.Pointer {
    if sys.PtrSize == 8 &amp;&amp; uint64(n) &gt; 1Â«32 || sys.GoosNacl != 0 {
        *reserved = false
        return v
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
if uintptr(p) &lt; 4096 {
    return nil
}
*reserved = true
return p }
</code></pre></div></div>

<p>//darwin
func sysReserve(v unsafe.Pointer, n uintptr, reserved *bool) unsafe.Pointer {
    *reserved = true
    p := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
    if uintptr(p) &lt; 4096 {
        return nil
    }
    return p
}</p>

<p>//linux
func sysReserve(v unsafe.Pointer, n uintptr, reserved *bool) unsafe.Pointer {
    â€¦
    p := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)
    if uintptr(p) &lt; 4096 {
        return nil
    }
    *reserved = true
    return p
}
//windows
func sysReserve(v unsafe.Pointer, n uintptr, reserved *bool) unsafe.Pointer {
    *reserved = true
    // v is just a hint.
    // First try at v.
    v = unsafe.Pointer(stdcall4(_VirtualAlloc, uintptr(v), n, _MEM_RESERVE, _PAGE_READWRITE))
    if v != nil {
        return v
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Next let the kernel choose the address.
return unsafe.Pointer(stdcall4(_VirtualAlloc, 0, n, _MEM_RESERVE, _PAGE_READWRITE)) } 3.3 mheap åˆå§‹åŒ– æˆ‘ä»¬ä¸Šé¢ä»‹ç» mheap ç»“æ„çš„æ—¶å€™çŸ¥é“ spans, bitmap, arena éƒ½æ˜¯å­˜åœ¨äº mheap ä¸­çš„ï¼Œä»æ“ä½œç³»ç»Ÿç”³è¯·å®Œåœ°å€ä¹‹åå°±æ˜¯åˆå§‹åŒ– mheap äº†ã€‚ func mallocinit() {
...
p1 := round(p, _PageSize)

spansStart := p1
mheap_.bitmap = p1 + spansSize + bitmapSize
if sys.PtrSize == 4 {
    // Set arena_start such that we can accept memory
    // reservations located anywhere in the 4GB virtual space.
    mheap_.arena_start = 0
} else {
    mheap_.arena_start = p1 + (spansSize + bitmapSize)
}
mheap_.arena_end = p + pSize
mheap_.arena_used = p1 + (spansSize + bitmapSize)
mheap_.arena_reserved = reserved

if mheap_.arena_start&amp;(_PageSize-1) != 0 {
    println("bad pagesize", hex(p), hex(p1), hex(spansSize), hex(bitmapSize), hex(_PageSize), "start", hex(mheap_.arena_start))
    throw("misrounded allocation in mallocinit")
}

// Initialize the rest of the allocator.
mheap_.init(spansStart, spansSize)
//è·å–å½“å‰ G
_g_ := getg()
// è·å– G ä¸Šç»‘å®šçš„ M çš„ mcache
_g_.m.mcache = allocmcache() } p æ˜¯ä»è¿ç»­è™šæ‹Ÿåœ°å€çš„èµ·å§‹åœ°å€ï¼Œå…ˆè¿›è¡Œå¯¹é½ï¼Œç„¶ååˆå§‹åŒ– arenaï¼Œbitmapï¼Œspans åœ°å€ã€‚mheap_.init()ä¼šåˆå§‹åŒ– fixalloc ç­‰ç›¸å…³çš„æˆå‘˜ï¼Œè¿˜æœ‰ mcentral çš„åˆå§‹åŒ–ã€‚ func (h *mheap) init(spansStart, spansBytes uintptr) {
h.spanalloc.init(unsafe.Sizeof(mspan{}), recordspan, unsafe.Pointer(h), &amp;memstats.mspan_sys)
h.cachealloc.init(unsafe.Sizeof(mcache{}), nil, nil, &amp;memstats.mcache_sys)
h.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer{}), nil, nil, &amp;memstats.other_sys)
h.specialprofilealloc.init(unsafe.Sizeof(specialprofile{}), nil, nil, &amp;memstats.other_sys)

h.spanalloc.zero = false

// h-&gt;mapcache needs no init
for i := range h.free {
    h.free[i].init()
    h.busy[i].init()
}

h.freelarge.init()
h.busylarge.init()
for i := range h.central {
    h.central[i].mcentral.init(int32(i))
}

sp := (*slice)(unsafe.Pointer(&amp;h.spans))
sp.array = unsafe.Pointer(spansStart)
sp.len = 0
sp.cap = int(spansBytes / sys.PtrSize) } mheap åˆå§‹åŒ–ä¹‹åï¼Œå¯¹å½“å‰çš„çº¿ç¨‹ä¹Ÿå°±æ˜¯ M è¿›è¡Œåˆå§‹åŒ–ã€‚ //è·å–å½“å‰ G _g_ := getg() // è·å– G ä¸Šç»‘å®šçš„ M çš„ mcache _g_.m.mcache = allocmcache() 3.4 per-P mcache åˆå§‹åŒ– ä¸Šé¢å¥½åƒå¹¶æ²¡æœ‰è¯´åˆ°é’ˆå¯¹ P çš„ mcache åˆå§‹åŒ–ï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™è¿˜æ²¡æœ‰åˆå§‹åŒ– Pã€‚æˆ‘ä»¬çœ‹ä¸€ä¸‹ bootstrap çš„ä»£ç ã€‚ func schedinit() {
...
mallocinit()
...

if procs &gt; _MaxGomaxprocs {
    procs = _MaxGomaxprocs
}
if procresize(procs) != nil {
    ...
} } å…¶ä¸­ mallocinit() ä¸Šé¢è¯´è¿‡äº†ã€‚å¯¹ P çš„åˆå§‹åŒ–åœ¨å‡½æ•° procresize() ä¸­æ‰§è¡Œï¼Œæˆ‘ä»¬ä¸‹é¢åªçœ‹å†…å­˜ç›¸å…³çš„éƒ¨åˆ†ã€‚ func procresize(nprocs int32) *p {
...
// initialize new P's
for i := int32(0); i &lt; nprocs; i++ {
    pp := allp[i]
    if pp == nil {
        pp = new(p)
        pp.id = i
        pp.status = _Pgcstop
        pp.sudogcache = pp.sudogbuf[:0]
        for i := range pp.deferpool {
            pp.deferpool[i] = pp.deferpoolbuf[i][:0]
        }
        atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))
    }
    // P mcache åˆå§‹åŒ–
    if pp.mcache == nil {
        if old == 0 &amp;&amp; i == 0 {
            if getg().m.mcache == nil {
                throw("missing mcache?")
            }
            // P[0] åˆ†é…ç»™ä¸» Goroutine
            pp.mcache = getg().m.mcache // bootstrap
        } else {
            // P[0] ä¹‹å¤–çš„ P ç”³è¯· mcache
            pp.mcache = allocmcache()
        }
    }
    ...
}
... } æ‰€æœ‰çš„ P éƒ½å­˜æ”¾åœ¨ä¸€ä¸ªå…¨å±€æ•°ç»„ allp ä¸­ï¼Œprocresize() çš„ç›®çš„å°±æ˜¯å°† allp ä¸­ç”¨åˆ°çš„ P è¿›è¡Œåˆå§‹åŒ–ï¼ŒåŒæ—¶å¯¹å¤šä½™ P çš„èµ„æºå‰¥ç¦»ã€‚
</code></pre></div></div>

<ol>
  <li>å†…å­˜åˆ†é…
å…ˆè¯´ä¸€ä¸‹ç»™å¯¹è±¡ object åˆ†é…å†…å­˜çš„ä¸»è¦æµç¨‹ï¼š</li>
</ol>

<p>object size &gt; 32Kï¼Œåˆ™ä½¿ç”¨ mheap ç›´æ¥åˆ†é…ã€‚
object size &lt; 16 byteï¼Œä½¿ç”¨ mcache çš„å°å¯¹è±¡åˆ†é…å™¨ tiny ç›´æ¥åˆ†é…ã€‚ ï¼ˆå…¶å® tiny å°±æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œæš‚ä¸”è¿™ä¹ˆè¯´å§ã€‚ï¼‰
object size &gt; 16 byte &amp;&amp; size &lt;=32K byte æ—¶ï¼Œå…ˆä½¿ç”¨ mcache ä¸­å¯¹åº”çš„ size class åˆ†é…ã€‚
å¦‚æœ mcache å¯¹åº”çš„ size class çš„ span å·²ç»æ²¡æœ‰å¯ç”¨çš„å—ï¼Œåˆ™å‘ mcentral è¯·æ±‚ã€‚
å¦‚æœ mcentral ä¹Ÿæ²¡æœ‰å¯ç”¨çš„å—ï¼Œåˆ™å‘ mheap ç”³è¯·ï¼Œå¹¶åˆ‡åˆ†ã€‚
å¦‚æœ mheap ä¹Ÿæ²¡æœ‰åˆé€‚çš„ spanï¼Œåˆ™æƒ³æ“ä½œç³»ç»Ÿç”³è¯·ã€‚
æˆ‘ä»¬çœ‹ä¸€ä¸‹åœ¨å †ä¸Šï¼Œä¹Ÿå°±æ˜¯ arena åŒºåˆ†é…å†…å­˜çš„ç›¸å…³å‡½æ•°ã€‚
package main</p>

<p>func foo() *int {
    x := 1
    return &amp;x
}</p>

<p>func main() {
    x := foo()
    println(*x)
}
æ ¹æ®ä¹‹å‰ä»‹ç»çš„é€ƒé€¸åˆ†æï¼Œfoo() ä¸­çš„ x ä¼šè¢«åˆ†é…åˆ°å †ä¸Šã€‚æŠŠä¸Šé¢ä»£ç ä¿å­˜ä¸º test1.go çœ‹ä¸€ä¸‹æ±‡ç¼–ä»£ç ã€‚
$ go build -gcflags â€˜-lâ€™ -o test1 test1.go
$ go tool objdump -s â€œmain.fooâ€ test1
TEXT main.foo(SB) /Users/didi/code/go/malloc_example/test2.go
    test2.go:3  0x2040  65488b0c25a0080000  GS MOVQ GS:0x8a0, CX
    test2.go:3  0x2049  483b6110        CMPQ 0x10(CX), SP
    test2.go:3  0x204d  762a            JBE 0x2079
    test2.go:3  0x204f  4883ec10        SUBQ $0x10, SP
    test2.go:4  0x2053  488d1d66460500      LEAQ 0x54666(IP), BX
    test2.go:4  0x205a  48891c24        MOVQ BX, 0(SP)
    test2.go:4  0x205e  e82d8f0000      CALL runtime.newobject(SB)
    test2.go:4  0x2063  488b442408      MOVQ 0x8(SP), AX
    test2.go:4  0x2068  48c70001000000      MOVQ $0x1, 0(AX)
    test2.go:5  0x206f  4889442418      MOVQ AX, 0x18(SP)
    test2.go:5  0x2074  4883c410        ADDQ $0x10, SP
    test2.go:5  0x2078  c3          RET
    test2.go:3  0x2079  e8a28d0400      CALL runtime.morestack_noctxt(SB)
    test2.go:3  0x207e  ebc0            JMP main.foo(SB)
å †ä¸Šå†…å­˜åˆ†é…è°ƒç”¨äº† runtime åŒ…çš„ newobject å‡½æ•°ã€‚
func newobject(typ *_type) unsafe.Pointer {
    return mallocgc(typ.size, typ, true)
}</p>

<p>func mallocgc(size uintptr, typ <em>_type, needzero bool) unsafe.Pointer {
    â€¦ 
    c := gomcache()
    var x unsafe.Pointer
    noscan := typ == nil || typ.kind&amp;kindNoPointers != 0
    if size &lt;= maxSmallSize {
        // object size &lt;= 32K
        if noscan &amp;&amp; size &lt; maxTinySize {
            // å°äº 16 byte çš„å°å¯¹è±¡åˆ†é…
            off := c.tinyoffset
            // Align tiny pointer for required (conservative) alignment.
            if size&amp;7 == 0 {
                off = round(off, 8)
            } else if size&amp;3 == 0 {
                off = round(off, 4)
            } else if size&amp;1 == 0 {
                off = round(off, 2)
            }
            if off+size &lt;= maxTinySize &amp;&amp; c.tiny != 0 {
                // The object fits into existing tiny block.
                x = unsafe.Pointer(c.tiny + off)
                c.tinyoffset = off + size
                c.local_tinyallocs++
                mp.mallocing = 0
                releasem(mp)
                return x
            }
            // Allocate a new maxTinySize block.
            span := c.alloc[tinySizeClass]
            v := nextFreeFast(span)
            if v == 0 {
                v, _, shouldhelpgc = c.nextFree(tinySizeClass)
            }
            x = unsafe.Pointer(v)
            (</em>[2]uint64)(x)[0] = 0
            (*[2]uint64)(x)[1] = 0
            // See if we need to replace the existing tiny block with the new one
            // based on amount of remaining free space.
            if size &lt; c.tinyoffset || c.tiny == 0 {
                c.tiny = uintptr(x)
                c.tinyoffset = size
            }
            size = maxTinySize
        } else {
            // object size &gt;= 16 byte  &amp;&amp; object size &lt;= 32K byte
            var sizeclass uint8
            if size &lt;= smallSizeMax-8 {
                sizeclass = size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]
            } else {
                sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]
            }
            size = uintptr(class_to_size[sizeclass])
            span := c.alloc[sizeclass]
            v := nextFreeFast(span)
            if v == 0 {
                v, span, shouldhelpgc = c.nextFree(sizeclass)
            }
            x = unsafe.Pointer(v)
            if needzero &amp;&amp; span.needzero != 0 {
                memclrNoHeapPointers(unsafe.Pointer(v), size)
            }
        }
    } else {
        //object size &gt; 32K byte
        var s *mspan
        shouldhelpgc = true
        systemstack(func() {
            s = largeAlloc(size, needzero)
        })
        s.freeindex = 1
        s.allocCount = 1
        x = unsafe.Pointer(s.base())
        size = s.elemsize
    }
}
æ•´ä¸ªåˆ†é…è¿‡ç¨‹å¯ä»¥æ ¹æ® object size æ‹†è§£æˆä¸‰éƒ¨åˆ†ï¼šsize &lt; 16 byte, 16 byte &lt;= size &lt;= 32 K byte, size &gt; 32 K byteã€‚</p>

<p>4.1 size å°äº 16 byte
å¯¹äºå°äº 16 byte çš„å†…å­˜å—ï¼Œmcache æœ‰ä¸ªä¸“é—¨çš„å†…å­˜åŒºåŸŸ tiny ç”¨æ¥åˆ†é…ï¼Œtiny æ˜¯æŒ‡é’ˆï¼ŒæŒ‡å‘å¼€å§‹åœ°å€ã€‚
func mallocgc(â€¦) {
    â€¦
            off := c.tinyoffset
            // åœ°å€å¯¹é½
            if size&amp;7 == 0 {
                off = round(off, 8)
            } else if size&amp;3 == 0 {
                off = round(off, 4)
            } else if size&amp;1 == 0 {
                off = round(off, 2)
            }
            // åˆ†é…
            if off+size &lt;= maxTinySize &amp;&amp; c.tiny != 0 {
                // The object fits into existing tiny block.
                x = unsafe.Pointer(c.tiny + off)
                c.tinyoffset = off + size
                c.local_tinyallocs++
                mp.mallocing = 0
                releasem(mp)
                return x
            }
            // tiny ä¸å¤Ÿäº†ï¼Œä¸ºå…¶é‡æ–°åˆ†é…ä¸€ä¸ª 16 byte å†…å­˜å—
            span := c.alloc[tinySizeClass]
            v := nextFreeFast(span)
            if v == 0 {
                v, _, shouldhelpgc = c.nextFree(tinySizeClass)
            }
            x = unsafe.Pointer(v)
            //å°†ç”³è¯·çš„å†…å­˜å—å…¨ç½®ä¸º 0
            (<em>[2]uint64)(x)[0] = 0
            (</em>[2]uint64)(x)[1] = 0
            // See if we need to replace the existing tiny block with the new one
            // based on amount of remaining free space.
            // å¦‚æœç”³è¯·çš„å†…å­˜å—ç”¨ä¸å®Œï¼Œåˆ™å°†å‰©ä¸‹çš„ç»™ tinyï¼Œç”¨ tinyoffset è®°å½•åˆ†é…äº†å¤šå°‘ã€‚
            if size &lt; c.tinyoffset || c.tiny == 0 {
                c.tiny = uintptr(x)
                c.tinyoffset = size
            }
            size = maxTinySize
}
å¦‚ä¸Šæ‰€ç¤ºï¼Œtinyoffset è¡¨ç¤º tiny å½“å‰åˆ†é…åˆ°ä»€ä¹ˆåœ°å€äº†ï¼Œä¹‹åçš„åˆ†é…æ ¹æ® tinyoffset å¯»å€ã€‚å…ˆæ ¹æ®è¦åˆ†é…çš„å¯¹è±¡å¤§å°è¿›è¡Œåœ°å€å¯¹é½ï¼Œæ¯”å¦‚ size æ˜¯ 8 çš„å€æ•°ï¼Œtinyoffset å’Œ 8 å¯¹é½ã€‚ç„¶åå°±æ˜¯è¿›è¡Œåˆ†é…ã€‚å¦‚æœ tiny å‰©ä½™çš„ç©ºé—´ä¸å¤Ÿç”¨ï¼Œåˆ™é‡æ–°ç”³è¯·ä¸€ä¸ª 16 byte çš„å†…å­˜å—ï¼Œå¹¶åˆ†é…ç»™ objectã€‚å¦‚æœæœ‰ç»“ä½™ï¼Œåˆ™è®°å½•åœ¨ tiny ä¸Šã€‚</p>

<p>4.2 size å¤§äº 32 K byte
å¯¹äºå¤§äº 32 Kb çš„å†…å­˜åˆ†é…ï¼Œç›´æ¥è·³è¿‡ mcache å’Œ mcentralï¼Œé€šè¿‡ mheap åˆ†é…ã€‚
func mallocgc(â€¦) {
    } else {
        var s *mspan
        shouldhelpgc = true
        systemstack(func() {
            s = largeAlloc(size, needzero)
        })
        s.freeindex = 1
        s.allocCount = 1
        x = unsafe.Pointer(s.base())
        size = s.elemsize
    }
    â€¦
}</p>

<p>func largeAlloc(size uintptr, needzero bool) *mspan {
    â€¦
    npages := sizeÂ Â» <em>PageShift
    if size&amp;_PageMask != 0 {
        npages++
    }
    â€¦
    s := mheap</em>.alloc(npages, 0, true, needzero)
    if s == nil {
        throw(â€œout of memoryâ€)
    }
    s.limit = s.base() + size
    heapBitsForSpan(s.base()).initSpan(s)
    return s
}
å¯¹äºå¤§äº 32 K çš„å†…å­˜åˆ†é…éƒ½æ˜¯åˆ†é…æ•´æ•°é¡µï¼Œå…ˆå³ç§»ç„¶åä½ä½ä¸è®¡ç®—éœ€è¦çš„é¡µæ•°ã€‚</p>

<p>4.3 size ä»‹äº 16 å’Œ 32K
å¯¹äº size ä»‹äº 16 ~ 32K byte çš„å†…å­˜åˆ†é…å…ˆè®¡ç®—åº”è¯¥åˆ†é…çš„ sizeclassï¼Œç„¶åå» mcache é‡Œé¢ alloc[sizeclass] ç”³è¯·ï¼Œå¦‚æœ mcache.alloc[sizeclass] ä¸è¶³ä»¥ç”³è¯·ï¼Œåˆ™ mcache å‘ mcentral ç”³è¯·ï¼Œç„¶åå†åˆ†é…ã€‚mcentral ç»™ mcache åˆ†é…å®Œä¹‹åä¼šåˆ¤æ–­è‡ªå·±éœ€ä¸éœ€è¦æ‰©å……ï¼Œå¦‚æœéœ€è¦åˆ™æƒ³ mheap ç”³è¯·ã€‚
func mallocgc(â€¦) {
        â€¦
        } else {
            var sizeclass uint8</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        //è®¡ç®— sizeclass
        if size &lt;= smallSizeMax-8 {
            sizeclass = size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]
        } else {
            sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv-       1)/largeSizeDiv]
        }
        size = uintptr(class_to_size[sizeclass])
        span := c.alloc[sizeclass]
        //ä»å¯¹åº”çš„ span é‡Œé¢åˆ†é…ä¸€ä¸ª object 
        v := nextFreeFast(span)
        if v == 0 {
            v, span, shouldhelpgc = c.nextFree(sizeclass)
        }
        x = unsafe.Pointer(v)
        if needzero &amp;&amp; span.needzero != 0 {
            memclrNoHeapPointers(unsafe.Pointer(v), size)
        }
    } } æˆ‘ä»¬é¦–å…ˆçœ‹ä¸€ä¸‹å¦‚ä½•è®¡ç®— sizeclass çš„ï¼Œé¢„å…ˆå®šä¹‰äº†ä¸¤ä¸ªæ•°ç»„ï¼šsize_to_class8 å’Œ size_to_class128ã€‚ æ•°ç»„ size_to_class8ï¼Œå…¶ç¬¬ i ä¸ªå€¼è¡¨ç¤ºåœ°å€åŒºé—´ ( (i-1)*8, i*8 ] (smallSizeDiv = 8) å¯¹åº”çš„ sizeclassï¼Œsize_to_class128 ç±»ä¼¼ã€‚å°äº 1024 - 8 = 1016 ï¼ˆsmallSizeMax=1024ï¼‰ï¼Œä½¿ç”¨ size_to_class8ï¼Œå¦åˆ™ä½¿ç”¨æ•°ç»„ size_to_class128ã€‚çœ‹ä¸€ä¸‹æ•°ç»„å…·ä½“çš„å€¼ï¼š0, 1, 2, 3, 3, 4, 4â€¦ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œæ¯”å¦‚è¦åˆ†é… 17 byte çš„å†…å­˜ ï¼ˆ16 byte ä»¥ä¸‹çš„ä½¿ç”¨ mcache.tiny åˆ†é…ï¼‰ï¼Œsizeclass = size_to_calss8[(17+7)/8] = size_to_class8[3] = 3ã€‚ä¸å¾—ä¸è¯´è¿™ç§ç”¨ç©ºé—´æ¢æ—¶é—´çš„ç­–ç•¥ç¡®å®æé«˜äº†è¿è¡Œæ•ˆç‡ã€‚
</code></pre></div></div>

<p>è®¡ç®—å‡º sizeclassï¼Œé‚£ä¹ˆå°±å¯ä»¥å» mcache.alloc[sizeclass] åˆ†é…äº†ï¼Œæ³¨æ„è¿™æ˜¯ä¸€ä¸ª mspan æŒ‡é’ˆï¼ŒçœŸæ­£çš„åˆ†é…å‡½æ•°æ˜¯ nextFreeFast() å‡½æ•°ã€‚å¦‚ä¸‹ã€‚
// nextFreeFast returns the next free object if one is quickly available.
// Otherwise it returns 0.
func nextFreeFast(s <em>mspan) gclinkptr {
    theBit := sys.Ctz64(s.allocCache) // Is there a free object in the allocCache?
    if theBit &lt; 64 {
        result := s.freeindex + uintptr(theBit)
        if result &lt; s.nelems {
            freeidx := result + 1
            if freeidx%64 == 0 &amp;&amp; freeidx != s.nelems {
                return 0
            }
            s.allocCacheÂ Â»= (theBit + 1)
            s.freeindex = freeidx
            v := gclinkptr(result</em>s.elemsize + s.base())
            s.allocCount++
            return v
        }
    }
    return 0
}
allocCache è¿™é‡Œæ˜¯ç”¨ä½å›¾è¡¨ç¤ºå†…å­˜æ˜¯å¦å¯ç”¨ï¼Œ1 è¡¨ç¤ºå¯ç”¨ã€‚ç„¶åé€šè¿‡ span é‡Œé¢çš„ freeindex å’Œ elemsize æ¥è®¡ç®—åœ°å€å³å¯ã€‚</p>

<p>å¦‚æœ mcache.alloc[sizeclass] å·²ç»ä¸å¤Ÿç”¨äº†ï¼Œåˆ™ä» mcentral ç”³è¯·å†…å­˜åˆ° mcacheã€‚
// nextFree returns the next free object from the cached span if one is available.
// Otherwise it refills the cache with a span with an available object and
// returns that object along with a flag indicating that this was a heavy
// weight allocation. If it is a heavy weight allocation the caller must
// determine whether a new GC cycle needs to be started or if the GC is active
// whether this goroutine needs to assist the GC.
func (c *mcache) nextFree(sizeclass uint8) (v gclinkptr, s *mspan, shouldhelpgc bool) {
    s = c.alloc[sizeclass]
    shouldhelpgc = false
    freeIndex := s.nextFreeIndex()
    if freeIndex == s.nelems {
        // The span is full.
        if uintptr(s.allocCount) != s.nelems {
            println(â€œruntime: s.allocCount=â€, s.allocCount, â€œs.nelems=â€, s.nelems)
            throw(â€œs.allocCount != s.nelems &amp;&amp; freeIndex == s.nelemsâ€)
        }
        systemstack(func() {
            // è¿™ä¸ªåœ°æ–¹ mcache å‘ mcentral ç”³è¯·
            c.refill(int32(sizeclass))
        })
        shouldhelpgc = true
        s = c.alloc[sizeclass]
        // mcache å‘ mcentral ç”³è¯·å®Œä¹‹åï¼Œå†æ¬¡ä» mcache ç”³è¯·
        freeIndex = s.nextFreeIndex()
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>... }
</code></pre></div></div>

<p>// nextFreeIndex returns the index of the next free object in s at
// or after s.freeindex.
// There are hardware instructions that can be used to make this
// faster if profiling warrants it.
// è¿™ä¸ªå‡½æ•°å’Œ nextFreeFast æœ‰ç‚¹å†—ä½™äº†
func (s *mspan) nextFreeIndex() uintptr {
    â€¦
}
mcache å‘ mcentralï¼Œå¦‚æœ mcentral ä¸å¤Ÿï¼Œåˆ™å‘ mheap ç”³è¯·ã€‚
func (c *mcache) refill(sizeclass int32) *mspan {
    â€¦
    // å‘ mcentral ç”³è¯·
    s = mheap_.central[sizeclass].mcentral.cacheSpan()
    â€¦
    return s
}</p>

<p>// Allocate a span to use in an MCache.
func (c *mcentral) cacheSpan() *mspan {
    â€¦
    // Replenish central list if empty.
    s = c.grow()
}</p>

<p>func (c *mcentral) grow() *mspan {
    npages := uintptr(class_to_allocnpages[c.sizeclass])
    size := uintptr(class_to_size[c.sizeclass])
    n := (npages Â«Â _PageShift) / size</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//è¿™é‡Œæƒ³ mheap ç”³è¯·
s := mheap_.alloc(npages, c.sizeclass, false, true)
...
return s } å¦‚æœ mheap ä¸è¶³ï¼Œåˆ™æƒ³ OS ç”³è¯·ã€‚æ¥ä¸Šé¢çš„ä»£ç  mheap_.alloc() func (h *mheap) alloc(npage uintptr, sizeclass int32, large bool, needzero bool) *mspan {
...
var s *mspan
systemstack(func() {
    s = h.alloc_m(npage, sizeclass, large)
})
... }
</code></pre></div></div>

<p>func (h *mheap) alloc_m(npage uintptr, sizeclass int32, large bool) *mspan {
    â€¦ 
    s := h.allocSpanLocked(npage)
    â€¦
}</p>

<p>func (h *mheap) allocSpanLocked(npage uintptr) *mspan {
    â€¦
    s = h.allocLarge(npage)
    if s == nil {
        if !h.grow(npage) {
            return nil
        }
        s = h.allocLarge(npage)
        if s == nil {
            return nil
        }
    }
    â€¦
}</p>

<p>func (h *mheap) grow(npage uintptr) bool {
    // Ask for a big chunk, to reduce the number of mappings
    // the operating system needs to track; also amortizes
    // the overhead of an operating system mapping.
    // Allocate a multiple of 64kB.
    npage = round(npage, (64Â«10)/_PageSize)
    ask := npage Â«Â _PageShift
    if ask &lt; _HeapAllocChunk {
        ask = _HeapAllocChunk
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v := h.sysAlloc(ask)
... } æ•´ä¸ªå‡½æ•°è°ƒç”¨é“¾å¦‚ä¸Šæ‰€ç¤ºï¼Œæœ€å sysAlloc ä¼šè°ƒç”¨ç³»ç»Ÿè°ƒç”¨ï¼ˆmmap æˆ–è€… VirtualAllocï¼Œå’Œåˆå§‹åŒ–é‚£éƒ¨åˆ†æœ‰ç‚¹ç±»ä¼¼ï¼‰å»å‘æ“ä½œç³»ç»Ÿç”³è¯·ã€‚
</code></pre></div></div>

<ol>
  <li>å†…å­˜å›æ”¶
è¿™é‡Œåªä¼šä»‹ç»ä¸€äº›ç®€å•çš„å†…å­˜å›æ”¶ï¼Œæ›´è¯¦ç»†çš„åƒåœ¾å›æ”¶ä¹‹åä¼šå•ç‹¬å†™ä¸€ç¯‡æ–‡ç« æ¥è®²ã€‚</li>
</ol>

<p>5.1 mcache å›æ”¶
mcache å›æ”¶å¯ä»¥åˆ†ä¸¤éƒ¨åˆ†ï¼šç¬¬ä¸€éƒ¨åˆ†æ˜¯å°† alloc ä¸­æœªç”¨å®Œçš„å†…å­˜å½’è¿˜ç»™å¯¹åº”çš„ mcentralã€‚
func freemcache(c *mcache) {
    systemstack(func() {
        c.releaseAll()
        â€¦</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    lock(&amp;mheap_.lock)
    purgecachedstats(c)
    mheap_.cachealloc.free(unsafe.Pointer(c))
    unlock(&amp;mheap_.lock)
}) }
</code></pre></div></div>

<p>func (c <em>mcache) releaseAll() {
    for i := 0; i &lt; _NumSizeClasses; i++ {
        s := c.alloc[i]
        if s != &amp;emptymspan {
            mheap_.central[i].mcentral.uncacheSpan(s)
            c.alloc[i] = &amp;emptymspan
        }
    }
    // Clear tinyalloc pool.
    c.tiny = 0
    c.tinyoffset = 0
}
å‡½æ•° releaseAll() è´Ÿè´£å°† mcache.alloc ä¸­å„ä¸ª sizeclass ä¸­çš„ mspan å½’è¿˜ç»™ mcentralã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯å½’è¿˜ç»™ mcentral çš„æ—¶å€™éœ€è¦åŠ é”ï¼Œå› ä¸º mcentral æ˜¯å…¨å±€çš„ã€‚é™¤æ­¤ä¹‹å¤–å°†å‰©ä¸‹çš„ mcache ï¼ˆåŸºæœ¬æ˜¯ä¸ªç©ºå£³ï¼‰å½’è¿˜ç»™ mheap.cacheallocï¼Œå…¶å®å°±æ˜¯æŠŠ mcache æ’å…¥ free list è¡¨å¤´ã€‚
func (f *fixalloc) free(p unsafe.Pointer) {
    f.inuse -= f.size
    v := (</em>mlink)(p)
    v.next = f.list
    f.list = v
}
5.2 mcentral å›æ”¶
å½“ mspan æ²¡æœ‰ free object çš„æ—¶å€™ï¼Œå°† mspan å½’è¿˜ç»™ mheapã€‚
func (c *mcentral) freeSpan(s *mspan, preserve bool, wasempty bool) bool {
    â€¦
    lock(&amp;c.lock)
    â€¦
    if s.allocCount != 0 {
        unlock(&amp;c.lock)
        return false
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c.nonempty.remove(s)
unlock(&amp;c.lock)
mheap_.freeSpan(s, 0)
return true } 5.3 mheap mheap å¹¶ä¸ä¼šå®šæ—¶å‘æ“ä½œç³»ç»Ÿå½’è¿˜ï¼Œä½†æ˜¯ä¼šå¯¹ span åšä¸€äº›æ“ä½œï¼Œæ¯”å¦‚åˆå¹¶ç›¸é‚»çš„ spanã€‚
</code></pre></div></div>

<ol>
  <li>æ€»ç»“
tcmalloc æ˜¯ä¸€ç§ç†è®ºï¼Œè¿ç”¨åˆ°å®è·µä¸­è¿˜è¦è€ƒè™‘å·¥ç¨‹å®ç°çš„é—®é¢˜ã€‚å­¦ä¹  Golang æºç çš„è¿‡ç¨‹ä¸­ï¼Œé™¤äº†çŸ¥é“å®ƒæ˜¯å¦‚ä½•å·¥ä½œçš„ä¹‹å¤–ï¼Œè¿˜å¯ä»¥å­¦ä¹ åˆ°å¾ˆå¤šæœ‰è¶£çš„çŸ¥è¯†ï¼Œæ¯”å¦‚ä½¿ç”¨å˜é‡å¡«å…… CacheLine é¿å… False Sharingï¼Œåˆ©ç”¨ debruijn åºåˆ—æ±‚è§£ Trailing Zeroï¼ˆåœ¨å‡½æ•°ä¸­ sys.Ctz64 ä½¿ç”¨ï¼‰ç­‰ç­‰ã€‚</li>
</ol>

<p>goçš„å†…å­˜ç®¡ç†å’Œtcmallocï¼ˆthread-caching mallocï¼‰å¾ˆåƒï¼Œä¸å¦¨å…ˆçœ‹çœ‹tcmallocçš„å®ç°ã€‚</p>

<p>tcmallocæ˜¯ä»€ä¹ˆ
tcmallocæ˜¯googleæ¨å‡ºçš„ä¸€ç§å†…å­˜åˆ†é…å™¨ï¼Œå¸¸è§çš„å†…å­˜åˆ†é…å™¨è¿˜æœ‰glibcçš„ptmallocå’Œgoogleçš„jemallocã€‚ç›¸æ¯”äºptmallocï¼Œtcmallocæ€§èƒ½æ›´å¥½ï¼Œç‰¹åˆ«é€‚ç”¨äºé«˜å¹¶å‘åœºæ™¯ã€‚</p>

<p>tcmallocå…·ä½“ç­–ç•¥
tcmallocåˆ†é…çš„å†…å­˜ä¸»è¦æ¥è‡ªä¸¤ä¸ªåœ°æ–¹ï¼šå…¨å±€ç¼“å­˜å †å’Œè¿›ç¨‹çš„ç§æœ‰ç¼“å­˜ã€‚å¯¹äºä¸€äº›å°å®¹é‡çš„å†…å­˜ç”³è¯·è¯•ç”¨è¿›ç¨‹çš„ç§æœ‰ç¼“å­˜ï¼Œç§æœ‰ç¼“å­˜ä¸è¶³çš„æ—¶å€™å¯ä»¥å†ä»å…¨å±€ç¼“å­˜ç”³è¯·ä¸€éƒ¨åˆ†ä½œä¸ºç§æœ‰ç¼“å­˜ã€‚å¯¹äºå¤§å®¹é‡çš„å†…å­˜ç”³è¯·åˆ™éœ€è¦ä»å…¨å±€ç¼“å­˜ä¸­è¿›è¡Œç”³è¯·ã€‚è€Œå¤§å°å®¹é‡çš„è¾¹ç•Œå°±æ˜¯32kã€‚ç¼“å­˜çš„ç»„ç»‡æ–¹å¼æ˜¯ä¸€ä¸ªå•é“¾è¡¨æ•°ç»„ï¼Œæ•°ç»„çš„æ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªå•é“¾è¡¨ï¼Œé“¾è¡¨ä¸­çš„æ¯ä¸ªå…ƒç´ å…·æœ‰ç›¸åŒçš„å¤§å°ã€‚</p>

<p>Small Object Allocation
å°å¯¹è±¡å†…å­˜åˆ†é…é»˜è®¤ä¼šåˆ†é…86ä¸ªä¸åŒå¤§å°çš„å—ï¼Œè€Œè¿™äº›å—çš„å¤§å°å¹¶æ²¡æœ‰æ˜ç¡®è¯´æ˜ï¼Œéœ€è¦æŸ¥ä¸€ä¸‹æºç ã€‚æ¯ç§å¤§å°çš„å—çš„æ•°ç»„çš„é•¿åº¦éƒ½é‡‡ç”¨ä½¿ç”¨äº†æ‰åˆå§‹åŒ–ï¼Œæœ‰ç‚¹ç±»ä¼¼äºlazy-initializeã€‚</p>

<p>Big Object Allocation
å¯¹äºå¤§äº32kçš„å†…å­˜ç”³è¯·ï¼Œä½¿ç”¨å…¨å±€å†…å­˜æ¥åˆ†é…ã€‚å…¨å±€å†…å­˜çš„ç»„ç»‡ä¹Ÿæ˜¯å•é“¾è¡¨æ•°ç»„ï¼Œæ•°ç»„é•¿åº¦ä¸º256ï¼Œåˆ†åˆ«å¯¹ç”¨1 pageå¤§å°, 2 pageå¤§å°ï¼ˆ1 page=4kï¼‰.</p>

<p>Span
tcmallocä½¿ç”¨spanæ¥ç®¡ç†å†…å­˜åˆ†é¡µï¼Œä¸€ä¸ªspanå¯ä»¥åŒ…å«å‡ ä¸ªè¿ç»­åˆ†é¡µã€‚spançš„çŠ¶æ€åªæœ‰æœªåˆ†é…ã€ä½œä¸ºå¤§å¯¹è±¡åˆ†é…ã€ä½œä¸ºå°å¯¹è±¡åˆ†é…ã€‚</p>

<p>goçš„å†…å­˜åˆ†é…
goè¯­è¨€çš„å†…å­˜åˆ†é…å¹¶ä¸æ˜¯å’Œtcmallocä¸€æ¨¡ä¸€æ ·ã€‚</p>

<p>å±€éƒ¨ç¼“å­˜å¹¶ä¸æ˜¯åˆ†é…ç»™è¿›ç¨‹æˆ–è€…çº¿ç¨‹ï¼Œè€Œæ˜¯åˆ†é…ç»™Pï¼ˆè¿™ä¸ªè¿˜éœ€è¦è¯´ä¸€ä¸‹goçš„goroutineå®ç°ï¼‰
goçš„GCæ˜¯stop the worldï¼Œå¹¶ä¸æ˜¯æ¯ä¸ªè¿›ç¨‹å•ç‹¬è¿›è¡ŒGCã€‚
spançš„ç®¡ç†æ›´æœ‰æ•ˆç‡
http://goog-perftools.sourceforge.net/doc/tcmalloc.html</p>
:ET