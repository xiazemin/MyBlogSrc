I"ß×<p>CASåŸå­æ“ä½œã€‚
éœ€è¦æœ‰ä¸€ç§é˜»å¡å’Œå”¤é†’æœºåˆ¶ã€‚
å°½é‡å‡å°‘é˜»å¡å’Œå”¤é†’åˆ‡æ¢æˆæœ¬ã€‚
é”å°½é‡å…¬å¹³ï¼Œåæ¥è€…è¦æ’é˜Ÿã€‚å³ä½¿è¢«åæ¥è€…æ’é˜Ÿäº†ï¼Œä¹Ÿè¦ç…§é¡¾å…ˆæ¥è€…ï¼Œä¸èƒ½æœ‰â€œé¥¥é¥¿â€ç°è±¡ã€‚
å…ˆçœ‹3ï¼Œ4ç‚¹ã€‚å†çœ‹2ï¼Œ1ç‚¹ã€‚æœ€åæ˜¯æºç ã€‚
<!-- more -->
å°½é‡å‡å°‘é˜»å¡å’Œå”¤é†’åˆ‡æ¢æˆæœ¬
å‡å°‘åˆ‡æ¢æˆæœ¬çš„æ–¹æ³•å°±æ˜¯ä¸åˆ‡æ¢ï¼Œç®€å•è€Œç›´æ¥ã€‚</p>

<p>ä¸åˆ‡æ¢çš„æ–¹å¼å°±æ˜¯è®©ç«äº‰è€…è‡ªæ—‹ã€‚è‡ªæ—‹ä¸€ä¼šå„¿ï¼Œç„¶åæŠ¢é”ã€‚ä¸æˆåŠŸå°±å†è‡ªæ—‹ã€‚åˆ°è¾¾ä¸Šé™æ¬¡æ•°æ‰é˜»å¡ã€‚</p>

<p>è‡ªæ—‹å°±æ˜¯CPUç©ºè½¬ä¸€å®šçš„æ—¶é’Ÿå‘¨æœŸ</p>

<p>ä¸åŒå¹³å°ä¸Šè‡ªæ—‹æ‰€ç”¨çš„æŒ‡ä»¤ä¸ä¸€æ ·ã€‚ä¾‹å¦‚åœ¨amd64å¹³å°ä¸‹ï¼Œæ±‡ç¼–çš„å®ç°å¦‚ä¸‹</p>

<p>TEXT runtimeÂ·procyield(SB),NOSPLIT,$0-0
  MOVL  cycles+0(FP), AX
again:
    // è‡ªæ—‹cyclesæ¬¡ï¼Œæ¯æ¬¡è‡ªæ—‹æ‰§è¡ŒPAUSEæŒ‡ä»¤
  PAUSE
  SUBL  $1, AX
  JNZ  again
  RET
æ˜¯å¦å…è®¸è‡ªæ—‹çš„åˆ¤æ–­æ˜¯ä¸¥æ ¼çš„ã€‚è€Œä¸”æœ€å¤šè‡ªæ—‹å››æ¬¡ï¼Œæ¯æ¬¡30ä¸ªCPUæ—¶é’Ÿå‘¨æœŸã€‚</p>

<table>
  <tbody>
    <tr>
      <td>èƒ½ä¸èƒ½è‡ªæ—‹å…¨ç”±è¿™ä¸ªæ¡ä»¶è¯­å¥å†³å®šif old&amp;(mutexLocked</td>
      <td>mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter)ã€‚</td>
    </tr>
  </tbody>
</table>

<p>ç¿»è¯‘ä¸‹ï¼Œå°±æ˜¯ä¸‹é¢çš„æ¡ä»¶éƒ½æ»¡è¶³ï¼Œæ‰å…è®¸è‡ªæ—‹ã€‚</p>

<p>é”å·²è¢«å ç”¨ï¼Œå¹¶ä¸”é”ä¸å¤„äºé¥¥é¥¿æ¨¡å¼ã€‚</p>

<p>ç§¯ç´¯çš„è‡ªæ—‹æ¬¡æ•°å°äºæœ€å¤§è‡ªæ—‹æ¬¡æ•°ï¼ˆactive_spin=4ï¼‰ã€‚</p>

<p>cpuæ ¸æ•°å¤§äº1ã€‚</p>

<p>æœ‰ç©ºé—²çš„Pã€‚</p>

<p>å½“å‰goroutineæ‰€æŒ‚è½½çš„Pä¸‹ï¼Œæœ¬åœ°å¾…è¿è¡Œé˜Ÿåˆ—ä¸ºç©ºã€‚</p>

<p>å¯ä»¥çœ‹åˆ°è‡ªæ—‹è¦æ±‚ä¸¥æ ¼ï¼Œæ¯•ç«Ÿåœ¨é”ç«äº‰æ¿€çƒˆæ—¶ï¼Œè¿˜æ— é™åˆ¶åœ°è‡ªæ—‹å°±è‚¯å®šä¼šå½±å“å…¶ä»–goroutineã€‚</p>

<p>const   active_spin     = 4
func sync_runtime_canSpin(i int) bool {
  // è‡ªæ—‹æ¬¡æ•°ä¸èƒ½å¤§äº active_spin(4) æ¬¡
  // cpuæ ¸æ•°åªæœ‰ä¸€ä¸ªï¼Œä¸èƒ½è‡ªæ—‹
  // æ²¡æœ‰ç©ºé—²çš„päº†ï¼Œä¸èƒ½è‡ªæ—‹
  if i &gt;= active_spin || ncpu &lt;= 1 || gomaxprocs &lt;= int32(sched.npidle+sched.nmspinning)+1 {
    return false
  }
  // å½“å‰gç»‘å®šçš„pé‡Œé¢æœ¬åœ°å¾…è¿è¡Œé˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œä¸èƒ½è‡ªæ—‹
  if p := getg().m.p.ptr(); !runqempty(p) {
    return false
  }
  return true
}</p>

<p>é”æ¨¡å¼ä»‹ç»
ä¸Šé¢çš„å‡ºç°äº†ä¸¤ä¸ªå¸¸é‡ï¼ŒmutexStarvingå’ŒmutexLockedã€‚å®ƒä»¬ä¸é”å¯¹è±¡ç»“æ„æœ‰å…³ã€‚æ¯”è¾ƒåŸºç¡€ï¼Œè¿™é‡Œä»‹ç»ä¸€ä¸‹ã€‚</p>

<p>type Mutex struct {
  // [é˜»å¡çš„goroutineä¸ªæ•°, starvingæ ‡è¯†, wokenæ ‡è¯†, lockedæ ‡è¯†]
  state int32
  sema  uint32
}
Mutexç»“æ„ç®€å•çš„å°±åªæœ‰ä¸¤ä¸ªæˆå‘˜å˜é‡ã€‚semaæ˜¯ä¿¡å·é‡ï¼Œä¸‹æ–‡ä¼šä»‹ç»åˆ°ã€‚è¿™é‡Œä¸»è¦ä»‹ç»stateçš„ç»“æ„ã€‚</p>

<p>ä¸€ä¸ª32ä½çš„å˜é‡ï¼Œè¢«åˆ’åˆ†æˆä¸Šå›¾çš„æ ·å­ã€‚å³è¾¹çš„æ ‡è¯†ä¹Ÿæœ‰å¯¹åº”çš„å¸¸é‡</p>

<p>const (
  mutexLocked = 1 Â«Â iota // mutex is locked
  mutexWoken  <br />
  mutexStarving 
  mutexWaiterShift = iota
)</p>

<p>å«ä¹‰å¦‚ä¸‹ï¼š</p>

<p>mutexLockedå¯¹åº”å³è¾¹ä½ä½ç¬¬ä¸€ä¸ªbitã€‚å€¼ä¸º1ï¼Œè¡¨ç¤ºé”è¢«å ç”¨ã€‚å€¼ä¸º0ï¼Œè¡¨ç¤ºé”æœªè¢«å ç”¨ã€‚</p>

<p>mutexWokenå¯¹åº”å³è¾¹ä½ä½ç¬¬äºŒä¸ªbitã€‚å€¼ä¸º1ï¼Œè¡¨ç¤ºæ‰“ä¸Šå”¤é†’æ ‡è®°ã€‚å€¼ä¸º0ï¼Œè¡¨ç¤ºæ²¡æœ‰å”¤é†’æ ‡è®°ã€‚</p>

<p>mutexStarvingå¯¹åº”å³è¾¹ä½ä½ç¬¬ä¸‰ä¸ªbitã€‚å€¼ä¸º1ï¼Œè¡¨ç¤ºé”å¤„äºé¥¥é¥¿æ¨¡å¼ã€‚å€¼ä¸º0ï¼Œè¡¨ç¤ºé”å­˜äºæ­£å¸¸æ¨¡å¼ã€‚</p>

<p>mutexWaiterShiftæ˜¯åç§»é‡ã€‚å®ƒå€¼ä¸º3ã€‚ç”¨æ³•æ˜¯stateÂ»=mutexWaiterShiftä¹‹åï¼Œstateçš„å€¼å°±è¡¨ç¤ºå½“å‰é˜»å¡ç­‰å¾…é”çš„goroutineä¸ªæ•°ã€‚æœ€å¤šå¯ä»¥é˜»å¡2^29ä¸ªgoroutineã€‚</p>

<p>Mutexé”åˆ†ä¸ºä¸¤ç§æ¨¡å¼ï¼Œæ­£å¸¸æ¨¡å¼ å’Œ é¥¥é¥¿æ¨¡å¼ã€‚</p>

<p>æ­£å¸¸æ¨¡å¼ä¸‹ï¼Œå¯¹äºæ–°æ¥çš„goroutineè€Œè¨€ï¼Œå®ƒæœ‰ä¸¤ç§é€‰æ‹©ï¼Œè¦ä¹ˆæŠ¢åˆ°äº†é”ï¼Œç›´æ¥æ‰§è¡Œï¼›è¦ä¹ˆæŠ¢ä¸åˆ°é”ï¼Œè¿½åŠ åˆ°é˜»å¡é˜Ÿåˆ—å°¾éƒ¨ï¼Œç­‰å¾…è¢«å”¤é†’çš„ã€‚</p>

<p>é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œå¯¹äºæ–°æ¥çš„goroutineï¼Œå®ƒåªæœ‰ä¸€ä¸ªé€‰æ‹©ï¼Œå°±æ˜¯è¿½åŠ åˆ°é˜»å¡é˜Ÿåˆ—å°¾éƒ¨ï¼Œç­‰å¾…è¢«å”¤é†’çš„ã€‚è€Œä¸”åœ¨è¯¥æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰é”ç«äº‰è€…éƒ½ä¸èƒ½è‡ªæ—‹ã€‚</p>

<p>é™¤äº†è¿™ä¸¤ç§æ¨¡å¼ã€‚è¿˜æœ‰ä¸€ä¸ªWoken(å”¤é†’æ ‡è®°)ã€‚å®ƒä¸»è¦ç”¨äºè‡ªæ—‹çŠ¶æ€çš„é€šçŸ¥å’Œé”å…¬å¹³æ€§çš„ä¿è¯ã€‚åˆ†ä¸¤ä¸ªè§’åº¦ç†è§£ï¼š</p>

<p>ä¸€ã€æ–°çš„goroutineç”³è¯·é”æ—¶ï¼Œå‘ç°é”è¢«å ç”¨äº†ã€‚ä½†è‡ªå·±æ»¡è¶³è‡ªæ—‹æ¡ä»¶ï¼Œäºæ˜¯è‡ªå·±è‡ªæ—‹ï¼Œå¹¶è®¾ç½®ä¸Šçš„Wokenæ ‡è®°ã€‚æ­¤æ—¶å ç”¨é”çš„goroutineåœ¨é‡Šæ”¾é”æ—¶ï¼Œæ£€æŸ¥Wokenæ ‡è®°ï¼Œå¦‚æœè¢«æ ‡è®°ã€‚å“ªæ€•ç°åœ¨é”ä¸Šé¢çš„é˜»å¡é˜Ÿåˆ—ä¸ä¸ºç©ºï¼Œä¹Ÿä¸åšå”¤é†’ã€‚ç›´æ¥returnï¼Œè®©è‡ªæ—‹ç€çš„goroutineæœ‰æ›´å¤§æœºä¼šæŠ¢åˆ°é”ã€‚</p>

<p>if oldÂ»mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
    return
}
äºŒã€é‡Šæ”¾é”æ—¶ï¼Œæ£€æŸ¥Wokenæ ‡è®°ä¸ºç©ºã€‚è€Œé˜»å¡é˜Ÿåˆ—é‡Œæœ‰goroutineéœ€è¦è¢«å”¤é†’ã€‚é‚£ä¹ˆåœ¨å”¤é†’æ—¶ï¼ŒåŒæ—¶æ ‡è®°é”Wokenã€‚è¿™é‡Œå¯èƒ½æœ‰ç–‘é—®ï¼ŒåŸæ¥æ²¡æœ‰Wokenæ ‡è®°ï¼Œä¸ºä»€ä¹ˆåœ¨å”¤é†’ä¸€ä¸ªgoroutineè¦ä¸»åŠ¨æ ‡è®°å‘¢ï¼Ÿç›®çš„æ˜¯ä¿è¯é”å…¬å¹³ã€‚</p>

<p>è€ƒè™‘è¿™æ ·çš„åœºæ™¯ï¼šç°åœ¨é˜»å¡é˜Ÿåˆ—é‡Œåªæœ‰ä¸€ä¸ªgoroutineã€‚æŠŠå®ƒå”¤é†’åï¼Œè¿˜å¾—ç­‰è°ƒåº¦å™¨è¿è¡Œåˆ°å®ƒï¼Œå®ƒè‡ªå·±å†å»æŠ¢é”ã€‚ä½†åœ¨è°ƒåº¦å™¨è¿è¡Œåˆ°å®ƒä¹‹å‰ï¼Œå¾ˆå¯èƒ½æ–°çš„ç«äº‰è€…å‚ä¸è¿›æ¥ï¼Œæ­¤æ—¶é”è¢«æŠ¢èµ°çš„æ¦‚ç‡å°±å¾ˆå¤§ã€‚</p>

<p>è¿™æœ‰å¤±å…¬å¹³ï¼Œè¢«é˜»å¡çš„goroutineæ˜¯å…ˆåˆ°è€…ï¼Œæ–°çš„ç«äº‰è€…æ˜¯åæ¥è€…ã€‚åº”è¯¥å°½é‡è®©å®ƒä»¬ä¸€èµ·ç«äº‰ã€‚</p>

<p>// å”¤é†’ä¸€ä¸ªé˜»å¡çš„goroutineï¼Œå¹¶æŠŠé”çš„Wokenæ ‡è®°è®¾ç½®ä¸Š
new = (old - 1Â«mutexWaiterShift) | mutexWoken
è®¾ç½®Wokenæ ‡è®°åï¼Œstateå°±è‚¯å®šä¸ä¸ºé›¶ã€‚æ­¤æ—¶æ–°æ¥çš„ç«äº‰è€…ï¼Œåœ¨æ‰§è¡ŒLock()çš„fast-pathæ—¶ä¼šå¤±è´¥ï¼Œæ¥ä¸‹æ¥å°±åªèƒ½ä¹–ä¹–æ’é˜Ÿäº†ã€‚</p>

<p>func (m *Mutex) Lock() {
  // Fast path: grab unlocked mutex.
  // Wokenæ ‡è®°è®¾ç½®åï¼Œè¿™é‡Œçš„CASå°±ä¼šä¸ºfalse
  if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
    // â€¦
    return
  }
  // æ¥ä¸‹æ¥åœ¨é˜»å¡é‡Œæ’é˜Ÿ
}
å°æ€»ç»“ï¼šä¸ºäº†å‡å°‘åˆ‡æ¢æˆæœ¬ï¼ŒçŸ­æš‚çš„è‡ªæ—‹ç­‰å¾…æ˜¯ç®€å•çš„æ–¹æ³•ã€‚è€Œç«äº‰è€…åœ¨è‡ªæ—‹æ—¶ï¼Œè¦ä¸»åŠ¨è®¾ç½®Wokenæ ‡è®°ã€‚è¿™æ ·é‡Šæ”¾è€…æ‰èƒ½æ„ŸçŸ¥åˆ°ã€‚</p>

<p>é”å°½é‡å…¬å¹³
ä¸ºä»€ä¹ˆä¸æ˜¯ç»å¯¹å…¬å¹³ï¼Ÿè¦ç»å¯¹å…¬å¹³çš„ç²—æš´åšæ³•å°±æ˜¯åœ¨é”è¢«å ç”¨åï¼Œå…¶å®ƒæ‰€æœ‰ç«äº‰è€…ï¼ŒåŒ…æ‹¬æ–°æ¥çš„ï¼Œå…¨éƒ¨æ’é˜Ÿã€‚</p>

<p>ä½†æ’é˜Ÿçš„é—®é¢˜ä¹Ÿå¾ˆæ˜æ˜¾ï¼Œæ’é˜Ÿé˜»å¡å”¤é†’çš„åˆ‡æ¢æˆæœ¬(è¿™æ˜¯æŸè€—æ€§èƒ½çš„æ½œåœ¨çš„éšæ‚£ï¼Œä¸‹é¢Mutexçš„é—®é¢˜æœ‰ä¸¾ä¾‹)ã€‚å‡å¦‚ä¸´ç•ŒåŒºä»£ç æ‰§è¡Œåªéœ€è¦åå‡ ä¸ªæ—¶é’Ÿå‘¨æœŸæ—¶ï¼Œè®©ç«äº‰è€…è‡ªæ—‹ç­‰å¾…ä¸€ä¸‹ï¼Œç«‹åˆ»å°±å¯ä»¥è·å¾—é”ã€‚å‡å°‘ä¸å¿…è¦çš„åˆ‡æ¢æˆæœ¬ï¼Œæ•ˆç‡æ›´é«˜ã€‚</p>

<p>å°½é‡å…¬å¹³çš„ç»“æœå°±æ˜¯é˜»å¡çš„ç«äº‰è€…è¢«å”¤é†’åï¼Œä¹Ÿè¦ä¸(æ­£åœ¨è‡ªæ—‹çš„)æ–°ç«äº‰è€…æŠ¢å¤ºé”èµ„æºã€‚</p>

<p>goä½¿ç”¨ä¸‰ç§æ‰‹æ®µä¿è¯Mutexé”å°½é‡å…¬å¹³ï¼š</p>

<p>ä¸Šé¢ä»‹ç»çš„ï¼Œåœ¨é”é‡Šæ”¾æ—¶ï¼Œä¸»åŠ¨è®¾ç½®Wokenæ ‡è®°ï¼Œé˜²æ­¢æ–°çš„ç«äº‰è€…è½»æ˜“æŠ¢åˆ°é”ã€‚</p>

<p>ç«äº‰è€…è¿›é˜»å¡é˜Ÿåˆ—ç­–ç•¥ä¸ä¸€æ ·ã€‚æ–°çš„ç«äº‰è€…ï¼ŒæŠ¢ä¸åˆ°é”ï¼Œå°±æ’åœ¨é˜Ÿåˆ—å°¾éƒ¨ã€‚å…ˆæ¥ç«äº‰è€…ï¼Œä»é˜Ÿåˆ—ä¸­è¢«å”¤é†’åï¼Œè¿˜æ˜¯æŠ¢ä¸åˆ°é”ï¼Œå°±æ”¾åœ¨é˜Ÿåˆ—å¤´éƒ¨ã€‚</p>

<p>ä»»ä½•ç«äº‰è€…ï¼Œè¢«é˜»å¡ç­‰å¾…çš„æ—¶é—´è¶…è¿‡æŒ‡å®šé˜€å€¼(1ms)ã€‚é”å°±è½¬ä¸ºé¥¥é¥¿æ¨¡å¼ã€‚è¿™æ—¶é”é‡Šæ”¾æ—¶ä¼šå”¤é†’å®ƒä»¬ï¼Œæ‰‹é€’æ‰‹å¼æŠŠé”èµ„æºç»™å®ƒä»¬ã€‚åˆ«çš„ç«äº‰è€…ï¼ˆåŒ…æ‹¬æ–°æ¥çš„ï¼‰éƒ½æŠ¢ä¸åˆ°ã€‚ç›´æ¥æŠŠé¥¥é¥¿é—®é¢˜è§£å†³æ‰ã€‚</p>

<p>é¥¥é¥¿é—®é¢˜æ˜¯ä¼šç§¯å‹çš„ã€‚è¦å°½å¿«è§£å†³ã€‚ä¸¾ä¸ªä¾‹å­è§£é‡Šä¸€ä¸‹ï¼š</p>

<p>è“è‰²æ˜¯æ–°ç«äº‰è€…ï¼Œçº¢è‰²æ˜¯é˜»å¡ç­‰å¾…æ—¶é—´è¶…è¿‡é˜€å€¼çš„ç«äº‰è€…ã€‚æ¯æ¬¡æŒé”æ—¶é—´æ˜¯0.3msã€‚</p>

<p>åªè¦æœ‰ç«äº‰è€…é˜»å¡è¶…æ—¶äº†ï¼Œé”å°±ä¼šè½¬æ¢ä¸ºé¥¥é¥¿æ¨¡å¼ã€‚é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰çš„æ–°ç«äº‰è€…éƒ½å¾—æ’é˜Ÿã€‚</p>

<p>æ—¶åˆ»4ä¸­çš„G3å°±æ˜¯è¢«ç§¯å‹çš„ã€‚å¦‚æœæ—¶åˆ»0ä¸­çš„ç«äº‰è€…æ›´å¤šæ—¶ï¼Œå¹¶ä¸”æŠ¢é”é¡ºåºä¸å˜ã€‚é‚£ä¹ˆæ—¶åˆ»4çš„ç§¯å‹å°±æ›´ä¸¥é‡ã€‚</p>

<p>åŒæ—¶åæ˜ å‡ºä¸€ä¸ªé—®é¢˜ã€‚</p>

<p>Mutexå¸¦æ¥çš„é—®é¢˜
å‡è®¾åœ¨ä¸šåŠ¡æŸä¸ªåœºæ™¯ä¸­ï¼Œå¯¹æ¯ä¸ªè¯·æ±‚éƒ½éœ€è¦è®¿é—®æŸäº’æ–¥èµ„æºã€‚ä½¿ç”¨Mutexé”æ—¶ï¼Œå¦‚æœQPSå¾ˆé«˜ï¼Œé˜»å¡é˜Ÿåˆ—è‚¯å®šä¼šå¾ˆæ»¡ã€‚è™½ç„¶QPSå¯èƒ½ä¼šé™ï¼Œä½†è¯·æ±‚æ˜¯æŒç»­çš„ã€‚</p>

<p>æ–°æ¥çš„è¯·æ±‚ï¼Œåœ¨è®¿é—®äº’æ–¥èµ„æºæ—¶æœ‰å¯èƒ½æŠ¢é”æˆåŠŸï¼Œåæ¥è€…èƒœäºå…ˆåˆ°è€…ã€‚è¿™ç§æƒ…å†µæŒç»­å‘ç”Ÿçš„è¯ï¼Œå°±ä¼šå¯¼è‡´é˜»å¡é˜Ÿåˆ—ä¸­æ‰€æœ‰çš„è¯·æ±‚å¾—ä¸åˆ°å¤„ç†ï¼Œè€—æ—¶å¢é«˜ï¼Œç›´è‡³è¶…å‡ºä¸Šæ¸¸è®¾ç½®çš„è¶…æ—¶æ—¶é—´ï¼Œä¸€ä¸‹å­å¤±è´¥ç‡çªå¢ï¼Œä¸Šæ¸¸å†å½±å“å®ƒçš„ä¸Šæ¸¸ï¼Œå¼•èµ·è¿é”ååº”è¿›è€ŒæœåŠ¡æ•…éšœå¼‚å¸¸ã€‚</p>

<p>è§£å†³æ–¹æ¡ˆè¦æ ¹æ®å®é™…ä¸šåŠ¡åœºæ™¯æ¥ä¼˜åŒ–ã€‚å‰Šå‡é”çš„ç²’åº¦ï¼›æˆ–è€…ä½¿ç”¨CASçš„æ–¹å¼è¿›é˜Ÿåˆ—ï¼Œç„¶åé˜»å¡åœ¨é€šé“ä¸Šï¼›æˆ–è€…ä½¿ç”¨æ— é”ç»“æ„ç­‰å¾…ã€‚</p>

<p>é˜»å¡åœ¨é€šé“è€Œä¸æ˜¯é˜»å¡çš„é”ä¸Šï¼Œæ˜¯å› ä¸ºgoçš„runtimeå¯¹å¾…é”å”¤é†’å’Œé€šé“å”¤é†’goroutineçš„æ•ˆç‡æ˜¯ä¸ä¸€æ ·çš„ã€‚è¿™ä¹Ÿå¼•å‡ºäº†è¿˜æœ‰ä¸€ç§æ–¹æ¡ˆæ˜¯æ”¹runtimeï¼Œè®©é”å”¤é†’çš„goroutineæ›´å¿«åœ°å¾—åˆ°æ‰§è¡Œã€‚æ¯•ç«Ÿä¸Šé¢é—®é¢˜ç‚¹æ˜¯è¢«å”¤é†’çš„goroutineå’Œæ–°çš„goroutineåœ¨ç«äº‰ä¸­ä¸èƒ½ä¿è¯ç¨³èƒœï¼Œè¢«å”¤é†’çš„goroutineä¼šæœ‰ä¸€ä¸ªè°ƒåº¦è€—æ—¶ï¼Œå‡å°‘è€—æ—¶å°±æœ‰å¯èƒ½æé«˜ç«äº‰æˆåŠŸç‡ã€‚</p>

<p>é˜»å¡å’Œå”¤é†’æœºåˆ¶
goçš„é˜»å¡å’Œå”¤é†’æ˜¯semacquireå’Œsemreleaseã€‚è™½ç„¶å‘½åä¸Šæ˜¯semaï¼Œä½†å®é™…ç”¨é€”å´æ˜¯ä¸€å¥—é˜»å¡å”¤é†’æœºåˆ¶ã€‚</p>

<p>// That is, donâ€™t think of these as semaphores.
// Think of them as a way to implement sleep and wakeup</p>

<p>é˜»å¡å’Œå”¤é†’æœºåˆ¶</p>

<p>goçš„runtimeæœ‰ä¸€ä¸ªå…¨å±€å˜é‡semtableï¼Œå®ƒæ”¾ç½®äº†æ‰€æœ‰çš„ä¿¡å·é‡ã€‚</p>

<p>var semtable [semTabSize]struct {
  root semaRoot
  pad  [sys.CacheLineSize - unsafe.Sizeof(semaRoot{})]byte
}</p>

<p>func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags)
func semrelease1(addr *uint32, handoff bool)
æ¯ä¸ªä¿¡å·é‡éƒ½ç”±ä¸€ä¸ªå˜é‡åœ°å€æŒ‡å®šã€‚Mutexå°±æ˜¯ç”¨æˆå‘˜semaçš„åœ°å€ã€‚</p>

<p>åœ¨é˜»å¡æ—¶ï¼Œè°ƒç”¨semacquire1ï¼ŒæŠŠåœ°å€(addr)ä¼ ç»™å®ƒã€‚</p>

<p>å¦‚æœaddrå¤§äº1ï¼Œå¹¶ä¸”é€šè¿‡CASå‡ä¸€æˆåŠŸï¼Œé‚£å°±è¯´æ˜è·å–ä¿¡å·é‡æˆåŠŸã€‚ä¸ç”¨é˜»å¡ã€‚</p>

<p>å¦åˆ™ï¼Œsemacquire1ä¼šåœ¨semtableæ•°ç»„ä¸­æ‰¾ä¸€ä¸ªå…ƒç´ å’Œå®ƒå¯¹åº”ä¸Šã€‚æ¯ä¸ªå…ƒç´ éƒ½æœ‰ä¸€ä¸ªrootï¼Œè¿™ä¸ªrootæ˜¯Treapæ ‘ï¼ˆACMåŒå­¦åº”è¯¥ç†Ÿæ‚‰ï¼‰ã€‚</p>

<p>æœ€åaddrå˜æˆä¸€ä¸ªæ ‘èŠ‚ç‚¹ï¼Œè¿™ä¸ªæ ‘èŠ‚ç‚¹ï¼Œæœ‰è‡ªå·±çš„ä¸€ä¸ªé˜Ÿåˆ—ï¼Œä¸“é—¨æ”¾è¢«é˜»å¡çš„goroutineã€‚å«å®ƒé˜»å¡é˜Ÿåˆ—å§ã€‚</p>

<p>è¿™ä¸ªé˜»å¡é˜Ÿåˆ—æ˜¯ä¸ªåŒç«¯é˜Ÿåˆ—ï¼Œå¤´å°¾éƒ½å¯ä»¥è¿›ã€‚</p>

<p>semacquire1æŠŠå½“å‰goroutineç›¸å…³å…ƒæ•°æ®æ”¾è¿›é˜»å¡é˜Ÿåˆ—ä¹‹åï¼Œå°±æŒ‚èµ·äº†ã€‚</p>

<p>semrelease1æ˜¯ç»™addr CASåŠ ä¸€ã€‚
å¦‚æœåšæŒå‘ç°å½“å‰addrä¸Šæœ‰é˜»å¡çš„goroutineæ—¶ï¼Œå°±å–ä¸€ä¸ªå‡ºæ¥ï¼Œå”¤é†’å®ƒï¼Œè®©å®ƒè‡ªå·±å†å»semacquire1ã€‚è¿™æ˜¯handoffä¸ºfalseçš„æƒ…å†µã€‚
ä½†handoffä¸ºtrueçš„è¯ï¼Œå°±å°è¯•æ‰‹é€’æ‰‹åœ°æŠŠä¿¡å·é‡é€ç»™è¿™ä¸ªgoroutineã€‚ç­‰äºè¯´goroutineä¸ç”¨å†è‡ªå·±å»æŠ¢äº†ï¼Œå› ä¸ºè‡ªå·±å†å»æŠ¢æœ‰å¯èƒ½æŠ¢ä¸åˆ°ã€‚
æœ€åsemrelease1ä¼šæŠŠå–å‡ºæ¥çš„è¿™ä¸ªgoroutineæŒ‚åœ¨å½“å‰Pçš„æœ¬åœ°å¾…è¿è¡Œé˜Ÿåˆ—å°¾éƒ¨ï¼Œç­‰å¾…è°ƒåº¦æ‰§è¡Œã€‚
å°±æ˜¯è¿™æ ·ï¼Œåœ¨è·å–ä¸åˆ°Mutexé”æ—¶ï¼Œé€šè¿‡ä¿¡å·é‡æ¥é˜»å¡å’Œå”¤é†’goroutineã€‚</p>

<p>CASåŸå­æ“ä½œ
CASå°±æ˜¯åŸºæœ¬çš„åŸå­æ“ä½œã€‚æ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚</p>

<p>ä¾‹å¦‚åœ¨amd64ä¸Šï¼Œgoçš„æ±‡ç¼–å®ç°ï¼š</p>

<p>TEXT Â·CompareAndSwapUint32(SB),NOSPLIT,$0-17
  MOVV  addr+0(FP), R1
  MOVW  old+8(FP), R2
  MOVW  new+12(FP), R5
  SYNC
cas_again:
  MOVV  R5, R3
  LL  (R1), R4
  BNE  R2, R4, cas_fail
  SC  R3, (R1)
  BEQ  R3, cas_again
  MOVV  $1, R1
  MOVB  R1, swapped+16(FP)
  SYNC
  RET
cas_fail:
  MOVV  $0, R1
  JMP  -4(PC)</p>

<p>æºç 
type Mutex struct {
  // [é˜»å¡çš„goroutineä¸ªæ•°, starvingæ ‡è¯†, wokenæ ‡è¯†, lockedæ ‡è¯†]
  // [0~28, 1, 1, 1]
  state int32
  sema  uint32
}</p>

<p>const (
  mutexLocked = 1 Â«Â iota // mutex is locked
  mutexWoken    // å”¤é†’æ ‡è®°
  mutexStarving // é¥¥é¥¿æ¨¡å¼
  mutexWaiterShift = iota // ä½ç§»æ•°</p>

<p>starvationThresholdNs = 1e6  // é˜»å¡æ—¶é—´é˜€å€¼1ms
)</p>

<p>func (m *Mutex) Lock() {
  // Fast path: grab unlocked mutex.
  // å°è¯•CASä¸Šé”
  if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
    if race.Enabled {
      race.Acquire(unsafe.Pointer(m))
    }
    // ä¸Šé”æˆåŠŸï¼Œç›´æ¥è¿”å›
    return
  }</p>

<p>var waitStartTime int64
  starving := false
  awoke := false
  iter := 0
  old := m.state
  for {</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// è¿›å…¥åˆ°è¿™ä¸ªå¾ªç¯çš„ï¼Œæœ‰ä¸¤ç§è§’è‰²goroutine
// ä¸€ç§æ˜¯æ–°æ¥çš„goroutineã€‚å¦ä¸€ç§æ˜¯è¢«å”¤é†’çš„goroutineã€‚æ‰€ä»¥å®ƒä»¬å¯èƒ½åœ¨è¿™ä¸ªåœ°æ–¹å†ä¸€èµ·ç«äº‰é”
// å¦‚æœæ–°æ¥çš„goroutineæŠ¢æˆåŠŸäº†ï¼Œé‚£å¦ä¸€ä¸ªåªèƒ½å†é˜»å¡ç€ç­‰å¾…ã€‚ä½†è¶…è¿‡1msåï¼Œé”ä¼šè½¬æ¢æˆé¥¥é¥¿æ¨¡å¼
// åœ¨è¿™ä¸ªæ¨¡å¼ä¸‹ï¼Œæ‰€æœ‰æ–°æ¥çš„goroutineå¿…é¡»æ’åœ¨é˜Ÿä¼çš„åé¢ã€‚æ²¡æœ‰æŠ¢é”èµ„æ ¼

// é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œä¸èƒ½è‡ªæ—‹
// é”è¢«å ç”¨äº†ï¼Œä¸èƒ½è‡ªæ—‹
if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
  // wokenä½æ²¡æœ‰è¢«è®¾ç½®ï¼›è¢«é˜»å¡ç­‰å¾…goroutineçš„ä¸ªæ•°å¤§äº0
  if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
    // å¯ä»¥è‡ªæ—‹äº†ï¼Œé‚£å°±è®¾ç½®ä¸Šwokenä½ï¼Œåœ¨unlockæ—¶ï¼Œå¦‚æœå‘ç°æœ‰åˆ«çš„goroutineåœ¨è‡ªæ—‹ï¼Œå°±ç«‹å³è¿”å›ï¼Œæœ‰è¢«é˜»å¡çš„goroutineä¹Ÿä¸å”¤é†’äº†
    awoke = true
  }
  // runtime_doSpin -&gt; sync_runtime_doSpin
  // æ¯æ¬¡è‡ªæ—‹30ä¸ªæ—¶é’Ÿå‘¨æœŸï¼Œæœ€å¤š120ä¸ªå‘¨æœŸ
  runtime_doSpin()
  iter++
  old = m.state
  continue
}

// è‡ªæ—‹å®Œäº†è¿˜æ˜¯ç­‰ä¸åˆ°é” æˆ– å¯ä»¥ä¸Šé”

new := old
// é¥¥é¥¿æ¨¡å¼ä¸‹çš„é”ä¸æŠ¢
if old&amp;mutexStarving == 0 {
  // éé¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œå¯ä»¥æŠ¢é”
  new |= mutexLocked
}
if old&amp;(mutexLocked|mutexStarving) != 0 {
  // å·²ç»è¢«ä¸Šé”äº†ï¼Œæˆ–é”å¤„äºé¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œå°±é˜»å¡å½“å‰çš„goroutine
  new += 1 &lt;&lt; mutexWaiterShift
}
if starving &amp;&amp; old&amp;mutexLocked != 0 {
  // å½“å‰çš„goroutineå·²ç»è¢«é¥¿ç€äº†ï¼Œæ‰€ä»¥è¦æŠŠé”è®¾ç½®ä¸ºé¥¥é¥¿æ¨¡å¼
  new |= mutexStarving
}
if awoke {
  // å½“å‰çš„goroutineæœ‰è‡ªæ—‹è¿‡ï¼Œä½†ç°åœ¨å·²ç»è‡ªæ—‹ç»“æŸäº†ã€‚æ‰€ä»¥è¦å–æ¶ˆwokenæ¨¡å¼
  if new&amp;mutexWoken == 0 {
    panic("sync: inconsistent mutex state")
  }
  // å–æ¶ˆwokenæ ‡å¿—
  new &amp;^= mutexWoken
}
if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
  if old&amp;(mutexLocked|mutexStarving) == 0 {
    // æˆåŠŸä¸Šé”
    break // locked the mutex with CAS
  }
  
  // ä¸»è¦æ˜¯ä¸ºäº†å’Œç¬¬ä¸€æ¬¡è°ƒç”¨çš„Lockçš„gåˆ’åˆ†ä¸åŒçš„ä¼˜å…ˆçº§
  queueLifo := waitStartTime != 0
  if waitStartTime == 0 {
    waitStartTime = runtime_nanotime()
  }
  // ä½¿ç”¨ä¿¡å·é‡é˜»å¡å½“å‰çš„g
  // å¦‚æœå½“å‰gå·²ç»é˜»å¡ç­‰å¾…è¿‡ä¸€æ¬¡äº†ï¼ŒqueueLifoè¢«èµ‹å€¼true
  runtime_SemacquireMutex(&amp;m.sema, queueLifo)
  // åˆ¤æ–­å½“å‰gæ˜¯å¦è¢«é¥¿ç€äº†
  starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
  old = m.state
  if old&amp;mutexStarving != 0 {
    // é¥¥é¥¿æ¨¡å¼ä¸‹ï¼Œè¢«æ‰‹é€’æ‰‹å–‚ä¿¡å·é‡å”¤é†’çš„
    if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {
      panic("sync: inconsistent mutex state")
    }
    delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift) // -7(111)
    if !starving || old&gt;&gt;mutexWaiterShift == 1 {
      // é€€å‡ºé¥¥é¥¿æ¨¡å¼
      // é¥¥é¥¿æ¨¡å¼ä¼šå½±å“è‡ªæ—‹
      delta -= mutexStarving
    }
    atomic.AddInt32(&amp;m.state, delta)
    break
  }
  // ä¸æ˜¯æ‰‹é€’æ‰‹çš„ä¿¡å·é‡ï¼Œé‚£å°±è‡ªå·±ç»§ç»­ç«äº‰é”
  // å¿…é¡»è®¾ç½®ä¸ºtrueï¼Œè¿™æ ·æ–°ä¸€è½®çš„CASä¹‹å‰ï¼Œå°±å¯ä»¥å–æ¶ˆwokenæ¨¡å¼ã€‚
  // å› ä¸ºé€šè¿‡ä¿¡å·é‡é‡Šæ”¾é”æ—¶ï¼Œä¸ºäº†ä¿æŒå…¬å¹³æ€§ï¼Œä¼šåŒæ—¶è®¾ç½®wokenæ¨¡å¼ã€‚
  awoke = true
  iter = 0
} else {
  old = m.state
}   }
</code></pre></div></div>

<p>if race.Enabled {
    race.Acquire(unsafe.Pointer(m))
  }
}</p>

<p>func (m *Mutex) Unlock() {
  if race.Enabled {
    _ = m.state
    race.Release(unsafe.Pointer(m))
  }</p>

<p>// Fast path: drop lock bit.
  new := atomic.AddInt32(&amp;m.state, -mutexLocked)
  if (new+mutexLocked)&amp;mutexLocked == 0 {
    // ä¸èƒ½å¤šæ¬¡æ‰§è¡Œunclock()
    panic(â€œsync: unlock of unlocked mutexâ€)
  }
  if new&amp;mutexStarving == 0 {
    // éé¥¥é¥¿æ¨¡å¼
    old := new
    for {
      // æ²¡æœ‰è¢«é˜»å¡çš„goroutineã€‚ç›´æ¥è¿”å›
      // æœ‰é˜»å¡çš„goroutineï¼Œä½†å¤„äºwokenæ¨¡å¼ï¼Œç›´æ¥è¿”å›
      // æœ‰é˜»å¡çš„goroutineï¼Œä½†è¢«ä¸Šé”äº†ã€‚å¯èƒ½å‘ç”Ÿåœ¨æ­¤forå¾ªç¯å†…ï¼Œç¬¬ä¸€æ¬¡CASä¸æˆåŠŸã€‚å› ä¸ºCASå‰å¯èƒ½è¢«æ–°çš„goroutineæŠ¢åˆ°é”ã€‚ç›´æ¥è¿”å›
      // æœ‰é˜»å¡çš„goroutineï¼Œä½†é”å¤„äºé¥¥é¥¿æ¨¡å¼ã€‚å¯èƒ½å‘ç”Ÿåœ¨è¢«é˜»å¡çš„goroutineä¸æ˜¯è¢«å”¤é†’è°ƒåº¦çš„ï¼Œè€Œæ˜¯è¢«æ­£å¸¸è°ƒåº¦è¿è¡Œçš„ã€‚ç›´æ¥è¿”å›
      if oldÂ»mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
        return
      }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  // æœ‰é˜»å¡çš„goroutineï¼Œå”¤é†’ä¸€ä¸ªæˆ–å˜ä¸ºæ²¡æœ‰é˜»å¡çš„goroutineäº†å°±é€€å‡º
  // è¿™ä¸ªè¢«å”¤é†’çš„goroutineè¿˜éœ€è¦è·Ÿæ–°æ¥çš„goroutineç«äº‰
  // å¦‚æœåªå‰©æœ€åä¸€ä¸ªè¢«é˜»å¡çš„goroutineã€‚å”¤é†’å®ƒä¹‹åï¼Œstateå°±å˜æˆ0ã€‚
  // å¦‚æœæ­¤åˆ»æ¥ä¸€ä¸ªæ–°çš„goroutineæŠ¢é”ï¼Œå®ƒæœ‰å¯èƒ½åœ¨goroutineè¢«é‡æ–°è°ƒåº¦ä¹‹å‰æŠ¢é”æˆåŠŸã€‚
  // è¿™æ ·å°±å¤±å»å…¬å¹³æ€§äº†ï¼Œä¸èƒ½è®©å®ƒé‚£ä¹ˆå¹²ï¼Œæ‰€ä»¥è¿™é‡Œä¹Ÿè¦è®¾ç½®ä¸ºwokenæ¨¡å¼ã€‚
  // å› ä¸ºLockæ–¹æ³•å¼€å§‹çš„fast pathï¼ŒCASæ“ä½œçš„oldå€¼æ˜¯0ã€‚è¿™é‡Œè®¾ç½®wokenæ¨¡å¼æˆåŠŸåï¼Œåæ¥è€…å°±åªèƒ½ä¹–ä¹–æ’é˜Ÿã€‚ä¿æŒäº†é”çš„å…¬å¹³æ€§
  new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
  if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
    runtime_Semrelease(&amp;m.sema, false)
    return
  }
  old = m.state
}   } else {
// é¥¥é¥¿æ¨¡å¼
// æ‰‹é€’æ‰‹å”¤é†’ä¸€ä¸ªgoroutine
runtime_Semrelease(&amp;m.sema, true)   } }
</code></pre></div></div>

<p>golang 1.10 mutexäº’æ–¥é”æºç 
2018å¹´05æœˆ13æ—¥ 18:10:54 tydhot é˜…è¯»æ•° 369
Mutexé”åˆ†ä¸ºnormalæ¨¡å¼å’Œstarvationæ¨¡å¼ã€‚ä¸€å¼€å§‹é»˜è®¤å¤„äºnormalæ¨¡å¼ã€‚åœ¨normalæ¨¡å¼ä¸­ï¼Œæ¯ä¸ªæ–°åŠ å…¥ç«äº‰é”è¡Œåˆ—çš„åç¨‹éƒ½ä¼šç›´æ¥å‚ä¸åˆ°é”çš„ç«äº‰å½“ä¸­æ¥ï¼Œè€Œå¤„äºstarvationæ¨¡å¼æ—¶ï¼Œæ‰€æœ‰æ‰€æœ‰æ–°è¿›å…¥çš„åç¨‹éƒ½ä¼šç›´æ¥è¢«æ”¾å…¥ç­‰å¾…é˜Ÿåˆ—ä¸­æŒ‚èµ·ï¼Œç›´åˆ°å…¶æ‰€åœ¨é˜Ÿåˆ—ä¹‹å‰çš„åç¨‹å…¨éƒ¨æ‰§è¡Œå®Œæ¯•ã€‚</p>

<p>åœ¨normalæ¨¡å¼ä¸­åç¨‹çš„æŒ‚èµ·ç­‰å¾…æ—¶é—´å¦‚æœå¤§äºæŸä¸ªå€¼ï¼Œå°±ä¼šè¿›å…¥starvationæ¨¡å¼ã€‚</p>

<p>type Mutex struct {
   state int32
   sema  uint32
}
å…¶ä¸­ï¼Œstateç”¨æ¥ä¿å­˜mutexçš„çŠ¶æ€é‡ï¼Œä½ä¸€ä½è¡¨ç¤ºæ˜¯å¦ä¸Šé”ï¼Œä½äºŒä½è¡¨ç¤ºå½“å‰é”å¯¹è±¡æ˜¯å¦è¢«å”¤é†’ï¼Œä½ä¸‰ä½è¡¨ç¤ºè¯¥é”æ˜¯å¦å¤„äºstarationçŠ¶æ€ï¼Œè€Œåå‡ ä½è¡¨ç¤ºå½“å‰æ­£è¢«è¯¥é”é˜»å¡çš„åç¨‹æ•°ã€‚è€Œsemaåˆ™æ˜¯ä½œä¸ºä¿¡å·é‡æ¥ä½œä¸ºé˜»å¡çš„ä¾æ®ã€‚</p>

<p>Lock()æ–¹æ³•è¿›è¡ŒåŠ é”ã€‚</p>

<p>func (m *Mutex) Lock() {
   // Fast path: grab unlocked mutex.
   if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
      if race.Enabled {
         race.Acquire(unsafe.Pointer(m))
      }
      return
   }</p>

<p>var waitStartTime int64
   starving := false
   awoke := false
   iter := 0
   old := m.state
   for {
      // Donâ€™t spin in starvation mode, ownership is handed off to waiters
      // so we wonâ€™t be able to acquire the mutex anyway.
      if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
         // Active spinning makes sense.
         // Try to set mutexWoken flag to inform Unlock
         // to not wake other blocked goroutines.
         if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; oldÂ»mutexWaiterShift != 0 &amp;&amp;
            atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
            awoke = true
         }
         runtime_doSpin()
         iter++
         old = m.state
         continue
      }
      new := old
      // Donâ€™t try to acquire starving mutex, new arriving goroutines must queue.
      if old&amp;mutexStarving == 0 {
         new |= mutexLocked
      }
      if old&amp;(mutexLocked|mutexStarving) != 0 {
         new += 1 Â«Â mutexWaiterShift
      }
      // The current goroutine switches mutex to starvation mode.
      // But if the mutex is currently unlocked, donâ€™t do the switch.
      // Unlock expects that starving mutex has waiters, which will not
      // be true in this case.
      if starving &amp;&amp; old&amp;mutexLocked != 0 {
         new |= mutexStarving
      }
      if awoke {
         // The goroutine has been woken from sleep,
         // so we need to reset the flag in either case.
         if new&amp;mutexWoken == 0 {
            throw(â€œsync: inconsistent mutex stateâ€)
         }
         new &amp;^= mutexWoken
      }
      if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
         if old&amp;(mutexLocked|mutexStarving) == 0 {
            break // locked the mutex with CAS
         }
         // If we were already waiting before, queue at the front of the queue.
         queueLifo := waitStartTime != 0
         if waitStartTime == 0 {
            waitStartTime = runtime_nanotime()
         }
         runtime_SemacquireMutex(&amp;m.sema, queueLifo)
         starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
         old = m.state
         if old&amp;mutexStarving != 0 {
            // If this goroutine was woken and mutex is in starvation mode,
            // ownership was handed off to us but mutex is in somewhat
            // inconsistent state: mutexLocked is not set and we are still
            // accounted as waiter. Fix that.
            if old&amp;(mutexLocked|mutexWoken) != 0 || oldÂ»mutexWaiterShift == 0 {
               throw(â€œsync: inconsistent mutex stateâ€)
            }
            delta := int32(mutexLocked - 1Â«mutexWaiterShift)
            if !starving || oldÂ»mutexWaiterShift == 1 {
               // Exit starvation mode.
               // Critical to do it here and consider wait time.
               // Starvation mode is so inefficient, that two goroutines
               // can go lock-step infinitely once they switch mutex
               // to starvation mode.
               delta -= mutexStarving
            }
            atomic.AddInt32(&amp;m.state, delta)
            break
         }
         awoke = true
         iter = 0
      } else {
         old = m.state
      }
   }</p>

<p>if race.Enabled {
      race.Acquire(unsafe.Pointer(m))
   }
}
ä¸€å¼€å§‹ä¼šç›´æ¥é€šè¿‡caså°†åŸæœ¬å€¼ä¸º0ï¼ˆä¹Ÿå°±æ˜¯å½“å‰æ²¡ä»»ä½•åç¨‹å ç”¨é”ï¼‰çš„stateèµ‹ä¸º1ï¼Œè¡¨ç¤ºè¿™ä¸ªé”å·²ç»æœ‰äººåŠ é”ã€‚å¦‚æœæˆåŠŸï¼Œè¡¨ç¤ºè¿™æ˜¯å½“å‰é”ç¬¬ä¸€æ¬¡åŠ é”å¹¶ä¸”åŠ é”æˆåŠŸï¼Œé‚£ä¹ˆå¯ä»¥ç›´æ¥è¿”å›ã€‚</p>

<p>å¦‚æœä¹‹å‰åŠ é”å¤±è´¥ï¼Œä¹Ÿå°±æ˜¯åˆšåˆšçš„casæ“ä½œå¤±è´¥ï¼Œé‚£ä¹ˆè¯´æ˜å°±éœ€è¦ç­‰å¾…é”çš„é‡Šæ”¾ï¼Œé¦–å…ˆåˆ¤æ–­æ˜¯å¦å·²ç»åŠ é”å¹¶å¤„äºnormalæ¨¡å¼ï¼Œå°†åŸå…ˆé”çš„stateä¸1å’Œ4ç›¸æˆ–çš„ç»“æœç›¸ä¸ï¼Œå¦‚æœä¸1ç›¸ç­‰ï¼Œåˆ™è¯´æ˜æ­¤æ—¶å¤„äºnormalæ¨¡å¼å¹¶ä¸”å·²ç»åŠ é”ï¼Œè€Œååˆ¤æ–­å½“å‰åç¨‹æ˜¯å¦å¯ä»¥è‡ªæ—‹ã€‚å¦‚æœå¯ä»¥è‡ªæ—‹ï¼Œåˆ™é€šè¿‡å³ç§»ä¸‰ä½åˆ¤æ–­æ˜¯å¦è¿˜æœ‰åç¨‹æ­£åœ¨ç­‰å¾…è¿™ä¸ªé”ï¼Œå¦‚æœæœ‰ï¼Œå¹¶é€šè¿‡ä½2ä½åˆ¤æ–­æ˜¯å¦è¯¥æ‰€å¤„äºè¢«å”¤é†’çŠ¶æ€ï¼Œå¦‚æœå¹¶æ²¡æœ‰ï¼Œåˆ™å°†å…¶çŠ¶æ€é‡è®¾ä¸ºè¢«å”¤é†’çš„çŠ¶æ€ï¼Œä¹‹åè¿›è¡Œè‡ªæ—‹ï¼Œç›´åˆ°è¯¥åç¨‹è‡ªæ—‹æ•°é‡è¾¾åˆ°ä¸Šé™ï¼Œæˆ–è€…å½“å‰é”è¢«è§£é”ï¼Œæˆ–è€…å½“å‰é”å·²ç»å¤„äºstarvationæ¨¡å¼ã€‚</p>

<p>if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
   // Active spinning makes sense.
   // Try to set mutexWoken flag to inform Unlock
   // to not wake other blocked goroutines.
   if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; oldÂ»mutexWaiterShift != 0 &amp;&amp;
      atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
      awoke = true
   }
   runtime_doSpin()
   iter++
   old = m.state
   continue
}
åœ¨è¶…è¿‡è‡ªæ—‹æ•°é‡ä¸Šé™æˆ–è€…å½“å‰é”å·²ç»è§£é”æˆ–è€…å½“å‰é”å·²ç»å¤„äºstarvationæ¨¡å¼ï¼Œé‚£ä¹ˆå°±åœ¨å¾ªç¯ä¸­è¿›å…¥ä¸‹é¢çš„éƒ¨åˆ†ã€‚</p>

<p>new := old
// Donâ€™t try to acquire starving mutex, new arriving goroutines must queue.
if old&amp;mutexStarving == 0 {
   new |= mutexLocked
}
if old&amp;(mutexLocked|mutexStarving) != 0 {
   new += 1 Â«Â mutexWaiterShift
}
// The current goroutine switches mutex to starvation mode.
// But if the mutex is currently unlocked, donâ€™t do the switch.
// Unlock expects that starving mutex has waiters, which will not
// be true in this case.
if starving &amp;&amp; old&amp;mutexLocked != 0 {
   new |= mutexStarving
}
if awoke {
   // The goroutine has been woken from sleep,
   // so we need to reset the flag in either case.
   if new&amp;mutexWoken == 0 {
      throw(â€œsync: inconsistent mutex stateâ€)
   }
   new &amp;^= mutexWoken
}
if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
   if old&amp;(mutexLocked|mutexStarving) == 0 {
      break // locked the mutex with CAS
   }
   // If we were already waiting before, queue at the front of the queue.
   queueLifo := waitStartTime != 0
   if waitStartTime == 0 {
      waitStartTime = runtime_nanotime()
   }
   runtime_SemacquireMutex(&amp;m.sema, queueLifo)
   starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
   old = m.state
   if old&amp;mutexStarving != 0 {
      // If this goroutine was woken and mutex is in starvation mode,
      // ownership was handed off to us but mutex is in somewhat
      // inconsistent state: mutexLocked is not set and we are still
      // accounted as waiter. Fix that.
      if old&amp;(mutexLocked|mutexWoken) != 0 || oldÂ»mutexWaiterShift == 0 {
         throw(â€œsync: inconsistent mutex stateâ€)
      }
      delta := int32(mutexLocked - 1Â«mutexWaiterShift)
      if !starving || oldÂ»mutexWaiterShift == 1 {
         // Exit starvation mode.
         // Critical to do it here and consider wait time.
         // Starvation mode is so inefficient, that two goroutines
         // can go lock-step infinitely once they switch mutex
         // to starvation mode.
         delta -= mutexStarving
      }
      atomic.AddInt32(&amp;m.state, delta)
      break
   }
   awoke = true
   iter = 0
} else {
   old = m.state
}</p>

<p>é¦–å…ˆï¼Œå¦‚æœæ­¤æ—¶è¿˜æ˜¯ç”±äºåˆ«çš„åç¨‹çš„å ç”¨æ— æ³•è·å¾—é”æˆ–è€…å¤„äºstarvationæ¨¡å¼ï¼Œéƒ½åœ¨å…¶stateåŠ 8è¡¨ç¤ºæœ‰æ–°çš„åç¨‹æ­£åœ¨å¤„äºç­‰å¾…çŠ¶æ€ã€‚å¹¶ä¸”å¦‚æœä¹‹å‰ç”±äºè‡ªæ—‹è€Œå°†è¯¥é”å”¤é†’ï¼Œé‚£ä¹ˆæ­¤æ—¶å°†å…¶ä½äºŒä½çš„çŠ¶æ€é‡èµ‹å€¼ä¸º0ã€‚ä¹‹ååˆ¤æ–­starvingæ˜¯å¦ä¸ºtrueï¼Œå¦‚æœä¸ºtrueè¯´æ˜åœ¨ä¸Šä¸€æ¬¡çš„å¾ªç¯ä¸­ï¼Œé”éœ€è¦è¢«å®šä¹‰ä¸ºstarvationæ¨¡å¼ï¼Œé‚£ä¹ˆåœ¨è¿™é‡Œå°±å°†ç›¸åº”çš„çŠ¶æ€é‡ä½ä¸‰ä½è®¾ç½®ä¸º1è¡¨ç¤ºè¿›å…¥starvationæ¨¡å¼ã€‚</p>

<p>ä¹‹åå°è¯•é€šè¿‡caså°†æ–°çš„stateçŠ¶æ€é‡èµ‹å€¼ç»™stateï¼Œå¦‚æœå¤±è´¥ï¼Œåˆ™é‡æ–°è·å¾—å…¶ stateåœ¨ä¸‹ä¸€æ­¥å¾ªç¯é‡æ–°é‡å¤ä¸Šè¿°çš„æ“ä½œã€‚å¦‚æœæˆåŠŸï¼Œé¦–å…ˆåˆ¤æ–­å·²ç»é˜»å¡æ—¶é—´ï¼Œå¦‚æœä¸ºé›¶ï¼Œåˆ™ä»ç°åœ¨å¼€å§‹è®°å½•ã€‚</p>

<p>ä¹‹åé€šè¿‡runtime_SemacquireMutex()é€šè¿‡ä¿¡å·é‡å°†å½“å‰åç¨‹é˜»å¡ã€‚</p>

<p>ä¸Šè¿°runtime_SemacquireMutex()æ–¹æ³•çš„å…·ä½“å®ç°åœ¨äº†sema.goä¸­ã€‚</p>

<p>func sync_runtime_SemacquireMutex(addr *uint32, lifo bool) {
   semacquire1(addr, lifo, semaBlockProfile|semaMutexProfile)
}</p>

<p>func semacquire1(addr *uint32, lifo bool, profile semaProfileFlags) {
   gp := getg()
   if gp != gp.m.curg {
      throw(â€œsemacquire not on the G stackâ€)
   }</p>

<p>// Easy case.
   if cansemacquire(addr) {
      return
   }</p>

<p>// Harder case:
   // increment waiter count
   // try cansemacquire one more time, return if succeeded
   // enqueue itself as a waiter
   // sleep
   // (waiter descriptor is dequeued by signaler)
   s := acquireSudog()
   root := semroot(addr)
   t0 := int64(0)
   s.releasetime = 0
   s.acquiretime = 0
   s.ticket = 0
   if profile&amp;semaBlockProfile != 0 &amp;&amp; blockprofilerate &gt; 0 {
      t0 = cputicks()
      s.releasetime = -1
   }
   if profile&amp;semaMutexProfile != 0 &amp;&amp; mutexprofilerate &gt; 0 {
      if t0 == 0 {
         t0 = cputicks()
      }
      s.acquiretime = t0
   }
   for {
      lock(&amp;root.lock)
      // Add ourselves to nwait to disable â€œeasy caseâ€ in semrelease.
      atomic.Xadd(&amp;root.nwait, 1)
      // Check cansemacquire to avoid missed wakeup.
      if cansemacquire(addr) {
         atomic.Xadd(&amp;root.nwait, -1)
         unlock(&amp;root.lock)
         break
      }
      // Any semrelease after the cansemacquire knows weâ€™re waiting
      // (we set nwait above), so go to sleep.
      root.queue(addr, s, lifo)
      goparkunlock(&amp;root.lock, â€œsemacquireâ€, traceEvGoBlockSync, 4)
      if s.ticket != 0 || cansemacquire(addr) {
         break
      }
   }
   if s.releasetime &gt; 0 {
      blockevent(s.releasetime-t0, 3)
   }
   releaseSudog(s)
}</p>

<p>é¦–å…ˆï¼Œåœ¨ä¸Šè¿°çš„æ–¹æ³•ä¸­ï¼Œé¦–å…ˆé€šè¿‡semroot()æ–¹æ³•æ ¹æ®ä¼ å…¥çš„åœ°å€è·å¾—semRootï¼Œå…¶å…·ä½“æ“ä½œå¦‚ä¸‹ã€‚</p>

<p>func semroot(addr *uint32) *semaRoot {
   return &amp;semtable[(uintptr(unsafe.Pointer(addr))Â»3)%semTabSize].root
}</p>

<p>å°†ä¼ å…¥çš„Mutexçš„ä¿¡å·é‡semaçš„åœ°å€å³ç§»ä¸‰ä½å¹¶ä¸251å–ä½™ï¼Œå¾—åˆ°çš„æ–°åœ°å€æ¥å¾—åˆ°semRootï¼Œåšåˆ°å°†semRooté€šè¿‡ä¿¡å·é‡semaæ¥ä¸ç›¸åº”çš„Mutexç»‘å®šçš„ç›®çš„ã€‚</p>

<p>semRootçš„ç»“æ„å¦‚ä¸‹ã€‚</p>

<p>type semaRoot struct {
   lock  mutex
   treap *sudog // root of balanced tree of unique waiters.
   nwait uint32 // Number of waiters. Read w/o the lock.
}</p>

<p>å…¶ä¸­çš„mutexä¸ä¹‹å‰çš„Mutexæ— å…³ï¼Œåªæ˜¯ä¸€ä¸ªç®€å•çš„uintptræ¥ç®€å•çš„å®ç°å¹¶å‘çš„çº¿ç¨‹å®‰å…¨çš„åŠŸèƒ½ã€‚Treapåˆ™æ˜¯å…¶ä¸­å¹³è¡¡äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œnwaitåˆ™è¡¨ç¤ºè¯åœ¨å¹³è¡¡äºŒå‰æ ‘é˜»å¡çš„åç¨‹æ•°é‡ã€‚</p>

<p>æ­¤æ—¶ï¼Œä¼šå¯¹ä¿¡å·é‡semaçš„å€¼è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœä¸º0ï¼Œåˆ™ç»§ç»­ï¼Œå¦åˆ™å°è¯•å‡1å¹¶è¿”å›ã€‚</p>

<p>è€Œåé€šè¿‡semRootä¸­çš„mutexè¿›è¡ŒåŠ é”ï¼Œè¿™é‡Œçš„é”å®ç°å¾ˆç®€å•ï¼Œç®€å•æ¥è¯´å®åˆ™åªæ˜¯å¯¹äº’æ–¥ä¿¡å·é‡çš„casæ“ä½œã€‚</p>

<p>ä¹‹åç»™semRootçš„nwaitåŠ ä¸€ï¼Œè¡¨ç¤ºæ–°çš„åç¨‹è¿›å…¥ç­‰å¾…ã€‚</p>

<p>ä¹‹åé€šè¿‡queue()æ–¹æ³•æ­£å¼å°†ç›®æ ‡åç¨‹æ”¾å…¥å¹³è¡¡äºŒå‰æ ‘ä¸­ç­‰å¾…ã€‚</p>

<p>å¯¹äºè¿™ä¸ªèŠ‚ç‚¹ï¼Œé¦–å…ˆè®¾ç½®è¯¥èŠ‚ç‚¹ä¸­ä¿å­˜çš„åç¨‹ä¸ºå½“å‰åç¨‹ï¼Œå¹¶ä¿å­˜å½“å‰ä¿¡å·é‡åœ°å€ã€‚</p>

<p>é¦–å…ˆï¼Œå¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ ¹æ®æ–°çš„ä¿¡å·é‡è€Œè¦åŠ å…¥çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆä¼šç›´æ¥åŠ å…¥åˆ°å¹³è¡¡äºŒå‰æ ‘ä¸­ï¼Œè¿™é¢—äºŒå‰æ ‘ä¸­èŠ‚ç‚¹çš„ä½ç½®é€šè¿‡ä¿¡å·é‡çš„åœ°å€ä½œä¸ºæ’åºçš„ä¾æ®ï¼Œç„¶åæ’å…¥ã€‚</p>

<p>s.ticket = fastrand() | 1
s.parent = last
*pt = s</p>

<p>// Rotate up into tree according to ticket (priority).
for s.parent != nil &amp;&amp; s.parent.ticket &gt; s.ticket {
   if s.parent.prev == s {
      root.rotateRight(s.parent)
   } else {
      if s.parent.next != s {
         panic(â€œsemaRoot queueâ€)
      }
      root.rotateLeft(s.parent)
   }
}
å¦‚æœä¸æ˜¯ç¬¬ä¸€æ¬¡çš„æ’å…¥ï¼Œé‚£ä¹ˆé¦–å…ˆæ ¹æ®ä¿¡å·é‡çš„åœ°å€ä»å¹³è¡¡äºŒå‰æ ‘æ ¹èŠ‚ç‚¹å¼€å§‹å¯»æ‰¾å¯¹åº”çš„ä¿¡å·é‡åœ°å€æ‰€ç»‘å®šçš„èŠ‚ç‚¹ï¼Œé€šè¿‡å¤§å°ç¡®å®šå¯»æ‰¾çš„å·¦å„¿å­èŠ‚ç‚¹æˆ–è€…å³å„¿å­èŠ‚ç‚¹ï¼Œç›´åˆ°æ‰¾åˆ°ã€‚</p>

<p>æ‰¾åˆ°ä¹‹åï¼Œä¹‹å‰åœ¨å°†åç¨‹å‡†å¤‡é˜»å¡ä¹‹å‰ä¼šåˆ¤æ–­ä»¥ç­‰å¾…æ—¶é—´ï¼Œå¦‚æœä¸ä¸º0ï¼Œè¯´æ˜è¯¥åç¨‹å·²ç»è¿›å…¥è¿‡è¯¥å¹³è¡¡äºŒå‰æ ‘ã€‚é‚£ä¹ˆå°†æ–°ç”Ÿæˆçš„èŠ‚ç‚¹å–ä»£åŸæœ¬èŠ‚ç‚¹åœ¨å¹³è¡¡äºŒå‰æ ‘çš„ä½ç½®ï¼Œå¹¶å°†è€èŠ‚ç‚¹æ”¾ç½®åœ¨è¯¥ä¿¡å·é‡ç»‘å®šèŠ‚ç‚¹çš„ç­‰å¾…é˜Ÿåˆ—çš„å¤´éƒ¨ã€‚å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡ï¼Œé‚£ä¹ˆåªéœ€è¦å°†æ–°çš„èŠ‚ç‚¹æ”¾åœ¨ç­‰å¾…é˜Ÿåˆ—çš„æœ«å°¾ã€‚</p>

<p>var last *sudog
pt := &amp;root.treap
for t := *pt; t != nil; t = *pt {
   if t.elem == unsafe.Pointer(addr) {
      // Already have addr in list.
      if lifo {
         // Substitute s in tâ€™s place in treap.
         *pt = s
         s.ticket = t.ticket
         s.acquiretime = t.acquiretime
         s.parent = t.parent
         s.prev = t.prev
         s.next = t.next
         if s.prev != nil {
            s.prev.parent = s
         }
         if s.next != nil {
            s.next.parent = s
         }
         // Add t first in sâ€™s wait list.
         s.waitlink = t
         s.waittail = t.waittail
         if s.waittail == nil {
            s.waittail = t
         }
         t.parent = nil
         t.prev = nil
         t.next = nil
         t.waittail = nil
      } else {
         // Add s to end of tâ€™s wait list.
         if t.waittail == nil {
            t.waitlink = s
         } else {
            t.waittail.waitlink = s
         }
         t.waittail = s
         s.waitlink = nil
      }
      return
   }
   last = t
   if uintptr(unsafe.Pointer(addr)) &lt; uintptr(t.elem) {
      pt = &amp;t.prev
   } else {
      pt = &amp;t.next
   }
}</p>

<p>å°†å½“æ¬¡é˜»å¡åŠ å…¥å¹³è¡¡äºŒå‰æ ‘ä¸­é˜Ÿåˆ—ä¹‹åï¼Œå°±å¯ä»¥å…ˆå°†semRootä¸­çš„mutexè§£é”ï¼Œå¹¶å°†å½“å‰åç¨‹æŒ‚èµ·ã€‚</p>

<p>å›åˆ°Mutexçš„Lock()ä¸­ï¼Œå½“ä¹‹å‰è°ƒç”¨æ–¹æ³•å°†åç¨‹æŒ‚èµ·åï¼Œå¦‚æœåç¨‹è¢«å”¤é†’ï¼Œé‚£ä¹ˆå°±ä¼šç»§ç»­ä¸‹é¢çš„æµç¨‹ã€‚</p>

<p>starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
old = m.state
if old&amp;mutexStarving != 0 {
   // If this goroutine was woken and mutex is in starvation mode,
   // ownership was handed off to us but mutex is in somewhat
   // inconsistent state: mutexLocked is not set and we are still
   // accounted as waiter. Fix that.
   if old&amp;(mutexLocked|mutexWoken) != 0 || oldÂ»mutexWaiterShift == 0 {
      throw(â€œsync: inconsistent mutex stateâ€)
   }
   delta := int32(mutexLocked - 1Â«mutexWaiterShift)
   if !starving || oldÂ»mutexWaiterShift == 1 {
      // Exit starvation mode.
      // Critical to do it here and consider wait time.
      // Starvation mode is so inefficient, that two goroutines
      // can go lock-step infinitely once they switch mutex
      // to starvation mode.
      delta -= mutexStarving
   }
   atomic.AddInt32(&amp;m.state, delta)
   break
}</p>

<p>å¦‚æœè¿™é‡Œåç¨‹é˜»å¡è€ŒæŒ‚èµ·çš„æ—¶é—´è¶…è¿‡äº†é»˜è®¤å€¼ï¼Œé‚£ä¹ˆå°±ä¼šå°†starveè®¾ç½®ä¸ºtrueï¼Œå°±ä¼šåœ¨ä¸‹ä¸€æ¬¡çš„å¾ªç¯ä¸­å°†è¯¥é”è¿™æ˜¯ä¸ºstarvationæ¨¡å¼ã€‚å¦‚æœå·²ç»æ˜¯è¿™ä¸ªæ¨¡å¼ï¼Œé‚£ä¹ˆå°±ä¼šå°†çŠ¶æ€é‡çš„ç­‰å¾…æ•°å‡1ï¼Œå¹¶åˆ¤æ–­å½“å‰å¦‚æœå·²ç»æ²¡æœ‰ç­‰å¾…çš„åç¨‹ï¼Œå°±æ²¡æœ‰å¿…è¦ç»§ç»­ç»´æŒstarvationæ¨¡å¼ï¼ŒåŒæ—¶ä¹Ÿæ²¡å¿…è¦ç»§ç»­æ‰§è¡Œè¯¥å¾ªç¯ï¼ˆå½“å‰åªæœ‰ä¸€ä¸ªåç¨‹åœ¨å ç”¨é”ï¼‰ã€‚</p>

<p>è§£é”é€šè¿‡Unlock()æ–¹æ³•ã€‚</p>

<p>func (m *Mutex) Unlock() {
   if race.Enabled {
      _ = m.state
      race.Release(unsafe.Pointer(m))
   }</p>

<p>// Fast path: drop lock bit.
   new := atomic.AddInt32(&amp;m.state, -mutexLocked)
   if (new+mutexLocked)&amp;mutexLocked == 0 {
      throw(â€œsync: unlock of unlocked mutexâ€)
   }
   if new&amp;mutexStarving == 0 {
      old := new
      for {
         // If there are no waiters or a goroutine has already
         // been woken or grabbed the lock, no need to wake anyone.
         // In starvation mode ownership is directly handed off from unlocking
         // goroutine to the next waiter. We are not part of this chain,
         // since we did not observe mutexStarving when we unlocked the mutex above.
         // So get off the way.
         if oldÂ»mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
            return
         }
         // Grab the right to wake someone.
         new = (old - 1Â«mutexWaiterShift) | mutexWoken
         if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            runtime_Semrelease(&amp;m.sema, false)
            return
         }
         old = m.state
      }
   } else {
      // Starving mode: handoff mutex ownership to the next waiter.
      // Note: mutexLocked is not set, the waiter will set it after wakeup.
      // But mutex is still considered locked if mutexStarving is set,
      // so new coming goroutines wonâ€™t acquire it.
      runtime_Semrelease(&amp;m.sema, true)
   }
}</p>

<p>è§£é”é¦–å…ˆç›´æ¥å°†ç¬¬ä¸€ä½çŠ¶æ€é‡å˜ä¸º0ï¼Œè¡¨ç¤ºå·²ç»è§£é”ã€‚ç„¶åæ ¹æ®æ¨¡å¼ï¼Œå¦‚æœå¤„äºnormalæ¨¡å¼ï¼Œæ ¹æ®çŠ¶æ€é‡å½“å‰æ˜¯å¦æœ‰åç¨‹ç­‰å¾…ï¼Œæˆ–è€…å·²ç»æœ‰åç¨‹å·²ç»åœ¨è‡ªæ—‹ç­‰å¾…é”ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç›´æ¥ç»“æŸã€‚å¦åˆ™ï¼Œå°±é€šè¿‡runtime_Semrelease()æ–¹æ³•å°è¯•å”¤é†’æŒ‚èµ·çš„åç¨‹ã€‚åœ¨runtime_Semrelease()ä¸­ä¸ä¹‹å‰å¯¹åº”ï¼Œé€šè¿‡dequeue()æ–¹æ³•å°†å¯»æ‰¾åˆ°çš„äºŒå‰æ ‘èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯å¾ªç¯é˜Ÿåˆ—çš„å¤´éƒ¨å–å‡ºï¼ŒèŠ‚ç‚¹ä¸­ä¿å­˜çš„åç¨‹ä½œä¸ºè¦å”¤é†’çš„åç¨‹ã€‚ä½†æ˜¯ï¼Œè¿™é‡Œå”¤é†’çš„æºç¨‹å¹¶ä¸ä¸€å®šä¼šç«‹å³è·å–é”ï¼Œé”çš„è·å–ä»æ—§éœ€è¦ç«äº‰ã€‚</p>

<p>è€Œå¦‚æœå¤„äºstarvationæ¨¡å¼ï¼Œé‚£ä¹ˆä¼šç›´æ¥é€šè¿‡runtime_Semrelease()æ–¹æ³•å°è¯•å”¤é†’æŒ‚èµ·çš„åç¨‹ï¼Œè¿™é‡Œå”¤é†’çš„åç¨‹å¿…å®šæŒæœ‰é”ã€‚</p>

<p>golangçš„ç‰ˆæœ¬æ˜¯1.12ï¼Œå…¶ä¸­çš„mutexæ˜¯å¢åŠ äº†æ™®é€šæ¨¡å¼å’Œé¥¥é¥¿æ¨¡å¼åˆ‡æ¢çš„ä¼˜åŒ–ç‰ˆæœ¬ï¼Œä¸ºäº†ä¾¿äºç†è§£ï¼Œè¿™é‡Œå…ˆä»ä¸Šä¸€ä¸ªç‰ˆæœ¬1.7ç‰ˆæœ¬çš„mutexå¼€å§‹åˆ†æï¼Œä»¥åå†å¯¹ä¼˜åŒ–ç‰ˆæœ¬è¿›è¡Œè¯´æ˜ã€‚</p>

<p>Mutexç»“æ„è¯´æ˜
å®šä¹‰
æœ€åˆç‰ˆæœ¬é”çš„å®šä¹‰å¦‚ä¸‹ï¼š</p>

<p>// mutexæ˜¯äº’æ–¥é”
// mutexçš„é›¶å€¼æ˜¯æ²¡æœ‰åŠ é”çš„
//åœ¨ä½¿ç”¨ä¹‹åä¸èƒ½è¢«æ‹·è´
type Mutex struct {
    state int32  //çŠ¶æ€æ ‡è¯†
    sema  uint32 //ä¿¡å·é‡
}</p>

<p>const (
    mutexLocked = 1 Â«Â iota // mutex is locked
    mutexWoken
    mutexWaiterShift = iota
)
1
2
3
4
5
6
7
8
9
10
11
12
13
å…¶ä¸­stateæ˜¯è®°å½•ç”¨æ¥è®°å½•åŠ é”çŠ¶æ€çš„ï¼Œå°†ä¸€ä¸ªæ•´å‹æŒ‰ä½åˆ’åˆ†æ¥è¡¨ç¤ºä¸åŒçš„å«ä¹‰ï¼Œä»ä½åˆ°é«˜åˆ†åˆ«ä¸ºç¬¬1ä½åˆ°ç¬¬32ä½ï¼Œ</p>

<p>ç¬¬1ä½è¡¨ç¤ºæ˜¯å¦è¢«é”ä½ï¼Œå³0è¡¨ç¤ºæ²¡æœ‰é”ä½ï¼ŒmutexLockedä¹Ÿå°±æ˜¯1è¡¨ç¤ºå·²ç»è¢«é”ä½ã€‚
ç¬¬2è¡¨ç¤ºæ˜¯å¦è¢«å”¤é†’ï¼Œ1è¡¨ç¤ºè¢«å”¤é†’ï¼ŒmutexWoken=2è¡¨ç¤ºè¢«å”¤é†’ã€‚
ç¬¬3ä½åˆ°ç¬¬32ä½è¡¨ç¤ºç­‰å¾…åœ¨mutexä¸Šåç¨‹æ•°é‡ï¼ŒmutexWaiterShift=3è¡¨ç¤ºåœ¨è·å–ç­‰å¾…åç¨‹æ•°é‡ï¼Œéœ€è¦å°†stateå³ç§»ä½3ä½ã€‚
å…¶ä¸­semaæ˜¯ä¿¡å·é‡ï¼Œæ˜¯ä¸€ä¸ªéè´Ÿæ•°çš„å…¨å±€å˜é‡ï¼Œä¸‹é¢å¯¹ä¿¡å·é‡è¿›è¡Œç®€å•è¯´æ˜ã€‚</p>

<p>ä¿¡å·é‡
ä¿¡å·é‡æ˜¯è¿›ç¨‹é—´é€šä¿¡å¤„ç†åŒæ­¥äº’æ–¥çš„æœºåˆ¶ï¼Œé€šè¿‡ä¸€ä¸ªè®¡æ•°å™¨æ¥æ§åˆ¶å¯¹å…±äº«èµ„æºçš„è®¿é—®æ¬¡æ•°é™åˆ¶ã€‚ä¾‹å¦‚ä¸€ä¸ªåŠå…¬å®¤æœ‰ä¸¤å°æ‰“å°æœºï¼Œæœ‰å‡ åå°ç”µè„‘è¿ä¸Šï¼Œè¿™æ˜¯åŒæ—¶åªèƒ½å…è®¸ä¸¤ä¸ªç”µè„‘è¿›è¡Œæ‰“å°ï¼Œè€Œå…¶ä»–ç”µè„‘å¿…é¡»æ’é˜Ÿç­‰å¾…å®Œæˆåæ‰èƒ½æ‰“å°ã€‚</p>

<p>semaå°±æ˜¯ä¿¡å·é‡ï¼Œæ˜¯ä¸€ä¸ªéè´Ÿæ•°çš„å…¨å±€å˜é‡ï¼Œè¯¥å˜é‡æœ‰ä¸¤ä¸ªæ“ä½œPå’ŒVï¼ŒPVæ“ä½œéƒ½æ˜¯ä¸å¯ä¸­æ–­çš„ã€‚</p>

<p>P(S):
ï¼ˆ1ï¼‰æ‰§è¡ŒS=S-1ï¼›
ï¼ˆ2ï¼‰è¿›è¡Œä»¥ä¸‹åˆ¤æ–­ï¼š</p>

<p>å¦‚æœS &lt; 0ï¼Œè¿›å…¥é˜»å¡é˜Ÿåˆ—ï¼Œç›´åˆ°æ»¡è¶³S&gt;=0
å¦‚æœS &gt;= 0, ç›´æ¥è¿”å›
å› æ­¤Pæ“ä½œæ‰§è¡Œä¸€æ¬¡æ„å‘³ç€åˆ†é…ä¸€ä¸ªèµ„æºï¼Œå¦‚ä¸Šæ‰“å°æœºæ„å‘³ç€æ˜¯èµ„æºï¼Œå½“Så°äº0æ„å‘³ç€æ²¡æœ‰å¯ç”¨èµ„æºäº†ï¼Œåªèƒ½ä¸€ç›´ç­‰å¾…ï¼Œç›´åˆ°èµ„æºç©ºé—²å‡ºæ¥æ—¶æ‰èƒ½ç»§ç»­ã€‚
V(S):
ï¼ˆ1ï¼‰æ‰§è¡ŒS=S+1ï¼›
ï¼ˆ2ï¼‰è¿›è¡Œä»¥ä¸‹åˆ¤æ–­ï¼š</p>

<p>å¦‚æœS &gt; 0ï¼Œç›´æ¥è¿”å›
å¦‚æœS &lt;= 0ï¼Œ é‡Šæ”¾é˜»å¡é˜Ÿåˆ—ä¸­çš„ç¬¬ä¸€ä¸ªç­‰å¾…è¿›ç¨‹
å› æ­¤Væ“ä½œæ‰§è¡Œä¸€æ¬¡æ„å‘³ç€é‡Šæ”¾ä¸€ä¸ªèµ„æºï¼Œå½“Så°äºç­‰äº0æ—¶ï¼Œæ„å‘³ç€è¿˜æœ‰è¿›ç¨‹åœ¨è¯·æ±‚èµ„æºï¼Œæ­¤æ—¶é‡Šæ”¾äº†ä¸€ä¸ªèµ„æºï¼Œå°±éœ€è¦ä»ç­‰å¾…é˜Ÿåˆ—ä¸­æ‹¿å‡ºä¸€ä¸ªè¿›ç¨‹æ¥ä½¿ç”¨æ­¤åˆ»é‡Šæ”¾çš„èµ„æºã€‚
golangä¸­ä¿¡å·é‡æ“ä½œ
runtime_Semacquire
func runtime_Semacquire(s <em>uint32)ï¼ŒPæ“ä½œï¼Œç­‰å¾…</em>så¤§äºç­‰äº0ï¼Œæºç åœ¨runtime/sema.goä¸­</p>

<p>runtime_Semrelease
func runtime_Semrelease, Væ“ä½œï¼Œé˜»å¡ç­‰å¾…è¢«å”¤é†’ï¼Œç›®å‰ç‰ˆæœ¬åœ¨runtime/sema.goä¸­(å®šä¹‰ç¨æœ‰ä¸åŒäº†)ã€‚</p>

<p>å¦‚æœç›´æ¥ç”¨ä¿¡å·é‡æ¥å®ç°äº’æ–¥ï¼Œå³æ–°å»ºä¸€ä¸ªsema=1ï¼Œç„¶åç”¨PVæ“ä½œruntime_Semacquireå’Œruntime_Semreleaseæ¥å®ç°ï¼Œä¹Ÿå¯ä»¥åšåˆ°å½“ä¸€æ¬¡è¯·æ±‚æ—¶ï¼Œæ‹¿åˆ°èµ„æºè¿›è¡Œæ‰§è¡Œï¼Œåç»­è¯·æ±‚é˜»å¡ï¼Œè¿›å…¥ç­‰å¾…é˜Ÿåˆ—ï¼Œä¸è€ƒè™‘æ€§èƒ½ï¼ŒæŒ‰ç…§è¿™æ ·ç®€å•çš„æ€è·¯å®ç°å¦‚ä¸‹ï¼š</p>

<p>ä¸ºä½•ç”¨ä¿¡å·é‡å®ç°äº’æ–¥é”</p>

<p>type Mutex struct {
    sema uint32
}</p>

<p>func NewMutex() *Mutex {
    var mu Mutex
    mu.sema = 1
    return &amp;mu
}
func (m *Mutex) Lock() {
        runtime_Semacquire(&amp;m.sema)
}</p>

<p>func (m *Mutex2) Unlock() {
    runtime_Semrelease(&amp;m.sema)
}</p>

<p>è¿™é‡Œä¼šæœ‰ä¸€ç‚¹é—®é¢˜æ˜¯ï¼Œå½“åŠ é”ä¸€æ¬¡ï¼Œä»£ç ä¸­è§£é”äº†ä¸¤æ¬¡ï¼Œ ä¼šå¯¼è‡´semaå€¼å˜åŒ–è€Œä¸æç¤ºä»»ä½•é”™è¯¯ï¼Œå³è¿™æ—¶sema=2ï¼Œèµ„æºæ•°é‡å‘ç”Ÿäº†å˜åŒ–ï¼Œå¯¼è‡´åç»­è¿è¡Œå¼‚å¸¸ï¼Œæ‰€ä»¥å¤šæ¬¡è§£é”æ—¶éœ€è¦è¿”å›å¼‚å¸¸ã€‚è¿™é‡Œï¼Œé€šè¿‡å¤šä¸€ä¸ªå˜é‡æ¥è¡¨ç¤ºåŠ é”æ¬¡æ•°ï¼Œæ”¹è¿›ä»£ç å¦‚ä¸‹ï¼š</p>

<p>type Mutex struct {
        key  int32
        sema uint32
}</p>

<p>func (m *Mutex) Lock() {
        if atomic.AddInt32(&amp;m.key, 1) == 1 {
                // changed from 0 to 1; we hold lock
                return
        }
        runtime_Semacquire(&amp;m.sema)
}</p>

<p>func (m *Mutex) Unlock() {
        switch v := atomic.AddInt32(&amp;m.key, -1); {
        case v == 0:
                // changed from 1 to 0; no contention
                return
        case v == -1:
                // changed from 0 to -1: wasnâ€™t locked
                // (or there are 4 billion goroutines waiting)
                panic(â€œsync: unlock of unlocked mutexâ€)
        }
        runtime_Semrelease(&amp;m.sema)
}
è¿™ä¸ªè§£å†³æ–¹æ¡ˆé™¤äº†è§£å†³äº†æˆ‘ä»¬å‰é¢è¯´çš„é‡å¤åŠ é”çš„é—®é¢˜å¤–ï¼Œè¿˜å¯¹æˆ‘ä»¬åˆå§‹åŒ–å·¥ä½œåšäº†ç®€åŒ–ï¼Œä¸éœ€è¦æ„é€ å‡½æ•°äº†ã€‚æ‰§è¡Œè¿‡ç¨‹ä¸­å€¼å˜åŒ–å¦‚ä¸‹ï¼š</p>

<p>åˆå§‹ï¼škey=0, sema = 0
Lockç¬¬ä¸€æ¬¡ï¼škey+1=1è¿”å›ï¼Œsema=0ï¼Œå³ç¬¬ä¸€æ¬¡ä¸è¿›è¡ŒPæ“ä½œï¼Œç›´æ¥å°†keyåŠ 1è¡¨ç¤ºè·å–äº†é”ã€‚
Lockç¬¬äºŒæ¬¡ï¼škey=2ï¼Œè¿›è¡ŒPæ“ä½œï¼Œå‘ç°sema-1 =-1&lt;0ï¼Œé˜»å¡ç­‰å¾…è·å–é”ã€‚
å½“æ‰§è¡Œäº†ä¸€æ¬¡Lockåï¼Œkey=1ï¼Œsema=0ï¼Œæ‰§è¡Œä»¥ä¸‹æ“ä½œæ—¶ï¼š</p>

<p>Unlockç¬¬ä¸€æ¬¡ï¼škey-1=0è¿”å›ï¼Œsema=0ï¼Œç¬¬ä¸€æ¬¡è§£é”ä¸æ‰§è¡ŒVæ“ä½œï¼Œç›´æ¥keyå‡1è¡¨ç¤ºé‡Šæ”¾é”ã€‚
Unlockç¬¬äºŒæ¬¡ï¼škey-1=-1ï¼Œè¡¨ç¤ºè§£é”è¿‡äº†ï¼Œè¿”å›å¼‚å¸¸ã€‚
å½“æ‰§è¡Œäº†ä¸¤æ¬¡Lockåï¼Œkey=2ï¼Œsema=-1ï¼Œæ‰§è¡Œä»¥ä¸‹æ“ä½œæ—¶ï¼š</p>

<p>Unlockç¬¬ä¸€æ¬¡ï¼škey-1=1ï¼Œæ‰§è¡ŒVæ“ä½œruntime_Semreleaseï¼Œå‘ç°sema+1=0ï¼Œä¼šé˜»å¡ç›´åˆ°å”¤é†’äº†å…¶ä»–åç¨‹ï¼Œç„¶åè¿”å›ã€‚
ç®€å•æ¥è¯´ï¼Œå¢åŠ ä¸€ä¸ªkeyå˜é‡åï¼Œsema=0è¡¨ç¤ºæœ‰ä¸€ä¸ªèµ„æºï¼Œè·Ÿåªç”¨ä¿¡å·é‡æ—¶sema=1å«ä¹‰ä¸€æ ·ï¼Œåœ¨golang mutexä¹Ÿæ˜¯åŸºäºæ­¤å®ç°çš„</p>

<p>Mutexæ“ä½œè§£è¯»
Lock
æœ€åˆç‰ˆæœ¬çš„mutex lockå¦‚ä¸‹ï¼š</p>

<p>func (m *Mutex) Lock() {
â€”â€”â€”â€”â€”â€“ä»£ç å—1 startâ€”â€”â€”â€”â€”â€“
    // Fast path: grab unlocked mutex.<br />
    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
        if race.Enabled {
            race.Acquire(unsafe.Pointer(m))
        }
        return
    }
â€”â€”â€”â€”â€”â€“ä»£ç å—1 endâ€”â€”â€”â€”â€”â€“ 
    awoke := false
    iter := 0
    for {
  â€”â€”â€”â€”â€”â€“ä»£ç å—2 startâ€”â€”â€”â€”â€”â€“<br />
        old := m.state
        new := old | mutexLocked
        if old&amp;mutexLocked != 0 {
            if runtime_canSpin(iter) {
                // Active spinning makes sense.
                // Try to set mutexWoken flag to inform Unlock
                // to not wake other blocked goroutines.
                if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; oldÂ»mutexWaiterShift != 0 &amp;&amp;
                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                    awoke = true
                }
                runtime_doSpin()
                iter++
                continue
            }
            new = old + 1Â«mutexWaiterShift
        }
    â€”â€”â€”â€”â€”â€“ä»£ç å—2 endâ€”â€”â€”â€”â€”â€“
    â€”â€”â€”â€”â€”â€“ä»£ç å—3 startâ€”â€”â€”â€”â€”â€“
        if awoke {
            // The goroutine has been woken from sleep,
            // so we need to reset the flag in either case.
            if new&amp;mutexWoken == 0 {
                panic(â€œsync: inconsistent mutex stateâ€)
            }
            new &amp;^= mutexWoken
        }
â€”â€”â€”â€”â€”â€“ä»£ç å—3 endâ€”â€”â€”â€”â€”â€“
â€”â€”â€”â€”â€”â€“ä»£ç å—4 startâ€”â€”â€”â€”â€”â€“
        if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            if old&amp;mutexLocked == 0 {
                break
            }
            runtime_Semacquire(&amp;m.sema)
            awoke = true
            iter = 0
        }
â€”â€”â€”â€”â€”â€“ä»£ç å—4 startâ€”â€”â€”â€”â€”â€“
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if race.Enabled {
    race.Acquire(unsafe.Pointer(m))
} }
</code></pre></div></div>

<p>å°†ä¸Šé¢ä»£ç æ ‡æ³¨ä¸º4å—ï¼Œä¸‹é¢ä¾æ¬¡è¿›è¡Œåˆ†æã€‚å¯¹ä»£ç é€»è¾‘è¿›è¡Œè¯¦ç»†åˆ†æä¹‹å‰ï¼Œå…ˆä»‹ç»ä¸‹å…¶ä¸­ç”¨åˆ°éƒ¨åˆ†å‡½æ•°ã€‚</p>

<p>race.Acquire</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if race.Enabled {
        race.Acquire(unsafe.Pointer(m))
    }
</code></pre></div></div>

<p>ç«äº‰æ£€æµ‹é€»è¾‘ï¼Œã€‚goä¸­ä½¿ç”¨goroutineæ¯”è¾ƒå¸¸è§ï¼Œåœ¨å¤§å‹é¡¹ç›®ä¸­å¯èƒ½ä¼šåœ¨å¤šä¸ªgoroutineä¸­ç”¨åˆ°æŸä¸ªå…¨å±€å˜é‡ï¼Œå¦‚æœæœ‰ç«äº‰å°±éœ€è¦åŠ é”æ“ä½œã€‚goæä¾›äº†raceæ£€æµ‹å·¥å…·ï¼Œå¯ä»¥ä½¿ç”¨go run -race æˆ–è€… go build -raceæ¥è¿›è¡Œç«äº‰æ£€æµ‹ã€‚</p>

<p>runtime_canSpin
åˆ¤æ–­æ˜¯å¦éœ€è¦è‡ªé€‰ï¼Œgolangä¸­è‡ªæ—‹é”å¹¶ä¸ä¼šä¸€ç›´è‡ªæ—‹ä¸‹å»ï¼Œåœ¨runtimeåŒ…ä¸­runtime_canSpinæ–¹æ³•åšäº†ä¸€äº›é™åˆ¶, ä¼ é€’è¿‡æ¥çš„iterå¤§ç­‰äº4æˆ–è€…cpuæ ¸æ•°å°ç­‰äº1ï¼Œæœ€å¤§é€»è¾‘å¤„ç†å™¨å¤§äº1ï¼Œè‡³å°‘æœ‰ä¸ªæœ¬åœ°çš„Pé˜Ÿåˆ—ï¼Œå¹¶ä¸”æœ¬åœ°çš„Pé˜Ÿåˆ—å¯è¿è¡ŒGé˜Ÿåˆ—ä¸ºç©ºæ‰ä¼šè¿›è¡Œè‡ªæ—‹ã€‚</p>

<p>//go:linkname sync_runtime_canSpin sync.runtime_canSpin
func sync_runtime_canSpin(i int) bool {
 if i &gt;= active_spin || ncpu &lt;= 1 || gomaxprocs &lt;= int32(sched.npidle+sched.nmspinning)+1 {
 return false
 }
 if p := getg().m.p.ptr(); !runqempty(p) {
 return false
 }
 return true
}
runtime_doSpin
è¿›è¡Œè‡ªæ—‹æ“ä½œï¼Œä¼šè°ƒç”¨procyieldå‡½æ•°ï¼Œè¯¥å‡½æ•°ä¹Ÿæ˜¯æ±‡ç¼–è¯­è¨€å®ç°ã€‚å‡½æ•°å†…éƒ¨å¾ªç¯è°ƒç”¨PAUSEæŒ‡ä»¤ã€‚PAUSEæŒ‡ä»¤ä»€ä¹ˆéƒ½ä¸åšï¼Œä½†æ˜¯ä¼šæ¶ˆè€—CPUæ—¶é—´ï¼Œåœ¨æ‰§è¡ŒPAUSEæŒ‡ä»¤æ—¶ï¼ŒCPUä¸ä¼šå¯¹å®ƒåšä¸å¿…è¦çš„ä¼˜åŒ–ã€‚</p>

<p>//go:linkname sync_runtime_doSpin sync.runtime_doSpin
func sync_runtime_doSpin() {
 procyield(active_spin_cnt)
}
ä»£ç å—1
    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
        if race.Enabled {
            race.Acquire(unsafe.Pointer(m))
        }
        return
    }
å¦‚æœstate=0ï¼Œå³æ²¡æœ‰é”ä½ã€æ²¡æœ‰å”¤é†’ä¸”æ²¡æœ‰ç­‰å¾…é˜Ÿåˆ—ï¼Œå¯ç›´æ¥æ‹¿åˆ°é”ï¼Œå°†çŠ¶æ€ç½®ä¸ºé”ä½å¹¶è¿”å›ï¼Œè¿™ç›¸å½“äºæ˜¯ä¸Šé¢demoç‰ˆä¸­ä»key=0ï¼Œsema=0çš„çŠ¶æ€ï¼Œå˜ä¸ºkey=1ï¼Œseme=0çš„çŠ¶æ€ã€‚</p>

<p>ä»£ç å—2
    //æœ€æ–°çŠ¶æ€
    old := m.state<br />
        new := old | mutexLocked
        //å·²ç»è¢«é”ä½
        if old&amp;mutexLocked != 0 {
          //åˆ¤æ–­æ˜¯å¦éœ€è¦è‡ªé€‰ï¼Œè¿™æ˜¯åœ¨forå¾ªç¯ä¸­ï¼Œiteræ¬¡æ•°å¯èƒ½å·²ç»è¶…è¿‡ä¸éœ€è¦è‡ªæ—‹äº†ï¼Œæˆ–è€…å…¶ä»–æ¡ä»¶
            if runtime_canSpin(iter) {
                // ä¸»åŠ¨è‡ªæ—‹æ˜¯æœ‰æ„ä¹‰çš„ï¼Œå› ä¸ºä¼šå°è¯•å”¤é†’é”ï¼Œ
                //è¿™æ ·ä¸Šä¸ªåç¨‹æ­¤æ—¶unlockçš„è¯ï¼Œå°±ä¸ä¼šå”¤é†’å…¶ä»–åç¨‹
                if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; oldÂ»mutexWaiterShift != 0 &amp;&amp;
                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                    //è‡ªå·±æ²¡æœ‰å”¤é†’ï¼Œä¸”åŸçŠ¶æ€æ²¡æœ‰å”¤é†’ï¼Œ
                    //ä¸”æœ‰åç¨‹åœ¨æ’é˜Ÿä¸”è®¾ç½®å”¤é†’æ ‡è¯†æˆåŠŸï¼Œ
                    //è¯´æ˜ä¸Šä¸ªçš„åç¨‹æ­¤æ—¶unlockäº†ï¼Œ
                    awoke = true
                }
                //è‡ªæ—‹ä¸€æ®µæ—¶é—´
                runtime_doSpin()
                iter++
                continue
            }
            //ä¸éœ€è¦è‡ªæ—‹ï¼Œå°†stateçš„ç­‰å¾…é˜Ÿåˆ—æ•°æ®åŠ 1
            new = old + 1Â«mutexWaiterShift
        }
ä»£ç å—3
        if awoke {
            //ä»£ç å—1ä¸­å°†awokeç½®ä¸º1äº†ï¼Œæ ‡è¯†è¢«å”¤é†’
            //ä»£ç å—1ä¸­åªæœ‰è®¾ç½®äº†å”¤é†’æ ‡è¯†ï¼Œawokeæ‰ä¼šä¸ºtrueï¼Œå› æ­¤ä¸ä¼šnew&amp;mutexWoken == 0
            if new&amp;mutexWoken == 0 {
                panic(â€œsync: inconsistent mutex stateâ€)
            }
            //æ—¢ç„¶å½“å‰åç¨‹è¢«å”¤é†’äº†ï¼Œéœ€è¦å°†stateç½®ä¸ºæœªå”¤é†’
            new &amp;^= mutexWoken
        }
ä»£ç å—4
        //è¿™é‡Œnewæœ‰å››ç§å€¼
        if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            if old&amp;mutexLocked == 0 {
                //æ²¡æœ‰é”ä½ï¼Œç›´æ¥è¿”å›
                break 
            }
            //å½“å‰é”ä½çš„ï¼Œé˜»å¡åœ¨æ­¤å¤„ç­‰å¾…ï¼Œä¼šè®©å‡ºcpu
            runtime_Semacquire(&amp;m.sema)
            //ä»é˜»å¡ä¸­è¿”å›ï¼Œè®¾ç½®å½“å‰åç¨‹è¢«å”¤é†’äº†
            awoke = true
            iter = 0
        }
è¿™é‡Œnewå¯èƒ½æœ‰å››ç§å€¼ï¼š</p>

<p>new := old | mutexLocked
new = old + 1Â«mutexWaiterShift
new := old | mutexLocked ï¼Œ new &amp;^= mutexWoken
new = old + 1Â«mutexWaiterShiftï¼Œ new &amp;^= mutexWoken
æƒ…å†µ1
new := old | mutexLocked ï¼Œåç¨‹åœ¨å¼€å§‹è‡ªæ—‹å‰æˆ–è€…è‡ªæ—‹è¿‡ç¨‹ä¸­ï¼ŒåŸåç¨‹å·²ç»unlockäº†ï¼Œä¼šå‡ºçº¿è¿™ç§æƒ…å†µã€‚å‡è®¾åŸåç¨‹ä¸ºaï¼Œå½“å‰åç¨‹ä¸ºbï¼Œæ‰§è¡Œå¦‚ä¸‹ï¼š
a.Lock()
b.Lock()
æ­¤æ—¶bä¸­lockå¯èƒ½é€»è¾‘ä¸ºï¼š</p>

<p>//stateå·²ç»è¢«é”ä½
â€”â€”â€”â€”â€”â€“ä»£ç å—1 startâ€”â€”â€”â€”â€”â€“ 
â€¦
â€”â€”â€”â€”â€”â€“ä»£ç å—1 endâ€”â€”â€”â€”â€”â€“ 
//è¿™é‡Œaæ‰§è¡Œ a.Unlock()å°†stateè®¾ç½®ä¸ºæœªé”ä½çŠ¶æ€
    awoke := false
    for {
        old := m.state
        new := old | mutexLocked
        if old&amp;mutexLocked != 0 {
        //ä¸æ‰§è¡Œæ­¤å—
        }
        if awoke {
    //ä¸æ‰§è¡Œæ­¤å—
        }
        if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            if old&amp;mutexLocked == 0 {
              //æ‰§è¡Œè¿™é‡Œ
                break
            }
            //ä¸æ‰§è¡Œä»¥ä¸‹å‡ å¥
            runtime_Semacquire(&amp;m.sema)
            awoke = true
            iter = 0
        }
    }
æˆ–è€…è‡ªæ—‹æœªç»“æŸå‰a.Unlock()ï¼Œè¿™æ—¶new = old + 1Â«mutexWaiterShiftä¸ä¼šè¢«æ‰§è¡Œï¼Œ</p>

<p>//stateå·²ç»è¢«é”ä½
â€”â€”â€”â€”â€”â€“ä»£ç å—1 startâ€”â€”â€”â€”â€”â€“ 
â€¦
â€”â€”â€”â€”â€”â€“ä»£ç å—1 endâ€”â€”â€”â€”â€”â€“ 
    awoke := false
    for {
        old := m.state
        new := old | mutexLocked
    if old&amp;mutexLocked != 0 {
            if runtime_canSpin(iter) {
                //æ‰§è¡Œæ­¤å—ï¼Œiterè¿˜å°äºactive_spinæ¬¡ï¼Œå›åˆ°forå¼€å§‹
                //åœ¨iterå°äºactive_spinä¹‹å‰ï¼Œaæ‰§è¡Œäº†unlockï¼Œæ­¤æ—¶bä¼šæ‰§è¡Œåˆ°ä»£ç å—4
                if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; oldÂ»mutexWaiterShift != 0 &amp;&amp;
                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                    //å…ˆå‡è®¾è¿™é‡Œæœªæ‰§è¡Œï¼Œå¦‚æœæ‰§è¡Œäº†ï¼Œåˆ™æ˜¯æƒ…å†µ3çš„èµ‹å€¼é€»è¾‘äº†
                    awoke = true
                }
                continue
            }
            //ä¸æ‰§è¡Œè¿™å¥
            new = old + 1Â«mutexWaiterShift
        }
        if awoke {
    //ä¸æ‰§è¡Œæ­¤å—
        }
        if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            if old&amp;mutexLocked == 0 {
              //æ‰§è¡Œè¿™é‡Œ
                break
            }
            //ä¸æ‰§è¡Œä»¥ä¸‹å‡ å¥
            runtime_Semacquire(&amp;m.sema)
            awoke = true
            iter = 0
        }
    }
æƒ…å†µ2
new = old + 1Â«mutexWaiterShiftï¼Œè¿™æ˜¯æ‰§è¡Œå®Œè‡ªæ—‹æµç¨‹ï¼Œæˆ–è€…ä¸éœ€è¦æ‰§è¡Œè‡ªæ—‹çš„æƒ…å†µï¼Œå³ä»£ç è¿è¡Œåˆ°ä»£ç å—2çš„new = old + 1Â«mutexWaiterShiftï¼Œ</p>

<p>//stateå·²ç»è¢«é”ä½
â€”â€”â€”â€”â€”â€“ä»£ç å—1 startâ€”â€”â€”â€”â€”â€“ 
â€¦
â€”â€”â€”â€”â€”â€“ä»£ç å—1 endâ€”â€”â€”â€”â€”â€“ 
    awoke := false
    for {
        old := m.state
        new := old | mutexLocked
    if old&amp;mutexLocked != 0 {
            if runtime_canSpin(iter) {
                //æ‰§è¡Œæ­¤å—ï¼Œiterè¿˜å°äºactive_spinæ¬¡ï¼Œå›åˆ°forå¼€å§‹
                //åœ¨iterå°äºactive_spinä¹‹å‰ï¼Œaæ‰§è¡Œäº†unlockï¼Œæ­¤æ—¶bä¼šæ‰§è¡Œåˆ°ä»£ç å—4
                if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; oldÂ»mutexWaiterShift != 0 &amp;&amp;
                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                    //å…ˆå‡è®¾è¿™é‡Œæœªæ‰§è¡Œï¼Œå¦‚æœæ‰§è¡Œäº†ï¼Œåˆ™æ˜¯æƒ…å†µ4çš„èµ‹å€¼é€»è¾‘äº†
                    awoke = true
                }
                continue
            }
            //æ‰§è¡Œè¿™å¥
            new = old + 1Â«mutexWaiterShift
        }
        if awoke {
    //ä¸æ‰§è¡Œæ­¤å—
        }
        if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
            if old&amp;mutexLocked == 0 {
              //ä¸æ‰§è¡Œè¿™é‡Œ
                break
            }
            //æ‰§è¡Œè¿™é‡Œé˜»å¡
            runtime_Semacquire(&amp;m.sema)
            awoke = true
            iter = 0
        }
    }
æƒ…å†µ3å’Œæƒ…å†µ4
è¿™ä¸¤ç§æ˜¯æƒ…å†µ1å’Œ2ä¸­ï¼Œæ‰§è¡Œåˆ°ä¸‹é¢è¯­å¥çš„æƒ…å†µï¼š</p>

<p>if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; oldÂ»mutexWaiterShift != 0 &amp;&amp;
                    atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
                    awoke = true
                }
æ­¤æ—¶å› ä¸ºawoke=trueï¼Œä¹Ÿä¼šæ‰§è¡Œï¼š</p>

<p>if awoke {
            if new&amp;mutexWoken == 0 {
                panic(â€œsync: inconsistent mutex stateâ€)
            }
            new &amp;^= mutexWoken
        }
è¿™ç§æƒ…å†µæ˜¯åœ¨è‡ªæ—‹è¿‡ç¨‹ä¸­ï¼Œè®¾ç½®å”¤é†’æ ‡è¯†æˆåŠŸï¼Œå³æœ¬åç¨‹å¯ä»¥æ‹¿åˆ°é”ï¼Œå› æ­¤éœ€è¦å°†å”¤é†’æ ‡è¯†ç½®ä¸º0ï¼Œé˜²æ­¢å…¶ä»–åç¨‹è·å–ã€‚</p>

<p>Unlock
æºç å¦‚ä¸‹ï¼š</p>

<p>func (m *Mutex) Unlock() {
  //raceæ£€æµ‹
    if race.Enabled {
        _ = m.state
        race.Release(unsafe.Pointer(m))
    }</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// åˆ¤æ–­æ˜¯å¦å¤šæ¬¡è§£é”ï¼Œå¤šæ¬¡è§£é”åˆ™æŠ›å‡ºå¼‚å¸¸
new := atomic.AddInt32(&amp;m.state, -mutexLocked)
if (new+mutexLocked)&amp;mutexLocked == 0 {
    panic("sync: unlock of unlocked mutex")
}
 
old := new
for {
    if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken) != 0 {
        return
    }
    new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
    if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
        runtime_Semrelease(&amp;m.sema)
        return
    }
    old = m.state
} } forå¾ªç¯ä¸­ï¼Œå› ä¸ºoldåœ¨æ›´æ–°ï¼Œç¬¬ä¸€ä¸ªifè¯­å¥ä¼šåœ¨ä»¥ä¸‹ä¸¤ç§æƒ…å†µæ—¶è¿”å›ï¼š
</code></pre></div></div>

<p>å½“å‰é”ä¸Šæ²¡æœ‰åç¨‹åœ¨ç­‰å¾…
å½“å‰é”å·²ç»è¢«å…¶ä»–åç¨‹lockäº†æˆ–è€…å”¤é†’äº†
ç¬¬äºŒä¸ªifè¯­å¥ï¼ŒcasåŸå­æ“ä½œå°†ç­‰å¾…åç¨‹æ•°ç›®å‡1ï¼Œå¹¶è®¾ç½®å”¤é†’æ ‡è¯†ï¼Œé˜»å¡åœ¨runtime_Semreleaseå¤„ï¼Œç›´åˆ°æœ‰å…¶ä»–åç¨‹è¢«å”¤é†’æ‰è¿”å›ã€‚
çœ‹åˆ°è¿™é‡Œï¼Œå°±å¯ä»¥çŸ¥é“ï¼Œå”¤é†’æ“ä½œæœ‰ä¸¤ç§ï¼š
ï¼ˆ1ï¼‰lockå‡½æ•°ï¼Œæ‰§è¡Œè‡ªæ—‹è¿‡ç¨‹ä¸­ä¸»åŠ¨å”¤é†’è‡ªå·±ï¼Œä¼šæ‰§è¡Œåˆ°awoke = trueç›¸å…³ä»£ç ï¼›
ï¼ˆ2ï¼‰unlockå‡½æ•°ï¼ŒåŸåç¨‹è®¾ç½®å”¤é†’æ ‡è¯†ï¼Œæœ¬åç¨‹è¢«åŠ¨å”¤é†’ï¼Œä¸ä¼šæ‰§è¡Œawoke = trueç›¸å…³ä»£ç ã€‚</p>

<p>ä»æ‰§è¡Œæ¥çœ‹çŠ¶æ€å˜åŒ–
å‡å¦‚ä¾æ¬¡æ‰§è¡Œï¼š</p>

<p>Mutex mutex
mutex.Lock()  // aåç¨‹
mutex.Lock()  // båç¨‹
mutex.Lock()  // cåç¨‹
mutex.Unlock()  // aåç¨‹
mutex.Unlock()  // båç¨‹
mutex.Unlock()  // cåç¨‹
å®šä¹‰lockflagè¡¨ç¤ºåŠ é”ä½ï¼Œwokenflagè¡¨ç¤ºå”¤é†’ä½ï¼Œwaitcountè¡¨ç¤ºç­‰å¾…é˜Ÿåˆ—ä¸ªæ•°ã€‚</p>

<p>åŸå§‹ï¼šsema = 0ï¼Œ lockflag = 0ï¼Œ waitcount = 0ï¼Œwokenflag = 0
aä¸­lockåï¼šsema = 0ï¼Œ lockflag = 1ï¼Œ waitcount = 0ï¼Œwokenflag = 0
bä¸­lockåï¼šsema = -1ï¼Œ lockflag = 1ï¼Œ waitcount = 1ï¼Œwokenflag = 0
cä¸­lockåï¼šsema = -2ï¼Œ lockflag = 1ï¼Œ waitcount = 2ï¼Œwokenflagä¸­é—´è®¾ç½®ä¸º1ï¼Œåé¢ä¿®æ”¹ä¸º0
aä¸­unlockåï¼šsema = -1ï¼Œ lockflag = 1ï¼Œ waitcount = 1ï¼Œwokenflag ä¸­é—´è®¾ç½®ä¸º1ï¼Œåé¢è¢«å…¶ä»–åç¨‹ï¼ˆè¿™é‡Œä¸ºbï¼‰ä¿®æ”¹ä¸º0ã€‚
bä¸­unlockåï¼šsema = 0ï¼Œ lockflag = 1ï¼Œ waitcount = 0ï¼Œwokenflag ä¸­é—´è®¾ç½®ä¸º1ï¼Œåé¢è¢«å…¶ä»–åç¨‹ï¼ˆè¿™é‡Œä¸ºaï¼‰ä¿®æ”¹ä¸º0ã€‚
aä¸­unlockåï¼šsema = 0ï¼Œ lockflag = 0ï¼Œ waitcount = 0ï¼Œwokenflag = 0ã€‚
è¿™é‡Œè€ƒè™‘çš„æ˜¯æ¯”è¾ƒç®€å•çš„æƒ…å†µï¼Œä¸è¿‡å¯¹äºç†è§£ä»£ç é€»è¾‘å·²è¶³å¤Ÿã€‚</p>

:ET