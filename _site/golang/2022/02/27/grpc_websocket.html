<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">grpc websocket WebRTC</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2022-02-27T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Feb 27, 2022</time></p>
					</div>
					 <p>从本质上讲,HTTP/2是在后台运行服务器推送的客户端/服务器,因此您可以发出请求,只需在该连接上继续监听更新,而无需轮询.</p><br />
<br />
<p>虽然WebSockets不会因为HTTP/2而消失,但对于以”让我知道何时更新发生与我刚刚做过的事情有关”的用例来说,它们可能不被认为是必要的.</p><br />
<br />
<!-- more --><br />
<p>https://qa.1r1g.com/sf/ask/3283327211/</p><br />
<br />
<p>HTTP/2</p><br />
<br />
<p>WebSocket</p><br />
<br />
<p>Headers</p><br />
<br />
<p>Compressed (HPACK)</p><br />
<br />
<p>None</p><br />
<br />
<p>Binary</p><br />
<br />
<p>Yes</p><br />
<br />
<p>Binary or Textual</p><br />
<br />
<p>Multiplexing</p><br />
<br />
<p>Yes</p><br />
<br />
<p>Yes</p><br />
<br />
<p>Prioritization</p><br />
<br />
<p>Yes</p><br />
<br />
<p>No</p><br />
<br />
<p>Compression</p><br />
<br />
<p>Yes</p><br />
<br />
<p>Yes</p><br />
<br />
<p>Direction</p><br />
<br />
<p>Client/Server + Server Push</p><br />
<br />
<p>Bidirectional</p><br />
<br />
<p>Full-duplex</p><br />
<br />
<p>Yes</p><br />
<br />
<p>Yes</p><br />
<br />
<p>https://www.infoq.com/articles/websocket-and-http2-coexist/</p><br />
<br />
<p>WebSocket 是一个双向通信协议，它在握手阶段采用 HTTP/1.1 协议（暂时不支持 HTTP/2）。</p><br />
<br />
<p>握手过程如下：</p><br />
<br />
<p>首先客户端向服务端发起一个特殊的 HTTP 请求，其消息头如下：<br />
GET /chat HTTP/1.1  // 请求行<br />
Host: server.example.com<br />
Upgrade: websocket  // required<br />
Connection: Upgrade // required<br />
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ== // required，一个 16bits 编码得到的 base64 串<br />
Origin: http://example.com  // 用于防止未认证的跨域脚本使用浏览器 websocket api 与服务端进行通信<br />
Sec-WebSocket-Protocol: chat, superchat  // optional, 子协议协商字段<br />
Sec-WebSocket-Version: 13<br />
如果服务端支持该版本的 WebSocket，会返回 101 响应，响应标头如下：<br />
HTTP/1.1 101 Switching Protocols  // 状态行<br />
Upgrade: websocket   // required<br />
Connection: Upgrade  // required<br />
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo= // required，加密后的 Sec-WebSocket-Key<br />
Sec-WebSocket-Protocol: chat // 表明选择的子协议<br />
握手完成后，接下来的 TCP 数据包就都是 WebSocket 协议的帧了。</p><br />
<br />
<p>可以看到，这里的握手不是 TCP 的握手，而是在 TCP 连接内部，从 HTTP/1.1 upgrade 到 WebSocket 的握手。</p><br />
<br />
<p>WebSocket 提供两种协议：不加密的 ws:// 和 加密的 wss://. 因为是用 HTTP 握手，它和 HTTP 使用同样的端口：ws 是 80（HTTP），wss 是 443（HTTPS）</p><br />
<br />
<p>在 Python 编程中，可使用 websockets 实现的异步 WebSocket 客户端与服务端。此外 aiohttp 也提供了 WebSocket 支持。</p><br />
<br />
<p>Note：如果你搜索 Flask 的 WebScoket 插件，得到的第一个结果很可能是 Flask-SocketIO。但是 Flask-ScoektIO 使用的是它独有的 SocketIO 协议，并不是标准的 WebSocket。只是它刚好提供与 WebSocket 相同的功能而已。</p><br />
<br />
<p>SocketIO 的优势在于只要 Web 端使用了 SocketIO.js，就能支持该协议。而纯 WS 协议，只有较新的浏览器才支持。对于客户端非 Web 的情况，更好的选择可能是使用 Flask-Sockets。</p><br />
<br />
<p>https://www.cnblogs.com/kirito-c/p/10360309.html<br />
https://www.infoq.com/articles/websocket-and-http2-coexist/</p><br />
<br />
<p>一、基础</p><br />
<br />
<p>1、HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接；且只能从客户端主动请求服务端，服务端不能主动通知客户端。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 对于实时通信系统（聊天室或监控系统）这样显然是不合理的。传统的方法有：长轮询（客户端每隔很短的时间，都对服务器发出请求，当时间足够小就能实现实时的效果）、长连接（客户端只请求一次，但是服务器会将连接保持，当有数据时就返回结果给客户端）。这两种方式，都对客户端和服务器都造成了大量的性能浪费，于是WebSocket应运而生。WebSocket协议能够让浏览器和服务器全双工实时通信，互相的，服务器也能主动通知客户端。<br />
</code></pre></div></div><br />
<br />
<p>2、 WebSocket的原理非常的简单：利用HTTP请求产生握手，HTTP头部中含有WebSocket协议的请求，所以握手之后，二者转用TCP协议进行交流。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Socket.IO是业界良心，新手福音。它屏蔽了所有底层细节，让顶层调用非常简单。并且还为不支持WebSocket协议的浏览器，提供了长轮询的透明模拟机制。<br />
</code></pre></div></div><br />
<br />
<p>https://www.cnblogs.com/george93/p/7513334.html</p><br />
<br />
<p>　　WebRTC<br />
　　WebRTC（Web Real-Time Communication）。Real-Time Communication，实时通讯。</p><br />
<br />
<p>　　WebRTC能让web应用和站点之间选择性地分享音视频流。在不安装其它应用和插件的情况下，完成点对点通信。 WebRTC背后的技术被实现为一个开放的Web标准，并在所有主要浏览器中均以常规JavaScript API的形式提供。对于客户端（例如Android和iOS），可以使用提供相同功能的库。 WebRTC是个开源项目，得到Google，Apple，Microsoft和Mozilla等等公司的支持。2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准。</p><br />
<br />
<p>　　WebSocket<br />
　　WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。<br />
　　WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p><br />
<br />
<p>https://www.cnblogs.com/huanzi-qch/p/15716286.html</p><br />
<br />
<p>webrtc是p2p,去中心化的。而web socket还是有中心(服务端)的，webrtc在建立信道过程中，依赖web socket来传输sdp</p><br />
<br />
<p>Websocket 是浏览器 和 服务器之间传输数据。</p><br />
<br />
<p>Webrtc 是 能支持浏览器之间进行数据传输，当然浏览器之间的连接建立要依赖服务器，连接建立的过程中使用websocket传输协商数据。</p><br />
<br />
<p>https://www.zhihu.com/question/424264607/answer/1512337034</p><br />
<br />
<p>https://developer.mozilla.org/zh-CN/docs/Web/API<br />
WebSocket的主要问题是队首阻塞，我在稍后将详细说明什么是队首堵塞，这是推广WebSocket协议使用的一个主要障碍，不过WebSocket能随时提供可靠的传送服务。WebRTC数据通道的问题是建立连接的负担很高</p><br />
<br />
<p>那么为什么不使用现有的Web协议WebRTC呢？这张图表就能解释其中的原因，因为这是一个非常复杂的协议。它最初被构建为p2p通信协议，并且在建立连接之前会要求会话描述协议来进行SDP消息传递。在客户端服务器通信模型中我们不需要这样做，因为服务器端也需要通过客户端进行寻址。</p><br />
<br />
<p>WebRTC也要求的ICE、DTL、SCTP协议也通常不会再CDN中大规模部署。因此在某些情况下我们可以使用WebRTC，但WebRTC不是为服务器-客户端模型的应用程序而专门设计的。</p><br />
<br />
<p>https://segmentfault.com/a/1190000039710193?utm_source=tag-newest</p><br />
<br />
<p>建立一个WebRTC端到端连接需要3步：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              #1 信令<br />
<br />
              #2 发现<br />
<br />
              #3 连接建立<br />
</code></pre></div></div><br />
<br />
<p>第一步：信令</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     信令是建立WebRTC端到端连接的第一步。信令是想要建立端到端连接的两方用来交换初始信息的通道。<br />
<br />
     建立初始阶段需要交换下面几个信息：<br />
</code></pre></div></div><br />
<br />
<h1 id="参与各方的ip及可使用的端口号ice候选">参与各方的IP及可使用的端口号（ICE候选）</h1><br />
<br />
<h1 id="媒体功能">媒体功能</h1><br />
<br />
<h1 id="会话控制消息">会话控制消息</h1><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     Websocket被广泛应用于信令中。像Kurento这样的著名的WebRTC媒体服务器在使用它们。如果你想要在信令过程中进行安全的数据传输，那么建议你使用安全websocket（wss://）<br />
</code></pre></div></div><br />
<br />
<p>以Kurento为例，Kurento在8888端口接收websocket连接，在8443端口接收安全websocket连接。这个默认配置允许Kurento在你的网页服务器上平行运行，但因为它们使用的不是像80或者443这样的惯用端口，所以那些处于受限网络的电脑或者设备，有很大的可能性并不能与你的信令服务器通过这些端口进行通信。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     在端口80或者443上运行信令是你确保WebRTC高连接率所能做的第一件事。<br />
</code></pre></div></div><br />
<br />
<p>第二步：发现（STUN和TURN）</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     一旦在WebRTC终端和信令服务器之间建立了信令连接之后，就可以进行信息交换了。<br />
<br />
     其中一个重要的信息就是公共IP和每个终端可以使用的端口。对于直接连入互联网的电脑来说，想要寻找到IP并不是一个问题，因为它（OS）知道自身的公共IP地址，并且可以很简单地通过浏览器查询到。但是这对于处于本地网络中（路由器后方）的电脑和设备来说就会成为一个问题，也包括通过3G/4G连入网络的移动设备，因为它们的IP是本地网络分配的IP地址。<br />
<br />
     这些设备只知道它们自己的本地网络IP，所以它们使用STUN协议来：<br />
</code></pre></div></div><br />
<br />
<p>1 与STUN服务器进行通信，来找到它们网络的公共IP以及可到达的端口。</p><br />
<br />
<p>2 打穿一个双向的通道，通过网络路由器的隐性NAT功能。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     此外，对称NAT后的设备只能与之前进行过连接的设备通信，所以还需要一个TURN服务器传输由一端发送的数据，因为另一端终端无法穿过对称NAT与我们的设备直接连接。<br />
<br />
     每个WebRTC端点都要询问STUN/TURN服务器它们自己的公共IP和可连接的端口是什么。一旦接受到一个响应，WebRTC终端就会通过信令通道发送一个数据对给对方。这个IP:端口号对被叫做ICE候选。<br />
</code></pre></div></div><br />
<br />
<p>与STUN/TURN服务器的通信是第二个可能造成WebRTC连接失败的地方。我们已经遇到过3个可能造成失败的原因：</p><br />
<br />
<p>1 默认的STUN/TURN端口被屏蔽</p><br />
<br />
<p>2 所有UDP端口都被屏蔽</p><br />
<br />
<p>3 STUN/TURN协议被禁止使用</p><br />
<br />
<p>端口屏蔽</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     还记得我们建议通过端口80或者端口443建立信令连接吗？STUN和TURN有它们自己默认的端口（互不相同）：<br />
</code></pre></div></div><br />
<br />
<h1 id="发送或接听stunturn请求的默认端口为3478">发送（或接听）STUN/TURN请求的默认端口为3478。</h1><br />
<br />
<h1 id="通过tls发送或接听sturnturn的默认端口5349">通过TLS发送（或接听）STURN/TURN的默认端口5349。</h1><br />
<br />
<h1 id="一些服务器像google的通用stun服务器使用其他端口如19305和19307">一些服务器，像Google的通用STUN服务器，使用其他端口，如19305和19307。</h1><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     上述任何端口都可以被想要进行连接的两端之一所屏蔽。这些情况中，都无法连接到STUN/TURN服务器。<br />
<br />
     为了避免这些问题的发生，可以对STUN/TURN服务器使用惯用端口（443/80），但是UDP和协议屏蔽的问题还是没法解决。<br />
</code></pre></div></div><br />
<br />
<p>UDP屏蔽</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     默认STUN/TURN消息通过UDP传输，意味防火墙不允许DNS询问机制使用53端口，也就不允许STUN/TURN消息通过防火墙。<br />
<br />
     幸运的是，STUN/TURN服务器还可以通过TCP进行连接，通过指定URL中的transport参数来实现：turn:myTurnServer.com?transport=tcp<br />
<br />
     意思基本是告诉WebRTC客户“对于TURN/STUN服务器，通过TCP连接而不是UDP”。你也可以指定udp或者tls。<br />
</code></pre></div></div><br />
<br />
<p>STUN/TURN屏蔽</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     开发者可能遇到的一个更严重的情况是STUN/TURN协议消息同时被屏蔽。举个例子，我们已经发现Tunnel Bear VPN屏蔽了STUN/TURN数据包，因为即便你通过VPN连入网络它们也会暴露你的真实IP。在这种情况中，你除了让用户在进行WebRTC通话的时候关闭这类app以外并没有其他解决办法。<br />
</code></pre></div></div><br />
<br />
<p>第三步：建立连接</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     在每个WebRTC终端知道了对方的ICE候选之后，就可以建立端到端连接了<br />
     <br />
     在一些WebRTC用例中，比如视频录制，终端会同时作为信令服务器和WebRTC终端。<br />
<br />
     每个用户都会通过UDP向另一个终端发送数据：<br />
</code></pre></div></div><br />
<br />
<h1 id="如果是直接发送给对方的那么就可能将数据发送给0-65535之间任一端口">如果是直接发送给对方的，那么就可能将数据发送给0-65535之间任一端口</h1><br />
<br />
<h1 id="如果是发送给turn服务器的那么数据会发送给49152-65535之间的一个端口">如果是发送给TURN服务器的，那么数据会发送给49152-65535之间的一个端口</h1><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     没有一种方法可以控制这些端口，它们会在“发现”阶段中被分配并作为ICE候选的一部分。<br />
     <br />
     https://webrtc.org.cn/troubleshooting-connection/<br />
</code></pre></div></div><br />
<br />
<p>https://webrtc.org.cn/ice-restarts/</p><br />
<br />
<p>实现思路：<br />
两个浏览器打开同一页面，连接到同一个socket。<br />
此时由一端点击建立连接，发起建立连接的一端就是offer(携带信号源信息)，发给另外一个端，另外一个端收到offer之后，发出响应answer(携带信号源信息)，offer端收到answer端信息进行存储；这样每个端都有了自己的信息和对方的信息，offer发出answer发出后设置了localDescription和remoteDescription后就会触发onicecandidate，如此一来，双方都有了对方的localDescription、remoteDescription和candidata；有了这三种数据之后，就可以触发Connection.onaddstream函数,然后通过theirVideo.srcObject = e.stream这个方法，把流写到video标签内，然后video标签里就会有对方的视频画面了。</p><br />
<br />
<p>注意：这样实现之后不能直接调用NAVIGATOR.GETUSERMEDIA()函数，浏览器会默认GETUSERMEDIA为UNDIFINED，如果是互联网模式这里需要设置浏览(如果只是本地测试则不需要)（谷歌浏览器配置方法）；WEBRTC如只是P2P不需要特别服务器，自已开发信令服务就可以啦，当要安装TURN SERVER 国内常有打洞不成功需要转发。</p><br />
<br />
<p>https://www.freesion.com/article/62371393961/</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>