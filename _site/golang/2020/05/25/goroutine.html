<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">goroutine 启动运行详细过程</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-05-25T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> May 25, 2020</time></p>
					</div>
					 <p>https://juejin.im/post/5ec72e0951882542f346e672<br />
它跟线程有啥区别？原理是啥？<br />
都说他好，他好在哪里？<br />
使用上面有啥注意的？<br />
<!-- more --><br />
package main</p><br />
<br />
<p>import (<br />
	“fmt”<br />
)</p><br />
<br />
<p>func worker(stop chan bool) {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i:=0;i&lt;10;i++ {<br />
	fmt.Println("干活....")<br />
}<br />
stop &lt;- true }<br />
</code></pre></div></div><br />
<br />
<p>func main() {<br />
	stop := make(chan bool)<br />
	go worker(stop)<br />
	&lt;- stop<br />
}<br />
复制代码我们在main中新起了一个goroutine来干活。后台实现是runtime.newproc调用,函数体如下<br />
// 使用siz字节参数创建一个运行fn的新g。 <br />
// 将其放在g等待运行的队列中。 编译器将go语句转换为对此的调用。 <br />
// 无法拆分堆栈，因为它假定参数在＆fn;之后顺序可用。 <br />
// 如果发生堆栈拆分，则不会复制它们。<br />
//go:nosplit<br />
func newproc(siz int32, fn <em>funcval) {<br />
    // 从 fn 的地址增加一个指针的长度，从而获取第一参数地址<br />
	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)<br />
	// 获取当前的运行的g<br />
	gp := getg()<br />
	// getcallerpc返回其调用方的程序计数器（PC）。用于存放下一条指令所在单元的地址的地方。<br />
	pc := getcallerpc()<br />
	// systemstack在系统堆栈上运行<br />
	// 如果从每个OS线程（g0）堆栈调用systemstack<br />
	// ，或者从信号处理（gsignal）堆栈调用systemstack ，<br />
	// systemstack直接调用fn并返回。<br />
	// 否则，从普通goroutine的有限堆栈中调用systemstack。<br />
	// 在这种情况下，系统堆栈切换到每个OS线程堆栈，调用fn，然后切回。<br />
	// 通常使用func字面量作为参数，以便与调用系统堆栈周围的代码共享输入和输出<br />
	systemstack(func() {<br />
	    // 原型：func newproc1(fn *funcval, argp *uint8, narg int32, callergp *g, callerpc uintptr) <br />
	    // 创建一个新的g，运行fn，其中narg个字节的参数从argp开始。<br />
	    // callerpc是创建它的go语句的地址。新g放入g等待运行的队列中。<br />
		newproc1(fn, (</em>uint8)(argp), siz, gp, pc)<br />
	})<br />
}<br />
复制代码newproc1是重头戏，也比较复杂，可能目前还不能看的很明白，但是，大致先了解一下：<br />
func newproc1(fn *funcval, argp *uint8, narg int32, callergp *g, callerpc uintptr) {<br />
	<em>g</em> := getg()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if fn == nil {<br />
	_g_.m.throwing = -1 // do not dump full stacks<br />
	throw("go of nil func value")<br />
}<br />
_g_.m.locks++ // disable preemption because it can be holding p in a local var<br />
siz := narg<br />
siz = (siz + 7) &amp;^ 7<br />
<br />
// We could allocate a larger initial stack if necessary.<br />
// Not worth it: this is almost always an error.<br />
// 4*sizeof(uintreg): extra space added below<br />
// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).<br />
if siz &gt;= _StackMin-4*sys.RegSize-sys.RegSize {<br />
	throw("newproc: function arguments too large for new goroutine")<br />
}<br />
<br />
_p_ := _g_.m.p.ptr() <br />
newg := gfget(_p_) // 根据 p 获得一个新的 g<br />
// 初始化阶段，gfget 是不可能找到 g 的<br />
// 也可能运行中本来就已经耗尽了<br />
if newg == nil {<br />
	newg = malg(_StackMin) // 创建一个拥有 _StackMin 大小的栈的 g<br />
	casgstatus(newg, _Gidle, _Gdead) // 将新创建的 g 从 _Gidle 更新为 _Gdead 状态<br />
	allgadd(newg) // 将 Gdead 状态的 g 添加到 allg，这样 GC 不会扫描未初始化的栈<br />
}<br />
if newg.stack.hi == 0 {<br />
	throw("newproc1: newg missing stack")<br />
}<br />
<br />
if readgstatus(newg) != _Gdead {<br />
	throw("newproc1: new g is not Gdead")<br />
}<br />
<br />
totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame<br />
totalSize += -totalSize &amp; (sys.SpAlign - 1)                  // align to spAlign<br />
sp := newg.stack.hi - totalSize<br />
spArg := sp<br />
if usesLR {<br />
	// caller's LR<br />
	*(*uintptr)(unsafe.Pointer(sp)) = 0<br />
	prepGoExitFrame(sp)<br />
	spArg += sys.MinFrameSize<br />
}<br />
if narg &gt; 0 {<br />
	memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg))<br />
	// This is a stack-to-stack copy. If write barriers<br />
	// are enabled and the source stack is grey (the<br />
	// destination is always black), then perform a<br />
	// barrier copy. We do this *after* the memmove<br />
	// because the destination stack may have garbage on<br />
	// it.<br />
	if writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone {<br />
		f := findfunc(fn.fn)<br />
		stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))<br />
		if stkmap.nbit &gt; 0 {<br />
			// We're in the prologue, so it's always stack map index 0.<br />
			bv := stackmapdata(stkmap, 0)<br />
			bulkBarrierBitmap(spArg, spArg, uintptr(bv.n)*sys.PtrSize, 0, bv.bytedata)<br />
		}<br />
	}<br />
}<br />
<br />
memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))<br />
newg.sched.sp = sp<br />
newg.stktopsp = sp<br />
newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function<br />
newg.sched.g = guintptr(unsafe.Pointer(newg))<br />
gostartcallfn(&amp;newg.sched, fn)<br />
newg.gopc = callerpc<br />
newg.ancestors = saveAncestors(callergp)<br />
newg.startpc = fn.fn<br />
if _g_.m.curg != nil {<br />
	newg.labels = _g_.m.curg.labels<br />
}<br />
if isSystemGoroutine(newg, false) {<br />
	atomic.Xadd(&amp;sched.ngsys, +1)<br />
}<br />
newg.gcscanvalid = false<br />
casgstatus(newg, _Gdead, _Grunnable)<br />
<br />
if _p_.goidcache == _p_.goidcacheend {<br />
	// Sched.goidgen is the last allocated id,<br />
	// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].<br />
	// At startup sched.goidgen=0, so main goroutine receives goid=1.<br />
	_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)<br />
	_p_.goidcache -= _GoidCacheBatch - 1<br />
	_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch<br />
}<br />
newg.goid = int64(_p_.goidcache)<br />
_p_.goidcache++<br />
if raceenabled {<br />
	newg.racectx = racegostart(callerpc)<br />
}<br />
if trace.enabled {<br />
	traceGoCreate(newg, newg.startpc)<br />
}<br />
runqput(_p_, newg, true)<br />
<br />
if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 &amp;&amp; mainStarted {<br />
	wakep()<br />
}<br />
_g_.m.locks--<br />
if _g_.m.locks == 0 &amp;&amp; _g_.preempt { // restore the preemption request in case we've cleared it in newstack<br />
	_g_.stackguard0 = stackPreempt<br />
} } 复制代码也就是说，刚开始的时候，p上并没有可以使用的g,所以创建了一个具有很少栈容量的g. // 分配一个新的g，其堆栈足以容纳stacksize字节。 func malg(stacksize int32) *g {<br />
newg := new(g)<br />
if stacksize &gt;= 0 {<br />
	stacksize = round2(_StackSystem + stacksize)<br />
	systemstack(func() {<br />
		newg.stack = stackalloc(uint32(stacksize))<br />
	})<br />
	newg.stackguard0 = newg.stack.lo + _StackGuard<br />
	newg.stackguard1 = ^uintptr(0)<br />
}<br />
return newg } 复制代码分配的g是一个结构体指针,如果stacksize大于零，还将分配stack堆栈，该结构体具体内容如下： type g struct {<br />
// Stack parameters.<br />
// stack describes the actual stack memory: [stack.lo, stack.hi).<br />
// stackguard0 is the stack pointer compared in the Go stack growth prologue.<br />
// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.<br />
// stackguard1 is the stack pointer compared in the C stack growth prologue.<br />
// It is stack.lo+StackGuard on g0 and gsignal stacks.<br />
// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).<br />
stack       stack   // offset known to runtime/cgo<br />
stackguard0 uintptr // offset known to liblink<br />
stackguard1 uintptr // offset known to liblink<br />
<br />
_panic         *_panic // innermost panic - offset known to liblink<br />
_defer         *_defer // innermost defer<br />
m              *m      // current m; offset known to arm liblink<br />
sched          gobuf<br />
syscallsp      uintptr        // if status==Gsyscall, syscallsp = sched.sp to use during gc<br />
syscallpc      uintptr        // if status==Gsyscall, syscallpc = sched.pc to use during gc<br />
stktopsp       uintptr        // expected sp at top of stack, to check in traceback<br />
param          unsafe.Pointer // passed parameter on wakeup<br />
atomicstatus   uint32<br />
stackLock      uint32 // sigprof/scang lock; TODO: fold in to atomicstatus<br />
goid           int64<br />
schedlink      guintptr<br />
waitsince      int64      // approx time when the g become blocked<br />
waitreason     waitReason // if status==Gwaiting<br />
preempt        bool       // preemption signal, duplicates stackguard0 = stackpreempt<br />
paniconfault   bool       // panic (instead of crash) on unexpected fault address<br />
preemptscan    bool       // preempted g does scan for gc<br />
gcscandone     bool       // g has scanned stack; protected by _Gscan bit in status<br />
gcscanvalid    bool       // false at start of gc cycle, true if G has not run since last scan; TODO: remove?<br />
throwsplit     bool       // must not split stack<br />
raceignore     int8       // ignore race detection events<br />
sysblocktraced bool       // StartTrace has emitted EvGoInSyscall about this goroutine<br />
sysexitticks   int64      // cputicks when syscall has returned (for tracing)<br />
traceseq       uint64     // trace event sequencer<br />
tracelastp     puintptr   // last P emitted an event for this goroutine<br />
lockedm        muintptr<br />
sig            uint32<br />
writebuf       []byte<br />
sigcode0       uintptr<br />
sigcode1       uintptr<br />
sigpc          uintptr<br />
gopc           uintptr         // pc of go statement that created this goroutine<br />
ancestors      *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)<br />
startpc        uintptr         // pc of goroutine function<br />
racectx        uintptr<br />
waiting        *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order<br />
cgoCtxt        []uintptr      // cgo traceback context<br />
labels         unsafe.Pointer // profiler labels<br />
timer          *timer         // cached timer for time.Sleep<br />
selectDone     uint32         // are we participating in a select and did someone win the race?<br />
<br />
// Per-G GC state<br />
<br />
// gcAssistBytes is this G's GC assist credit in terms of<br />
// bytes allocated. If this is positive, then the G has credit<br />
// to allocate gcAssistBytes bytes without assisting. If this<br />
// is negative, then the G must correct this by performing<br />
// scan work. We track this in bytes to make it fast to update<br />
// and check for debt in the malloc hot path. The assist ratio<br />
// determines how this corresponds to scan work debt.<br />
gcAssistBytes int64 } 复制代码东西太多，目前能看懂的就是new过g后，分配了一个round2(_StackSystem + stacksize)个字节的stack. newg.stackguard0 = newg.stack.lo + _StackGuard newg.stackguard1 = ^uintptr(0) 复制代码然后将新生成的g的状态由_Gidle变成_Gdead。将 Gdead 状态的 g 添加到 allg切片中。 var (<br />
allgs    []*g<br />
allglock mutex )<br />
</code></pre></div></div><br />
<br />
<p>func allgadd(gp *g) {<br />
	if readgstatus(gp) == _Gidle {<br />
		throw(“allgadd: bad status Gidle”)<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lock(&amp;allglock)<br />
allgs = append(allgs, gp)<br />
allglen = uintptr(len(allgs))<br />
unlock(&amp;allglock) } 复制代码之后对g相关的sched字段进行初始化赋值,该字段类型是个结构体， type gobuf struct {<br />
// The offsets of sp, pc, and g are known to (hard-coded in) libmach.<br />
//<br />
// ctxt is unusual with respect to GC: it may be a<br />
// heap-allocated funcval, so GC needs to track it, but it<br />
// needs to be set and cleared from assembly, where it's<br />
// difficult to have write barriers. However, ctxt is really a<br />
// saved, live register, and we only ever exchange it between<br />
// the real register and the gobuf. Hence, we treat it as a<br />
// root during stack scanning, which means assembly that saves<br />
// and restores it doesn't need write barriers. It's still<br />
// typed as a pointer so that any other writes from Go get<br />
// write barriers.<br />
sp   uintptr<br />
pc   uintptr<br />
g    guintptr<br />
ctxt unsafe.Pointer<br />
ret  sys.Uintreg<br />
lr   uintptr<br />
bp   uintptr // for GOEXPERIMENT=framepointer } 复制代码该字段的功能，目前我们不得而知，先看<br />
memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))<br />
newg.sched.sp = sp<br />
newg.stktopsp = sp<br />
newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function<br />
newg.sched.g = guintptr(unsafe.Pointer(newg))<br />
gostartcallfn(&amp;newg.sched, fn) 复制代码调整Gobuf就像执行对fn的调用一样，然后立即执行gosave. func gostartcallfn(gobuf *gobuf, fv *funcval) {<br />
var fn unsafe.Pointer<br />
if fv != nil {<br />
	fn = unsafe.Pointer(fv.fn)<br />
} else {<br />
	fn = unsafe.Pointer(funcPC(nilfunc))<br />
}<br />
gostartcall(gobuf, fn, unsafe.Pointer(fv)) } 复制代码之后有一个将当前g的状态调整的动作 casgstatus(newg, _Gdead, _Grunnable) 复制代码可运行状态的g会被放入到本地的可运行队列中， runqput(_p_, newg, true) 复制代码该函数体如下： // runqput尝试将g放置在本地可运行队列中。  // 如果next为false，则runqput将g添加到可运行队列的尾部。 // 如果next为true，则runqput将g放在_p_.runnext插槽中。  // 如果运行队列已满，则runnext将g放入全局队列。  // 仅由所有者P执行。 func runqput(_p_ *p, gp *g, next bool) {<br />
if randomizeScheduler &amp;&amp; next &amp;&amp; fastrand()%2 == 0 {<br />
	next = false<br />
}<br />
<br />
if next {<br />
retryNext:<br />
	oldnext := _p_.runnext<br />
	if !_p_.runnext.cas(oldnext, guintptr(unsafe.Pointer(gp))) {<br />
		goto retryNext<br />
	}<br />
	if oldnext == 0 {<br />
		return<br />
	}<br />
	// Kick the old runnext out to the regular run queue.<br />
	gp = oldnext.ptr()<br />
}<br />
</code></pre></div></div><br />
<br />
<p>retry:<br />
	h := atomic.LoadAcq(&amp;<em>p</em>.runqhead) // load-acquire, synchronize with consumers<br />
	t := <em>p</em>.runqtail<br />
	if t-h &lt; uint32(len(<em>p</em>.runq)) {<br />
		<em>p</em>.runq[t%uint32(len(<em>p</em>.runq))].set(gp)<br />
		atomic.StoreRel(&amp;<em>p</em>.runqtail, t+1) // store-release, makes the item available for consumption<br />
		return<br />
	}<br />
	if runqputslow(<em>p</em>, gp, h, t) {<br />
		return<br />
	}<br />
	// the queue is not full, now the put above must succeed<br />
	goto retry<br />
}<br />
复制代码以上，关于g的内容，我们有了一个大致的了解，当我们将创建的g放到本地队列时，提到了一个结构体p,这个东西是什么呢？下面是他的结构体<br />
type p struct {<br />
	lock mutex</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id          int32<br />
status      uint32 // one of pidle/prunning/...<br />
link        puintptr<br />
schedtick   uint32     // incremented on every scheduler call<br />
syscalltick uint32     // incremented on every system call<br />
sysmontick  sysmontick // last tick observed by sysmon<br />
m           muintptr   // back-link to associated m (nil if idle)<br />
mcache      *mcache<br />
racectx     uintptr<br />
<br />
deferpool    [5][]*_defer // pool of available defer structs of different sizes (see panic.go)<br />
deferpoolbuf [5][32]*_defer<br />
<br />
// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.<br />
goidcache    uint64<br />
goidcacheend uint64<br />
<br />
// Queue of runnable goroutines. Accessed without lock.<br />
// 可运行goroutines的队列，访问无需锁，这个就是我们上述创建的g存放的位置<br />
runqhead uint32<br />
runqtail uint32<br />
runq     [256]guintptr<br />
// runnext（如果不是nil）是当前G准备好的可运行G，<br />
// 如果正在运行的G的时间片中还有剩余时间，则应下一个运行，而不是从runq中获取G。<br />
// 它将继承当前时间片中剩余的时间。<br />
// 如果将一组goroutine锁定为通信等待模式，<br />
// 则此调度会将其设置为一个单元，<br />
// 并消除（可能很大的）调度延迟，<br />
// 否则该延迟可能是由于将就绪的goroutine添加到运行队列的末尾而引起的。<br />
runnext guintptr<br />
<br />
// Available G's (status == Gdead)<br />
gFree struct {<br />
	gList<br />
	n int32<br />
}<br />
<br />
sudogcache []*sudog<br />
sudogbuf   [128]*sudog<br />
<br />
tracebuf traceBufPtr<br />
<br />
// traceSweep indicates the sweep events should be traced.<br />
// This is used to defer the sweep start event until a span<br />
// has actually been swept.<br />
traceSweep bool<br />
// traceSwept and traceReclaimed track the number of bytes<br />
// swept and reclaimed by sweeping in the current sweep loop.<br />
traceSwept, traceReclaimed uintptr<br />
<br />
palloc persistentAlloc // per-P to avoid mutex<br />
<br />
// Per-P GC state<br />
gcAssistTime         int64 // Nanoseconds in assistAlloc<br />
gcFractionalMarkTime int64 // Nanoseconds in fractional mark worker<br />
gcBgMarkWorker       guintptr<br />
gcMarkWorkerMode     gcMarkWorkerMode<br />
<br />
// gcMarkWorkerStartTime is the nanotime() at which this mark<br />
// worker started.<br />
gcMarkWorkerStartTime int64<br />
<br />
// gcw is this P's GC work buffer cache. The work buffer is<br />
// filled by write barriers, drained by mutator assists, and<br />
// disposed on certain GC state transitions.<br />
gcw gcWork<br />
<br />
// wbBuf is this P's GC write barrier buffer.<br />
//<br />
// TODO: Consider caching this in the running G.<br />
wbBuf wbBuf<br />
<br />
runSafePointFn uint32 // if 1, run sched.safePointFn at next safe point<br />
<br />
pad cpu.CacheLinePad } 复制代码在newproc函数中，从当前g获取p结构时，通过的是g的m字段，该字段是个什么呢？是个m结构体指针，m的结构体原型为： type m struct {<br />
g0      *g     // 用于执行调度指令的 goroutine<br />
morebuf gobuf  // gobuf arg to morestack<br />
divmod  uint32 // div/mod denominator for arm - known to liblink<br />
<br />
// Fields not known to debuggers.<br />
procid        uint64       // for debuggers, but offset not hard-coded<br />
gsignal       *g           // 处理 signal 的 g<br />
goSigStack    gsignalStack // Go-allocated signal handling stack<br />
sigmask       sigset       // storage for saved signal mask<br />
tls           [6]uintptr   // 线程本地存储<br />
mstartfn      func()<br />
curg          *g       // 当前运行的G<br />
caughtsig     guintptr // goroutine running during fatal signal<br />
p             puintptr // 执行 go 代码时持有的 p (如果没有执行则为 nil)<br />
nextp         puintptr<br />
oldp          puintptr // the p that was attached before executing a syscall<br />
id            int64<br />
mallocing     int32<br />
throwing      int32<br />
preemptoff    string // if != "", keep curg running on this m<br />
locks         int32<br />
dying         int32<br />
profilehz     int32<br />
spinning      bool // m 当前没有运行 work 且正处于寻找 work 的活跃状态<br />
blocked       bool // m is blocked on a note<br />
inwb          bool // m is executing a write barrier<br />
newSigstack   bool // minit on C thread called sigaltstack<br />
printlock     int8<br />
incgo         bool   // m is executing a cgo call<br />
freeWait      uint32 // if == 0, safe to free g0 and delete m (atomic)<br />
fastrand      [2]uint32<br />
needextram    bool<br />
traceback     uint8<br />
ncgocall      uint64      // number of cgo calls in total<br />
ncgo          int32       // number of cgo calls currently in progress<br />
cgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily<br />
cgoCallers    *cgoCallers // cgo traceback if crashing in cgo call<br />
park          note<br />
alllink       *m // on allm<br />
schedlink     muintptr<br />
mcache        *mcache<br />
lockedg       guintptr<br />
createstack   [32]uintptr    // stack that created this thread.<br />
lockedExt     uint32         // tracking for external LockOSThread<br />
lockedInt     uint32         // tracking for internal lockOSThread<br />
nextwaitm     muintptr       // next m waiting for lock<br />
waitunlockf   unsafe.Pointer // todo go func(*g, unsafe.pointer) bool<br />
waitlock      unsafe.Pointer<br />
waittraceev   byte<br />
waittraceskip int<br />
startingtrace bool<br />
syscalltick   uint32<br />
thread        uintptr // thread handle<br />
freelink      *m      // on sched.freem<br />
<br />
// these are here because they are too large to be on the stack<br />
// of low-level NOSPLIT functions.<br />
libcall   libcall<br />
libcallpc uintptr // for cpu profiler<br />
libcallsp uintptr<br />
libcallg  guintptr<br />
syscall   libcall // stores syscall parameters on windows<br />
<br />
vdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call)<br />
vdsoPC uintptr // PC for traceback while in VDSO call<br />
<br />
mOS } 复制代码看了上面的结构体感觉很空洞，都是些什么呢？就知道newproc时，创建的G,放到了关联的P的本地可运行队列中，要明白这些东西是什么，就要从他们是如何产生的说起？ ➜  goroutinetest gdb main GNU gdb (GDB) 8.3 Copyright (C) 2019 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type "show copying" and "show warranty" for details. This GDB was configured as "x86_64-apple-darwin16.7.0". Type "show configuration" for configuration details. For bug reporting instructions, please see:<br />
</code></pre></div></div><br />
<p><a href="http://www.gnu.org/software/gdb/bugs/">http://www.gnu.org/software/gdb/bugs/</a>.<br />
Find the GDB manual and other documentation resources online at:<br />
    <a href="http://www.gnu.org/software/gdb/documentation/">http://www.gnu.org/software/gdb/documentation/</a>.</p><br />
<br />
<p>For help, type “help”.<br />
Type “apropos word” to search for commands related to “word”…<br />
Reading symbols from main…<br />
(No debugging symbols found in main)<br />
Loading Go Runtime support.<br />
(gdb) info files<br />
Symbols from “/Users/zhaojunwei/workspace/src/just.for.test/goroutinetest/main”.<br />
Local exec file:<br />
	`/Users/zhaojunwei/workspace/src/just.for.test/goroutinetest/main’, file type mach-o-x86-64.<br />
	Entry point: 0x1052770<br />
	0x0000000001001000 - 0x0000000001093194 is .text<br />
	0x00000000010931a0 - 0x00000000010e1ace is __TEXT.__rodata<br />
	0x00000000010e1ae0 - 0x00000000010e1be2 is __TEXT.__symbol_stub1<br />
	0x00000000010e1c00 - 0x00000000010e2864 is __TEXT.__typelink<br />
	0x00000000010e2868 - 0x00000000010e28d0 is __TEXT.__itablink<br />
	0x00000000010e28d0 - 0x00000000010e28d0 is __TEXT.__gosymtab<br />
	0x00000000010e28e0 - 0x000000000115c108 is __TEXT.__gopclntab<br />
	0x000000000115d000 - 0x000000000115d158 is __DATA.__nl_symbol_ptr<br />
	0x000000000115d160 - 0x0000000001169c9c is __DATA.__noptrdata<br />
	0x0000000001169ca0 - 0x0000000001170610 is .data<br />
	0x0000000001170620 - 0x000000000118be50 is .bss<br />
	0x000000000118be60 - 0x000000000118e418 is __DATA.__noptrbss<br />
(gdb)<br />
(gdb) b *0x1052770<br />
Breakpoint 1 at 0x1052770<br />
(gdb) info br<br />
Num     Type           Disp Enb Address            What<br />
1       breakpoint     keep y   0x0000000001052770 <_rt0_amd64_darwin><br />
(gdb)<br />
复制代码查看一下_rt0_amd64_darwin是什么？<br />
#include "textflag.h"</_rt0_amd64_darwin></p><br />
<br />
<p>TEXT _rt0_amd64_darwin(SB),NOSPLIT,$-8<br />
	JMP	_rt0_amd64(SB)</p><br />
<br />
<p>// When linking with -shared, this symbol is called when the shared library<br />
// is loaded.<br />
TEXT _rt0_amd64_darwin_lib(SB),NOSPLIT,$0<br />
	JMP	_rt0_amd64_lib(SB)</p><br />
<br />
<p>复制代码_rt0_amd64是使用内部链接时大多数amd64系统的通用启动代码。 这是内核中普通-buildmode = exe程序的程序入口点。 堆栈保存参数数量和C风格的argv。<br />
TEXT _rt0_amd64(SB),NOSPLIT,$-8<br />
	MOVQ	0(SP), DI	// argc<br />
	LEAQ	8(SP), SI	// argv<br />
	JMP	runtime·rt0_go(SB)<br />
复制代码最终调用的是runtime.rt0_go方法<br />
TEXT runtime·rt0_go(SB),NOSPLIT,$0<br />
	// SP = stack; R0 = argc; R1 = argv</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SUB	$32, RSP<br />
MOVW	R0, 8(RSP) // argc<br />
MOVD	R1, 16(RSP) // argv<br />
<br />
// create istack out of the given (operating system) stack.<br />
// _cgo_init may update stackguard.<br />
MOVD	$runtime·g0(SB), g<br />
MOVD	RSP, R7<br />
MOVD	$(-64*1024)(R7), R0<br />
MOVD	R0, g_stackguard0(g)<br />
MOVD	R0, g_stackguard1(g)<br />
MOVD	R0, (g_stack+stack_lo)(g)<br />
MOVD	R7, (g_stack+stack_hi)(g)<br />
<br />
// if there is a _cgo_init, call it using the gcc ABI.<br />
MOVD	_cgo_init(SB), R12<br />
CMP	$0, R12<br />
BEQ	nocgo<br />
<br />
MRS_TPIDR_R0			// load TLS base pointer<br />
MOVD	R0, R3			// arg 3: TLS base pointer #ifdef TLSG_IS_VARIABLE<br />
MOVD	$runtime·tls_g(SB), R2 	// arg 2: &amp;tls_g #else<br />
MOVD	$0, R2		        // arg 2: not used when using platform's TLS #endif<br />
MOVD	$setg_gcc&lt;&gt;(SB), R1	// arg 1: setg<br />
MOVD	g, R0			// arg 0: G<br />
SUB	$16, RSP		// reserve 16 bytes for sp-8 where fp may be saved.<br />
BL	(R12)<br />
ADD	$16, RSP<br />
</code></pre></div></div><br />
<br />
<p>nocgo:<br />
	BL	runtime·save_g(SB)<br />
	// update stackguard after _cgo_init<br />
	MOVD	(g_stack+stack_lo)(g), R0<br />
	ADD	$const__StackGuard, R0<br />
	MOVD	R0, g_stackguard0(g)<br />
	MOVD	R0, g_stackguard1(g)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// set the per-goroutine and per-mach "registers"<br />
MOVD	$runtime·m0(SB), R0<br />
<br />
// save m-&gt;g0 = g0<br />
MOVD	g, m_g0(R0)<br />
// save m0 to g0-&gt;m<br />
MOVD	R0, g_m(g)<br />
<br />
BL	runtime·check(SB)<br />
<br />
MOVW	8(RSP), R0	// copy argc<br />
MOVW	R0, -8(RSP)<br />
MOVD	16(RSP), R0		// copy argv<br />
MOVD	R0, 0(RSP)<br />
BL	runtime·args(SB)<br />
BL	runtime·osinit(SB)<br />
BL	runtime·schedinit(SB)<br />
<br />
// create a new goroutine to start program<br />
MOVD	$runtime·mainPC(SB), R0		// entry<br />
MOVD	RSP, R7<br />
MOVD.W	$0, -8(R7)<br />
MOVD.W	R0, -8(R7)<br />
MOVD.W	$0, -8(R7)<br />
MOVD.W	$0, -8(R7)<br />
MOVD	R7, RSP<br />
BL	runtime·newproc(SB)<br />
ADD	$32, RSP<br />
<br />
// start this M<br />
BL	runtime·mstart(SB)<br />
<br />
MOVD	$0, R0<br />
MOVD	R0, (R0)	// boom<br />
UNDEF 复制代码首先进行g0和m0的初始化，之后进行本地线程存储的检测设置。之后尽心调度器的初始化，并创建一个新的goroutine运行程序，最后开启我们的M. // The bootstrap sequence is: // //	call osinit //	call schedinit //	make &amp; queue new G //	call runtime·mstart // // The new G calls runtime·main. func schedinit() {<br />
// raceinit must be the first call to race detector.<br />
// In particular, it must be done before mallocinit below calls racemapshadow.<br />
_g_ := getg()<br />
if raceenabled {<br />
	_g_.racectx, raceprocctx0 = raceinit()<br />
}<br />
// 设置最多启动10000个操作系统线程，也是最多10000个M<br />
sched.maxmcount = 10000<br />
<br />
tracebackinit()<br />
moduledataverify()<br />
stackinit()<br />
mallocinit()<br />
mcommoninit(_g_.m) // 初始化m0，因为从前面的代码我们知道g0-&gt;m = &amp;m0<br />
cpuinit()       // must run before alginit<br />
alginit()       // maps must not be used before this call<br />
modulesinit()   // provides activeModules<br />
typelinksinit() // uses maps, activeModules<br />
itabsinit()     // uses activeModules<br />
<br />
msigsave(_g_.m)<br />
initSigmask = _g_.m.sigmask<br />
<br />
goargs()<br />
goenvs()<br />
parsedebugvars()<br />
gcinit()<br />
<br />
sched.lastpoll = uint64(nanotime())<br />
// 系统中有多少核，就创建和初始化多少个p结构体对象<br />
procs := ncpu<br />
if n, ok := atoi32(gogetenv("GOMAXPROCS")); ok &amp;&amp; n &gt; 0 {<br />
    // 如果环境变量指定了GOMAXPROCS，则创建指定数量的p<br />
	procs = n<br />
}<br />
// 创建和初始化全局变量allp<br />
if procresize(procs) != nil {<br />
	throw("unknown runnable goroutine during bootstrap")<br />
}<br />
<br />
// For cgocheck &gt; 1, we turn on the write barrier at all times<br />
// and check all pointer writes. We can't do this until after<br />
// procresize because the write barrier needs a P.<br />
if debug.cgocheck &gt; 1 {<br />
	writeBarrier.cgo = true<br />
	writeBarrier.enabled = true<br />
	for _, p := range allp {<br />
		p.wbBuf.reset()<br />
	}<br />
}<br />
<br />
if buildVersion == "" {<br />
	// Condition should never trigger. This code just serves<br />
	// to ensure runtime·buildVersion is kept in the resulting binary.<br />
	buildVersion = "unknown"<br />
} } 复制代码我们来关注一下m0是如何初始化的 func mcommoninit(mp *m) {<br />
_g_ := getg()<br />
<br />
// g0 stack won't make sense for user (and is not necessary unwindable).<br />
if _g_ != _g_.m.g0 {<br />
	callers(1, mp.createstack[:])<br />
}<br />
<br />
lock(&amp;sched.lock)<br />
if sched.mnext+1 &lt; sched.mnext {<br />
	throw("runtime: thread ID overflow")<br />
}<br />
// m0分配的id,schedt结构体的mnext字段标识下一个可用的thread id.<br />
mp.id = sched.mnext<br />
sched.mnext++<br />
<br />
checkmcount()<br />
<br />
mp.fastrand[0] = 1597334677 * uint32(mp.id)<br />
mp.fastrand[1] = uint32(cputicks())<br />
if mp.fastrand[0]|mp.fastrand[1] == 0 {<br />
	mp.fastrand[1] = 1<br />
}<br />
<br />
mpreinit(mp)<br />
if mp.gsignal != nil {<br />
	mp.gsignal.stackguard1 = mp.gsignal.stack.lo + _StackGuard<br />
}<br />
<br />
// Add to allm so garbage collector doesn't free g-&gt;m<br />
// when it is just in a register or thread-local storage.<br />
// allm挂到这里，防止被垃圾回收<br />
mp.alllink = allm<br />
<br />
// NumCgoCall() iterates over allm w/o schedlock,<br />
// so we need to publish it safely.<br />
atomicstorep(unsafe.Pointer(&amp;allm), unsafe.Pointer(mp))<br />
unlock(&amp;sched.lock)<br />
<br />
// Allocate memory to hold a cgo traceback if the cgo call crashes.<br />
if iscgo || GOOS == "solaris" || GOOS == "windows" {<br />
	mp.cgoCallers = new(cgoCallers)<br />
} } 复制代码调度器初始化最后一部分工作就是p的初始化<br />
</code></pre></div></div><br />
<br />
<p>初始化调度后，开启新的goroutine运行我们的主程序，然后调用runtime.mstart开启M.<br />
func mstart() {<br />
	<em>g</em> := getg()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 通过检查 g 执行占的边界来确定是否为系统栈<br />
osStack := _g_.stack.lo == 0<br />
if osStack {<br />
	// Initialize stack bounds from system stack.<br />
	// Cgo may have left stack size in stack.hi.<br />
	// minit may update the stack bounds.<br />
	size := _g_.stack.hi<br />
	if size == 0 {<br />
		size = 8192 * sys.StackGuardMultiplier<br />
	}<br />
	_g_.stack.hi = uintptr(noescape(unsafe.Pointer(&amp;size)))<br />
	_g_.stack.lo = _g_.stack.hi - size + 1024<br />
}<br />
// Initialize stack guards so that we can start calling<br />
// both Go and C functions with stack growth prologues.<br />
_g_.stackguard0 = _g_.stack.lo + _StackGuard<br />
_g_.stackguard1 = _g_.stackguard0<br />
// 启动m<br />
mstart1()<br />
<br />
// Exit this thread.<br />
if GOOS == "windows" || GOOS == "solaris" || GOOS == "plan9" || GOOS == "darwin" || GOOS == "aix" {<br />
	// Window, Solaris, Darwin, AIX and Plan 9 always system-allocate<br />
	// the stack, but put it in _g_.stack before mstart,<br />
	// so the logic above hasn't set osStack yet.<br />
	osStack = true<br />
}<br />
mexit(osStack) }<br />
</code></pre></div></div><br />
<br />
<p>func mstart1() {<br />
	<em>g</em> := getg()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if _g_ != _g_.m.g0 {<br />
	throw("bad runtime·mstart")<br />
}<br />
<br />
// Record the caller for use as the top of stack in mcall and<br />
// for terminating the thread.<br />
// We're never coming back to mstart1 after we call schedule,<br />
// so other calls can reuse the current frame.<br />
save(getcallerpc(), getcallersp())<br />
asminit()<br />
minit()<br />
<br />
// Install signal handlers; after minit so that minit can<br />
// prepare the thread to be able to handle the signals.<br />
if _g_.m == &amp;m0 {<br />
	mstartm0()<br />
}<br />
<br />
if fn := _g_.m.mstartfn; fn != nil {<br />
	fn()<br />
}<br />
// 如果当前 m 并非 m0，则要求绑定 p<br />
if _g_.m != &amp;m0 {<br />
	acquirep(_g_.m.nextp.ptr())<br />
	_g_.m.nextp = 0<br />
}<br />
schedule() } 复制代码在mstart1中，调用了schedule函数：一轮调度程序：找到一个可运行的goroutine并执行它。永不return. func schedule() {<br />
_g_ := getg()<br />
<br />
if _g_.m.locks != 0 {<br />
	throw("schedule: holding locks")<br />
}<br />
<br />
if _g_.m.lockedg != 0 {<br />
	stoplockedm()<br />
	execute(_g_.m.lockedg.ptr(), false) // Never returns.<br />
}<br />
<br />
// We should not schedule away from a g that is executing a cgo call,<br />
// since the cgo call is using the m's g0 stack.<br />
if _g_.m.incgo {<br />
	throw("schedule: in cgo")<br />
}<br />
</code></pre></div></div><br />
<br />
<p>top:<br />
	if sched.gcwaiting != 0 {<br />
		gcstopm()<br />
		goto top<br />
	}<br />
	if <em>g</em>.m.p.ptr().runSafePointFn != 0 {<br />
		runSafePointFn()<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var gp *g<br />
var inheritTime bool<br />
if trace.enabled || trace.shutdown {<br />
	gp = traceReader()<br />
	if gp != nil {<br />
		casgstatus(gp, _Gwaiting, _Grunnable)<br />
		traceGoUnpark(gp, 0)<br />
	}<br />
}<br />
if gp == nil &amp;&amp; gcBlackenEnabled != 0 {<br />
	gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())<br />
}<br />
if gp == nil {<br />
	// // 说明不在 GC<br />
	//<br />
	// 每调度 61 次，就检查一次全局队列，保证公平性<br />
	// 否则两个 goroutine 可以通过互相 respawn 一直占领本地的 runqueue<br />
	if _g_.m.p.ptr().schedtick%61 == 0 &amp;&amp; sched.runqsize &gt; 0 {<br />
		lock(&amp;sched.lock)<br />
		// 从全局队列中偷 g<br />
		gp = globrunqget(_g_.m.p.ptr(), 1)<br />
		unlock(&amp;sched.lock)<br />
	}<br />
}<br />
if gp == nil {<br />
	gp, inheritTime = runqget(_g_.m.p.ptr())<br />
	if gp != nil &amp;&amp; _g_.m.spinning {<br />
		throw("schedule: spinning with local work")<br />
	}<br />
}<br />
if gp == nil {<br />
	gp, inheritTime = findrunnable() // 如果偷都偷不到，则休眠，在此阻塞<br />
}<br />
<br />
// 该线程将运行goroutine，并且不再自旋，<br />
// 因此，如果将其标记为正在自旋，则需要立即将其重置并可能启动新自旋的M。<br />
if _g_.m.spinning {<br />
	resetspinning()<br />
}<br />
<br />
if sched.disable.user &amp;&amp; !schedEnabled(gp) {<br />
	// Scheduling of this goroutine is disabled. Put it on<br />
	// the list of pending runnable goroutines for when we<br />
	// re-enable user scheduling and look again.<br />
	lock(&amp;sched.lock)<br />
	if schedEnabled(gp) {<br />
		// Something re-enabled scheduling while we<br />
		// were acquiring the lock.<br />
		unlock(&amp;sched.lock)<br />
	} else {<br />
		sched.disable.runnable.pushBack(gp)<br />
		sched.disable.n++<br />
		unlock(&amp;sched.lock)<br />
		goto top<br />
	}<br />
}<br />
<br />
if gp.lockedm != 0 {<br />
	// Hands off own p to the locked m,<br />
	// then blocks waiting for a new p.<br />
	startlockedm(gp)<br />
	goto top<br />
}<br />
<br />
// 开始执行<br />
execute(gp, inheritTime) }<br />
</code></pre></div></div><br />
<br />
<p>复制代码如果m处在自旋的状态，那么将调用resetspinning方法，<br />
func resetspinning() {<br />
	<em>g</em> := getg()<br />
	if !<em>g</em>.m.spinning {<br />
		throw(“resetspinning: not a spinning m”)<br />
	}<br />
	<em>g</em>.m.spinning = false<br />
	nmspinning := atomic.Xadd(&amp;sched.nmspinning, -1)<br />
	if int32(nmspinning) &lt; 0 {<br />
		throw(“findrunnable: negative nmspinning”)<br />
	}<br />
	// M的唤醒策略故意有些保守，因此请检查是否需要在此处唤醒另一个P。<br />
	// 有关详细信息，请参见文件顶部的“工作线程park/unpark”注释。<br />
	if nmspinning == 0 &amp;&amp; atomic.Load(&amp;sched.npidle) &gt; 0 {<br />
		wakep()<br />
	}<br />
}<br />
复制代码wakep()尝试再添加一个P以执行G。 当G变为可运行时调用（newproc，就绪）.该函数会调用startm(nil, true).startm函数调度一些M以运行p（必要时创建M）。 如果p == nil，则尝试获取一个空闲P，如果没有空闲P则不执行任何操作。 可以与m.p == nil一起运行，因此不允许写障碍。 如果设置了旋转，则调用者已增加nmspinning，并且startm将减少nmspinning或在新启动的M中设置m.spinning。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>