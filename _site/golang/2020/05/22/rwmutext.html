<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">map 加锁与sync.Map性能对比分析</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-05-22T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> May 22, 2020</time></p>
					</div>
					 <p>sync.Map，读写锁的适用场景<br />
实现方式	原理	适用场景<br />
map+Mutex	通过Mutex互斥锁来实现多个goroutine对map的串行化访问	读写都需要通过Mutex加锁和释放锁，适用于读写比接近的场景<br />
map+RWMutex	通过RWMutex来实现对map的读写进行读写锁分离加锁，从而实现读的并发性能提高	同Mutex相比适用于读多写少的场景<br />
sync.Map	底层通分离读写map和原子指令来实现读的近似无锁，并通过延迟更新的方式来保证读的无锁化	读多修改少，元素增加删除频率不高的情况，在大多数情况下替代上述两种实现<br />
<!-- more --><br />
https://blog.csdn.net/u010853261/article/details/103848666</p><br />
<br />
<p>golang支持map关键字，golang的map的读写是编译成runtime的函数调用。但是默认的map是非线程安全的。go 1.9 版本中支持了 sync.Map 用于线程安全的map。<br />
关于go map的实现可以参考：Golang map实践以及实现原理</p><br />
<br />
<p>支持并发的map<br />
golang内置的map读写操作，很多都是编译器帮我们转换成runtime的函数调用，而且整体的设计比较封闭，没有留下扩展的空间。</p><br />
<br />
<p>要支持线程安全的map，一种方式就是在go内置的map上进行封装。比较简单的就是使用sync提供的锁来实现，这种是最简单的，具体情况这里就不说了。</p><br />
<br />
<p>sync.Map<br />
go 1.9 官方提供了sync.Map 来优化线程安全的并发读写的map。该实现也是基于内置map关键字来实现的。</p><br />
<br />
<p>这个实现类似于一个线程安全的 map[interface{}]interface{} . 这个map的优化主要适用了以下场景：</p><br />
<br />
<p>（1）给定key的键值对只写了一次，但是读了很多次，比如在只增长的缓存中；<br />
（2）当多个goroutine读取、写入和覆盖的key值不相交时。</p><br />
<br />
<p>在这两种情况下，使用Map可能比使用单独互斥锁或RWMutex的Go Map大大减少锁争用。</p><br />
<br />
<p>对于其余情况最好还是使用RWMutex保证线程安全。</p><br />
<br />
<p>数据结构<br />
先看一下底层的数据结构：</p><br />
<br />
<p>// 封装的线程安全的map<br />
type Map struct {<br />
	// lock<br />
	mu Mutex</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 实际是readOnly这个结构<br />
// 一个只读的数据结构，因为只读，所以不会有读写冲突。<br />
// readOnly包含了map的一部分数据，用于并发安全的访问。(冗余，内存换性能)<br />
// 访问这一部分不需要锁。<br />
read atomic.Value // readOnly<br />
<br />
// dirty数据包含当前的map包含的entries,它包含最新的entries(包括read中未删除的数据,虽有冗余，但是提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。<br />
// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。<br />
// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。<br />
dirty map[interface{}]*entry<br />
<br />
// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，<br />
// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁。<br />
misses int }<br />
</code></pre></div></div><br />
<br />
<p>// readOnly is an immutable struct stored atomically in the Map.read field.<br />
type readOnly struct {<br />
	m       map[interface{}]*entry<br />
	// 如果Map.dirty有些数据不在m中，这个值为true<br />
	amended bool <br />
}</p><br />
<br />
<p>// An entry is a slot in the map corresponding to a particular key.<br />
type entry struct {<br />
	// *interface{}<br />
	p unsafe.Pointer <br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
25<br />
26<br />
27<br />
28<br />
29<br />
30<br />
31<br />
32<br />
33<br />
readOnly.amended指明Map.dirty中有readOnly.m未包含的数据，所以如果从Map.read找不到数据的话，还要进一步到Map.dirty中查找。</p><br />
<br />
<p>这里虽然有冗余的两份map数据，但是Map.dirty和readOnly.m的value都是一个指针变量 *entry，所以整体内存占用还好。</p><br />
<br />
<p>sync.Map 的kv都是 interface{} ，entry里面的p实际是一个 *interface{}，也就是entry实际保存的是指向value的指针。</p><br />
<br />
<p>这里p有三个值：</p><br />
<br />
<p>nil: entry已被删除了，并且m.dirty为nil<br />
expunged: entry已被删除了，并且m.dirty不为nil，而且这个entry不存在于m.dirty中<br />
其它： entry是一个正常的value<br />
sync.Map也是在golang提供的map关键字之上封装实现的。</p><br />
<br />
<p>sync.Map 整体的优化可以描述为以下几点：</p><br />
<br />
<p>空间换时间。 通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。<br />
map只保存key和对应的value的指针，这样可以并发的读写map, 实际更新指向value的指针再通过基于CAS的无锁atomic。<br />
使用只读数据(read)，避免读写冲突<br />
动态调整，miss次数多了之后，将dirty数据提升为read。<br />
double-checking。<br />
延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。<br />
优先从read读取、更新、删除，因为对read的读取不需要锁。<br />
Load<br />
线程安全的加载key对应的value：</p><br />
<br />
<p>func (m *Map) Load(key interface{}) (value interface{}, ok bool) {<br />
	// 1.首先从m.read中加载只读的readOnly, 从它的map中查找，无锁。<br />
	read, _ := m.read.Load().(readOnly)<br />
	e, ok := read.m[key]<br />
	// 2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁<br />
	if !ok &amp;&amp; read.amended {<br />
		m.mu.Lock()<br />
		// double check<br />
		read, _ = m.read.Load().(readOnly)<br />
		e, ok = read.m[key]<br />
		if !ok &amp;&amp; read.amended {<br />
			// // 从m.dirty查找<br />
			e, ok = m.dirty[key]<br />
			// 不管m.dirty中存不存在，都将misses计数加一<br />
			// missLocked()中满足条件后就会提升m.dirty<br />
			m.missLocked()<br />
		}<br />
		m.mu.Unlock()<br />
	}<br />
	if !ok {<br />
		return nil, false<br />
	}<br />
	// 原子加载 *entry 所保存的value。<br />
	return e.load()<br />
}</p><br />
<br />
<p>func (m *Map) missLocked() {<br />
	m.misses++<br />
	if m.misses &lt; len(m.dirty) {<br />
		return<br />
	}<br />
	m.read.Store(readOnly{m: m.dirty})<br />
	m.dirty = nil<br />
	m.misses = 0<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
25<br />
26<br />
27<br />
28<br />
29<br />
30<br />
31<br />
32<br />
33<br />
34<br />
35<br />
整体pipeline如下图：</p><br />
<br />
<p>首先要强调的是，首先是从readonly里面读，读不到时候才加锁去 map.dirty 里面去读，并且加锁之后首先是进行double check(熟悉Java的都知道double check是什么)。</p><br />
<br />
<p>double check 之后即使不存在于m.read中，经过miss几次之后，m.dirty会被提升为m.read，又会从m.read中查找。所以对于更新／增加较少，加载存在的key很多的case,性能基本和无锁的map类似。</p><br />
<br />
<p>missLocked方法中可能会将m.dirty提升，m,misses会记录从readOnly中获取不到 *entry 的次数，也就是miss的次数，如果达到了 len(m.dirty) 就会原子的替换m.read.m 为 m.dirty。提升后m.dirty、m.misses重置， 并且m.read.amended为false。</p><br />
<br />
<p>Store<br />
安全的更新一个key对应的value:</p><br />
<br />
<p>// Store sets the value for a key.<br />
func (m *Map) Store(key, value interface{}) {<br />
	// 1. 如果m.read存在这个键，并且这个entry没有被标记删除(expunged)，那么cas自旋更新value。<br />
	// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。<br />
	read, _ := m.read.Load().(readOnly)<br />
	if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {<br />
		return<br />
	}<br />
	// 2. m.read不存在或者已经被标记删除<br />
	m.mu.Lock()<br />
	// double check<br />
	read, _ = m.read.Load().(readOnly)<br />
	if e, ok := read.m[key]; ok {<br />
		if e.unexpungeLocked() {//标记成未被删除<br />
			//m.dirty中不存在这个键，所以加入m.dirty<br />
			m.dirty[key] = e<br />
		}<br />
		e.storeLocked(&amp;value)<br />
	// m.dirty存在这个键，更新<br />
	} else if e, ok := m.dirty[key]; ok {<br />
		e.storeLocked(&amp;value)<br />
	//新键值<br />
	} else {<br />
		//m.dirty中没有比m.readOnly更新的数据，往m.dirty中增加第一个新键<br />
		if !read.amended {<br />
			// 从m.read中复制未删除的数据<br />
			// 并标记m.read已经落后于m.dirty<br />
			m.dirtyLocked()<br />
			m.read.Store(readOnly{m: read.m, amended: true})<br />
		}<br />
		//将这个entry加入到m.dirty中<br />
		m.dirty[key] = newEntry(value)<br />
	}<br />
	m.mu.Unlock()<br />
}</p><br />
<br />
<p>// tryStore stores a value if the entry has not been expunged.<br />
//<br />
// If the entry is expunged, tryStore returns false and leaves the entry<br />
// unchanged.<br />
func (e *entry) tryStore(i *interface{}) bool {<br />
	for {<br />
		p := atomic.LoadPointer(&amp;e.p)<br />
		if p == expunged {<br />
			return false<br />
		}<br />
		if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) {<br />
			return true<br />
		}<br />
	}<br />
}</p><br />
<br />
<p>func (m *Map) dirtyLocked() {<br />
	if m.dirty != nil {<br />
		return<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>read, _ := m.read.Load().(readOnly)<br />
m.dirty = make(map[interface{}]*entry, len(read.m))<br />
for k, e := range read.m {<br />
	if !e.tryExpungeLocked() {<br />
		m.dirty[k] = e<br />
	}<br />
} } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 整体的pipeline可以用下图来解释：<br />
</code></pre></div></div><br />
<br />
<p>你可以看到，以上操作都是先从操作m.read开始的，不满足条件再加锁，然后操作m.dirty。</p><br />
<br />
<p>可能会发生两种数据迁移：</p><br />
<br />
<p>从m.dirty到m.read的迁移，这个迁移过程其实是指针的的修改，所以效率高；<br />
从read map到dirty map的迁移, 这个迁移需要创建一个新的map来复制key-value，所以效率会低一些<br />
Store可能会在某种情况下（在刚初始化和将所有元素迁移到read中后，dirty默认都是nil元素，而此时如果有新的元素增加，则需要先将read map中的所有未删除数据先迁移到dirty中）从m.read中复制数据到m.dirty，如果这个时候m.read中数据量非常大，可能会影响性能。</p><br />
<br />
<p>delete<br />
删除一个键值对：</p><br />
<br />
<p>func (m *Map) Delete(key interface{}) {<br />
	// 1. 如果不存在于 m.read中，而且 m.dirty 和 m.read 数据不一致。<br />
	read, _ := m.read.Load().(readOnly)<br />
	e, ok := read.m[key]<br />
	if !ok &amp;&amp; read.amended {<br />
		// 加锁，double check， 然后删除对应的key。<br />
		m.mu.Lock()<br />
		read, _ = m.read.Load().(readOnly)<br />
		e, ok = read.m[key]<br />
		if !ok &amp;&amp; read.amended {<br />
			delete(m.dirty, key)<br />
		}<br />
		m.mu.Unlock()<br />
	}<br />
	if ok {<br />
		e.delete()<br />
	}<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
整体pipeline:</p><br />
<br />
<p>这里会删除 m.dirty 对应的key-value, 但是m.read中的key-value其实并没有删除，只是设置了删除的标志为expunged。这里的惰性删除避免了重新创建 entry 实体，只用更新指针和value指针。</p><br />
<br />
<p>func (e *entry) delete() (hadValue bool) {<br />
	for {<br />
		p := atomic.LoadPointer(&amp;e.p)<br />
		if p == nil || p == expunged {<br />
			return false<br />
		}<br />
		if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {<br />
			return true<br />
		}<br />
	}<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
Range<br />
这里sync.Map是对map关键字的封装，肯定无法使用系统提供的 for range 操作。所以这里采用了一个回调的操作：</p><br />
<br />
<p>func (m *Map) Range(f func(key, value interface{}) bool) {<br />
	// 如果m.dirty中有新数据，则提升m.dirty,然后在遍历<br />
	read, _ := m.read.Load().(readOnly)<br />
	if read.amended {<br />
		///提升m.dirty<br />
		m.mu.Lock()<br />
		read, _ = m.read.Load().(readOnly)<br />
		if read.amended {<br />
			read = readOnly{m: m.dirty}<br />
			m.read.Store(read)<br />
			m.dirty = nil<br />
			m.misses = 0<br />
		}<br />
		m.mu.Unlock()<br />
	}<br />
	// 遍历, for range是安全的<br />
	for k, e := range read.m {<br />
		v, ok := e.load()<br />
		if !ok {<br />
			continue<br />
		}<br />
		if !f(k, v) {<br />
			break<br />
		}<br />
	}<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
25<br />
26<br />
Range方法调用前可能会做一个m.dirty的提升，不过提升m.dirty不是一个耗时的操作。</p><br />
<br />
<p>sync.Map总结<br />
sync.Map的优化策略简单总结可以理解为：</p><br />
<br />
<p>无锁读与读写分离；</p><br />
<br />
<p>写加锁与延迟提升；</p><br />
<br />
<p>指针与惰性删除，map保存的value都是指针。惰性删除，实际删除是在 Store时候去check 然后删除。<br />
sync.Map，读写锁的适用场景<br />
实现方式	原理	适用场景<br />
map+Mutex	通过Mutex互斥锁来实现多个goroutine对map的串行化访问	读写都需要通过Mutex加锁和释放锁，适用于读写比接近的场景<br />
map+RWMutex	通过RWMutex来实现对map的读写进行读写锁分离加锁，从而实现读的并发性能提高	同Mutex相比适用于读多写少的场景<br />
sync.Map	底层通分离读写map和原子指令来实现读的近似无锁，并通过延迟更新的方式来保证读的无锁化	读多修改少，元素增加删除频率不高的情况，在大多数情况下替代上述两种实现<br />
源码提供分析背景，实际情况还是要case by case的测试。</p><br />
<br />
<p>参考文献<br />
官方源码：src/sync/map.go<br />
Go 1.9 sync.Map揭秘 https://colobu.com/2017/07/11/dive-into-sync-Map/</p><br />
<br />
<p>https://colobu.com/2017/07/11/dive-into-sync-Map/</p><br />
<br />
<p>https://www.cnblogs.com/shuiyuejiangnan/p/9722791.html</p><br />
<br />
<p>如之前的文章可以看到，golang中的map是不支持并发操作的，golang推荐用户直接用读写锁对map进行保护，也有第三方类库使用分段锁。在1.19版本中，golang基于原本的map，新增了一个支持并发操作的map，叫sync map。</p><br />
<br />
<p>下面我们先介绍一下它的用法，然后在介绍原理，最后详细看看代码。</p><br />
<br />
<p>用法<br />
基本api有这几个</p><br />
<br />
<p>Store 写入<br />
Load 读取，返回值有两个，第一个是value，第二个是bool变量表示key是否存在<br />
Delete 删除<br />
LoadOrStore 存在就读，不存在就写<br />
Range 遍历，注意遍历的快照<br />
sync map底层使用map[interface{}]* entry来做存储，所以无论key还是value都是支持多种数据类型。<br />
一个简单的例子：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
     “sync”<br />
)</p><br />
<br />
<p>type MySyncMap struct {<br />
    sync.Map<br />
}</p><br />
<br />
<p>func (m MySyncMap) Print(k interface{}) {<br />
    value, ok := m.Load(k)<br />
    fmt.Println(value, ok)<br />
}</p><br />
<br />
<p>func main() {<br />
        var syncMap MySyncMap</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    syncMap.Print("Key1")<br />
<br />
    syncMap.Store("Key1", "Value1")<br />
    syncMap.Print("Key1")<br />
<br />
    syncMap.Store("Key2", "Value2")<br />
<br />
    syncMap.Store("Key3", 2)<br />
    syncMap.Print("Key3")<br />
<br />
    syncMap.Store(4, 4)<br />
    syncMap.Print(4)<br />
<br />
    syncMap.Delete("Key1")<br />
    syncMap.Print("Key1") } 输出：<br />
</code></pre></div></div><br />
<br />
<nil> false<br />
Value1 true<br />
2 true<br />
4 true<br />
<nil> false<br />
设计原理<br />
常用方案比较<br />
并发hashmap的方案有很多，下面简单提一下几种，然后再讨论golang实现时的考虑。<br />
第一种是最简单的，直接在不支持并发的hashmap上，使用一个读写锁的保护，这也是golang sync map还没出来前，大家常用的方法。这种方法的缺点是写会堵塞读。<br />
<br />
第二种是数据库常用的方法，分段锁，每一个读写锁保护一段区间，golang的第三方库也有人是这么实现的。java的ConcurrentHashMap也是这么实现的。平均情况下这样的性能还挺好的，但是极端情况下，如果某个区间有热点写，那么那个区间的读请求也会受到影响。<br />
<br />
第三种方法是我们C++自己造轮子时经常用的，使用使用链表法解决冲突，然后链表使用CAS去解决并发下冲突，这样读写都是无锁，我觉得这种挺好的，性能非常高，不知为啥其他语言不这么实现。<br />
<br />
然后在《An overview of sync.Map》中有提到，在cpu核数很多的情况下，因为cache contention，reflect.New、sync.RWMutex、atomic.AddUint32都会很慢，golang团队为了适应cpu核很多的情况，没有采用上面的几种常见的方案。<br />
<br />
golang sync map的目标是实现适合读多写少的场景、并且要求稳定性很好，不能出现像分段锁那样读经常被阻塞的情况。golang sync map基于map做了一层封装，在大部分情况下，不过写入性能比较差。下面来详细说说实现。<br />
<br />
实现思路<br />
要读受到的影响尽量小，那么最容易想到的想法，就是读写分离。golang sync map也是受到这个想法的启发（我自认为）设计出来的。使用了两个map，一个叫read，一个叫dirty，两个map存储的都是指针，指向value数据本身，所以两个map是共享value数据的，更新value对两个map同时可见。<br />
<br />
dirty可以进行增删查，当时都要进行加互斥锁。<br />
<br />
read中存在的key，可以无锁的读，借助CAS进行无锁的更新、删除操作，但是不能新增key，相当于dirty的一个cache，由于value共享，所以能通过read对已存在的value进行更新。<br />
<br />
read不能新增key，那么数据怎么来的呢？sync map中会记录miss cache的次数，当miss次数大于等于dirty元素个数时，就会把dirty变成read，原来的dirty清空。<br />
<br />
为了方便dirty直接变成read，那么得保证read中存在的数据dirty必须有，所以在dirty是空的时候，如果要新增一个key，那么会把read中的元素复制到dirty中，然后写入新key。<br />
<br />
然后删除操作也很有意思，使用的是延迟删除，优先看read中没有，read中有，就把read中的对应entry指针中的p置为nil，作为一个标记。在read中标记为nil的，只有在dirty提升为read时才会被实际删除。<br />
<br />
源码<br />
结构<br />
// The zero Map is empty and ready for use. A Map must not be copied after first use.<br />
type Map struct {<br />
    mu Mutex<br />
<br />
    // read contains the portion of the map's contents that are safe for<br />
    // concurrent access (with or without mu held).<br />
    //<br />
    // The read field itself is always safe to load, but must only be stored with<br />
    // mu held.<br />
    //<br />
    // Entries stored in read may be updated concurrently without mu, but updating<br />
    // a previously-expunged entry requires that the entry be copied to the dirty<br />
    // map and unexpunged with mu held.<br />
    read atomic.Value // readOnly<br />
<br />
    // dirty contains the portion of the map's contents that require mu to be<br />
    // held. To ensure that the dirty map can be promoted to the read map quickly,<br />
    // it also includes all of the non-expunged entries in the read map.<br />
    //<br />
    // Expunged entries are not stored in the dirty map. An expunged entry in the<br />
    // clean map must be unexpunged and added to the dirty map before a new value<br />
    // can be stored to it.<br />
    //<br />
    // If the dirty map is nil, the next write to the map will initialize it by<br />
    // making a shallow copy of the clean map, omitting stale entries.<br />
    dirty map[interface{}]*entry<br />
<br />
    // misses counts the number of loads since the read map was last updated that<br />
    // needed to lock mu to determine whether the key was present.<br />
    //<br />
    // Once enough misses have occurred to cover the cost of copying the dirty<br />
    // map, the dirty map will be promoted to the read map (in the unamended<br />
    // state) and the next store to the map will make a new dirty copy.<br />
    misses int<br />
}<br />
<br />
//read的实际结构体<br />
// readOnly is an immutable struct stored atomically in the Map.read field.<br />
type readOnly struct {<br />
    m       map[interface{}]*entry<br />
    amended bool // true if the dirty map contains some key not in m.<br />
}<br />
<br />
// expunged is an arbitrary pointer that marks entries which have been deleted<br />
// from the dirty map.<br />
var expunged = unsafe.Pointer(new(interface{}))<br />
<br />
// An entry is a slot in the map corresponding to a particular key.<br />
type entry struct {<br />
    // p points to the interface{} value stored for the entry.<br />
    //<br />
    // If p == nil, the entry has been deleted and m.dirty == nil.<br />
    //<br />
    // If p == expunged, the entry has been deleted, m.dirty != nil, and the entry<br />
    // is missing from m.dirty.<br />
    //<br />
    // Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty<br />
    // != nil, in m.dirty[key].<br />
    //<br />
    // An entry can be deleted by atomic replacement with nil: when m.dirty is<br />
    // next created, it will atomically replace nil with expunged and leave<br />
    // m.dirty[key] unset.<br />
    //<br />
    // An entry's associated value can be updated by atomic replacement, provided<br />
    // p != expunged. If p == expunged, an entry's associated value can be updated<br />
    // only after first setting m.dirty[key] = e so that lookups using the dirty<br />
    // map find the entry.<br />
    p unsafe.Pointer // *interface{}<br />
}<br />
<br />
sync map结构<br />
mu是用来保护dirty的互斥锁<br />
missed是记录没命中read的次数<br />
<br />
注意对于entry.p，有两个特殊值，一个是nil，另一个是expunged。nil代表的意思是，在read中被删除了，但是dirty中还在，所以能直接更新值(如果dirty==nill的特殊情况,下次写入新值时会复制)；expunged代表数据在ditry中已经被删除了，更新值的时候要先把这个entry复制到dirty。<br />
<br />
Load 读取<br />
<br />
// Load returns the value stored in the map for a key, or nil if no<br />
// value is present.<br />
// The ok result indicates whether value was found in the map.<br />
func (m *Map) Load(key interface{}) (value interface{}, ok bool) {<br />
    read, _ := m.read.Load().(readOnly)<br />
    e, ok := read.m[key]<br />
    if !ok &amp;&amp; read.amended {<br />
        m.mu.Lock()<br />
        // Avoid reporting a spurious miss if m.dirty got promoted while we were<br />
        // blocked on m.mu. (If further loads of the same key will not miss, it's<br />
        // not worth copying the dirty map for this key.)<br />
        read, _ = m.read.Load().(readOnly)<br />
        e, ok = read.m[key]<br />
        if !ok &amp;&amp; read.amended {<br />
            e, ok = m.dirty[key]<br />
            // Regardless of whether the entry was present, record a miss: this key<br />
            // will take the slow path until the dirty map is promoted to the read<br />
            // map.<br />
            m.missLocked()<br />
        }<br />
        m.mu.Unlock()<br />
    }<br />
    if !ok {<br />
        return nil, false<br />
    }<br />
    return e.load()<br />
}<br />
<br />
func (e *entry) load() (value interface{}, ok bool) {<br />
    p := atomic.LoadPointer(&amp;e.p)<br />
    if p == nil || p == expunged {<br />
        return nil, false<br />
    }<br />
    return *(*interface{})(p), true<br />
}<br />
<br />
func (m *Map) missLocked() {<br />
    m.misses++<br />
    if m.misses &lt; len(m.dirty) {<br />
        return<br />
    }<br />
    m.read.Store(readOnly{m: m.dirty})<br />
    m.dirty = nil<br />
    m.misses = 0<br />
}<br />
读取时，先去read读取；如果没有，就加锁，然后去dirty读取，同时调用missLocked()，再解锁。在missLocked中，会递增misses变量，如果misses&gt;len(dirty)，那么把dirty提升为read，清空原来的dirty。<br />
<br />
在代码中，我们可以看到一个double check，检查read没有，上锁，再检查read中有没有，是因为有可能在第一次检查之后，上锁之前的间隙，dirty提升为read了，这时如果不double check，可能会导致一个存在的key却返回给调用方说不存在。 在下面的其他操作中，我们经常会看到这个double check。<br />
<br />
Store 写入<br />
// Store sets the value for a key.<br />
func (m *Map) Store(key, value interface{}) {<br />
    read, _ := m.read.Load().(readOnly)<br />
    if e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) {<br />
        return<br />
    }<br />
<br />
    m.mu.Lock()<br />
    read, _ = m.read.Load().(readOnly)<br />
    if e, ok := read.m[key]; ok {<br />
        if e.unexpungeLocked() {<br />
            // The entry was previously expunged, which implies that there is a<br />
            // non-nil dirty map and this entry is not in it.<br />
            m.dirty[key] = e<br />
        }<br />
        e.storeLocked(&amp;value)<br />
    } else if e, ok := m.dirty[key]; ok {<br />
        e.storeLocked(&amp;value)<br />
    } else {<br />
        if !read.amended {<br />
            // We're adding the first new key to the dirty map.<br />
            // Make sure it is allocated and mark the read-only map as incomplete.<br />
            m.dirtyLocked()<br />
            m.read.Store(readOnly{m: read.m, amended: true})<br />
        }<br />
        m.dirty[key] = newEntry(value)<br />
    }<br />
    m.mu.Unlock()<br />
}<br />
<br />
// tryStore stores a value if the entry has not been expunged.<br />
//<br />
// If the entry is expunged, tryStore returns false and leaves the entry<br />
// unchanged.<br />
func (e *entry) tryStore(i *interface{}) bool {<br />
    p := atomic.LoadPointer(&amp;e.p)<br />
    if p == expunged {<br />
        return false<br />
    }<br />
    for {<br />
        if atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) {<br />
            return true<br />
        }<br />
        p = atomic.LoadPointer(&amp;e.p)<br />
        if p == expunged {<br />
            return false<br />
        }<br />
    }<br />
}<br />
<br />
func (m *Map) dirtyLocked() {<br />
    if m.dirty != nil {<br />
        return<br />
    }<br />
<br />
    read, _ := m.read.Load().(readOnly)<br />
    m.dirty = make(map[interface{}]*entry, len(read.m))<br />
    for k, e := range read.m {<br />
        if !e.tryExpungeLocked() {<br />
            m.dirty[k] = e<br />
        }<br />
    }<br />
}<br />
<br />
func (e *entry) tryExpungeLocked() (isExpunged bool) {<br />
    p := atomic.LoadPointer(&amp;e.p)<br />
    for p == nil {<br />
        if atomic.CompareAndSwapPointer(&amp;e.p, nil, expunged) {<br />
            return true<br />
        }<br />
        p = atomic.LoadPointer(&amp;e.p)<br />
    }<br />
    return p == expunged<br />
}<br />
<br />
// unexpungeLocked ensures that the entry is not marked as expunged.<br />
//<br />
// If the entry was previously expunged, it must be added to the dirty map<br />
// before m.mu is unlocked.<br />
func (e *entry) unexpungeLocked() (wasExpunged bool) {<br />
    return atomic.CompareAndSwapPointer(&amp;e.p, expunged, nil)<br />
}<br />
写入的时候，先看read中能否查到key，在read中存在的话，直接通过read中的entry来更新值；在read中不存在，那么就上锁，然后double check。这里需要留意，分几种情况：<br />
<br />
double check发现read中存在，如果是expunged，那么就先尝试把expunged替换成nil，最后如果entry.p==expunged就复制到dirty中，再写入值；否则不用替换直接写入值。<br />
dirty中存在，直接更新<br />
dirty中不存在，如果此时dirty为空，那么需要将read复制到dirty中，最后再把新值写入到dirty中。复制的时候调用的是dirtyLocked()，在复制到dirty的时候，read中为nil的元素，会更新为expunged，并且不复制到dirty中。<br />
我们可以看到，在更新read中的数据时，使用的是tryStore，通过CAS来解决冲突，在CAS出现冲突后，如果发现数据被置为expung，tryStore那么就不会写入数据，而是会返回false，在Store流程中，就是接着往下走，在dirty中写入。<br />
<br />
再看下情况1的时候，为啥要那么做。double check的时候，在read中存在，那么就是说在加锁之前，有并发线程先写入了key，然后由Load触发了dirty提升为read，这时dirty可能为空，也可能不为空，但无论dirty状态如何，都是可以直接更新entry.p。如果是expunged的话，那么要先替换成nil，再复制entry到dirty中。<br />
<br />
疑问：这里不太懂，为啥在read中直接更新就用cas去更新，跑到下面的流程，就用原子更新，可是尽管上了锁，key在read中存在，那么就会并发写，为啥可以不用cas更新？？<br />
<br />
Delete 删除<br />
// Delete deletes the value for a key.<br />
func (m *Map) Delete(key interface{}) {<br />
    read, _ := m.read.Load().(readOnly)<br />
    e, ok := read.m[key]<br />
    if !ok &amp;&amp; read.amended {<br />
        m.mu.Lock()<br />
        read, _ = m.read.Load().(readOnly)<br />
        e, ok = read.m[key]<br />
        if !ok &amp;&amp; read.amended {<br />
            delete(m.dirty, key)<br />
        }<br />
        m.mu.Unlock()<br />
    }<br />
    if ok {<br />
        e.delete()<br />
    }<br />
}<br />
<br />
func (e *entry) delete() (hadValue bool) {<br />
    for {<br />
        p := atomic.LoadPointer(&amp;e.p)<br />
        if p == nil || p == expunged {<br />
            return false<br />
        }<br />
        if atomic.CompareAndSwapPointer(&amp;e.p, p, nil) {<br />
            return true<br />
        }<br />
    }<br />
}<br />
删除很简单，read中存在，就把read中的entry.p置为nil，如果只在ditry中存在，那么就直接从dirty中删掉对应的entry。<br />
<br />
https://studygolang.com/articles/16141<br />
<br />
<br />
golang map 读写锁与深度拷贝的坑<br />
<br />
0X01<br />
<br />
golang中，map（字典）无法并发读写<br />
<br />
简单来说，新建万条线程对同一个map又读又写，会报错。<br />
<br />
为此，最好加锁，其实性能影响并不明显。<br />
<br />
type taskCache struct{<br />
    sync.RWMutex<br />
    data map[string] interface{}<br />
}<br />
 <br />
<br />
 <br />
<br />
0X02<br />
<br />
golang中，map（字典）为引用拷贝。<br />
<br />
a = 字典一<br />
<br />
b = a <br />
<br />
实际上是直接将指针传给了b。<br />
<br />
 <br />
<br />
于是，有一个读取，写的时候直接读map并返回<br />
<br />
复制代码<br />
func GetAllTasks() (result map[string]interface{}, err error) {<br />
    // 获得当前的所有任务<br />
    DEMO.RLock()<br />
    defer DEMO.RUnlock()<br />
    return DEMO.data, err<br />
}<br />
复制代码<br />
而在线程中<br />
<br />
// 接收后直接打印<br />
fmt.Println(store.GetAllTasks())<br />
结果居然报错，map读写冲突。<br />
<br />
 <br />
<br />
于是，我返回去一遍一遍看代码，觉得自己的读写锁写错了。<br />
<br />
调式折腾了半天，最后发现，在接收后不用 fmt.Println 打印就不会报错。<br />
<br />
这很不科学，然后在接收打印前后加上读锁，不报错了。<br />
<br />
 <br />
<br />
0X03<br />
<br />
所以golang，加了读写锁的时候，要返回全部值，还不能直接返回这个字典，因为直接返回这个字典，返回了指针，操作的时候要不还要加读写锁，要不就报错。<br />
<br />
还没有直接的取地址的值重新给另一个变量的东西，自己写个遍历，一个一个赋值吧，蛋疼，坑货，坑了一晚上<br />
<br />
var cache = make(map[string]interface{})<br />
for k,v := range Demo.data{<br />
    cache[k] = v<br />
}<br />
<br />
https://zhuanlan.zhihu.com/p/102385081?utm_source=qq<br />
<br />
核心思想是用空间换时间，用两个map来存储数据，read和dirty，read支持原子操作，可以看作是dirty 的cache，dirty是更底层的数据存储层<br />
4种操作：读key、增加key、更新key、删除key的基本流程<br />
读key：先到read中读取，如果有则直接返回结果，如果没有或者是被删除（有特殊value值可以判断），则到dirty加锁中读取，如果有返回结果并更新miss数<br />
增加key：直接增加到dirty中<br />
更新key：先到read中看看有没有，如果有直接更新key，如果没有则到dirty中更新<br />
删除key：先到read中看看有没有，如果有则直接更新为nil，如果没有则到dirty中直接删除<br />
<br />
read的替换：当read多次都没有命中数据，达到阈值，表示这个cache命中率太低，这时直接将整个read用dirty替换掉，然后dirty又重新置为nil，下一次再添加一个新key的时候，会触发一次read到dirty的复制，这样二者又保持了一致。<br />
<br />
虽然read和dirty有冗余，但这些map的value数据是通过指针指向同一个数据，所以尽管实际的value会很大，但是冗余的空间占用还是有限的。<br />
<br />
总结，如果对map的读操作远远多于写操作（写操作包括新增和删除key），那么sync.Map是很合适，能够大大提升性能<br />
<br />
syncmap是golang1.5引入的线程安全的map，以下是测试程序，结论： 不建议使用sync.map, 原因： 1. 性能不及加锁的map, 2. 对json不友好<br />
<br />
package main_test<br />
<br />
import (<br />
	"math/rand"<br />
	"sync"<br />
	"testing"<br />
)<br />
<br />
type WrapedMap struct {<br />
	lck sync.Mutex<br />
	m   map[int]int<br />
}<br />
<br />
var normalMap WrapedMap<br />
var syncMap sync.Map<br />
<br />
func TestMain(m *testing.M) {<br />
	normalMap = WrapedMap{<br />
		lck: sync.Mutex{},<br />
		m:   make(map[int]int, 100000),<br />
	}<br />
<br />
	m.Run()<br />
}<br />
<br />
func BenchmarkLockMapWrite(b *testing.B) {<br />
	b.RunParallel(func(pb *testing.PB) {<br />
		for pb.Next() {<br />
			a := rand.Intn(100) + 1<br />
			b := rand.Intn(a)<br />
			normalMap.lck.Lock()<br />
			normalMap.m[a] = b<br />
			normalMap.lck.Unlock()<br />
		}<br />
	})<br />
}<br />
<br />
func BenchmarkLockMapRead(b *testing.B) {<br />
	b.RunParallel(func(pb *testing.PB) {<br />
		for pb.Next() {<br />
			a := rand.Intn(100) + 1<br />
			normalMap.lck.Lock()<br />
			_, _ = normalMap.m[a]<br />
			normalMap.lck.Unlock()<br />
		}<br />
	})<br />
}<br />
<br />
func BenchmarkSyncMapWrite(b *testing.B) {<br />
<br />
	b.RunParallel(func(pb *testing.PB) {<br />
		for pb.Next() {<br />
			a := rand.Intn(100) + 1<br />
			b := rand.Intn(a)<br />
			syncMap.Store(a, b)<br />
		}<br />
	})<br />
}<br />
<br />
func BenchmarkSyncMapRead(b *testing.B) {<br />
	b.RunParallel(func(pb *testing.PB) {<br />
		for pb.Next() {<br />
			a := rand.Intn(100) + 1<br />
			syncMap.Load(a)<br />
		}<br />
	})<br />
}<br />
<br />
</nil></nil><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>