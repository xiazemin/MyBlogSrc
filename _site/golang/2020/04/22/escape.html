<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">pprof分析变量逃逸过程</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-04-22T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 22, 2020</time></p>
					</div>
					 <p>在优化ac自动机时发现在匹配过程中有大量时间消耗在GC里面，通过pprof发现match过程有很多的临时变量逃逸到heap里，增加了很多的GC压力，简要记录下问题定位的过程。</p><br />
<br />
<p>问题定位</p><br />
<br />
<p>首先需要在测试程序添加生成pprof数据的代码段。</p><br />
<br />
<p>f, err := os.Create(“benchmark.prof”)<br />
  if err != nil {<br />
  	log.Fatal(err)<br />
  }<br />
  defer f.Close()<br />
  pprof.StartCPUProfile(f)<br />
  defer pprof.StopCPUProfile()</p><br />
<br />
<p>go func() {<br />
  	http.ListenAndServe(“:8787”, http.DefaultServeMux)<br />
  }()</p><br />
<br />
<p>…<br />
  // 等待一段时间做问题分析<br />
  fmt.Println(“nCTL+C exit http pprof”)<br />
  time.Sleep(15 * time.Minute)<br />
查看各函数调用申请的内存对象大小。</p><br />
<br />
<p>go tool pprof -alloc_space -svg http://localhost:8787/debug/pprof/heap &gt; ~/Desktop/go_heap.svg<br />
image</p><br />
<br />
<p>我们发现matchOf申请了大量的内存，于是怀疑matchOf可能存在变量逃逸，使用-gcflags -m重新生成测试程序发现确实存在MatchToken临时变量逃逸到heap。</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>go build -gcflags -m</td><br />
      <td>grep escape</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>../acmatcher.go:165: &amp;MatchToken literal escapes to heap<br />
  ../acmatcher.go:165: &amp;MatchToken literal escapes to heap<br />
​</p><br />
<br />
<p>问题修复</p><br />
<br />
<p>使用interface{}实现的泛型fixedbuf存在变量逃逸情况，直接使用slice做固定的buf.</p><br />
<br />
<p>// FixedBuffer fixed reuse buffer for zero alloc<br />
  type FixedBuffer struct {<br />
  	b   interface{}<br />
  	idx int<br />
  	cap int<br />
  	op  iBufferOP<br />
  }</p><br />
<br />
<p>type iBufferOP interface {<br />
  	assign(fb *FixedBuffer, val interface{})<br />
  	init(fb *FixedBuffer, n int)<br />
  }</p><br />
<br />
<p>func (fb *FixedBuffer) push(t interface{}) {<br />
  	if fb.idx &gt;= fb.cap {<br />
  		panic(“ERROR buffer overflow”)<br />
  	}<br />
  	fb.op.assign(fb, t)<br />
  	fb.idx++<br />
  }</p><br />
<br />
<p>func (fb *FixedBuffer) reset() {<br />
  	fb.idx = 0<br />
  }</p><br />
<br />
<p>func NewFixedBuffer(n int, op iBufferOP) *FixedBuffer {<br />
  	fb := &amp;FixedBuffer{<br />
  		// b:   make([]interface{}, n),<br />
  		idx: 0,<br />
  		cap: n,<br />
  		op:  op,<br />
  	}<br />
  	fb.op.init(fb, n)<br />
  	return fb<br />
  }<br />
优化后，函数调用完全ZeroAlloc，达到了使用fixedbuffer的预期.</p><br />
<br />
<p>type mbuf struct {<br />
  	token  []MatchToken<br />
  	at     []matchAt<br />
  	ti, ai int<br />
  }</p><br />
<br />
<p>func (mb *mbuf) reset() {<br />
  	mb.ai, mb.ti = 0, 0<br />
  }</p><br />
<br />
<p>func (mb *mbuf) addToken(mt MatchToken) {<br />
  	if mb.ti &gt;= TokenBufferSize {<br />
  		panic(“ERROR buffer overflow”)<br />
  	}<br />
  	mb.token[mb.ti] = mt<br />
  	mb.ti++<br />
  }</p><br />
<br />
<p>func (mb *mbuf) addAt(mt matchAt) {<br />
  	if mb.ai &gt;= MatchBufferSize {<br />
  		panic(“ERROR buffer overflow”)<br />
  	}<br />
  	mb.at[mb.ai] = mt<br />
  	mb.ai++<br />
  }<br />
问题原因</p><br />
<br />
<p>首先我们来看下面这个变量逃逸示例</p><br />
<br />
<p>func main() {<br />
	lc := 1<br />
	s := make([]interface{}, lc)<br />
	s[0] = lc<br />
}</p><br />
<br />
<p>func main2() {<br />
	lc := 1<br />
	s := make([]*int, lc)<br />
	s[0] = &amp;lc<br />
}</p><br />
<br />
<p>go run -gcflags=’-m -m’ sample2.go<br />
./sample2.go:5: make([]interface {}, lc) escapes to heap<br />
./sample2.go:6: lc escapes to heap<br />
make从堆申请，这点无可厚非，我们把interface{}改为int类型后</p><br />
<br />
<p>func main() {<br />
	lc := 1<br />
	s := make([]int, lc)<br />
	s[0] = lc<br />
}</p><br />
<br />
<p>go run -gcflags=’-m -m’ sample2.go<br />
./sample2.go:5: make([]interface {}, lc) escapes to heap<br />
make得到的slice是在堆申请的，生命周期比函数更长，当slice里为引用时变量会转移到堆，而interface{}能接收任意类型，在做逃逸分析时，保守的认为输入的值可能是引用，所以把变量移到堆里去了。stackoverflow相关资料：</p><br />
<br />
<p>make for a slice returns a slice descriptor struct (pointer to underlying array, length, and capacity) and allocates an underlying slice element array. The underlying array is generally allocated on the heap: make([]<em>int, lc) escapes to heap from make([]</em>int, lc).</p><br />
<br />
<p>s[0] = &amp;v stores a reference to the variable v (&amp;v) in the underlying array on the heap: &amp;v escapes to heap from s[0] (slice-element-equals), moved to heap: v. The reference remains on the heap, after the function ends and its stack is reclaimed, until the underlying array is garbage collected.</p><br />
<br />
<p>If the make slice capacity is a small (compile time) constant, make([]*int, 1) in your example, the underlying array may be allocated on the stack. However, escape analysis does not take this into account.</p><br />
<br />
<p>https://www.dazhuanlan.com/2020/03/09/5e65cb2d01af6/<br />
<!-- more --><br />
package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
)</p><br />
<br />
<p>func main(){<br />
    s := []byte(“”)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s1 := append(s, 'a')<br />
s2 := append(s, 'b')<br />
<br />
// 如果有此行，打印的结果是 a b，否则打印的结果是b b<br />
// fmt.Println(s1, "===", s2)<br />
fmt.Println(string(s1), string(s2)) }<br />
</code></pre></div></div><br />
<br />
<p>诡异的现象：如果有行 14 的代码，则行 15 打印的结果为 a b， 否则打印的结果为b b ，本文分析的go版本：</p><br />
<br />
<p>$ go version<br />
go version go1.9.2 darwin/amd64<br />
初步分析<br />
首先我们分析在没有行14的情况下，为什么打印的结果是 b b，这个问题相对比较简单，只要熟悉 slice 的实现原理，简单分析一下 append 的实现原理即可得出结论。</p><br />
<br />
<p>slice 结构分析<br />
如果熟悉 slice 的原理可以跳过该章节。</p><br />
<br />
<p>首先对于 slice 结构进行一个简单的了解 结构定义 slice对应的runtime 包的相关源码参见： https://golang.org/src/runtime/slice.go</p><br />
<br />
<p>type slice struct {<br />
    array unsafe.Pointer<br />
    len   int<br />
    cap   int<br />
}</p><br />
<br />
<p>var slice []int 定义的变量内部结构如下：</p><br />
<br />
<p>slice.array = nil<br />
slice.len = 0<br />
slice.cap = 0<br />
如果我们声明了一下变量 slice := []int{} 或 slice := make([]int, 0) 的内部结构如下：</p><br />
<br />
<p>slice.array = 0xxxxxxxx  // 分配了地址<br />
slice.len = 0<br />
slice.cap = 18208800<br />
如果使用 make([]byte, 5) 定义的话，结构如下图：</p><br />
<br />
<p>如果使用 s := s[2:4]，则结构如下图：</p><br />
<br />
<p>通过分析 slice 的反射de 实现：Go Slices: usage and internals，也能够在程序中进行分析。slice 反射中对应的结构体</p><br />
<br />
<p>// slice 对应的结构体<br />
type SliceHeader struct {<br />
        Data uintptr<br />
        Len  int<br />
        Cap  int<br />
}</p><br />
<br />
<p>// string 对应结构体<br />
type StringHeader struct {<br />
        Data uintptr<br />
        Len  int<br />
}<br />
下面的函数可以直接获取 slice 的底层指针：</p><br />
<br />
<p>func bytePointer(b []byte) unsafe.Pointer {<br />
   // slice 的指针本质是<em>reflect.SliceHeader<br />
  p := (</em>reflect.SliceHeader)(unsafe.Pointer(&amp;b))<br />
  return unsafe.Pointer(p.Data)<br />
}<br />
append 原理实现<br />
Append 的实现伪代码，代码默认已经支持了 slice 为 nil 的情况</p><br />
<br />
<p>func Append(slice, data []byte) []byte {<br />
    l := len(slice)<br />
    if l + len(data) &gt; cap(slice) {  // reallocate<br />
        // Allocate double what’s needed, for future growth.<br />
        newSlice := make([]byte, (l+len(data))*2)<br />
        // The copy function is predeclared and works for any slice type.<br />
        copy(newSlice, slice)<br />
        slice = newSlice<br />
    }<br />
    slice = slice[0:l+len(data)]<br />
    copy(slice[l:], data)<br />
    return slice<br />
}<br />
append 函数原型如下，其中 T 为通用类型。</p><br />
<br />
<p>func append(s []T, x …T) []T<br />
展开分析<br />
为了方便程序分析的，我们在程序中添加打印信息，代码和结果如下：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
)</p><br />
<br />
<p>func main() {<br />
    s := []byte(“”)<br />
    println(s) // 添加用于打印信息, println() print() 为go内置函数，直接输出到 stderr 无缓存</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s1 := append(s, 'a')<br />
s2 := append(s, 'b')<br />
<br />
// fmt.Println(s1, "===", s2)<br />
fmt.Println(string(s1), string(s2)) }<br />
</code></pre></div></div><br />
<br />
<p>运行程序结果如下：</p><br />
<br />
<p>$ go run q.go<br />
[0/32]0xc420045ef8<br />
b b<br />
结果运行后 s := []byte(“”) 初始化以后结构内部如下：</p><br />
<br />
<p>s.len = 0 <br />
s.cap = 32<br />
s.ptr = 0xc420045ef8<br />
我们分析以下两行代码调用会发生什么：</p><br />
<br />
<p>s1 := append(s, ‘a’)<br />
s2 := append(s, ‘b’)<br />
s1 := append(s, ‘a’) 代码调用分析：</p><br />
<br />
<p>// slice = s  data = <code class="language-plaintext highlighter-rouge">a</code>   slice.len = 0 slice.cap = 32    <br /><br />
func Append(slice, data []byte) []byte {<br />
    l := len(slice) // l = 0</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// l = 0 len(data) = 1  cap(slice) = 32   1 + 1 &gt; 32 false<br />
if l + len(data) &gt; cap(slice) { <br />
    newSlice := make([]byte, (l+len(data))*2)<br />
    copy(newSlice, slice)<br />
    slice = newSlice<br />
}<br />
// l = 0 len(data) = 1<br />
slice = slice[0:l+len(data)] // slice = slice[0:1]<br />
copy(slice[l:], data)  // 调用变成： copy(slice[0:], 'a') <br />
return slice // 由于未涉及到重分配，因此返回的还是原来的 slice 对象 } s2 := append(s, 'b') 的分析完全一样。<br />
</code></pre></div></div><br />
<br />
<p>简化 apend 函数的处理路径，在没有进行 slice 重新分配内存情况下，直接进行展开分析：</p><br />
<br />
<p>s1 := append(s, ‘a’)<br />
s2 := append(s, ‘b’)<br />
等价于</p><br />
<br />
<p>s1 := copy(s[0:], ‘a’)<br />
s2 := copy(s[0:], ‘b’) // 直接覆盖了上的赋值<br />
基于上述分析，能够很好地解释代码输出b b的情况。但是如何避免出现这种类型的情况呢？问题出现在这条语句上</p><br />
<br />
<p>s := []byte(“”)<br />
语句执行后 s.len = 0 s.cap = 32，导致了 append 的工作不能够正常工作，那么正常如何使用？只要将 s.len = s.cap = 0 则会导致 slice 在 append 中重新进行分配则可以避免这种情况的发生。</p><br />
<br />
<p>正确的写法应该为：</p><br />
<br />
<p>func main() {<br />
    // Notice []byte(“”) -&gt;  []byte{}    或者  var s []byte<br />
    s := []byte{}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s1 := append(s, 'a')<br />
s2 := append(s, 'b')<br />
<br />
// fmt.Println(s1, "===", s2)<br />
fmt.Println(string(s1), string(s2)) } 由此也可以看出一个良好的编程习惯是可以规避很多莫名其妙的问题排查。<br />
</code></pre></div></div><br />
<br />
<p>深入分析<br />
那么既然 bug 出现在了 s := []byte(““)这句话中，那么这条语句为什么会导致 s.cap = 32 呢？这条语句背后隐藏的逻辑是什么呢?</p><br />
<br />
<p>s := []byte(“”) 等价于以下代码：</p><br />
<br />
<p>// 初始化字符串<br />
str := “”</p><br />
<br />
<p>// 将字符串转换成 []byte<br />
s := []byte(str)<br />
在go语言中 s := []byte(str) 的底层其实是调用了 stringtoslicebyte 实现的，该函数位于 go 的 runtime包中。</p><br />
<br />
<p>const tmpStringBufSize = 32</p><br />
<br />
<p>type tmpBuf [tmpStringBufSize]byte</p><br />
<br />
<p>func stringtoslicebyte(buf *tmpBuf, s string) []byte {<br />
    var b []byte<br />
    // 如果字符串 s 的长度内部长度不超过 32， 那么就直接分配一个 32 直接的大小<br />
    if buf != nil &amp;&amp; len(s) &lt;= len(buf) { <br />
        *buf = tmpBuf{}<br />
        b = buf[:len(s)]<br />
    } else {<br />
        b = rawbyteslice(len(s))<br />
    }<br />
    copy(b, s)<br />
    return b<br />
}<br />
如果字符串的大小没有超过 32 长度的大小，则默认分配一个 32 长度的 buf，这也是我们上面分析 s.cap = 32 的由来。</p><br />
<br />
<p>到此为止，我们仍然没有分析问题中 fmt.Println(s1, “===”, s2) 这句打印注释掉就能够正常工作的原因？那么最终到底是什么样的情况呢？</p><br />
<br />
<p>最终分析<br />
最后我们来启用魔法的开关 fmt.Println(s1, “===”, s2), 来进行最后谜底的揭晓：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
)</p><br />
<br />
<p>func main() {<br />
    s := []byte(“”)<br />
    println(s) // 添加用于打印信息</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s1 := append(s, 'a')<br />
s2 := append(s, 'b')<br />
<br />
fmt.Println(s1, "===", s2)<br />
fmt.Println(string(s1), string(s2)) } $ go run q.go [0/0]0x115b820   # 需要注意 s.len = 0 s.cap = 0 [97] === [98]    # 取消了打印的注释 a b              # 打印一切正常 $ go run -gcflags '-S -S' q.go ....<br />
0x0032 00050 (q.go:8)   MOVQ    $0, (SP)<br />
0x003a 00058 (q.go:8)   MOVQ    $0, 8(SP)<br />
0x0043 00067 (q.go:8)   MOVQ    $0, 16(SP)<br />
0x004c 00076 (q.go:8)   PCDATA  $0, $0<br />
0x004c 00076 (q.go:8)   CALL    runtime.stringtoslicebyte(SB)<br />
0x0051 00081 (q.go:8)   MOVQ    32(SP), AX<br />
0x0056 00086 (q.go:8)   MOVQ    AX, "".s.len+96(SP)<br />
0x005b 00091 (q.go:8)   MOVQ    40(SP), CX<br />
0x0060 00096 (q.go:8)   MOVQ    CX, "".s.cap+104(SP)<br />
0x0065 00101 (q.go:8)   MOVQ    24(SP), DX<br />
0x006a 00106 (q.go:8)   MOVQ    DX, "".s.ptr+136(SP)<br />
</code></pre></div></div><br />
<br />
<p>….<br />
通过分析发现底层调用的仍然是 runtime.stringtoslicebyte(), 但是行为却发生了变化 s.len = s.cap = 0，很显然由于 fmt.Println(s1, “===”, s2) 行的出现导致了 s := []byte(““)内存分配的情况发生了变化。</p><br />
<br />
<p>我们可以通过 go build 提供的内存分配工具进行分析：</p><br />
<br />
<p>$ go build -gcflags “-m -m” q.go</p><br />
<h1 id="command-line-arguments">command-line-arguments</h1><br />
<p>./q.go:7:6: cannot inline main: non-leaf function<br />
./q.go:14:13: s1 escapes to heap<br />
./q.go:14:13:   from … argument (arg to …) at ./q.go:14:13<br />
./q.go:14:13:   from *(… argument) (indirection) at ./q.go:14:13<br />
./q.go:14:13:   from … argument (passed to call[argument content escapes]) at ./q.go:14:13<br />
./q.go:8:13: ([]byte)(“”) escapes to heap<br />
./q.go:8:13:    from s (assigned) at ./q.go:8:4<br />
./q.go:8:13:    from s1 (assigned) at ./q.go:11:5<br />
./q.go:8:13:    from s1 (interface-converted) at ./q.go:14:13<br />
./q.go:8:13:    from … argument (arg to …) at ./q.go:14:13<br />
./q.go:8:13:    from *(… argument) (indirection) at ./q.go:14:13<br />
./q.go:8:13:    from … argument (passed to call[argument content escapes]) at ./q.go:14:13</p><br />
<br />
<p>以上输出中的 s1 escapes to heap 和 ([]byte)(“”) escapes to heap 表明，由于 fmt.Println(s1, “===”, s2) 代码的引入导致了变量分配模型的变化。简单点讲就是从栈中逃逸到了堆上。内存逃逸的分析我们会在后面的章节详细介绍。问题到此，大概的思路已经有了，但是我们如何通过代码层面进行验证呢? 通过搜索 go 源码实现调用的函数 runtime.stringtoslicebyte 的地方进行入手。通过搜索发现调用的文件在 cmd/compile/internal/gc/walk.go</p><br />
<br />
<p>关于 string到[]byte 分析调用的代码如下</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case OSTRARRAYBYTE:<br />
    a := nodnil()  // 分配到堆上的的默认行为<br />
<br />
    if n.Esc == EscNone {<br />
        // Create temporary buffer for slice on stack.<br />
        t := types.NewArray(types.Types[TUINT8], tmpstringbufsize)<br />
<br />
        a = nod(OADDR, temp(t), nil)  // 分配在栈上，大小为32<br />
    }<br />
<br />
    n = mkcall("stringtoslicebyte", n.Type, init, a, conv(n.Left, types.Types[TSTRING])) OSTRARRAYBYTE 定义<br />
</code></pre></div></div><br />
<br />
<p>OSTRARRAYBYTE    // Type(Left) (Type is []byte, Left is a string)<br />
上述代码中的 n.Esc == EscNone 条件分析则表明了发生内存逃逸和不发生内存逃逸的情况下，初始化的方式是不同的。 EscNone 的定义：</p><br />
<br />
<p>EscNone           // Does not escape to heap, result, or parameters.<br />
通过以上分析，我们总算找到了魔法的最终谜底。 以上分析的go语言版本基于 1.9.2，不同的go语言的内存分配机制可能不同，具体可以参见我同事更加详细的分析 Go中string转[]byte的陷阱.md</p><br />
<br />
<p>Go 内存管理<br />
Go 语言能够自动进行内存管理，避免了 C 语言中的内存自己管理的麻烦，但是同时对于代码的内存管理和回收细节进行了封装，也潜在增加了系统调试和优化的难度。同时，内存自动管理也是一项非常困难的事情，比如函数的多层调用、闭包调用、结构体或者管道的多次赋值、切片和MAP、CGO调用等多种情况综合下，往往会导致自动管理优化机制失效，退化成原始的管理状态；go 中的内存回收（GC）策略也在不断地优化过程。Golang 从第一个版本以来，GC 一直是大家诟病最多的，但是每一个版本的发布基本都伴随着 GC 的改进。下面列出一些比较重要的改动。</p><br />
<br />
<p>v1.1 STW<br />
v1.3 Mark STW, Sweep 并行<br />
v1.5 三色标记法<br />
v1.8 hybrid write barrier<br />
预热基础知识：How do I know whether a variable is allocated on the heap or the stack?</p><br />
<br />
<p>逃逸分析-Escape Analysis<br />
更深入和细致的了解建议阅读 William Kennedy 的 4 篇 Post</p><br />
<br />
<p>go 没有像 C 语言那样提供精确的堆与栈分配控制，由于提供了内存自动管理的功能，很大程度上模糊了堆与栈的界限。例如以下代码：</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br />
    str := GetString()<br />
    _ = str<br />
}</p><br />
<br />
<p>func GetString() *string {<br />
    var s string<br />
    s = “hello”<br />
    return &amp;s<br />
}<br />
行 10 中的变量 s = “hello” 尽管声明在了 GetString() 函数内，但是在 main 函数中却仍然能够访问到返回的变量；这种在函数内定义的局部变量，能够突破自身的范围被外部访问的行为称作逃逸，也即通过逃逸将变量分配到堆上，能够跨边界进行数据共享。</p><br />
<br />
<p>Escape Analysis 技术就是为该场景而存在的；通过 Escape Analysis 技术，编译器会在编译阶段对代码做了分析，当发现当前作用域的变量没有跨出函数范围，则会自动分配在 stack 上，反之则分配在 heap 上。 go 的内存回收针对的也是堆上的对象。go 语言中 Escape Analysis还未看到官方 spec 的文档，因此很多特性需要进行代码尝试和分析才能得出结论，而且 go Escape Analysis 的实现还存在很多不完善的地方。</p><br />
<br />
<p>stack allocation is cheap and heap allocation is expensive.</p><br />
<br />
<p>Go 语言逃逸分析实现<br />
更多内存建议阅读 Allocation efficiency in high-performance Go services</p><br />
<br />
<p>2.go</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br />
        x := 42<br />
        fmt.Println(x)<br />
}<br />
go build 工具中的 flag -gcflags ‘-m’ 可以用来分析内存逃逸的情况汇总，最多可以提供 4 个 “-m”, m 越多则表示分析的程度越详细，一般情况下我们可以采用两个 m 分析。</p><br />
<br />
<p>$ go build -gcflags ‘-m -l’ 2.go</p><br />
<h1 id="command-line-arguments-1">command-line-arguments</h1><br />
<p>./2.go:7:13: x escapes to heap<br />
./2.go:7:13: main … argument does not escape</p><br />
<br />
<h1 id="-l-disable-inline-也可以调用的函数前添加注释">-l disable inline， 也可以调用的函数前添加注释</h1><br />
<p>$ go build -gcflags ‘-m -m -l’ 2.go</p><br />
<h1 id="command-line-arguments-2">command-line-arguments</h1><br />
<p>./2.go:7:13: x escapes to heap<br />
./2.go:7:13:    from … argument (arg to …) at ./2.go:7:13<br />
./2.go:7:13:    from *(… argument) (indirection) at ./2.go:7:13<br />
./2.go:7:13:    from … argument (passed to call[argument content escapes]) at ./2.go:7:13<br />
./2.go:7:13: main … argument does not escape<br />
上例中的 x escapes to heap 则表明了变量 x 变量逃逸到了堆（heap）上。其中 -l 表示不启用 inline 模式调用，否则会使得分析更加复杂，也可以在函数上方添加注释 //go:noinline禁止函数 inline调用。至于调用 fmt.Println()为什么会导致 x escapes to heap，可以参考 Issue #19720 和 Issue #8618，对于上述 fmt.Println() 的行为我们可以通过以下代码进行简单模拟测试，效果基本一样：</p><br />
<br />
<p>package main</p><br />
<br />
<p>type pp struct {<br />
    arg interface{}<br />
}</p><br />
<br />
<p>func MyPrintln(a …interface{}) {<br />
    Fprintln(a…)<br />
}</p><br />
<br />
<p>func Fprintln(a …interface{}) (n int, err error) {<br />
    pp := new(pp)<br />
    pp.arg = a  // 此处导致了内存的逃逸<br />
    return<br />
}</p><br />
<br />
<p>func main() {<br />
    x := 42<br />
    MyPrintln(x)<br />
}<br />
内存逃逸分析结果如下：</p><br />
<br />
<p>$ go build -gcflags ‘-m -m -l’ 3.go</p><br />
<h1 id="command-line-arguments-3">command-line-arguments</h1><br />
<p>./3.go:13:9: a escapes to heap<br />
./3.go:13:9:    from pp.arg (star-dot-equals) at ./3.go:13:9<br />
./3.go:11:45: leaking param: a<br />
./3.go:11:45:   from a (interface-converted) at ./3.go:13:9<br />
./3.go:11:45:   from pp.arg (star-dot-equals) at ./3.go:13:9<br />
./3.go:12:11: Fprintln new(pp) does not escape<br />
./3.go:7:21: leaking param: a<br />
./3.go:7:21:    from a (passed to call[argument escapes]) at ./3.go:8:10<br />
./3.go:19:11: … argument escapes to heap<br />
./3.go:19:11:   from … argument (passed to call[argument escapes]) at ./3.go:19:11<br />
./3.go:19:11: x escapes to heap<br />
./3.go:19:11:   from … argument (arg to …) at ./3.go:19:11<br />
./3.go:19:11:   from … argument (passed to call[argument escapes]) at ./3.go:19:11<br />
逃逸的常见情况分析参见： http://www.agardner.me/golang/garbage/collection/gc/escape/analysis/2015/10/18/go-escape-analysis.html</p><br />
<br />
<p>主要原因如下：变量 x 虽为 int 类型，但是在传递给函数 MyPrintln函数中被转换成 interface{} 类型，因为 interface{} 类型中包含指向数据的地址，因此 x 在传递到函数 MyPrintln过程中进行了一个内存重新分配的过程，由于 pp.arg = a 结构体中的字段赋值的引用，导致了后续变量的逃逸到了堆上。如果将上述 pp.arg = a 注释掉，则不会出现内存逃逸的情况。</p><br />
<br />
<p>导致内存逃逸的情况比较多，有些可能还是官方未能够实现精确的分析逃逸情况的 bug，简单一点来讲就是如果变量的作用域不会扩大并且其行为或者大小能够在编译的时候确定，一般情况下都是分配到栈上，否则就可能发生内存逃逸分配到堆上。</p><br />
<br />
<p>简单总结一下有以下几类情况：</p><br />
<br />
<p>发送指针的指针或值包含了指针到 channel 中，由于在编译阶段无法确定其作用域与传递的路径，所以一般都会逃逸到堆上分配。<br />
slices 中的值是指针的指针或包含指针字段。一个例子是类似[] *string 的类型。这总是导致 slice 的逃逸。即使切片的底层存储数组仍可能位于堆栈上，数据的引用也会转移到堆中。</p><br />
<br />
<p>slice 由于 append 操作超出其容量，因此会导致 slice 重新分配。这种情况下，由于在编译时 slice 的初始大小的已知情况下，将会在栈上分配。如果 slice 的底层存储必须基于仅在运行时数据进行扩展，则它将分配在堆上。</p><br />
<br />
<p>调用接口类型的方法。接口类型的方法调用是动态调度 - 实际使用的具体实现只能在运行时确定。考虑一个接口类型为 io.Reader 的变量 r。对 r.Read(b) 的调用将导致 r 的值和字节片b的后续转义并因此分配到堆上。 参考 http://npat-efault.github.io/programming/2016/10/10/escape-analysis-and-interfaces.html</p><br />
<br />
<p>尽管能够符合分配到栈的场景，但是其大小不能够在在编译时候确定的情况，也会分配到堆上</p><br />
<br />
<p>关于指针<br />
关于指针的使用多数情况下我们会受一个前提影响：“指针传递过程不涉及到底层数据拷贝，因此效率更高”，而且一般情况下也的确是如此。</p><br />
<br />
<p>但是由于指针的访问是间接寻址，也就是说访问到了指针保存的地址后，还需要根据保存的地址再进行一次访问，才能获取到指针所指向的数据，另外一种情况对于指针在使用的时候还需要进行 nil 情况的判断，以防止 panic 的发生，更重要的是指针所指向的地址多数是保存在堆上，在涉及到内存收回的情况下，指针的存在可能会让程序的性能大打折扣。除此之外由于指针的间接访问，还会导致缓存的优化失效，可以参考 Locality of reference，当前在缓存中拷贝少量数据与指针的访问相比，性能上基本上可以等同。</p><br />
<br />
<p>综上所述，指针的使用也不是没有代价的，需要合理进行使用。</p><br />
<br />
<p>“the garbage collector will skip regions of memory that it can prove will contain no pointers”</p><br />
<br />
<p>简单点讲，如果在堆上分配的结构中指针比较少，回收的机制会比较简单，应该会提升回收的效率，需要通过了解 go 回收算法进行相关测试 。 TODO</p><br />
<br />
<p>关于接口转换<br />
接口实现参见： Go Data Structures: Interfaces Go interfaces: static vs dynamic binding</p><br />
<br />
<p>上图展示了一个 Binary 对象转换成一个 Stringer 接口后的数据结构。检查类型是否匹配 s.tab-&gt;type 即可。</p><br />
<br />
<p>go 语言中的 interface 接口，在编译时候的时候会进行隐式转换的静态检查，但是显示的 interface 到 interface 的转换可以在运行时查询方法集，动态检测比如：</p><br />
<br />
<p>type Stringer interface {<br />
    String() string<br />
}</p><br />
<br />
<p>if v, ok := any.(Stringer); ok {<br />
        return v.String()<br />
 }<br />
关于 Itab 结构的计算，由于（interface、type）对的不确定性，go 编译器或者链接器不可能在编译的时候计算两者的对应关系，而且即使能够计算出来也可能是绝大多数的对应关系在实际中不适用；因此 go 编译器会在编译的过程中对于 interface 和 type 中的方法生成一个相关的描述结构，分别记录 interface 和 type 各自对应的方法集合，go 语言会在 type 实际的动态转换成 interface 过程中，将 interafce 中定义的方法在 type 中一一进行对比查找，并完善 Itab 结构，并将 Itab 结构进行缓存提升性能。</p><br />
<br />
<p>综上所述，go 中的接口类型的方法调用是动态调度，因此不能够在编译阶段确定，所有类型结构转换成接口的过程会涉及到内存逃逸的情况发生。如果对于性能要求比较高且访问频次比较高的函数调用，应该尽量避免使用接口类型。</p><br />
<br />
<p>以下样例参考：http://npat-efault.github.io/programming/2016/10/10/escape-analysis-and-interfaces.html</p><br />
<br />
<p>package main</p><br />
<br />
<p>// go build -gcflags ‘-m -m -l’ 5.go</p><br />
<br />
<p>type S struct {<br />
    s1 int<br />
}</p><br />
<br />
<p>func (s *S) M1(i int) { s.s1 = i }</p><br />
<br />
<p>type I interface {<br />
    M1(int)<br />
}</p><br />
<br />
<p>func main() {<br />
    var s1 S // this escapes<br />
    var s2 S // this does not</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f1(&amp;s1)<br />
f2(&amp;s2) }<br />
</code></pre></div></div><br />
<br />
<p>func f1(s I)  { s.M1(42) }<br />
func f2(s *S) { s.M1(42) }<br />
逃逸分析确认：</p><br />
<br />
<p>go build -gcflags ‘-m -m -l’ 5.go</p><br />
<h1 id="command-line-arguments-4">command-line-arguments</h1><br />
<p>./5.go:9:18: (*S).M1 s does not escape<br />
./5.go:23:11: leaking param: s<br />
./5.go:23:11:   from s.M1(42) (receiver in indirect call) at ./5.go:23:21<br />
./5.go:24:12: f2 s does not escape<br />
./5.go:19:5: &amp;s1 escapes to heap<br />
./5.go:19:5:    from &amp;s1 (passed to call[argument escapes]) at ./5.go:19:4<br />
./5.go:19:5: &amp;s1 escapes to heap<br />
./5.go:19:5:    from &amp;s1 (interface-converted) at ./5.go:19:5<br />
./5.go:19:5:    from &amp;s1 (passed to call[argument escapes]) at ./5.go:19:4<br />
./5.go:16:6: moved to heap: s1<br />
./5.go:20:5: main &amp;s2 does not escape</p><br />
<autogenerated>:1:0: leaking param: .this<br />
<autogenerated>:1:0:    from .this.M1(.anon0) (receiver in indirect call) at <autogenerated>:1:0<br />
性能测试分析：<br />
<br />
package main_test<br />
<br />
import "testing"<br />
<br />
// go test -bench . --benchmem -gcflags "-N -l" 5_test.go<br />
<br />
type S struct {<br />
    s1 int<br />
}<br />
<br />
func (s *S) M1(i int) {<br />
    s.s1 = i<br />
}<br />
<br />
type I interface {<br />
    M1(int)<br />
}<br />
<br />
func f1(s I)  { s.M1(86) }<br />
func f2(s *S) { s.M1(86) }<br />
<br />
func BenchmarkTestInterface(b *testing.B) {<br />
    var s1 S<br />
    for i := 0; i &lt; b.N; i++ {<br />
        f1(&amp;s1)<br />
    }<br />
}<br />
<br />
func BenchmarkTestNoInterface(b *testing.B) {<br />
    var s2 S<br />
    for i := 0; i &lt; b.N; i++ {<br />
        f2(&amp;s2)<br />
    }<br />
}<br />
禁止使用 inline 方式的函数调用性能报告：<br />
<br />
# 禁止使用 inline<br />
$ go test -bench . --benchmem -gcflags "-N -l" 5_test.go<br />
goos: darwin<br />
goarch: amd64<br />
BenchmarkTestInterface-8        300000000            4.50 ns/op        0 B/op          0 allocs/op<br />
BenchmarkTestNoInterface-8      500000000            3.80 ns/op        0 B/op          0 allocs/op<br />
PASS<br />
ok      command-line-arguments  4.094s<br />
<br />
启用了 inline 方式的函数调用性能报告：<br />
<br />
# 如果启用了 inline，性能差别非常明显<br />
$ go test -bench . --benchmem  5_test.go<br />
goos: darwin<br />
goarch: amd64<br />
BenchmarkTestInterface-8        500000000            3.45 ns/op        0 B/op          0 allocs/op<br />
BenchmarkTestNoInterface-8      2000000000           0.29 ns/op        0 B/op          0 allocs/op<br />
PASS<br />
ok      command-line-arguments  2.685s<br />
<br />
关于切片<br />
由于切片一般都是使用在函数传递的场景下，而且切片在 append 的时候可能会涉及到重新分配内存，如果切片在编译期间的大小不能够确认或者大小超出栈的限制，多数情况下都会分配到堆上。<br />
<br />
大小验证<br />
package main<br />
<br />
func main() {<br />
    s := make([]byte, 1, 1*1024)<br />
    _ = s<br />
}<br />
$ go build -gcflags "-m -m" slice_esc.go<br />
# command-line-arguments<br />
./slice_esc.go:3:6: can inline main as: func() { s := make([]byte, 1, 1 * 1024); _ = s }<br />
./slice_esc.go:4:11: main make([]byte, 1, 1 * 1024) does not escape<br />
如果 slice 大小超过 64k，则会分配到堆上 （go 1.9.2)<br />
<br />
package main<br />
<br />
func main() {<br />
    s := make([]byte, 1, 64*1024) // 64k<br />
    _ = s<br />
}<br />
$ go build -gcflags "-m -m" slice_esc.go<br />
# command-line-arguments<br />
./slice_esc.go:3:6: can inline main as: func() { s := make([]byte, 1, 64 * 1024); _ = s }<br />
./slice_esc.go:4:11: make([]byte, 1, 64 * 1024) escapes to heap<br />
./slice_esc.go:4:11:    from make([]byte, 1, 64 * 1024) (too large for stack) at ./slice_esc.go:4:11<br />
<br />
指针类型切片验证<br />
package main<br />
<br />
func main() {<br />
    s := make([]*string, 1, 100)<br />
    str := "hello"<br />
    s = append(s, &amp;str)<br />
    _ = s<br />
}<br />
$ go build -gcflags "-m -m -l" slice_esc.go<br />
# command-line-arguments<br />
./slice_esc.go:6:16: &amp;str escapes to heap<br />
./slice_esc.go:6:16:    from append(s, &amp;str) (appended to slice) at ./slice_esc.go:6:12<br />
./slice_esc.go:5:9: moved to heap: str<br />
./slice_esc.go:4:11: main make([]*string, 1, 100) does not escape<br />
<br />
对于保存在 []*string 中的字符串都会直接在堆上分配。<br />
<br />
package main<br />
<br />
import "math/rand"<br />
<br />
func main() {<br />
    randSize := rand.Int()<br />
    s := make([]*string, 0, randSize)<br />
    str := "hello"<br />
    s = append(s, &amp;str)<br />
    _ = s<br />
}<br />
$ go build -gcflags "-m -m -l" slice_esc.go<br />
# command-line-arguments<br />
./slice_esc.go:7:11: make([]*string, 0, randSize) escapes to heap<br />
./slice_esc.go:7:11:    from make([]*string, 0, randSize) (too large for stack) at ./slice_esc.go:7:11<br />
./slice_esc.go:9:16: &amp;str escapes to heap<br />
./slice_esc.go:9:16:    from append(s, &amp;str) (appended to slice) at ./slice_esc.go:9:12<br />
./slice_esc.go:8:9: moved to heap: str<br />
由于 s := make([]*string, 0, randSize) 大小不能编译确定，所以会逃逸到堆上。<br />
<br />
参考<br />
Golang 内存逃逸分析<br />
深入解析 Go 中 Slice 底层实现 ***<br />
以C视角来理解Go内存逃逸<br />
golang string和[]byte的对比<br />
Go Slices: usage and internals<br />
Where is append() implementation?<br />
SliceTricks ***<br />
Variadic func changes []byte(s) cap #24972<br />
spec: clarify that conversions to slices don't guarantee slice capacity? #24163<br />
Golang escape analysis ***<br />
Go Escape Analysis Flaws<br />
Escape Analysis for Java<br />
Language Mechanics On Escape Analysis 中文 中文2<br />
Allocation efficiency in high-performance Go services ***<br />
Profiling Go Programs<br />
https://github.com/mushroomsir/blog/blob/master/Go%E4%B8%ADstring%E8%BD%AC%5B%5Dbyte%E7%9A%84%E9%99%B7%E9%98%B1.md<br />
the-go-programming-language-report<br />
https://golang.org/doc/faq<br />
年终盘点！2017年超有价值的Golang文章<br />
Golang 垃圾回收剖析<br />
深入Golang之垃圾回收<br />
<br />
https://www.do1618.com/archives/1328/go-%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/<br />
<br />
下面这段程序会输出什么？<br />
<br />
package main<br />
import "fmt"<br />
func f(s []string, level int) {<br />
        if level &gt; 5 {<br />
               return<br />
        }<br />
        s = append(s, fmt.Sprint(level))<br />
        f(s, level+1)<br />
        fmt.Println("level:", level, "slice:", s)<br />
}<br />
<br />
func main() {<br />
        f(nil, 0)<br />
}<br />
其输出为：<br />
<br />
level: 5 slice: [0 1 2 3 4 5]<br />
level: 4 slice: [0 1 2 3 4]<br />
level: 3 slice: [0 1 2 3]<br />
level: 2 slice: [0 1 2]<br />
level: 1 slice: [0 1]<br />
level: 0 slice: [0]<br />
如果对输出结果有一些疑惑,你需要了解这篇文章的内容<br />
<br />
如果你知道了结果,你仍然需要了解这篇文章的内容,因为本文完整介绍了<br />
<br />
切片的典型用法<br />
<br />
切片的陷阱<br />
<br />
切片的逃逸分析<br />
<br />
切片的扩容<br />
<br />
切片在编译与运行时的研究<br />
<br />
如果你啥都知道了,请直接滑动最下方,双击666.<br />
<br />
切片基本操作<br />
切片是某种程度上和其他语言(例如C语言)中的数组在使用中有许多相似之处,但是go语言中的切片有许多独特之处<br />
<br />
Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。<br />
<br />
一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，但是没有固定长度。<br />
<br />
数组和slice之间有着紧密的联系。一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能。一个slice在运行时由三个部分构成：指针、长度和容量。<br />
<br />
type SliceHeader struct {<br />
    Data uintptr<br />
    Len  int<br />
    Cap  int<br />
}<br />
指针指向第一个slice元素对应的底层数组元素的地址<br />
<br />
长度对应slice中元素的数目；长度不能超过容量<br />
<br />
容量一般是从slice的开始位置到底层数据的结尾位置的长度<br />
<br />
切片的声明<br />
//切片的声明1  //nil<br />
var slice1 []int<br />
<br />
//切片的声明2<br />
var slice2 []int = make([]int,5)<br />
var slice3 []int = make([]int,5,7)<br />
numbers:= []int{1,2,3,4,5,6,7,8}<br />
切片的截取<br />
numbers:= []int{1,2,3,4,5,6,7,8}<br />
//从下标1一直到下标4，但是不包括下标4<br />
numbers1 :=numbers[1:4]<br />
//从下标0一直到下标3，但是不包括下标3<br />
numbers2 :=numbers[:3]<br />
//从下标3一直到结束<br />
numbers3 :=numbers[3:]<br />
切片的长度与容量<br />
内置的len和cap函数分别返回slice的长度和容量<br />
<br />
    slice6 := make([]int,0)<br />
    fmt.Printf("len=%d,cap=%d,slice=%v\n",len(slice4),cap(slice4),slice4)<br />
切片与数组的拷贝对比<br />
数组的拷贝是副本拷贝。对于副本的改变不会影响到原来的数组<br />
<br />
但是，切片的拷贝很特殊，切片的拷贝只是对于运行时切片结构体的拷贝,切片的副本仍然指向了相同的数组。所以，对于副本的修改会影响到原来的切片。<br />
<br />
下面用一个简单的例子来说明<br />
<br />
    //数组是值类型<br />
    a := [4]int{1, 2, 3, 4}<br />
<br />
    //切片是引用类型<br />
    b := []int{100, 200, 300}<br />
<br />
    c := a<br />
    d := b<br />
<br />
    c[1] = 200<br />
    d[0] = 1<br />
    //output: c[1 200 3 4] a[1 2 3 4]<br />
    fmt.Println("a=", a, "c=", c)<br />
    //output: d[1 200 300]  b[1 200 300]<br />
    fmt.Println("b=", b, "d=", d)<br />
切片追加元素：append<br />
numbers := make([]int, 0, 20)<br />
<br />
<br />
//append一个元素<br />
numbers = append(numbers, 0)<br />
<br />
//append多个元素<br />
numbers = append(numbers, 1, 2, 3, 4, 5, 6, 7)<br />
<br />
<br />
//append添加切片<br />
s1 := []int{100, 200, 300, 400, 500, 600, 700}<br />
numbers = append(numbers, s1...)<br />
<br />
//now:[0 1 2 3 4 5 6 7 100 200 300 400 500 600 700]<br />
经典案例: 切片删除<br />
//    删除第一个元素<br />
numbers = numbers[1:]<br />
<br />
// 删除最后一个元素<br />
numbers = numbers[:len(numbers)-1]<br />
<br />
// 删除中间一个元素<br />
a := int(len(numbers) / 2)<br />
numbers = append(numbers[:a], numbers[a+1:]...)<br />
经典案例：切片反转<br />
// reverse reverses a slice of ints in place.<br />
func reverse(s []int) {<br />
    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 {<br />
        s[i], s[j] = s[j], s[i]<br />
    }<br />
}<br />
切片在编译时的特性<br />
编译时新建一个切片,切片内元素的类型是在编译期间确定的<br />
<br />
func NewSlice(elem *Type) *Type {<br />
    if t := elem.Cache.slice; t != nil {<br />
        if t.Elem() != elem {<br />
            Fatalf("elem mismatch")<br />
        }<br />
        return t<br />
    }<br />
<br />
    t := New(TSLICE)<br />
    t.Extra = Slice{Elem: elem}<br />
    elem.Cache.slice = t<br />
    return t<br />
}<br />
切片的类型<br />
<br />
// Slice contains Type fields specific to slice types.<br />
type Slice struct {<br />
    Elem *Type // element type<br />
}<br />
编译时：字面量初始化<br />
当我们使用字面量 []int{1, 2, 3} 创建新的切片时，会创建一个array数组([3]int{1,2,3})存储于静态区中。同时会创建一个变量。<br />
<br />
核心逻辑位于slicelit函数<br />
<br />
// go/src/cmd/compile/internal/gc/sinit.go<br />
func slicelit(ctxt initContext, n *Node, var_ *Node, init *Nodes)<br />
其抽象的过程如下:<br />
<br />
var vstat [3]int<br />
vstat[0] = 1<br />
vstat[1] = 2<br />
vstat[2] = 3<br />
var vauto *[3]int = new([3]int)<br />
*vauto = vstat<br />
slice := vauto[:]<br />
源码中的注释如下：<br />
<br />
// recipe for var = []t{...}<br />
// 1. make a static array<br />
//    var vstat [...]t<br />
// 2. assign (data statements) the constant part<br />
//    vstat = constpart{}<br />
// 3. make an auto pointer to array and allocate heap to it<br />
//    var vauto *[...]t = new([...]t)<br />
// 4. copy the static array to the auto array<br />
//    *vauto = vstat<br />
// 5. for each dynamic part assign to the array<br />
//    vauto[i] = dynamic part<br />
// 6. assign slice of allocated heap to var<br />
//    var = vauto[:]<br />
编译时：make 初始化<br />
例如make([]int,3,4)<br />
<br />
使用make 关键字,在typecheck1类型检查阶段,节点Node的op操作变为OMAKESLICE,并且左节点存储长度3, 右节点存储容量4<br />
<br />
func typecheck1(n *Node, top int) (res *Node) {<br />
switch t.Etype {<br />
case TSLICE:<br />
    if i &gt;= len(args) {<br />
        yyerror("missing len argument to make(%v)", t)<br />
        n.Type = nil<br />
        return n<br />
    }<br />
<br />
    l = args[i]<br />
    i++<br />
    l = typecheck(l, ctxExpr)<br />
    var r *Node<br />
    if i &lt; len(args) {<br />
        r = args[i]<br />
        i++<br />
        r = typecheck(r, ctxExpr)<br />
    }<br />
<br />
    if l.Type == nil || (r != nil &amp;&amp; r.Type == nil) {<br />
        n.Type = nil<br />
        return n<br />
    }<br />
    if !checkmake(t, "len", l) || r != nil &amp;&amp; !checkmake(t, "cap", r) {<br />
        n.Type = nil<br />
        return n<br />
    }<br />
    n.Left = l<br />
    n.Right = r<br />
    n.Op = OMAKESLICE<br />
下面来分析一下编译时内存的逃逸问题,如果make初始化了一个太大的切片，这个空间会逃逸到堆中,由运行时分配。如果一个空间比较小,会在栈中分配。<br />
<br />
此临界值值定义在/usr/local/go/src/cmd/compile/internal/gc，可以被flag smallframes更新,默认为64KB。<br />
<br />
所以make([]int64,1023) 与make([]int64,1024)的效果是截然不同的，这是不是压倒骆驼的最后一根稻草？<br />
<br />
// maximum size of implicit variables that we will allocate on the stack.<br />
    //   p := new(T)          allocating T on the stack<br />
    //   p := &amp;T{}            allocating T on the stack<br />
    //   s := make([]T, n)    allocating [n]T on the stack<br />
    //   s := []byte("...")   allocating [n]byte on the stack<br />
    // Note: the flag smallframes can update this value.<br />
    maxImplicitStackVarSize = int64(64 * 1024)<br />
核心逻辑位于go/src/cmd/compile/internal/gc/walk.go，n.Esc代表变量是否逃逸<br />
<br />
func walkexpr(n *Node, init *Nodes) *Node{<br />
case OMAKESLICE:<br />
    ...<br />
    if n.Esc == EscNone {<br />
        // var arr [r]T<br />
        // n = arr[:l]<br />
        i := indexconst(r)<br />
        if i &lt; 0 {<br />
            Fatalf("walkexpr: invalid index %v", r)<br />
        }<br />
        t = types.NewArray(t.Elem(), i) // [r]T<br />
        var_ := temp(t)<br />
        a := nod(OAS, var_, nil) // zero temp<br />
        a = typecheck(a, ctxStmt)<br />
        init.Append(a)<br />
        r := nod(OSLICE, var_, nil) // arr[:l]<br />
        r.SetSliceBounds(nil, l, nil)<br />
        r = conv(r, n.Type) // in case n.Type is named.<br />
        r = typecheck(r, ctxExpr)<br />
        r = walkexpr(r, init)<br />
        n = r<br />
    } else {<br />
        if t.Elem().NotInHeap() {<br />
            yyerror("%v is go:notinheap; heap allocation disallowed", t.Elem())<br />
        }<br />
<br />
        len, cap := l, r<br />
<br />
        fnname := "makeslice64"<br />
        argtype := types.Types[TINT64]<br />
<br />
        m := nod(OSLICEHEADER, nil, nil)<br />
        m.Type = t<br />
<br />
        fn := syslook(fnname)<br />
        m.Left = mkcall1(fn, types.Types[TUNSAFEPTR], init, typename(t.Elem()), conv(len, argtype), conv(cap, argtype))<br />
        m.Left.SetNonNil(true)<br />
        m.List.Set2(conv(len, types.Types[TINT]), conv(cap, types.Types[TINT]))<br />
<br />
        m = typecheck(m, ctxExpr)<br />
        m = walkexpr(m, init)<br />
        n = m<br />
    }<br />
对上面代码具体分析，如果没有逃逸，分配在栈中。<br />
<br />
抽象为：<br />
<br />
arr := [r]T<br />
ss := arr[:l]<br />
如果发生了逃逸，运行时调用makeslice64或makeslice分配在堆中,当切片的长度和容量小于int类型的最大值，会调用makeslice,反之调用makeslice64创建切片。<br />
<br />
makeslice64最终也是调用了makeslice,比较简单，最后调用mallocgc申请的内存大小为类型大小 * 容量cap<br />
<br />
// go/src/runtime/slice.go<br />
func makeslice(et *_type, len, cap int) unsafe.Pointer {<br />
    mem, overflow := math.MulUintptr(et.size, uintptr(cap))<br />
    if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap {<br />
        // NOTE: Produce a 'len out of range' error instead of a<br />
        // 'cap out of range' error when someone does make([]T, bignumber).<br />
        // 'cap out of range' is true too, but since the cap is only being<br />
        // supplied implicitly, saying len is clearer.<br />
        // See golang.org/issue/4085.<br />
        mem, overflow := math.MulUintptr(et.size, uintptr(len))<br />
        if overflow || mem &gt; maxAlloc || len &lt; 0 {<br />
            panicmakeslicelen()<br />
        }<br />
        panicmakeslicecap()<br />
    }<br />
<br />
    return mallocgc(mem, et, true)<br />
}<br />
<br />
func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer {<br />
    len := int(len64)<br />
    if int64(len) != len64 {<br />
        panicmakeslicelen()<br />
    }<br />
<br />
    cap := int(cap64)<br />
    if int64(cap) != cap64 {<br />
        panicmakeslicecap()<br />
    }<br />
<br />
    return makeslice(et, len, cap)<br />
}<br />
切片的扩容<br />
Go 中切片append表示添加元素,但不是使用了append就需要扩容,如下代码不需要扩容<br />
<br />
a:= make([]int,3,4)<br />
append(a,1)<br />
当Go 中切片append当容量超过了现有容量,才需要进行扩容,例如：<br />
<br />
a:= make([]int,3,3)<br />
append(a,1)<br />
核心逻辑位于go/src/runtime/slice.go growslice函数<br />
<br />
func growslice(et *_type, old slice, cap int) slice {<br />
    newcap := old.cap<br />
    doublecap := newcap + newcap<br />
    if cap &gt; doublecap {<br />
        newcap = cap<br />
    } else {<br />
        if old.len &lt; 1024 {<br />
            newcap = doublecap<br />
        } else {<br />
<br />
            for 0 &lt; newcap &amp;&amp; newcap &lt; cap {<br />
                newcap += newcap / 4<br />
            }<br />
<br />
            if newcap &lt;= 0 {<br />
                newcap = cap<br />
            }<br />
        }<br />
    }<br />
    ...<br />
}<br />
上面的代码显示了扩容的核心逻辑,Go 中切片扩容的策略是这样的：<br />
<br />
首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）<br />
<br />
否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）<br />
<br />
否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）<br />
<br />
如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）<br />
<br />
接着根据切片类型的大小,确定不同的内存分配大小。其主要是用作内存的对齐。因此，申请的内存可能会大于实际的et.size * newcap<br />
<br />
    switch {<br />
    case et.size == 1:<br />
        lenmem = uintptr(old.len)<br />
        newlenmem = uintptr(cap)<br />
        capmem = roundupsize(uintptr(newcap))<br />
        overflow = uintptr(newcap) &gt; maxAlloc<br />
        newcap = int(capmem)<br />
    case et.size == sys.PtrSize:<br />
        lenmem = uintptr(old.len) * sys.PtrSize<br />
        newlenmem = uintptr(cap) * sys.PtrSize<br />
        capmem = roundupsize(uintptr(newcap) * sys.PtrSize)<br />
        overflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSize<br />
        newcap = int(capmem / sys.PtrSize)<br />
    case isPowerOfTwo(et.size):<br />
        var shift uintptr<br />
        if sys.PtrSize == 8 {<br />
            // Mask shift for better code generation.<br />
            shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63<br />
        } else {<br />
            shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31<br />
        }<br />
        lenmem = uintptr(old.len) &lt;&lt; shift<br />
        newlenmem = uintptr(cap) &lt;&lt; shift<br />
        capmem = roundupsize(uintptr(newcap) &lt;&lt; shift)<br />
        overflow = uintptr(newcap) &gt; (maxAlloc &gt;&gt; shift)<br />
        newcap = int(capmem &gt;&gt; shift)<br />
    default:<br />
        lenmem = uintptr(old.len) * et.size<br />
        newlenmem = uintptr(cap) * et.size<br />
        capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))<br />
        capmem = roundupsize(capmem)<br />
        newcap = int(capmem / et.size)<br />
    }<br />
最后核心是申请内存。要注意的是，新的切片不一定意味着新的地址。<br />
<br />
根据切片类型et.ptrdata是否为指针,需要执行不同的逻辑。<br />
<br />
    if et.ptrdata == 0 {<br />
        p = mallocgc(capmem, nil, false)<br />
        // The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).<br />
        // Only clear the part that will not be overwritten.<br />
        memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)<br />
    } else {<br />
        // Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.<br />
        p = mallocgc(capmem, et, true)<br />
        if lenmem &gt; 0 &amp;&amp; writeBarrier.enabled {<br />
            // Only shade the pointers in old.array since we know the destination slice p<br />
            // only contains nil pointers because it has been cleared during alloc.<br />
            bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem)<br />
        }<br />
    }<br />
    memmove(p, old.array, lenmem)<br />
<br />
    return slice{p, old.len, newcap}<br />
当切片类型不是指针,分配内存后只需要将内存的后面的值清空,memmove(p, old.array, lenmem) 函数用于将old切片的值赋值给新的切片<br />
<br />
整个过程的抽象抽象表示如下<br />
<br />
old = make([]int,3,3)<br />
new = append(old,1) =&gt; new = malloc(newcap * sizeof(int))   a[4]  = 0<br />
new[1] = old[1]<br />
new[2] = old[2]<br />
new[3] = old[3]<br />
当切片类型为指针,指针需要写入当前协程缓冲区中,这个地方涉及到GC 回收机制中的写屏障,后面介绍。<br />
<br />
切片的截取<br />
对于数组下标的截取,如下所示，可以从多个维度证明,切片的截取生成了一个新的切片,但是底层数据源却是使用的同一个。<br />
<br />
    old := make([]int64,3,3)<br />
    new := old[1:3]<br />
    fmt.Printf("%p %p",arr,slice)<br />
输出为:<br />
<br />
0xc000018140 0xc000018148<br />
二者的地址正好相差了8个字节，这不是偶然的,而是因为二者指向了相同的数据源，刚好相差int64的大小。<br />
另外我们也可以从生成的汇编的过程查看到到一些端倪<br />
<br />
GOSSAFUNC=main GOOS=linux GOARCH=amd64 go tool compile main.go<br />
<br />
image<br />
在ssa的初始阶段start,old := make([]int64,3,3)对应的是SliceMake &lt;[]int&gt; v10 v15 v15, SliceMake操作￿需要传递数组的指针、长度、容量。<br />
而 new := old[1:3] 对应SliceMake &lt;[]int&gt; v34 v28 v29。传递的指针v34正好的原始的Ptr + 8个字节后的位置<br />
<br />
下面列出一张图比较形象的表示切片引用相同数据源的图：<br />
<br />
image<br />
切片的复制<br />
由于切片的复制不会改变指向的底层数据源。但是我们有些时候希望建一个新的数组，连底层数据源也是全新的。这个时候可以使用copy函数<br />
<br />
切片进行值拷贝：copy<br />
<br />
// 创建目标切片<br />
numbers1 := make([]int, len(numbers), cap(numbers)*2)<br />
// 将numbers的元素拷贝到numbers1中<br />
count := copy(numbers1, numbers)<br />
切片转数组<br />
<br />
slice := []byte("abcdefgh")<br />
var arr [4]byte<br />
copy(arr[:], slice[:4])<br />
//或者直接如下,这涉及到一个特性,即只会拷贝min(len(arr),len(slice)<br />
copy(arr[:], slice)<br />
copy函数在编译时会决定使用哪一种方式，普通的方式会直接调用memmove<br />
<br />
func copyany(n *Node, init *Nodes, runtimecall bool) *Node {<br />
    ...<br />
    if runtimecall {<br />
        if n.Right.Type.IsString() {<br />
            fn := syslook("slicestringcopy")<br />
            fn = substArgTypes(fn, n.Left.Type, n.Right.Type)<br />
            return mkcall1(fn, n.Type, init, n.Left, n.Right)<br />
        }<br />
<br />
        fn := syslook("slicecopy")<br />
        fn = substArgTypes(fn, n.Left.Type, n.Right.Type)<br />
        return mkcall1(fn, n.Type, init, n.Left, n.Right, nodintconst(n.Left.Type.Elem().Width))<br />
    }<br />
    ...<br />
    fn := syslook("memmove")<br />
    fn = substArgTypes(fn, nl.Type.Elem(), nl.Type.Elem())<br />
    nwid := temp(types.Types[TUINTPTR])<br />
    setwid := nod(OAS, nwid, conv(nlen, types.Types[TUINTPTR]))<br />
    ne.Nbody.Append(setwid)<br />
    nwid = nod(OMUL, nwid, nodintconst(nl.Type.Elem().Width))<br />
    call := mkcall1(fn, nil, init, nto, nfrm, nwid)<br />
}<br />
抽象表示为：<br />
<br />
 init {<br />
   n := len(a)<br />
   if n &gt; len(b) { n = len(b) }<br />
   if a.ptr != b.ptr { memmove(a.ptr, b.ptr, n*sizeof(elem(a))) }<br />
 }<br />
除非是协程调用的方式go copy(numbers1, numbers) 或者（加入了race等检测 &amp;&amp; 不是在编译go运行时代码） 会转而调用运行时slicestringcopy 或 slicecopy .<br />
<br />
case OCOPY:<br />
    n = copyany(n, init, instrumenting &amp;&amp; !compiling_runtime)<br />
case OGO:<br />
    switch n.Left.Op {<br />
    case OCOPY:<br />
        n.Left = copyany(n.Left, &amp;n.Ninit, true)<br />
slicestringcopy 或 slicecopy 本质上仍然是调用了memmove只是进行了额外的race冲突等判断。<br />
<br />
func slicecopy(to, fm slice, width uintptr) int {<br />
    ...<br />
    if raceenabled {<br />
        callerpc := getcallerpc()<br />
        pc := funcPC(slicecopy)<br />
        racewriterangepc(to.array, uintptr(n*int(width)), callerpc, pc)<br />
        racereadrangepc(fm.array, uintptr(n*int(width)), callerpc, pc)<br />
    }<br />
    if msanenabled {<br />
        msanwrite(to.array, uintptr(n*int(width)))<br />
        msanread(fm.array, uintptr(n*int(width)))<br />
    }<br />
<br />
    size := uintptr(n) * width<br />
    if size == 1 { // common case worth about 2x to do here<br />
        // TODO: is this still worth it with new memmove impl?<br />
        *(*byte)(to.array) = *(*byte)(fm.array) // known to be a byte pointer<br />
    } else {<br />
        memmove(to.array, fm.array, size)<br />
    }<br />
    return n<br />
}<br />
总结<br />
切片是go语言中重要的数据结果,其和其他语言不同的是，其维护了底层的内存，以及长度和容量<br />
<br />
切片与数组的赋值拷贝有明显区别,切片在赋值拷贝与下标截断时引用了相同的底层数据<br />
<br />
如果要完全复制切片,使用copy函数。其逻辑是新建一个新的内存,并拷贝过去。在极端情况需要考虑其对性能的影响<br />
<br />
切片字面量的初始化，数组存储于静态区。切片make的初始化方式时,如果make初始化了一个大于64KB的切片，这个空间会逃逸到堆中,在运行时调用makeslice创建。小于64KB的切片在栈中初始化<br />
<br />
Go 中切片append当容量超过了现有容量,需要进行扩容,其策略是：<br />
<br />
首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）<br />
<br />
否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap）<br />
<br />
否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap &gt;= cap）<br />
<br />
如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）<br />
<br />
Go 中切片append后返回的切片地址并不一定是原来的、也不一定是新的内存地址,因此必须小心其可能遇到的陷阱。一般会使用a = append(a,T)的方式保证安全。<br />
<br />
前文<br />
golang快速入门[1]-go语言导论<br />
<br />
golang快速入门[2.1]-go语言开发环境配置-windows<br />
<br />
golang快速入门[2.2]-go语言开发环境配置-macOS<br />
<br />
golang快速入门[2.3]-go语言开发环境配置-linux<br />
<br />
golang快速入门[3]-go语言helloworld<br />
<br />
golang快速入门[4]-go语言如何编译为机器码<br />
<br />
golang快速入门[5.1]-go语言是如何运行的-链接器<br />
<br />
golang快速入门[5.2]-go语言是如何运行的-内存概述<br />
<br />
golang快速入门[5.3]-go语言是如何运行的-内存分配<br />
<br />
golang快速入门[6.1]-集成开发环境-goland详解<br />
<br />
golang快速入门[6.2]-集成开发环境-emacs详解<br />
<br />
golang快速入门[7.1]-项目与依赖管理-gopath<br />
<br />
golang快速入门[7.2]-北冥神功—go module绝技<br />
<br />
golang快速入门[8.1]-变量类型、声明赋值、作用域声明周期与变量内存分配<br />
<br />
golang快速入门[8.2]-自动类型推断的秘密<br />
<br />
golang快速入门[8.3]-深入理解浮点数<br />
<br />
golang快速入门[8.4]-常量与隐式类型转换<br />
<br />
golang快速入门[9.1]--深入字符串的存储、编译与运行<br />
<br />
golang快速入门[9.2]-深入数组用法、陷阱与编译时<br />
<br />
https://mp.weixin.qq.com/s?__biz=MzU1NjY0MDk3NQ==&amp;mid=2247484222&amp;idx=1&amp;sn=feee698e4c3a32c47e2203bb76685e62&amp;chksm=fbc0bc9eccb7358868b3745a6f6bf21fe3a12a7e59d5fe7c224a1cebf7769f94b9b64d369431&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1587341167469&amp;sharer_shareid=8bc5c9f63486c7f1a0dc0c828de4b59b&amp;exportkey=ASllTw2sQCJzKPe6CqzWF54%3D&amp;pass_ticket=Xi4ovRoiqyRYOgFcVJvsZm%2Bj%2FbCpBkw%2B87QzEXYMWgQ8gmz%2FqPY8EuqR3690VyRi#rd<br />
</autogenerated></autogenerated></autogenerated><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>