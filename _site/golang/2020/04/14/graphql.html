<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">graphql-code-generator 生成graphql</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-04-14T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 14, 2020</time></p>
					</div>
					 <p>类似的工具比较多，比如prisma 、qloo、golang 的gqlgen、apollo-codegen<br />
graphql-code-generator 也是一个不错的工具（灵活、模版自定义<br />
<!-- more --><br />
npm install –save-dev graphql-code-generator graphql<br />
 Or<br />
 yarn add -D graphql-code-generator graphql<br />
参考demo<br />
项目初始化<br />
yarn init -y <br />
添加依赖<br />
 yarn add –dev graphql-code-generator graphql<br />
package.json:</p><br />
<br />
<p>https://github.com/eatonphil/gosql<br />
https://mp.weixin.qq.com/s/jOnqEz31rDcUxSNs_Hjwaw</p><br />
<br />
<p>GraphQL背景<br />
REST API的使用方式是，server定义一系列的接口，client调用自己需要的接口，获取目标数据进行整合。REST API开发中遇到的问题：</p><br />
<br />
<p>扩展性 ，随着API的不断发展，REST API的接口会变得越来臃肿。<br />
无法按需获取 ，一个返回id, name, age, city, addr, email的接口，如果仅获取部分信息，如name, age，却必须返回接口的全部信息，然后从中提取自己需要的。坏处不仅会增加网络传输量，并且不便于client处理数据<br />
一个请求无法获取所需全部资源 ，例如client需要显示一篇文章的内容，同时要显示评论，作者信息，那么就需要调用文章、评论、用户的接口。坏处造成服务的的维护困难，以及响应时间变长 。<br />
原因： REST API通常由多个端点组成，每个端点代表一种资源。所以，当client需要多个资源是，它需要向REST API发起多个请求，才能获取到所需要的数据。<br />
REST API不好处理的问题 ， 比如确保client提供的参数是类型安全的，如何从代码生成API的文档等。<br />
GraphQL解决的问题：</p><br />
<br />
<p>请求你的数据不多不少 ：GraphQL查询总是能准确获得你想要的数据，不多不少，所以返回的结果是可预测的。<br />
获取多个资源只用一个请求 ：GraphQL查询不仅能够获得资源的属性，还能沿着资源间进一步查询，所以GraphQL可以通过一次请求就获取你应用所需的所有数据。<br />
描述所有的可能类型系统： GraphQL API基于类型和字段的方式进行组成，使用类型来保证应用只请求可能的类型，同时提供了清晰的辅助性错误信息。<br />
使用你现有的数据和代码： GraphQL让你的整个应用共享一套API，通过GraphQL API能够更好的利用你的现有数据和代码。GraphQL 引擎已经有多种语言实现，GraphQL不限于某一特定数据库，可以使用已经存在的数据、代码、甚至可以连接第三方的APIs。<br />
API 演进无需划分版本： 给GraphQL API添加字段和类型而无需影响现有查询。老旧字段可以废弃，从工具中隐藏。<br />
什么是GraphQL<br />
GraphQL官网给出定义：GraphQL既是一种用于API的查询语言 也是一个满足你数据查询的运行时 。GraphQL对你的API中的数据提供了一套易于理解的完整描述 ，使得客户端能够准确地获得它需要的数据 ，而且没有任何冗余，也让API更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p><br />
<br />
<p>API不是用来调用的吗？是的，者正是GraphQL的强大之处，引用官方文档的一句话ask exactly what you want<br />
本质上来说GraphQL是一种查询语言<br />
上述的定义其实很难理解，只有真的使用过GraphQL才能够理解。<br />
在GraphQL中，通过定义一张Schema和声明一些Type来达到上述描述的功能，需要学习：</p><br />
<br />
<p>对于数据模型的抽象是通过Type来描述的 ，如何定义Type？<br />
对于接口获取数据的逻辑是通过schema来描述的 ，如何定义schema？<br />
如何定义Type<br />
对于数据模型的抽象是通过Type来描述的，每一个Type有若干Field组成，每个Field又分别指向某个Type。</p><br />
<br />
<p>GraphQL的Type简单可以分为两种，一种是scalar type（标量类型） ，另一种是object type（对象类型）。</p><br />
<br />
<p>scalar type<br />
GraphQL中的内建的标量包含，String、Int、Float、Boolean、Enum，除此之外，GraphQL中可以通过scalar声明一个新的标量 ，比如：</p><br />
<br />
<p>prisma ——一个使用GraphQL来抽象数据库操作的库中，还有DataTime（日期格式）和主键（ID）。<br />
在使用GraphQL实现文件上传接口时，需要声明一个Upload标量来代表要上传的文件。<br />
标量是GraphQL类型系统中最小的颗粒。<br />
object type<br />
仅有标量是不够抽象一些复杂的数据模型，这时需要使用对象类型。通过对象类型来构建GraphQL中关于一个数据模型的形状，同时还可以声明各个模型之间的内在关联（一对多，一对一或多对多）。</p><br />
<br />
<p>一对一模型</p><br />
<br />
<p>type Article {<br />
  id: ID<br />
  text: String<br />
  isPublished: Boolean<br />
  author: User<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
上述代码，声明了一个Article类型，它有3个Field，分别是id（ID类型）、text（String类型）、isPublished（Boolean类型）以及author（新建的对象类型User），User类型的声明如下：</p><br />
<br />
<p>type User {<br />
  id: ID<br />
  name: String<br />
}<br />
1<br />
2<br />
3<br />
4<br />
lType Modifier<br />
类型修饰符，当前的类型修饰符有两种，分别是List和Required ，语法分别为[Type]和[Type!]，两者可以组合：</p><br />
<br />
<p>[Type]! ：列表本身为必填项，但内部元素可以为空<br />
[Type!] ：列表本身可以为空，但是其内部元素为必填<br />
[Type!]! ：列表本身和内部元素均为必填<br />
如何定义Schema<br />
schema用来描述对于接口获取数据逻辑 ，GraphQL中使用Query来抽象数据的查询逻辑，分为三种，分别是query（查询）、mutation（更改）、subscription（订阅） 。API的接口概括起来有CRUD（创建、获取、更改、删除）四类，query可以覆盖R（获取）的功能，mutation可以覆盖（CUD创建、更改、删除）的功能。</p><br />
<br />
<p>注意： Query特指GraphQL中的查询（包含三种类型），query指GraphQL中的查询类型（仅指查询类型）。</p><br />
<br />
<p>Query<br />
query（查询）：当获取数据时，选择query类型<br />
mutation（更改）： 当尝试修改数据时，选择mutation类型<br />
subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型（针对当前的日趋流行的real-time应用提出的）。<br />
以Article为数据模型，分别以REST和GraphQL的角度，编写CURD的接口</p><br />
<br />
<p>Rest接口</p><br />
<br />
<p>GET /api/v1/articles/<br />
GET /api/v1/article/:id/<br />
POST /api/v1/article/<br />
DELETE /api/v1/article/:id/<br />
PATCH /api/v1/article/:id/<br />
GraphQL Query</p><br />
<br />
<p>query类型<br />
query {<br />
articles():[Article!]!<br />
article(id: Int!): Article!<br />
}<br />
mutation类型<br />
mutation {<br />
createArticle(): Article!<br />
updateArticle(id: Int): Article!<br />
deleteArticle(id: Int): Article!<br />
}<br />
注意：</p><br />
<br />
<p>GraphQL是按照类型来划分职能的query、mutation、ssubscription，同时必须明确声明返回的数据类型。</p><br />
<br />
<p>如果实际应用中对于评论列表有real-time 的需求，该如何处理？</p><br />
<br />
<p>在REST中，可以通过长连接，或者通过提供一些带验证的获取长连接URL的接口，比如POST /api/v1/messages/之后长连接会将新的数据进行实时推送。</p><br />
<br />
<p>在GraphQL中，会以更加声明式的方式进行声明，如下：</p><br />
<br />
<p>subscription {<br />
updatedArticle() {<br />
  mutation<br />
  node {<br />
    comments: [Comment!]!<br />
  }<br />
}<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
此处声明了一个subscription，这个subscription会在有新的Article被创建或者更新时，推送新的数据对象。实际上内部仍然是建立于长连接之上 。</p><br />
<br />
<p>Resolve<br />
上述的描述并未说明如何返回相关操作（query、mutation、subscription）的数据逻辑。所有此处引入一个更核心的概念Resolve(解析函数)</p><br />
<br />
<p>GraphQL中，默认有这样的约定，Query（包括query、mutation、subscription）和与之对应的Resolve是同名的，比如关于articles(): [Articles!]!这个query，它的Resolve的名字必然叫做articles</p><br />
<br />
<p>以已经声明的articles的query为例，解释下GraphQL的内部工作机制：</p><br />
<br />
<p>Query {<br />
articles {<br />
     id<br />
     author {<br />
        name<br />
     }<br />
     comments {<br />
    id<br />
    desc<br />
    author<br />
  }<br />
}<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
按照如下步骤进行解析：</p><br />
<br />
<p>首先进行第一次解析，当前的类型是query 类型，同时Resolver的名字为articles。<br />
之后会尝试使用articles的Resolver获取解析数据，第一层解析完毕<br />
之后对第一层解析的返回值，进行第二层解析，当前articles包含三个子query ，分别是id、author和comments<br />
id在Author类型中为标量类型，解析结束<br />
author在articles类型中为对象类型User，尝试使用User的Resolver获取数据，当前field解析完毕。<br />
之后对第二层解析的返回值，进行第三层解析，当前author还包含一个query，name是标量类型，解析结束<br />
comments解析同上<br />
概括总结GraphQL大体解析流程就是遇见一个Query之后，尝试使用它的Resolver取值，之后再对返回值进行解析，这个过程是递归的，直到所有解析Field类型是Scalar Type（标量类型）为止。整个解析过程可以想象为一个很长的Resolver Chain（解析链）。</p><br />
<br />
<p>Resolver本身的声明在各个语言中是不同的，它代表数据获取的具体逻辑。它的函数签名（以golang为例）：</p><br />
<br />
<p>func(p graphql.ResolveParams) (interface{}, error) {}</p><br />
<br />
<p>// ResolveParams Params for FieldResolveFn()<br />
type ResolveParams struct {<br />
    // Source is the source value<br />
    Source interface{}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Args is a map of arguments for current GraphQL request<br />
Args map[string]interface{}<br />
<br />
// Info is a collection of information about the current execution state.<br />
Info ResolveInfo<br />
<br />
// Context argument is a context value that is provided to every resolve function within an execution.<br />
// It is commonly<br />
// used to represent an authenticated user, or request-specific caches.<br />
Context context.Context } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 值得注意的是，Resolver内部实现对于GraphQL完全是黑盒状态。这意味着Resolver如何返回数据、返回什么样的数据、从哪里返回数据，完全取决于Resolver本身。GraphQL在实际使用中常常作为中间层来使用，**数据的获取通过Resolver来封装，内部数据获取的实现可能基于RPC、REST、WS、SQL等多种不同的方式。<br />
</code></pre></div></div><br />
<br />
<p>GraphQL例子<br />
下面这部分将会展示一个用graphql-go实现的用户管理的例子，包括获取全部用户信息、获取指定用户信息、修改用户名称、删除用户的功能，以及如何创建枚举类型的功能，完整代码在这里。</p><br />
<br />
<p>生成后的schema文件内容如下：<br />
type Mutation {<br />
  “”“[用户管理] 修改用户名称”””<br />
  changeUserName(<br />
    “"”用户ID”””<br />
    userId: Int!</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"""用户名称"""<br />
userName: String!   ): Boolean<br />
</code></pre></div></div><br />
<br />
<p>””“[用户管理] 创建用户”””<br />
  createUser(<br />
    “"”用户名称”””<br />
    userName: String!</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"""用户邮箱"""<br />
email: String!<br />
<br />
"""用户密码"""<br />
pwd: String!<br />
<br />
"""用户联系方式"""<br />
phone: Int   ): Boolean<br />
</code></pre></div></div><br />
<br />
<p>””“[用户管理] 删除用户”””<br />
  deleteUser(<br />
    “"”用户ID”””<br />
    userId: Int!<br />
  ): Boolean<br />
}</p><br />
<br />
<p>type Query {<br />
  “”“[用户管理] 获取指定用户的信息”””<br />
  UserInfo(<br />
    “"”用户ID”””<br />
    userId: Int!<br />
  ): userInfo</p><br />
<br />
<p>””“[用户管理] 获取全部用户的信息”””<br />
  UserListInfo: [userInfo]!<br />
}</p><br />
<br />
<p>”"”用户信息描述”””<br />
type userInfo {<br />
  “"”用户email”””<br />
  email: String</p><br />
<br />
<p>”"”用户名称”””<br />
  name: String</p><br />
<br />
<p>”"”用户手机号”””<br />
  phone: Int</p><br />
<br />
<p>”"”用户密码”””<br />
  pwd: String</p><br />
<br />
<p>”"”用户状态”””<br />
  status: UserStatusEnum</p><br />
<br />
<p>”"”用户ID”””<br />
  userID: Int<br />
}</p><br />
<br />
<p>”"”用户状态信息”””<br />
enum UserStatusEnum {<br />
  “"”用户可用”””<br />
  EnableUser</p><br />
<br />
<p>”"”用户不可用”””<br />
  DisableUser<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
25<br />
26<br />
27<br />
28<br />
29<br />
30<br />
31<br />
32<br />
33<br />
34<br />
35<br />
36<br />
37<br />
38<br />
39<br />
40<br />
41<br />
42<br />
43<br />
44<br />
45<br />
46<br />
47<br />
48<br />
49<br />
50<br />
51<br />
52<br />
53<br />
54<br />
55<br />
56<br />
57<br />
58<br />
59<br />
60<br />
61<br />
62<br />
63<br />
64<br />
65<br />
66<br />
67<br />
68<br />
69<br />
70<br />
71<br />
72<br />
73<br />
注意</p><br />
<br />
<p>GraphQL基于golang实现的例子比较少<br />
GraphQL的schema可以自动生成，具体操作可查看graphq-cli文档，步骤大致包括npm包的安装、graphql-cli工具的安装，配置文件的更改（此处需要指定服务对外暴露的地址） ，执行graphql get-schema 命令。<br />
GraphQL API以及Rsolve函数定义</p><br />
<br />
<p>type UserInfo struct {<br />
    UserID uint64               <code class="language-plaintext highlighter-rouge">json:"userID"</code><br />
    Name   string               <code class="language-plaintext highlighter-rouge">json:"name"</code><br />
    Email  string               <code class="language-plaintext highlighter-rouge">json:"email"</code><br />
    Phone  int64                <code class="language-plaintext highlighter-rouge">json:"phone"</code><br />
    Pwd    string               <code class="language-plaintext highlighter-rouge">json:"pwd"</code><br />
    Status model.UserStatusType <code class="language-plaintext highlighter-rouge">json:"status"</code><br />
}<br />
//这段内容是如何使用GraphQL定义枚举类型<br />
var UserStatusEnumType = graphql.NewEnum(graphql.EnumConfig{<br />
    Name:        “UserStatusEnum”,<br />
    Description: “用户状态信息”,<br />
    Values: graphql.EnumValueConfigMap{<br />
        “EnableUser”: &amp;graphql.EnumValueConfig{<br />
            Value:       model.EnableStatus,<br />
            Description: “用户可用”,<br />
        },<br />
        “DisableUser”: &amp;graphql.EnumValueConfig{<br />
            Value:       model.DisableStatus,<br />
            Description: “用户不可用”,<br />
        },<br />
    },<br />
})</p><br />
<br />
<p>var UserInfoType = graphql.NewObject(graphql.ObjectConfig{<br />
    Name:        “userInfo”,<br />
    Description: “用户信息描述”,<br />
    Fields: graphql.Fields{<br />
        “userID”: &amp;graphql.Field{<br />
            Description: “用户ID”,<br />
            Type:        graphql.Int,<br />
        },<br />
        “name”: &amp;graphql.Field{<br />
            Description: “用户名称”,<br />
            Type:        graphql.String,<br />
        },<br />
        “email”: &amp;graphql.Field{<br />
            Description: “用户email”,<br />
            Type:        graphql.String,<br />
        },<br />
        “phone”: &amp;graphql.Field{<br />
            Description: “用户手机号”,<br />
            Type:        graphql.Int,<br />
        },<br />
        “pwd”: &amp;graphql.Field{<br />
            Description: “用户密码”,<br />
            Type:        graphql.String,<br />
        },<br />
        “status”: &amp;graphql.Field{<br />
            Description: “用户状态”,<br />
            Type:        UserStatusEnumType,<br />
        },<br />
    },<br />
})<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
25<br />
26<br />
27<br />
28<br />
29<br />
30<br />
31<br />
32<br />
33<br />
34<br />
35<br />
36<br />
37<br />
38<br />
39<br />
40<br />
41<br />
42<br />
43<br />
44<br />
45<br />
46<br />
47<br />
48<br />
49<br />
50<br />
51<br />
52<br />
53<br />
54<br />
55<br />
query与mutation的定义<br />
var MutationType = graphql.NewObject(graphql.ObjectConfig{<br />
    Name: “Mutation”,<br />
    Fields: graphql.Fields{<br />
        “createUser”: &amp;graphql.Field{<br />
            Type:        graphql.Boolean,<br />
            Description: “[用户管理] 创建用户”,<br />
            Args: graphql.FieldConfigArgument{<br />
                “userName”: &amp;graphql.ArgumentConfig{<br />
                    Description: “用户名称”,<br />
                    Type:        graphql.NewNonNull(graphql.String),<br />
                },<br />
                “email”: &amp;graphql.ArgumentConfig{<br />
                    Description: “用户邮箱”,<br />
                    Type:        graphql.NewNonNull(graphql.String),<br />
                },<br />
                “pwd”: &amp;graphql.ArgumentConfig{<br />
                    Description: “用户密码”,<br />
                    Type:        graphql.NewNonNull(graphql.String),<br />
                },<br />
                “phone”: &amp;graphql.ArgumentConfig{<br />
                    Description: “用户联系方式”,<br />
                    Type:        graphql.Int,<br />
                },<br />
            },<br />
            Resolve: func(p graphql.ResolveParams) (interface{}, error) {<br />
                userId, _ := strconv.Atoi(GenerateID())<br />
                user := &amp;model.User{<br />
                  //展示如何解析传入的参数<br />
                    Name: p.Args[“userName”].(string),<br />
                    Email: sql.NullString{<br />
                        String: p.Args[“email”].(string),<br />
                        Valid:  true,<br />
                    },<br />
                    Pwd:    p.Args[“pwd”].(string),<br />
                    Phone:  int64(p.Args[“phone”].(int)),<br />
                    UserID: uint64(userId),<br />
                    Status: int64(model.EnableStatus),<br />
                }<br />
                if err := model.InsertUser(user); err != nil {<br />
                    log.WithError(err).Error(“[mutaition.createUser] invoke InserUser() failed”)<br />
                    return false, err<br />
                }<br />
                return true, nil</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        },<br />
    },<br />
<br />
}, })<br />
</code></pre></div></div><br />
<br />
<p>var QueryType = graphql.NewObject(graphql.ObjectConfig{<br />
    Name: “Query”,<br />
    Fields: graphql.Fields{<br />
        “UserListInfo”: &amp;graphql.Field{<br />
            Description: “[用户管理] 获取指定用户的信息”,<br />
          //定义了非空的list类型<br />
            Type:        graphql.NewNonNull(graphql.NewList(UserInfoType)),<br />
            Resolve: func(p graphql.ResolveParams) (interface{}, error) {<br />
                users, err := model.GetUsers()<br />
                if err != nil {<br />
                    log.WithError(err).Error(“[query.UserInfo] invoke InserUser() failed”)<br />
                    return false, err<br />
                }<br />
                usersList := make([]*UserInfo, 0)<br />
                for _, v := range users {<br />
                    userInfo := new(UserInfo)<br />
                    userInfo.Name = v.Name<br />
                    userInfo.Email = v.Email.String<br />
                    userInfo.Phone = v.Phone<br />
                    userInfo.Pwd = v.Pwd<br />
                    userInfo.Status = model.UserStatusType(v.Status)<br />
                    usersList = append(usersList, userInfo)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            }<br />
            return usersList, nil<br />
<br />
        },<br />
    },<br />
}, }) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 注意：<br />
</code></pre></div></div><br />
<br />
<p>此处仅展示了部分例子<br />
此处笔者仅列举了query、mutation类型的定义<br />
如何定义服务main函数<br />
type ServerCfg struct {<br />
    Addr      string<br />
    MysqlAddr string<br />
}</p><br />
<br />
<p>func main() {<br />
    //load config info<br />
    m := multiconfig.NewWithPath(“config.toml”)<br />
    svrCfg := new(ServerCfg)<br />
    m.MustLoad(svrCfg)<br />
    //new graphql schema<br />
    schema, err := graphql.NewSchema(<br />
        graphql.SchemaConfig{<br />
            Query:    object.QueryType,<br />
            Mutation: object.MutationType,<br />
        },<br />
    )<br />
    if err != nil {<br />
        log.WithError(err).Error(“[main] invoke graphql.NewSchema() failed”)<br />
        return<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>model.InitSqlxClient(svrCfg.MysqlAddr)<br />
h := handler.New(&amp;handler.Config{<br />
    Schema:   &amp;schema,<br />
    Pretty:   true,<br />
    GraphiQL: true,<br />
})<br />
http.HandleFunc("/graphql", func(w http.ResponseWriter, r *http.Request) {<br />
    ctx := context.Background()<br />
    //read user_id from gateway<br />
    userIDStr := r.Header.Get("user_id")<br />
    if len(userIDStr) &gt; 0 {<br />
        userID, err := strconv.Atoi(userIDStr)<br />
        if err != nil {<br />
            w.WriteHeader(http.StatusBadRequest)<br />
            w.Write([]byte(err.Error()))<br />
            return<br />
        }<br />
        ctx = context.WithValue(ctx, "ContextUserIDKey", userID)<br />
    }<br />
    h.ContextHandler(ctx, w, r)<br />
<br />
})<br />
log.Fatal(http.ListenAndServe(svrCfg.Addr, nil)) }<br />
</code></pre></div></div><br />
<br />
<p>http://graphql.cn/<br />
https://juejin.im/post/5ac1b03bf265da237b223e82<br />
https://laravel-china.org/topics/3112/why-did-github-open-a-graphql-version-of-api<br />
http://www.cnblogs.com/sunshine-anycall/p/6357577.html</p><br />
<br />
<p>Golang</p><br />
<br />
<p>Go 是Google开发的一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。为了方便搜索和识别，有时会将其称为Golang。<br />
GraphQL</p><br />
<br />
<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。<br />
Gin</p><br />
<br />
<p>Gin is a HTTP web framework written in Go (Golang).<br />
为什么要用GraphQL？</p><br />
<br />
<p>为了让api具有更强的适应性，采用graphql来编写查询接口是个不错的选择。现在的api需要适应的场景太多了，而且迭代节奏也很快，RESTful的查询接口在一些复杂的场景下显得特别的繁杂，如多重嵌套的资源。</p><br />
<br />
<p>为什么要用Go？</p><br />
<br />
<p>在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。</p><br />
<br />
<p>为什么要用Gin？</p><br />
<br />
<p>因为Gin够简洁，适合定制合适自己风格的框架。</p><br />
<br />
<p>在这里主要记录集成GraphQL的部分，对于Gin的目录结构组织因人而异，就不做详细介绍。</p><br />
<br />
<p>在Go里面集成graphql需要用到graphql-go这个package，当然可以参考GraphQL文档提供的其他。</p><br />
<br />
<p>// 从schema开始<br />
// schema/schema.go<br />
package schema</p><br />
<br />
<p>// 引入包graphql-go<br />
import (<br />
	“github.com/graphql-go/graphql”<br />
)</p><br />
<br />
<p>// 定义跟查询节点<br />
var rootQuery = graphql.NewObject(graphql.ObjectConfig{<br />
	Name: “RootQuery”,<br />
	Description: “Root Query”,<br />
	Fields: graphql.Fields{<br />
		“hello”: &amp;queryHello, // queryHello 参考schema/hello.go<br />
	},<br />
})</p><br />
<br />
<p>// 定义Schema用于http handler处理<br />
var Schema, _ = graphql.NewSchema(graphql.SchemaConfig{<br />
	Query:    rootQuery,<br />
	Mutation: nil, // 需要通过GraphQL更新数据，可以定义Mutation<br />
})</p><br />
<br />
<p>// schema/hello.go<br />
package schema</p><br />
<br />
<p>import (<br />
	“golesson/model”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/graphql-go/graphql" )<br />
</code></pre></div></div><br />
<br />
<p>// 定义查询对象的字段，支持嵌套<br />
var helloType = graphql.NewObject(graphql.ObjectConfig{<br />
	Name: “Hello”,<br />
	Description: “Hello Model”,<br />
	Fields: graphql.Fields{<br />
		“id”: &amp;graphql.Field{<br />
			Type: graphql.Int,<br />
		},<br />
		“name”: &amp;graphql.Field{<br />
			Type: graphql.String,<br />
		},<br />
	},<br />
})</p><br />
<br />
<p>// 处理查询请求<br />
var queryHello = graphql.Field{<br />
	Name: “QueryHello”,<br />
	Description: “Query Hello”,<br />
	Type: graphql.NewList(helloType),<br />
        // Args是定义在GraphQL查询中支持的查询字段，<br />
        // 可自行随意定义，如加上limit,start这类<br />
	Args: graphql.FieldConfigArgument{<br />
		“id”: &amp;graphql.ArgumentConfig{<br />
			Type: graphql.Int,<br />
		},<br />
		“name”: &amp;graphql.ArgumentConfig{<br />
			Type: graphql.String,<br />
		},<br />
	},<br />
        // Resolve是一个处理请求的函数，具体处理逻辑可在此进行<br />
	Resolve: func(p graphql.ResolveParams) (result interface{}, err error) {<br />
                // Args里面定义的字段在p.Args里面，对应的取出来<br />
                // 因为是interface{}的值，需要类型转换，可参考类型断言(type assertion): https://zengweigang.gitbooks.io/core-go/content/eBook/11.3.html<br />
		id, _ := p.Args[“id”].(int)<br />
		name, _ := p.Args[“name”].(string)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            // 调用Hello这个model里面的Query方法查询数据<br />
	return (&amp;model.Hello{}).Query(id, name)<br />
}, }<br />
</code></pre></div></div><br />
<br />
<p>// 准备好了GraphQL在Go里面需要的东西之后，来看看如何跟Gin结合<br />
// controller/graphql/graphql.go<br />
package graphql</p><br />
<br />
<p>import (<br />
	“golesson/schema”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/gin-gonic/gin"<br />
"github.com/graphql-go/handler" )<br />
</code></pre></div></div><br />
<br />
<p>func GraphqlHandler() gin.HandlerFunc{<br />
	h := handler.New(&amp;handler.Config{<br />
		Schema: &amp;schema.Schema,<br />
		Pretty: true,<br />
		GraphiQL: true,<br />
	})</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // 只需要通过Gin简单封装即可<br />
return func(c *gin.Context) {<br />
	h.ServeHTTP(c.Writer, c.Request)<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>// route/router.go<br />
package router</p><br />
<br />
<p>import (<br />
	“golesson/controller/graphql”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/gin-gonic/gin" )<br />
</code></pre></div></div><br />
<br />
<p>var Router *gin.Engine</p><br />
<br />
<p>func init() {<br />
	Router = gin.Default()<br />
}</p><br />
<br />
<p>func SetRouter() {<br />
        // GET方法用于支持GraphQL的web界面操作<br />
        // 如果不需要web界面，可根据自己需求用GET/POST或者其他都可以<br />
	Router.POST(“/graphql”, graphql.GraphqlHandler())<br />
	Router.GET(“/graphql”, graphql.GraphqlHandler())<br />
}</p><br />
<br />
<p>// main.go<br />
package main</p><br />
<br />
<p>import “golesson/route”</p><br />
<br />
<p>func main () {<br />
	r := router.Router</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>router.SetRouter()<br />
<br />
r.Run(":1234") }<br />
</code></pre></div></div><br />
<br />
<p>https://zhuanlan.zhihu.com/p/35792985</p><br />
<br />
<p>Github提供的GraphQL接口非常全面，那么我们该如何搭建出自己的接口呢？好在GraphQL提供了很多语言的解决方案。本文主要阐述如何用go搭建自己的GraphQL服务器。如果了解GraphQL建议先阅读GraphQL — API查询语言 或相关资料。</p><br />
<br />
<p>graphql-go<br />
An implementation of GraphQL in Go. Follows the official reference implementation graphql-js.<br />
一套比较完善的框架，众所周知go的结构体对json非常友好，所以并不需要对数据有特殊的处理，还是很方便的。打开终端输入命令</p><br />
<br />
<p>go get github.com/graphql-go/graphql</p><br />
<br />
<p>Object<br />
在服务端编程中，编写的一切都可以称之为对象（Object）。例如一个商品（goods）的实例可以有商品名（name）、价格（price）、购买链接（url）三个字段。此时商品可以很自然的被称为一个object，查询的语句可以写成：</p><br />
<br />
<p>{<br />
    goods{<br />
        name<br />
        price<br />
        url<br />
    }<br />
}<br />
如果此时我们要查询商品和文章两种object的信息:</p><br />
<br />
<p>/* query 可以省去 */<br />
query{ <br />
    goods{<br />
        name<br />
    }<br />
    article{<br />
        name<br />
    }<br />
}<br />
是否你已经发觉，query像一个大的object，它有goods和article两个字段。除此之外，mutation也是如此：</p><br />
<br />
<p>mutation{<br />
    addGoods(input:goodsInput){<br />
        name<br />
    }<br />
}<br />
这里的addGoods可以看做是一个可以处理参数的对象，也就是某种意义上的函数。</p><br />
<br />
<p>总之，GraphQL服务端的编程就是一个又一个的对象将形成的嵌套结构（schema）组织起来，并对外提供服务。</p><br />
<br />
<p>query&amp;mutation<br />
为了防止低级错误的发生，在当前pkg下新建一个名为query.go（随便起）的文件。</p><br />
<br />
<p>import (<br />
    “github.com/graphql-go/graphql”<br />
    “errors”<br />
)<br />
定义good object</p><br />
<br />
<p>type Goods struct {<br />
    ID    string <code class="language-plaintext highlighter-rouge">json:"id"</code><br />
    Name  string <code class="language-plaintext highlighter-rouge">json:"name"</code><br />
    Price float64<code class="language-plaintext highlighter-rouge">json:"price"</code><br />
    Url   string <code class="language-plaintext highlighter-rouge">json:"url"</code><br />
}</p><br />
<br />
<p>var goodsType = graphql.NewObject(<br />
    graphql.ObjectConfig{<br />
        Name: “Goods”,<br />
        Fields: graphql.Fields{<br />
            “id”: &amp;graphql.Field{<br />
                Type: graphql.String,<br />
            },<br />
            “name”: &amp;graphql.Field{<br />
                Type: graphql.String,<br />
            },<br />
            “price”: &amp;graphql.Field{<br />
                Type: graphql.Float,<br />
            },<br />
            “url”: &amp;graphql.Field{<br />
                Type: graphql.String,<br />
            },<br />
        },<br />
    },<br />
)<br />
var goodsListType = graphql.NewList(goodsType)<br />
注意：数组相当于新的object类型。</p><br />
<br />
<p>定义query object</p><br />
<br />
<p>var queryType = graphql.NewObject(<br />
    graphql.ObjectConfig{<br />
        Name: “Query”,<br />
        Fields: graphql.Fields{<br />
            // 无需处理参数<br />
            “goodsList”: &amp;graphql.Field{<br />
                Type:goodsListType,<br />
                // 处理结构体的回调函数，直接返回处理完成的结构体即可<br />
                Resolve: func(p graphql.ResolveParams) (interface{}, error) {<br />
                    return result, err<br />
                },<br />
            },<br />
            // 参数是id<br />
            “goods”: &amp;graphql.Field{<br />
                Type: goodsType,<br />
                Args: graphql.FieldConfigArgument{<br />
                    “id”: &amp;graphql.ArgumentConfig{<br />
                        Type: graphql.String,<br />
                    },<br />
                },<br />
                Resolve: func(p graphql.ResolveParams) (interface{}, error) {<br />
                    // 获取参数<br />
                    idQuery, isOK := p.Args[“id”].(string)<br />
                    if isOK {<br />
                        return result, nil<br />
                    }<br />
                    err := errors.New(“Field ‘goods’ is missing required arguments: id. “)<br />
                    return nil, err<br />
                },<br />
            },<br />
        },<br />
    },<br />
)<br />
mutation定义基本相同，新建一个名为mutation.go的文件：</p><br />
<br />
<p>定义input object</p><br />
<br />
<p>var goodsInputType = graphql.NewInputObject(<br />
    graphql.InputObjectConfig{<br />
        Name: “goodsInput”,<br />
        Fields: graphql.InputObjectConfigFieldMap{<br />
            “name”: &amp;graphql.InputObjectFieldConfig{<br />
                Type: graphql.String,<br />
            },<br />
            “price”: &amp;graphql.InputObjectFieldConfig{<br />
                Type: graphql.Float,<br />
            },<br />
            “url”: &amp;graphql.InputObjectFieldConfig{<br />
                Type: graphql.String,<br />
            },<br />
        },<br />
    },<br />
)<br />
定义 mutation object</p><br />
<br />
<p>var mutationType = graphql.NewObject(<br />
   graphql.ObjectConfig{<br />
      Name: “Mutation”,<br />
      Fields: graphql.Fields{<br />
      “addGoods”:&amp;graphql.Field{<br />
                Type:goodsType,<br />
                Args:graphql.FieldConfigArgument{<br />
                    “input”:&amp;graphql.ArgumentConfig{<br />
                        Type:goodsInputType,<br />
                    },<br />
                },<br />
                Resolve: func(p graphql.ResolveParams) (interface{}, error) {<br />
                    input,isOk := p.Args[“input”].(map[string]string)<br />
                    if !isOk{<br />
                        err := errors.New(“Field ‘addGoods’ is missing required arguments: input. “)<br />
                        return nil,err<br />
                    }<br />
                    result := Goods{<br />
                        Name:input[“name”].(string),<br />
                        Price:input[“price”].(float64),<br />
                        Url:input[“url”].(string),<br />
                    }<br />
                    // 处理数据<br />
                    return result,err<br />
                },<br />
            },<br />
        },<br />
    },<br />
)<br />
然而，input类型并不能直接转换为struct，而是一个map[string]interface{}类型，还需要进行手动转换。</p><br />
<br />
<p>定义schema</p><br />
<br />
<p>var schema, _ = graphql.NewSchema(<br />
   graphql.SchemaConfig{<br />
      Query:    queryType,<br />
      Mutation: mutationType,<br />
   },<br />
)<br />
至此，我们的全部的object定义完成。</p><br />
<br />
<p>提供服务<br />
graphql-go为我们提供了一个方便的接口，封装好的handler可以直接与go自带的http包绑定。</p><br />
<br />
<p>package api<br />
import “github.com/graphql-go/handler”</p><br />
<br />
<p>func Register() *handler.Handler {<br />
   h := handler.New(&amp;handler.Config{<br />
      Schema:   &amp;schema,<br />
      Pretty:   true,<br />
      GraphiQL: true,<br />
   })<br />
   return h<br />
}<br />
func main() {<br />
   h := api.Register()<br />
   handler := cors.Default().Handler(h)<br />
   http.Handle(“/graphql”, handler)<br />
   fmt.Println(“The api server will run on port : “, apiPort)<br />
   http.ListenAndServe(apiPort, nil)<br />
}<br />
打开浏览器，访问http://localhost:apiPort/graphql, 查看你自己的GraphiQL界面吧！</p><br />
<br />
<p>结束语<br />
如果你觉得这样的代码谈不上优雅，甚至非常丑陋，那就对了。因为我也这样觉得，看一看隔壁python的实现方式：</p><br />
<br />
<p>import graphene</p><br />
<br />
<p>class Query(graphene.ObjectType):<br />
  hello = graphene.String()</p><br />
<br />
<p>def resolve_hello(self, args, context, info):<br />
    return ‘Hello world!’</p><br />
<br />
<p>schema = graphene.Schema(query=Query)<br />
有没有涌来一口老血。</p><br />
<br />
<p>可能是受限与golang本身反射系统并不够完善，没有python各种各样的魔术方法，没有泛型，或者说go本身不太适合编写框架类的代码。在编写的过程中，冗余非常多，当然也可能是框架本身的问题</p><br />
<br />
<p>不可否认的是，go确实是非常不错的一门语言，虽然开发效率无法与python媲美，但是在多并发环境下，go表现出非常出色，同时拥有与C级别的运行速度和丰富的生态。</p><br />
<br />
<p>GitHub 宣布开放了一套使用 GraphQL 开发的公共 API。</p><br />
<br />
<p>GitHub 的 REST API 已经非常完善，设计得很优秀，很多公司开发自己的 REST API 时都会参考 GitHub，也有很多爱好者写了非常丰富的教程。</p><br />
<br />
<p>GraphQL 的核心是一套数据查询语言的规范，是 Facebook 在 2012 年开发的，2015 年开源，Facebook 内部已经广泛应用，用于替代 REST。</p><br />
<br />
<p>GitHub 为什么选择 GraphQL？这是很多用户关心的问题，Github 对此做了解释。</p><br />
<br />
<p>REST API 有什么问题？<br />
首要问题就是扩展性方面，随着 API 的不断发展，会变得越来越臃肿</p><br />
<br />
<p>REST API 的方式是：server 定义一系列的接口，client 调用自己需要的接口，获取目标数据进行整合</p><br />
<br />
<p>例如用户接口，刚开始时，返回的信息会比较少，例如只有 id,name</p><br />
<br />
<p>后来用户的信息增加了，就在用户接口中返回更多的信息，例如 id,name,age,city,addr,email,headimage,nick</p><br />
<br />
<p>但可能很多 client 只是想获取其中少部分信息，如 name,headimage，却必须得到所有的用户信息，然后从中提取自己想要的</p><br />
<br />
<p>这个情况会增加网络传输量，并且不便于 client 处理数据</p><br />
<br />
<p>还有一个不方便的地方，例如 client 在某个需求中，可能需要调用多个独立的 API 才能获取到足够的数据</p><br />
<br />
<p>例如 client 要显示一篇文章的内容，同时要显示评论、作者信息，那么就可能需要调用文章接口、评论接口、用户接口</p><br />
<br />
<p>这种方式非常不灵活</p><br />
<br />
<p>GitHub 还遇到其他一些 REST API 不好处理的问题，例如</p><br />
<br />
<p>想要确保 client 提供的参数的类型安全；想要从代码生成文档；想要识别每个端点的 OAuth 请求范围 ……</p><br />
<br />
<p>使用 GraphQL 有什么好处？<br />
GraphQL 简单来说就是：取哪些数据是由 client 来决定</p><br />
<br />
<p>REST 中，给哪些数据是 server 决定的，client 只能从中挑选，如果 A 接口中的数据不够，再请求 B 接口，然后从他们返回的数据中挑出自己需要的</p><br />
<br />
<p>GraphQL 中，client 直接对 server 说想要什么数据，server 负责精确的返回目标数据</p><br />
<br />
<p>例如，你想要获取用户的几个属性信息，你的 GraphQL 请求就是这样的</p><br />
<br />
<p>{<br />
 viewer {<br />
   login<br />
   bio<br />
   location<br />
   isBountyHunter<br />
 }<br />
}<br />
返回的响应信息如下</p><br />
<br />
<p>{<br />
 “data”: {<br />
   “viewer”: {<br />
     “login”: “octocat”,<br />
     “bio”: “I’ve been around the world, from London to the Bay.”,<br />
     “location”: “San Francisco, CA”,<br />
     “isBountyHunter”: true<br />
   }<br />
 }<br />
}<br />
再看一个更复杂的例子，例如你想知道你给多少个项目点亮过星星、最初 3 个项目的名字、及他们 star fork watcher 的总数可以看到，返回的 JSON 数据中，key value 是和请求完全一致的</p><br />
<br />
<p>GraphQL 请求就是这样的</p><br />
<br />
<p>{<br />
 viewer {<br />
   login<br />
   starredRepositories {<br />
     totalCount<br />
   }<br />
   repositories(first: 3) {<br />
     edges {<br />
       node {<br />
         name<br />
         stargazers {<br />
           totalCount<br />
         }<br />
         forks {<br />
           totalCount<br />
         }<br />
         watchers {<br />
           totalCount<br />
         }<br />
         issues(states:[OPEN]) {<br />
           totalCount<br />
         }<br />
       }<br />
     }<br />
   }<br />
 }<br />
}<br />
响应信息如下</p><br />
<br />
<p>{<br /><br />
 “data”:{<br /><br />
   “viewer”:{<br /><br />
     “login”: “octocat”,<br />
     “starredRepositories”: {<br />
       “totalCount”: 131<br />
     },<br />
     “repositories”:{<br />
       “edges”:[<br />
         {<br />
           “node”:{<br />
             “name”:”octokit.rb”,<br />
             “stargazers”:{<br />
               “totalCount”: 17<br />
             },<br />
             “forks”:{<br />
               “totalCount”: 3<br />
             },<br />
             “watchers”:{<br />
               “totalCount”: 3<br />
             },<br />
             “issues”: {<br />
               “totalCount”: 1<br />
             }<br />
           }<br />
         },<br />
         {<br /><br />
           “node”:{<br /><br />
             “name”:”octokit.objc”,<br />
             “stargazers”:{<br />
               “totalCount”: 2<br />
             },<br />
             “forks”:{<br />
               “totalCount”: 0<br />
             },<br />
             “watchers”:{<br />
               “totalCount”: 1<br />
             },<br />
             “issues”: {<br />
               “totalCount”: 10<br />
             }<br />
           }<br />
         },<br />
         {<br />
           “node”:{<br />
             “name”:”octokit.net”,<br />
             “stargazers”:{<br />
               “totalCount”: 19<br />
             },<br />
             “forks”:{<br />
               “totalCount”: 7<br />
             },<br />
             “watchers”:{<br />
               “totalCount”: 3<br />
             },<br />
             “issues”: {<br />
               “totalCount”: 4<br />
             }<br />
           }<br />
         }<br />
       ]<br />
     }<br />
   }<br />
 }<br />
}<br />
 代码已被折叠，点此展开<br />
GraphQL 还有很多其他的特点，例如你只需要一个请求，就可以得到所有需要的数据</p><br />
<br />
<p>批量请求，可以定义两个独立请求的依赖关系，高效的获取数据<br />
创建订阅，client 可以收到新的数据<br />
数据延迟，可以对响应中一部分数据标识为时间不敏感<br />
小结<br />
不只是 Github，还有很多大公司已经使用 GraphQL，例如 Pinterest, Coursera, Shopify</p><br />
<br />
<p>Github 也表达了对 GraphQL API 的重视，接下来会持续完善，使其更加灵活</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>