<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">切片</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-04-21T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 21, 2020</time></p>
					</div>
					 <p>https://gocn.vip/topics/10271<br />
下面这段程序会输出什么？</p><br />
<br />
<p>package main<br />
import “fmt”<br />
func f(s []string, level int) {<br />
        if level &gt; 5 {<br />
               return<br />
        }<br />
        s = append(s, fmt.Sprint(level))<br />
        f(s, level+1)<br />
        fmt.Println(“level:”, level, “slice:”, s)<br />
}</p><br />
<br />
<p>func main() {<br />
        f(nil, 0)<br />
}<br />
其输出为：</p><br />
<br />
<p>level: 5 slice: [0 1 2 3 4 5]<br />
level: 4 slice: [0 1 2 3 4]<br />
level: 3 slice: [0 1 2 3]<br />
level: 2 slice: [0 1 2]<br />
level: 1 slice: [0 1]<br />
level: 0 slice: [0]<br />
如果对输出结果有一些疑惑,你需要了解这篇文章的内容</p><br />
<br />
<p>如果你知道了结果,你仍然需要了解这篇文章的内容,因为本文完整介绍了</p><br />
<br />
<p>切片的典型用法<br />
切片的陷阱<br />
切片的逃逸分析<br />
切片的扩容<br />
切片在编译与运行时的研究<br />
<!-- more --><br />
切片基本操作<br />
切片是某种程度上和其他语言 (例如 C 语言) 中的数组在使用中有许多相似之处,但是 go 语言中的切片有许多独特之处<br />
Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。<br />
一个 slice 类型一般写作[]T，其中 T 代表 slice 中元素的类型；slice 的语法和数组很像，但是没有固定长度。<br />
数组和 slice 之间有着紧密的联系。一个 slice 是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能。一个 slice 在运行时由三个部分构成：指针、长度和容量。 type SliceHeader struct { Data uintptr Len int Cap int }<br />
指针指向第一个 slice 元素对应的底层数组元素的地址<br />
长度对应 slice 中元素的数目；长度不能超过容量<br />
容量一般是从 slice 的开始位置到底层数据的结尾位置的长度<br />
切片的声明<br />
//切片的声明1  //nil<br />
var slice1 []int</p><br />
<br />
<p>//切片的声明2<br />
var slice2 []int = make([]int,5)<br />
var slice3 []int = make([]int,5,7)<br />
numbers:= []int{1,2,3,4,5,6,7,8}<br />
切片的截取<br />
numbers:= []int{1,2,3,4,5,6,7,8}<br />
//从下标1一直到下标4，但是不包括下标4<br />
numbers1 :=numbers[1:4]<br />
//从下标0一直到下标3，但是不包括下标3<br />
numbers2 :=numbers[:3]<br />
//从下标3一直到结束<br />
numbers3 :=numbers[3:]<br />
切片的长度与容量<br />
内置的 len 和 cap 函数分别返回 slice 的长度和容量 slice6 := make([]int,0) fmt.Printf(“len=%d,cap=%d,slice=%v\n”,len(slice4),cap(slice4),slice4)<br />
切片与数组的拷贝对比<br />
数组的拷贝是副本拷贝。对于副本的改变不会影响到原来的数组<br />
但是，切片的拷贝很特殊，切片的拷贝只是对于运行时切片结构体的拷贝,切片的副本仍然指向了相同的数组。所以，对于副本的修改会影响到原来的切片。<br />
下面用一个简单的例子来说明</p><br />
<br />
<p>//数组是值类型<br />
a := [4]int{1, 2, 3, 4}</p><br />
<br />
<p>//切片是引用类型<br />
b := []int{100, 200, 300}</p><br />
<br />
<p>c := a<br />
d := b</p><br />
<br />
<p>c[1] = 200<br />
d[0] = 1<br />
//output: c[1 200 3 4] a[1 2 3 4]<br />
fmt.Println(“a=”, a, “c=”, c)<br />
//output: d[1 200 300]  b[1 200 300]<br />
fmt.Println(“b=”, b, “d=”, d)<br />
切片追加元素：append<br />
numbers := make([]int, 0, 20)</p><br />
<br />
<p>//append一个元素<br />
numbers = append(numbers, 0)</p><br />
<br />
<p>//append多个元素<br />
numbers = append(numbers, 1, 2, 3, 4, 5, 6, 7)</p><br />
<br />
<p>//append添加切片<br />
s1 := []int{100, 200, 300, 400, 500, 600, 700}<br />
numbers = append(numbers, s1…)</p><br />
<br />
<p>//now:[0 1 2 3 4 5 6 7 100 200 300 400 500 600 700]</p><br />
<br />
<p>经典案例: 切片删除<br />
//  删除第一个元素<br />
numbers = numbers[1:]</p><br />
<br />
<p>// 删除最后一个元素<br />
numbers = numbers[:len(numbers)-1]</p><br />
<br />
<p>// 删除中间一个元素<br />
a := int(len(numbers) / 2)<br />
numbers = append(numbers[:a], numbers[a+1:]…)<br />
经典案例：切片反转<br />
// reverse reverses a slice of ints in place.<br />
func reverse(s []int) {<br />
    for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 {<br />
        s[i], s[j] = s[j], s[i]<br />
    }<br />
}<br />
切片在编译时的特性<br />
编译时新建一个切片,切片内元素的类型是在编译期间确定的<br />
func NewSlice(elem *Type) *Type {<br />
    if t := elem.Cache.slice; t != nil {<br />
        if t.Elem() != elem {<br />
            Fatalf(“elem mismatch”)<br />
        }<br />
        return t<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>t := New(TSLICE)<br />
t.Extra = Slice{Elem: elem}<br />
elem.Cache.slice = t<br />
return t } 切片的类型 // Slice contains Type fields specific to slice types. type Slice struct {<br />
Elem *Type // element type }<br />
</code></pre></div></div><br />
<br />
<p>编译时：字面量初始化<br />
当我们使用字面量 [] int{1, 2, 3} 创建新的切片时，会创建一个 array 数组 ([3]int{1,2,3}) 存储于静态区中。同时会创建一个变量。</p><br />
<br />
<p>核心逻辑位于 slicelit 函数<br />
// go/src/cmd/compile/internal/gc/sinit.go<br />
func slicelit(ctxt initContext, n *Node, var_ *Node, init *Nodes)<br />
其抽象的过程如下:</p><br />
<br />
<p>var vstat [3]int<br />
vstat[0] = 1<br />
vstat[1] = 2<br />
vstat[2] = 3<br />
var vauto *[3]int = new([3]int)<br />
*vauto = vstat<br />
slice := vauto[:]<br />
源码中的注释如下：<br />
// recipe for var = []t{…}<br />
// 1. make a static array<br />
//  var vstat […]t<br />
// 2. assign (data statements) the constant part<br />
//  vstat = constpart{}<br />
// 3. make an auto pointer to array and allocate heap to it<br />
//  var vauto *[…]t = new([…]t)<br />
// 4. copy the static array to the auto array<br />
//  *vauto = vstat<br />
// 5. for each dynamic part assign to the array<br />
//  vauto[i] = dynamic part<br />
// 6. assign slice of allocated heap to var<br />
//  var = vauto[:]<br />
编译时：make 初始化<br />
例如make([]int,3,4)<br />
使用make 关键字,在 typecheck1 类型检查阶段,节点 Node 的 op 操作变为OMAKESLICE,并且左节点存储长度 3, 右节点存储容量 4<br />
func typecheck1(n *Node, top int) (res *Node) {<br />
switch t.Etype {<br />
case TSLICE:<br />
    if i &gt;= len(args) {<br />
        yyerror(“missing len argument to make(%v)”, t)<br />
        n.Type = nil<br />
        return n<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l = args[i]<br />
i++<br />
l = typecheck(l, ctxExpr)<br />
var r *Node<br />
if i &lt; len(args) {<br />
    r = args[i]<br />
    i++<br />
    r = typecheck(r, ctxExpr)<br />
}<br />
<br />
if l.Type == nil || (r != nil &amp;&amp; r.Type == nil) {<br />
    n.Type = nil<br />
    return n<br />
}<br />
if !checkmake(t, "len", l) || r != nil &amp;&amp; !checkmake(t, "cap", r) {<br />
    n.Type = nil<br />
    return n<br />
}<br />
n.Left = l<br />
n.Right = r<br />
n.Op = OMAKESLICE 下面来分析一下编译时内存的逃逸问题,如果 make 初始化了一个太大的切片，这个空间会逃逸到堆中,由运行时分配。如果一个空间比较小,会在栈中分配。 此临界值值定义在/usr/local/go/src/cmd/compile/internal/gc，可以被 flag smallframes 更新,默认为 64KB。 所以make([]int64,1023) 与make([]int64,1024)的效果是截然不同的，这是不是压倒骆驼的最后一根稻草？ // maximum size of implicit variables that we will allocate on the stack.<br />
//   p := new(T)          allocating T on the stack<br />
//   p := &amp;T{}            allocating T on the stack<br />
//   s := make([]T, n)    allocating [n]T on the stack<br />
//   s := []byte("...")   allocating [n]byte on the stack<br />
// Note: the flag smallframes can update this value.<br />
maxImplicitStackVarSize = int64(64 * 1024) 核心逻辑位于go/src/cmd/compile/internal/gc/walk.go，n.Esc代表变量是否逃逸 func walkexpr(n *Node, init *Nodes) *Node{ case OMAKESLICE:<br />
...<br />
if n.Esc == EscNone {<br />
    // var arr [r]T<br />
    // n = arr[:l]<br />
    i := indexconst(r)<br />
    if i &lt; 0 {<br />
        Fatalf("walkexpr: invalid index %v", r)<br />
    }<br />
    t = types.NewArray(t.Elem(), i) // [r]T<br />
    var_ := temp(t)<br />
    a := nod(OAS, var_, nil) // zero temp<br />
    a = typecheck(a, ctxStmt)<br />
    init.Append(a)<br />
    r := nod(OSLICE, var_, nil) // arr[:l]<br />
    r.SetSliceBounds(nil, l, nil)<br />
    r = conv(r, n.Type) // in case n.Type is named.<br />
    r = typecheck(r, ctxExpr)<br />
    r = walkexpr(r, init)<br />
    n = r<br />
} else {<br />
    if t.Elem().NotInHeap() {<br />
        yyerror("%v is go:notinheap; heap allocation disallowed", t.Elem())<br />
    }<br />
<br />
    len, cap := l, r<br />
<br />
    fnname := "makeslice64"<br />
    argtype := types.Types[TINT64]<br />
<br />
    m := nod(OSLICEHEADER, nil, nil)<br />
    m.Type = t<br />
<br />
    fn := syslook(fnname)<br />
    m.Left = mkcall1(fn, types.Types[TUNSAFEPTR], init, typename(t.Elem()), conv(len, argtype), conv(cap, argtype))<br />
    m.Left.SetNonNil(true)<br />
    m.List.Set2(conv(len, types.Types[TINT]), conv(cap, types.Types[TINT]))<br />
<br />
    m = typecheck(m, ctxExpr)<br />
    m = walkexpr(m, init)<br />
    n = m<br />
}<br />
</code></pre></div></div><br />
<br />
<p>对上面代码具体分析，如果没有逃逸，分配在栈中。<br />
抽象为：<br />
arr := [r]T<br />
ss := arr[:l]<br />
如果发生了逃逸，运行时调用 makeslice64 或 makeslice 分配在堆中,当切片的长度和容量小于 int 类型的最大值，会调用 makeslice,反之调用 makeslice64 创建切片。<br />
makeslice64 最终也是调用了 makeslice,比较简单，最后调用 mallocgc 申请的内存大小为类型大小 * 容量cap<br />
// go/src/runtime/slice.go<br />
func makeslice(et *_type, len, cap int) unsafe.Pointer {<br />
    mem, overflow := math.MulUintptr(et.size, uintptr(cap))<br />
    if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap {<br />
        // NOTE: Produce a ‘len out of range’ error instead of a<br />
        // ‘cap out of range’ error when someone does make([]T, bignumber).<br />
        // ‘cap out of range’ is true too, but since the cap is only being<br />
        // supplied implicitly, saying len is clearer.<br />
        // See golang.org/issue/4085.<br />
        mem, overflow := math.MulUintptr(et.size, uintptr(len))<br />
        if overflow || mem &gt; maxAlloc || len &lt; 0 {<br />
            panicmakeslicelen()<br />
        }<br />
        panicmakeslicecap()<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return mallocgc(mem, et, true) }<br />
</code></pre></div></div><br />
<br />
<p>func makeslice64(et *_type, len64, cap64 int64) unsafe.Pointer {<br />
    len := int(len64)<br />
    if int64(len) != len64 {<br />
        panicmakeslicelen()<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cap := int(cap64)<br />
if int64(cap) != cap64 {<br />
    panicmakeslicecap()<br />
}<br />
<br />
return makeslice(et, len, cap) }<br />
</code></pre></div></div><br />
<br />
<p>切片的扩容<br />
Go 中切片 append 表示添加元素,但不是使用了 append 就需要扩容,如下代码不需要扩容<br />
a:= make([]int,3,4)<br />
append(a,1)<br />
当 Go 中切片 append 当容量超过了现有容量,才需要进行扩容,例如：</p><br />
<br />
<p>a:= make([]int,3,3)<br />
append(a,1)<br />
核心逻辑位于go/src/runtime/slice.go growslice函数</p><br />
<br />
<p>func growslice(et *_type, old slice, cap int) slice {<br />
    newcap := old.cap<br />
    doublecap := newcap + newcap<br />
    if cap &gt; doublecap {<br />
        newcap = cap<br />
    } else {<br />
        if old.len &lt; 1024 {<br />
            newcap = doublecap<br />
        } else {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        for 0 &lt; newcap &amp;&amp; newcap &lt; cap {<br />
            newcap += newcap / 4<br />
        }<br />
<br />
        if newcap &lt;= 0 {<br />
            newcap = cap<br />
        }<br />
    }<br />
}<br />
... } 上面的代码显示了扩容的核心逻辑,Go 中切片扩容的策略是这样的：<br />
</code></pre></div></div><br />
<br />
<p>首先判断，如果新申请容量（cap）大于 2 倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）<br />
否则判断，如果旧切片的长度小于 1024，则最终容量 (newcap) 就是旧容量 (old.cap) 的两倍，即（newcap=doublecap）<br />
否则判断，如果旧切片长度大于等于 1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量 (cap)，即（newcap &gt;= cap）<br />
如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）<br />
接着根据切片类型的大小,确定不同的内存分配大小。其主要是用作内存的对齐。因此，申请的内存可能会大于实际的et.size * newcap</p><br />
<br />
<p>switch {<br />
case et.size == 1:<br />
    lenmem = uintptr(old.len)<br />
    newlenmem = uintptr(cap)<br />
    capmem = roundupsize(uintptr(newcap))<br />
    overflow = uintptr(newcap) &gt; maxAlloc<br />
    newcap = int(capmem)<br />
case et.size == sys.PtrSize:<br />
    lenmem = uintptr(old.len) * sys.PtrSize<br />
    newlenmem = uintptr(cap) * sys.PtrSize<br />
    capmem = roundupsize(uintptr(newcap) * sys.PtrSize)<br />
    overflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSize<br />
    newcap = int(capmem / sys.PtrSize)<br />
case isPowerOfTwo(et.size):<br />
    var shift uintptr<br />
    if sys.PtrSize == 8 {<br />
        // Mask shift for better code generation.<br />
        shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63<br />
    } else {<br />
        shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31<br />
    }<br />
    lenmem = uintptr(old.len) « shift<br />
    newlenmem = uintptr(cap) « shift<br />
    capmem = roundupsize(uintptr(newcap) « shift)<br />
    overflow = uintptr(newcap) &gt; (maxAlloc » shift)<br />
    newcap = int(capmem » shift)<br />
default:<br />
    lenmem = uintptr(old.len) * et.size<br />
    newlenmem = uintptr(cap) * et.size<br />
    capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))<br />
    capmem = roundupsize(capmem)<br />
    newcap = int(capmem / et.size)<br />
}</p><br />
<br />
<p>最后核心是申请内存。要注意的是，新的切片不一定意味着新的地址。<br />
根据切片类型et.ptrdata是否为指针,需要执行不同的逻辑。<br />
if et.ptrdata == 0 {<br />
    p = mallocgc(capmem, nil, false)<br />
    // The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).<br />
    // Only clear the part that will not be overwritten.<br />
    memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)<br />
} else {<br />
    // Note: can’t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.<br />
    p = mallocgc(capmem, et, true)<br />
    if lenmem &gt; 0 &amp;&amp; writeBarrier.enabled {<br />
        // Only shade the pointers in old.array since we know the destination slice p<br />
        // only contains nil pointers because it has been cleared during alloc.<br />
        bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem)<br />
    }<br />
}<br />
memmove(p, old.array, lenmem)</p><br />
<br />
<p>return slice{p, old.len, newcap}<br />
当切片类型不是指针,分配内存后只需要将内存的后面的值清空,memmove(p, old.array, lenmem) 函数用于将 old 切片的值赋值给新的切片<br />
整个过程的抽象抽象表示如下<br />
old = make([]int,3,3)<br />
new = append(old,1) =&gt; new = malloc(newcap * sizeof(int))   a[4]  = 0<br />
new[1] = old[1]<br />
new[2] = old[2]<br />
new[3] = old[3]<br />
当切片类型为指针,指针需要写入当前协程缓冲区中,这个地方涉及到 GC 回收机制中的写屏障,后面介绍。<br />
切片的截取<br />
对于数组下标的截取,如下所示，可以从多个维度证明,切片的截取生成了一个新的切片,但是底层数据源却是使用的同一个。<br />
old := make([]int64,3,3)<br />
new := old[1:3]<br />
fmt.Printf(“%p %p”,arr,slice)<br />
输出为:</p><br />
<br />
<p>0xc000018140 0xc000018148<br />
二者的地址正好相差了 8 个字节，这不是偶然的,而是因为二者指向了相同的数据源，刚好相差 int64 的大小。 另外我们也可以从生成的汇编的过程查看到到一些端倪</p><br />
<br />
<p>GOSSAFUNC=main GOOS=linux GOARCH=amd64 go tool compile main.go<br />
![image](../image/golang[10.2</p><br />
<br />
<p>在 ssa 的初始阶段start,old := make([]int64,3,3)对应的是SliceMake &lt;[]int&gt; v10 v15 v15, SliceMake 操作需要传递数组的指针、长度、容量。 而 new := old[1:3] 对应SliceMake &lt;[]int&gt; v34 v28 v29。传递的指针 v34 正好的原始的 Ptr + 8 个字节后的位置</p><br />
<br />
<p>下面列出一张图比较形象的表示切片引用相同数据源的图：</p><br />
<br />
<p>切片的复制<br />
由于切片的复制不会改变指向的底层数据源。但是我们有些时候希望建一个新的数组，连底层数据源也是全新的。这个时候可以使用copy函数<br />
切片进行值拷贝：copy<br />
// 创建目标切片<br />
numbers1 := make([]int, len(numbers), cap(numbers)*2)<br />
// 将numbers的元素拷贝到numbers1中<br />
count := copy(numbers1, numbers)<br />
切片转数组<br />
slice := []byte(“abcdefgh”)<br />
var arr [4]byte<br />
copy(arr[:], slice[:4])<br />
//或者直接如下,这涉及到一个特性,即只会拷贝min(len(arr),len(slice)<br />
copy(arr[:], slice)<br />
copy 函数在编译时会决定使用哪一种方式，普通的方式会直接调用memmove<br />
func copyany(n *Node, init *Nodes, runtimecall bool) *Node {<br />
    …<br />
    if runtimecall {<br />
        if n.Right.Type.IsString() {<br />
            fn := syslook(“slicestringcopy”)<br />
            fn = substArgTypes(fn, n.Left.Type, n.Right.Type)<br />
            return mkcall1(fn, n.Type, init, n.Left, n.Right)<br />
        }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    fn := syslook("slicecopy")<br />
    fn = substArgTypes(fn, n.Left.Type, n.Right.Type)<br />
    return mkcall1(fn, n.Type, init, n.Left, n.Right, nodintconst(n.Left.Type.Elem().Width))<br />
}<br />
...<br />
fn := syslook("memmove")<br />
fn = substArgTypes(fn, nl.Type.Elem(), nl.Type.Elem())<br />
nwid := temp(types.Types[TUINTPTR])<br />
setwid := nod(OAS, nwid, conv(nlen, types.Types[TUINTPTR]))<br />
ne.Nbody.Append(setwid)<br />
nwid = nod(OMUL, nwid, nodintconst(nl.Type.Elem().Width))<br />
call := mkcall1(fn, nil, init, nto, nfrm, nwid) }<br />
</code></pre></div></div><br />
<br />
<p>抽象表示为：<br />
init {<br />
  n := len(a)<br />
  if n &gt; len(b) { n = len(b) }<br />
  if a.ptr != b.ptr { memmove(a.ptr, b.ptr, n*sizeof(elem(a))) }<br />
}<br />
除非是协程调用的方式go copy(numbers1, numbers) 或者（加入了 race 等检测 &amp;&amp; 不是在编译 go 运行时代码） 会转而调用运行时 slicestringcopy 或 slicecopy .<br />
case OCOPY:<br />
    n = copyany(n, init, instrumenting &amp;&amp; !compiling_runtime)<br />
case OGO:<br />
    switch n.Left.Op {<br />
    case OCOPY:<br />
        n.Left = copyany(n.Left, &amp;n.Ninit, true)</p><br />
<br />
<p>slicestringcopy 或 slicecopy 本质上仍然是调用了memmove只是进行了额外的 race 冲突等判断。<br />
func slicecopy(to, fm slice, width uintptr) int {<br />
    …<br />
    if raceenabled {<br />
        callerpc := getcallerpc()<br />
        pc := funcPC(slicecopy)<br />
        racewriterangepc(to.array, uintptr(n<em>int(width)), callerpc, pc)<br />
        racereadrangepc(fm.array, uintptr(n</em>int(width)), callerpc, pc)<br />
    }<br />
    if msanenabled {<br />
        msanwrite(to.array, uintptr(n<em>int(width)))<br />
        msanread(fm.array, uintptr(n</em>int(width)))<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>size := uintptr(n) * width<br />
if size == 1 { // common case worth about 2x to do here<br />
    // TODO: is this still worth it with new memmove impl?<br />
    *(*byte)(to.array) = *(*byte)(fm.array) // known to be a byte pointer<br />
} else {<br />
    memmove(to.array, fm.array, size)<br />
}<br />
return n }<br />
</code></pre></div></div><br />
<br />
<p>总结<br />
切片是 go 语言中重要的数据结果,其和其他语言不同的是，其维护了底层的内存，以及长度和容量<br />
切片与数组的赋值拷贝有明显区别,切片在赋值拷贝与下标截断时引用了相同的底层数据<br />
如果要完全复制切片,使用copy函数。其逻辑是新建一个新的内存,并拷贝过去。在极端情况需要考虑其对性能的影响<br />
切片字面量的初始化，数组存储于静态区。 切片make的初始化方式时,如果 make 初始化了一个大于 64KB 的切片，这个空间会逃逸到堆中,在运行时调用makeslice创建。小于 64KB 的切片在栈中初始化<br />
Go 中切片 append 当容量超过了现有容量,需要进行扩容,其策略是：<br />
首先判断，如果新申请容量（cap）大于 2 倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）<br />
否则判断，如果旧切片的长度小于 1024，则最终容量 (newcap) 就是旧容量 (old.cap) 的两倍，即（newcap=doublecap）<br />
否则判断，如果旧切片长度大于等于 1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的 1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量 (cap)，即（newcap &gt;= cap）<br />
如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）<br />
Go 中切片 append 后返回的切片地址并不一定是原来的、也不一定是新的内存地址,因此必须小心其可能遇到的陷阱。一般会使用a = append(a,T)的方式保证安全。<br />
前文<br />
golang 快速入门 [1]-go 语言导论<br />
golang 快速入门 [2.1]-go 语言开发环境配置-windows<br />
golang 快速入门 [2.2]-go 语言开发环境配置-macOS<br />
golang 快速入门 [2.3]-go 语言开发环境配置-linux<br />
golang 快速入门 [3]-go 语言 helloworld<br />
golang 快速入门 [4]-go 语言如何编译为机器码<br />
golang 快速入门 [5.1]-go 语言是如何运行的-链接器<br />
golang 快速入门 [5.2]-go 语言是如何运行的-内存概述<br />
golang 快速入门 [5.3]-go 语言是如何运行的-内存分配<br />
golang 快速入门 [6.1]-集成开发环境-goland 详解<br />
golang 快速入门 [6.2]-集成开发环境-emacs 详解<br />
golang 快速入门 [7.1]-项目与依赖管理-gopath<br />
golang 快速入门 [7.2]-北冥神功—go module 绝技<br />
golang 快速入门 [8.1]-变量类型、声明赋值、作用域声明周期与变量内存分配<br />
golang 快速入门 [8.2]-自动类型推断的秘密<br />
golang 快速入门 [8.3]-深入理解浮点数<br />
golang 快速入门 [8.4]-常量与隐式类型转换<br />
golang 快速入门 [9.1]-深入字符串的存储、编译与运行<br />
golang 快速入门 [9.2]-深入数组用法、陷阱与编译时</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>