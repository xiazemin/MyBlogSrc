<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">Slice 实现原理分析</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-04-07T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 7, 2020</time></p>
					</div>
					 <p>众所周知，在golang中，slice（切片）是我们最常使用到的一种数据结构，是一种可变长度的数组，本篇文章我们主要结合源码来介绍一下slice的底层实现，以及在使用slice时的一些注意事项。<br />
Slice结构体<br />
首先我们来看一段代码：<br />
package<br />
 main<br />
import (<br />
“fmt”<br />
  “unsafe”<br />
)<br />
func main() {<br />
var a int<br />
  var b int8<br />
  var c int16<br />
  var d int32<br />
  var e int64<br />
  slice := make([]int, 0)<br />
  slice = append(slice, 1)<br />
  fmt.Printf(“int:%d\nint8:%d\nint16:%d\nint32:%d\nint64:%d\n”, unsafe.Sizeof(a), unsafe.Sizeof(b), unsafe.Sizeof(c), unsafe.Sizeof(d), unsafe.Sizeof(e))<br />
  fmt.Printf(“slice:%d”, unsafe.Sizeof(slice))<br />
}<br />
该程序输出golang中常用数据类型占多少byte，输出结果是：</p><br />
<br />
<p>int:8<br />
int8:1<br />
int16:2<br />
int32:4<br />
int64:8<br />
slice:24<br />
我们可以看到slice占24byte，为什么会占24byte，这就跟slice底层定义的结构有关，我们在golang的runtime/slice.go中可以找到slice的结构定义，如下：<br />
type slice struct {<br />
array<br />
 unsafe.Pointer<br />
//指向底层数组的指针<br />
  len int//切片的长度<br />
  cap int//切片的容量<br />
}<br />
我们可以看到slice中定义了三个变量，一个是指向底层数字的指针array，另外两个是切片的长度len和切片的容量cap。<br />
slice初始化<br />
简单了解了slice的底层结构后，我们来看下slice的初始化，在golang中slice有多重初始化方式，在这里我们就不一一介绍了，我们主要关注slice在底层是如何初始化的，首先我们来看一段代码：<br />
package main<br />
import “fmt”<br />
func main() {<br />
  slice := make([]int, 0)<br />
  slice = append(slice, 1)<br />
  fmt.Println(slice, len(slice), cap(slice))<br />
}<br />
<!-- more --><br />
很简单的一段代码，make一个slice，往slice中append一个一个1，打印slice内容，长度和容量，接下来我们利用gotool提供的工具将以上代码反汇编：<br />
go tool compile -S slice.go<br />
得到汇编代码如下（截取部分）：<br />
0x0000 00000 (slice.go<br />
:<br />
8<br />
)  TEXT<br /><br />
“”<br />
.main(SB), ABIInternal, $<br />
152<br />
-0<br />
  0x0000 00000 (slice.go:8)  MOVQ  (TLS), CX<br />
  0x0009 00009 (slice.go:8)  LEAQ  -24(SP), AX<br />
  0x000e 00014 (slice.go:8)  CMPQ  AX, 16(CX)<br />
  0x0012 00018 (slice.go:8)  JLS  375<br />
  0x0018 00024 (slice.go:8)  SUBQ  $152, SP<br />
  0x001f 00031 (slice.go:8)  MOVQ  BP, 144(SP)<br />
  0x0027 00039 (slice.go:8)  LEAQ  144(SP), BP<br />
  0x002f 00047 (slice.go:8)  FUNCDATA  $0, gclocals- f14a5bc6d08bc46424827f54d2e3f8ed(SB)//编译器产生，用于保存一些垃圾收集相关的信息<br />
  0x002f 00047 (slice.go:8)  FUNCDATA  $1, gclocals- 3e7bd269c75edba02eda3b9069a96409(SB)<br />
  0x002f 00047 (slice.go:8)  FUNCDATA  $2, gclocals- f6aec3988379d2bd21c69c093370a150(SB)<br />
  0x002f 00047 (slice.go:8)  FUNCDATA  $3, ““.main.stkobj(SB)<br />
  0x002f 00047 (slice.go:9)  PCDATA  $0, $1<br />
  0x002f 00047 (slice.go:9)  PCDATA  $1, $0<br />
  0x002f 00047 (slice.go:9)  LEAQ  type.int(SB), AX<br />
  0x0036 00054 (slice.go:9)  PCDATA  $0, $0<br />
  0x0036 00054 (slice.go:9)  MOVQ  AX, (SP)<br />
  0x003a 00058 (slice.go:9)  XORPS  X0, X0<br />
  0x003d 00061 (slice.go:9)  MOVUPS  X0, 8(SP)<br />
  0x0042 00066 (slice.go:9)  CALL  runtime.makeslice(SB)//初始化slice<br />
  0x0047 00071 (slice.go:9)  PCDATA  $0, $1<br />
  0x0047 00071 (slice.go:9)  MOVQ  24(SP), AX<br />
  0x004c 00076 (slice.go:10)  PCDATA  $0, $2<br />
  0x004c 00076 (slice.go:10)  LEAQ  type.int(SB), CX<br />
  0x0053 00083 (slice.go:10)  PCDATA  $0, $1<br />
  0x0053 00083 (slice.go:10)  MOVQ  CX, (SP)<br />
  0x0057 00087 (slice.go:10)  PCDATA  $0, $0<br />
  0x0057 00087 (slice.go:10)  MOVQ  AX, 8(SP)<br />
  0x005c 00092 (slice.go:10)  XORPS  X0, X0<br />
  0x005f 00095 (slice.go:10)  MOVUPS  X0, 16(SP)<br />
  0x0064 00100 (slice.go:10)  MOVQ  $1, 32(SP)<br />
  0x006d 00109 (slice.go:10)  CALL  runtime.growslice(SB)//append操作<br />
  0x0072 00114 (slice.go:10)  PCDATA  $0, $1<br />
  0x0072 00114 (slice.go:10)  MOVQ  40(SP), AX<br />
  0x0077 00119 (slice.go:10)  MOVQ  48(SP), CX<br />
  0x007c 00124 (slice.go:10)  MOVQ  56(SP), DX<br />
  0x0081 00129 (slice.go:10)  MOVQ  DX, ““.slice.cap+72(SP)<br />
  0x0086 00134 (slice.go:10)  MOVQ  $1, (AX)<br />
  0x008d 00141 (slice.go:11)  PCDATA  $0, $0<br />
  0x008d 00141 (slice.go:11)  MOVQ  AX, (SP)<br />
  0x0091 00145 (slice.go:10)  LEAQ  1(CX), AX<br />
  0x0095 00149 (slice.go:10)  MOVQ  AX, ““.slice.len+64(SP)<br />
  0x009a 00154 (slice.go:11)  MOVQ  AX, 8(SP)<br />
  0x009f 00159 (slice.go:11)  MOVQ  DX, 16(SP)<br />
  0x00a4 00164 (slice.go:11)  CALL  runtime.convTslice(SB)//类型转换<br />
  0x00a9 00169 (slice.go:11)  PCDATA  $0, $1<br />
  0x00a9 00169 (slice.go:11)  MOVQ  24(SP), AX<br />
  0x00ae 00174 (slice.go:11)  PCDATA  $0, $0<br />
  0x00ae 00174 (slice.go:11)  PCDATA  $1, $1<br />
  0x00ae 00174 (slice.go:11)  MOVQ  AX, “”..autotmp_33+88(SP)<br />
  0x00b3 00179 (slice.go:11)  MOVQ  ““.slice.len+64(SP), CX<br />
  0x00b8 00184 (slice.go:11)  MOVQ  CX, (SP)<br />
  0x00bc 00188 (slice.go:11)  CALL  runtime.convT64(SB)<br />
  0x00c1 00193 (slice.go:11)  PCDATA  $0, $1<br />
  0x00c1 00193 (slice.go:11)  MOVQ  8(SP), AX<br />
  0x00c6 00198 (slice.go:11)  PCDATA  $0, $0<br />
  0x00c6 00198 (slice.go:11)  PCDATA  $1, $2<br />
  0x00c6 00198 (slice.go:11)  MOVQ  AX, “”..autotmp_34+80(SP)<br />
  0x00cb 00203 (slice.go:11)  MOVQ  ““.slice.cap+72(SP), CX<br />
  0x00d0 00208 (slice.go:11)  MOVQ  CX, (SP)<br />
  0x00d4 00212 (slice.go:11)  CALL  runtime.convT64(SB)<br />
  0x00d9 00217 (slice.go:11)  PCDATA  $0, $1<br />
  0x00d9 00217 (slice.go:11)  MOVQ  8(SP), AX<br />
  0x00de 00222 (slice.go:11)  PCDATA  $1, $3<br />
  0x00de 00222 (slice.go:11)  XORPS  X0, X0<br />
大家可能看到这里有点蒙，这是在干啥，其实我们只需要关注一些关键的信息就好了，主要是这几行：<br />
0x0042 00066 (slice.go<br />
:<br />
9<br />
)<br /><br />
CALL<br />
  runtime.makeslice(SB)<br />
//初始化slice<br />
0x006d 00109 (slice.go:10)  CALL  runtime.growslice(SB)//append操作<br />
0x00a4 00164 (slice.go:11)  CALL  runtime.convTslice(SB)//类型转换<br />
0x00bc 00188 (slice.go:11)  CALL  runtime.convT64(SB)<br />
0x00d4 00212 (slice.go:11)  CALL  runtime.convT64(SB)<br />
我们能观察出，底层是调用runtime中的makeslice方法来创建slice的，我们来看一下makeslice函数到底做了什么。<br />
func makeslice<br />
(et *_type, len, cap int) unsafe<br />
.<br />
Pointer {<br />
  mem, overflow := math.MulUintptr(et.size, <br />
uintptr<br />
(<br />
cap<br />
))<br />
  if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap {<br />
// NOTE: Produce a ‘len out of range’ error instead of a<br />
// ‘cap out of range’ error when someone does make([]T, bignumber).<br />
    // ‘cap out of range’ is true too, but since the cap is only being<br />
    // supplied implicitly, saying len is clearer.<br />
    // See golang.org/issue/4085.<br />
    mem, overflow := math.MulUintptr(et.size, uintptr(len))<br />
    if overflow || mem &gt; maxAlloc || len &lt; 0 {<br />
      panicmakeslicelen()<br />
    }<br />
    panicmakeslicecap()<br />
  }</p><br />
<br />
<p>// Allocate an object of size bytes.<br />
  // Small objects are allocated from the per-P cache’s free lists.<br />
  // Large objects (&gt; 32 kB) are allocated straight from the heap.<br />
  return mallocgc(mem, et, true)<br />
}<br />
func panicmakeslicelen() {<br />
panic<br />
(errorString(<br />
“makeslice: len out of range”<br />
))<br />
}<br />
func panicmakeslicecap() {<br />
  panic(errorString(“makeslice: cap out of range”))<br />
}<br />
MulUintptr函数源码：<br />
package<br />
math<br />
import “runtime/internal/sys”<br />
const MaxUintptr = ^uintptr(0)<br />
// MulUintptr returns a * b and whether the multiplication overflowed.<br />
// On supported platforms this is an intrinsic lowered by the compiler.<br />
func MulUintptr(a, b uintptr) (uintptr, bool) {<br />
if a|b &lt; 1<br />
«(<br />
4<br />
<em>sys.PtrSize) || a == <br />
0 {//a|b &lt; 1«(4</em>8)<br />
    return a * b, false<br />
  }<br />
  overflow := b &gt; MaxUintptr/a<br />
  return a * b, overflow<br />
}<br />
简单来说，makeslice函数的工作主要就是计算slice所需内存大小，然后调用mallocgc进行内存的分配。计算slice所需内存又是通过MulUintptr来实现的，MulUintptr的源码我们也已经贴出，主要就是用切片中元素大小和切片的容量相乘计算出所需占用的内存空间，如果内存溢出，或者计算出的内存大小大于最大可分配内存，MulUintptr的overflow会返回true，makeslice就会报错。另外如果传入长度小于0或者长度小于容量，makeslice也会报错。<br />
append操作<br />
首先我们来看一段程序：<br />
package main</p><br />
<br />
<p>import (<br />
“<br />
fmt<br />
“<br />
   “unsafe”<br />
)</p><br />
<br />
<p>func main() {<br />
   slice := make([]int, 0, 10)<br />
   slice = append(slice, 1)<br />
   fmt.Println(unsafe.Pointer(&amp;slice[0]), len(slice), cap(slice))<br />
   slice = append(slice, 2)<br />
   fmt.Println(unsafe.Pointer(&amp;slice[0]), len(slice), cap(slice))<br />
}<br />
我们直接给出结果：</p><br />
<br />
<p>0xc00009e000 1 10<br />
0xc00009e000 2 10<br />
我们可以看到，当slice容量足够时，我们往slice中append一个2，slice底层数组指向的内存地址没有发生改变；再看一段程序：<br />
func main() {<br />
   slice := make([]int, 0)<br />
   slice = append(slice, 1)<br />
   fmt.Printf(“%p %d %d\n”, unsafe.Pointer(&amp;slice[0]), len(slice), cap(slice))<br />
   slice = append(slice, 2)<br />
   fmt.Printf(“%p %d %d\n”, unsafe.Pointer(&amp;slice[0]), len(slice), cap(slice))<br />
}<br />
输出结果是：</p><br />
<br />
<p>0xc00009a008 1 1<br />
0xc00009a030 2 2<br />
我们可以看到当往slice中append一个1后，slice底层数组的指针指向地址0xc00009a008，长度为1，容量为1。这时再往slice中append一个2，那么slice的容量不够了，此时底层数组会发生copy，会重新分配一块新的内存地址，容量也变成了2，所以我们会看到底层数组的指针指向地址发生了改变。根据之前汇编的结果我们知晓了，append操作其实是调用了runtime/slice.go中的growslice函数，我们来看下源码：<br />
func growslice<br />
(et <em>_type, old slice, cap int) slice {<br />
  …<br />
  …<br />
  if cap &lt; old.cap {<br />
panic<br />
(errorString(<br />
“growslice: cap out of range”<br />
))<br />
  }<br />
  if et.size == 0 {<br />
// append should not create a slice with nil pointer but non-zero len.<br />
    // We assume that append doesn’t need to preserve old.array in this case.<br />
    return slice{unsafe.Pointer(&amp;zerobase), old.len, cap}<br />
  }<br />
  newcap := old.cap//1280<br />
  doublecap := newcap + newcap//1280+1280=2560<br />
  if cap &gt; doublecap {<br />
newcap<br />
 = <br />
cap<br />
  } else {<br />
if old.len &lt; 1024 {<br />
newcap<br />
 = doublecap<br />
    } else {<br />
// Check 0 &lt; newcap to detect overflow<br />
      // and prevent an infinite loop.<br />
      for 0 &lt; newcap &amp;&amp; newcap &lt; cap {<br />
newcap<br />
 += newcap / <br />
4<br />
//1280</em>1.25=1600<br />
      }<br />
      // Set newcap to the requested cap when<br />
      // the newcap calculation overflowed.<br />
      if newcap &lt;= 0 {<br />
        newcap = cap<br />
      }<br />
    }<br />
  }<br />
  …<br />
}<br />
我们主要关注下cap的扩容规则，从源码中我们可以简单的总结出slice容量的扩容规则：当原slice的cap小于1024时，新slice的cap变为原来的2倍；原slice的cap大于1024时，新slice变为原来的1.25倍，我们写个程序来验证下：<br />
package<br />
 main<br />
import “fmt”<br />
func main() {<br />
  slice := <br />
make<br />
([]<br />
int<br />
, <br />
0<br />
)<br />
  oldCap := cap(slice)<br />
  for i := 0; i &lt; 4096; i++ {<br />
    slice = append(slice, i)<br />
    newCap := cap(slice)<br />
    if newCap != oldCap {<br />
      fmt.Printf(“oldCap = %-4d  after append %-4d  newCap = %-4d\n”, oldCap, i, newCap)<br />
      oldCap = newCap<br />
    }<br />
  }<br />
}<br />
这段程序实现的功能是：当cap发生改变时，打印出cap改变前后的值。我们来看程序的输出结果：</p><br />
<br />
<p>oldCap = 0 after append 0 newCap = 1 <br />
oldCap = 1 after append 1 newCap = 2 <br />
oldCap = 2 after append 2 newCap = 4 <br />
oldCap = 4 after append 4 newCap = 8 <br />
oldCap = 8 after append 8 newCap = 16 <br />
oldCap = 16 after append 16 newCap = 32 <br />
oldCap = 32 after append 32 newCap = 64 <br />
oldCap = 64 after append 64 newCap = 128 <br />
oldCap = 128 after append 128 newCap = 256 <br />
oldCap = 256 after append 256 newCap = 512 <br />
oldCap = 512 after append 512 newCap = 1024<br />
oldCap = 1024 after append 1024 newCap = 1280<br />
oldCap = 1280 after append 1280 newCap = 1696<br />
oldCap = 1696 after append 1696 newCap = 2304<br />
oldCap = 2304 after append 2304 newCap = 3072<br />
oldCap = 3072 after append 3072 newCap = 4096<br />
一开始的时候看起来跟我说的扩容规则是一样的，从1-&gt;2-&gt;4-&gt;8-&gt;16…-&gt;1024，都是成倍增长，当cap大于1024后，再append元素，cap变为1280，变成了1024的1.25倍，也符合我们的规则；但是继续append，1280-&gt;1696，似乎不是1.25倍，而是1.325倍，可见扩容规则并不是我们以上所说的那么简单，我们再继续往下看源码：</p><br />
<br />
<p>var overflow bool<br />
  var lenmem, newlenmem, capmem uintptr<br />
  // Specialize for common values of et.size.<br />
  // For 1 we don’t need any division/multiplication.<br />
  // For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.<br />
  // For powers of 2, use a variable shift.<br />
  switch {<br />
case et.size == 1<br />
:<br />
    lenmem = uintptr(old.len)<br />
    newlenmem = uintptr(cap)<br />
    capmem = roundupsize(uintptr(newcap))<br />
    overflow = uintptr(newcap) &gt; maxAlloc<br />
    newcap = int(capmem)<br />
  case et.size == sys.PtrSize:<br />
    lenmem = <br />
uintptr<br />
(old.<br />
len<br />
) * sys.PtrSize<br />
    newlenmem = uintptr(cap) * sys.PtrSize<br />
    capmem = roundupsize(uintptr(newcap) * sys.PtrSize)//13568<br />
    overflow = uintptr(newcap) &gt; maxAlloc/sys.PtrSize<br />
    newcap = int(capmem / sys.PtrSize)//13568/8=1696<br />
  case isPowerOfTwo(et.size):<br />
var shift uintptr<br />
    if sys.PtrSize == 8 {<br />
// Mask shift for better code generation.<br />
      shift = uintptr(sys.Ctz64(uint64(et.size))) &amp; 63<br />
    } else {<br />
      shift = uintptr(sys.Ctz32(uint32(et.size))) &amp; 31<br />
    }<br />
    lenmem = uintptr(old.len) « shift<br />
    newlenmem = uintptr(cap) « shift<br />
    capmem = roundupsize(uintptr(newcap) « shift)<br />
    overflow = uintptr(newcap) &gt; (maxAlloc » shift)<br />
    newcap = int(capmem » shift)<br />
  default:<br />
    lenmem = uintptr(old.len) * et.size<br />
    newlenmem = uintptr(cap) * et.size<br />
    capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))<br />
    capmem = roundupsize(capmem)<br />
    newcap = int(capmem / et.size)<br />
  }<br />
我们看到每个case中都执行了roundupsize，我们再看下roundupsize的源码，如下：</p><br />
<br />
<p>package<br />
 runtime<br />
// Returns size of the memory block that mallocgc will allocate if you ask for the size.<br />
func roundupsize(size uintptr) uintptr {<br />
if size &lt; _MaxSmallSize {//size=1600*8=12800&lt;32768<br />
    if size &lt;= smallSizeMax-8 {//12800&lt;=0<br />
      return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])<br />
    } else {<br />
return uintptr<br />
(class_to_size[size_to_class128[(size-smallSizeMax+largeSizeDiv<br />
-1<br />
)/largeSizeDiv]])<br />
//size_to_class128[92]= 56<br />
      //class_to_size[56]=13568<br />
      //13568/8=1696<br />
    }<br />
  }<br />
  if size+_PageSize &lt; size {<br />
return size<br />
  }<br />
  return round(size, _PageSize)<br />
}<br />
const _MaxSmallSize   = 32768<br />
const smallSizeDiv    = 8<br />
const smallSizeMax    = 1024<br />
const largeSizeDiv    = 128<br />
其实roundupsize是内存对齐的过程，我们知道golang中内存分配是根据对象大小来配不同的mspan，为了避免造成过多的内存碎片，slice在扩容中需要对扩容后的cap容量进行内存对齐的操作，接下来我们对照源码来实际计算下cap容量是否由1280变成了1696。<br />
从以上流程图可以看出，cap在变成1600后又进入了内存对齐的过程，最终cap变为了1696。<br />
slice截取<br />
go中的slice是支持截取操作的，虽然使用起来非常的方便，但是有很多坑，稍有不慎就会出现bug且不易排查。<br />
让我们来看一段程序：<br />
package<br />
 main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br />
  slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}<br />
  s1 := slice[2:5]<br />
  s2 := s1[2:7]<br />
  fmt.Printf(“len=%-4d cap=%-4d slice=%-1v \n”, len(slice), cap(slice), slice)<br />
  fmt.Printf(“len=%-4d cap=%-4d s1=%-1v \n”, len(s1), cap(s1), s1)<br />
  fmt.Printf(“len=%-4d cap=%-4d s2=%-1v \n”, len(s2), cap(s2), s2)<br />
}<br />
程序输出：</p><br />
<br />
<h1 id="len">len</h1><br />
<p>10 cap=10 slice=[0 1 2 3 4 5 6 7 8 9<br />
] <br />
len=3 cap=8 s1=[2 3 4] <br />
len=5 cap=6 s2=[4 5 6 7 8]<br />
s1的长度变成3，cap变为8（默认截取到最大容量）， 但是s2截取s1的第2到第7个元素，左闭右开，很多人想问，s1根本没有那么元素啊，但是实际情况是s2截取到了，并且没有发生数组越界，原因就是s2实际截取的是底层数组，目前slice、s1、s2都是共用的同一个底层数组。</p><br />
<br />
<p>我们继续操作：</p><br />
<br />
<p>fmt.Println(“——–append 100—————-“)<br />
s2 = append(s2, 100)<br />
输出结果是：</p><br />
<br />
<hr /><br />
<p>append 100<br />
—————-<br />
len=10 cap=10 slice=[0 1 2 3 4 5 6 7 8 100] <br />
len=3 cap=8 s1=[2 3 4] <br />
len=6 cap=6 s2=[4 5 6 7 8 100]<br />
我们看到往s2里append数据影响到了slice，正是因为两者底层数组是一样的；但是既然都是共用的同一底层数组，s1为什么没有100，这个问题再下一节会讲到，大家稍安勿躁。我们继续进行操作：</p><br />
<br />
<p>fmt.Println(“——–append 200—————-“)<br />
s2 = append(s2, 200)<br />
输出结果是：</p><br />
<br />
<hr /><br />
<p>append 200<br />
—————-<br />
len=10 cap=10 slice=[0 1 2 3 4 5 6 7 8 100] <br />
len=3 cap=8 s1=[2 3 4] <br />
len=7 cap=12 s2=[4 5 6 7 8 100 200]<br />
我们看到继续往s2中append一个200，但是只有s2发生了变化，slice并未改变，为什么呢？对，是因为在append完100后，s2的容量已满，再往s2中append，底层数组发生复制，系统分配了一块新的内存地址给s2，s2的容量也翻倍了。</p><br />
<br />
<p>我们继续操作：</p><br />
<br />
<p>fmt.Println(“——–modify s1—————-“)<br />
s1[2] = 20<br />
输出会是什么样呢？</p><br />
<br />
<p>——–modify s1—————-<br />
len=10   cap=10   slice=[0 1 2 3 20 5 6 7 8 100] <br />
len=3    cap=8    s1=[2 3 20] <br />
len=7    cap=12   s2=[4 5 6 7 8 100 200]<br />
这就很容易理解了，我们对s1进行更新，影响了slice，因为两者共用的还是同一底层数组，s2未发生改变是因为在上一步时底层数组已经发生了变化；</p><br />
<br />
<p>以此来看，slice截取的坑确实很多，极容易出现bug，并且难以排查，大家在使用的时候一定注意。</p><br />
<br />
<p>slice深拷贝<br />
上一节中对slice进行的截取，新的slice和原始slice共用同一个底层数组，因此可以看做是对slice的浅拷贝，那么在go中如何实现对slice的深拷贝呢？那么就要依赖golang提供的copy函数了，我们用一段程序来简单看下如何实现深拷贝：<br />
func main<br />
() {</p><br />
<br />
<p>// Creating slices<br />
  slice1 := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}<br />
  var slice2 []int<br />
  slice3 := make([]int, 5)</p><br />
<br />
<p>// Before copying<br />
  fmt.Println(“————before copy————-“)<br />
  fmt.Printf(“len=%-4d cap=%-4d slice1=%v\n”, len(slice1), cap(slice1), slice1)<br />
  fmt.Printf(“len=%-4d cap=%-4d slice2=%v\n”, len(slice2), cap(slice2), slice2)<br />
  fmt.Printf(“len=%-4d cap=%-4d slice3=%v\n”, len(slice3), cap(slice3), slice3)</p><br />
<br />
<p>// Copying the slices<br />
  copy_1 := copy(slice2, slice1)<br />
  fmt.Println()<br />
  fmt.Printf(“len=%-4d cap=%-4d slice1=%v\n”, len(slice1), cap(slice1), slice1)<br />
  fmt.Printf(“len=%-4d cap=%-4d slice2=%v\n”, len(slice2), cap(slice2), slice2)<br />
  fmt.Println(“Total number of elements copied:”, copy_1)<br />
}<br />
首先定义了三个slice，然后将slice1 copy到slice2，我们来看下输出结果：</p><br />
<br />
<p>————before <br />
copy<br />
————-<br />
len=10 cap=10 slice1=[0 1 2 3 4 5 6 7 8 9]<br />
len=0 cap=0 slice2=[]<br />
len<br />
=<br />
5 cap<br />
=<br />
5 slice3=[0 0 0 0 0<br />
]</p><br />
<br />
<p>len=10 cap=10 slice1=[0 1 2 3 4 5 6 7 8 9]<br />
len=0 cap=0 slice2=[]<br />
Total number of elements copied: 0<br />
我们发现slice1的内容并未copy到slice2，为什么呢？我们再试下将slice1 copy到slice3，如下：</p><br />
<br />
<p>copy_2 := copy(slice3, slice1)<br />
输出结果：<br />
len=10   cap=10   slice1=[0 1 2 3 4 5 6 7 8 9]<br />
len=5    cap=5    slice3=[0 1 2 3 4]<br />
Total number of elements copied: 5<br />
我们看到copy成功，slice3和slice2唯一的区别就是slice3的容量为5，而slice2容量为0，那么是否是深拷贝呢，我们修改slice3的内容看下：<br />
slice3[0] = 100<br />
我们再看下输出结果：<br />
len<br />
=<br />
10 cap=10 slice1=[0 1 2 3 4 5 6 7 8 9<br />
]<br />
len=5 cap=5 slice3=[100 1 2 3 4]<br />
我们可以看到修改slice3后，slice1的值并未改变，可见copy实现的是深拷贝。由此可见，copy函数为slice提供了深拷贝能力，但是需要在拷贝前申请内存空间。参照makeslice和growslice我们对本节一开始的程序进行反汇编，得到汇编代码（部分）如下：<br />
0x0080 00128 (slice.go<br />
:<br />
10<br />
)<br />
CALL<br />
runtime<br />
.makeslice<br />
(<br />
SB<br />
)<br />
  0x0085 00133 (slice.go:10)  PCDATA  $0, $1<br />
  0x0085 00133 (slice.go:10)  MOVQ  24(SP), AX<br />
  0x008a 00138 (slice.go:10)  PCDATA  $1, $2<br />
  0x008a 00138 (slice.go:10)  MOVQ  AX, “”..autotmp_75+96(SP)<br />
  0x008f 00143 (slice.go:11)  PCDATA  $0, $4<br />
  0x008f 00143 (slice.go:11)  MOVQ  “”..autotmp_74+104(SP), CX<br />
  0x0094 00148 (slice.go:11)  CMPQ  AX, CX<br />
  0x0097 00151 (slice.go:11)  JEQ  176<br />
  0x0099 00153 (slice.go:11)  PCDATA  $0, $5<br />
  0x0099 00153 (slice.go:11)  MOVQ  AX, (SP)<br />
  0x009d 00157 (slice.go:11)  PCDATA  $0, $0<br />
  0x009d 00157 (slice.go:11)  MOVQ  CX, 8(SP)<br />
  0x00a2 00162 (slice.go:11)  MOVQ  $40, 16(SP)<br />
  0x00ab 00171 (slice.go:11)  CALL  runtime.memmove(SB)<br />
  0x00b0 00176 (slice.go:12)  MOVQ  $10, (SP)<br />
  0x00b8 00184 (slice.go:12)  CALL  runtime.convT64(SB)<br />
我们发现copy函数其实是调用runtime.memmove，其实我们在研究runtime/slice.go文件中的源码的时候，会发现有一个slicecopy函数，这个函数最终就是调用runtime.memmove来实现slice的copy的，我们看下源码：<br />
func slicecopy<br />
(to, fm slice, width uintptr) int {<br />
// 如果源切片或者目标切片有一个长度为0，那么就不需要拷贝，直接 return <br />
  if fm.len == 0 || to.len == 0 {<br />
return 0<br />
  }</p><br />
<br />
<p>// n 记录下源切片或者目标切片较短的那一个的长度<br />
  n := fm.len<br />
  if to.len &lt; n {<br />
n<br />
 = to.<br />
len<br />
  }</p><br />
<br />
<p>// 如果入参 width = 0，也不需要拷贝了，返回较短的切片的长度<br />
  if width == 0 {<br />
return n<br />
  }</p><br />
<br />
<p>//如果开启竞争检测<br />
  if raceenabled {<br />
callerpc<br />
 := getcallerpc()<br />
    pc := funcPC(slicecopy)<br />
    racewriterangepc(to.array, uintptr(n<em>int(width)), callerpc, pc)<br />
    racereadrangepc(fm.array, uintptr(n</em>int(width)), callerpc, pc)<br />
  }<br />
  if msanenabled {<br />
    msanwrite(to.<br />
array<br />
, <br />
uintptr<br />
(n*<br />
int<br />
(width)))<br />
    msanread(fm.array, uintptr(n*int(width)))<br />
  }</p><br />
<br />
<p>size := uintptr(n) * width<br />
  if size == 1 { // common case worth about 2x to do here<br />
    // TODO: is this still worth it with new memmove impl?<br />
//如果只有一个元素，那么直接进行地址转换<br />
    <em>(</em>byte)(to.array) = <em>(</em>byte)(fm.array) // known to be a byte pointer<br />
  } else {<br />
//如果不止一个元素，那么就从 fm.array 地址开始，拷贝到 to.array 地址之后，拷贝个数为size<br />
    memmove(to.array, fm.array, size)<br />
  }<br />
  return n<br />
}<br />
源码解读见中文注释。<br />
值传递还是引用传递<br />
slice在作为函数参数进行传递的时候，是值传递还是引用传递，我们来看一段程序：<br />
package<br />
 main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br />
  slice := <br />
make<br />
([]<br />
int<br />
, <br />
0<br />
, <br />
10<br />
)<br />
  slice = append(slice, 1)<br />
  fmt.Println(slice, len(slice), cap(slice))<br />
  fn(slice)<br />
  fmt.Println(slice, len(slice), cap(slice))<br />
}<br />
func fn(in []int) {<br />
  in = append(in, 5)<br />
}<br />
很简单的一段程序，我们直接来看输出结果：<br />
[<br />
1<br />
] <br />
1 10<br />
[1] 1 10<br />
可见fn内的append操作并未对slice产生影响，那我们再看一段代码：<br />
package<br />
 main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br />
  slice := <br />
make<br />
([]<br />
int<br />
, <br />
0<br />
, <br />
10<br />
)<br />
  slice = append(slice, 1)<br />
  fmt.Println(slice, len(slice), cap(slice))<br />
  fn(slice)<br />
  fmt.Println(slice, len(slice), cap(slice))<br />
}<br />
func fn(in []int) {<br />
  in[0] = 100<br />
}<br />
输出是什么？我们来看下：</p><br />
<br />
<p>[<br />
1<br />
] <br />
1 10<br />
[100] 1 10<br />
slice居然改变了，是不是有点混乱？前面我们说到slice底层其实是一个结构体，len、cap、array分别表示长度、容量、底层数组的地址，当slice作为函数的参数传递的时候，跟普通结构体的传递是没有区别的；如果直接传slice，实参slice是不会被函数中的操作改变的，但是如果传递的是slice的指针，是会改变原来的slice的；另外，无论是传递slice还是slice的指针，如果改变了slice的底层数组，那么都是会影响slice的，这种通过数组下标的方式更新slice数据，是会对底层数组进行改变的，所以就会影响slice。</p><br />
<br />
<p>那么，讲到这里，在第一段程序中在fn函数内append的5到哪里去了，不可能凭空消失啊，我们再来看一段程序：<br />
package<br />
 main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br />
  slice := <br />
make<br />
([]<br />
int<br />
, <br />
0<br />
, <br />
10<br />
)<br />
  slice = append(slice, 1)<br />
  fmt.Println(slice, len(slice), cap(slice))<br />
  fn(slice)<br />
  fmt.Println(slice, len(slice), cap(slice))<br />
  s1 := slice[0:9]//数组截取<br />
  fmt.Println(s1, len(s1), cap(s1))<br />
}<br />
func fn(in []int) {<br />
  in = append(in, 5)<br />
}<br />
我们来看输出结果：<br />
[<br />
1<br />
] <br />
1 10<br />
[1] 1 10<br />
[1 5 0 0 0 0 0 0 0] 9 10<br />
显然，虽然在append后，slice中并未展示出5，也无法通过slice[1]取到（会数组越界）,但是实际上底层数组已经有了5这个元素，但是由于slice的len未发生改变，所以我们在上层是无法获取到5这个元素的。那么，再问一个问题，我们是不是可以手动强制改变slice的len长度，让我们可以获取到5这个元素呢？是可以的，我们来看一段程序：<br />
package<br />
 main</p><br />
<br />
<p>import (<br />
“fmt”<br />
  “reflect”<br />
  “unsafe”<br />
)</p><br />
<br />
<p>func main() {<br />
  slice := <br />
make<br />
([]<br />
int<br />
, <br />
0<br />
, <br />
10<br />
)<br />
  slice = append(slice, 1)<br />
  fmt.Println(slice, len(slice), cap(slice))<br />
  fn(slice)<br />
  fmt.Println(slice, len(slice), cap(slice))<br />
  (*reflect.SliceHeader)(unsafe.Pointer(&amp;slice)).Len = 2 //强制修改slice长度<br />
  fmt.Println(slice, len(slice), cap(slice))<br />
}</p><br />
<br />
<p>func fn(in []int) {<br />
  in = append(in, 5)<br />
}<br />
我们来看输出结果：<br />
[<br />
1<br />
] <br />
1 10<br />
[1] 1 10<br />
[1 5] 2 10<br />
可以看出，通过强制修改slice的len，我们可以获取到了5这个元素。<br />
所以再次回答一开始我们提出的问题，slice是值传递还是引用传递？答案是值传递！<br />
以上，在使用golang中的slice的时候大家一定注意，否则稍有不慎就会出现bug。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>