<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">并发模型汇总</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-04-07T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 7, 2020</time></p>
					</div>
					 <p>https://gocn.vip/topics/10192<br />
 Server 的并发模型，这些模型与编程语言本身无关，有的编程语言可能在语法上直接透明了模型本质，所以开发者没必要一定要基于模型去编写，只是需要知道和了解并发模型的构成和特点即可。</p><br />
<br />
<p>那么在了解并发模型之前，我们需要两个必备的前置知识：</p><br />
<br />
<p>socket 网络编程<br />
多路 IO 复用机制<br />
多线程/多进程等并发编程理论<br />
<!-- more --><br />
模型一、单线程 Accept（无 IO 复用）<br />
(1) 模型结构图<br />
<img src="https://xiazemin.github.io/MyBlog/img/multiio.jpeg" /><br />
2) 模型分析<br />
① 主线程main thread执行阻塞 Accept，每次客户端 Connect 链接过来，main thread中 accept 响应并建立连接</p><br />
<br />
<p>② 创建链接成功，得到Connfd1套接字后, 依然在main thread串行处理套接字读写，并处理业务。</p><br />
<br />
<p>③ 在②处理业务中，如果有新客户端Connect过来，Server无响应，直到当前套接字全部业务处理完毕。</p><br />
<br />
<p>④ 当前客户端处理完后，完毕链接，处理下一个客户端请求。</p><br />
<br />
<p>(3) 优缺点<br />
优点：</p><br />
<br />
<p>socket 编程流程清晰且简单，适合学习使用，了解 socket 基本编程流程。<br />
缺点：</p><br />
<br />
<p>该模型并非并发模型，是串行的服务器，同一时刻，监听并响应最大的网络请求量为1。 即并发量为1。</p><br />
<br />
<p>仅适合学习基本 socket 编程，不适合任何服务器 Server 构建。</p><br />
<br />
<p>模型二、单线程 Accept+ 多线程读写业务（无 IO 复用）<br />
(1) 模型结构图<br />
	<img src="https://xiazemin.github.io/MyBlog/img/multiAccept.jpeg" /><br />
	(2) 模型分析<br />
① 主线程main thread执行阻塞 Accept，每次客户端 Connect 链接过来，main thread中 accept 响应并建立连接</p><br />
<br />
<p>② 创建链接成功，得到Connfd1套接字后，创建一个新线程thread1用来处理客户端的读写业务。main thead依然回到Accept阻塞等待新客户端。</p><br />
<br />
<p>③ thread1通过套接字Connfd1与客户端进行通信读写。</p><br />
<br />
<p>④ server 在②处理业务中，如果有新客户端Connect过来，main thread中Accept依然响应并建立连接，重复②过程。</p><br />
<br />
<p>(3) 优缺点<br />
优点：</p><br />
<br />
<p>基于模型一：单线程Accept（无IO复用） 支持了并发的特性。<br />
使用灵活，一个客户端对应一个线程单独处理，server处理业务内聚程度高，客户端无论如何写，服务端均会有一个线程做资源响应。<br />
缺点：</p><br />
<br />
<p>随着客户端的数量增多，需要开辟的线程也增加，客户端与 server 线程数量1:1正比关系，一次对于高并发场景，线程数量收到硬件上限瓶颈。<br />
对于长链接，客户端一旦无业务读写，只要不关闭，server 的对应线程依然需要保持连接 (心跳、健康监测等机制)，占用连接资源和线程开销资源浪费。<br />
仅适合客户端数量不大，并且数量可控的场景使用。<br />
仅适合学习基本 socket 编程，不适合任何服务器 Server 构建。</p><br />
<br />
<p>模型三、单线程多路 IO 复用<br />
(1) 模型结构图<br />
	<img src="https://xiazemin.github.io/MyBlog/img/selectiomulti.jpeg" /><br />
	(2) 模型分析<br />
① 主线程main thread创建listenFd之后，采用多路 I/O 复用机制 (如:select、epoll) 进行 IO 状态阻塞监控。有Client1客户端Connect请求，I/O 复用机制检测到ListenFd触发读事件，则进行Accept建立连接，并将新生成的connFd1加入到监听I/O集合中。</p><br />
<br />
<p>② Client1再次进行正常读写业务请求，main thread的多路I/O复用机制阻塞返回，会触该套接字的读/写事件等。</p><br />
<br />
<p>③ 对于Client1的读写业务，Server 依然在main thread执行流程提继续执行，此时如果有新的客户端Connect链接请求过来，Server 将没有即时响应。</p><br />
<br />
<p>④ 等到 Server 处理完一个连接的Read+Write操作，继续回到多路I/O复用机制阻塞，其他链接过来重复 ②、③流程。</p><br />
<br />
<p>(3) 优缺点<br />
优点：</p><br />
<br />
<p>单流程解决了可以同时监听多个客户端读写状态的模型，不需要1:1与客户端的线程数量关系。<br />
多路 I/O 复用阻塞，非忙询状态，不浪费 CPU 资源， CPU 利用率较高。<br />
缺点：</p><br />
<br />
<p>虽然可以监听多个客户端的读写状态，但是同一时间内，只能处理一个客户端的读写操作，实际上读写的业务并发为 1。<br />
多客户端访问 Server，业务为串行执行，大量请求会有排队延迟现象，如图中⑤所示，当Client3占据main thread流程时，Client1,Client2流程卡在IO复用等待下次监听触发事件。<br />
模型四、单线程多路 IO 复用 + 多线程读写业务 (业务工作池)<br />
(1) 模型结构图<br />
	<img src="https://xiazemin.github.io/MyBlog/img/multithreadpoll.jpeg" /><br />
	(2) 模型分析<br />
① 主线程main thread创建listenFd之后，采用多路 I/O 复用机制 (如:select、epoll) 进行 IO 状态阻塞监控。有Client1客户端Connect请求，I/O 复用机制检测到ListenFd触发读事件，则进行Accept建立连接，并将新生成的connFd1加入到监听I/O集合中。</p><br />
<br />
<p>② 当connFd1有可读消息，触发读事件，并且进行读写消息</p><br />
<br />
<p>③ main thread按照固定的协议读取消息，并且交给worker pool工作线程池， 工作线程池在 server 启动之前就已经开启固定数量的thread，里面的线程只处理消息业务，不进行套接字读写操作。</p><br />
<br />
<p>④ 工作池处理完业务，触发connFd1写事件，将回执客户端的消息通过main thead写给对方。</p><br />
<br />
<p>(3) 优缺点<br />
优点：</p><br />
<br />
<p>对于模型三, 将业务处理部分，通过工作池分离出来，减少多客户端访问 Server，业务为串行执行，大量请求会有排队延迟时间。<br />
实际上读写的业务并发为 1，但是业务流程并发为 worker pool 线程数量，加快了业务处理并行效率。<br />
缺点：</p><br />
<br />
<p>读写依然为main thread单独处理，最高读写并行通道依然为 1.<br />
虽然多个 worker 线程处理业务，但是最后返回给客户端，依旧需要排队，因为出口还是main thread的Read + Write<br />
模型五、单线程 IO 复用 + 多线程 IO 复用 (链接线程池)<br />
(1) 模型结构图<br />
	<img src="https://xiazemin.github.io/MyBlog/img/multiiopool.jpeg" /><br />
	(2) 模型分析<br />
① Server 在启动监听之前，开辟固定数量 (N) 的线程，用Thead Pool线程池管理</p><br />
<br />
<p>② 主线程main thread创建listenFd之后，采用多路 I/O 复用机制 (如:select、epoll) 进行 IO 状态阻塞监控。有Client1客户端Connect请求，I/O 复用机制检测到ListenFd触发读事件，则进行Accept建立连接，并将新生成的connFd1分发给Thread Pool中的某个线程进行监听。</p><br />
<br />
<p>③ Thread Pool中的每个thread都启动多路I/O复用机制(select、epoll),用来监听main thread建立成功并且分发下来的 socket 套接字。</p><br />
<br />
<p>④ 如图， thread监听ConnFd1、ConnFd2, thread2监听ConnFd3,thread3监听ConnFd4. 当对应的ConnFd有读写事件，对应的线程处理该套接字的读写及业务。</p><br />
<br />
<p>(3) 优缺点<br />
优点：</p><br />
<br />
<p>将main thread的单流程读写，分散到多线程完成，这样增加了同一时刻的读写并行通道，并行通道数量N， N为线程池Thread数量。<br />
server 同时监听的ConnFd套接字数量几乎成倍增大，之前的全部监控数量取决于main thread的多路I/O复用机制的最大限制(select 默认为 1024， epoll 默认与内存大小相关，约 3~6w 不等)，所以理论单点 Server 最高响应并发数量为N*(3~6W)(N为线程池Thread数量，建议与 CPU 核心成比例 1:1)。<br />
如果良好的线程池数量和 CPU 核心数适配，那么可以尝试 CPU 核心与 Thread 进行绑定，从而降低 CPU 的切换频率，提升每个Thread处理合理业务的效率，降低 CPU 切换成本开销。<br />
缺点：</p><br />
<br />
<p>虽然监听的并发数量提升，但是最高读写并行通道依然为N，而且多个身处同一个 Thread 的客户端，会出现读写延迟现象，实际上每个Thread的模型特征与模型三：单线程多路IO复用一致。<br />
模型五 (进程版)、单进程多路 I/O 复用 + 多进程多路 I/O 复用 (进程池)<br />
(1) 模型结构图<br />
	<img src="https://xiazemin.github.io/MyBlog/img/multiioepool.jpeg" /><br />
(2) 模型分析<br />
与五、单线程IO复用+多线程IO复用(链接线程池)无大差异。</p><br />
<br />
<p>不同处</p><br />
<br />
<p>进程和线程的内存布局不同导致，main process(主进程) 不再进行Accept操作，而是将Accept过程分散到各个子进程(process)中.<br />
进程的特性，资源独立，所以main process如果 Accept 成功的 fd，其他进程无法共享资源，所以需要各子进程自行 Accept 创建链接<br />
main process只是监听ListenFd状态，一旦触发读事件 (有新连接请求). 通过一些 IPC(进程间通信：如信号、共享内存、管道) 等, 让各自子进程Process竞争Accept完成链接建立，并各自监听。<br />
(3) 优缺点<br />
与五、单线程IO复用+多线程IO复用(链接线程池)无大差异。</p><br />
<br />
<p>不同处:</p><br />
<br />
<p>多进程内存资源空间占用稍微大一些</p><br />
<br />
<p>多进程模型安全稳定型较强，这也是因为各自进程互不干扰的特点导致。</p><br />
<br />
<p>模型六、单线程多路 I/O 复用 + 多线程多路 I/O 复用 + 多线程<br />
(1) 模型结构图<br />
	<img src="https://xiazemin.github.io/MyBlog/img/mioioreuse.jpeg" /><br />
	(2) 模型分析<br />
① Server 在启动监听之前，开辟固定数量 (N) 的线程，用Thead Pool线程池管理</p><br />
<br />
<p>② 主线程main thread创建listenFd之后，采用多路 I/O 复用机制 (如:select、epoll) 进行 IO 状态阻塞监控。有Client1客户端Connect请求，I/O 复用机制检测到ListenFd触发读事件，则进行Accept建立连接，并将新生成的connFd1分发给Thread Pool中的某个线程进行监听。</p><br />
<br />
<p>③ Thread Pool中的每个thread都启动多路I/O复用机制(select、epoll),用来监听main thread建立成功并且分发下来的 socket 套接字。一旦其中某个被监听的客户端套接字触发I/O读写事件,那么，会立刻开辟一个新线程来处理I/O读写业务。</p><br />
<br />
<p>④ 但某个读写线程完成当前读写业务，如果当前套接字没有被关闭，那么将当前客户端套接字如:ConnFd3重新加回线程池的监控线程中，同时自身线程自我销毁。</p><br />
<br />
<p>(3) 优缺点<br />
优点：</p><br />
<br />
<p>在模型五、单线程IO复用+多线程IO复用(链接线程池)基础上，除了能够保证同时响应的最高并发数，又能解决读写并行通道局限的问题。</p><br />
<br />
<p>同一时刻的读写并行通道，达到最大化极限，一个客户端可以对应一个单独执行流程处理读写业务，读写并行通道与客户端数量1:1关系。</p><br />
<br />
<p>缺点：</p><br />
<br />
<p>该模型过于理想化，因为要求 CPU 核心数量足够大。<br />
如果硬件 CPU 数量可数 (目前的硬件情况)，那么该模型将造成大量的 CPU 切换成本浪费。因为为了保证读写并行通道与客户端1:1的关系，那么 Server 需要开辟的Thread数量就与客户端一致，那么线程池中做多路I/O复用的监听线程池绑定 CPU 数量将变得毫无意义。<br />
如果每个临时的读写Thread都能够绑定一个单独的 CPU，那么此模型将是最优模型。但是目前 CPU 的数量无法与客户端的数量达到一个量级，目前甚至差的不是几个量级的事。<br />
总结<br />
综上，我们整理了 7 中 Server 的服务器处理结构模型，每个模型都有各自的特点和优势，那么对于多少应付高并发和高 CPU 利用率的模型，目前多数采用的是模型五 (或模型五进程版，如 Nginx 就是类似模型五进程版的改版)。</p><br />
<br />
<p>至于并发模型并非设计的约复杂越好，也不是线程开辟的越多越好，我们要考虑硬件的利用与和切换成本的开销。模型六设计就极为复杂，线程较多，但以当今的硬件能力无法支撑，反倒导致该模型性能极差。所以对于不同的业务场景也要选择适合的模型构建，并不是一定固定就要使用某个来应用。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>