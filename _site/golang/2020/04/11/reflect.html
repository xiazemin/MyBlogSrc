<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">reflect</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-04-11T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 11, 2020</time></p>
					</div>
					 <p>reflect 包实现具有两个基础 unsafe 操作内存对齐和 runtime 包的变量。</p><br />
<br />
<p>runtime 变量<br />
runtime 变量是 reflect 的实现基础，基于 unsafe 包操作 runtime 变量实现 reflect 功能。<br />
https://gocn.vip/topics/10233<br />
<!-- more --><br />
首先我们按照 go 的规则先简单的定义一个变量类型 Value，Value 有两个类型成员属性 typ 和 ptr，typ 是类型表示这个变量是什么对象，ptr 是一个地址指向这个变量的地址。</p><br />
<br />
<p>// 如果看reflect或runtime源码会发现两者相识，只不过被我删了不少属性。<br />
type Value struct {<br />
    typ Type<br />
    ptr uintptr<br />
}</p><br />
<br />
<p>type Type interface {<br />
    Name() string         // by all type<br />
    Index(int) Value      // by Slice Array<br />
    MapIndex(value) Value // by Map<br />
    Send(Value)           // By Chan<br />
}<br />
当我们去操作一个变量时就按照 Type 类型来操作，而操作对象的数据就在内存的 ptr 位置。</p><br />
<br />
<p>变量类型 Type 定义的是一个接口，因为不同类型有不同的操作方法，例如 Map 的获取/设置值，Slice 和 Array 的获取一个索引，Chan 具有发送和接实一个对象，Struct 可以获得一个结构体属性，属性具有 tag，这样不同的类型就具有不同独特的操作方法，如果 Map 类型调用 Index 方法无法实现就会 panic 了。</p><br />
<br />
<p>理解变量本质就是一个数据地址和一个类型数据组成，然后基于者两个变量来操作就是 reflect。</p><br />
<br />
<p>reflect example<br />
一个 reflect 简单的例子，reflect.TypeOf和reflect.ValueOf方法将一个 runtime 类型和变量转换成 reflect 类型和变量，依赖 unsafe 操作内存对齐来强制转换，reflect 类型和变量和 runtime 中一样的，就可以实现自由操作了。</p><br />
<br />
<p>最后reflect.Value调用Interface()方法将变量从 reflect 状态转换回来成 runtime 状态了。</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “reflect”<br />
)</p><br />
<br />
<p>type Student struct {<br />
    Name string<br />
    Age  int<br />
}</p><br />
<br />
<p>func main() {<br />
    s := new(Student)<br />
    fmt.Println(reflect.TypeOf(s))<br />
    fmt.Println(reflect.TypeOf(s).Elem())<br />
    fmt.Println(reflect.TypeOf(*s))</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v := reflect.ValueOf(s).Elem()<br />
v.Field(0).SetString("66")<br />
fmt.Printf("%#v\n", v.Interface()) } reflect Type 先从 reflect/type.go 简单的抄一点代码来。rtype 对象就是 Type 接口的简化实现，kind 就是这个类型的类型，然后其他组合类型 (Ptr、Slice、Map 等) 就额外添加了一些属性和方法。<br />
</code></pre></div></div><br />
<br />
<p>type rtype struct {<br />
    size    uintptr<br />
    ptrdata uintptr<br />
    kind    uint8<br />
    …<br />
}<br />
ptrType 是指针类型的定义，属性 rtype 就是指针的类型，elem 就是指针指向的类型，那么一个 Ptr Type 调用 Elem 获得指针的类型就返回了 elem 值。</p><br />
<br />
<p>// ptrType represents a pointer type.<br />
type ptrType struct {<br />
    rtype<br />
    elem *rtype // pointer element (pointed at) type<br />
}<br />
structType 是指针类型的定义，rtype 是结构体类型的基础信息，pkgPath 就是结构体的名称，当一个结构体调用 Name 方法时就返回了 pkgPath，如果是结构体指针调用 Name 方法就没有返回数据，因为没有 pkgPath 需要先 Elem 一次转换成结构体类型，而结构体类型的 Field、FieldByIndex、FieldByName、FieldByNameFunc 方法就对象结构体类型 fields 信息进行变量操作了。</p><br />
<br />
<p>而在结构体属性 structField 中，name、typ 分别记录这个属性的名称和类型，offsetEmbed 是属性偏移位置。</p><br />
<br />
<p>// structType represents a struct type.<br />
type structType struct {<br />
    rtype<br />
    pkgPath name<br />
    fields  []structField // sorted by offset<br />
}</p><br />
<br />
<p>// Struct field<br />
type structField struct {<br />
    name        name    // name is always non-empty<br />
    typ         *rtype  // type of field<br />
    offsetEmbed uintptr // byte offset of field«1 | isEmbedded<br />
}<br />
chanType 是 chan 类型的 ing 有，rtype 是 chan 本身，elem 是 chan 操作对象的类型和指针指向相识，dir 就是 chan 的反向进、出、进出。</p><br />
<br />
<p>// chanType represents a channel type.<br />
type chanType struct {<br />
    rtype<br />
    elem *rtype  // channel element type<br />
    dir  uintptr // channel direction (ChanDir)<br />
}<br />
sliceType 是切片类型定义，切片类型 rtype 是本身信息，elem 就是切片操作的对象类型。</p><br />
<br />
<p>// sliceType represents a slice type.<br />
type sliceType struct {<br />
    rtype<br />
    elem *rtype // slice element type<br />
}<br />
arrayType 是数组类型，在切片上额外多了两个属性，slice 是数组转换成切片的类型，预先静态定义好了，而 len 是数组长度。</p><br />
<br />
<p>// arrayType represents a fixed array type.<br />
type arrayType struct {<br />
    rtype<br />
    elem  *rtype // array element type<br />
    slice *rtype // slice type<br />
    len   uintptr<br />
}<br />
上述 example 讲述了部分类型的定义，完整查看源码 reflect.type.go。</p><br />
<br />
<p>method、interface、map 暂未完全看完，懂原理后没必要看没有几行使用相关知识。</p><br />
<br />
<p>reflect Kind<br />
reflect.Kind 是定义反射类型常量，是类型的标识。rtype 的 kind 属性就是指 reflect.Kind。</p><br />
<br />
<p>// A Kind represents the specific kind of type that a Type represents.<br />
// The zero Kind is not a valid kind.<br />
type Kind uint</p><br />
<br />
<p>const (<br />
    Invalid Kind = iota<br />
    Bool<br />
    Int<br />
    Int8<br />
    Int16<br />
    Int32<br />
    Int64<br />
    Uint<br />
    Uint8<br />
    Uint16<br />
    Uint32<br />
    Uint64<br />
    Uintptr<br />
    Float32<br />
    Float64<br />
    Complex64<br />
    Complex128<br />
    Array<br />
    Chan<br />
    Func<br />
    Interface<br />
    Map<br />
    Ptr<br />
    Slice<br />
    String<br />
    Struct<br />
    UnsafePointer<br />
)<br />
reflect Type method<br />
Kind 方法注释说明返回 kind 值就是 rtype.kind，类型是 reflect.Kind 是 go 中类型的主要分类,是 iota 定义的类型常量。</p><br />
<br />
<p>// Kind returns the specific kind of this type.<br />
Kind() Kind<br />
变量实现的方法定义在类型连续后面的一块内存中，可以 unsafe 读到一个类型的全部方法，就可以实现 Implements 方法判断是否实现了一个接口了。</p><br />
<br />
<p>// Implements reports whether the type implements the interface type u.<br />
Implements(u Type) bool<br />
ChanDir 方法很简单就返回 chanType.dir,注释说如果不是 Chan 类型 panic 了，类型不 chan 就没有 dir 这个属性无法处理就 panic 了，在调用前一般都明确了 Kind 是 Chan。</p><br />
<br />
<p>// ChanDir returns a channel type’s direction.<br />
// It panics if the type’s Kind is not Chan.<br />
ChanDir() ChanDir<br />
Elem 方法全称是 element，就是指元素类型也可以叫指向类型，注释要求 Kind 必须是 Array、Chan、Map、Ptr、Slice 类型否在就 panic，和 Chan 的 ChanDir 方法一样，只有这 5 个类型才有 elem 属性。</p><br />
<br />
<p>查看前面定义就可以知道 Arry、Slice、Ptr、Chan 的 elem 就是指向的对象的类型，map 是值的类型，例如以下类型 Elem 后 Kind 都是 Int。</p><br />
<br />
<p>[20]int<br />
[]int<br />
*int<br />
chan int<br />
map[string]int<br />
// Elem returns a type’s element type.<br />
// It panics if the type’s Kind is not Array, Chan, Map, Ptr, or Slice.<br />
Elem() Type<br />
Field 和 NumField 方法是获得结构体的指定索引的属性和结构体属性数量，注释一样有说明要求 Kind 是 Struct 类型否在 panic，因为就结构体类型才有 [] StructField 能实现这些方法。</p><br />
<br />
<p>根据前面 structType 定义两个方法的实现思路就是 typ.fields[i] 转换一下和 len(typ.fields).</p><br />
<br />
<p>// Field returns a struct type’s i’th field.<br />
// It panics if the type’s Kind is not Struct.<br />
// It panics if i is not in the range [0, NumField()).<br />
Field(i int) StructField<br />
// NumField returns a struct type’s field count.<br />
// It panics if the type’s Kind is not Struct.<br />
NumField() int<br />
NumIn 和 In 方法是 Func Kind 独有的方法，NumIn 返回这个 Func 具有多个入参，对于返回参数就是 NumOut；In 方法是获得这个 Func 指定第 i 参数的类型。</p><br />
<br />
<p>// NumIn returns a function type’s input parameter count.<br />
// It panics if the type’s Kind is not Func.<br />
NumIn() int<br />
    // In returns the type of a function type’s i’th input parameter.<br />
// It panics if the type’s Kind is not Func.<br />
// It panics if i is not in the range [0, NumIn()).<br />
In(i int) Type<br />
Key 方法是 Map Kind 独有方法，返回 map 键的类型。</p><br />
<br />
<p>// Key returns a map type’s key type.<br />
// It panics if the type’s Kind is not Map.<br />
Key() Type<br />
Len 方法是 Array Kind 独有方法，返回 Array 定义的长度。</p><br />
<br />
<p>// Len returns an array type’s length.<br />
// It panics if the type’s Kind is not Array.<br />
Len() int<br />
上述说明 reflect.Type 的部分方法实现原理，剩余方法原理类似，就是操作 rtype 的属性，部分 Kind 类型是具有独有方法可以调用。</p><br />
<br />
<p>reflect.Value Method<br />
反射 Value 对象定义了三个属性 类型、数据位置、flag，数据内存位置就在 ptr 位置，操作方法就需要依靠 typ 类型来判断数据类型操作了。</p><br />
<br />
<p>Type 是静态数据，而 Value 是动态数据，Value 的很多方法具体值是和数据相关的。</p><br />
<br />
<p>type Value struct {<br />
    typ *rtype<br />
    ptr unsafe.Pointer<br />
    flag<br />
}<br />
通用方法<br />
通用方法是指所有类型具有的方法，仅说明根据 Type 和 Value 定义实现这个方法大概的思路，具体实现代码并不一样,以源码为准。</p><br />
<br />
<p>Type 方法返回这个值的类型，大致思路就是返回 v.typ，具体实现还有一些额外处理。</p><br />
<br />
<p>func (v Value) Type() Type<br />
Kind 方法实现大致思路就是返回 v.typ.kind。</p><br />
<br />
<p>// Kind returns v’s Kind. If v is the zero Value (IsValid returns false),<br />
//  Kind returns Invalid.<br />
func (v Value) Kind() Kind<br />
Interface 法思路就是返回 v.ptr 值转换成一个 interface{}变量，这样就从 reflect.Value 重新转换会变量了。</p><br />
<br />
<p>// Interface returns v’s current value as an interface{}.<br />
// It is equivalent to:<br />
//  var i interface{} = (v’s underlying value)<br />
// It panics if the Value was obtained by accessing unexported struct fields.<br />
func (v Value) Interface() (i interface{})<br />
Convert 方法思路就是 v.ptr 值转换成参数 t 的类型，实现规则是Conversions 语法文档 镜像地址。</p><br />
<br />
<p>// Convert returns the value v converted to type t. If the usual Go conversion rules do not allow conversion of the value v to type t, Convert panics.<br />
func (v Value) Convert(t Type) Value<br />
Set 方法实现就是设置 v.ptr=x.ptr，要求 v 和 x 的类型是一样的。</p><br />
<br />
<p>同时要这个 Value 是 CanSet，如果将一个 int 转换成 reflect.Value，函数传递的是一个值的副本，那么再对 int 设置新的值就无效了，CanSet 返回就是 false，需要传递*int 这样的指针类型才能有效设置</p><br />
<br />
<p>// Set assigns x to the value v. It panics if CanSet returns false. As in Go, x’s value must be assignable to v’s type.<br />
func (v Value) Set(x Value)<br />
SetBool 方法是设置 bool Kind 的值，前置要求 Kind 是一样的，类型还有 SetInt、SetString 等方法。</p><br />
<br />
<p>// SetBool sets v’s underlying value. It panics if v’s Kind is not Bool or if CanSet() is false.<br />
func (v Value) SetBool(x bool)<br />
Method 返回这个值的指定索引方法。</p><br />
<br />
<p>// Method returns a function value corresponding to v’s i’th method.<br />
// The arguments to a Call on the returned function should not include<br />
// a receiver; the returned function will always use v as the receiver.<br />
// Method panics if i is out of range or if v is a nil interface value.<br />
func (v Value) Method(i int) Value<br />
独有方法<br />
Len 方法返回数据数据，注释说明要求是 Array, Chan, Map, Slice, or String，前四个返回就是数据量，而 String Kind 返回字符串长度。</p><br />
<br />
<p>// It panics if v’s Kind is not Array, Chan, Map, Slice, or String.<br />
func (v Value) Len() int<br />
IsNil 方法判断指针是否是空,在 go 的实现中 chan、func、interface、map、pointer、slice 底层才是指针类型，才能判断 IsNil 否在 panic，判断这些指针类型的 ptr 是否为 0，在 go 代码编写中也只有这几种类型可以i==nil这样的比较。</p><br />
<br />
<p>在 go1.13 中新增了 IsZero 方法，判断是否是空值，里面这些指针类型会判断 IsNil，其他类型就是判断数据值是不是零值那样。</p><br />
<br />
<p>// IsNil reports whether its argument v is nil. The argument must be<br />
// a chan, func, interface, map, pointer, or slice value; if it is<br />
// not, IsNil panics. Note that IsNil is not always equivalent to a<br />
// regular comparison with nil in Go. For example, if v was created<br />
// by calling ValueOf with an uninitialized interface variable i,<br />
// i==nil will be true but v.IsNil will panic as v will be the zero Value.<br />
func (v Value) IsNil() bool<br />
Index 方法获取指定类型的索引，就 Array、Slice、String 可以执行，否在 panic，在 ptr 指向的位置进行一个计算得到的偏移位置获得到索引的值。</p><br />
<br />
<p>// Index returns v’s i’th element. It panics if v’s Kind is not Array, Slice, or String or i is out of range.<br />
func (v Value) Index(i int) Value<br />
Field 方法是返回结构体指定索引的值，要求 Kind 是 Struct，通过指定索引的偏移来获得这个值的地址，然后类型里面获得到类型，最后返回索引的值。</p><br />
<br />
<p>// Field returns the i’th field of the struct v. It panics if v’s Kind is not Struct or i is out of range.<br />
func (v Value) Field(i int) Value<br />
Elem 方法是返回 Ptr 和 Interface Kind 指向值，为了解除引用。</p><br />
<br />
<p>为什么 Value.Elem 方法没有了 Slice、Map 等类型？ 具体额外独立的操作方法 Index、MapIndex 等。</p><br />
<br />
<p>// Elem returns the value that the interface v contains or that the pointer v points to. <br />
// It panics if v’s Kind is not Interface or Ptr. It returns the zero Value if v is nil.<br />
func (v Value) Elem() Value<br />
MapIndex 和 MapKeys 是 Map Kind 独有的方法，获取到 map 的索引值和全部键，通过 typ 提供的类型和 ptr 地址进行复杂的 map 操作。</p><br />
<br />
<p>// MapIndex returns the value associated with key in the map v.<br />
// It panics if v’s Kind is not Map.<br />
// It returns the zero Value if key is not found in the map or if v represents a nil map.<br />
// As in Go, the key’s value must be assignable to the map’s key type.<br />
func (v Value) MapIndex(key Value) Value<br />
// MapKeys returns a slice containing all the keys present in the map,<br />
// in unspecified order.<br />
// It panics if v’s Kind is not Map.<br />
// It returns an empty slice if v represents a nil map.<br />
func (v Value) MapKeys() []Value</p><br />
<br />
<p>Send 方法是 Chan Kind 独有方法，给 chan 放一个数据进去。</p><br />
<br />
<p>func (v Value) Send(x Value)<br />
end<br />
以上讲述了 reflect 库的原理就是操作 runtime 变量，而 runtime 变量就是一个类型加地址。</p><br />
<br />
<p>本文并没有完整分析 reflect 库，通过这些原理就可以大概理解这些方法的作用和操作了，具体请参考源码。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>