<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">writing a SQL database from scratch in Go</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-04-15T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 15, 2020</time></p>
					</div>
					 <p>https://notes.eatonphil.com/database-basics.html<br />
https://notes.eatonphil.com/database-basics-expressions-and-where.html</p><br />
<br />
<p>https://github.com/eatonphil/gosql</p><br />
<br />
<p>In this series we’ll write a rudimentary database from scratch in Go. Project source code is available on Github.</p><br />
<br />
<p>In this first post we’ll build enough of a parser to run some simple CREATE, INSERT, and SELECT queries. Then we’ll build an in-memory backend supporting TEXT and INT types and write a basic REPL.</p><br />
<br />
<p>We’ll be able to support the following interaction:</p><br />
<br />
<p>$ go run *.go<br />
Welcome to gosql.</p><br />
<h1 id="create-table-users-id-int-name-text">CREATE TABLE users (id INT, name TEXT);</h1><br />
<p>ok</p><br />
<h1 id="insert-into-users-values-1-phil">INSERT INTO users VALUES (1, ‘Phil’);</h1><br />
<p>ok</p><br />
<h1 id="select-id-name-from-users">SELECT id, name FROM users;</h1><br />
<p>| id | name |<br />
====================<br />
| 1 |  Phil |<br />
ok</p><br />
<h1 id="insert-into-users-values-2-kate">INSERT INTO users VALUES (2, ‘Kate’);</h1><br />
<p>ok</p><br />
<h1 id="select-name-id-from-users">SELECT name, id FROM users;</h1><br />
<p>| name | id |<br />
====================<br />
| Phil |  1 |<br />
| Kate |  2 |<br />
ok<br />
<!-- more --><br />
The first stage will be to map a SQL source into a list of tokens (lexing). Then we’ll call parse functions to find individual SQL statements (such as SELECT). These parse functions will in turn call their own helper functions to find patterns of recursively parseable chunks, keywords, symbols (like parenthesis), identifiers (like a table name), and numeric or string literals.</p><br />
<br />
<p>Then, we’ll write an in-memory backend to do operations based on an AST. Finally, we’ll write a REPL to accept SQL from a CLI and pass it to the in-memory backend.</p><br />
<br />
<p>This post assumes a basic understanding of parsing concepts. We won’t skip any code, but also won’t go into great detail on why we structure the way we do.</p><br />
<br />
<p>For a simpler introduction to parsing and parsing concepts, see this post on parsing JSON.</p><br />
<br />
<p>Lexing<br />
The lexer is responsible for finding every distinct group of characters in source code: tokens. This will consist primarily of identifiers, numbers, strings, and symbols.</p><br />
<br />
<p>What follows is a second, more orthodox pass at lexing. The first pass took a number of shortcuts and couldn’t handle spaces in strings, for example.</p><br />
<br />
<p>Here is the relevant pull request in gosql if you are curious.</p><br />
<br />
<p>The gist of the logic will be to pass control to a helper function for each kind of token. If the helper function succeeds in finding a token, it will return true and the location for the lexer to start at next. It will continue doing this until it reaches the end of the source.</p><br />
<br />
<p>First off, we’ll define a few types and constants for use in lexer.go:</p><br />
<br />
<p>package gosql</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “strings”<br />
)</p><br />
<br />
<p>type location struct {<br />
    line uint<br />
    col  uint<br />
}</p><br />
<br />
<p>type keyword string</p><br />
<br />
<p>const (<br />
    selectKeyword keyword = “select”<br />
    fromKeyword   keyword = “from”<br />
    asKeyword     keyword = “as”<br />
    tableKeyword  keyword = “table”<br />
    createKeyword keyword = “create”<br />
    insertKeyword keyword = “insert”<br />
    intoKeyword   keyword = “into”<br />
    valuesKeyword keyword = “values”<br />
    intKeyword    keyword = “int”<br />
    textKeyword   keyword = “text”<br />
)</p><br />
<br />
<p>type symbol string</p><br />
<br />
<p>const (<br />
    semicolonSymbol  symbol = “;”<br />
    asteriskSymbol   symbol = “*”<br />
    commaSymbol      symbol = “,”<br />
    leftparenSymbol  symbol = “(“<br />
    rightparenSymbol symbol = “)”<br />
)</p><br />
<br />
<p>type tokenKind uint</p><br />
<br />
<p>const (<br />
    keywordKind tokenKind = iota<br />
    symbolKind<br />
    identifierKind<br />
    stringKind<br />
    numericKind<br />
)</p><br />
<br />
<p>type token struct {<br />
    value string<br />
    kind  tokenKind<br />
    loc   location<br />
}</p><br />
<br />
<p>type cursor struct {<br />
    pointer uint<br />
    loc     location<br />
}</p><br />
<br />
<p>func (t *token) equals(other *token) bool {<br />
    return t.value == other.value &amp;&amp; t.kind == other.kind<br />
}</p><br />
<br />
<p>type lexer func(string, cursor) (*token, cursor, bool)<br />
Next we’ll write out the main loop:</p><br />
<br />
<p>func lex(source string) ([]<em>token, error) {<br />
    tokens := []</em>token{}<br />
    cur := cursor{}</p><br />
<br />
<p>lex:<br />
    for cur.pointer &lt; uint(len(source)) {<br />
        lexers := []lexer{lexKeyword, lexSymbol, lexString, lexNumeric, lexIdentifier}<br />
        for _, l := range lexers {<br />
            if token, newCursor, ok := l(source, cur); ok {<br />
                cur = newCursor</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            // Omit nil tokens for valid, but empty syntax like newlines<br />
            if token != nil {<br />
                tokens = append(tokens, token)<br />
            }<br />
<br />
            continue lex<br />
        }<br />
    }<br />
<br />
    hint := ""<br />
    if len(tokens) &gt; 0 {<br />
        hint = " after " + tokens[len(tokens)-1].value<br />
    }<br />
    return nil, fmt.Errorf("Unable to lex token%s, at %d:%d", hint, cur.loc.line, cur.loc.col)<br />
}<br />
<br />
return tokens, nil } Then we'll write a helper for each kind of fundemental token.<br />
</code></pre></div></div><br />
<br />
<p>Analyzing numbers<br />
Numbers are the most complex. So we’ll refer to the PostgreSQL documentation (section 4.1.2.6) for what constitutes a valid number.</p><br />
<br />
<p>func lexNumeric(source string, ic cursor) (*token, cursor, bool) {<br />
    cur := ic</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>periodFound := false<br />
expMarkerFound := false<br />
<br />
for ; cur.pointer &lt; uint(len(source)); cur.pointer++ {<br />
    c := source[cur.pointer]<br />
    cur.loc.col++<br />
<br />
    isDigit := c &gt;= '0' &amp;&amp; c &lt;= '9'<br />
    isPeriod := c == '.'<br />
    isExpMarker := c == 'e'<br />
<br />
    // Must start with a digit or period<br />
    if cur.pointer == ic.pointer {<br />
        if !isDigit &amp;&amp; !isPeriod {<br />
            return nil, ic, false<br />
        }<br />
<br />
        periodFound = isPeriod<br />
        continue<br />
    }<br />
<br />
    if isPeriod {<br />
        if periodFound {<br />
            return nil, ic, false<br />
        }<br />
<br />
        periodFound = true<br />
        continue<br />
    }<br />
<br />
    if isExpMarker {<br />
        if expMarkerFound {<br />
            return nil, ic, false<br />
        }<br />
<br />
        // No periods allowed after expMarker<br />
        periodFound = true<br />
        expMarkerFound = true<br />
<br />
        // expMarker must be followed by digits<br />
        if cur.pointer == uint(len(source)-1) {<br />
            return nil, ic, false<br />
        }<br />
<br />
        cNext := source[cur.pointer+1]<br />
        if cNext == '-' || cNext == '+' {<br />
            cur.pointer++<br />
            cur.loc.col++<br />
        }<br />
<br />
        continue<br />
    }<br />
<br />
    if !isDigit {<br />
        break<br />
    }<br />
}<br />
<br />
// No characters accumulated<br />
if cur.pointer == ic.pointer {<br />
    return nil, ic, false<br />
}<br />
<br />
return &amp;token{<br />
    value: source[ic.pointer:cur.pointer],<br />
    loc:   ic.loc,<br />
    kind:  numericKind,<br />
}, cur, true } Analyzing strings Strings must start and end with a single apostrophe. They can contain a single apostophe if it is followed by another single apostrophe. We'll put this kind of character delimited lexing logic into a helper function so we can use it again when analyzing identifiers.<br />
</code></pre></div></div><br />
<br />
<p>func lexCharacterDelimited(source string, ic cursor, delimiter byte) (*token, cursor, bool) {<br />
    cur := ic</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if len(source[cur.pointer:]) == 0 {<br />
    return nil, ic, false<br />
}<br />
<br />
if source[cur.pointer] != delimiter {<br />
    return nil, ic, false<br />
}<br />
<br />
cur.loc.col++<br />
cur.pointer++<br />
<br />
var value []byte<br />
for ; cur.pointer &lt; uint(len(source)); cur.pointer++ {<br />
    c := source[cur.pointer]<br />
<br />
    if c == delimiter {<br />
        // SQL escapes are via double characters, not backslash.<br />
        if cur.pointer+1 &gt;= uint(len(source)) || source[cur.pointer+1] != delimiter {<br />
            return &amp;token{<br />
                value: string(value),<br />
                loc:   ic.loc,<br />
                kind:  stringKind,<br />
            }, cur, true<br />
        } else {<br />
            value = append(value, delimiter)<br />
            cur.pointer++<br />
            cur.loc.col++<br />
        }<br />
    }<br />
<br />
    value = append(value, c)<br />
    cur.loc.col++<br />
}<br />
<br />
return nil, ic, false }<br />
</code></pre></div></div><br />
<br />
<p>func lexString(source string, ic cursor) (*token, cursor, bool) {<br />
    return lexCharacterDelimited(source, ic, ‘'’)<br />
}<br />
Analyzing symbols and keywords<br />
Symbols and keywords come from a fixed set of strings, so they’re easy to compare against. Whitespace should be thrown away.</p><br />
<br />
<p>func lexSymbol(source string, ic cursor) (*token, cursor, bool) {<br />
    c := source[ic.pointer]<br />
    cur := ic<br />
    cur.loc.col++<br />
    cur.pointer++</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>switch c {<br />
// Syntax that should be thrown away<br />
case '\n':<br />
    cur.loc.line++<br />
    cur.loc.col = 0<br />
    fallthrough<br />
case '\t':<br />
    fallthrough<br />
case ' ':<br />
    return nil, cur, true<br />
<br />
// Syntax that should be kept<br />
case ',':<br />
    fallthrough<br />
case '(':<br />
    fallthrough<br />
case ')':<br />
    fallthrough<br />
case ';':<br />
    fallthrough<br />
case '*':<br />
    break<br />
<br />
// Unknown character<br />
default:<br />
    return nil, ic, false<br />
}<br />
<br />
return &amp;token{<br />
    value: string(c),<br />
    loc:   ic.loc,<br />
    kind:  symbolKind,<br />
}, cur, true } Analyzing identifiers An identifier is either a double-quoted string or a group of characters starting with an alphabetical character and possibly containing numbers and underscores.<br />
</code></pre></div></div><br />
<br />
<p>func lexIdentifier(source string, ic cursor) (*token, cursor, bool) {<br />
    // Handle separately if is a double-quoted identifier<br />
    if token, newCursor, ok := lexCharacterDelimited(source, ic, ‘”’); ok {<br />
        return token, newCursor, true<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cur := ic<br />
<br />
c := source[cur.pointer]<br />
// Other characters count too, big ignoring non-ascii for now<br />
isAlphabetical := (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z')<br />
if !isAlphabetical {<br />
    return nil, ic, false<br />
}<br />
cur.pointer++<br />
cur.loc.col++<br />
<br />
value := []byte{c}<br />
for ; cur.pointer &lt; uint(len(source)); cur.pointer++ {<br />
    c = source[cur.pointer]<br />
<br />
    // Other characters count too, big ignoring non-ascii for now<br />
    isAlphabetical := (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z')<br />
    isNumeric := c &gt;= '0' &amp;&amp; c &lt;= '9'<br />
    if isAlphabetical || isNumeric || c == '$' || c == '_' {<br />
        value = append(value, c)<br />
        cur.loc.col++<br />
        continue<br />
    }<br />
<br />
    break<br />
}<br />
<br />
if len(value) == 0 {<br />
    return nil, ic, false<br />
}<br />
<br />
return &amp;token{<br />
    // Unquoted dentifiers are case-insensitive<br />
    value: strings.ToLower(string(value)),<br />
    loc:   ic.loc,<br />
    kind:  identifierKind,<br />
}, cur, true } And that's it for the lexer! If you copy lexer_test.go from the main project, the tests should now pass.<br />
</code></pre></div></div><br />
<br />
<p>AST model<br />
At the highest level, an AST is a collection of statements:</p><br />
<br />
<p>package main</p><br />
<br />
<p>type Ast struct {<br />
    Statements []*Statement<br />
}<br />
A statement, for now, is one of INSERT, CREATE, or SELECT:</p><br />
<br />
<p>type AstKind uint</p><br />
<br />
<p>const (<br />
    SelectKind AstKind = iota<br />
    CreateTableKind<br />
    InsertKind<br />
)</p><br />
<br />
<p>type Statement struct {<br />
    SelectStatement      *SelectStatement<br />
    CreateTableStatement *CreateTableStatement<br />
    InsertStatement      *InsertStatement<br />
    Kind                 AstKind<br />
}<br />
INSERT<br />
An insert statement, for now, has a table name and a list of values to insert:</p><br />
<br />
<p>type InsertStatement struct {<br />
    table  token<br />
    values <em>[]</em>expression<br />
}<br />
An expression is a literal token or (in the future) a function call or inline operation:</p><br />
<br />
<p>type expressionKind uint</p><br />
<br />
<p>const (<br />
    literalKind expressionKind = iota<br />
)</p><br />
<br />
<p>type expression struct {<br />
    literal *token<br />
    kind    expressionKind<br />
}<br />
CREATE<br />
A create statement, for now, has a table name and a list of column names and types:</p><br />
<br />
<p>type columnDefinition struct {<br />
    name     token<br />
    datatype token<br />
}</p><br />
<br />
<p>type CreateTableStatement struct {<br />
    name token<br />
    cols <em>[]</em>columnDefinition<br />
}<br />
SELECT<br />
A select statement, for now, has a table name and a list of column names:</p><br />
<br />
<p>type SelectStatement struct {<br />
    item []*expression<br />
    from token<br />
}<br />
And that’s it for the AST.</p><br />
<br />
<p>Parsing<br />
The Parse entrypoint will take a list of tokens and attempt to parse statements, separated by a semi-colon, until it reaches the last token.</p><br />
<br />
<p>In general our strategy will be to increment and pass around a cursor containing the current position of unparsed tokens. Each helper will return the new cursor that the caller should start from.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “errors”<br />
    “fmt”<br />
)</p><br />
<br />
<p>func tokenFromKeyword(k keyword) token {<br />
    return token{<br />
        kind:  keywordKind,<br />
        value: string(k),<br />
    }<br />
}</p><br />
<br />
<p>func tokenFromSymbol(s symbol) token {<br />
    return token{<br />
        kind:  symbolKind,<br />
        value: string(s),<br />
    }<br />
}</p><br />
<br />
<p>func expectToken(tokens []*token, cursor uint, t token) bool {<br />
    if cursor &gt;= uint(len(tokens)) {<br />
        return false<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return t.equals(tokens[cursor]) }<br />
</code></pre></div></div><br />
<br />
<p>func helpMessage(tokens []*token, cursor uint, msg string) {<br />
    var c *token<br />
    if cursor &lt; uint(len(tokens)) {<br />
        c = tokens[cursor]<br />
    } else {<br />
        c = tokens[cursor-1]<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("[%d,%d]: %s, got: %s\n", c.loc.line, c.loc.col, msg, c.value) }<br />
</code></pre></div></div><br />
<br />
<p>func Parse(source string) (*Ast, error) {<br />
    tokens, err := lex(source)<br />
    if err != nil {<br />
        return nil, err<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a := Ast{}<br />
cursor := uint(0)<br />
for cursor &lt; uint(len(tokens)) {<br />
    stmt, newCursor, ok := parseStatement(tokens, cursor, tokenFromSymbol(semicolonSymbol))<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected statement")<br />
        return nil, errors.New("Failed to parse, expected statement")<br />
    }<br />
    cursor = newCursor<br />
<br />
    a.Statements = append(a.Statements, stmt)<br />
<br />
    atLeastOneSemicolon := false<br />
    for expectToken(tokens, cursor, tokenFromSymbol(semicolonSymbol)) {<br />
        cursor++<br />
        atLeastOneSemicolon = true<br />
    }<br />
<br />
    if !atLeastOneSemicolon {<br />
        helpMessage(tokens, cursor, "Expected semi-colon delimiter between statements")<br />
        return nil, errors.New("Missing semi-colon between statements")<br />
    }<br />
}<br />
<br />
return &amp;a, nil } Parsing statements Each statement will be one of INSERT, CREATE, or SELECT. The parseStatement helper will call a helper on each of these statement types and return true if one of them succeeds in parsing.<br />
</code></pre></div></div><br />
<br />
<p>func parseStatement(tokens []<em>token, initialCursor uint, delimiter token) (</em>Statement, uint, bool) {<br />
    cursor := initialCursor</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Look for a SELECT statement<br />
semicolonToken := tokenFromSymbol(semicolonSymbol)<br />
slct, newCursor, ok := parseSelectStatement(tokens, cursor, semicolonToken)<br />
if ok {<br />
    return &amp;Statement{<br />
        Kind:            SelectKind,<br />
        SelectStatement: slct,<br />
    }, newCursor, true<br />
}<br />
<br />
// Look for a INSERT statement<br />
inst, newCursor, ok := parseInsertStatement(tokens, cursor, semicolonToken)<br />
if ok {<br />
    return &amp;Statement{<br />
        Kind:            InsertKind,<br />
        InsertStatement: inst,<br />
    }, newCursor, true<br />
}<br />
<br />
// Look for a CREATE statement<br />
crtTbl, newCursor, ok := parseCreateTableStatement(tokens, cursor, semicolonToken)<br />
if ok {<br />
    return &amp;Statement{<br />
        Kind:                 CreateTableKind,<br />
        CreateTableStatement: crtTbl,<br />
    }, newCursor, true<br />
}<br />
<br />
return nil, initialCursor, false } Parsing select statements Parsing SELECT statements is easy. We'll look for the following token pattern:<br />
</code></pre></div></div><br />
<br />
<p>SELECT<br />
$expression [, …]<br />
FROM<br />
$table-name<br />
Sketching that out we get:</p><br />
<br />
<p>func parseSelectStatement(tokens []<em>token, initialCursor uint, delimiter token) (</em>SelectStatement, uint, bool) {<br />
    cursor := initialCursor<br />
    if !expectToken(tokens, cursor, tokenFromKeyword(selectKeyword)) {<br />
        return nil, initialCursor, false<br />
    }<br />
    cursor++</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slct := SelectStatement{}<br />
<br />
exps, newCursor, ok := parseExpressions(tokens, cursor, []token{tokenFromKeyword(fromKeyword), delimiter})<br />
if !ok {<br />
    return nil, initialCursor, false<br />
}<br />
<br />
slct.item = *exps<br />
cursor = newCursor<br />
<br />
if expectToken(tokens, cursor, tokenFromKeyword(fromKeyword)) {<br />
    cursor++<br />
<br />
    from, newCursor, ok := parseToken(tokens, cursor, identifierKind)<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected FROM token")<br />
        return nil, initialCursor, false<br />
    }<br />
<br />
    slct.from = *from<br />
    cursor = newCursor<br />
}<br />
<br />
return &amp;slct, cursor, true } The parseToken helper will look for a token of a particular token kind.<br />
</code></pre></div></div><br />
<br />
<p>func parseToken(tokens []<em>token, initialCursor uint, kind tokenKind) (</em>token, uint, bool) {<br />
    cursor := initialCursor</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if cursor &gt;= uint(len(tokens)) {<br />
    return nil, initialCursor, false<br />
}<br />
<br />
current := tokens[cursor]<br />
if current.kind == kind {<br />
    return current, cursor + 1, true<br />
}<br />
<br />
return nil, initialCursor, false } The parseExpressions helper will look for tokens separated by a comma until a delimiter is found. It will use existing helpers plus parseExpression.<br />
</code></pre></div></div><br />
<br />
<p>func parseExpressions(tokens []<em>token, initialCursor uint, delimiters []token) (</em>[]*expression, uint, bool) {<br />
    cursor := initialCursor</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exps := []*expression{} outer:<br />
for {<br />
    if cursor &gt;= uint(len(tokens)) {<br />
        return nil, initialCursor, false<br />
    }<br />
<br />
    // Look for delimiter<br />
    current := tokens[cursor]<br />
    for _, delimiter := range delimiters {<br />
        if delimiter.equals(current) {<br />
            break outer<br />
        }<br />
    }<br />
<br />
    // Look for comma<br />
    if len(exps) &gt; 0 {<br />
        if !expectToken(tokens, cursor, tokenFromSymbol(commaSymbol)) {<br />
            helpMessage(tokens, cursor, "Expected comma")<br />
            return nil, initialCursor, false<br />
        }<br />
<br />
        cursor++<br />
    }<br />
<br />
    // Look for expression<br />
    exp, newCursor, ok := parseExpression(tokens, cursor, tokenFromSymbol(commaSymbol))<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected expression")<br />
        return nil, initialCursor, false<br />
    }<br />
    cursor = newCursor<br />
<br />
    exps = append(exps, exp)<br />
}<br />
<br />
return &amp;exps, cursor, true } The parseExpression helper (for now) will look for a numeric, string, or identifier token.<br />
</code></pre></div></div><br />
<br />
<p>func parseExpression(tokens []<em>token, initialCursor uint, _ token) (</em>expression, uint, bool) {<br />
    cursor := initialCursor</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kinds := []tokenKind{identifierKind, numericKind, stringKind}<br />
for _, kind := range kinds {<br />
    t, newCursor, ok := parseToken(tokens, cursor, kind)<br />
    if ok {<br />
        return &amp;expression{<br />
            literal: t,<br />
            kind:    literalKind,<br />
        }, newCursor, true<br />
    }<br />
}<br />
<br />
return nil, initialCursor, false } And that's it for parsing a SELECT statement!<br />
</code></pre></div></div><br />
<br />
<p>Parsing insert statements<br />
We’ll look for the following token pattern:</p><br />
<br />
<p>INSERT<br />
INTO<br />
$table-name<br />
VALUES<br />
(<br />
$expression [, …]<br />
)<br />
With the existing helpers, this is straightforward to sketch out:</p><br />
<br />
<p>func parseInsertStatement(tokens []<em>token, initialCursor uint, delimiter token) (</em>InsertStatement, uint, bool) {<br />
    cursor := initialCursor</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Look for INSERT<br />
if !expectToken(tokens, cursor, tokenFromKeyword(insertKeyword)) {<br />
    return nil, initialCursor, false<br />
}<br />
cursor++<br />
<br />
// Look for INTO<br />
if !expectToken(tokens, cursor, tokenFromKeyword(intoKeyword)) {<br />
    helpMessage(tokens, cursor, "Expected into")<br />
    return nil, initialCursor, false<br />
}<br />
cursor++<br />
<br />
// Look for table name<br />
table, newCursor, ok := parseToken(tokens, cursor, identifierKind)<br />
if !ok {<br />
    helpMessage(tokens, cursor, "Expected table name")<br />
    return nil, initialCursor, false<br />
}<br />
cursor = newCursor<br />
<br />
// Look for VALUES<br />
if !expectToken(tokens, cursor, tokenFromKeyword(valuesKeyword)) {<br />
    helpMessage(tokens, cursor, "Expected VALUES")<br />
    return nil, initialCursor, false<br />
}<br />
cursor++<br />
<br />
// Look for left paren<br />
if !expectToken(tokens, cursor, tokenFromSymbol(leftparenSymbol)) {<br />
    helpMessage(tokens, cursor, "Expected left paren")<br />
    return nil, initialCursor, false<br />
}<br />
cursor++<br />
<br />
// Look for expression list<br />
values, newCursor, ok := parseExpressions(tokens, cursor, []token{tokenFromSymbol(rightparenSymbol)})<br />
if !ok {<br />
    return nil, initialCursor, false<br />
}<br />
cursor = newCursor<br />
<br />
// Look for right paren<br />
if !expectToken(tokens, cursor, tokenFromSymbol(rightparenSymbol)) {<br />
    helpMessage(tokens, cursor, "Expected right paren")<br />
    return nil, initialCursor, false<br />
}<br />
cursor++<br />
<br />
return &amp;InsertStatement{<br />
    table:  *table,<br />
    values: values,<br />
}, cursor, true } And that's it for parsing an INSERT statement!<br />
</code></pre></div></div><br />
<br />
<p>Parsing create statements<br />
Finally, for create statements we’ll look for the following token pattern:</p><br />
<br />
<p>CREATE<br />
$table-name<br />
(<br />
[$column-name $column-type [, …]]<br />
)<br />
Sketching that out with a new parseColumnDefinitions helper we get:</p><br />
<br />
<p>func parseCreateTableStatement(tokens []<em>token, initialCursor uint, delimiter token) (</em>CreateTableStatement, uint, bool) {<br />
    cursor := initialCursor</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if !expectToken(tokens, cursor, tokenFromKeyword(createKeyword)) {<br />
    return nil, initialCursor, false<br />
}<br />
cursor++<br />
<br />
if !expectToken(tokens, cursor, tokenFromKeyword(tableKeyword)) {<br />
    return nil, initialCursor, false<br />
}<br />
cursor++<br />
<br />
name, newCursor, ok := parseToken(tokens, cursor, identifierKind)<br />
if !ok {<br />
    helpMessage(tokens, cursor, "Expected table name")<br />
    return nil, initialCursor, false<br />
}<br />
cursor = newCursor<br />
<br />
if !expectToken(tokens, cursor, tokenFromSymbol(leftparenSymbol)) {<br />
    helpMessage(tokens, cursor, "Expected left parenthesis")<br />
    return nil, initialCursor, false<br />
}<br />
cursor++<br />
<br />
cols, newCursor, ok := parseColumnDefinitions(tokens, cursor, tokenFromSymbol(rightparenSymbol))<br />
if !ok {<br />
    return nil, initialCursor, false<br />
}<br />
cursor = newCursor<br />
<br />
if !expectToken(tokens, cursor, tokenFromSymbol(rightparenSymbol)) {<br />
    helpMessage(tokens, cursor, "Expected right parenthesis")<br />
    return nil, initialCursor, false<br />
}<br />
cursor++<br />
<br />
return &amp;CreateTableStatement{<br />
    name: *name,<br />
    cols: cols,<br />
}, cursor, true } The parseColumnDefinitions helper will look column names followed by column types separated by a comma and ending with some delimiter:<br />
</code></pre></div></div><br />
<br />
<p>func parseColumnDefinitions(tokens []<em>token, initialCursor uint, delimiter token) (</em>[]*columnDefinition, uint, bool) {<br />
    cursor := initialCursor</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cds := []*columnDefinition{}<br />
for {<br />
    if cursor &gt;= uint(len(tokens)) {<br />
        return nil, initialCursor, false<br />
    }<br />
<br />
    // Look for a delimiter<br />
    current := tokens[cursor]<br />
    if delimiter.equals(current) {<br />
        break<br />
    }<br />
<br />
    // Look for a comma<br />
    if len(cds) &gt; 0 {<br />
        if !expectToken(tokens, cursor, tokenFromSymbol(commaSymbol)) {<br />
            helpMessage(tokens, cursor, "Expected comma")<br />
            return nil, initialCursor, false<br />
        }<br />
<br />
        cursor++<br />
    }<br />
<br />
    // Look for a column name<br />
    id, newCursor, ok := parseToken(tokens, cursor, identifierKind)<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected column name")<br />
        return nil, initialCursor, false<br />
    }<br />
    cursor = newCursor<br />
<br />
    // Look for a column type<br />
    ty, newCursor, ok := parseToken(tokens, cursor, keywordKind)<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected column type")<br />
        return nil, initialCursor, false<br />
    }<br />
    cursor = newCursor<br />
<br />
    cds = append(cds, &amp;columnDefinition{<br />
        name:     *id,<br />
        datatype: *ty,<br />
    })<br />
}<br />
<br />
return &amp;cds, cursor, true } And that's it for parsing! If you copy parser_test.go from the main project, the tests should now pass.<br />
</code></pre></div></div><br />
<br />
<p>An in-memory backend<br />
Our in-memory backend should conform to a general backend interface that allows a user to create, select, and insert data:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “errors”</p><br />
<br />
<p>type ColumnType uint</p><br />
<br />
<p>const (<br />
    TextType ColumnType = iota<br />
    IntType<br />
)</p><br />
<br />
<p>type Cell interface {<br />
    AsText() string<br />
    AsInt() int32<br />
}</p><br />
<br />
<p>type Results struct {<br />
    Columns []struct {<br />
        Type ColumnType<br />
        Name string<br />
    }<br />
    Rows [][]Cell<br />
}</p><br />
<br />
<p>var (<br />
    ErrTableDoesNotExist  = errors.New(“Table does not exist”)<br />
    ErrColumnDoesNotExist = errors.New(“Column does not exist”)<br />
    ErrInvalidSelectItem  = errors.New(“Select item is not valid”)<br />
    ErrInvalidDatatype    = errors.New(“Invalid datatype”)<br />
    ErrMissingValues      = errors.New(“Missing values”)<br />
)</p><br />
<br />
<p>type Backend interface {<br />
    CreateTable(<em>CreateTableStatement) error<br />
    Insert(</em>InsertStatement) error<br />
    Select(<em>SelectStatement) (</em>Results, error)<br />
}<br />
This leaves us room in the future for a disk-backed backend.</p><br />
<br />
<p>Memory layout<br />
Our in-memory backend should store a list of tables. Each table will have a list of columns and rows. Each column will have a name and type. Each row will have a list of byte arrays.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “bytes”<br />
    “encoding/binary”<br />
    “fmt”<br />
    “strconv”<br />
)</p><br />
<br />
<p>type MemoryCell []byte</p><br />
<br />
<p>func (mc MemoryCell) AsInt() int32 {<br />
    var i int32<br />
    err := binary.Read(bytes.NewBuffer(mc), binary.BigEndian, &amp;i)<br />
    if err != nil {<br />
        panic(err)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return i }<br />
</code></pre></div></div><br />
<br />
<p>func (mc MemoryCell) AsText() string {<br />
    return string(mc)<br />
}</p><br />
<br />
<p>type table struct {<br />
    columns     []string<br />
    columnTypes []ColumnType<br />
    rows        [][]MemoryCell<br />
}</p><br />
<br />
<p>type MemoryBackend struct {<br />
    tables map[string]*table<br />
}</p><br />
<br />
<p>func NewMemoryBackend() <em>MemoryBackend {<br />
    return &amp;MemoryBackend{<br />
        tables: map[string]</em>table{},<br />
    }<br />
}<br />
Implementing create table support<br />
When creating a table, we’ll make a new entry in the backend tables map. Then we’ll create columns as specified by the AST.</p><br />
<br />
<p>func (mb *MemoryBackend) CreateTable(crt *CreateTableStatement) error {<br />
    t := table{}<br />
    mb.tables[crt.name.value] = &amp;t<br />
    if crt.cols == nil {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    return nil<br />
}<br />
<br />
for _, col := range *crt.cols {<br />
    t.columns = append(t.columns, col.name.value)<br />
<br />
    var dt ColumnType<br />
    switch col.datatype.value {<br />
    case "int":<br />
        dt = IntType<br />
    case "text":<br />
        dt = TextType<br />
    default:<br />
        return ErrInvalidDatatype<br />
    }<br />
<br />
    t.columnTypes = append(t.columnTypes, dt)<br />
}<br />
<br />
return nil } Implementing insert support Keeping things simple, we'll assume the value passed can be correctly mapped to the type of the column specified.<br />
</code></pre></div></div><br />
<br />
<p>We’ll reference a helper for mapper values to internal storage, tokenToCell.</p><br />
<br />
<p>func (mb *MemoryBackend) Insert(inst *InsertStatement) error {<br />
    table, ok := mb.tables[inst.table.value]<br />
    if !ok {<br />
        return ErrTableDoesNotExist<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if inst.values == nil {<br />
    return nil<br />
}<br />
<br />
row := []MemoryCell{}<br />
<br />
if len(*inst.values) != len(table.columns) {<br />
    return ErrMissingValues<br />
}<br />
<br />
for _, value := range *inst.values {<br />
    if value.kind != literalKind {<br />
        fmt.Println("Skipping non-literal.")<br />
        continue<br />
    }<br />
<br />
    row = append(row, mb.tokenToCell(value.literal))<br />
}<br />
<br />
table.rows = append(table.rows, row)<br />
return nil } The tokenToCell helper will write numbers as binary bytes and will write strings as bytes:<br />
</code></pre></div></div><br />
<br />
<p>func (mb *MemoryBackend) tokenToCell(t *token) MemoryCell {<br />
    if t.kind == numericKind {<br />
        buf := new(bytes.Buffer)<br />
        i, err := strconv.Atoi(t.value)<br />
        if err != nil {<br />
            panic(err)<br />
        }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    err = binary.Write(buf, binary.BigEndian, int32(i))<br />
    if err != nil {<br />
        panic(err)<br />
    }<br />
    return MemoryCell(buf.Bytes())<br />
}<br />
<br />
if t.kind == stringKind {<br />
    return MemoryCell(t.value)<br />
}<br />
<br />
return nil } Implementing select support Finally, for select we'll iterate over each row in the table and return the cells according to the columns specified by the AST.<br />
</code></pre></div></div><br />
<br />
<p>func (mb <em>MemoryBackend) Select(slct *SelectStatement) (</em>Results, error) {<br />
    table, ok := mb.tables[slct.from.table]<br />
    if !ok {<br />
        return nil, ErrTableDoesNotExist<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>results := [][]Cell{}<br />
columns := []struct {<br />
    Type ColumnType<br />
    Name string<br />
}{}<br />
<br />
for i, row := range table.rows {<br />
    result := []Cell{}<br />
    isFirstRow := i == 0<br />
<br />
    for _, exp := range slct.item {<br />
        if exp.kind != literalKind {<br />
            // Unsupported, doesn't currently exist, ignore.<br />
            fmt.Println("Skipping non-literal expression.")<br />
            continue<br />
        }<br />
<br />
        lit := exp.literal<br />
        if lit.kind == identifierKind {<br />
            found := false<br />
            for i, tableCol := range table.columns {<br />
                if tableCol == lit.value {<br />
                    if isFirstRow {<br />
                        columns = append(columns, struct {<br />
                            Type ColumnType<br />
                            Name string<br />
                        }{<br />
                            Type: table.columnTypes[i],<br />
                            Name: lit.value,<br />
                        })<br />
                    }<br />
<br />
                    result = append(result, row[i])<br />
                    found = true<br />
                    break<br />
                }<br />
            }<br />
<br />
            if !found {<br />
                return nil, ErrColumnDoesNotExist<br />
            }<br />
<br />
            continue<br />
        }<br />
<br />
        return nil, ErrColumnDoesNotExist<br />
    }<br />
<br />
    results = append(results, result)<br />
}<br />
<br />
return &amp;Results{<br />
    Columns: columns,<br />
    Rows:    results,<br />
}, nil } The REPL At last, we're ready to wrap the parser and in-memory backend in a REPL. The most complex part is displaying the table of results from a select query.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “bufio”<br />
    “fmt”<br />
    “os”<br />
    “strings”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/eatonphil/gosql" )<br />
</code></pre></div></div><br />
<br />
<p>func main() {<br />
    mb := gosql.NewMemoryBackend()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reader := bufio.NewReader(os.Stdin)<br />
fmt.Println("Welcome to gosql.")<br />
for {<br />
    fmt.Print("# ")<br />
    text, err := reader.ReadString('\n')<br />
    text = strings.Replace(text, "\n", "", -1)<br />
<br />
    ast, err := gosql.Parse(text)<br />
    if err != nil {<br />
        panic(err)<br />
    }<br />
<br />
    for _, stmt := range ast.Statements {<br />
        switch stmt.Kind {<br />
        case gosql.CreateTableKind:<br />
            err = mb.CreateTable(ast.Statements[0].CreateTableStatement)<br />
            if err != nil {<br />
                panic(err)<br />
            }<br />
            fmt.Println("ok")<br />
        case gosql.InsertKind:<br />
            err = mb.Insert(stmt.InsertStatement)<br />
            if err != nil {<br />
                panic(err)<br />
            }<br />
<br />
            fmt.Println("ok")<br />
        case gosql.SelectKind:<br />
            results, err := mb.Select(stmt.SelectStatement)<br />
            if err != nil {<br />
                panic(err)<br />
            }<br />
<br />
            for _, col := range results.Columns {<br />
                fmt.Printf("| %s ", col.Name)<br />
            }<br />
            fmt.Println("|")<br />
<br />
            for i := 0; i &lt; 20; i++ {<br />
                fmt.Printf("=")<br />
            }<br />
            fmt.Println()<br />
<br />
            for _, result := range results.Rows {<br />
                fmt.Printf("|")<br />
<br />
                for i, cell := range result {<br />
                    typ := results.Columns[i].Type<br />
                    s := ""<br />
                    switch typ {<br />
                    case gosql.IntType:<br />
                        s = fmt.Sprintf("%d", cell.AsInt())<br />
                    case gosql.TextType:<br />
                        s = cell.AsText()<br />
                    }<br />
<br />
                    fmt.Printf(" %s | ", s)<br />
                }<br />
<br />
                fmt.Println()<br />
            }<br />
<br />
            fmt.Println("ok")<br />
        }<br />
    }<br />
} } Putting it all together:<br />
</code></pre></div></div><br />
<br />
<p>$ go run *.go<br />
Welcome to gosql.</p><br />
<h1 id="create-table-users-id-int-name-text-1">CREATE TABLE users (id INT, name TEXT);</h1><br />
<p>ok</p><br />
<h1 id="insert-into-users-values-1-phil-1">INSERT INTO users VALUES (1, ‘Phil’);</h1><br />
<p>ok</p><br />
<h1 id="select-id-name-from-users-1">SELECT id, name FROM users;</h1><br />
<p>| id | name |<br />
====================<br />
| 1 |  Phil |<br />
ok</p><br />
<h1 id="insert-into-users-values-2-kate-1">INSERT INTO users VALUES (2, ‘Kate’);</h1><br />
<p>ok</p><br />
<h1 id="select-name-id-from-users-1">SELECT name, id FROM users;</h1><br />
<p>| name | id |<br />
====================<br />
| Phil |  1 |<br />
| Kate |  2 |<br />
ok<br />
And we’ve got a very simple SQL database!</p><br />
<br />
<p>Next up we’ll get into filtering, sorting, and indexing.</p><br />
<br />
<p>Further reading<br />
Writing a simple JSON parser<br />
This post goes into a little more detail about the theory and basics of parsing.<br />
Database Systems: A Practical Approach to Design, Implementation and Management<br />
A giant book, but an excellent and very easy introduction to database theory.<br />
Comments<br />
Please reply on Twitter with questions or comments.</p><br />
<br />
<p>Latest blog post: writing a simple SQL database from scratch in Go https://t.co/csQmNhWIEf</p><br />
<br />
<p>In this post, we’ll extend gosql to support binary expressions and very simple filtering on SELECT results via WHERE. We’ll introduce a general mechanism for interpreting an expression on a row in a table. The expression may be an identifier (where the result is the value of the cell corresponding to that column in the row), a numeric literal, a combination via a binary expression, etc.</p><br />
<br />
<p>The following interactions will be possible:</p><br />
<br />
<h1 id="create-table-users-name-text-age-int">CREATE TABLE users (name TEXT, age INT);</h1><br />
<p>ok</p><br />
<h1 id="insert-into-users-values-stephen-16">INSERT INTO users VALUES (‘Stephen’, 16);</h1><br />
<p>ok</p><br />
<h1 id="select-name-age-from-users">SELECT name, age FROM users;</h1><br />
<p>name   | age<br />
———-+——<br />
Stephen |  16<br />
(1 result)<br />
ok</p><br />
<h1 id="insert-into-users-values-adrienne-23">INSERT INTO users VALUES (‘Adrienne’, 23);</h1><br />
<p>ok</p><br />
<h1 id="select-age--2-name-from-users-where-age--23">SELECT age + 2, name FROM users WHERE age = 23;</h1><br />
<p>age |   name<br />
——+———–<br />
25 | Adrienne<br />
(1 result)<br />
ok</p><br />
<h1 id="select-name-from-users">SELECT name FROM users;</h1><br />
<p>name<br />
————<br />
Stephen<br />
Adrienne<br />
(2 results)<br />
ok<br />
The changes we’ll make in this post are roughly a walk through of this commit.</p><br />
<br />
<p>Boilerplate updates<br />
There are a few updates to pick up that I won’t go into in this post. Grab the following files from the main repo:</p><br />
<br />
<p>lexer.go<br />
The big change here is to use the same keyword matching algorithm for symbols. This allows us to support symbols that are longer than one character.<br />
This file also now includes the following keywords and symbols: and, or, true, false, =, &lt;&gt;, ||, and +.<br />
cmd/main.go<br />
This file now uses a third-party table-rendering library instead of the hacky, handwritten original one.<br />
This also uses a third-party readline implementation so you get history and useful cursor movement in the REPL.<br />
Parsing boilerplate<br />
We’ll redefine three helper functions in parser.go before going further: parseToken, parseTokenKind, and helpMessage.</p><br />
<br />
<p>The parseToken helper will consume a token if it matches the one provided as an argument (ignoring location).</p><br />
<br />
<p>func parseToken(tokens []<em>token, initialCursor uint, t token) (</em>token, uint, bool) {<br />
    cursor := initialCursor</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if cursor &gt;= uint(len(tokens)) {<br />
    return nil, initialCursor, false<br />
}<br />
<br />
if p := tokens[cursor]; t.equals(p) {<br />
    return p, cursor + 1, true<br />
}<br />
<br />
return nil, initialCursor, false } The parseTokenKind helper will consume a token if it is the same kind as an argument provided.<br />
</code></pre></div></div><br />
<br />
<p>func parseTokenKind(tokens []<em>token, initialCursor uint, kind tokenKind) (</em>token, uint, bool) {<br />
    cursor := initialCursor</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if cursor &gt;= uint(len(tokens)) {<br />
    return nil, initialCursor, false<br />
}<br />
<br />
current := tokens[cursor]<br />
if current.kind == kind {<br />
    return current, cursor + 1, true<br />
}<br />
<br />
return nil, initialCursor, false } And the helpMessage helper will give an indication of where in a program something happened.<br />
</code></pre></div></div><br />
<br />
<p>func helpMessage(tokens []*token, cursor uint, msg string) {<br />
    var c *token<br />
    if cursor+1 &lt; uint(len(tokens)) {<br />
        c = tokens[cursor+1]<br />
    } else {<br />
        c = tokens[cursor]<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("[%d,%d]: %s, near: %s\n", c.loc.line, c.loc.col, msg, c.value) } Parsing binary expressions Next we'll extend the AST structure in ast.go to support a "binary kind" of expression. The binary expression will have two sub-expressions and an operator.<br />
</code></pre></div></div><br />
<br />
<p>const (<br />
    literalKind expressionKind<br />
    binaryKind<br />
)</p><br />
<br />
<p>type binaryExpression struct {<br />
    a  expression<br />
    b  expression<br />
    op token<br />
}</p><br />
<br />
<p>type expression struct {<br />
    literal *token<br />
    binary  *binaryExpression<br />
    kind    expressionKind<br />
}<br />
We’ll use Pratt parsing to handle operator precedence. There is an excellent introduction to this technique here.</p><br />
<br />
<p>If at the beginning of parsing we see a left parenthesis, we’ll consume it and parse an expression within it. Then we’ll look for a right parenthesis. Otherwise we’ll look for a non-binary expression first (e.g. symbol, number).</p><br />
<br />
<p>func parseExpression(tokens []<em>token, initialCursor uint, delimiters []token, minBp uint) (</em>expression, uint, bool) {<br />
    cursor := initialCursor</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var exp *expression<br />
_, newCursor, ok := parseToken(tokens, cursor, tokenFromSymbol(leftParenSymbol))<br />
if ok {<br />
    cursor = newCursor<br />
    rightParenToken := tokenFromSymbol(rightParenSymbol)<br />
<br />
    exp, cursor, ok = parseExpression(tokens, cursor, append(delimiters, rightParenToken), minBp)<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected expression after opening paren")<br />
        return nil, initialCursor, false<br />
    }<br />
<br />
    _, cursor, ok = parseToken(tokens, cursor, rightParenToken)<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected closing paren")<br />
        return nil, initialCursor, false<br />
    }<br />
} else {<br />
    exp, cursor, ok = parseLiteralExpression(tokens, cursor)<br />
    if !ok {<br />
        return nil, initialCursor, false<br />
    }<br />
}<br />
<br />
...<br />
<br />
return exp, cursor, true } Then we'll look for a binary operator (e.g. =, and) or delimiter. If we find an operator and it of lesser "binding power" than the current minimum (minBp passed as an argument to the parse function with a default value of 0), we'll return the current expression.<br />
<br />
...<br />
<br />
lastCursor := cursor outer:<br />
for cursor &lt; uint(len(tokens)) {<br />
    for _, d := range delimiters {<br />
        _, _, ok = parseToken(tokens, cursor, d)<br />
        if ok {<br />
            break outer<br />
        }<br />
    }<br />
<br />
    binOps := []token{<br />
        tokenFromKeyword(andKeyword),<br />
        tokenFromKeyword(orKeyword),<br />
        tokenFromSymbol(eqSymbol),<br />
        tokenFromSymbol(neqSymbol),<br />
        tokenFromSymbol(concatSymbol),<br />
        tokenFromSymbol(plusSymbol),<br />
    }<br />
<br />
    var op *token = nil<br />
    for _, bo := range binOps {<br />
        var t *token<br />
        t, cursor, ok = parseToken(tokens, cursor, bo)<br />
        if ok {<br />
            op = t<br />
            break<br />
        }<br />
    }<br />
<br />
    if op == nil {<br />
        helpMessage(tokens, cursor, "Expected binary operator")<br />
        return nil, initialCursor, false<br />
    }<br />
<br />
    bp := op.bindingPower()<br />
    if bp &lt; minBp {<br />
        cursor = lastCursor<br />
        break<br />
    }<br />
<br />
    ...<br />
}<br />
<br />
return exp, cursor, true The bindingPower function on tokens can be defined for now such that sum and concatenation have the highest binding power, followed by equality operations, then boolean operators, and then everything else at zero.<br />
</code></pre></div></div><br />
<br />
<p>func (t token) bindingPower() uint {<br />
    switch t.kind {<br />
    case keywordKind:<br />
        switch keyword(t.value) {<br />
        case andKeyword:<br />
            fallthrough<br />
        case orKeyword:<br />
            return 1<br />
        }<br />
    case symbolKind:<br />
        switch symbol(t.value) {<br />
        case eqSymbol:<br />
            fallthrough<br />
        case neqSymbol:<br />
            fallthrough<br />
        case concatSymbol:<br />
            fallthrough<br />
        case plusSymbol:<br />
            return 3<br />
        }<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return 0 } Back in parseExpression, if the new operator has greater binding power we'll parse the next operand expression (a recursive call, passing the binding power of the new operator as the new minBp).<br />
</code></pre></div></div><br />
<br />
<p>Upon completion, the current expression (the return value of the recursive call) is set to a new binary expression containing the previously current expression on the left and the just-parsed expression on the right.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    ...<br />
<br />
    b, newCursor, ok := parseExpression(tokens, cursor, delimiters, bp)<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected right operand")<br />
        return nil, initialCursor, false<br />
    }<br />
    exp = &amp;expression{<br />
        binary: &amp;binaryExpression{<br />
            *exp,<br />
            *b,<br />
            *op,<br />
        },<br />
        kind: binaryKind,<br />
    }<br />
    cursor = newCursor<br />
    lastCursor = cursor<br />
}<br />
<br />
return exp, cursor, true } To reiterate, it is expected that each external caller of parseExpression passes 0 as the default minBp.<br />
</code></pre></div></div><br />
<br />
<p>All together:</p><br />
<br />
<p>func parseExpression(tokens []<em>token, initialCursor uint, delimiters []token, minBp uint) (</em>expression, uint, bool) {<br />
    cursor := initialCursor</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var exp *expression<br />
_, newCursor, ok := parseToken(tokens, cursor, tokenFromSymbol(leftParenSymbol))<br />
if ok {<br />
    cursor = newCursor<br />
    rightParenToken := tokenFromSymbol(rightParenSymbol)<br />
<br />
    exp, cursor, ok = parseExpression(tokens, cursor, append(delimiters, rightParenToken), minBp)<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected expression after opening paren")<br />
        return nil, initialCursor, false<br />
    }<br />
<br />
    _, cursor, ok = parseToken(tokens, cursor, rightParenToken)<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected closing paren")<br />
        return nil, initialCursor, false<br />
    }<br />
} else {<br />
    exp, cursor, ok = parseLiteralExpression(tokens, cursor)<br />
    if !ok {<br />
        return nil, initialCursor, false<br />
    }<br />
}<br />
<br />
lastCursor := cursor outer:<br />
for cursor &lt; uint(len(tokens)) {<br />
    for _, d := range delimiters {<br />
        _, _, ok = parseToken(tokens, cursor, d)<br />
        if ok {<br />
            break outer<br />
        }<br />
    }<br />
<br />
    binOps := []token{<br />
        tokenFromKeyword(andKeyword),<br />
        tokenFromKeyword(orKeyword),<br />
        tokenFromSymbol(eqSymbol),<br />
        tokenFromSymbol(neqSymbol),<br />
        tokenFromSymbol(concatSymbol),<br />
        tokenFromSymbol(plusSymbol),<br />
    }<br />
<br />
    var op *token = nil<br />
    for _, bo := range binOps {<br />
        var t *token<br />
        t, cursor, ok = parseToken(tokens, cursor, bo)<br />
        if ok {<br />
            op = t<br />
            break<br />
        }<br />
    }<br />
<br />
    if op == nil {<br />
        helpMessage(tokens, cursor, "Expected binary operator")<br />
        return nil, initialCursor, false<br />
    }<br />
<br />
    bp := op.bindingPower()<br />
    if bp &lt; minBp {<br />
        cursor = lastCursor<br />
        break<br />
    }<br />
<br />
    b, newCursor, ok := parseExpression(tokens, cursor, delimiters, bp)<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected right operand")<br />
        return nil, initialCursor, false<br />
    }<br />
    exp = &amp;expression{<br />
        binary: &amp;binaryExpression{<br />
            *exp,<br />
            *b,<br />
            *op,<br />
        },<br />
        kind: binaryKind,<br />
    }<br />
    cursor = newCursor<br />
    lastCursor = cursor<br />
}<br />
<br />
return exp, cursor, true } Now that we have this general parse expression helper in place, we can add support for parsing WHERE in SELECT statements.<br />
</code></pre></div></div><br />
<br />
<p>Parsing WHERE<br />
This part’s pretty easy. We modify the existing parseSelectStatement to search for an optional WHERE token followed by an expression.</p><br />
<br />
<p>func parseSelectStatement(tokens []<em>token, initialCursor uint, delimiter token) (</em>SelectStatement, uint, bool) {<br />
    var ok bool<br />
    cursor := initialCursor<br />
    _, cursor, ok = parseToken(tokens, cursor, tokenFromKeyword(selectKeyword))<br />
    if !ok {<br />
        return nil, initialCursor, false<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slct := SelectStatement{}<br />
<br />
fromToken := tokenFromKeyword(fromKeyword)<br />
item, newCursor, ok := parseSelectItem(tokens, cursor, []token{fromToken, delimiter})<br />
if !ok {<br />
    return nil, initialCursor, false<br />
}<br />
<br />
slct.item = item<br />
cursor = newCursor<br />
<br />
whereToken := tokenFromKeyword(whereKeyword)<br />
delimiters := []token{delimiter, whereToken}<br />
<br />
_, cursor, ok = parseToken(tokens, cursor, fromToken)<br />
if ok {<br />
    from, newCursor, ok := parseFromItem(tokens, cursor, delimiters)<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected FROM item")<br />
        return nil, initialCursor, false<br />
    }<br />
<br />
    slct.from = from<br />
    cursor = newCursor<br />
}<br />
<br />
_, cursor, ok = parseToken(tokens, cursor, whereToken)<br />
if ok {<br />
    where, newCursor, ok := parseExpression(tokens, cursor, []token{delimiter}, 0)<br />
    if !ok {<br />
        helpMessage(tokens, cursor, "Expected WHERE conditionals")<br />
        return nil, initialCursor, false<br />
    }<br />
<br />
    slct.where = where<br />
    cursor = newCursor<br />
}<br />
<br />
return &amp;slct, cursor, true } Now we're all done with parsing binary expressions and WHERE filters! If in doubt, refer to parser.go in the project.<br />
</code></pre></div></div><br />
<br />
<p>Re-thinking query execution<br />
In the first post in this series, we didn’t establish any standard way for interpreting an expression in any kind of statement. In SQL though, every expression is always run in the context of a row in a table. We’ll handle cases like SELECT 1 and INSERT INTO users VALUES (1) by creating a table with a single empty row to act as the context.</p><br />
<br />
<p>This requires a bit of re-architecting. So we’ll rewrite the memory.go implementation in this post from scratch.</p><br />
<br />
<p>We’ll also stop panic-ing when things go wrong. Instead we’ll print a message. This allows the REPL loop to keep going.</p><br />
<br />
<p>Memory cells<br />
Again the fundamental blocks of memory in the table will be an untyped array of bytes. We’ll provide conversion methods from this memory cell into integers, strings, and boolean Go values.</p><br />
<br />
<p>type MemoryCell []byte</p><br />
<br />
<p>func (mc MemoryCell) AsInt() int32 {<br />
    var i int32<br />
    err := binary.Read(bytes.NewBuffer(mc), binary.BigEndian, &amp;i)<br />
    if err != nil {<br />
        fmt.Printf(“Corrupted data [%s]: %s\n”, mc, err)<br />
        return 0<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return i }<br />
</code></pre></div></div><br />
<br />
<p>func (mc MemoryCell) AsText() string {<br />
    return string(mc)<br />
}</p><br />
<br />
<p>func (mc MemoryCell) AsBool() bool {<br />
    return len(mc) != 0<br />
}</p><br />
<br />
<p>func (mc MemoryCell) equals(b MemoryCell) bool {<br />
    // Seems verbose but need to make sure if one is nil, the<br />
    // comparison still fails quickly<br />
    if mc == nil || b == nil {<br />
        return mc == nil &amp;&amp; b == nil<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return bytes.Compare(mc, b) == 0 } We'll also extend the Cell interface in backend.go to support the new boolean type.<br />
</code></pre></div></div><br />
<br />
<p>package gosql</p><br />
<br />
<p>type ColumnType uint</p><br />
<br />
<p>const (<br />
    TextType ColumnType = iota<br />
    IntType<br />
    BoolType<br />
)</p><br />
<br />
<p>type Cell interface {<br />
    AsText() string<br />
    AsInt() int32<br />
    AsBool() bool<br />
}</p><br />
<br />
<p>…<br />
Finally, we need a way for mapping a Go value into a memory cell.</p><br />
<br />
<p>func literalToMemoryCell(t *token) MemoryCell {<br />
    if t.kind == numericKind {<br />
        buf := new(bytes.Buffer)<br />
        i, err := strconv.Atoi(t.value)<br />
        if err != nil {<br />
            fmt.Printf(“Corrupted data [%s]: %s\n”, t.value, err)<br />
            return MemoryCell(nil)<br />
        }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // TODO: handle bigint<br />
    err = binary.Write(buf, binary.BigEndian, int32(i))<br />
    if err != nil {<br />
        fmt.Printf("Corrupted data [%s]: %s\n", string(buf.Bytes()), err)<br />
        return MemoryCell(nil)<br />
    }<br />
    return MemoryCell(buf.Bytes())<br />
}<br />
<br />
if t.kind == stringKind {<br />
    return MemoryCell(t.value)<br />
}<br />
<br />
if t.kind == boolKind {<br />
    if t.value == "true" {<br />
        return MemoryCell([]byte{1})<br />
    } else {<br />
        return MemoryCell(nil)<br />
    }<br />
}<br />
<br />
return nil } And we'll provide global true and false values:<br />
</code></pre></div></div><br />
<br />
<p>var (<br />
    trueToken  = token{kind: boolKind, value: “true”}<br />
    falseToken = token{kind: boolKind, value: “false”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trueMemoryCell  = literalToMemoryCell(&amp;trueToken)<br />
falseMemoryCell = literalToMemoryCell(&amp;falseToken) ) Tables A table has a list of rows (an array of memory cells) and a list of column names and types.<br />
</code></pre></div></div><br />
<br />
<p>type table struct {<br />
    columns     []string<br />
    columnTypes []ColumnType<br />
    rows        [][]MemoryCell<br />
}<br />
Finally we’ll add a series of methods on table that, given a row index, interprets an expression AST against that row in the table.</p><br />
<br />
<p>Interpreting literals<br />
First we’ll implement evaluateLiteralCell that will look up an identifier or return the value of integers, strings, and booleans.</p><br />
<br />
<p>func (t *table) evaluateLiteralCell(rowIndex uint, exp expression) (MemoryCell, string, ColumnType, error) {<br />
    if exp.kind != literalKind {<br />
        return nil, “”, 0, ErrInvalidCell<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lit := exp.literal<br />
if lit.kind == identifierKind {<br />
    for i, tableCol := range t.columns {<br />
        if tableCol == lit.value {<br />
            return t.rows[rowIndex][i], tableCol, t.columnTypes[i], nil<br />
        }<br />
    }<br />
<br />
    return nil, "", 0, ErrColumnDoesNotExist<br />
}<br />
<br />
columnType := IntType<br />
if lit.kind == stringKind {<br />
    columnType = TextType<br />
} else if lit.kind == boolKind {<br />
    columnType = BoolType<br />
}<br />
<br />
return literalToMemoryCell(lit), "?column?", columnType, nil } Interpreting binary expressions Now we can implement evaluateBinaryCell that will evaluate it's two sub-expressions and combine them together according to the operator. The SQL operators we have defined so far do no coercion. So we'll fail immediately if the two sides of the operation are not of the same type. Additionally, the concatenation and addition operators require that their arguments are strings and numbers, respectively.<br />
</code></pre></div></div><br />
<br />
<p>func (t *table) evaluateBinaryCell(rowIndex uint, exp expression) (MemoryCell, string, ColumnType, error) {<br />
    if exp.kind != binaryKind {<br />
        return nil, “”, 0, ErrInvalidCell<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bexp := exp.binary<br />
<br />
l, _, lt, err := t.evaluateCell(rowIndex, bexp.a)<br />
if err != nil {<br />
    return nil, "", 0, err<br />
}<br />
<br />
r, _, rt, err := t.evaluateCell(rowIndex, bexp.b)<br />
if err != nil {<br />
    return nil, "", 0, err<br />
}<br />
<br />
switch bexp.op.kind {<br />
case symbolKind:<br />
    switch symbol(bexp.op.value) {<br />
    case eqSymbol:<br />
        eq := l.equals(r)<br />
        if lt == TextType &amp;&amp; rt == TextType &amp;&amp; eq {<br />
            return trueMemoryCell, "?column?", BoolType, nil<br />
        }<br />
<br />
        if lt == IntType &amp;&amp; rt == IntType &amp;&amp; eq {<br />
            return trueMemoryCell, "?column?", BoolType, nil<br />
        }<br />
<br />
        if lt == BoolType &amp;&amp; rt == BoolType &amp;&amp; eq {<br />
            return trueMemoryCell, "?column?", BoolType, nil<br />
        }<br />
<br />
        return falseMemoryCell, "?column?", BoolType, nil<br />
    case neqSymbol:<br />
        if lt != rt || !l.equals(r) {<br />
            return trueMemoryCell, "?column?", BoolType, nil<br />
        }<br />
<br />
        return falseMemoryCell, "?column?", BoolType, nil<br />
    case concatSymbol:<br />
        if lt != TextType || rt != TextType {<br />
            return nil, "", 0, ErrInvalidOperands<br />
        }<br />
<br />
        return literalToMemoryCell(&amp;token{kind: stringKind, value: l.AsText() + r.AsText()}), "?column?", TextType, nil<br />
    case plusSymbol:<br />
        if lt != IntType || rt != IntType {<br />
            return nil, "", 0, ErrInvalidOperands<br />
        }<br />
<br />
        iValue := int(l.AsInt() + r.AsInt())<br />
        return literalToMemoryCell(&amp;token{kind: numericKind, value: strconv.Itoa(iValue)}), "?column?", IntType, nil<br />
    default:<br />
        // TODO<br />
        break<br />
    }<br />
case keywordKind:<br />
    switch keyword(bexp.op.value) {<br />
    case andKeyword:<br />
        if lt != BoolType || rt != BoolType {<br />
            return nil, "", 0, ErrInvalidOperands<br />
        }<br />
<br />
        res := falseMemoryCell<br />
        if l.AsBool() &amp;&amp; r.AsBool() {<br />
            res = trueMemoryCell<br />
        }<br />
<br />
        return res, "?column?", BoolType, nil<br />
    case orKeyword:<br />
        if lt != BoolType || rt != BoolType {<br />
            return nil, "", 0, ErrInvalidOperands<br />
        }<br />
<br />
        res := falseMemoryCell<br />
        if l.AsBool() || r.AsBool() {<br />
            res = trueMemoryCell<br />
        }<br />
<br />
        return res, "?column?", BoolType, nil<br />
    default:<br />
        // TODO<br />
        break<br />
    }<br />
}<br />
<br />
return nil, "", 0, ErrInvalidCell } Then we'll provide a generic evaluateCell method to wrap these two correctly:<br />
</code></pre></div></div><br />
<br />
<p>func (t *table) evaluateCell(rowIndex uint, exp expression) (MemoryCell, string, ColumnType, error) {<br />
    switch exp.kind {<br />
        case literalKind:<br />
            return t.evaluateLiteralCell(rowIndex, exp)<br />
        case binaryKind:<br />
            return t.evaluateBinaryCell(rowIndex, exp)<br />
        default:<br />
            return nil, “”, 0, ErrInvalidCell<br />
    }<br />
}<br />
Implementing SELECT<br />
As before, each statement will operate on a backend of tables.</p><br />
<br />
<p>type MemoryBackend struct {<br />
    tables map[string]*table<br />
}</p><br />
<br />
<p>func NewMemoryBackend() <em>MemoryBackend {<br />
    return &amp;MemoryBackend{<br />
        tables: map[string]</em>table{},<br />
    }<br />
}<br />
When we implement SELECT, we’ll iterate over each row in the table (we only support looking up one table for now). If the SELECT statement contains a WHERE block, we’ll evaluate the WHERE expression against the current row and move on if the result is false.</p><br />
<br />
<p>Otherwise for each expression in the SELECT list of items we’ll evaluate it against the current row in the table.</p><br />
<br />
<p>If there is no table selected, we provide a fake table with a single empty row.</p><br />
<br />
<p>func (mb <em>MemoryBackend) Select(slct *SelectStatement) (</em>Results, error) {<br />
    t := &amp;table{}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if slct.from != nil &amp;&amp; slct.from.table != nil {<br />
    var ok bool<br />
    t, ok = mb.tables[slct.from.table.value]<br />
    if !ok {<br />
        return nil, ErrTableDoesNotExist<br />
    }<br />
}<br />
<br />
if slct.item == nil || len(*slct.item) == 0 {<br />
    return &amp;Results{}, nil<br />
}<br />
<br />
results := [][]Cell{}<br />
columns := []struct {<br />
    Type ColumnType<br />
    Name string<br />
}{}<br />
<br />
if slct.from == nil {<br />
    t = &amp;table{}<br />
    t.rows = [][]MemoryCell\{\{\}\}<br />
}<br />
<br />
for i := range t.rows {<br />
    result := []Cell{}<br />
    isFirstRow := len(results) == 0<br />
<br />
    if slct.where != nil {<br />
        val, _, _, err := t.evaluateCell(uint(i), *slct.where)<br />
        if err != nil {<br />
            return nil, err<br />
        }<br />
<br />
        if !val.AsBool() {<br />
            continue<br />
        }<br />
    }<br />
<br />
    for _, col := range *slct.item {<br />
        if col.asterisk {<br />
            // TODO: handle asterisk<br />
            fmt.Println("Skipping asterisk.")<br />
            continue<br />
        }<br />
<br />
        value, columnName, columnType, err := t.evaluateCell(uint(i), *col.exp)<br />
        if err != nil {<br />
            return nil, err<br />
        }<br />
<br />
        if isFirstRow {<br />
            columns = append(columns, struct {<br />
                Type ColumnType<br />
                Name string<br />
            }{<br />
                Type: columnType,<br />
                Name: columnName,<br />
            })<br />
        }<br />
<br />
        result = append(result, value)<br />
    }<br />
<br />
    results = append(results, result)<br />
}<br />
<br />
return &amp;Results{<br />
    Columns: columns,<br />
    Rows:    results,<br />
}, nil } Implementing INSERT, CREATE The INSERT and CREATE statements stay mostly the same except for that we'll use the evaluateCell help for every expression. Refer back to the first post if the implementation is otherwise unclear.<br />
</code></pre></div></div><br />
<br />
<p>func (mb *MemoryBackend) Insert(inst *InsertStatement) error {<br />
    t, ok := mb.tables[inst.table.value]<br />
    if !ok {<br />
        return ErrTableDoesNotExist<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if inst.values == nil {<br />
    return nil<br />
}<br />
<br />
row := []MemoryCell{}<br />
<br />
if len(*inst.values) != len(t.columns) {<br />
    return ErrMissingValues<br />
}<br />
<br />
for _, value := range *inst.values {<br />
    if value.kind != literalKind {<br />
        fmt.Println("Skipping non-literal.")<br />
        continue<br />
    }<br />
<br />
    emptyTable := &amp;table{}<br />
    value, _, _, err := emptyTable.evaluateCell(0, *value)<br />
    if err != nil {<br />
        return err<br />
    }<br />
<br />
    row = append(row, value)<br />
}<br />
<br />
t.rows = append(t.rows, row)<br />
return nil }<br />
</code></pre></div></div><br />
<br />
<p>func (mb *MemoryBackend) CreateTable(crt *CreateTableStatement) error {<br />
    t := table{}<br />
    mb.tables[crt.name.value] = &amp;t<br />
    if crt.cols == nil {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    return nil<br />
}<br />
<br />
for _, col := range *crt.cols {<br />
    t.columns = append(t.columns, col.name.value)<br />
<br />
    var dt ColumnType<br />
    switch col.datatype.value {<br />
    case "int":<br />
        dt = IntType<br />
    case "text":<br />
        dt = TextType<br />
    default:<br />
        return ErrInvalidDatatype<br />
    }<br />
<br />
    t.columnTypes = append(t.columnTypes, dt)<br />
}<br />
<br />
return nil } Back to the REPL Putting it all together, we run the following session:<br />
</code></pre></div></div><br />
<br />
<h1 id="create-table-users-name-text-age-int-1">CREATE TABLE users (name TEXT, age INT);</h1><br />
<p>ok</p><br />
<h1 id="insert-into-users-values-stephen-16-1">INSERT INTO users VALUES (‘Stephen’, 16);</h1><br />
<p>ok</p><br />
<h1 id="select-name-age-from-users-1">SELECT name, age FROM users;</h1><br />
<p>name   | age<br />
———-+——<br />
Stephen |  16<br />
(1 result)<br />
ok</p><br />
<h1 id="insert-into-users-values-adrienne-23-1">INSERT INTO users VALUES (‘Adrienne’, 23);</h1><br />
<p>ok</p><br />
<h1 id="select-age--2-name-from-users-where-age--23-1">SELECT age + 2, name FROM users WHERE age = 23;</h1><br />
<p>age |   name<br />
——+———–<br />
25 | Adrienne<br />
(1 result)<br />
ok</p><br />
<h1 id="select-name-from-users-1">SELECT name FROM users;</h1><br />
<p>name<br />
————<br />
Stephen<br />
Adrienne<br />
(2 results)<br />
ok<br />
And that’s it for now! In future posts we’ll get into indices, joining tables, etc.</p><br />
<br />
<p>Comment<br />
Please reply on Twitter with questions or comments.</p><br />
<br />
<p>Latest post up in the database basics series: adding support for binary expressions and WHERE filtering in SELECTs.</p><br />
<br />
<p>Much nicer to have a real table rendering library and readline implementation in the REPL too.https://t.co/GYzn3FUNon</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>