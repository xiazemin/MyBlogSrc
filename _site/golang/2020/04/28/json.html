<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">json</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-04-28T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 28, 2020</time></p>
					</div>
					 <p>JSON（JavaScript 对象表示，JavaScript Object Notation）作为一种轻量级的数据交换格式1，在今天几乎占据了绝大多数的市场份额。虽然与更紧凑的数据交换格式相比，它的序列化和反序列化性能不足，但是它也提供了良好的可读性与易用性，在不追求机制性能的情况下，JSON 是一种非常好的选择。</p><br />
<br />
<p>9.1.1 设计原理<br />
几乎所有的现代编程语言都会将处理 JSON 的函数直接纳入标准库，Go 语言也不例外，它通过 encoding/json 对外提供标准的 JSON 序列化和反序列化方法，即 encoding/json.Marshal 和 encoding/json.Unmarshal，它们也是包中最常用的两个方法。<br />
https://draveness.me/golang/docs/part4-advanced/ch09-stdlib/golang-json/<br />
<!-- more --><br />
图 9-1 序列化和反序列化</p><br />
<br />
<p>序列化和反序列化的开销完全不同，JSON 反序列化的开销是序列化开销的好几倍，相信这背后的原因也非常好理解。Go 语言中的 JSON 序列化过程不需要被序列化的对象预先实现任何接口，它会通过反射获取结构体或者数组中的值并以树形的结构递归地进行编码，标准库也会根据 encoding/json.Unmarshal 中传入的值对 JSON 进行解码。</p><br />
<br />
<p>Go 语言 JSON 标准库编码和解码的过程大量地运用了反射这一特性，你会在本节的后半部分看到大量的反射代码，这里就不过多介绍了。我们在这里会简单介绍 JSON 标准库中的接口和标签，这是它为开发者提供的为数不多的影响编解码过程的接口。</p><br />
<br />
<p>接口<br />
JSON 标准库中提供了 encoding/json.Marshaler 和 encoding/json.Unmarshaler 两个接口分别可以影响 JSON 的序列化和反序列化结果：</p><br />
<br />
<p>type Marshaler interface {<br />
	MarshalJSON() ([]byte, error)<br />
}</p><br />
<br />
<p>type Unmarshaler interface {<br />
	UnmarshalJSON([]byte) error<br />
}<br />
在 JSON 序列化和反序列化的过程中，它们会使用反射判断结构体类型是否实现了上述接口，如果实现了上述接口就会优先使用对应的方法进行编码和解码操作，除了这两个方法之外，Go 语言其实还提供了另外两个用于控制编解码结果的方法，即 encoding.TextMarshaler 和 encoding.TextUnmarshaler：</p><br />
<br />
<p>type TextMarshaler interface {<br />
	MarshalText() (text []byte, err error)<br />
}</p><br />
<br />
<p>type TextUnmarshaler interface {<br />
	UnmarshalText(text []byte) error<br />
}<br />
一旦发现 JSON 相关的序列化方法没有被实现，上述两个方法会作为候选方法被 JSON 标准库调用，参与编解码的过程。总得来说，我们可以在任意类型上实现上述这四个方法自定义最终的结果，后面的两个方法的适用范围更广，但是不会被 JSON 标准库优先调用。</p><br />
<br />
<p>标签<br />
Go 语言的结构体标签也是一个比较有趣的功能，在默认情况下，当我们在序列化和反序列化结构体时，标准库都会认为字段名和 JSON 中的键具有一一对应的关系，然而 Go 语言的字段一般都是驼峰命名法，JSON 中下划线的命名方式相对比较常见，所以使用标签这一特性直接建立键与字段之间的映射关系是一个非常方便的设计。</p><br />
<br />
<p>struct-and-json</p><br />
<br />
<p>图 9-2 结构体与 JSON 的映射</p><br />
<br />
<p>JSON 中的标签由两部分组成，如下所示的 name 和 age 都是标签名，后面的所有的字符串是标签选项，即 encoding/json.tagOptions，标签名和字段名会建立一一对应的关系，后面的标签选项也会影响编解码的过程：</p><br />
<br />
<p>type Author struct {<br />
    Name string <code class="language-plaintext highlighter-rouge">json:"name,omitempty"</code><br />
    Age  int32  <code class="language-plaintext highlighter-rouge">json:"age,string,omitempty"</code><br />
}<br />
常见的两个标签是 string 和 omitempty，前者表示当前的整数或者浮点数是由 JSON 中的字符串表示的，而另一个字段 omitempty 会在字段为零值时，直接在生成的 JSON 中忽略对应的键值对，例如：”age”: 0、”author”: “” 等。标准库会使用 encoding/json.parseTag 函数来解析标签：</p><br />
<br />
<p>func parseTag(tag string) (string, tagOptions) {<br />
	if idx := strings.Index(tag, “,”); idx != -1 {<br />
		return tag[:idx], tagOptions(tag[idx+1:])<br />
	}<br />
	return tag, tagOptions(“”)<br />
}<br />
从该方法的实现中，我们能分析出 JSON 标准库中的合法标签是什么形式的 — 标签名和标签选项都以 , 连接，最前面的字符串为标签名，后面的都是标签选项。</p><br />
<br />
<p>9.1.2 序列化<br />
encoding/json.Marshal 是 JSON 标准库中提供的最简单的序列化函数，它会接收一个 interface{} 类型的值作为参数，这也意味着几乎全部的 Go 语言变量都可以被 JSON 标准库序列化，为了提供如此复杂和通用的功能，在静态语言中使用反射是常见的选项，我们来深入了解一下该方法的实现：</p><br />
<br />
<p>func Marshal(v interface{}) ([]byte, error) {<br />
	e := newEncodeState()<br />
	err := e.marshal(v, encOpts{escapeHTML: true})<br />
	if err != nil {<br />
		return nil, err<br />
	}<br />
	buf := append([]byte(nil), e.Bytes()…)<br />
	encodeStatePool.Put(e)<br />
	return buf, nil<br />
}<br />
上述方法会调用 encoding/json.newEncodeState 从全局的编码状态池中获取 encoding/json.encodeState，随后的序列化过程都会使用这个编码状态，该结构体也会在编码结束后被重新放回池中以便重复利用。</p><br />
<br />
<p>json-marshal-call-stack</p><br />
<br />
<p>图 9-3 序列化调用栈</p><br />
<br />
<p>按照如上所示的复杂调用栈，一系列的序列化方法在最后获取了对象的反射类型并调用了 encoding/json.newTypeEncoder 这个核心的编码方法，该方法会递归地为所有的类型找到对应的编码方法，不过它的执行过程可以分成以下两个步骤：</p><br />
<br />
<p>获取用户自定义的 encoding/json.Marshaler 或者 encoding.TextMarshaler 编码器；<br />
获取标准库中为基本类型内置的 JSON 编码器；<br />
在该方法的第一部分，我们会检查当前值的类型是否可以使用用户自定义的编码器，这里有两种不同的判断方法：</p><br />
<br />
<p>func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc {<br />
	if t.Kind() != reflect.Ptr &amp;&amp; allowAddr &amp;&amp; reflect.PtrTo(t).Implements(marshalerType) {<br />
		return newCondAddrEncoder(addrMarshalerEncoder, newTypeEncoder(t, false))<br />
	}<br />
	if t.Implements(marshalerType) {<br />
		return marshalerEncoder<br />
	}<br />
	if t.Kind() != reflect.Ptr &amp;&amp; allowAddr &amp;&amp; reflect.PtrTo(t).Implements(textMarshalerType) {<br />
		return newCondAddrEncoder(addrTextMarshalerEncoder, newTypeEncoder(t, false))<br />
	}<br />
	if t.Implements(textMarshalerType) {<br />
		return textMarshalerEncoder<br />
	}<br />
	…<br />
}<br />
如果当前值是值类型、可以取地址并且值类型对应的指针类型实现了 encoding/json.Marshaler 接口，调用 encoding/json.newCondAddrEncoder 获取一个条件编码器，条件编码器会在 encoding/json.addrMarshalerEncoder 失败时重新选择新的编码器；<br />
如果当前类型实现了 encoding/json.Marshaler 接口，可以直接使用 encoding/json.marshalerEncoder 对该值进行序列化；<br />
在这段代码中，标准库对 encoding.TextMarshaler 的处理也几乎完全相同，只是它会先判断 encoding/json.Marshaler 接口，这也印证了我们在设计原理一节中的结论。</p><br />
<br />
<p>encoding/json.newTypeEncoder 方法随后会根据传入值的反射类型获取对应的编码器，其中包括 bool、int、float 等基本类型编码器等和数组、结构体、切片等复杂类型的编码器：</p><br />
<br />
<p>func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc {<br />
	…<br />
	switch t.Kind() {<br />
	case reflect.Bool:<br />
		return boolEncoder<br />
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<br />
		return intEncoder<br />
	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<br />
		return uintEncoder<br />
	case reflect.Float32:<br />
		return float32Encoder<br />
	case reflect.Float64:<br />
		return float64Encoder<br />
	case reflect.String:<br />
		return stringEncoder<br />
	case reflect.Interface:<br />
		return interfaceEncoder<br />
	case reflect.Struct:<br />
		return newStructEncoder(t)<br />
	case reflect.Map:<br />
		return newMapEncoder(t)<br />
	case reflect.Slice:<br />
		return newSliceEncoder(t)<br />
	case reflect.Array:<br />
		return newArrayEncoder(t)<br />
	case reflect.Ptr:<br />
		return newPtrEncoder(t)<br />
	default:<br />
		return unsupportedTypeEncoder<br />
	}<br />
}<br />
我们在这里就不一一介绍全部的内置类型编码器了，只挑选其中的几个帮助各位读者了解整体的设计。首先我们来看布尔值的 JSON 编码器，它的实现很简单，甚至没有太多值得介绍的地方：</p><br />
<br />
<p>func boolEncoder(e *encodeState, v reflect.Value, opts encOpts) {<br />
	if opts.quoted {<br />
		e.WriteByte(‘”’)<br />
	}<br />
	if v.Bool() {<br />
		e.WriteString(“true”)<br />
	} else {<br />
		e.WriteString(“false”)<br />
	}<br />
	if opts.quoted {<br />
		e.WriteByte(‘”’)<br />
	}<br />
}<br />
它会根据当前值向编码状态中写入不同的字符串，也就是 true 或者 false，除此之外还会根据编码配置决定是否要在布尔值周围写入双引号 “，而其他的基本类型编码器也都大同小异。</p><br />
<br />
<p>复杂类型的编码器有着相对复杂的控制结构，我们在这里以结构体的编码器 encoding/json.structEncoder 为例介绍它们的原理，encoding/json.newStructEncoder 会为当前结构体的所有字段调用 encoding/json.typeEncoder 获取类型编码器并返回 encoding/json.structEncoder.encode 方法：</p><br />
<br />
<p>func newStructEncoder(t reflect.Type) encoderFunc {<br />
	se := structEncoder{fields: cachedTypeFields(t)}<br />
	return se.encode<br />
}<br />
从 encoding/json.structEncoder.encode 的实现我们能看出结构体序列的结果，该方法会遍历结构体中的全部字段，在写入了字段名后，它会调用字段对应类型的编码方法将该字段对应的 JSON 写入缓冲区：</p><br />
<br />
<p>func (se structEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {<br />
	next := byte(‘{‘)<br />
FieldLoop:<br />
	for i := range se.fields.list {<br />
		f := &amp;se.fields.list[i]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	fv := v<br />
	for _, i := range f.index {<br />
		if fv.Kind() == reflect.Ptr {<br />
			if fv.IsNil() {<br />
				continue FieldLoop<br />
			}<br />
			fv = fv.Elem()<br />
		}<br />
		fv = fv.Field(i)<br />
	}<br />
<br />
	if f.omitEmpty &amp;&amp; isEmptyValue(fv) {<br />
		continue<br />
	}<br />
	e.WriteByte(next)<br />
	next = ','<br />
	e.WriteString(f.nameNonEsc)<br />
	opts.quoted = f.quoted<br />
	f.encoder(e, fv, opts)<br />
}<br />
if next == '{' {<br />
	e.WriteString("{}")<br />
} else {<br />
	e.WriteByte('}')<br />
} } 数组以及指针等编码器的实现原理与该方法也没有太多的区别，它们都会使用类似的策略递归地调用持有字段的编码方法，这也就能形成一个如下图所示的树形结构：<br />
</code></pre></div></div><br />
<br />
<p>struct-encoder</p><br />
<br />
<p>图 9-4 序列化与树形结构体</p><br />
<br />
<p>树形结构的所有叶节点都是基础类型编码器或者开发者自定义的编码器，得到了整棵树的编码器之后会调用 encoding/json.encodeState.reflectValue 从根节点依次调用整棵树的序列化函数，整个 JSON 序列化的过程其实是查找类型和子类型的编码方法并调用的过程，它利用了大量反射的特性做到了足够的通用。</p><br />
<br />
<p>9.1.3 反序列化<br />
标准库会使用 encoding/json.Unmarshal 函数处理 JSON 的反序列化，与执行过程确定的序列化相比，反序列化的过程比较像一个逐渐探索的过程，所以会复杂很多，开销也会高出几倍。因为 Go 语言的表达能力比较有限，反序列化的使用相对比较繁琐，需要传入一个变量帮助标准库进行反序列化：</p><br />
<br />
<p>func Unmarshal(data []byte, v interface{}) error {<br />
	var d decodeState<br />
	err := checkValid(data, &amp;d.scan)<br />
	if err != nil {<br />
		return err<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d.init(data)<br />
return d.unmarshal(v) } 在真正执行反序列化之前，我们会先调用 encoding/json.checkValid 验证传入 JSON 的合法性保证在反序列化的过程中不会遇到语法错误的问题，在通过合法性的验证之后，标准库就会初始化数据并调用 encoding/json.decodeState.unmarshal 开始反序列化了：<br />
</code></pre></div></div><br />
<br />
<p>func (d *decodeState) unmarshal(v interface{}) error {<br />
	rv := reflect.ValueOf(v)<br />
	if rv.Kind() != reflect.Ptr || rv.IsNil() {<br />
		return &amp;InvalidUnmarshalError{reflect.TypeOf(v)}<br />
	}<br />
	d.scan.reset()<br />
	d.scanWhile(scanSkipSpace)<br />
	err := d.value(rv)<br />
	if err != nil {<br />
		return d.addErrorContext(err)<br />
	}<br />
	return d.savedError<br />
}<br />
如果传入的值不是指针或者是空指针，当前方法就会返回我们经常会见到的错误 encoding/json.InvalidUnmarshalError，使用格式化输出可以将该错误转换成 json: Unmarshal(non-pointer xxx)。该方法调用的 encoding/json.decodeState.value 是所有反序列化过程的执行入口：</p><br />
<br />
<p>func (d *decodeState) value(v reflect.Value) error {<br />
	switch d.opcode {<br />
	default:<br />
		panic(phasePanicMsg)<br />
	case scanBeginArray:<br />
		…<br />
	case scanBeginLiteral:<br />
		…<br />
	case scanBeginObject:<br />
		if v.IsValid() {<br />
			if err := d.object(v); err != nil {<br />
				return err<br />
			}<br />
		} else {<br />
			d.skip()<br />
		}<br />
		d.scanNext()<br />
	}<br />
	return nil<br />
}<br />
该方法作为最顶层的反序列化方法可以接收三种不同类型的值，也就是数组、字面量和对象，这三种类型都可以作为 JSON 的顶层对象，我们首先来了解一下标准库是如何解析 JSON 中对象的，该过程会使用 encoding/json.decodeState.object 函数进行反序列化，它会先调用 encoding/json.indirect 函数查找当前类型对应的非指针类型：</p><br />
<br />
<p>func (d <em>decodeState) object(v reflect.Value) error {<br />
	u, ut, pv := indirect(v, false)<br />
	if u != nil {<br />
		start := d.readIndex()<br />
		d.skip()<br />
		return u.UnmarshalJSON(d.data[start:d.off])<br />
	}<br />
	…<br />
}<br />
在调用 encoding/json.indirect 的过程中，如果当前值的类型是 **Type，那么它会依次检查形如 **Type、</em>Type 和 Type 类型是否实现了 encoding/json.Unmarshal 或者 encoding.TextUnmarshaler 接口；如果实现了该接口，标准库会直接调用 UnmarshalJSON 方法使用开发者定义的方法完成反序列化。</p><br />
<br />
<p>在其他情况下，我们仍然会回到默认的逻辑中处理对象中的键值对，如下所示的代码会调用 encoding/json.decodeState.rescanLiteral 方法扫描 JSON 中的键并在结构体中找到对应字段的反射值，接下来继续扫描符号 : 并调用 encoding/json.decodeState.value 解析对应的值：</p><br />
<br />
<p>func (d *decodeState) object(v reflect.Value) error {<br />
	…<br />
	v = pv<br />
	t := v.Type()<br />
	fields = cachedTypeFields(t)<br />
	for {<br />
		start := d.readIndex()<br />
		d.rescanLiteral()<br />
		item := d.data[start:d.readIndex()]<br />
		key, _ := d.unquoteBytes(item)<br />
		var subv reflect.Value<br />
		var f *field<br />
		if i, ok := fields.nameIndex[string(key)]; ok {<br />
			f = &amp;fields.list[i]<br />
		}<br />
		if f != nil {<br />
			subv = v<br />
			for _, i := range f.index {<br />
				subv = subv.Field(i)<br />
			}<br />
		}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	if d.opcode != scanObjectKey {<br />
		panic(phasePanicMsg)<br />
	}<br />
	d.scanWhile(scanSkipSpace)<br />
<br />
	if err := d.value(subv); err != nil {<br />
		return err<br />
	}<br />
	if d.opcode == scanEndObject {<br />
		break<br />
	}<br />
}<br />
return nil } 当上述方法调用 encoding/json.decodeState.value 时，该方法会重新判断键对应的值是否是对象、数组或者字面量，因为数组和对象都是集合类型，所以该方法会递归地进行扫描，在这里也就不再继续介绍这些集合类型的解析过程了，我们来简单分析一下字面量是如何被处理的：<br />
</code></pre></div></div><br />
<br />
<p>func (d *decodeState) value(v reflect.Value) error {<br />
	switch d.opcode {<br />
	default:<br />
		panic(phasePanicMsg)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case scanBeginArray:<br />
	...<br />
case scanBeginObject:<br />
	...<br />
case scanBeginLiteral:<br />
	start := d.readIndex()<br />
	d.rescanLiteral()<br />
	if v.IsValid() {<br />
		if err := d.literalStore(d.data[start:d.readIndex()], v, false); err != nil {<br />
			return err<br />
		}<br />
	}<br />
}<br />
return nil } 字面量的扫描会通过 encoding/json.decodeState.rescanLiteral，该方法会依次扫描缓冲区中的字符并根据字符的不同对字符串进行切片，整个过程有点像编译器的词法分析：<br />
</code></pre></div></div><br />
<br />
<p>func (d *decodeState) rescanLiteral() {<br />
	data, i := d.data, d.off<br />
Switch:<br />
	switch data[i-1] {<br />
	case ‘”’: // string<br />
		…<br />
	case ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’, ‘-‘: // number<br />
		…<br />
	case ‘t’: // true<br />
		i += len(“rue”)<br />
	case ‘f’: // false<br />
		i += len(“alse”)<br />
	case ‘n’: // null<br />
		i += len(“ull”)<br />
	}<br />
	if i &lt; len(data) {<br />
		d.opcode = stateEndValue(&amp;d.scan, data[i])<br />
	} else {<br />
		d.opcode = scanEnd<br />
	}<br />
	d.off = i + 1<br />
}<br />
因为 JSON 中的字面量其实也只包含字符串、数字、布尔值和空值几种，所以该方法的实现也不会特别复杂，当该方法扫描了对应的字面量之后，就会调用 encoding/json.decodeState.literalStore 字面量存储到反射类型变量所在的地址中，在这个过程中会调用反射的 reflect.Value.SetInt、reflect.Value.SetFloat 和 reflect.Value.SetBool 等方法。</p><br />
<br />
<p>9.1.4 小结<br />
JSON 本身就是一种树形的数据结构，无论是序列化还是反序列化，都会遵循自顶向下的编码和解码过程，使用递归的方式处理 JSON 对象。作为标准库的 JSON 提供的接口非常简洁，虽然它的性能一直被开发者所诟病，但是作为框架它提供了很好的通用性，通过分析 JSON 库的实现，我们也可以从中学习到使用反射的各种方法。</p><br />
<br />
<p>https://www.json.org/json-en.html</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>