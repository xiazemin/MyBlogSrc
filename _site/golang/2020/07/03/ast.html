<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">ast</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-07-03T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jul 3, 2020</time></p>
					</div>
					 <p>我们拿到一个golang的工程后（通常是个微服务），怎么从词法、语法的角度来分析源代码呢？golang提供了一系列的工具供我们使用：</p><br />
<br />
<p>go/scanner包提供词法分析功能，将源代码转换为一系列的token，以供go/parser使用<br />
go/parser包提供语法分析功能，将这些token转换为AST（Abstract Syntax Tree, 抽象语法树）<br />
Scanner<br />
任何编译器所做的第一步都是将源代码转换成token，这就是Scanner所做的事<br />
token可以是关键字，字符串值，变量名以及函数名等等<br />
在golang中，每个token都以它所处的位置，类型和原始字面量来表示</p><br />
<br />
<p>https://www.jianshu.com/p/937d649039ec<br />
<!-- more --><br />
AST的结构定义<br />
go/ast/ast.go中指明了ast节点的定义：</p><br />
<br />
<p>// All node types implement the Node interface.<br />
type Node interface {<br />
    Pos() token.Pos // position of first character belonging to the node<br />
    End() token.Pos // position of first character immediately after the node<br />
}</p><br />
<br />
<p>// All expression nodes implement the Expr interface.<br />
type Expr interface {<br />
    Node<br />
    exprNode()<br />
}</p><br />
<br />
<p>// All statement nodes implement the Stmt interface.<br />
type Stmt interface {<br />
    Node<br />
    stmtNode()<br />
}</p><br />
<br />
<p>// All declaration nodes implement the Decl interface.<br />
type Decl interface {<br />
    Node<br />
    declNode()<br />
}<br />
语法有三个主体：表达式(expression)、语句(statement)、声明(declaration)，Node是基类，用于标记该节点的位置的开始和结束。而三个主体的函数没有实际意义，只是用三个interface来划分不同的语法单位,如果某个语法是Stmt的话,就实现一个空的stmtNode函数即可。</p><br />
<br />
<p>比如我们用如下代码扫描源代码的token：</p><br />
<br />
<p>func TestScanner(t *testing.T) {<br />
    src := []byte(<code class="language-plaintext highlighter-rouge">package main<br />
import "fmt"<br />
//comment<br />
func main() {<br />
  fmt.Println("Hello, world!")<br />
}<br />
</code>)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var s scanner.Scanner<br />
fset := token.NewFileSet()<br />
file := fset.AddFile("", fset.Base(), len(src))<br />
s.Init(file, src, nil, 0)<br />
<br />
for {<br />
    pos, tok, lit := s.Scan()<br />
    fmt.Printf("%-6s%-8s%q\n", fset.Position(pos), tok, lit)<br />
<br />
    if tok == token.EOF {<br />
        break<br />
    }<br />
} } 结果：<br />
</code></pre></div></div><br />
<br />
<p>1:1   package “package”<br />
1:9   IDENT   “main”<br />
1:13  ;       “\n”<br />
2:1   import  “import”<br />
2:8   STRING  “"fmt"”<br />
2:13  ;       “\n”<br />
4:1   func    “func”<br />
4:6   IDENT   “main”<br />
4:10  (       “”<br />
4:11  )       “”<br />
4:13  {       “”<br />
5:3   IDENT   “fmt”<br />
5:6   .       “”<br />
5:7   IDENT   “Println”<br />
5:14  (       “”<br />
5:15  STRING  “"Hello, world!"”<br />
5:30  )       “”<br />
5:31  ;       “\n”<br />
6:1   }       “”<br />
6:2   ;       “\n”<br />
6:3   EOF     “”<br />
注意没有扫描出注释，需要的话要将s.Init的最后一个参数改为scanner.ScanComments。</p><br />
<br />
<p>看下go/token/token.go的源代码可知，token就是一堆定义好的枚举类型，对于每种类型的字面值都有对应的token。</p><br />
<br />
<p>// Copyright 2009 The Go Authors. All rights reserved.<br />
// Use of this source code is governed by a BSD-style<br />
// license that can be found in the LICENSE file.</p><br />
<br />
<p>// Package token defines constants representing the lexical tokens of the Go<br />
// programming language and basic operations on tokens (printing, predicates).<br />
//<br />
package token</p><br />
<br />
<p>import “strconv”</p><br />
<br />
<p>// Token is the set of lexical tokens of the Go programming language.<br />
type Token int</p><br />
<br />
<p>// The list of tokens.<br />
const (<br />
    // Special tokens<br />
    ILLEGAL Token = iota<br />
    EOF<br />
    COMMENT</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>literal_beg<br />
// Identifiers and basic type literals<br />
// (these tokens stand for classes of literals)<br />
IDENT  // main<br />
INT    // 12345<br />
FLOAT  // 123.45<br />
IMAG   // 123.45i<br />
CHAR   // 'a'<br />
STRING // "abc"<br />
literal_end<br />
        ...略... ) Parser 当源码被扫描成token之后，结果就被传递给了Parser 将token转换为抽象语法树（AST） 编译时的错误也是在这个时候报告的 什么是AST呢，这篇文章何为语法树讲的很好。简单来说，AST（Abstract Syntax Tree）是使用树状结构表示源代码的语法结构，树的每一个节点就代表源代码中的一个结构。<br />
</code></pre></div></div><br />
<br />
<p>来看如下的例子：</p><br />
<br />
<p>func TestParserAST(t *testing.T) {<br />
    src := []byte(<code class="language-plaintext highlighter-rouge">/*comment0*/<br />
package main<br />
import "fmt"<br />
//comment1<br />
/*comment2*/<br />
func main() {<br />
  fmt.Println("Hello, world!")<br />
}<br />
</code>)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Create the AST by parsing src.<br />
fset := token.NewFileSet() // positions are relative to fset<br />
f, err := parser.ParseFile(fset, "", src, 0)<br />
if err != nil {<br />
    panic(err)<br />
}<br />
<br />
// Print the AST.<br />
ast.Print(fset, f) } 结果很长就不贴出来了，整个AST的树形结构可以用如下图表示：<br />
</code></pre></div></div><br />
<br />
<p>image<br />
同样注意没有扫描出注释，需要的话要将parser.ParseFile的最后一个参数改为parser.ParseComments。再对照如下ast.File的定义：</p><br />
<br />
<p>type File struct {<br />
    Doc        <em>CommentGroup   // associated documentation; or nil<br />
    Package    token.Pos       // position of “package” keyword<br />
    Name       *Ident          // package name<br />
    Decls      []Decl          // top-level declarations; or nil<br />
    Scope      *Scope          // package scope (this file only)<br />
    Imports    []</em>ImportSpec   // imports in this file<br />
    Unresolved []<em>Ident        // unresolved identifiers in this file<br />
    Comments   []</em>CommentGroup // list of all comments in the source file<br />
}<br />
可知上述例子中的/<em>comment0</em>/对照结构中的Doc，是整个go文件的描述。和//comment1以及/<em>comment2</em>/不同，后两者是Decls中的结构。</p><br />
<br />
<p>遍历AST<br />
golang提供了ast.Inspect方法供我们遍历整个AST树，比如如下例子遍历整个example/test1.go文件寻找所有return返回的地方：</p><br />
<br />
<p>func TestInspectAST(t *testing.T) {<br />
    // Create the AST by parsing src.<br />
    fset := token.NewFileSet() // positions are relative to fset<br />
    f, err := parser.ParseFile(fset, “./example/test1.go”, nil, parser.ParseComments)<br />
    if err != nil {<br />
        panic(err)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ast.Inspect(f, func(n ast.Node) bool {<br />
    // Find Return Statements<br />
    ret, ok := n.(*ast.ReturnStmt)<br />
    if ok {<br />
        fmt.Printf("return statement found on line %v:\n", fset.Position(ret.Pos()))<br />
        printer.Fprint(os.Stdout, fset, ret)<br />
        fmt.Printf("\n")<br />
        return true<br />
    }<br />
    return true<br />
}) } example/test1.go代码如下：<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”<br />
import “strings”</p><br />
<br />
<p>func test1() {<br />
    hello := “Hello”<br />
    world := “World”<br />
    words := []string{hello, world}<br />
    SayHello(words)<br />
}</p><br />
<br />
<p>// SayHello says Hello<br />
func SayHello(words []string) bool {<br />
    fmt.Println(joinStrings(words))<br />
    return true<br />
}</p><br />
<br />
<p>// joinStrings joins strings<br />
func joinStrings(words []string) string {<br />
    return strings.Join(words, “, “)<br />
}<br />
结果为：</p><br />
<br />
<p>return statement found on line ./example/test1.go:16:2:<br />
return true<br />
return statement found on line ./example/test1.go:21:2:<br />
return strings.Join(words, “, “)<br />
还有另一种方法遍历AST，构造一个ast.Visitor接口：</p><br />
<br />
<p>type Visitor int</p><br />
<br />
<p>func (v Visitor) Visit(n ast.Node) ast.Visitor {<br />
    if n == nil {<br />
        return nil<br />
    }<br />
    fmt.Printf(“%s%T\n”, strings.Repeat(“\t”, int(v)), n)<br />
    return v + 1<br />
}</p><br />
<br />
<p>func TestASTWalk(t *testing.T) {<br />
    // Create the AST by parsing src.<br />
    fset := token.NewFileSet() // positions are relative to fset<br />
    f, err := parser.ParseFile(fset, “”, “package main; var a = 3”, parser.ParseComments)<br />
    if err != nil {<br />
        panic(err)<br />
    }<br />
    var v Visitor<br />
    ast.Walk(v, f)<br />
}<br />
旨在递归地打印出所有的token节点，输出：</p><br />
<br />
<p>*ast.File<br />
    *ast.Ident<br />
    *ast.GenDecl<br />
        *ast.ValueSpec<br />
            *ast.Ident<br />
            *ast.BasicLit<br />
以上基础知识主要参考文章How a Go Program Compiles down to Machine Code（译文：Go 程序到机器码的编译之旅）。下面来点干货。</p><br />
<br />
<p>怎么找到特定的代码块<br />
其实翻一翻网上将这个golang的ast的文章也不少，但是大多停留在上文的阶段，没有实际指导开发运用。那么我们假设现在有一个任务，拿到了一个别人的项目（俗称接盘侠），现在需要找到源文件中的这些地方：特征是调用了context.WithCancel函数，并且入参为nil。比如example/test2.go文件里面，有十多种可能：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “context”<br />
    “fmt”<br />
)</p><br />
<br />
<p>func test2(a string, b int) {<br />
    context.WithCancel(nil) //000</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if _, err := context.WithCancel(nil); err != nil { //111<br />
    context.WithCancel(nil) //222<br />
} else {<br />
    context.WithCancel(nil) //333<br />
}<br />
<br />
_, _ = context.WithCancel(nil) //444<br />
<br />
go context.WithCancel(nil) //555<br />
<br />
go func() {<br />
    context.WithCancel(nil) //666<br />
}()<br />
<br />
defer context.WithCancel(nil) //777<br />
<br />
defer func() {<br />
    context.WithCancel(nil) //888<br />
}()<br />
<br />
data := map[string]interface{}{<br />
    "x2": context.WithValue(nil, "k", "v"), //999<br />
}<br />
fmt.Println(data)<br />
<br />
/*<br />
    for i := context.WithCancel(nil); i; i = false {//aaa<br />
        context.WithCancel(nil)//bbb<br />
    }<br />
*/<br />
<br />
var keys []string = []string{"ccc"}<br />
for _, k := range keys {<br />
    fmt.Println(k)<br />
    context.WithCancel(nil)<br />
} } 从000到ccc，对应golang的AST的不同结构类型，现在需要把他们全部找出来。其中bbb这种情况代表了for语句，只不过在context.WithCancel函数不适用，所以注掉了。为了解决这个问题，首先需要仔细分析go/ast的Node接口。<br />
</code></pre></div></div><br />
<br />
<p>AST的结构定义<br />
go/ast/ast.go中指明了ast节点的定义：</p><br />
<br />
<p>// All node types implement the Node interface.<br />
type Node interface {<br />
    Pos() token.Pos // position of first character belonging to the node<br />
    End() token.Pos // position of first character immediately after the node<br />
}</p><br />
<br />
<p>// All expression nodes implement the Expr interface.<br />
type Expr interface {<br />
    Node<br />
    exprNode()<br />
}</p><br />
<br />
<p>// All statement nodes implement the Stmt interface.<br />
type Stmt interface {<br />
    Node<br />
    stmtNode()<br />
}</p><br />
<br />
<p>// All declaration nodes implement the Decl interface.<br />
type Decl interface {<br />
    Node<br />
    declNode()<br />
}<br />
语法有三个主体：表达式(expression)、语句(statement)、声明(declaration)，Node是基类，用于标记该节点的位置的开始和结束。而三个主体的函数没有实际意义，只是用三个interface来划分不同的语法单位,如果某个语法是Stmt的话,就实现一个空的stmtNode函数即可。参考这篇文章go-parser-语法分析，定义了源文件中可能出现的语法结构。列表如下：</p><br />
<br />
<p>普通Node,不是特定语法结构,属于某个语法结构的一部分.<br />
Comment 表示一行注释 // 或者 / /<br />
CommentGroup 表示多行注释<br />
Field 表示结构体中的一个定义或者变量,或者函数签名当中的参数或者返回值<br />
FieldList 表示以”{}”或者”()”包围的Filed列表<br />
Expression &amp; Types (都划分成Expr接口)<br />
BadExpr 用来表示错误表达式的占位符<br />
Ident 比如报名,函数名,变量名<br />
Ellipsis 省略号表达式,比如参数列表的最后一个可以写成arg…<br />
BasicLit 基本字面值,数字或者字符串<br />
FuncLit 函数定义<br />
CompositeLit 构造类型,比如{1,2,3,4}<br />
ParenExpr 括号表达式,被括号包裹的表达式<br />
SelectorExpr 选择结构,类似于a.b的结构<br />
IndexExpr 下标结构,类似这样的结构 expr[expr]<br />
SliceExpr 切片表达式,类似这样 expr[low:mid:high]<br />
TypeAssertExpr 类型断言类似于 X.(type)<br />
CallExpr 调用类型,类似于 expr()<br />
StarExpr 表达式,类似于 X<br />
UnaryExpr 一元表达式<br />
BinaryExpr 二元表达式<br />
KeyValueExp 键值表达式 key:value<br />
ArrayType 数组类型<br />
StructType 结构体类型<br />
FuncType 函数类型<br />
InterfaceType 接口类型<br />
MapType map类型<br />
ChanType 管道类型<br />
Statements<br />
BadStmt 错误的语句<br />
DeclStmt 在语句列表里的申明<br />
EmptyStmt 空语句<br />
LabeledStmt 标签语句类似于 indent:stmt<br />
ExprStmt 包含单独的表达式语句<br />
SendStmt chan发送语句<br />
IncDecStmt 自增或者自减语句<br />
AssignStmt 赋值语句<br />
GoStmt Go语句<br />
DeferStmt 延迟语句<br />
ReturnStmt return 语句<br />
BranchStmt 分支语句 例如break continue<br />
BlockStmt 块语句 {} 包裹<br />
IfStmt If 语句<br />
CaseClause case 语句<br />
SwitchStmt switch 语句<br />
TypeSwitchStmt 类型switch 语句 switch x:=y.(type)<br />
CommClause 发送或者接受的case语句,类似于 case x &lt;-:<br />
SelectStmt select 语句<br />
ForStmt for 语句<br />
RangeStmt range 语句<br />
Declarations<br />
Spec type<br />
Import Spec<br />
Value Spec<br />
Type Spec<br />
BadDecl 错误申明<br />
GenDecl 一般申明(和Spec相关,比如 import “a”,var a,type a)<br />
FuncDecl 函数申明<br />
Files and Packages<br />
File 代表一个源文件节点,包含了顶级元素.<br />
Package 代表一个包,包含了很多文件.<br />
全类型匹配<br />
那么我们需要仔细判断上面的总总结构，来适配我们的特征：</p><br />
<br />
<p>package go_code_analysis</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “go/ast”<br />
    “go/token”<br />
    “log”<br />
)</p><br />
<br />
<p>var GFset *token.FileSet<br />
var GFixedFunc map[string]Fixed //key的格式为Package.Func</p><br />
<br />
<p>func stmtCase(stmt ast.Stmt, todo func(call <em>ast.CallExpr) bool) bool {<br />
    switch t := stmt.(type) {<br />
    case *ast.ExprStmt:<br />
        log.Printf(“表达式语句%+v at line:%v”, t, GFset.Position(t.Pos()))<br />
        if call, ok := t.X.(</em>ast.CallExpr); ok {<br />
            return todo(call)<br />
        }<br />
    case <em>ast.ReturnStmt:<br />
        for i, p := range t.Results {<br />
            log.Printf(“return语句%d:%v at line:%v”, i, p, GFset.Position(p.Pos()))<br />
            if call, ok := p.(</em>ast.CallExpr); ok {<br />
                return todo(call)<br />
            }<br />
        }<br />
    case <em>ast.AssignStmt:<br />
        //函数体里的构造类型 999<br />
        for _, p := range t.Rhs {<br />
            switch t := p.(type) {<br />
            case *ast.CompositeLit:<br />
                for i, p := range t.Elts {<br />
                    switch t := p.(type) {<br />
                    case *ast.KeyValueExpr:<br />
                        log.Printf(“构造赋值语句%d:%+v at line:%v”, i, t.Value, GFset.Position(p.Pos()))<br />
                        if call, ok := t.Value.(</em>ast.CallExpr); ok {<br />
                            return todo(call)<br />
                        }<br />
                    }<br />
                }<br />
            }<br />
        }<br />
    default:<br />
        log.Printf(“不匹配的类型:%T”, stmt)<br />
    }<br />
    return false<br />
}</p><br />
<br />
<p>//调用函数的N种情况<br />
//对函数调用使用todo适配，并返回是否适配成功<br />
func AllCallCase(n ast.Node, todo func(call *ast.CallExpr) bool) (find bool) {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//函数体里的直接调用 000<br />
if fn, ok := n.(*ast.FuncDecl); ok {<br />
    for i, p := range fn.Body.List {<br />
        log.Printf("函数体表达式%d:%T at line:%v", i, p, GFset.Position(p.Pos()))<br />
        find = find || stmtCase(p, todo)<br />
    }<br />
<br />
    log.Printf("func:%+v done", fn.Name.Name)<br />
}<br />
<br />
//if语句里<br />
if ifstmt, ok := n.(*ast.IfStmt); ok {<br />
    log.Printf("if语句开始:%T %+v", ifstmt, GFset.Position(ifstmt.If))<br />
<br />
    //if的赋值表达式 111<br />
    if a, ok := ifstmt.Init.(*ast.AssignStmt); ok {<br />
        for i, p := range a.Rhs {<br />
            log.Printf("if语句赋值%d:%T at line:%v", i, p, GFset.Position(p.Pos()))<br />
            switch call := p.(type) {<br />
            case *ast.CallExpr:<br />
                c := todo(call)<br />
                find = find || c<br />
            }<br />
        }<br />
    }<br />
<br />
    //if的花括号里面 222<br />
    for i, p := range ifstmt.Body.List {<br />
        log.Printf("if语句内部表达式%d:%T at line:%v", i, p, GFset.Position(p.Pos()))<br />
        c := stmtCase(p, todo)<br />
        find = find || c<br />
    }<br />
<br />
    //if的else里面 333<br />
    if b, ok := ifstmt.Else.(*ast.BlockStmt); ok {<br />
        for i, p := range b.List {<br />
            log.Printf("if语句else表达式%d:%T at line:%v", i, p, GFset.Position(p.Pos()))<br />
            c := stmtCase(p, todo)<br />
            find = find || c<br />
        }<br />
    }<br />
<br />
    log.Printf("if语句结束:%+v done", GFset.Position(ifstmt.End()))<br />
}<br />
<br />
//赋值语句 444<br />
if assign, ok := n.(*ast.AssignStmt); ok {<br />
    log.Printf("赋值语句开始:%T %s", assign, GFset.Position(assign.Pos()))<br />
    for i, p := range assign.Rhs {<br />
        log.Printf("赋值表达式%d:%T at line:%v", i, p, GFset.Position(p.Pos()))<br />
        switch t := p.(type) {<br />
        case *ast.CallExpr:<br />
            c := todo(t)<br />
            find = find || c<br />
        case *ast.CompositeLit:<br />
            for i, p := range t.Elts {<br />
                switch t := p.(type) {<br />
                case *ast.KeyValueExpr:<br />
                    log.Printf("构造赋值%d:%+v at line:%v", i, t.Value, GFset.Position(p.Pos()))<br />
                    if call, ok := t.Value.(*ast.CallExpr); ok {<br />
                        c := todo(call)<br />
                        find = find || c<br />
                    }<br />
                }<br />
            }<br />
        }<br />
    }<br />
}<br />
<br />
if gostmt, ok := n.(*ast.GoStmt); ok {<br />
    log.Printf("go语句开始:%T %s", gostmt.Call.Fun, GFset.Position(gostmt.Go))<br />
<br />
    //go后面直接调用 555<br />
    c := todo(gostmt.Call)<br />
    find = find || c<br />
<br />
    //go func里面的调用 666<br />
    if g, ok := gostmt.Call.Fun.(*ast.FuncLit); ok {<br />
        for i, p := range g.Body.List {<br />
            log.Printf("go语句表达式%d:%T at line:%v", i, p, GFset.Position(p.Pos()))<br />
            c := stmtCase(p, todo)<br />
            find = find || c<br />
        }<br />
    }<br />
<br />
    log.Printf("go语句结束:%+v done", GFset.Position(gostmt.Go))<br />
}<br />
<br />
if deferstmt, ok := n.(*ast.DeferStmt); ok {<br />
    log.Printf("defer语句开始:%T %s", deferstmt.Call.Fun, GFset.Position(deferstmt.Defer))<br />
<br />
    //defer后面直接调用 777<br />
    c := todo(deferstmt.Call)<br />
    find = find || c<br />
<br />
    //defer func里面的调用 888<br />
    if g, ok := deferstmt.Call.Fun.(*ast.FuncLit); ok {<br />
        for i, p := range g.Body.List {<br />
            log.Printf("defer语句内部表达式%d:%T at line:%v", i, p, GFset.Position(p.Pos()))<br />
            c := stmtCase(p, todo)<br />
            find = find || c<br />
        }<br />
    }<br />
<br />
    log.Printf("defer语句结束:%+v done", GFset.Position(deferstmt.Defer))<br />
}<br />
<br />
if fostmt, ok := n.(*ast.ForStmt); ok {<br />
    //for语句对应aaa和bbb<br />
    log.Printf("for语句开始:%T %s", fostmt.Body, GFset.Position(fostmt.Pos()))<br />
    for i, p := range fostmt.Body.List {<br />
        log.Printf("for语句函数体表达式%d:%T at line:%v", i, p, GFset.Position(p.Pos()))<br />
        c := stmtCase(p, todo)<br />
        find = find || c<br />
    }<br />
}<br />
<br />
if rangestmt, ok := n.(*ast.RangeStmt); ok {<br />
    //range语句对应ccc<br />
    log.Printf("range语句开始:%T %s", rangestmt.Body, GFset.Position(rangestmt.Pos()))<br />
    for i, p := range rangestmt.Body.List {<br />
        log.Printf("range语句函数体表达式%d:%T at line:%v", i, p, GFset.Position(p.Pos()))<br />
        c := stmtCase(p, todo)<br />
        find = find || c<br />
    }<br />
}<br />
<br />
return }<br />
</code></pre></div></div><br />
<br />
<p>type FindContext struct {<br />
    File      string<br />
    Package   string<br />
    LocalFunc *ast.FuncDecl<br />
}</p><br />
<br />
<p>func (f *FindContext) Visit(n ast.Node) ast.Visitor {<br />
    if n == nil {<br />
        return f<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if fn, ok := n.(*ast.FuncDecl); ok {<br />
    log.Printf("函数[%s.%s]开始 at line:%v", f.Package, fn.Name.Name, GFset.Position(fn.Pos()))<br />
    f.LocalFunc = fn<br />
} else {<br />
    log.Printf("类型%T at line:%v", n, GFset.Position(n.Pos()))<br />
}<br />
<br />
find := AllCallCase(n, f.FindCallFunc)<br />
<br />
if find {<br />
    name := fmt.Sprintf("%s.%s", f.Package, f.LocalFunc.Name)<br />
    GFixedFunc[name] = Fixed{FuncDesc: FuncDesc{f.File, f.Package, f.LocalFunc.Name.Name}}<br />
}<br />
<br />
return f }<br />
</code></pre></div></div><br />
<br />
<p>func (f *FindContext) FindCallFunc(call *ast.CallExpr) bool {<br />
    if call == nil {<br />
        return false<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>log.Printf("call func:%+v, %v", call.Fun, call.Args)<br />
<br />
if callFunc, ok := call.Fun.(*ast.SelectorExpr); ok {<br />
    if fmt.Sprint(callFunc.X) == "context" &amp;&amp; fmt.Sprint(callFunc.Sel) == "WithCancel" {<br />
        if len(call.Args) &gt; 0 {<br />
            if argu, ok := call.Args[0].(*ast.Ident); ok {<br />
                log.Printf("argu type:%T, %s", argu.Name, argu.String())<br />
                if argu.Name == "nil" {<br />
                    location := fmt.Sprint(GFset.Position(argu.NamePos))<br />
                    log.Printf("找到关键函数:%s.%s at line:%v", callFunc.X, callFunc.Sel, location)<br />
                    return true<br />
                }<br />
            }<br />
        }<br />
    }<br />
}<br />
<br />
return false } 在AllCallCase方法中我们穷举了所有的调用函数的情况（ast.CallExpr），分别对应了000到ccc这13种情况。stmtCase方法分析了语句的各种可能，尽量找全所有。 FindContext.FindCallFunc方法首先看调用函数是不是选择结构，类似于a.b的结构；然后对比了调用函数的a.b是不是我们关心的context.WithCancel；最后看第一个实参的名称是不是nil。<br />
</code></pre></div></div><br />
<br />
<p>最终找到了所有特征点：</p><br />
<br />
<p>2019/01/16 20:19:52 找到关键函数:context.WithCancel at line:./example/test2.go:9:21<br />
2019/01/16 20:19:52 找到关键函数:context.WithCancel at line:./example/test2.go:11:34<br />
2019/01/16 20:19:52 找到关键函数:context.WithCancel at line:./example/test2.go:12:22<br />
2019/01/16 20:19:52 找到关键函数:context.WithCancel at line:./example/test2.go:14:22<br />
2019/01/16 20:19:52 找到关键函数:context.WithCancel at line:./example/test2.go:11:34<br />
2019/01/16 20:19:52 找到关键函数:context.WithCancel at line:./example/test2.go:17:28<br />
2019/01/16 20:19:52 找到关键函数:context.WithCancel at line:./example/test2.go:19:24<br />
2019/01/16 20:19:52 找到关键函数:context.WithCancel at line:./example/test2.go:22:22<br />
2019/01/16 20:19:52 找到关键函数:context.WithCancel at line:./example/test2.go:25:27<br />
2019/01/16 20:19:52 找到关键函数:context.WithCancel at line:./example/test2.go:28:22<br />
2019/01/16 20:19:52 找到关键函数:context.WithCancel at line:./example/test2.go:45:22<br />
故事的结尾，我们使用FindContext提供的walk方法递归了AST树，找到了所有符合我们特征的函数，当然例子里就test一个函数。所有代码都在https://github.com/baixiaoustc/go_code_analysis中能找到。</p><br />
<br />
<p>https://github.com/baixiaoustc/go_code_analysis<br />
https://getstream.io/blog/how-a-go-program-compiles-down-to-machine-code/</p><br />
<br />
<p>https://getstream.io/blog/switched-python-go/<br />
https://github.com/golang/go/blob/3fd364988ce5dcf3aa1d4eb945d233455db30af6/src/cmd/compile/internal/ssa/gen/genericOps.go#L411</p><br />
<br />
<p>https://studygolang.com/articles/15648?utm_source=tuicool&amp;utm_medium=referral</p><br />
<br />
<p>https://studygolang.com/articles/6709</p><br />
<br />
<p>本文主要看一下Go的语法分析是如何进行.Go的parser接受的输入是源文件,内嵌了一个scanner,最后把scanner生成的token变成一颗抽象语法树(AST).<br />
编译时的错误也是在这个时候报告的,但是大部分编译器编译时的错误系统并不是很完美,有时候报的错误文不对题,这主要是因为写对的方式有几种<br />
但是写错的方式有很多种,编译器只能把一些错误进行归类,并且指出当前认为可疑的地方,并不能完完全全的知道到底是什么语法错误.这个需要结合给出的错误进行判断,clang作为一个C编译器做得好很多,这都是开发者不断地添加错误处理的结果,比gcc的报错完善很多.然而Go的编译时的错误处理也是秉承了gcc的风格,并不明确,但是会指出可疑的地方,在大多数场景下或者对语言标准熟悉的情况下也不是很麻烦.<br />
下面看一下Go是怎么定义这些语法结构.这些结构都在go/ast当中.</p><br />
<br />
<p>// All node types implement the Node interface.<br />
type Node interface {<br />
        Pos() token.Pos // position of first character belonging to the node<br />
        End() token.Pos // position of first character immediately after the node<br />
}</p><br />
<br />
<p>// All expression nodes implement the Expr interface.<br />
type Expr interface {<br />
        Node<br />
        exprNode()<br />
}</p><br />
<br />
<p>// All statement nodes implement the Stmt interface.<br />
type Stmt interface {<br />
        Node<br />
        stmtNode()<br />
}</p><br />
<br />
<p>// All declaration nodes implement the Decl interface.<br />
type Decl interface {<br />
        Node<br />
        declNode()<br />
}<br />
语法有三个主体,表达式(expression),语句(statement),声明(declaration),Node是基类,用于标记该节点的位置的开始和结束.<br />
而三个主体的函数没有实际意义,只是用三个interface来划分不同的语法单位,如果某个语法是Stmt的话,就实现一个空的stmtNode函数即可.<br />
这样的好处是可以对语法单元进行comma,ok来判断类型,并且保证只有这些变量可以赋值给对应的interface.但是实际上这个划分不是很严格,比如</p><br />
<br />
<p>func (<em>ArrayType) exprNode()     {}<br />
func (</em>StructType) exprNode()    {}<br />
func (<em>FuncType) exprNode()      {}<br />
func (</em>InterfaceType) exprNode() {}<br />
就是类型,但是属于Expr,而真正的表达式比如</p><br />
<br />
<p>func (<em>BasicLit) exprNode()       {}<br />
func (</em>FuncLit) exprNode()        {}<br />
是可以赋值给Exprt的.</p><br />
<br />
<p>了解了这个设计,再来看整个内容其实就是定义了源文件中可能出现的语法结构.列表如下,这个列表很长,扫一眼就可以,具体可以再回来看.</p><br />
<br />
<p>普通Node,不是特定语法结构,属于某个语法结构的一部分.<br />
Comment 表示一行注释 // 或者 / /<br />
CommentGroup 表示多行注释<br />
Field 表示结构体中的一个定义或者变量,或者函数签名当中的参数或者返回值<br />
FieldList 表示以”{}”或者”()”包围的Filed列表<br />
Expression &amp; Types (都划分成Expr接口)<br />
BadExpr 用来表示错误表达式的占位符<br />
Ident 比如报名,函数名,变量名<br />
Ellipsis 省略号表达式,比如参数列表的最后一个可以写成arg…<br />
BasicLit 基本字面值,数字或者字符串<br />
FuncLit 函数定义<br />
CompositeLit 构造类型,比如{1,2,3,4}<br />
ParenExpr 括号表达式,被括号包裹的表达式<br />
SelectorExpr 选择结构,类似于a.b的结构<br />
IndexExpr 下标结构,类似这样的结构 expr[expr]<br />
SliceExpr 切片表达式,类似这样 expr[low:mid:high]<br />
TypeAssertExpr 类型断言类似于 X.(type)<br />
CallExpr 调用类型,类似于 expr()<br />
StarExpr 表达式,类似于 X<br />
UnaryExpr 一元表达式<br />
BinaryExpr 二元表达式<br />
KeyValueExp 键值表达式 key:value<br />
ArrayType 数组类型<br />
StructType 结构体类型<br />
FuncType 函数类型<br />
InterfaceType 接口类型<br />
MapType map类型<br />
ChanType 管道类型<br />
Statements<br />
BadStmt 错误的语句<br />
DeclStmt 在语句列表里的申明<br />
EmptyStmt 空语句<br />
LabeledStmt 标签语句类似于 indent:stmt<br />
ExprStmt 包含单独的表达式语句<br />
SendStmt chan发送语句<br />
IncDecStmt 自增或者自减语句<br />
AssignStmt 赋值语句<br />
GoStmt Go语句<br />
DeferStmt 延迟语句<br />
ReturnStmt return 语句<br />
BranchStmt 分支语句 例如break continue<br />
BlockStmt 块语句 {} 包裹<br />
IfStmt If 语句<br />
CaseClause case 语句<br />
SwitchStmt switch 语句<br />
TypeSwitchStmt 类型switch 语句 switch x:=y.(type)<br />
CommClause 发送或者接受的case语句,类似于 case x &lt;-:<br />
SelectStmt select 语句<br />
ForStmt for 语句<br />
RangeStmt range 语句<br />
Declarations<br />
Spec type<br />
Import Spec<br />
Value Spec<br />
Type Spec<br />
BadDecl 错误申明<br />
GenDecl 一般申明(和Spec相关,比如 import “a”,var a,type a)<br />
FuncDecl 函数申明<br />
Files and Packages<br />
File 代表一个源文件节点,包含了顶级元素.<br />
Package 代表一个包,包含了很多文件.<br />
上面就是整个源代码的所有组成元素,接下来就来看一下语法分析是如何进行的,也就是最后的AST是如何构建出来的.</p><br />
<br />
<p>先看一下parser结构体的定义,parser是以file为单位的.</p><br />
<br />
<p>// The parser structure holds the parser’s internal state.<br />
type parser struct {<br />
        file    *token.File<br />
        errors  scanner.ErrorList // 解析过程中遇到的错误列表<br />
        scanner scanner.Scanner // 词法分析器.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // Tracing/debugging<br />
    mode   Mode // parsing mode // 解析模式<br />
    trace  bool // == (mode &amp; Trace != 0)<br />
    indent int  // indentation used for tracing output<br />
<br />
    // Comments 列表<br />
    comments    []*ast.CommentGroup<br />
    leadComment *ast.CommentGroup // last lead comment<br />
    lineComment *ast.CommentGroup // last line comment<br />
<br />
    // Next token<br />
    pos token.Pos   // token position<br />
    tok token.Token // one token look-ahead<br />
    lit string      // token literal<br />
<br />
    // Error recovery<br />
    // (used to limit the number of calls to syncXXX functions<br />
    // w/o making scanning progress - avoids potential endless<br />
    // loops across multiple parser functions during error recovery)<br />
    syncPos token.Pos // last synchronization position 解析错误的同步点.<br />
    syncCnt int       // number of calls to syncXXX without progress<br />
<br />
    // Non-syntactic parser control<br />
    // 非语法性的控制<br />
    // &lt;0 在控制语句中, &gt;= 在表达式中.<br />
    exprLev int  // &lt; 0: in control clause, &gt;= 0: in expression<br />
    // 正在解析右值表达式<br />
    inRhs   bool // if set, the parser is parsing a rhs expression<br />
<br />
    // Ordinary identifier scopes<br />
    pkgScope   *ast.Scope        // pkgScope.Outer == nil<br />
    topScope   *ast.Scope        // top-most scope; may be pkgScope<br />
    unresolved []*ast.Ident      // unresolved identifiers<br />
    imports    []*ast.ImportSpec // list of imports<br />
<br />
    // Label scopes<br />
    // (maintained by open/close LabelScope)<br />
    labelScope  *ast.Scope     // label scope for current function<br />
    targetStack [][]*ast.Ident // stack of unresolved labels } 解析的入口是ParseFile,首先调用init,再调用parseFile进行解析. 整个解析是一个递归向下的过程也就是最low但是最实用的手写实现的方式.像yacc[4]生成的是我们编译里学的LALR[5]文法,牛逼的一逼,但是 gcc和Go都没用自动生成的解析器,也就是手写个几千行代码的事,所以为了更好的掌握编译器的细节,都选择了手写最简单的递归向下的方式.<br />
</code></pre></div></div><br />
<br />
<p>通过init初始化scanner等.</p><br />
<br />
<p>func (p *parser) init(fset *token.FileSet, filename string, src []byte, mode Mode) {<br />
        p.file = fset.AddFile(filename, -1, len(src))<br />
        var m scanner.Mode<br />
        if mode&amp;ParseComments != 0 {<br />
                m = scanner.ScanComments<br />
        }<br />
        // 错误处理函数是在错误列表中添加错误.<br />
        eh := func(pos token.Position, msg string) { p.errors.Add(pos, msg) }<br />
        p.scanner.Init(p.file, src, eh, m)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    p.mode = mode<br />
    p.trace = mode&amp;Trace != 0 // for convenience (p.trace is used frequently)<br />
<br />
    p.next() } parseFile的简化流程:<br />
<br />
    // package clause<br />
    // 获取源文件开头的doc注释,从这里递归向下的解析开始了<br />
    doc := p.leadComment<br />
    // expect 从scanner获取一个token,并且返回位置pos.<br />
    pos := p.expect(token.PACKAGE)<br />
    // parseIdent 获取一个token并且转化为indent,如果不是报错.<br />
    ident := p.parseIdent()<br />
    if ident.Name == "_" &amp;&amp; p.mode&amp;DeclarationErrors != 0 {<br />
            p.error(p.pos, "invalid package name _")<br />
    }<br />
    // 作用域开始,标记解释器当前开始一个新的作用域<br />
    p.openScope()<br />
    // pkgScope 就是现在进入的作用域<br />
    p.pkgScope = p.topScope <br />
    // 解析 import 申明<br />
    for p.tok == token.IMPORT {<br />
    // parseGenDecl解析的是 <br />
    // import (<br />
    // )<br />
    // 这样的结构,如果有括号就用parseImportSpec解析列表<br />
    // 没有就单独解析.<br />
    // 而parseImportSpec解析的是 一个可选的indent token和一个字符串token.<br />
    // 并且加入到imports列表中.<br />
            decls = append(decls, p.parseGenDecl(token.IMPORT, p.parseImportSpec))<br />
    }<br />
// 解析全局的申明,包括函数申明<br />
    if p.mode&amp;ImportsOnly == 0 {<br />
            // rest of package body<br />
            for p.tok != token.EOF {<br />
                    decls = append(decls, p.parseDecl(syncDecl))<br />
            }<br />
    }<br />
// 标记从当前作用域离开.<br />
p.closeScope()<br />
// 最后返回ast.File文件对象.<br />
    return &amp;ast.File{<br />
            Doc:        doc,<br />
            Package:    pos,<br />
            Name:       ident,<br />
            Decls:      decls,<br />
            Scope:      p.pkgScope,<br />
            Imports:    p.imports,<br />
            Unresolved: p.unresolved[0:i],<br />
            Comments:   p.comments,<br />
    } 看一下parseDecl主要是根据类型的不同调用不同的解析函数,parseValueSpec解析Value类型,parseTypeSpec解析Type类型,parseFuncDecl解析函数. 解析定义和解析类型的都是解析了,类似于var|type ( ident valueSpec|typeSpec)的token结构.因为parseFuncDecl里面也会解析这些内容,所以直接从函数解析来看也可以. 因为外一层的top scope其实就是相当于一个抽象的函数作用域而已,这样是为什么len和new这样的内嵌函数在函数内是可以做变量名的原因,因为可以在子作用域覆盖top作用域.整个解析过程简化过程如下.<br />
<br />
// 解析一个func.<br />
    pos := p.expect(token.FUNC)<br />
// 开一个新的作用域,topScope作为父Scope.<br />
    scope := ast.NewScope(p.topScope) // function scope<br />
// 解析一个ident作为函数名<br />
ident := p.parseIdent()    <br />
// 解析函数签名,也就是参数和返回值<br />
params, results := p.parseSignature(scope)<br />
// 再解析body<br />
body = p.parseBody(scope)<br />
// 最后返回函数申明.<br />
    decl := &amp;ast.FuncDecl{<br />
            Doc:  doc,<br />
            Recv: recv,<br />
            Name: ident,<br />
            Type: &amp;ast.FuncType{<br />
                    Func:    pos,<br />
                    Params:  params,<br />
                    Results: results,<br />
            },<br />
            Body: body,<br />
    } 解析参数和返回值就是解析(filed,filed)这样的格式,每个filed是indent type的token,最后构造成函数签名.然后来到parseBody,这个函数其实就是解析了左右花括号,然后向下开始解析Statement列表,类似于body -&gt; { stmt_list },然后进入stmt_list的解析,不断地解析statement.<br />
<br />
    for p.tok != token.CASE &amp;&amp; p.tok != token.DEFAULT &amp;&amp; p.tok != token.RBRACE &amp;&amp; p.tok != token.EOF {<br />
            list = append(list, p.parseStmt())<br />
    } parseStmt最后会进入到语句的解析,然后根据不同的token选择进入不同的解析流程,比如看到var,type,const就是申明,碰到标识符和数字等等可能就是单独的表达式, 如果碰到go,就知道是一个go语句,如果看到defer和return都能判断出相应的语句并按规则解析,看到break等条件关键字就解析条件语句,看到{就解析块语句.都是可以递归去解析的.<br />
</code></pre></div></div><br />
<br />
<p>func (p *parser) parseStmt() (s ast.Stmt) {<br />
        if p.trace {<br />
                defer un(trace(p, “Statement”))<br />
        }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    switch p.tok {<br />
    case token.CONST, token.TYPE, token.VAR:<br />
            s = &amp;ast.DeclStmt{Decl: p.parseDecl(syncStmt)}<br />
    case<br />
            // tokens that may start an expression<br />
            token.IDENT, token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING, token.FUNC, token.LPAREN, // operands<br />
            token.LBRACK, token.STRUCT, token.MAP, token.CHAN, token.INTERFACE, // composite types<br />
            token.ADD, token.SUB, token.MUL, token.AND, token.XOR, token.ARROW, token.NOT: // unary operators<br />
            s, _ = p.parseSimpleStmt(labelOk)<br />
            // because of the required look-ahead, labeled statements are<br />
            // parsed by parseSimpleStmt - don't expect a semicolon after<br />
            // them<br />
            if _, isLabeledStmt := s.(*ast.LabeledStmt); !isLabeledStmt {<br />
                    p.expectSemi()<br />
            }<br />
    case token.GO:<br />
            s = p.parseGoStmt()<br />
    case token.DEFER:<br />
            s = p.parseDeferStmt()<br />
    case token.RETURN:<br />
            s = p.parseReturnStmt()<br />
    case token.BREAK, token.CONTINUE, token.GOTO, token.FALLTHROUGH:<br />
            s = p.parseBranchStmt(p.tok)<br />
    case token.LBRACE:<br />
            s = p.parseBlockStmt()<br />
...省略 举个例子看一下parseSimpleStmt()的简化流程<br />
<br />
    // 解析左列表 一般是 l := r 或者 l1,l2 = r1,r2 或者 l &lt;- r 或者 l++<br />
    x := p.parseLhsList()<br />
    switch p.tok {<br />
    case<br />
            token.DEFINE, token.ASSIGN, token.ADD_ASSIGN,<br />
            token.SUB_ASSIGN, token.MUL_ASSIGN, token.QUO_ASSIGN,<br />
            token.REM_ASSIGN, token.AND_ASSIGN, token.OR_ASSIGN,<br />
            token.XOR_ASSIGN, token.SHL_ASSIGN, token.SHR_ASSIGN, token.AND_NOT_ASSIGN:<br />
    // 如果看到range,range作为一种运算符按照range rhs来解析<br />
    // 如果没看到就按正常赋值语句解析 lhs op rhs 来解析op可以是上面那些token中的一种.<br />
            pos, tok := p.pos, p.tok<br />
            p.next()<br />
            var y []ast.Expr<br />
            isRange := false<br />
            if mode == rangeOk &amp;&amp; p.tok == token.RANGE &amp;&amp; (tok == token.DEFINE || tok == token.ASSIGN) {<br />
                    pos := p.pos<br />
                    p.next()<br />
                    y = []ast.Expr{&amp;ast.UnaryExpr{OpPos: pos, Op: token.RANGE, X: p.parseRhs()}}<br />
                    isRange = true<br />
            } else {<br />
                    y = p.parseRhsList()<br />
            }<br />
            as := &amp;ast.AssignStmt{Lhs: x, TokPos: pos, Tok: tok, Rhs: y}<br />
<br />
// 碰到":"找一个ident, 构成 goto: indent 之类的语句.<br />
case token.COLON:<br />
            colon := p.pos<br />
            p.next()<br />
            if label, isIdent := x[0].(*ast.Ident); mode == labelOk &amp;&amp; isIdent {<br />
                    // Go spec: The scope of a label is the body of the function<br />
                    // in which it is declared and excludes the body of any nested<br />
                    // function.<br />
                    stmt := &amp;ast.LabeledStmt{Label: label, Colon: colon, Stmt: p.parseStmt()}<br />
                    p.declare(stmt, nil, p.labelScope, ast.Lbl, label)<br />
                    return stmt, false<br />
            }<br />
// 碰到"&lt;-",就构成 &lt;- rhs 这样的语句.<br />
    case token.ARROW:<br />
            // send statement<br />
            arrow := p.pos<br />
            p.next()<br />
            y := p.parseRhs()<br />
            return &amp;ast.SendStmt{Chan: x[0], Arrow: arrow, Value: y}, false<br />
<br />
// 碰到"++"或者"--"就构成一个单独的自增语句.<br />
    case token.INC, token.DEC:<br />
            // increment or decrement<br />
            s := &amp;ast.IncDecStmt{X: x[0], TokPos: p.pos, Tok: p.tok}<br />
            p.next()<br />
            return s, false<br />
    } 接下来就不一一解释每段代码了,具体情况具体看就可以.这里举个例子.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
        “go/ast”<br />
        “go/parser”<br />
        “go/token”<br />
)</p><br />
<br />
<p>func main() {<br />
        fset := token.NewFileSet()<br />
        f, err := parser.ParseFile(fset, “”, ` <br />
package main<br />
func main(){<br />
        // comments<br />
        x:=1<br />
        go println(x)</p><br />
<br />
<p>}<br />
        `, parser.ParseComments)<br />
        if err != nil {<br />
                panic(err)<br />
        }<br />
        ast.Print(fset, f)<br />
}<br />
产生的结果是</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 0  *ast.File {<br />
 1  .  Package: 2:1                        |PACKAGE token<br />
 2  .  Name: *ast.Ident {                    |IDENT token<br />
 3  .  .  NamePos: 2:9                    |<br />
 4  .  .  Name: "main"                    |<br />
 5  .  }                            |整个构成了顶部的 package main<br />
 6  .  Decls: []ast.Decl (len = 1) {            |最上层的申明列表<br />
 7  .  .  0: *ast.FuncDecl {                |func main的函数申明<br />
 8  .  .  .  Name: *ast.Ident {                |IDENT token<br />
 9  .  .  .  .  NamePos: 3:6                |<br />
10  .  .  .  .  Name: "main"                |<br />
11  .  .  .  .  Obj: *ast.Object {                |Objec是一个用于表达语法对象的结构<br />
12  .  .  .  .  .  Kind: func                |表示之前存在过,Decl指向了7,也就是第7行的FuncDecl.<br />
13  .  .  .  .  .  Name: "main"                |<br />
14  .  .  .  .  .  Decl: *(obj @ 7)                |<br />
15  .  .  .  .  }                        |<br />
16  .  .  .  }                        |<br />
17  .  .  .  Type: *ast.FuncType {                |函数类型,也就是函数签名<br />
18  .  .  .  .  Func: 3:1                    |参数和返回值都是空的<br />
19  .  .  .  .  Params: *ast.FieldList {            |<br />
20  .  .  .  .  .  Opening: 3:10<br />
21  .  .  .  .  .  Closing: 3:11<br />
22  .  .  .  .  }<br />
23  .  .  .  }<br />
24  .  .  .  Body: *ast.BlockStmt {                |块语句,也就是main的body<br />
25  .  .  .  .  Lbrace: 3:12<br />
26  .  .  .  .  List: []ast.Stmt (len = 2) {        |语句列表<br />
27  .  .  .  .  .  0: *ast.AssignStmt {            |赋值语句<br />
28  .  .  .  .  .  .  Lhs: []ast.Expr (len = 1) {        |左值是x<br />
29  .  .  .  .  .  .  .  0: *ast.Ident {<br />
30  .  .  .  .  .  .  .  .  NamePos: 5:2            |<br />
31  .  .  .  .  .  .  .  .  Name: "x"<br />
32  .  .  .  .  .  .  .  .  Obj: *ast.Object {        |<br />
33  .  .  .  .  .  .  .  .  .  Kind: var<br />
34  .  .  .  .  .  .  .  .  .  Name: "x"            |<br />
35  .  .  .  .  .  .  .  .  .  Decl: *(obj @ 27)<br />
36  .  .  .  .  .  .  .  .  }<br />
37  .  .  .  .  .  .  .  }                    |<br />
38  .  .  .  .  .  .  }<br />
39  .  .  .  .  .  .  TokPos: 5:3                |:=和它的位置<br />
40  .  .  .  .  .  .  Tok: :=<br />
41  .  .  .  .  .  .  Rhs: []ast.Expr (len = 1) {        |右边是一个数字类型的token<br />
42  .  .  .  .  .  .  .  0: *ast.BasicLit {<br />
43  .  .  .  .  .  .  .  .  ValuePos: 5:5<br />
44  .  .  .  .  .  .  .  .  Kind: INT<br />
45  .  .  .  .  .  .  .  .  Value: "1"<br />
46  .  .  .  .  .  .  .  }<br />
47  .  .  .  .  .  .  }<br />
48  .  .  .  .  .  }<br />
49  .  .  .  .  .  1: *ast.GoStmt {                |接下来是go语句<br />
50  .  .  .  .  .  .  Go: 6:2<br />
51  .  .  .  .  .  .  Call: *ast.CallExpr {            |一个调用表达式<br />
52  .  .  .  .  .  .  .  Fun: *ast.Ident {            |IDENT token是println<br />
53  .  .  .  .  .  .  .  .  NamePos: 6:5<br />
54  .  .  .  .  .  .  .  .  Name: "println"<br />
55  .  .  .  .  .  .  .  }<br />
56  .  .  .  .  .  .  .  Lparen: 6:12            |左括号的位置<br />
57  .  .  .  .  .  .  .  Args: []ast.Expr (len = 1) {    |参数列表<br />
58  .  .  .  .  .  .  .  .  0: *ast.Ident {            |是一个符号INDENT,并且指向的是32行的x<br />
59  .  .  .  .  .  .  .  .  .  NamePos: 6:13<br />
60  .  .  .  .  .  .  .  .  .  Name: "x"<br />
61  .  .  .  .  .  .  .  .  .  Obj: *(obj @ 32)<br />
62  .  .  .  .  .  .  .  .  }<br />
63  .  .  .  .  .  .  .  }<br />
64  .  .  .  .  .  .  .  Ellipsis: -<br />
65  .  .  .  .  .  .  .  Rparen: 6:14            |右括号的位置<br />
66  .  .  .  .  .  .  }<br />
67  .  .  .  .  .  }<br />
68  .  .  .  .  }<br />
69  .  .  .  .  Rbrace: 8:1<br />
70  .  .  .  }<br />
71  .  .  }<br />
72  .  }<br />
73  .  Scope: *ast.Scope {                    |最顶级的作用域<br />
74  .  .  Objects: map[string]*ast.Object (len = 1) {<br />
75  .  .  .  "main": *(obj @ 11)<br />
76  .  .  }<br />
77  .  }<br />
78  .  Unresolved: []*ast.Ident (len = 1) {            |这里有个没有定义的符号println,是因为是内置符号,会另外处理<br />
79  .  .  0: *(obj @ 52)                    |从源文件上是表现不出来的.<br />
80  .  }<br />
81  .  Comments: []*ast.CommentGroup (len = 1) {        |评论列表,以及位置和内容.<br />
82  .  .  0: *ast.CommentGroup {<br />
83  .  .  .  List: []*ast.Comment (len = 1) {<br />
84  .  .  .  .  0: *ast.Comment {<br />
85  .  .  .  .  .  Slash: 4:2<br />
86  .  .  .  .  .  Text: "// comments"<br />
87  .  .  .  .  }<br />
88  .  .  .  }<br />
89  .  .  }<br />
90  .  }<br />
91  } 这就是Go的整个语法分析和最后产生的语法树的结构.<br />
</code></pre></div></div><br />
<br />
<p>废话说了这么多其实实现很简单,问题是如何把一个语言的spec定义好,很重要,早期语言设计不是很固定的.都是慢慢尝试不断改进的过程.最早的一次spec文档[6]其实和现在差了很多很多.就是把TOKEN记号流从左至右匹配规则(可能会向前看几个token),然后递归解析语法树,最后得到AST.<br />
我在我的字符画转换器里用的也是类似的方式[7],做了自顶向下递归解析语法的方式,但是错误处理都是速错,不会做错误恢复找到一个可以同步的节点继续分析.<br />
所以这里补充一点,Go是如何进行错误处理的同步问题,寄希望于能够向使用者提供更多的错误.主要是parser当中的两个结构</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    syncPos token.Pos // last synchronization position<br />
    syncCnt int       // number of calls to syncXXX without progress syncPos错误的同步位置,也就类似于游戏的存档点,如果发生错误那就从这个地方开始跳过(BadStmt|BadExpr)继续解析,在每次完成语句,申明或者表达式的解析之后就会保存一个同步点.虽然这种继续解析的行为不一定能够给出很精确的错误提示,但的确够用了.当然如果错误实在太多了,从同步点恢复也没有太大意义,就会主动放弃,所以记录了没有成功解析而同步的次数.<br />
</code></pre></div></div><br />
<br />
<p>因为之前造过轮子了,所以我发现其实编译器的前端用手写是一个很繁琐并且需要花很多时间去做的一件事情,如果语言有设计良好,那么也至少需要花实现的时间,如果设计不好,实现也要跟着修修补补,那就更麻烦,虽然整个编译器的前端也就不到万行代码,但是的确是很考验耐心的一件事情,而且用递归向下的方式解析也没什么效率问题,编译器编译慢一点也不是很要紧,所以有轮子还是用轮子吧,这只是一件苦力活,的确没什么高科技.</p><br />
<br />
<p>最后附带一个用Go实现的Go语法的子集的动态语言版本,只有几十行.</p><br />
<br />
<p>https://gist.github.com/ggaaooppeenngg/dff0fff8f0c9194d93c70550d50edbfa</p><br />
<br />
<p>https://gist.github.com/ggaaooppeenngg/dff0fff8f0c9194d93c70550d50edbfa</p><br />
<br />
<p>https://huang-jerryc.com/2016/03/15/%E4%BD%95%E4%B8%BA%E8%AF%AD%E6%B3%95%E6%A0%91/</p><br />
<br />
<p>再窥视一下JavaScript的语法树<br />
在语法复杂的语言中，语法树是包含很多细节的语法结果表达式，我们需要靠语法树把这种形式以更简洁的形式表达出来。</p><br />
<br />
<p>Javascript 有不少工具可以把代码构造出清晰的语法树，比如 esprima、v8、SpiderMonkey、UglifyJS、AST explorer等。</p><br />
<br />
<p>https://www.php.cn/manual/view/35199.html</p><br />
<br />
<p>https://blog.csdn.net/weixin_33896726/article/details/93181205</p><br />
<br />
<p>https://www.jianshu.com/p/937d649039ec</p><br />
<br />
<p>https://www.shangmayuan.com/a/90f086113eef412aa353e0be.html</p><br />
<br />
<p>许多自动化代码生成工具都离不开语法树分析，例如goimport，gomock，wire等项目都离不开语法树分析。基于语法树分析，能够实现许多有趣实用的工具。本篇将结合示例，展现如何基于ast标准包操做语法树。node</p><br />
<br />
<p>本篇中的代码的完整示例能够在这里找到：ast-examplegit</p><br />
<br />
<p>Quick Start<br />
首先咱们看下语法树长什么样子，如下代码将打印./demo.go文件的语法树：github</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
	“go/ast”<br />
	“go/parser”<br />
	“go/token”<br />
	“log”<br />
	“path/filepath”<br />
)</p><br />
<br />
<p>func main() {<br />
	fset := token.NewFileSet()<br />
	// 这里取绝对路径，方便打印出来的语法树能够转跳到编辑器<br />
	path, _ := filepath.Abs(“./demo.go”)<br />
	f, err := parser.ParseFile(fset, path, nil, parser.AllErrors)<br />
	if err != nil {<br />
		log.Println(err)<br />
		return<br />
	}<br />
	// 打印语法树<br />
	ast.Print(fset, f)<br />
}</p><br />
<br />
<p>复制代码<br />
demo.go:golang</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
	“context”<br />
)</p><br />
<br />
<p>// Foo 结构体<br />
type Foo struct {<br />
	i int<br />
}</p><br />
<br />
<p>// Bar 接口<br />
type Bar interface {<br />
	Do(ctx context.Context) error<br />
}</p><br />
<br />
<p>// main方法<br />
func main() {<br />
    a := 1<br />
}<br />
复制代码<br />
demo.go文件已尽可能简化，但其语法树的输出内容依旧十分庞大。咱们截取部分来作一些简要的说明。express</p><br />
<br />
<p>首先是文件所属的包名，和其声明在文件中的位置：bash</p><br />
<br />
<p>0  *ast.File {<br />
     1  .  Package: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:1:1<br />
     2  .  Name: *ast.Ident {<br />
     3  .  .  NamePos: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:1:9<br />
     4  .  .  Name: “main”<br />
     5  .  }<br />
     …<br />
复制代码<br />
紧接着是Decls，也就是Declarations，其包含了声明的一些变量，方法，接口等：app</p><br />
<br />
<p>…<br />
     6  .  Decls: []ast.Decl (len = 4) {<br />
     7  .  .  0: <em>ast.GenDecl {<br />
     8  .  .  .  TokPos: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:3:1<br />
     9  .  .  .  Tok: import<br />
    10  .  .  .  Lparen: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:3:8<br />
    11  .  .  .  Specs: []ast.Spec (len = 1) {<br />
    12  .  .  .  .  0: *ast.ImportSpec {<br />
    13  .  .  .  .  .  Path: *ast.BasicLit {<br />
    14  .  .  .  .  .  .  ValuePos: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:4:2<br />
    15  .  .  .  .  .  .  Kind: STRING<br />
    16  .  .  .  .  .  .  Value: “"context"”<br />
    17  .  .  .  .  .  }<br />
    18  .  .  .  .  .  EndPos: -<br />
    19  .  .  .  .  }<br />
    20  .  .  .  }<br />
    21  .  .  .  Rparen: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:5:1<br />
    22  .  .  }<br />
 ….<br />
复制代码<br />
能够看到该语法树包含了4条Decl记录，咱们取第一条记录为例，该记录为</em>ast.GenDecl类型。不难看出这条记录对应的是咱们的import代码段。始位置(TokPos)，左右括号的位置(Lparen,Rparen)，和import的包（Specs）等信息都能从语法树中获得。编辑器</p><br />
<br />
<p>语法树的打印信来自ast.File结构体：ide</p><br />
<br />
<p>$GOROOT/src/go/ast/ast.go函数</p><br />
<br />
<p>// 该结构体位于标准包 go/ast/ast.go 中，有兴趣能够转跳到源码阅读更详尽的注释<br />
type File struct {<br />
	Doc        <em>CommentGroup   // associated documentation; or nil<br />
	Package    token.Pos       // position of “package” keyword<br />
	Name       *Ident          // package name<br />
	Decls      []Decl          // top-level declarations; or nil<br />
	Scope      *Scope          // package scope (this file only)<br />
	Imports    []</em>ImportSpec   // imports in this file<br />
	Unresolved []<em>Ident        // unresolved identifiers in this file<br />
	Comments   []</em>CommentGroup // list of all comments in the source file<br />
}<br />
复制代码<br />
结合注释和字段名咱们大概知道每一个字段的含义，接下来咱们详细梳理一下语法树的组成结构。</p><br />
<br />
<p>Node节点<br />
整个语法树由不一样的node组成，从源码注释中能够得知主要有以下三种node：</p><br />
<br />
<p>There are 3 main classes of nodes: Expressions and type nodes, statement nodes, and declaration nodes.</p><br />
<br />
<p>在Go的Language Specification中能够找到这些节点类型详细规范和说明，有兴趣的小伙伴能够深刻研究一下，在此不作展开。</p><br />
<br />
<p>但实际在代码，出现了第四种node：Spec Node，每种node都有专门的接口定义：</p><br />
<br />
<p>$GOROOT/src/go/ast/ast.go</p><br />
<br />
<p>…<br />
// All node types implement the Node interface.<br />
type Node interface {<br />
	Pos() token.Pos // position of first character belonging to the node<br />
	End() token.Pos // position of first character immediately after the node<br />
}</p><br />
<br />
<p>// All expression nodes implement the Expr interface.<br />
type Expr interface {<br />
	Node<br />
	exprNode()<br />
}</p><br />
<br />
<p>// All statement nodes implement the Stmt interface.<br />
type Stmt interface {<br />
	Node<br />
	stmtNode()<br />
}</p><br />
<br />
<p>// All declaration nodes implement the Decl interface.<br />
type Decl interface {<br />
	Node<br />
	declNode()<br />
}<br />
…</p><br />
<br />
<p>// A Spec node represents a single (non-parenthesized) import,<br />
// constant, type, or variable declaration.<br />
//<br />
type (<br />
	// The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.<br />
	Spec interface {<br />
		Node<br />
		specNode()<br />
	}<br />
….<br />
)<br />
复制代码<br />
能够看到全部的node都继承Node接口，记录了node的开始和结束位置。还记得Quick Start示例中的Decls吗？它正是declaration nodes。除去上述四种使用接口进行分类的node，还有些node没有再额外定义接口细分类别，仅实现了Node接口，为了方便描述，在本篇中我把这些节点称为common node。 $GOROOT/src/go/ast/ast.go列举了全部全部节点的实现，咱们从中挑选几个做为例子，感觉一下它们的区别。</p><br />
<br />
<p>Expression and Type<br />
先来看expression node。</p><br />
<br />
<p>$GOROOT/src/go/ast/ast.go</p><br />
<br />
<p>…<br />
	// An Ident node represents an identifier.<br />
	Ident struct {<br />
		NamePos token.Pos // identifier position<br />
		Name    string    // identifier name<br />
		Obj     *Object   // denoted object; or nil<br />
	}<br />
…<br />
复制代码<br />
Indent（identifier）表示一个标识符，好比Quick Start示例中表示包名的Name字段就是一个expression node：</p><br />
<br />
<p>0  *ast.File {<br />
     1  .  Package: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:1:1<br />
     2  .  Name: *ast.Ident { &lt;—-<br />
     3  .  .  NamePos: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:1:9<br />
     4  .  .  Name: “main”<br />
     5  .  }<br />
     …<br />
复制代码<br />
接下来是type node。</p><br />
<br />
<p>$GOROOT/src/go/ast/ast.go</p><br />
<br />
<p>…<br />
	// A StructType node represents a struct type.<br />
	StructType struct {<br />
		Struct     token.Pos  // position of “struct” keyword<br />
		Fields     *FieldList // list of field declarations<br />
		Incomplete bool       // true if (source) fields are missing in the Fields list<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Pointer types are represented via StarExpr nodes.<br />
<br />
// A FuncType node represents a function type.<br />
FuncType struct {<br />
	Func    token.Pos  // position of "func" keyword (token.NoPos if there is no "func")<br />
	Params  *FieldList // (incoming) parameters; non-nil<br />
	Results *FieldList // (outgoing) results; or nil<br />
}<br />
<br />
// An InterfaceType node represents an interface type.<br />
InterfaceType struct {<br />
	Interface  token.Pos  // position of "interface" keyword<br />
	Methods    *FieldList // list of methods<br />
	Incomplete bool       // true if (source) methods are missing in the Methods list<br />
} ... 复制代码 type node很好理解，它包含一些复合类型，例如在Quick Start中出现的StructType,FuncType和InterfaceType。<br />
</code></pre></div></div><br />
<br />
<p>Statement<br />
赋值语句，控制语句（if，else,for，select…）等均属于statement node。</p><br />
<br />
<p>$GOROOT/src/go/ast/ast.go</p><br />
<br />
<p>…<br />
	// An AssignStmt node represents an assignment or<br />
	// a short variable declaration.<br />
	//<br />
	AssignStmt struct {<br />
		Lhs    []Expr<br />
		TokPos token.Pos   // position of Tok<br />
		Tok    token.Token // assignment token, DEFINE<br />
		Rhs    []Expr<br />
	}<br />
…</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// An IfStmt node represents an if statement.<br />
IfStmt struct {<br />
	If   token.Pos // position of "if" keyword<br />
	Init Stmt      // initialization statement; or nil<br />
	Cond Expr      // condition<br />
	Body *BlockStmt<br />
	Else Stmt // else branch; or nil<br />
} ... 复制代码 例如Quick Start中，咱们在main函数中对变量a赋值的程序片断就属于AssignStmt:<br />
</code></pre></div></div><br />
<br />
<p>…<br />
 174  .  .  .  Body: *ast.BlockStmt {<br />
   175  .  .  .  .  Lbrace: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:18:13<br />
   176  .  .  .  .  List: []ast.Stmt (len = 1) {<br />
   177  .  .  .  .  .  0: *ast.AssignStmt { &lt;— 这里<br />
   178  .  .  .  .  .  .  Lhs: []ast.Expr (len = 1) {<br />
   179  .  .  .  .  .  .  .  0: *ast.Ident {<br />
   180  .  .  .  .  .  .  .  .  NamePos: /usr/local/gopath/src/github.com/DrmagicE/ast-example/quickstart/demo.go:19:2<br />
   181  .  .  .  .  .  .  .  .  Name: “a”<br />
…<br />
复制代码<br />
Spec Node<br />
Spec node只有3种，分别是ImportSpec，ValueSpec和TypeSpec：</p><br />
<br />
<p>$GOROOT/src/go/ast/ast.go</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// An ImportSpec node represents a single package import.<br />
ImportSpec struct {<br />
	Doc     *CommentGroup // associated documentation; or nil<br />
	Name    *Ident        // local package name (including "."); or nil<br />
	Path    *BasicLit     // import path<br />
	Comment *CommentGroup // line comments; or nil<br />
	EndPos  token.Pos     // end of spec (overrides Path.Pos if nonzero)<br />
}<br />
<br />
// A ValueSpec node represents a constant or variable declaration<br />
// (ConstSpec or VarSpec production).<br />
//<br />
ValueSpec struct {<br />
	Doc     *CommentGroup // associated documentation; or nil<br />
	Names   []*Ident      // value names (len(Names) &gt; 0)<br />
	Type    Expr          // value type; or nil<br />
	Values  []Expr        // initial values; or nil<br />
	Comment *CommentGroup // line comments; or nil<br />
}<br />
<br />
// A TypeSpec node represents a type declaration (TypeSpec production).<br />
TypeSpec struct {<br />
	Doc     *CommentGroup // associated documentation; or nil<br />
	Name    *Ident        // type name<br />
	Assign  token.Pos     // position of '=', if any<br />
	Type    Expr          // *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes<br />
	Comment *CommentGroup // line comments; or nil<br />
} 复制代码 ImportSpec表示一个单独的import，ValueSpec表示一个常量或变量的声明，TypeSpec则表示一个type声明。例如 在Quick Start示例中，出现了ImportSpec和TypeSpec<br />
</code></pre></div></div><br />
<br />
<p>import (<br />
	“context” // &lt;— 这里是一个ImportSpec node<br />
)</p><br />
<br />
<p>// Foo 结构体<br />
type Foo struct { // &lt;— 这里是一个TypeSpec node<br />
	i int<br />
}<br />
复制代码<br />
在语法树的打印结果中能够看到对应的输出，小伙伴们可自行查找。</p><br />
<br />
<p>Declaration Node<br />
Declaration node也只有三种：</p><br />
<br />
<p>$GOROOT/src/go/ast/ast.go</p><br />
<br />
<p>…<br />
type (<br />
	// A BadDecl node is a placeholder for declarations containing<br />
	// syntax errors for which no correct declaration nodes can be<br />
	// created.<br />
	//<br />
	BadDecl struct {<br />
		From, To token.Pos // position range of bad declaration<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// A GenDecl node (generic declaration node) represents an import,<br />
// constant, type or variable declaration. A valid Lparen position<br />
// (Lparen.IsValid()) indicates a parenthesized declaration.<br />
//<br />
// Relationship between Tok value and Specs element type:<br />
//<br />
//	token.IMPORT  *ImportSpec<br />
//	token.CONST   *ValueSpec<br />
//	token.TYPE    *TypeSpec<br />
//	token.VAR     *ValueSpec<br />
//<br />
GenDecl struct {<br />
	Doc    *CommentGroup // associated documentation; or nil<br />
	TokPos token.Pos     // position of Tok<br />
	Tok    token.Token   // IMPORT, CONST, TYPE, VAR<br />
	Lparen token.Pos     // position of '(', if any<br />
	Specs  []Spec<br />
	Rparen token.Pos // position of ')', if any<br />
}<br />
<br />
// A FuncDecl node represents a function declaration.<br />
FuncDecl struct {<br />
	Doc  *CommentGroup // associated documentation; or nil<br />
	Recv *FieldList    // receiver (methods); or nil (functions)<br />
	Name *Ident        // function/method name<br />
	Type *FuncType     // function signature: parameters, results, and position of "func" keyword<br />
	Body *BlockStmt    // function body; or nil for external (non-Go) function<br />
} ) ... 复制代码 BadDecl表示一个有语法错误的节点； GenDecl用于表示import, const，type或变量声明；FunDecl用于表示函数声明。 GenDecl和FunDecl在Quick Start例子中均有出现，小伙伴们可自行查找。<br />
</code></pre></div></div><br />
<br />
<p>Common Node<br />
除去上述四种类别划分的node,还有一些node不属于上面四种类别：</p><br />
<br />
<p>$GOROOT/src/go/ast/ast.go</p><br />
<br />
<p>// Comment 注释节点，表明单行的 //-格式 或 /*-格式的注释.<br />
type Comment struct {<br />
    …<br />
}<br />
…<br />
// CommentGroup 注释块节点，包含多个连续的Comment<br />
type CommentGroup struct {<br />
    …<br />
}</p><br />
<br />
<p>// Field 字段节点, 能够表明结构体定义中的字段，接口定义中的方法列表，函数前面中的入参和返回值字段<br />
type Field struct {<br />
    …<br />
}<br />
…<br />
// FieldList 包含多个Field<br />
type FieldList struct {<br />
    …<br />
}</p><br />
<br />
<p>// File 表示一个文件节点<br />
type File struct {<br />
	…<br />
}</p><br />
<br />
<p>// Package 表示一个包节点<br />
type Package struct {<br />
    …<br />
}<br />
复制代码<br />
Quick Start示例包含了上面列举的全部node，小伙伴们能够自行查找。更为详细的注释和具体的结构体字段请查阅源码。</p><br />
<br />
<p>全部的节点类型大体列举完毕，其中还有许多具体的节点类型未能一一列举，但基本上都是大同小异，源码注释也比较清晰，等用到的时候再细看也不迟。如今咱们对整个语法树的构造有了基本的了解，接下来经过几个示例来演示具体用法。</p><br />
<br />
<p>示例<br />
为文件中全部接口方法添加context参数<br />
实现这个功能咱们须要四步：</p><br />
<br />
<p>遍历整个语法树<br />
判断是否已经importcontext包，若是没有则import<br />
遍历全部的接口方法，判断方法列表中是否有context.Context类型的入参，若是没有咱们将其添加到方法的第一个参数<br />
将修改事后的语法树转换成Go代码并输出<br />
遍历语法树<br />
语法树层级较深，嵌套关系复杂，若是不能彻底掌握node之间的关系和嵌套规则，咱们很难本身写出正确的遍历方法。不过好在ast包已经为咱们提供了遍历方法：</p><br />
<br />
<p>$GOROOT/src/go/ast/ast.go</p><br />
<br />
<p>func Walk(v Visitor, node Node) <br />
复制代码<br />
type Visitor interface {<br />
	Visit(node Node) (w Visitor)<br />
}<br />
复制代码<br />
Walk方法会按照深度优先搜索方法（depth-first order）遍历整个语法树，咱们只需按照咱们的业务须要，实现Visitor接口便可。 Walk每遍历一个节点就会调用Visitor.Visit方法，传入当前节点。若是Visit返回nil，则中止遍历当前节点的子节点。本示例的Visitor实现以下：</p><br />
<br />
<p>// Visitor<br />
type Visitor struct {<br />
}<br />
func (v <em>Visitor) Visit(node ast.Node) ast.Visitor {<br />
	switch node.(type) {<br />
	case *ast.GenDecl:<br />
		genDecl := node.(</em>ast.GenDecl)<br />
		// 查找有没有import context包<br />
		// Notice：没有考虑没有import任何包的状况<br />
		if genDecl.Tok == token.IMPORT {<br />
			v.addImport(genDecl)<br />
			// 不须要再遍历子树<br />
			return nil<br />
		}<br />
	case <em>ast.InterfaceType:<br />
		// 遍历全部的接口类型<br />
		iface := node.(</em>ast.InterfaceType)<br />
		addContext(iface)<br />
		// 不须要再遍历子树<br />
		return nil<br />
	}<br />
	return v<br />
}<br />
复制代码<br />
添加import<br />
// addImport 引入context包<br />
func (v <em>Visitor) addImport(genDecl *ast.GenDecl) {<br />
	// 是否已经import<br />
	hasImported := false<br />
	for _, v := range genDecl.Specs {<br />
		imptSpec := v.(</em>ast.ImportSpec)<br />
		// 若是已经包含”context”<br />
		if imptSpec.Path.Value == strconv.Quote(“context”) {<br />
			hasImported = true<br />
		}<br />
	}<br />
	// 若是没有import context，则import<br />
	if !hasImported {<br />
		genDecl.Specs = append(genDecl.Specs, &amp;ast.ImportSpec{<br />
			Path: &amp;ast.BasicLit{<br />
				Kind:  token.STRING,<br />
				Value: strconv.Quote(“context”),<br />
			},<br />
		})<br />
	}<br />
}</p><br />
<br />
<p>复制代码<br />
为接口方法添加参数<br />
// addContext 添加context参数<br />
func addContext(iface <em>ast.InterfaceType) {<br />
	// 接口方法不为空时，遍历接口方法<br />
	if iface.Methods != nil || iface.Methods.List != nil {<br />
		for _, v := range iface.Methods.List {<br />
			ft := v.Type.(</em>ast.FuncType)<br />
			hasContext := false<br />
			// 判断参数中是否包含context.Context类型<br />
			for _, v := range ft.Params.List {<br />
				if expr, ok := v.Type.(<em>ast.SelectorExpr); ok {<br />
					if ident, ok := expr.X.(</em>ast.Ident); ok {<br />
						if ident.Name == “context” {<br />
							hasContext = true<br />
						}<br />
					}<br />
				}<br />
			}<br />
			// 为没有context参数的方法添加context参数<br />
			if !hasContext {<br />
				ctxField := &amp;ast.Field{<br />
					Names: []<em>ast.Ident{<br />
						ast.NewIdent(“ctx”),<br />
					},<br />
					// Notice: 没有考虑import别名的状况<br />
					Type: &amp;ast.SelectorExpr{<br />
						X:   ast.NewIdent(“context”),<br />
						Sel: ast.NewIdent(“Context”),<br />
					},<br />
				}<br />
				list := []</em>ast.Field{<br />
					ctxField,<br />
				}<br />
				ft.Params.List = append(list, ft.Params.List…)<br />
			}<br />
		}<br />
	}<br />
}<br />
复制代码<br />
将语法树转换成Go代码<br />
format包为咱们提供了转换函数，format.Node会将语法树按照gofmt的格式输出：</p><br />
<br />
<p>…<br />
	var output []byte<br />
	buffer := bytes.NewBuffer(output)<br />
	err = format.Node(buffer, fset, f)<br />
	if err != nil {<br />
		log.Fatal(err)<br />
	}<br />
	// 输出Go代码<br />
	fmt.Println(buffer.String())<br />
…<br />
复制代码<br />
输出结果以下：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
        “context”<br />
)</p><br />
<br />
<p>type Foo interface {<br />
        FooA(ctx context.Context, i int)<br />
        FooB(ctx context.Context, j int)<br />
        FooC(ctx context.Context)<br />
}</p><br />
<br />
<p>type Bar interface {<br />
        BarA(ctx context.Context, i int)<br />
        BarB(ctx context.Context)<br />
        BarC(ctx context.Context)<br />
}<br />
复制代码<br />
能够看到咱们全部的接口方的第一个参数都变成了context.Context。建议将示例中的语法树先打印出来，再对照着代码看，方便理解。</p><br />
<br />
<p>一些坑与不足<br />
至此咱们已经完成了语法树的解析，遍历，修改以及输出。但细心的小伙伴可能已经发现：示例中的文件并无出现一行注释。这的确是有意为之，若是咱们加上注释，会发现最终生成文件的注释就像迷途的羔羊，彻底找不到本身的位置。好比这样：</p><br />
<br />
<p>//修改前<br />
type Foo interface {<br />
	FooA(i int)<br />
	// FooB<br />
	FooB(j int)<br />
	FooC(ctx context.Context)<br />
}</p><br />
<br />
<p>// 修改后<br />
type Foo interface {<br />
    FooA(ctx context.<br />
            // FooB<br />
            Context, i int)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FooB(ctx context.Context, j int)<br />
FooC(ctx context.Context) } 复制代码 致使这种现象的缘由在于：ast包生成的语法树中的注释是"free-floating"的。还记得每一个node都有Pos()和End()方法来标识其位置吗？对于非注释节点，语法树可以正确的调整他们的位置，但却不能自动调整注释节点的位置。若是咱们想要让注释出如今正确的位置上，咱们必须手动设置节点Pos和End。源码注释中提到了这个问题：<br />
</code></pre></div></div><br />
<br />
<p>Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: Except for Doc and Comment comments directly associated with nodes, the remaining comments are “free-floating” (see also issues #18593, #20744).</p><br />
<br />
<p>issue中有具体的讨论，官方认可这是一个设计缺陷，但仍是迟迟未能改进。其中有位火烧眉毛的小哥提供了本身的方案：</p><br />
<br />
<p>github.com/dave/dst</p><br />
<br />
<p>若是实在是要对有注释的语法树进行修改，能够尝试一下。 虽然语法树的确存在修改困难问题，但其仍是能知足大部分基于语法树分析的代码生成工做了(gomock,wire等等)。</p><br />
<br />
<p>https://studygolang.com/articles/19353?fr=sidebar</p><br />
<br />
<p>https://blog.csdn.net/weixin_33851429/article/details/91449588</p><br />
<br />
<p>https://www.shangmayuan.com/a/42992bc766534cba9658bca9.html</p><br />
<br />
<p>https://www.jianshu.com/p/428d663cb2d8</p><br />
<br />
<p>Go语言有很多工具, goimports用于package的自动导入或者删除, golint用于检查源码中不符合Go coding style的地方, 比如全名,注释等. 还有其它工具如gorename, guru等工具. 作为工具它们都是使用go语言(查看)开发的, 这些工具都有一个共同点就是: 读取源代码, 分析源代码, 修改或生成新代码.</p><br />
<br />
<p>简述</p><br />
<br />
<p>很多编程语言/库/框架等都能生成代码, 比如使用rails, 可以轻松地new一个project出来, 生成项目基本代码, 我们称其为boilerplate, 或者template, 这已经习以为常了. 像ruby的动态语言通常能在运行时生成代码, 我们称之为meta programming(元编程), 比如rails的resources可以生成restful的router出来.因为是运行时动态生成, 因此可能会遇到exception, 以及性能方面有所损失.</p><br />
<br />
<p>像elixir这种编程语言的macro则比ruby的元编程方面向”前”一步, 它在编译期生成代码, 而不在运行时生成, 好处是可以生成大量的代码而对性能几乎没有太大影响. 像phoenix框架的router查看部分, 则通过macro生成大量的函数, 利用BEAM的pattern matching机制高效路由.elixir的macro是写在源代码里的, 而Go则可以分离.</p><br />
<br />
<p>Go语言可以通过reflect包同样做到ruby的运行时生成代码(比如创建对象), 但更强大的一点是, 它通过读取源码, 再修改源码, 生成新的代码.我们可以将这个过程单独写作一个工具, 这个工具可以适用于不同的项目.</p><br />
<br />
<p>例子</p><br />
<br />
<p>stringer</p><br />
<br />
<p>package game</p><br />
<br />
<p>//go:generate stringer -type=GameStatus<br />
// 注意//与go:generate字符之间不能有空格<br />
// GameStatus 表示比赛的状态<br />
type GameStatus int</p><br />
<br />
<p>const (<br />
    Unvalid GameStatus = iota<br />
    ValidFailed<br />
    Valid<br />
    Register<br />
    Start<br />
    Running<br />
    End<br />
)<br />
运行 go generate 会生成gamestatus_string.go文件, 并且实现了Stringer接口.</p><br />
<br />
<p>同样的例子在gRPC中也出现过code, 生成的string.正如Rob Pike所说:</p><br />
<br />
<p>let the mechine do the work.source</p><br />
<br />
<p>gen_columns</p><br />
<br />
<p>很多项目在使用数据库时, 通过tag指定数据库里的字段名字, 在写SQL时, 又只能通过字符串来表示字段名, 因此如果某一个字段名修改时, 则意味着涉及到此字段的SQL都面临着修改, 而我们希望只需要修改一个地方.</p><br />
<br />
<p>有一个结构作为数据库表结构如下:</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
type User struct {<br />
    ID int <code class="language-plaintext highlighter-rouge">json:"id" bson:"id"</code><br />
    Name string <code class="language-plaintext highlighter-rouge">json:"name" bson:"name"</code><br />
}<br />
当使用这个model里的字段进行sql查询时, 通常使用:</p><br />
<br />
<p>1<br />
2<br />
3<br />
map[string]interface{}{<br />
    “id”:123456,<br />
}<br />
作为查询条件, 如果当字段名更改时, 不得不修改这个map里的key值<br />
如果能够自动生成一个结构体, 用于表示这些column name值, 那么只需修改一处:</p><br />
<br />
<p>1<br />
2<br />
3<br />
map[string]interface{}{<br />
    UserColumns.ID: 123456<br />
}</p><br />
<br />
<p>使用方法</p><br />
<br />
<p>1<br />
gen_columns -tag=”bson” -path=”./models/user.go”<br />
会生成一个独立的文件, 里面的内容为:</p><br />
<br />
<p>package models</p><br />
<br />
<p>type _UserColumn struct {<br />
    ID   string<br />
    Name string<br />
}</p><br />
<br />
<p>var UserColumns _UserColumn</p><br />
<br />
<p>func init() {<br />
    UserColumns.ID = “id”<br />
    UserColumns.Name = “name”</p><br />
<br />
<p>}</p><br />
<br />
<p>总结<br />
gen_columns是自己在项目中遇到问题所给出的解决办法, 第一版本是通过reflect做的, 总共需要好几个步骤; 使用ast做就只需在编译时多加一个go generate, 而这命令基本上可以集成在build的脚本里, 因此不需要再额外担心代码生成的问题.<br />
让我们用Go创造更多生成代码的工具吧.</p><br />
<br />
<p>https://www.cnblogs.com/qgymje/p/5879375.html</p><br />
<br />
<p>https://studygolang.com/articles/5147</p><br />
<br />
<p>Tokenizer 和 Lexical anaylizer<br />
如果你知道tokenizer和lexical anaylizer是什么的话，请跳到下一章，不熟的话请看下面这个最简单的go代码</p><br />
<br />
<p>package main<br />
func main() {<br />
     println(“Hello, World!”)<br />
}<br />
这段go代码做了什么？很简单吧，package是main，定义了个main函数，main函数里调用了println函数，参数是”Hello, World!“。好，你是知道了，可当你运行go run时，go怎么知道的？go先要把你的代码打散成自己可以理解的构成部分（token），这一过程就叫tokenize。例如，第一行就被拆成了package和main。 这个阶段，go就像小婴儿只会理解我、要、吃饭等词，但串不成合适句子。因为”吃饭我要”是讲不通的，所以把词按一定的语法串起来的过程就是lexical anaylize或者parse，简单吧！和人脑不同的是，被程序理解的代码，通常会以abstract syntax tree（AST）的形式存储起来，方便进行校验和查找。</p><br />
<br />
<p>Go的AST<br />
那我们来看看go的ast库对代码的理解程度是不是小婴儿吧（可运行的源代码在此），其实就是token+parse刚才我们看到的上一章代码，并且按AST的方式打印出来，结果在这里</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “go/ast”<br />
    “go/parser”<br />
    “go/token”<br />
)</p><br />
<br />
<p>func main() {<br />
    // 这就是上一章的代码.<br />
    src := `<br />
package main<br />
func main() {<br />
    println(“Hello, World!”)<br />
}<br />
`</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Create the AST by parsing src.<br />
fset := token.NewFileSet() // positions are relative to fset<br />
f, err := parser.ParseFile(fset, "", src, 0)<br />
if err != nil {<br />
    panic(err)<br />
}<br />
<br />
// Print the AST.<br />
ast.Print(fset, f)<br />
</code></pre></div></div><br />
<br />
<p>}<br />
为了不吓到你，我先只打印前6行：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 0  *ast.File {<br />
 1  .  Package: 2:1<br />
 2  .  Name: *ast.Ident {<br />
 3  .  .  NamePos: 2:9<br />
 4  .  .  Name: "main"<br />
 5  .  }  <br />
 // 省略之后的50＋行 可见，go 解析出了package这个关键词在文本的第二行的第一个（2:1）。”main”也解析出来了，在第二行的第9个字符，但是go的解析器还给它安了一个叫法：ast.Ident, 标示符 或者大家常说的ID，如下图所示：<br />
</code></pre></div></div><br />
<br />
<p>Ident +————+<br />
                   |                       <br /><br />
Package +—–+    |<br />
              v    v<br />
           package main<br />
接下来我们看看那个main函数被整成了什么样。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 6  .  Decls: []ast.Decl (len = 1) {<br />
 7  .  .  0: *ast.FuncDecl {<br />
 8  .  .  .  Name: *ast.Ident {<br />
 9  .  .  .  .  NamePos: 3:6<br />
10  .  .  .  .  Name: "main"<br />
11  .  .  .  .  Obj: *ast.Object {<br />
12  .  .  .  .  .  Kind: func<br />
13  .  .  .  .  .  Name: "main"<br />
14  .  .  .  .  .  Decl: *(obj @ 7) 此处func main被解析成ast.FuncDecl（function declaration）,而函数的参数（Params）和函数体（Body）自然也在这个FuncDecl中。Params对应的是*ast.FieldList，顾名思义就是项列表；而由大括号”｛｝”组成的函数体对应的是ast.BlockStmt（block statement）。如果不清楚，可以参考下面的图：<br />
<br />
             FuncDecl.Params +----------+<br />
                                        |<br />
               FuncDecl.Name +--------+ |<br />
                                      v v<br />
      +----------------------&gt; func main() {<br />
      |                    +-&gt; FuncDecl ++    FuncDecl.Body +-+       println("Hello, World!")<br />
      |                    +-&gt;<br />
      +----------------------&gt; } 而对于main函数的函数体中，我们可以看到调用了println函数，在ast中对应的是ExprStmt（Express Statement），调用函数的表达式对应的是CallExpr(Call Expression)，调用的参数自然不能错过，因为参数只有字符串，所以go把它归为ast.BasicLis (a literal of basic type)。如下图所示：<br />
</code></pre></div></div><br />
<br />
<p>+—–+ ExprStmt +—————+<br />
|                                |<br />
|    CallExpr   BasicLit         |<br />
|        +          +            |<br />
|        v          v            |<br />
+—&gt; println(“Hello, World!”)&lt;–+<br />
还有什么？<br />
    50  .  Scope: <em>ast.Scope {<br />
    51  .  .  Objects: map[string]</em>ast.Object (len = 1) {<br />
    52  .  .  .  “main”: <em>(obj @ 11)<br />
    53  .  .  }<br />
    54  .  }<br />
    55  .  Unresolved: []</em>ast.Ident (len = 1) {<br />
    56  .  .  0: *(obj @ 29)<br />
    57  .  }<br />
    58  }<br />
我们可以看出ast还解析出了函数的作用域，以及作用域对应的对象。</p><br />
<br />
<p>https://www.cnblogs.com/skzxc/p/12944921.html</p><br />
<br />
<p>https://www.cntofu.com/book/73/ch7-ast/readme.md</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/137196665</p><br />
<br />
<p>http://www.verydoc.net/go/00003872.html</p><br />
<br />
<p>https://developer.51cto.com/art/201911/606075.htm</p><br />
<br />
<p>http://blog.sina.com.cn/s/blog_a2e9bb2b0102x0gm.html</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>