<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">Markdown</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-07-02T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jul 2, 2020</time></p>
					</div>
					 <p>我们经常会在一些 Markdown 解析库的描述中看到类似这样的话：兼容 CommonMark，支持 GFM 扩展等。</p><br />
<br />
<p>CommonMark 是什么<br />
这是 Markdown 标准或规范。CommonMark 官网（https://commonmark.org ）提到：</p><br />
<br />
<p>由于没有明确的规范，Markdown 解析渲染会有很大差异。因此用户经常会发现在一个系统（例如 GitHub）上渲染正常的文档在另一个系统上渲染不正常。更糟糕的是由于 Markdown 中不存在“语法错误”，所以无法立即发现这类问题。</p><br />
<br />
<p>在 Markdown 处理上“模糊的正确”是不可取的。所以 CommonMark 规范的目的就是消除二义性，制定统一明确的 Markdown 解析渲染规则。</p><br />
<br />
<p>该规范的主要参与者包括：</p><br />
<br />
<p>David Greenspan, 来自 Meteor<br />
Vicent Marti, 来自 GitHub<br />
Neil Williams, 来自 Reddit<br />
Benjamin Dumke-von der Ehe, 来自 Stack Exchange<br />
Jeff Atwood, 前 Stack Exchange 联合创始人，Discourse 创始人<br />
从作者阵容我们可以看出，该规范算是众望所归了，因为这几大社区都需要一个标准化的 Markdown。</p><br />
<br />
<p>至于规范的具体内容，有兴趣的可以看官网上的规范定义文档，其中的一些点，在后文介绍 Go 语言的 Markdown 解析器时会介绍。</p><br />
<br />
<p>GFM 又是什么<br />
有了 CommonMark（标准 Markdown），为什么又会有 GFM？</p><br />
<br />
<p>GFM 是 GitHub Flavored Markdown 的缩写，即 GitHub 风格的 Markdown，它和标准 Markdown 存在一些差异，主要是增加一些功能，所以一般叫做 GFM 扩展。类似的、基于标准 Markdown 的衍生分支有很多，但因为 GitHub 的流行，GFM 几乎成为了最强大的一个，而且各种解析器、编辑器都会支持 GFM。</p><br />
<br />
<p>对于大部分人来说，关于 CommonMark 和 GFM，知道这么多就够了。GFM 规范见：https://github.github.com/gfm/。</p><br />
<br />
<p>Go 语言 Markdown 解析器<br />
在 GitHub 上一搜，发现 Go 语言 Markdown 解析器不止一个，如何选择呢？一般来说根据 Star 数来。另外，如果是实现某个规范的库，看这个规范有无推荐。比如我们找的是 Markdown 库，看看 CommonMark 有无推荐。</p><br />
<br />
<p>在 List of CommonMark Implementations 列出了各个语言的 CommonMark 实现，其中 Go 语言列出了 4 个。虽然 russross/blackfriday 是最早也是 Star 数最多的 Go 语言 Markdown 解析库，然而它不兼容 CommonMark。</p><br />
<br />
<p>因为 Hugo 从 0.60.0 开始，Markdown 解析器默认使用 yuin/goldmark，之前使用的是 blackfriday。因此本文我们主要通过学习 goldmark 这个解析器来深入学习 Markdown。</p><br />
<br />
<p>https://mp.weixin.qq.com/s?src=11&amp;timestamp=1593653764&amp;ver=2435&amp;signature=83wG-zrlxgsy7KXkBAG7dMEfnEL2j3YDDdGsOo7hmDH2MCXxddmpxOpz3FwhTVZ<em>5GyJUDP3lPCL15iKSYE</em>FYnn0awEmq1xy5wolo6BtFImKzKAVKVaR9XTgkMhwlG5&amp;new=1</p><br />
<br />
<p>https://studygolang.com/markdown<br />
https://github.github.com/gfm</p><br />
<br />
<p>https://github.com/russross/blackfriday<br />
https://github.com/yuin/goldmark<br />
<!-- more --><br />
简介<br />
goldmark 是一个用 Go 编写的 Markdown 解析器。易于扩展，符合标准，结构良好。它兼容最新的 CommonMark 0.29 规范。</p><br />
<br />
<p>该库希望满足如下需求：</p><br />
<br />
<p>易于扩展<br />
与其他轻量级标记语言（例如 reStructuredText）相比，Markdown 在文档表达式方面的表现较差。<br />
我们可以对 Markdown 语法进行了扩展，例如 PHP Markdown Extra，GitHub 风格 Markdown（GFM）。<br />
符合标准<br />
CommonMark 复杂且难以完全实现。<br />
Markdown 有许多方言。<br />
GitHub Flavored Markdown 被广泛使用并且基于 CommonMark，有效地提出了 CommonMark 是否是理想规范的问题。<br />
结构良好<br />
基于 AST；保留节点的源位置。<br />
纯 Go 语言实现<br />
基于此，该库具有如下一些特性：</p><br />
<br />
<p>符合标准。goldmark 完全符合最新的 CommonMark 规范。<br />
可扩展。你是否要在 Markdown 中添加 @username 提到谁的语法？你可以轻松地在 goldmark 中实现。你可以添加 AST 节点，用于块级元素的解析器，用于内联级元素的解析器，用于段落的转换器，用于整个 AST 结构的转换器以及渲染器等。<br />
性能。goldmark 的性能与用 C 语言编写的 CommonMark 参考实现 cmark 的性能相当。<br />
健壮性。goldmark 已通过模糊测试工具 go-fuzz 进行了测试。<br />
内置扩展。goldmark 附带了常见的扩展，例如表格，删除线，任务列表和定义列表。<br />
只依赖标准库。<br />
使用<br />
本文使用的 Go 版本是 1.14.x，依赖管理使用 Go Module。</p><br />
<br />
<p>首先安装 goldmark：</p><br />
<br />
<p>$ go get github.com/yuin/goldmark<br />
为了方便演示，我们使用 https://studygolang.com/markdown 上的教程作为原始 markdown 内容（部分内容是 studygolang 特有的）。</p><br />
<br />
<p>Demo1<br />
代码如下：</p><br />
<br />
<p>func demo1() {<br />
 source, err := ioutil.ReadFile(“guide.md”)<br />
 if err != nil {<br />
  panic(err)<br />
 }</p><br />
<br />
<p>f, err := os.Create(“guide1.html”)<br />
 if err != nil {<br />
  panic(err)<br />
 }</p><br />
<br />
<p>err = goldmark.Convert(source, f)<br />
 if err != nil {<br />
  panic(err)<br />
 }<br />
}<br />
guide.md 存放 https://studygolang.com/markdown 上的原始 markdown 内容，略有增减；<br />
通过 goldmark 的 Convert 函数将  markdown 转为 html，没有使用任何选项；<br />
在项目目录生成 guide1.html，在浏览器中打开，发现存在以下问题：</p><br />
<br />
<p>不支持自动链接，例如 https://studygolang.com 不会被识别为链接；<br />
不支持删除线，即 ~~；<br />
不支持表格；<br />
不支持任务列表；<br />
不支持语法高亮；<br />
不支持 @；<br />
不支持表情；<br />
Demo2<br />
demo1 中问题 1-4 是 GFM 支持的语法，因此我们可以通过 goldmark 内置的 GFM 扩展实现。</p><br />
<br />
<p>func demo2() {<br />
 source, err := ioutil.ReadFile(“guide.md”)<br />
 if err != nil {<br />
  panic(err)<br />
 }</p><br />
<br />
<p>f, err := os.Create(“guide2.html”)<br />
 if err != nil {<br />
  panic(err)<br />
 }</p><br />
<br />
<p>// 自定义解析器<br />
 markdown := goldmark.New(<br />
  // 支持 GFM<br />
  goldmark.WithExtensions(extension.GFM),<br />
 )</p><br />
<br />
<p>err = markdown.Convert(source, f)<br />
 if err != nil {<br />
  panic(err)<br />
 }<br />
}<br />
验证上面问题 1-4 发现都解决了；<br />
这里关于自动链接，有一个小问题：中文标点符号问题。自动链接：https://studygolang.com 这里的冒号是中文的，因此识别不出来。所以，如果使用自动链接，注意链接前后加上英文空格；或单独链接总是使用 &lt;&gt; 包裹，这是 CommonMark 支持的语法；<br />
Dome3<br />
语法高亮问题，虽然 goldmark 库没有内置该扩展，但该库作者在另外一个包实现了，这就是 goldmark-highlighting。</p><br />
<br />
<p>func demo3() {<br />
 source, err := ioutil.ReadFile(“guide.md”)<br />
 if err != nil {<br />
  panic(err)<br />
 }</p><br />
<br />
<p>f, err := os.Create(“guide3.html”)<br />
 if err != nil {<br />
  panic(err)<br />
 }</p><br />
<br />
<p>// 自定义解析器<br />
 markdown := goldmark.New(<br />
  // 支持 GFM<br />
  goldmark.WithExtensions(extension.GFM),<br />
  // 语法高亮<br />
  goldmark.WithExtensions(<br />
   highlighting.NewHighlighting(<br />
    highlighting.WithStyle(“monokai”),<br />
    highlighting.WithFormatOptions(<br />
     html.WithLineNumbers(true),<br />
    ),<br />
   ),<br />
  ),<br />
 )</p><br />
<br />
<p>err = markdown.Convert(source, f)<br />
 if err != nil {<br />
  panic(err)<br />
 }<br />
}<br />
这是语法高亮后的效果：</p><br />
<br />
<p>语法高亮使用的是一个 Go 第三方库：alecthomas/chroma<br />
学习 goldmark 的设计<br />
上节遗留的问题先不处理，因为涉及到扩展 goldmark，我们先学习下 goldmark 的设计。</p><br />
<br />
<p>该库的主包（github.com/yuin/goldmark）公开的内容不多，一共 3 个类型和 3 个函数。</p><br />
<br />
<p>Markdown 是一个接口<br />
type Markdown interface {<br />
 // Convert interprets a UTF-8 bytes source in Markdown and write rendered<br />
 // contents to a writer w.<br />
 Convert(source []byte, writer io.Writer, opts …parser.ParseOption) error</p><br />
<br />
<p>// Parser returns a Parser that will be used for conversion.<br />
 Parser() parser.Parser</p><br />
<br />
<p>// SetParser sets a Parser to this object.<br />
 SetParser(parser.Parser)</p><br />
<br />
<p>// Parser returns a Renderer that will be used for conversion.<br />
 Renderer() renderer.Renderer</p><br />
<br />
<p>// SetRenderer sets a Renderer to this object.<br />
 SetRenderer(renderer.Renderer)<br />
}<br />
解析器：Parser<br />
渲染器：Renderer<br />
解析 markdown 文本并将渲染的结果写入 io.Writer 中<br />
从这个接口的定义可以看到，我们可以定义自己的 Parser 或 Renderer 来改变 goldmark 的工作方式。一般我们不需要这么做，只需要使用默认的实现即可，这也就是 DefaultParser() 和 DefaultRenderer() 两个函数的作用。另外，在转换时（Convert）支持指定解析选项。</p><br />
<br />
<p>然而在该包中，我们并没有看到 Markdown 接口的实现类型。很显然，实现类型没有导出。这体现了“依赖抽象而不依赖具体”的设计原则。</p><br />
<br />
<p>看看获取 Markdown 接口实例的 New 函数：</p><br />
<br />
<p>func New(options …Option) Markdown<br />
该函数接收一个不定参数：Option，用于控制 Markdown 的行为。这里引出了 Go 中常见的一个设计模式。</p><br />
<br />
<p>Go 不是完全的面向对象语言。当类型中有较多成员，且可以通过外部控制时，根据封装的原则，一般不建议将这些字段导出（公开），但这样一来构造函数就需要能接收很多参数；亦或是希望通过其他方式扩展。在 Go 中有两种较常见的设计方法。</p><br />
<br />
<p>1）通过另外一个结构体来控制</p><br />
<br />
<p>这里以 BigCache 这个包为例，该包中的 Config 结构体就是这种设计。这么做有什么好处？</p><br />
<br />
<p>func NewBigCache(config Config) (*BigCache, error)<br />
一方面控制了 BigCache 类型的行为，避免实例化后可以随意更改，起到了封装的作用。另一方面，让构造函数更简洁，只需要接收一个 Config 即可（注意最好使用 Config 值类型，而不是指针）。而且可以通过提供一些 Config 的默认值来做到更易用，比如 bigcache.DefaultConfig() 函数就是这样的例子。</p><br />
<br />
<p>2）通过一个函数类型来控制</p><br />
<br />
<p>前面提到，goldmark 只导出了 Markdown 接口，并没有导出该接口的具体实现类型。那想要控制具体实现类型的行为怎么办呢？这就是 Option 这个函数类型的作用：接收一个 markdown 类型指针（注意这里不是 Markdown 接口，而是实现了该接口的具体类型）</p><br />
<br />
<p>type Option func(*markdown)<br />
然后构造函数中接收一个 Option 类型的不定参数，来控制 Markdown 的行为。</p><br />
<br />
<p>func New(options …Option) Markdown<br />
为了方便使用 ，一般包会提供若干获得 Option 实例的方法。goldmark 包提供了 5 个返回 Option 的函数：</p><br />
<br />
<p>// 增加扩展<br />
func WithExtensions(ext …Extender) Option<br />
// 允许你覆盖默认的 Parser<br />
func WithParser(p parser.Parser) Option<br />
// 为 Parser 修改配置选项<br />
func WithParserOptions(opts …parser.Option) Option<br />
// 允许你覆盖默认的 Render<br />
func WithRenderer(r renderer.Renderer) Option<br />
// 为 Renderer 修改配置选项<br />
func WithRendererOptions(opts …renderer.Option) Option<br />
在 Demo3 中使用了 WithExtensions() 为解析器增加扩展，该函数接收一个 Extender 类型的不定参数。</p><br />
<br />
<p>Extender 也是一个接口<br />
该接口用于扩展 Markdown，因此方法接收一个 Markdown 参数：</p><br />
<br />
<p>type Extender interface {<br />
 // Extend extends the Markdown.<br />
 Extend(Markdown)<br />
}<br />
由此可见，所谓的 goldmark 扩展，就是一个实现了 Extender 接口的类型。</p><br />
<br />
<p>Convert 函数<br />
这是一个为了方便使用的函数，在 Go 语言标准库中有大量这样的设计。</p><br />
<br />
<p>针对包的主要类型提供一个默认实例，包级便利函数直接调用该默认实例的相应方法</p><br />
<br />
<p>比如 log 包中的 std 是一个默认的 Logger 实例、net/http 包中的 DefaultClient 是一个默认的 Client 实例。</p><br />
<br />
<p>而 Convert 函数的实现如下：</p><br />
<br />
<p>func Convert(source []byte, w io.Writer, opts …parser.ParseOption) error {<br />
 return defaultMarkdown.Convert(source, w, opts…)<br />
}<br />
其中 defaultMarkdown 就是一个 Markdown 的实例：</p><br />
<br />
<p>var defaultMarkdown = New()<br />
因此最终调用的还是 Markdown 接口的 Convert 方法。</p><br />
<br />
<p>New 函数<br />
最后看看该包 New 函数实现：</p><br />
<br />
<p>// New returns a new Markdown with given options.<br />
func New(options …Option) Markdown {<br />
 md := &amp;markdown{<br />
  parser:     DefaultParser(),<br />
  renderer:   DefaultRenderer(),<br />
  extensions: []Extender{},<br />
 }<br />
 for _, opt := range options {<br />
  opt(md)<br />
 }<br />
 for _, e := range md.extensions {<br />
  e.Extend(md)<br />
 }<br />
 return md<br />
}<br />
markdown 实现了 Markdown 接口；</p><br />
<br />
<p>parser 和 renderer 使用 goldmark 包默认的；</p><br />
<br />
<p>遍历执行 Options；如果 Option 是 Extender，则 md.extensions 会赋上值：</p><br />
<br />
<p>func WithExtensions(ext …Extender) Option {<br />
 return func(m *markdown) {<br />
  m.extensions = append(m.extensions, ext…)<br />
 }<br />
}<br />
最后遍历执行 Extender 的 Extend 方法；</p><br />
<br />
<p>小结<br />
从 goldmark 的设计和源码看出，它大量使用接口，包括 Parser 和 Renderer 都是接口，这使得它具有极强的可扩展性。接下来我们会尝试自己实现一个 goldmark 扩展。</p><br />
<br />
<p>自己实现一个 goldmark 扩展<br />
上面我们遗留了两个问题没有处理，即支持 @ 和 :+1: 这种形式的表情。现在我们通过实现自己的扩展来解决这两个问题。</p><br />
<br />
<p>如何实现一个扩展<br />
goldmark 的文档有一些扩展开发的内容，提供了一个 goldmark 处理 markdown 的概要图：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        &lt;Markdown in []byte, parser.Context&gt;<br />
                       |<br />
                       V<br />
        +-------- parser.Parser ---------------------------<br />
        | 1. Parse block elements into AST<br />
        |   1. If a parsed block is a paragraph, apply <br />
        |      ast.ParagraphTransformer<br />
        | 2. Traverse AST and parse blocks.<br />
        |   1. Process delimiters(emphasis) at the end of<br />
        |      block parsing<br />
        | 3. Apply parser.ASTTransformers to AST<br />
                       |<br />
                       V<br />
                  &lt;ast.Node&gt;<br />
                       |<br />
                       V<br />
        +------- renderer.Renderer ------------------------<br />
        | 1. Traverse AST and apply renderer.NodeRenderer<br />
        |    corespond to the node type<br />
<br />
                       |<br />
                       V<br />
                    &lt;Output&gt; 你可能看着有点晕。整体上扩展开发有 4 个工作：<br />
</code></pre></div></div><br />
<br />
<p>定义一个 AST（抽象语法树）节点（结构体），该节点需要嵌入一个 ast.BaseBlock 或 ast.BaseInline；<br />
定义一个解析器（Parser），实现 parser.BlockParser 或 parser.InlineParser；<br />
定义一个渲染器（Renderer），实现 renderer.NodeRenderer；<br />
定义一个 goldmark 扩展，实现 goldmark.Extender；<br />
其中 Block 和 Inline 是什么意思？学习过 Web 前端的应该了解。Markdown 和 HTML 类似，将内容元素分为块级元素（Block）和行级元素（Inline）：（块级元素优先级高于行级元素）</p><br />
<br />
<p>块级元素：块引用（&gt;）、列表项和列表（列表只能包含列表项）、分隔线、标题、代码块、某些 HTML 块、段落等<br />
行级元素：内联代码（code）、强调、加粗、链接、图片、某些 HTML 标签、文本等<br />
根据以上的内容，要自己实现一个扩展还是有难度的。好在 goldmark 中内置了一些扩展，可以作为参考。</p><br />
<br />
<p>GFM 的 strikethrough 扩展源码学习<br />
CommonMark 是不支持删除线（strikethrough）的，而 GFM 支持。因此 goldmark 通过 strikethrough 这个扩展来实现对 GFM 删除线的支持。根据扩展实现的步骤来学习下 strikethrough 扩展的源码。</p><br />
<br />
<p>1）AST 节点结构体：Strikethrough</p><br />
<br />
<p>// A Strikethrough struct represents a strikethrough of GFM text.<br />
type Strikethrough struct {<br />
 gast.BaseInline<br />
}</p><br />
<br />
<p>// Dump implements Node.Dump.<br />
func (n *Strikethrough) Dump(source []byte, level int) {<br />
 gast.DumpHelper(n, source, level, nil, nil)<br />
}</p><br />
<br />
<p>// KindStrikethrough is a NodeKind of the Strikethrough node.<br />
var KindStrikethrough = gast.NewNodeKind(“Strikethrough”)</p><br />
<br />
<p>// Kind implements Node.Kind.<br />
func (n *Strikethrough) Kind() gast.NodeKind {<br />
 return KindStrikethrough<br />
}</p><br />
<br />
<p>// NewStrikethrough returns a new Strikethrough node.<br />
func NewStrikethrough() *Strikethrough {<br />
 return &amp;Strikethrough{}<br />
}<br />
内嵌了一个 gast.BaseInline（gast 是 ast 导入时重命名的），表明是一个行级元素；<br />
根据 goldmark 的设计，AST 节点结构体需要实现 ast.Node 接口，然而该接口拥有很多方法，为了方便实现，该库使用了内嵌的方式来处理；<br />
ast.NewNodeKind() 构造函数得到一个 NodeKind；<br />
看一下类图：</p><br />
<br />
<p>因为 Go 不是完全面向对象语言，因此这里的类图是不严谨的：</p><br />
<br />
<p>BaseNode 并没有实现 Node 接口，因为它没有实现 Kind 和 Dump 方法，这也是因为 Go 没有抽象类的概念；<br />
BaseBlock 和 BaseInline 的区别在于实现的几个方法，BaseLine 里面好几个方法直接 panic，不需要实现；<br />
因为 BaseNode、BaseBlock 和 BaseInline 实际没有实现 Node 接口，因此它们不能直接当做 Node 使用，一定程度上模拟了抽象类；<br />
Strikethrough 扩展通过内嵌 BaseInline “继承”了相应的实现方法，同时提供 Kind 和 Dump 的实现，达到完整实现了 Node 接口的目的，因此是一个 Node；<br />
2）Strikethrough 解析器</p><br />
<br />
<p>var defaultStrikethroughDelimiterProcessor = &amp;strikethroughDelimiterProcessor{}</p><br />
<br />
<p>type strikethroughParser struct {}</p><br />
<br />
<p>var defaultStrikethroughParser = &amp;strikethroughParser{}</p><br />
<br />
<p>// NewStrikethroughParser return a new InlineParser that parses<br />
// strikethrough expressions.<br />
func NewStrikethroughParser() parser.InlineParser {<br />
 return defaultStrikethroughParser<br />
}</p><br />
<br />
<p>func (s *strikethroughParser) Trigger() []byte {<br />
 return []byte{‘~’}<br />
}</p><br />
<br />
<p>func (s *strikethroughParser) Parse(parent gast.Node, block text.Reader, pc parser.Context) gast.Node {<br />
 before := block.PrecendingCharacter()<br />
 line, segment := block.PeekLine()<br />
 node := parser.ScanDelimiter(line, before, 2, defaultStrikethroughDelimiterProcessor)<br />
 if node == nil {<br />
  return nil<br />
 }<br />
 node.Segment = segment.WithStop(segment.Start + node.OriginalLength)<br />
 block.Advance(node.OriginalLength)<br />
 pc.PushDelimiter(node)<br />
 return node<br />
}<br />
InlineParser 接口只有两个方法：Trigger 和 Parse；<br />
Trigger 表示遇到什么字符触发该节点解析；<br />
Parse 是扩展的一个关键点，不同的扩展实现方式不同。这里有两点提一下：<br />
block.PeekLine() 获取当前行，这个很有用，解析基本都能用到；<br />
block.Advance() 表示移动内部指针，可以理解为文件读取过程中的 Seek；<br />
3）Strikethrough 渲染器</p><br />
<br />
<p>// StrikethroughHTMLRenderer is a renderer.NodeRenderer implementation that<br />
// renders Strikethrough nodes.<br />
type StrikethroughHTMLRenderer struct {<br />
 html.Config<br />
}</p><br />
<br />
<p>// NewStrikethroughHTMLRenderer returns a new StrikethroughHTMLRenderer.<br />
func NewStrikethroughHTMLRenderer(opts …html.Option) renderer.NodeRenderer {<br />
 r := &amp;StrikethroughHTMLRenderer{<br />
  Config: html.NewConfig(),<br />
 }<br />
 for _, opt := range opts {<br />
  opt.SetHTMLOption(&amp;r.Config)<br />
 }<br />
 return r<br />
}</p><br />
<br />
<p>// RegisterFuncs implements renderer.NodeRenderer.RegisterFuncs.<br />
func (r *StrikethroughHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {<br />
 reg.Register(ast.KindStrikethrough, r.renderStrikethrough)<br />
}</p><br />
<br />
<p>// StrikethroughAttributeFilter defines attribute names which dd elements can have.<br />
var StrikethroughAttributeFilter = html.GlobalAttributeFilter</p><br />
<br />
<p>func (r *StrikethroughHTMLRenderer) renderStrikethrough(w util.BufWriter, source []byte, n gast.Node, entering bool) (gast.WalkStatus, error) {<br />
 if entering {<br />
  if n.Attributes() != nil {<br />
   _, _ = w.WriteString(“&lt;del”)<br />
   html.RenderAttributes(w, n, StrikethroughAttributeFilter)<br />
   _ = w.WriteByte(‘&gt;’)<br />
  } else {<br />
   _, _ = w.WriteString(“<del>”)<br />
  }<br />
 } else {<br />
  _, _ = w.WriteString(“</del>”)<br />
 }<br />
 return gast.WalkContinue, nil<br />
}<br />
renderer.NodeRenderer 接口只有一个方法：RegisterFuncs，用于注册节点类型对应的渲染函数；<br />
渲染函数是一个回调函数，签名为：func(writer util.BufWriter, source []byte, n ast.Node, entering bool) (ast.WalkStatus, error)，用于渲染某一个节点（Node）；<br />
渲染为 HTML，删除线通过加 <del></del> 标签来实现；<br />
4）定义一个扩展类型</p><br />
<br />
<p>扩展需要实现 goldmark.Extender 接口。</p><br />
<br />
<p>type strikethrough struct {}</p><br />
<br />
<p>// Strikethrough is an extension that allow you to use strikethrough expression like ‘<del>text</del>’ .<br />
var Strikethrough = &amp;strikethrough{}</p><br />
<br />
<p>func (e *strikethrough) Extend(m goldmark.Markdown) {<br />
 m.Parser().AddOptions(parser.WithInlineParsers(<br />
  util.Prioritized(NewStrikethroughParser(), 500),<br />
 ))<br />
 m.Renderer().AddOptions(renderer.WithNodeRenderers(<br />
  util.Prioritized(NewStrikethroughHTMLRenderer(), 500),<br />
 ))<br />
}<br />
这是一个固定的形式：结构体不导出，导出一个实例。外部使用时直接用导出的实例；<br />
Extend 方法的实现，设置解析选项和渲染选项，固定的写法；<br />
至此内置扩展 Strikethrough 的源码分析完成了，建议先别继续往下看，自己动手实现一个 @ 的扩展！</p><br />
<br />
<p>Mention 扩展的实现<br />
现在我们实现一个 @ 的扩展，命名为：Mention。</p><br />
<br />
<p>1）AST 节点结构体：MentionNode</p><br />
<br />
<p>// KindMention is a NodeKind of the Mention node.<br />
var KindMention = gast.NewNodeKind(“Mention”)</p><br />
<br />
<p>type MentionNode struct {<br />
 gast.BaseInline<br />
 Who string<br />
}</p><br />
<br />
<p>// NewStrikethrough returns a new Mention node.<br />
func NewMentionNode(username string) *MentionNode {<br />
 return &amp;MentionNode{<br />
  BaseInline: gast.BaseInline{},<br />
  Who:        username,<br />
 }<br />
}</p><br />
<br />
<p>// Dump implements Node.Dump.<br />
func (n *MentionNode) Dump(source []byte, level int) {<br />
 gast.DumpHelper(n, source, level, nil, nil)<br />
}</p><br />
<br />
<p>// Kind implements Node.Kind.<br />
func (n *MentionNode) Kind() gast.NodeKind {<br />
 return KindMention<br />
}<br />
这里的关键是结构体字段 Who，用于保存 @ 谁；<br />
其他和 Strikethrough 没啥区别；<br />
2）Mention 解析器</p><br />
<br />
<p>var usernameRegexp = regexp.MustCompile(<code class="language-plaintext highlighter-rouge">@([^\s@]{4,20})</code>)</p><br />
<br />
<p>type mentionParser struct{}</p><br />
<br />
<p>func NewMentionParser() parser.InlineParser {<br />
 return mentionParser{}<br />
}</p><br />
<br />
<p>func (m mentionParser) Trigger() []byte {<br />
 return []byte{‘@’}<br />
}</p><br />
<br />
<p>func (m mentionParser) Parse(parent gast.Node, block text.Reader, pc parser.Context) gast.Node {<br />
 before := block.PrecendingCharacter()<br />
 if !unicode.IsSpace(before) {<br />
  return nil<br />
 }<br />
 line, _ := block.PeekLine()<br />
 matched := usernameRegexp.FindSubmatch(line)<br />
 if len(matched) &lt; 2 {<br />
  return nil<br />
 }<br />
 block.Advance(len(matched[0]))<br />
 node := NewMentionNode(string(matched[1]))<br />
 return node<br />
}<br />
这里假定 @ 用户名长度在 4-20 字符；<br />
Trigger 在遇到 @ 时触发；<br />
要求 @ 之前必须是空格；<br />
通过正则找到当前行（line）中的目标字符串（用户名），matched 中第一个元素包含 @，第二个元素不包含 @；<br />
因为解析出了用户名，用户名这个字符串就不需要再解析了，因此通过 block.Advance 移动指针；<br />
构建一个 MentionNode 并返回；<br />
3）Mention 渲染器</p><br />
<br />
<p>type mentionHTMLRenderer struct{}</p><br />
<br />
<p>func NewMentionHTMLRenderer(opts …html.Option) renderer.NodeRenderer {<br />
 return mentionHTMLRenderer{}<br />
}</p><br />
<br />
<p>func (m mentionHTMLRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) {<br />
 reg.Register(KindMention, m.renderMention)<br />
}</p><br />
<br />
<p>func (m mentionHTMLRenderer) renderMention(w util.BufWriter, source []byte, n gast.Node, entering bool) (gast.WalkStatus, error) {<br />
 if entering {<br />
  mn := n.(*MentionNode)<br />
  w.WriteString(<code class="language-plaintext highlighter-rouge">&lt;a href="https://studygolang.com/user/</code> + mn.Who + <code class="language-plaintext highlighter-rouge">"&gt;@</code>)<br />
  w.WriteString(mn.Who)<br />
 } else {<br />
  w.WriteString(“&lt;/a&gt;”)<br />
 }</p><br />
<br />
<p>return gast.WalkContinue, nil<br />
}<br />
entering 为 true，表示进入该节点，因此构造链接写入 w 中；由于在 Parse 时移动了指针，因此这里将 Who 写入 w；<br />
else 中闭合 a 标签；<br />
4）定义一个扩展类型</p><br />
<br />
<p>type mention struct{}</p><br />
<br />
<p>var Mention = mention{}</p><br />
<br />
<p>func (m mention) Extend(markdown goldmark.Markdown) {<br />
 markdown.Parser().AddOptions(parser.WithInlineParsers(<br />
  util.Prioritized(NewMentionParser(), 500),<br />
 ))</p><br />
<br />
<p>markdown.Renderer().AddOptions(renderer.WithNodeRenderers(<br />
  util.Prioritized(NewMentionHTMLRenderer(), 500),<br />
 ))<br />
}<br />
跟上面 Strikethrough 没有太多区别。</p><br />
<br />
<p>使用 Mention<br />
使用和其他扩展没有区别：</p><br />
<br />
<p>markdown := goldmark.New(<br />
  // 支持 GFM<br />
  goldmark.WithExtensions(extension.GFM),<br />
  // 语法高亮<br />
  goldmark.WithExtensions(<br />
    highlighting.NewHighlighting(<br />
      highlighting.WithStyle(“monokai”),<br />
      highlighting.WithFormatOptions(<br />
        html.WithLineNumbers(true),<br />
      ),<br />
    ),<br />
  ),<br />
  // 支持 @<br />
  goldmark.WithExtensions(mention.Mention),<br />
)<br />
这样 @ 就能正常解析了。</p><br />
<br />
<p>关键字方式的表情解析扩展<br />
这个就不讲解了，有兴趣的可以动手实现下，有问题可以交流。</p><br />
<br />
<p>另外两个不错的“扩展”<br />
另外介绍两个 goldmark “扩展”。这里扩展用引号，是因为它们并非按照上面要求的方式实现的，因此不算是真正意义上 goldmark 说的扩展，只能说是增加了 goldmark 的功能。（这也证明了 goldmark 的可扩展性很强）</p><br />
<br />
<p>生成目录：TOC<br />
这是一个很实用的功能，特别对于长文来说。有一个扩展实现了该功能，即 https://github.com/mdigger/goldmark-toc。</p><br />
<br />
<p>它的实现方式是扩展 goldmark.Markdown 接口，也可以说是类似 goldmark.Extender 的方式。</p><br />
<br />
<p>// Markdown extends initialied goldmark.Markdown and return converter function.<br />
func Markdown(m goldmark.Markdown) ConverterFunc {<br />
 m.Parser().AddOptions(<br />
  parser.WithAttribute(),<br />
  parser.WithAutoHeadingID(),<br />
 )<br />
 return func(source []byte, writer io.Writer) (toc []Header, err error) {<br />
  doc := m.Parser().Parse(text.NewReader(source), WithIDs())<br />
  toc = Headers(doc, source)<br />
  if writer != nil {<br />
   err = m.Renderer().Render(writer, source, doc)<br />
  }<br />
  return toc, err<br />
 }<br />
}<br />
接着 Demo4，为其增加 TOC 输出，相关代码改为：</p><br />
<br />
<p>convertFunc := toc.Markdown(markdown)<br />
headers, err := convertFunc(source, f)</p><br />
<br />
<p>for _, header := range headers {<br />
  fmt.Printf(“%+v\n”, header)<br />
}<br />
运行输出如下信息：</p><br />
<br />
<p>{Level:2 Text:语法指导 ID:yu-fa-zhi-dao}<br />
{Level:3 Text:普通内容 ID:pu-tong-nei-rong}<br />
{Level:3 Text:提及用户 ID:ti-ji-yong-hu}<br />
{Level:3 Text:表情符号 Emoji ID:biao-qing-fu-hao-emoji}<br />
{Level:4 Text:一些表情例子 ID:xie-biao-qing-li-zi}<br />
{Level:3 Text:大标题 - Heading 3 ID:da-biao-ti-heading-3}<br />
{Level:4 Text:Heading 4 ID:heading-4}<br />
{Level:5 Text:Heading 5 ID:heading-5}<br />
{Level:6 Text:Heading 6 ID:heading-6}<br />
{Level:3 Text:图片 ID:tu-pian}<br />
{Level:3 Text:代码块 ID:dai-ma-kuai}<br />
{Level:4 Text:普通 ID:pu-tong}<br />
{Level:4 Text:语法高亮支持 ID:yu-fa-gao-liang-zhi-chi}<br />
{Level:5 Text:演示 Go 代码高亮 ID:yan-shi-go-dai-ma-gao-liang}<br />
{Level:5 Text:演示 JSON 代码高亮 ID:yan-shi-json-dai-ma-gao-liang}<br />
{Level:3 Text:有序、无序列表 ID:you-xu-wu-xu-lie-biao}<br />
{Level:4 Text:无序列表 ID:wu-xu-lie-biao}<br />
{Level:4 Text:有序列表 ID:you-xu-lie-biao}<br />
{Level:3 Text:表格 ID:biao-ge}<br />
{Level:3 Text:段落 ID:duan-luo}<br />
{Level:3 Text:任务列表 ID:ren-wu-lie-biao}<br />
通过这些数据可以很方便的实现 TOC。</p><br />
<br />
<p>文本统计<br />
这个扩展来自同一个作者：https://github.com/mdigger/goldmark-stats，用于进行文本统计，这个扩展统计的是渲染后的，因此比直接统计原始 markdown 文本要更准确。为我们 Dem4 增加统计功能，在最后加上如下代码：</p><br />
<br />
<p>doc := goldmark.DefaultParser().Parse(text.NewReader(source))<br />
info := stats.New(doc, source)</p><br />
<br />
<p>fmt.Printf(“words: %d, unique: %d, chars: %d, reading time: %v\n”,<br />
  info.Words, info.Unique(), info.Chars, info.Duration(400))<br />
输出：</p><br />
<br />
<p>words: 194, unique: 141, chars: 1263, reading time: 3m9s<br />
作者是俄国人，这个 words 是针对西方国家的，用空格分隔的词，并非中文的字，因此中文忽略该字段；<br />
中文主要看 chars 字段，表示多少个字；<br />
阅读时间，我们按照一分钟 400 个字算，需要 3m9s；</p><br />
<br />
<p>https://github.com/polaris1119/go-demo/tree/master/goldmark</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>