<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">使用gqlgen构建GraphQL服务</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-07-13T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jul 13, 2020</time></p>
					</div>
					 <p>gqlgen 是一个使用 Go 语言实现的用于快速创建严格类型的 graphql 服务器的库。<br />
https://github.com/99designs/gqlgen<br />
https://github.com/rongfengliang/gqlgen-demo<br />
https://tutorialedge.net/golang/go-graphql-beginners-tutorial/<br />
https://tutorialedge.net/golang/go-graphql-beginners-tutorial-part-2/<br />
https://blog.csdn.net/liuyh73/article/details/85028977<br />
https://blog.csdn.net/liuyh73/article/details/85010148<br />
https://github.com/graph-gophers/graphql-go<br />
https://github.com/vektah/gqlparser</p><br />
<br />
<p>https://github.com/Go-GraphQL-Group/GraphQL-Service<br />
<!-- more --><br />
https://studygolang.com/articles/13825<br />
https://www.ctolib.com/amp/99designs-gqlgen.html<br />
https://github.com/Go-GraphQL-Group/SW-Crawler/tree/master/data<br />
https://github.com/boltdb/bolt<br />
https://graphql.org/learn/schema/</p><br />
<br />
<p>GraphQL介绍<br />
All of the data you need, in one request</p><br />
<br />
<p>GraphQL is an open spec for a flexible API layer.</p><br />
<br />
<p>Ask exactly what you want.</p><br />
<br />
<p>GraphQL是一个用于API的查询语言。GraphQL并没有和特定数据库或者存储引擎绑定，而是依靠现有的代码和数据支撑。和RESTful不同的是，GraphQL会在一个请求中获取所有想要的数据，比如我们想要从服务器获取id=1的书籍name信息和id=2的文章的title信息，则对于GraphQL请求，我们只需按照下方语法来发送请求即可获得想要的信息。</p><br />
<br />
<p>query{<br />
  book(id:”1”) {<br />
    name<br />
  },<br />
  article(id:”2”) {<br />
  	title<br />
  }<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
但是，对于RESTful API，我们就不得不按照类似于host:port/api/book/1/和host:port/api/article/2/的url来向服务器发送两次请求，然后对返回的数据进行筛选得到name和title字段。这只是GraphQL和RESTful的其中一个区别，有关两者的比较，详见传送门。</p><br />
<br />
<p>GraphQL相关文法<br />
基于GraphQL的服务构建主要有四个部分：数据定义（schema）、查询（query）、更改（Mutation）、数据解析（Resolver）</p><br />
<br />
<p>数据定义<br />
Schema<br />
gqlgen is a schema-first library — before writing code, you describe your API using the GraphQL Schema Definition Language. This usually goes into a file called schema.graphql。</p><br />
<br />
<p>首先，我们需要定义Schema（模型），在此文件中，我们需要定要定义各种数据类型。Schema 明确了服务端有哪些字段（用户自定义类型）可以用，每个字段的类型和子字段。每次查询时，服务器就会根据 Schema 验证并执行查询。</p><br />
<br />
<p>在Schema文件中，有4个比较特殊的关键字：</p><br />
<br />
<p>schema，标识这是一个GraphQL Schema定义，其中包含了用户可以进行的三种操作（可以省略）<br />
query，定义查询操作，必须有<br />
mutation，定义变更操作，可以省略<br />
subscription，定义订阅操作，可以省略<br />
schema {<br /><br />
 query: Query<br />
 mutation: Mutation<br />
 subscription: Subscription<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
Type<br />
Type关键字是用来定义抽象数据类型，类似于golang中的Type但是并不相同。在每一个自定义数据类型中，可以有多个Field（字段），每个Field可以再次指向某个Type。</p><br />
<br />
<p>标量Scalar<br />
Scalar是解析到单个标量对象的类型，无法再进行次级选择（次级选择的含义在阅读GraphQL查询语法之后会有所了解）。GraphQL中包含的标量有String，Int，Float，Boolean，Enum，ID。</p><br />
<br />
<p>The ID scalar type represents a unique identifier, often used to refetch an object or as key for a cache.</p><br />
<br />
<h1 id="定义性别标量">定义性别标量</h1><br />
<p>enum Gender {<br />
    MALE<br />
    FEMALE<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
对象Object<br />
与我们在其他语言中定义对象类似：下方Person这个自定义数据类型中包括了id、name等字段。</p><br />
<br />
<p>type People {<br />
    name: String<br />
    birth_year: String<br />
    gender: String<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
上述People类型中只有标量字段，我们同样可以使用自定义数据类型字段，例如，我们定义了Film数据类型，每一部Film都有一个director字段：</p><br />
<br />
<p>type Film {<br />
	name: string<br />
	director: People<br />
	…<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
接口Interface<br />
接口是一个抽象类型，相信学习过go和java的读者都不陌生，下面直接看定义：</p><br />
<br />
<p>type Human {	# 实现Human的Type必须有这两个字段<br />
	age: Int<br />
    name: String<br />
}<br />
type Programmer implements Human {<br />
	age: Int			<br />
    name: String		<br />
    Hair: Int<br />
    field: String<br />
}<br />
type Student implements Human {<br />
	age: Int<br />
    name: String<br />
    id:	ID<br />
    major: String<br />
}</p><br />
<br />
<p>列表和非空<br />
对于上面People类型中的name字段，假如我们想要让其不为空，则可以在数据类型后面添加感叹号!，如果我们要新增字段参演电影的列表films，则可以使用[]。</p><br />
<br />
<p>type People {<br />
	name: String!<br />
    birth_year: String<br />
    gender: String<br />
	films: [Film]<br />
}</p><br />
<br />
<p>同样，我们可以对列表进行非空限制：</p><br />
<br />
<p>myField: [String!]</p><br />
<br />
<h1 id="表示数组本身可以为空但是其不能有任何控制成员">表示数组本身可以为空，但是其不能有任何控制成员</h1><br />
<p>myField: null # 有效<br />
myField: [] # 有效<br />
myField: [‘a’, ‘b’] # 有效<br />
myField: [‘a’, null, ‘b’] # 错误</p><br />
<br />
<p>myField: [String]!</p><br />
<h1 id="这表示数组本身不能为空但是其可以包含空值成员">这表示数组本身不能为空，但是其可以包含空值成员：</h1><br />
<p>myField: null // 错误<br />
myField: [] // 有效<br />
myField: [‘a’, ‘b’] // 有效<br />
myField: [‘a’, null, ‘b’] // 有效</p><br />
<br />
<p>联合类型<br />
联合类型和接口十分相似，但是它并不指定类型之间的任何共同字段。</p><br />
<br />
<p>union SearchResult = Person | Film<br />
1<br />
任何返回一个 SearchResult 类型的地方，都可能得到一个 Person 或者 Film。注意，联合类型的成员需要是具体对象类型；不能使用接口或者其他联合类型来创造一个联合类型。</p><br />
<br />
<p>输入类型Input<br />
输入常常用于变更（mutation）中，类似于post请求来新建对象。</p><br />
<br />
<p>input PersonInput {<br />
	name: String<br />
    birth_year: String<br />
    gender: String<br />
    films: [Film]<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
数据操作<br />
查询（Query）<br />
定义查询<br />
在schema中，定义查询方法如下：</p><br />
<br />
<h1 id="定义people查询方法参数为必填字段id返回数据类型为people">定义people查询方法，参数为必填字段id，返回数据类型为People</h1><br />
<p>type Query {<br />
    people(id: ID!): People<br />
}<br />
1<br />
2<br />
3<br />
4<br />
下面介绍一下如何查询：</p><br />
<br />
<p>参数查询<br />
在下属查询方法中，people()为定义的查询方法</p><br />
<br />
<p>为查询起别名（Aliases）<br />
如果我们先要再一次请求中查询两个people，则会出现下方的错误：</p><br />
<br />
<p>对于上述情况，我们可以使用别名的方式来进行查询：</p><br />
<br />
<p>使用片段（Fragment）<br />
在上面的people5和people1的查询中，我们发现，两者都查询了name，此时只有一个字段还好，如果相同字段过多时，那应该怎么办呢？这种情况下我们便可以使用fragment：</p><br />
<br />
<p>片段的概念经常用于将复杂的应用数据需求分割成小块，特别是你要将大量不同片段的 UI 组件组合成一个初始数据获取的时候。</p><br />
<br />
<p>定义操作名称<br />
上述所有查询，我们都使用了query关键字作为查询标识，虽然可以省略，但依然推荐这么加上。实际上，我们还可以为我们的查询定义名称，这对我们在开发过程中寻找可能存在的漏洞提供帮助。例如：定义一个名称为filmQuery的查询操作</p><br />
<br />
<p>query filmQuery{<br />
  film(id:”1”){<br />
    title<br />
  }<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
后续将要讲述的mutation操作也可以定义名称。</p><br />
<br />
<p>使用变量（Variable）<br />
使用变量的步骤：</p><br />
<br />
<p>使用 $variableName 替代查询中的静态值。<br />
声明 $variableName 为查询接受的变量之一。<br />
将 variableName: value 通过传输专用（通常是 JSON）的分离的变量字典中。</p><br />
<br />
<p>使用变量可以很方便的在客户端构造查询语法，客户端可以构造一个复选框，下拉菜单等方式来获取动态参数，然后将动态参数提取到查询之外，作为分离的字典传进去。而不用构建一个全新的查询。（为了安全起见，我们不能使用用户提供的值来进行字符串插值构建查询）</p><br />
<br />
<p>我们也可以使用默认变量，定义如下：</p><br />
<br />
<p>query peopleQuery($id: ID = “5”){<br />
    …<br />
}<br />
1<br />
2<br />
3<br />
变更（Mutation）<br />
上述介绍的全部都是查询操作，GraphQL也为我们提供了mutation变更操作，用于修改数据。</p><br />
<br />
<p>定义变更</p><br />
<h1 id="参数为episodeenum以及一个input类型的输入数据返回类型为review">参数为Episode（Enum）以及一个Input类型的输入数据，返回类型为Review</h1><br />
<p>type Mutation {<br />
    createReview(episode: Episode!, review: ReviewInput!): Review<br />
}<br />
1<br />
2<br />
3<br />
4<br />
更新数据<br />
变更和查询一样都可以使用变量以及片段等：</p><br />
<br />
<p>查询字段时，是并行执行，而变更字段时，是线性执行，一个接着一个。</p><br />
<br />
<p>订阅（Subscription）<br />
订阅用于real-time实时请求。具体用法可以自行谷歌。</p><br />
<br />
<p>数据解析Resolver<br />
当用户请求发送到服务器时，服务器如何进行相应并返回所需数据呢？下面介绍一下GraphQL的响应过程，以query查询为例：</p><br />
<br />
<p>首先，GraphQL解析操作类型得知为query，查询方法为people。<br />
之后，会尝试调用people解析（Resolver）函数，在此解析函数中，我们会调用其他函数（此函数通常需要自己手动实现）从数据库查询id为35的people对象并返回，第一层解析结束。<br />
之后对第一层解析的返回值，进行第二层解析。当前查询字段为name，和films，<br />
title为String标量类型数据，则不必再深入解析<br />
films为Film列表类型，调用Film解析（Resolver）函数。查询字段为title，由于是标量类型，则不必再深入解析。<br />
……<br />
最后将解析结果整合之后返回给客户端即可。<br />
上述过程中大部分函数其实并不需要手动实现，这些操作对于我们来说相当于黑盒状态，我们接下来会介绍几个常用的GraphQL生成工具。</p><br />
<br />
<p>关于GraphQL的相关内容就介绍到这里，如果想有进一步的了解，可以前往GraphQL官网进一步学习。</p><br />
<br />
<p>GraphQL构建工具<br />
以go语言为例，graphql构建工具有：</p><br />
<br />
<p>gqlgen<br />
gophers<br />
graphql-go<br />
thunder<br />
其中gqlgen支持语法最多，我的另一篇文章中介绍了如何使用gqlgen构建graphql服务。</p><br />
<br />
<p>文章目录<br />
gqlgen工具介绍<br />
graphql服务执行流程<br />
server/server.go<br />
graphql.go<br />
GraphQL<br />
ServeHTTP<br />
generated.go<br />
Query()<br />
_Query()<br />
_Query_people<br />
_People<br />
_People_films<br />
_Film<br />
resolver.go<br />
属性分页<br />
修改schema<br />
新增model<br />
将model加入到gqlgen.yml中<br />
删除resolver.go<br />
重新生成GraphQL骨架<br />
定义FilmConnection<br />
查询结果<br />
gqlgen工具介绍<br />
gqlgen is a golang library for building graphql servers without any fuss. gqlgen is:</p><br />
<br />
<p>Schema first: You define your API using the graphql Schema Definition Language<br />
Type safe: You should never see map[string]interface{} here.<br />
Codegen: Let us generate the boring bits, so you can build your app quickly.<br />
gqlgen是一个开源的GraphQL API服务构建工具，关于GraphQL的介绍参加我的另一篇文章GraphQL核心概念。下面进行项目的构建，以我的一次作业，使用GraphQL构建服务并复制SWAPI界面（小组合作开发）为例，完整代码详见Github。第一次使用GraphQL，项目结构还不够完善。</p><br />
<br />
<p>文章所用代码为GraphQLdemo</p><br />
<br />
<p>下载安装gqlgen工具：<br />
$ go get github.com/99designs/gqlgen<br />
1<br />
创建项目文件夹：<br />
$ mkdir -p $GOPATH/src/github.com/[username]/[project-name]</p><br />
<h1 id="mkdir--p-gopathsrcgithubcomliuyh73graphqldemo-后续介绍都以graphqldemo为例">mkdir -p $GOPATH/src/github.com/liuyh73/GraphQLdemo 后续介绍都以GraphQLdemo为例</h1><br />
<p>1<br />
2<br />
在项目文件夹根目录下，创建scripts/gqlgen.go，书写内容如下：<br />
package main</p><br />
<br />
<p>import “github.com/99designs/gqlgen/cmd”</p><br />
<br />
<p>func main() {<br />
	cmd.Execute()<br />
}<br />
由文章开头介绍可知，gqlgen是schema-first库，使用GraphQL来定义我们的API，所以现在创建schema，文件通常命名为schema.graphql，放在项目根目录下即可。此部分是由我的另外一位同学完成，具体介绍详见APIDOC，下面展示部分代码：<br />
type Query {<br />
    people(id: ID!): People								# 指定id查询people<br />
    peoples (first: Int, after: ID): PeopleConnection!	# 用户分页查询(加s只是为了区分)<br />
}</p><br />
<br />
<p>type People {<br />
    id: ID!<br />
    name: String!<br />
    birth_year: String<br />
    eye_color: String<br />
    gender: String<br />
    hair_color: String<br />
    height: String<br />
    mass: String<br />
    skin_color: String<br />
    films: [Film]<br />
}</p><br />
<br />
<p>type PeopleConnection {<br />
    pageInfo: PageInfo!<br />
    edges: [PeopleEdge!]<br />
    totalCount: Int!<br />
}</p><br />
<br />
<p>type PeopleEdge {<br />
    node: People<br />
    cursor: ID!<br />
}</p><br />
<br />
<p>type PageInfo {<br />
    hasNextPage: Boolean!<br />
    hasPreviousPage: Boolean!<br />
    startCursor: ID!<br />
    endCursor: ID!<br />
}</p><br />
<br />
<p>type Film {<br />
    id: ID!<br />
    title: String!<br />
    episode_id: Int<br />
    opening_crawl: String<br />
    director: String<br />
    producer: String<br />
    release_date: String<br />
}</p><br />
<br />
<p>然后，再项目根目录下执行命令：go run scripts/gqlgen.go init，会自动生成以下文件</p><br />
<br />
<p>gqlgen.yml — The gqlgen config file, knobs for controlling the generated code.<br />
generated.go — The GraphQL execution runtime, the bulk of the generated code.<br />
models_gen.go — Generated models required to build the graph. Often you will override these with your own models. Still very useful for input types.<br />
resolver.go — This is where your application code lives. generated.go will call into this to get the data the user has requested.<br />
server/server.go — This is a minimal entry point that sets up an http.Handler to the generated GraphQL server.<br />
至此，我们的graphql服务架构已经构建完毕，但是我们依然还有很长的路要走…</p><br />
<br />
<p>graphql服务执行流程<br />
在上述生成的文件中，我们需要更改的文件主要是resolver.go，在介绍此文件之前，我们需要了解以下gengql生成的graphql的服务的运行过程：</p><br />
<br />
<p>首先，修改resolver.go文件下的People()函数：<br />
func (r <em>queryResolver) People(ctx context.Context, id string) (</em>People, error) {<br />
	return &amp;people{}, nil	// 替换panic（避免运行过程中退出，利于我们观察执行过程）<br />
}<br />
1<br />
2<br />
3<br />
启动服务<br />
go run server/server.go<br />
1<br />
访问127.0.0.1:8080，并进行一次People查询：</p><br />
<br />
<p>由上图可知，我们的查询成功得到返回结果，各个字段都为空。下面我们来详细介绍graphql内部是如何进行查询的。</p><br />
<br />
<p>server/server.go<br />
可以看到如下代码：</p><br />
<br />
<p>http.Handle(“/”, handler.Playground(“GraphQL playground”, “/query”))<br />
http.Handle(“/query”, handler.GraphQL(GraphQLdemo.NewExecutableSchema(GraphQLdemo.Config{Resolvers: &amp;GraphQLdemo.Resolver{}})))<br />
1<br />
2<br />
其中第一行代码是根路由注册，即我们访问的127.0.0.1:8080的处理函数，在这里我们不做展开。</p><br />
<br />
<p>主要关注第二行代码，注册query路由处理函数，使用的是gqlgen/handler包中的GrapgQL服务；右键点击GraphQL转到此函数的定义。</p><br />
<br />
<p>在此之前，我们可以先看一下handler.GraphQL()的参数：</p><br />
<br />
<p>GraphQLdemo.NewExecutableSchema(GraphQLdemo.Config{Resolvers: &amp;GraphQLdemo.Resolver{}})。<br />
1<br />
NewExecutableSchema、Config以及Resolver定义如下：</p><br />
<br />
<p>// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.<br />
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {<br />
	return &amp;executableSchema{<br />
		resolvers:  cfg.Resolvers,<br />
		directives: cfg.Directives,<br />
		complexity: cfg.Complexity,<br />
	}<br />
}</p><br />
<br />
<p>type executableSchema struct {<br />
	resolvers  ResolverRoot<br />
	directives DirectiveRoot<br />
	complexity ComplexityRoot<br />
}</p><br />
<br />
<p>type Config struct {<br />
	Resolvers  ResolverRoot<br />
	Directives DirectiveRoot<br />
	Complexity ComplexityRoot<br />
}</p><br />
<br />
<p>type Resolver struct{}</p><br />
<br />
<p>func (r *Resolver) Query() QueryResolver {<br />
	return &amp;queryResolver{r}<br />
}<br />
所以NewExecutableSchema调用返回结果为包含了Resolver的executableSchema对象。executableSchema实现了ExecutableSchema接口所定义的函数。这些函数将在之后的查询过程中调用，之后我们将进行部分介绍。</p><br />
<br />
<p>type ExecutableSchema interface {<br />
	Schema() *ast.Schema</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Complexity(typeName, fieldName string, childComplexity int, args map[string]interface{}) (int, bool)<br />
Query(ctx context.Context, op *ast.OperationDefinition) *Response<br />
Mutation(ctx context.Context, op *ast.OperationDefinition) *Response<br />
Subscription(ctx context.Context, op *ast.OperationDefinition) func() *Response }<br />
</code></pre></div></div><br />
<br />
<p>下面便来便来看以下executableSchema到底是如何作用的。</p><br />
<br />
<p>graphql.go<br />
GraphQL<br />
下方代码即为GraphQL函数，在此函数中cfg、cache暂且不做考虑，我们只需关注handler对象。</p><br />
<br />
<p>func GraphQL(exec graphql.ExecutableSchema, options …Option) http.HandlerFunc {<br />
	cfg := &amp;Config{<br />
		cacheSize: DefaultCacheSize,<br />
		upgrader: websocket.Upgrader{<br />
			ReadBufferSize:  1024,<br />
			WriteBufferSize: 1024,<br />
		},<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _, option := range options {<br />
	option(cfg)<br />
}<br />
<br />
var cache *lru.Cache<br />
if cfg.cacheSize &gt; 0 {<br />
	var err error<br />
	cache, err = lru.New(DefaultCacheSize)<br />
	if err != nil {<br />
		// An error is only returned for non-positive cache size<br />
		// and we already checked for that.<br />
		panic("unexpected error creating cache: " + err.Error())<br />
	}<br />
}<br />
if cfg.tracer == nil {<br />
	cfg.tracer = &amp;graphql.NopTracer{}<br />
}<br />
<br />
handler := &amp;graphqlHandler{<br />
	cfg:   cfg,<br />
	cache: cache,<br />
	exec:  exec,<br />
}<br />
<br />
return handler.ServeHTTP } handler为graphqlhandler的实例，并且graphqlhandler实现了ServeHTTP函数，该函数参数为(w http.ResponseWriter, r *http.Request)，所以此函数即为http.HandlerFunc类型，这也解释了http.Handle("/query", http.HandlerFunc)路由注册的正确性。<br />
</code></pre></div></div><br />
<br />
<p>ServeHTTP<br />
在ServeHTTP函数中</p><br />
<br />
<p>func (gh *graphqlHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {<br />
	if r.Method == http.MethodOptions {<br />
		w.Header().Set(“Allow”, “OPTIONS, GET, POST”)<br />
		w.WriteHeader(http.StatusOK)<br />
		return<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if strings.Contains(r.Header.Get("Upgrade"), "websocket") {<br />
	connectWs(gh.exec, w, r, gh.cfg)<br />
	return<br />
}<br />
<br />
// 此部分代码解析请求数据，其中MethodPost可以将上传的数据（variables）构建为graphql语法<br />
// reqParams即为解析后的请求数据<br />
// type params struct {<br />
//     Query         string                 `json:"query"`			// Query语法<br />
//     OperationName string                 `json:"operationName"`	// 操作名称<br />
//     Variables     map[string]interface{} `json:"variables"`		// 变量（插入到语法中）<br />
// }<br />
<br />
var reqParams params<br />
switch r.Method {<br />
case http.MethodGet:<br />
	reqParams.Query = r.URL.Query().Get("query")<br />
	reqParams.OperationName = r.URL.Query().Get("operationName")<br />
<br />
	if variables := r.URL.Query().Get("variables"); variables != "" {<br />
		if err := jsonDecode(strings.NewReader(variables), &amp;reqParams.Variables); err != nil {<br />
			sendErrorf(w, http.StatusBadRequest, "variables could not be decoded")<br />
			return<br />
		}<br />
	}<br />
case http.MethodPost:<br />
	if err := jsonDecode(r.Body, &amp;reqParams); err != nil {<br />
		sendErrorf(w, http.StatusBadRequest, "json body could not be decoded: "+err.Error())<br />
		return<br />
	}<br />
default:<br />
	w.WriteHeader(http.StatusMethodNotAllowed)<br />
	return<br />
}<br />
w.Header().Set("Content-Type", "application/json")<br />
<br />
ctx := r.Context()<br />
<br />
...<br />
...<br />
// 此部分代码即为区分操作类型Query或Mutation（其中op为解析reqParams后的*OperationDefination对象，包括操作类型等数据）<br />
switch op.Operation {<br />
case ast.Query:<br />
	b, err := json.Marshal(gh.exec.Query(ctx, op))	// 此函数调用是我们所着重关注的（exec的作用也在此体现，调用Query函数进行查询操作）<br />
	if err != nil {<br />
		panic(err)<br />
	}<br />
	w.Write(b)			// 返回请求响应结果<br />
case ast.Mutation:<br />
	b, err := json.Marshal(gh.exec.Mutation(ctx, op))	// 此次demo中并没有用到Mutation<br />
	if err != nil {<br />
		panic(err)<br />
	}<br />
	w.Write(b)<br />
default:<br />
	sendErrorf(w, http.StatusBadRequest, "unsupported operation type")<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>Ctrl+右键进入gh.exec.Query(ctx, op)的Query函数。</p><br />
<br />
<p>generated.go<br />
Query()<br />
看到下方的函数，服务端在此开始真正的查询操作，我们将一步一步观察query的执行过程。</p><br />
<br />
<p>func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {<br />
	// executionContext是一个利用上下文信息的查询struct<br />
	// type executionContext struct {<br />
	//     *graphql.RequestContext		// 请求上下文<br />
	//     *executableSchema			// executableSchema对象<br />
	// }<br />
	// 此类型实现了_Query()等一系列查询函数，后面我们将看到其强大之处<br />
	ec := executionContext{graphql.GetRequestContext(ctx), e}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {<br />
	// 回调函数中调用_Query()函数，并传入上下文，一次查询集合(进入此函数)<br />
	data := ec._Query(ctx, op.SelectionSet)<br />
	var buf bytes.Buffer<br />
	data.MarshalGQL(&amp;buf)<br />
	return buf.Bytes()<br />
})<br />
// 返回查询结果<br />
return &amp;graphql.Response{<br />
	Data:       buf,<br />
	Errors:     ec.Errors,<br />
	Extensions: ec.Extensions} }<br />
</code></pre></div></div><br />
<br />
<p>_Query()<br />
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {<br />
	fields := graphql.CollectFields(ctx, sel, queryImplementors)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctx = graphql.WithResolverContext(ctx, &amp;graphql.ResolverContext{<br />
	Object: "Query",<br />
})<br />
<br />
var wg sync.WaitGroup<br />
out := graphql.NewOrderedMap(len(fields))<br />
invalid := false<br />
for i, field := range fields {<br />
	out.Keys[i] = field.Alias<br />
<br />
	switch field.Name {<br />
	case "__typename":<br />
		out.Values[i] = graphql.MarshalString("Query")<br />
	case "people":	// 解析查询，若为People查询，则调用_Query_people进一步解析<br />
		wg.Add(1)<br />
		go func(i int, field graphql.CollectedField) {<br />
			out.Values[i] = ec._Query_people(ctx, field)<br />
			wg.Done()<br />
		}(i, field)<br />
	case "peoples": // 解析查询，若为Peoples查询，则调用_Query_peoples进一步解析<br />
		wg.Add(1)<br />
		go func(i int, field graphql.CollectedField) {<br />
			out.Values[i] = ec._Query_peoples(ctx, field)<br />
			if out.Values[i] == graphql.Null {<br />
				invalid = true<br />
			}<br />
			wg.Done()<br />
		}(i, field)<br />
	case "__type":<br />
		out.Values[i] = ec._Query___type(ctx, field)<br />
	case "__schema":<br />
		out.Values[i] = ec._Query___schema(ctx, field)<br />
	default:<br />
		panic("unknown field " + strconv.Quote(field.Name))<br />
	}<br />
}<br />
wg.Wait()<br />
if invalid {<br />
	return graphql.Null<br />
}<br />
// 返回查询结果<br />
return out } _Query_people func (ec *executionContext) _Query_people(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {<br />
ctx = ec.Tracer.StartFieldExecution(ctx, field)<br />
defer func() { ec.Tracer.EndFieldExecution(ctx) }()<br />
rawArgs := field.ArgumentMap(ec.Variables)<br />
args, err := field_Query_people_args(rawArgs)<br />
if err != nil {<br />
	ec.Error(ctx, err)<br />
	return graphql.Null<br />
}<br />
rctx := &amp;graphql.ResolverContext{<br />
	Object: "Query",<br />
	Args:   args,<br />
	Field:  field,<br />
}<br />
ctx = graphql.WithResolverContext(ctx, rctx)<br />
ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)<br />
resTmp := ec.FieldMiddleware(ctx, nil, func(rctx context.Context) (interface{}, error) {<br />
	ctx = rctx // use context from middleware stack in children<br />
	// 此函数中，我们需要关注此函数，executionContext拥有executableSchema的所有字段，所以可以使用resolvers属性的Query()方法。<br />
	// 回到我们之前介绍定义executableSchema的过程，executableSchema的resolvers属性为cfg.Resolvers，而cfg.Resolvers为我们在resolver.go文件中生成的Resolver结构体（此结构体实现Query()方法），并且Query()方法返回queryResolver对象：<br />
	// type queryResolver struct{ *Resolver }<br />
<br />
	// func (r *queryResolver) People(ctx context.Context, id string) (*People, error) {<br />
	//	   return &amp;People{}, nil<br />
	// }<br />
	// func (r *queryResolver) Peoples(ctx context.Context, first *int, after *string) (PeopleConnection, error) {<br />
	//     panic("not implemented")<br />
	// }<br />
	// 这就进入了resolver.go文件，这也正是我们需要实现的查询函数（访问数据库等操作即在此进行）<br />
	return ec.resolvers.Query().People(rctx, args["id"].(string))<br />
})<br />
<br />
if resTmp == nil {<br />
	return graphql.Null<br />
}<br />
res := resTmp.(*People)<br />
rctx.Result = res<br />
ctx = ec.Tracer.StartFieldChildExecution(ctx)<br />
<br />
if res == nil {<br />
	return graphql.Null<br />
}<br />
// 当我们获得查询结果后，我们需要筛选出用户所需要的字段，这也正是GraphQL比较关键的地方<br />
return ec._People(ctx, field.Selections, res) } _People func (ec *executionContext) _People(ctx context.Context, sel ast.SelectionSet, obj *People) graphql.Marshaler {<br />
fields := graphql.CollectFields(ctx, sel, peopleImplementors)<br />
<br />
out := graphql.NewOrderedMap(len(fields))<br />
invalid := false<br />
// 遍历用户查询fields（字段）<br />
for i, field := range fields {<br />
	out.Keys[i] = field.Alias<br />
<br />
	switch field.Name {<br />
	case "__typename":<br />
		out.Values[i] = graphql.MarshalString("People")<br />
	case "id":<br />
		out.Values[i] = ec._People_id(ctx, field, obj)<br />
		if out.Values[i] == graphql.Null {<br />
			invalid = true<br />
		}<br />
	case "name":<br />
		out.Values[i] = ec._People_name(ctx, field, obj)<br />
		if out.Values[i] == graphql.Null {<br />
			invalid = true<br />
		}<br />
	case "birth_year":<br />
		out.Values[i] = ec._People_birth_year(ctx, field, obj)<br />
	case "eye_color":<br />
		out.Values[i] = ec._People_eye_color(ctx, field, obj)<br />
	case "gender":<br />
		out.Values[i] = ec._People_gender(ctx, field, obj)<br />
	case "hair_color":<br />
		out.Values[i] = ec._People_hair_color(ctx, field, obj)<br />
	case "height":<br />
		out.Values[i] = ec._People_height(ctx, field, obj)<br />
	case "mass":<br />
		out.Values[i] = ec._People_mass(ctx, field, obj)<br />
	case "skin_color":<br />
		out.Values[i] = ec._People_skin_color(ctx, field, obj)<br />
	// 以上字段都为标量字段，所以调用各自的查询函数即返回最终结果<br />
	// 在此我们需要关注films字段，由于films为自定义类型Film列表，所以我们还需进行深层次筛选，产看_People_films函数<br />
	case "films":<br />
		out.Values[i] = ec._People_films(ctx, field, obj)<br />
	default:<br />
		panic("unknown field " + strconv.Quote(field.Name))<br />
	}<br />
}<br />
<br />
if invalid {<br />
	return graphql.Null<br />
}<br />
return out } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 _People_films func (ec *executionContext) _People_films(ctx context.Context, field graphql.CollectedField, obj *People) graphql.Marshaler {<br />
...<br />
...<br />
for idx1 := range res {<br />
	idx1 := idx1<br />
	rctx := &amp;graphql.ResolverContext{<br />
		Index:  &amp;idx1,<br />
		Result: res[idx1],<br />
	}<br />
	ctx := graphql.WithResolverContext(ctx, rctx)<br />
	f := func(idx1 int) {<br />
		if !isLen1 {<br />
			defer wg.Done()<br />
		}<br />
		arr1[idx1] = func() graphql.Marshaler {<br />
<br />
			if res[idx1] == nil {<br />
				return graphql.Null<br />
			}<br />
			// 当我们获得people中films列表，以及所要查询的film字段之后我们进一步调用_Film函数进行筛选<br />
			return ec._Film(ctx, field.Selections, res[idx1])<br />
		}()<br />
	}<br />
	if isLen1 {<br />
		f(idx1)<br />
	} else {<br />
		go f(idx1)<br />
	}<br />
}<br />
wg.Wait()<br />
return arr1 } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 _Film func (ec *executionContext) _Film(ctx context.Context, sel ast.SelectionSet, obj *Film) graphql.Marshaler {<br />
fields := graphql.CollectFields(ctx, sel, filmImplementors)<br />
<br />
out := graphql.NewOrderedMap(len(fields))<br />
invalid := false<br />
// 子过程与_People调用类似，进行筛选，如果有必要则需要进一步筛选数据<br />
for i, field := range fields {<br />
	out.Keys[i] = field.Alias<br />
<br />
	switch field.Name {<br />
	case "__typename":<br />
		out.Values[i] = graphql.MarshalString("Film")<br />
	case "id":<br />
		out.Values[i] = ec._Film_id(ctx, field, obj)<br />
		if out.Values[i] == graphql.Null {<br />
			invalid = true<br />
		}<br />
	case "title":<br />
		out.Values[i] = ec._Film_title(ctx, field, obj)<br />
		if out.Values[i] == graphql.Null {<br />
			invalid = true<br />
		}<br />
	case "episode_id":<br />
		out.Values[i] = ec._Film_episode_id(ctx, field, obj)<br />
	case "opening_crawl":<br />
		out.Values[i] = ec._Film_opening_crawl(ctx, field, obj)<br />
	case "director":<br />
		out.Values[i] = ec._Film_director(ctx, field, obj)<br />
	case "producer":<br />
		out.Values[i] = ec._Film_producer(ctx, field, obj)<br />
	case "release_date":<br />
		out.Values[i] = ec._Film_release_date(ctx, field, obj)<br />
	default:<br />
		panic("unknown field " + strconv.Quote(field.Name))<br />
	}<br />
}<br />
<br />
if invalid {<br />
	return graphql.Null<br />
}<br />
return out } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 到此，我们的People查询所进行的步骤已经结束，之后按照函数调用顺序依次返回查询即可，最终得到请求响应数据进行返回。同样我们的Peoples分页查询步骤于此类似，所以不再赘述。<br />
</code></pre></div></div><br />
<br />
<p>resolver.go<br />
下面我们便需要实现resolver.go中的People和Peoples方法：</p><br />
<br />
<p>type queryResolver struct{ *Resolver }</p><br />
<br />
<p>func (r <em>queryResolver) People(ctx context.Context, id string) (</em>People, error) {<br />
	return &amp;People{}, nil<br />
}<br />
func (r *queryResolver) Peoples(ctx context.Context, first *int, after *string) (PeopleConnection, error) {<br />
	panic(“not implemented”)<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
在此Demo中，我使用boltdb数据库来存储数据，数据来源来自The Star Wars API，可以根据API爬取下来，当然也可以去github上下载。由于我们在schema中定义的People所含字段与数据库中存储并不一致，所以可以自行书写转化函数，将从数据库中获取到的数据转化为所需的People类型。</p><br />
<br />
<p>之后我们实现的People和Peoples函数如下：</p><br />
<br />
<p>func (r <em>queryResolver) People(ctx context.Context, id string) (</em>People, error) {<br />
	// GetPeopleByID即使我们要实现的获取people的函数<br />
	err, people := GetPeopleByID(id, nil)<br />
	checkErr(err)<br />
	return people, err<br />
}</p><br />
<br />
<p>func (r <em>queryResolver) Peoples(ctx context.Context, first *int, after *string) (PeopleConnection, error) {<br />
	from := -1<br />
	if after != nil {<br />
		b, err := base64.StdEncoding.DecodeString(</em>after)<br />
		if err != nil {<br />
			return PeopleConnection{}, err<br />
		}<br />
		i, err := strconv.Atoi(strings.TrimPrefix(string(b), “cursor”))<br />
		if err != nil {<br />
			return PeopleConnection{}, err<br />
		}<br />
		from = i<br />
	}<br />
	count := 0<br />
	startID := “”<br />
	hasPreviousPage := true<br />
	hasNextPage := true<br />
	// 获取edges<br />
	edges := []PeopleEdge{}<br />
	db, err := bolt.Open(“./data/data.db”, 0600, nil)<br />
	CheckErr(err)<br />
	defer db.Close()<br />
	db.View(func(tx *bolt.Tx) error {<br />
		c := tx.Bucket([]byte(peopleBucket)).Cursor()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	// 判断是否还有前向页<br />
	k, v := c.First()<br />
	if from == -1 || strconv.Itoa(from) == string(k) {<br />
		startID = string(k)<br />
		hasPreviousPage = false<br />
	}<br />
<br />
	if from == -1 {<br />
		for k, _ := c.First(); k != nil; k, _ = c.Next() {<br />
			_, people := GetPeopleByID(string(k), db)<br />
			edges = append(edges, PeopleEdge{<br />
				Node:   people,<br />
				Cursor: encodeCursor(string(k)),<br />
			})<br />
			count++<br />
			if count == *first {<br />
				break<br />
			}<br />
		}<br />
	} else {<br />
		for k, _ := c.First(); k != nil; k, _ = c.Next() {<br />
			if strconv.Itoa(from) == string(k) {<br />
				k, _ = c.Next()<br />
				startID = string(k)<br />
			}<br />
			if startID != "" {<br />
				_, people := GetPeopleByID(string(k), db)<br />
				edges = append(edges, PeopleEdge{<br />
					Node:   people,<br />
					Cursor: encodeCursor(string(k)),<br />
				})<br />
				count++<br />
				if count == *first {<br />
					break<br />
				}<br />
			}<br />
		}<br />
	}<br />
<br />
	k, v = c.Next()<br />
	if k == nil &amp;&amp; v == nil {<br />
		hasNextPage = false<br />
	}<br />
	return nil<br />
})<br />
if count == 0 {<br />
	return PeopleConnection{}, nil<br />
}<br />
// 获取pageInfo<br />
pageInfo := PageInfo{<br />
	HasPreviousPage: hasPreviousPage,<br />
	HasNextPage:     hasNextPage,<br />
	StartCursor:     encodeCursor(startID),<br />
	EndCursor:       encodeCursor(edges[count-1].Node.ID),<br />
}<br />
<br />
return PeopleConnection{<br />
	PageInfo:   pageInfo,<br />
	Edges:      edges,<br />
	TotalCount: count,<br />
}, nil } // 编码游标（游标指向当前节点） func encodeCursor(k string) string {<br />
i, _ := strconv.Atoi(k)<br />
return base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("cursor%d", i))) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 项目结构如下：<br />
</code></pre></div></div><br />
<br />
<p>GraphQLdemo<br />
│  dbOp.go<br />
│  generated.go<br />
│  gqlgen.yml<br />
│  models_gen.go<br />
│  resolver.go<br />
│  schema.graphql<br />
│<br />
├─data<br />
│      data.db<br />
│<br />
├─scripts<br />
│      gqlgen.go<br />
│<br />
└─server<br />
        server.go<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
此时在此查询可得到如下结果：</p><br />
<br />
<p>到此步骤，我们的功能基本上已经实现，但此时我们依然还有一个问题，对于People查询的films是否可以分页呢？答案是否定的，那我们应该怎样实现属性分页？</p><br />
<br />
<p>属性分页<br />
修改schema<br />
想要进行属性分页，则该属性必须拥有类似于People(Int, ID!):People的查询函数，所以我们需要修改schema中People的定义：</p><br />
<br />
<p>type People {<br />
    id: ID!<br />
    name: String!<br />
    birth_year: String<br />
    eye_color: String<br />
    gender: String<br />
    hair_color: String<br />
    height: String<br />
    mass: String<br />
    skin_color: String<br />
    films: [Film]	# 此字段可以保留，无需分页时使用此属性即可<br />
    filmConnection(first: Int, after: ID): FilmConnection!	# 此属性用于film分页查询<br />
}</p><br />
<h1 id="新增字段">新增字段</h1><br />
<p>type FilmConnection {<br />
    pageInfo: PageInfo!<br />
    edges: [FilmEdge!]<br />
    totalCount: Int!<br />
}</p><br />
<br />
<p>type FilmEdge {<br />
    node: Film<br />
    cursor: ID!<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
新增model<br />
在项目根目录下新建文件model.go，由于schema中People被我们修改，所以我们可以根据需要定义People：</p><br />
<br />
<p>type People struct {<br />
	ID        string  <code class="language-plaintext highlighter-rouge">json:"id"</code><br />
	Name      string  <code class="language-plaintext highlighter-rouge">json:"name"</code><br />
	BirthYear <em>string <code class="language-plaintext highlighter-rouge">json:"birth_year"</code><br />
	EyeColor  *string <code class="language-plaintext highlighter-rouge">json:"eye_color"</code><br />
	Gender    *string <code class="language-plaintext highlighter-rouge">json:"gender"</code><br />
	HairColor *string <code class="language-plaintext highlighter-rouge">json:"hair_color"</code><br />
	Height    *string <code class="language-plaintext highlighter-rouge">json:"height"</code><br />
	Mass      *string <code class="language-plaintext highlighter-rouge">json:"mass"</code><br />
	SkinColor *string <code class="language-plaintext highlighter-rouge">json:"skin_color"</code><br />
	Films     []</em>Film <code class="language-plaintext highlighter-rouge">json:"films"</code><br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
将model加入到gqlgen.yml中<br />
models:<br />
  People:<br />
    model: github.com/liuyh73/GraphQLdemo.People<br />
1<br />
2<br />
3<br />
删除resolver.go<br />
删除之前注意备份一下</p><br />
<br />
<p>重新生成GraphQL骨架<br />
$ go run scripts/gqlgen.go -v <br />
Unable to bind People.filmConnection to github.com/liuyh73/GraphQLdemo.People<br />
  no method named filmConnection<br />
  no field named filmConnection<br />
  Adding resolver method<br />
Unable to bind People.filmConnection to github.com/liuyh73/GraphQLdemo.People<br />
  no method named filmConnection<br />
  no field named filmConnection<br />
  Adding resolver method<br />
查看重新生成的resolver.go，增加了如下定义和函数</p><br />
<br />
<p>func (r *Resolver) People() PeopleResolver {<br />
	return &amp;peopleResolver{r}<br />
}</p><br />
<br />
<p>type peopleResolver struct{ *Resolver }<br />
// 此函数便是我们实现films分页的关键步骤<br />
func (r *peopleResolver) FilmConnection(ctx context.Context, obj *People, first *int, after *string) (FilmConnection, error) {<br />
	panic(“not implemented”)<br />
}<br />
将之前备份的resolver.go中的函数重新粘贴到相应的位置。</p><br />
<br />
<p>定义FilmConnection<br />
// 具体操作与People类似<br />
func (r <em>peopleResolver) FilmConnection(ctx context.Context, obj *People, first *int, after *string) (FilmConnection, error) {<br />
	from := -1<br />
	if after != nil {<br />
		b, err := base64.StdEncoding.DecodeString(</em>after)<br />
		if err != nil {<br />
			return FilmConnection{}, err<br />
		}<br />
		i, err := strconv.Atoi(strings.TrimPrefix(string(b), “cursor”))<br />
		if err != nil {<br />
			return FilmConnection{}, err<br />
		}<br />
		from = i<br />
	}<br />
	index := -1<br />
	count := 0<br />
	hasPreviousPage := false<br />
	hasNextPage := true<br />
	// 获取edges<br />
	edges := []FilmEdge{}<br />
	for i, film := range obj.Films {<br />
		if film.ID == strconv.Itoa(from) {<br />
			index = i<br />
			break<br />
		}<br />
	}<br />
	if index &gt; 0 {<br />
		hasPreviousPage = true<br />
	}<br />
	for i := index + 1; i &lt; len(obj.Films); i++ {<br />
		edges = append(edges, FilmEdge{<br />
			Node:   obj.Films[i],<br />
			Cursor: encodeCursor(obj.Films[i].ID),<br />
		})<br />
		count++<br />
		if count &gt;= *first {<br />
			break<br />
		}<br />
	}<br />
	if count &lt; *first {<br />
		hasNextPage = false<br />
	}<br />
	if count == 0 {<br />
		return FilmConnection{}, nil<br />
	}<br />
	// 获取pageInfo<br />
	pageInfo := PageInfo{<br />
		HasPreviousPage: hasPreviousPage,<br />
		HasNextPage:     hasNextPage,<br />
		StartCursor:     encodeCursor(edges[0].Node.ID),<br />
		EndCursor:       encodeCursor(edges[count-1].Node.ID),<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return FilmConnection{<br />
	PageInfo:   pageInfo,<br />
	Edges:      edges,<br />
	TotalCount: count,<br />
}, nil } 查询结果<br />
</code></pre></div></div><br />
<br />
<p>下面我们便来看看FilmConnection到底是什么时候被调用的。<br />
同样进入generated.go文件，此次我们直接定位到_People函数（1168行），观察以下代码：</p><br />
<br />
<p>case “filmConnection”:<br />
    wg.Add(1)<br />
    go func(i int, field graphql.CollectedField) {<br />
        out.Values[i] = ec._People_filmConnection(ctx, field, obj)<br />
        if out.Values[i] == graphql.Null {<br />
            invalid = true<br />
        }<br />
        wg.Done()<br />
    }(i, field)<br />
这是新增的case，接下来我们进入_People_filmConnection，</p><br />
<br />
<p>func (ec <em>executionContext) _People_filmConnection(ctx context.Context, field graphql.CollectedField, obj *People) graphql.Marshaler {<br />
	ctx = ec.Tracer.StartFieldExecution(ctx, field)<br />
	defer func() { ec.Tracer.EndFieldExecution(ctx) }()<br />
	rawArgs := field.ArgumentMap(ec.Variables)<br />
	args, err := field_People_filmConnection_args(rawArgs)<br />
	if err != nil {<br />
		ec.Error(ctx, err)<br />
		return graphql.Null<br />
	}<br />
	rctx := &amp;graphql.ResolverContext{<br />
		Object: “People”,<br />
		Args:   args,<br />
		Field:  field,<br />
	}<br />
	ctx = graphql.WithResolverContext(ctx, rctx)<br />
	ctx = ec.Tracer.StartFieldResolverExecution(ctx, rctx)<br />
	resTmp := ec.FieldMiddleware(ctx, obj, func(rctx context.Context) (interface{}, error) {<br />
		ctx = rctx // use context from middleware stack in children<br />
		// 这里便是我们调用FilmConnection的地方<br />
		return ec.resolvers.People().FilmConnection(rctx, obj, args[“first”].(</em>int), args[“after”].(*string))<br />
	})<br />
	if resTmp == nil {<br />
		if !ec.HasError(rctx) {<br />
			ec.Errorf(ctx, “must not be null”)<br />
		}<br />
		return graphql.Null<br />
	}<br />
	res := resTmp.(FilmConnection)<br />
	rctx.Result = res<br />
	ctx = ec.Tracer.StartFieldChildExecution(ctx)<br />
	// 返回筛选结果<br />
	return ec._FilmConnection(ctx, field.Selections, &amp;res)<br />
}</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>