<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">StructOf</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-08-11T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Aug 11, 2020</time></p>
					</div>
					 <p>Go language provides inbuilt support implementation of run-time reflection and allowing a program to manipulate objects with arbitrary types with the help of reflect package. The reflect.StructOf() Function in Golang is used to get the struct type containing fields. To access this function, one needs to imports the reflect package in the program.</p><br />
<br />
<p>Syntax:</p><br />
<br />
<p>func StructOf(fields []StructField) Type<br />
Parameters: This function takes only one parameters of StructFields( fields ).</p><br />
<br />
<p>Return Value: This function returns the struct type containing fields.</p><br />
<br />
<p>https://www.geeksforgeeks.org/reflect-structof-function-in-golang-with-examples/</p><br />
<br />
<p>https://github.com/golang/go/issues/23063<br />
<!-- more --><br />
https://blog.golang.org/laws-of-reflection</p><br />
<br />
<p>https://golang.org/pkg/reflect/</p><br />
<br />
<p>什么是反射<br />
多数情况下，Go 中的变量、类型和函数的使用都是非常简单的。<br />
当你需要一个类型，定义如下：<br />
type Foo struct {<br />
  A int<br />
  B string<br />
}<br />
复制代码当你需要一个变量，定义如下：<br />
var x Foo<br />
复制代码当你需要一个函数，定义如下：<br />
func DoSomething(f Foo) {<br />
  fmt.Println(f.A, f.B)<br />
}<br />
复制代码但有时候，你想使用的变量依赖于运行时信息，它们在编程时并不存在。比如数据来源于文件，或来源于网络，你想把它映射到一个变量，而它们可能是不同的类型。在这类场景下，你就需要用到反射。反射让你可以在运行时检查类型，创建、更新、检查变量以及组织结构。<br />
Go 中的反射主要围绕着三个概念：类型（Types）、类别（Kinds）和值（Values）。反射的实现源码位于 Go 标准库 reflection 包中。<br />
检查类型<br />
首先，让我们来看看类型（Types）。你可以通过 reflect.TypeOf(var) 形式的函数调用获取变量的类型，它会返回一个类型为 reflect.Type 的变量，reflect.Type 中的操作方法涉及了定义该类型变量的各类信息。<br />
我们要看的第一个方法是 Name()，它返回的是类型的名称。有些类型，比如 slice 或 指针，没有类型名称，那么将会返回空字符串。<br />
下一个介绍方法是 Kind()，我的观点，这是第一个真正有用的方法。Kind，即类别，比如切片 slice、映射 map、指针 pointer、结构体 struct、接口 interface、字符串 string、数组 array、函数 function、整型 int、或其他的基本类型。type 和 kind 是区别不是那么容易理清楚，但是可以这么想：<br />
当你定义一个名称为 Foo 的结构体，那么它的 kind 是 struct，而它的 type 是 Foo。<br />
当使用反射时，我们必须要意识到：在使用 reflect 包时，会假设你清楚的知道自己在做什么，如果使用不当，将会产生 panic。举个例子，你在 int 类型上调用 struct 结构体类型上才用的方法，你的代码就会产生 panic。我们时刻要记住，什么类型有有什么方法可以使用，从而避免产生 panic。<br />
如果一个变量是指针、映射、切片、管道、或者数组类型，那么这个变量的类型就可以调用方法 varType.Elem()。<br />
如果一个变量是结构体，那么你就可以使用反射去得到它的字段个数，并且可以得到每个字段的信息，这些信息包含在 reflect.StructField 结构体中。reflect.StructField 包含字段的名称、排序、类型、标签。<br />
前言万语也不如一行代码看的明白，下面的这个例子输出了不同变量所属类型的信息。</p><br />
<br />
<p>type Foo struct {<br />
	A int <code class="language-plaintext highlighter-rouge">tag1:"First Tag" tag2:"Second Tag"</code><br />
	B string<br />
}</p><br />
<br />
<p>func main() {<br />
	sl := []int{1, 2, 3}<br />
	greeting := “hello”<br />
	greetingPtr := &amp;greeting<br />
	f := Foo{A: 10, B: “Salutations”}<br />
	fp := &amp;f</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>slType := reflect.TypeOf(sl)<br />
gType := reflect.TypeOf(greeting)<br />
grpType := reflect.TypeOf(greetingPtr)<br />
fType := reflect.TypeOf(f)<br />
fpType := reflect.TypeOf(fp)<br />
<br />
examiner(slType, 0)<br />
examiner(gType, 0)<br />
examiner(grpType, 0)<br />
examiner(fType, 0)<br />
examiner(fpType, 0) }<br />
</code></pre></div></div><br />
<br />
<p>func examiner(t reflect.Type, depth int) {<br />
	fmt.Println(strings.Repeat(“\t”, depth), “Type is”, t.Name(), “and kind is”, t.Kind())<br />
	switch t.Kind() {<br />
	case reflect.Array, reflect.Chan, reflect.Map, reflect.Ptr, reflect.Slice:<br />
		fmt.Println(strings.Repeat(“\t”, depth+1), “Contained type:”)<br />
		examiner(t.Elem(), depth+1)<br />
	case reflect.Struct:<br />
		for i := 0; i &lt; t.NumField(); i++ {<br />
			f := t.Field(i)<br />
			fmt.Println(strings.Repeat(“\t”, depth+1), “Field”, i+1, “name is”, f.Name, “type is”, f.Type.Name(), “and kind is”, f.Type.Kind())<br />
			if f.Tag != “” {<br />
				fmt.Println(strings.Repeat(“\t”, depth+2), “Tag is”, f.Tag)<br />
				fmt.Println(strings.Repeat(“\t”, depth+2), “tag1 is”, f.Tag.Get(“tag1”), “tag2 is”, f.Tag.Get(“tag2”))<br />
			}<br />
		}<br />
	}<br />
}<br />
复制代码输出如下：<br />
Type is  and kind is slice<br />
	 Contained type:<br />
	 Type is int and kind is int<br />
 Type is string and kind is string<br />
 Type is  and kind is ptr<br />
	 Contained type:<br />
	 Type is string and kind is string<br />
 Type is Foo and kind is struct<br />
	 Field 1 name is A type is int and kind is int<br />
		 Tag is tag1:”First Tag” tag2:”Second Tag”<br />
		 tag1 is First Tag tag2 is Second Tag<br />
	 Field 2 name is B type is string and kind is string<br />
 Type is  and kind is ptr<br />
	 Contained type:<br />
	 Type is Foo and kind is struct<br />
		 Field 1 name is A type is int and kind is int<br />
			 Tag is tag1:”First Tag” tag2:”Second Tag”<br />
			 tag1 is First Tag tag2 is Second Tag<br />
		 Field 2 name is B type is string and kind is string<br />
复制代码运行示例<br />
创建实例<br />
除了检查变量的类型外，你还可以利用来获取、设置和创建变量。首先，通过 refVal := reflect.ValueOf(var) 创建类型为 reflect.Value 的实例。如果你想通过反射来更新值，那么必须要获取到变量的指针 refPtrVal := reflect.ValueOf(&amp;var)，如果不这么做，那么你只能读取值，而不能设置值。<br />
一旦得到变量的 reflect.Value，你就可以通过 Value 的 Type 属性获取变量的 reflect.Type 类型信息。<br />
如果想更新值，记住要通过指针，而且在设置时，要先取消引用，通过 refPtrVal.Elem().Set(newRefVal) 更新其中的值，传递给 Set 的参数也必须要是 reflect.Value 类型。<br />
如果想创建一个新的变量，可以通过 reflect.New(varType) 实现，传递的参数是 reflect.Type 类型，该方法将会返回一个指针，如前面介绍的那样，你可以通过使用 Elem().Set() 来设置它的值。<br />
最终，通过 Interface() 方法，你就得到一个正常的变量。Go 中没有泛型，变量的类型将会丢失，Interface() 方法将会返回一个类型为 interface{} 的变量。如果你为了能更新值，创建的是一个指针，那么需要使用 Elem().Interface() 来获取变量。但无论是上面的哪种情况，你都需要把 interface{} 类型变量转化为实际的类型，如此才能使用。<br />
下面是一些代码，实现了这些概念。<br />
type Foo struct {<br />
	A int <code class="language-plaintext highlighter-rouge">tag1:"First Tag" tag2:"Second Tag"</code><br />
	B string<br />
}</p><br />
<br />
<p>func main() {<br />
	greeting := “hello”<br />
	f := Foo{A: 10, B: “Salutations”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gVal := reflect.ValueOf(greeting)<br />
// not a pointer so all we can do is read it<br />
fmt.Println(gVal.Interface())<br />
<br />
gpVal := reflect.ValueOf(&amp;greeting)<br />
// it’s a pointer, so we can change it, and it changes the underlying variable<br />
gpVal.Elem().SetString("goodbye")<br />
fmt.Println(greeting)<br />
<br />
fType := reflect.TypeOf(f)<br />
fVal := reflect.New(fType)<br />
fVal.Elem().Field(0).SetInt(20)<br />
fVal.Elem().Field(1).SetString("Greetings")<br />
f2 := fVal.Elem().Interface().(Foo)<br />
fmt.Printf("%+v, %d, %s\n", f2, f2.A, f2.B) } 复制代码输出如下： hello goodbye {A:20 B:Greetings}, 20, Greetings 复制代码运行示例 无 make 的创建实例 对于像 slice、map、channel类型，它们需要用 make 创建实例，你也可以使用反射实现。slice 使用 reflect.MakeSlice，map 使用 reflect.MakeMap，channel 使用 reflect.MakeChan，你需要提供将创建变量的类型，即 reflect.Type，传递给这些函数。成功调用后，你将得到一个类型为 reflect.Value 的变量，你可以通过反射操作这个变量，操作完成后，就 可以将它转化为正常的变量。 func main() {<br />
// declaring these vars, so I can make a reflect.Type<br />
intSlice := make([]int, 0)<br />
mapStringInt := make(map[string]int)<br />
<br />
// here are the reflect.Types<br />
sliceType := reflect.TypeOf(intSlice)<br />
mapType := reflect.TypeOf(mapStringInt)<br />
<br />
// and here are the new values that we are making<br />
intSliceReflect := reflect.MakeSlice(sliceType, 0, 0)<br />
mapReflect := reflect.MakeMap(mapType)<br />
<br />
// and here we are using them<br />
v := 10<br />
rv := reflect.ValueOf(v)<br />
intSliceReflect = reflect.Append(intSliceReflect, rv)<br />
intSlice2 := intSliceReflect.Interface().([]int)<br />
fmt.Println(intSlice2)<br />
<br />
k := "hello"<br />
rk := reflect.ValueOf(k)<br />
mapReflect.SetMapIndex(rk, rv)<br />
mapStringInt2 := mapReflect.Interface().(map[string]int)<br />
fmt.Println(mapStringInt2) } 复制代码输出如下： [10] map[hello:10] 复制代码运行示例 创建函数 你不仅经可以通过反射创建空间存储数据，还可以通过反射提供的函数 reflect.MakeFunc 来创建新的函数。这个函数期待接收参数有两个，一个是 reflect.Type 类型，并且 Kind 为 Function，另外一个是闭包函数，它的输入参数类型是 []reflect.Value，输出参数是 []reflect.Value。 下面是一个快速体验示例，可为任何函数在外层包裹一个记录执行时间的函数。<br />
</code></pre></div></div><br />
<br />
<p>func MakeTimedFunction(f interface{}) interface{} {<br />
	rf := reflect.TypeOf(f)<br />
	if rf.Kind() != reflect.Func {<br />
		panic(“expects a function”)<br />
	}<br />
	vf := reflect.ValueOf(f)<br />
	wrapperF := reflect.MakeFunc(rf, func(in []reflect.Value) []reflect.Value {<br />
		start := time.Now()<br />
		out := vf.Call(in)<br />
		end := time.Now()<br />
		fmt.Printf(“calling %s took %v\n”, runtime.FuncForPC(vf.Pointer()).Name(), end.Sub(start))<br />
		return out<br />
	})<br />
	return wrapperF.Interface()<br />
}</p><br />
<br />
<p>func timeMe() {<br />
	fmt.Println(“starting”)<br />
	time.Sleep(1 * time.Second)<br />
	fmt.Println(“ending”)<br />
}</p><br />
<br />
<p>func timeMeToo(a int) int {<br />
	fmt.Println(“starting”)<br />
	time.Sleep(time.Duration(a) * time.Second)<br />
	result := a * 2<br />
	fmt.Println(“ending”)<br />
	return result<br />
}</p><br />
<br />
<p>func main() {<br />
	timed := MakeTimedFunction(timeMe).(func())<br />
	timed()<br />
	timedToo := MakeTimedFunction(timeMeToo).(func(int) int)<br />
    fmt.Println(timedToo(2))<br />
}<br />
复制代码输出如下：<br />
starting<br />
ending<br />
calling main.timeMe took 1s<br />
starting<br />
ending<br />
calling main.timeMeToo took 2s<br />
4<br />
复制代码运行示例<br />
创建一个新的结构<br />
Go 中，反射还可以在运行时创建一个全新的结构体，你可以通过传递一个 reflect.StructField 的  slice 给 reflect.StructOf 函数来实现。是不是听起来挺荒诞的，我们创建的一个新的类型，但是这个类型没有名字，因此也就无法将它转化为正常的变量。你可以通过它创建实例，用 Interface() 把它的值转给类型为 interface{} 的变量，但是如果要设置它的值，必须来反射来做。<br />
func MakeStruct(vals …interface{}) interface{} {<br />
	var sfs []reflect.StructField<br />
	for k, v := range vals {<br />
		t := reflect.TypeOf(v)<br />
		sf := reflect.StructField{<br />
			Name: fmt.Sprintf(“F%d”, (k + 1)),<br />
			Type: t,<br />
		}<br />
		sfs = append(sfs, sf)<br />
	}<br />
	st := reflect.StructOf(sfs)<br />
	so := reflect.New(st)<br />
	return so.Interface()<br />
}</p><br />
<br />
<p>func main() {<br />
	s := MakeStruct(0, “”, []int{})<br />
	// this returned a pointer to a struct with 3 fields:<br />
	// an int, a string, and a slice of ints<br />
	// but you can’t actually use any of these fields<br />
	// directly in the code; you have to reflect them<br />
	sr := reflect.ValueOf(s)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// getting and setting the int field<br />
fmt.Println(sr.Elem().Field(0).Interface())<br />
sr.Elem().Field(0).SetInt(20)<br />
fmt.Println(sr.Elem().Field(0).Interface())<br />
<br />
// getting and setting the string field<br />
fmt.Println(sr.Elem().Field(1).Interface())<br />
sr.Elem().Field(1).SetString("reflect me")<br />
fmt.Println(sr.Elem().Field(1).Interface())<br />
<br />
// getting and setting the []int field<br />
fmt.Println(sr.Elem().Field(2).Interface())<br />
v := []int{1, 2, 3}<br />
rv := reflect.ValueOf(v)<br />
sr.Elem().Field(2).Set(rv)<br />
fmt.Println(sr.Elem().Field(2).Interface()) } 复制代码输出如下： 0 20<br />
</code></pre></div></div><br />
<br />
<p>reflect me<br />
[]<br />
[1 2 3]<br />
复制代码运行示例<br />
反射的限制<br />
反射有一个大的限制。虽然运行时可以通过反射创建新的函数，但无法用反射创建新的方法，这也就意味着你不能在运行时用反射实现一个接口，用反射创建的结构体使用起来很支离破碎。而且，通过反射创建的结构体，无法实现 GO 的一个特性 —— 通过匿名字段实现委托模式。<br />
看一个通过结构体实现委托模式的例子，通常情况下，结构体的字段都会定义名称。在这例子中，我们定义了两个类型，Foo 和 Bar：<br />
type Foo struct {<br />
	A int<br />
}</p><br />
<br />
<p>func (f Foo) Double() int {<br />
	return f.A * 2<br />
}</p><br />
<br />
<p>type Bar struct {<br />
	Foo<br />
	B int<br />
}</p><br />
<br />
<p>type Doubler interface {<br />
	Double() int<br />
}</p><br />
<br />
<p>func DoDouble(d Doubler) {<br />
	fmt.Println(d.Double())<br />
}</p><br />
<br />
<p>func main() {<br />
	f := Foo{10}<br />
	b := Bar{Foo: f, B: 20}<br />
	DoDouble(f) // passed in an instance of Foo; it meets the interface, so no surprise here<br />
    DoDouble(b) // passed in an instance of Bar; it works!<br />
}<br />
复制代码运行示例<br />
代码中显示，Bar 中的 Foo 字段并没有名称，这使它成了一个匿名或内嵌的字段。Bar 也是满足 Double 接口的，虽然只有 Foo 实现了 Double 方法，这种能力被称为委托。在编译时，Go 会自动为 Bar 生成 Foo 中的方法。这不是继承，如果你尝试给一个只接收 Foo 的函数传递 Bar，编译将不会通过。<br />
如果你用反射去创建一个内嵌字段，并且尝试去访问它的方法，将会产生一些非常奇怪的行为。最好的方式就是，我们不要用它。关于这个问题，可以看下 github 的两个 issue，issue/15924 和 issues/16522。不幸的是，它们还没有任何的进展。<br />
那么，这会有什么问题呢？如果支持动态的接口，我们可以实现什么功能？如前面介绍，我们能通过 Go 的反射创建函数，实现包裹函数，通过 interface 也可以实现。在 Java 中，这叫做动态代理。当把它和注解结合，将能得到一个非常强大的能力，实现从命令式编程方式到声明式编程的切换，一个例子 JDBI，这个 Java 库让你可以在 DAO 层定义一个接口，它的 SQL 查询通过注解定义。所有数据操作的代码都是在运行时动态生成，就是如此的强大</p><br />
<br />
<p>https://juejin.im/post/6844903860935327757</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>