<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">50 Shades of Go Traps, Gotchas, and Common Mistakes for New Golang Devs</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-02-03T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Feb 3, 2020</time></p>
					</div>
					 <p>http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/</p><br />
<br />
<p>50 Shades of Go in Other Languages<br />
Chinese Translation: blog post, segmentfault (by wuYin) - needs updates<br />
Another Chinese Translation: blog post (by Shadowwind LEY) - needs updates<br />
Russian Translation: blog post (by Ilia Ozhereliev, Mail.Ru Group Blog) - needs updates<br />
Overview<br />
Go is a simple and fun language, but, like any other language, it has a few gotchas… Many of those gotchas are not entirely Go’s fault. Some of these mistakes are natural traps if you are coming from another language. Others are due to faulty assumptions and missing details.</p><br />
<br />
<p>A lot of these gotchas may seem obvious if you took the time to learn the language reading the official spec, wiki, mailing list discussions, many great posts and presentations by Rob Pike, and the source code. Not everybody starts the same way though and that’s OK. If you are new to Go the information here will save you hours debugging your code.</p><br />
<br />
<!-- more --><br />
<p>Blog Logo<br />
Kyle Quest | golang<br />
50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs<br />
50 Shades of Go in Other Languages<br />
Chinese Translation: blog post, segmentfault (by wuYin) - needs updates<br />
Another Chinese Translation: blog post (by Shadowwind LEY) - needs updates<br />
Russian Translation: blog post (by Ilia Ozhereliev, Mail.Ru Group Blog) - needs updates<br />
Overview<br />
Go is a simple and fun language, but, like any other language, it has a few gotchas… Many of those gotchas are not entirely Go’s fault. Some of these mistakes are natural traps if you are coming from another language. Others are due to faulty assumptions and missing details.</p><br />
<br />
<p>A lot of these gotchas may seem obvious if you took the time to learn the language reading the official spec, wiki, mailing list discussions, many great posts and presentations by Rob Pike, and the source code. Not everybody starts the same way though and that’s OK. If you are new to Go the information here will save you hours debugging your code.</p><br />
<br />
<p>Total Beginner:</p><br />
<br />
<p>Opening Brace Can’t Be Placed on a Separate Line<br />
Unused Variables<br />
Unused Imports<br />
Short Variable Declarations Can Be Used Only Inside Functions<br />
Redeclaring Variables Using Short Variable Declarations<br />
Can’t Use Short Variable Declarations to Set Field Values<br />
Accidental Variable Shadowing<br />
Can’t Use “nil” to Initialize a Variable Without an Explicit Type<br />
Using “nil” Slices and Maps<br />
Map Capacity<br />
Strings Can’t Be “nil”<br />
Array Function Arguments<br />
Unexpected Values in Slice and Array “range” Clauses<br />
Slices and Arrays Are One-Dimensional<br />
Accessing Non-Existing Map Keys<br />
Strings Are Immutable<br />
Conversions Between Strings and Byte Slices<br />
Strings and Index Operator<br />
Strings Are Not Always UTF8 Text<br />
String Length<br />
Missing Comma In Multi-Line Slice/Array/Map Literals<br />
log.Fatal and log.Panic Do More Than Log<br />
Built-in Data Structure Operations Are Not Synchronized<br />
Iteration Values For Strings in “range” Clauses<br />
Iterating Through a Map Using a “for range” Clause<br />
Fallthrough Behavior in “switch” Statements<br />
Increments and Decrements<br />
Bitwise NOT Operator<br />
Operator Precedence Differences<br />
Unexported Structure Fields Are Not Encoded<br />
App Exits With Active Goroutines<br />
Sending to an Unbuffered Channel Returns As Soon As the Target Receiver Is Ready<br />
Sending to an Closed Channel Causes a Panic<br />
Using “nil” Channels<br />
Methods with Value Receivers Can’t Change the Original Value<br />
Intermediate Beginner:</p><br />
<br />
<p>Closing HTTP Response Body<br />
Closing HTTP Connections<br />
JSON Encoder Adds a Newline Character<br />
JSON Package Escapes Special HTML Characters in Keys and String Values<br />
Unmarshalling JSON Numbers into Interface Values<br />
JSON String Values Will Not Be Ok with Hex or Other non-UTF8 Escape Sequences<br />
Comparing Structs, Arrays, Slices, and Maps<br />
Recovering From a Panic<br />
Updating and Referencing Item Values in Slice, Array, and Map “for range” Clauses<br />
“Hidden” Data in Slices<br />
Slice Data Corruption<br />
“Stale” Slices<br />
Type Declarations and Methods<br />
Breaking Out of “for switch” and “for select” Code Blocks<br />
Iteration Variables and Closures in “for” Statements<br />
Deferred Function Call Argument Evaluation<br />
Deferred Function Call Execution<br />
Failed Type Assertions<br />
Blocked Goroutines and Resource Leaks<br />
Same Address for Different Zero-sized Variables<br />
The First Use of iota Doesn’t Always Start with Zero<br />
Advanced Beginner:</p><br />
<br />
<p>Using Pointer Receiver Methods On Value Instances<br />
Updating Map Value Fields<br />
“nil” Interfaces and “nil” Interfaces Values<br />
Stack and Heap Variables<br />
GOMAXPROCS, Concurrency, and Parallelism<br />
Read and Write Operation Reordering<br />
Preemptive Scheduling<br />
Cgo (aka Brave Beginner):</p><br />
<br />
<p>Import C and Multiline Import Blocks<br />
No blank lines Between Import C and Cgo Comments<br />
Can’t Call C Functions with Variable Arguments</p><br />
<br />
<p>Traps, Gotchas, and Common Mistakes</p><br />
<br />
<p>Opening Brace Can’t Be Placed on a Separate Line<br />
level: beginner<br />
In most other languages that use braces you get to choose where you place them. Go is different. You can thank automatic semicolon injection (without lookahead) for this behavior. Yes, Go does have semicolons :-)</p><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main()<br /><br />
{ //error, can’t have the opening brace on a separate line<br />
    fmt.Println(“hello there!”)<br />
}<br />
Compile Error:</p><br />
<br />
<p>/tmp/sandbox826898458/main.go:6: syntax error: unexpected semicolon or newline before {</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    fmt.Println(“works!”)<br />
}<br />
Unused Variables<br />
level: beginner<br />
If you have an unused variable your code will fail to compile. There’s an exception though. You must use variables you declare inside functions, but it’s OK if you have unused global variables. It’s also OK to have unused function arguments.</p><br />
<br />
<p>If you assign a new value to the unused variable your code will still fail to compile. You need to use the variable value somehow to make the compiler happy.</p><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>var gvar int //not an error</p><br />
<br />
<p>func main() {<br /><br />
    var one int   //error, unused variable<br />
    two := 2      //error, unused variable<br />
    var three int //error, even though it’s assigned 3 on the next line<br />
    three = 3</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func(unused string) {<br />
    fmt.Println("Unused arg. No compile error")<br />
}("what?") } Compile Errors:<br />
</code></pre></div></div><br />
<br />
<p>/tmp/sandbox473116179/main.go:6: one declared and not used /tmp/sandbox473116179/main.go:7: two declared and not used /tmp/sandbox473116179/main.go:8: three declared and not used</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    var one int<br />
    _ = one</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>two := 2 <br />
fmt.Println(two)<br />
<br />
var three int <br />
three = 3<br />
one = three<br />
<br />
var four int<br />
four = four } Another option is to comment out or remove the unused variables :-)<br />
</code></pre></div></div><br />
<br />
<p>Unused Imports<br />
level: beginner<br />
Your code will fail to compile if you import a package without using any of its exported functions, interfaces, structures, or variables.</p><br />
<br />
<p>If you really need the imported package you can use the blank identifier, _, as its package name to avoid this compilation failure. The blank identifier is used to import packages for their side effects.</p><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “log”<br />
    “time”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
}<br />
Compile Errors:</p><br />
<br />
<p>/tmp/sandbox627475386/main.go:4: imported and not used: “fmt” /tmp/sandbox627475386/main.go:5: imported and not used: “log” /tmp/sandbox627475386/main.go:6: imported and not used: “time”</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    _ “fmt”<br />
    “log”<br />
    “time”<br />
)</p><br />
<br />
<p>var _ = log.Println</p><br />
<br />
<p>func main() {<br /><br />
    _ = time.Now<br />
}<br />
Another option is to remove or comment out the unused imports :-) The goimports tool can help you with that.</p><br />
<br />
<p>Short Variable Declarations Can Be Used Only Inside Functions<br />
level: beginner<br />
Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>myvar := 1 //error</p><br />
<br />
<p>func main() {<br /><br />
}<br />
Compile Error:</p><br />
<br />
<p>/tmp/sandbox265716165/main.go:3: non-declaration statement outside function body</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>var myvar = 1</p><br />
<br />
<p>func main() {<br /><br />
}<br />
Redeclaring Variables Using Short Variable Declarations<br />
level: beginner<br />
You can’t redeclare a variable in a standalone statement, but it is allowed in multi-variable declarations where at least one new variable is also declared.</p><br />
<br />
<p>The redeclared variable has to be in the same block or you’ll end up with a shadowed variable.</p><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br /><br />
    one := 0<br />
    one := 1 //error<br />
}<br />
Compile Error:</p><br />
<br />
<p>/tmp/sandbox706333626/main.go:5: no new variables on left side of :=</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br /><br />
    one := 0<br />
    one, two := 1,2</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>one,two = two,one } Can't Use Short Variable Declarations to Set Field Values level: beginner Fails:<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
  “fmt”<br />
)</p><br />
<br />
<p>type info struct {<br /><br />
  result int<br />
}</p><br />
<br />
<p>func work() (int,error) {<br /><br />
    return 13,nil<br /><br />
  }</p><br />
<br />
<p>func main() {<br /><br />
  var data info</p><br />
<br />
<p>data.result, err := work() //error<br />
  fmt.Printf(“info: %+v\n”,data)<br />
}<br />
Compile Error:</p><br />
<br />
<p>prog.go:18: non-name data.result on left side of :=</p><br />
<br />
<p>Even though there’s a ticket to address this gotcha it’s unlikely to change because Rob Pike likes it “as is” :-)</p><br />
<br />
<p>Use temporary variables or predeclare all your variables and use the standard assignment operator.</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
  “fmt”<br />
)</p><br />
<br />
<p>type info struct {<br /><br />
  result int<br />
}</p><br />
<br />
<p>func work() (int,error) {<br /><br />
    return 13,nil<br /><br />
  }</p><br />
<br />
<p>func main() {<br /><br />
  var data info</p><br />
<br />
<p>var err error<br />
  data.result, err = work() //ok<br />
  if err != nil {<br />
    fmt.Println(err)<br />
    return<br />
  }</p><br />
<br />
<p>fmt.Printf(“info: %+v\n”,data) //prints: info: {result:13}<br />
}<br />
Accidental Variable Shadowing<br />
level: beginner<br />
The short variable declaration syntax is so convenient (especially for those coming from a dynamic language) that it’s easy to treat it like a regular assignment operation. If you make this mistake in a new code block there will be no compiler error, but your app will not do what you expect.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    x := 1<br />
    fmt.Println(x)     //prints 1<br />
    {<br />
        fmt.Println(x) //prints 1<br />
        x := 2<br />
        fmt.Println(x) //prints 2<br />
    }<br />
    fmt.Println(x)     //prints 1 (bad if you need 2)<br />
}<br />
This is a very common trap even for experienced Go developers. It’s easy to make and it could be hard to spot.</p><br />
<br />
<p>You can use the vet command to find some of these problems. By default, vet will not perform any shadowed variable checks. Make sure to use the -shadow flag: go tool vet -shadow your_file.go</p><br />
<br />
<p>Note that the vet command will not report all shadowed variables. Use go-nyet for more aggressive shadowed variable detection.</p><br />
<br />
<p>Can’t Use “nil” to Initialize a Variable Without an Explicit Type<br />
level: beginner<br />
The “nil” identifier can be used as the “zero value” for interfaces, functions, pointers, maps, slices, and channels. If you don’t specify the variable type the compiler will fail to compile your code because it can’t guess the type.</p><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br /><br />
    var x = nil //error</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_ = x } Compile Error:<br />
</code></pre></div></div><br />
<br />
<p>/tmp/sandbox188239583/main.go:4: use of untyped nil</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br /><br />
    var x interface{} = nil</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_ = x } Using "nil" Slices and Maps level: beginner It's OK to add items to a "nil" slice, but doing the same with a map will produce a runtime panic.<br />
</code></pre></div></div><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br /><br />
    var s []int<br />
    s = append(s,1)<br />
}<br />
Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br /><br />
    var m map[string]int<br />
    m[“one”] = 1 //error</p><br />
<br />
<p>}<br />
Map Capacity<br />
level: beginner<br />
You can specify the map capacity when it’s created, but you can’t use the cap() function on maps.</p><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br /><br />
    m := make(map[string]int,99)<br />
    cap(m) //error<br />
}<br />
Compile Error:</p><br />
<br />
<p>/tmp/sandbox326543983/main.go:5: invalid argument m (type map[string]int) for cap</p><br />
<br />
<p>Strings Can’t Be “nil”<br />
level: beginner<br />
This is a gotcha for developers who are used to assigning “nil” identifiers to string variables.</p><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br /><br />
    var x string = nil //error</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x == nil { //error<br />
    x = "default"<br />
} } Compile Errors:<br />
</code></pre></div></div><br />
<br />
<p>/tmp/sandbox630560459/main.go:4: cannot use nil as type string in assignment /tmp/sandbox630560459/main.go:6: invalid operation: x == nil (mismatched types string and nil)</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br /><br />
    var x string //defaults to “” (zero value)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if x == "" {<br />
    x = "default"<br />
} } Array Function Arguments level: beginner If you are a C or C++ developer arrays for you are pointers. When you pass arrays to functions the functions reference the same memory location, so they can update the original data. Arrays in Go are values, so when you pass arrays to functions the functions get a copy of the original array data. This can be a problem if you are trying to update the array data.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    x := [3]int{1,2,3}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func(arr [3]int) {<br />
    arr[0] = 7<br />
    fmt.Println(arr) //prints [7 2 3]<br />
}(x)<br />
<br />
fmt.Println(x) //prints [1 2 3] (not ok if you need [7 2 3]) } If you need to update the original array data use array pointer types.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    x := [3]int{1,2,3}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func(arr *[3]int) {<br />
    (*arr)[0] = 7<br />
    fmt.Println(arr) //prints &amp;[7 2 3]<br />
}(&amp;x)<br />
<br />
fmt.Println(x) //prints [7 2 3] } Another option is to use slices. Even though your function gets a copy of the slice variable it still references the original data.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    x := []int{1,2,3}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func(arr []int) {<br />
    arr[0] = 7<br />
    fmt.Println(arr) //prints [7 2 3]<br />
}(x)<br />
<br />
fmt.Println(x) //prints [7 2 3] } Unexpected Values in Slice and Array "range" Clauses level: beginner This can happen if you are used to the "for-in" or "foreach" statements in other languages. The "range" clause in Go is different. It generates two values: the first value is the item index while the second value is the item data.<br />
</code></pre></div></div><br />
<br />
<p>Bad:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    x := []string{“a”,”b”,”c”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for v := range x {<br />
    fmt.Println(v) //prints 0, 1, 2<br />
} } Good:<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    x := []string{“a”,”b”,”c”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _, v := range x {<br />
    fmt.Println(v) //prints a, b, c<br />
} } Slices and Arrays Are One-Dimensional level: beginner It may seem like Go supports multi-dimensional arrays and slices, but it doesn't. Creating arrays of arrays or slices of slices is possible though. For numerical computation apps that rely on dynamic multi-dimensional arrays it's far from ideal in terms of performance and complexity.<br />
</code></pre></div></div><br />
<br />
<p>You can build dynamic multi-dimensional arrays using raw one-dimensional arrays, slices of “independent” slices, and slices of “shared data” slices.</p><br />
<br />
<p>If you are using raw one-dimensional arrays you are responsible for indexing, bounds checking, and memory reallocations when the arrays need to grow.</p><br />
<br />
<p>Creating a dynamic multi-dimensional array using slices of “independent” slices is a two step process. First, you have to create the outer slice. Then, you have to allocate each inner slice. The inner slices are independent of each other. You can grow and shrink them without affecting other inner slices.</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br /><br />
    x := 2<br />
    y := 4</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>table := make([][]int,x)<br />
for i:= range table {<br />
    table[i] = make([]int,y)<br />
} } Creating a dynamic multi-dimensional array using slices of "shared data" slices is a three step process. First, you have to create the data "container" slice that will hold raw data. Then, you create the outer slice. Finally, you initialize each inner slice by reslicing the raw data slice.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    h, w := 2, 4</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>raw := make([]int,h*w)<br />
for i := range raw {<br />
    raw[i] = i<br />
}<br />
fmt.Println(raw,&amp;raw[4])<br />
//prints: [0 1 2 3 4 5 6 7] &lt;ptr_addr_x&gt;<br />
<br />
table := make([][]int,h)<br />
for i:= range table {<br />
    table[i] = raw[i*w:i*w + w]<br />
}<br />
<br />
fmt.Println(table,&amp;table[1][0])<br />
//prints: [[0 1 2 3] [4 5 6 7]] &lt;ptr_addr_x&gt; } There's a spec/proposal for multi-dimensional arrays and slices, but it looks like it's a low priority feature at this point in time.<br />
</code></pre></div></div><br />
<br />
<p>Accessing Non-Existing Map Keys<br />
level: beginner<br />
This is a gotcha for developers who expect to get “nil” identifiers (like it’s done in other languages). The returned value will be “nil” if the “zero value” for the corresponding data type is “nil”, but it’ll be different for other data types. Checking for the appropriate “zero value” can be used to determine if the map record exists, but it’s not always reliable (e.g., what do you do if you have a map of booleans where the “zero value” is false). The most reliable way to know if a given map record exists is to check the second value returned by the map access operation.</p><br />
<br />
<p>Bad:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    x := map[string]string{“one”:”a”,”two”:””,”three”:”c”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if v := x["two"]; v == "" { //incorrect<br />
    fmt.Println("no entry")<br />
} } Good:<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    x := map[string]string{“one”:”a”,”two”:””,”three”:”c”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if _,ok := x["two"]; !ok {<br />
    fmt.Println("no entry")<br />
} } Strings Are Immutable level: beginner Trying to update an individual character in a string variable using the index operator will result in a failure. Strings are read-only byte slices (with a few extra properties). If you do need to update a string then use a byte slice instead converting it to a string type when necessary.<br />
</code></pre></div></div><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    x := “text”<br />
    x[0] = ‘T’</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println(x) } Compile Error:<br />
</code></pre></div></div><br />
<br />
<p>/tmp/sandbox305565531/main.go:7: cannot assign to x[0]</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    x := “text”<br />
    xbytes := []byte(x)<br />
    xbytes[0] = ‘T’</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println(string(xbytes)) //prints Text } Note that this isn't really the right way to update characters in a text string because a given character could be stored in multiple bytes. If you do need to make updates to a text string convert it to a rune slice first. Even with rune slices a single character might span multiple runes, which can happen if you have characters with grave accent, for example. This complicated and ambiguous nature of "characters" is the reason why Go strings are represented as byte sequences.<br />
</code></pre></div></div><br />
<br />
<p>Conversions Between Strings and Byte Slices<br />
level: beginner<br />
When you convert a string to a byte slice (and vice versa) you get a complete copy of the orginal data. It’s not like a cast operation in other languages and it’s not like reslicing where the new slice variable points to the same underlying array used by the original byte slice.</p><br />
<br />
<p>Go does have a couple of optimizations for []byte to string and string to []byte conversions to avoid extra allocations (with more optimizations on the todo list).</p><br />
<br />
<p>The first optimization avoids extra allocations when []byte keys are used to lookup entries in map[string] collections: m[string(key)].</p><br />
<br />
<p>The second optimization avoids extra allocations in for range clauses where strings are converted to []byte: for i,v := range []byte(str) {…}.</p><br />
<br />
<p>Strings and Index Operator<br />
level: beginner<br />
The index operator on a string returns a byte value, not a character (like it’s done in other languages).</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    x := “text”<br />
    fmt.Println(x[0]) //print 116<br />
    fmt.Printf(“%T”,x[0]) //prints uint8<br />
}<br />
If you need to access specific string “characters” (unicode code points/runes) use the for range clause. The official “unicode/utf8” package and the experimental utf8string package (golang.org/x/exp/utf8string) are also useful. The utf8string package includes a convenient At() method. Converting the string to a slice of runes is an option too.</p><br />
<br />
<p>Strings Are Not Always UTF8 Text<br />
level: beginner<br />
String values are not required to be UTF8 text. They can contain arbitrary bytes. The only time strings are UTF8 is when string literals are used. Even then they can include other data using escape sequences.</p><br />
<br />
<p>To know if you have a UTF8 text string use the ValidString() function from the “unicode/utf8” package.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “unicode/utf8”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    data1 := “ABC”<br />
    fmt.Println(utf8.ValidString(data1)) //prints: true</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data2 := "A\xfeC"<br />
fmt.Println(utf8.ValidString(data2)) //prints: false } String Length level: beginner Let's say you are a python developer and you have the following piece of code:<br />
</code></pre></div></div><br />
<br />
<p>data = u’♥’<br /><br />
print(len(data)) #prints: 1<br /><br />
When you convert it to a similar Go code snippet you might be surprised.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    data := “♥”<br />
    fmt.Println(len(data)) //prints: 3<br />
}<br />
The built-in len() function returns the number of bytes instead of the number of characters like it’s done for unicode strings in Python.</p><br />
<br />
<p>To get the same results in Go use the RuneCountInString() function from the “unicode/utf8” package.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “unicode/utf8”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    data := “♥”<br />
    fmt.Println(utf8.RuneCountInString(data)) //prints: 1<br />
Technically the RuneCountInString() function doesn’t return the number of characters because a single character may span multiple runes.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “unicode/utf8”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    data := “é”<br />
    fmt.Println(len(data))                    //prints: 3<br />
    fmt.Println(utf8.RuneCountInString(data)) //prints: 2<br />
}<br />
Missing Comma In Multi-Line Slice, Array, and Map Literals<br />
level: beginner<br />
Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br /><br />
    x := []int{<br />
    1,<br />
    2 //error<br />
    }<br />
    _ = x<br />
}<br />
Compile Errors:</p><br />
<br />
<p>/tmp/sandbox367520156/main.go:6: syntax error: need trailing comma before newline in composite literal /tmp/sandbox367520156/main.go:8: non-declaration statement outside function body /tmp/sandbox367520156/main.go:9: syntax error: unexpected }</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>func main() {<br /><br />
    x := []int{<br />
    1,<br />
    2,<br />
    }<br />
    x = x</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>y := []int{3,4,} //no error<br />
y = y } You won't get a compiler error if you leave the trailing comma when you collapse the declaration to be on a single line.<br />
</code></pre></div></div><br />
<br />
<p>log.Fatal and log.Panic Do More Than Log<br />
level: beginner<br />
Logging libraries often provide different log levels. Unlike those logging libraries, the log package in Go does more than log if you call its Fatal<em>() and Panic</em>() functions. When your app calls those functions Go will also terminate your app :-)</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “log”</p><br />
<br />
<p>func main() {<br /><br />
    log.Fatalln(“Fatal Level: log entry”) //app exits here<br />
    log.Println(“Normal Level: log entry”)<br />
}<br />
Built-in Data Structure Operations Are Not Synchronized<br />
level: beginner<br />
Even though Go has a number of features to support concurrency natively, concurrency safe data collections are not one them :-) It’s your responsibility to ensure the data collection updates are atomic. Goroutines and channels are the recommended way to implement those atomic operations, but you can also leverage the “sync” package if it makes sense for your application.</p><br />
<br />
<p>Iteration Values For Strings in “range” Clauses<br />
level: beginner<br />
The index value (the first value returned by the “range” operation) is the index of the first byte for the current “character” (unicode code point/rune) returned in the second value. It’s not the index for the current “character” like it’s done in other languages. Note that an actual character might be represented by multiple runes. Make sure to check out the “norm” package (golang.org/x/text/unicode/norm) if you need to work with characters.</p><br />
<br />
<p>The for range clauses with string variables will try to interpret the data as UTF8 text. For any byte sequences it doesn’t understand it will return 0xfffd runes (aka unicode replacement characters) instead of the actual data. If you have arbitrary (non-UTF8 text) data stored in your string variables, make sure to convert them to byte slices to get all stored data as is.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    data := “A\xfe\x02\xff\x04”<br />
    for _,v := range data {<br />
        fmt.Printf(“%#x “,v)<br />
    }<br />
    //prints: 0x41 0xfffd 0x2 0xfffd 0x4 (not ok)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println()<br />
for _,v := range []byte(data) {<br />
    fmt.Printf("%#x ",v)<br />
}<br />
//prints: 0x41 0xfe 0x2 0xff 0x4 (good) } Iterating Through a Map Using a "for range" Clause level: beginner This is a gotcha if you expect the items to be in a certain order (e.g., ordered by the key value). Each map iteration will produce different results. The Go runtime tries to go an extra mile randomizing the iteration order, but it doesn't always succeed so you may get several identical map iterations. Don't be surprised to see 5 identical iterations in a row.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    m := map[string]int{“one”:1,”two”:2,”three”:3,”four”:4}<br />
    for k,v := range m {<br />
        fmt.Println(k,v)<br />
    }<br />
}<br />
And if you use the Go Playground (https://play.golang.org/) you’ll always get the same results because it doesn’t recompile the code unless you make a change.</p><br />
<br />
<p>Fallthrough Behavior in “switch” Statements<br />
level: beginner<br />
The “case” blocks in “switch” statements break by default. This is different from other languages where the default behavior is to fall through to the next “case” block.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    isSpace := func(ch byte) bool {<br />
        switch(ch) {<br />
        case ‘ ‘: //error<br />
        case ‘\t’:<br />
            return true<br />
        }<br />
        return false<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println(isSpace('\t')) //prints true (ok)<br />
fmt.Println(isSpace(' '))  //prints false (not ok) } You can force the "case" blocks to fall through by using the "fallthrough" statement at the end of each "case" block. You can also rewrite your switch statement to use expression lists in the "case" blocks.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    isSpace := func(ch byte) bool {<br />
        switch(ch) {<br />
        case ‘ ‘, ‘\t’:<br />
            return true<br />
        }<br />
        return false<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println(isSpace('\t')) //prints true (ok)<br />
fmt.Println(isSpace(' '))  //prints true (ok) } Increments and Decrements level: beginner Many languages have increment and decrement operators. Unlike other languages, Go doesn't support the prefix version of the operations. You also can't use these two operators in expressions.<br />
</code></pre></div></div><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    data := []int{1,2,3}<br />
    i := 0<br />
    ++i //error<br />
    fmt.Println(data[i++]) //error<br />
}<br />
Compile Errors:</p><br />
<br />
<p>/tmp/sandbox101231828/main.go:8: syntax error: unexpected ++ /tmp/sandbox101231828/main.go:9: syntax error: unexpected ++, expecting :</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    data := []int{1,2,3}<br />
    i := 0<br />
    i++<br />
    fmt.Println(data[i])<br />
}<br />
Bitwise NOT Operator<br />
level: beginner<br />
Many languages use ~ as the unary NOT operator (aka bitwise complement), but Go reuses the XOR operator (^) for that.</p><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    fmt.Println(~2) //error<br />
}<br />
Compile Error:</p><br />
<br />
<p>/tmp/sandbox965529189/main.go:6: the bitwise complement operator is ^</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    var d uint8 = 2<br />
    fmt.Printf(“%08b\n”,^d)<br />
}<br />
Go still uses ^ as the XOR operator, which may be confusing for some people.</p><br />
<br />
<p>If you want you can represent a unary NOT operation (e.g, NOT 0x02) with a binary XOR operation (e.g., 0x02 XOR 0xff). This could explain why ^ is reused to represent unary NOT operations.</p><br />
<br />
<p>Go also has a special ‘AND NOT’ bitwise operator (&amp;^), which adds to the NOT operator confusion. It looks like a special feature/hack to support A AND (NOT B) without requiring parentheses.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    var a uint8 = 0x82<br />
    var b uint8 = 0x02<br />
    fmt.Printf(“%08b [A]\n”,a)<br />
    fmt.Printf(“%08b [B]\n”,b)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("%08b (NOT B)\n",^b)<br />
fmt.Printf("%08b ^ %08b = %08b [B XOR 0xff]\n",b,0xff,b ^ 0xff)<br />
<br />
fmt.Printf("%08b ^ %08b = %08b [A XOR B]\n",a,b,a ^ b)<br />
fmt.Printf("%08b &amp; %08b = %08b [A AND B]\n",a,b,a &amp; b)<br />
fmt.Printf("%08b &amp;^%08b = %08b [A 'AND NOT' B]\n",a,b,a &amp;^ b)<br />
fmt.Printf("%08b&amp;(^%08b)= %08b [A AND (NOT B)]\n",a,b,a &amp; (^b)) } Operator Precedence Differences level: beginner Aside from the "bit clear" operators (&amp;^) Go has a set of standard operators shared by many other languages. The operator precedence is not always the same though.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    fmt.Printf(“0x2 &amp; 0x2 + 0x4 -&gt; %#x\n”,0x2 &amp; 0x2 + 0x4)<br />
    //prints: 0x2 &amp; 0x2 + 0x4 -&gt; 0x6<br />
    //Go:    (0x2 &amp; 0x2) + 0x4<br />
    //C++:    0x2 &amp; (0x2 + 0x4) -&gt; 0x2</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("0x2 + 0x2 &lt;&lt; 0x1 -&gt; %#x\n",0x2 + 0x2 &lt;&lt; 0x1)<br />
//prints: 0x2 + 0x2 &lt;&lt; 0x1 -&gt; 0x6<br />
//Go:     0x2 + (0x2 &lt;&lt; 0x1)<br />
//C++:   (0x2 + 0x2) &lt;&lt; 0x1 -&gt; 0x8<br />
<br />
fmt.Printf("0xf | 0x2 ^ 0x2 -&gt; %#x\n",0xf | 0x2 ^ 0x2)<br />
//prints: 0xf | 0x2 ^ 0x2 -&gt; 0xd<br />
//Go:    (0xf | 0x2) ^ 0x2<br />
//C++:    0xf | (0x2 ^ 0x2) -&gt; 0xf } Unexported Structure Fields Are Not Encoded level: beginner The struct fields starting with lowercase letters will not be (json, xml, gob, etc.) encoded, so when you decode the structure you'll end up with zero values in those unexported fields.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “encoding/json”<br />
)</p><br />
<br />
<p>type MyData struct {<br /><br />
    One int<br />
    two string<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    in := MyData{1,”two”}<br />
    fmt.Printf(“%#v\n”,in) //prints main.MyData{One:1, two:”two”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>encoded,_ := json.Marshal(in)<br />
fmt.Println(string(encoded)) //prints {"One":1}<br />
<br />
var out MyData<br />
json.Unmarshal(encoded,&amp;out)<br />
<br />
fmt.Printf("%#v\n",out) //prints main.MyData{One:1, two:""} } App Exits With Active Goroutines level: beginner The app will not wait for all your goroutines to complete. This is a common mistake for beginners in general. Everybody starts somewhere, so there's no shame in making rookie mistakes :-)<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “time”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    workerCount := 2</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i := 0; i &lt; workerCount; i++ {<br />
    go doit(i)<br />
}<br />
time.Sleep(1 * time.Second)<br />
fmt.Println("all done!") }<br />
</code></pre></div></div><br />
<br />
<p>func doit(workerId int) {<br /><br />
    fmt.Printf(“[%v] is running\n”,workerId)<br />
    time.Sleep(3 * time.Second)<br />
    fmt.Printf(“[%v] is done\n”,workerId)<br />
}<br />
You’ll see:</p><br />
<br />
<p>[0] is running<br />
[1] is running<br />
all done!</p><br />
<br />
<p>One of the most common solutions is to use a “WaitGroup” variable. It will allow the main goroutine to wait until all worker goroutines are done. If your app has long running workers with message processing loops you’ll also need a way to signal those goroutines that it’s time to exit. You can send a “kill” message to each worker. Another option is to close a channel all workers are receiving from. It’s a simple way to signal all goroutines at once.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “sync”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    var wg sync.WaitGroup<br />
    done := make(chan struct{})<br />
    workerCount := 2</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i := 0; i &lt; workerCount; i++ {<br />
    wg.Add(1)<br />
    go doit(i,done,wg)<br />
}<br />
<br />
close(done)<br />
wg.Wait()<br />
fmt.Println("all done!") }<br />
</code></pre></div></div><br />
<br />
<p>func doit(workerId int,done &lt;-chan struct{},wg sync.WaitGroup) {<br /><br />
    fmt.Printf(“[%v] is running\n”,workerId)<br />
    defer wg.Done()<br />
    &lt;- done<br />
    fmt.Printf(“[%v] is done\n”,workerId)<br />
}<br />
If you run this app you’ll see:</p><br />
<br />
<p>[0] is running<br />
[0] is done<br />
[1] is running<br />
[1] is done</p><br />
<br />
<p>Looks like the workers are done before the main goroutine exits. Great! However, you’ll also see this:</p><br />
<br />
<p>fatal error: all goroutines are asleep - deadlock!</p><br />
<br />
<p>That’s not so great :-) What’s going on? Why is there a deadlock? The workers exited and they executed wg.Done(). The app should work.</p><br />
<br />
<p>The deadlock happens because each worker gets a copy of the original “WaitGroup” variable. When workers execute wg.Done() it has no effect on the “WaitGroup” variable in the main goroutine.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “sync”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    var wg sync.WaitGroup<br />
    done := make(chan struct{})<br />
    wq := make(chan interface{})<br />
    workerCount := 2</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for i := 0; i &lt; workerCount; i++ {<br />
    wg.Add(1)<br />
    go doit(i,wq,done,&amp;wg)<br />
}<br />
<br />
for i := 0; i &lt; workerCount; i++ {<br />
    wq &lt;- i<br />
}<br />
<br />
close(done)<br />
wg.Wait()<br />
fmt.Println("all done!") }<br />
</code></pre></div></div><br />
<br />
<p>func doit(workerId int, wq &lt;-chan interface{},done &lt;-chan struct{},wg *sync.WaitGroup) {<br /><br />
    fmt.Printf(“[%v] is running\n”,workerId)<br />
    defer wg.Done()<br />
    for {<br />
        select {<br />
        case m := &lt;- wq:<br />
            fmt.Printf(“[%v] m =&gt; %v\n”,workerId,m)<br />
        case &lt;- done:<br />
            fmt.Printf(“[%v] is done\n”,workerId)<br />
            return<br />
        }<br />
    }<br />
}<br />
Now it works as expected :-)</p><br />
<br />
<p>Sending to an Unbuffered Channel Returns As Soon As the Target Receiver Is Ready<br />
level: beginner<br />
The sender will not be blocked until your message is processed by the receiver. Depending on the machine where you are running the code, the receiver goroutine may or may not have enough time to process the message before the sender continues its execution.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    ch := make(chan string)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go func() {<br />
    for m := range ch {<br />
        fmt.Println("processed:",m)<br />
    }<br />
}()<br />
<br />
ch &lt;- "cmd.1"<br />
ch &lt;- "cmd.2" //won't be processed } Sending to an Closed Channel Causes a Panic level: beginner Receiving from a closed channel is safe. The ok return value in a receive statement will be set to false indicating that no data was received. If you are receiving from a buffered channel you'll get the buffered data first and once it's empty the ok return value will be false.<br />
</code></pre></div></div><br />
<br />
<p>Sending data to a closed channel causes a panic. It is a documented behavior, but it’s not very intuitive for new Go developers who might expect the send behavior to be similar to the receive behavior.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “time”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    ch := make(chan int)<br />
    for i := 0; i &lt; 3; i++ {<br />
        go func(idx int) {<br />
            ch &lt;- (idx + 1) * 2<br />
        }(i)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//get the first result<br />
fmt.Println(&lt;-ch)<br />
close(ch) //not ok (you still have other senders)<br />
//do other work<br />
time.Sleep(2 * time.Second) } Depending on your application the fix will be different. It might be a minor code change or it might require a change in your application design. Either way, you'll need to make sure your application doesn't try to send data to a closed channel.<br />
</code></pre></div></div><br />
<br />
<p>The buggy example can be fixed by using a special cancellation channel to signal the remaining workers that their results are no longer neeeded.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “time”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    ch := make(chan int)<br />
    done := make(chan struct{})<br />
    for i := 0; i &lt; 3; i++ {<br />
        go func(idx int) {<br />
            select {<br />
            case ch &lt;- (idx + 1) * 2: fmt.Println(idx,”sent result”)<br />
            case &lt;- done: fmt.Println(idx,”exiting”)<br />
            }<br />
        }(i)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//get first result<br />
fmt.Println("result:",&lt;-ch)<br />
close(done)<br />
//do other work<br />
time.Sleep(3 * time.Second) } Using "nil" Channels level: beginner Send and receive operations on a nil channel block forver. It's a well documented behavior, but it can be a surprise for new Go developers.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “time”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    var ch chan int<br />
    for i := 0; i &lt; 3; i++ {<br />
        go func(idx int) {<br />
            ch &lt;- (idx + 1) * 2<br />
        }(i)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//get first result<br />
fmt.Println("result:",&lt;-ch)<br />
//do other work<br />
time.Sleep(2 * time.Second) } If you run the code you'll see a runtime error like this: fatal error: all goroutines are asleep - deadlock!<br />
</code></pre></div></div><br />
<br />
<p>This behavior can be used as a way to dynamically enable and disable case blocks in a select statement.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”<br /><br />
import “time”</p><br />
<br />
<p>func main() {<br /><br />
    inch := make(chan int)<br />
    outch := make(chan int)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go func() {<br />
    var in &lt;- chan int = inch<br />
    var out chan &lt;- int<br />
    var val int<br />
    for {<br />
        select {<br />
        case out &lt;- val:<br />
            out = nil<br />
            in = inch<br />
        case val = &lt;- in:<br />
            out = outch<br />
            in = nil<br />
        }<br />
    }<br />
}()<br />
<br />
go func() {<br />
    for r := range outch {<br />
        fmt.Println("result:",r)<br />
    }<br />
}()<br />
<br />
time.Sleep(0)<br />
inch &lt;- 1<br />
inch &lt;- 2<br />
time.Sleep(3 * time.Second) } Methods with Value Receivers Can't Change the Original Value level: beginner Method receivers are like regular function arguments. If it's declared to be a value then your function/method gets a copy of your receiver argument. This means making changes to the receiver will not affect the original value unless your receiver is a map or slice variable and you are updating the items in the collection or the fields you are updating in the receiver are pointers.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>type data struct {<br /><br />
    num int<br />
    key *string<br />
    items map[string]bool<br />
}</p><br />
<br />
<p>func (this *data) pmethod() {<br /><br />
    this.num = 7<br />
}</p><br />
<br />
<p>func (this data) vmethod() {<br /><br />
    this.num = 8<br />
    *this.key = “v.key”<br />
    this.items[“vmethod”] = true<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    key := “key.1”<br />
    d := data{1,&amp;key,make(map[string]bool)}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("num=%v key=%v items=%v\n",d.num,*d.key,d.items)<br />
//prints num=1 key=key.1 items=map[]<br />
<br />
d.pmethod()<br />
fmt.Printf("num=%v key=%v items=%v\n",d.num,*d.key,d.items) <br />
//prints num=7 key=key.1 items=map[]<br />
<br />
d.vmethod()<br />
fmt.Printf("num=%v key=%v items=%v\n",d.num,*d.key,d.items)<br />
//prints num=7 key=v.key items=map[vmethod:true] }<br />
</code></pre></div></div><br />
<br />
<p>Closing HTTP Response Body<br />
level: intermediate<br />
When you make requests using the standard http library you get a http response variable. If you don’t read the response body you still need to close it. Note that you must do it for empty responses too. It’s very easy to forget especially for new Go developers.</p><br />
<br />
<p>Some new Go developers do try to close the response body, but they do it in the wrong place.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “net/http”<br />
    “io/ioutil”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    resp, err := http.Get(“https://api.ipify.org?format=json”)<br />
    defer resp.Body.Close()//not ok<br />
    if err != nil {<br />
        fmt.Println(err)<br />
        return<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>body, err := ioutil.ReadAll(resp.Body)<br />
if err != nil {<br />
    fmt.Println(err)<br />
    return<br />
}<br />
<br />
fmt.Println(string(body)) } This code works for successful requests, but if the http request fails the resp variable might be nil, which will cause a runtime panic.<br />
</code></pre></div></div><br />
<br />
<p>The most common why to close the response body is by using a defer call after the http response error check.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “net/http”<br />
    “io/ioutil”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    resp, err := http.Get(“https://api.ipify.org?format=json”)<br />
    if err != nil {<br />
        fmt.Println(err)<br />
        return<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defer resp.Body.Close()//ok, most of the time :-)<br />
body, err := ioutil.ReadAll(resp.Body)<br />
if err != nil {<br />
    fmt.Println(err)<br />
    return<br />
}<br />
<br />
fmt.Println(string(body)) } Most of the time when your http request fails the resp variable will be nil and the err variable will be non-nil. However, when you get a redirection failure both variables will be non-nil. This means you can still end up with a leak.<br />
</code></pre></div></div><br />
<br />
<p>You can fix this leak by adding a call to close non-nil response bodies in the http response error handling block. Another option is to use one defer call to close response bodies for all failed and successful requests.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “net/http”<br />
    “io/ioutil”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    resp, err := http.Get(“https://api.ipify.org?format=json”)<br />
    if resp != nil {<br />
        defer resp.Body.Close()<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if err != nil {<br />
    fmt.Println(err)<br />
    return<br />
}<br />
<br />
body, err := ioutil.ReadAll(resp.Body)<br />
if err != nil {<br />
    fmt.Println(err)<br />
    return<br />
}<br />
<br />
fmt.Println(string(body)) } The orignal implementation for resp.Body.Close() also reads and discards the remaining response body data. This ensured that the http connection could be reused for another request if the keepalive http connection behavior is enabled. The latest http client behavior is different. Now it's your responsibility to read and discard the remaining response data. If you don't do it the http connection might be closed instead of being reused. This little gotcha is supposed to be documented in Go 1.5.<br />
</code></pre></div></div><br />
<br />
<p>If reusing the http connection is important for your application you might need to add something like this at the end of your response processing logic:</p><br />
<br />
<p>_, err = io.Copy(ioutil.Discard, resp.Body)<br /><br />
It will be necessary if you don’t read the entire response body right away, which might happen if you are processing json API responses with code like this:</p><br />
<br />
<p>json.NewDecoder(resp.Body).Decode(&amp;data)<br /><br />
Closing HTTP Connections<br />
level: intermediate<br />
Some HTTP servers keep network connections open for a while (based on the HTTP 1.1 spec and the server “keep-alive” configurations). By default, the standard http library will close the network connections only when the target HTTP server asks for it. This means your app may run out of sockets/file descriptors under certain conditions.</p><br />
<br />
<p>You can ask the http library to close the connection after your request is done by setting the Close field in the request variable to true.</p><br />
<br />
<p>Another option is to add a Connection request header and set it to close. The target HTTP server should respond with a Connection: close header too. When the http library sees this response header it will also close the connection.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “net/http”<br />
    “io/ioutil”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    req, err := http.NewRequest(“GET”,”http://golang.org”,nil)<br />
    if err != nil {<br />
        fmt.Println(err)<br />
        return<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>req.Close = true<br />
//or do this:<br />
//req.Header.Add("Connection", "close")<br />
<br />
resp, err := http.DefaultClient.Do(req)<br />
if resp != nil {<br />
    defer resp.Body.Close()<br />
}<br />
<br />
if err != nil {<br />
    fmt.Println(err)<br />
    return<br />
}<br />
<br />
body, err := ioutil.ReadAll(resp.Body)<br />
if err != nil {<br />
    fmt.Println(err)<br />
    return<br />
}<br />
<br />
fmt.Println(len(string(body))) } You can also disable http connection reuse globally. You'll need to create a custom http transport configuration for it.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “net/http”<br />
    “io/ioutil”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    tr := &amp;http.Transport{DisableKeepAlives: true}<br />
    client := &amp;http.Client{Transport: tr}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resp, err := client.Get("http://golang.org")<br />
if resp != nil {<br />
    defer resp.Body.Close()<br />
}<br />
<br />
if err != nil {<br />
    fmt.Println(err)<br />
    return<br />
}<br />
<br />
fmt.Println(resp.StatusCode)<br />
<br />
body, err := ioutil.ReadAll(resp.Body)<br />
if err != nil {<br />
    fmt.Println(err)<br />
    return<br />
}<br />
<br />
fmt.Println(len(string(body))) } If you send a lot of requests to the same HTTP server it's ok to keep the network connection open. However, if your app sends one or two requests to many different HTTP servers in a short period of time it's a good idea to close the network connections right after your app receives the responses. Increasing the open file limit might be a good idea too. The correct solution depends on your application though.<br />
</code></pre></div></div><br />
<br />
<p>JSON Encoder Adds a Newline Character<br />
level: intermediate<br />
You are writing a test for your JSON encoding function when you discover that your tests fail because you are not getting the expected value. What happened? If you are using the JSON Encoder object then you’ll get an extra newline character at the end of your encoded JSON object.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
  “fmt”<br />
  “encoding/json”<br />
  “bytes”<br />
)</p><br />
<br />
<p>func main() {<br />
  data := map[string]int{“key”: 1}</p><br />
<br />
<p>var b bytes.Buffer<br />
  json.NewEncoder(&amp;b).Encode(data)</p><br />
<br />
<p>raw,_ := json.Marshal(data)</p><br />
<br />
<p>if b.String() == string(raw) {<br />
    fmt.Println(“same encoded data”)<br />
  } else {<br />
    fmt.Printf(“‘%s’ != ‘%s’\n”,raw,b.String())<br />
    //prints:<br />
    //’{“key”:1}’ != ‘{“key”:1}\n’<br />
  }<br />
}<br />
The JSON Encoder object is designed for streaming. Streaming with JSON usually means newline delimited JSON objects and this is why the Encode method adds a newline character. This is a documented behavior, but it’s commonly overlooked or forgotten.</p><br />
<br />
<p>JSON Package Escapes Special HTML Characters in Keys and String Values<br />
level: intermediate<br />
This is a documented behavior, but you have to be careful reading all of the JSON package documentation to learn about it. The SetEscapeHTML method description talks about the default encoding behavior for the and, less than and greater than characters.</p><br />
<br />
<p>This is a very unfortunate design decision by the Go team for a number of reasons. First, you can’t disable this behavior for the json.Marshal calls. Second, this is a badly implemented security feature because it assumes that doing HTML encoding is sufficient to protect against XSS vulnerabilities in all web applications. There are a lot of different contexts where the data can be used and each context requires its own encoding method. And finally, it’s bad because it assumes that the primary use case for JSON is a web page, which breaks the configuration libraries and the REST/HTTP APIs by default.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
  “fmt”<br />
  “encoding/json”<br />
  “bytes”<br />
)</p><br />
<br />
<p>func main() {<br />
  data := “x &lt; y”</p><br />
<br />
<p>raw,_ := json.Marshal(data)<br />
  fmt.Println(string(raw))<br />
  //prints: “x \u003c y” &lt;- probably not what you expected</p><br />
<br />
<p>var b1 bytes.Buffer<br />
  json.NewEncoder(&amp;b1).Encode(data)<br />
  fmt.Println(b1.String())<br />
  //prints: “x \u003c y” &lt;- probably not what you expected</p><br />
<br />
<p>var b2 bytes.Buffer<br />
  enc := json.NewEncoder(&amp;b2)<br />
  enc.SetEscapeHTML(false)<br />
  enc.Encode(data)<br />
  fmt.Println(b2.String())<br />
  //prints: “x &lt; y” &lt;- looks better<br />
}<br />
A suggestion to the Go team… Make it an opt-in.</p><br />
<br />
<p>Unmarshalling JSON Numbers into Interface Values<br />
level: intermediate<br />
By default, Go treats numeric values in JSON as float64 numbers when you decode/unmarshal JSON data into an interface. This means the following code will fail with a panic:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
  “encoding/json”<br />
  “fmt”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
  var data = []byte(<code class="language-plaintext highlighter-rouge">{"status": 200}</code>)</p><br />
<br />
<p>var result map[string]interface{}<br />
  if err := json.Unmarshal(data, &amp;result); err != nil {<br />
    fmt.Println(“error:”, err)<br />
    return<br />
  }</p><br />
<br />
<p>var status = result[“status”].(int) //error<br />
  fmt.Println(“status value:”,status)<br />
}<br />
Runtime Panic:</p><br />
<br />
<p>panic: interface conversion: interface is float64, not int</p><br />
<br />
<p>If the JSON value you are trying to decode is an integer you have serveral options.</p><br />
<br />
<p>Option one: use the float value as-is :-)</p><br />
<br />
<p>Option two: convert the float value to the integer type you need.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
  “encoding/json”<br />
  “fmt”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
  var data = []byte(<code class="language-plaintext highlighter-rouge">{"status": 200}</code>)</p><br />
<br />
<p>var result map[string]interface{}<br />
  if err := json.Unmarshal(data, &amp;result); err != nil {<br />
    fmt.Println(“error:”, err)<br />
    return<br />
  }</p><br />
<br />
<p>var status = uint64(result[“status”].(float64)) //ok<br />
  fmt.Println(“status value:”,status)<br />
}<br />
Option three: use a Decoder type to unmarshal JSON and tell it to represent JSON numbers using the Number interface type.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
  “encoding/json”<br />
  “bytes”<br />
  “fmt”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
  var data = []byte(<code class="language-plaintext highlighter-rouge">{"status": 200}</code>)</p><br />
<br />
<p>var result map[string]interface{}<br />
  var decoder = json.NewDecoder(bytes.NewReader(data))<br />
  decoder.UseNumber()</p><br />
<br />
<p>if err := decoder.Decode(&amp;result); err != nil {<br />
    fmt.Println(“error:”, err)<br />
    return<br />
  }</p><br />
<br />
<p>var status,_ = result[“status”].(json.Number).Int64() //ok<br />
  fmt.Println(“status value:”,status)<br />
}<br />
You can use the string representation of your Number value to unmarshal it to a different numeric type:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
  “encoding/json”<br />
  “bytes”<br />
  “fmt”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
  var data = []byte(<code class="language-plaintext highlighter-rouge">{"status": 200}</code>)</p><br />
<br />
<p>var result map[string]interface{}<br />
  var decoder = json.NewDecoder(bytes.NewReader(data))<br />
  decoder.UseNumber()</p><br />
<br />
<p>if err := decoder.Decode(&amp;result); err != nil {<br />
    fmt.Println(“error:”, err)<br />
    return<br />
  }</p><br />
<br />
<p>var status uint64<br />
  if err := json.Unmarshal([]byte(result[“status”].(json.Number).String()), &amp;status); err != nil {<br />
    fmt.Println(“error:”, err)<br />
    return<br />
  }</p><br />
<br />
<p>fmt.Println(“status value:”,status)<br />
}<br />
Option four: use a struct type that maps your numeric value to the numeric type you need.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
  “encoding/json”<br />
  “bytes”<br />
  “fmt”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
  var data = []byte(<code class="language-plaintext highlighter-rouge">{"status": 200}</code>)</p><br />
<br />
<p>var result struct {<br />
    Status uint64 <code class="language-plaintext highlighter-rouge">json:"status"</code><br />
  }</p><br />
<br />
<p>if err := json.NewDecoder(bytes.NewReader(data)).Decode(&amp;result); err != nil {<br />
    fmt.Println(“error:”, err)<br />
    return<br />
  }</p><br />
<br />
<p>fmt.Printf(“result =&gt; %+v”,result)<br />
  //prints: result =&gt; {Status:200}<br />
}<br />
Option five: use a struct that maps your numeric value to the json.RawMessage type if you need to defer the value decoding.</p><br />
<br />
<p>This option is useful if you have to perform conditional JSON field decoding where the field type or structure might change.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
  “encoding/json”<br />
  “bytes”<br />
  “fmt”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
  records := [][]byte{<br />
    []byte(<code class="language-plaintext highlighter-rouge">{"status": 200, "tag":"one"}</code>),<br />
    []byte(<code class="language-plaintext highlighter-rouge">{"status":"ok", "tag":"two"}</code>),<br />
  }</p><br />
<br />
<p>for idx, record := range records {<br />
    var result struct {<br />
      StatusCode uint64<br />
      StatusName string<br />
      Status json.RawMessage <code class="language-plaintext highlighter-rouge">json:"status"</code><br />
      Tag string             <code class="language-plaintext highlighter-rouge">json:"tag"</code><br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if err := json.NewDecoder(bytes.NewReader(record)).Decode(&amp;result); err != nil {<br />
  fmt.Println("error:", err)<br />
  return<br />
}<br />
<br />
var sstatus string<br />
if err := json.Unmarshal(result.Status, &amp;sstatus); err == nil {<br />
  result.StatusName = sstatus<br />
}<br />
<br />
var nstatus uint64<br />
if err := json.Unmarshal(result.Status, &amp;nstatus); err == nil {<br />
  result.StatusCode = nstatus<br />
}<br />
<br />
fmt.Printf("[%v] result =&gt; %+v\n",idx,result)   } } JSON String Values Will Not Be Ok with Hex or Other non-UTF8 Escape Sequences level: intermediate Go expects string values to be UTF8 encoded. This means you can't have arbitrary hex escaped binary data in your JSON strings (and you also have to escape the backslash character). This is really a JSON gotcha Go inherited, but it happens often enough in Go apps that it makes sense to mention it anyways.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
  “fmt”<br />
  “encoding/json”<br />
)</p><br />
<br />
<p>type config struct {<br />
  Data string <code class="language-plaintext highlighter-rouge">json:"data"</code><br />
}</p><br />
<br />
<p>func main() {<br />
  raw := []byte(<code class="language-plaintext highlighter-rouge">{"data":"\xc2"}</code>)<br />
  var decoded config</p><br />
<br />
<p>if err := json.Unmarshal(raw, &amp;decoded); err != nil {<br />
        fmt.Println(err)<br />
    //prints: invalid character ‘x’ in string escape code<br />
    }</p><br />
<br />
<p>}<br />
The Unmarshal/Decode calls will fail if Go sees a hex escape sequence. If you do need to have a backslash in you string make sure to escape it with another backlash. If you want to use hex encoded binary data you can escape the backslash and then do your own hex escaping with the decoded data in your JSON string.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
  “fmt”<br />
  “encoding/json”<br />
)</p><br />
<br />
<p>type config struct {<br />
  Data string <code class="language-plaintext highlighter-rouge">json:"data"</code><br />
}</p><br />
<br />
<p>func main() {<br />
  raw := []byte(<code class="language-plaintext highlighter-rouge">{"data":"\\xc2"}</code>)</p><br />
<br />
<p>var decoded config</p><br />
<br />
<p>json.Unmarshal(raw, &amp;decoded)</p><br />
<br />
<p>fmt.Printf(“%#v”,decoded) //prints: main.config{Data:”\xc2”}<br />
  //todo: do your own hex escape decoding for decoded.Data<br /><br />
}<br />
Another option is to use the byte array/slice data type in your JSON object, but the binary data will have to be base64 encoded.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
  “fmt”<br />
  “encoding/json”<br />
)</p><br />
<br />
<p>type config struct {<br />
  Data []byte <code class="language-plaintext highlighter-rouge">json:"data"</code><br />
}</p><br />
<br />
<p>func main() {<br />
  raw := []byte(<code class="language-plaintext highlighter-rouge">{"data":"wg=="}</code>)<br />
  var decoded config</p><br />
<br />
<p>if err := json.Unmarshal(raw, &amp;decoded); err != nil {<br />
          fmt.Println(err)<br />
      }</p><br />
<br />
<p>fmt.Printf(“%#v”,decoded) //prints: main.config{Data:[]uint8{0xc2}}<br />
}<br />
Something else to watch out for is the Unicode replacement character (U+FFFD). Go will use the replacement character instead of invalid UTF8, so the Unmarshal/Decode call will not fail, but the string value you get might not be what you expected.</p><br />
<br />
<p>Comparing Structs, Arrays, Slices, and Maps<br />
level: intermediate<br />
You can use the equality operator, ==, to compare struct variables if each structure field can be compared with the equality operator.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>type data struct {<br /><br />
    num int<br />
    fp float32<br />
    complex complex64<br />
    str string<br />
    char rune<br />
    yes bool<br />
    events &lt;-chan string<br />
    handler interface{}<br />
    ref *byte<br />
    raw [10]byte<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    v1 := data{}<br />
    v2 := data{}<br />
    fmt.Println(“v1 == v2:”,v1 == v2) //prints: v1 == v2: true<br />
}<br />
If any of the struct fields are not comparable then using the equality operator will result in compile time errors. Note that arrays are comparable only if their data items are comparable.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>type data struct {<br /><br />
    num int                //ok<br />
    checks [10]func() bool //not comparable<br />
    doit func() bool       //not comparable<br />
    m map[string] string   //not comparable<br />
    bytes []byte           //not comparable<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    v1 := data{}<br />
    v2 := data{}<br />
    fmt.Println(“v1 == v2:”,v1 == v2)<br />
}<br />
Go does provide a number of helper functions to compare variables that can’t be compared using the comparison operators.</p><br />
<br />
<p>The most generic solution is to use the DeepEqual() function in the reflect package.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “reflect”<br />
)</p><br />
<br />
<p>type data struct {<br /><br />
    num int                //ok<br />
    checks [10]func() bool //not comparable<br />
    doit func() bool       //not comparable<br />
    m map[string] string   //not comparable<br />
    bytes []byte           //not comparable<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    v1 := data{}<br />
    v2 := data{}<br />
    fmt.Println(“v1 == v2:”,reflect.DeepEqual(v1,v2)) //prints: v1 == v2: true</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m1 := map[string]string{"one": "a","two": "b"}<br />
m2 := map[string]string{"two": "b", "one": "a"}<br />
fmt.Println("m1 == m2:",reflect.DeepEqual(m1, m2)) //prints: m1 == m2: true<br />
<br />
s1 := []int{1, 2, 3}<br />
s2 := []int{1, 2, 3}<br />
fmt.Println("s1 == s2:",reflect.DeepEqual(s1, s2)) //prints: s1 == s2: true } Aside from being slow (which may or may not be a deal breaker for your application), DeepEqual() also has its own gotchas.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “reflect”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    var b1 []byte = nil<br />
    b2 := []byte{}<br />
    fmt.Println(“b1 == b2:”,reflect.DeepEqual(b1, b2)) //prints: b1 == b2: false<br />
}<br />
DeepEqual() doesn’t consider an empty slice to be equal to a “nil” slice. This behavior is different from the behavior you get using the bytes.Equal() function. bytes.Equal() considers “nil” and empty slices to be equal.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “bytes”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    var b1 []byte = nil<br />
    b2 := []byte{}<br />
    fmt.Println(“b1 == b2:”,bytes.Equal(b1, b2)) //prints: b1 == b2: true<br />
}<br />
DeepEqual() isn’t always perfect comparing slices.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “reflect”<br />
    “encoding/json”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    var str string = “one”<br />
    var in interface{} = “one”<br />
    fmt.Println(“str == in:”,str == in,reflect.DeepEqual(str, in)) <br />
    //prints: str == in: true true</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v1 := []string{"one","two"}<br />
v2 := []interface{}{"one","two"}<br />
fmt.Println("v1 == v2:",reflect.DeepEqual(v1, v2)) <br />
//prints: v1 == v2: false (not ok)<br />
<br />
data := map[string]interface{}{<br />
    "code": 200,<br />
    "value": []string{"one","two"},<br />
}<br />
encoded, _ := json.Marshal(data)<br />
var decoded map[string]interface{}<br />
json.Unmarshal(encoded, &amp;decoded)<br />
fmt.Println("data == decoded:",reflect.DeepEqual(data, decoded)) <br />
//prints: data == decoded: false (not ok) } If your byte slices (or strings) contain text data you might be tempted to use ToUpper() or ToLower() from the "bytes" and "strings" packages when you need to compare values in a case insensitive manner (before using ==,bytes.Equal(), or bytes.Compare()). It will work for English text, but it will not work for text in many other languages. strings.EqualFold() and bytes.EqualFold() should be used instead.<br />
</code></pre></div></div><br />
<br />
<p>If your byte slices contain secrets (e.g., cryptographic hashes, tokens, etc.) that need to be validated against user-provided data, don’t use reflect.DeepEqual(), bytes.Equal(), or bytes.Compare() because those functions will make your application vulnerable to timing attacks. To avoid leaking the timing information use the functions from the ‘crypto/subtle’ package (e.g., subtle.ConstantTimeCompare()).</p><br />
<br />
<p>Recovering From a Panic<br />
level: intermediate<br />
The recover() function can be used to catch/intercept a panic. Calling recover() will do the trick only when it’s done in a deferred function.</p><br />
<br />
<p>Incorrect:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    recover() //doesn’t do anything<br />
    panic(“not good”)<br />
    recover() //won’t be executed :)<br />
    fmt.Println(“ok”)<br />
}<br />
Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    defer func() {<br />
        fmt.Println(“recovered:”,recover())<br />
    }()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>panic("not good") } The call to recover() works only if it's called directly in your deferred function.<br />
</code></pre></div></div><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func doRecover() {<br /><br />
    fmt.Println(“recovered =&gt;”,recover()) //prints: recovered =&gt; <nil><br />
}</nil></p><br />
<br />
<p>func main() {<br /><br />
    defer func() {<br />
        doRecover() //panic is not recovered<br />
    }()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>panic("not good") } Updating and Referencing Item Values in Slice, Array, and Map "range" Clauses level: intermediate The data values generated in the "range" clause are copies of the actual collection elements. They are not references to the original items. This means that updating the values will not change the original data. It also means that taking the address of the values will not give you pointers to the original data.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    data := []int{1,2,3}<br />
    for _,v := range data {<br />
        v *= 10 //original item is not changed<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println("data:",data) //prints data: [1 2 3] } If you need to update the original collection record value use the index operator to access the data.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    data := []int{1,2,3}<br />
    for i,_ := range data {<br />
        data[i] *= 10<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println("data:",data) //prints data: [10 20 30] } If your collection holds pointer values then the rules are slightly different. You still need to use the index operator if you want the original record to point to another value, but you can update the data stored at the target location using the second value in the "for range" clause.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    data := []*struct{num int} {{1},{2},{3}}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _,v := range data {<br />
    v.num *= 10<br />
}<br />
<br />
fmt.Println(data[0],data[1],data[2]) //prints &amp;{10} &amp;{20} &amp;{30} } "Hidden" Data in Slices level: intermediate When you reslice a slice, the new slice will reference the array of the original slice. If you forget about this behavior it can lead to unexpected memory usage if your application allocates large temporary slices creating new slices from them to refer to small sections of the original data.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func get() []byte {<br /><br />
    raw := make([]byte,10000)<br />
    fmt.Println(len(raw),cap(raw),&amp;raw[0]) //prints: 10000 10000 <byte_addr_x><br />
    return raw[:3]<br />
}</byte_addr_x></p><br />
<br />
<p>func main() {<br /><br />
    data := get()<br />
    fmt.Println(len(data),cap(data),&amp;data[0]) //prints: 3 10000 <byte_addr_x><br />
}<br />
To avoid this trap make sure to copy the data you need from the temporary slice (instead of reslicing it).</byte_addr_x></p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func get() []byte {<br /><br />
    raw := make([]byte,10000)<br />
    fmt.Println(len(raw),cap(raw),&amp;raw[0]) //prints: 10000 10000 <byte_addr_x><br />
    res := make([]byte,3)<br />
    copy(res,raw[:3])<br />
    return res<br />
}</byte_addr_x></p><br />
<br />
<p>func main() {<br /><br />
    data := get()<br />
    fmt.Println(len(data),cap(data),&amp;data[0]) //prints: 3 3 <byte_addr_y><br />
}<br />
Slice Data "Corruption"<br />
level: intermediate<br />
Let's say you need to rewrite a path (stored in a slice). You reslice the path to reference each directory modifying the first folder name and then you combine the names to create a new path.</byte_addr_y></p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “bytes”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    path := []byte(“AAAA/BBBBBBBBB”)<br />
    sepIndex := bytes.IndexByte(path,’/’)<br />
    dir1 := path[:sepIndex]<br />
    dir2 := path[sepIndex+1:]<br />
    fmt.Println(“dir1 =&gt;”,string(dir1)) //prints: dir1 =&gt; AAAA<br />
    fmt.Println(“dir2 =&gt;”,string(dir2)) //prints: dir2 =&gt; BBBBBBBBB</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dir1 = append(dir1,"suffix"...)<br />
path = bytes.Join([][]byte{dir1,dir2},[]byte{'/'})<br />
<br />
fmt.Println("dir1 =&gt;",string(dir1)) //prints: dir1 =&gt; AAAAsuffix<br />
fmt.Println("dir2 =&gt;",string(dir2)) //prints: dir2 =&gt; uffixBBBB (not ok)<br />
<br />
fmt.Println("new path =&gt;",string(path)) } It didn't work as you expected. Instead of "AAAAsuffix/BBBBBBBBB" you ended up with "AAAAsuffix/uffixBBBB". It happened because both directory slices referenced the same underlying array data from the original path slice. This means that the original path is also modified. Depending on your application this might be a problem too.<br />
</code></pre></div></div><br />
<br />
<p>This problem can fixed by allocating new slices and copying the data you need. Another option is to use the full slice expression.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “bytes”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    path := []byte(“AAAA/BBBBBBBBB”)<br />
    sepIndex := bytes.IndexByte(path,’/’)<br />
    dir1 := path[:sepIndex:sepIndex] //full slice expression<br />
    dir2 := path[sepIndex+1:]<br />
    fmt.Println(“dir1 =&gt;”,string(dir1)) //prints: dir1 =&gt; AAAA<br />
    fmt.Println(“dir2 =&gt;”,string(dir2)) //prints: dir2 =&gt; BBBBBBBBB</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dir1 = append(dir1,"suffix"...)<br />
path = bytes.Join([][]byte{dir1,dir2},[]byte{'/'})<br />
<br />
fmt.Println("dir1 =&gt;",string(dir1)) //prints: dir1 =&gt; AAAAsuffix<br />
fmt.Println("dir2 =&gt;",string(dir2)) //prints: dir2 =&gt; BBBBBBBBB (ok now)<br />
<br />
fmt.Println("new path =&gt;",string(path)) } The extra parameter in the full slice expression controls the capacity for the new slice. Now appending to that slice will trigger a new buffer allocation instead of overwriting the data in the second slice.<br />
</code></pre></div></div><br />
<br />
<p>“Stale” Slices<br />
level: intermediate<br />
Multiple slices can reference the same data. This can happen when you create a new slice from an existing slice, for example. If your application relies on this behavior to function properly then you’ll need to worry about “stale” slices.</p><br />
<br />
<p>At some point adding data to one of the slices will result in a new array allocation when the original array can’t hold any more new data. Now other slices will point to the old array (with old data).</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    s1 := []int{1,2,3}<br />
    fmt.Println(len(s1),cap(s1),s1) //prints 3 3 [1 2 3]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s2 := s1[1:]<br />
fmt.Println(len(s2),cap(s2),s2) //prints 2 2 [2 3]<br />
<br />
for i := range s2 { s2[i] += 20 }<br />
<br />
//still referencing the same array<br />
fmt.Println(s1) //prints [1 22 23]<br />
fmt.Println(s2) //prints [22 23]<br />
<br />
s2 = append(s2,4)<br />
<br />
for i := range s2 { s2[i] += 10 }<br />
<br />
//s1 is now "stale"<br />
fmt.Println(s1) //prints [1 22 23]<br />
fmt.Println(s2) //prints [32 33 14] } Type Declarations and Methods level: intermediate When you create a type declaration by defining a new type from an existing (non-interface) type, you don't inherit the methods defined for that existing type.<br />
</code></pre></div></div><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “sync”</p><br />
<br />
<p>type myMutex sync.Mutex</p><br />
<br />
<p>func main() {<br /><br />
    var mtx myMutex<br />
    mtx.Lock() //error<br />
    mtx.Unlock() //error<br /><br />
}<br />
Compile Errors:</p><br />
<br />
<p>/tmp/sandbox106401185/main.go:9: mtx.Lock undefined (type myMutex has no field or method Lock) /tmp/sandbox106401185/main.go:10: mtx.Unlock undefined (type myMutex has no field or method Unlock)</p><br />
<br />
<p>If you do need the methods from the original type you can define a new struct type embedding the original type as an anonymous field.</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “sync”</p><br />
<br />
<p>type myLocker struct {<br /><br />
    sync.Mutex<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    var lock myLocker<br />
    lock.Lock() //ok<br />
    lock.Unlock() //ok<br />
}<br />
Interface type declarations also retain their method sets.</p><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “sync”</p><br />
<br />
<p>type myLocker sync.Locker</p><br />
<br />
<p>func main() {<br /><br />
    var lock myLocker = new(sync.Mutex)<br />
    lock.Lock() //ok<br />
    lock.Unlock() //ok<br />
}<br />
Breaking Out of “for switch” and “for select” Code Blocks<br />
level: intermediate<br />
A “break” statement without a label only gets you out of the inner switch/select block. If using a “return” statement is not an option then defining a label for the outer loop is the next best thing.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    loop:<br />
        for {<br />
            switch {<br />
            case true:<br />
                fmt.Println(“breaking out…”)<br />
                break loop<br />
            }<br />
        }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println("out!") } A "goto" statement will do the trick too...<br />
</code></pre></div></div><br />
<br />
<p>Iteration Variables and Closures in “for” Statements<br />
level: intermediate<br />
This is the most common gotcha in Go. The iteration variables in for statements are reused in each iteration. This means that each closure (aka function literal) created in your for loop will reference the same variable (and they’ll get that variable’s value at the time those goroutines start executing).</p><br />
<br />
<p>Incorrect:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “time”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    data := []string{“one”,”two”,”three”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _,v := range data {<br />
    go func() {<br />
        fmt.Println(v)<br />
    }()<br />
}<br />
<br />
time.Sleep(3 * time.Second)<br />
//goroutines print: three, three, three } The easiest solution (that doesn't require any changes to the goroutine) is to save the current iteration variable value in a local variable inside the for loop block.<br />
</code></pre></div></div><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “time”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    data := []string{“one”,”two”,”three”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _,v := range data {<br />
    vcopy := v //<br />
    go func() {<br />
        fmt.Println(vcopy)<br />
    }()<br />
}<br />
<br />
time.Sleep(3 * time.Second)<br />
//goroutines print: one, two, three } Another solution is to pass the current iteration variable as a parameter to the anonymous goroutine.<br />
</code></pre></div></div><br />
<br />
<p>Works:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “time”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    data := []string{“one”,”two”,”three”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _,v := range data {<br />
    go func(in string) {<br />
        fmt.Println(in)<br />
    }(v)<br />
}<br />
<br />
time.Sleep(3 * time.Second)<br />
//goroutines print: one, two, three } Here's a slightly more complicated version of the trap.<br />
</code></pre></div></div><br />
<br />
<p>Incorrect:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “time”<br />
)</p><br />
<br />
<p>type field struct {<br /><br />
    name string<br />
}</p><br />
<br />
<p>func (p *field) print() {<br /><br />
    fmt.Println(p.name)<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    data := []field{{“one”},{“two”},{“three”}}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _,v := range data {<br />
    go v.print()<br />
}<br />
<br />
time.Sleep(3 * time.Second)<br />
//goroutines print: three, three, three } Works:<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “time”<br />
)</p><br />
<br />
<p>type field struct {<br /><br />
    name string<br />
}</p><br />
<br />
<p>func (p *field) print() {<br /><br />
    fmt.Println(p.name)<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    data := []field{{“one”},{“two”},{“three”}}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _,v := range data {<br />
    v := v<br />
    go v.print()<br />
}<br />
<br />
time.Sleep(3 * time.Second)<br />
//goroutines print: one, two, three } What do you think you'll see when you run this code (and why)?<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “time”<br />
)</p><br />
<br />
<p>type field struct {<br /><br />
    name string<br />
}</p><br />
<br />
<p>func (p *field) print() {<br /><br />
    fmt.Println(p.name)<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    data := []*field{{“one”},{“two”},{“three”}}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _,v := range data {<br />
    go v.print()<br />
}<br />
<br />
time.Sleep(3 * time.Second) } Deferred Function Call Argument Evaluation level: intermediate Arguments for a deferred function call are evaluated when the defer statement is evaluated (not when the function is actually executing). The same rules apply when you defer a method call. The structure value is also saved along with the explicit method parameters and the closed variables.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    var i int = 1</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defer fmt.Println("result =&gt;",func() int { return i * 2 }())<br />
i++<br />
//prints: result =&gt; 2 (not ok if you expected 4) } If you have pointer parameters it is possible to change the values they point to because only the pointer is saved when the defer statement is evaluated.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
  “fmt”<br />
)</p><br />
<br />
<p>func main() {<br />
  i := 1<br />
  defer func (in *int) { fmt.Println(“result =&gt;”, *in) }(&amp;i)</p><br />
<br />
<p>i = 2<br />
  //prints: result =&gt; 2<br />
}<br />
Deferred Function Call Execution<br />
level: intermediate<br />
The deferred calls are executed at the end of the containing function (and in reverse order) and not at the end of the containing code block. It’s an easy mistake to make for new Go developers confusing the deferred code execution rules with the variable scoping rules. It can become a problem if you have a long running function with a for loop that tries to defer resource cleanup calls in each iteration.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “os”<br />
    “path/filepath”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    if len(os.Args) != 2 {<br />
        os.Exit(-1)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>start, err := os.Stat(os.Args[1])<br />
if err != nil || !start.IsDir(){<br />
    os.Exit(-1)<br />
}<br />
<br />
var targets []string<br />
filepath.Walk(os.Args[1], func(fpath string, fi os.FileInfo, err error) error {<br />
    if err != nil {<br />
        return err<br />
    }<br />
<br />
    if !fi.Mode().IsRegular() {<br />
        return nil<br />
    }<br />
<br />
    targets = append(targets,fpath)<br />
    return nil<br />
})<br />
<br />
for _,target := range targets {<br />
    f, err := os.Open(target)<br />
    if err != nil {<br />
        fmt.Println("bad target:",target,"error:",err) //prints error: too many open files<br />
        break<br />
    }<br />
    defer f.Close() //will not be closed at the end of this code block<br />
    //do something with the file...<br />
} } One way to solve the problem is by wrapping the code block in a function.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “os”<br />
    “path/filepath”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    if len(os.Args) != 2 {<br />
        os.Exit(-1)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>start, err := os.Stat(os.Args[1])<br />
if err != nil || !start.IsDir(){<br />
    os.Exit(-1)<br />
}<br />
<br />
var targets []string<br />
filepath.Walk(os.Args[1], func(fpath string, fi os.FileInfo, err error) error {<br />
    if err != nil {<br />
        return err<br />
    }<br />
<br />
    if !fi.Mode().IsRegular() {<br />
        return nil<br />
    }<br />
<br />
    targets = append(targets,fpath)<br />
    return nil<br />
})<br />
<br />
for _,target := range targets {<br />
    func() {<br />
        f, err := os.Open(target)<br />
        if err != nil {<br />
            fmt.Println("bad target:",target,"error:",err)<br />
            return<br />
        }<br />
        defer f.Close() //ok<br />
        //do something with the file...<br />
    }()<br />
} } Another option is to get rid of the defer statement :-)<br />
</code></pre></div></div><br />
<br />
<p>Failed Type Assertions<br />
level: intermediate<br />
Failed type assertions return the “zero value” for the target type used in the assertion statement. This can lead to unexpected behavior when it’s mixed with variable shadowing.</p><br />
<br />
<p>Incorrect:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    var data interface{} = “great”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if data, ok := data.(int); ok {<br />
    fmt.Println("[is an int] value =&gt;",data)<br />
} else {<br />
    fmt.Println("[not an int] value =&gt;",data) <br />
    //prints: [not an int] value =&gt; 0 (not "great")<br />
} } Works:<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    var data interface{} = “great”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if res, ok := data.(int); ok {<br />
    fmt.Println("[is an int] value =&gt;",res)<br />
} else {<br />
    fmt.Println("[not an int] value =&gt;",data) <br />
    //prints: [not an int] value =&gt; great (as expected)<br />
} } Blocked Goroutines and Resource Leaks level: intermediate Rob Pike talked about a number of fundamental concurrency patterns in his "Go Concurrency Patterns" presentation at Google I/O in 2012. Fetching the first result from a number of targets is one of them.<br />
</code></pre></div></div><br />
<br />
<p>func First(query string, replicas …Search) Result {<br /><br />
    c := make(chan Result)<br />
    searchReplica := func(i int) { c &lt;- replicas<a href="query">i</a> }<br />
    for i := range replicas {<br />
        go searchReplica(i)<br />
    }<br />
    return &lt;-c<br />
}<br />
The function starts a goroutines for each search replica. Each goroutine sends its search result to the result channel. The first value from the result channel is returned.</p><br />
<br />
<p>What about the results from the other goroutines? What about the goroutines themselves?</p><br />
<br />
<p>The result channel in the First() function is unbuffered. This means that only the first goroutine returns. All other goroutines are stuck trying to send their results. This means if you have more than one replica each call will leak resources.</p><br />
<br />
<p>To avoid the leaks you need to make sure all goroutines exit. One potential solution is to use a buffered result channel big enough to hold all results.</p><br />
<br />
<p>func First(query string, replicas …Search) Result {<br /><br />
    c := make(chan Result,len(replicas))<br />
    searchReplica := func(i int) { c &lt;- replicas<a href="query">i</a> }<br />
    for i := range replicas {<br />
        go searchReplica(i)<br />
    }<br />
    return &lt;-c<br />
}<br />
Another potential solution is to use a select statement with a default case and a buffered result channel that can hold one value. The default case ensures that the goroutines don’t get stuck even when the result channel can’t receive messages.</p><br />
<br />
<p>func First(query string, replicas …Search) Result {<br /><br />
    c := make(chan Result,1)<br />
    searchReplica := func(i int) { <br />
        select {<br />
        case c &lt;- replicas<a href="query">i</a>:<br />
        default:<br />
        }<br />
    }<br />
    for i := range replicas {<br />
        go searchReplica(i)<br />
    }<br />
    return &lt;-c<br />
}<br />
You can also use a special cancellation channel to interrupt the workers.</p><br />
<br />
<p>func First(query string, replicas …Search) Result {<br /><br />
    c := make(chan Result)<br />
    done := make(chan struct{})<br />
    defer close(done)<br />
    searchReplica := func(i int) { <br />
        select {<br />
        case c &lt;- replicas<a href="query">i</a>:<br />
        case &lt;- done:<br />
        }<br />
    }<br />
    for i := range replicas {<br />
        go searchReplica(i)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return &lt;-c } Why did the presentation contain these bugs? Rob Pike simply didn't want to comlicate the slides. It makes sense, but it can be a problem for new Go developers who would use the code as is without thinking that it might have problems.<br />
</code></pre></div></div><br />
<br />
<p>Same Address for Different Zero-sized Variables<br />
level: intermediate<br />
If you have two different variables shouldn’t they have different addresses? Well, it’s not the case with Go :-) If you have zero-sized variables they might share the exact same address in memory.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
  “fmt”<br />
)</p><br />
<br />
<p>type data struct {<br />
}</p><br />
<br />
<p>func main() {<br />
  a := &amp;data{}<br />
  b := &amp;data{}</p><br />
<br />
<p>if a == b {<br />
    fmt.Printf(“same address - a=%p b=%p\n”,a,b)<br />
    //prints: same address - a=0x1953e4 b=0x1953e4<br />
  }<br />
}<br />
The First Use of iota Doesn’t Always Start with Zero<br />
level: intermediate<br />
It may seem like the iota identifyer is like an increment operator. You start a new constant declaration and the first time you use iota you get zero, the second time you use it you get one and so on. It’s not always the case though.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
  “fmt”<br />
)</p><br />
<br />
<p>const (<br />
  azero = iota<br />
  aone  = iota<br />
)</p><br />
<br />
<p>const (<br />
  info  = “processing”<br />
  bzero = iota<br />
  bone  = iota<br />
)</p><br />
<br />
<p>func main() {<br />
  fmt.Println(azero,aone) //prints: 0 1<br />
  fmt.Println(bzero,bone) //prints: 1 2<br />
}<br />
The iota is really an index operator for the current line in the constant declaration block, so if the first use of iota is not the first line in the constant declaration block the initial value will not be zero.</p><br />
<br />
<p>Using Pointer Receiver Methods On Value Instances<br />
level: advanced<br />
It’s OK to call a pointer receiver method on a value as long as the value is addressable. In other words, you don’t need to have a value receiver version of the method in some cases.</p><br />
<br />
<p>Not every variable is addressable though. Map elements are not addressable. Variables referenced through interfaces are also not addressable.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>type data struct {<br /><br />
    name string<br />
}</p><br />
<br />
<p>func (p *data) print() {<br /><br />
    fmt.Println(“name:”,p.name)<br />
}</p><br />
<br />
<p>type printer interface {<br /><br />
    print()<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    d1 := data{“one”}<br />
    d1.print() //ok</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var in printer = data{"two"} //error<br />
in.print()<br />
<br />
m := map[string]data {"x":data{"three"}}<br />
m["x"].print() //error } Compile Errors:<br />
</code></pre></div></div><br />
<br />
<p>/tmp/sandbox017696142/main.go:21: cannot use data literal (type data) as type printer in assignment: data does not implement printer (print method has pointer receiver)<br />
/tmp/sandbox017696142/main.go:25: cannot call pointer method on m[“x”] /tmp/sandbox017696142/main.go:25: cannot take the address of m[“x”]</p><br />
<br />
<p>Updating Map Value Fields<br />
level: advanced<br />
If you have a map of struct values you can’t update individual struct fields.</p><br />
<br />
<p>Fails:</p><br />
<br />
<p>package main</p><br />
<br />
<p>type data struct {<br /><br />
    name string<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    m := map[string]data {“x”:{“one”}}<br />
    m[“x”].name = “two” //error<br />
}<br />
Compile Error:</p><br />
<br />
<p>/tmp/sandbox380452744/main.go:9: cannot assign to m[“x”].name</p><br />
<br />
<p>It doesn’t work because map elements are not addressable.</p><br />
<br />
<p>What can be extra confusing for new Go devs is the fact that slice elements are addressable.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>type data struct {<br /><br />
    name string<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    s := []data {{“one”}}<br />
    s[0].name = “two” //ok<br />
    fmt.Println(s)    //prints: [{two}]<br />
}<br />
Note that a while ago it was possible to update map element fields in one of the Go compilers (gccgo), but that behavior was quickly fixed :-) It was also considered as a potential feature for Go 1.3. It wasn’t important enough to support at that point in time, so it’s still on the todo list.</p><br />
<br />
<p>The first work around is to use a temporary variable.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>type data struct {<br /><br />
    name string<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    m := map[string]data {“x”:{“one”}}<br />
    r := m[“x”]<br />
    r.name = “two”<br />
    m[“x”] = r<br />
    fmt.Printf(“%v”,m) //prints: map[x:{two}]<br />
}<br />
Another workaround is to use a map of pointers.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>type data struct {<br /><br />
    name string<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    m := map[string]*data {“x”:{“one”}}<br />
    m[“x”].name = “two” //ok<br />
    fmt.Println(m[“x”]) //prints: &amp;{two}<br />
}<br />
By the way, what happens when you run this code?</p><br />
<br />
<p>package main</p><br />
<br />
<p>type data struct {<br /><br />
    name string<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    m := map[string]*data {“x”:{“one”}}<br />
    m[“z”].name = “what?” //???<br />
}<br />
“nil” Interfaces and “nil” Interfaces Values<br />
level: advanced<br />
This is the second most common gotcha in Go because interfaces are not pointers even though they may look like pointers. Interface variables will be “nil” only when their type and value fields are “nil”.</p><br />
<br />
<p>The interface type and value fields are populated based on the type and value of the variable used to create the corresponding interface variable. This can lead to unexpected behavior when you are trying to check if an interface variable equals to “nil”.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    var data *byte<br />
    var in interface{}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println(data,data == nil) //prints: &lt;nil&gt; true<br />
fmt.Println(in,in == nil)     //prints: &lt;nil&gt; true<br />
<br />
in = data<br />
fmt.Println(in,in == nil)     //prints: &lt;nil&gt; false<br />
//'data' is 'nil', but 'in' is not 'nil' } Watch out for this trap when you have a function that returns interfaces.<br />
</code></pre></div></div><br />
<br />
<p>Incorrect:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    doit := func(arg int) interface{} {<br />
        var result *struct{} = nil</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if(arg &gt; 0) {<br />
        result = &amp;struct{}{}<br />
    }<br />
<br />
    return result<br />
}<br />
<br />
if res := doit(-1); res != nil {<br />
    fmt.Println("good result:",res) //prints: good result: &lt;nil&gt;<br />
    //'res' is not 'nil', but its value is 'nil'<br />
} } Works:<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    doit := func(arg int) interface{} {<br />
        var result *struct{} = nil</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if(arg &gt; 0) {<br />
        result = &amp;struct{}{}<br />
    } else {<br />
        return nil //return an explicit 'nil'<br />
    }<br />
<br />
    return result<br />
}<br />
<br />
if res := doit(-1); res != nil {<br />
    fmt.Println("good result:",res)<br />
} else {<br />
    fmt.Println("bad result (res is nil)") //here as expected<br />
} } Stack and Heap Variables level: advanced You don't always know if your variable is allocated on the stack or heap. In C++ creating variables using the new operator always means that you have a heap variable. In Go the compiler decides where the variable will be allocated even if the new() or make() functions are used. The compiler picks the location to store the variable based on its size and the result of "escape analysis". This also means that it's ok to return references to local variables, which is not ok in other languages like C or C++.<br />
</code></pre></div></div><br />
<br />
<p>If you need to know where your variables are allocated pass the “-m” gc flag to “go build” or “go run” (e.g., go run -gcflags -m app.go).</p><br />
<br />
<p>GOMAXPROCS, Concurrency, and Parallelism<br />
level: advanced<br />
Go 1.4 and below uses only one execution context / OS thread. This means that only one goroutine can execute at any given time. Starting with 1.5 Go sets the number of execution contexts to the number of logical CPU cores returned by runtime.NumCPU(). That number may or may not match the total number of logical CPU cores on your system depending on the CPU affinity settings of your process. You can adjust this number by changing the GOMAXPROCS environment variable or by calling the runtime.GOMAXPROCS() function.</p><br />
<br />
<p>There’s a common misconception that GOMAXPROCS represents the number of CPUs Go will use to run goroutines. The runtime.GOMAXPROCS() function documentation adds more to the confusion. The GOMAXPROCS variable description (https://golang.org/pkg/runtime/) does a better job talking about OS threads.</p><br />
<br />
<p>You can set GOMAXPROCS to more than the number of your CPUs. As of 1.10 there’s no longer a limit for GOMAXPROCS. The max value for GOMAXPROCS used to be 256 and it was later increased to 1024 in 1.9.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “runtime”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    fmt.Println(runtime.GOMAXPROCS(-1)) //prints: X (1 on play.golang.org)<br />
    fmt.Println(runtime.NumCPU())       //prints: X (1 on play.golang.org)<br />
    runtime.GOMAXPROCS(20)<br />
    fmt.Println(runtime.GOMAXPROCS(-1)) //prints: 20<br />
    runtime.GOMAXPROCS(300)<br />
    fmt.Println(runtime.GOMAXPROCS(-1)) //prints: 256<br />
}<br />
Read and Write Operation Reordering<br />
level: advanced<br />
Go may reorder some operations, but it ensures that the overall behavior in the goroutine where it happens doesn’t change. However, it doesn’t guarantee the order of execution across multiple goroutines.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “runtime”<br />
    “time”<br />
)</p><br />
<br />
<p>var _ = runtime.GOMAXPROCS(3)</p><br />
<br />
<p>var a, b int</p><br />
<br />
<p>func u1() {<br /><br />
    a = 1<br />
    b = 2<br />
}</p><br />
<br />
<p>func u2() {<br /><br />
    a = 3<br />
    b = 4<br />
}</p><br />
<br />
<p>func p() {<br /><br />
    println(a)<br />
    println(b)<br />
}</p><br />
<br />
<p>func main() {<br /><br />
    go u1()<br />
    go u2()<br />
    go p()<br />
    time.Sleep(1 * time.Second)<br />
}<br />
If you run this code a few times you might see these a and b variable combinations:</p><br />
<br />
<p>1<br />
2</p><br />
<br />
<p>3<br />
4</p><br />
<br />
<p>0<br />
2</p><br />
<br />
<p>0<br />
0</p><br />
<br />
<p>1<br />
4</p><br />
<br />
<p>The most interesting combination for a and b is “02”. It shows that b was updated before a.</p><br />
<br />
<p>If you need to preserve the order of read and write operations across multiple goroutines you’ll need to use channels or the appropriate constructs from the “sync” package.</p><br />
<br />
<p>Preemptive Scheduling<br />
level: advanced<br />
It’s possible to have a rogue goroutine that prevents other goroutines from running. It can happen if you have a for loop that doesn’t allow the scheduler to run.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    done := false</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go func(){<br />
    done = true<br />
}()<br />
<br />
for !done {<br />
}<br />
fmt.Println("done!") } The for loop doesn't have to be empty. It'll be a problem as long as it contains code that doesn't trigger the scheduler execution.<br />
</code></pre></div></div><br />
<br />
<p>The scheduler will run after GC, “go” statements, blocking channel operations, blocking system calls, and lock operations. It may also run when a non-inlined function is called.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br /><br />
    done := false</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go func(){<br />
    done = true<br />
}()<br />
<br />
for !done {<br />
    fmt.Println("not done!") //not inlined<br />
}<br />
fmt.Println("done!") } To find out if the function you call in the for loop is inlined pass the "-m" gc flag to "go build" or "go run" (e.g., go build -gcflags -m).<br />
</code></pre></div></div><br />
<br />
<p>Another option is to invoke the scheduler explicitly. You can do it with the Gosched() function from the “runtime” package.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br /><br />
    “fmt”<br />
    “runtime”<br />
)</p><br />
<br />
<p>func main() {<br /><br />
    done := false</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go func(){<br />
    done = true<br />
}()<br />
<br />
for !done {<br />
    runtime.Gosched()<br />
}<br />
fmt.Println("done!") } Note that the code above contains a race condition. It was done intentionally to show the sheduling gotcha.<br />
</code></pre></div></div><br />
<br />
<p>Import C and Multiline Import Blocks<br />
level: Cgo<br />
You need to import the “C” package to use Cgo. You can do that with a single line import or you can do it with an import block.</p><br />
<br />
<p>package main</p><br />
<br />
<p>/*<br />
#include <stdlib.h><br />
*/<br />
import (<br />
  "C"<br />
)</stdlib.h></p><br />
<br />
<p>import (<br />
  “unsafe”<br />
)</p><br />
<br />
<p>func main() {<br />
  cs := C.CString(“my go string”)<br />
  C.free(unsafe.Pointer(cs))<br />
}<br />
If you are using the import block format you can’t import other packages in the same block.</p><br />
<br />
<p>package main</p><br />
<br />
<p>/*<br />
#include <stdlib.h><br />
*/<br />
import (<br />
  "C"<br />
  "unsafe"<br />
)</stdlib.h></p><br />
<br />
<p>func main() {<br />
  cs := C.CString(“my go string”)<br />
  C.free(unsafe.Pointer(cs))<br />
}<br />
Compile Error:</p><br />
<br />
<p>./main.go:13:2: could not determine kind of name for C.free</p><br />
<br />
<p>No blank lines Between Import C and Cgo Comments<br />
level: Cgo<br />
One of the first gotchas with Cgo is the location of the cgo comments above the import “C” statement.</p><br />
<br />
<p>package main</p><br />
<br />
<p>/*<br />
#include <stdlib.h><br />
*/</stdlib.h></p><br />
<br />
<p>import “C”</p><br />
<br />
<p>import (<br />
  “unsafe”<br />
)</p><br />
<br />
<p>func main() {<br />
  cs := C.CString(“my go string”)<br />
  C.free(unsafe.Pointer(cs))<br />
}<br />
Compile Error:</p><br />
<br />
<p>./main.go:15:2: could not determine kind of name for C.free</p><br />
<br />
<p>Make sure you don’t have any blank lines above import “C” statement.</p><br />
<br />
<p>Can’t Call C Functions with Variable Arguments<br />
level: Cgo<br />
You can’t call C functions with variable arguments directly.</p><br />
<br />
<p>package main</p><br />
<br />
<p>/*<br />
#include <stdio.h><br />
#include <stdlib.h><br />
*/<br />
import "C"</stdlib.h></stdio.h></p><br />
<br />
<p>import (<br />
  “unsafe”<br />
)</p><br />
<br />
<p>func main() {<br />
  cstr := C.CString(“go”)<br />
  C.printf(“%s\n”,cstr) //not ok<br />
  C.free(unsafe.Pointer(cstr))<br />
}<br />
Compile Error:</p><br />
<br />
<p>./main.go:15:2: unexpected type: …</p><br />
<br />
<p>You have to wrap your variadic C functions in functions with a known number of parameters.</p><br />
<br />
<p>package main</p><br />
<br />
<p>/*<br />
#include <stdio.h><br />
#include <stdlib.h></stdlib.h></stdio.h></p><br />
<br />
<p>void out(char* in) {<br />
  printf(“%s\n”, in);<br />
}<br />
*/<br />
import “C”</p><br />
<br />
<p>import (<br />
  “unsafe”<br />
)</p><br />
<br />
<p>func main() {<br />
  cstr := C.CString(“go”)<br />
  C.out(cstr) //ok<br />
  C.free(unsafe.Pointer(cstr))<br />
}</p><br />
<br />
<p>Comments and Discussions<br />
Old Reddit discussion.</p><br />
<br />
<p>Latest Hacker News discussion.</p><br />
<br />
<p>Thank you for your feedback and suggestions!</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>