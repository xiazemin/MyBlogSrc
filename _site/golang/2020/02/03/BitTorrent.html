<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>Ê≥ΩÊ∞ëÂçöÂÆ¢ | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--ÁôæÂ∫¶ÁªüËÆ°-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--ËΩÆÊí≠ÂõæÁâá-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--Ê∞¥Âç∞-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'Ê≥ΩÊ∞ëÂçöÂÆ¢',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--Ê∞¥Âç∞-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">Ê≥ΩÊ∞ëÂçöÂÆ¢</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">BitTorrent</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by Â§èÊ≥ΩÊ∞ë</span></span> <time datetime="2020-02-03T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Feb 3, 2020</time></p>
					</div>
					 <p>https://blog.jse.li/posts/torrent/<br />
https://github.com/veggiedefender/torrent-client<br />
<!-- more --><br />
Building a BitTorrent client from the ground up in Go<br />
Jan 4, 2020<br />
tl;dr: What is the complete path between visiting thepiratebay and sublimating an mp3 file from thin air? In this post, we‚Äôll implement enough of the BitTorrent protocol to download Debian. Look at the Source code or skip to the last bit.<br />
BitTorrent is a protocol for downloading and distributing files across the Internet. In contrast with the traditional client/server relationship, in which downloaders connect to a central server (for example: watching a movie on Netflix, or loading the web page you‚Äôre reading now), participants in the BitTorrent network, called peers, download pieces of files from each other‚Äîthis is what makes it a peer-to-peer protocol. We‚Äôll investigate how this works, and build our own client that can find peers and exchange data between them.</p><br />
<br />
<p>diagram showing the difference between client/server (all clients connecting to one server) and peer-to-peer (peers connecting to each other) relationships</p><br />
<br />
<p>The protocol evolved organically over the past 20 years, and various people and organizations added extensions for features like encryption, private torrents, and new ways of finding peers. We‚Äôll be implementing the original spec from 2001 to keep this a weekend-sized project.</p><br />
<br />
<p>I‚Äôll be using a Debian ISO file as my guinea pig because it‚Äôs big, but not huge, at 350MB. As a popular Linux distribution, there will be lots of fast and cooperative peers for us to connect to. And we‚Äôll avoid the legal and ethical issues related to downloading pirated content.</p><br />
<br />
<p>Finding peers<br />
Here‚Äôs a problem: we want to download a file with BitTorrent, but it‚Äôs a peer-to-peer protocol and we have no idea where to find peers to download it from. This is a lot like moving to a new city and trying to make friends‚Äîmaybe we‚Äôll hit up a local pub or a meetup group! Centralized locations like these are the big idea behind trackers, which are central servers that introduce peers to each other. They‚Äôre just web servers running over HTTP* , and you can find Debian‚Äôs at http://bttracker.debian.org:6969/</p><br />
<br />
<p>illustration of a desktop computer and laptop sitting at a pub</p><br />
<br />
<p>Of course, these central servers are liable to get raided by the feds if they facilitate peers exchanging illegal content. You may remember reading about trackers like TorrentSpy, Popcorn Time, and KickassTorrents getting seized and shut down. New methods cut out the middleman by making even peer discovery a distributed process. We won‚Äôt be implementing them, but if you‚Äôre interested, some terms you can research are DHT, PEX, and magnet links.</p><br />
<br />
<p>Parsing a .torrent file<br />
A .torrent file describes the contents of a torrentable file and information for connecting to a tracker. It‚Äôs all we need in order to kickstart the process of downloading a torrent. Debian‚Äôs .torrent file looks like this:</p><br />
<br />
<p>d8:announce41:http://bttracker.debian.org:6969/announce7:comment35:‚ÄùDebian CD from cdimage.debian.org‚Äù13:creation datei1573903810e9:httpseedsl145:https://cdimage.debian.org/cdimage/release/10.2.0//srv/cdbuilder.debian.org/dst/deb-cd/weekly-builds/amd64/iso-cd/debian-10.2.0-amd64-netinst.iso145:https://cdimage.debian.org/cdimage/archive/10.2.0//srv/cdbuilder.debian.org/dst/deb-cd/weekly-builds/amd64/iso-cd/debian-10.2.0-amd64-netinst.isoe4:infod6:lengthi351272960e4:name31:debian-10.2.0-amd64-netinst.iso12:piece lengthi262144e6:pieces26800:ÔøΩÔøΩÔøΩÔøΩÔøΩPSÔøΩ^ÔøΩÔøΩ (binary blob of the hashes of each piece)ee<br />
That mess is encoded in a format called Bencode (pronounced bee-encode), and we‚Äôll need to decode it.</p><br />
<br />
<p>Bencode can encode roughly the same types of structures as JSON‚Äîstrings, integers, lists, and dictionaries. Bencoded data is not as human-readable/writable as JSON, but it can efficiently handle binary data and it‚Äôs really simple to parse from a stream. Strings come with a length prefix, and look like 4:spam. Integers go between start and end markers, so 7 would encode to i7e. Lists and dictionaries work in a similar way: l4:spami7ee represents [‚Äòspam‚Äô, 7], while d4:spami7ee means {spam: 7}.</p><br />
<br />
<p>In a prettier format, our .torrent file looks like this:</p><br />
<br />
<p>d<br />
  8:announce<br />
    41:http://bttracker.debian.org:6969/announce<br />
  7:comment<br />
    35:‚ÄùDebian CD from cdimage.debian.org‚Äù<br />
  13:creation date<br />
    i1573903810e<br />
  4:info<br />
    d<br />
      6:length<br />
        i351272960e<br />
      4:name<br />
        31:debian-10.2.0-amd64-netinst.iso<br />
      12:piece length<br />
        i262144e<br />
      6:pieces<br />
        26800:ÔøΩÔøΩÔøΩÔøΩÔøΩPSÔøΩ^ÔøΩÔøΩ (binary blob of the hashes of each piece)<br />
    e<br />
e<br />
In this file, we can spot the URL of the tracker, the creation date (as a Unix timestamp), the name and size of the file, and a big binary blob containing the SHA-1 hashes of each piece, which are equally-sized parts of the file we want to download. The exact size of a piece varies between torrents, but they are usually somewhere between 256KB and 1MB. This means that a large file might be made up of thousands of pieces. We‚Äôll download these pieces from our peers, check them against the hashes from our torrent file, assemble them together, and boom, we‚Äôve got a file!</p><br />
<br />
<p>illustration of a file being cut with scissors into multiple pieces, starting with piece 0</p><br />
<br />
<p>This mechanism allows us to verify the integrity of each piece as we go. It makes BitTorrent resistant to accidental corruption or intentional torrent poisoning. Unless an attacker is capable of breaking SHA-1 with a preimage attack, we will get exactly the content we asked for.</p><br />
<br />
<p>It would be really fun to write a bencode parser, but parsing isn‚Äôt our focus today. But I found Fredrik Lundh‚Äôs 50 line parser to be especially illuminating. For this project, I used github.com/jackpal/bencode-go:</p><br />
<br />
<p>import (<br />
    ‚Äúgithub.com/jackpal/bencode-go‚Äù<br />
)</p><br />
<br />
<p>type bencodeInfo struct {<br />
    Pieces      string <code class="language-plaintext highlighter-rouge">bencode:"pieces"</code><br />
    PieceLength int    <code class="language-plaintext highlighter-rouge">bencode:"piece length"</code><br />
    Length      int    <code class="language-plaintext highlighter-rouge">bencode:"length"</code><br />
    Name        string <code class="language-plaintext highlighter-rouge">bencode:"name"</code><br />
}</p><br />
<br />
<p>type bencodeTorrent struct {<br />
    Announce string      <code class="language-plaintext highlighter-rouge">bencode:"announce"</code><br />
    Info     bencodeInfo <code class="language-plaintext highlighter-rouge">bencode:"info"</code><br />
}</p><br />
<br />
<p>// Open parses a torrent file<br />
func Open(r io.Reader) (*bencodeTorrent, error) {<br />
    bto := bencodeTorrent{}<br />
    err := bencode.Unmarshal(r, &amp;bto)<br />
    if err != nil {<br />
        return nil, err<br />
    }<br />
    return &amp;bto, nil<br />
}<br />
Because I like to keep my structures relatively flat, and I like to keep my application structs separate from my serialization structs, I exported a different, flatter struct named TorrentFile and wrote a few helper functions to convert between the two.</p><br />
<br />
<p>Notably, I split pieces (previously a string) into a slice of hashes (each [20]byte) so that I can easily access individual hashes later. I also computed the SHA-1 hash of the entire bencoded info dict (the one which contained the name, size, and piece hashes). We know this as the infohash and it uniquely identifies files when we talk to trackers and peers. More on this later.</p><br />
<br />
<p>a name tag saying ‚ÄòHello my name is 86d4c80024a469be4c50bc5a102cf71780310074‚Äô</p><br />
<br />
<p>type TorrentFile struct {<br />
    Announce    string<br />
    InfoHash    [20]byte<br />
    PieceHashes [][20]byte<br />
    PieceLength int<br />
    Length      int<br />
    Name        string<br />
}</p><br />
<br />
<p>func (bto <em>bencodeTorrent) toTorrentFile() (</em>TorrentFile, error) {<br />
    // ‚Ä¶<br />
}<br />
Retrieving peers from the tracker<br />
Now that we have information about the file and its tracker, let‚Äôs talk to the tracker to announce our presence as a peer and to retrieve a list of other peers. We just need to make a GET request to the announce URL supplied in the .torrent file, with a few query parameters:</p><br />
<br />
<p>func (t *TorrentFile) buildTrackerURL(peerID [20]byte, port uint16) (string, error) {<br />
    base, err := url.Parse(t.Announce)<br />
    if err != nil {<br />
        return ‚Äú‚Äù, err<br />
    }<br />
    params := url.Values{<br />
        ‚Äúinfo_hash‚Äù:  []string{string(t.InfoHash[:])},<br />
        ‚Äúpeer_id‚Äù:    []string{string(peerID[:])},<br />
        ‚Äúport‚Äù:       []string{strconv.Itoa(int(Port))},<br />
        ‚Äúuploaded‚Äù:   []string{‚Äú0‚Äù},<br />
        ‚Äúdownloaded‚Äù: []string{‚Äú0‚Äù},<br />
        ‚Äúcompact‚Äù:    []string{‚Äú1‚Äù},<br />
        ‚Äúleft‚Äù:       []string{strconv.Itoa(t.Length)},<br />
    }<br />
    base.RawQuery = params.Encode()<br />
    return base.String(), nil<br />
}<br />
The important ones:</p><br />
<br />
<p>info_hash: Identifies the file we‚Äôre trying to download. It‚Äôs the infohash we calculated earlier from the bencoded info dict. The tracker will use this to figure out which peers to show us.<br />
peer_id: A 20 byte name to identify ourselves to trackers and peers. We‚Äôll just generate 20 random bytes for this. Real BitTorrent clients have IDs like -TR2940-k8hj0wgej6ch which identify the client software and version‚Äîin this case, TR2940 stands for Transmission client 2.94.<br />
a file with a name tag saying ‚Äòinfo_hash‚Äô and a person with a name tag ‚Äòpeer_id‚Äô</p><br />
<br />
<p>Parsing the tracker response<br />
We get back a bencoded response:</p><br />
<br />
<p>d<br />
  8:interval<br />
    i900e<br />
  5:peers<br />
    252:(another long binary blob)<br />
e<br />
Interval tells us how often we‚Äôre supposed to connect to the tracker again to refresh our list of peers. A value of 900 means we should reconnect every 15 minutes (900 seconds).</p><br />
<br />
<p>Peers is another long binary blob containing the IP addresses of each peer. It‚Äôs made out of groups of six bytes. The first four bytes in each group represent the peer‚Äôs IP address‚Äîeach byte represents a number in the IP. The last two bytes represent the port, as a big-endian uint16. Big-endian, or network order, means that we can interpret a group of bytes as an integer by just squishing them together left to right. For example, the bytes 0x1A, 0xE1 make 0x1AE1, or 6881 in decimal.*</p><br />
<br />
<p>diagram showing how 192, 0, 2, 123, 0x1A, 0xE1 can be interpreted as 192.0.1.123:6881</p><br />
<br />
<p>// Peer encodes connection information for a peer<br />
type Peer struct {<br />
    IP   net.IP<br />
    Port uint16<br />
}</p><br />
<br />
<p>// Unmarshal parses peer IP addresses and ports from a buffer<br />
func Unmarshal(peersBin []byte) ([]Peer, error) {<br />
    const peerSize = 6 // 4 for IP, 2 for port<br />
    numPeers := len(peersBin) / peerSize<br />
    if len(peersBin)%peerSize != 0 {<br />
        err := fmt.Errorf(‚ÄúReceived malformed peers‚Äù)<br />
        return nil, err<br />
    }<br />
    peers := make([]Peer, numPeers)<br />
    for i := 0; i &lt; numPeers; i++ {<br />
        offset := i * peerSize<br />
        peers[i].IP = net.IP(peersBin[offset : offset+4])<br />
        peers[i].Port = binary.BigEndian.Uint16(peersBin[offset+4 : offset+6])<br />
    }<br />
    return peers, nil<br />
}<br />
Downloading from peers<br />
Now that we have a list of peers, it‚Äôs time to connect with them and start downloading pieces! We can break down the process into a few steps. For each peer, we want to:</p><br />
<br />
<p>Start a TCP connection with the peer. This is like starting a phone call.<br />
Complete a two-way BitTorrent handshake. ‚ÄúHello?‚Äù ‚ÄúHello.‚Äù<br />
Exchange messages to download pieces. ‚ÄúI‚Äôd like piece #231 please.‚Äù<br />
Start a TCP connection<br />
conn, err := net.DialTimeout(‚Äútcp‚Äù, peer.String(), 3*time.Second)<br />
if err != nil {<br />
    return nil, err<br />
}<br />
I set a timeout so that I don‚Äôt waste too much time on peers that aren‚Äôt going to let me connect. For the most part, it‚Äôs a pretty standard TCP connection.</p><br />
<br />
<p>Complete the handshake<br />
We‚Äôve just set up a connection with a peer, but we want do a handshake to validate our assumptions that the peer</p><br />
<br />
<p>can communicate using the BitTorrent protocol<br />
is able to understand and respond to our messages<br />
has the file that we want, or at least knows what we‚Äôre talking about<br />
Two computers communicating. One asks ‚Äòdo you speak BitTorrent and have this file?‚Äô and the other replies ‚ÄòI speak BitTorrent and have that file‚Äô</p><br />
<br />
<p>My father told me that the secret to a good handshake is a firm grip and eye contact. The secret to a good BitTorrent handshake is that it‚Äôs made up of five parts:</p><br />
<br />
<p>The length of the protocol identifier, which is always 19 (0x13 in hex)<br />
The protocol identifier, called the pstr which is always BitTorrent protocol<br />
Eight reserved bytes, all set to 0. We‚Äôd flip some of them to 1 to indicate that we support certain extensions. But we don‚Äôt, so we‚Äôll keep them at 0.<br />
The infohash that we calculated earlier to identify which file we want<br />
The Peer ID that we made up to identify ourselves<br />
Put together, a handshake string might look like this:</p><br />
<br />
<p>\x13BitTorrent protocol\x00\x00\x00\x00\x00\x00\x00\x00\x86\xd4\xc8\x00\x24\xa4\x69\xbe\x4c\x50\xbc\x5a\x10\x2c\xf7\x17\x80\x31\x00\x74-TR2940-k8hj0wgej6ch<br />
After we send a handshake to our peer, we should receive a handshake back in the same format. The infohash we get back should match the one we sent so that we know that we‚Äôre talking about the same file. If everything goes as planned, we‚Äôre good to go. If not, we can sever the connection because there‚Äôs something wrong. ‚ÄúHello?‚Äù ‚ÄúËøôÊòØË∞ÅÔºü ‰Ω†ÊÉ≥Ë¶Å‰ªÄ‰πàÔºü‚Äù ‚ÄúOkay, wow, wrong number.‚Äù</p><br />
<br />
<p>In our code, let‚Äôs make a struct to represent a handshake, and write a few methods for serializing and reading them:</p><br />
<br />
<p>// A Handshake is a special message that a peer uses to identify itself<br />
type Handshake struct {<br />
    Pstr     string<br />
    InfoHash [20]byte<br />
    PeerID   [20]byte<br />
}</p><br />
<br />
<p>// Serialize serializes the handshake to a buffer<br />
func (h *Handshake) Serialize() []byte {<br />
    buf := make([]byte, len(h.Pstr)+49)<br />
    buf[0] = byte(len(h.Pstr))<br />
    curr := 1<br />
    curr += copy(buf[curr:], h.Pstr)<br />
    curr += copy(buf[curr:], make([]byte, 8)) // 8 reserved bytes<br />
    curr += copy(buf[curr:], h.InfoHash[:])<br />
    curr += copy(buf[curr:], h.PeerID[:])<br />
    return buf<br />
}</p><br />
<br />
<p>// Read parses a handshake from a stream<br />
func Read(r io.Reader) (*Handshake, error) {<br />
    // Do Serialize(), but backwards<br />
    // ‚Ä¶<br />
}<br />
Send and receive messages<br />
Once we‚Äôve completed the initial handshake, we can send and receive messages. Well, not quite‚Äîif the other peer isn‚Äôt ready to accept messages, we can‚Äôt send any until they tell us they‚Äôre ready. In this state, we‚Äôre considered choked by the other peer. They‚Äôll send us an unchoke message to let us know that we can begin asking them for data. By default, we assume that we‚Äôre choked until proven otherwise.</p><br />
<br />
<p>Once we‚Äôve been unchoked, we can then begin sending requests for pieces, and they can send us messages back containing pieces.</p><br />
<br />
<p>A cartoon in which person 1 says ‚Äòhello I would like piece number‚Äî‚Äô and person 2 grabs him by the neck and says ‚Äò00 00 00 01 00 (choke)‚Äô</p><br />
<br />
<p>Interpreting messages<br />
A message has a length, an ID and a payload. On the wire, it looks like:</p><br />
<br />
<p>A message with 4 byte for the length, 1 byte for ID, and an optional payload</p><br />
<br />
<p>A message starts with a length indicator which tells us how many bytes long the message will be. It‚Äôs a 32-bit integer, meaning it‚Äôs made out of four bytes smooshed together in big-endian order. The next byte, the ID, tells us which type of message we‚Äôre receiving‚Äîfor example, a 2 byte means ‚Äúinterested.‚Äù Finally, the optional payload fills out the remaining length of the message.</p><br />
<br />
<p>type messageID uint8</p><br />
<br />
<p>const (<br />
    MsgChoke         messageID = 0<br />
    MsgUnchoke       messageID = 1<br />
    MsgInterested    messageID = 2<br />
    MsgNotInterested messageID = 3<br />
    MsgHave          messageID = 4<br />
    MsgBitfield      messageID = 5<br />
    MsgRequest       messageID = 6<br />
    MsgPiece         messageID = 7<br />
    MsgCancel        messageID = 8<br />
)</p><br />
<br />
<p>// Message stores ID and payload of a message<br />
type Message struct {<br />
    ID      messageID<br />
    Payload []byte<br />
}</p><br />
<br />
<p>// Serialize serializes a message into a buffer of the form<br />
// <length prefix=""><message ID=""><payload><br />
// Interprets `nil` as a keep-alive message<br />
func (m *Message) Serialize() []byte {<br />
    if m == nil {<br />
        return make([]byte, 4)<br />
    }<br />
    length := uint32(len(m.Payload) + 1) // +1 for id<br />
    buf := make([]byte, 4+length)<br />
    binary.BigEndian.PutUint32(buf[0:4], length)<br />
    buf[4] = byte(m.ID)<br />
    copy(buf[5:], m.Payload)<br />
    return buf<br />
}<br />
To read a message from a stream, we just follow the format of a message. We read four bytes and interpret them as a uint32 to get the length of the message. Then, we read that number of bytes to get the ID (the first byte) and the payload (the remaining bytes).</payload></message></length></p><br />
<br />
<p>// Read parses a message from a stream. Returns <code class="language-plaintext highlighter-rouge">nil</code> on keep-alive message<br />
func Read(r io.Reader) (*Message, error) {<br />
    lengthBuf := make([]byte, 4)<br />
    _, err := io.ReadFull(r, lengthBuf)<br />
    if err != nil {<br />
        return nil, err<br />
    }<br />
    length := binary.BigEndian.Uint32(lengthBuf)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// keep-alive message<br />
if length == 0 {<br />
    return nil, nil<br />
}<br />
<br />
messageBuf := make([]byte, length)<br />
_, err = io.ReadFull(r, messageBuf)<br />
if err != nil {<br />
    return nil, err<br />
}<br />
<br />
m := Message{<br />
    ID:      messageID(messageBuf[0]),<br />
    Payload: messageBuf[1:],<br />
}<br />
<br />
return &amp;m, nil } Bitfields One of the most interesting types of message is the bitfield, which is a data structure that peers use to efficiently encode which pieces they are able to send us. A bitfield looks like a byte array, and to check which pieces they have, we just need to look at the positions of the bits set to 1. You can think of it like the digital equivalent of a coffee shop loyalty card. We start with a blank card of all 0, and flip bits to 1 to mark their positions as ‚Äústamped.‚Äù<br />
</code></pre></div></div><br />
<br />
<p>a coffee shop loyalty card with eight slots, with stamps on the first four slots and a stamp on the second to last slot, represented as 11110010</p><br />
<br />
<p>By working with bits instead of bytes, this data structure is super compact. We can stuff information about eight pieces in the space of a single byte‚Äîthe size of a bool. The tradeoff is that accessing values becomes a little more tricky. The smallest unit of memory that computers can address are bytes, so to get to our bits, we have to do some bitwise manipulation:</p><br />
<br />
<p>// A Bitfield represents the pieces that a peer has<br />
type Bitfield []byte</p><br />
<br />
<p>// HasPiece tells if a bitfield has a particular index set<br />
func (bf Bitfield) HasPiece(index int) bool {<br />
    byteIndex := index / 8<br />
    offset := index % 8<br />
    return bf[byteIndex]¬ª(7-offset)&amp;1 != 0<br />
}</p><br />
<br />
<p>// SetPiece sets a bit in the bitfield<br />
func (bf Bitfield) SetPiece(index int) {<br />
    byteIndex := index / 8<br />
    offset := index % 8<br />
    bf[byteIndex] |= 1 ¬´¬†(7 - offset)<br />
}<br />
Putting it all together<br />
We now have all the tools we need to download a torrent: we have a list of peers obtained from the tracker, and we can communicate with them by dialing a TCP connection, initiating a handshake, and sending and receiving messages. Our last big problems are handling the concurrency involved in talking to multiple peers at once, and managing the state of our peers as we interact with them. These are both classically Hard problems.</p><br />
<br />
<p>Managing concurrency: channels as queues<br />
In Go, we share memory by communicating, and we can think of a Go channel as a cheap thread-safe queue.</p><br />
<br />
<p>We‚Äôll set up two channels to synchronize our concurrent workers: one for dishing out work (pieces to download) between peers, and another for collecting downloaded pieces. As downloaded pieces come in through the results channel, we can copy them into a buffer to start assembling our complete file.</p><br />
<br />
<p>// Init queues for workers to retrieve work and send results<br />
workQueue := make(chan *pieceWork, len(t.PieceHashes))<br />
results := make(chan *pieceResult)<br />
for index, hash := range t.PieceHashes {<br />
    length := t.calculatePieceSize(index)<br />
    workQueue &lt;- &amp;pieceWork{index, hash, length}<br />
}</p><br />
<br />
<p>// Start workers<br />
for _, peer := range t.Peers {<br />
    go t.startDownloadWorker(peer, workQueue, results)<br />
}</p><br />
<br />
<p>// Collect results into a buffer until full<br />
buf := make([]byte, t.Length)<br />
donePieces := 0<br />
for donePieces &lt; len(t.PieceHashes) {<br />
    res := &lt;-results<br />
    begin, end := t.calculateBoundsForPiece(res.index)<br />
    copy(buf[begin:end], res.buf)<br />
    donePieces++<br />
}<br />
close(workQueue)<br />
We‚Äôll spawn a worker goroutine for each peer we‚Äôve received from the tracker. It‚Äôll connect and handshake with the peer, and then start retrieving work from the workQueue, attempting to download it, and sending downloaded pieces back through the results channel.</p><br />
<br />
<p>a flow chart of the download strategy</p><br />
<br />
<p>func (t *Torrent) startDownloadWorker(peer peers.Peer, workQueue chan *pieceWork, results chan *pieceResult) {<br />
    c, err := client.New(peer, t.PeerID, t.InfoHash)<br />
    if err != nil {<br />
        log.Printf(‚ÄúCould not handshake with %s. Disconnecting\n‚Äù, peer.IP)<br />
        return<br />
    }<br />
    defer c.Conn.Close()<br />
    log.Printf(‚ÄúCompleted handshake with %s\n‚Äù, peer.IP)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c.SendUnchoke()<br />
c.SendInterested()<br />
<br />
for pw := range workQueue {<br />
    if !c.Bitfield.HasPiece(pw.index) {<br />
        workQueue &lt;- pw // Put piece back on the queue<br />
        continue<br />
    }<br />
<br />
    // Download the piece<br />
    buf, err := attemptDownloadPiece(c, pw)<br />
    if err != nil {<br />
        log.Println("Exiting", err)<br />
        workQueue &lt;- pw // Put piece back on the queue<br />
        return<br />
    }<br />
<br />
    err = checkIntegrity(pw, buf)<br />
    if err != nil {<br />
        log.Printf("Piece #%d failed integrity check\n", pw.index)<br />
        workQueue &lt;- pw // Put piece back on the queue<br />
        continue<br />
    }<br />
<br />
    c.SendHave(pw.index)<br />
    results &lt;- &amp;pieceResult{pw.index, buf}<br />
} } Managing state We‚Äôll keep track of each peer in a struct, and modify that struct as we read messages. It‚Äôll include data like how much we‚Äôve downloaded from the peer, how much we‚Äôve requested from them, and whether we‚Äôre choked. If we wanted to scale this further, we could formalize this as a finite state machine. But a struct and a switch are good enough for now.<br />
</code></pre></div></div><br />
<br />
<p>type pieceProgress struct {<br />
    index      int<br />
    client     *client.Client<br />
    buf        []byte<br />
    downloaded int<br />
    requested  int<br />
    backlog    int<br />
}</p><br />
<br />
<p>func (state *pieceProgress) readMessage() error {<br />
    msg, err := state.client.Read() // this call blocks<br />
    switch msg.ID {<br />
    case message.MsgUnchoke:<br />
        state.client.Choked = false<br />
    case message.MsgChoke:<br />
        state.client.Choked = true<br />
    case message.MsgHave:<br />
        index, err := message.ParseHave(msg)<br />
        state.client.Bitfield.SetPiece(index)<br />
    case message.MsgPiece:<br />
        n, err := message.ParsePiece(state.index, state.buf, msg)<br />
        state.downloaded += n<br />
        state.backlog‚Äì<br />
    }<br />
    return nil<br />
}<br />
Time to make requests!<br />
Files, pieces, and piece hashes aren‚Äôt the full story‚Äîwe can go further by breaking down pieces into blocks. A block is a part of a piece, and we can fully define a block by the index of the piece it‚Äôs part of, its byte offset within the piece, and its length. When we make requests for data from peers, we are actually requesting blocks. A block is usually 16KB large, meaning that a single 256 KB piece might actually require 16 requests.</p><br />
<br />
<p>A peer is supposed to sever the connection if they receive a request for a block larger than 16KB. However, based on my experience, they‚Äôre often perfectly happy to satisfy requests up to 128KB. I only got moderate gains in overall speed with larger block sizes, so it‚Äôs probably better to stick with the spec.</p><br />
<br />
<p>Pipelining<br />
Network round-trips are expensive, and requesting each block one by one will absolutely tank the performance of our download. Therefore, it‚Äôs important to pipeline our requests such that we keep up a constant pressure of some number of unfulfilled requests. This can increase the throughput of our connection by an order of magnitude.</p><br />
<br />
<p>Two email threads simulating peer connections. The thread on the left shows a request followed by a reply, repeated three times. The thread on the left sends three requests, and receives three replies in quick succession.</p><br />
<br />
<p>Classically, BitTorrent clients kept a queue of five pipelined requests, and that‚Äôs the value I‚Äôll be using. I found that increasing it can up to double the speed of a download. Newer clients use an adaptive queue size to better accommodate modern network speeds and conditions. This is definitely a parameter worth tweaking, and it‚Äôs pretty low hanging fruit for future performance optimization.</p><br />
<br />
<p>// MaxBlockSize is the largest number of bytes a request can ask for<br />
const MaxBlockSize = 16384</p><br />
<br />
<p>// MaxBacklog is the number of unfulfilled requests a client can have in its pipeline<br />
const MaxBacklog = 5</p><br />
<br />
<p>func attemptDownloadPiece(c *client.Client, pw *pieceWork) ([]byte, error) {<br />
    state := pieceProgress{<br />
        index:  pw.index,<br />
        client: c,<br />
        buf:    make([]byte, pw.length),<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Setting a deadline helps get unresponsive peers unstuck.<br />
// 30 seconds is more than enough time to download a 262 KB piece<br />
c.Conn.SetDeadline(time.Now().Add(30 * time.Second))<br />
defer c.Conn.SetDeadline(time.Time{}) // Disable the deadline<br />
<br />
for state.downloaded &lt; pw.length {<br />
    // If unchoked, send requests until we have enough unfulfilled requests<br />
    if !state.client.Choked {<br />
        for state.backlog &lt; MaxBacklog &amp;&amp; state.requested &lt; pw.length {<br />
            blockSize := MaxBlockSize<br />
            // Last block might be shorter than the typical block<br />
            if pw.length-state.requested &lt; blockSize {<br />
                blockSize = pw.length - state.requested<br />
            }<br />
<br />
            err := c.SendRequest(pw.index, state.requested, blockSize)<br />
            if err != nil {<br />
                return nil, err<br />
            }<br />
            state.backlog++<br />
            state.requested += blockSize<br />
        }<br />
    }<br />
<br />
    err := state.readMessage()<br />
    if err != nil {<br />
        return nil, err<br />
    }<br />
}<br />
<br />
return state.buf, nil } main.go This is a short one. We‚Äôre almost there.<br />
</code></pre></div></div><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    ‚Äúlog‚Äù<br />
    ‚Äúos‚Äù</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/veggiedefender/torrent-client/torrentfile" )<br />
</code></pre></div></div><br />
<br />
<p>func main() {<br />
    inPath := os.Args[1]<br />
    outPath := os.Args[2]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tf, err := torrentfile.Open(inPath)<br />
if err != nil {<br />
    log.Fatal(err)<br />
}<br />
<br />
err = tf.DownloadToFile(outPath)<br />
if err != nil {<br />
    log.Fatal(err)<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>This isn‚Äôt the full story<br />
For brevity, I included only a few of the important snippets of code. Notably, I left out all the glue code, parsing, unit tests, and the boring parts that build character. View my full implementation if you‚Äôre interested.</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--Ëµû-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">È¶ñÈ°µ</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">Â§èÊ≥ΩÊ∞ë</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"ÂàÜ‰∫´Âà∞Ôºö","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // ÂºÄÂêØÂØπËØùÊ°Ü
            enable: true,
            script: {
              // ÊØèÁ©∫Èó≤ 10 ÁßíÈíüÔºåÊòæÁ§∫‰∏ÄÊù°‰∏ÄË®Ä
              'every idle 10s': '$hitokoto$',
              // ÂΩìËß¶Êë∏Âà∞ÊòüÊòüÂõæÊ°à
              'hover .star': 'ÊòüÊòüÂú®Â§©‰∏äËÄå‰Ω†Âú®ÊàëÂøÉÈáå (*/œâÔºº*)',
              // ÂΩìËß¶Êë∏Âà∞ËßíËâ≤Ë∫´‰Ωì
              'tap body': 'ÂìéÂëÄÔºÅÂà´Á¢∞ÊàëÔºÅ',
              // ÂΩìËß¶Êë∏Âà∞ËßíËâ≤Â§¥ÈÉ®
              'tap face': '‰∫∫ÂÆ∂Â∑≤Áªè‰∏çÊòØÂ∞èÂ≠©Â≠ê‰∫ÜÔºÅ'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--Êú¨ÊñáÊù•Ëá™-->
     <script type="text/javascript">
      /* ‰ªÖIE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/nÊú¨ÁØáÊñáÁ´†Êù•Ê∫ê‰∫é xiazemin ÁöÑ Ê≥ΩÊ∞ëÂçöÂÆ¢|https://xiazemin.github.io/MyBlog/index.html ÂéüÊñáÈìæÊé•Ôºö"+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //ÁªëÂÆöÂú®‰∫Übody‰∏äÔºå‰πüÂèØ‰ª•ÁªëÂÆöÂú®ÂÖ∂‰ªñÂèØÁî®ÂÖÉÁ¥†Ë°åÔºå‰ΩÜÊòØ‰∏çÊòØÊâÄÊúâÂÖÉÁ¥†ÈÉΩÊîØÊåÅcopyÂíåpast‰∫ã‰ª∂„ÄÇ

     /*
$(document.body).bind({
    copy: function(event) {//copy‰∫ã‰ª∂
        //var cpTxt = "Â§çÂà∂ÁöÑÊï∞ÊçÆ";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//ÂèØ‰ª•Ëé∑ÂèñÁî®Êà∑ÈÄâ‰∏≠Â§çÂà∂ÁöÑÊï∞ÊçÆ
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//Âê¶ÂàôËÆæ‰∏çÁîüÊïà
    },paste: function(e) {//paste‰∫ã‰ª∂
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />Êú¨ÊñáÊù•Ê∫êÔºöxiazemin ÁöÑ Ê≥ΩÊ∞ëÂçöÂÆ¢ <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+ÂΩìÂâçÈ°µÈù¢ÈìæÊé•
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--Êú¨ÊñáÊù•Ëá™-->

</div>
  </body>

</html>