<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">race</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-03-14T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Mar 14, 2020</time></p>
					</div>
					 <p>https://xargin.com/map-concurrent-throw/<br />
某系统中有类似下面这样的代码：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
	“sync”<br />
	“time”<br />
)</p><br />
<br />
<p>type resp struct {<br />
	k string<br />
	v string<br />
}</p><br />
<br />
<p>func main() {<br />
	res := fetchData()<br />
    log.Print(res)<br />
}</p><br />
<br />
<p>func rpcwork() resp {<br />
	// do some rpc work<br />
	return resp{}<br />
}</p><br />
<br />
<p>func fetchData() (map[string]string, error) {<br />
	var result = map[string]string{} // result is k -&gt; v<br />
	var keys = []string{“a”, “b”, “c”}<br />
	var wg sync.WaitGroup<br />
	var m sync.Mutex<br />
	for i := 0; i &lt; len(keys); i++ {<br />
		wg.Add(1)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	go func() {<br />
		m.Lock()<br />
		defer m.Unlock()<br />
		defer wg.Done()<br />
<br />
		// do some rpc<br />
		resp := rpcwork()<br />
<br />
		result[resp.k] = resp.v<br />
	}()<br />
}<br />
<br />
waitTimeout(&amp;wg, time.Second)<br />
return result, nil }<br />
</code></pre></div></div><br />
<br />
<p>func waitTimeout(wg *sync.WaitGroup, timeout time.Duration) bool {<br />
	c := make(chan struct{})<br />
	go func() {<br />
		defer close(c)<br />
		wg.Wait()<br />
	}()<br />
	select {<br />
	case &lt;-c:<br />
		return false // completed normally<br />
	case &lt;-time.After(timeout):<br />
		return true // timed out<br />
	}<br />
}</p><br />
<br />
<p>线上会偶现崩溃(concurrent write and iteration)，但其负责人声称一定是离职员工的锅，连代码都不愿意看。</p><br />
<br />
<p>这里的代码我已经简化过了，相信你大概可以看出来，这里的 waitgroup 使用不恰当，若下游系统发生超时时，该 waitgroup 其实并没有完成，这也就意味着，其子任务也并没有全部完成。虽然在 fetchData 内部对 map 的修改加了写锁，但若下游超时，在 fetchData 返回后，fetchData 内部启动的 goroutine 仍然可能对返回的 map 进行修改。</p><br />
<br />
<p>当 map 对象同时进行加锁的 write 和不加锁的读取时，也会发生崩溃。不加锁的读取发生在什么地方呢？其实就是这里例子的 log.Print。如果你做个 json.Marshal 之类的，效果也差不多。</p><br />
<br />
<p>至于为什么是偶发，超时本来也不是经常发生的，看起来这个 bug 就变成了一个偶现 bug。</p><br />
<br />
<p>和这个 bug 类似的还有在打印 context 对象的时候，参考这里。</p><br />
<br />
<p>我们再顺便控诉一下 Go 本身，这种 map 并发崩溃的 bug 对很多人造成了困扰，按说崩溃的时候会打印导致崩溃的 goroutine 栈，但为什么还是一个值得总结的问题呢？</p><br />
<br />
<p>是因为 Go 在崩溃时，其实并不能完整地打印导致崩溃的因果关系，参考这里。</p><br />
<br />
<p>这个 issue 中同时也给了下面这段代码，只有在 go run -race 时，才能看到导致 throw 的真正原因。</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
	“sync”<br />
)</p><br />
<br />
<p>var x map[int]string = make(map[int]string)</p><br />
<br />
<p>func f(s string, wg *sync.WaitGroup) {<br />
	x[0] = s<br />
	wg.Done()<br />
}</p><br />
<br />
<p>func g(s string, wg *sync.WaitGroup) {<br />
	x[1] = s<br />
	wg.Done()<br />
}</p><br />
<br />
<p>func main() {<br />
	for {<br />
		var wg sync.WaitGroup<br />
		wg.Add(2)<br />
		go f(“Hello”, &amp;wg)<br />
		go g(“Playground”, &amp;wg)<br />
		wg.Wait()<br />
	}<br />
}<br />
下面这个崩溃栈只能看到 main.g(你运行的时候，也可能只能看到 main.f)。</p><br />
<br />
<p>~/test ❯❯❯ go run mmmm.go<br />
fatal error: concurrent map writes</p><br />
<br />
<p>goroutine 48 [running]:<br />
runtime.throw(0x1074091, 0x15)<br />
	/usr/local/go/src/runtime/panic.go:774 +0x72 fp=0xc000030758 sp=0xc000030728 pc=0x1024fb2<br />
runtime.mapassign_fast64(0x1060d00, 0xc000064000, 0x1, 0xc000066048)<br />
	/usr/local/go/src/runtime/map_fast64.go:101 +0x350 fp=0xc000030798 sp=0xc000030758 pc=0x100dcd0<br />
main.g(0x1072f92, 0xa, 0xc0000680f0)<br />
	/Users/didi/test/mmmm.go:15 +0x46 fp=0xc0000307c8 sp=0xc000030798 pc=0x10525f6<br />
runtime.goexit()<br />
	/usr/local/go/src/runtime/asm_amd64.s:1357 +0x1 fp=0xc0000307d0 sp=0xc0000307c8 pc=0x104c001<br />
created by main.main<br />
	/Users/didi/test/mmmm.go:24 +0xbb</p><br />
<br />
<p>goroutine 1 [semacquire]:<br />
sync.runtime_Semacquire(0xc0000680f8)<br />
	/usr/local/go/src/runtime/sema.go:56 +0x42<br />
sync.(*WaitGroup).Wait(0xc0000680f0)<br />
	/usr/local/go/src/sync/waitgroup.go:130 +0x64<br />
main.main()<br />
	/Users/didi/test/mmmm.go:25 +0xc9<br />
exit status 2<br />
下面这样才能看到真正的原因：</p><br />
<br />
<h1 id="test--go-run--race-mmmmgo">~/test ❯❯❯ go run -race mmmm.go</h1><br />
<p>WARNING: DATA RACE<br />
Write at 0x00c00008c000 by goroutine 7:<br />
  runtime.mapassign_fast64()<br />
      /usr/local/go/src/runtime/map_fast64.go:92 +0x0<br />
  main.g()<br />
      /Users/didi/test/mmmm.go:15 +0x63</p><br />
<br />
<p>Previous write at 0x00c00008c000 by goroutine 6:<br />
  runtime.mapassign_fast64()<br />
      /usr/local/go/src/runtime/map_fast64.go:92 +0x0<br />
  main.f()<br />
      /Users/didi/test/mmmm.go:10 +0x63</p><br />
<br />
<p>Goroutine 7 (running) created at:<br />
  main.main()<br />
      /Users/didi/test/mmmm.go:24 +0xee</p><br />
<br />
<p>Goroutine 6 (finished) created at:<br />
  main.main()<br />
      /Users/didi/test/mmmm.go:23 +0xb7<br />
==================<br />
fatal error: concurrent map writes</p><br />
<br />
<p>goroutine 67286 [running]:<br />
runtime.throw(0x10ad440, 0x15)<br />
	/usr/local/go/src/runtime/panic.go:774 +0x72 fp=0xc000094750 sp=0xc000094720 pc=0x105c272<br />
runtime.mapassign_fast64(0x1099c20, 0xc00008c000, 0x0, 0x0)<br />
	/usr/local/go/src/runtime/map_fast64.go:176 +0x364 fp=0xc000094790 sp=0xc000094750 pc=0x1044ed4<br />
main.f(0x10abea9, 0x5, 0xc00017ffa0)<br />
	/Users/didi/test/mmmm.go:10 +0x64 fp=0xc0000947c8 sp=0xc000094790 pc=0x108b184<br />
runtime.goexit()<br />
	/usr/local/go/src/runtime/asm_amd64.s:1357 +0x1 fp=0xc0000947d0 sp=0xc0000947c8 pc=0x1084651<br />
created by main.main<br />
	/Users/didi/test/mmmm.go:23 +0xb8</p><br />
<br />
<p>goroutine 1 [semacquire]:<br />
sync.runtime_Semacquire(0xc00017ffa8)<br />
	/usr/local/go/src/runtime/sema.go:56 +0x42<br />
sync.(*WaitGroup).Wait(0xc00017ffa0)<br />
	/usr/local/go/src/sync/waitgroup.go:130 +0xb1<br />
main.main()<br />
	/Users/didi/test/mmmm.go:25 +0xfd<br />
exit status 2<br />
如若在实践中碰到了类似的 bug，只能好好读代码，别无他法，甩锅给离职员工是解决不了问题的。</p><br />
<br />
<p>如果你手边的代码抽象程度比较高，比如函数的参数都是一些 interface，由运行期来决定，那可能要定位这种 bug 就更费劲一些。<br />
<!-- more --><br />
http://xiaorui.cc/archives/5919<br />
https://github.com/golang/go/issues/26703<br />
https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651437803&amp;idx=1&amp;sn=fe69335648dde77395659d2bb88bf832&amp;chksm=80bb6419b7cced0fd4eca56ae5a7a928990e189dd9c94aaae75950be70b73f9523ad1351e8e5&amp;scene=21#wechat_redirect<br />
https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651436434&amp;idx=1&amp;sn=33143ae7dea378157f1555fa4a213dba&amp;chksm=80bb6b60b7cce2764ad7b0152f47ea26971c5ce9a9980aa65a0e0daa9a079ba596117109401f&amp;scene=21#wechat_redirect</p><br />
<br />
<p>当我意识到我一直在处理和解决的问题有一个专有名词描述的时候，我总会觉得这事十分有趣。这次出现这种情况的是竞争条件(Race Conditions)。当你处理多个 routine 共享某类资源的时候，不可避免的需要考虑到这个。如果你未曾在你的代码中考虑过这个问题，现在就是一个不错的时候。</p><br />
<br />
<p>竞争条件是：当两个或两个以上的 routines 访问相同资源的时候，例如一个变量或者结构体，并且在不考虑其他 Gorutines 的情况下对资源进行读/写。这类代码能够造成你所能见到的最令人头疼，最随机的 bugs。通常需要大量的日志和一些运气才能找到这些类型的错误。这么多年来，我完善了我的日志的技能，以便识别这些问题。</p><br />
<br />
<p>Go 工具套件在 Go 版本 1.1 引入了一个竞态检测工具(race detector)。这个竞态检测工具是在编译流程中内置到你程序的代码。一旦你的程序开始运行，它能够发现和报告任何他所检测到的竞态情况。这是非常棒的功能, 为识别缺陷代码做出了非常重要的工作。</p><br />
<br />
<p>让我们写一个非常的简单的包含竞态条件内置竞态检测代码的程序。</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
   “fmt”<br />
   “sync”<br />
)</p><br />
<br />
<p>var Wait sync.WaitGroup<br />
var Counter int = 0</p><br />
<br />
<p>func main() {</p><br />
<br />
<p>for routine := 1; routine &lt;= 2; routine++ {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Wait.Add(1)<br />
   go Routine(routine)   }<br />
</code></pre></div></div><br />
<br />
<p>Wait.Wait()<br />
   fmt.Printf(“Final Counter: %d\n”, Counter)<br />
}</p><br />
<br />
<p>func Routine(id int) {</p><br />
<br />
<p>for count := 0; count &lt; 2; count++ {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   value := Counter<br />
   value++<br />
   Counter = value   }<br />
</code></pre></div></div><br />
<br />
<p>Wait.Done()<br />
}<br />
这个程序看起来没有问题。它创建了两个协程，每一个协程都会增加全局变量 Counter 两次。当他们都运行结束后，程序显示全局变量 Counter 的值。当我运行这个程序的时候，他会显示正确答案 4。所以这个程序工作正常,但真的吗？</p><br />
<br />
<p>让我们通过 Go 竞态检测运行这个代码，看看它会发现什么？在代码所在的目录打开终端，以 -race 参数编译代码。</p><br />
<br />
<p>go build -race<br />
然后程序输出</p><br />
<br />
<p>==================<br />
WARNING: DATA RACE<br />
Read by goroutine 5:<br />
main.Routine()<br />
    /Users/bill/Spaces/Test/src/test/main.go:29 +0x44<br />
gosched0()<br />
    /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f</p><br />
<br />
<p>Previous write by goroutine 4:<br />
main.Routine()<br />
    /Users/bill/Spaces/Test/src/test/main.go:33 +0x65<br />
gosched0()<br />
    /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f</p><br />
<br />
<p>Goroutine 5 (running) created at:<br />
main.main()<br />
    /Users/bill/Spaces/Test/src/test/main.go:17 +0x66<br />
runtime.main()<br />
    /usr/local/go/src/pkg/runtime/proc.c:182 +0x91</p><br />
<br />
<p>Goroutine 4 (finished) created at:<br />
main.main()<br />
    /Users/bill/Spaces/Test/src/test/main.go:17 +0x66<br />
runtime.main()<br />
    /usr/local/go/src/pkg/runtime/proc.c:182 +0x91</p><br />
<br />
<p>==================<br />
Final Counter: 4<br />
Found 1 data race(s)<br />
看起来，工具在代码中检测到竞争条件。如果你查看上面的竞争条件报告，你会看到针对程序的输出。全局变量 Counter 的值是 4。这就是这类的 bug 的难点所在，代码大部分情况是工作正常的，但错误的情况会随机产生。竞争检测告诉我们隐藏在代码中的糟糕问题。</p><br />
<br />
<p>警告报告告诉我们问题发生的准确位置:</p><br />
<br />
<p>Read by goroutine 5:<br />
main.Routine()<br />
    /Users/bill/Spaces/Test/src/test/main.go:29 +0x44<br />
gosched0()<br />
    /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  value := Counter<br />
</code></pre></div></div><br />
<br />
<p>Previous write by goroutine 4:<br />
main.Routine()<br />
    /Users/bill/Spaces/Test/src/test/main.go:33 +0x65<br />
gosched0()<br />
    /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Counter = value<br />
</code></pre></div></div><br />
<br />
<p>Goroutine 5 (running) created at:<br />
main.main()<br />
    /Users/bill/Spaces/Test/src/test/main.go:17 +0x66<br />
runtime.main()<br />
    /usr/local/go/src/pkg/runtime/proc.c:182 +0x91</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  go Routine(routine) 你能发现竞争检测器指出两行读和写全局变量 Counter 的代码。同时也指出生成协程的代码。<br />
</code></pre></div></div><br />
<br />
<p>让我们对代码进行简单修改，让竞争情况更容易暴露出来。</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
   “fmt”<br />
   “sync”<br />
   “time”<br />
)</p><br />
<br />
<p>var Wait sync.WaitGroup<br />
var Counter int = 0</p><br />
<br />
<p>func main() {</p><br />
<br />
<p>for routine := 1; routine &lt;= 2; routine++ {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Wait.Add(1)<br />
   go Routine(routine)   }<br />
</code></pre></div></div><br />
<br />
<p>Wait.Wait()<br />
   fmt.Printf(“Final Counter: %d\n”, Counter)<br />
}</p><br />
<br />
<p>func Routine(id int) {</p><br />
<br />
<p>for count := 0; count &lt; 2; count++ {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   value := Counter<br />
   time.Sleep(1 * time.Nanosecond)<br />
   value++<br />
   Counter = value   }<br />
</code></pre></div></div><br />
<br />
<p>Wait.Done()<br />
}<br />
我在循环中增加了一个纳秒的暂停。这个暂停正好位于协程读取全局变量 Couter 存储到本地副本之后。让我们运行这个程序看看在这种修改之后，全局变量 Counter 的值是什么？</p><br />
<br />
<p>Final Counter: 2<br />
循环中的暂停导致程序的失败。Counter 变量的值不再是 4 而是 2。发生了什么？让我们深挖代码看看为什么这个纳秒的暂停会导致这个 Bug。</p><br />
<br />
<p>在没有暂停的情况下，代码运行如下图：</p><br />
<br />
<p>没有暂停的情况下，第一个协程被生成，并且完成执行，紧接着第二个协程才开始运行。这就是为什么程序看起来像正确运行的原因，因为它在我的电脑上运行速度非常快，以至于代码自行排队运行。</p><br />
<br />
<p>让我们看看在有暂停的情况下，代码如何运行:</p><br />
<br />
<p>上图已经展示了所有必要的信息，因此我就没有把他全部画出来。这个暂停导致运行的两个协程之间进行了一次上下文切换。这次我们有一个完全不同的情况。让我们看看图中展示的代码:</p><br />
<br />
<p>value := Counter</p><br />
<br />
<p>time.Sleep(1 * time.Nanosecond)</p><br />
<br />
<p>value++</p><br />
<br />
<p>Counter = value<br />
在每一次循环的迭代过程中，全局变量 Counter 的值都被暂存到本地变量 value，本地的副本自增后，最终写回全局变量 Counter。如果这三行代码在没有中断的情况下，没有立即运行，那么程序就会出现问题。上面的图片展示了全局变量 Counter 的读取和上下文切换是如何导致问题的。</p><br />
<br />
<p>在这幅图中，在被协程 1 增加的变量被写回全局变量 Counter 之前，协程 2 被唤醒并读取全局变量 Counter。实质上，这两个协程对全局Counter变量执行完全相同的读写操作，因此最终的结果才是 2。</p><br />
<br />
<p>为了解决这个问题，你也许认为我们只需要将增加全局变量 Counter 的三行代码改写减少到一行即可。</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
   “fmt”<br />
   “sync”<br />
   “time”<br />
)</p><br />
<br />
<p>var Wait sync.WaitGroup<br />
var Counter int = 0</p><br />
<br />
<p>func main() {</p><br />
<br />
<p>for routine := 1; routine &lt;= 2; routine++ {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Wait.Add(1)<br />
   go Routine(routine)   }<br />
</code></pre></div></div><br />
<br />
<p>Wait.Wait()<br />
   fmt.Printf(“Final Counter: %d\n”, Counter)<br />
}</p><br />
<br />
<p>func Routine(id int) {</p><br />
<br />
<p>for count := 0; count &lt; 2; count++ {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Counter = Counter + 1<br />
   time.Sleep(1 * time.Nanosecond)   }<br />
</code></pre></div></div><br />
<br />
<p>Wait.Done()<br />
}<br />
当我们运行这个版本的代码的时候，我们会再次得到正确的结果:</p><br />
<br />
<p>Final Counter: 4<br />
如果我们启动竞争检测来运行该代码，上面出现的问题应该会消失:</p><br />
<br />
<p>go build -race<br />
并且输出为:</p><br />
<br />
<p>==================<br />
WARNING: DATA RACE<br />
Write by goroutine 5:<br />
main.Routine()<br />
    /Users/bill/Spaces/Test/src/test/main.go:30 +0x44<br />
gosched0()<br />
    /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f</p><br />
<br />
<p>Previous write by goroutine 4:<br />
main.Routine()<br />
    /Users/bill/Spaces/Test/src/test/main.go:30 +0x44<br />
gosched0()<br />
    /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f</p><br />
<br />
<p>Goroutine 5 (running) created at:<br />
main.main()<br />
    /Users/bill/Spaces/Test/src/test/main.go:18 +0x66<br />
runtime.main()<br />
    /usr/local/go/src/pkg/runtime/proc.c:182 +0x91</p><br />
<br />
<p>Goroutine 4 (running) created at:<br />
main.main()<br />
    /Users/bill/Spaces/Test/src/test/main.go:18 +0x66<br />
runtime.main()<br />
    /usr/local/go/src/pkg/runtime/proc.c:182 +0x91</p><br />
<br />
<p>==================<br />
Final Counter: 4<br />
Found 1 data race(s)<br />
然而，在这三十行代码的程序中，我们仍然检测到一个竞争条件。</p><br />
<br />
<p>Write by goroutine 5:<br />
main.Routine()<br />
    /Users/bill/Spaces/Test/src/test/main.go:30 +0x44<br />
gosched0()<br />
    /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Counter = Counter + 1<br />
</code></pre></div></div><br />
<br />
<p>Previous write by goroutine 4:<br />
main.Routine()<br />
    /Users/bill/Spaces/Test/src/test/main.go:30 +0x44<br />
gosched0()<br />
    /usr/local/go/src/pkg/runtime/proc.c:1218 +0x9f</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  Counter = Counter + 1<br />
</code></pre></div></div><br />
<br />
<p>Goroutine 5 (running) created at:<br />
main.main()<br />
    /Users/bill/Spaces/Test/src/test/main.go:18 +0x66<br />
runtime.main()<br />
    /usr/local/go/src/pkg/runtime/proc.c:182 +0x91</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  go Routine(routine) 使用一行代码进行增加操作的程序正确地运行了。但为什么代码仍然有一个竞态条件？不要被我们用于递增 Counter 变量的一行Go代码所欺骗。让我们看看这一行代码生成的汇编代码:<br />
</code></pre></div></div><br />
<br />
<p>0064 (./main.go:30) MOVQ Counter+0(SB),BX ; Copy the value of Counter to BX<br />
0065 (./main.go:30) INCQ ,BX             ; Increment the value of BX<br />
0066 (./main.go:30) MOVQ BX,Counter+0(SB) ; Move the new value to Counter<br />
实际上是执行这三行汇编代码增加 counter 变量。他们十分诡异地看起来像最初的 Go 代码。上下文切换可能发生在这三行汇编的中的任意一行后面。尽管这个程序正常工作了，但严格来说，Bug 仍然存在。</p><br />
<br />
<p>尽管我使用的例子非常简单，它还是体现发现这种 Bug 的复杂性。任何一行由 Go 编译器产生的汇编代码都有可能因为下文切换而停止运行。我们的 Go 代码也许看起来能够安全地访问资源，实际上底层汇编代码可能漏洞百出。</p><br />
<br />
<p>为了解决这类问题，我们需要确保读写全局变量 Counter 总是在任何其他协程访问该变量之前完成。管道(channle)能够帮助我们有序地访问资源。这一次，我会使用一个互斥锁(Mutex):</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
   “fmt”<br />
   “sync”<br />
   “time”<br />
)</p><br />
<br />
<p>var Wait sync.WaitGroup<br />
var Counter int = 0<br />
var Lock sync.Mutex</p><br />
<br />
<p>func main() {</p><br />
<br />
<p>for routine := 1; routine &lt;= 2; routine++ {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Wait.Add(1)<br />
   go Routine(routine)   }<br />
</code></pre></div></div><br />
<br />
<p>Wait.Wait()<br />
   fmt.Printf(“Final Counter: %d\n”, Counter)<br />
}</p><br />
<br />
<p>func Routine(id int) {</p><br />
<br />
<p>for count := 0; count &lt; 2; count++ {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   Lock.Lock()<br />
<br />
   value := Counter<br />
   time.Sleep(1 * time.Nanosecond)<br />
   value++<br />
   Counter = value<br />
<br />
   Lock.Unlock()   }<br />
</code></pre></div></div><br />
<br />
<p>Wait.Done()<br />
}<br />
以竞态检测的模式，编译程序，查看运行结果:</p><br />
<br />
<p>go build -race<br />
./test</p><br />
<br />
<p>Final Counter: 4<br />
这一次，我们得到了正确的结果，并且没有发现任何竞态条件。这个程序是没有问题的。互斥锁保护了在 Lock 和 Unlock 之间的代码，确保了一次只有一个协程执行该段代码。</p><br />
<br />
<p>你可以通过以下文章学习更多例子，更好地理解 Go 竞态检测器：</p><br />
<br />
<p>http://blog.golang.org/race-detector</p><br />
<br />
<p>如果你使用了多个协程，那么使用竞态检测器测试你的代码是个不错的建议。它会在单元测试和质量保证测试中，为你节省大量的时间和麻烦。Go 开发人员能有这样的工具是很幸运地，所以值得学习一下。</p><br />
<br />
<p>https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651437922&amp;idx=4&amp;sn=7950c36dc1c53c4cd7f3f619459cd3b9&amp;chksm=80bb6590b7ccec861b15ac40e54856add76bb0befd1a186d7e07c3d4767ce4f521c3060420ff&amp;scene=21#wechat_redirect</p><br />
<br />
<p>https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;mid=2651437922&amp;idx=4&amp;sn=7950c36dc1c53c4cd7f3f619459cd3b9&amp;chksm=80bb6590b7ccec861b15ac40e54856add76bb0befd1a186d7e07c3d4767ce4f521c3060420ff&amp;scene=21#wechat_redirect</p><br />
<br />
<p>Any race is a bug<br />
我在接手其他同事的 golang 项目时，一般都会习惯性的做一个竞态检测。有时总会得到一些“惊喜”，比如像下面这段代码：</p><br />
<br />
<p>package<br />
 main</p><br />
<br />
<p>import</p><br />
<br />
<p>(</p><br />
<br />
<p>“fmt”</p><br />
<br />
<p>“runtime”</p><br />
<br />
<p>“time”</p><br />
<br />
<p>)</p><br />
<br />
<p>var<br />
 i <br />
=</p><br />
<br />
<p>0</p><br />
<br />
<p>func main<br />
()</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>runtime . GOMAXPROCS ( 2 )<br />
<br />
<br />
<br />
go func ()<br />
</code></pre></div></div><br />
<br />
<p>{</p><br />
<br />
<p>for</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        fmt . Println ( "i is" ,  i )<br />
<br />
        time . Sleep ( time . Second )<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>}()</p><br />
<br />
<p>for</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    i  +=<br />
</code></pre></div></div><br />
<br />
<p>1</p><br />
<br />
<p>}</p><br />
<br />
<p>}</p><br />
<br />
<p>当通过 go run-race cmd.go 执行时，可以看到有明显的竞态出现：</p><br />
<br />
<p>==================</p><br />
<br />
<p>WARNING<br />
:<br />
 DATA RACE</p><br />
<br />
<p>Read<br />
 at <br />
0x0000005e4600</p><br />
<br />
<p>by<br />
 goroutine <br />
6<br />
:</p><br />
<br />
<p>main<br />
.<br />
main<br />
.<br />
func1<br />
()</p><br />
<br />
<p>/<br />
root<br />
/<br />
gofourge<br />
/<br />
src<br />
/<br />
lab<br />
/<br />
cmd<br />
.<br />
go<br />
:<br />
15</p><br />
<br />
<p>+<br />
0x63</p><br />
<br />
<p>Previous<br />
 write at <br />
0x0000005e4600</p><br />
<br />
<p>by<br />
 main goroutine<br />
:</p><br />
<br />
<p>main<br />
.<br />
main<br />
()</p><br />
<br />
<p>/<br />
root<br />
/<br />
gofourge<br />
/<br />
src<br />
/<br />
lab<br />
/<br />
cmd<br />
.<br />
go<br />
:<br />
20</p><br />
<br />
<p>+<br />
0x7b</p><br />
<br />
<p>Goroutine</p><br />
<br />
<p>6</p><br />
<br />
<p>(<br />
running<br />
)<br />
 created at<br />
:</p><br />
<br />
<p>main<br />
.<br />
main<br />
()</p><br />
<br />
<p>/<br />
root<br />
/<br />
gofourge<br />
/<br />
src<br />
/<br />
lab<br />
/<br />
cmd<br />
.<br />
go<br />
:<br />
13</p><br />
<br />
<p>+<br />
0x4f</p><br />
<br />
<p>==================</p><br />
<br />
<p>i <br />
is<br />
:</p><br />
<br />
<p>8212</p><br />
<br />
<p>i <br />
is<br />
:</p><br />
<br />
<p>54959831</p><br />
<br />
<p>i <br />
is<br />
:</p><br />
<br />
<p>109202117</p><br />
<br />
<p>我觉得不同的 goroutine 并发读写同一个变量，需要加锁，这应该是天经地义的常识。但是总有人以为，不加锁导致的问题最多就是读取的数据是修改前的数据，不能保证原子性罢了。是这样的吗？从上面的输出来看，似乎也差不多，其实这些都是典型的误解。</p><br />
<br />
<p>有些朋友可能不知道，在 Go（甚至是大部分语言）中，一条普通的赋值语句其实并不是一个原子操作（语言规范同样没有定义 i++ 是原子操作, 任何变量的赋值都不是原子操作）。例如，在 32 位机器上写 int64类型的变量是有中间状态的，它会被拆成两次写操作 MOV —— 写低 32 位和写高 32 位，如下图所示：</p><br />
<br />
<p>如果一个线程刚写完低 32 位，还没来得及写高 32 位时，另一个线程读取了这个变量，那它得到的就是一个毫无逻辑的中间变量，这很有可能使我们的程序出现诡异的 Bug。</p><br />
<br />
<p>而在 Go 的内存模型中，有 race 的 Go 程序的行为是未定义行为，理论上出现什么情况都是正常的。就拿上面的代码来说，当去掉 -race 参数执行时，大概率会得到这样的输出：</p><br />
<br />
<p>i <br />
is<br />
:</p><br />
<br />
<p>0</p><br />
<br />
<p>i <br />
is<br />
:</p><br />
<br />
<p>0</p><br />
<br />
<p>i <br />
is<br />
:</p><br />
<br />
<p>0</p><br />
<br />
<p>i <br />
is<br />
:</p><br />
<br />
<p>0</p><br />
<br />
<p>而用较老的 go 版本执行时，基本上执行一段时间，程序就会 HANG 住。所以讨论为什么出现这种现象实际上没有任何意义，不要依赖这种行为。</p><br />
<br />
<p>Mutex vs Atomic<br />
解决 race 的问题时，无非就是上锁。可能很多人都听说过一个高逼格的词叫「无锁队列」。都一听到加锁就觉得很 low，那无锁又是怎么一回事？其实就是利用 atomic 特性，那 atomic 会比 mutex 有什么好处呢？Benign Data Races: What Could Possibly Go Wrong? 的作者总结了这两者的一个区别：</p><br />
<br />
<p>Mutexes do no scale. Atomic loads do.</p><br />
<br />
<p>mutex 由操作系统实现，而 atomic 包中的原子操作则由底层硬件直接提供支持。在 CPU 实现的指令集里，有一些指令被封装进了 atomic 包，这些指令在执行的过程中是不允许中断（interrupt）的，因此原子操作可以在 lock-free 的情况下保证并发安全，并且它的性能也能做到随 CPU 个数的增多而线性扩展。</p><br />
<br />
<p>若实现相同的功能，后者通常会更有效率，并且更能利用计算机多核的优势。所以，以后当我们想并发安全的更新一些变量的时候，我们应该优先选择用 atomic 来实现。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>