<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">evio</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-03-18T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Mar 18, 2020</time></p>
					</div>
					 <p>https://github.com/tidwall/evio<br />
https://github.com/Allenxuxu/eviop/<br />
https://github.com/Allenxuxu/gev<br />
<!-- more --><br />
最近翻了 evio 的源码，发现一些问题，主要集中在 linux 平台 epoll 上和读写的处理。</p><br />
<br />
<p>用来唤醒 epoll 的 eventfd 写入数据没有读出<br />
listen 的 fd 注册到所有事件循环，epoll 的惊群问题<br />
loopWrite 在内核缓冲区满，无法一次写入时，出现写入数据丢失<br />
eventfd 的使用问题<br />
在 internal/internal_linux.go 中封装了 epoll 的使用 API 。</p><br />
<br />
<p>// Poll …<br />
type Poll struct {<br />
	fd    int // epoll fd<br />
	wfd   int // wake fd<br />
	notes noteQueue<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
在 OpenPoll 时，会创建一个 eventfd 并将 fd 赋值给 Poll 的 wfd 成员， 并且注册到 epoll 监听可读事件。</p><br />
<br />
<p>当需要唤醒当前 epoll 时，提供了 Trigger 方法</p><br />
<br />
<p>// Trigger …<br />
func (p *Poll) Trigger(note interface{}) error {<br />
	p.notes.Add(note)<br />
	_, err := syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1})<br />
	return err<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
这是往刚刚提到的 eventfd 中写入八字节数据，此时 epol l会被唤醒 epoll_wait 函数返回。 但是，evio 并没有去把 8 个字节的数据读取出来，内核缓冲区会不断积压，并且 evio 使用的是 epoll 的LT模式（默认模式），只要缓冲区中有数据，epoll 就会不断唤醒。这应该算是一个 bug 吧。</p><br />
<br />
<p>listen 的 fd 注册到所有事件循环，epoll 的惊群问题<br />
evio 可以指定启动多个事件循环。evio 将 listen fd 注册到每一个事件循环中（epoll）监听可读事件，所以当一个连接到来时，所有的事件循环都会唤醒。</p><br />
<br />
<p>// create loops locally and bind the listeners.<br />
	for i := 0; i &lt; numLoops; i++ {<br />
		l := &amp;loop{<br />
			idx:     i,<br />
			poll:    internal.OpenPoll(),<br />
			packet:  make([]byte, 0xFFFF),<br />
			fdconns: make(map[int]*conn),<br />
		}<br />
		for _, ln := range listeners {<br />
			l.poll.AddRead(ln.fd)<br />
		}<br />
		s.loops = append(s.loops, l)<br />
	}<br />
	// start loops in background<br />
	s.wg.Add(len(s.loops))<br />
	for _, l := range s.loops {<br />
		go loopRun(s, l)<br />
	}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
这并不是一个 bug ，因为最终只有一个线程可以accept调用返回成功，其他线程（协程）的accept函数调用返回EAGAIN错误 ，作者也做出了处理。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nfd, sa, err := syscall.Accept(fd)<br />
if err != nil {<br />
	if err == syscall.EAGAIN {<br />
		return nil<br />
	}<br />
	return err<br />
} 1 2 3 4 5 6 7 并且作者还利用每个事件循环都会被唤醒，来做客户端连接的负载均衡策略。<br />
</code></pre></div></div><br />
<br />
<p>LeastConnections : 当存在其他事件循环的注册的客户端连接数比当前事件循环的连接数少的时候，直接 return nil 。当有两个最下连接数相同的时候，也没关系，因为 accept 会保证只有一个可以成功。</p><br />
<br />
<p>RoundRobin： 原理也是一样，每个事件循环都会去判断 int(atomic.LoadUintptr(&amp;s.accepted)) % len(s.loops) ，轮到自己了，才继续执行，否则 return nil 。</p><br />
<br />
<p>if ln.fd == fd {<br />
	if len(s.loops) &gt; 1 {<br />
		switch s.balance {<br />
		case LeastConnections:<br />
			n := atomic.LoadInt32(&amp;l.count)<br />
			for _, lp := range s.loops {<br />
				if lp.idx != l.idx {<br />
					if atomic.LoadInt32(&amp;lp.count) &lt; n {<br />
						return nil // do not accept<br />
					}<br />
				}<br />
			}<br />
		case RoundRobin:<br />
			idx := int(atomic.LoadUintptr(&amp;s.accepted)) % len(s.loops)<br />
			if idx != l.idx {<br />
				return nil // do not accept<br />
			}<br />
			atomic.AddUintptr(&amp;s.accepted, 1)<br />
		}<br />
	}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
这样的做法没有问题，但是个人觉得 muduo 的做法似乎更好。</p><br />
<br />
<p>loopWrite 在内核缓冲区满，无法一次写入时，出现写入数据丢失<br />
func loopWrite(s *server, l *loop, c *conn) error {<br />
	if s.events.PreWrite != nil {<br />
		s.events.PreWrite()<br />
	}<br />
	n, err := syscall.Write(c.fd, c.out)<br />
	if err != nil {<br />
		if err == syscall.EAGAIN {<br />
			return nil<br />
		}<br />
		return loopCloseConn(s, l, c, err)<br />
	}<br />
	if n == len(c.out) {<br />
		c.out = nil<br />
	} else {<br />
		c.out = c.out[n:]<br />
	}<br />
	if len(c.out) == 0 &amp;&amp; c.action == None {<br />
		l.poll.ModRead(c.fd)<br />
	}<br />
	return nil<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
当内核缓冲区满时， syscall.Write(c.fd, c.out) 会无法全部写入，可以通过返回值得到已经写入的个数。</p><br />
<br />
<p>if n == len(c.out) {<br />
	c.out = nil<br />
} else {<br />
	c.out = c.out[n:]<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
作者也做出了处理，判断了 返回值 n 不是 c.out 长度的情况，c.out = c.out[n:] 。</p><br />
<br />
<p>但是作者并没有去注册 epoll 可写事件啊。</p><br />
<br />
<p>在当前文件搜索 ModReadWrite ，注册可读可写的事件，共有两处。一次是 loopWake 函数，一次是在 loopRead 函数。会不会作者在 loopRead 方法中了做了处理，规避了没有注册可写事件这种情况呢？</p><br />
<br />
<p>我们看下 loopRead</p><br />
<br />
<p>func loopRead(s *server, l *loop, c *conn) error {<br />
	var in []byte<br />
	n, err := syscall.Read(c.fd, l.packet)<br />
	if n == 0 || err != nil {<br />
		if err == syscall.EAGAIN {<br />
			return nil<br />
		}<br />
		return loopCloseConn(s, l, c, err)<br />
	}<br />
	in = l.packet[:n]<br />
	if !c.reuse {<br />
		in = append([]byte{}, in…)<br />
	}<br />
	if s.events.Data != nil {<br />
		out, action := s.events.Data(c, in)<br />
		c.action = action<br />
		if len(out) &gt; 0 {<br />
			c.out = append([]byte{}, out…)<br />
		}<br />
	}<br />
	if len(c.out) != 0 || c.action != None {<br />
		l.poll.ModReadWrite(c.fd)<br />
	}<br />
	return nil<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
25<br />
果然，作者做了处理！ 当 s.events.Data(c, in) 函数返回，如果 c.out 有数据，就注册可读可写事件。</p><br />
<br />
<p>所以，执行的流程是：</p><br />
<br />
<p>客户端有数据到来，loopRead 函数执行<br />
调用客户注册的回调函数 events.Data 函数，客户将需要的写入给客户端的数据返回，evio 将需要写给客户端数据存到 c.out , 然后监听可读可写事件<br />
eopll 可写事件唤醒，执行 loopWrite 直接 write 数据。 如果写完就重新注册，只注册可读事件；如果没写完，就不重新注册，还是可读可写事件都监听<br />
当缓冲区有空间了时，epoll 又会唤醒继续 loopWrite 。</p><br />
<br />
<p>似乎没问题，但是仔细想一想，会不会有这种情况呢：</p><br />
<br />
<p>内核的缓冲区满了，第一次没写完，等待缓冲区可写。此时客户端又来了数据，继续执行 loopRead 。调用用户回调函数，又有要写入的数据。这是来看看处理逻辑</p><br />
<br />
<p>if s.events.Data != nil {<br />
	out, action := s.events.Data(c, in)<br />
	c.action = action<br />
	if len(out) &gt; 0 {<br />
		c.out = append([]byte{}, out…)<br />
	}<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
c.out = append([]byte{}, out…) 这里，之前没写完存在 c.out 里的数据直接被清空了啊。这样要写入的数据就丢失了一部分啊。</p><br />
<br />
<p>思考<br />
evio 速度非常快，但是翻了源码，发现 evio 并没有刻意去减少 epoll 的唤醒次数，相反 evio 利用 epoll 的多次唤醒去做操作。</p><br />
<br />
<p>比如，调用客户回调后，并没有直接处理 action 的状态，反而是先把 action 存起来，增加注册 fd 的可写事件，让epoll 再唤醒，在 loopAction 中再来处理 action。先不说这样会不会有问题，这样让 epoll 频繁唤醒似乎不妥。</p><br />
<br />
<p>evio 的处理 read 和 write 的方式，也导致多次的内存拷贝，换种方式，性能还可以再次提升。evio 在 linux 环境（epoll）下，单元测试因为 用来唤醒 epoll 的 eventfd 写入数据没有读出 这个bug ，单元测试并不能通过。</p><br />
<br />
<p>evio 非常轻量，这也说明它非常简单，使用起来还是非常不方便，并且对于 epoll 的处理还有很多可以优化的地方。而且，作者似乎很忙。。。 PR也不理，Issues 也不理。所以决定自己撸一个了，更好用，更快速：eviop 。</p><br />
<br />
<p>推荐库<br />
gev 一个轻量、快速的基于 Reactor 模式的非阻塞 TCP 网络库。</p><br />
<br />
<p>原理<br />
evio 是 Reactor 模式的简单实现。Reactor 本质就是“non-blocking IO + IO multiplexing”，通过非阻塞 IO+ IO 多路复用来处理并发。程序运行一个或者多个事件循环，通过在事件循环中注册回调的方式实现业务逻辑。</p><br />
<br />
<p>evio 将所有文件描述符设为非阻塞，并注册到事件循环（ epoll / kqueue ）中。相较于传统的 per thread per connection 的处理方法，线程使用更少，线程资源利用率更高。</p><br />
<br />
<p>evio 需要在服务启动前，注册回调函数，当事件循环中有事件到来时，会调用回调函数处理。</p><br />
<br />
<p>使用示例<br />
先从一个简单的 echo server 的例子来了解 evio 。</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
	“flag”<br />
	“fmt”<br />
	“log”<br />
	“strings”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/tidwall/evio" )<br />
</code></pre></div></div><br />
<br />
<p>func main() {<br />
	var port int<br />
	var loops int<br />
	var udp bool<br />
	var trace bool<br />
	var reuseport bool<br />
	var stdlib bool</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>flag.IntVar(&amp;port, "port", 5000, "server port")<br />
flag.BoolVar(&amp;udp, "udp", false, "listen on udp")<br />
flag.BoolVar(&amp;reuseport, "reuseport", false, "reuseport (SO_REUSEPORT)")<br />
flag.BoolVar(&amp;trace, "trace", false, "print packets to console")<br />
flag.IntVar(&amp;loops, "loops", 0, "num loops")<br />
flag.BoolVar(&amp;stdlib, "stdlib", false, "use stdlib")<br />
flag.Parse()<br />
<br />
var events evio.Events<br />
events.NumLoops = loops<br />
events.Serving = func(srv evio.Server) (action evio.Action) {<br />
	log.Printf("echo server started on port %d (loops: %d)", port, srv.NumLoops)<br />
	if reuseport {<br />
		log.Printf("reuseport")<br />
	}<br />
	if stdlib {<br />
		log.Printf("stdlib")<br />
	}<br />
	return<br />
}<br />
events.Data = func(c evio.Conn, in []byte) (out []byte, action evio.Action) {<br />
	if trace {<br />
		log.Printf("%s", strings.TrimSpace(string(in)))<br />
	}<br />
	out = in<br />
	return<br />
}<br />
scheme := "tcp"<br />
if udp {<br />
	scheme = "udp"<br />
}<br />
if stdlib {<br />
	scheme += "-net"<br />
}<br />
log.Fatal(evio.Serve(events, fmt.Sprintf("%s://:%d?reuseport=%t", scheme, port, reuseport))) }<br />
</code></pre></div></div><br />
<br />
<p>上面的例子主要就是注册了两个回调函数： events.Serving 和 events.Data 。</p><br />
<br />
<p>当 server 启动时，会来执行注册的 events.Serving 回调函数；<br />
当有数据到来时，执行 events.Data 回调函数。</p><br />
<br />
<p>程序最后调用 evio.Serve 方法开启事件循环，程序在此处不断循环检测是否有事件发生并处理（有数据到来，有数据要发送…)。</p><br />
<br />
<p>evio 都是通过回调函数来执行业务逻辑的。 当客户端有数据发送过来时，调用用户注册的 events.Data 函数。</p><br />
<br />
<p>需要发送数据给客户端时，只可以通过注册的回调函数的返回值来返回，evio 框架来负责发送（有 bug）。</p><br />
<br />
<p>回调函数的返回值主要有两个 out []byte, action evio.Action , out 就是需要发送给客户端的， Action 就是返回一些状态，用来关闭连接，或者服务器退出啥的操作。主要状态如下：</p><br />
<br />
<p>const (<br />
	// None indicates that no action should occur following an event.<br />
	None Action = iota<br />
	// Detach detaches a connection. Not available for UDP connections.<br />
	Detach<br />
	// Close closes the connection.<br />
	Close<br />
	// Shutdown shutdowns the server.<br />
	Shutdown<br />
)<br />
evio 的事件循环<br />
evio.Serve<br />
我们先来看下 evio.Serve 方法的实现</p><br />
<br />
<p>func Serve(events Events, addr …string) error {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var lns []*listener<br />
defer func() {<br />
	// 这个函数如果推出，需要关闭所有 listener<br />
	for _, ln := range lns {<br />
		ln.close()<br />
	}<br />
}()<br />
var stdlib bool<br />
// 可以选择使用 stdlib（stdlib 主要是为了支持 非 *unix 平台）<br />
for _, addr := range addr {<br />
	// 生成 listener<br />
	var ln listener<br />
	var stdlibt bool<br />
	ln.network, ln.addr, ln.opts, stdlibt = parseAddr(addr)<br />
	if stdlibt {<br />
		stdlib = true<br />
	}<br />
	if ln.network == "unix" {<br />
		os.RemoveAll(ln.addr)<br />
	}<br />
	var err error<br />
	if ln.network == "udp" {<br />
		if ln.opts.reusePort {<br />
			ln.pconn, err = reuseportListenPacket(ln.network, ln.addr)<br />
		} else {<br />
			ln.pconn, err = net.ListenPacket(ln.network, ln.addr)<br />
		}<br />
	} else {<br />
		if ln.opts.reusePort {<br />
			ln.ln, err = reuseportListen(ln.network, ln.addr)<br />
		} else {<br />
			ln.ln, err = net.Listen(ln.network, ln.addr)<br />
		}<br />
	}<br />
	if err != nil {<br />
		return err<br />
	}<br />
	if ln.pconn != nil {<br />
		ln.lnaddr = ln.pconn.LocalAddr()<br />
	} else {<br />
		ln.lnaddr = ln.ln.Addr()<br />
	}<br />
	if !stdlib {<br />
		if err := ln.system(); err != nil {<br />
			return err<br />
		}<br />
	}<br />
	lns = append(lns, &amp;ln)<br />
}<br />
if stdlib {<br />
	return stdserve(events, lns)<br />
	// 使用 std net 库 启动server<br />
}<br />
return serve(events, lns)<br />
// 使用 epoll or kqueue 启动server }<br />
</code></pre></div></div><br />
<br />
<p>从 Serve 函数签名中可以看出 evio 是支持绑定多地址监听的</p><br />
<br />
<p>func Serve(events Events, addr …string) error<br />
使用方式如下：</p><br />
<br />
<p>evio.Serve(events, “tcp://localhost:5000”, “tcp://192.168.0.10:5001”)<br />
现在我们看看 evio 的核心部分： serve(events, lns)<br />
，这里会启动 evio 的 sever 。</p><br />
<br />
<p>func serve(events Events, listeners []*listener) error {<br />
	numLoops := events.NumLoops // 确定启动的事件循环数量<br />
	if numLoops &lt;= 0 {<br />
		if numLoops == 0 {<br />
			numLoops = 1<br />
		} else {<br />
			numLoops = runtime.NumCPU()<br />
		}<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s := &amp;server{}<br />
s.events = events<br />
s.lns = listeners<br />
s.cond = sync.NewCond(&amp;sync.Mutex{})<br />
s.balance = events.LoadBalance<br />
s.tch = make(chan time.Duration)<br />
<br />
//println("-- server starting")<br />
if s.events.Serving != nil { // 如果注册了回调函数，就执行<br />
	var svr Server<br />
	svr.NumLoops = numLoops<br />
	svr.Addrs = make([]net.Addr, len(listeners))<br />
	for i, ln := range listeners {<br />
		svr.Addrs[i] = ln.lnaddr<br />
	}<br />
	action := s.events.Serving(svr)<br />
	switch action {<br />
	case None:<br />
	case Shutdown:<br />
		return nil<br />
	}<br />
}<br />
<br />
defer func() { // server 退出后的清理工作<br />
	// wait on a signal for shutdown<br />
	s.waitForShutdown()<br />
<br />
	// notify all loops to close by closing all listeners<br />
	for _, l := range s.loops {<br />
		l.poll.Trigger(errClosing)<br />
	}<br />
<br />
	// wait on all loops to complete reading events<br />
	s.wg.Wait()<br />
<br />
	// close loops and all outstanding connections<br />
	for _, l := range s.loops {<br />
		for _, c := range l.fdconns {<br />
			loopCloseConn(s, l, c, nil)<br />
		}<br />
		l.poll.Close()<br />
	}<br />
	//println("-- server stopped")<br />
}()<br />
<br />
// create loops locally and bind the listeners.<br />
for i := 0; i &lt; numLoops; i++ {<br />
	l := &amp;loop{<br />
		idx:     i,<br />
		poll:    internal.OpenPoll(),<br />
		packet:  make([]byte, 0xFFFF), // event loop 的 read 缓冲区<br />
		fdconns: make(map[int]*conn),<br />
	}<br />
	for _, ln := range listeners {<br />
		l.poll.AddRead(ln.fd) // 将 fd 注册到 epoll 中并监听可读事件<br />
	}<br />
	s.loops = append(s.loops, l)<br />
}<br />
// start loops in background<br />
s.wg.Add(len(s.loops))<br />
for _, l := range s.loops { // 启动所有的 event loop<br />
	go loopRun(s, l)<br />
}<br />
return nil }<br />
</code></pre></div></div><br />
<br />
<p>serve 主要做这些事：</p><br />
<br />
<p>根据配置启动指定数量的 event loop，如果传入配置的 loop 数量为 0 则设置启动一个事件循环，如果传入配置小于 0 则设置为运行平台的 CPU 核心数量<br />
如果设置了回调函数 events.Serving ，运行它<br />
按照指定 event loop 数量，创建 epoll 句柄生成 loop ，并将所有的 listener 注册到 epoll 监听可读事件（有客户端连接）<br />
启动所有事件循环(一个事件循环一个 goroutine)<br />
需要注意的是，evio 将所有的 listener 的 fd 在每一个事件循环的 epoll 中都注册了。也就是说，如果有三个事件循环，一个 listener ，那么这个 listener 的 fd 会注册到三个 epoll 中。这就会出现 epoll 的惊群现象，感兴趣的可以自己搜索了解下。</p><br />
<br />
<p>evio 当一个新连接到来时，所有的事件循环都会唤醒，但是最终只有一个线程可以 accept 调用返回成功，其他线程（协程）的 accept 函数调用返回 EAGAIN 错误 。</p><br />
<br />
<p>loopRun<br />
下面我们看看 loopRun 的内部实现</p><br />
<br />
<p>func loopRun(s *server, l *loop) {<br />
	defer func() {<br />
		//fmt.Println(“– loop stopped –”, l.idx)<br />
		s.signalShutdown()<br />
		s.wg.Done()<br />
	}()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if l.idx == 0 &amp;&amp; s.events.Tick != nil {<br />
	go loopTicker(s, l)<br />
}<br />
<br />
//fmt.Println("-- loop started --", l.idx)<br />
l.poll.Wait(func(fd int, note interface{}) error {<br />
	if fd == 0 {<br />
		return loopNote(s, l, note)<br />
	}<br />
	c := l.fdconns[fd]<br />
	switch {<br />
	case c == nil:<br />
		return loopAccept(s, l, fd)<br />
	case !c.opened:<br />
		return loopOpened(s, l, c)<br />
	case len(c.out) &gt; 0:<br />
		return loopWrite(s, l, c)<br />
	case c.action != None:<br />
		return loopAction(s, l, c)<br />
	default:<br />
		return loopRead(s, l, c)<br />
	}<br />
}) }<br />
</code></pre></div></div><br />
<br />
<p>l.poll.Wait 传入一个回调函数作为参数，当 epoll 收到事件通知时，会执行这个回调函数。</p><br />
<br />
<p>在这个函数中接受客户端连接，读取客户端数据，调用客户回调函数处理业务逻辑…</p><br />
<br />
<p>我们先来看下 poll.Wait 的内部实现，再看看 loopAccept，loopOpened，loopWrite 等函数。<br />
loopRun 方法中最重要的就是 poll.Wait ，我们看看 Linux 下 epoll 的实现</p><br />
<br />
<p>func (p *Poll) Wait(iter func(fd int, note interface{}) error) error {<br />
	events := make([]syscall.EpollEvent, 64)<br />
	for {<br />
		n, err := syscall.EpollWait(p.fd, events, -1)<br />
		if err != nil &amp;&amp; err != syscall.EINTR {<br />
			return err<br />
		}<br />
		if err := p.notes.ForEach(func(note interface{}) error {<br />
			return iter(0, note)<br />
		}); err != nil {<br />
			return err<br />
		}<br />
		for i := 0; i &lt; n; i++ {<br />
			if fd := int(events[i].Fd); fd != p.wfd {<br />
				if err := iter(fd, nil); err != nil {<br />
					return err<br />
				}<br />
			} else {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		}<br />
	}<br />
} } 这个函数中是一个死循环，程序会阻塞在此处等待 epoll 的”通知“，然后处理就绪的 fd （读取/发送数据、执行用户注册的回调函数）。<br />
</code></pre></div></div><br />
<br />
<p>当有 fd 就绪的时候，syscall.EpollWait 函数返回，并且将就绪的 fd 通过 events 传出，返回值 n 为就绪 fd 的个数。</p><br />
<br />
<p>然后循环逐个遍历就绪的 fd，调用回调函数处理。</p><br />
<br />
<p>for i := 0; i &lt; n; i++ {<br />
	if fd := int(events[i].Fd); fd != p.wfd {<br />
		if err := iter(fd, nil); err != nil {<br />
			return err<br />
		}<br />
	} else {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>} } evio 的事件处理<br />
</code></pre></div></div><br />
<br />
<p>l.poll.Wait(func(fd int, note interface{}) error {<br />
	if fd == 0 {<br />
		return loopNote(s, l, note)<br />
	}<br />
	c := l.fdconns[fd]<br />
	switch {<br />
	case c == nil:<br />
		return loopAccept(s, l, fd)<br />
	case !c.opened:<br />
		return loopOpened(s, l, c)<br />
	case len(c.out) &gt; 0:<br />
		return loopWrite(s, l, c)<br />
	case c.action != None:<br />
		return loopAction(s, l, c)<br />
	default:<br />
		return loopRead(s, l, c)<br />
	}<br />
})<br />
当 epoll 检测到有就绪的 fd 时，会逐个调用上面的回调函数，evio 的主要逻辑也在这里。</p><br />
<br />
<p>当 fd == 0 时，会执行 loopNote 函数。loopNote 主要是用来处理一些非 fd 就绪的事件，比如定时任务、强制退出等。当然，我们都知道 fd 为 0 是标准输入，所以此处并不是真的去处理 fd 为 0 的文件描述符（注册到 epoll 的文件描述 &gt;= 3）。作者知道 epoll 返回的就绪 fd 中不会有为 0 的情况，所以此处 fd 为 0，是作者调用时传入，用来表示一种特殊的唤醒场景。</p><br />
<br />
<p>func (p *Poll) Wait(iter func(fd int, note interface{}) error) error {<br />
…<br />
	p.changes = p.changes[:0]<br />
		if err := p.notes.ForEach(func(note interface{}) error {<br />
			return iter(0, note)<br />
…<br />
我们跳到调用它的地方，可以看到只有在 p.notes.ForEach 这个函数中注册的回调函数中才会传入 fd 为 0 来执行 iter 回调函数。</p><br />
<br />
<p>notes noteQueue</p><br />
<br />
<p>noteQueue 的实现在 internal 目录中的 notequeue.go , 是一个无锁队列。我们不详细分析，只看下 ForEach 这个方法：</p><br />
<br />
<p>func (q *noteQueue) ForEach(iter func(note interface{}) error) error {<br />
	q.mu.Lock()<br />
	if len(q.notes) == 0 {<br />
		q.mu.Unlock()<br />
		return nil<br />
	}<br />
	notes := q.notes<br />
	q.notes = nil<br />
	q.mu.Unlock()<br />
	for _, note := range notes {<br />
		if err := iter(note); err != nil { // 执行回调函数<br />
			return err<br />
		}<br />
	}<br />
	return nil<br />
}</p><br />
<br />
<p>当队列中有数据时， 会执行回调函数，即</p><br />
<br />
<p>func(note interface{}) error {<br />
	return iter(0, note)<br />
}<br />
从上面的分析中可以我们已经知道为什么会有 fd 为 0 ，下面我们看下 loopNote 做什么。</p><br />
<br />
<p>loopNote<br />
func loopNote(s *server, l *loop, note interface{}) error {<br />
	var err error<br />
	switch v := note.(type) {<br />
	case time.Duration:<br />
		delay, action := s.events.Tick()<br />
		switch action {<br />
		case None:<br />
		case Shutdown:<br />
			err = errClosing<br />
		}<br />
		s.tch &lt;- delay<br />
	case error: // shutdown<br />
		err = v<br />
	case *conn:<br />
		// Wake called for connection<br />
		if l.fdconns[v.fd] != v {<br />
			return nil // ignore stale wakes<br />
		}<br />
		return loopWake(s, l, v)<br />
	}<br />
	return err<br />
}<br />
传入的 note 是 interface{} ，首先对 note 进行类型判断。</p><br />
<br />
<p>当 note 是 time.Duration 时，调用回调函数 events.Tick() ，这是 evio 提供的定时任务接口。</p><br />
<br />
<p>在 loopRun 函数中，如果设置了定时回调函数，会启动一个协程来来运行 loopTicker</p><br />
<br />
<p>if l.idx == 0 &amp;&amp; s.events.Tick != nil {<br />
	go loopTicker(s, l)<br />
}<br />
loopTicker 实现如下，可以看出会定时去触发 l.poll.Trigger，并且传入 time.Duration(0)</p><br />
<br />
<p>func loopTicker(s *server, l *loop) {<br />
	for {<br />
		if err := l.poll.Trigger(time.Duration(0)); err != nil {<br />
			break<br />
		}<br />
		time.Sleep(&lt;-s.tch)<br />
	}<br />
}<br />
我们跳到 poll.Trigger 的 Linux 下的实现，可以发现 evio 在此处 p.notes.Add(note) ，也就是 time.Duration(0)</p><br />
<br />
<p>func (p *Poll) Trigger(note interface{}) error {<br />
	p.notes.Add(note)<br />
	_, err := syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1})<br />
	return err<br />
}<br />
poll.Trigger 这个函数不仅仅是在 p.notes 里增加了一个 note，还唤醒了事件循环。</p><br />
<br />
<p>当 epoll 中注册 fd 都没有就绪事件时，线程会挂起，epoll 的 wait 方法会处于阻塞状态。evio 使用<br />
Linux 提供的 eventfd 来实现事件循环的唤醒，也就是代码上中的 syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1}) ,往 p.wfd 这个文件描述符中写入了 8 个字节的数据。</p><br />
<br />
<p>p.wfd 是一个 eventfd , 是 Poll 结构体的成员，在 OpenPoll 时赋值，即打开一个 eventfd 代码如下：</p><br />
<br />
<p>type Poll struct {<br />
	fd    int // epoll fd<br />
	wfd   int // wake fd<br />
	notes noteQueue<br />
}</p><br />
<br />
<p>func OpenPoll() *Poll {<br />
	l := new(Poll)<br />
	p, err := syscall.EpollCreate1(0)<br />
	if err != nil {<br />
		panic(err)<br />
	}<br />
	l.fd = p<br />
	r0, _, e0 := syscall.Syscall(syscall.SYS_EVENTFD2, 0, 0, 0)<br />
	if e0 != 0 {<br />
		syscall.Close(p)<br />
		panic(err)<br />
	}<br />
	l.wfd = int(r0)<br />
	l.AddRead(l.wfd)<br />
	return l<br />
}<br />
syscall.Syscall(syscall.SYS_EVENTFD2, 0, 0, 0) 创建了一个 eventfd ，然后将这个 eventfd 注册到了 epoll 监听可读事件。当 syscall.Write(p.wfd, []byte{0, 0, 0, 0, 0, 0, 0, 1}) 时候，epoll 就会唤醒。</p><br />
<br />
<p>但是，我翻了好久，也没有找到 evio 在哪里读取 eventfd 写入的 8 个字节（epoll）。这是一个 bug，所以在 Linux 机器上，这是不能用的。</p><br />
<br />
<p>这个 bug 会造成 epoll 不断唤醒，CPU 被长期占用</p><br />
<br />
<p>当我们注册了 evio 的定时任务 Tick 回调函数，程序启动后会往 eventfd 里写入 8 个字节数据，但是 evio 并没有读取，并且 evio 使用的是 epoll 的默认模式 LT，即只要可读缓冲区里还有数据，epoll 会一直不断唤醒，这是一个严重的 bug，作者应该没有在 Linux 环境下严格测试过。</p><br />
<br />
<p>我们抛开这个 bug， 继续来看 note 为 error 类型的情况。在 serve 函数中，当函数退出时，通过 l.poll.Trigger(errClosing) 来通知每个事件循环退出。</p><br />
<br />
<p>func  serve(events Events, listeners []*listener) error {<br />
…</p><br />
<br />
<p>defer func() {<br />
	// wait on a signal for shutdown<br />
	s.waitForShutdown()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// notify all loops to close by closing all listeners<br />
for _, l := range s.loops {<br />
	l.poll.Trigger(errClosing)<br />
}<br />
<br />
// wait on all loops to complete reading events<br />
s.wg.Wait()<br />
<br />
// close loops and all outstanding connections<br />
for _, l := range s.loops {<br />
	for _, c := range l.fdconns {<br />
		loopCloseConn(s, l, c, nil)<br />
	}<br />
	l.poll.Close()<br />
}<br />
//println("-- server stopped") }()<br />
</code></pre></div></div><br />
<br />
<p>…<br />
当 note 为 *conn 这种情况，是用来提供给使用者主动唤醒当前事件循环</p><br />
<br />
<p>func (c <em>conn) Wake() {<br />
	if c.loop != nil {<br />
		c.loop.poll.Trigger(c)<br />
	}<br />
}<br />
loopAccept<br />
c := l.fdconns[fd]<br />
	switch {<br />
	case c == nil:<br />
		return loopAccept(s, l, fd)<br />
type loop struct {<br />
	idx     int            // loop index in the server loops list<br />
	poll    *internal.Poll // epoll or kqueue<br />
	packet  []byte         // read packet buffer<br />
	fdconns map[int]</em>conn  // loop connections fd -&gt; conn<br />
	count   int32          // connection count<br />
}</p><br />
<br />
<p>fdconns 是用来存储已连接的 TCP connection 信息，key 为 fd， value 为 *conn 。</p><br />
<br />
<p>当 epoll 唤醒时，如果 fd 不在当前事件循环的连接，那就说明它是新连接，则执行 loopAccept 。</p><br />
<br />
<p>func loopAccept(s *server, l *loop, fd int) error {<br />
	for i, ln := range s.lns {<br />
		if ln.fd == fd {<br />
			if len(s.loops) &gt; 1 {<br />
				switch s.balance {<br />
				case LeastConnections:<br />
					n := atomic.LoadInt32(&amp;l.count)<br />
					for _, lp := range s.loops {<br />
						if lp.idx != l.idx {<br />
							if atomic.LoadInt32(&amp;lp.count) &lt; n {<br />
								return nil // do not accept<br />
							}<br />
						}<br />
					}<br />
				case RoundRobin:<br />
					idx := int(atomic.LoadUintptr(&amp;s.accepted)) % len(s.loops)<br />
					if idx != l.idx {<br />
						return nil // do not accept<br />
					}<br />
					atomic.AddUintptr(&amp;s.accepted, 1)<br />
				}<br />
			}<br />
			if ln.pconn != nil {<br />
				return loopUDPRead(s, l, i, fd)<br />
			}<br />
			nfd, sa, err := syscall.Accept(fd)<br />
			if err != nil {<br />
				if err == syscall.EAGAIN {<br />
					return nil<br />
				}<br />
				return err<br />
			}<br />
			if err := syscall.SetNonblock(nfd, true); err != nil {<br />
				return err<br />
			}<br />
			c := &amp;conn{fd: nfd, sa: sa, lnidx: i, loop: l}<br />
			l.fdconns[c.fd] = c<br />
			l.poll.AddReadWrite(c.fd)<br />
			atomic.AddInt32(&amp;l.count, 1)<br />
			break<br />
		}<br />
	}<br />
	return nil<br />
}</p><br />
<br />
<p>因为 evio 支持多地址监听，所以会存在多个 listener ，也就是 s.lns 。</p><br />
<br />
<p>第一步，先遍历所有的 listener 看看当前 epoll 中就绪的 fd 是哪一个 listener ，然后执行客户端的负载策略，决定新的客户端连接放在哪一个事件循环中。</p><br />
<br />
<p>这里关于客户端的负载策略，evio 利用了 epoll 的惊群效果，所有的事件循环都会唤醒进入 loopAccept，不符合负载策略直接 return nil。 关于这边的更多细节，可以看我的另一篇文章 【Golang 网络库 evio 一些问题/bug 和思考】。</p><br />
<br />
<p>接下来就是常规操作了， syscall.Accept(fd) 接受连接，然后  syscall.SetNonblock(nfd, true) 设置成非阻塞模式， l.poll.AddReadWrite(c.fd) 最后加入事件循环，注册可读可写事件。</p><br />
<br />
<p>loopOpened<br />
func loopOpened(s <em>server, l *loop, c *conn) error {<br />
	c.opened = true<br />
	c.addrIndex = c.lnidx<br />
	c.localAddr = s.lns[c.lnidx].lnaddr<br />
	c.remoteAddr = internal.SockaddrToAddr(c.sa)<br />
	if s.events.Opened != nil {<br />
		out, opts, action := s.events.Opened(c)<br />
		if len(out) &gt; 0 {<br />
			c.out = append([]byte{}, out…)<br />
		}<br />
		c.action = action<br />
		c.reuse = opts.ReuseInputBuffer<br />
		if opts.TCPKeepAlive &gt; 0 {<br />
			if _, ok := s.lns[c.lnidx].ln.(</em>net.TCPListener); ok {<br />
				internal.SetKeepAlive(c.fd, int(opts.TCPKeepAlive/time.Second))<br />
			}<br />
		}<br />
	}<br />
	if len(c.out) == 0 &amp;&amp; c.action == None {<br />
		l.poll.ModRead(c.fd)<br />
	}<br />
	return nil<br />
}<br />
loopOpened 是在 loopAccept 执行完成后，epoll 会立马再次唤醒然后执行的。</p><br />
<br />
<p>因为在 loopAccept 中最后将新的客户端连接加入 epoll 管理时注册的是可读可写事件，当前的内核写缓冲区肯定是为空的，所以 epoll 会再次唤醒。</p><br />
<br />
<p>…<br />
case !c.opened:<br />
	return loopOpened(s, l, c)<br />
…<br />
唤醒后会执行到这个 case case !c.opened:，因为在 loopAccept 中并没有去设置这个值。</p><br />
<br />
<p>loopOpened 内部的操作，主要就是设置一下 conn 的属性，然后调用客户注册的回调函数 events.Opened 。</p><br />
<br />
<p>如果在回调函数中，没有给客户端发送数据，则需要重新注册，只注册可读事件，不然 epoll 会一直唤醒（可写事件）。</p><br />
<br />
<p>loopAction<br />
func loopAction(s *server, l *loop, c *conn) error {<br />
	switch c.action {<br />
	default:<br />
		c.action = None<br />
	case Close:<br />
		return loopCloseConn(s, l, c, nil)<br />
	case Shutdown:<br />
		return errClosing<br />
	case Detach:<br />
		return loopDetachConn(s, l, c, nil)<br />
	}<br />
	if len(c.out) == 0 &amp;&amp; c.action == None {<br />
		l.poll.ModRead(c.fd)<br />
	}<br />
	return nil<br />
}<br />
case c.action != None:<br />
	return loopAction(s, l, c)<br />
loopAction 会在 case c.action != None: 的情况下执行， c.action 是执行完用户回调函数后会被赋值的状态。</p><br />
<br />
<p>在会有 action 的 loopXXX 中都会有如下类似操作。</p><br />
<br />
<p>if len(c.out) != 0 || c.action != None {<br />
	l.poll.ModReadWrite(c.fd)<br />
}<br />
也就是说 loopAction 依赖于 epoll 被可写事件再次唤醒来执行，这样会不会有问题呢？ 内核缓冲区满了？？</p><br />
<br />
<p>loopAction 内部的主要操作就是根据 action 做一些处理，关闭连接等等。</p><br />
<br />
<p>loopRead 和 loopWrite<br />
loopRead 和 loopWrite 主要就是调用系统调用读取和发送数据，并且调用用户回调函数，根据回调函数返回值来重新注册 epoll 的可读可写事件。</p><br />
<br />
<p>func loopRead(s *server, l *loop, c *conn) error {<br />
	var in []byte<br />
	n, err := syscall.Read(c.fd, l.packet)<br />
	if n == 0 || err != nil {<br />
		if err == syscall.EAGAIN {<br />
			return nil<br />
		}<br />
		return loopCloseConn(s, l, c, err)<br />
	}<br />
	in = l.packet[:n]<br />
	if !c.reuse {<br />
		in = append([]byte{}, in…)<br />
	}<br />
	if s.events.Data != nil {<br />
		out, action := s.events.Data(c, in)<br />
		c.action = action<br />
		if len(out) &gt; 0 {<br />
			c.out = append([]byte{}, out…)<br />
		}<br />
	}<br />
	if len(c.out) != 0 || c.action != None {<br />
		l.poll.ModReadWrite(c.fd)<br />
	}<br />
	return nil<br />
}<br />
调用 n, err := syscall.Read(c.fd, l.packet) 读取内核缓冲区的数据，如果返回出错 err == syscall.EAGAIN 意思是再试一次，直接返回。</p><br />
<br />
<p>如果 n == 0 或者 err 错误不为 syscall.EAGAIN ，则说明对方关闭了连接或是其他错误，直接 loopCloseConn 。</p><br />
<br />
<p>然后调用用户回调函数 s.events.Data ，根据返回值做相应操作。c.action = action</p><br />
<br />
<p>如果 out 里有数据，则赋给 c.out , 并且注册可读可写事件。</p><br />
<br />
<p>如果 c.action != None ，同样需要注册可读可写事件，原因上面已经说过了。</p><br />
<br />
<p>loopWrite 操作也大同小异，就不细说了。</p><br />
<br />
<p>但是其实关于 loopWrite 和 loopRead 的处理是会有 bug 的</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>