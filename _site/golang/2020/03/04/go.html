<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">go 的坑</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-03-04T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Mar 4, 2020</time></p>
					</div>
					 <p>This article is going to have a different tone from what I’ve been posting the past year - it’s a proper rant. And I always feel bad writing those, because, inevitably, it discusses things a lot of people have been working very hard on.</p><br />
<br />
<p>In spite of that, here we are.</p><br />
<br />
<p>Having invested thousands of hours into the language, and implemented several critical (to my employer) pieces of infrastructure with it, I wish I hadn’t.</p><br />
<br />
<p>If you’re already heavily invested in Go, you probably shouldn’t read this, it’ll probably just twist the knife. If you work on Go, you definitely shouldn’t read this.</p><br />
<br />
<p>I’ve been suffering Go’s idiosyncracies in relative silence for too long, there’s a few things I really need to get off my chest.</p><br />
<br />
<p>https://fasterthanli.me/blog/2020/i-want-off-mr-golangs-wild-ride<br />
<!-- more --><br />
Garden-variety takes on Go<br />
By now, everybody knows Go doesn’t have generics, which makes a lot of problems impossible to model accurately (instead, you have to fall back to reflection, which is extremely unsafe, and the API is very error-prone), error handling is wonky (even with your pick of the third-party libraries that add context or stack traces), package management took a while to arrive, etc.</p><br />
<br />
<p>But everybody also knows Go’s strengths: static linking makes binaries easy to deploy (although, Go binaries get very large, even if you strip DWARF tables - stack trace annotations still remain, and are costly).</p><br />
<br />
<p>Compile times are short (unless you need cgo), there’s an interactive runtime profiler (pprof) at arm’s reach, it’s relatively cross-platform (there’s even a tiny variant for embedded), it’s easy to syntax-highlight, and there’s now an official LSP server for it.</p><br />
<br />
<p>I’ve accepted all of these - the good and the bad.</p><br />
<br />
<p>We’re here to talk about the ugly.</p><br />
<br />
<p>Simple is a lie<br />
Over and over, every piece of documentation for the Go language markets it as “simple”.</p><br />
<br />
<p>This is a lie.</p><br />
<br />
<p>Or rather, it’s a half-truth that conveniently covers up the fact that, when you make something simple, you move complexity elsewhere.</p><br />
<br />
<p>Computers, operating systems, networks are a hot mess. They’re barely manageable, even if you know a decent amount about what you’re doing. Nine out of ten software engineers agree: it’s a miracle anything works at all.</p><br />
<br />
<p>So all the complexity is swept under the rug. Hidden from view, but not solved.</p><br />
<br />
<p>Here’s a simple example.</p><br />
<br />
<p>Cool bear’s hot tip<br />
This example does go on for a while, actually - but don’t let the specifics distract you. While it goes rather in-depth, it illustrates a larger point.</p><br />
<br />
<p>Most of Go’s APIs (much like NodeJS’s APIs) are designed for Unix-like operating systems. This is not surprising, as Rob &amp; Ken are from the Plan 9 gang.</p><br />
<br />
<p>So, the file API in Go looks like this:</p><br />
<br />
<p>// File represents an open file descriptor.<br />
type File struct {<br />
    *file // os specific<br />
}</p><br />
<br />
<p>func (f *File) Stat() (FileInfo, error) {<br />
    // omitted<br />
}</p><br />
<br />
<p>// A FileInfo describes a file and is returned by Stat and Lstat.<br />
type FileInfo interface {<br />
	Name() string       // base name of the file<br />
	Size() int64        // length in bytes for regular files; system-dependent for others<br />
	Mode() FileMode     // file mode bits<br />
	ModTime() time.Time // modification time<br />
	IsDir() bool        // abbreviation for Mode().IsDir()<br />
	Sys() interface{}   // underlying data source (can return nil)<br />
}</p><br />
<br />
<p>// A FileMode represents a file’s mode and permission bits.<br />
// The bits have the same definition on all systems, so that<br />
// information about files can be moved from one system<br />
// to another portably. Not all bits apply to all systems.<br />
// The only required bit is ModeDir for directories.<br />
type FileMode uint32</p><br />
<br />
<p>// The defined file mode bits are the most significant bits of the FileMode.<br />
// The nine least-significant bits are the standard Unix rwxrwxrwx permissions.<br />
// The values of these bits should be considered part of the public API and<br />
// may be used in wire protocols or disk representations: they must not be<br />
// changed, although new bits might be added.<br />
const (<br />
	// The single letters are the abbreviations<br />
	// used by the String method’s formatting.<br />
	ModeDir        FileMode = 1 « (32 - 1 - iota) // d: is a directory<br />
	ModeAppend                                     // a: append-only<br />
	ModeExclusive                                  // l: exclusive use<br />
	ModeTemporary                                  // T: temporary file; Plan 9 only<br />
	ModeSymlink                                    // L: symbolic link<br />
	ModeDevice                                     // D: device file<br />
	ModeNamedPipe                                  // p: named pipe (FIFO)<br />
	ModeSocket                                     // S: Unix domain socket<br />
	ModeSetuid                                     // u: setuid<br />
	ModeSetgid                                     // g: setgid<br />
	ModeCharDevice                                 // c: Unix character device, when ModeDevice is set<br />
	ModeSticky                                     // t: sticky<br />
	ModeIrregular                                  // ?: non-regular file; nothing else is known about this file</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Mask for the type bits. For regular files, none will be set.<br />
ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice | ModeCharDevice | ModeIrregular<br />
<br />
ModePerm FileMode = 0777 // Unix permission bits ) Makes sense for a Unix, right?<br />
</code></pre></div></div><br />
<br />
<p>Every file has a mode, there’s even a command that lets you dump it as hex:</p><br />
<br />
<p>$ stat -c ‘%f’ /etc/hosts<br />
81a4<br />
$ stat -c ‘%f’ /usr/bin/man<br />
81ed<br />
And so, a simple Go program can easily grab those “Unix permission bits”:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
        “fmt”<br />
        “os”<br />
)</p><br />
<br />
<p>func main() {<br />
        arg := os.Args[1]<br />
        fi, _ := os.Stat(arg)<br />
        fmt.Printf(“(%s) mode = %o\n”, arg, fi.Mode() &amp; os.ModePerm)<br />
}<br />
$ go run main.go /etc/hosts<br />
(/etc/hosts) mode = 644<br />
$ go run main.go /usr/bin/man<br />
(/etc/hosts) mode = 755<br />
On Windows, files don’t have modes. It doesn’t have stat, lstat, fstat syscalls - it has a FindFirstFile family of functions (alternatively, CreateFile to open, then GetFileAttributes, alternatively, GetFileInformationByHandle), which takes a pointer to a WIN32_FIND_DATA structure, which contains file attributes.</p><br />
<br />
<p>So, what happens if you run that program on Windows?</p><br />
<br />
<blockquote><br />
  <p>go run main.go C:\Windows\notepad.exe<br />
(C:\Windows\notepad.exe) mode = 666<br />
It makes up a mode.</p><br />
</blockquote><br />
<br />
<p>// src/os/types_windows.go</p><br />
<br />
<p>func (fs *fileStat) Mode() (m FileMode) {<br />
	if fs == &amp;devNullStat {<br />
		return ModeDevice | ModeCharDevice | 0666<br />
	}<br />
	if fs.FileAttributes&amp;syscall.FILE_ATTRIBUTE_READONLY != 0 {<br />
		m |= 0444<br />
	} else {<br />
		m |= 0666<br />
	}<br />
	if fs.isSymlink() {<br />
		return m | ModeSymlink<br />
	}<br />
	if fs.FileAttributes&amp;syscall.FILE_ATTRIBUTE_DIRECTORY != 0 {<br />
		m |= ModeDir | 0111<br />
	}<br />
	switch fs.filetype {<br />
	case syscall.FILE_TYPE_PIPE:<br />
		m |= ModeNamedPipe<br />
	case syscall.FILE_TYPE_CHAR:<br />
		m |= ModeDevice | ModeCharDevice<br />
	}<br />
	return m<br />
}<br />
Node.js does the same. There’s a single fs.Stats “type” for all platforms.</p><br />
<br />
<p>Using “whatever Unix has” as the lowest common denominator is extremely common in open-source codebases, so it’s not surprising.</p><br />
<br />
<p>Let’s go a little bit further. On Unix systems, you can change the modes of files, to make them read-only, or flip the executable bit.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
	“fmt”<br />
	“os”<br />
)</p><br />
<br />
<p>func main() {<br />
	arg := os.Args[1]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fi, err := os.Stat(arg)<br />
must(err)<br />
fmt.Printf("(%s) old mode = %o\n", arg, fi.Mode()&amp;os.ModePerm)<br />
<br />
must(os.Chmod(arg, 0755))<br />
<br />
fi, err = os.Stat(arg)<br />
must(err)<br />
fmt.Printf("(%s) new mode = %o\n", arg, fi.Mode()&amp;os.ModePerm) }<br />
</code></pre></div></div><br />
<br />
<p>func must(err error) {<br />
	if err != nil {<br />
		panic(err)<br />
	}<br />
}<br />
Let’s run this on Linux:</p><br />
<br />
<p>$ touch test.txt<br />
$ go run main.go test.txt<br />
(test.txt) old mode = 644<br />
(test.txt) new mode = 755<br />
And now on Windows:</p><br />
<br />
<blockquote><br />
  <p>go run main.go test.txt<br />
(test.txt) old mode = 666<br />
(test.txt) new mode = 666<br />
So, no errors. Chmod just silently does… nothing. Which is reasonably - there’s no equivalent to the “executable bit” for files on Windows.</p><br />
</blockquote><br />
<br />
<p>What does Chmod even do on Windows?</p><br />
<br />
<p>// src/syscall/syscall_windows.go</p><br />
<br />
<p>func Chmod(path string, mode uint32) (err error) {<br />
	p, e := UTF16PtrFromString(path)<br />
	if e != nil {<br />
		return e<br />
	}<br />
	attrs, e := GetFileAttributes(p)<br />
	if e != nil {<br />
		return e<br />
	}<br />
	if mode&amp;S_IWRITE != 0 {<br />
		attrs &amp;^= FILE_ATTRIBUTE_READONLY<br />
	} else {<br />
		attrs |= FILE_ATTRIBUTE_READONLY<br />
	}<br />
	return SetFileAttributes(p, attrs)<br />
}<br />
It sets or clears the read-only bit. That’s it.</p><br />
<br />
<p>We have an uint32 argument, with four billion two hundred ninety-four million nine hundred sixty-seven thousand two hundred ninety-five possible values, to encode… one bit of information.</p><br />
<br />
<p>That’s a pretty innocent lie. The assumption that files have modes was baked into the API design from the start, and now, everyone has to live with it. Just like in Node.JS, and probably tons of other languages.</p><br />
<br />
<p>But it doesn’t have to be like that.</p><br />
<br />
<p>A language with a more involved type system, and better designed libraries could avoid that pitfall.</p><br />
<br />
<p>Out of curiosity, what does Rust do?</p><br />
<br />
<p>Cool bear’s hot tip<br />
Oh, here we go again - Rust, Rust, and Rust again.</p><br />
<br />
<p>Why always Rust?</p><br />
<br />
<p>Well, I tried real hard to keep Rust out of all of this. Among other things, because people are going to dismiss this article as coming from “a typical rustacean”.</p><br />
<br />
<p>But for all the problems I raise in this article… Rust gets it right. If I had another good example, I’d use it. But I don’t, so, here goes.</p><br />
<br />
<p>There’s no stat-like function in the Rust standard library. There’s std::fs::metadata:</p><br />
<br />
<p>pub fn metadata&lt;P: AsRef<Path>&gt;(path: P) -&gt; Result<Metadata><br />
This function signatures tells us a lot already. It returns a Result, which means, not only do we know this can fail, we have to handle it. Either by panicking on error, with .unwrap() or .expect(), or by matching it against Result::Ok / Result::Err, or by bubbling it up with the ? operator.</Metadata></Path></p><br />
<br />
<p>The point is, this function signature makes it impossible for us to access an invalid/uninitialized/null Metadata. With a Go function, if you ignore the returned error, you still get the result - most probably a null pointer.</p><br />
<br />
<p>Also, the argument is not a string - it’s a path. Or rather, it’s something that can be turned into a path.</p><br />
<br />
<p>And String does implement AsRef<Path>, so, for simple use cases, it's not troublesome:</Path></p><br />
<br />
<p>fn main() {<br />
    let metadata = std::fs::metadata(“Cargo.toml”).unwrap();<br />
    println!(“is dir? {:?}”, metadata.is_dir());<br />
    println!(“is file? {:?}”, metadata.is_file());<br />
}<br />
But paths are not necessarily strings. On Unix (!), paths can be any sequence of bytes, except null bytes.</p><br />
<br />
<p>$ cd rustfun/<br />
$ touch “$(printf “\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98”)”<br />
$ ls<br />
ls: cannot compare file names ‘Cargo.lock’ and ‘\275\262=\274 ⌘’: Invalid or incomplete multibyte or wide character<br />
 src   target   Cargo.lock   Cargo.toml  ‘’$’\275\262’’=’$’\274’’ ⌘’<br />
We’ve just made a file with a very naughty name - but it’s a perfectly valid file, even if ls struggles with it.</p><br />
<br />
<p>$ stat “$(printf “\xbd\xb2\x3d\xbc\x20\xe2\x8c\x98”)”<br />
  File: = ⌘<br />
  Size: 0               Blocks: 0          IO Block: 65536  regular empty file<br />
Device: 8c70d496h/2356204694d   Inode: 72620543991375285  Links: 1<br />
Access: (0644/-rw-r–r–)  Uid: (197611/    amos)   Gid: (197611/    amos)<br />
Access: 2020-02-28 13:12:12.783734000 +0100<br />
Modify: 2020-02-28 13:12:12.783734000 +0100<br />
Change: 2020-02-28 13:12:12.783329400 +0100<br />
 Birth: 2020-02-28 13:12:12.783329400 +0100<br />
That’s not something we can represent with a String in Rust, because Rust Strings are valid utf-8, and this isn’t.</p><br />
<br />
<p>Rust Paths, however, are… arbitrary byte sequences.</p><br />
<br />
<p>And so, if we use std::fs::read_dir, we have no problem listing it and getting its metadata:</p><br />
<br />
<p>use std::fs;</p><br />
<br />
<p>fn main() {<br />
    let entries = fs::read_dir(“.”).unwrap();<br />
    for entry in entries {<br />
        let path = entry.unwrap().path();<br />
        let meta = fs::metadata(&amp;path).unwrap();<br />
        if meta.is_dir() {<br />
            println!(“(dir) {:?}”, path);<br />
        } else {<br />
            println!(“      {:?}”, path);<br />
        }<br />
    }<br />
}<br />
$ cargo run –quiet<br />
(dir) “./src”<br />
      “./Cargo.toml”<br />
      “./.gitignore”<br />
      “./\xBD\xB2=\xBC ⌘”<br />
(dir) “./.git”<br />
      “./Cargo.lock”<br />
(dir) “./target”<br />
What about Go?</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
        “fmt”<br />
        “os”<br />
)</p><br />
<br />
<p>func main() {<br />
        arg := os.Args[1]<br />
        f, err := os.Open(arg)<br />
        must(err)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    entries, err := f.Readdir(-1)<br />
    must(err)<br />
<br />
    for _, e := range entries {<br />
            if e.IsDir() {<br />
                    fmt.Printf("(dir) %s\n", e.Name())<br />
            } else {<br />
                    fmt.Printf("      %s\n", e.Name())<br />
            }<br />
    } }<br />
</code></pre></div></div><br />
<br />
<p>func must(err error) {<br />
        if err != nil {<br />
                panic(err)<br />
        }<br />
}<br />
$ go build<br />
$ ./gofun ../rustfun<br />
(dir) src<br />
      Cargo.toml<br />
      .gitignore<br />
      = ⌘<br />
(dir) .git<br />
      Cargo.lock<br />
(dir) target<br />
It… silently prints a wrong version of the path.</p><br />
<br />
<p>See, there’s no “path” type in Go. Just “string”. And Go strings are just byte slices, with no guarantees what’s inside.</p><br />
<br />
<p>So it prints garbage, whereas in Rust, Path does not implement Display, so we couldn’t do this:</p><br />
<br />
<p>println!(“(dir) {}”, path);<br />
We had to do this:</p><br />
<br />
<p>println!(“(dir) {:?}”, path);<br />
And if we wanted a friendlier output, we could handle both cases: when the path happens to be a valid utf-8 string, and when it doesn’t:</p><br />
<br />
<p>use std::fs;</p><br />
<br />
<p>fn main() {<br />
    let entries = fs::read_dir(“.”).unwrap();<br />
    for entry in entries {<br />
        let path = entry.unwrap().path();<br />
        let meta = fs::metadata(&amp;path).unwrap();<br />
        let prefix = if meta.is_dir() {<br />
            “(dir)”<br />
        } else {<br />
            “     “<br />
        };<br />
        match path.to_str() {<br />
            Some(s) =&gt; println!(“{} {}”, prefix, s),<br />
            None =&gt; println!(“{} {:?} (invalid utf-8)”, prefix, path),<br />
        }<br />
    }<br />
}<br />
$ cargo run –quiet<br />
(dir) ./src<br />
      ./Cargo.toml<br />
      ./.gitignore<br />
      “./\xBD\xB2=\xBC ⌘” (invalid utf-8)<br />
(dir) ./.git<br />
      ./Cargo.lock<br />
(dir) ./target<br />
Go says “don’t worry about encodings! things are probably utf-8”.</p><br />
<br />
<p>Except when they aren’t. And paths aren’t. So, in Go, all path manipulation routines operate on string, let’s take a look at the path/filepath package.</p><br />
<br />
<p>Package filepath implements utility routines for manipulating filename paths in a way compatible with the target operating system-defined file paths.</p><br />
<br />
<p>The filepath package uses either forward slashes or backslashes, depending on the operating system. To process paths such as URLs that always use forward slashes regardless of the operating system, see the path package.</p><br />
<br />
<p>What does this package give us?</p><br />
<br />
<p>func Abs(path string) (string, error)<br />
func Base(path string) string<br />
func Clean(path string) string<br />
func Dir(path string) string<br />
func EvalSymlinks(path string) (string, error)<br />
func Ext(path string) string<br />
func FromSlash(path string) string<br />
func Glob(pattern string) (matches []string, err error)<br />
func HasPrefix(p, prefix string) bool<br />
func IsAbs(path string) bool<br />
func Join(elem …string) string<br />
func Match(pattern, name string) (matched bool, err error)<br />
func Rel(basepath, targpath string) (string, error)<br />
func Split(path string) (dir, file string)<br />
func SplitList(path string) []string<br />
func ToSlash(path string) string<br />
func VolumeName(path string) string<br />
func Walk(root string, walkFn WalkFunc) error<br />
Strings. Lots and lots of strings. Well, byte slices.</p><br />
<br />
<p>Speaking of bad design decisions - what’s that Ext function I see?</p><br />
<br />
<p>// Ext returns the file name extension used by path. The extension is the suffix<br />
// beginning at the final dot in the final element of path; it is empty if there<br />
// is no dot.<br />
func Ext(path string) string<br />
Interesting! Let’s try it out.</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
        “fmt”<br />
        “path/filepath”<br />
)</p><br />
<br />
<p>func main() {<br />
        inputs := []string{<br />
                “/”,<br />
                “/.”,<br />
                “/.foo”,<br />
                “/foo”,<br />
                “/foo.txt”,<br />
                “/foo.txt/bar”,<br />
                “C:\”,<br />
                “C:\.”,<br />
                “C:\foo.txt”,<br />
                “C:\foo.txt\bar”,<br />
        }<br />
        for _, i := range inputs {<br />
                fmt.Printf(“%24q =&gt; %q\n”, i, filepath.Ext(i))<br />
        }<br />
}</p><br />
<br />
<p>func must(err error) {<br />
        if err != nil {<br />
                panic(err)<br />
        }<br />
}<br />
$ go run main.go<br />
                     “/” =&gt; “”<br />
                    “/.” =&gt; “.”<br />
                 “/.foo” =&gt; “.foo”<br />
                  “/foo” =&gt; “”<br />
              “/foo.txt” =&gt; “.txt”<br />
          “/foo.txt/bar” =&gt; “”<br />
                  “C:\” =&gt; “”<br />
                 “C:\.” =&gt; “.”<br />
           “C:\foo.txt” =&gt; “.txt”<br />
      “C:\foo.txt\bar” =&gt; “.txt\bar”<br />
Right away, I’m in debating mood - is .foo’s extension really .foo? But let’s move on.</p><br />
<br />
<p>This example was run on Linux, so C:\foo.txt\bar’s extension, according to filepath.Ext, is.. .txt\bar.</p><br />
<br />
<p>Why? Because the Go standard library makes the assumption that a platform has a single path separator - on Unix and BSD-likes, it’s /, and on Windows it’s \.</p><br />
<br />
<p>Except… that’s not the whole truth. I was curious, so I checked:</p><br />
<br />
<p>// in <code class="language-plaintext highlighter-rouge">fun.c</code></p><br />
<br />
<p>void main() {<br />
  HANDLE hFile = CreateFile(“C:/Users/amos/test.txt”, GENERIC_WRITE, 0, NULL,<br />
                            CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);</p><br />
<br />
<p>char *data = “Hello from the Win32 API”;<br />
  DWORD dwToWrite = (DWORD) strlen(data);<br />
  DWORD dwWritten = 0;<br />
  WriteFile(hFile, data, dwToWrite, &amp;dwWritten, NULL);<br />
  CloseHandle(hFile);<br />
}</p><br />
<blockquote><br />
  <p>cl fun.c<br />
Microsoft (R) C/C++ Optimizing Compiler Version 19.23.28107 for x64<br />
Copyright (C) Microsoft Corporation.  All rights reserved.</p><br />
</blockquote><br />
<br />
<p>fun.c<br />
Microsoft (R) Incremental Linker Version 14.23.28107.0<br />
Copyright (C) Microsoft Corporation.  All rights reserved.</p><br />
<br />
<p>/out:fun.exe<br />
fun.obj</p><br />
<blockquote><br />
  <p>.\fun.exe<br />
type C:\Users\amos\test.txt<br />
Hello from the Win32 API<br />
No funny Unix emulation business going on - just regular old Windows 10.</p><br />
</blockquote><br />
<br />
<p>And yet, in Go’s standard library, the path/filepath package exports those constants:</p><br />
<br />
<p>const (<br />
    Separator     = os.PathSeparator<br />
    ListSeparator = os.PathListSeparator<br />
)<br />
os, in turn, exports:</p><br />
<br />
<p>// src/os/path_windows.go<br />
const (<br />
	PathSeparator     = ‘\’ // OS-specific path separator<br />
	PathListSeparator = ‘;’  // OS-specific path list separator<br />
)<br />
So how comes filepath.Ext works with both separators on Windows?</p><br />
<br />
<p>$ go run main.go<br />
                     “/” =&gt; “”<br />
                    “/.” =&gt; “.”<br />
                 “/.foo” =&gt; “.foo”<br />
                  “/foo” =&gt; “”<br />
              “/foo.txt” =&gt; “.txt”<br />
          “/foo.txt/bar” =&gt; “”<br />
                  “C:\” =&gt; “”<br />
                 “C:\.” =&gt; “.”<br />
           “C:\foo.txt” =&gt; “.txt”<br />
      “C:\foo.txt\bar” =&gt; “”<br />
Let’s look at its implementation:</p><br />
<br />
<p>// src/path/filepath/path.go</p><br />
<br />
<p>func Ext(path string) string {<br />
	for i := len(path) - 1; i &gt;= 0 &amp;&amp; !os.IsPathSeparator(path[i]); i– {<br />
		if path[i] == ‘.’ {<br />
			return path[i:]<br />
		}<br />
	}<br />
	return “”<br />
}<br />
Ah. An IsPathSeparator function.</p><br />
<br />
<p>Sure enough:</p><br />
<br />
<p>// src/os/path_windows.go</p><br />
<br />
<p>// IsPathSeparator reports whether c is a directory separator character.<br />
func IsPathSeparator(c uint8) bool {<br />
	// NOTE: Windows accept / as path separator.<br />
	return c == ‘\’ || c == ‘/’<br />
}<br />
(Can I just point out how hilarious that “Extension” was deemed long enough to abbreviate to “Ext”, but “IsPathSeparator” wasn’t?)</p><br />
<br />
<p>How does Rust handle this?</p><br />
<br />
<p>It has std::path::is_separator:</p><br />
<br />
<p>/// Determines whether the character is one of the permitted<br />
// path separators for the current platform.<br />
pub fn is_separator(c: char) -&gt; bool<br />
And it has std::path::MAIN_SEPARATOR - emphasis on main separator:</p><br />
<br />
<p>/// The primary separator of path components for the current platform.<br />
/// <br />
/// For example, / on Unix and \ on Windows.<br />
pub const MAIN_SEPARATOR: char<br />
The naming along makes it much clearer that there might be secondary path separators, and the rich Path manipulation API makes it much less likely to find this kind of code, for example:</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DefaultScripts = "downloads" + string(os.PathSeparator) + "defaultScripts" Or this kind:<br />
<br />
if os.PathSeparator == '/' {<br />
	projname = strings.Replace(name, "\\", "/", -1)<br />
} else if os.PathSeparator == '\\' {<br />
	projname = strings.Replace(name, "/", "\\", -1)<br />
} Or this… kind:<br />
</code></pre></div></div><br />
<br />
<p>filefullpath = fmt.Sprintf(“%s%c%s%c%s%c%s%c%s%s”,<br />
		a.DataDir, os.PathSeparator,<br />
		m[0:1], os.PathSeparator,<br />
		m[1:2], os.PathSeparator,<br />
		m[2:3], os.PathSeparator,<br />
		m, ext)<br />
It turns out Rust also has a “get a path’s extension” function, but it’s a lot more conservative in the promises it makes:</p><br />
<br />
<p>// Extracts the extension of self.file_name, if possible.<br />
// <br />
// The extension is:<br />
// <br />
//   * None, if there is no file name;<br />
//   * None, if there is no embedded .;<br />
//   * None, if the file name begins with . and has no other .s within;<br />
//   * Otherwise, the portion of the file name after the final .<br />
pub fn extension(&amp;self) -&gt; Option&lt;&amp;OsStr&gt;<br />
Let’s submit it to the same test:</p><br />
<br />
<p>fn main() {<br />
    let inputs = [<br />
        r”/”,<br />
        r”/.”,<br />
        r”/.foo”,<br />
        r”/foo”,<br />
        r”/foo.txt”,<br />
        r”/foo.txt/bar”,<br />
        r”C:",<br />
        r”C:.”,<br />
        r”C:\foo.txt”,<br />
        r”C:\foo.txt\bar”,<br />
    ];<br />
    for input in &amp;inputs {<br />
        use std::path::Path;<br />
        println!(“ =&gt; {:?}”, input, Path::new(input).extension());<br />
    }<br />
}<br />
On Linux:</p><br />
<br />
<p>$ cargo run –quiet<br />
                   / =&gt; None<br />
                  /. =&gt; None<br />
               /.foo =&gt; None<br />
               /foo. =&gt; Some(“”)<br />
                /foo =&gt; None<br />
            /foo.txt =&gt; Some(“txt”)<br />
        /foo.txt/bar =&gt; None<br />
                 C:\ =&gt; None<br />
                C:. =&gt; Some(“”)<br />
          C:\foo.txt =&gt; Some(“txt”)<br />
      C:\foo.txt\bar =&gt; Some(“txt\bar”)<br />
On Windows:</p><br />
<br />
<p>$ cargo run –quiet<br />
                   / =&gt; None<br />
                  /. =&gt; None<br />
               /.foo =&gt; None<br />
               /foo. =&gt; Some(“”)<br />
                /foo =&gt; None<br />
            /foo.txt =&gt; Some(“txt”)<br />
        /foo.txt/bar =&gt; None<br />
                 C:\ =&gt; None<br />
                C:. =&gt; None<br />
          C:\foo.txt =&gt; Some(“txt”)<br />
      C:\foo.txt\bar =&gt; None<br />
Like Go, it gives a txt\bar extension for a Windows path on Linux.</p><br />
<br />
<p>Unlike Go, it:</p><br />
<br />
<p>Doesn’t think “/.foo” has a file extension<br />
Distinguishes between the “/foo.” case (Some(“”)) and the “/foo” case (None)<br />
Let’s also look at the Rust implementation of std::path::extension:</p><br />
<br />
<p>pub fn extension(&amp;self) -&gt; Option&lt;&amp;OsStr&gt; {<br />
	self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.and(after))<br />
}<br />
Let’s dissect that: first it calls file_name(). How does that work? Is it where it searches for path separators backwards from the end of the path?</p><br />
<br />
<p>pub fn file_name(&amp;self) -&gt; Option&lt;&amp;OsStr&gt; {<br />
	self.components().next_back().and_then(|p| match p {<br />
		Component::Normal(p) =&gt; Some(p.as_ref()),<br />
		_ =&gt; None,<br />
	})<br />
}<br />
No! It calls components which returns a type that implements DoubleEndedIterator - an iterator you can navigate from the front or the back. Then it grabs the first item from the back - if any - and returns that.</p><br />
<br />
<p>The iterator does look for path separators - lazily, in a re-usable way. There is no code duplication, like in the Go library:</p><br />
<br />
<p>// src/os/path_windows.go</p><br />
<br />
<p>func dirname(path string) string {<br />
	vol := volumeName(path)<br />
	i := len(path) - 1<br />
	for i &gt;= len(vol) &amp;&amp; !IsPathSeparator(path[i]) {<br />
		i–<br />
	}<br />
	dir := path[len(vol) : i+1]<br />
	last := len(dir) - 1<br />
	if last &gt; 0 &amp;&amp; IsPathSeparator(dir[last]) {<br />
		dir = dir[:last]<br />
	}<br />
	if dir == “” {<br />
		dir = “.”<br />
	}<br />
	return vol + dir<br />
}<br />
So, now we have only the file name. If we had /foo/bar/baz.txt, we’re now only dealing with baz.txt - as an OsStr, not a utf-8 String. We can still have random bytes.</p><br />
<br />
<p>We then map this result through split_file_at_dot, which behaves like so:</p><br />
<br />
<p>For “foo”, return (Some(“foo”), None)<br />
For “foo.bar”, return (Some(“foo”), Some(“bar”))<br />
For “foo.bar.baz”, return (Some(“foo.bar”), Some(“baz”))<br />
and_then, we only return after if before wasn’t None.</p><br />
<br />
<p>If we spelled out everything, we’d have:</p><br />
<br />
<p>pub fn extension(&amp;self) -&gt; Option&lt;&amp;OsStr&gt; {<br />
	if let Some(file_name) = self.file_name() {<br />
		let (before, after) = split_file_at_dot(file_name);<br />
		if let Some(before) {<br />
			// note: <code class="language-plaintext highlighter-rouge">after</code> is already an <code class="language-plaintext highlighter-rouge">Option&lt;&amp;OsStr&gt;</code> - it<br />
			// might still be <code class="language-plaintext highlighter-rouge">None</code>.<br />
			return after<br />
		}<br />
	}<br />
	None<br />
}<br />
The problem is carefully modelled. We can look at what we’re manipulating just by looking at its type. If it might not exist, it’s an Option<T>! If it's a path with multiple components, it's a &amp;Path (or its owned counterpart, PathBuf). If it's just part of a path, it's an &amp;OsStr.</T></p><br />
<br />
<p>Of course there’s a learning curve. Of course there’s more concepts involved than just throwing for loops at byte slices and seeing what sticks, like the Go library does.</p><br />
<br />
<p>But the result is a high-performance, reliable and type-safe library.</p><br />
<br />
<p>It’s worth it.</p><br />
<br />
<p>Speaking of Rust, we haven’t seen how it handles the whole “mode” thing yet.</p><br />
<br />
<p>So std::fs::Metadata has is_dir() and is_file(), which return booleans. It also has len(), which returns an u64 (unsigned 64-bit integer).</p><br />
<br />
<p>It has created(), modified(), and accessed(), all of which return an Option<SystemTime>. Again - the types inform us on what scenarios are possible. Access timestamps might not exist at all.</SystemTime></p><br />
<br />
<p>The returned time is not an std::time::Instant - it’s an std::time::SystemTime - the documentation tells us the difference:</p><br />
<br />
<p>A measurement of the system clock, useful for talking to external entities like the file system or other processes.</p><br />
<br />
<p>Distinct from the Instant type, this time measurement is not monotonic. This means that you can save a file to the file system, then save another file to the file system, and the second file has a SystemTime measurement earlier than the first. In other words, an operation that happens after another operation in real time may have an earlier SystemTime!</p><br />
<br />
<p>Consequently, comparing two SystemTime instances to learn about the duration between them returns a Result instead of an infallible Duration to indicate that this sort of time drift may happen and needs to be handled.</p><br />
<br />
<p>Although a SystemTime cannot be directly inspected, the UNIX_EPOCH constant is provided in this module as an anchor in time to learn information about a SystemTime. By calculating the duration from this fixed point in time, a SystemTime can be converted to a human-readable time, or perhaps some other string representation.</p><br />
<br />
<p>The size of a SystemTime struct may vary depending on the target operating system.</p><br />
<br />
<p>Source: https://doc.rust-lang.org/std/time/struct.SystemTime.html</p><br />
<br />
<p>Cool bear’s hot tip<br />
In fairness to everyone, monotonic time is really hard.</p><br />
<br />
<p>What about permissions? Well, there it is:</p><br />
<br />
<p>pub fn permissions(&amp;self) -&gt; Permissions<br />
A Permissions type! Just for that! And we can afford it, too - because types don’t cost anything at runtime. Everything probably ends up inlined anyway.</p><br />
<br />
<p>What does it expose?</p><br />
<br />
<p>pub fn readonly(&amp;self) -&gt; bool {}<br />
pub fn set_readonly(&amp;mut self, readonly: bool) {}<br />
Well! It exposes only what all supported operating systems have in common.</p><br />
<br />
<p>Can we still get Unix permission? Of course! But only on Unix:</p><br />
<br />
<p>Representation of the various permissions on a file.</p><br />
<br />
<p>This module only currently provides one bit of information, readonly, which is exposed on all currently supported platforms. Unix-specific functionality, such as mode bits, is available through the PermissionsExt trait.</p><br />
<br />
<p>Source: https://doc.rust-lang.org/std/fs/struct.Permissions.html</p><br />
<br />
<p>std::os::unix::fs::PermissionsExt is only compiled in on Unix, and exposes the following functions:</p><br />
<br />
<p>fn mode(&amp;self) -&gt; u32 {}<br />
fn set_mode(&amp;mut self, mode: u32) {}<br />
fn from_mode(mode: u32) -&gt; Self {}<br />
The documentation makes it really clear it’s Unix-only:</p><br />
<br />
<p>But it’s not just documentation. This sample program will compile and run on Linux (and macOS, etc.)</p><br />
<br />
<p>use std::fs::File;<br />
use std::os::unix::fs::PermissionsExt;</p><br />
<br />
<p>fn main() -&gt; std::io::Result&lt;()&gt; {<br />
    let f = File::open(“/usr/bin/man”)?;<br />
    let metadata = f.metadata()?;<br />
    let permissions = metadata.permissions();</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>println!("permissions: {:o}", permissions.mode());<br />
Ok(()) } $ cargo run --quiet permissions: 100755 But will fail to compile on Windows:<br />
</code></pre></div></div><br />
<br />
<p>$ cargo run –quiet<br />
error[E0433]: failed to resolve: could not find <code class="language-plaintext highlighter-rouge">unix</code> in <code class="language-plaintext highlighter-rouge">os</code><br />
 –&gt; src\main.rs:2:14<br />
  |<br />
2 | use std::os::unix::fs::PermissionsExt;<br />
  |              ^^^^ could not find <code class="language-plaintext highlighter-rouge">unix</code> in <code class="language-plaintext highlighter-rouge">os</code></p><br />
<br />
<p>error[E0599]: no method named <code class="language-plaintext highlighter-rouge">mode</code> found for type <code class="language-plaintext highlighter-rouge">std::fs::Permissions</code> in the current scope<br />
 –&gt; src\main.rs:9:47<br />
  |<br />
9 |     println!(“permissions: {:o}”, permissions.mode());<br />
  |                                               ^^^^ method not found in <code class="language-plaintext highlighter-rouge">std::fs::Permissions</code></p><br />
<br />
<p>error: aborting due to 2 previous errors</p><br />
<br />
<p>Some errors have detailed explanations: E0433, E0599.<br />
For more information about an error, try <code class="language-plaintext highlighter-rouge">rustc --explain E0433</code>.<br />
error: could not compile <code class="language-plaintext highlighter-rouge">rustfun</code>.</p><br />
<br />
<p>To learn more, run the command again with –verbose.<br />
How can we make a program that runs on Windows too? The same way the standard library only exposes PermissionsExt on Unix: with attributes.</p><br />
<br />
<p>use std::fs::File;<br />
#[cfg(target_family = “unix”)]<br />
use std::os::unix::fs::PermissionsExt;</p><br />
<br />
<p>fn main() -&gt; std::io::Result&lt;()&gt; {<br />
    let arg = std::env::args().nth(1).unwrap();<br />
    let f = File::open(&amp;arg)?;<br />
    let metadata = f.metadata()?;<br />
    let permissions = metadata.permissions();</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#[cfg(target_family = "unix")]<br />
{<br />
    println!("permissions: {:o}", permissions.mode());<br />
}<br />
<br />
#[cfg(target_family = "windows")]<br />
{<br />
    println!("readonly? {:?}", permissions.readonly());<br />
}<br />
<br />
Ok(()) } Those aren't #ifdef - they're not preprocessor directives. There's no risk of forgetting an #endif. And if you miss if/else chains, there's a crate for that.<br />
</code></pre></div></div><br />
<br />
<p>Here’s that sample program on Linux:</p><br />
<br />
<p>$ cargo run –quiet – /usr/bin/man<br />
permissions: 100755<br />
And on Windows:</p><br />
<br />
<p>$ cargo run –quiet – Cargo.toml<br />
readonly? false<br />
Can you do that in Go? Sure! Kind of!</p><br />
<br />
<p>There’s two ways to do something similar, and both involve multiple files.</p><br />
<br />
<p>Here’s one:</p><br />
<br />
<p>$ go mod init github.com/fasterthanlime/gofun<br />
In main.go, we need:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “os”</p><br />
<br />
<p>func main() {<br />
        poke(os.Args[1])<br />
}<br />
In poke_windows.go, we need:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
        “fmt”<br />
        “os”<br />
)</p><br />
<br />
<p>func poke(path string) {<br />
        stats, _ := os.Stat(path)<br />
        fmt.Printf(“readonly? %v\n”, (stats.Mode() &amp; 0o600) == 0);<br />
}<br />
And in poke_unix.go, we need:</p><br />
<br />
<p>// +build !windows</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
        “fmt”<br />
        “os”<br />
)</p><br />
<br />
<p>func poke(path string) {<br />
		stats, _ := os.Stat(path)<br />
		fmt.Printf(“permissions: %o\n”, stats.Mode() &amp; os.ModePerm);<br />
}<br />
Note how the _windows.go suffix is magic - it’ll get automatically excluded on non-Windows platforms. There’s no magic suffix for Unix systems though!</p><br />
<br />
<p>So we have to add a build constraint, which is:</p><br />
<br />
<p>A comment<br />
That must be “near the top of the file”<br />
That can only be preceded by blank space<br />
That must appear before the package clause<br />
That has its own language<br />
From the docs:</p><br />
<br />
<p>A build constraint is evaluated as the OR of space-separated options. Each option evaluates as the AND of its comma-separated terms. Each term consists of letters, digits, underscores, and dots. A term may be negated with a preceding !. For example, the build constraint:</p><br />
<br />
<p>// +build linux,386 darwin,!cgo</p><br />
<br />
<p>corresponds to the boolean formula:</p><br />
<br />
<p>(linux AND 386) OR (darwin AND (NOT cgo))</p><br />
<br />
<p>A file may have multiple build constraints. The overall constraint is the AND of the individual constraints. That is, the build constraints:</p><br />
<br />
<p>// +build linux darwin<br />
// +build 386</p><br />
<br />
<p>corresponds to the boolean formula:</p><br />
<br />
<p>(linux OR darwin) AND 386</p><br />
<br />
<p>Fun! Fun fun fun. So, on Linux, we get:</p><br />
<br />
<p>$ go build<br />
$ ./gofun /usr/bin/man<br />
permissions: 755<br />
$ ./gofun /etc/hosts<br />
permissions: 644<br />
And on Windows, we get:</p><br />
<br />
<blockquote><br />
  <p>go build<br />
.\gofun.exe .\main.go<br />
readonly? false<br />
Now, at least there’s a way to write platform-specific code in Go.</p><br />
</blockquote><br />
<br />
<p>In practice, it gets old very quickly. You now have related code split across multiple files, even if only one of the functions is platform-specific.</p><br />
<br />
<p>Build constraints override the magic suffixes, so it’s never obvious exactly which files are compiled in. You also have to duplicate (and keep in sync!) function signatures all over the place.</p><br />
<br />
<p>It’s… a hack. A shortcut. And an annoying one, at that.</p><br />
<br />
<p>So what happens when you make it hard for users to do things the right way? (The right way being, in this case, to not compile in code that isn’t relevant for a given platform). They take shortcuts, too.</p><br />
<br />
<p>Even in the official Go distribution, a lot of code just switches on the value of runtime.GOOS at, well, run-time:</p><br />
<br />
<p>// src/net/file_test.go</p><br />
<br />
<p>func TestFileConn(t *testing.T) {<br />
	switch runtime.GOOS {<br />
	case “plan9”, “windows”:<br />
		t.Skipf(“not supported on %s”, runtime.GOOS)<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for _, tt := range fileConnTests {<br />
	if !testableNetwork(tt.network) {<br />
		t.Logf("skipping %s test", tt.network)<br />
		continue<br />
	} “But these are little things!”<br />
</code></pre></div></div><br />
<br />
<p>They’re all little things. They add up. Quickly.</p><br />
<br />
<p>And they’re symptomatic of the problems with “the Go way” in general. The Go way is to half-ass things.</p><br />
<br />
<p>The Go way is to patch things up until they sorta kinda work, in the name of simplicity.</p><br />
<br />
<p>Lots of little things<br />
Speaking of little things, let’s consider what pushed me over the edge and provoked me to write this whole rant in the first place.</p><br />
<br />
<p>It was this package.</p><br />
<br />
<p>What does it do?</p><br />
<br />
<p>Provides mechanisms for adding idle timeouts to net.Conn and net.Listener.</p><br />
<br />
<p>Why do we need it?</p><br />
<br />
<p>Because the real-world is messy.</p><br />
<br />
<p>If you do a naive HTTP request in Go:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
	“fmt”<br />
	“io/ioutil”<br />
	“net/http”<br />
)</p><br />
<br />
<p>func main() {<br />
	res, err := http.Get(“http://perdu.com”)<br />
	must(err)<br />
	defer res.Body.Close() // this is a <em>very</em> common gotcha</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>body, err := ioutil.ReadAll(res.Body)<br />
must(err)<br />
fmt.Printf("%s", string(body)) }<br />
</code></pre></div></div><br />
<br />
<p>func must(err error) {<br />
	if err != nil {<br />
		panic(err)<br />
	}<br />
}<br />
$ go run main.go</p><br />
<html><head><title>Vous Etes Perdu ?</title></head><body><h1>Perdu sur l'Internet ?</h1><h2>Pas de panique, on va vous aider</h2><strong><pre>    * &lt;----- vous &ecirc;tes ici</pre></strong></body></html><br />
<p>Then it works. When it works.</p><br />
<br />
<p>If the server never accepts your connection - which might definitely happen if it’s dropping all the traffic to the relevant port, then you’ll just hang forever.</p><br />
<br />
<p>If you don’t want to hang forever, you have to do something else.</p><br />
<br />
<p>Like this:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
	“fmt”<br />
	“io/ioutil”<br />
	“net”<br />
	“net/http”<br />
	“time”<br />
)</p><br />
<br />
<p>func main() {<br />
	client := &amp;http.Client{<br />
		Transport: &amp;http.Transport{<br />
			DialContext: (&amp;net.Dialer{<br />
				Timeout: 5 * time.Second,<br />
			}).DialContext,<br />
		},<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>req, err := http.NewRequest("GET", "http://perdu.com", nil)<br />
must(err)<br />
<br />
res, err := client.Do(req)<br />
must(err)<br />
defer res.Body.Close()<br />
<br />
body, err := ioutil.ReadAll(res.Body)<br />
must(err)<br />
fmt.Printf("%s", string(body)) }<br />
</code></pre></div></div><br />
<br />
<p>func must(err error) {<br />
	if err != nil {<br />
		panic(err)<br />
	}<br />
}<br />
Not so simple, but, eh, whatever, it works.</p><br />
<br />
<p>Unless the server accepts your connection, says it’s going to send a bunch of bytes, and then never sends you anything.</p><br />
<br />
<p>Which definitely, 100%, for-sure, if-it-can-happen-it-does-happen, happens.</p><br />
<br />
<p>And then you hang forever.</p><br />
<br />
<p>To avoid that, you can set a timeout on the whole request, like so:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
	“context”<br />
	“fmt”<br />
	“io/ioutil”<br />
	“net/http”<br />
	“time”<br />
)</p><br />
<br />
<p>func main() {<br />
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)<br />
	defer cancel()<br />
	req, err := http.NewRequestWithContext(ctx, “GET”, “http://perdu.com”, nil)<br />
	must(err)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>res, err := http.DefaultClient.Do(req)<br />
must(err)<br />
defer res.Body.Close()<br />
<br />
body, err := ioutil.ReadAll(res.Body)<br />
must(err)<br />
fmt.Printf("%s", string(body)) }<br />
</code></pre></div></div><br />
<br />
<p>func must(err error) {<br />
	if err != nil {<br />
		panic(err)<br />
	}<br />
}<br />
But that doesn’t work if you’re planning on uploading something large, for example. How many seconds is enough to upload a large file? Is 30 seconds enough? And how do you know you’re spending those seconds uploading, and not waiting for the server to accept your request?</p><br />
<br />
<p>So, getlantern/idletiming adds a mechanism for timing out if there hasn’t been any data transmitted in a while, which is distinct from a dial timeout, and doesn’t force you to set a timeout on the whole request, so that it works for arbitrarily large uploads.</p><br />
<br />
<p>The repository looks innocent enough:</p><br />
<br />
<p>Just a couple files! And even some tests. Also - it works. I’m using it in production. I’m happy with it.</p><br />
<br />
<p>There’s just.. one thing.</p><br />
<br />
<p>$ git clone https://github.com/getlantern/idletiming<br />
Cloning into ‘idletiming’…<br />
(cut)<br />
$ cd idletiming<br />
$ go mod graph | wc -l<br />
196<br />
I’m sorry?</p><br />
<br />
<p>One hundred and ninety-six packages?</p><br />
<br />
<p>Well, I mean… lots of small, well-maintained libraries isn’t necessarily a bad idea - I never really agreed that the takeaway from the left-pad disaster was “small libraries are bad”.</p><br />
<br />
<p>Let’s look at what we’ve got there:</p><br />
<br />
<p>$ go mod graph<br />
github.com/getlantern/idletiming github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183<br />
github.com/getlantern/idletiming github.com/getlantern/fdcount@v0.0.0-20190912142506-f89afd7367c4<br />
github.com/getlantern/idletiming github.com/getlantern/golog@v0.0.0-20190830074920-4ef2e798c2d7<br />
github.com/getlantern/idletiming github.com/getlantern/grtrack@v0.0.0-20160824195228-cbf67d3fa0fd<br />
github.com/getlantern/idletiming github.com/getlantern/mtime@v0.0.0-20170117193331-ba114e4a82b0<br />
github.com/getlantern/idletiming github.com/getlantern/netx@v0.0.0-20190110220209-9912de6f94fd<br />
github.com/getlantern/idletiming github.com/stretchr/testify@v1.4.0<br />
I’m sure all of these are reasonable. Lantern is a “site unblock” product, so it has to deal with networking a lot, it makes sense that they’d have their own libraries for a bunch of things, including logging (golog) and some network extensions (netx). testify is a well-known set of testing helpers, I use it too!</p><br />
<br />
<p>Let’s keep going:</p><br />
<br />
<p>github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/Shopify/sarama@v1.23.1<br />
Uhh….</p><br />
<br />
<p>github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/aristanetworks/fsnotify@v1.4.2<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/aristanetworks/glog@v0.0.0-20180419172825&gt;<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/aristanetworks/splunk-hec-go@v0.3.3<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/garyburd/redigo@v1.6.0<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/golang/protobuf@v1.3.2<br />
Wait, I think we..</p><br />
<br />
<p>github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/influxdata/influxdb1-client@v0.0.0-201908&gt;<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/klauspost/cpuid@v1.2.1<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/klauspost/reedsolomon@v1.9.2<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/kylelemons/godebug@v1.1.0<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/onsi/ginkgo@v1.10.1<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/onsi/gomega@v1.7.0<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/openconfig/gnmi@v0.0.0-20190823184014-89b&gt;<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/openconfig/reference@v0.0.0-2019072701583&gt;<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/prometheus/client_golang@v1.1.0<br />
I can understand some of these but…</p><br />
<br />
<p>github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/satori/go.uuid@v1.2.0<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/stretchr/testify@v1.3.0<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/templexxx/cpufeat@v0.0.0-20180724012125-c&gt;<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/templexxx/xor@v0.0.0-20181023030647-4e92f&gt;<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/tjfoc/gmsm@v1.0.1<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/xtaci/kcp-go@v5.4.5+incompatible<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 github.com/xtaci/lossyconn@v0.0.0-20190602105132-8df&gt;<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 golang.org/x/net@v0.0.0-20190912160710-24e19bdeb0f2<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 golang.org/x/sys@v0.0.0-20190912141932-bc967efca4b8<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 golang.org/x/time@v0.0.0-20190308202827-9d24e82272b4<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 golang.org/x/tools@v0.0.0-20190912185636-87d9f09c5d89<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 google.golang.org/grpc@v1.23.1<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 gopkg.in/bsm/ratelimit.v1@v1.0.0-20160220154919-db14&gt;<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 gopkg.in/jcmturner/goidentity.v3@v3.0.0<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 gopkg.in/redis.v4@v4.2.4<br />
github.com/aristanetworks/goarista@v0.0.0-20200131140622-c6473e3ed183 gopkg.in/yaml.v2@v2.2.2<br />
STOP! Just stop. Stop it already.</p><br />
<br />
<p>It keeps going on, and on. There’s everything.</p><br />
<br />
<p>YAML, Redis, GRPC, which in turns needs protobuf, InfluxDB, an Apache Kafka client, a Prometheus client, Snappy, Zstandard, LZ4, a chaos-testing TCP proxy, three other logging packages, and client libraries for various Google Cloud services.</p><br />
<br />
<p>What could possibly justify all this?</p><br />
<br />
<p>Let’s review:</p><br />
<br />
<p>// <code class="language-plaintext highlighter-rouge">idletiming_listener.go</code></p><br />
<br />
<p>package idletiming</p><br />
<br />
<p>import (<br />
	“net”<br />
	“time”<br />
)<br />
Only built-in imports. Good.</p><br />
<br />
<p>// <code class="language-plaintext highlighter-rouge">idletiming_conn.go</code></p><br />
<br />
<p>// package idletiming provides mechanisms for adding idle timeouts to net.Conn<br />
// and net.Listener.<br />
package idletiming</p><br />
<br />
<p>import (<br />
	“errors”<br />
	“io”<br />
	“net”<br />
	“sync”<br />
	“sync/atomic”<br />
	“time”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/getlantern/golog"<br />
"github.com/getlantern/mtime"<br />
"github.com/getlantern/netx" ) This one is the meat of the library, so to say, and it requires a few of the getlantern packages we've seen:<br />
</code></pre></div></div><br />
<br />
<p>It does end up importing golang.org/x/net/http2/hpack - but that’s just because of net/http. These are built-ins, so let’s ignore them for now.</p><br />
<br />
<p>getlantern/hex is self-contained, so, moving on to getlantern/mtime:</p><br />
<br />
<p>That’s it? What’s why Go ends up fetching the entire github.com/aristanetworks/goarista repository, and all its transitive dependencies?</p><br />
<br />
<p>What does aristanetworks/goariasta/monotime even do?</p><br />
<br />
<p>Mh. Let’s look inside issue15006.s</p><br />
<br />
<p>// Copyright (c) 2016 Arista Networks, Inc.<br />
// Use of this source code is governed by the Apache License 2.0<br />
// that can be found in the COPYING file.</p><br />
<br />
<p>// This file is intentionally empty.<br />
// It’s a workaround for https://github.com/golang/go/issues/15006<br />
I uh… okay.</p><br />
<br />
<p>What does that issue say?</p><br />
<br />
<p>This is known and I think the empty assembly file is the accepted fix.</p><br />
<br />
<p>It’s a rarely used feature and having an assembly file also make it standout.</p><br />
<br />
<p>I don’t think we should make this unsafe feature easy to use.</p><br />
<br />
<p>And later (emphasis mine):</p><br />
<br />
<p>I agree with Minux. If you’re looking at a Go package to import, you might want to know if it does any unsafe trickery. Currently you have to grep for an import of unsafe and look for non-.go files. If we got rid of the requirement for the empty .s file, then you’d have to grep for //go:linkname also.</p><br />
<br />
<p>That’s… that’s certainly a stance.</p><br />
<br />
<p>But which unsafe feature exactly?</p><br />
<br />
<p>Let’s look at nanotime.go:</p><br />
<br />
<p>// Copyright (c) 2016 Arista Networks, Inc.<br />
// Use of this source code is governed by the Apache License 2.0<br />
// that can be found in the COPYING file.</p><br />
<br />
<p>// Package monotime provides a fast monotonic clock source.<br />
package monotime</p><br />
<br />
<p>import (<br />
	“time”<br />
	_ “unsafe” // required to use //go:linkname<br />
)</p><br />
<br />
<p>//go:noescape<br />
//go:linkname nanotime runtime.nanotime<br />
func nanotime() int64</p><br />
<br />
<p>// Now returns the current time in nanoseconds from a monotonic clock.<br />
// The time returned is based on some arbitrary platform-specific point in the<br />
// past.  The time returned is guaranteed to increase monotonically at a<br />
// constant rate, unlike time.Now() from the Go standard library, which may<br />
// slow down, speed up, jump forward or backward, due to NTP activity or leap<br />
// seconds.<br />
func Now() uint64 {<br />
	return uint64(nanotime())<br />
}</p><br />
<br />
<p>// Since returns the amount of time that has elapsed since t. t should be<br />
// the result of a call to Now() on the same machine.<br />
func Since(t uint64) time.Duration {<br />
	return time.Duration(Now() - t)<br />
}<br />
That’s it. That’s the whole package.</p><br />
<br />
<p>The unsafe feature in question is being able to access unexported (read: lowercase, sigh) symbols from the Go standard library.</p><br />
<br />
<p>Why is that even needed?</p><br />
<br />
<p>If you remember from earlier, Rust has two types for time: SystemTime, which corresponds to your… system’s… time, which can be adjusted via NTP. It can go back, so subtraction can fail.</p><br />
<br />
<p>And it has Instant, which is weakly monotonically increasing - at worse, it’ll give the same value twice, but never less than the previous value. This is useful to measure elapsed time within a process.</p><br />
<br />
<p>How did Go solve that problem?</p><br />
<br />
<p>At first, it didn’t. Monotonic time measurement is a hard problem, so it was only available internally, in the standard library, not for regular Go developers (a common theme):</p><br />
<br />
<p>And then, it did.</p><br />
<br />
<p>Sort of. In the most “Go way” possible.</p><br />
<br />
<p>I thought some more about the suggestion above to reuse time.Time with a special location. The special location still seems wrong, but what if we reuse time.Time by storing inside it both a wall time and a monotonic time, fetched one after the other?</p><br />
<br />
<p>Then there are two kinds of time.Times: those with wall and monotonic stored inside (let’s call those “wall+monotonic Times”) and those with only wall stored inside (let’s call those “wall-only Times”).</p><br />
<br />
<p>Suppose further that:</p><br />
<br />
<p>time.Now returns a wall+monotonic Time.<br />
for t.Add(d), if t is a wall+monotonic Time, so is the result; if t is wall-only, so is the result.<br />
all other functions that return Times return wall-only Times. These include: time.Date, time.Unix, t.AddDate, t.In, t.Local, t.Round, t.Truncate, t.UTC<br />
for t.Sub(u), if t and u are both wall+monotonic, the result is computed by subtracting monotonics; otherwise the result is computed by subtracting wall times. - t.After(u), t.Before(u), t.Equal(u) compare monotonics if available (just like t.Sub(u)), otherwise walls.<br />
all the other functions that operate on time.Times use the wall time only. These include: t.Day, t.Format, t.Month, t.Unix, t.UnixNano, t.Year, and so on.<br />
Doing this returns a kind of hybrid time from time.Now: it works as a wall time but also works as a monotonic time, and future operations use the right one.</p><br />
<br />
<p>So, as of Go 1.9 - problem solved!</p><br />
<br />
<p>If you’re confused by the proposal, no worries, let’s check out the release notes:</p><br />
<br />
<p>Transparent Monotonic Time support<br />
The time package now transparently tracks monotonic time in each Time value, making computing durations between two Time values a safe operation in the presence of wall clock adjustments. See the package docs and design document for details.</p><br />
<br />
<p>This changed the behavior of a number of Go packages, but, the core team knows best:</p><br />
<br />
<p>This is a breaking change, but more importantly, it wasn’t before the introduction of Go modules (declared “stable” as of Go 1.14) that you could require a certain Go version for a package.</p><br />
<br />
<p>So, if you have a package without a minimum required Go version, you can’t be sure you have the “transparent monotonic time support” of Go 1.9, and it’s better to rely on aristanetworks/goarista/monotime, which pulls 100+ packages, because Go packages are “simple” and they’re just folders in a git repository.</p><br />
<br />
<p>Cool bear’s hot tip<br />
It’s not just idletiming that depends on monotime.</p><br />
<br />
<p>As of the time of this writing, 266 publicly-avilable Go packages import it</p><br />
<br />
<p>and the pull in the hundred plus dependencies with it.<br />
The change raised other questions: since time.Time now sometimes packs two types of time, two calls are needed. This concern was dismissed.</p><br />
<br />
<p>In order for time.Time not to grow, both values were packed inside it, which restricted the range of times that could be represented with it:</p><br />
<br />
<p>This issue was raised early on in the design process:</p><br />
<br />
<p>You can check out the complete thread for a full history.</p><br />
<br />
<p>Parting words<br />
This is just one issue. But there are many like it - this one is as good an example as any.</p><br />
<br />
<p>Over and over, Go is a victim of its own mantra - “simplicity”.</p><br />
<br />
<p>It constantly takes power away from its users, reserving it for itself.</p><br />
<br />
<p>It constantly lies about how complicated real-world systems are, and optimize for the 90% case, ignoring correctness.</p><br />
<br />
<p>It is a minefield of subtle gotchas that have very real implications - everything looks simple on the surface, but nothing is.</p><br />
<br />
<p>The Channel Axioms are a good example. There is nothing explicit about them. They are invented truths, that were convenient to implement, and who everyone must now work around.</p><br />
<br />
<p>Here’s a fun gotcha I haven’t mentioned yet:</p><br />
<br />
<p>// IdleTimingConn is a net.Conn that wraps another net.Conn and that times out<br />
// if idle for more than idleTimeout.<br />
type IdleTimingConn struct {<br />
	// Keep 64-bit words at the top to make sure 64-bit alignment, see<br />
	// https://golang.org/pkg/sync/atomic/#pkg-note-BUG<br />
	lastActivityTime uint64</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// (cut) } The documentation reads:<br />
</code></pre></div></div><br />
<br />
<p>BUGS</p><br />
<br />
<p>On ARM, x86-32, and 32-bit MIPS, it is the caller’s responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned.</p><br />
<br />
<p>If the condition isn’t satisfied, it panics at run-time. Only on 32-bit platforms. I didn’t have to go far to hit this one - I got bit by this bug multiple times in the last few years.</p><br />
<br />
<p>It’s a footnote. Not a compile-time check. There’s an in-progress lint, for very simple cases, because Go’s simplicity made it extremely hard to check for.</p><br />
<br />
<p>This fake “simplicity” runs deep in the Go ecosystem. Rust has the opposite problem - things look scary at first, but it’s for a good reason. The problems tackled have inherent complexity, and it takes some effort to model them appropriately.</p><br />
<br />
<p>At this point in time, I deeply regret investing in Go.</p><br />
<br />
<p>Go is a Bell Labs fantasy, and not a very good one at that.</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>