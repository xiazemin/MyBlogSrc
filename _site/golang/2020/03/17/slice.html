<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">slice</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-03-17T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Mar 17, 2020</time></p>
					</div>
					 <p>https://kilabit.info/journal/2020/re-learning_slice/</p><br />
<br />
<!-- more --><br />
<p>Re-learning slice<br />
Shulhan<br />
15 March 2020<br />
Overview<br />
Back to the basic: What is an array?<br />
Array size is part of its type<br />
Arrays elements are zeroed<br />
Array are values<br />
What is slice?<br />
The backing storage<br />
Slicing slice<br />
Zeroing slice<br />
Slice gotchas<br />
Too much reallocation<br />
Unreleased memory allocation<br />
Taking advantages of gotchas<br />
References<br />
This article show how the slice works in Go language in practice, by using code examples which you can try by yourself.</p><br />
<br />
<p>The original source of this article is the following slide that I submit to GopherCon Singapore 2019,</p><br />
<br />
<p>Overview<br />
Most of the time we forgot or did not know how actually the slices works. Most of the time we just assume that slices is dynamic array. By relearning how slices works, we can possible avoid slice’s “gotcha” or take advantage of it. In this article we will review back how the slices works and maybe by knowing how it work we can write a better program.</p><br />
<br />
<p>The content of this article is not new, if you already read and understand Effective Go, The Go Programming Language Specification, and The Go Blog - Go Slices: usage and internals, most of the topics in here already discussed there. This article try to emphasis on code examples, learning by doing, step by step.</p><br />
<br />
<p>Back to the basic: What is an array?<br />
An array is sequence of value of single type with fixed size.</p><br />
<br />
<p>There are two elements needed to create an array: size and type. The size is defined inside the square bracket and the type is defined after the closing bracket.</p><br />
<br />
<p>ArrayType   = “[” ArrayLength “]” ElementType .<br />
ArrayLength = Expression .<br />
ElementType = Type .<br />
Array size is part of its type<br />
One of the first properties of array is the size of an array is part of its type.</p><br />
<br />
<p>x := [5]int{1, 2, 3}<br />
y := [5]int{3, 2, 1}<br />
z := [5]int{1, 2, 3}</p><br />
<br />
<p>fmt.Printf(“x == y: %v\n”, x == y) // false<br />
fmt.Printf(“x == z: %v\n”, x == z) // true<br />
In the above snippet, x, y, and z are array with size 5 and int as its type.</p><br />
<br />
<p>Array x have the same size with y but does not contains the same order of value, so if we compare them it will return false.</p><br />
<br />
<p>Array x have the same size with z and contains the same value in the same order, so if we compare them it will return true.</p><br />
<br />
<p>Let say that we have another array a with different size from x,</p><br />
<br />
<p>a := [4]int{1, 2, 3}<br />
If we try to compare them</p><br />
<br />
<p>fmt.Printf(“x == a: %v\n”, x == a)<br />
the compiler will thrown an error,</p><br />
<br />
<p>[…] invalid operation: x == a (mismatched types [5]int and [4]int)<br />
Out of curiosity, what would happen if we access address of array out of its range?</p><br />
<br />
<p>fmt.Printf(“out of bounds&gt; &amp;in[5]:%p\n”, &amp;in[5])<br />
The compiler will thrown an error at compile time,</p><br />
<br />
<p>./main_test.go:14:66: invalid array index 5 (out of bounds for 5-element array)<br />
Arrays elements are zeroed<br />
Once the array is created, all of its elements are set to its zero value.</p><br />
<br />
<p>in := [5]int{10, 20, 30}<br />
fmt.Printf(“contents &gt; in:%v\n”, in)<br />
// Output:<br />
// contents &gt; in:[10 20 30 0 0]<br />
In the above snippet, in is an array of int with size set to 5. The values for the first three elements at index 0, 1, 2 are set to 10, 20, 30 and the rest of values will be set to 0 by the compiler.</p><br />
<br />
<p>Array are values<br />
Assigning or passing an array to another array will copy all of its values.</p><br />
<br />
<p>To understand this let see the address of instance of array and its first value.</p><br />
<br />
<p>in := [5]int{1, 2, 3}<br />
fmt.Printf(“&amp;in:%p &amp;in[0]:%p &amp;in[1]:%p\n”, &amp;in, &amp;in[0], &amp;in[1])</p><br />
<br />
<p>// Output:<br />
// &amp;in:0xc0000122a0 &amp;in[0]:0xc0000122a0 &amp;in[1]:0xc0000122a8<br />
(Note: The %p format print the address of value in memory, and it will be different on each system.)</p><br />
<br />
<p>The address of array in can be accessed using &amp;in, and we got 0xc0000122a0. The address of first value can be accessed using &amp;in[0], and we got 0xc0000122a0. This means the address of instance of array and address of its first element is equal.</p><br />
<br />
<p>Now, what would happen if we pass an array to function?</p><br />
<br />
<p>func passArray(y [5]int) {<br />
	fmt.Printf(“&amp;y:%p\n”, &amp;y) // &amp;y:0x45e020<br />
	y[0] = 90<br />
	fmt.Printf(“y: %v\n”, y)  // y: [90 20 30 0 0]<br />
}</p><br />
<br />
<p>func main() {<br />
	x := [5]int{10, 20, 30}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("&amp;x:%p\n", &amp;x) // &amp;x:0x45e000<br />
<br />
passArray(x)<br />
<br />
fmt.Printf("x: %v\n", x) // x: [10 20 30 0 0] } Playground.<br />
</code></pre></div></div><br />
<br />
<p>Array x is created with address is 0xc00007a0f0. When we pass x to passArray() function, x values is copied to y. Array y is in different address 0xc00007a120 but have the same size and values as x. We can test this by changing the first value of y to 9 and print the x after call to passArray, the values in x does not affected by assignment in passArray() function.</p><br />
<br />
<p>So, x and y are two different arrays with the same size and values (on initial pass).</p><br />
<br />
<p>If we want passArray() function to be able to change the value that it received in y and the changes affected in x, we can pass x by using address and receive them by using pointer in y.</p><br />
<br />
<p>func passArray(y *[5]int) {<br />
	fmt.Printf(“y:%p\n”, y) // &amp;y:0x45e000<br />
	y[0] = 90<br />
	fmt.Printf(“y: %v\n”, y)  // y: [90 20 30 0 0]<br />
}</p><br />
<br />
<p>func main() {<br />
	x := [5]int{1, 2, 3}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("&amp;x:%p\n", &amp;x) // &amp;x:0x45e000<br />
<br />
passArray(&amp;x)<br />
<br />
fmt.Printf("x: %v\n", x) // x: [90 20 30 0 0] } Playground.<br />
</code></pre></div></div><br />
<br />
<p>Since y is a pointer to array of [5]int, we access the address without &amp;, and we can see that x and y now have the same address. Changing any value in y will affect x.</p><br />
<br />
<p>What is slice?<br />
In this section I will not discuss how to create slice, zero value of slice, growing slice, since most of article in Effective Go, and others tutorial already explain it in detail. Instead, we will do a reverse learning, or learning by doing.</p><br />
<br />
<p>From the go blog The Go Blog - Go Slices: usage and internals,</p><br />
<br />
<p>A slice is a descriptor of an array segment. It consists of a pointer to the array, the length of the segment, and its capacity (the maximum length of the segment).<br />
An attempt to rewrite slice with struct will result in linked-list.</p><br />
<br />
<p>type Slice struct {<br />
    Len int<br />
    Cap int<br />
    elements *Element<br />
}</p><br />
<br />
<p>Type Element struct {<br />
    next *Element<br />
}<br />
But instead of linked-list, Go internal use an array in *Element, or what we will call as backing storage of slice.</p><br />
<br />
<p>The backing storage<br />
To test this hypothesis let break then down one by one, first by printing their address.</p><br />
<br />
<p>func passSlice(xx []int) {<br />
	fmt.Printf(“xx&gt; &amp;xx:%p &amp;xx[0]:%p\n”, &amp;xx, &amp;xx[0])<br />
	fmt.Printf(“xx&gt; len:%d cap:%d\n”, len(xx), cap(xx))<br />
}</p><br />
<br />
<p>func main() {<br />
	x := []int{1, 2, 3}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("x&gt; &amp;x:%p &amp;x[0]:%p\n", &amp;x, &amp;x[0])<br />
fmt.Printf("x&gt; len:%d cap:%d\n", len(x), cap(x))<br />
<br />
passSlice(x) } Playground.<br />
</code></pre></div></div><br />
<br />
<p>It will print the following output,</p><br />
<br />
<p>x&gt; &amp;x:0x40a0e0 &amp;x[0]:0x40e020<br />
x&gt; len:3 cap:3<br />
xx&gt; &amp;xx:0x40a0f0 &amp;xx[0]:0x40e020<br />
xx&gt; len:3 cap:3<br />
Did you see the different? Go create new slice when passing it to function, but the backing storage is point to the same address. The address of x is different with xx, x and xx is different instance of slice with the same type. The address of first value of x and xx are same 0x40e020, that means x and xx share the same backing storage.</p><br />
<br />
<p>Of course both have the same length and capacity.</p><br />
<br />
<p>What would happen if we change the content of slice passed in function?</p><br />
<br />
<p>func sliceModifyByIndex(xx []int) {<br />
	xx[0] = 0<br />
}</p><br />
<br />
<p>func main() {<br />
	x := []int{1, 2, 3}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sliceModifyByIndex(x)<br />
<br />
fmt.Printf("%v\n", x) } Playground.<br />
</code></pre></div></div><br />
<br />
<p>Output,</p><br />
<br />
<p>[0 2 3]<br />
This confirm our hypothesis that slice share the same backing storage.</p><br />
<br />
<p>But wait, things are become more interesting. What would happen if we append a value to slice in function?</p><br />
<br />
<p>func sliceAppend(xx []int) {<br />
	xx = append(xx, 4)<br />
}</p><br />
<br />
<p>func main() {<br />
	x := []int{1, 2, 3}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sliceAppend(x)<br />
<br />
fmt.Printf("%v\n", x) } Playground.<br />
</code></pre></div></div><br />
<br />
<p>If you thought the output would be [1 2 3 4] you are wrong. The program will print [1 2 3].</p><br />
<br />
<p>What happened? Let see their addresses.</p><br />
<br />
<p>func sliceAppendAddress(xx []int) {<br />
	fmt.Printf(“xx before &gt; &amp;[0]:%p len:%d cap:%d\n”, &amp;xx[0], len(xx), cap(xx))<br />
	xx = append(xx, 4)<br />
	fmt.Printf(“xx after  &gt; &amp;[0]:%p len:%d cap:%d\n”, &amp;xx[0], len(xx), cap(xx))<br />
}</p><br />
<br />
<p>func main() {<br />
	x := []int{1, 2, 3}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("x before  &gt; &amp;[0]:%p len:%d cap:%d\n", &amp;x[0], len(x), cap(x))<br />
sliceAppendAddress(x)<br />
fmt.Printf("x after   &gt; &amp;[0]:%p len:%d cap:%d\n", &amp;x[0], len(x), cap(x)) }<br />
</code></pre></div></div><br />
<br />
<p>// Output:<br />
// x before  &gt; &amp;[0]:0x40e020 len:3 cap:3<br />
// xx before &gt; &amp;[0]:0x40e020 len:3 cap:3<br />
// xx after  &gt; &amp;[0]:0x456020 len:4 cap:8<br />
// x after   &gt; &amp;[0]:0x40e020 len:3 cap:3<br />
Playground.</p><br />
<br />
<p>Before we append the slice xx the length and capability of xx and x are same: 3. After we append new value to xx the backing storage of xx is changed, but the change does not affect the x. This means the backing storage of xx after append is different with backing storage of x. We can see this from the address of first value of xx that change from 0x40e020 to 0x456020, but the address of first value of x still the same as before and after the function is called.</p><br />
<br />
<p>So, the address change because in previous exercise the slice xx does not have enough capacity to add new item to backing storage.</p><br />
<br />
<p>What if we provide enough capacity and pass to function and let function append the slice again, there will be no allocation and backing storage still reference the same right?</p><br />
<br />
<p>func sliceAppend(xx []int) {<br />
	fmt.Printf(“xx before &gt; len:%d cap:%d\n”, len(xx), cap(xx))<br />
	xx = append(xx, 4)<br />
	fmt.Printf(“xx after  &gt; len:%d cap:%d\n”, len(xx), cap(xx))<br />
}</p><br />
<br />
<p>func main() {<br />
	x := make([]int, 0, 5)<br />
	x = append(x, 1, 2, 3) // [1 2 3]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("x before  &gt; len:%d cap:%d\n", len(x), cap(x))<br />
sliceAppend(x)<br />
fmt.Printf("x after   &gt; %v\n", x) }<br />
</code></pre></div></div><br />
<br />
<p>// Output:<br />
// x before  &gt; len:3 cap:5<br />
// xx before &gt; len:3 cap:5<br />
// xx after  &gt; len:4 cap:5<br />
// x after   &gt; [1 2 3]<br />
Playground.</p><br />
<br />
<p>Why? Remember that the variable xx in function is different with x at the outside. The length of xx is growing with append, but the length of x does not change.</p><br />
<br />
<p>Since the backing storage of xx is not reallocated (the capacity is large enough for new item), does the address of backing storage in xx change? Or equal with x?</p><br />
<br />
<p>func sliceAppend(xx []int) {<br />
	fmt.Printf(“&amp;xx[0] before:%p\n”, &amp;xx[0])<br />
	xx = append(xx, 4)<br />
	fmt.Printf(“&amp;xx[0] after :%p\n”, &amp;xx[0])<br />
}</p><br />
<br />
<p>func main() {<br />
	x := make([]int, 0, 5)<br />
	x = append(x, 1, 2, 3)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("&amp;x[0] before :%p\n", &amp;x[0])<br />
sliceAppendAddress(x)<br />
fmt.Printf("&amp;x[0] after  :%p\n", &amp;x[0]) }<br />
</code></pre></div></div><br />
<br />
<p>// Output:<br />
// &amp;x[0] before :0x456000<br />
// &amp;xx[0] before:0x456000<br />
// &amp;xx[0] after :0x456000<br />
// &amp;x[0] after  :0x456000<br />
Playground.</p><br />
<br />
<p>So both the address of x and xx does not change. But how come when we print x its output is [1 2 3] not [1 2 3 4]? Because printing x limited by their length.</p><br />
<br />
<p>To see the new value 4 in x, we can extend its length using x = x[:4],</p><br />
<br />
<p>func sliceAppend(xx []int) {<br />
	fmt.Printf(“xx before &gt; len:%d cap:%d\n”, len(xx), cap(xx))<br />
	xx = append(xx, 4)<br />
	fmt.Printf(“xx after  &gt; len:%d cap:%d\n”, len(xx), cap(xx))<br />
}</p><br />
<br />
<p>func main() {<br />
	x := make([]int, 0, 5)<br />
	x = append(x, 1, 2, 3) // [1 2 3]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("x before  &gt; len:%d cap:%d\n", len(x), cap(x))<br />
sliceAppend(x)<br />
x = x[:4]<br />
fmt.Printf("x after   &gt; %v\n", x)<br />
fmt.Printf("x after   &gt; len:%d cap:%d\n", len(x), cap(x)) }<br />
</code></pre></div></div><br />
<br />
<p>// Output:<br />
// x before  &gt; len:3 cap:5<br />
// xx before &gt; len:3 cap:5<br />
// xx after  &gt; len:4 cap:5<br />
// x after   &gt; [1 2 3 4]<br />
// x after   &gt; len:4 cap:5<br />
Playground.</p><br />
<br />
<p>What we have learned?</p><br />
<br />
<p>Slice passed by value</p><br />
<br />
<p>Unless the address in backing storage is not changed, the slice receiver can change the content of its referenced</p><br />
<br />
<p>If the address in backing storage changed, both receiver and caller/assigner will have different backing storage</p><br />
<br />
<p>Slicing slice<br />
Now, that we know how the slice works when passing to function, we got to the second point of relearning slices: slicing slice.</p><br />
<br />
<p>What is the output of this snippet?</p><br />
<br />
<p>s := []int{1, 2, 3, 4, 5, 6, 7}<br />
fmt.Printf(“s &gt; len:%d cap:%d\n”, len(s), cap(s))</p><br />
<br />
<p>ss := s[2:4]<br />
fmt.Printf(“ss&gt; len:%d cap:%d\n”, len(ss), cap(ss))</p><br />
<br />
<p>// s &gt; len:6 cap:7<br />
// ss&gt; len:? Cap:?<br />
// A. 2 2<br />
// B. 2 5<br />
// C. 2 7<br />
In the simplest form, the input for slicing a slice is</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T [ low : high ) which return the new slice, or the sub-slice.<br />
</code></pre></div></div><br />
<br />
<p>The sub-slice will contains parent elements start from low index and end with high index, exclusive. The length of sub-slice is set to high - low. The capability of sub-slice is set to cap(T) - low. If low is not defined, it will be default to 0. If high is not defined, it will be default to len(T).</p><br />
<br />
<p>If your answer to previous exercise is B. 2 5, you are correct.</p><br />
<br />
<p>In the full form, the input for slicing a slice have third parameter, max,</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ low : high : max ) This syntax only applicable for an array, pointer to array, or slice; but not a string.<br />
</code></pre></div></div><br />
<br />
<p>The result, sub-slice, is the same with simple form, but the sub-slice will have capacity set to max - low.</p><br />
<br />
<p>Address of sub-slice<br />
The next question is what is the address of sub-slice?</p><br />
<br />
<p>s := []int{10, 20, 30, 40, 50, 60, 70}<br />
fmt.Printf(“ &amp;s:%p  &amp;s[2]:%p\n”, &amp;s, &amp;s[2])</p><br />
<br />
<p>ss := s[2:4]<br />
fmt.Printf(“&amp;ss:%p &amp;ss[0]:%p\n”, &amp;ss, &amp;ss[0])</p><br />
<br />
<p>// &amp;s :0xc00000a0a0  &amp;s[2]:0xc000018250<br />
// &amp;ss:0xc00000a0c0 &amp;ss[0]:0xc000018250<br />
The sub-slice ss created by slicing s start from index 2 until 4 (values [30 40]). The address of index 2 in slice s is 0xc000018250 which is equal to the address of first value (index 0) in ss, 0xc000018250. This means that slice and its sub-slice share the same backing storage.</p><br />
<br />
<p>To prove this lets change the content of sub slice,</p><br />
<br />
<p>s := []int{10, 20, 30, 40, 50, 60, 70}<br />
ss := s[2:4]<br />
ss[0] = 80</p><br />
<br />
<p>fmt.Printf(“s :%v\n”, s)</p><br />
<br />
<p>// s :[10 20 80 40 50 60 70]<br />
When we change the value of index 0 in sub-slice ss to 80, the value in the slice s at index 2 (which point to the same address) is also change.</p><br />
<br />
<p>Appending to sub-slice<br />
In previous section we said that “slice and sub-slice share the same backing storage”, is it always true?</p><br />
<br />
<p>In the following example, we will append the new value to sub-slice and print the result of both original slice and its sub-slice.</p><br />
<br />
<p>s := []int{10, 20, 30, 40, 50, 60, 70}<br />
ss := s[2:4]</p><br />
<br />
<p>ss = append(ss, 80)</p><br />
<br />
<p>fmt.Printf(“ss after :%v\n”, ss)<br />
fmt.Printf(“s after  :%v\n”, s)</p><br />
<br />
<p>// ss after :[30 40 80]<br />
// s after  :[10 20 30 40 80 60 70]<br />
Surprise?</p><br />
<br />
<p>This is what happened,</p><br />
<br />
<p>func main() {<br />
	s := []int{10, 20, 30, 40, 50, 60, 70}<br />
	ss := s[2:4]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("s  before  &amp;s[2]:%p len:%d cap:%d values:%v\n", &amp;s[2], len(s), cap(s), s)<br />
fmt.Printf("ss before &amp;ss[0]:%p len:%d cap:%d values:%v\n", &amp;ss[0], len(ss), cap(ss), ss)<br />
<br />
ss = append(ss, 80)<br />
<br />
fmt.Printf("s  after  &amp;s[2]:%p len:%d cap:%d values:%v\n", &amp;s[2], len(s), cap(s), s)<br />
fmt.Printf("ss after &amp;ss[0]:%p len:%d cap:%d values:%v\n", &amp;ss[0], len(ss), cap(ss), ss) }<br />
</code></pre></div></div><br />
<br />
<p>// Output:<br />
// s  before  &amp;s[2]:0x45e008 len:7 cap:7 values:[10 20 30 40 50 60 70]<br />
// ss before &amp;ss[0]:0x45e008 len:2 cap:5 values:[30 40]<br />
// s  after  &amp;s[2]:0x45e008 len:7 cap:7 values:[10 20 30 40 80 60 70]<br />
// ss after &amp;ss[0]:0x45e008 len:3 cap:5 values:[30 40 80]<br />
Playground.</p><br />
<br />
<p>The length of sub-slice ss is 2 and its capability is 5, so append only write the appended value 80 into index 2 (the length) and increase the len to len+1 because the sub-slice ss have enough backing storage for new item.</p><br />
<br />
<p>What would happened if we grow the sub-slice beyond its capacity?</p><br />
<br />
<p>func main() {<br />
	s := []int{10, 20, 30, 40, 50, 60, 70}<br />
	ss := s[2:4]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Printf("s  before  &amp;s[2]:%p len:%d cap:%d values:%v\n", &amp;s[2], len(s), cap(s), s)<br />
fmt.Printf("ss before &amp;ss[0]:%p len:%d cap:%d values:%v\n", &amp;ss[0], len(ss), cap(ss), ss)<br />
<br />
ss = append(ss, 80, 90, 100, 110)<br />
<br />
fmt.Printf("s  after   &amp;s[2]:%p len:%d cap:%d values:%v\n", &amp;s[2], len(s), cap(s), s)<br />
fmt.Printf("ss after  &amp;ss[0]:%p len:%d cap:%d values:%v\n", &amp;ss[0], len(ss), cap(ss), ss) }<br />
</code></pre></div></div><br />
<br />
<p>// Output:<br />
// s  before  &amp;s[2]:0x456008 len:7 cap:7 values:[10 20 30 40 50 60 70]<br />
// ss before &amp;ss[0]:0x456008 len:2 cap:5 values:[30 40]<br />
// s  after   &amp;s[2]:0x456008 len:7 cap:7 values:[10 20 30 40 50 60 70]<br />
// ss after  &amp;ss[0]:0x454030 len:6 cap:12 values:[30 40 80 90 100 110]<br />
Playground.</p><br />
<br />
<p>Once the slice is growing beyond their capacity, Go will reallocated new backing storage, copy the old value to new backing stroage, and update the backing storage of ss to new one. The sub-slice ss now use new backing storage, different with s.</p><br />
<br />
<p>What we have learned?</p><br />
<br />
<p>Sub-slice initial element address is pointer to their original slice</p><br />
<br />
<p>Unless the backing storage is not changed, the sub-slice can change the content that its referenced</p><br />
<br />
<p>If the backing storage in sub-slice changed, both original slice and sub-slice will have different backing storage</p><br />
<br />
<p>Zeroing slice<br />
What is the best way to reset slice to zero? Is it s = nil or s = [:0]?</p><br />
<br />
<p>First, lets look how nil behave.</p><br />
<br />
<p>s := []int{1, 2, 3}<br />
fmt.Printf(“s&gt; len:%d cap:%d &amp;[0]:%p\n”, len(s), cap(s), &amp;s[0])</p><br />
<br />
<p>s = nil<br />
fmt.Printf(“s&gt; len:%d cap:%d\n”, len(s), cap(s))</p><br />
<br />
<p>s = append(s, 4)<br />
fmt.Printf(“s&gt; len:%d cap:%d &amp;[0]:%p\n”, len(s), cap(s), &amp;s[0])</p><br />
<br />
<p>// Output:<br />
// s&gt; len:3 cap:3 &amp;[0]:0xc0000ac040<br />
// s&gt; len:0 cap:0<br />
// s&gt; len:1 cap:1 &amp;[0]:0xc00007e0e8<br />
The first backing storage of s have and address at 0xc0000ac040, and after we nil it and append new item, the backing storage change. So, this means nil-ing a slice will release the previous backing storage and create new backing storage when we append new item.</p><br />
<br />
<p>Second, we look how sub-slicing with cap 0.</p><br />
<br />
<p>s := []int{1, 2, 3}<br />
fmt.Printf(“s&gt; len:%d cap:%d &amp;[0]:%p\n”, len(s), cap(s), &amp;s[0])</p><br />
<br />
<p>s = s[:0]<br />
fmt.Printf(“s&gt; len:%d cap:%d\n”, len(s), cap(s))</p><br />
<br />
<p>s = append(s, 4)<br />
fmt.Printf(“s&gt; len:%d cap:%d &amp;[0]:%p\n”, len(s), cap(s), &amp;s[0])<br />
fmt.Printf(“s&gt; %v\n”, s)</p><br />
<br />
<p>// s&gt; len:3 cap:3 &amp;[0]:0xc0000144c0<br />
// s&gt; len:0 cap:3<br />
// s&gt; len:1 cap:3 &amp;[0]:0xc0000144c0<br />
// s&gt; [4]<br />
Zeroing slice using [:0] reset the length to zero and keep and backing storage.</p><br />
<br />
<p>Concolusion</p><br />
<br />
<p>The answer to above question is depends on how you use the slice,</p><br />
<br />
<p>use nil if we want to release slice’s (and its backing storage),</p><br />
<br />
<p>use [:0] if we want to keep the slice backing storage, to minimize reallocation.</p><br />
<br />
<p>Slice gotchas<br />
In this section we look what are commons mistake that we do when using slice.</p><br />
<br />
<p>Too much reallocation<br />
Calling multiple append() on slices values may cause memory re-allocation.</p><br />
<br />
<p>In this example we print the length and capability of slice before and appending the slice.</p><br />
<br />
<p>func doX(in []int) (out []int){<br />
    for _, v := range in {<br />
    	fmt.Printf(“before&gt; out len:%d cap:%d\n”, len(out), cap(out))<br />
        out = append(out, v)<br />
    	fmt.Printf(“after &gt; out len:%d cap:%d\n”, len(out), cap(out))<br />
    }<br />
    return out<br />
}</p><br />
<br />
<p>doX([]int{1,2,3,4,5})<br />
We found that doX do 4 reallocation to slice out,</p><br />
<br />
<p>// Output: 4 re-allocation<br />
before&gt; out len:0 cap:0<br />
after &gt; out len:1 cap:1<br />
before&gt; out len:1 cap:1<br />
after &gt; out len:2 cap:2<br />
before&gt; out len:2 cap:2<br />
after &gt; out len:3 cap:4<br />
before&gt; out len:3 cap:4<br />
after &gt; out len:4 cap:4<br />
before&gt; out len:4 cap:4<br />
after &gt; out len:5 cap:8<br />
The slice out backing storage growth from 0 to 1, 2, 4, and 8.</p><br />
<br />
<p>To minimize this we can allocate the capability to the possible maximum values that we may know. Since we know that out will at least take all length of in, we can allocate the initialize storage to len(in),</p><br />
<br />
<p>func doX(in []int) (out []int){<br />
    out = make([]int, 0, len(in))<br />
    for _, v := range in {<br />
        out = append(out, v)<br />
    }<br />
    return out<br />
}<br />
doX([]int{1,2,3,4,5})<br />
The allocation decrease to 1 (on initial make),</p><br />
<br />
<p>// Output: 1 allocation<br />
before&gt; out len:0 cap:5<br />
after &gt; out len:1 cap:5<br />
before&gt; out len:1 cap:5<br />
after &gt; out len:2 cap:5<br />
before&gt; out len:2 cap:5<br />
after &gt; out len:3 cap:5<br />
before&gt; out len:3 cap:5<br />
after &gt; out len:4 cap:5<br />
before&gt; out len:4 cap:5<br />
after &gt; out len:5 cap:5<br />
The good news is we have static analysis tool for that: prealloc.</p><br />
<br />
<p>Unreleased memory allocation<br />
A quote from go blog,</p><br />
<br />
<p>re-slicing a slice doesn’t make a copy of the underlying array. The full array will be kept in memory until it is no longer referenced. Occasionally this can cause the program to hold all the data in memory when only a small piece of it is needed.<br />
— Andrew Gerrand<br />
The Go Blog - Go Slices: usage and internals<br />
Given the following slicing statement,</p><br />
<br />
<p>msg.id = packet[0:4]<br />
Memory allocated by packet will not released until msg.id get nil-ed or msg itself has no reference.</p><br />
<br />
<p>I avoid the term “memory leak” here, because technically part of the memory content is still in use, but not whole of it. The term “memory leak” is when we allocated it but forgot to free-it.</p><br />
<br />
<p>Just like reading Term of Services, sometimes we skip reading the content and looking only how to do X while forgot the internal detail.</p><br />
<br />
<p>Bad news is, AFAIK, there is no static analysis tool to help us with it. Your best friend right now is pprof.</p><br />
<br />
<p>Taking advantages of gotchas<br />
If we knew that the original slices is cacheable or reusable, we can take advantage of it to minimize memory usage.</p><br />
<br />
<p>Case example, assume that we have a cacheable packet, that need to be parsed, checked, and validated; we can reuse the content by sub-slicing it.</p><br />
<br />
<p>Assume that a packet is sequences of characters with the following format,</p><br />
<br />
<p>key:value<br />
we create a struct to store the key and value,</p><br />
<br />
<p>type Field struct {<br />
    Key []byte<br />
    Value []byte<br />
}<br />
Common approaches when parsing it is by appending it one by one, and each Field’s key and name will allocated new slices.</p><br />
<br />
<p>field := Field{}<br />
packet := []byte(“key:value”)</p><br />
<br />
<p>for _, c := range packet {<br />
	if c == ‘:’ {<br />
		break<br />
	}<br />
	field.Key = append(field.Key, c)<br />
}<br />
field.Value = append(field.Value, packet[len(field.Key)+1:]…)</p><br />
<br />
<p>fmt.Printf(“Key: %s len:%d cap:%d\n”, field.Key, len(field.Key), cap(field.Key))<br />
fmt.Printf(“Value: %s len:%d cap:%d\n”, field.Value, len(field.Value), cap(field.Value))</p><br />
<br />
<p>fmt.Printf(“packet storage: %p\n”, &amp;packet[0])<br />
fmt.Printf(“field.Key storage: %p\n”, &amp;field.Key[0])<br />
fmt.Printf(“field.Value storage: %p\n”, &amp;field.Value[0])</p><br />
<br />
<p>// Key: key len:3 cap:8<br />
// Value: value len:5 cap:8<br />
// packet storage: 0x40e020<br />
// field.Key storage: 0x40e030<br />
// field.Value storage: 0x40e038<br />
In this approach the backing storage for packet, Key, and Value are different, and we have 4 * 2 re-allocation.</p><br />
<br />
<p>An alternative to minimize memory allocation is to use the original backing array and point the Field Key and Value into it.</p><br />
<br />
<p>var x := 0<br />
// Get the beginning and end of index key<br />
for ; x &lt; len(packet); x++ {<br />
	if packet[x] == ‘:’<br />
		break<br />
	}<br />
}</p><br />
<br />
<p>field.Key = packet[:x]<br />
field.Value = packet[x+1:]<br />
With this approach all of the slice use single backing storage.</p><br />
<br />
<p>slices_gotcha_subslicing_original</p><br />
<br />
<p>Remember, using this approach require a careful attention on where the instance of Field go and released.</p><br />
<br />
<p>References<br />
[EFF-GO] The Go Authors, “Effective Go”, https://golang.org/doc/effective_go.html, February 2019.</p><br />
<br />
<p>[GO-SPEC] The Go Authors, “The Go Programming Language Specification”, https://golang.org/ref/spec, May 2018.</p><br />
<br />
<p>[GO-BLOG] Gerrand, Andrew, “The Go Blog - Go Slices: usage and internals”, https://blog.golang.org/go-slices-usage-and-internals, January 2011.</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>