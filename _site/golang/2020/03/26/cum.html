<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">flat cum sum pprof文本输出的含义</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-03-26T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Mar 26, 2020</time></p>
					</div>
					 <p>pprof函数耗时的文本输出，其中前几行比较容易理解，其说明了显示出来的函数耗时总计占用了5.73s，而全部耗时为6.21秒，所以显示出来的函数耗时占总体的92.27%，其中有cum耗时小于0.03秒的67个函数耗时被丢弃而未予显示。</p><br />
<br />
<p>(pprof) top78<br />
 Showing nodes accounting for 5.73s, 92.27% of 6.21s total<br />
 Dropped 67 nodes (cum &lt;= 0.03s)<br />
 Showing top 78 nodes out of 79<br />
     flat  flat%  sum%       cum  cum%<br />
    4.14s 66.67% 66.67%     4.14s 66.67%  runtime.kevent /usr/local/go/src/runtime/sys_darwin_amd64.s<br />
    0.52s  8.37% 75.04%     0.52s  8.37% runtime.mach_semaphore_signal /usr/local/go/src/runtime/sys_darwin_amd64.s<br />
    0.34s  5.48% 80.52%     0.34s  5.48% runtime.mach_semaphore_timedwait /usr/local/go/src/runtime/sys_darwin_amd64.s<br />
    0.17s  2.74% 83.25%     0.17s  2.74% runtime.mach_semaphore_wait /usr/local/go/src/runtime/sys_darwin_amd64.s<br />
    0.13s  2.09% 85.35%     0.13s  2.09%  runtime.scanstack /usr/local/go/src/runtime/mgcmark.go<br />
    0.07s  1.13% 86.47%     0.07s  1.13%  runtime.memmove /usr/local/go/src/runtime/memmove_amd64.s<br />
    0.06s  0.97% 87.44%     0.06s  0.97%  runtime.usleep /usr/local/go/src/runtime/sys_darwin_amd64.s</p><br />
<br />
<p>接下来的一大坨文本涉及到了这样几列字段：flat和flat%、sum%、cum和cum%，其中flat代表的是该函数自身代码的执行时长，而cum代表的是该函数自身代码+所有调用的函数的执行时长。这样解释可能不太直观，我们以下面的例子来说明，函数b由三部分组成：调用函数c、自己直接处理一些事情、调用函数d，其中调用函数c耗时1秒，自己直接处理事情耗时3秒，调用函数d耗时2秒，那么函数b的flat耗时就是3秒，cum耗时就是6秒。</p><br />
<br />
<p>func b() {<br />
    c() // takes 1s<br />
    do something directly // takes 3s<br />
    d() // takes 2s<br />
}</p><br />
<br />
<p>至于flat%和cum%指的就是flat耗时和cum耗时占总耗时（也就是6.21秒）的百分比，而最后一个sum%指的就是每一行的flat%与上面所有行的flat%总和，代表从上到下的累计值，比如第二行的75.04%就等于第一行flat%的66.67%+本行flat%的8.37%，下面的以此类推<br />
<!-- more --><br />
https://github.com/Shitaibin/golang_step_by_step/tree/master/pprof<br />
https://segmentfault.com/a/1190000019222661?utm_source=tag-newest</p><br />
<br />
<p>关于Go的内存泄露有这么一句话不知道你听过没有：</p><br />
<br />
<p>10次内存泄露，有9次是goroutine泄露。<br />
我所解决的问题，也是goroutine泄露导致的内存泄露，所以这篇文章主要介绍Go程序的goroutine泄露，掌握了如何定位和解决goroutine泄露，就掌握了内存泄露的大部分场景。</p><br />
<br />
<p>本文草稿最初数据都是生产坏境数据，为了防止敏感内容泄露，全部替换成了demo数据，demo的数据比生产环境数据简单多了，更适合入门理解，有助于掌握pprof。<br />
go pprof基本知识<br />
定位goroutine泄露会使用到pprof，pprof是Go的性能工具，在开始介绍内存泄露前，先简单介绍下pprof的基本使用，更详细的使用给大家推荐了资料。</p><br />
<br />
<p>什么是pprof<br />
pprof是Go的性能分析工具，在程序运行过程中，可以记录程序的运行信息，可以是CPU使用情况、内存使用情况、goroutine运行情况等，当需要性能调优或者定位Bug时候，这些记录的信息是相当重要。</p><br />
<br />
<p>基本使用<br />
使用pprof有多种方式，Go已经现成封装好了1个：net/http/pprof，使用简单的几行命令，就可以开启pprof，记录运行信息，并且提供了Web服务，能够通过浏览器和命令行2种方式获取运行数据。</p><br />
<br />
<p>看个最简单的pprof的例子：</p><br />
<br />
<p>文件：golang_step_by_step/pprof/pprof/demo.go</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “net/http”<br />
    _ “net/http/pprof”<br />
)</p><br />
<br />
<p>func main() {<br />
    // 开启pprof，监听请求<br />
    ip := “0.0.0.0:6060”<br />
    if err := http.ListenAndServe(ip, nil); err != nil {<br />
        fmt.Printf(“start pprof failed on %s\n”, ip)<br />
    }<br />
}<br />
提醒：本文所有代码部分可左右滑动</p><br />
<br />
<p>浏览器方式<br />
image-20190516173924325</p><br />
<br />
<p>输入网址ip:port/debug/pprof/打开pprof主页，从上到下依次是5类profile信息：</p><br />
<br />
<p>block：goroutine的阻塞信息，本例就截取自一个goroutine阻塞的demo，但block为0，没掌握block的用法<br />
goroutine：所有goroutine的信息，下面的full goroutine stack dump是输出所有goroutine的调用栈，是goroutine的debug=2，后面会详细介绍。<br />
heap：堆内存的信息<br />
mutex：锁的信息<br />
threadcreate：线程信息<br />
这篇文章我们主要关注goroutine和heap，这两个都会打印调用栈信息，goroutine里面还会包含goroutine的数量信息，heap则是内存分配信息，本文用不到的地方就不展示了，最后推荐几篇文章大家去看。</p><br />
<br />
<p>命令行方式<br />
当连接在服务器终端上的时候，是没有浏览器可以使用的，Go提供了命令行的方式，能够获取以上5类信息，这种方式用起来更方便。</p><br />
<br />
<p>使用命令go tool pprof url可以获取指定的profile文件，此命令会发起http请求，然后下载数据到本地，之后进入交互式模式，就像gdb一样，可以使用命令查看运行信息，以下是5类请求的方式：</p><br />
<br />
<h1 id="下载cpu-profile默认从当前开始收集30s的cpu使用情况需要等待30s">下载cpu profile，默认从当前开始收集30s的cpu使用情况，需要等待30s</h1><br />
<p>go tool pprof http://localhost:6060/debug/pprof/profile   # 30-second CPU profile<br />
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=120     # wait 120s</p><br />
<br />
<h1 id="下载heap-profile">下载heap profile</h1><br />
<p>go tool pprof http://localhost:6060/debug/pprof/heap      # heap profile</p><br />
<br />
<h1 id="下载goroutine-profile">下载goroutine profile</h1><br />
<p>go tool pprof http://localhost:6060/debug/pprof/goroutine # goroutine profile</p><br />
<br />
<h1 id="下载block-profile">下载block profile</h1><br />
<p>go tool pprof http://localhost:6060/debug/pprof/block     # goroutine blocking profile</p><br />
<br />
<h1 id="下载mutex-profile">下载mutex profile</h1><br />
<p>go tool pprof http://localhost:6060/debug/pprof/mutex<br />
上面的pprof/demo.go太简单了，如果去获取内存profile，几乎获取不到什么，换一个Demo进行内存profile的展示：</p><br />
<br />
<p>文件：golang_step_by_step/pprof/heap/demo2.go</p><br />
<br />
<p>// 展示内存增长和pprof，并不是泄露<br />
package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “net/http”<br />
    _ “net/http/pprof”<br />
    “os”<br />
    “time”<br />
)</p><br />
<br />
<p>// 运行一段时间：fatal error: runtime: out of memory<br />
func main() {<br />
    // 开启pprof<br />
    go func() {<br />
        ip := “0.0.0.0:6060”<br />
        if err := http.ListenAndServe(ip, nil); err != nil {<br />
            fmt.Printf(“start pprof failed on %s\n”, ip)<br />
            os.Exit(1)<br />
        }<br />
    }()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tick := time.Tick(time.Second / 100)<br />
var buf []byte<br />
for range tick {<br />
    buf = append(buf, make([]byte, 1024*1024)...)<br />
} } 上面这个demo会不断的申请内存，把它编译运行起来，然后执行：<br />
</code></pre></div></div><br />
<br />
<p>$ go tool pprof http://localhost:6060/debug/pprof/heap</p><br />
<br />
<p>Fetching profile over HTTP from http://localhost:6060/debug/pprof/heap<br />
Saved profile in /home/ubuntu/pprof/pprof.demo.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz       //&lt;— 下载到的内存profile文件<br />
File: demo // 程序名称<br />
Build ID: a9069a125ee9c0df3713b2149ca859e8d4d11d5a<br />
Type: inuse_space<br />
Time: May 16, 2019 at 8:55pm (CST)<br />
Entering interactive mode (type “help” for commands, “o” for options)<br />
(pprof)<br />
(pprof)<br />
(pprof) help  // 使用help打印所有可用命令<br />
  Commands:<br />
    callgrind        Outputs a graph in callgrind format<br />
    comments         Output all profile comments<br />
    disasm           Output assembly listings annotated with samples<br />
    dot              Outputs a graph in DOT format<br />
    eog              Visualize graph through eog<br />
    evince           Visualize graph through evince<br />
    gif              Outputs a graph image in GIF format<br />
    gv               Visualize graph through gv<br />
    kcachegrind      Visualize report in KCachegrind<br />
    list             Output annotated source for functions matching regexp<br />
    pdf              Outputs a graph in PDF format<br />
    peek             Output callers/callees of functions matching regexp<br />
    png              Outputs a graph image in PNG format<br />
    proto            Outputs the profile in compressed protobuf format<br />
    ps               Outputs a graph in PS format<br />
    raw              Outputs a text representation of the raw profile<br />
    svg              Outputs a graph in SVG format<br />
    tags             Outputs all tags in the profile<br />
    text             Outputs top entries in text form<br />
    top              Outputs top entries in text form<br />
    topproto         Outputs top entries in compressed protobuf format<br />
    traces           Outputs all profile samples in text form<br />
    tree             Outputs a text rendering of call graph<br />
    web              Visualize graph through web browser<br />
    weblist          Display annotated source in a web browser<br />
    o/options        List options and their current values<br />
    quit/exit/^D     Exit pprof</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.... 以上信息我们只关注2个地方：<br />
</code></pre></div></div><br />
<br />
<p>下载得到的文件：/home/ubuntu/pprof/pprof.demo.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz，这其中包含了程序名demo，profile类型alloc已分配的内存，inuse代表使用中的内存。<br />
help可以获取帮助，最先会列出支持的命令，想掌握pprof，要多看看，多尝试。<br />
关于命令，本文只会用到3个，我认为也是最常用的：top、list、traces，分别介绍一下。</p><br />
<br />
<p>top<br />
按指标大小列出前10个函数，比如内存是按内存占用多少，CPU是按执行时间多少。</p><br />
<br />
<p>(pprof) top<br />
Showing nodes accounting for 814.62MB, 100% of 814.62MB total<br />
      flat  flat%   sum%        cum   cum%<br />
  814.62MB   100%   100%   814.62MB   100%  main.main<br />
         0     0%   100%   814.62MB   100%  runtime.main<br />
top会列出5个统计数据：</p><br />
<br />
<p>flat: 本函数占用的内存量。<br />
flat%: 本函数内存占使用中内存总量的百分比。<br />
sum%: 前面每一行flat百分比的和，比如第2行虽然的100% 是 100% + 0%。<br />
cum: 是累计量，加入main函数调用了函数f，函数f占用的内存量，也会记进来。<br />
cum%: 是累计量占总量的百分比。<br />
list<br />
查看某个函数的代码，以及该函数每行代码的指标信息，如果函数名不明确，会进行模糊匹配，比如list main会列出main.main和runtime.main。</p><br />
<br />
<p>(pprof) list main.main  // 精确列出函数<br />
Total: 814.62MB<br />
ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.go<br />
  814.62MB   814.62MB (flat, cum)   100% of Total<br />
         .          .     20:    }()<br />
         .          .     21:<br />
         .          .     22:    tick := time.Tick(time.Second / 100)<br />
         .          .     23:    var buf []byte<br />
         .          .     24:    for range tick {<br />
  814.62MB   814.62MB     25:        buf = append(buf, make([]byte, 1024*1024)…)<br />
         .          .     26:    }<br />
         .          .     27:}<br />
         .          .     28:<br />
(pprof) list main  // 匹配所有函数名带main的函数<br />
Total: 814.62MB<br />
ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.go<br />
  814.62MB   814.62MB (flat, cum)   100% of Total<br />
         .          .     20:    }()<br />
         .          .     21:<br />
….. // 省略几行<br />
         .          .     28:<br />
ROUTINE ======================== runtime.main in /usr/lib/go-1.10/src/runtime/proc.go<br />
         0   814.62MB (flat, cum)   100% of Total<br />
         .          .    193:        // A program compiled with -buildmode=c-archive or c-shared<br />
….. // 省略几行<br />
可以看到在main.main中的第25行占用了814.62MB内存，左右2个数据分别是flat和cum，含义和top中解释的一样。</p><br />
<br />
<p>traces<br />
打印所有调用栈，以及调用栈的指标信息。</p><br />
<br />
<p>(pprof) traces<br />
File: demo2<br />
Type: inuse_space<br />
Time: May 16, 2019 at 7:08pm (CST)<br />
———–+——————————————————-<br />
     bytes:  813.46MB<br />
  813.46MB   main.main<br />
             runtime.main<br />
———–+——————————————————-<br />
     bytes:  650.77MB<br />
         0   main.main<br />
             runtime.main<br />
……. // 省略几十行<br />
每个- - - - - 隔开的是一个调用栈，能看到runtime.main调用了main.main，并且main.main中占用了813.46MB内存。</p><br />
<br />
<p>其他的profile操作和内存是类似的，这里就不展示了。</p><br />
<br />
<p>这里只是简单介绍本文用到的pprof的功能，pprof功能很强大，也经常和benchmark结合起来，但这不是本文的重点，所以就不多介绍了，为大家推荐几篇文章，一定要好好研读、实践：</p><br />
<br />
<p>Go官方博客关于pprof的介绍，很详细，也包含样例，可以实操：Profiling Go Programs。<br />
跟煎鱼也讨论过pprof，煎鱼的这篇文章也很适合入门： Golang 大杀器之性能剖析 PProf。<br />
什么是内存泄露<br />
内存泄露指的是程序运行过程中已不再使用的内存，没有被释放掉，导致这些内存无法被使用，直到程序结束这些内存才被释放的问题。</p><br />
<br />
<p>Go虽然有GC来回收不再使用的堆内存，减轻了开发人员对内存的管理负担，但这并不意味着Go程序不再有内存泄露问题。在Go程序中，如果没有Go语言的编程思维，也不遵守良好的编程实践，就可能埋下隐患，造成内存泄露问题。</p><br />
<br />
<p>怎么发现内存泄露<br />
在Go中发现内存泄露有2种方法，一个是通用的监控工具，另一个是go pprof：</p><br />
<br />
<p>监控工具：固定周期对进程的内存占用情况进行采样，数据可视化后，根据内存占用走势（持续上升），很容易发现是否发生内存泄露。<br />
go pprof：适合没有监控工具的情况，使用Go提供的pprof工具判断是否发生内存泄露。<br />
这2种方式分别介绍一下。</p><br />
<br />
<p>监控工具查看进程内在占用情况<br />
如果使用云平台部署Go程序，云平台都提供了内存查看的工具，可以查看OS的内存占用情况和某个进程的内存占用情况，比如阿里云，我们在1个云主机上只部署了1个Go服务，所以OS的内存占用情况，基本是也反映了进程内存占用情况，OS内存占用情况如下，可以看到随着时间的推进，内存的占用率在不断的提高，这是内存泄露的最明显现象：</p><br />
<br />
<p>image-20190512111200988</p><br />
<br />
<p>如果没有云平台这种内存监控工具，可以制作一个简单的内存记录工具。</p><br />
<br />
<p>1、建立一个脚本prog_mem.sh，获取进程占用的物理内存情况，脚本内容如下：</p><br />
<br />
<p>#!/bin/bash<br />
prog_name=”your_programe_name”<br />
prog_mem=$(pidstat  -r -u -h -C $prog_name |awk ‘NR==4{print $12}’)<br />
time=$(date “+%Y-%m-%d %H:%M:%S”)<br />
echo $time”\tmemory(Byte)\t”$prog_mem »~/record/prog_mem.log<br />
2、然后使用crontab建立定时任务，每分钟记录1次。使用crontab -e编辑crontab配置，在最后增加1行：</p><br />
<br />
<p>*/1 * * * * ~/record/prog_mem.sh<br />
脚本输出的内容保存在prog_mem.log，只要大体浏览一下就可以发现内存的增长情况，判断是否存在内存泄露。如果需要可视化，可以直接黏贴prog_mem.log内容到Excel等表格工具，绘制内存占用图。</p><br />
<br />
<p>image-20190512172935195</p><br />
<br />
<p>go pprof发现存在内存问题<br />
有情提醒：如果对pprof不了解，可以先看go pprof基本知识，这是下一节，看完再倒回来看。<br />
如果你Google或者百度，Go程序内存泄露的文章，它总会告诉你使用pprof heap，能够生成漂亮的调用路径图，火焰图等等，然后你根据调用路径就能定位内存泄露问题，我最初也是对此深信不疑，尝试了若干天后，只是发现内存泄露跟某种场景有关，根本找不到内存泄露的根源，如果哪位朋友用heap就能定位内存泄露的线上问题，麻烦介绍下。</p><br />
<br />
<p>后来读了Dave的《High Performance Go Workshop》，刷新了对heap的认识，内存pprof的简要内容如下：</p><br />
<br />
<p>image-20190512114048868</p><br />
<br />
<p>Dave讲了以下几点：</p><br />
<br />
<p>内存profiling记录的是堆内存分配的情况，以及调用栈信息，并不是进程完整的内存情况，猜测这也是在go pprof中称为heap而不是memory的原因。<br />
栈内存的分配是在调用栈结束后会被释放的内存，所以并不在内存profile中。<br />
内存profiling是基于抽样的，默认是每1000次堆内存分配，执行1次profile记录。<br />
因为内存profiling是基于抽样和它跟踪的是已分配的内存，而不是使用中的内存，（比如有些内存已经分配，看似使用，但实际以及不使用的内存，比如内存泄露的那部分），所以不能使用内存profiling衡量程序总体的内存使用情况。<br />
Dave个人观点：使用内存profiling不能够发现内存泄露。<br />
基于目前对heap的认知，我有2个观点：</p><br />
<br />
<p>heap能帮助我们发现内存问题，但不一定能发现内存泄露问题，这个看法与Dave是类似的。heap记录了内存分配的情况，我们能通过heap观察内存的变化，增长与减少，内存主要被哪些代码占用了，程序存在内存问题，这只能说明内存有使用不合理的地方，但并不能说明这是内存泄露。<br />
heap在帮助定位内存泄露原因上贡献的力量微乎其微。如第一条所言，能通过heap找到占用内存多的位置，但这个位置通常不一定是内存泄露，就算是内存泄露，也只是内存泄露的结果，并不是真正导致内存泄露的根源。<br />
接下来，我介绍怎么用heap发现问题，然后再解释为什么heap几乎不能定位内存泄露的根因。</p><br />
<br />
<p>怎么用heap发现内存问题<br />
使用pprof的heap能够获取程序运行时的内存信息，在程序平稳运行的情况下，每个一段时间使用heap获取内存的profile，然后使用base能够对比两个profile文件的差别，就像diff命令一样显示出增加和减少的变化，使用一个简单的demo来说明heap和base的使用，依然使用demo2进行展示。</p><br />
<br />
<p>文件：golang_step_by_step/pprof/heap/demo2.go</p><br />
<br />
<p>// 展示内存增长和pprof，并不是泄露<br />
package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “net/http”<br />
    _ “net/http/pprof”<br />
    “os”<br />
    “time”<br />
)</p><br />
<br />
<p>// 运行一段时间：fatal error: runtime: out of memory<br />
func main() {<br />
    // 开启pprof<br />
    go func() {<br />
        ip := “0.0.0.0:6060”<br />
        if err := http.ListenAndServe(ip, nil); err != nil {<br />
            fmt.Printf(“start pprof failed on %s\n”, ip)<br />
            os.Exit(1)<br />
        }<br />
    }()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tick := time.Tick(time.Second / 100)<br />
var buf []byte<br />
for range tick {<br />
    buf = append(buf, make([]byte, 1024*1024)...)<br />
} } 将上面代码运行起来，执行以下命令获取profile文件，Ctrl-D退出，1分钟后再获取1次。<br />
</code></pre></div></div><br />
<br />
<p>go tool pprof http://localhost:6060/debug/pprof/heap<br />
我已经获取到了两个profile文件：</p><br />
<br />
<p>$ ls<br />
pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz<br />
pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.002.pb.gz<br />
使用base把001文件作为基准，然后用002和001对比，先执行top看top的对比，然后执行list main列出main函数的内存对比，结果如下：</p><br />
<br />
<p>$ go tool pprof -base pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.001.pb.gz pprof.demo2.alloc_objects.alloc_space.inuse_objects.inuse_space.002.pb.gz</p><br />
<br />
<p>File: demo2<br />
Type: inuse_space<br />
Time: May 14, 2019 at 2:33pm (CST)<br />
Entering interactive mode (type “help” for commands, “o” for options)<br />
(pprof)<br />
(pprof)<br />
(pprof) top<br />
Showing nodes accounting for 970.34MB, 32.30% of 3003.99MB total<br />
      flat  flat%   sum%        cum   cum%<br />
  970.34MB 32.30% 32.30%   970.34MB 32.30%  main.main   // 看这<br />
         0     0% 32.30%   970.34MB 32.30%  runtime.main<br />
(pprof)<br />
(pprof)<br />
(pprof) list main.main<br />
Total: 2.93GB<br />
ROUTINE ======================== main.main in /home/ubuntu/heap/demo2.go<br />
  970.34MB   970.34MB (flat, cum) 32.30% of Total<br />
         .          .     20:    }()<br />
         .          .     21:<br />
         .          .     22:    tick := time.Tick(time.Second / 100)<br />
         .          .     23:    var buf []byte<br />
         .          .     24:    for range tick {<br />
  970.34MB   970.34MB     25:        buf = append(buf, make([]byte, 1024*1024)…) // 看这<br />
         .          .     26:    }<br />
         .          .     27:}<br />
         .          .     28:<br />
top列出了main.main和runtime.main，main.main就是我们编写的main函数，runtime.main是runtime包中的main函数，也就是所有main函数的入口，这里不多介绍了，有兴趣可以看之前的调度器文章《Go调度器系列（2）宏观看调度器》。</p><br />
<br />
<p>top显示main.main 第2次内存占用，比第1次内存占用多了970.34MB。</p><br />
<br />
<p>list main.main告诉了我们增长的内存都在这一行：</p><br />
<br />
<p>buf = append(buf, make([]byte, 1024*1024)…)<br />
001和002 profile的文件不进去看了，你本地测试下计算差值，绝对是刚才对比出的970.34MB。</p><br />
<br />
<p>heap“不能”定位内存泄露<br />
heap能显示内存的分配情况，以及哪行代码占用了多少内存，我们能轻易的找到占用内存最多的地方，如果这个地方的数值还在不断怎大，基本可以认定这里就是内存泄露的位置。</p><br />
<br />
<p>曾想按图索骥，从内存泄露的位置，根据调用栈向上查找，总能找到内存泄露的原因，这种方案看起来是不错的，但实施起来却找不到内存泄露的原因，结果是事半功倍。</p><br />
<br />
<p>原因在于一个Go程序，其中有大量的goroutine，这其中的调用关系也许有点复杂，也许内存泄露是在某个三方包里。举个栗子，比如下面这幅图，每个椭圆代表1个goroutine，其中的数字为编号，箭头代表调用关系。heap profile显示g111（最下方标红节点）这个协程的代码出现了泄露，任何一个从g101到g111的调用路径都可能造成了g111的内存泄露，有2类可能：</p><br />
<br />
<p>该goroutine只调用了少数几次，但消耗了大量的内存，说明每个goroutine调用都消耗了不少内存，内存泄露的原因基本就在该协程内部。<br />
该goroutine的调用次数非常多，虽然每个协程调用过程中消耗的内存不多，但该调用路径上，协程数量巨大，造成消耗大量的内存，并且这些goroutine由于某种原因无法退出，占用的内存不会释放，内存泄露的原因在到g111调用路径上某段代码实现有问题，造成创建了大量的g111。<br />
第2种情况，就是goroutine泄露，这是通过heap无法发现的，所以heap在定位内存泄露这件事上，发挥的作用不大。</p><br />
<br />
<p>image-20190512144150064</p><br />
<br />
<p>goroutine泄露怎么导致内存泄露<br />
什么是goroutine泄露<br />
如果你启动了1个goroutine，但并没有符合预期的退出，直到程序结束，此goroutine才退出，这种情况就是goroutine泄露。</p><br />
<br />
<p>提前思考：什么会导致goroutine无法退出/阻塞？<br />
goroutine泄露怎么导致内存泄露<br />
每个goroutine占用2KB内存，泄露1百万goroutine至少泄露2KB * 1000000 = 2GB内存，为什么说至少呢？</p><br />
<br />
<p>goroutine执行过程中还存在一些变量，如果这些变量指向堆内存中的内存，GC会认为这些内存仍在使用，不会对其进行回收，这些内存谁都无法使用，造成了内存泄露。</p><br />
<br />
<p>所以goroutine泄露有2种方式造成内存泄露：</p><br />
<br />
<p>goroutine本身的栈所占用的空间造成内存泄露。<br />
goroutine中的变量所占用的堆内存导致堆内存泄露，这一部分是能通过heap profile体现出来的。<br />
Dave在文章中也提到了，如果不知道何时停止一个goroutine，这个goroutine就是潜在的内存泄露：</p><br />
<br />
<p>7.1.1 Know when to stop a goroutine<br />
If you don’t know the answer, that’s a potential memory leak as the goroutine will pin its stack’s memory on the heap, as well as any heap allocated variables reachable from the stack.</p><br />
<br />
<p>怎么确定是goroutine泄露引发的内存泄露<br />
掌握了前面的pprof命令行的基本用法，很快就可以确认是否是goroutine泄露导致内存泄露，如果你不记得了，马上回去看一下go pprof基本知识。</p><br />
<br />
<p>判断依据：在节点正常运行的情况下，隔一段时间获取goroutine的数量，如果后面获取的那次，某些goroutine比前一次多，如果多获取几次，是持续增长的，就极有可能是goroutine泄露。</p><br />
<br />
<p>goroutine导致内存泄露的demo：</p><br />
<br />
<p>文件：golang_step_by_step/pprof/goroutine/leak_demo1.go</p><br />
<br />
<p>// goroutine泄露导致内存泄露<br />
package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “net/http”<br />
    _ “net/http/pprof”<br />
    “os”<br />
    “time”<br />
)</p><br />
<br />
<p>func main() {<br />
    // 开启pprof<br />
    go func() {<br />
        ip := “0.0.0.0:6060”<br />
        if err := http.ListenAndServe(ip, nil); err != nil {<br />
            fmt.Printf(“start pprof failed on %s\n”, ip)<br />
            os.Exit(1)<br />
        }<br />
    }()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>outCh := make(chan int)<br />
// 死代码，永不读取<br />
go func() {<br />
    if false {<br />
        &lt;-outCh<br />
    }<br />
    select {}<br />
}()<br />
<br />
// 每s起100个goroutine，goroutine会阻塞，不释放内存<br />
tick := time.Tick(time.Second / 100)<br />
i := 0<br />
for range tick {<br />
    i++<br />
    fmt.Println(i)<br />
    alloc1(outCh)<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>func alloc1(outCh chan&lt;- int) {<br />
    go alloc2(outCh)<br />
}</p><br />
<br />
<p>func alloc2(outCh chan&lt;- int) {<br />
    func() {<br />
        defer fmt.Println(“alloc-fm exit”)<br />
        // 分配内存，假用一下<br />
        buf := make([]byte, 1024<em>1024</em>10)<br />
        _ = len(buf)<br />
        fmt.Println(“alloc done”)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    outCh &lt;- 0 // 53行<br />
}() } 编译并运行以上代码，然后使用go tool pprof获取gorourine的profile文件。<br />
</code></pre></div></div><br />
<br />
<p>go tool pprof http://localhost:6060/debug/pprof/goroutine<br />
已经通过pprof命令获取了2个goroutine的profile文件:</p><br />
<br />
<p>$ ls<br />
/home/ubuntu/pprof/pprof.leak_demo.goroutine.001.pb.gz<br />
/home/ubuntu/pprof/pprof.leak_demo.goroutine.002.pb.gz<br />
同heap一样，我们可以使用base对比2个goroutine profile文件：</p><br />
<br />
<p>$go tool pprof -base pprof.leak_demo.goroutine.001.pb.gz pprof.leak_demo.goroutine.002.pb.gz</p><br />
<br />
<p>File: leak_demo<br />
Type: goroutine<br />
Time: May 16, 2019 at 2:44pm (CST)<br />
Entering interactive mode (type “help” for commands, “o” for options)<br />
(pprof)<br />
(pprof) top<br />
Showing nodes accounting for 20312, 100% of 20312 total<br />
      flat  flat%   sum%        cum   cum%<br />
     20312   100%   100%      20312   100%  runtime.gopark<br />
         0     0%   100%      20312   100%  main.alloc2<br />
         0     0%   100%      20312   100%  main.alloc2.func1<br />
         0     0%   100%      20312   100%  runtime.chansend<br />
         0     0%   100%      20312   100%  runtime.chansend1<br />
         0     0%   100%      20312   100%  runtime.goparkunlock<br />
(pprof)<br />
可以看到运行到runtime.gopark的goroutine数量增加了20312个。再通过002文件，看一眼执行到gopark的goroutine数量，即挂起的goroutine数量：</p><br />
<br />
<p>go tool pprof pprof.leak_demo.goroutine.002.pb.gz<br />
File: leak_demo<br />
Type: goroutine<br />
Time: May 16, 2019 at 2:47pm (CST)<br />
Entering interactive mode (type “help” for commands, “o” for options)<br />
(pprof) top<br />
Showing nodes accounting for 24330, 100% of 24331 total<br />
Dropped 32 nodes (cum &lt;= 121)<br />
      flat  flat%   sum%        cum   cum%<br />
     24330   100%   100%      24330   100%  runtime.gopark<br />
         0     0%   100%      24326   100%  main.alloc2<br />
         0     0%   100%      24326   100%  main.alloc2.func1<br />
         0     0%   100%      24326   100%  runtime.chansend<br />
         0     0%   100%      24326   100%  runtime.chansend1<br />
         0     0%   100%      24327   100%  runtime.goparkunlock<br />
显示有24330个goroutine被挂起，这不是goroutine泄露这是啥？已经能确定八九成goroutine泄露了。</p><br />
<br />
<p>是什么导致如此多的goroutine被挂起而无法退出？接下来就看怎么定位goroutine泄露。</p><br />
<br />
<p>定位goroutine泄露的2种方法<br />
使用pprof有2种方式，一种是web网页，一种是go tool pprof命令行交互，这两种方法查看goroutine都支持，但有轻微不同，也有各自的优缺点。</p><br />
<br />
<p>我们先看Web的方式，再看命令行交互的方式，这两种都很好使用，结合起来用也不错。</p><br />
<br />
<p>Web可视化查看<br />
Web方式适合web服务器的端口能访问的情况，使用起来方便，有2种方式：</p><br />
<br />
<p>查看某条调用路径上，当前阻塞在此goroutine的数量<br />
查看所有goroutine的运行栈（调用路径），可以显示阻塞在此的时间<br />
方式一<br />
url请求中设置debug=1：</p><br />
<br />
<p>http://ip:port/debug/pprof/goroutine?debug=1<br />
效果如下：</p><br />
<br />
<p>看起来密密麻麻的，其实简单又十分有用，看上图标出来的部分，手机上图看起来可能不方便，那就放大图片，或直接看下面各字段的含义：</p><br />
<br />
<p>goroutine profile: total 32023：32023是goroutine的总数量，<br />
32015 @ 0x42e15a 0x42e20e 0x40534b 0x4050e5 …：32015代表当前有32015个goroutine运行这个调用栈，并且停在相同位置，@后面的十六进制，现在用不到这个数据，所以暂不深究了。<br />
下面是当前goroutine的调用栈，列出了函数和所在文件的行数，这个行数对定位很有帮助，如下：<br />
32015 @ 0x42e15a 0x42e20e 0x40534b 0x4050e5 0x6d8559 0x6d831b 0x45abe1</p><br />
<h1 id="0x6d8558----mainalloc2func10xf8----homeubuntuheapleak_demogo53">0x6d8558    main.alloc2.func1+0xf8    /home/ubuntu/heap/leak_demo.go:53</h1><br />
<h1 id="0x6d831a----mainalloc20x2a----homeubuntuheapleak_demogo54">0x6d831a    main.alloc2+0x2a    /home/ubuntu/heap/leak_demo.go:54</h1><br />
<p>根据上面的提示，就能判断32015个goroutine运行到leak_demo.go的53行：</p><br />
<br />
<p>func alloc2(outCh chan&lt;- int) {<br />
    func() {<br />
        defer fmt.Println(“alloc-fm exit”)<br />
        // 分配内存，假用一下<br />
        buf := make([]byte, 1024<em>1024</em>10)<br />
        _ = len(buf)<br />
        fmt.Println(“alloc done”)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    outCh &lt;- 0 // 53行<br />
}() } 阻塞的原因是outCh这个写操作无法完成，outCh是无缓冲的通道，并且由于以下代码是死代码，所以goroutine始终没有从outCh读数据，造成outCh阻塞，进而造成无数个alloc2的goroutine阻塞，形成内存泄露：<br />
</code></pre></div></div><br />
<br />
<p>if false {<br />
    &lt;-outCh<br />
}<br />
方式二<br />
url请求中设置debug=2：</p><br />
<br />
<p>http://ip:port/debug/pprof/goroutine?debug=2</p><br />
<br />
<p>第2种方式和第1种方式是互补的，它可以看到每个goroutine的信息：</p><br />
<br />
<p>goroutine 20 [chan send, 2 minutes]：20是goroutine id，[]中是当前goroutine的状态，阻塞在写channel，并且阻塞了2分钟，长时间运行的系统，你能看到阻塞时间更长的情况。<br />
同时，也可以看到调用栈，看当前执行停到哪了：leak_demo.go的53行，<br />
goroutine 20 [chan send, 2 minutes]:<br />
main.alloc2.func1(0xc42015e060)<br />
    /home/ubuntu/heap/leak_demo.go:53 +0xf9  // 这<br />
main.alloc2(0xc42015e060)<br />
    /home/ubuntu/heap/leak_demo.go:54 +0x2b<br />
created by main.alloc1<br />
    /home/ubuntu/heap/leak_demo.go:42 +0x3f<br />
命令行交互式方法<br />
Web的方法是简单粗暴，无需登录服务器，浏览器打开看看就行了。但就像前面提的，没有浏览器可访问时，命令行交互式才是最佳的方式，并且也是手到擒来，感觉比Web一样方便。</p><br />
<br />
<p>命令行交互式只有1种获取goroutine profile的方法，不像Web网页分debug=1和debug=22中方式，并将profile文件保存到本地：</p><br />
<br />
<p>// 注意命令没有<code class="language-plaintext highlighter-rouge">debug=1</code>，debug=1，加debug有些版本的go不支持<br />
$ go tool pprof http://0.0.0.0:6060/debug/pprof/goroutine<br />
Fetching profile over HTTP from http://localhost:6061/debug/pprof/goroutine<br />
Saved profile in /home/ubuntu/pprof/pprof.leak_demo.goroutine.001.pb.gz  // profile文件保存位置<br />
File: leak_demo<br />
Type: goroutine<br />
Time: May 16, 2019 at 2:44pm (CST)<br />
Entering interactive mode (type “help” for commands, “o” for options)<br />
(pprof)<br />
命令行只需要掌握3个命令就好了，上面介绍过了，详细的倒回去看top, list, traces：</p><br />
<br />
<p>top：显示正运行到某个函数goroutine的数量<br />
traces：显示所有goroutine的调用栈<br />
list：列出代码详细的信息。<br />
我们依然使用leak_demo.go这个demo，</p><br />
<br />
<p>$  go tool pprof -base pprof.leak_demo.goroutine.001.pb.gz pprof.leak_demo.goroutine.002.pb.gz<br />
File: leak_demo<br />
Type: goroutine<br />
Time: May 16, 2019 at 2:44pm (CST)<br />
Entering interactive mode (type “help” for commands, “o” for options)<br />
(pprof)<br />
(pprof)<br />
(pprof) top<br />
Showing nodes accounting for 20312, 100% of 20312 total<br />
      flat  flat%   sum%        cum   cum%<br />
     20312   100%   100%      20312   100%  runtime.gopark<br />
         0     0%   100%      20312   100%  main.alloc2<br />
         0     0%   100%      20312   100%  main.alloc2.func1<br />
         0     0%   100%      20312   100%  runtime.chansend<br />
         0     0%   100%      20312   100%  runtime.chansend1<br />
         0     0%   100%      20312   100%  runtime.goparkunlock<br />
(pprof)<br />
(pprof) traces<br />
File: leak_demo<br />
Type: goroutine<br />
Time: May 16, 2019 at 2:44pm (CST)<br />
———–+——————————————————-<br />
     20312   runtime.gopark<br />
             runtime.goparkunlock<br />
             runtime.chansend<br />
             runtime.chansend1 // channel发送<br />
             main.alloc2.func1 // alloc2中的匿名函数<br />
             main.alloc2<br />
———–+——————————————————-<br />
top命令在怎么确定是goroutine泄露引发的内存泄露介绍过了，直接看traces命令，traces能列出002中比001中多的那些goroutine的调用栈，这里只有1个调用栈，有20312个goroutine都执行这个调用路径，可以看到alloc2中的匿名函数alloc2.func1调用了写channel的操作，然后阻塞挂起了goroutine，使用list列出alloc2.func1的代码，显示有20312个goroutine阻塞在53行：</p><br />
<br />
<p>(pprof) list main.alloc2.func1<br />
Total: 20312<br />
ROUTINE ======================== main.alloc2.func1 in /home/ubuntu/heap/leak_demo.go<br />
         0      20312 (flat, cum)   100% of Total<br />
         .          .     48:        // 分配内存，假用一下<br />
         .          .     49:        buf := make([]byte, 1024<em>1024</em>10)<br />
         .          .     50:        _ = len(buf)<br />
         .          .     51:        fmt.Println(“alloc done”)<br />
         .          .     52:<br />
         .      20312     53:        outCh &lt;- 0  // 看这<br />
         .          .     54:    }()<br />
         .          .     55:}<br />
         .          .     56:<br />
友情提醒：使用list命令的前提是程序的源码在当前机器，不然可没法列出源码。服务器上，通常没有源码，那我们咋办呢？刚才介绍了Web查看的方式，那里会列出代码行数，我们可以使用wget下载网页：</p><br />
<br />
<p>$ wget http://localhost:6060/debug/pprof/goroutine?debug=1<br />
下载网页后，使用编辑器打开文件，使用关键字main.alloc2.func1进行搜索，找到与当前相同的调用栈，就可以看到该goroutine阻塞在哪一行了，不要忘记使用debug=2还可以看到阻塞了多久和原因，Web方式中已经介绍了，此处省略代码几十行。</p><br />
<br />
<p>总结<br />
文章略长，但全是干货，感谢阅读到这。然读到着了，跟定很想掌握pprof，建议实践一把，现在和大家温习一把本文的主要内容。</p><br />
<br />
<p>goroutine泄露的本质<br />
goroutine泄露的本质是channel阻塞，无法继续向下执行，导致此goroutine关联的内存都无法释放，进一步造成内存泄露。</p><br />
<br />
<p>goroutine泄露的发现和定位<br />
利用好go pprof获取goroutine profile文件，然后利用3个命令top、traces、list定位内存泄露的原因。</p><br />
<br />
<p>goroutine泄露的场景<br />
泄露的场景不仅限于以下两类，但因channel相关的泄露是最多的。</p><br />
<br />
<p>channel的读或者写：</p><br />
<br />
<p>无缓冲channel的阻塞通常是写操作因为没有读而阻塞<br />
有缓冲的channel因为缓冲区满了，写操作阻塞<br />
期待从channel读数据，结果没有goroutine写<br />
select操作，select里也是channel操作，如果所有case上的操作阻塞，goroutine也无法继续执行。<br />
编码goroutine泄露的建议<br />
为避免goroutine泄露造成内存泄露，启动goroutine前要思考清楚：</p><br />
<br />
<p>goroutine如何退出？<br />
是否会有阻塞造成无法退出？如果有，那么这个路径是否会创建大量的goroutine？<br />
示例源码<br />
本文所有示例源码，及历史文章、代码都存储在Github，阅读原文可直接跳转，Github：https://github.com/Shitaibin/golang_step_by_step/tree/master/pprof 。</p><br />
<br />
<p>推荐阅读<br />
这些既是参考资料也是推荐阅读的文章，不容错过。</p><br />
<br />
<p>【Go Blog关于pprof详细介绍和Demo】 https://blog.golang.org/profi…</p><br />
<br />
<p>【Dave关于高性能Go程序的workshop】 https://dave.cheney.net/high-…</p><br />
<br />
<p>【煎鱼pprof文章，很适合入门 Golang大杀器之性能剖析PProf】 https://segmentfault.com/a/11…</p><br />
<br />
<p>【SO上goroutine调用栈各字段的介绍】https://stackoverflow.com/a/3…</p><br />
<br />
<p>【我的老文，有runtime.main的介绍，想学习调度器，可以看下系列文章 Go调度器系列（2）宏观看调度器】http://lessisbetter.site/2019…</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>