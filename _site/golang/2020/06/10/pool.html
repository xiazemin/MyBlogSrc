<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">Go 内存池对象池技术</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-06-10T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jun 10, 2020</time></p>
					</div>
					 <p>前言: tcmalloc 与 Go<br />
以前 C++服务上线，遇到性能优化一定会涉及 Google 大名鼎鼎的 tcmalloc。</p><br />
<br />
<p>相比 glibc，tcmalloc 在多线程下有巨大的优势：</p><br />
<br />
<p>vs tcmalloc<br />
其中使用的就是内存池技术。如果想了解 tcmalloc 的细节，盗一张图解 TCMalloc中比较经典的结构图：</p><br />
<br />
<p>图解 TCMalloc<br />
作为 Google 的得意之作，Golang自然也用上了 tcmalloc 的内存池03 技术。因此我们普通使用 Golang 时，无需关注内存分配的性能问题。<br />
<!-- more --></p><br />
<ol><br />
  <li>关于 map 你需要了解的<br />
既然 Go 本身内存已经做了 tcmalloc 的管理，那实现缓存我们能想到的就是 map 了，是吧？（但仔细想想，map 不需要加锁吗？不加锁用 sync.Map 更好吗）</li><br />
</ol><br />
<br />
<p>坑 1: 为什么不用 sync.Map<br />
2020-05-09 补充：多位同学也提到了，bigcache 这个测试并不公平。查了下 issues，map+lock 和 sync.Map 的有人做过测试，性能确实低一些（单锁的情况） https://github.com/golang/go/issues/28938#issuecomment-441737879但如果是 shards map+lock 和 sync.Map，在不同的读写比（比如读多写少，当超时才更新）时，这块就不好判断哪种实现更优了，有兴趣的同学可以尝试深挖下（而且 doyenli 也提到，sync.Map 内部是 append only 的）<br />
用过 map 的同学应该会知道，map 并不是线程安全的。多个协程同步更新 map 时，会有概率导致程序 core 掉。</p><br />
<br />
<p>那我们为什么不用sync.Map？当然不是因为 go 版本太老不支持这种肤浅原因。</p><br />
<br />
<p>https://github.com/allegro/bigcache-bench 里有张对比数据，纯写 map 是比 sync.Map 要快很多，读也有一定优势。考虑到多数场景下读多写少，我们只需对 map 加个读写锁，异步写的问题就搞定了（还不损失太多性能）。</p><br />
<br />
<p>map vs sync.Map<br />
除了读写锁，我们还可以使用 shard map 的分布式锁来继续提高并发（后面 bigcache 部分会介绍），所以你看最终的 cache 库里，大家都没用 sync.Map，而是用map+读写锁来实现存储。</p><br />
<br />
<p>坑 2: 用 map 做内存池就可以了？<br />
并不能。map 存储 keys 也是有限制的，当 map 中 keys 数量超过千万级，有可能造成性能瓶颈。</p><br />
<br />
<p>这个是我在之前业务中实际遇到的情况，当时服务里用了 GroupCache 做缓存，导致部分线上请求会超时(0.08%左右的超时率)。我们先暂时放下这个问题，弄清原因再来介绍这里的差异。</p><br />
<br />
<p>找了下资料，发现 2014 年 Go 有个 issue 提到 Large maps cause significant GC pauses 的问题。简单来说就是当 map 中存在大量 keys 时，GC 扫描 map 产生的停顿将不能忽略。</p><br />
<br />
<p>好消息是 2015 年 Go 开发者已经对 map 中无指针的情况进行了优化：</p><br />
<br />
<p>GC ignore maps with no pointers<br />
我们参考其中的代码，写个GC 测试程序验证下：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
  “fmt”<br />
  “os”<br />
  “runtime”<br />
  “time”<br />
)</p><br />
<br />
<p>// Results of this program on my machine:<br />
//<br />
// for t in 1 2 3 4 5; do go run maps.go $t; done<br />
//<br />
// Higher parallelism does help, to some extent:<br />
//<br />
// for t in 1 2 3 4 5; do GOMAXPROCS=8 go run maps.go $t; done<br />
//<br />
// Output(go 1.14):<br />
// With map[int32]<em>int32, GC took 456.159324ms<br />
// With map[int32]int32, GC took 10.644116ms<br />
// With map shards ([]map[int32]</em>int32), GC took 383.296446ms<br />
// With map shards ([]map[int32]int32), GC took 1.023655ms<br />
// With a plain slice ([]main.t), GC took 172.776µs</p><br />
<br />
<p>func main() {<br />
  const N = 5e7 // 5000w</p><br />
<br />
<p>if len(os.Args) != 2 {<br />
    fmt.Printf(“usage: %s [1 2 3 4]\n(number selects the test)\n”, os.Args[0])<br />
    return<br />
  }</p><br />
<br />
<p>switch os.Args[1] {<br />
  case “1”:<br />
    // Big map with a pointer in the value<br />
    m := make(map[int32]<em>int32)<br />
    for i := 0; i &lt; N; i++ {<br />
      n := int32(i)<br />
      m[n] = &amp;n<br />
    }<br />
    runtime.GC()<br />
    fmt.Printf(“With %T, GC took %s\n”, m, timeGC())<br />
    _ = m[0] // Preserve m until here, hopefully<br />
  case “2”:<br />
    // Big map, no pointer in the value<br />
    m := make(map[int32]int32)<br />
    for i := 0; i &lt; N; i++ {<br />
      n := int32(i)<br />
      m[n] = n<br />
    }<br />
    runtime.GC()<br />
    fmt.Printf(“With %T, GC took %s\n”, m, timeGC())<br />
    _ = m[0]<br />
  case “3”:<br />
    // Split the map into 100 shards<br />
    shards := make([]map[int32]</em>int32, 100)<br />
    for i := range shards {<br />
      shards[i] = make(map[int32]*int32)<br />
    }<br />
    for i := 0; i &lt; N; i++ {<br />
      n := int32(i)<br />
      shards[i%100][n] = &amp;n<br />
    }<br />
    runtime.GC()<br />
    fmt.Printf(“With map shards (%T), GC took %s\n”, shards, timeGC())<br />
    _ = shards[0][0]<br />
  case “4”:<br />
    // Split the map into 100 shards<br />
    shards := make([]map[int32]int32, 100)<br />
    for i := range shards {<br />
      shards[i] = make(map[int32]int32)<br />
    }<br />
    for i := 0; i &lt; N; i++ {<br />
      n := int32(i)<br />
      shards[i%100][n] = n<br />
    }<br />
    runtime.GC()<br />
    fmt.Printf(“With map shards (%T), GC took %s\n”, shards, timeGC())<br />
    _ = shards[0][0]<br />
  case “5”:<br />
    // A slice, just for comparison to show that<br />
    // merely holding onto millions of int32s is fine<br />
    // if they’re in a slice.<br />
    type t struct {<br />
      p, q int32<br />
    }<br />
    var s []t<br />
    for i := 0; i &lt; N; i++ {<br />
      n := int32(i)<br />
      s = append(s, t{n, n})<br />
    }<br />
    runtime.GC()<br />
    fmt.Printf(“With a plain slice (%T), GC took %s\n”, s, timeGC())<br />
    _ = s[0]<br />
  }<br />
}</p><br />
<br />
<p>func timeGC() time.Duration {<br />
  start := time.Now()<br />
  runtime.GC()<br />
  return time.Since(start)<br />
}<br />
代码中一共测试了 5 种情况，写入5000w的 keys 后，主动触发 2 次 GC 来测量耗时：</p><br />
<br />
<p>[1] With map[int32]<em>int32, GC took 456.159324ms<br />
[2] With map[int32]int32, GC took 10.644116ms<br />
[3] With map shards ([]map[int32]</em>int32), GC took 383.296446ms<br />
[4] With map shards ([]map[int32]int32), GC took 1.023655ms<br />
[5] With a plain slice ([]main.t), GC took 172.776µs<br />
可以看到，当 map 中没有指针时，扫描停顿时间大约在 10ms 左右，而包含指针int32时则会扩大 45 倍。</p><br />
<br />
<p>先看 5 的数据，单纯的 slice 速度飞快，基本没有 GC 消耗。而 map shards 就有点耐人寻味了，为什么我们没有对 map 加锁，分 shard 后 GC 时间还是缩短了呢？说好的将锁分布式化，才能提高性能呢？</p><br />
<br />
<p>坑 3: shards map 能提高性能的元凶(原因)<br />
要了解 shards map 性能变化的原因，需要先弄清楚 Golang GC 的机制。我们先加上GODEBUG=gctrace=1观察下 map 里包含指针与没有指针的 gc 差异：</p><br />
<br />
<p>map[]*int: gc 11 @11.688s 2%: 0.004+436+0.004 ms clock, 0.055+0/1306/3899+0.049 ms cpu, 1762-&gt;1762-&gt;1220 MB, 3195 MB goal, 12 P (forced)map[]int: gc 10 @9.357s 0%: 0.003+14+0.004 ms clock, 0.046+0/14/13+0.054 ms cpu, 1183-&gt;1183-&gt;746 MB, 2147 MB goal, 12 P (forced)</p><br />
<br />
<p>输出各字段含义可以看GODEBUG 之 gctrace 干货解析，这里我们只关注 cpu 里 0.055+0/1306/3899+0.049 ms cpu 这段的解释：</p><br />
<br />
<p>Mark Prepare (STW) - 0.055 表示整个进程在 mark 阶段 STW 停顿时间<br />
Marking - 0/1306/3899 三段信息，其中 0 是 mutator assist 占用时间，1306 是 dedicated mark workers+fractional mark worker 占用的时间，3899 是 idle mark workers 占用的时间（虽然被拆分为 3 种不同的 gc worker，过程中被扫描的 P 还是会暂停的，另外注意这里时间是所有 P 消耗时间的总和）<br />
Mark Termination (STW) - 0.049 表示整个进程在 markTermination 阶段 STW 停顿时间<br />
只有 Mark 的前后两个阶段会导致 Stop-The-World(STW)，中间 Marking 过程是并行的。这里 1306ms 是因为我们启动了 12 个 P，1306ms 和 3899ms 是所有 P 消耗时间的综合。虽然说是 Marking 是并行，但被扫描到的 P 还是会被暂停的。因此这个时间最终反映到业务程序上，就是某个 P 处理的请求，在 GC 时耗时突增（不稳定），不能被简单的忽略</p><br />
<br />
<p>那回到上面的问题了，shards map 的性能又是如何得到提升（近 10 倍）的？</p><br />
<br />
<p>// With map[int32]int32, GC took 11.285541ms<br />
gc 1 @0.001s 7%: 0.010+2.1+0.012 ms clock, 0.12+0.99/2.1/1.2+0.15 ms cpu, 4-&gt;6-&gt;6 MB, 5 MB goal, 12 P<br />
…<br />
gc 8 @2.374s 0%: 0.003+3.9+0.018 ms clock, 0.042+0.31/6.7/3.1+0.21 ms cpu, 649-&gt;649-&gt;537 MB, 650 MB goal, 12 P<br />
gc 9 @4.834s 0%: 0.003+7.5+0.021 ms clock, 0.040+0/14/5.1+0.25 ms cpu, 1298-&gt;1298-&gt;1073 MB, 1299 MB goal, 12 P<br />
gc 10 @9.188s 0%: 0.003+26+0.004 ms clock, 0.045+0/26/0.35+0.053 ms cpu, 1183-&gt;1183-&gt;746 MB, 2147 MB goal, 12 P (forced)<br />
gc 11 @9.221s 0%: 0.018+9.4+0.003 ms clock, 0.22+0/17/5.0+0.043 ms cpu, 746-&gt;746-&gt;746 MB, 1492 MB goal, 12 P (forced)</p><br />
<br />
<p>// With map shards ([]map[int32]int32), GC took 1.017494ms<br />
gc 1 @0.001s 7%: 0.010+2.9+0.048 ms clock, 0.12+0.26/3.6/4.1+0.57 ms cpu, 4-&gt;7-&gt;6 MB, 5 MB goal, 12 P<br />
…<br />
gc 12 @3.924s 0%: 0.003+3.2+0.004 ms clock, 0.040+1.2/7.5/14+0.048 ms cpu, 822-&gt;827-&gt;658 MB, 840 MB goal, 12 P<br />
gc 13 @8.096s 0%: 0.003+6.1+0.004 ms clock, 0.044+6.0/14/32+0.053 ms cpu, 1290-&gt;1290-&gt;945 MB, 1317 MB goal, 12 P<br />
gc 14 @11.619s 0%: 0.003+1.2+0.004 ms clock, 0.045+0/2.5/3.7+0.056 ms cpu, 1684-&gt;1684-&gt;1064 MB, 1891 MB goal, 12 P (forced)<br />
gc 15 @11.628s 0%: 0.003+0.91+0.004 ms clock, 0.038+0/2.3/3.6+0.057 ms cpu, 1064-&gt;1064-&gt;1064 MB, 2128 MB goal, 12 P (forced)<br />
从倒数第三轮内存最大的时候看，GC worker 的耗时都是接近的；唯一差异较大的，是 markTermination 阶段的 STW 时间，shard 方式下少了 1/10，因此推测和该阶段得到优化有关。</p><br />
<br />
<p>至于这个时间为什么能减少，我也不清楚为什么（这个坑挖得太深，只能以后找到资料再来填…)</p><br />
<br />
<ol><br />
  <li>GroupCache<br />
言归正传（众人：什么？！前面写这么多你还没进入正文。我：咳..咳..），我们总结下用 map 实现内存池的要点：</li><br />
</ol><br />
<br />
<p>内存池用 map 不用 sync.Map；map 要加读写锁<br />
map 尽量存非指针(key 和 value 都不包含指针)<br />
map 里存放指针，需要注意 keys 过多会带来的 GC 停顿问题<br />
使用 shards map<br />
然后我们看看GroupCache 的实现方法，这个定义在 lru/lru.go 里：</p><br />
<br />
<p>// Cache is an LRU cache. It is not safe for concurrent access.<br />
type Cache struct {<br />
  cache map[interface{}]*list.Element<br />
}<br />
从 cache 的定义可以看出，这是我们说的 map 里包含指针的情况，而且还是不分 shards 的。所以如果你单机 GroupCache 里 keys 过多，还是要注意下用法的。</p><br />
<br />
<p>注：截止目前 1.14，map 里包含指针时 idle worker 耗时问题还未有结论，有兴趣可以参考 10ms-26ms latency from GC in go1.14rc1, possibly due to ‘GC (idle)’ work 里面的例子和现象。</p><br />
<br />
<ol><br />
  <li>BigCache<br />
相比分布式场景的 GroupCache，如果你本地依然有千万级的 keys，那推荐你用 bigcache。无数经验证明，超大 map 的内存池导致的 GC 延迟，是可以通过切 bigcache 解决的。那 bigcache 到底怎么做到的？</li><br />
</ol><br />
<br />
<p>简单来说：shards map + map[uint]uint + []byte + free link = BigCache<br />
定义 shards cache，避免锁粒度过大<br />
map 里只存放 uint 避免指针<br />
实现一个 queue 结构（实际是[]byte，通过 uint 下标追加分配）<br />
采用 free 链机制，删除保留空洞最后一起回收（这块逻辑还蛮复杂的，先留个不大不小的坑吧…）<br />
其内存池定义如下：</p><br />
<br />
<p>type cacheShard struct {<br />
  hashmap     map[uint64]uint32        // key在entries中的位置<br />
  entries     queue.BytesQueue         // 实际是[]byte，新数据来了后copy到尾部<br />
}<br />
这样 GC 就变成了map 无指针+[]byte 结构的扫描问题了，因此性能会高出很多。</p><br />
<br />
<p>坑 4: 两种方式(GroupCache 和 BigCache)对具体业务到底有多大影响？<br />
上面只是 map 实现内存池的模拟分析，以及两种典型 Cache 库的对比。如果你也和我一样，问自己“具体两种 Cache 对业务有多大影响呢”？那只能很高兴的对你说：欢迎来到坑底 -_-</p><br />
<br />
<p>我们线上大概需要单机缓存 1000 万左右的 keys。首先我尝试模拟业务，向两种 Cache 中插入 1000w 数据来测试 GC 停顿。然而因为实验代码或其他未知的坑，最后认为这个方法不太可侧<br />
最后讨论，觉得还是用老办法，用 Prometheus 的 histogram 统计耗时分布。我们先统计底层存储（Redis）的耗时分布，然后再分别统计 BigCache 和 GroupCache 在写入 500w 数据后的实际情况。分析结论可知：</p><br />
<br />
<p>40ms 以上请求<br />
从 redis 数据看，40ms 以上请求占比0.08%；BigCache 的 40ms 以上请求占0.04%（即相反有一半以上超时请求被 Cache 挡住了） GroupCache 则是0.2%，将这种长时间请求放大了1倍多（推测和 map 的锁机制有关）</p><br />
<br />
<p>10ms-40ms 请求<br />
redis 本身这个区间段请求占比24.11%；BigCache 则只有15.51%，相当于挡掉了33%左右的高延迟请求（证明加热点 Cache 还是有作用的） GroupCache 这个区间段请求占比21.55%，也比直接用 redis 来得好</p><br />
<br />
<p>详细数据分布：<br />
redis     [  0.1] 0.00%<br />
redis     [  0.5] 0.38%<br />
redis     [    1] 3.48%<br />
redis     [    5] 71.94%<br />
redis     [   10] 22.90%<br />
redis     [   20] 1.21%<br />
redis     [   40] 0.07%<br />
redis     [ +Inf] 0.01%</p><br />
<br />
<p>bigcache  [  0.1] 0.40%<br />
bigcache  [  0.5] 16.16%<br />
bigcache  [    1] 14.82%<br />
bigcache  [    5] 53.07%<br />
bigcache  [   10] 14.85%<br />
bigcache  [   20] 0.66%<br />
bigcache  [   40] 0.03%<br />
bigcache  [ +Inf] 0.01%</p><br />
<br />
<p>groupcache[  0.1] 0.24%<br />
groupcache[  0.5] 9.59%<br />
groupcache[    1] 9.69%<br />
groupcache[    5] 58.74%<br />
groupcache[   10] 19.10%<br />
groupcache[   20] 2.45%<br />
groupcache[   40] 0.17%<br />
groupcache[ +Inf] 0.03%<br />
然而我们测完只能大致知道：本地使用 GroupCache 在 500w 量级的 keys 下，还是不如 BigCache 稳定的（哪怕 GroupCache 实现了 LRU 淘汰，但实际上因为有 Hot/Main Cache 的存在，内存利用效率上不如 BigCache）</p><br />
<br />
<p>分布式情况下，GroupCache 和 BigCache 相比又有多少差距，这个就只能挖坑等大家一起跳了。</p><br />
<br />
<ol><br />
  <li>对象池与零拷贝<br />
在实际业务中，往往 map 中并不会存储 5000w 级的 keys。如果我们只有 50w 的 keys，GC 停顿就会骤减到 4ms 左右（其间 gc worker 还会并行工作，避免 STW）。</li><br />
</ol><br />
<br />
<p>例如无极（腾讯内部的一个配置服务）这类配置服务（或其他高频数据查询场景），往往需要 Get(key) 获取对应的结构化数据。而从 BigCache，CPU 消耗发现（如图），相比网络 IO 和 Protobuf 解析，Get 占用0.78%、Set 占用0.9%，基本可以忽略：</p><br />
<br />
<p>CPU profile<br />
因此优化的思路也很明确，我们参考 GroupCache 的 lru 实现，将 JSON 提前解析好，在业务侧 Get 时直接返回 struct 的指针即可。具体流程不复杂，直接 ppt 截图：</p><br />
<br />
<p>zero-copy<br />
我们把接口设计成注册的方式（注册需要解析 JSON 数据的结构），然后再 Get 时返回该结构的指针实现零拷贝。下面 benchmark 可以反映性能差异和内存分配情况（Client_Get 是实时 JSON 解析，Filter_Get 是优化的对象池 API），可以切实看到0 allocs/op：</p><br />
<br />
<p>goos: linux<br />
goarch: amd64<br />
pkg: open-wuji/go-sdk/wujiclient<br />
BenchmarkClient_Get-8              1000000        1154 ns/op           1.00 hits        87 B/op        3 allocs/op<br />
BenchmarkFilter_Get-8              4899364         302 ns/op           1.00 hits         7 B/op        1 allocs/op<br />
BenchmarkClient_GetParallel-8      8383149         162 ns/op           1.00 hits        80 B/op        2 allocs/op<br />
BenchmarkFilter_GetParallel-8     13053680        91.4 ns/op           1.00 hits         0 B/op        0 allocs/op<br />
PASS<br />
ok    open-wuji/go-sdk/wujiclient 93.494s<br />
Success: Benchmarks passed.<br />
目前无极尚未对外开源。对具体实现感兴趣的同学，可以看 gist 中filter API 的实现代码</p><br />
<br />
<p>https://mp.weixin.qq.com/s/SWfPV6tUC5olZgIdVabd3A</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>