<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">netpoller</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-05-09T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> May 9, 2019</time></p>
					</div>
					 <p>Go中网络交互采用多路复用的技术，具体到各个平台，即Kqueue、Epoll、Select、Poll等，下面以Linux下的Epoll实现为例进行分析。</p><br />
<br />
<p>netpoller代码分析<br />
所谓的netpoller，其实是Golang实利用了OS提供的非阻塞IO访问模式，并配合epll/kqueue等IO事件监控机制；为了弥合OS的异步机制与Golang接口的差异，而在runtime上做的一层封装。以此来实现网络IO优化。</p><br />
<br />
<p>实际的实现(epoll/kqueue)必须定义以下函数：</p><br />
<br />
<p>func netpollinit() // 初始化轮询器<br />
func netpollopen(fd uintptr, pd *pollDesc) int32 // 为fd和pd启动边缘触发通知<br />
<!-- more --><br />
当一个goroutine进行io阻塞时，会去被放到等待队列。这里面就关键的就是建立起文件描述符和goroutine之间的关联。 pollDesc结构体就是完成这个任务的。代码参见src/runtime/netpoll.go。</p><br />
<br />
<p>type pollDesc struct { // Poller对象<br />
    link *pollDesc // 链表<br />
    lock mutex // 保护下面字段<br />
    fd uintptr // fd是底层网络io文件描述符，整个生命期内，不能改变值<br />
    closing bool<br />
    seq uintptr // protect from stale(过时) timers and ready notifications<br />
    rg uintptr // reader goroutine addr<br />
    rt timer<br />
    rd int64<br />
    wg uintptr // writer goroutine addr<br />
    wt timer<br />
    wd int64<br />
    user int32 // user-set cookie用户自定义数据<br />
}</p><br />
<br />
<p>type pollCache struct { // 全局Poller链表<br />
    lock mutex // 保护Poller链表<br />
    first *pollDesc<br />
}</p><br />
<br />
<p>func poll_runtime_pollServerInit() // 调用netpollinit()<br />
func poll_runtime_pollOpen() // 调用netpollopen()<br />
func poll_runtime_pollClose() // 调用netpollclose()<br />
func poll_runtime_pollReset(pd, mode) // 先check(netpollcheckerr(pd, mode))是否有err发生，没有的话重置pd对应字段<br />
func poll_runtime_pollWait(pd, mode) // 先chekerr，再调用netpollblock(pd, mode, false)<br />
func poll_runtime_pollWaitCanceled(pd, mode) // windows下专用<br />
func poll_runtime_pollSetDeadline(pd, deadline, mode)<br />
//1. 重置定时器，并seq++<br />
//2. 设置超时函数netpollDeadline(或者netpollReadDeadline、netpollWriteDeadline)<br />
//3. 如果已经过期，调用netpollunblock和netpollgoready<br />
func poll_runtime_pollUnblock(pd) // netpollUnblock、netpollgoready</p><br />
<br />
<p>/<em>——————部分实现——————</em>/<br />
func netpollcheckerr(pd, mode) // 检查是否超时或正在关闭<br />
func netpollblockcommit(gp *g, gpp unsafe.Pointer)<br />
func netpollready(gpp *guintptr, pd, mode) // 调用netpollunblock，更新g的schedlink<br />
func netpollgoready(gp *g, traceskip) // 更新统计数据，调用goready — 通知调度器协程g从parked变为ready<br />
func netpollblock(pd, mode, waitio) // Set rg/wg = pdWait，调用gopark挂起pd对应的g。<br />
func netpollunblock(pd, mode, ioready)<br />
func netpoll(Write/Read)Deadline(arg, seq)<br />
pollCache是pollDesc链表入口，加锁保护链表安全。</p><br />
<br />
<p>pollDesc中，rg、wg有些特殊，它可能有如下3种状态:</p><br />
<br />
<p>pdReady == 1:  网络io就绪通知，goroutine消费完后应置为nil<br />
pdWait == 2: goroutine等待被挂起，后续可能有3种情况:<br />
goroutine被调度器挂起，置为goroutine地址<br />
收到io通知，置为pdReady<br />
超时或者被关闭，置为nil<br />
Goroutine地址: 被挂起的goroutine的地址，当io就绪时、或者超时、被关闭时，此goroutine将被唤醒，同时将状态改为pdReady或者nil。<br />
另外，由于wg、rg是goroutine的地址，因此当GC发生后，如果goroutine被回收(在heap区)，代码就崩溃了(指针无效)。所以，进行网络IO的goroutine不能在heap区分配内存。</p><br />
<br />
<p>lock锁对象保护了pollOpen, pollSetDeadline, pollUnblock和deadlineimpl操作。而这些操作又完全包含了对seq, rt, tw变量。fd在PollDesc整个生命过程中都是一个常量。处理pollReset, pollWait, pollWaitCanceled和runtime.netpollready(IO就绪通知)不需要用到锁，所以closing, rg, rd, wg和wd的所有操作都是一个无锁的操作。</p><br />
<br />
<p>多路复用三部曲<br />
初始化PollServer<br />
初始化在下面注册fd监听时顺便处理了，调用runtime_pollServerInit()，并使用sync.Once()机制保证只会被初始化一次。全局使用同一个EpollServer(同一个Epfd)。</p><br />
<br />
<p>func poll_runtime_ServerInit() {<br />
    netpollinit() // 具现化到Linux下，调用epoll_create<br />
    …<br />
}<br />
注册监听fd<br />
所有Unix文件在初始化时，如果支持Poll，都会加入到PollServer的监听中。源码下搜索runtime_pollOpen，即见分晓。</p><br />
<br />
<p>/<strong>**</strong><strong>**</strong><strong>**<em>internal/poll/fd_unix.go</em></strong><strong>**</strong><strong>**</strong><strong>**/<br />
type FD struct {<br />
    // Lock sysfd and serialize access to Read and Write methods.<br />
    fdmu fdMutex<br />
    // System file descriptor. Immutable until Close.<br />
    Sysfd int<br />
    // I/O poller.<br />
    pd pollDesc<br />
    …<br />
}<br />
func(fd <em>FD) Init(net string, pollable bool) error {<br />
    …<br />
    err := fd.pd.init(fd) // 初始化pd<br />
    …<br />
}<br />
…<br />
/</em></strong><strong>**</strong><strong>**</strong><strong>internal/poll/fd_poll_runtime.go</strong><strong>**</strong><strong>**</strong><strong><em>/<br />
type pollDesc struct {<br />
    runtimeCtx uintptr<br />
}<br />
func (pd *pollDesc) init(fd *FD) error {<br />
    serverInit.Do(runtime_pollServerInit) // 初始化PollServer(sync.Once)<br />
    ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))<br />
    …<br />
    runtimeCtx = ctx<br />
    return nil<br />
}<br />
…<br />
/</em></strong><strong>**</strong><strong>**</strong><strong>runtime/netpoll.go</strong><strong>**</strong><strong>**</strong><em>**/<br />
func poll_runtime_pollOpen(fd uintptr) (</em>epDesc, int32) {<br />
    …<br />
    errno := netpollopen(fd, pd) // 具现化到Linux下，调用epoll_ctl<br />
    …<br />
}<br />
取消fd的监听与此流程类似，最终调用epoll_ctl.</p><br />
<br />
<p>定期Poll<br />
结合上述实现，必然有处逻辑定期执行epoll_wait来检测fd状态。在代码中搜索下netpoll(，即可发现是在sysmon、startTheWorldWithSema、pollWork、findrunnable中调用的，以sysmon为例:</p><br />
<br />
<p>// runtime/proc.go<br />
…<br />
lastpoll := int64(atomic.Load64(&amp;sched.lastpoll))<br />
now := nanotime()<br />
// 如果10ms内没有poll过，则poll。(1ms=1000000ns)<br />
if lastpoll != 0 &amp;&amp; lastpoll+10<em>1000</em>1000 &lt; now {<br />
    atomic.Cas64(&amp;sched.lastpoll, uint64(lastpoll), uint64(now))<br />
    gp := netpoll(false) // netpoll在Linux具现为epoll_wait<br />
    if gp != nil {<br />
       injectglist(gp) //把g放到sched中去执行，底层仍然是调用的之前在goroutine里面提到的startm函数。<br />
	}<br />
}<br />
…<br />
以读等待挂起为例<br />
加入监听<br />
golang中客户端与服务端进行通讯时，常用如下方法:</p><br />
<br />
<p>conn, err := net.Dial(“tcp”, “localhost:1208”)<br />
…<br />
从net.Dial看进去，最终会调用net/net_posix.go中的socket函数，大致流程如下:</p><br />
<br />
<p>func socket(…) … {<br />
	/*<br />
	1. 调用sysSocket创建原生socket<br />
	2. 调用同名包下netFd()，初始化网络文件描述符netFd<br />
	3. 调用fd.dial()，其中最终有调用runtime_pollOpen()加入监听列表<br />
	*/<br />
}<br />
至此，文件描述符已经加入pollServer监听列表。</p><br />
<br />
<p>读等待<br />
主要是挂起goroutine，并建立gorotine和fd之间的关联。</p><br />
<br />
<p>当从netFd读取数据时，调用system call，循环从fd.sysfd读取数据：</p><br />
<br />
<p>func (fd *FD) Read(p []byte) (int, error) {<br />
    if err := fd.pd.prepareRead(fd.isFile); err != nil {<br />
        return 0, err<br />
    }<br />
    if fd.IsStream &amp;&amp; len(p) &gt; maxRW {<br />
        p = p[:maxRW]<br />
    }<br />
    for {<br />
        n, err := syscall.Read(fd.Sysfd, p)<br />
        if err != nil {<br />
            n = 0<br />
            if err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() {<br />
                if err = fd.pd.waitRead(fd.isFile); err == nil {<br />
                    continue<br />
                }<br />
            }<br />
        }<br />
        err = fd.eofError(n, err)<br />
        return n, err<br />
    }<br />
}<br />
读取的时候只处理EAGAIN类型的错误，其他错误一律返回给调用者，因为对于非阻塞的网络连接的文件描述符，如果错误是EAGAIN，说明Socket的缓冲区为空，未读取到任何数据，则调用fd.pd.WaitRead：</p><br />
<br />
<p>func (pd *pollDesc) waitRead(isFile bool) error {<br />
    return pd.wait(‘r’, isFile)<br />
}</p><br />
<br />
<p>func (pd *pollDesc) wait(mode int, isFile bool) error {<br />
    if pd.runtimeCtx == 0 {<br />
        return errors.New(“waiting for unsupported file type”)<br />
    }<br />
    res := runtime_pollWait(pd.runtimeCtx, mode)<br />
    return convertErr(res, isFile)<br />
}<br />
res是runtime_pollWait函数返回的结果，由conevertErr函数包装后返回：</p><br />
<br />
<p>func convertErr(res int, isFile bool) error {<br />
    switch res {<br />
    case 0:<br />
        return nil<br />
    case 1:<br />
        return errClosing(isFile)<br />
    case 2:<br />
        return ErrTimeout<br />
    }<br />
    println(“unreachable: “, res)<br />
    panic(“unreachable”)<br />
}<br />
其中0表示io已经准备好了，1表示链接意见关闭，2表示io超时。再来看看pollWait的实现：</p><br />
<br />
<p>func poll_runtime_pollWait(pd *pollDesc, mode int) int {<br />
    err := netpollcheckerr(pd, int32(mode))<br />
    if err != 0 {<br />
        return err<br />
    }<br />
    for !netpollblock(pd, int32(mode), false) {<br />
        err = netpollcheckerr(pd, int32(mode))<br />
        if err != 0 {<br />
            return err<br />
        }<br />
    }<br />
    return 0<br />
}<br />
调用netpollblock来判断IO是否准备好了：</p><br />
<br />
<p>func netpollblock(pd *pollDesc, mode int32, waitio bool) bool {<br />
	gpp := &amp;pd.rg<br />
	if mode == ‘w’ {<br />
		gpp = &amp;pd.wg<br />
	}<br />
    for {<br />
        old := *gpp<br />
        if old == pdReady {<br />
            *gpp = 0<br />
            return true<br />
        }<br />
        if old != 0 {<br />
            throw(“runtime: double wait”)<br />
        }<br />
        if atomic.Casuintptr(gpp, 0, pdWait) {<br />
            break<br />
        }<br />
    }<br />
    if waitio || netpollcheckerr(pd, mode) == 0 {<br />
	    gopark(netpollblockcommit, unsafe.Pointer(gpp), “IO wait”, traceEvGoBlockNet, 5)<br />
    }<br />
    old := atomic.Xchguintptr(gpp, 0)<br />
    if old &gt; pdWait {<br />
        throw(“runtime: corrupted polldesc”)<br />
    }<br />
    return old == pdReady<br />
}<br />
返回true说明IO已经准备好，返回false说明IO操作已经超时或者已经关闭。否则当waitio为false, 且io不出现错误或者超时才会挂起当前goroutine。最后的gopark函数，就是将当前的goroutine(调用者)设置为waiting状态。</p><br />
<br />
<p>就绪唤醒<br />
如上所述，go在多种场景下都会调用netpoll检查文件描述符状态。寻找到IO就绪的socket文件描述符，并找到这些socket文件描述符对应的轮询器中附带的信息，根据这些信息将之前等待这些socket文件描述符就绪的goroutine状态修改为Grunnable。执行完netpoll之后，会找到一个就绪的goroutine列表，接下来将就绪的goroutine加入到调度队列中，等待调度运行。</p><br />
<br />
<p>总结<br />
总的来说，netpoller的最终的效果就是用户层阻塞，底层非阻塞。当goroutine读或写阻塞时会被放到等待队列，这个goroutine失去了运行权，但并不是真正的整个系统“阻塞”于系统调用。而通过后台的poller不停地poll，所有的文件描述符都被添加到了这个poller中的，当某个时刻一个文件描述符准备好了，poller就会唤醒之前因它而阻塞的goroutine，于是goroutine重新运行起来。</p><br />
<br />
<p>和使用Unix系统中的select或是poll方法不同地是，Golang的netpoller查询的是能被调度的goroutine而不是那些函数指针、包含了各种状态变量的struct等，这样你就不用管理这些状态，也不用重新检查函数指针等，这些都是你在传统Unix网络I/O需要操心的问题。</p><br />
<br />
<p>netpoll只是一种框架和一些接口，只有依赖这个框架和接口实现的netpoll实例，netpoll才能发挥它的功能。类似于kernel中的vfs，vfs本身并不会去做具体的文件操作，只是为不同的文件系统提供了一个框架。netpoll不依赖于网络协议栈，因此在内核网络及I/O子系统尚未可用时，也可以发送或接收数据包。当然netpoll能够处理的数据包类型也很有限，只有UDP和ARP数据包，并且只能是以太网报文。注意这里对UDP数据包的处理并不像四层的UDP协议那样复杂，并且netpoll可以发挥作用要依赖网络设备的支持。<br />
  1、netpoll结构和netpoll_info结构<br />
  netpoll结构用来描述接收和发送数据包的必要信息，每一个依赖netpoll的模块在使用这个框架前都必须实现并注册netpoll实例。<br />
  netpoll结构定义如下：</p><br />
<br />
<p>[cpp] view plaincopy<br />
struct netpoll {<br /><br />
    struct net_device *dev;<br /><br />
    char dev_name[IFNAMSIZ];</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const char *name;  <br />
   <br />
void (*rx_hook)(struct netpoll *, int, char *, int);  <br />
   <br />
__be32 local_ip, remote_ip;  <br />
u16 local_port, remote_port;  <br />
   <br />
u8 remote_mac[ETH_ALEN];   };     dev成员存储的是绑定的网络设备实例，netpoll实例只能通过特定的网络设备接收和发送数据包。该设备在注册netpoll实例时设置。   dev_name存储的是网络设备名，通过它调用dev_get_by_name()获取指定的网络设备实例，并保存在dev中。   name是netpoll实例的名称。   netpoll实例有两种：能接收数据包和不能接收数据包。如果要接收数据包的话，必须实现rx_hook接口。如果不接收数据包的话，则不用。   local_ip和remote_ip分别存储的是远端和本地的IP，由netpoll实例指定。   local_port和remote_port分别存储的是远端和本地的port。   remote_mac存储的MAC地址。netpoll只支持以太网数据包，所以这里的MAC地址是以太网MAC地址。   当支持netpoll时，网络设备的net_device实例必须实现npinfo成员，即网络设备的netpoll_info信息块，描述结构为netpoll_info，定义如下： [cpp] view plaincopy struct netpoll_info {  <br />
   <br />
atomic_t refcnt;  <br />
   <br />
int rx_flags;  <br />
   <br />
spinlock_t rx_lock;  <br />
   <br />
struct netpoll *rx_np; /* netpoll that registered an rx_hook */  <br />
   <br />
struct sk_buff_head arp_tx; /* list of arp requests to reply to */  <br />
   <br />
struct sk_buff_head txq;  <br />
struct delayed_work tx_work;   };     refcnt是引用计数。每个netpoll_info实例被多个netpoll实例引用，每次引用时都对该成员加1.   rx_flags是标识接收的特性，可取的值为NETPOLL_RX_ENABLED和NETPOLL_RX_DROP（尚未使用）。如果所属的netpoll实例允许接收数据包，则会设置为NETPOLL_RX_ENABLED，否则为0.   rx_lock用来保证同一时刻只有一个CPU在进行相关的netpoll的输入操作。除此之外，在清理netpoll实例操作与netpoll的输入操作互斥，参见netpoll_cleanup().   如果注册的netpoll实例可以接收数据包，则将实例存储在rx_np成员中，不过该成员在发送数据包时也会使用，参见arp_reply().   arp_tx存储的是接收到的ARP报文。这里存储的ARP报文是在service_arp_queue()中处理的，而调用该函数的是netpoll_poll()，后面再讨论netpoll_poll()函数。   如果netpoll没有能成功发送数据包或者设备繁忙，则将待输出报文缓存到txq队列中，重新调度tx_work工作队列，等待再次尝试发送。   2、netpoll的输入   netpoll_rx()函数是netpoll接收数据包的入口函数，在netif_rx()和netif_receive_skb()中都会调用到。如果该函数返回0，则表示当前数据包不是netpoll想要的，继续传递到上层协议栈继续处理；如果返回1，则表示由netpoll来处理，不再向上层传递。   如果是ARP包，是否接收还要看静态变量trapped。trapped默认状态下是0，只有在poll_one_api()中调用网络设备的poll接口接收数据包前，才会加1，接收完后又会减1，如下所示： [cpp] view plaincopy static int poll_one_napi(struct netpoll_info *npinfo,  <br />
         struct napi_struct *napi, int budget)   {  <br />
int work;  <br />
   <br />
/* net_rx_action's -&gt;poll() invocations and our's are <br />
 * synchronized by this test which is only made while <br />
 * holding the napi-&gt;poll_lock. <br />
 */  <br />
if (!test_bit(NAPI_STATE_SCHED, &amp;napi-&gt;state))  <br />
    return budget;  <br />
   <br />
npinfo-&gt;rx_flags |= NETPOLL_RX_DROP;  <br />
atomic_inc(&amp;trapped);  <br />
set_bit(NAPI_STATE_NPSVC, &amp;napi-&gt;state);  <br />
   <br />
work = napi-&gt;poll(napi, budget);  <br />
trace_napi_poll(napi);  <br />
   <br />
clear_bit(NAPI_STATE_NPSVC, &amp;napi-&gt;state);  <br />
atomic_dec(&amp;trapped);  <br />
npinfo-&gt;rx_flags &amp;= ~NETPOLL_RX_DROP;  <br />
   <br />
return budget - work;   }     poll_one_api()是由poll_napi()调用的，如果当前CPU和接收数据包的CPU不是一个CPU，并且此时网卡被放置到轮询列表，即设置了NAPI_STATE_SCHED，才会去执行接收操作。所以netpoll在调度接收网卡的数据包过程中会trap数据包（trapped不为0），这种情况下ARP包会被接收。如果trapped为0，即不trap数据包，并且是ARP数据包，则会传递到上层协议栈。不过，在__netpoll_rx()中返回之前，trapped此时不为0，会丢弃ARP包。   如果是UDP数据包，则主要是检查校验和和IP地址、端口号等信息，确定是否是netpoll想要的数据包，如果不是，则根据trapped决定是丢弃数据包还是传递到上层协议栈。如果是netpoll实例感兴趣的报文，则会调用其注册的rx_hook接口来接收，然后释放掉SKB包（注意，是在调用rx_hook之后立即释放）。   还有一点需要注意，如果netpoll在调度接收网卡的数据包，即trapped不为0，这个过程中会直接释放掉所有不是netpoll想要的数据包（只是netpoll实例绑定的网卡上的数据包）。个人理解是，netpoll只有在发送数据包没有成功或者分配skb失败（尝试10次）时（都是在向外输出数据包的时候）才会调度网卡接收数据包，如果出现这种情况，则说明网卡非常繁忙，并且很多数据包没来得及处理，此时丢掉数据包也是合理的。 3、netpoll的输出   如果接收到ARP报文，会调用arp_reply()来发送ARP响应；如果是UDP报文，则由netpoll实例处理，发送数据包调用的是netpoll_send_udp()。不过这两个接口最终都是在封装好要发送的数据包后，交给netpoll_send_skb()来发送，如下所示： [cpp] view plaincopy static void netpoll_send_skb(struct netpoll *np, struct sk_buff *skb)   {  <br />
......  <br />
   <br />
/* don't get messages out of order, and no recursion */  <br />
if (skb_queue_len(&amp;npinfo-&gt;txq) == 0 &amp;&amp; !netpoll_owner_active(dev)) {  <br />
    struct netdev_queue *txq;  <br />
    unsigned long flags;  <br />
   <br />
    txq = netdev_get_tx_queue(dev, skb_get_queue_mapping(skb));  <br />
   <br />
    local_irq_save(flags);  <br />
    /* try until next clock tick */  <br />
    for (tries = jiffies_to_usecs(1)/USEC_PER_POLL;  <br />
         tries &gt; 0; --tries) {  <br />
        if (__netif_tx_trylock(txq)) {  <br />
            if (!netif_tx_queue_stopped(txq)) {  <br />
                status = ops-&gt;ndo_start_xmit(skb, dev);  <br />
                if (status == NETDEV_TX_OK)  <br />
                    txq_trans_update(txq);  <br />
            }  <br />
            __netif_tx_unlock(txq);  <br />
   <br />
            if (status == NETDEV_TX_OK)  <br />
                break;  <br />
   <br />
        }  <br />
   <br />
        /* tickle device maybe there is some cleanup */  <br />
        netpoll_poll(np);  <br />
   <br />
        udelay(USEC_PER_POLL);  <br />
    }  <br />
   <br />
    WARN_ONCE(!irqs_disabled(),  <br />
        "netpoll_send_skb(): %s enabled interrupts in poll (%pF)\n",  <br />
        dev-&gt;name, ops-&gt;ndo_start_xmit);  <br />
   <br />
    local_irq_restore(flags);  <br />
}  <br />
   <br />
if (status != NETDEV_TX_OK) {  <br />
    skb_queue_tail(&amp;npinfo-&gt;txq, skb);  <br />
    schedule_delayed_work(&amp;npinfo-&gt;tx_work,0);  <br />
}   }     从上面的代码我们可以看到，只有在（skb_queue_len(&amp;npinfo-&gt;txq) == 0 &amp;&amp; !netpoll_owner_active(dev)）为真时才会尝试，发送数据包，否则直接缓存到txq队列中。   如果npinfo-&gt;txq队列不为空，说明tx_work工作队列已经被调度执行，此时直接将数据包缓存到txq队列中，通过tx_work工作队列来输出。注意，这里调用schedule_delayed_work()的时候，延迟时间设置的是0，所以如果重新调度的话，tx_work工作队列会立即开始执行。   如果npinfo-&gt;txq队列为空，是否将数据包直接缓存到txq队列，取决于netpoll_owner_active()的返回值。netpoll_owner_active()源码如下： [cpp] view plaincopy static int netpoll_owner_active(struct net_device *dev)   {  <br />
struct napi_struct *napi;  <br />
   <br />
list_for_each_entry(napi, &amp;dev-&gt;napi_list, dev_list) {  <br />
    if (napi-&gt;poll_owner == smp_processor_id())  <br />
        return 1;  <br />
}  <br />
return 0;   }     poll_owner是在接收数据包的软中断处理函数net_rx_action()中设置的，保存的是当前处理软中断的CPU的ID。如果netpoll实例绑定的网卡没有在接收数据包，也就是网卡没有放到设备轮询列表上，此时会直接返回0.如果此时网卡被放到轮询列表上，但是接收数据包的CPU不是当前的CPU，也会返回0。如果此时绑定的网卡正在接收数据包，并且是当前CPU，才会返回1，这时netpoll在发送SKB包时，会直接将数据包放到txq队列中，等待tx_work工作队列发送。     如果不是上述情况，netpoll_send_skb()会立即调用网络设备的ndo_start_xmit接口发送数据包。如果发送失败，则会尝试多次，直到下一次时钟节拍。如果仍然没有发送成功，则会将数据包缓存到txq队列中。   在尝试重新发送的过程中，netpoll对调用netpoll_poll()接口来模拟网络设备接收到数据包的中断，然后借助其他CPU来接收数据包，源码如下： [cpp] view plaincopy void netpoll_poll(struct netpoll *np)   {  <br />
struct net_device *dev = np-&gt;dev;  <br />
const struct net_device_ops *ops;  <br />
   <br />
if (!dev || !netif_running(dev))  <br />
    return;  <br />
   <br />
ops = dev-&gt;netdev_ops;  <br />
if (!ops-&gt;ndo_poll_controller)  <br />
    return;  <br />
   <br />
/* Process pending work on NIC */  <br />
ops-&gt;ndo_poll_controller(dev);  <br />
   <br />
poll_napi(dev);  <br />
   <br />
/* <br />
  * 处理arp_tx队列中的ARP报文 <br />
  */  <br />
service_arp_queue(dev-&gt;npinfo);  <br />
   <br />
zap_completion_queue();   }     模拟中断的接口是ndo_poll_controller，如果网卡不支持，则直接返回。模拟中断后，网卡设备会被放到轮询列表上，在poll_api()中会检查接收数据包的CPU和当前CPU是否是同一个CPU，如果不是，则会调用poll_one_napi()去使用网络设备的poll接口来接收数据包，否则直接返回，避免在UP上出现递归的情况。如果可以接收数据包，则trapped会加1，此时netpoll会trap数据包，该网卡上不是netpoll想要的数据包都会被直接丢掉，也只有在这段时间netpoll才可以接收ARP报文。所以我们看到，处理netpoll接收到的ARP包的接口，只在netpoll_poll()中调用，也只有在此时才有必要去处理接收到的ARP包。   综上所述，netpoll_poll()会加速网卡对数据包的处理，这样下次发送数据包时就更容易成功。 4、netpoll应用   netconsole是依赖netpoll实现的，可以将本机的dmesg系统信息，通过网络的方式输出到另一台主机上。这样就可以实现远程监控某些主机的dmesg信息，给开发人员调试内核提供了非常方便的途径。netconolse的使用方法参见内核文档netconsole.txt，里面介绍的非常详细 <br />
</code></pre></div></div><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>