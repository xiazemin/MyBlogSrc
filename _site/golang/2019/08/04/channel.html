<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">channel</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-08-04T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Aug 4, 2019</time></p>
					</div>
					 <p>并发问题一般有下面这几种：</p><br />
<br />
<p>数据竞争。简单来说就是两个或多个线程同时读写某个变量，造成了预料之外的结果。</p><br />
<br />
<p>原子性。在一个定义好的上下文里，原子性操作不可分割。上下文的定义非常重要。有些代码，你在程序里看起来是原子的，如最简单的 i++，但在机器层面看来，这条语句通常需要几条指令来完成（Load，Incr，Store），不是不可分割的，也就不是原子性的。原子性可以让我们放心地构造并发安全的程序。</p><br />
<br />
<p>内存访问同步。代码中需要控制同时只有一个线程访问的区域称为临界区。Go 语言中一般使用 sync 包里的 Mutex 来完成同步访问控制。锁一般会带来比较大的性能开销，因此一般要考虑加锁的区域是否会频繁进入、锁的粒度如何控制等问题。</p><br />
<br />
<p>死锁。在一个死锁的程序里，每个线程都在等待其他线程，形成了一个首尾相连的尴尬局面，程序无法继续运行下去。</p><br />
<br />
<p>活锁。想象一下，你走在一条小路上，一个人迎面走来。你往左边走，想避开他；他做了相反的事情，他往右边走，结果两个都过不了。之后，两个人又都想从原来自己相反的方向走，还是同样的结果。这就是活锁，看起来都像在工作，但工作进度就是无法前进。</p><br />
<br />
<p>饥饿。并发的线程不能获取它所需要的资源以进行下一步的工作。通常是有一个非常贪婪的线程，长时间占据资源不释放，导致其他线程无法获得资源。</p><br />
<br />
<p>关于并发和并行的区别，引用一个经典的描述：</p><br />
<br />
<p>并发是同一时间应对（dealing with）多件事情的能力。<br />
并行是同一时间动手（doing）做多件事情的能力。<br />
雨痕老师《Go 语言学习笔记》上的解释：</p><br />
<br />
<p>并发是指逻辑上具备同时处理多个任务的能力；并行则是物理上同时执行多个任务。<br />
<!-- more --><br />
而根据《Concurrency in Go》这本书，计算机的概念都是抽象的结果，并发和并行也不例外。它这样描述并发和并行的区别：</p><br />
<br />
<p>Concurrency is a property of the code; parallelism is a property of the running program.<br />
并发是代码的特性，并行是正在运行的程序的特性。先忽略我拙劣的翻译。很新奇，不是吗？我也是第一次见到这样的说法，细想一下，还是很有道理的。</p><br />
<br />
<p>我们一直说写的代码是并发的或者是并行的，但是我们能提供什么保证吗？如果在只有一个核的机器上跑并行的代码，它还能并行吗？你就是再天才，也无法写出并行的程序。充其量也就是代码上看起来“并发”的，如此而已。</p><br />
<br />
<p>当然，表面上看起来还是并行的，但那不过 CPU 的障眼法，多个线程在分时共享 CPU 的资源，在一个粗糙的时间隔里看起来就是“并行”。</p><br />
<br />
<p>所以，我们实际上只能编写“并发”的代码，而不能编写“并行”的代码，而且只是希望并发的代码能够并行地执行。并发的代码能否并行，取决于抽象的层级：代码里的并发原语、runtime，操作系统（虚拟机、容器）。层级越来越底层，要求也越来越高。因此，我们谈并发或并行实际上要指定上下文，也就是抽象的层级。</p><br />
<br />
<p>《Concurrency in Go》书里举了一个例子：假如两个人同时打开电脑上的计算器程序，这两个程序肯定不会影响彼此，这就是并行。在这个例子中，上下文就是两个人的机器，而两个计算器进程就是并行的元素。</p><br />
<br />
<p>随着抽象层次的降低，并发模型实际上变得更难也更重要，而越低层次的并发模型对我们也越重要。要想并发程序正确地执行，就要深入研究并发模型。</p><br />
<br />
<p>在 Go 语言发布前，我们写并发代码时，考虑到的最底层抽象是：系统线程。Go 发布之后，在这条抽象链上，又加一个 goroutine。而且 Go 从著名的计算机科学家 Tony Hoare 那借来一个概念：channel。Tony Hoare 就是那篇著名文章《Communicating Sequential Processes》的作者。</p><br />
<br />
<p>看起来事情变得更加复杂，因为 Go 又引入了一个更底层的抽象，但事实并不是这样。因为 goroutine 并不是看起来的那样又抽象了一层，它其实是替代了系统线程。Gopher 在写代码的时候，并不会去关心系统线程，大部分时候只需要考虑到 goroutine 和 channel。当然有时候会用到一些共享内存的概念，一般就是指 sync 包里的东西，比如 sync.Mutex。</p><br />
<br />
<p>什么是 CSP<br />
CSP 经常被认为是 Go 在并发编程上成功的关键因素。CSP 全称是 “Communicating Sequential Processes”，这也是 Tony Hoare 在 1978 年发表在 ACM 的一篇论文。论文里指出一门编程语言应该重视 input 和 output 的原语，尤其是并发编程的代码。</p><br />
<br />
<p>在那篇文章发表的时代，人们正在研究模块化编程的思想，该不该用 goto 语句在当时是最激烈的议题。彼时，面向对象编程的思想正在崛起，几乎没什么人关心并发编程。</p><br />
<br />
<p>在文章中，CSP 也是一门自定义的编程语言，作者定义了输入输出语句，用于 processes 间的通信（communicatiton）。processes 被认为是需要输入驱动，并且产生输出，供其他 processes 消费，processes 可以是进程、线程、甚至是代码块。输入命令是：!，用来向 processes 写入；输出是：?，用来从 processes 读出。这篇文章要讲的 channel 正是借鉴了这一设计。</p><br />
<br />
<p>Hoare 还提出了一个 -&gt; 命令，如果 -&gt; 左边的语句返回 false，那它右边的语句就不会执行。</p><br />
<br />
<p>通过这些输入输出命令，Hoare 证明了如果一门编程语言中把 processes 间的通信看得第一等重要，那么并发编程的问题就会变得简单。</p><br />
<br />
<p>Go 是第一个将 CSP 的这些思想引入，并且发扬光大的语言。仅管内存同步访问控制（原文是 memory access synchronization）在某些情况下大有用处，Go 里也有相应的 sync 包支持，但是这在大型程序很容易出错。</p><br />
<br />
<p>Go 一开始就把 CSP 的思想融入到语言的核心里，所以并发编程成为 Go 的一个独特的优势，而且很容易理解。</p><br />
<br />
<p>大多数的编程语言的并发编程模型是基于线程和内存同步访问控制，Go 的并发编程的模型则用 goroutine 和 channel 来替代。Goroutine 和线程类似，channel 和 mutex (用于内存同步访问控制)类似。</p><br />
<br />
<p>Goroutine 解放了程序员，让我们更能贴近业务去思考问题。而不用考虑各种像线程库、线程开销、线程调度等等这些繁琐的底层问题，goroutine 天生替你解决好了。</p><br />
<br />
<p>Channel 则天生就可以和其他 channel 组合。我们可以把收集各种子系统结果的 channel 输入到同一个 channel。Channel 还可以和 select, cancel, timeout 结合起来。而 mutex 就没有这些功能。</p><br />
<br />
<p>Go 的并发原则非常优秀，目标就是简单：尽量使用 channel；把 goroutine 当作免费的资源，随便用。</p><br />
<br />
<p>说明一下，前面这两部分的内容来自英文开源书《Concurrency In Go》，强烈推荐阅读。</p><br />
<br />
<p>引入结束，我们正式开始今天的主角：channel。</p><br />
<br />
<p>什么是 channel<br />
Goroutine 和 channel 是 Go 语言并发编程的 两大基石。Goroutine 用于执行并发任务，channel 用于 goroutine 之间的同步、通信。</p><br />
<br />
<p>Channel 在 gouroutine 间架起了一条管道，在管道里传输数据，实现 gouroutine 间的通信；由于它是线程安全的，所以用起来非常方便；channel 还提供“先进先出”的特性；它还能影响 goroutine 的阻塞和唤醒。</p><br />
<br />
<p>相信大家一定见过一句话：</p><br />
<br />
<p>Do not communicate by sharing memory; instead, share memory by communicating.<br />
不要通过共享内存来通信，而要通过通信来实现内存共享。</p><br />
<br />
<p>这就是 Go 的并发哲学，它依赖 CSP 模型，基于 channel 实现。</p><br />
<br />
<p>简直是一头雾水，这两句话难道不是同一个意思？</p><br />
<br />
<p>通过前面两节的内容，我个人这样理解这句话：前面半句说的是通过 sync 包里的一些组件进行并发编程；而后面半句则是说 Go 推荐使用 channel 进行并发编程。两者其实都是必要且有效的。实际上看完本文后面对 channel 的源码分析，你会发现，channel 的底层就是通过 mutex 来控制并发的。只是 channel 是更高一层次的并发编程原语，封装了更多的功能。</p><br />
<br />
<p>关于是选择 sync 包里的底层并发编程原语还是 channel，《Concurrency In Go》这本书的第 2 章 “Go’s Philosophy on Concurrency” 里有一张决策树和详细的论述，再次推荐你去阅读。</p><br />
<br />
<p>channel 实现 CSP<br />
Channel 是 Go 语言中一个非常重要的类型，是 Go 里的第一对象。通过 channel，Go 实现了通过通信来实现内存共享。Channel 是在多个 goroutine 之间传递数据和同步的重要手段。</p><br />
<br />
<p>使用原子函数、读写锁可以保证资源的共享访问安全，但使用 channel 更优雅。</p><br />
<br />
<p>channel 字面意义是“通道”，类似于 Linux 中的管道。声明 channel 的语法如下：</p><br />
<br />
<p>chan T // 声明一个双向通道<br />
chan&lt;- T // 声明一个只能用于发送的通道<br />
&lt;-chan T // 声明一个只能用于接收的通道<br />
单向通道的声明，用 &lt;- 来表示，它指明通道的方向。你只要明白，代码的书写顺序是从左到右就马上能掌握通道的方向是怎样的。</p><br />
<br />
<p>因为 channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。可以向它传递一个 int 值，代表 channel 缓冲区的大小（容量），构造出来的是一个缓冲型的 channel；不传或传 0 的，构造的就是一个非缓冲型的 channel。</p><br />
<br />
<p>两者有一些差别：非缓冲型 channel 无法缓冲元素，对它的操作一定顺序是“发送-&gt; 接收 -&gt; 发送 -&gt; 接收 -&gt; ……”，如果连续向一个非缓冲 chan 发送 2 个元素，并且没有接收的话，第二次一定会被阻塞；对于缓冲型 channel 的操作，则要“宽松”一些，毕竟是带了“缓冲”光环。</p><br />
<br />
<p>为什么要 channel<br />
Go 通过 channel 实现 CSP 通信模型，主要用于 goroutine 之间的消息传递和事件通知。</p><br />
<br />
<p>有了 channel 和 goroutine 之后，Go 的并发编程变得异常容易和安全，得以让程序员把注意力留到业务上去，实现开发效率的提升。</p><br />
<br />
<p>channel 实现原理<br />
对 chan 的发送和接收操作都会在编译期间转换成为底层的发送接收函数。</p><br />
<br />
<p>Channel 分为两种：带缓冲、不带缓冲。对不带缓冲的 channel 进行的操作实际上可以看作“同步模式”，带缓冲的则称为“异步模式”。</p><br />
<br />
<p>同步模式下，发送方和接收方要同步就绪，只有在两者都 ready 的情况下，数据才能在两者间传输（后面会看到，实际上就是内存拷贝）。否则，任意一方先行进行发送或接收操作，都会被挂起，等待另一方的出现才能被唤醒。</p><br />
<br />
<p>异步模式下，在缓冲槽可用的情况下（有剩余容量），发送和接收操作都可以顺利进行。否则，操作的一方（如写入）同样会被挂起，直到出现相反操作（如接收）才会被唤醒。</p><br />
<br />
<p>小结一下：同步模式下，必须要使发送方和接收方配对，操作才会成功，否则会被阻塞；异步模式下，缓冲槽要有剩余容量，操作才会成功，否则也会被阻塞。</p><br />
<br />
<p>数据结构<br />
直接上源码（版本是 1.9.2）：</p><br />
<br />
<p>type hchan struct {<br />
    // chan 里元素数量<br />
    qcount   uint<br />
    // chan 底层循环数组的长度<br />
    dataqsiz uint<br />
    // 指向底层循环数组的指针<br />
    // 只针对有缓冲的 channel<br />
    buf      unsafe.Pointer<br />
    // chan 中元素大小<br />
    elemsize uint16<br />
    // chan 是否被关闭的标志<br />
    closed   uint32<br />
    // chan 中元素类型<br />
    elemtype *_type // element type<br />
    // 已发送元素在循环数组中的索引<br />
    sendx    uint   // send index<br />
    // 已接收元素在循环数组中的索引<br />
    recvx    uint   // receive index<br />
    // 等待接收的 goroutine 队列<br />
    recvq    waitq  // list of recv waiters<br />
    // 等待发送的 goroutine 队列<br />
    sendq    waitq  // list of send waiters</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 保护 hchan 中所有字段<br />
lock mutex } 关于字段的含义都写在注释里了，再来重点说几个字段：<br />
</code></pre></div></div><br />
<br />
<p>buf 指向底层循环数组，只有缓冲型的 channel 才有。</p><br />
<br />
<p>sendx，recvx 均指向底层循环数组，表示当前可以发送和接收的元素位置索引值（相对于底层数组）。</p><br />
<br />
<p>sendq，recvq 分别表示被阻塞的 goroutine，这些 goroutine 由于尝试读取 channel 或向 channel 发送数据而被阻塞。</p><br />
<br />
<p>waitq 是 sudog 的一个双向链表，而 sudog 实际上是对 goroutine 的一个封装：</p><br />
<br />
<p>type waitq struct {<br />
    first *sudog<br />
    last  *sudog<br />
}<br />
lock 用来保证每个读 channel 或写 channel 的操作都是原子的。</p><br />
<br />
<p>创建<br />
我们知道，通道有两个方向，发送和接收。理论上来说，我们可以创建一个只发送或只接收的通道，但是这种通道创建出来后，怎么使用呢？一个只能发的通道，怎么接收呢？同样，一个只能收的通道，如何向其发送数据呢？</p><br />
<br />
<p>一般而言，使用 make 创建一个能收能发的通道：</p><br />
<br />
<p>// 无缓冲通道<br />
ch1 := make(chan int)<br />
// 有缓冲通道<br />
ch2 := make(chan int, 10)<br />
通过汇编分析，我们知道，最终创建 chan 的函数是 makechan：</p><br />
<br />
<p>func makechan(t *chantype, size int64) *hchan<br />
从函数原型来看，创建的 chan 是一个指针。所以我们能在函数间直接传递 channel，而不用传递 channel 的指针。</p><br />
<br />
<p>具体来看下代码：</p><br />
<br />
<p>const hchanSize = unsafe.Sizeof(hchan{}) + uintptr(-int(unsafe.Sizeof(hchan{}))&amp;(maxAlign-1))</p><br />
<br />
<p>func makechan(t *chantype, size int64) *hchan {<br />
    elem := t.elem</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 省略了检查 channel size，align 的代码<br />
// ……<br />
<br />
var c *hchan<br />
// 如果元素类型不含指针 或者 size 大小为 0（无缓冲类型）<br />
// 只进行一次内存分配<br />
if elem.kind&amp;kindNoPointers != 0 || size == 0 {<br />
    // 如果 hchan 结构体中不含指针，GC 就不会扫描 chan 中的元素<br />
    // 只分配 "hchan 结构体大小 + 元素大小*个数" 的内存<br />
    c = (*hchan)(mallocgc(hchanSize+uintptr(size)*elem.size, nil, true))<br />
    // 如果是缓冲型 channel 且元素大小不等于 0（大小等于 0的元素类型：struct{}）<br />
    if size &gt; 0 &amp;&amp; elem.size != 0 {<br />
        c.buf = add(unsafe.Pointer(c), hchanSize)<br />
    } else {<br />
        // race detector uses this location for synchronization<br />
        // Also prevents us from pointing beyond the allocation (see issue 9401).<br />
        // 1. 非缓冲型的，buf 没用，直接指向 chan 起始地址处<br />
        // 2. 缓冲型的，能进入到这里，说明元素无指针且元素类型为 struct{}，也无影响<br />
        // 因为只会用到接收和发送游标，不会真正拷贝东西到 c.buf 处（这会覆盖 chan的内容）<br />
        c.buf = unsafe.Pointer(c)<br />
    }<br />
} else {<br />
    // 进行两次内存分配操作<br />
    c = new(hchan)<br />
    c.buf = newarray(elem, int(size))<br />
}<br />
c.elemsize = uint16(elem.size)<br />
c.elemtype = elem<br />
// 循环数组长度<br />
c.dataqsiz = uint(size)<br />
<br />
// 返回 hchan 指针<br />
return c } 新建一个 chan 后，内存在堆上分配<br />
</code></pre></div></div><br />
<br />
<p>深入 channel 底层】的例子来理解创建、发送、接收的整个过程。</p><br />
<br />
<p>func goroutineA(a &lt;-chan int) {<br />
    val := &lt;- a<br />
    fmt.Println(“G1 received data: “, val)<br />
    return<br />
}</p><br />
<br />
<p>func goroutineB(b &lt;-chan int) {<br />
    val := &lt;- b<br />
    fmt.Println(“G2 received data: “, val)<br />
    return<br />
}</p><br />
<br />
<p>func main() {<br />
    ch := make(chan int)<br />
    go goroutineA(ch)<br />
    go goroutineB(ch)<br />
    ch &lt;- 3<br />
    time.Sleep(time.Second)<br />
}<br />
首先创建了一个无缓冲的 channel，接着启动两个 goroutine，并将前面创建的 channel 传递进去。然后，向这个 channel 中发送数据 3，最后 sleep 1 秒后程序退出。</p><br />
<br />
<p>程序第 14 行创建了一个非缓冲型的 channel，我们只看 chan 结构体中的一些重要字段，来从整体层面看一下 chan 的状态，一开始什么都没有：</p><br />
<br />
<p>接收<br />
在继续分析前面小节的例子前，我们先来看一下接收相关的源码。在清楚了接收的具体过程之后，也就能轻松理解具体的例子了。</p><br />
<br />
<p>接收操作有两种写法，一种带 “ok”，反应 channel 是否关闭；一种不带 “ok”，这种写法，当接收到相应类型的零值时无法知道是真实的发送者发送过来的值，还是 channel 被关闭后，返回给接收者的默认类型的零值。两种写法，都有各自的应用场景。</p><br />
<br />
<p>经过编译器的处理后，这两种写法最后对应源码里的这两个函数：</p><br />
<br />
<p>// entry points for &lt;- c from compiled code<br />
func chanrecv1(c *hchan, elem unsafe.Pointer) {<br />
    chanrecv(c, elem, true)<br />
}</p><br />
<br />
<p>func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {<br />
    _, received = chanrecv(c, elem, true)<br />
    return<br />
}<br />
chanrecv1 函数处理不带 “ok” 的情形，chanrecv2 则通过返回 “received” 这个字段来反应 channel 是否被关闭。接收值则比较特殊，会“放到”参数 elem 所指向的地址了，这很像 C/C++ 里的写法。如果代码里忽略了接收值，这里的 elem 为 nil。</p><br />
<br />
<p>无论如何，最终转向了 chanrecv 函数：</p><br />
<br />
<p>// 位于 src/runtime/chan.go</p><br />
<br />
<p>// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。<br />
// 如果 ep 是 nil，说明忽略了接收值。<br />
// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)<br />
// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)<br />
// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)<br />
// 如果 ep 非空，则应该指向堆或者函数调用者的栈</p><br />
<br />
<p>func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {<br />
    // 省略 debug 内容 …………</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 如果是一个 nil 的 channel<br />
if c == nil {<br />
    // 如果不阻塞，直接返回 (false, false)<br />
    if !block {<br />
        return<br />
    }<br />
    // 否则，接收一个 nil 的 channel，goroutine 挂起<br />
    gopark(nil, nil, "chan receive (nil chan)", traceEvGoStop, 2)<br />
    // 不会执行到这里<br />
    throw("unreachable")<br />
}<br />
<br />
// 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回<br />
// 当我们观察到 channel 没准备好接收：<br />
// 1. 非缓冲型，等待发送列队 sendq 里没有 goroutine 在等待<br />
// 2. 缓冲型，但 buf 里没有元素<br />
// 之后，又观察到 closed == 0，即 channel 未关闭。<br />
// 因为 channel 不可能被重复打开，所以前一个观测的时候 channel 也是未关闭的，<br />
// 因此在这种情况下可以直接宣布接收失败，返回 (false, false)<br />
if !block &amp;&amp; (c.dataqsiz == 0 &amp;&amp; c.sendq.first == nil ||<br />
    c.dataqsiz &gt; 0 &amp;&amp; atomic.Loaduint(&amp;c.qcount) == 0) &amp;&amp;<br />
    atomic.Load(&amp;c.closed) == 0 {<br />
    return<br />
}<br />
<br />
var t0 int64<br />
if blockprofilerate &gt; 0 {<br />
    t0 = cputicks()<br />
}<br />
<br />
// 加锁<br />
lock(&amp;c.lock)<br />
<br />
// channel 已关闭，并且循环数组 buf 里没有元素<br />
// 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况<br />
// 也就是说即使是关闭状态，但在缓冲型的 channel，<br />
// buf 里有元素的情况下还能接收到元素<br />
if c.closed != 0 &amp;&amp; c.qcount == 0 {<br />
    if raceenabled {<br />
        raceacquire(unsafe.Pointer(c))<br />
    }<br />
    // 解锁<br />
    unlock(&amp;c.lock)<br />
    if ep != nil {<br />
        // 从一个已关闭的 channel 执行接收操作，且未忽略返回值<br />
        // 那么接收的值将是一个该类型的零值<br />
        // typedmemclr 根据类型清理相应地址的内存<br />
        typedmemclr(c.elemtype, ep)<br />
    }<br />
    // 从一个已关闭的 channel 接收，selected 会返回true<br />
    return true, false<br />
}<br />
<br />
// 等待发送队列里有 goroutine 存在，说明 buf 是满的<br />
// 这有可能是：<br />
// 1. 非缓冲型的 channel<br />
// 2. 缓冲型的 channel，但 buf 满了<br />
// 针对 1，直接进行内存拷贝（从 sender goroutine -&gt; receiver goroutine）<br />
// 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部<br />
if sg := c.sendq.dequeue(); sg != nil {<br />
    // Found a waiting sender. If buffer is size 0, receive value<br />
    // directly from sender. Otherwise, receive from head of queue<br />
    // and add sender's value to the tail of the queue (both map to<br />
    // the same buffer slot because the queue is full).<br />
    recv(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)<br />
    return true, true<br />
}<br />
<br />
// 缓冲型，buf 里有元素，可以正常接收<br />
if c.qcount &gt; 0 {<br />
    // 直接从循环数组里找到要接收的元素<br />
    qp := chanbuf(c, c.recvx)<br />
<br />
    // …………<br />
<br />
    // 代码里，没有忽略要接收的值，不是 "&lt;- ch"，而是 "val &lt;- ch"，ep 指向 val<br />
    if ep != nil {<br />
        typedmemmove(c.elemtype, ep, qp)<br />
    }<br />
    // 清理掉循环数组里相应位置的值<br />
    typedmemclr(c.elemtype, qp)<br />
    // 接收游标向前移动<br />
    c.recvx++<br />
    // 接收游标归零<br />
    if c.recvx == c.dataqsiz {<br />
        c.recvx = 0<br />
    }<br />
    // buf 数组里的元素个数减 1<br />
    c.qcount--<br />
    // 解锁<br />
    unlock(&amp;c.lock)<br />
    return true, true<br />
}<br />
<br />
if !block {<br />
    // 非阻塞接收，解锁。selected 返回 false，因为没有接收到值<br />
    unlock(&amp;c.lock)<br />
    return false, false<br />
}<br />
<br />
// 接下来就是要被阻塞的情况了<br />
// 构造一个 sudog<br />
gp := getg()<br />
mysg := acquireSudog()<br />
mysg.releasetime = 0<br />
if t0 != 0 {<br />
    mysg.releasetime = -1<br />
}<br />
<br />
// 待接收数据的地址保存下来<br />
mysg.elem = ep<br />
mysg.waitlink = nil<br />
gp.waiting = mysg<br />
mysg.g = gp<br />
mysg.selectdone = nil<br />
mysg.c = c<br />
gp.param = nil<br />
// 进入channel 的等待接收队列<br />
c.recvq.enqueue(mysg)<br />
// 将当前 goroutine 挂起<br />
goparkunlock(&amp;c.lock, "chan receive", traceEvGoBlockRecv, 3)<br />
<br />
// 被唤醒了，接着从这里继续执行一些扫尾工作<br />
if mysg != gp.waiting {<br />
    throw("G waiting list is corrupted")<br />
}<br />
gp.waiting = nil<br />
if mysg.releasetime &gt; 0 {<br />
    blockevent(mysg.releasetime-t0, 2)<br />
}<br />
closed := gp.param == nil<br />
gp.param = nil<br />
mysg.c = nil<br />
releaseSudog(mysg)<br />
return true, !closed } 上面的代码注释地比较详细了，你可以对着源码一行行地去看，我们再来详细看一下。<br />
</code></pre></div></div><br />
<br />
<p>如果 channel 是一个空值（nil），在非阻塞模式下，会直接返回。在阻塞模式下，会调用 gopark 函数挂起 goroutine，这个会一直阻塞下去。因为在 channel 是 nil 的情况下，要想不阻塞，只有关闭它，但关闭一个 nil 的 channel 又会发生 panic，所以没有机会被唤醒了。更详细地可以在 closechan 函数的时候再看。<br />
和发送函数一样，接下来搞了一个在非阻塞模式下，不用获取锁，快速检测到失败并且返回的操作。顺带插一句，我们平时在写代码的时候，找到一些边界条件，快速返回，能让代码逻辑更清晰，因为接下来的正常情况就比较少，更聚焦了，看代码的人也更能专注地看核心代码逻辑了。<br />
    // 在非阻塞模式下，快速检测到失败，不用获取锁，快速返回 (false, false)<br />
    if !block &amp;&amp; (c.dataqsiz == 0 &amp;&amp; c.sendq.first == nil ||<br />
        c.dataqsiz &gt; 0 &amp;&amp; atomic.Loaduint(&amp;c.qcount) == 0) &amp;&amp;<br />
        atomic.Load(&amp;c.closed) == 0 {<br />
        return<br />
    }<br />
当我们观察到 channel 没准备好接收：</p><br />
<br />
<p>非缓冲型，等待发送列队里没有 goroutine 在等待<br />
缓冲型，但 buf 里没有元素<br />
之后，又观察到 closed == 0，即 channel 未关闭。</p><br />
<br />
<p>因为 channel 不可能被重复打开，所以前一个观测的时候， channel 也是未关闭的，因此在这种情况下可以直接宣布接收失败，快速返回。因为没被选中，也没接收到数据，所以返回值为 (false, false)。</p><br />
<br />
<p>接下来的操作，首先会上一把锁，粒度比较大。如果 channel 已关闭，并且循环数组 buf 里没有元素。对应非缓冲型关闭和缓冲型关闭但 buf 无元素的情况，返回对应类型的零值，但 received 标识是 false，告诉调用者此 channel 已关闭，你取出来的值并不是正常由发送者发送过来的数据。但是如果处于 select 语境下，这种情况是被选中了的。很多将 channel 用作通知信号的场景就是命中了这里。<br />
接下来，如果有等待发送的队列，说明 channel 已经满了，要么是非缓冲型的 channel，要么是缓冲型的 channel，但 buf 满了。这两种情况下都可以正常接收数据。<br />
于是，调用 recv 函数：</p><br />
<br />
<p>func recv(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {<br />
    // 如果是非缓冲型的 channel<br />
    if c.dataqsiz == 0 {<br />
        if raceenabled {<br />
            racesync(c, sg)<br />
        }<br />
        // 未忽略接收的数据<br />
        if ep != nil {<br />
            // 直接拷贝数据，从 sender goroutine -&gt; receiver goroutine<br />
            recvDirect(c.elemtype, sg, ep)<br />
        }<br />
    } else {<br />
        // 缓冲型的 channel，但 buf 已满。<br />
        // 将循环数组 buf 队首的元素拷贝到接收数据的地址<br />
        // 将发送者的数据入队。实际上这时 revx 和 sendx 值相等<br />
        // 找到接收游标<br />
        qp := chanbuf(c, c.recvx)<br />
        // …………<br />
        // 将接收游标处的数据拷贝给接收者<br />
        if ep != nil {<br />
            typedmemmove(c.elemtype, ep, qp)<br />
        }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // 将发送者数据拷贝到 buf<br />
    typedmemmove(c.elemtype, qp, sg.elem)<br />
    // 更新游标值<br />
    c.recvx++<br />
    if c.recvx == c.dataqsiz {<br />
        c.recvx = 0<br />
    }<br />
    c.sendx = c.recvx<br />
}<br />
sg.elem = nil<br />
gp := sg.g<br />
<br />
// 解锁<br />
unlockf()<br />
gp.param = unsafe.Pointer(sg)<br />
if sg.releasetime != 0 {<br />
    sg.releasetime = cputicks()<br />
}<br />
<br />
// 唤醒发送的 goroutine。需要等到调度器的光临<br />
goready(gp, skip+1) } 如果是非缓冲型的，就直接从发送者的栈拷贝到接收者的栈。<br />
</code></pre></div></div><br />
<br />
<p>func recvDirect(t *_type, sg *sudog, dst unsafe.Pointer) {<br />
    // dst is on our stack or the heap, src is on another stack.<br />
    src := sg.elem<br />
    typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)<br />
    memmove(dst, src, t.size)<br />
}<br />
否则，就是缓冲型 channel，而 buf 又满了的情形。说明发送游标和接收游标重合了，因此需要先找到接收游标：</p><br />
<br />
<p>// chanbuf(c, i) is pointer to the i’th slot in the buffer.<br />
func chanbuf(c <em>hchan, i uint) unsafe.Pointer {<br />
    return add(c.buf, uintptr(i)</em>uintptr(c.elemsize))<br />
}<br />
将该处的元素拷贝到接收地址。然后将发送者待发送的数据拷贝到接收游标处。这样就完成了接收数据和发送数据的操作。接着，分别将发送游标和接收游标向前进一，如果发生“环绕”，再从 0 开始。</p><br />
<br />
<p>最后，取出 sudog 里的 goroutine，调用 goready 将其状态改成 “runnable”，待发送者被唤醒，等待调度器的调度。</p><br />
<br />
<p>然后，如果 channel 的 buf 里还有数据，说明可以比较正常地接收。注意，这里，即使是在 channel 已经关闭的情况下，也是可以走到这里的。这一步比较简单，正常地将 buf 里接收游标处的数据拷贝到接收数据的地址。<br />
到了最后一步，走到这里来的情形是要阻塞的。当然，如果 block 传进来的值是 false，那就不阻塞，直接返回就好了。<br />
先构造一个 sudog，接着就是保存各种值了。注意，这里会将接收数据的地址存储到了 elem 字段，当被唤醒时，接收到的数据就会保存到这个字段指向的地址。然后将 sudog 添加到 channel 的 recvq 队列里。调用 goparkunlock 函数将 goroutine 挂起。</p><br />
<br />
<p>接下来的代码就是 goroutine 被唤醒后的各种收尾工作了。</p><br />
<br />
<p>我们继续之前的例子。前面说到第 14 行，创建了一个非缓冲型的 channel，接着，第 15、16 行分别创建了一个 goroutine，各自执行了一个接收操作。通过前面的源码分析，我们知道，这两个 goroutine （后面称为 G1 和 G2 好了）都会被阻塞在接收操作。G1 和 G2 会挂在 channel 的 recq 队列中，形成一个双向循环链表。</p><br />
<br />
<p>在程序的 17 行之前</p><br />
<br />
<p>buf 指向一个长度为 0 的数组，qcount 为 0，表示 channel 中没有元素。重点关注 recvq 和 sendq，它们是 waitq 结构体，而 waitq 实际上就是一个双向链表，链表的元素是 sudog，里面包含 g 字段，g 表示一个 goroutine，所以 sudog 可以看成一个 goroutine。recvq 存储那些尝试读取 channel 但被阻塞的 goroutine，sendq 则存储那些尝试写入 channel，但被阻塞的 goroutine。</p><br />
<br />
<p>此时，我们可以看到，recvq 里挂了两个 goroutine，也就是前面启动的 G1 和 G2。因为没有 goroutine 接收，而 channel 又是无缓冲类型，所以 G1 和 G2 被阻塞。sendq 没有被阻塞的 goroutine。</p><br />
<br />
<p>G1 和 G2 被挂起了，状态是 WAITING。关于 goroutine 调度器这块不是今天的重点，当然后面肯定会写相关的文章。这里先简单说下，goroutine 是用户态的协程，由 Go runtime 进行管理，作为对比，内核线程由 OS 进行管理。Goroutine 更轻量，因此我们可以轻松创建数万 goroutine。</p><br />
<br />
<p>一个内核线程可以管理多个 goroutine，当其中一个 goroutine 阻塞时，内核线程可以调度其他的 goroutine 来运行，内核线程本身不会阻塞。这就是通常我们说的 M:N 模型</p><br />
<br />
<p>M:N 模型通常由三部分构成：M、P、G。M 是内核线程，负责运行 goroutine；P 是 context，保存 goroutine 运行所需要的上下文，它还维护了可运行（runnable）的 goroutine 列表；G 则是待运行的 goroutine。M 和 P 是 G 运行的基础。</p><br />
<br />
<p>假设我们只有一个 M，当 G1（go goroutineA(ch)） 运行到 val := &lt;- a 时，它由本来的 running 状态变成了 waiting 状态（调用了 gopark 之后的结果）</p><br />
<br />
<p>G1 脱离与 M 的关系，但调度器可不会让 M 闲着，所以会接着调度另一个 goroutine 来运行：</p><br />
<br />
<p>G2 也是同样的遭遇。现在 G1 和 G2 都被挂起了，等待着一个 sender 往 channel 里发送数据，才能得到解救。</p><br />
<br />
<p>发送<br />
接着上面的例子，G1 和 G2 现在都在 recvq 队列里了。</p><br />
<br />
<p>ch &lt;- 3<br />
第 17 行向 channel 发送了一个元素 3。</p><br />
<br />
<p>G2 也是同样的遭遇。现在 G1 和 G2 都被挂起了，等待着一个 sender 往 channel 里发送数据，才能得到解救。</p><br />
<br />
<p>发送<br />
接着上面的例子，G1 和 G2 现在都在 recvq 队列里了。</p><br />
<br />
<p>ch &lt;- 3<br />
第 17 行向 channel 发送了一个元素 3。</p><br />
<br />
<p>发送操作最终转化为 chansend 函数，直接上源码，同样大部分都注释了，可以看懂主流程：</p><br />
<br />
<p>// 位于 src/runtime/chan.go</p><br />
<br />
<p>func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {<br />
    // 如果 channel 是 nil<br />
    if c == nil {<br />
        // 不能阻塞，直接返回 false，表示未发送成功<br />
        if !block {<br />
            return false<br />
        }<br />
        // 当前 goroutine 被挂起<br />
        gopark(nil, nil, “chan send (nil chan)”, traceEvGoStop, 2)<br />
        throw(“unreachable”)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 省略 debug 相关……<br />
<br />
// 对于不阻塞的 send，快速检测失败场景<br />
//<br />
// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：<br />
// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine<br />
// 2. channel 是缓冲型的，但循环数组已经装满了元素<br />
if !block &amp;&amp; c.closed == 0 &amp;&amp; ((c.dataqsiz == 0 &amp;&amp; c.recvq.first == nil) ||<br />
    (c.dataqsiz &gt; 0 &amp;&amp; c.qcount == c.dataqsiz)) {<br />
    return false<br />
}<br />
<br />
var t0 int64<br />
if blockprofilerate &gt; 0 {<br />
    t0 = cputicks()<br />
}<br />
<br />
// 锁住 channel，并发安全<br />
lock(&amp;c.lock)<br />
<br />
// 如果 channel 关闭了<br />
if c.closed != 0 {<br />
    // 解锁<br />
    unlock(&amp;c.lock)<br />
    // 直接 panic<br />
    panic(plainError("send on closed channel"))<br />
}<br />
<br />
// 如果接收队列里有 goroutine，直接将要发送的数据拷贝到接收 goroutine<br />
if sg := c.recvq.dequeue(); sg != nil {<br />
    send(c, sg, ep, func() { unlock(&amp;c.lock) }, 3)<br />
    return true<br />
}<br />
<br />
// 对于缓冲型的 channel，如果还有缓冲空间<br />
if c.qcount &lt; c.dataqsiz {<br />
    // qp 指向 buf 的 sendx 位置<br />
    qp := chanbuf(c, c.sendx)<br />
<br />
    // ……<br />
<br />
    // 将数据从 ep 处拷贝到 qp<br />
    typedmemmove(c.elemtype, qp, ep)<br />
    // 发送游标值加 1<br />
    c.sendx++<br />
    // 如果发送游标值等于容量值，游标值归 0<br />
    if c.sendx == c.dataqsiz {<br />
        c.sendx = 0<br />
    }<br />
    // 缓冲区的元素数量加一<br />
    c.qcount++<br />
<br />
    // 解锁<br />
    unlock(&amp;c.lock)<br />
    return true<br />
}<br />
<br />
// 如果不需要阻塞，则直接返回错误<br />
if !block {<br />
    unlock(&amp;c.lock)<br />
    return false<br />
}<br />
<br />
// channel 满了，发送方会被阻塞。接下来会构造一个 sudog<br />
<br />
// 获取当前 goroutine 的指针<br />
gp := getg()<br />
mysg := acquireSudog()<br />
mysg.releasetime = 0<br />
if t0 != 0 {<br />
    mysg.releasetime = -1<br />
}<br />
<br />
mysg.elem = ep<br />
mysg.waitlink = nil<br />
mysg.g = gp<br />
mysg.selectdone = nil<br />
mysg.c = c<br />
gp.waiting = mysg<br />
gp.param = nil<br />
<br />
// 当前 goroutine 进入发送等待队列<br />
c.sendq.enqueue(mysg)<br />
<br />
// 当前 goroutine 被挂起<br />
goparkunlock(&amp;c.lock, "chan send", traceEvGoBlockSend, 3)<br />
<br />
// 从这里开始被唤醒了（channel 有机会可以发送了）<br />
if mysg != gp.waiting {<br />
    throw("G waiting list is corrupted")<br />
}<br />
gp.waiting = nil<br />
if gp.param == nil {<br />
    if c.closed == 0 {<br />
        throw("chansend: spurious wakeup")<br />
    }<br />
    // 被唤醒后，channel 关闭了。坑爹啊，panic<br />
    panic(plainError("send on closed channel"))<br />
}<br />
gp.param = nil<br />
if mysg.releasetime &gt; 0 {<br />
    blockevent(mysg.releasetime-t0, 2)<br />
}<br />
// 去掉 mysg 上绑定的 channel<br />
mysg.c = nil<br />
releaseSudog(mysg)<br />
return true } 上面的代码注释地比较详细了，我们来详细看看。<br />
</code></pre></div></div><br />
<br />
<p>如果检测到 channel 是空的，当前 goroutine 会被挂起。<br />
对于不阻塞的发送操作，如果 channel 未关闭并且没有多余的缓冲空间（说明：a. channel 是非缓冲型的，且等待接收队列里没有 goroutine；b. channel 是缓冲型的，但循环数组已经装满了元素）<br />
对于这一点，runtime 源码里注释了很多。这一条判断语句是为了在不阻塞发送的场景下快速检测到发送失败，好快速返回。</p><br />
<br />
<p>if !block &amp;&amp; c.closed == 0 &amp;&amp; ((c.dataqsiz == 0 &amp;&amp; c.recvq.first == nil) || (c.dataqsiz &gt; 0 &amp;&amp; c.qcount == c.dataqsiz)) {<br />
    return false<br />
}<br />
注释里主要讲为什么这一块可以不加锁，我详细解释一下。if 条件里先读了两个变量：block 和 c.closed。block 是函数的参数，不会变；c.closed 可能被其他 goroutine 改变，因为没加锁嘛，这是“与”条件前面两个表达式。</p><br />
<br />
<p>最后一项，涉及到三个变量：c.dataqsiz，c.recvq.first，c.qcount。c.dataqsiz == 0 &amp;&amp; c.recvq.first == nil 指的是非缓冲型的 channel，并且 recvq 里没有等待接收的 goroutine；c.dataqsiz &gt; 0 &amp;&amp; c.qcount == c.dataqsiz 指的是缓冲型的 channel，但循环数组已经满了。这里 c.dataqsiz 实际上也是不会被修改的，在创建的时候就已经确定了。不加锁真正影响地是 c.qcount 和 c.recvq.first。</p><br />
<br />
<p>这一部分的条件就是两个 word-sized read，就是读两个 word 操作：c.closed 和 c.recvq.first（非缓冲型） 或者 c.qcount（缓冲型）。</p><br />
<br />
<p>当我们发现 c.closed == 0 为真，也就是 channel 未被关闭，再去检测第三部分的条件时，观测到 c.recvq.first == nil 或者 c.qcount == c.dataqsiz 时（这里忽略 c.dataqsiz），就断定要将这次发送操作作失败处理，快速返回 false。</p><br />
<br />
<p>这里涉及到两个观测项：channel 未关闭、channel not ready for sending。这两项都会因为没加锁而出现观测前后不一致的情况。例如我先观测到 channel 未被关闭，再观察到 channel not ready for sending，这时我以为能满足这个 if 条件了，但是如果这时 c.closed 变成 1，这时其实就不满足条件了，谁让你不加锁呢！</p><br />
<br />
<p>但是，因为一个 closed channel 不能将 channel 状态从 ‘ready for sending’ 变成 ‘not ready for sending’，所以当我观测到 ‘not ready for sending’ 时，channel 不是 closed。即使 c.closed == 1，即 channel 是在这两个观测中间被关闭的，那也说明在这两个观测中间，channel 满足两个条件：not closed 和 not ready for sending，这时，我直接返回 false 也是没有问题的。</p><br />
<br />
<p>这部分解释地比较绕，其实这样做的目的就是少获取一次锁，提升性能。</p><br />
<br />
<p>如果检测到 channel 已经关闭，直接 panic。<br />
如果能从等待接收队列 recvq 里出队一个 sudog（代表一个 goroutine），说明此时 channel 是空的，没有元素，所以才会有等待接收者。这时会调用 send 函数将元素直接从发送者的栈拷贝到接收者的栈，关键操作由 sendDirect 函数完成。<br />
// send 函数处理向一个空的 channel 发送操作</p><br />
<br />
<p>// ep 指向被发送的元素，会被直接拷贝到接收的 goroutine<br />
// 之后，接收的 goroutine 会被唤醒<br />
// c 必须是空的（因为等待队列里有 goroutine，肯定是空的）<br />
// c 必须被上锁，发送操作执行完后，会使用 unlockf 函数解锁<br />
// sg 必须已经从等待队列里取出来了<br />
// ep 必须是非空，并且它指向堆或调用者的栈</p><br />
<br />
<p>func send(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf func(), skip int) {<br />
    // 省略一些用不到的<br />
    // ……</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// sg.elem 指向接收到的值存放的位置，如 val &lt;- ch，指的就是 &amp;val<br />
if sg.elem != nil {<br />
    // 直接拷贝内存（从发送者到接收者）<br />
    sendDirect(c.elemtype, sg, ep)<br />
    sg.elem = nil<br />
}<br />
// sudog 上绑定的 goroutine<br />
gp := sg.g<br />
// 解锁<br />
unlockf()<br />
gp.param = unsafe.Pointer(sg)<br />
if sg.releasetime != 0 {<br />
    sg.releasetime = cputicks()<br />
}<br />
// 唤醒接收的 goroutine. skip 和打印栈相关，暂时不理会<br />
goready(gp, skip+1) } 继续看 sendDirect 函数：<br />
</code></pre></div></div><br />
<br />
<p>// 向一个非缓冲型的 channel 发送数据、从一个无元素的（非缓冲型或缓冲型但空）的 channel<br />
// 接收数据，都会导致一个 goroutine 直接操作另一个 goroutine 的栈<br />
// 由于 GC 假设对栈的写操作只能发生在 goroutine 正在运行中并且由当前 goroutine 来写<br />
// 所以这里实际上违反了这个假设。可能会造成一些问题，所以需要用到写屏障来规避<br />
func sendDirect(t *_type, sg *sudog, src unsafe.Pointer) {<br />
    // src 在当前 goroutine 的栈上，dst 是另一个 goroutine 的栈</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 直接进行内存"搬迁"<br />
// 如果目标地址的栈发生了栈收缩，当我们读出了 sg.elem 后<br />
// 就不能修改真正的 dst 位置的值了<br />
// 因此需要在读和写之前加上一个屏障<br />
dst := sg.elem<br />
typeBitsBulkBarrier(t, uintptr(dst), uintptr(src), t.size)<br />
memmove(dst, src, t.size) } 这里涉及到一个 goroutine 直接写另一个 goroutine 栈的操作，一般而言，不同 goroutine 的栈是各自独有的。而这也违反了 GC 的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确地完成写操作。这样做的好处是减少了一次内存 copy：不用先拷贝到 channel 的 buf，直接由发送者到接收者，没有中间商赚差价，效率得以提高，完美。<br />
</code></pre></div></div><br />
<br />
<p>然后，解锁、唤醒接收者，等待调度器的光临，接收者也得以重见天日，可以继续执行接收操作之后的代码了。</p><br />
<br />
<p>如果 c.qcount &lt; c.dataqsiz，说明缓冲区可用（肯定是缓冲型的 channel）。先通过函数取出待发送元素应该去到的位置：<br />
qp := chanbuf(c, c.sendx)</p><br />
<br />
<p>// 返回循环队列里第 i 个元素的地址处<br />
func chanbuf(c <em>hchan, i uint) unsafe.Pointer {<br />
    return add(c.buf, uintptr(i)</em>uintptr(c.elemsize))<br />
}<br />
c.sendx 指向下一个待发送元素在循环数组中的位置，然后调用 typedmemmove 函数将其拷贝到循环数组中。之后 c.sendx 加 1，元素总量加 1 ：c.qcount++，最后，解锁并返回。</p><br />
<br />
<p>如果没有命中以上条件的，说明 channel 已经满了。不管这个 channel 是缓冲型的还是非缓冲型的，都要将这个 sender “关起来”（goroutine 被阻塞）。如果 block 为 false，直接解锁，返回 false。<br />
最后就是真的需要被阻塞的情况。先构造一个 sudog，将其入队（channel 的 sendq 字段）。然后调用 goparkunlock 将当前 goroutine 挂起，并解锁，等待合适的时机再唤醒。<br />
唤醒之后，从 goparkunlock 下一行代码开始继续往下执行。</p><br />
<br />
<p>这里有一些绑定操作，sudog 通过 g 字段绑定 goroutine，而 goroutine 通过 waiting 绑定 sudog，sudog 还通过 elem 字段绑定待发送元素的地址，以及 c 字段绑定被“坑”在此处的 channel。</p><br />
<br />
<p>所以，待发送的元素地址其实是存储在 sudog 结构体里，也就是当前 goroutine 里。</p><br />
<br />
<p>好了，看完源码。我们接着来分析例子，相信大家已经把例子忘得差不多了，我再贴一下代码：</p><br />
<br />
<p>func goroutineA(a &lt;-chan int) {<br />
    val := &lt;- a<br />
    fmt.Println(“goroutine A received data: “, val)<br />
    return<br />
}</p><br />
<br />
<p>func goroutineB(b &lt;-chan int) {<br />
    val := &lt;- b<br />
    fmt.Println(“goroutine B received data: “, val)<br />
    return<br />
}</p><br />
<br />
<p>func main() {<br />
    ch := make(chan int)<br />
    go goroutineA(ch)<br />
    go goroutineB(ch)<br />
    ch &lt;- 3<br />
    time.Sleep(time.Second)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ch1 := make(chan struct{}) } 在发送小节里我们说到 G1 和 G2 现在被挂起来了，等待 sender 的解救。在第 17 行，主协程向 ch 发送了一个元素 3，来看下接下来会发生什么。<br />
</code></pre></div></div><br />
<br />
<p>根据前面源码分析的结果，我们知道，sender 发现 ch 的 recvq 里有 receiver 在等待着接收，就会出队一个 sudog，把 recvq 里 first 指针的 sudo “推举”出来了，并将其加入到 P 的可运行 goroutine 队列中。</p><br />
<br />
<p>然后，sender 把发送元素拷贝到 sudog 的 elem 地址处，最后会调用 goready 将 G1 唤醒，状态变为 runnable。</p><br />
<br />
<p>当调度器光顾 G1 时，将 G1 变成 running 状态，执行 goroutineA 接下来的代码。G 表示其他可能有的 goroutine。</p><br />
<br />
<p>这里其实涉及到一个协程写另一个协程栈的操作。有两个 receiver 在 channel 的一边虎视眈眈地等着，这时 channel 另一边来了一个 sender 准备向 channel 发送数据，为了高效，用不着通过 channel 的 buf “中转”一次，直接从源地址把数据 copy 到目的地址就可以了，效率高啊！</p><br />
<br />
<p>3 会被拷贝到 G1 栈上的某个位置，也就是 val 的地址处，保存在 elem 字段。</p><br />
<br />
<p>关闭<br />
关闭某个 channel，会执行函数 closechan：</p><br />
<br />
<p>func closechan(c *hchan) {<br />
    // 关闭一个 nil channel，panic<br />
    if c == nil {<br />
        panic(plainError(“close of nil channel”))<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 上锁<br />
lock(&amp;c.lock)<br />
// 如果 channel 已经关闭<br />
if c.closed != 0 {<br />
    unlock(&amp;c.lock)<br />
    // panic<br />
    panic(plainError("close of closed channel"))<br />
}<br />
<br />
// …………<br />
<br />
// 修改关闭状态<br />
c.closed = 1<br />
<br />
var glist *g<br />
<br />
// 将 channel 所有等待接收队列的里 sudog 释放<br />
for {<br />
    // 从接收队列里出队一个 sudog<br />
    sg := c.recvq.dequeue()<br />
    // 出队完毕，跳出循环<br />
    if sg == nil {<br />
        break<br />
    }<br />
<br />
    // 如果 elem 不为空，说明此 receiver 未忽略接收数据<br />
    // 给它赋一个相应类型的零值<br />
    if sg.elem != nil {<br />
        typedmemclr(c.elemtype, sg.elem)<br />
        sg.elem = nil<br />
    }<br />
    if sg.releasetime != 0 {<br />
        sg.releasetime = cputicks()<br />
    }<br />
    // 取出 goroutine<br />
    gp := sg.g<br />
    gp.param = nil<br />
    if raceenabled {<br />
        raceacquireg(gp, unsafe.Pointer(c))<br />
    }<br />
    // 相连，形成链表<br />
    gp.schedlink.set(glist)<br />
    glist = gp<br />
}<br />
<br />
// 将 channel 等待发送队列里的 sudog 释放<br />
// 如果存在，这些 goroutine 将会 panic<br />
for {<br />
    // 从发送队列里出队一个 sudog<br />
    sg := c.sendq.dequeue()<br />
    if sg == nil {<br />
        break<br />
    }<br />
<br />
    // 发送者会 panic<br />
    sg.elem = nil<br />
    if sg.releasetime != 0 {<br />
        sg.releasetime = cputicks()<br />
    }<br />
    gp := sg.g<br />
    gp.param = nil<br />
    if raceenabled {<br />
        raceacquireg(gp, unsafe.Pointer(c))<br />
    }<br />
    // 形成链表<br />
    gp.schedlink.set(glist)<br />
    glist = gp<br />
}<br />
// 解锁<br />
unlock(&amp;c.lock)<br />
<br />
// Ready all Gs now that we've dropped the channel lock.<br />
// 遍历链表<br />
for glist != nil {<br />
    // 取最后一个<br />
    gp := glist<br />
    // 向前走一步，下一个唤醒的 g<br />
    glist = glist.schedlink.ptr()<br />
    gp.schedlink = 0<br />
    // 唤醒相应 goroutine<br />
    goready(gp, 3)<br />
} } close 逻辑比较简单，对于一个 channel，recvq 和 sendq 中分别保存了阻塞的发送者和接收者。关闭 channel 后，对于等待接收者而言，会收到一个相应类型的零值。对于等待发送者，会直接 panic。所以，在不了解 channel 还有没有接收者的情况下，不能贸然关闭 channel。<br />
</code></pre></div></div><br />
<br />
<p>close 函数先上一把大锁，接着把所有挂在这个 channel 上的 sender 和 receiver 全都连成一个 sudog 链表，再解锁。最后，再将所有的 sudog 全都唤醒。</p><br />
<br />
<p>唤醒之后，该干嘛干嘛。sender 会继续执行 chansend 函数里 goparkunlock 函数之后的代码，很不幸，检测到 channel 已经关闭了，panic。receiver 则比较幸运，进行一些扫尾工作后，返回。这里，selected 返回 true，而返回值 received 则要根据 channel 是否关闭，返回不同的值。如果 channel 关闭，received 为 false，否则为 true。这我们分析的这种情况下，received 返回 false。</p><br />
<br />
<p>channel 进阶<br />
总结一下操作 channel 的结果：</p><br />
<br />
<p>操作	nil channel	closed channel	not nil, not closed channel<br />
close	panic	panic	正常关闭<br />
读 &lt;- ch	阻塞	读到对应类型的零值	阻塞或正常读取数据。缓冲型 channel 为空或非缓冲型 channel 没有等待发送者时会阻塞<br />
写 ch &lt;-	阻塞	panic	阻塞或正常写入数据。非缓冲型 channel 没有等待接收者或缓冲型 channel buf 满时会被阻塞<br />
总结一下，发生 panic 的情况有三种：向一个关闭的 channel 进行写操作；关闭一个 nil 的 channel；重复关闭一个 channel。</p><br />
<br />
<p>读、写一个 nil channel 都会被阻塞。</p><br />
<br />
<p>发送和接收元素的本质<br />
Channel 发送和接收元素的本质是什么？参考资料【深入 channel 底层】里是这样回答的：</p><br />
<br />
<p>Remember all transfer of value on the go channels happens with the copy of value.<br />
就是说 channel 的发送和接收操作本质上都是 “值的拷贝”，无论是从 sender goroutine 的栈到 chan buf，还是从 chan buf 到 receiver goroutine，或者是直接从 sender goroutine 到 receiver goroutine。</p><br />
<br />
<p>这里再引用文中的一个例子，我会加上更加详细地解释。顺带说一下，这是一篇英文的博客，写得很好，没有像我们这篇文章那样大段的源码分析，它是将代码里情况拆开来各自描述的，各有利弊吧。推荐去读下原文，阅读体验比较好。</p><br />
<br />
<p>type user struct {<br />
    name string<br />
    age int8<br />
}</p><br />
<br />
<p>var u = user{name: “Ankur”, age: 25}<br />
var g = &amp;u</p><br />
<br />
<p>func modifyUser(pu *user) {<br />
    fmt.Println(“modifyUser Received Vaule”, pu)<br />
    pu.name = “Anand”<br />
}</p><br />
<br />
<p>func printUser(u &lt;-chan *user) {<br />
    time.Sleep(2 * time.Second)<br />
    fmt.Println(“printUser goRoutine called”, &lt;-u)<br />
}</p><br />
<br />
<p>func main() {<br />
    c := make(chan *user, 5)<br />
    c &lt;- g<br />
    fmt.Println(g)<br />
    // modify g<br />
    g = &amp;user{name: “Ankur Anand”, age: 100}<br />
    go printUser(c)<br />
    go modifyUser(g)<br />
    time.Sleep(5 * time.Second)<br />
    fmt.Println(g)<br />
}<br />
运行结果：</p><br />
<br />
<p>&amp;{Ankur 25}<br />
modifyUser Received Value &amp;{Ankur Anand 100}<br />
printUser goRoutine called &amp;{Ankur 25}<br />
&amp;{Anand 100}<br />
这里就是一个很好的 share memory by communicating 的例子。</p><br />
<br />
<p>一开始构造一个结构体 u，地址是 0x56420，图中地址上方就是它的内容。接着把 &amp;u 赋值给指针 g，g 的地址是 0x565bb0，它的内容就是一个地址，指向 u。</p><br />
<br />
<p>main 程序里，先把 g 发送到 c，根据 copy value 的本质，进入到 chan buf 里的就是 0x56420，它是指针 g 的值（不是它指向的内容），所以打印从 channel 接收到的元素时，它就是 &amp;{Ankur 25}。因此，这里并不是将指针 g “发送” 到了 channel 里，只是拷贝它的值而已。</p><br />
<br />
<p>再强调一次：</p><br />
<br />
<p>Remember all transfer of value on the go channels happens with the copy of value.</p><br />
<br />
<p>一开始构造一个结构体 u，地址是 0x56420，图中地址上方就是它的内容。接着把 &amp;u 赋值给指针 g，g 的地址是 0x565bb0，它的内容就是一个地址，指向 u。</p><br />
<br />
<p>main 程序里，先把 g 发送到 c，根据 copy value 的本质，进入到 chan buf 里的就是 0x56420，它是指针 g 的值（不是它指向的内容），所以打印从 channel 接收到的元素时，它就是 &amp;{Ankur 25}。因此，这里并不是将指针 g “发送” 到了 channel 里，只是拷贝它的值而已。</p><br />
<br />
<p>再强调一次：</p><br />
<br />
<p>Remember all transfer of value on the go channels happens with the copy of value.<br />
资源泄漏<br />
Channel 可能会引发 goroutine 泄漏。</p><br />
<br />
<p>泄漏的原因是 goroutine 操作 channel 后，处于发送或接收阻塞状态，而 channel 处于满或空的状态，一直得不到改变。同时，垃圾回收器也不会回收此类资源，进而导致 gouroutine 会一直处于等待队列中，不见天日。</p><br />
<br />
<p>雨痕老师的《Go 语言学习笔记》第 8 章通道的“资源泄露”一节举了个例子，大家可以自己去看。</p><br />
<br />
<p>happened before<br />
维基百科上给的定义：</p><br />
<br />
<p>In computer science, the happened-before relation (denoted: -&gt;) is a relation between the result of two events, such that if one event should happen before another event, the result must reflect that, even if those events are in reality executed out of order (usually to optimize program flow).<br />
简单来说就是如果事件 a 和事件 b 存在 happened-before 关系，即 a -&gt; b，那么 a，b 完成后的结果一定要体现这种关系。由于现代编译器、CPU 会做各种优化，包括编译器重排、内存重排等等，在并发代码里，happened-before 限制就非常重要了。</p><br />
<br />
<p>根据晃岳攀老师在 Gopher China 2019 上的并发编程分享，关于 channel 的发送（send）、发送完成（send finished）、接收（receive）、接收完成（receive finished）的 happened-before 关系如下：</p><br />
<br />
<p>第 n 个 send 一定 happened before 第 n 个 receive finished，无论是缓冲型还是非缓冲型的 channel。<br />
对于容量为 m 的缓冲型 channel，第 n 个 receive 一定 happened before 第 n+m 个 send finished。<br />
对于非缓冲型的 channel，第 n 个 receive 一定 happened before 第 n 个 send finished。<br />
channel close 一定 happened before receiver 得到通知。<br />
我们来逐条解释一下。</p><br />
<br />
<p>第一条，我们从源码的角度看也是对的，send 不一定是 happened before receive，因为有时候是先 receive，然后 goroutine 被挂起，之后被 sender 唤醒，send happened after receive。但不管怎样，要想完成接收，一定是要先有发送。</p><br />
<br />
<p>第二条，缓冲型的 channel，当第 n+m 个 send 发生后，有下面两种情况：</p><br />
<br />
<p>若第 n 个 receive 没发生。这时，channel 被填满了，send 就会被阻塞。那当第 n 个 receive 发生时，sender goroutine 会被唤醒，之后再继续发送过程。这样，第 n 个 receive 一定 happened before 第 n+m 个 send finished。</p><br />
<br />
<p>若第 n 个 receive 已经发生过了，这直接就符合了要求。</p><br />
<br />
<p>第三条，也是比较好理解的。第 n 个 send 如果被阻塞，sender goroutine 挂起，第 n 个 receive 这时到来，先于第 n 个 send finished。如果第 n 个 send 未被阻塞，说明第 n 个 receive 早就在那等着了，它不仅 happened before send finished，它还 happened before send。</p><br />
<br />
<p>第四条，回忆一下源码，先设置完 closed = 1，再唤醒等待的 receiver，并将零值拷贝给 receiver。</p><br />
<br />
<p>参考资料【鸟窝 并发编程分享】这篇博文的评论区有 PPT 的下载链接，这是晁老师在 Gopher 2019 大会上的演讲。</p><br />
<br />
<p>关于 happened before，这里再介绍一个柴大和曹大的新书《Go 语言高级编程》里面提到的一个例子。</p><br />
<br />
<p>书中 1.5 节先讲了顺序一致性的内存模型，这是并发编程的基础。</p><br />
<br />
<p>我们直接来看例子：</p><br />
<br />
<p>var done = make(chan bool)<br />
var msg string</p><br />
<br />
<p>func aGoroutine() {<br />
    msg = “hello, world”<br />
    done &lt;- true<br />
}</p><br />
<br />
<p>func main() {<br />
    go aGoroutine()<br />
    &lt;-done<br />
    println(msg)<br />
}<br />
先定义了一个 done channel 和一个待打印的字符串。在 main 函数里，启动一个 goroutine，等待从 done 里接收到一个值后，执行打印 msg 的操作。如果 main 函数中没有 &lt;-done 这行代码，打印出来的 msg 为空，因为 aGoroutine 来不及被调度，还来不及给 msg 赋值，主程序就会退出。而在 Go 语言里，主协程退出时不会等待其他协程。</p><br />
<br />
<p>加了 &lt;-done 这行代码后，就会阻塞在此。等 aGoroutine 里向 done 发送了一个值之后，才会被唤醒，继续执行打印 msg 的操作。而这在之前，msg 已经被赋值过了，所以会打印出 hello, world。</p><br />
<br />
<p>这里依赖的 happened before 就是前面讲的第一条。第一个 send 一定 happened before 第一个 receive finished，即 done &lt;- true 先于 &lt;-done 发生，这意味着 main 函数里执行完 &lt;-done 后接着执行 println(msg) 这一行代码时，msg 已经被赋过值了，所以会打印出想要的结果。</p><br />
<br />
<p>书中，又进一步利用前面提到的第 3 条 happened before 规则，修改了一下代码：</p><br />
<br />
<p>var done = make(chan bool)<br />
var msg string</p><br />
<br />
<p>func aGoroutine() {<br />
    msg = “hello, world”<br />
    &lt;-done<br />
}</p><br />
<br />
<p>func main() {<br />
    go aGoroutine()<br />
    done &lt;- true<br />
    println(msg)<br />
}<br />
同样可以得到相同的结果，为什么？根据第三条规则，对于非缓冲型的 channel，第一个 receive 一定 happened before 第一个 send finished。也就是说，<br />
在 done &lt;- true 完成之前，&lt;-done 就已经发生了，也就意味着 msg 已经被赋上值了，最终也会打印出 hello, world。</p><br />
<br />
<p>如何优雅地关闭 channel<br />
这部分内容主要来自 Go 101 上的一篇英文文章，参考资料【如何优雅地关闭 channel】可以直达原文。</p><br />
<br />
<p>文章先“吐槽”了下 Go channel 在设计上的一些问题，接着给出了几种不同情况下如何优雅地关闭 channel 的例子。按照惯例，我会在原作者内容的基础上给出自己的解读，看完这一节你可以再回头看一下英文原文，会觉得很有意思。</p><br />
<br />
<p>关于 channel 的使用，有几点不方便的地方：</p><br />
<br />
<p>在不改变 channel 自身状态的情况下，无法获知一个 channel 是否关闭。<br />
关闭一个 closed channel 会导致 panic。所以，如果关闭 channel 的一方在不知道 channel 是否处于关闭状态时就去贸然关闭 channel 是很危险的事情。<br />
向一个 closed channel 发送数据会导致 panic。所以，如果向 channel 发送数据的一方不知道 channel 是否处于关闭状态时就去贸然向 channel 发送数据是很危险的事情。<br />
文中还真的就给出了一个检查 channel 是否关闭的函数：</p><br />
<br />
<p>func IsClosed(ch &lt;-chan T) bool {<br />
    select {<br />
    case &lt;-ch:<br />
        return true<br />
    default:<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return false }<br />
</code></pre></div></div><br />
<br />
<p>func main() {<br />
    c := make(chan T)<br />
    fmt.Println(IsClosed(c)) // false<br />
    close(c)<br />
    fmt.Println(IsClosed(c)) // true<br />
}<br />
看一下代码，其实存在很多问题。首先，IsClosed 函数是一个有副作用的函数。每调用一次，都会读出 channel 里的一个元素，改变了 channel 的状态。这不是一个好的函数，干活就干活，还顺手牵羊！</p><br />
<br />
<p>其次，IsClosed 函数返回的结果仅代表调用那个瞬间，并不能保证调用之后会不会有其他 goroutine 对它进行了一些操作，改变了它的这种状态。例如，IsClosed 函数返回 true，但这时有另一个 goroutine 关闭了 channel，而你还拿着这个过时的 “channel 未关闭”的信息，向其发送数据，就会导致 panic 的发生。当然，一个 channel 不会被重复关闭两次，如果 IsClosed 函数返回的结果是 true，说明 channel 是真的关闭了。</p><br />
<br />
<p>有一条广泛流传的关闭 channel 的原则：</p><br />
<br />
<p>don’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.<br />
不要从一个 receiver 侧关闭 channel，也不要在有多个 sender 时，关闭 channel。</p><br />
<br />
<p>比较好理解，向 channel 发送元素的就是 sender，因此 sender 可以决定何时不发送数据，并且关闭 channel。但是如果有多个 sender，某个 sender 同样没法确定其他 sender 的情况，这时也不能贸然关闭 channel。</p><br />
<br />
<p>但是上面所说的并不是最本质的，最本质的原则就只有一条：</p><br />
<br />
<p>don’t close (or send values to) closed channels.<br />
有两个不那么优雅地关闭 channel 的方法：</p><br />
<br />
<p>使用 defer-recover 机制，放心大胆地关闭 channel 或者向 channel 发送数据。即使发生了 panic，有 defer-recover 在兜底。<br />
使用 sync.Once 来保证只关闭一次。<br />
代码我就不贴上来了，直接去看原文。</p><br />
<br />
<p>这一节的重头戏来了，那应该如何优雅地关闭 channel？</p><br />
<br />
<p>根据 sender 和 receiver 的个数，分下面几种情况：</p><br />
<br />
<p>一个 sender，一个 receiver<br />
一个 sender， M 个 receiver<br />
N 个 sender，一个 reciver<br />
N 个 sender， M 个 receiver<br />
对于 1，2，只有一个 sender 的情况就不用说了，直接从 sender 端关闭就好了，没有问题。重点关注第 3，4 种情况。</p><br />
<br />
<p>第 3 种情形下，优雅关闭 channel 的方法是：the only receiver says “please stop sending more” by closing an additional signal channel。</p><br />
<br />
<p>解决方案就是增加一个传递关闭信号的 channel，receiver 通过信号 channel 下达关闭数据 channel 指令。senders 监听到关闭信号后，停止发送数据。我把代码修改地更简洁了：</p><br />
<br />
<p>func main() {<br />
    rand.Seed(time.Now().UnixNano())</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const Max = 100000<br />
const NumSenders = 1000<br />
<br />
dataCh := make(chan int, 100)<br />
stopCh := make(chan struct{})<br />
<br />
// senders<br />
for i := 0; i &lt; NumSenders; i++ {<br />
    go func() {<br />
        for {<br />
            select {<br />
            case &lt;- stopCh:<br />
                return<br />
            case dataCh &lt;- rand.Intn(Max):<br />
            }<br />
        }<br />
    }()<br />
}<br />
<br />
// the receiver<br />
go func() {<br />
    for value := range dataCh {<br />
        if value == Max-1 {<br />
            fmt.Println("send stop signal to senders.")<br />
            close(stopCh)<br />
            return<br />
        }<br />
<br />
        fmt.Println(value)<br />
    }<br />
}()<br />
<br />
select {<br />
case &lt;- time.After(time.Hour):<br />
} } 这里的 stopCh 就是信号 channel，它本身只有一个 sender，因此可以直接关闭它。senders 收到了关闭信号后，select 分支 “case &lt;- stopCh” 被选中，退出函数，不再发送数据。<br />
</code></pre></div></div><br />
<br />
<p>需要说明的是，上面的代码并没有明确关闭 dataCh。在 Go 语言中，对于一个 channel，如果最终没有任何 goroutine 引用它，不管 channel 有没有被关闭，最终都会被 gc 回收。所以，在这种情形下，所谓的优雅地关闭 channel 就是不关闭 channel，让 gc 代劳。</p><br />
<br />
<p>最后一种情况，优雅关闭 channel 的方法是：any one of them says “let’s end the game” by notifying a moderator to close an additional signal channel。</p><br />
<br />
<p>和第 3 种情况不同，这里有 M 个 receiver，如果直接还是采取第 3 种解决方案，由 receiver 直接关闭 stopCh 的话，就会重复关闭一个 channel，导致 panic。因此需要增加一个中间人，M 个 receiver 都向它发送关闭 dataCh 的“请求”，中间人收到第一个请求后，就会直接下达关闭 dataCh 的指令（通过关闭 stopCh，这时就不会发生重复关闭的情况，因为 stopCh 的发送方只有中间人一个）。另外，这里的 N 个 sender 也可以向中间人发送关闭 dataCh 的请求。</p><br />
<br />
<p>func main() {<br />
    rand.Seed(time.Now().UnixNano())</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const Max = 100000<br />
const NumReceivers = 10<br />
const NumSenders = 1000<br />
<br />
dataCh := make(chan int, 100)<br />
stopCh := make(chan struct{})<br />
<br />
// It must be a buffered channel.<br />
toStop := make(chan string, 1)<br />
<br />
var stoppedBy string<br />
<br />
// moderator<br />
go func() {<br />
    stoppedBy = &lt;-toStop<br />
    close(stopCh)<br />
}()<br />
<br />
// senders<br />
for i := 0; i &lt; NumSenders; i++ {<br />
    go func(id string) {<br />
        for {<br />
            value := rand.Intn(Max)<br />
            if value == 0 {<br />
                select {<br />
                case toStop &lt;- "sender#" + id:<br />
                default:<br />
                }<br />
                return<br />
            }<br />
<br />
            select {<br />
            case &lt;- stopCh:<br />
                return<br />
            case dataCh &lt;- value:<br />
            }<br />
        }<br />
    }(strconv.Itoa(i))<br />
}<br />
<br />
// receivers<br />
for i := 0; i &lt; NumReceivers; i++ {<br />
    go func(id string) {<br />
        for {<br />
            select {<br />
            case &lt;- stopCh:<br />
                return<br />
            case value := &lt;-dataCh:<br />
                if value == Max-1 {<br />
                    select {<br />
                    case toStop &lt;- "receiver#" + id:<br />
                    default:<br />
                    }<br />
                    return<br />
                }<br />
<br />
                fmt.Println(value)<br />
            }<br />
        }<br />
    }(strconv.Itoa(i))<br />
}<br />
<br />
select {<br />
case &lt;- time.After(time.Hour):<br />
}<br />
</code></pre></div></div><br />
<br />
<p>}<br />
代码里 toStop 就是中间人的角色，使用它来接收 senders 和 receivers 发送过来的关闭 dataCh 请求。</p><br />
<br />
<p>这里将 toStop 声明成了一个 缓冲型的 channel。假设 toStop 声明的是一个非缓冲型的 channel，那么第一个发送的关闭 dataCh 请求可能会丢失。因为无论是 sender 还是 receiver 都是通过 select 语句来发送请求，如果中间人所在的 goroutine 没有准备好，那 select 语句就不会选中，直接走 default 选项，什么也不做。这样，第一个关闭 dataCh 的请求就会丢失。</p><br />
<br />
<p>如果，我们把 toStop 的容量声明成 Num(senders) + Num(receivers)，那发送 dataCh 请求的部分可以改成更简洁的形式：</p><br />
<br />
<p>…<br />
toStop := make(chan string, NumReceivers + NumSenders)<br />
…<br />
            value := rand.Intn(Max)<br />
            if value == 0 {<br />
                toStop &lt;- “sender#” + id<br />
                return<br />
            }<br />
…<br />
                if value == Max-1 {<br />
                    toStop &lt;- “receiver#” + id<br />
                    return<br />
                }<br />
…<br />
直接向 toStop 发送请求，因为 toStop 容量足够大，所以不用担心阻塞，自然也就不用 select 语句再加一个 default case 来避免阻塞。</p><br />
<br />
<p>可以看到，这里同样没有真正关闭 dataCh，原样同第 3 种情况。</p><br />
<br />
<p>以上，就是最基本的一些情形，但已经能覆盖几乎所有的情况及其变种了。只要记住：</p><br />
<br />
<p>don’t close a channel from the receiver side and don’t close a channel if the channel has multiple concurrent senders.<br />
以及更本质的原则：</p><br />
<br />
<p>don’t close (or send values to) closed channels.<br />
关闭的 channel 仍能读出数据<br />
从一个有缓冲的 channel 里读数据，当 channel 被关闭，依然能读出有效值。只有当返回的 ok 为 false 时，读出的数据才是无效的。</p><br />
<br />
<p>func main() {<br />
    ch := make(chan int, 5)<br />
    ch &lt;- 18<br />
    close(ch)<br />
    x, ok := &lt;-ch<br />
    if ok {<br />
        fmt.Println(“received: “, x)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x, ok = &lt;-ch<br />
if !ok {<br />
    fmt.Println("channel closed, data invalid.")<br />
} } 运行结果：<br />
</code></pre></div></div><br />
<br />
<p>received:  18<br />
channel closed, data invalid.<br />
先创建了一个有缓冲的 channel，向其发送一个元素，然后关闭此 channel。之后两次尝试从 channel 中读取数据，第一次仍然能正常读出值。第二次返回的 ok 为 false，说明 channel 已关闭，且通道里没有数据。</p><br />
<br />
<p>channel 应用<br />
Channel 和 goroutine 的结合是 Go 并发编程的大杀器。而 Channel 的实际应用也经常让人眼前一亮，通过与 select，cancel，timer 等结合，它能实现各种各样的功能。接下来，我们就要梳理一下 channel 的应用。</p><br />
<br />
<p>停止信号<br />
前面一节如何优雅关闭 channel 那一节已经讲得很多了，这块就略过了。</p><br />
<br />
<p>channel 用于停止信号的场景还是挺多的，经常是关闭某个 channel 或者向 channel 发送一个元素，使得接收 channel 的那一方获知道此信息，进而做一些其他的操作。</p><br />
<br />
<p>任务定时<br />
与 timer 结合，一般有两种玩法：实现超时控制，实现定期执行某个任务。</p><br />
<br />
<p>有时候，需要执行某项操作，但又不想它耗费太长时间，上一个定时器就可以搞定：</p><br />
<br />
<p>select {<br />
    case &lt;-time.After(100 * time.Millisecond):<br />
    case &lt;-s.stopc:<br />
        return false<br />
}<br />
等待 100 ms 后，如果 s.stopc 还没有读出数据或者被关闭，就直接结束。这是来自 etcd 源码里的一个例子，这样的写法随处可见。</p><br />
<br />
<p>定时执行某个任务，也比较简单：</p><br />
<br />
<p>func worker() {<br />
    ticker := time.Tick(1 * time.Second)<br />
    for {<br />
        select {<br />
        case &lt;- ticker:<br />
            // 执行定时任务<br />
            fmt.Println(“执行 1s 定时任务”)<br />
        }<br />
    }<br />
}<br />
每隔 1 秒种，执行一次定时任务。</p><br />
<br />
<p>解耦生产方和消费方<br />
服务启动时，启动 n 个 worker，作为工作协程池，这些协程工作在一个 for {} 无限循环里，从某个 channel 消费工作任务并执行：</p><br />
<br />
<p>func main() {<br />
    taskCh := make(chan int, 100)<br />
    go worker(taskCh)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 塞任务<br />
for i := 0; i &lt; 10; i++ {<br />
    taskCh &lt;- i<br />
}<br />
<br />
// 等待 1 小时 <br />
select {<br />
case &lt;-time.After(time.Hour):<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>func worker(taskCh &lt;-chan int) {<br />
    const N = 5<br />
    // 启动 5 个工作协程<br />
    for i := 0; i &lt; N; i++ {<br />
        go func(id int) {<br />
            for {<br />
                task := &lt;- taskCh<br />
                fmt.Printf(“finish task: %d by worker %d\n”, task, id)<br />
                time.Sleep(time.Second)<br />
            }<br />
        }(i)<br />
    }<br />
}<br />
5 个工作协程在不断地从工作队列里取任务，生产方只管往 channel 发送任务即可，解耦生产方和消费方。</p><br />
<br />
<p>程序输出：</p><br />
<br />
<p>finish task: 1 by worker 4<br />
finish task: 2 by worker 2<br />
finish task: 4 by worker 3<br />
finish task: 3 by worker 1<br />
finish task: 0 by worker 0<br />
finish task: 6 by worker 0<br />
finish task: 8 by worker 3<br />
finish task: 9 by worker 1<br />
finish task: 7 by worker 4<br />
finish task: 5 by worker 2<br />
控制并发数<br />
有时需要定时执行几百个任务，例如每天定时按城市来执行一些离线计算的任务。但是并发数又不能太高，因为任务执行过程依赖第三方的一些资源，对请求的速率有限制。这时就可以通过 channel 来控制并发数。</p><br />
<br />
<p>下面的例子来自《Go 语言高级编程》：</p><br />
<br />
<p>var limit = make(chan int, 3)</p><br />
<br />
<p>func main() {<br />
    // …………<br />
    for _, w := range work {<br />
        go func() {<br />
            limit &lt;- 1<br />
            w()<br />
            &lt;-limit<br />
        }()<br />
    }<br />
    // …………<br />
}<br />
构建一个缓冲型的 channel，容量为 3。接着遍历任务列表，每个任务启动一个 goroutine 去完成。真正执行任务，访问第三方的动作在 w() 中完成，在执行 w() 之前，先要从 limit 中拿“许可证”，拿到许可证之后，才能执行 w()，并且在执行完任务，要将“许可证”归还。这样就可以控制同时运行的 goroutine 数。</p><br />
<br />
<p>这里，limit &lt;- 1 放在 func 内部而不是外部，书籍作者柴大在读者群里的解释是：</p><br />
<br />
<p>如果在外层，就是控制系统 goroutine 的数量，可能会阻塞 for 循环，影响业务逻辑。<br />
limit 其实和逻辑无关，只是性能调优，放在内层和外层的语义不太一样。</p><br />
<br />
<p>还有一点要注意的是，如果 w() 发生 panic，那“许可证”可能就还不回去了，因此需要使用 defer 来保证。</p><br />
<br />
<p>总结<br />
终于写完了，你也终于看完了，恭喜！</p><br />
<br />
<p>回顾一下，这篇文章先从并发和并行讲起，又讲到了 CSP，Go 语言用 channel 实现 CSP。接着讲了什么是 channel，为什么需要 channel，然后详细分析了 channel 的实现原理，这也是全文最重要的部分。之后，又讲了几个进阶的例子，最后，列举了几个 channel 应用的场景。</p><br />
<br />
<p>希望大家能借助本文去读一下 Go 源码，这部分源码也不长，和 context 包一样，短小精悍，值得一读。</p><br />
<br />
<p>我在参考资料里列举了很多文章、书籍，很多都值得去细看，我在文中也有提及。</p><br />
<br />
<p>当你理解这 channel 的底层原理后，再去看这些英文文章，会觉得很有意思。以前对他有一种“畏难”心理，理解了之后再读，就会觉得很有意思，因为你确实都能看懂。</p><br />
<br />
<p>最后，阅读愉快！</p><br />
<br />
<p>参考资料<br />
【Concurrency In Go】https://github.com/arpitjinda…:Tools-and-Techniques-for-Developers.pdf</p><br />
<br />
<p>【Go 语言高级编程开源书】https://chai2010.cn/advanced-…</p><br />
<br />
<p>【简洁清晰明了】http://litang.me/post/golang-…</p><br />
<br />
<p>【柴大 &amp;&amp; 曹大 《Go语言高级编程》】https://chai2010.cn/advanced-…</p><br />
<br />
<p>【Go 并发编程实战】https://book.douban.com/subje…</p><br />
<br />
<p>【曹大 golang notes】https://github.com/cch123/gol…</p><br />
<br />
<p>【互联网技术窝 图解 channel 实现 动画】https://mp.weixin.qq.com/s/40…</p><br />
<br />
<p>【一起学 Golang，推荐的资料非常有用】https://segmentfault.com/a/11…</p><br />
<br />
<p>【如何优雅地关闭 channel】https://go101.org/article/cha…</p><br />
<br />
<p>【深入 channel 底层】https://codeburst.io/diving-d…</p><br />
<br />
<p>【Kavya在Gopher Con 上关于 channel 的设计，非常好】https://speakerd.s3.amazonaws…</p><br />
<br />
<p>【channel 应用】https://www.s0nnet.com/archiv…</p><br />
<br />
<p>【应用举例】https://zhuyasen.com/post/go_…</p><br />
<br />
<p>【应用】https://tonybai.com/2014/09/2…</p><br />
<br />
<p>【鸟窝 并发编程分享】https://colobu.com/2019/04/28…</p><br />
<br />
<p>【Go-Questions，码农桃花源项目】https://github.com/qcrao/Go-Q…</p><br />
<br />
<p>【GitBook 码农桃花源开源书】https://qcrao91.gitbook.io/go/</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>