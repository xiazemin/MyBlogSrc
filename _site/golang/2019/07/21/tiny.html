<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">tiny compiler</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-07-21T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jul 21, 2019</time></p>
					</div>
					 <p>https://github.com/xiazemin/the-super-tiny-compiler-1/blob/master/compiler.go<br />
https://github.com/xiazemin/the-super-tiny-compiler<br />
https://adampresley.github.io/2015/06/01/writing-a-lexer-and-parser-in-go-part-3.html<br />
https://adampresley.github.io/2015/06/01/writing-a-lexer-and-parser-in-go-part-2.html<br />
https://adampresley.github.io/2015/06/01/writing-a-lexer-and-parser-in-go-part-1.html<br />
<!-- more --><br />
/**</p><br />
<ul><br />
  <li>TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE</li><br />
  <li>T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E</li><br />
  <li>T:::::::::::::::::::::TH:::::::H     H:::::::HE::::::::::::::::::::E</li><br />
  <li>T:::::TT:::::::TT:::::THH::::::H     H::::::HHEE::::::EEEEEEEEE::::E</li><br />
  <li>TTTTTT  T:::::T  TTTTTT  H:::::H     H:::::H    E:::::E       EEEEEE</li><br />
  <li>T:::::T          H:::::H     H:::::H    E:::::E</li><br />
  <li>T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE</li><br />
  <li>T:::::T          H:::::::::::::::::H    E:::::::::::::::E</li><br />
  <li>T:::::T          H:::::::::::::::::H    E:::::::::::::::E</li><br />
  <li>T:::::T          H::::::HHHHH::::::H    E::::::EEEEEEEEEE</li><br />
  <li>T:::::T          H:::::H     H:::::H    E:::::E</li><br />
  <li>T:::::T          H:::::H     H:::::H    E:::::E       EEEEEE</li><br />
  <li>TT:::::::TT      HH::::::H     H::::::HHEE::::::EEEEEEEE:::::E</li><br />
  <li>T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E</li><br />
  <li>T:::::::::T      H:::::::H     H:::::::HE::::::::::::::::::::E</li><br />
  <li>TTTTTTTTTTT      HHHHHHHHH     HHHHHHHHHEEEEEEEEEEEEEEEEEEEEEE<br />
 *</li><br />
  <li>SSSSSSSSSSSSSSS UUUUUUUU     UUUUUUUUPPPPPPPPPPPPPPPPP   EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR</li><br />
  <li>SS:::::::::::::::SU::::::U     U::::::UP::::::::::::::::P  E::::::::::::::::::::ER::::::::::::::::R</li><br />
  <li>S:::::SSSSSS::::::SU::::::U     U::::::UP::::::PPPPPP:::::P E::::::::::::::::::::ER::::::RRRRRR:::::R</li><br />
  <li>S:::::S     SSSSSSSUU:::::U     U:::::UUPP:::::P     P:::::PEE::::::EEEEEEEEE::::ERR:::::R     R:::::R</li><br />
  <li>S:::::S             U:::::U     U:::::U   P::::P     P:::::P  E:::::E       EEEEEE  R::::R     R:::::R</li><br />
  <li>S:::::S             U:::::U     U:::::U   P::::P     P:::::P  E:::::E               R::::R     R:::::R</li><br />
  <li>S::::SSSS          U:::::U     U:::::U   P::::PPPPPP:::::P   E::::::EEEEEEEEEE     R::::RRRRRR:::::R</li><br />
  <li>SS::::::SSSSS     U:::::U     U:::::U   P:::::::::::::PP    E:::::::::::::::E     R:::::::::::::RR</li><br />
  <li>SSS::::::::SS   U:::::U     U:::::U   P::::PPPPPPPPP      E:::::::::::::::E     R::::RRRRRR:::::R</li><br />
  <li>SSSSSS::::S  U:::::U     U:::::U   P::::P              E::::::EEEEEEEEEE     R::::R     R:::::R</li><br />
  <li>S:::::S U:::::U     U:::::U   P::::P              E:::::E               R::::R     R:::::R</li><br />
  <li>S:::::S U::::::U   U::::::U   P::::P              E:::::E       EEEEEE  R::::R     R:::::R</li><br />
  <li>SSSSSSS     S:::::S U:::::::UUU:::::::U PP::::::PP          EE::::::EEEEEEEE:::::ERR:::::R     R:::::R</li><br />
  <li>S::::::SSSSSS:::::S  UU:::::::::::::UU  P::::::::P          E::::::::::::::::::::ER::::::R     R:::::R</li><br />
  <li>S:::::::::::::::SS     UU:::::::::UU    P::::::::P          E::::::::::::::::::::ER::::::R     R:::::R</li><br />
  <li>SSSSSSSSSSSSSSS         UUUUUUUUU      PPPPPPPPPP          EEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR<br />
 *</li><br />
  <li>TTTTTTTTTTTTTTTTTTTTTTTIIIIIIIIIINNNNNNNN        NNNNNNNNYYYYYYY       YYYYYYY</li><br />
  <li>T:::::::::::::::::::::TI::::::::IN:::::::N       N::::::NY:::::Y       Y:::::Y</li><br />
  <li>T:::::::::::::::::::::TI::::::::IN::::::::N      N::::::NY:::::Y       Y:::::Y</li><br />
  <li>T:::::TT:::::::TT:::::TII::::::IIN:::::::::N     N::::::NY::::::Y     Y::::::Y</li><br />
  <li>TTTTTT  T:::::T  TTTTTT  I::::I  N::::::::::N    N::::::NYYY:::::Y   Y:::::YYY</li><br />
  <li>T:::::T          I::::I  N:::::::::::N   N::::::N   Y:::::Y Y:::::Y</li><br />
  <li>T:::::T          I::::I  N:::::::N::::N  N::::::N    Y:::::Y:::::Y</li><br />
  <li>T:::::T          I::::I  N::::::N N::::N N::::::N     Y:::::::::Y</li><br />
  <li>T:::::T          I::::I  N::::::N  N::::N:::::::N      Y:::::::Y</li><br />
  <li>T:::::T          I::::I  N::::::N   N:::::::::::N       Y:::::Y</li><br />
  <li>T:::::T          I::::I  N::::::N    N::::::::::N       Y:::::Y</li><br />
  <li>T:::::T          I::::I  N::::::N     N:::::::::N       Y:::::Y</li><br />
  <li>TT:::::::TT      II::::::IIN::::::N      N::::::::N       Y:::::Y</li><br />
  <li>T:::::::::T      I::::::::IN::::::N       N:::::::N    YYYY:::::YYYY</li><br />
  <li>T:::::::::T      I::::::::IN::::::N        N::::::N    Y:::::::::::Y</li><br />
  <li>TTTTTTTTTTT      IIIIIIIIIINNNNNNNN         NNNNNNN    YYYYYYYYYYYYY<br />
 *</li><br />
  <li>CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPPPPPPPPP   IIIIIIIIIILLLLLLLLLLL             EEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR</li><br />
  <li>CCC::::::::::::C   OO:::::::::OO   M:::::::M             M:::::::MP::::::::::::::::P  I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::::::::::::R</li><br />
  <li>CC:::::::::::::::C OO:::::::::::::OO M::::::::M           M::::::::MP::::::PPPPPP:::::P I::::::::IL:::::::::L             E::::::::::::::::::::ER::::::RRRRRR:::::R</li><br />
  <li>C:::::CCCCCCCC::::CO:::::::OOO:::::::OM:::::::::M         M:::::::::MPP:::::P     P:::::PII::::::IILL:::::::LL             EE::::::EEEEEEEEE::::ERR:::::R     R:::::R</li><br />
  <li>C:::::C       CCCCCCO::::::O   O::::::OM::::::::::M       M::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E       EEEEEE  R::::R     R:::::R</li><br />
  <li>C:::::C              O:::::O     O:::::OM:::::::::::M     M:::::::::::M  P::::P     P:::::P  I::::I    L:::::L                 E:::::E               R::::R     R:::::R</li><br />
  <li>C:::::C              O:::::O     O:::::OM:::::::M::::M   M::::M:::::::M  P::::PPPPPP:::::P   I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::RRRRRR:::::R</li><br />
  <li>C:::::C              O:::::O     O:::::OM::::::M M::::M M::::M M::::::M  P:::::::::::::PP    I::::I    L:::::L                 E:::::::::::::::E     R:::::::::::::RR</li><br />
  <li>C:::::C              O:::::O     O:::::OM::::::M  M::::M::::M  M::::::M  P::::PPPPPPPPP      I::::I    L:::::L                 E:::::::::::::::E     R::::RRRRRR:::::R</li><br />
  <li>C:::::C              O:::::O     O:::::OM::::::M   M:::::::M   M::::::M  P::::P              I::::I    L:::::L                 E::::::EEEEEEEEEE     R::::R     R:::::R</li><br />
  <li>C:::::C              O:::::O     O:::::OM::::::M    M:::::M    M::::::M  P::::P              I::::I    L:::::L                 E:::::E               R::::R     R:::::R</li><br />
  <li>C:::::C       CCCCCCO::::::O   O::::::OM::::::M     MMMMM     M::::::M  P::::P              I::::I    L:::::L         LLLLLL  E:::::E       EEEEEE  R::::R     R:::::R</li><br />
  <li>C:::::CCCCCCCC::::CO:::::::OOO:::::::OM::::::M               M::::::MPP::::::PP          II::::::IILL:::::::LLLLLLLLL:::::LEE::::::EEEEEEEE:::::ERR:::::R     R:::::R</li><br />
  <li>CC:::::::::::::::C OO:::::::::::::OO M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R</li><br />
  <li>CCC::::::::::::C   OO:::::::::OO   M::::::M               M::::::MP::::::::P          I::::::::IL::::::::::::::::::::::LE::::::::::::::::::::ER::::::R     R:::::R</li><br />
  <li>CCCCCCCCCCCCC     OOOOOOOOO     MMMMMMMM               MMMMMMMMPPPPPPPPPP          IIIIIIIIIILLLLLLLLLLLLLLLLLLLLLLLLEEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR<br />
 *</li><br />
  <li>=======================================================================================================================================================================</li><br />
  <li>=======================================================================================================================================================================</li><br />
  <li>=======================================================================================================================================================================</li><br />
  <li>=======================================================================================================================================================================<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Today we’re going to write a compiler together. But not just any compiler… A</li><br />
  <li>super duper teeny tiny compiler! A compiler that is so small that if you</li><br />
  <li>remove all the comments this file would only be ~200 lines of actual code.<br />
 *</li><br />
  <li>We’re going to compile some lisp-like function calls into some C-like</li><br />
  <li>function calls.<br />
 *</li><br />
  <li>If you are not familiar with one or the other. I’ll just give you a quick intro.<br />
 *</li><br />
  <li>If we had two functions <code class="language-plaintext highlighter-rouge">add</code> and <code class="language-plaintext highlighter-rouge">subtract</code> they would be written like this:<br />
 *</li><br />
  <li>LISP                      C<br />
 *</li><br />
  <li>2 + 2          (add 2 2)                 add(2, 2)</li><br />
  <li>4 - 2          (subtract 4 2)            subtract(4, 2)</li><br />
  <li>2 + (4 - 2)    (add 2 (subtract 4 2))    add(2, subtract(4, 2))<br />
 *</li><br />
  <li>Easy peezy right?<br />
 *</li><br />
  <li>Well good, because this is exactly what we are going to compile. While this</li><br />
  <li>is neither a complete LISP or C syntax, it will be enough of the syntax to</li><br />
  <li>demonstrate many of the major pieces of a modern compiler.<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Most compilers break down into three primary stages: Parsing, Transformation,</li><br />
  <li>and Code Generation<br />
 *</li><br />
  <li><br />
    <ol><br />
      <li><em>Parsing</em> is taking raw code and turning it into a more abstract</li><br />
    </ol><br />
  </li><br />
  <li>representation of the code.<br />
 *</li><br />
  <li><br />
    <ol><br />
      <li><em>Transformation</em> takes this abstract representation and manipulates to do</li><br />
    </ol><br />
  </li><br />
  <li>whatever the compiler wants it to.<br />
 *</li><br />
  <li><br />
    <ol><br />
      <li><em>Code Generation</em> takes the transformed representation of the code and</li><br />
    </ol><br />
  </li><br />
  <li>turns it into new code.<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Parsing</li><br />
  <li><br />
    <hr /><br />
    <p>*</p><br />
  </li><br />
  <li>Parsing typically gets broken down into two phases: Lexical Analysis and</li><br />
  <li>Syntactic Analysis.<br />
 *</li><br />
  <li><br />
    <ol><br />
      <li><em>Lexical Analysis</em> takes the raw code and splits it apart into these things</li><br />
    </ol><br />
  </li><br />
  <li>called tokens by a thing called a tokenizer (or lexer).<br />
 *</li><br />
  <li>Tokens are an array of tiny little objects that describe an isolated piece</li><br />
  <li>of the syntax. They could be numbers, labels, punctuation, operators,</li><br />
  <li>whatever.<br />
 *</li><br />
  <li><br />
    <ol><br />
      <li><em>Syntactic Analysis</em> takes the tokens and reformats them into a</li><br />
    </ol><br />
  </li><br />
  <li>representation that describes each part of the syntax and their relation</li><br />
  <li>to one another. This is known as an intermediate representation or</li><br />
  <li>Abstract Syntax Tree.<br />
 *</li><br />
  <li>An Abstract Syntax Tree, or AST for short, is a deeply nested object that</li><br />
  <li>represents code in a way that is both easy to work with and tells us a lot</li><br />
  <li>of information.<br />
 *</li><br />
  <li>For the following syntax:<br />
 *</li><br />
  <li>(add 2 (subtract 4 2))<br />
 *</li><br />
  <li>Tokens might look something like this:<br />
 *</li><br />
  <li>[</li><br />
  <li>{ type: ‘paren’,  value: ‘(‘        },</li><br />
  <li>{ type: ‘name’,   value: ‘add’      },</li><br />
  <li>{ type: ‘number’, value: ‘2’        },</li><br />
  <li>{ type: ‘paren’,  value: ‘(‘        },</li><br />
  <li>{ type: ‘name’,   value: ‘subtract’ },</li><br />
  <li>{ type: ‘number’, value: ‘4’        },</li><br />
  <li>{ type: ‘number’, value: ‘2’        },</li><br />
  <li>{ type: ‘paren’,  value: ‘)’        },</li><br />
  <li>{ type: ‘paren’,  value: ‘)’        }</li><br />
  <li>]<br />
 *</li><br />
  <li>And an Abstract Syntax Tree (AST) might look like this:<br />
 *</li><br />
  <li>{</li><br />
  <li>type: ‘Program’,</li><br />
  <li>body: [{</li><br />
  <li>type: ‘CallExpression’,</li><br />
  <li>name: ‘add’,</li><br />
  <li>params: [{</li><br />
  <li>type: ‘NumberLiteral’,</li><br />
  <li>value: ‘2’</li><br />
  <li>}, {</li><br />
  <li>type: ‘CallExpression’,</li><br />
  <li>name: ‘subtract’,</li><br />
  <li>params: [{</li><br />
  <li>type: ‘NumberLiteral’,</li><br />
  <li>value: ‘4’</li><br />
  <li>}, {</li><br />
  <li>type: ‘NumberLiteral’,</li><br />
  <li>value: ‘2’</li><br />
  <li>}]</li><br />
  <li>}]</li><br />
  <li>}]</li><br />
  <li>}<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Transformation</li><br />
  <li><br />
    <hr /><br />
    <p>*</p><br />
  </li><br />
  <li>The next type of stage for a compiler is transformation. Again, this just</li><br />
  <li>takes the AST from the last step and makes changes to it. It can manipulate</li><br />
  <li>the AST in the same language or it can translate it into an entirely new</li><br />
  <li>language.<br />
 *</li><br />
  <li>Let’s look at how we would transform an AST.<br />
 *</li><br />
  <li>You might notice that our AST has elements within it that look very similar.</li><br />
  <li>There are these objects with a type property. Each of these are known as an</li><br />
  <li>AST Node. These nodes have defined properties on them that describe one</li><br />
  <li>isolated part of the tree.<br />
 *</li><br />
  <li>We can have a node for a “NumberLiteral”:<br />
 *</li><br />
  <li>{</li><br />
  <li>type: ‘NumberLiteral’,</li><br />
  <li>value: ‘2’</li><br />
  <li>}<br />
 *</li><br />
  <li>Or maybe a node for a “CallExpression”:<br />
 *</li><br />
  <li>{</li><br />
  <li>type: ‘CallExpression’,</li><br />
  <li>name: ‘subtract’,</li><br />
  <li>params: […nested nodes go here…]</li><br />
  <li>}<br />
 *</li><br />
  <li>When transforming the AST we can manipulate nodes by</li><br />
  <li>adding/removing/replacing properties, we can add new nodes, remove nodes, or</li><br />
  <li>we could leave the existing AST alone and create an entirely new one based</li><br />
  <li>on it.<br />
 *</li><br />
  <li>Since we’re targeting a new language, we’re going to focus on creating an</li><br />
  <li>entirely new AST that is specific to the target language.<br />
 *</li><br />
  <li>Traversal</li><br />
  <li><br />
    <hr /><br />
    <p>*</p><br />
  </li><br />
  <li>In order to navigate through all of these nodes, we need to be able to</li><br />
  <li>traverse through them. This traversal process goes to each node in the AST</li><br />
  <li>depth-first.<br />
 *</li><br />
  <li>{</li><br />
  <li>type: ‘Program’,</li><br />
  <li>body: [{</li><br />
  <li>type: ‘CallExpression’,</li><br />
  <li>name: ‘add’,</li><br />
  <li>params: [{</li><br />
  <li>type: ‘NumberLiteral’,</li><br />
  <li>value: ‘2’</li><br />
  <li>}, {</li><br />
  <li>type: ‘CallExpression’,</li><br />
  <li>name: ‘subtract’,</li><br />
  <li>params: [{</li><br />
  <li>type: ‘NumberLiteral’,</li><br />
  <li>value: ‘4’</li><br />
  <li>}, {</li><br />
  <li>type: ‘NumberLiteral’,</li><br />
  <li>value: ‘2’</li><br />
  <li>}]</li><br />
  <li>}]</li><br />
  <li>}]</li><br />
  <li>}<br />
 *</li><br />
  <li>So for the above AST we would go:<br />
 *</li><br />
  <li><br />
    <ol><br />
      <li>Program - Starting at the top level of the AST</li><br />
    </ol><br />
  </li><br />
  <li><br />
    <ol><br />
      <li>CallExpression (add) - Moving to the first element of the Program’s body</li><br />
    </ol><br />
  </li><br />
  <li><br />
    <ol><br />
      <li>NumberLiteral (2) - Moving to the first element of CallExpression’s params</li><br />
    </ol><br />
  </li><br />
  <li><br />
    <ol><br />
      <li>CallExpression (subtract) - Moving to the second element of CallExpression’s params</li><br />
    </ol><br />
  </li><br />
  <li><br />
    <ol><br />
      <li>NumberLiteral (4) - Moving to the first element of CallExpression’s params</li><br />
    </ol><br />
  </li><br />
  <li><br />
    <ol><br />
      <li>NumberLiteral (2) - Moving to the second element of CallExpression’s params<br />
 *</li><br />
    </ol><br />
  </li><br />
  <li>If we were manipulating this AST directly, instead of creating a separate AST,</li><br />
  <li>we would likely introduce all sorts of abstractions here. But just visiting</li><br />
  <li>each node in the tree is enough.<br />
 *</li><br />
  <li>The reason I use the word “visiting” is because there is this pattern of how</li><br />
  <li>to represent operations on elements of an object structure.<br />
 *</li><br />
  <li>Visitors</li><br />
  <li><br />
    <hr /><br />
    <p>*</p><br />
  </li><br />
  <li>The basic idea here is that we are going to create a “visitor” object that</li><br />
  <li>has methods that will accept different node types.<br />
 *</li><br />
  <li>var visitor = {</li><br />
  <li>NumberLiteral() {},</li><br />
  <li>CallExpression() {}</li><br />
  <li>};<br />
 *</li><br />
  <li>When we traverse our AST we will call the methods on this visitor whenever we</li><br />
  <li>encounter a node of a matching type.<br />
 *</li><br />
  <li>In order to make this useful we will also pass the node and a reference to</li><br />
  <li>the parent node.<br />
 *</li><br />
  <li>var visitor = {</li><br />
  <li>NumberLiteral(node, parent) {},</li><br />
  <li>CallExpression(node, parent) {}</li><br />
  <li>};<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Code Generation</li><br />
  <li><br />
    <hr /><br />
    <p>*</p><br />
  </li><br />
  <li>The final phase of a compiler is code generation. Sometimes compilers will do</li><br />
  <li>things that overlap with transformation, but for the most part code</li><br />
  <li>generation just means take our AST and string-ify code back out.<br />
 *</li><br />
  <li>Code generators work several different ways, some compilers will reuse the</li><br />
  <li>tokens from earlier, others will have created a separate representation of</li><br />
  <li>the code so that they can print node linearly, but from what I can tell most</li><br />
  <li>will use the same AST we just created, which is what we’re going to focus on.<br />
 *</li><br />
  <li>Effectively our code generator will know how to “print” all of the different</li><br />
  <li>node types of the AST, and it will recursively call itself to print nested</li><br />
  <li>nodes until everything is printed into one long string of code.<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>And that’s it! That’s all the different pieces of a compiler.<br />
 *</li><br />
  <li>Now that isn’t to say every compiler looks exactly like I described here.</li><br />
  <li>Compilers serve many different purposes, and they might need more steps than</li><br />
  <li>I have detailed.<br />
 *</li><br />
  <li>But now you should have a general high-level idea of what most compilers look</li><br />
  <li>like.<br />
 *</li><br />
  <li>Now that I’ve explained all of this, you’re all good to go write your own</li><br />
  <li>compilers right?<br />
 *</li><br />
  <li>Just kidding, that’s what I’m here to help with :P<br />
 *</li><br />
  <li>So let’s begin…<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>============================================================================</li><br />
  <li>(/^▽^)/</li><br />
  <li>THE TOKENIZER!</li><br />
  <li>============================================================================<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>We’re gonna start off with our first phase of parsing, lexical analysis, with</li><br />
  <li>the tokenizer.<br />
 *</li><br />
  <li>We’re just going to take our string of code and break it down into an array</li><br />
  <li>of tokens.<br />
 *</li><br />
  <li>(add 2 (subtract 4 2))   =&gt;   [{ type: ‘paren’, value: ‘(‘ }, …]<br />
 */<br />
package main</li><br />
</ul><br />
<br />
<p>import (<br />
	“fmt”<br />
	“log”<br />
	“strings”<br />
)</p><br />
<br />
<p>type token struct {<br />
	kind  string<br />
	value string<br />
}</p><br />
<br />
<p>// We start by accepting an input string of code, and we’re gonna set up two<br />
// things…<br />
func tokenizer(input string) []token {<br />
	// A new line is appended to the program<br />
	input += “\n”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// A `current` variable for tracking our position in the code like a cursor.<br />
current := 0<br />
<br />
// And a slice of our `token` type for appending tokens to.<br />
tokens := []token{}<br />
<br />
// We start by creating a `for` loop where we are setting up our `current`<br />
// variable to be incremented as much as we want `inside` the loop.<br />
//<br />
// We do this because we may want to increment `current` many times within a<br />
// single loop because our tokens can be any length.<br />
for current &lt; len([]rune(input)) {<br />
<br />
	// We're also going to store the `current` character in the `input`.<br />
	char := string([]rune(input)[current])<br />
<br />
	// The first thing we want to check for is an open parenthesis. This will<br />
	// later be used for `CallExpressions` but for now we only care about the<br />
	// character.<br />
	//<br />
	// We check to see if we have an open parenthesis:<br />
	if char == "(" {<br />
<br />
		// If we do, we append a new token to our slice with the kind `paren`<br />
		// and set the value to an open parenthesis.<br />
		tokens = append(tokens, token{<br />
			kind:  "paren",<br />
			value: "(",<br />
		})<br />
<br />
		// Then we increment `current`<br />
		current++<br />
<br />
		// And we `continue` onto the next cycle of the loop.<br />
		continue<br />
	}<br />
<br />
	// Next we're going to check for a closing parenthesis. We do the same exact<br />
	// thing as before: Check for a closing parenthesis, add a new token,<br />
	// increment `current`, and `continue`.<br />
	if char == ")" {<br />
		tokens = append(tokens, token{<br />
			kind:  "paren",<br />
			value: ")",<br />
		})<br />
		current++<br />
		continue<br />
	}<br />
<br />
	// Moving on, we're now going to check for whitespace. This is interesting<br />
	// because we care that whitespace exists to separate characters, but it<br />
	// isn't actually important for us to store as a token. We would only throw<br />
	// it out later.<br />
	//<br />
	// So here we're just going to test for existence and if it does exist we're<br />
	// going to just `continue` on.<br />
	if char == " " {<br />
		current++<br />
		continue<br />
	}<br />
<br />
	// The next type of token is a number. This is different than what we have<br />
	// seen before because a number could be any number of characters and we<br />
	// want to capture the entire sequence of characters as one token.<br />
	//<br />
	//   (add 123 456)<br />
	//        ^^^ ^^^<br />
	//        Only two separate tokens<br />
	//<br />
	// So we start this off when we encounter the first number in a sequence.<br />
	if isNumber(char) {<br />
<br />
		// We're going to create a `value` string that we are going to append<br />
		// characters to.<br />
		value := ""<br />
<br />
		// Then we're going to loop through each character in the sequence until<br />
		// we encounter a character that is not a number, pushing each character<br />
		// that is a number to our `value` and incrementing `current` as we go.<br />
		for isNumber(char) {<br />
			value += char<br />
			current++<br />
			char = string([]rune(input)[current])<br />
		}<br />
<br />
		// After that we append our `number` token to the `tokens` slice.<br />
		tokens = append(tokens, token{<br />
			kind:  "number",<br />
			value: value,<br />
		})<br />
<br />
		// And we continue on.<br />
		continue<br />
	}<br />
<br />
	// The last type of token will be a `name` token. This is a sequence of<br />
	// letters instead of numbers, that are the names of functions in our lisp<br />
	// syntax.<br />
	//<br />
	//   (add 2 4)<br />
	//    ^^^<br />
	//    Name token<br />
	//<br />
	if isLetter(char) {<br />
		value := ""<br />
<br />
		// Again we're just going to loop through all the letters pushing them to<br />
		// a value.<br />
		for isLetter(char) {<br />
			value += char<br />
			current++<br />
			char = string([]rune(input)[current])<br />
		}<br />
<br />
		// And appending that value as a token with the type `name` and continuing.<br />
		tokens = append(tokens, token{<br />
			kind:  "name",<br />
			value: value,<br />
		})<br />
		continue<br />
	}<br />
	break<br />
}<br />
<br />
// Then at the end of our `tokenizer` we simply return the tokens array.<br />
return tokens }<br />
</code></pre></div></div><br />
<br />
<p>// isNumber accepts a string and will check to see whether or not what has been<br />
// passed through is between the range of 0 - 9.<br />
func isNumber(char string) bool {<br />
	if char == “” {<br />
		return false<br />
	}<br />
	n := []rune(char)[0]<br />
	if n &gt;= ‘0’ &amp;&amp; n &lt;= ‘9’ {<br />
		return true<br />
	}<br />
	return false<br />
}</p><br />
<br />
<p>// isLetter works in a similar way to isNumber, but checks the range for a<br />
// letter in the range of a - z.<br />
func isLetter(char string) bool {<br />
	if char == “” {<br />
		return false<br />
	}<br />
	n := []rune(char)[0]<br />
	if n &gt;= ‘a’ &amp;&amp; n &lt;= ‘z’ {<br />
		return true<br />
	}<br />
	return false<br />
}</p><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>============================================================================</li><br />
  <li>ヽ/❀o ل͜ o\ﾉ</li><br />
  <li>THE PARSER!!!</li><br />
  <li>============================================================================<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>For our parser we’re going to take our array of tokens and turn it into an</li><br />
  <li>AST.<br />
 *</li><br />
  <li>[{ type: ‘paren’, value: ‘(‘ }, …]   =&gt;   { type: ‘Program’, body: […] }<br />
 */</li><br />
</ul><br />
<br />
<p>// We will define our type, <code class="language-plaintext highlighter-rouge">node</code> here. Within node are pointers types to what<br />
// would otherwise be recursive types in Go. e.g.<br />
//<br />
// callee    node<br />
//<br />
// Would cause the Go compiler to complain about a recursive type. When we want<br />
// to use one of these types to pass through to a function, for example, we’d<br />
// use <code class="language-plaintext highlighter-rouge">&amp;</code> as it’d be a reference. But we’ll come to that a bit later on.<br />
type node struct {<br />
	kind       string<br />
	value      string<br />
	name       string<br />
	callee     *node<br />
	expression *node<br />
	body       []node<br />
	params     []node<br />
	arguments  *[]node<br />
	context    *[]node<br />
}</p><br />
<br />
<p>// Type <code class="language-plaintext highlighter-rouge">ast</code> is just another alias type. I find this makes part of the code<br />
// more readable, as you’ll come to see that there are a ton of references to<br />
// <code class="language-plaintext highlighter-rouge">node</code>.<br />
type ast node</p><br />
<br />
<p>// This is the counter variable that we’ll use for parsing.<br />
var pc int</p><br />
<br />
<p>// This variable will store our slice of <code class="language-plaintext highlighter-rouge">token</code>s inside of it.<br />
var pt []token</p><br />
<br />
<p>// Okay, so we define a <code class="language-plaintext highlighter-rouge">parser</code> function that accepts our slice of <code class="language-plaintext highlighter-rouge">tokens</code>.<br />
func parser(tokens []token) ast {<br />
	// Here, we initially give both the parser counter and the parser tokens a<br />
	// value.<br />
	pc = 0<br />
	pt = tokens</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Now, we're going to create our AST which will have a root which is a<br />
// `Program` node.<br />
ast := ast{<br />
	kind: "Program",<br />
	body: []node{},<br />
}<br />
<br />
// And we're going to kickstart our `walk` function, which you can find just<br />
// below this, we'll be pushing nodes to our `ast.body` slice.<br />
//<br />
// The reason we are doing this inside a loop is because our program can have<br />
// `CallExpressions` after one another instead of being nested.<br />
//<br />
//   (add 2 2)<br />
//   (subtract 4 2)<br />
//<br />
for pc &lt; len(pt) {<br />
	ast.body = append(ast.body, walk())<br />
}<br />
<br />
// At the end of our parser we'll return the AST.<br />
return ast }<br />
</code></pre></div></div><br />
<br />
<p>// But this time we’re going to use recursion instead of a <code class="language-plaintext highlighter-rouge">while</code> loop. So we<br />
// define a <code class="language-plaintext highlighter-rouge">walk</code> function.<br />
func walk() node {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Inside the walk function we start by grabbing the `current` token.<br />
token := pt[pc]<br />
<br />
// We're going to split each type of token off into a different code path,<br />
// starting off with `number` tokens.<br />
//<br />
// We test to see if we have a `number` token.<br />
if token.kind == "number" {<br />
<br />
	// If we have one, we'll increment `current`.<br />
	pc++<br />
<br />
	// And we'll return a new AST node called `NumberLiteral` and setting its<br />
	// value to the value of our token.<br />
	return node{<br />
		kind:  "NumberLiteral",<br />
		value: token.value,<br />
	}<br />
}<br />
<br />
// Next we're going to look for CallExpressions. We start this off when we<br />
// encounter an open parenthesis.<br />
if token.kind == "paren" &amp;&amp; token.value == "(" {<br />
<br />
	// We'll increment `current` to skip the parenthesis since we don't care<br />
	// about it in our AST.<br />
	pc++<br />
	token = pt[pc]<br />
<br />
	// We create a base node with the type `CallExpression`, and we're going<br />
	// to set the name as the current token's value since the next token after<br />
	// the open parenthesis is the name of the function.<br />
	n := node{<br />
		kind:   "CallExpression",<br />
		name:   token.value,<br />
		params: []node{},<br />
	}<br />
<br />
	// We increment `current` *again* to skip the name token.<br />
	pc++<br />
	token = pt[pc]<br />
<br />
	// And now we want to loop through each token that will be the `params` of<br />
	// our `CallExpression` until we encounter a closing parenthesis.<br />
	//<br />
	// Now this is where recursion comes in. Instead of trying to parse a<br />
	// potentially infinitely nested set of nodes we're going to rely on<br />
	// recursion to resolve things.<br />
	//<br />
	// To explain this, let's take our Lisp code. You can see that the<br />
	// parameters of the `add` are a number and a nested `CallExpression` that<br />
	// includes its own numbers.<br />
	//<br />
	//   (add 2 (subtract 4 2))<br />
	//<br />
	// You'll also notice that in our tokens array we have multiple closing<br />
	// parenthesis.<br />
	//<br />
	//   [<br />
	//     { type: 'paren',  value: '('        },<br />
	//     { type: 'name',   value: 'add'      },<br />
	//     { type: 'number', value: '2'        },<br />
	//     { type: 'paren',  value: '('        },<br />
	//     { type: 'name',   value: 'subtract' },<br />
	//     { type: 'number', value: '4'        },<br />
	//     { type: 'number', value: '2'        },<br />
	//     { type: 'paren',  value: ')'        }, &lt;&lt;&lt; Closing parenthesis<br />
	//     { type: 'paren',  value: ')'        }  &lt;&lt;&lt; Closing parenthesis<br />
	//   ]<br />
	//<br />
	// We're going to rely on the nested `walk` function to increment our<br />
	// `current` variable past any nested `CallExpressions`.<br />
<br />
	// So we create a `for` loop that will continue until it encounters a<br />
	// token with a `type` of `'paren'` and a `value` of a closing<br />
	// parenthesis.<br />
	for token.kind != "paren" || (token.kind == "paren" &amp;&amp; token.value != ")") {<br />
		// we'll call the `walk` function which will return a `node` and we'll<br />
		// push it into our `node.params`.<br />
		n.params = append(n.params, walk())<br />
		token = pt[pc]<br />
	}<br />
<br />
	// Finally we will increment `current` one last time to skip the closing<br />
	// parenthesis.<br />
	pc++<br />
<br />
	// And return the node.<br />
	return n<br />
}<br />
<br />
// Again, if we haven't recognized the token type by now we're going to<br />
// throw an error.<br />
log.Fatal(token.kind)<br />
return node{} }<br />
</code></pre></div></div><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>============================================================================</li><br />
  <li>⌒(❀&gt;◞౪◟&lt;❀)⌒</li><br />
  <li>THE TRAVERSER!!!</li><br />
  <li>============================================================================<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>So now we have our AST, and we want to be able to visit different nodes with</li><br />
  <li>a visitor. We need to be able to call the methods on the visitor whenever we</li><br />
  <li>encounter a node with a matching type.<br />
 *</li><br />
  <li>traverse(ast, {</li><br />
  <li>Program(node, parent) {</li><br />
  <li>// …</li><br />
  <li>},<br />
 *</li><br />
  <li>CallExpression(node, parent) {</li><br />
  <li>// …</li><br />
  <li>},<br />
 *</li><br />
  <li>NumberLiteral(node, parent) {</li><br />
  <li>// …</li><br />
  <li>}</li><br />
  <li>});<br />
 */</li><br />
</ul><br />
<br />
<p>// We will define our <code class="language-plaintext highlighter-rouge">visitor</code> type here in such a way that strings can<br />
// be tested against easily and then represent the function associoated with it.<br />
//<br />
// e.g.<br />
// “NumberLiteral” : func(n *node, p node) {<br />
//     // do something<br />
// }<br />
//<br />
type visitor map[string]func(n *node, p node)</p><br />
<br />
<p>// So we define a traverser function which accepts an AST and a<br />
// visitor. Inside we’re going to define two functions…<br />
func traverser(a ast, v visitor) {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// We kickstart the traverser by calling `traverseNode` with our ast<br />
// with no `parent` because the top level of the AST doesn't have a parent.<br />
traverseNode(node(a), node{}, v) }<br />
</code></pre></div></div><br />
<br />
<p>// A <code class="language-plaintext highlighter-rouge">traverseArray</code> function that will allow us to iterate over a slice and<br />
// call the next function that we will define: <code class="language-plaintext highlighter-rouge">traverseNode</code>.<br />
func traverseArray(a []node, p node, v visitor) {<br />
	for _, child := range a {<br />
		traverseNode(child, p, v)<br />
	}<br />
}</p><br />
<br />
<p>// <code class="language-plaintext highlighter-rouge">traverseNode</code> will accept a <code class="language-plaintext highlighter-rouge">node</code> and its <code class="language-plaintext highlighter-rouge">parent</code> node. So that it can<br />
// pass both to our visitor methods.<br />
func traverseNode(n, p node, v visitor) {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// We start by testing for the existence of a method on the visitor with a<br />
// matching `type` and then calling it with the `node` and its `parent`.<br />
for k, va := range v {<br />
	if k == n.kind {<br />
		va(&amp;n, p)<br />
	}<br />
}<br />
<br />
// Next we are going to split things up by the current node type.<br />
switch n.kind {<br />
<br />
// We'll start with our top level `Program`. Since Program nodes have a<br />
// property named body that has an array of nodes, we will call<br />
// `traverseArray` to traverse down into them.<br />
//<br />
// (Remember that `traverseArray` will in turn call `traverseNode` so  we<br />
// are causing the tree to be traversed recursively)<br />
case "Program":<br />
	traverseArray(n.body, n, v)<br />
	break<br />
<br />
// Next we do the same with `CallExpressions` and traverse their `params`.<br />
case "CallExpression":<br />
	traverseArray(n.params, n, v)<br />
	break<br />
<br />
// In the case of `NumberLiterals` we don't have any child nodes to visit,<br />
// so we'll just break.<br />
case "NumberLiteral":<br />
	break<br />
<br />
// And again, if we haven't recognized the node type then we'll throw an<br />
// error.<br />
default:<br />
	log.Fatal(n.kind)<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>============================================================================</li><br />
  <li>⁽(◍˃̵͈̑ᴗ˂̵͈̑)⁽</li><br />
  <li>THE TRANSFORMER!!!</li><br />
  <li>============================================================================<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Next up, the transformer. Our transformer is going to take the AST that we</li><br />
  <li>have built and pass it to our traverser function with a visitor and will</li><br />
  <li>create a new ast.<br />
 *</li><br />
  <li><br />
    <hr /><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>Original AST</td><br />
          <td>Transformed AST</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <hr /><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>{</td><br />
          <td>{</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>type: ‘Program’,</td><br />
          <td>type: ‘Program’,</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>body: [{</td><br />
          <td>body: [{</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>type: ‘CallExpression’,</td><br />
          <td>type: ‘ExpressionStatement’,</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>name: ‘add’,</td><br />
          <td>expression: {</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>params: [{</td><br />
          <td>type: ‘CallExpression’,</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>type: ‘NumberLiteral’,</td><br />
          <td>callee: {</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>value: ‘2’</td><br />
          <td>type: ‘Identifier’,</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>}, {</td><br />
          <td>name: ‘add’</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>type: ‘CallExpression’,</td><br />
          <td>},</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>name: ‘subtract’,</td><br />
          <td>arguments: [{</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>params: [{</td><br />
          <td>type: ‘NumberLiteral’,</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>type: ‘NumberLiteral’,</td><br />
          <td>value: ‘2’</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>value: ‘4’</td><br />
          <td>}, {</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>}, {</td><br />
          <td>type: ‘CallExpression’,</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>type: ‘NumberLiteral’,</td><br />
          <td>callee: {</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>value: ‘2’</td><br />
          <td>type: ‘Identifier’,</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>}]</td><br />
          <td>name: ‘subtract’</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>}]</td><br />
          <td>},</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>}]</td><br />
          <td>arguments: [{</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>}</td><br />
          <td>type: ‘NumberLiteral’,</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>value: ‘4’</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>———————————-</td><br />
          <td>}, {</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>type: ‘NumberLiteral’,</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>value: ‘2’</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>}]</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>(sorry the other one is longer.)</td><br />
          <td>}]</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>}</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>}]</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>}</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <hr /><br />
    <p>*/</p><br />
  </li><br />
</ul><br />
<br />
<p>// So we have our transformer function which will accept the lisp ast.<br />
func transformer(a ast) ast {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// We'll create a new ast which like our previous AST will have a program<br />
// node.<br />
nast := ast{<br />
	kind: "Program",<br />
	body: []node{},<br />
}<br />
<br />
// Next I'm going to cheat a little and create a bit of a hack. We're going to<br />
// use a property named `context` on our parent nodes that we're going to push<br />
// nodes to their parent's `context`. Normally you would have a better<br />
// abstraction than this, but for our purposes this keeps things simple.<br />
//<br />
// Just take note that the context is a reference *from* the old ast *to* the<br />
// new ast.<br />
a.context = &amp;nast.body<br />
<br />
// We'll start by calling the traverser function with our ast and a visitor.<br />
traverser(a, map[string]func(n *node, p node){<br />
<br />
	// The first visitor method accepts `NumberLiterals`<br />
	"NumberLiteral": func(n *node, p node) {<br />
		// We'll create a new node also named `NumberLiteral` that we will push to<br />
		// the parent context.<br />
		*p.context = append(*p.context, node{<br />
			kind:  "NumberLiteral",<br />
			value: n.value,<br />
		})<br />
	},<br />
<br />
	// Next up, `CallExpressions`.<br />
	"CallExpression": func(n *node, p node) {<br />
<br />
		// We start creating a new node `CallExpression` with a nested<br />
		// `Identifier`.<br />
		e := node{<br />
			kind: "CallExpression",<br />
			callee: &amp;node{<br />
				kind: "Identifier",<br />
				name: n.name,<br />
			},<br />
			arguments: new([]node),<br />
		}<br />
<br />
		// Next we're going to define a new context on the original<br />
		// `CallExpression` node that will reference the `expression`'s arguments<br />
		// so that we can push arguments.<br />
		n.context = e.arguments<br />
<br />
		// Then we're going to check if the parent node is a `CallExpression`.<br />
		// If it is not...<br />
		if p.kind != "CallExpression" {<br />
<br />
			// We're going to wrap our `CallExpression` node with an<br />
			// `ExpressionStatement`.<br />
			es := node{<br />
				kind:       "ExpressionStatement",<br />
				expression: &amp;e,<br />
			}<br />
<br />
			// Last, we push our (possibly wrapped) `CallExpression` to the `parent`'s<br />
			// `context`.<br />
			*p.context = append(*p.context, es)<br />
		} else {<br />
			*p.context = append(*p.context, e)<br />
		}<br />
<br />
	},<br />
})<br />
<br />
// At the end of our transformer function we'll return the new ast that we<br />
// just created.<br />
return nast }<br />
</code></pre></div></div><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>============================================================================</li><br />
  <li>ヾ（〃＾∇＾）ﾉ♪</li><br />
  <li>THE CODE GENERATOR!!!!</li><br />
  <li>============================================================================<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Now let’s move onto our last phase: The Code Generator.<br />
 *</li><br />
  <li>Our code generator is going to recursively call itself to print each node in</li><br />
  <li>the tree into one giant string.<br />
 */</li><br />
</ul><br />
<br />
<p>func codeGenerator(n node) string {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// We'll break things down by the `type` of the `node`.<br />
switch n.kind {<br />
<br />
// If we have a `Program` node. We will map through each node in the `body`<br />
// and run them through the code generator and join them with a newline.<br />
case "Program":<br />
	var r []string<br />
	for _, no := range n.body {<br />
		r = append(r, codeGenerator(no))<br />
	}<br />
	return strings.Join(r, "\n")<br />
<br />
	// For `ExpressionStatements` we'll call the code generator on the nested<br />
	// expression and we'll add a semicolon...<br />
case "ExpressionStatement":<br />
	return codeGenerator(*n.expression) + ";"<br />
<br />
// For `CallExpressions` we will print the `callee`, add an open<br />
// parenthesis, we'll map through each node in the `arguments` array and run<br />
// them through the code generator, joining them with a comma, and then<br />
// we'll add a closing parenthesis.<br />
case "CallExpression":<br />
	var ra []string<br />
	c := codeGenerator(*n.callee)<br />
<br />
	for _, no := range *n.arguments {<br />
		ra = append(ra, codeGenerator(no))<br />
	}<br />
<br />
	r := strings.Join(ra, ", ")<br />
	return c + "(" + r + ")"<br />
<br />
// For `Identifiers` we'll just return the `node`'s name.<br />
case "Identifier":<br />
	return n.name<br />
<br />
// For `NumberLiterals` we'll just return the `node`'s value.<br />
case "NumberLiteral":<br />
	return n.value<br />
<br />
// And if we haven't recognized the node, we'll throw an error.<br />
default:<br />
	log.Fatal("err")<br />
	return ""<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>============================================================================</li><br />
  <li>(۶* ‘ヮ’)۶”</li><br />
  <li>!!!!!!!!THE COMPILER!!!!!!!!</li><br />
  <li>============================================================================<br />
 */</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>FINALLY! We’ll create our <code class="language-plaintext highlighter-rouge">compiler</code> function. Here we will link together</li><br />
  <li>every part of the pipeline.<br />
 *</li><br />
  <li><br />
    <ol><br />
      <li>input  =&gt; tokenizer   =&gt; tokens</li><br />
    </ol><br />
  </li><br />
  <li><br />
    <ol><br />
      <li>tokens =&gt; parser      =&gt; ast</li><br />
    </ol><br />
  </li><br />
  <li><br />
    <ol><br />
      <li>ast    =&gt; transformer =&gt; newAst</li><br />
    </ol><br />
  </li><br />
  <li><br />
    <ol><br />
      <li>newAst =&gt; generator   =&gt; output<br />
 */</li><br />
    </ol><br />
  </li><br />
</ul><br />
<br />
<p>func compiler(input string) string {<br />
	tokens := tokenizer(input)<br />
	ast := parser(tokens)<br />
	nast := transformer(ast)<br />
	out := codeGenerator(node(nast))</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// and simply return the output!<br />
return out }<br />
</code></pre></div></div><br />
<br />
<p>func main() {<br />
	program := “(add 10 (subtract 10 6))”<br />
	out := compiler(program)<br />
	fmt.Println(out)<br />
}</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>