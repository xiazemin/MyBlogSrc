<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">m p g schedt sudog</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-06-16T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jun 16, 2019</time></p>
					</div>
					 <p>go的调度器只要实现在 runtime 包中，路径为： ./src/runtime/proc.go 文件中。<br />
<!-- more --><br />
go语言其实是在操作系统提供的内核线程之上搭建了一个特有得 【两级线程】模型。下面再说两级线程模型前，有三个必知的核心元素。(G、M、P)</p><br />
<br />
<p>G：Goroutine的缩写，一个G代表了对一段需要被执行的Go语言代码的封装<br />
M：Machine的缩写，一个M代表了一个内核线程<br />
P：Processor的缩写，一个P代表了M所需的上下文环境<br />
简单的来说，一个G的执行需要M和P的支持。一个M在与一个P关联之后形成了一个有效的G运行环境【内核线程 + 上下文环境】。每个P都会包含一个可运行的G的队列 (runq )。</p><br />
<br />
<p>好了下面我们来具体的看看 G、M、P</p><br />
<br />
<p>M (machine)：<br />
M是machine的头文字, 在当前版本的golang中等同于系统线程.<br />
M可以运行两种代码:</p><br />
<br />
<p>go代码, 即goroutine, M运行go代码需要一个P<br />
原生代码, 例如阻塞的syscall, M运行原生代码不需要P<br />
M会从运行队列中取出G, 然后运行G, 如果G运行完毕或者进入休眠状态, 则从运行队列中取出下一个G运行, 周而复始。<br />
有时候G需要调用一些无法避免阻塞的原生代码, 这时M会释放持有的P并进入阻塞状态, 其他M会取得这个P并继续运行队列中的G.<br />
go需要保证有足够的M可以运行G, 不让CPU闲着, 也需要保证M的数量不能过多。通常创建一个M的原因是由于没有足够的M来关联P并运行其中可运行的G。而且运行时系统执行系统监控的时候，或者GC的时候也会创建M。</p><br />
<br />
<p>M的结构体定义：(在 ./src/runtime/runtime2.go 文件中)</p><br />
<br />
<p>// M 结构体<br />
type m struct {<br />
    /*<br />
        1.  所有调用栈的Goroutine,这是一个比较特殊的Goroutine。<br />
        2.  普通的Goroutine栈是在Heap分配的可增长的stack,而g0的stack是M对应的线程栈。<br />
        3.  所有调度相关代码,会先切换到该Goroutine的栈再执行。<br />
    */<br />
	g0      *g     // goroutine with scheduling stack<br />
	morebuf gobuf  // gobuf arg to morestack<br />
	divmod  uint32 // div/mod denominator for arm - known to liblink</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Fields not known to debuggers.<br />
procid        uint64       // for debuggers, but offset not hard-coded<br />
gsignal       *g           // signal-handling g<br />
goSigStack    gsignalStack // Go-allocated signal handling stack<br />
sigmask       sigset       // storage for saved signal mask<br />
tls           [6]uintptr   // thread-local storage (for x86 extern register)<br />
mstartfn      func()       // <br />
 <br />
curg          *g       //   M 正在运行的结构体G<br />
caughtsig     guintptr // goroutine running during fatal signal<br />
p             puintptr // attached p for executing go code (nil if not executing go code)<br />
nextp         puintptr<br />
id            int32<br />
mallocing     int32<br />
throwing      int32<br />
preemptoff    string // if != "", keep curg running on this m<br />
locks         int32<br />
softfloat     int32<br />
dying         int32<br />
profilehz     int32<br />
helpgc        int32<br />
spinning      bool // m is out of work and is actively looking for work<br />
blocked       bool // m is blocked on a note<br />
inwb          bool // m is executing a write barrier<br />
newSigstack   bool // minit on C thread called sigaltstack<br />
printlock     int8<br />
incgo         bool // m is executing a cgo call<br />
fastrand      uint32<br />
ncgocall      uint64      // number of cgo calls in total<br />
ncgo          int32       // number of cgo calls currently in progress<br />
cgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily<br />
cgoCallers    *cgoCallers // cgo traceback if crashing in cgo call<br />
park          note<br />
alllink       *m // on allm<br />
schedlink     muintptr<br />
mcache        *mcache<br />
lockedg       *g          // 表示与当前M锁定那个g<br />
createstack   [32]uintptr // stack that created this thread.<br />
freglo        [16]uint32  // d[i] lsb and f[i]<br />
freghi        [16]uint32  // d[i] msb and f[i+16]<br />
fflag         uint32      // floating point compare flags<br />
locked        uint32      // tracking for lockosthread<br />
nextwaitm     uintptr     // next m waiting for lock<br />
needextram    bool<br />
traceback     uint8<br />
waitunlockf   unsafe.Pointer // todo go func(*g, unsafe.pointer) bool<br />
waitlock      unsafe.Pointer<br />
waittraceev   byte<br />
waittraceskip int<br />
startingtrace bool<br />
syscalltick   uint32<br />
thread        uintptr // thread handle<br />
 <br />
// these are here because they are too large to be on the stack<br />
// of low-level NOSPLIT functions.<br />
libcall   libcall<br />
libcallpc uintptr // for cpu profiler<br />
libcallsp uintptr<br />
libcallg  guintptr<br />
syscall   libcall // stores syscall parameters on windows<br />
 <br />
mOS } M的字段众多，其中最重要的为下面四个：<br />
</code></pre></div></div><br />
<br />
<p>g0: Go运行时系统在启动之初创建的，用于执行一些运行时任务。</p><br />
<br />
<p>mstartfn：表示M的起始函数。其实就是我们 go 语句携带的那个函数啦。</p><br />
<br />
<p>curg：存放当前正在运行的G的指针。</p><br />
<br />
<p>p：指向当前与M关联的那个P。</p><br />
<br />
<p>nextp：用于暂存于当前M有潜在关联的P。 （预联）当M重新启动时，即用预联的这个P做关联啦</p><br />
<br />
<p>spinning：表示当前M是否正在寻找G。在寻找过程中M处于自旋状态。</p><br />
<br />
<p>lockedg：表示与当前M锁定的那个G。运行时系统会把 一个M 和一个G锁定，一旦锁定就只能双方相互作用，不接受第三者。</p><br />
<br />
<p>M并没有像G和P一样的状态标记, 但可以认为一个M有以下的状态:</p><br />
<br />
<p>自旋中(spinning): M正在从运行队列获取G, 这时候M会拥有一个P<br />
执行go代码中: M正在执行go代码, 这时候M会拥有一个P<br />
执行原生代码中: M正在执行原生代码或者阻塞的syscall, 这时M并不拥有P<br />
休眠中: M发现无待运行的G时会进入休眠, 并添加到空闲M链表中, 这时M并不拥有P<br />
自旋中(spinning)这个状态非常重要, 是否需要唤醒或者创建新的M取决于当前自旋中的M的数量。</p><br />
<br />
<p>M在被创建之初会被加入到全局的M列表 【runtime.allm】 。接着，M的起始函数（mstartfn）和准备关联的P（p）都会被设置。最后，运行时系统会为M专门创建一个新的内核线程并与之关联。这时候这个新的M就为执行G做好了准备。其中起始函数（mstartfn）仅当运行时系统要用此M执行系统监控或者垃圾回收等任务的时候才会被设置。全局M列表的作用是运行时系统在需要的时候会通过它获取到所有的M的信息，同时防止M被gc。</p><br />
<br />
<p>在新的M被创建后回西安做一番初始化工作。其中包括了对自身所持的栈空间以及信号做处理的初始化。在上述初始化完成后 mstartfn 函数就会被执行 (如果存在的话)。【注意】：如果mstartfn 代表的是系统监控任务的话，那么该M会一直在执行mstartfn 而不会有后续的流程。否则 mstartfn 执行完后，当前M将会与那个准备与之关联的P完成关联。至此，一个并发执行环境才真正完成。之后就是M开始寻找可运行的G并运行之。</p><br />
<br />
<p>运行时系统管辖的M会在GC任务执行的时候被停止，这时候系统会对M的属性做某些必要的重置并把M放置入调度器的空闲M列表。【很重要】因为在需要一个未被使用的M时，运行时系统会先去这个空闲列表获取M。(只有都没有的时候才会创建M)</p><br />
<br />
<p>M本身是无状态的。M是否有空闲仅以它是否存在于调度器的空闲M列表 【runtime.sched.midle】  中为依据 (空闲列表不是那个全局列表哦)。</p><br />
<br />
<p>单个Go程序所使用的M的最大数量是可以被设置的。在我们使用命令运行Go程序时候，有一个引导程序先会被启动的。在这个歌引导程序中会为Go程序的运行简历必要的环境。引导程序对M的数量进行初始化设置，默认是 最大值 1W 【即是说，一个Go程序最多可以使用1W个M，即：理想状态下，可以同时有1W个内核线程被同时运行】。使用 runtime/debug.SetMaxThreads() 函数设置。</p><br />
<br />
<p>P (process)：<br />
P是process的头文字, 代表M运行G所需要的资源。<br />
一些讲解协程的文章把P理解为cpu核心, 其实这是错误的.<br />
虽然P的数量默认等于cpu核心数, 但可以通过环境变量GOMAXPROC修改, 在实际运行时P跟cpu核心并无任何关联。</p><br />
<br />
<p>P也可以理解为控制go代码的并行度的机制,<br />
如果P的数量等于1, 代表当前最多只能有一个线程(M)执行go代码,<br />
如果P的数量等于2, 代表当前最多只能有两个线程(M)执行go代码.<br />
执行原生代码的线程数量不受P控制。</p><br />
<br />
<p>因为同一时间只有一个线程(M)可以拥有P， P中的数据都是锁自由(lock free)的, 读写这些数据的效率会非常的高。</p><br />
<br />
<p>P是使G能够在M中运行的关键。Go运行时系统适当地让P与不同的M建立或者断开联系，以使得P中的那些可运行的G能够在需要的时候及时获得运行时机。</p><br />
<br />
<p>P的结构体定义：(在 ./src/runtime/runtime2.go 文件中)</p><br />
<br />
<p>type p struct {<br />
	lock mutex</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id          int32<br />
status      uint32 // one of pidle/prunning/...<br />
link        puintptr<br />
schedtick   uint32     // incremented on every scheduler call<br />
syscalltick uint32     // incremented on every system call<br />
sysmontick  sysmontick // last tick observed by sysmon<br />
m           muintptr   // back-link to associated m (nil if idle)<br />
mcache      *mcache<br />
racectx     uintptr<br />
 <br />
deferpool    [5][]*_defer // pool of available defer structs of different sizes (see panic.go)<br />
deferpoolbuf [5][32]*_defer<br />
 <br />
// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.<br />
goidcache    uint64<br />
goidcacheend uint64<br />
 <br />
// Queue of runnable goroutines. Accessed without lock.<br />
runqhead uint32<br />
runqtail uint32<br />
runq     [256]guintptr<br />
// runnext, if non-nil, is a runnable G that was ready'd by<br />
// the current G and should be run next instead of what's in<br />
// runq if there's time remaining in the running G's time<br />
// slice. It will inherit the time left in the current time<br />
// slice. If a set of goroutines is locked in a<br />
// communicate-and-wait pattern, this schedules that set as a<br />
// unit and eliminates the (potentially large) scheduling<br />
// latency that otherwise arises from adding the ready'd<br />
// goroutines to the end of the run queue.<br />
runnext guintptr<br />
 <br />
// Available G's (status == Gdead)<br />
gfree    *g<br />
gfreecnt int32<br />
 <br />
sudogcache []*sudog<br />
sudogbuf   [128]*sudog<br />
 <br />
tracebuf traceBufPtr<br />
 <br />
// traceSweep indicates the sweep events should be traced.<br />
// This is used to defer the sweep start event until a span<br />
// has actually been swept.<br />
traceSweep bool<br />
// traceSwept and traceReclaimed track the number of bytes<br />
// swept and reclaimed by sweeping in the current sweep loop.<br />
traceSwept, traceReclaimed uintptr<br />
 <br />
palloc persistentAlloc // per-P to avoid mutex<br />
 <br />
// Per-P GC state<br />
gcAssistTime     int64 // Nanoseconds in assistAlloc<br />
gcBgMarkWorker   guintptr<br />
gcMarkWorkerMode gcMarkWorkerMode<br />
 <br />
// gcw is this P's GC work buffer cache. The work buffer is<br />
// filled by write barriers, drained by mutator assists, and<br />
// disposed on certain GC state transitions.<br />
gcw gcWork<br />
 <br />
runSafePointFn uint32 // if 1, run sched.safePointFn at next safe point<br />
 <br />
pad [sys.CacheLineSize]byte } 通过runtime.GOMAXPROCS函数我们可以改变单个Go程序可以间拥有的P的最大数量。<br />
</code></pre></div></div><br />
<br />
<p>P的最大数量相当于是对可以被并发执行的用户级的G的数量作出限制。</p><br />
<br />
<p>每一个P都必须关联一个M才能使其中的G得以运行。<br />
【注意】：运行时系统会将M与关联的P分离开来。但是如果该P的可运行队列中还有未运行的G，那么运行时系统就会找到一个空的M （在调度器的空闲队列中的M） 或者创建一个空的M，并与该P关联起来（为了运行G而做准备）。</p><br />
<br />
<p>runtime.GOMAXPROCS函数设置的只会影响P的数量，但是对M （内核线程）的数量不会影响，所以runtime.GOMAXPROCS 并不是控制线程数，只能说是影响上下文环境P的数目。</p><br />
<br />
<p>在Go程序开始运行时，会先由引导程序对M做了数量上的限制，及对P做了限制，P的数量默认为1。所以我们无论在程序中使用go关键字启用多少goroutine，它们都会被塞到一个P的可运行G队列中。</p><br />
<br />
<p>在确认P的最大数量后，运行时系统会根据这个数值初始化全局的P列表 【runtime.allp】，类似全局M列表，其中包含了所有 运行时系统创建的所有P。随后，运行时系统会把调度器的可运行G队列【runtime.sched.runq】中的所有G均匀的放入全局的P列表中的各个P的可执行G队列当中。到这里为止，运行时系统需要用到的所有P都准备就绪了。</p><br />
<br />
<p>类似M的空闲列表，调度器也存在一个P的空闲列表【runtime.sched.pidle】，当一个P不再与任何M关联的时候，运行时系统就会把该P放入这个列表中，而一个空闲的P关联了某个M之后会被从这个列表中取出【注意：就算一个P加入了空闲队列，但是它的可运行G队列不一定为空】</p><br />
<br />
<p>和M不同P是有状态的：（五种）</p><br />
<br />
<p>Pidle：当前P未和任何M关联</p><br />
<br />
<p>Prunning：当前P正在和某个M关联</p><br />
<br />
<p>Psyscall：当前P中的被运行的那个G正在进行系统调用</p><br />
<br />
<p>Pgcstop：运行时系统正在进行gc。（运行时系统在gc时会试图把全局P列表中的P都处于此状态）</p><br />
<br />
<p>Pdead：当前P已经不再被使用。（在调用runtime.GOMAXPROCS减少P的数量时，多余的P就处于此状态）</p><br />
<br />
<p>P的初始状态就是为Pgcstop，处于这个状态很短暂，在初始化和填充P中的G队列之后，运行时系统会将其状态置为Pidle并放入调度器的空闲P列表 （runtime.sched.pidle）中。其中的P会由调度器根据实际情况进行取用。下图是P在各个状态建的流转情况：</p><br />
<br />
<p>从上图，我们可以看出，除了Pdead之外的其他状态的P都会在运行时系统欲进行GC是被指为Pgcstop。在gc结束后状态不会回复到之前的状态的，而是都统一直接转到了Pidle 【这意味着，他们都需要被重新调度】。【注意】：除了Pgcstop 状态的P，其他状态的P都会在 调用runtime.GOMAXPROCS 函数去减少P数目时，被认为是多余的P而状态转为Pdead，这时候其带的可运行G的队列中的G都会被转移到 调度器的可运行G队列中，它的自由G队列 【gfree】也是一样被移到调度器的自由列表 【runtime.sched.gfree】中。</p><br />
<br />
<p>【注意】：每个P中都有一个可运行G队列及自由G队列。自由G队列包含了很多已经完成的G，随着被运行完成的G的积攒到一定程度后，运行时系统会把其中的部分G转移的调度器的自由G队列 【runtime.sched.gfree】中。</p><br />
<br />
<p>【注意】：当我们每次用 go关键字 启用一个G的时候，运行时系统都会先从P的自由G队列获取一个G来封装我们提供的函数 (go 关键字后面的函数) ，如果发现P中的自由G过少时，会从调度器的自由G队列中移一些G过来，只有连调度器的自由G列表都弹尽粮绝的时候，才会去创建新的G。</p><br />
<br />
<p>G (goroutine)：<br />
G是goroutine的头文字, goroutine可以解释为受管理的轻量线程, goroutine使用go关键词创建。</p><br />
<br />
<p>举例来说,  func main() { go other() },  这段代码创建了两个goroutine。<br />
一个是main, 另一个是other, 【注意】：main本身也是一个goroutine。</p><br />
<br />
<p>goroutine的新建, 休眠, 恢复, 停止都受到go运行时的管理。<br />
goroutine执行异步操作时会进入休眠状态, 待操作完成后再恢复, 无需占用系统线程。<br />
goroutine新建或恢复时会添加到运行队列, 等待M取出并运行。</p><br />
<br />
<p>G的结构体定义：(在 ./src/runtime/runtime2.go 文件中)</p><br />
<br />
<p>type g struct {<br />
	// Stack parameters.<br />
	// stack describes the actual stack memory: [stack.lo, stack.hi).<br />
	// stackguard0 is the stack pointer compared in the Go stack growth prologue.<br />
	// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.<br />
	// stackguard1 is the stack pointer compared in the C stack growth prologue.<br />
	// It is stack.lo+StackGuard on g0 and gsignal stacks.<br />
	// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).<br />
	stack       stack   // offset known to runtime/cgo   描述了真实的栈内存，包括上下界<br />
	stackguard0 uintptr // offset known to liblink<br />
	stackguard1 uintptr // offset known to liblink</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_panic         *_panic // innermost panic - offset known to liblink<br />
_defer         *_defer // innermost defer<br />
m              *m      // current m; offset known to arm liblink   当前运行G的M<br />
sched          gobuf    //  goroutine切换时，用于保存g的上下文<br />
syscallsp      uintptr        // if status==Gsyscall, syscallsp = sched.sp to use during gc<br />
syscallpc      uintptr        // if status==Gsyscall, syscallpc = sched.pc to use during gc<br />
stktopsp       uintptr        // expected sp at top of stack, to check in traceback<br />
param          unsafe.Pointer // passed parameter on wakeup   用于传递参数，睡眠时其他goroutine可以设置param，唤醒时该goroutine可以获取<br />
atomicstatus   uint32<br />
stackLock      uint32 // sigprof/scang lock; TODO: fold in to atomicstatus<br />
goid           int64    // goroutine的ID<br />
waitsince      int64  // approx time when the g become blocked   g被阻塞的大体时间<br />
waitreason     string // if status==Gwaiting<br />
schedlink      guintptr<br />
preempt        bool     // preemption signal, duplicates stackguard0 = stackpreempt<br />
paniconfault   bool     // panic (instead of crash) on unexpected fault address<br />
preemptscan    bool     // preempted g does scan for gc<br />
gcscandone     bool     // g has scanned stack; protected by _Gscan bit in status<br />
gcscanvalid    bool     // false at start of gc cycle, true if G has not run since last scan; TODO: remove?<br />
throwsplit     bool     // must not split stack<br />
raceignore     int8     // ignore race detection events<br />
sysblocktraced bool     // StartTrace has emitted EvGoInSyscall about this goroutine<br />
sysexitticks   int64    // cputicks when syscall has returned (for tracing)<br />
traceseq       uint64   // trace event sequencer<br />
tracelastp     puintptr // last P emitted an event for this goroutine<br />
lockedm        *m       // G被锁定只在这个m上运行<br />
sig            uint32<br />
writebuf       []byte<br />
sigcode0       uintptr<br />
sigcode1       uintptr<br />
sigpc          uintptr<br />
gopc           uintptr // pc of go statement that created this goroutine<br />
startpc        uintptr // pc of goroutine function<br />
racectx        uintptr<br />
waiting        *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order<br />
cgoCtxt        []uintptr      // cgo traceback context<br />
labels         unsafe.Pointer // profiler labels<br />
timer          *timer         // cached timer for time.Sleep<br />
 <br />
// Per-G GC state<br />
 <br />
// gcAssistBytes is this G's GC assist credit in terms of<br />
// bytes allocated. If this is positive, then the G has credit<br />
// to allocate gcAssistBytes bytes without assisting. If this<br />
// is negative, then the G must correct this by performing<br />
// scan work. We track this in bytes to make it fast to update<br />
// and check for debt in the malloc hot path. The assist ratio<br />
// determines how this corresponds to scan work debt.<br />
gcAssistBytes int64 }<br />
</code></pre></div></div><br />
<br />
<p>// 用于保存G切换时上下文的缓存结构体<br />
type gobuf struct {<br />
	// The offsets of sp, pc, and g are known to (hard-coded in) libmach.<br />
	//<br />
	// ctxt is unusual with respect to GC: it may be a<br />
	// heap-allocated funcval so write require a write barrier,<br />
	// but gobuf needs to be cleared from assembly. We take<br />
	// advantage of the fact that the only path that uses a<br />
	// non-nil ctxt is morestack. As a result, gogo is the only<br />
	// place where it may not already be nil, so gogo uses an<br />
	// explicit write barrier. Everywhere else that resets the<br />
	// gobuf asserts that ctxt is already nil.<br />
	sp   uintptr     // 当前的栈指针<br />
	pc   uintptr     // 计数器<br />
	g    guintptr    // g自身<br />
	ctxt unsafe.Pointer // this has to be a pointer so that gc scans it<br />
	ret  sys.Uintreg<br />
	lr   uintptr<br />
	bp   uintptr // for GOEXPERIMENT=framepointer<br />
}<br />
下面我们来讲讲G。Go语言的编译器会把我们编写的go语句编程一个运行时系统的函数调用，并把go语句中那个函数及其参数都作为参数传递给这个运行时系统函数中。</p><br />
<br />
<p>运行时系统在接到这样一个调用后，会先检查一下go函数及其参数的合法性，紧接着会试图从本地P的自由G队列中(或者调度器的自由G队列)中获取一个可用的自由G （P中有讲述了），如果没有则新创建一个G。类似M和P，G在运行时系统中也有全局的G列表【runtime.allg】，那些新建的G会先放到这个全局的G列表中，其列表的作用也是集中放置了当前运行时系统中给所有的G的指针。在用自由G封装go的函数时，运行时系统都会对这个G做一次初始化。</p><br />
<br />
<p>初始化：包含了被关联的go关键字后的函数及当前G的状态机G的ID等等。在G被初始化完成后就会被放置到当前本地的P的可运行队列中。只要时机成熟，调度器会立即尽心这个G的调度运行。</p><br />
<br />
<p>G的各种状态：</p><br />
<br />
<p>Gidle：G被创建但还未完全被初始化。</p><br />
<br />
<p>Grunnable：当前G为可运行的，正在等待被运行。</p><br />
<br />
<p>Grunning：当前G正在被运行。</p><br />
<br />
<p>Gsyscall：当前G正在被系统调用</p><br />
<br />
<p>Gwaiting：当前G正在因某个原因而等待</p><br />
<br />
<p>Gdead：当前G完成了运行</p><br />
<br />
<p>正在被初始化进行中的G是处于Grunnable状态的。一个G真正被使用是在状态为Grunnable之后。G的生命周期及状态变化如图：</p><br />
<br />
<p>图上有一步是事件到来，那么G在运行过程中，是否等待某个事件以及等待什么样的事件？完全由起封装的go关键字后的函数决定。（如：等待chan中的值、涉及网络I/O、time.Timer、time.Sleep等等事件）</p><br />
<br />
<p>G退出系统调用，及其复杂：运行时系统先会尝试直接运行当前G，仅当无法被运行时才会转成Grunnable并放置入调度器的自由G列表中。</p><br />
<br />
<p>最后，已经是Gdead状态的G是可以被重新初始化并使用的。而对比进入Pdead状态的P等待的命运只有被销毁。处于Gdead的G会被放置到本地P或者调度器的自由G列表中。</p><br />
<br />
<p>至此，G、M、P的初步描述已经完毕，下面我们来看一看一些核心的队列：</p><br />
<br />
<p>G、M、P的容器<br />
中文名	源码的名称	作用域	简要说明<br />
全局M列表	runtime.allm	运行时系统	存放所有M<br />
全局P列表	runtime.allp	运行时系统	存放所有P<br />
全局G列表	runtime.allg	运行时系统	存放所有G<br />
调度器中的空闲M列表	runtime.sched.midle	调度器	存放空闲M<br />
调度器中的空闲P列表	runtime.sched.pidle	调度器	存放空闲P<br />
调度器中的可运行G队列	runtime.sched.runq	调度器	存放可运行G<br />
调度器中那个的自由G列表	runtime.sched.gfree	调度器	存放自由G<br />
P的可运行G队列	runq	本地P	存放当前P中的可运行G<br />
P中的自由G列表	gfree	本地P	存放当前P中的自由G<br />
 三个全局的列表主要为了统计运行时系统的的所有G、M、P。我们主要关心剩下的这些容器，尤其是和G相关的四个。<br />
在运行时系统创建的G都会被保存在全局的G列表中，值得注意的是：从Gsyscall转出来的G，都会被放置到调度器的可运行G队列中。而被运行时系统初始化的G会被放置到本地P的可运行列表中。从Gwaiting转出来的G，除了因网络I/O陷入等待的G之外，都会被放置到本地P的可运行G队列中。转成Gdead状态的G会先被放置到本地P的自由G列表 （上面的描述可以知道这一点）。调度器中的与G、M、P相关的列表其实只是起了一个暂存的作用。</p><br />
<br />
<p>一句话概括三者关系：</p><br />
<br />
<p>G需要绑定在M上才能运行；<br />
M需要绑定P才能运行；<br />
下面我们看一看三者及内核调度实体【KSE】的关系：</p><br />
<br />
<p> </p><br />
<br />
<p>综上所述，一个G的执行需要M和P的支持。一个M在于一个P关联之后就形成一个有效的G运行环境 【内核线程 +  上下文环境】。每个P都含有一个 可运行G的队列【runq】。队列中的G会被一次传递给本地P关联的M并且获得运行时机。</p><br />
<br />
<p>由上图可以看出 M 与 KSE 总是 一对一 的。一个M能且仅能代表一个内核线程。</p><br />
<br />
<p>一个M的生命周期内，它会且仅会与一个KSE产生关联。M与P以及P与G之间的关联是多变的，总是会随着实际调度的过程而改变。其中， M 与 P 总是一对一，P 与 G 总是 一对多， 而 一个 G 最终由 一个 M 来负责运行。</p><br />
<br />
<p>上述我们讲的运行时系统其实就是我们下面要说的调度器。<br />
我们再来回顾下G、M、P 中的主要成员：</p><br />
<br />
<p>G里面比较重要的成员：<br />
stack: 当前g使用的栈空间, 有lo和hi两个成员<br />
stackguard0: 检查栈空间是否足够的值, 低于这个值会扩张栈, 0是go代码使用的<br />
stackguard1: 检查栈空间是否足够的值, 低于这个值会扩张栈, 1是原生代码使用的<br />
m: 当前g对应的m<br />
sched: g的调度数据, 当g中断时会保存当前的pc和rsp等值到这里, 恢复运行时会使用这里的值<br />
atomicstatus: g的当前状态<br />
schedlink: 下一个g, 当g在链表结构中会使用<br />
preempt: g是否被抢占中<br />
lockedm: g是否要求要回到这个M执行, 有的时候g中断了恢复会要求使用原来的M执行<br />
M里面比较重要的成员：<br />
g0: 用于调度的特殊g, 调度和执行系统调用时会切换到这个g<br />
curg: 当前运行的g<br />
p: 当前拥有的P<br />
nextp: 唤醒M时, M会拥有这个P<br />
park: M休眠时使用的信号量, 唤醒M时会通过它唤醒<br />
schedlink: 下一个m, 当m在链表结构中会使用<br />
mcache: 分配内存时使用的本地分配器, 和p.mcache一样(拥有P时会复制过来)<br />
lockedg: lockedm的对应值<br />
P里面比较重要的成员：<br />
status: p的当前状态<br />
link: 下一个p, 当p在链表结构中会使用<br />
m: 拥有这个P的M<br />
mcache: 分配内存时使用的本地分配器<br />
runqhead: 本地运行队列的出队序号<br />
runqtail: 本地运行队列的入队序号<br />
runq: 本地运行队列的数组, 可以保存256个G<br />
gfree: G的自由列表, 保存变为_Gdead后可以复用的G实例<br />
gcBgMarkWorker: 后台GC的worker函数, 如果它存在M会优先执行它<br />
gcw: GC的本地工作队列, 详细将在下一篇(GC篇)分析<br />
调度器涉及到的结构体除了上面的G、M、P 之外，还有以下，比如全局的调度器：</p><br />
<br />
<p>type schedt struct {<br />
	// accessed atomically. keep at top to ensure alignment on 32-bit systems.<br />
     // 下面两个变量需以原子访问访问。保持在 struct 顶部，确保其在 32 位系统上可以对齐<br />
	goidgen  uint64<br />
	lastpoll uint64</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lock mutex<br />
<br />
// 当修改 nmidle，nmidlelocked，nmsys，nmfreed 这些数值时<br />
// 需要记得调用 checkdead<br />
 <br />
midle        muintptr // idle m's waiting for work   空闲的M 队列。<br />
nmidle       int32    // number of idle m's waiting for work  当前等待工作的空闲 m 计数<br />
nmidlelocked int32    // number of locked m's waiting for work  当前等待工作的被 lock 的 m 计数<br />
mcount       int32    // number of m's that have been created  已经创建的 m 数量<br />
maxmcount    int32    // maximum number of m's allowed (or die)   允许创建的最大的 m 数量<br />
 <br />
ngsys uint32 // number of system goroutines; updated atomically  系统 goroutine 的数量， 原子操作<br />
 <br />
pidle      puintptr // idle p's   空闲的 p 队列<br />
npidle     uint32<br />
nmspinning uint32 // See "Worker thread parking/unparking" comment in proc.go.<br />
 <br />
// Global runnable queue.<br />
 // 全局的可运行 g 队列<br />
runqhead guintptr       // 队头地址<br />
runqtail guintptr       // 队尾地址 <br />
runqsize int32          // 队列宽度  <br />
 <br />
// Global cache of dead G's.<br />
// dead G 的全局缓<br />
gflock       mutex<br />
gfreeStack   *g        // 栈中自由g ？<br />
gfreeNoStack *g        // 堆中自由g ？   <br />
ngfree       int32<br />
 <br />
// Central cache of sudog structs.<br />
// sudog 结构的集中缓存<br />
sudoglock  mutex<br />
sudogcache *sudog<br />
 <br />
// Central pool of available defer structs of different sizes.<br />
// 不同大小的可用的 defer struct 的集中缓存池<br />
deferlock mutex<br />
deferpool [5]*_defer<br />
 <br />
gcwaiting  uint32 // gc is waiting to run  gc 等待运行状态。 作为gc任务被执行期间的辅助标记、停止计数和通知机制<br />
stopwait   int32<br />
stopnote   note<br />
sysmonwait uint32  // 作为 系统检测任务被执行期间的停止计数和通知机制<br />
sysmonnote note<br />
 <br />
// safepointFn should be called on each P at the next GC<br />
// safepoint if p.runSafePointFn is set.<br />
// 应在下一个GC上的每个P上调用safepointFn<br />
// 如果设置了p.runSafePointFn，则为safepoint。<br />
safePointFn   func(*p)<br />
safePointWait int32<br />
safePointNote note<br />
 <br />
profilehz int32 // cpu profiling rate   CPU分析率<br />
 <br />
procresizetime int64 // nanotime() of last change to gomaxprocs   上次修改 gomaxprocs 的纳秒时间<br />
totaltime      int64 // ∫gomaxprocs dt up to procresizetime } 全局调度器，全局只有一个schedt类型的实例。<br />
</code></pre></div></div><br />
<br />
<p>sudoG 结构体：</p><br />
<br />
<p>// sudog 代表在等待列表里的 g，比如向 channel 发送/接收内容时<br />
// 之所以需要 sudog 是因为 g 和同步对象之间的关系是多对多的<br />
// 一个 g 可能会在多个等待队列中，所以一个 g 可能被打包为多个 sudog<br />
// 多个 g 也可以等待在同一个同步对象上<br />
// 因此对于一个同步对象就会有很多 sudog 了<br />
// sudog 是从一个特殊的池中进行分配的。用 acquireSudog 和 releaseSudog 来分配和释放 sudog</p><br />
<br />
<p>type sudog struct {<br />
	// The following fields are protected by the hchan.lock of the<br />
	// channel this sudog is blocking on. shrinkstack depends on<br />
	// this for sudogs involved in channel ops.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g          *g<br />
selectdone *uint32 // CAS to 1 to win select race (may point to stack)<br />
next       *sudog<br />
prev       *sudog<br />
elem       unsafe.Pointer // data element (may point to stack)<br />
 <br />
// The following fields are never accessed concurrently.<br />
// For channels, waitlink is only accessed by g.<br />
// For semaphores, all fields (including the ones above)<br />
// are only accessed when holding a semaRoot lock.<br />
 <br />
acquiretime int64<br />
releasetime int64<br />
ticket      uint32<br />
parent      *sudog // semaRoot binary tree<br />
waitlink    *sudog // g.waiting list or semaRoot<br />
waittail    *sudog // semaRoot<br />
c           *hchan // channel }  <br />
</code></pre></div></div><br />
<br />
<p>那么goroutine的入口是怎么样的呢？首先，我们从goroutine是如何被创建的说起，创建goroutine的函数为：newproc 函数 (在 ./src/runtime/proc.go 文件中)，即：使用go命令创建goroutine时, go会把go命令编译为对runtime.newproc的调用。</p><br />
<br />
<p>// Create a new g running fn with siz bytes of arguments.<br />
// Put it on the queue of g’s waiting to run.<br />
// The compiler turns a go statement into a call to this.<br />
// Cannot split the stack because it assumes that the arguments<br />
// are available sequentially after &amp;fn; they would not be<br />
// copied if a stack split occurred.</p><br />
<br />
<p>// 根据 参数 fn 和 siz 创建一个 g<br />
// 并把它放置入 自由g队列中等待唤醒<br />
// 编译器翻译一个 go 表达式时会调用这个函数<br />
// 无法拆分堆栈，因为它假设参数在 &amp;fn 之后顺序可用; 如果发生堆栈拆分，则不会复制它们。</p><br />
<br />
<p>//    新建一个goroutine，<br />
//    用fn + PtrSize 获取第一个参数的地址，也就是argp<br />
//    用siz - 8 获取pc地址</p><br />
<br />
<p>//go:nosplit<br />
func newproc(siz int32, fn *funcval) {<br />
    // add 是一个指针运算，跳过函数指针<br />
    // 把栈上的参数起始地址找到<br />
	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// getcallerpc返回的是 调用函数之后的那条程序指令的地址，<br />
// 即callee函数返回时要执行的下一条指令的地址<br />
pc := getcallerpc(unsafe.Pointer(&amp;siz))<br />
<br />
// 用g0的栈创建G对象<br />
systemstack(func() {<br />
	newproc1(fn, (*uint8)(argp), siz, 0, pc)<br />
}) }<br />
</code></pre></div></div><br />
<br />
<p>// 结构体 funcval<br />
// funcval 是一个变长结构，第一个成员是函数指针<br />
// 所以上面的 add 是跳过这个 fn<br />
type funcval struct {<br />
	fn uintptr<br />
	// variable-size, fn-specific data here   这里的可变大小，特定于fn的数据<br />
}<br />
runtime.newproc函数中只做了三件事：</p><br />
<br />
<p>计算额外参数的地址 argp<br />
获取调用端的地址(返回地址) pc<br />
使用systemstack调用 newproc1 函数<br />
systemstack 会切换当前的 g 到 g0, 并且使用g0的栈空间, 然后调用传入的函数, 再切换回原来的g和原来的栈空间。<br />
切换到g0后会假装返回地址是mstart, 这样traceback的时候可以在mstart停止。<br />
这里传给systemstack的是一个闭包, 调用时会把闭包的地址放到寄存器rdx, 具体可以参考上面对闭包的分析。</p><br />
<br />
<p>下面我们在主要来看看  newproc1 函数做了什么：</p><br />
<br />
<p>// Create a new g running fn with narg bytes of arguments starting<br />
// at argp and returning nret bytes of results.  callerpc is the<br />
// address of the go statement that created this. The new g is put<br />
// on the queue of g’s waiting to run.</p><br />
<br />
<p>// 根据函数参数和函数地址，创建一个新的G，然后将这个G加入队列等待运行<br />
func newproc1(fn *funcval, argp *uint8, narg int32, nret int32, callerpc uintptr) *g {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 先获取 当前 g，其实这里获取到的是 g0<br />
_g_ := getg()<br />
<br />
// 判断下 func 的实现是否为空<br />
if fn == nil {<br />
	_g_.m.throwing = -1 // do not dump full stacks<br />
	throw("go of nil func value")<br />
}<br />
<br />
// 设置g对应的m的locks++, 禁止抢占<br />
_g_.m.locks++ // disable preemption because it can be holding p in a local var   禁用抢占，因为它可以在本地var中保存p<br />
siz := narg + nret<br />
siz = (siz + 7) &amp;^ 7<br />
 <br />
// We could allocate a larger initial stack if necessary.<br />
// Not worth it: this is almost always an error.<br />
// 4*sizeof(uintreg): extra space added below<br />
// sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall).<br />
if siz &gt;= _StackMin-4*sys.RegSize-sys.RegSize {<br />
	throw("newproc: function arguments too large for new goroutine")<br />
}<br />
 <br />
_p_ := _g_.m.p.ptr()<br />
newg := gfget(_p_)<br />
if newg == nil {<br />
	newg = malg(_StackMin)<br />
	casgstatus(newg, _Gidle, _Gdead)<br />
	allgadd(newg) // publishes with a g-&gt;status of Gdead so GC scanner doesn't look at uninitialized stack.<br />
}<br />
if newg.stack.hi == 0 {<br />
	throw("newproc1: newg missing stack")<br />
}<br />
 <br />
if readgstatus(newg) != _Gdead {<br />
	throw("newproc1: new g is not Gdead")<br />
}<br />
 <br />
totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame<br />
totalSize += -totalSize &amp; (sys.SpAlign - 1)                  // align to spAlign<br />
sp := newg.stack.hi - totalSize<br />
spArg := sp<br />
if usesLR {<br />
	// caller's LR<br />
	*(*uintptr)(unsafe.Pointer(sp)) = 0<br />
	prepGoExitFrame(sp)<br />
	spArg += sys.MinFrameSize<br />
}<br />
if narg &gt; 0 {<br />
	memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg))<br />
	// This is a stack-to-stack copy. If write barriers<br />
	// are enabled and the source stack is grey (the<br />
	// destination is always black), then perform a<br />
	// barrier copy. We do this *after* the memmove<br />
	// because the destination stack may have garbage on<br />
	// it.<br />
	if writeBarrier.needed &amp;&amp; !_g_.m.curg.gcscandone {<br />
		f := findfunc(fn.fn)<br />
		stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))<br />
		// We're in the prologue, so it's always stack map index 0.<br />
		bv := stackmapdata(stkmap, 0)<br />
		bulkBarrierBitmap(spArg, spArg, uintptr(narg), 0, bv.bytedata)<br />
	}<br />
}<br />
 <br />
memclrNoHeapPointers(unsafe.Pointer(&amp;newg.sched), unsafe.Sizeof(newg.sched))<br />
newg.sched.sp = sp<br />
newg.stktopsp = sp<br />
newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function<br />
newg.sched.g = guintptr(unsafe.Pointer(newg))<br />
gostartcallfn(&amp;newg.sched, fn)<br />
newg.gopc = callerpc<br />
newg.startpc = fn.fn<br />
if _g_.m.curg != nil {<br />
	newg.labels = _g_.m.curg.labels<br />
}<br />
if isSystemGoroutine(newg) {<br />
	atomic.Xadd(&amp;sched.ngsys, +1)<br />
}<br />
newg.gcscanvalid = false<br />
casgstatus(newg, _Gdead, _Grunnable)<br />
 <br />
if _p_.goidcache == _p_.goidcacheend {<br />
	// Sched.goidgen is the last allocated id,<br />
	// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].<br />
	// At startup sched.goidgen=0, so main goroutine receives goid=1.<br />
	_p_.goidcache = atomic.Xadd64(&amp;sched.goidgen, _GoidCacheBatch)<br />
	_p_.goidcache -= _GoidCacheBatch - 1<br />
	_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch<br />
}<br />
newg.goid = int64(_p_.goidcache)<br />
_p_.goidcache++<br />
if raceenabled {<br />
	newg.racectx = racegostart(callerpc)<br />
}<br />
if trace.enabled {<br />
	traceGoCreate(newg, newg.startpc)<br />
}<br />
runqput(_p_, newg, true)<br />
 <br />
if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 &amp;&amp; mainStarted {<br />
	wakep()<br />
}<br />
_g_.m.locks--<br />
if _g_.m.locks == 0 &amp;&amp; _g_.preempt { // restore the preemption request in case we've cleared it in newstack<br />
	_g_.stackguard0 = stackPreempt<br />
}<br />
return newg } 先大致看下newproc1 函数逻辑流程：<br />
</code></pre></div></div><br />
<br />
<p>newproc1 –&gt; newg<br />
newg[gfget] –&gt; nil{is nil?}<br />
nil –&gt;|yes|E[init stack]<br />
nil –&gt;|no|C[malg]<br />
C –&gt; D[set g status=&gt; idle-&gt;dead]<br />
D –&gt; allgadd<br />
E –&gt; G[set g status=&gt; dead-&gt; runnable]<br />
allgadd –&gt; G<br />
G –&gt; runqput<br />
runtime.newproc1的处理如下:</p><br />
<br />
<p>调用getg获取当前的g, 会编译为读取FS寄存器(TLS), 这里会获取到g0<br />
设置g对应的m的locks++, 禁止抢占<br />
获取m拥有的p<br />
新建一个g<br />
首先调用gfget从p.gfree获取g, 如果之前有g被回收在这里就可以复用<br />
获取不到时调用malg分配一个g, 初始的栈空间大小是2K<br />
需要先设置g的状态为已中止(_Gdead), 这样gc不会去扫描这个g的未初始化的栈<br />
把参数复制到g的栈上<br />
把返回地址复制到g的栈上, 这里的返回地址是goexit, 表示调用完目标函数后会调用goexit<br />
设置g的调度数据(sched)<br />
设置sched.sp等于参数+返回地址后的rsp地址<br />
设置sched.pc等于目标函数的地址, 查看gostartcallfn和gostartcall<br />
设置sched.g等于g<br />
设置g的状态为待运行(_Grunnable)<br />
调用runqput把g放到运行队列<br />
首先随机把g放到p.runnext, 如果放到runnext则入队原来在runnext的g<br />
然后尝试把g放到P的”本地运行队列”<br />
如果本地运行队列满了则调用runqputslow把g放到”全局运行队列”<br />
runqputslow会把本地运行队列中一半的g放到全局运行队列, 这样下次就可以继续用快速的本地运行队列了<br />
如果当前有空闲的P, 但是无自旋的M(nmspinning等于0), 并且主函数已执行则唤醒或新建一个M<br />
这一步非常重要, 用于保证当前有足够的M运行G, 具体请查看上面的”空闲M链表”<br />
唤醒或新建一个M会通过wakep函数<br />
首先交换nmspinning到1, 成功再继续, 多个线程同时执行wakep只有一个会继续<br />
调用startm函数<br />
调用pidleget从”空闲P链表”获取一个空闲的P<br />
调用mget从”空闲M链表”获取一个空闲的M<br />
如果没有空闲的M, 则调用newm新建一个M<br />
newm会新建一个m的实例, m的实例包含一个g0, 然后调用newosproc动一个系统线程<br />
newosproc会调用syscall clone创建一个新的线程<br />
线程创建后会设置TLS, 设置TLS中当前的g为g0, 然后执行mstart<br />
调用notewakeup(&amp;mp.park)唤醒线程</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>