<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">gomacro</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-09-27T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Sep 27, 2019</time></p>
					</div>
					 <p>https://github.com/micro/go-micro<br />
https://www.kancloud.cn/linimbus/go-micro/529018<br />
go-micro是基于Go语言实现的插件化RPC微服务框架，与go-kit，kite等微服务框架相比，它具有易上手、部署简单、工具插件化等优点。</p><br />
<br />
<p>go-micro框架提供了服务发现、负载均衡、同步传输、异步通信以及事件驱动等机制，它尝试去简化分布式系统间的通信，让我们可以专注于自身业务逻辑的开发。所以对于新手而言，go-micro是个不错的微服务实践的开始。<br />
<!-- more --><br />
go-micro是组件化的框架，每一个基础功能都是一个interface，方便扩展。同时，组件又是分层的，上层基于下层功能向上提供服务，整体构成go-micro框架。<br />
go-micro的组件包括：</p><br />
<br />
<p>Registry组件：服务发现组件，提供服务发现机制：解析服务名字至服务地址。目前支持的注册中心有consul、etcd、 zookeeper、dns、gossip等<br />
Selector组件：构建在Registry之上的客户端智能负载均衡组件，用于Client组件对Registry返回的服务进行智能选择。<br />
Broker组件：发布/订阅组件，服务之间基于消息中间件的异步通信方式，默认使用http方式，线上通常使用消息中间件，如Kafka、RabbitMQ等。<br />
Transport组件：服务之间同步通信方式。<br />
Codec组件：服务之间消息的编码/解码。<br />
Server组件：服务主体，该组件基于上面的Registry/Selector/Transport/Broker组件，对外提供一个统一的服务请求入口。<br />
Client组件：提供访问微服务的客户端。类似Server组件，它也是通过Registry/Selector/Transport/Broker组件实现查找服务、负载均衡、同步通信、异步消息等功能。<br />
所有以上组件功能共同构成一个go-micro微服务。</p><br />
<br />
<p>client与server之间我们使用点对点的同步方式（Transport），即无需消息中间件（Broker），注册中心采用consul系统。</p><br />
<br />
<p>3.1 安装consul - 注册中心<br />
服务注册中心我们选择consul：</p><br />
<br />
<p>mac：brew install consul<br />
windows：直接官网下载consul.exe可执行程序<br />
运行consul：启动Consul agent的开发模式：</p><br />
<br />
<p>consul agent -dev</p><br />
<br />
<p>该命令快速启动一个单节点的consul，且为集群的领袖</p><br />
<br />
<p>查看Consul集群的成员：打开另一个终端执行：</p><br />
<br />
<p>consul members</p><br />
<br />
<p>停止Agent：使用 Ctrl-C，优雅的关闭Agent</p><br />
<br />
<p>也可以通过WebUI来查看各service状态：http://localhost:8500/</p><br />
<br />
<p>3.2 安装micro：微服务管理工具<br />
micro是以go-micro框架为核心的微服务管理工具，通过它可以方便查看go-micro服务情况。</p><br />
<br />
<p>在$GOPATH目录下，执行go get github.com/micro/micro，该命令会在bin目录（$GOBIN）下生成micro(.exe)工具<br />
micro命令行工具可以提供诸如服务列表查看、服务详情查看、调用服务接口等功能。</p><br />
<br />
<p>3.3 安装goprotobuf相关工具：GRPC相关工具<br />
protoc：Protobuf（Protocol Buffers - Google’s data interchange format）编译器：</p><br />
<br />
<p>windows下直接下载 相关win的zip压缩文件（内含protoc.exe）<br />
mac： brew install protobuf<br />
protoc-gen-go：goprotobuf 提供的 Protobuf 插件：在$GOPATH目录下执行go get github.com/micro/protobuf/{proto,protoc-gen-go}，该命令会在bin目录下生成protoc-gen-go(.exe)工具，protoc编译器利用protoc-gen-go插件将.proto文件转换为Golang源文件<br />
protoc-gen-micro（Protobuf code generation for micro）：在$GOPATH目录下执行go get github.com/micro/protoc-gen-micro，该命令会在bin目录下生成protoc-gen-micro(.exe)，protoc编译器利用protoc-gen-micro插件将.proto文件转换为micro代码风格文件<br />
goprotobuf编译参数：</p><br />
<br />
<p>-I参数：指定import路径，可以指定多个-I参数，编译时按照顺序查找，不指定时默认查找当前目录<br />
–go_out：Golang编译支持，支持以下参数</p><br />
<br />
<ul><br />
  <li><code class="language-plaintext highlighter-rouge">plugins=plugin1+plugin2</code>：指定插件，支持grpc/micro，即：plugins=grpc+micro</li><br />
  <li><code class="language-plaintext highlighter-rouge">M</code>参数：指定导入的.proto文件路径编译后对应的goalng包名（不指定默认.proto文件中import语句路径）</li><br />
  <li><code class="language-plaintext highlighter-rouge">import_prefix=xxx</code>：为所有import路径添加前缀，主要用于编译子目录内的多个proto文件</li><br />
  <li><code class="language-plaintext highlighter-rouge">import_path=foo/bar</code>：指定未声明package或go_package的文件的包名，最右边的斜线前的字符会被忽略<br />
3.4 编写一个简单的Hello服务<br />
至此，go-micro框架的编程环境已基本搭建好，接下来就是写代码了。</li><br />
</ul><br />
<br />
<p>下面实现一个Hello服务：它接收一个字符串类型参数请求，返回一个字符串问候语：Hello 『参数值』。<br />
1）定义API</p><br />
<br />
<p>创建proto/hello.proto文件：<br />
使用protobuf文件来定义服务API接口</p><br />
<br />
<p>syntax = “proto3”;<br />
service Hello {<br />
    rpc Ping(Request) returns (Response) {}<br />
}<br />
message Request {<br />
    string name = 1;<br />
}<br />
message Response {<br />
    string msg = 1;<br />
}<br />
执行protoc命令，生成当前pb文件的go实现：</p><br />
<br />
<p>protoc –go_out=plugins=micro:. ./proto/hello.proto<br />
2）创建service</p><br />
<br />
<p>创建services/hello.go文件：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “context”<br />
    “fmt”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proto "winmicro/proto"<br />
<br />
micro "github.com/micro/go-micro" )<br />
</code></pre></div></div><br />
<br />
<p>type Hello struct{}</p><br />
<br />
<p>func (h *Hello) Ping(ctx context.Context, req *proto.Request, res *proto.Response) error {<br />
    res.Msg = “Hello “ + req.Name<br />
    return nil<br />
}<br />
func main() {<br />
    service := micro.NewService(<br />
        micro.Name(“hellooo”), // 服务名称<br />
    )<br />
    service.Init()<br />
    proto.RegisterHelloHandler(service.Server(), new(Hello))<br />
    if err := service.Run(); err != nil {<br />
        fmt.Println(err)<br />
    }<br />
}<br />
3)模拟client</p><br />
<br />
<p>创建Clients/helloclient.go文件：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “context”<br />
    “fmt”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>proto "winmicro/proto"<br />
<br />
micro "github.com/micro/go-micro" )<br />
</code></pre></div></div><br />
<br />
<p>func main() {<br />
    service := micro.NewService(micro.Name(“hello.client”)) // 客户端服务名称<br />
    service.Init()<br />
    helloservice := proto.NewHelloService(“hellooo”, service.Client())<br />
    res, err := helloservice.Ping(context.TODO(), &amp;proto.Request{Name: “World ^_^”})<br />
    if err != nil {<br />
        fmt.Println(err)<br />
    }<br />
    fmt.Println(res.Msg)<br />
}<br />
3.5 运行Hello服务<br />
启动consul之后<br />
执行micro list services 查看当前已有服务：</p><br />
<br />
<blockquote><br />
  <p>micro list services<br />
consul<br />
执行go run services/hello.go命令，启动hellooo服务：</p><br />
</blockquote><br />
<br />
<blockquote><br />
  <p>go run services/hello.go<br />
2018/11/29 20:18:08 Listening on [::]:61463<br />
2018/11/29 20:18:08 Broker Listening on [::]:61464<br />
2018/11/29 20:18:08 Registering node: hellooo-74122f56-4728-4449-a9d4-6c3c85ba2fcb<br />
….<br />
再次执行micro list services 查看当前已有服务：</p><br />
</blockquote><br />
<br />
<blockquote><br />
  <p>micro list services<br />
consul<br />
hellooo<br />
即hellooo服务已启动</p><br />
</blockquote><br />
<br />
<p>注 通过WebUI来查看各service信息：http://localhost:8500/</p><br />
<br />
<p>请求服务<br />
执行go run clients/helloclient.go命令，向hellooo服务发起请求：</p><br />
<br />
<blockquote><br />
  <p>go run clients/helloclient.go<br />
Hello World ^_^</p><br />
</blockquote><br />
<br />
<p>go-micro是go语言下的一个很好的rpc微服务框架，功能很完善，而且我关心的几个问题也解决的很好：</p><br />
<br />
<p>一：服务间传输格式为protobuf，效率上没的说，非常的快，也很安全。</p><br />
<br />
<p>二：go-micro的服务注册和发现是多种多样的。我个人比较喜欢etcdv3的服务服务发现和注册。</p><br />
<br />
<p>三：主要的功能都有相应的接口，只要实现相应的接口，就可以根据自己的需要订制插件。</p><br />
<br />
<p>Server监听客户端的调用，和Brocker推送过来的信息进行处理。并且Server端需要向Register注册自己的存在或消亡，这样Client才能知道自己的状态。</p><br />
<br />
<p>Register服务的注册的发现。</p><br />
<br />
<p>Client端从Register中得到Server的信息，然后每次调用都根据算法选择一个的Server进行通信，当然通信是要经过编码/解码，选择传输协议等一系列过程的。</p><br />
<br />
<p>如果有需要通知所有的Server端可以使用Brocker进行信息的推送。</p><br />
<br />
<p>Brocker 信息队列进行信息的接收和发布。</p><br />
<br />
<p>go-micro之所以可以高度订制和他的框架结构是分不开的，go-micro由8个关键的interface组成，每一个interface都可以根据自己的需求重新实现，这8个主要的inteface也构成了go-micro的框架结构。</p><br />
<br />
<p>Transort<br />
服务之间通信的接口。也就是服务发送和接收的最终实现方式，是由这些接口定制的。</p><br />
<br />
<p>源码：</p><br />
<br />
<p>type Socket interface {<br />
    Recv(<em>Message) error<br />
    Send(</em>Message) error<br />
    Close() error<br />
}</p><br />
<br />
<p>type Client interface {<br />
    Socket<br />
}</p><br />
<br />
<p>type Listener interface {<br />
    Addr() string<br />
    Close() error<br />
    Accept(func(Socket)) error<br />
}</p><br />
<br />
<p>type Transport interface {<br />
    Dial(addr string, opts …DialOption) (Client, error)<br />
    Listen(addr string, opts …ListenOption) (Listener, error)<br />
    String() string<br />
}<br />
Transport 的Listen方法是一般是Server端进行调用的，他监听一个端口，等待客户端调用。</p><br />
<br />
<p>Transport 的Dial就是客户端进行连接服务的方法。他返回一个Client接口，这个接口返回一个Client接口，这个Client嵌入了Socket接口，这个接口的方法就是具体发送和接收通信的信息。</p><br />
<br />
<p>http传输是go-micro默认的同步通信机制。当然还有很多其他的插件：grpc,nats,tcp,udp,rabbitmq,nats，都是目前已经实现了的方式。在go-plugins里你都可以找到。</p><br />
<br />
<p>Codec<br />
有了传输方式，下面要解决的就是传输编码和解码问题，go-micro有很多种编码解码方式，默认的实现方式是protobuf,当然也有其他的实现方式，json、protobuf、jsonrpc、mercury等等。</p><br />
<br />
<p>type Codec interface {<br />
    ReadHeader(<em>Message, MessageType) error<br />
    ReadBody(interface{}) error<br />
    Write(</em>Message, interface{}) error<br />
    Close() error<br />
    String() string<br />
}</p><br />
<br />
<p>type Message struct {<br />
    Id     uint64<br />
    Type   MessageType<br />
    Target string<br />
    Method string<br />
    Error  string<br />
    Header map[string]string<br />
}<br />
Codec接口的Write方法就是编码过程，两个Read是解码过程。</p><br />
<br />
<p>Registry<br />
服务的注册和发现，目前实现的consul,mdns, etcd,etcdv3,zookeeper,kubernetes.等等，</p><br />
<br />
<p>type Registry interface {<br />
    Register(<em>Service, …RegisterOption) error<br />
    Deregister(</em>Service) error<br />
    GetService(string) ([]<em>Service, error)<br />
    ListServices() ([]</em>Service, error)<br />
    Watch(…WatchOption) (Watcher, error)<br />
    String() string<br />
    Options() Options<br />
}<br />
简单来说，就是Service 进行Register，来进行注册，Client 使用watch方法进行监控，当有服务加入或者删除时这个方法会被触发，以提醒客户端更新Service信息。</p><br />
<br />
<p>默认的是服务注册和发现是consul</p><br />
<br />
<p>Selector<br />
以Registry为基础，Selector 是客户端级别的负载均衡，当有客户端向服务发送请求时， selector根据不同的算法从Registery中的主机列表，得到可用的Service节点，进行通信。目前实现的有循环算法和随机算法，默认的是随机算法。</p><br />
<br />
<p>源码：</p><br />
<br />
<p>type Selector interface {<br />
    Init(opts …Option) error<br />
    Options() Options<br />
    // Select returns a function which should return the next node<br />
    Select(service string, opts …SelectOption) (Next, error)<br />
    // Mark sets the success/error against a node<br />
    Mark(service string, node *registry.Node, err error)<br />
    // Reset returns state back to zero for a service<br />
    Reset(service string)<br />
    // Close renders the selector unusable<br />
    Close() error<br />
    // Name of the selector<br />
    String() string<br />
}<br />
默认的是实现是本地缓存，当<br />
前实现的有blacklist,label,named等方式。</p><br />
<br />
<p>Broker<br />
Broker是消息发布和订阅的接口。很简单的一个例子，因为服务的节点是不固定的，如果有需要修改所有服务行为的需求，可以使服务订阅某个主题，当有信息发布时，所有的监听服务都会收到信息，根据你的需要做相应的行为。</p><br />
<br />
<p>源码</p><br />
<br />
<p>type Broker interface {<br />
    Options() Options<br />
    Address() string<br />
    Connect() error<br />
    Disconnect() error<br />
    Init(…Option) error<br />
    Publish(string, *Message, …PublishOption) error<br />
    Subscribe(string, Handler, …SubscribeOption) (Subscriber, error)<br />
    String() string<br />
}<br />
Broker默认的实现方式是http方式，但是这种方式不要在生产环境用。go-plugins里有很多成熟的消息队列实现方式，有kafka、nsq、rabbitmq、redis，等等。</p><br />
<br />
<p>Client<br />
Client是请求服务的接口，他封装Transport和Codec进行rpc调用，也封装了Brocker进行信息的发布。</p><br />
<br />
<p>源码</p><br />
<br />
<p>type Client interface {<br />
    Init(…Option) error<br />
    Options() Options<br />
    NewMessage(topic string, msg interface{}, opts …MessageOption) Message<br />
    NewRequest(service, method string, req interface{}, reqOpts …RequestOption) Request<br />
    Call(ctx context.Context, req Request, rsp interface{}, opts …CallOption) error<br />
    Stream(ctx context.Context, req Request, opts …CallOption) (Stream, error)<br />
    Publish(ctx context.Context, msg Message, opts …PublishOption) error<br />
    String() string<br />
}<br />
当然他也支持双工通信 Stream 这些具体的实现方式和使用方式，以后会详细解说。</p><br />
<br />
<p>默认的是rpc实现方式，他还有grpc和http方式，在go-plugins里可以找到</p><br />
<br />
<p>Server<br />
Server看名字大家也知道是做什么的了。监听等待rpc请求。监听broker的订阅信息，等待信息队列的推送等。</p><br />
<br />
<p>源码</p><br />
<br />
<p>type Server interface {<br />
    Options() Options<br />
    Init(…Option) error<br />
    Handle(Handler) error<br />
    NewHandler(interface{}, …HandlerOption) Handler<br />
    NewSubscriber(string, interface{}, …SubscriberOption) Subscriber<br />
    Subscribe(Subscriber) error<br />
    Register() error<br />
    Deregister() error<br />
    Start() error<br />
    Stop() error<br />
    String() string<br />
}<br />
默认的是rpc实现方式，他还有grpc和http方式，在go-plugins里可以找到</p><br />
<br />
<p>Service<br />
Service是Client和Server的封装，他包含了一系列的方法使用初始值去初始化Service和Client，使我们可以很简单的创建一个rpc服务。</p><br />
<br />
<p>源码：</p><br />
<br />
<p>type Service interface {<br />
    Init(…Option)<br />
    Options() Options<br />
    Client() client.Client<br />
    Server() server.Server<br />
    Run() error<br />
    String() string<br />
}</p><br />
<br />
<p>Micro由开源的库与工具组成，旨在辅助微服务开发。</p><br />
<br />
<p>go-micro - 基于Go语言的可插拔RPC微服务开发框架；包含服务发现、RPC客户/服务端、广播/订阅机制等等。<br />
go-plugins - go-micro的插件有etcd、kubernetes、nats、rabbitmq、grpc等等。<br />
micro - 微服务工具集包含传统的入口点（entry point）；API 网关、CLI、Slack Bot、代理及Web UI。</p><br />
<br />
<p>可以通过micro工具集的cli，web ui，slack，或者api网关（api gateway）来访问操控务。</p><br />
<br />
<p>除了Consul，可以使用其它的注册中心吗<br />
当然是可以的，服务的注册发现的实现机制是可插拔的，之所以使用Consul是因为它拥有的特性以及它足够简单。 比如：</p><br />
<br />
<p>Etcd<br />
如果你想使用etcd那你只需要引用etcd包，然后在启动的注册方式上标明使用的是etcd就行了。</p><br />
<br />
<p>import (<br />
        _ “github.com/micro/go-plugins/registry/etcd”<br />
)</p><br />
<br />
<p>service –registry=etcd –registry_address=127.0.0.1:2379</p><br />
<br />
<p>零依赖<br />
micro专门为零依赖配置内置有一个多路广播DNS服务注册中心。</p><br />
<br />
<p>如果要使用，只需要在程序启动指令上传上–registry=mdns或者MICRO_REGISTRY=mdns。</p><br />
<br />
<p>Micro可以在哪些环境运行<br />
micro对运行环境不挑食。只要你喜欢，在哪都行，裸机, 亚马逊AWS或者Google Cloud，也可以运行在你喜欢的容器编排系统中比如：Mesos、Kubernetes。</p><br />
<br />
<p>右边的这个链接中有关于如何使用K8s来开发micro服务的micro kubernetes demo</p><br />
<br />
<p>Micro支持gRPC吗<br />
支持。这儿有几个插件：transport、client、server。</p><br />
<br />
<p>可以查看micro/go-plugins.</p><br />
<br />
<p>我们也提供了golang版本的gRPC快速上手demo：micro/go-grpc.</p><br />
<br />
<p>Micro与Go-Kit比较<br />
这个问题经常出现，那二者的区别有哪些呢？</p><br />
<br />
<p>Go-kit声称自己是一个微服务的标准库。像GO一样，go-kit提供独立的包，通过这些包，开发者可以用来组建自己的应用程序。Go-kit非常不错，基于Go-kit，你可以完全掌控你定义的服务。</p><br />
<br />
<p>Go-micro则是一个面向微服务的可插拔RPC框架。go-micro是一个只在特殊方向上努力的框架，它尝试简化分布式系统之间的通信，所以我们可以花更多的时间在我们需要关注的业务逻辑上。对于想快速启动，把程序跑起来，同时用拥有一些可插拔的能力从基础架构中断开的能力，而不用修改代码，那么go-micro也很不错。</p><br />
<br />
<p>Micro作为一个微服务工具库，好比一把瑞士军刀，在我们构建微服务时，可以提供传统的接入点，比如http api gateway，web ui，cli，slack bot等等。Micro使用工具来引导架构关注点之间逻辑上的隔离，推动开发者创建API层的服务来暴露对外的API接口，并且创建隔离于对外API的Web层微服务。</p><br />
<br />
<p>如果想全盘掌控，那么使用go-kit；但是如果想弄一个有想法框架，使用go-micro。</p><br />
<br />
<p>https://micro.mu/docs/users.html</p><br />
<br />
<p>https://github.com/micro/examples/tree/master/greeter</p><br />
<br />
<p>https://github.com/asim/kubernetes</p><br />
<br />
<p>Go kit 是一系列由 Go 的包组成的工具集，并且是生产级别的，完全适应于任何公司与组织的业务。</p><br />
<br />
<p>架构：三个层次<br />
Transport layer：通信层，这里可以用各种不同的通信方式，如 HTTP REST 接口或者 gRPC 接口（这是个很大的优点，方便切换成任何通信协议）；<br />
Endpoint layer：终端层，类似于 Controller，里面主要实现各种接口的 handler，负责 req／resp 格式的转换（同时也是被吐槽繁杂的原因所在）；<br />
Service layer：服务层，也就是实现业务逻辑的地方；<br />
从下面的架构图来看，它其实很简单明了。其中可以注意下中间件：类似于常见框架中的中间件模式，通常用来记录日志、限制频率、负载均衡以及分布式追踪等等，主要在 Endpoint 以及 Service 中实现。</p><br />
<br />
<p>各个模块之间应该是 低耦合，高内聚，于是，Go kit 鼓励你在 main 函数里面实现所有的组装，所有的模块的依赖都需要通过参数传入其它模块，减少甚至消灭所有全局状态，从根本上避免技术债务。</p><br />
<br />
<p>同时还有个很大的好处：便于测试，只要 mock 传入的依赖参数即可。</p><br />
<br />
<p>Eyal Posener 这位老哥在他的博客 为什么我建议不要使用 go-kit 中写到三点原因：</p><br />
<br />
<p>框架太繁琐，每个接口的代码太多，太啰嗦；<br />
难理解，主要体现在 Go kit 的三层模型；<br />
interface{} API 太蛋疼，在 Endpoint 层，每个 endpoint 都需要重复类似的转换代码；</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>