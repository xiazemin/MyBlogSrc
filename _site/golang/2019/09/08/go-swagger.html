<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">go-swagger</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-09-08T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Sep 8, 2019</time></p>
					</div>
					 <p>https://github.com/go-swagger/go-swagger<br />
https://legacy.gitbook.com/book/huangwenchao/swagger/details</p><br />
<br />
<p>“Swagger UI 允许任何人（无论是你的开发团队还是最终用户）在没有任何实现逻辑的情况下对 API 资源进行可视化和交互。它（API文档）通过 Swagger 定义自动生成，可视化文档使得后端实现和客户端消费变得更加容易。”</p><br />
<br />
<p>简而言之，通过提供 Swagger（OpenAPI）定义，您可以获得与 API 进行交互的界面，而不必关心编程语言本身。你可以将 Swagger（OpenAPI） 视为 REST 的 WSDL 。</p><br />
<br />
<p>作为参考，Swagger Codegen 可以从这个定义中，用几十种编程语言来生成客户端和服务器代码。</p><br />
<br />
<p>回到那个时候，我使用的是 Java 和 SpringBoot ，觉得 Swagger 简单易用。你仅需创建一次 bean ，并添加一两个注解到端点上，再添加一个标题和一个项目描述。此外，我习惯将所有请求从 “/” 重定向到 “/swagger-ui” 以便在我打开 host:port 时自动跳转到 SwaggerUI 。在运行应用程序的时候， SwaggerUI 在同一个端口依然可用。（例如，您的应用程序运行在[host]:[port]， SwaggerUI 将在[host]:[port]/swagger-ui上访问到）。</p><br />
<br />
<p>如何为项目加上swagger注释，然后一键生成API文档<br />
开始之前需要安装两个工具：</p><br />
<br />
<p>swagger-editor:用于编写swagger文档，UI展示，生成代码等…<br />
go-swagger:用于一键生成API文档</p><br />
<br />
<p>安装swagger-editor,我这里使用docker运行，其他安装方式，请查看官方文档：<br />
docker pull swaggerapi/swagger-editor<br />
docker run –rm -p 80:8080 swaggerapi/swagger-editor<br />
安装go-swagger,我这边使用brew安装</p><br />
<br />
<p>brew tap go-swagger/go-swagger<br />
brew install go-swagger<br />
<!-- more --><br />
开始编写注释<br />
1.假设有一个user.server，提供一些REST API，用于对用户数据的增删改查。<br />
比如这里有一个getOneUser接口，是查询用户信息的：<br />
package service</p><br />
<br />
<p>import (<br />
    “encoding/json”<br />
    “fmt”<br />
    “net/http”<br />
    “strconv”<br />
    “user.server/models”<br />
    “github.com/Sirupsen/logrus”<br />
)</p><br />
<br />
<p>type GetUserParam struct {<br />
    Id int <code class="language-plaintext highlighter-rouge">json:"id"</code><br />
}</p><br />
<br />
<p>func GetOneUser(w http.ResponseWriter, r *http.Request) {<br />
    defer r.Body.Close()<br />
    decoder := json.NewDecoder(r.Body)<br />
    var param GetUserParam<br />
    err := decoder.Decode(&amp;param)<br />
    if err != nil {<br />
        WriteResponse(w, ErrorResponseCode, “request param is invalid, please check!”, nil)<br />
        return<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// get user from db<br />
user, err := models.GetOne(strconv.Itoa(param.Id))<br />
if err != nil {<br />
    logrus.Warn(err)<br />
    WriteResponse(w, ErrorResponseCode, "failed", nil)<br />
    return<br />
}<br />
WriteResponse(w, SuccessResponseCode, "success", user) } 复制代码根据swagger文档规范，一个swagger文档首先要有swagger的版本和info信息。利用go-swagger只需要在声明package之前加上如下注释即可： // Package classification User API. // // The purpose of this service is to provide an application // that is using plain go code to define an API // //      Host: localhost //      Version: 0.0.1 // // swagger:meta package service 复制代码然后在项目根目录下使用swagger generate spec -o ./swagger.json命令生成swagger.json文件：<br />
</code></pre></div></div><br />
<br />
<p>此命令会找到main.go入口文件，然后遍历所有源码文件，解析然后生成swagger.json文件</p><br />
<br />
<p>{<br />
  “swagger”: “2.0”,<br />
  “info”: {<br />
    “description”: “The purpose of this service is to provide an application\nthat is using plain go code to define an API”,<br />
    “title”: “User API.”,<br />
    “version”: “0.0.1”<br />
  },<br />
  “host”: “localhost”,<br />
  “paths”: {}<br />
}<br />
复制代码2.基本信息有了，然后就要有路由，请求，响应等，下面针对getOneUser接口编写swagger注释：<br />
// swagger:parameters getSingleUser<br />
type GetUserParam struct {<br />
    // an id of user info<br />
    //<br />
    // Required: true<br />
    // in: path<br />
    Id int <code class="language-plaintext highlighter-rouge">json:"id"</code><br />
}</p><br />
<br />
<p>func GetOneUser(w http.ResponseWriter, r *http.Request) {<br />
    // swagger:route GET /users/{id} users getSingleUser<br />
    //<br />
    // get a user by userID<br />
    //<br />
    // This will show a user info<br />
    //<br />
    //     Responses:<br />
    //       200: UserResponse<br />
    decoder := json.NewDecoder(r.Body)<br />
    var param GetUserParam<br />
    err := decoder.Decode(&amp;param)<br />
    if err != nil {<br />
        WriteResponse(w, ErrorResponseCode, “request param is invalid, please check!”, nil)<br />
        return<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// get user from db<br />
user, err := models.GetOne(strconv.Itoa(param.Id))<br />
if err != nil {<br />
    logrus.Warn(err)<br />
    WriteResponse(w, ErrorResponseCode, "failed", nil)<br />
    return<br />
}<br />
WriteResponse(w, SuccessResponseCode, "success", user) } 复制代码可以看到在GetUserParam结构体上面加了一行swagger:parameters getSingleUser的注释信息，这是声明接口的入参注释，结构体内部的几行注释指明了id这个参数必填，并且查询参数id是在url path中。详细用法，参考: swagger:params 在GetOneUser函数中：<br />
</code></pre></div></div><br />
<br />
<p>swagger:route指明使用的http method，路由，以及标签和operation id,详细用法，参考： swagger:route<br />
Responses指明了返回值的code以及类型</p><br />
<br />
<p>然后再声明响应:<br />
// User Info<br />
//<br />
// swagger:response UserResponse<br />
type UserWapper struct {<br />
    // in: body<br />
    Body ResponseMessage<br />
}</p><br />
<br />
<p>type ResponseMessage struct {<br />
    Code    int         <code class="language-plaintext highlighter-rouge">json:"code"</code><br />
    Message string      <code class="language-plaintext highlighter-rouge">json:"message"</code><br />
    Data    interface{} <code class="language-plaintext highlighter-rouge">json:"data"</code><br />
}<br />
复制代码使用swagger:response语法声明返回值，其上两行是返回值的描述（我也不清楚，为啥描述信息要写在上面，欢迎解惑）,详细用法，参考； swagger:response<br />
然后浏览器访问localhost,查看swagger-editor界面,点击工具栏中的File-&gt;Impoprt File上传刚才生成的 swagger.json文件，就可以看到界面：</p><br />
<br />
<p>这样一个简单的api文档就生成了<br />
3.怎么样？是不是很简单？可是又感觉那里不对，嗯，注释都写在代码里了，很不美观，而且不易维护。想一下go-swagger的原理是扫描目录下的所有go文件，解析注释信息。那么是不是可以把api注释都集中写在单个文件内，统一管理，免得分散在各个源码文件内。<br />
新建一个doc.go文件，这里还有一个接口是UpdateUser,那么我们在doc.go文件中声明此接口的api注释。先看一下UpdateUser接口的代码：<br />
func UpdateUser(w http.ResponseWriter, r *http.Request) {<br />
    defer r.Body.Close()<br />
    // decode body data into user struct<br />
    decoder := json.NewDecoder(r.Body)<br />
    user := models.User{}<br />
    err := decoder.Decode(&amp;user)<br />
    if err != nil {<br />
        WriteResponse(w, ErrorResponseCode, “user data is invalid, please check!”, nil)<br />
        return<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// check if user exists<br />
data, err := models.GetUserById(user.Id)<br />
if err != nil {<br />
    logrus.Warn(err)<br />
    WriteResponse(w, ErrorResponseCode, "query user failed", nil)<br />
    return<br />
}<br />
if data.Id == 0 {<br />
    WriteResponse(w, ErrorResponseCode, "user not exists, no need to update", nil)<br />
    return<br />
}<br />
<br />
// update<br />
_, err = models.Update(user)<br />
if err != nil {<br />
    WriteResponse(w, ErrorResponseCode, "update user data failed, please try again!", nil)<br />
    return<br />
}<br />
WriteResponse(w, SuccessResponseCode, "update user data success!", nil) } 复制代码然后再doc.go文件中编写如下声明： package service<br />
</code></pre></div></div><br />
<br />
<p>import “user.server/models”</p><br />
<br />
<p>// swagger:parameters UpdateUserResponseWrapper<br />
type UpdateUserRequest struct {<br />
    // in: body<br />
    Body models.User<br />
}</p><br />
<br />
<p>// Update User Info<br />
//<br />
// swagger:response UpdateUserResponseWrapper<br />
type UpdateUserResponseWrapper struct {<br />
    // in: body<br />
    Body ResponseMessage<br />
}</p><br />
<br />
<p>// swagger:route POST /users users UpdateUserResponseWrapper<br />
//<br />
// Update User<br />
//<br />
// This will update user info<br />
//<br />
//     Responses:<br />
//       200: UpdateUserResponseWrapper<br />
复制代码这样就把api声明注释给抽离出来了，然后使用命令swagger generate spec -o ./swagger.json生成json文件,就可以看到结果：<br />
很简单吧，参照文档编写几行注释，然后一个命令生成API文档。</p><br />
<br />
<div class="container"><br />
	<div class="row"><br />
	<img src="https://xiazemin.github.io/MyBlog/img/jupyterSlider.png" /><br />
	</div><br />
	<div class="row"><br />
	如果你的 API 仅提供在 HTTP 或 HTTPS 上，且只生成 JSON ，您应在此处添加它 - 允许你从每个路由中删除该注释。<br />
<br />
安全也被添加在 swagger:meta 中，在 SwaggerUI 上添加一个授权按钮。为了实现JWT，我使用安全类型承载进行命名并将其定义为：<br />
<br />
//     Security:<br />
//     - bearer<br />
//<br />
//     SecurityDefinitions:<br />
//     bearer:<br />
//          type: apiKey<br />
//          name: Authorization<br />
//          in: header<br />
//<br />
Swagger:route [docs]<br />
有两种方式两个注释你的路由，swagger:operation 和swagger:route 。两者看起来都很相似，那么主要区别是什么？<br />
<br />
把 swagger:route 看作简单 API 的短注释,它适用于没有输入参数（路径/查询参数）的 API 。那些（带有参数）的例子是 /repos/{owner} ， /user/{id} 或者 /users/search?name=ribice<br />
<br />
如果你有一个那种类型，那么你就必须使用 swagger:operation ，除此之外，如 /user 或 /version 之类的 APIs 都可以用 swagger:route 来注释。<br />
<br />
swagger:route注释包含以下内容：<br />
<br />
// swagger:route POST /repo repos users createRepoReq<br />
// Creates a new repository for the currently authenticated user.<br />
// If repository name is "exists", error conflict (409) will be returned.<br />
// responses:<br />
//  200: repoResp<br />
//  400: badReq<br />
//  409: conflict<br />
//  500: internal<br />
swagger:route - 注解<br />
POST - HTTP方法<br />
/repo - 匹配路径，端点<br />
repos - 路由所在的空间分割标签，例如，“repos users”<br />
createRepoReq - 用于此端点的请求（详细的稍后会解释）<br />
Creates a new repository … - 摘要（标题）。对于swager:route注释，在第一个句号（.）前面的是标题。如果没有句号，就会没有标题并且这些文字会被用于描述。<br />
If repository name exists … - 描述。对于swager:route类型注释，在第一个句号（.）后面的是描述。<br />
responses: - 这个端点的响应<br />
200: repoResp - 一个（成功的）响应HTTP状态 200，包含 repoResp（用 swagger:response 注释的模型）<br />
400: badReq, 409: conflict, 500: internal - 此端点的错误响应（错误请求，冲突和内部错误， 定义在 cmd/api/swagger/model.go 下）<br />
<br />
<br />
请记住，您还可能需要使用其他注释，具体取决于您的 API 。由于我将我的项目定义为仅使用单一模式（ https ），并且我的所有 API 都使用 https ，所以我不需要单独注释方案。如果您为端点使用多个模式，则需要以下注释：<br />
<br />
// Schemes: http, https, ws, wss<br />
同样适用于 消费者/生产者 媒体类型。我所有的 API 都只消费/生成 application/json 。如果您的 API 正在 消费/生成 其他类型，则需要使用该媒体类型对其进行注释。例如：<br />
<br />
// consumes:<br />
// - application/json<br />
// - application/x-protobuf<br />
//<br />
// produces:<br />
// - application/json<br />
// - application/x-protobuf<br />
安全性：<br />
<br />
// security:<br />
//   api_key:<br />
//   oauth: read, write<br />
//   basicAuth:<br />
//      type: basic<br />
//   token:<br />
//      type: apiKey<br />
//      name: token<br />
//      in: query<br />
//   accessToken:<br />
//      type: apiKey<br />
//      name: access_token<br />
//      in: query<br />
另一方面，swagger:operation 用于更复杂的端点。三个破折号（-）下的部分被解析为 YAML ，允许更复杂的注释。确保您的缩进是一致的和正确的，否则将无法正确解析。<br />
<br />
Swagger:operation docs<br />
使用 Swagger:operation 可以让你使用所有OpenAPI规范，你可以描述你的复杂的端点。如果你对细节感兴趣，你可以阅读规范文档。<br />
<br />
简单来说 - swagger:operation 包含如下内容：<br />
<br />
// swagger:operation GET /repo/{author} repos repoList<br />
// ---<br />
// summary: List the repositories owned by the given author.<br />
// description: If author length is between 6 and 8, Error Not Found (404) will be returned.<br />
// parameters:<br />
// - name: author<br />
//   in: path<br />
//   description: username of author<br />
//   type: string<br />
//   required: true<br />
// responses:<br />
//   "200":<br />
//     "$ref": "#/responses/reposResp"<br />
//   "404":<br />
//     "$ref": "#/responses/notFound"<br />
swagger:operation - 注释<br />
GET - HTTP 方法<br />
/repo/{author} - 匹配路径，端点<br />
repos - 路由所在的空间分割标签，例如，“repos users”<br />
repoList - 用于此端点的请求。这个不存在（没有定义），但参数是强制性的，所以你可以用任何东西来替换repoList（noReq，emptyReq等）<br />
--- - 这个部分下面是YAML格式的swagger规范。确保您的缩进是一致的和正确的，否则将无法正确解析。注意，如果你在YAML中定义了标签，摘要，描述或操作标签，将覆盖上述常规swagger语法中的摘要，描述，标记或操作标签。<br />
summary: - 标题<br />
description: - 描述<br />
parameters: - URL参数（在这个例子中是{author}）。字符串格式，强制性的（Swagger不会让你调用端点而不输入），位于路径（/{author}）中。另一种选择是参数内嵌的请求 (?name="")<br />
定义你的路由后，你需要定义你的请求和响应。从示例中，你可以看到，我创建了一个新的包，命名为 swagger 。这不是强制性的，它把所有样板代码放在一个名为 swagger 的包中。但缺点是你必须导出你的所有 HTTP 请求和响应。<br />
<br />
如果你创建了一个单独的 Swagger 包，确保将它导入到你的主/服务器文件中（你可以通过在导入前加一个下划线来实现）：<br />
<br />
_ "github.com/ribice/golang-swaggerui-example/cmd/swagger"<br />
Swagger:parameters [docs]<br />
根据您的应用程序模型，您的 HTTP 请求可能会有所不同（简单，复杂，封装等）。要生成 Swagger 规范，您需要为每个不同的请求创建一个结构，甚至包含仅包含数字（例如id）或字符串（名称）的简单请求。<br />
<br />
一旦你有这样的结构（例如一个包含一个字符串和一个布尔值的结构），在你的Swagger包中定义如下：<br />
<br />
// Request containing string<br />
// swagger:parameters createRepoReq<br />
type swaggerCreateRepoReq struct {<br />
    // in:body<br />
    api.CreateRepoReq<br />
}<br />
第 1 行包含一个在 SwaggerUI 上可见的注释<br />
第 2 行包含 swagger:parameters 注释，以及请求的名称（operationID）。此名称用作路由注释的最后一个参数，以定义请求。<br />
第 4 行包含这个参数的位置（in:body，in:query 等）<br />
第 5 行是实际的内嵌结构。正如前面所提到的，你不需要一个独立的 swagger 批注包（你可以把swagger:parameters注释放在 api.CreateRepoReq 上），但是一旦你开始创建响应注释和验证，那么在 swagger 相关批注一个单独的包会更清晰。<br />
swagger-parameters<br />
<br />
如果你有大的请求，比如创建或更新，你应该创建一个新类型的变量,而不是内嵌结构。例如（注意第五行的区别）:<br />
<br />
// Request containing string<br />
// swagger:parameters createRepoReq<br />
type swaggerCreateRepoReq struct {<br />
    // in:body<br />
    Body api.CreateRepoReq<br />
}<br />
这会产生以下 SwaggerUI 请求：<br />
<br />
swagger-patameters-ui<br />
<br />
Swagger 有很多验证注释提供给 swagger:parameters和 swagger:response ，在注释标题旁边的文档中有详细的描述和使用方法。<br />
<br />
Swagger:response [docs]<br />
响应注释与参数注释非常相似。主要的区别在于，经常将响应包裹到更复杂的结构中，所以你必须要在 swagger 中考虑到这点。<br />
<br />
在我的示例中，我的成功响应如下所示：<br />
<br />
{<br />
     "code":200, // Code containing HTTP status CODE<br />
     "data":{} // Data containing actual response data<br />
}<br />
虽然错误响应有点不同：<br />
<br />
{<br />
     "code":400, // Code containing HTTP status CODE<br />
     "message":"" // String containing error message<br />
}<br />
要使用常规响应，像上面错误响应那样的，我通常在 swagger 包内部创建 model.go（或swagger.go）并在里面定义它们。在示例中，下面的响应用于 OK 响应（不返回任何数据）：<br />
<br />
// Success response<br />
// swagger:response ok<br />
type swaggScsResp struct {<br />
    // in:body<br />
    Body struct {<br />
        // HTTP status code 200 - OK<br />
        Code int `json:"code"`<br />
    }<br />
}<br />
对于错误响应，除了名称（和示例的情况下的 HTTP 代码注释）之外，它们中的大多数类似于彼此。尽管如此，你仍然应该为每一个错误的情况进行定义，以便把它们作为你的端点可能的响应：<br />
<br />
// Error Forbidden<br />
// swagger:response forbidden<br />
type swaggErrForbidden struct {<br />
    // in:body<br />
    Body struct {<br />
        // HTTP status code 403 -  Forbidden<br />
        Code int `json:"code"`<br />
        // Detailed error message<br />
        Message string `json:"message"`<br />
    }<br />
}<br />
data 中包含 model.Repository 的示例响应：<br />
<br />
// HTTP status code 200 and repository model in data<br />
// swagger:response repoResp<br />
type swaggRepoResp struct {<br />
    // in:body<br />
    Body struct {<br />
        // HTTP status code 200/201<br />
        Code int `json:"code"`<br />
        // Repository model<br />
        Data model.Repository `json:"data"`<br />
    }<br />
}<br />
data 中包含 model.Repository 切片的示例响应：<br />
<br />
// HTTP status code 200 and an array of repository models in data<br />
// swagger:response reposResp<br />
type swaggReposResp struct {<br />
    // in:body<br />
    Body struct {<br />
        // HTTP status code 200 - Status OK<br />
        Code int `json:"code"`<br />
        // Array of repository models<br />
        Data []model.Repository `json:"data"`<br />
    }<br />
}<br />
总之，这将足以生成您的 API 文档。您也应该向文档添加验证，但遵循本指南将帮助您开始。由于这主要是由我自己的经验组成，并且在某种程度上参考了 Gitea 的源代码，我将会听取关于如何改进这部分并相应更新的反馈。<br />
<br />
如果您有一些问题或疑问，我建议您查看如何生成FAQ。<br />
<br />
本地运行 SwaggerUI<br />
一旦你的注释准备就绪，你很可能会在你的本地环境中测试它。要做到这一点，你需要运行两个命令：<br />
<br />
Generate spec [docs]<br />
Serve [docs]<br />
这个命令我们用来生成 swagger.json 并使用 SwaggerUI：<br />
<br />
swagger generate spec -o ./swagger.json --scan-models<br />
swagger serve -F=swagger swagger.json<br />
或者，如果你只想使它成为一个命令：<br />
<br />
swagger generate spec -o ./swagger.json --scan-models &amp;&amp; swagger serve -F=swagger swagger.json<br />
执行该命令后，将使用 Petstore 托管的 SwaggerUI 打开一个新选项卡。服务器启用了 CORS，并将标准 JSON 的 URL 作为请求字符串附加到 petstore URL。<br />
<br />
另外，如果使用 Redoc flavor（-F = redoc），则文档将托管在您自己的计算机上（localhost:port/docs）。<br />
<br />
在服务器上部署<br />
在服务器上部署生成的 SwaggerUI 有很多种方法。一旦你生成了 swagger.json，它应该相对容易地被运行。<br />
<br />
例如，我们的应用程序正在 Google App Engine 上运行。Swagger Spec 由我们的 CI 工具生成，并在 /docs 路径上提供。<br />
<br />
我们将 SwaggerUI 作为 Docker 服务部署在 GKE（Google Container/Kubernates Engine）上，它从 /docs 路径中获取swagger.json。<br />
<br />
我们的 CI（Wercker）脚本的一部分：<br />
<br />
build:<br />
    steps:<br />
        - script:<br />
            name: workspace setup<br />
            code: |<br />
                mkdir -p $GOPATH/src/github.com/orga/repo<br />
                cp -R * $GOPATH/src/github.com/orga/repo/<br />
        - script:<br />
            cwd: $GOPATH/src/bitbucket.org/orga/repo/cmd/api/<br />
            name: build<br />
            code: |<br />
                go get -u github.com/go-swagger/go-swagger/cmd/swagger<br />
                swagger generate spec -o ./swagger.json --scan-models<br />
                CGO_ENABLED=0 go build -a -ldflags '-s' -installsuffix cgo -o app .<br />
                cp app *.template Dockerfile swagger.json "$WERCKER_OUTPUT_DIR"<br />
路由：<br />
<br />
func (d *Doc) docHandler(c context.Context, w http.ResponseWriter, r *http.Request) {<br />
    r.Header.Add("Content-Type", "application/json")<br />
    data, _ := ioutil.ReadFile("/swagger.json")<br />
    w.Write(data)<br />
}<br />
Dockerfile：<br />
<br />
FROM swaggerapi/swagger-ui<br />
ENV API_URL "https://api.orga.com/swagger"<br />
总结<br />
SwaggerUI 是一个功能强大的 API 文档工具，可以让您轻松而漂亮地记录您的 API。在 go-swagger 项目的帮助下，您可以轻松地生成 SwaggerUI 所需的swagger规范文件（swagger.json）。<br />
<br />
<br />
swagger 有一整套规范来定义一个接口文件，类似于 thrift 和 proto 文件，定义了服务的请求内容和返回内容，同样也有工具可以生成各种不同语言的框架代码，在 golang 里面我们使用 go-swagger 这个工具，这个工具还提供了额外的功能，可以可视化显示这个接口，方便阅读<br />
<br />
下面通过一个例子来简单介绍一下这个框架的使用，还是之前的点赞评论系统：https://github.com/hatlonely/microservices<br />
<br />
go-swagger 使用方法<br />
api 定义文件<br />
首先需要写一个 api 定义文件，这里我只展示其中一个接口 countlike，请求中带有某篇文章，返回点赞的次数<br />
<br />
paths:<br />
  /countlike:<br />
    get:<br />
      tags:<br />
        - like<br />
      summary: 有多少赞<br />
      description: ''<br />
      operationId: countLike<br />
      consumes:<br />
        - application/json<br />
      produces:<br />
        - application/json<br />
      parameters:<br />
        - name: title<br />
          in: query<br />
          description: 文章标题<br />
          required: true<br />
          type: string<br />
      responses:<br />
        '200':<br />
          description: 成功<br />
          schema:<br />
            $ref: '#/definitions/CountLikeModel'<br />
        '500':<br />
          description: 内部错误<br />
          schema:<br />
            $ref: '#/definitions/ErrorModel'<br />
definitions:<br />
  CountLikeModel:<br />
    type: object<br />
    properties:<br />
      count:<br />
        type: integer<br />
      title:<br />
        type: string<br />
        example: golang json 性能分析<br />
  ErrorModel:<br />
    type: object<br />
    properties:<br />
      message:<br />
        type: string<br />
        example: error message<br />
      code:<br />
        type: integer<br />
        example: 400<br />
这个是 yaml 语法，有点像去掉了括号的 json<br />
<br />
这里完整地定义了请求方法、请求参数、正常返回接口、异常返回结果，有了这个文件只需要执行下面命令就能生成框架代码了<br />
<br />
swagger generate server -f api/comment_like/comment_like.yaml<br />
还可以下面这个命令可视化查看这个接口文件<br />
<br />
swagger serve api/comment_like/comment_like.yaml<br />
这个命令依赖 swagger 工具，可以通过下面命令获取<br />
<br />
Mac<br />
<br />
brew tap go-swagger/go-swagger<br />
brew install go-swagger<br />
Linux<br />
<br />
go get -u github.com/go-swagger/go-swagger/cmd/swagger<br />
export PATH=$GOPATH/bin:$PATH<br />
执行完了之后，你发现多了几个文件夹，其中 cmd 目录里面包含 main 函数，是整个程序的入口，restapi 文件夹下面包含协议相关代码，其中 configure_xxx.go 是需要特别关注的，你需要在这个文件里面实现你具体的业务逻辑<br />
<br />
现在你就其实已经可以运行程序了，go run cmd/comment-like-server/main.go，在浏览器里面访问一下你的 api，会返回一个错误信息，告诉你 api 还没有实现，下面就来实现一下吧<br />
<br />
业务逻辑实现<br />
api.LikeCountLikeHandler = like.CountLikeHandlerFunc(func(params like.CountLikeParams) middleware.Responder {<br />
    count, err := comment_like.CountLike(params.Title)<br />
    if err != nil {<br />
        return like.NewCountLikeInternalServerError().WithPayload(&amp;models.ErrorModel{<br />
            Code: http.StatusInternalServerError,<br />
            Message: err.Error(),<br />
        })<br />
    }<br />
    return like.NewCountLikeOK().WithPayload(&amp;models.CountLikeModel{<br />
        Count: count,<br />
        Title: params.Title,<br />
    })<br />
})<br />
你只需要在这些 handler 里面实现自己的业务逻辑即可，这里对协议的封装非常好，除了业务逻辑以及打包返回，没有多余的逻辑<br />
<br />
再次运行，现在返回已经正常了<br />
<br />
统一处理<br />
如果你对请求有一些操作需要统一处理，比如输出统一的日志之类的，可以重写这个函数，也在 configure_xxx.go 这个文件中<br />
<br />
func setupGlobalMiddleware(handler http.Handler) http.Handler {<br />
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {<br />
        w.Header().Set("Access-Control-Allow-Origin", "*")<br />
        handler.ServeHTTP(w, r)<br />
    })<br />
}<br />
<br />
swagger是一款绿色开源的后端工具，以yml或者json格式的说明文档为基点，包含了以此说明文档一站式自动生成后端(路由转发层)代码、api说明文档spec可视化，客户端与交互模型client and model自动生成等模块。本文主要从安装本地swagger editor 到 一键生成 server端，并自制client测试对象slot的增删改查。阅读本文的读者须有基本的go语法与http协议知识.<br />
<br />
安装swagger editor <br />
https://swagger.io/ 官网安装下载swagger editor,解压后从cmd进入该解压文件路径,执行: <br />
npm install -g <br />
npm start <br />
使用npm的前提是要配置号nodeJS的环境，这里不再赘述 <br />
执行完后，cmd窗口上，会显示出服务的url地址，在任意浏览器地址栏上输入即可进入本地swagger editor，其内容和在线版本基本完全一致，所以网络环境健康的读者可以跳过第一步 <br />
http://editor.swagger.io/ 在线editor<br />
<br />
编辑slot.yml文档 <br />
yml的语法糖在这里有介绍https://legacy.gitbook.com/book/huangwenchao/swagger/details<br />
<br />
<br />
该文档描述了slot的增删改查开放的api接口，新建文件夹slotSwagger,点击editor的’generate server’-‘go server’ <br />
<br />
<br />
既然goa框架自动生成啦swagger-json文件，那么如何用swagger－ui展示出来呢？<br />
<br />
这里分三步：<br />
<br />
1.下载swagger－ui的web代码<br />
<br />
2.添加swagger.json 和 swagger－ui资源的导出<br />
<br />
3.main.go里面mount这两个资源，然后编译启动程序，访问即可<br />
<br />
 <br />
<br />
为什么连swagger－ui一并导出？因为在swagger－ui中的test程序，需要请求api，如果时部署在不同端口，会有跨域请求问题（这个坑我踩了）。<br />
<br />
跨域请求解决有很多方法：<br />
<br />
1）把所有api设置为可接受跨域请求<br />
<br />
2）把程序和swagger－ui部署到同一个域名下（或者设置代理访问）<br />
<br />
3）其它<br />
<br />
<br />
首先需要github.com/swaggo/gin-swagger和github.com/swaggo/gin-swagger/swaggerFiles（参见gin-swagger）。<br />
<br />
然后根据 github.com/swaggo/swag/cmd/swag文档获取到swag工具；执行swag init在项目根目录下生成docs文件夹。然后在路由中import _ "/docs"。这时候编译程序，打开http://localhost:8080/swagger/index.html就可以看到API。有时候打开页面js报错，多刷新几次就有了（原因未知）。<br />
<br />
github地址：https://github.com/swaggo/gin-swagger<br />
<br />
1、下载swag<br />
<br />
$ go get -u github.com/swaggo/swag/cmd/swag<br />
2、在main.go所在目录执行<br />
<br />
$ swag init<br />
生成docs/doc.go以及docs/swagger.json,docs/swagger.yaml<br />
<br />
3、下载gin-swagger<br />
<br />
$ go get -u github.com/swaggo/gin-swagger<br />
$ go get -u github.com/swaggo/files<br />
然后在路由文件引入<br />
<br />
import (<br />
	"github.com/gin-gonic/gin"<br />
	swaggerFiles "github.com/swaggo/files"<br />
	"github.com/swaggo/gin-swagger"<br />
	<br />
	_ "github.com/swaggo/gin-swagger/example/basic/docs" // docs is generated by Swag CLI, you have to import it.<br />
)<br />
并增加swagger访问路由<br />
<br />
url := ginSwagger.URL("http://localhost:8080/swagger/doc.json") // The url pointing to API definition<br />
    r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, url))<br />
 <br />
<br />
3、一些注解，编写各API handler方法注释（注解格式传送门）<br />
<br />
1）main.go主程序文件注释：<br />
<br />
// @title Golang Esign API<br />
// @version 1.0<br />
// @description  Golang api of demo<br />
// @termsOfService http://github.com<br />
<br />
// @contact.name API Support<br />
// @contact.url http://www.cnblogs.com<br />
// @contact.email ×××@qq.com<br />
<br />
//@host 127.0.0.1:8081<br />
func main() {<br />
}<br />
2）handler方法注释：eg<br />
<br />
//CreatScene createScene<br />
// @Summary createScene<br />
// @Description createScene<br />
// @Accept multipart/form-data<br />
// @Produce  json<br />
// @Param app_key formData string true "AppKey"<br />
// @Param nonce_str formData string true "NonceStr"<br />
// @Param time_stamp formData string true "TimeStamp"<br />
// @Success 200 {object} app.R<br />
// @Failure 500 {object} app.R<br />
// @Router /dictionaries/createScene [post]<br />
</div></div><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>