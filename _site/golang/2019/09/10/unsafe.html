<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">unsafe</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-09-10T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Sep 10, 2019</time></p>
					</div>
					 <p>unsafe包含以下资源：</p><br />
<br />
<p>三个函数：</p><br />
<br />
<p>func Alignof（variable ArbitraryType）uintptr<br />
func Offsetof（selector ArbitraryType）uintptr<br />
func Sizeof（variable ArbitraryType）uintptr<br />
和一种类型：</p><br />
<br />
<p>类型Pointer * ArbitraryType</p><br />
<br />
<p>其实就是一个int类型指针<br />
type ArbitraryType int</p><br />
<br />
<p>除了这三个函数和一个类型外，指针在unsafe包也为编译器服务。</p><br />
<br />
<p>出于安全原因，Golang不允许以下之间的直接转换：</p><br />
<br />
<p>两个不同指针类型的值，例如 int64和 float64。</p><br />
<br />
<p>指针类型和uintptr的值。<br />
但是借助unsafe.Pointer，我们可以打破Go类型和内存安全性，并使上面的转换成为可能。</p><br />
<br />
<p>unsafe包文档中列出的规则：</p><br />
<br />
<p>任何类型的指针值都可以转换为unsafe.Pointer。<br />
unsafe.Pointer可以转换为任何类型的指针值。<br />
uintptr可以转换为unsafe.Pointer。<br />
unsafe.Pointer可以转换为uintptr。<br />
这些规则与Go规范一致：</p><br />
<br />
<p>底层类型uintptr的任何指针或值都可以转换为指针类型，反之亦然。<br />
unsafe.Pointer其实就是类似C的void *，在golang中是用于各种指针相互转换的桥梁。uintptr是golang的内置类型，是能存储指针的整型，uintptr的底层类型是int，它和unsafe.Pointer可相互转换。uintptr和unsafe.Pointer的区别就是：unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象，uintptr类型的目标会被回收。golang的unsafe包很强大，基本上很少会去用它。它可以像C一样去操作内存，但由于golang不支持直接进行指针运算，所以用起来稍显麻烦。<br />
<!-- more --><br />
unsafe包提供了访问底层内存的方法。是用unsafe函数可以提高访问对象的速度。通常用于对大数组的遍历。<br />
unsafe内容介绍<br />
func Alignof(x ArbitraryType) uintptr<br />
func Offsetof(x ArbitraryType) uintptr<br />
func Sizeof(x ArbitraryType) uintptr<br />
type ArbitraryType int<br />
type Pointer *ArbitraryType</p><br />
<br />
<p>通过指针加偏移量的操作，在地址中，修改，访问变量的值</p><br />
<br />
<p>这个包中，只提供了3个函数，两个类型<br />
unsafe中，通过这两个个兼容万物的类型，将其他类型都转换过来，然后通过这三个函数，分别能取长度，偏移量，对齐字节数，就可以在内存地址映射中，来回游走。放在c语言中，是不是，只要给你一个起始地址，你就一下子干到底！！！在golang中，通过unsafe包，你也可以尽情的去放纵<br />
uintptr：用于指针运算，GC 不把 uintptr 当指针，uintptr 无法持有对象。uintptr 类型的目标会被回收。<br />
unsafe.Pointer 可以和 普通指针 进行相互转换。<br />
unsafe.Pointer 可以和 uintptr 进行相互转换。<br />
也就是说 unsafe.Pointer 是桥梁，可以让任意类型的指针实现相互转换，也可以将任意类型的指针转换为 uintptr 进行指针运算。<br />
详细说明</p><br />
<br />
<p>type ArbitraryType int</p><br />
<br />
<p>是int的一个别名，但是golang中，对ArbitraryType赋予了特殊的意义，</p><br />
<br />
<p>type Pointer *ArbitraryType</p><br />
<br />
<p>是int指针类型的一个别名，在golang系统中，可以把Pointer类型，理解成任何指针的亲爹。</p><br />
<br />
<p>func Alignof(x ArbitraryType) uintptr</p><br />
<br />
<p>Alignof返回变量对齐字节数量</p><br />
<br />
<p>func Offsetof(x ArbitraryType) uintptr</p><br />
<br />
<p>Offsetof返回变量指定属性的偏移量，这个函数虽然接收的是任何类型的变量，但是这个又一个前提，就是变量要是一个struct类型，且还不能直接将这个struct类型的变量当作参数，只能将这个struct类型变量的属性当作参数。</p><br />
<br />
<p>func Sizeof(x ArbitraryType) uintptr</p><br />
<br />
<p>Sizeof 返回变量在内存中占用的字节数，切记，如果是slice，则不会返回这个slice在内存中的实际占用长度。<br />
示例<br />
通过指针修改结构体字段<br />
package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “unsafe”<br />
)</p><br />
<br />
<p>func main() {<br />
    s := struct {<br />
        a byte<br />
        b byte<br />
        c byte<br />
        d int64<br />
    }{0, 0, 0, 0}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 将结构体指针转换为通用指针<br />
p := unsafe.Pointer(&amp;s)<br />
// 保存结构体的地址备用（偏移量为 0）<br />
up0 := uintptr(p)<br />
// 将通用指针转换为 byte 型指针<br />
pb := (*byte)(p)<br />
// 给转换后的指针赋值<br />
*pb = 10<br />
// 结构体内容跟着改变<br />
fmt.Println(s)<br />
<br />
// 偏移到第 2 个字段<br />
up := up0 + unsafe.Offsetof(s.b)<br />
// 将偏移后的地址转换为通用指针<br />
p = unsafe.Pointer(up)<br />
// 将通用指针转换为 byte 型指针<br />
pb = (*byte)(p)<br />
// 给转换后的指针赋值<br />
*pb = 20<br />
// 结构体内容跟着改变<br />
fmt.Println(s)<br />
<br />
// 偏移到第 3 个字段<br />
up = up0 + unsafe.Offsetof(s.c)<br />
// 将偏移后的地址转换为通用指针<br />
p = unsafe.Pointer(up)<br />
// 将通用指针转换为 byte 型指针<br />
pb = (*byte)(p)<br />
// 给转换后的指针赋值<br />
*pb = 30<br />
// 结构体内容跟着改变<br />
fmt.Println(s)<br />
<br />
// 偏移到第 4 个字段<br />
up = up0 + unsafe.Offsetof(s.d)<br />
// 将偏移后的地址转换为通用指针<br />
p = unsafe.Pointer(up)<br />
// 将通用指针转换为 int64 型指针<br />
pi := (*int64)(p)<br />
// 给转换后的指针赋值<br />
*pi = 40<br />
// 结构体内容跟着改变<br />
fmt.Println(s) }<br />
</code></pre></div></div><br />
<br />
<p>访问数组<br />
package main</p><br />
<br />
<p>import (<br />
     “fmt”<br />
     “unsafe”<br />
)</p><br />
<br />
<p>type Foo struct {<br />
     A int<br />
     B int<br />
}</p><br />
<br />
<p>func main() {<br />
     foo := &amp;Foo{1, 2}<br />
     fmt.Println(foo)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> base := uintptr(unsafe.Pointer(foo))<br />
 offset := unsafe.Offsetof(foo.A)<br />
<br />
 ptr := unsafe.Pointer(base + offset)<br />
 *(*int)(ptr) = 3<br />
<br />
 fmt.Println(foo) }<br />
</code></pre></div></div><br />
<br />
<p>修改其它包中的结构体私有字段<br />
方法A（指针遍历）<br />
package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “reflect”<br />
    “strings”<br />
    “unsafe”<br />
)</p><br />
<br />
<p>func main() {<br />
    // 创建一个 strings 包中的 Reader 对象<br />
    // 它有三个私有字段：s string、i int64、prevRune int<br />
    sr := strings.NewReader(“abcdef”)<br />
    // 此时 sr 中的成员是无法修改的<br />
    fmt.Println(sr)<br />
    // 但是我们可以通过 unsafe 来进行修改<br />
    // 先将其转换为通用指针<br />
    p := unsafe.Pointer(sr)<br />
    // 获取结构体地址<br />
    up0 := uintptr(p)<br />
    // 确定要修改的字段（这里不能用 unsafe.Offsetof 获取偏移量，因为是私有字段）<br />
    if sf, ok := reflect.TypeOf(<em>sr).FieldByName(“i”); ok {<br />
        // 偏移到指定字段的地址<br />
        up := up0 + sf.Offset<br />
        // 转换为通用指针<br />
        p = unsafe.Pointer(up)<br />
        // 转换为相应类型的指针<br />
        pi := (</em>int64)(p)<br />
        // 对指针所指向的内容进行修改<br />
        *pi = 3 // 修改索引<br />
    }<br />
    // 看看修改结果<br />
    fmt.Println(sr)<br />
    // 看看读出的是什么<br />
    b, err := sr.ReadByte()<br />
    fmt.Printf(“%c, %v\n”, b, err)<br />
}</p><br />
<br />
<p>方法B（类型转换）<br />
// 定义一个和 strings 包中的 Reader 相同的本地结构体<br />
type Reader struct {<br />
    s        string<br />
    i        int64<br />
    prevRune int<br />
}</p><br />
<br />
<p>func main() {<br />
    // 创建一个 strings 包中的 Reader 对象<br />
    sr := strings.NewReader(“abcdef”)<br />
    // 此时 sr 中的成员是无法修改的<br />
    fmt.Println(sr)<br />
    // 我们可以通过 unsafe 来进行修改<br />
    // 先将其转换为通用指针<br />
    p := unsafe.Pointer(sr)<br />
    // 再转换为本地 Reader 结构体<br />
    pR := (<em>Reader)(p)<br />
    // 这样就可以自由修改 sr 中的私有成员了<br />
    (</em>pR).i = 3 // 修改索引<br />
    // 看看修改结果<br />
    fmt.Println(sr)<br />
    // 看看读出的是什么<br />
    b, err := sr.ReadByte()<br />
    fmt.Printf(“%c, %v\n”, b, err)<br />
}</p><br />
<br />
<p>以下是标准库的描述：unsafe包提供了一些跳过go语言类型安全限制的操作。</p><br />
<br />
<p>API：<br />
该包里面只有一个文件unsafe.go和一堆声明，并没有具体的实现以及测试用例和例子。那我这里就把注释的信息简单翻一下。用作对该包的理解。</p><br />
<br />
<p>Unsafe包绕过了Go语言的安全限制。使用该包会导致你的程序无法移植。</p><br />
<br />
<p>// 该类型仅用于文档的目的，并不是真正unsafe包的一部分，它表示Go语言中的任意类型</p><br />
<br />
<p>type ArbitraryType int</p><br />
<br />
<p>Pointer类型是一个指向任何类型的指针类型。他有四种特殊的操作，这些操作其他类型不允许使用。</p><br />
<br />
<ol><br />
  <li><br />
    <p>任何类型的指针类型都可以转换为Pointer类型</p><br />
  </li><br />
  <li><br />
    <p>Pointer类型可以转换为任何类型的指针类型</p><br />
  </li><br />
  <li><br />
    <p>Uintptr类型值可以转换为Pointer类型</p><br />
  </li><br />
  <li><br />
    <p>Pointer类型可以转换为uintptr类型值</p><br />
  </li><br />
</ol><br />
<br />
<p>因此，通过Pointer类型，程序可以读写任意内存。使用时应该非常小心。</p><br />
<br />
<p>涉及到Pointer类型的，以下几种使用场景是有效的，其他场景均不号称支持。甚至在有效的这几个场景里面也有很多严格的限制。</p><br />
<br />
<p>场景1：将任意类型转换为Pointer类型然后转换为其他类型。T1-&gt;Pointer-&gt;T2</p><br />
<br />
<p>限制：T2不能长于T1，两种类型使用相同的内存布局方式。</p><br />
<br />
<p>这种转换允许一种类型转换为另外一种类型。例子如下（float64类型转换为uint64类型）</p><br />
<br />
<p>func Float64bits(f float64) uint64 {</p><br />
<br />
<p>return <em>(</em>uint64)(unsafe.Pointer(&amp;f))</p><br />
<br />
<p>}</p><br />
<br />
<p>场景2：将Pointer类型转换为uintptr类型（不返回指针类型）</p><br />
<br />
<p>将Pointer转换为uintptr类型，将会将内存地址作为int值进行保存。通常的用法是用于内存地址的打印。 通常情况下将一个uintptr的值转换为Pointer是无效的。</p><br />
<br />
<p>Uintptr是一个int类型的值并不是指针类型，将Pointer类型转换为Uintptr之后就丢失了指针的语义。即使uintptr包含了某个对象的地址，当该对象被移除的时候，垃圾回收器（GC）既不会更新uintptr的值，也不会因为uintptr值避免该对象被回收。</p><br />
<br />
<p>所以从uintptr到Pointer唯一有效的转换是枚举类型</p><br />
<br />
<p>场景3：将Pointer转换为uintptr，计算后返回</p><br />
<br />
<p>如果p是一个指向一个已分配的对象的Pointer对象，它可以通过如下方式进行偏移：</p><br />
<br />
<p>//将p转换为uintptr，加上一个偏移量之后转换为Pointer对象</p><br />
<br />
<p>p = unsafe.Pointer(uintptr(p) + offset)</p><br />
<br />
<p>最常见的使用方式是访问一个结构体的某一个字段或者数组的某一个元素。如下示例所示：</p><br />
<br />
<p>// 类似于 f := unsafe.Pointer(&amp;s.f)</p><br />
<br />
<p>f := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f))</p><br />
<br />
<p>// 类似于 e := unsafe.Pointer(&amp;x[i])</p><br />
<br />
<p>e := unsafe.Pointer(uintptr(unsafe.Pointer(&amp;x[0])) + i*unsafe.Sizeof(x[0]))</p><br />
<br />
<p>通过这种方式进行结构体的偏移是有效的，通过&amp;获取指针同样是有效的。任何情况下，返回的指针都必须指向原始分配的对象上。这一点与C不同，指针超过对象内存分配地址后是无效的。比如：</p><br />
<br />
<p>// 无效：因为end指针已经超出了s对象的申请空间</p><br />
<br />
<p>var s thing</p><br />
<br />
<p>end = unsafe.Pointer(uintptr(unsafe.Pointer(&amp;s)) + unsafe.Sizeof(s))</p><br />
<br />
<p>// 无效：原因同上</p><br />
<br />
<p>b := make([]byte, n)</p><br />
<br />
<p>end = unsafe.Pointer(uintptr(unsafe.Pointer(&amp;b[0])) + uintptr(n))</p><br />
<br />
<p>此外，需要注意的是，这种转换必须在同一个表达式中完成，并且中间只能包含int类型的运算符。比如：</p><br />
<br />
<p>// 无效：不能先存储后转换，必须在同一个表达式中完成该操作。</p><br />
<br />
<p>u := uintptr(p)</p><br />
<br />
<p>p = unsafe.Pointer(u + offset)</p><br />
<br />
<p>场景4：调用syscall.Syscall函数的时候从Pointer转换为uintptr</p><br />
<br />
<p>在syscall包中，包含这些uintptr参数的系统调用函数，在传入操作系统后有可能会将这些参数重新转换为指针类型（当然这依赖于系统函数的具体实现）。</p><br />
<br />
<p>也就是说有一些系统函数可以将传入的uintptr类型隐试的转换为指针对象并使用。</p><br />
<br />
<p>限制：这种Pointer类型向uintptr的转换必须要和syscall调用函数出现在同一条语句中。如下面实例：</p><br />
<br />
<p>syscall.Syscall(SYS_READ, uintptr(fd), uintptr(unsafe.Pointer(p)), uintptr(n))</p><br />
<br />
<p>这是为了避免调用时，指针指向的对象已经被释放了。如下示例就是无效的，存在对象被释放的风险。</p><br />
<br />
<p>u := uintptr(unsafe.Pointer(p))</p><br />
<br />
<p>syscall.Syscall(SYS_READ, uintptr(fd), u, uintptr(n))</p><br />
<br />
<p>场景5：将reflect.Value.Pointer或者reflect.Value.UnsafeAddr的结果从uintptr转换为Pointer类型</p><br />
<br />
<p>在reflect包中的Value.pointer和undafeaddr两个函数返回的都是uintptr来代替Pointer对象，以防止调用者在没有import unsafe包的情况下将该结果转换为任意类型。但是这就意味着这个结果必须在返回之前立刻转换为指针，否则该对象有被释放的风险。如下：</p><br />
<br />
<p>p := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))</p><br />
<br />
<p>// 下面这个示例是无效的，申请的对象有被GC回收的风险</p><br />
<br />
<p>u := reflect.ValueOf(new(int)).Pointer()</p><br />
<br />
<p>p := (*int)(unsafe.Pointer(u))</p><br />
<br />
<p>场景6：将一个reflect.SliceHeader 或 reflect.StringHeader的Data字段转换为Pointer（存疑，还没有理解）</p><br />
<br />
<p>和前面的例子一样，反射类型将结构体中的Data字段声明为uintptr，以防止在没有import unsafe之前就将该值转换为任意类型。但是这就意味着这两个类型只有在指向一个活动的切片或者字符串值的时候有效。</p><br />
<br />
<p>var s string</p><br />
<br />
<p>hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s)) // case 1</p><br />
<br />
<p>hdr.Data = uintptr(unsafe.Pointer(p)) // case 6 (this case)</p><br />
<br />
<p>hdr.Len = n</p><br />
<br />
<p>在这种用法中，hdr.Data实际上是指向字符串头的另外一种方式，而不是uintptr值本身。</p><br />
<br />
<p>通常情况下，reflect.SliceHeader and reflect.StringHeader这两个对象只有在下面这个情况下被使用，作为*reflect.SliceHeader and *reflect.StringHeader指针，指向一块切片或者字符串。</p><br />
<br />
<p>程序里面不应该声明这些对象，如下图：</p><br />
<br />
<p>//无效：直接声明，不会将Data信息保存为引用</p><br />
<br />
<p>var hdr reflect.StringHeader</p><br />
<br />
<p>hdr.Data = uintptr(unsafe.Pointer(p))</p><br />
<br />
<p>hdr.Len = n</p><br />
<br />
<p>s := <em>(</em>string)(unsafe.Pointer(&amp;hdr)) // p 有可能已经被回收</p><br />
<br />
<p>/*</p><br />
<br />
<p>Sizeof返回类型v本身数据所占用的字节数。返回值是“顶层”的数据占有的字节数。例如，若v是一个切片，它会返回该切片描述符的大小，而非该切片底层引用的内存的大小。</p><br />
<br />
<p>*/</p><br />
<br />
<p>func Sizeof（x ArbitraryType）uintptr</p><br />
<br />
<p>/*</p><br />
<br />
<p>Offsetof返回类型v所代表的结构体字段在结构体中的偏移量，它必须为结构体类型的字段的形式。换句话说，它返回该结构起始处与该字段起始处之间的字节数。</p><br />
<br />
<p>*/</p><br />
<br />
<p>func Offsetof(x ArbitraryType) uintptr</p><br />
<br />
<p>/*</p><br />
<br />
<p>Alignof返回类型v的对齐方式（即类型v在内存中占用的字节数）；若是结构体类型的字段的形式，它会返回字段f在该结构体中的对齐方式。</p><br />
<br />
<p>*/</p><br />
<br />
<p>func Alignof(x ArbitraryType) uintptr</p><br />
<br />
<p>Pointer与uintptr<br />
unsafe.Pointer在Golang中是用于各种类型转化的桥梁，Pointer代表了一个指向任意类型的指针。</p><br />
<br />
<p>uintptr是Golang的内置类型，是能存储指针的整型，uintptr的底层类型是int，它和unsafe.Pointer可相互转换。</p><br />
<br />
<p>Pointer与uintptr的区别在于：</p><br />
<br />
<p>unsafe.Pointer只是一个指针的类型，但是不能像C中的指针那样作计算，而只能用于转化不同类型的指针；如果unsafe.Pointer变量仍然有效，则由unsafe.Pointer变量表示的地址处的数据不会被GC回收；<br />
uintptr是可以用于指针运算的，但是无法持有对象，GC并不把uintptr当做指针，所以uintptr类型的目标会被回收。<br />
在Golang中出于安全的原因，不允许两个不同指针类型的值去直接转换；也不允许指针类型和uintptr的值去直接转换。但是借助unsafe.Pointer，我们</p><br />
<br />
<p>任何类型的指针值都可以转换为unsafe.Pointer；<br />
unsafe.Pointer可以转换为任何类型的指针值；<br />
uintptr可以转换为unsafe.Pointer；<br />
unsafe.Pointer可以转换为uintptr。<br />
例子<br />
通过unsafe.Pointer来转化类型<br />
在此之前提示一下这里我们说的类型的转化，是转化前后变量为同一变量，而不是这样为两个变量：</p><br />
<br />
<p>func main() {<br />
    var a int64 = 3<br />
    var b float64 = float64(a)<br />
    fmt.Println(&amp;a) // 0xc42000e248<br />
    fmt.Println(&amp;b) // 0xc42000e250<br />
} <br /><br />
如果我们要来做一个强制的转化的话，a = float64(a),Golang会报错：cannot use float64(a) (type float64) as type int64 in assignment。</p><br />
<br />
<p>使用unsafe.Pointer来将T1转化为T2，一个大致的语法为<em>(</em>T2)(unsafe.Pointer(&amp;t1))</p><br />
<br />
<p>func main() {<br />
    var n int64 = 3<br />
    var pn = &amp;n // n的指针<br />
    var pf = (<em>float64)(unsafe.Pointer(pn)) // 通过Pointer来将n的类型转为float<br />
    fmt.Println(</em>pf) // 2.5e-323<br />
    *pf = 3.5<br />
    fmt.Println(n) // 4615063718147915776</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fmt.Println(pf) // 0xc42007a050<br />
fmt.Println(pn) // 0xc42007a050 } 这个例子虽然没有实际的意义，但是绕过了Golang类型系统和内存安全，将一个变量的类型作了转化。<br />
</code></pre></div></div><br />
<br />
<p>通过uintptr来计算偏移量<br />
我们知道在Golang中指针是不能用来计算的，但是借助uintptr我们可以作计算：</p><br />
<br />
<p>func main() {<br />
    a := [4]int{0, 1, 2, 3}<br />
    p1 := unsafe.Pointer(&amp;a[1]) // index为1的元素<br />
    p3 := unsafe.Pointer(uintptr(p1) + 2 * unsafe.Sizeof(a[0])) // 拿到index为3的指针<br />
    <em>(</em>int)(p3) = 4 // 重新赋值<br />
    fmt.Println(a) // a = [0 1 2 4]<br />
}<br />
同样的对于一个结构体我们也可以通过增减偏移量来定位不同的成员变量，其依赖的注意思想是：结构体的成员在内存中的分配是一段连续的内存，结构体中第一个成员的地址就是这个结构体的地址：</p><br />
<br />
<p>type Person struct {<br />
    name   string<br />
    age    int<br />
}</p><br />
<br />
<p>func main() {<br />
    a := Person{“Jasper”, 27}<br />
    pa := unsafe.Pointer(&amp;a)<br />
    aname := (<em>string)(unsafe.Pointer(uintptr(pa) + unsafe.Offsetof(a.name))) // pname := (</em>string)(unsafe.Pointer(uintptr(pa))) 这样也是可以的<br />
    aage := (*int)(unsafe.Pointer(uintptr(pa) + unsafe.Offsetof(a.age)))<br />
    *aname = “Jasper2”<br />
    *aage = 28<br />
    fmt.Println(a) // {Jasper2 28}<br />
} <br /><br />
应用<br />
上面给的例子都是一些概念上的，没有太多的实际意义，那么在实际的应用中，我们有有哪些地方是可以或者必须借助Pointer与uintptr来实现的呢，下面我们来看一些例子。</p><br />
<br />
<p>string与[]byte相互转换<br />
我们在写程序的时候会经常遇到string与[]byte相互转换的情况，这种转化其实代价很高，因为string与[]byte的内存空间不共享，所以每次转换都伴随着内存的分配与底层字节的拷贝。而我们使用unsafe就可以避开这些，从而提升性能。</p><br />
<br />
<p>func string2byte(s string) []byte {<br />
    sh := (<em>reflect.StringHeader)(unsafe.Pointer(&amp;s))<br />
    bh := reflect.SliceHeader{<br />
        Data: sh.Data,<br />
        Len:  sh.Len,<br />
        Cap:  sh.Len,<br />
    }<br />
    return *(</em>[]byte)(unsafe.Pointer(&amp;bh))<br />
}</p><br />
<br />
<p>func byte2string(b []byte) string{<br />
    bh := (<em>reflect.SliceHeader)(unsafe.Pointer(&amp;b))<br />
    sh := reflect.StringHeader{<br />
        Data: bh.Data,<br />
        Len:  bh.Len,<br />
    }<br />
    return *(</em>string)(unsafe.Pointer(&amp;sh))<br />
}<br />
这样的转化过程依赖于二者的数据结构：</p><br />
<br />
<p>struct string{<br />
    uint8 *str;<br />
    int len;<br />
  }</p><br />
<br />
<p>struct []uint8{<br />
    uint8 *array;<br />
    int len;<br />
    int cap;<br />
  }<br /><br />
注意，这样虽然可以实现，但强烈推荐不要使用这种方法来转换类型，因为这样会导致修改转化过后的值会影响之前的变量。</p><br />
<br />
<p>修改私有成员变量<br />
在Golang中对于不在同一个package里面的对象的私有变量(小写的)是不能直接修改的，但是使用unsafe可以做到：</p><br />
<br />
<p>package p</p><br />
<br />
<p>import (<br />
    “fmt”<br />
)</p><br />
<br />
<p>type V struct {<br />
    i int32<br />
    j int64<br />
}</p><br />
<br />
<p>func (this V) PrintI() {<br />
    fmt.Printf(“i=%d\n”, this.i)<br />
}</p><br />
<br />
<p>func (this V) PrintJ() {<br />
    fmt.Printf(“j=%d\n”, this.j)<br />
}<br />
我们在mian里面实现来直接修改i,j的值：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “p”<br />
    “unsafe”<br />
)</p><br />
<br />
<p>func main() {<br />
    var v <em>p.V = new(p.V)<br />
    var i *int32 = (</em>int32)(unsafe.Pointer(v))<br />
    <em>i = int32(1)<br />
    var j *int64 = (</em>int64)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) +unsafe.Sizeof(int32(0))))<br />
    *j = int64(2)<br />
    v.PrintI()<br />
    v.PrintJ()<br />
}<br />
其实在上面用uintptr计算偏移量介绍的那样，这样可以达到修改私有变量的目的。虽然达到了目的，但是在开发中其实并不建议这么干。</p><br />
<br />
<p>在反射中使用<br />
reflect包中Value类型的方法中名称为Pointer和UnsafeAddr的方法的返回值类型是uintptr而不是unsafe.Pointer,目的是为了使调用者可以将结果转为任意类型而不用导入unsafe包。然而，这意味着调用结果必须马上再调用完成后转为Pointer,并且是在同一个表达式中完成；如下：</p><br />
<br />
<p>p := (*int)(unsafe.Pointer(reflect.ValueOf(new(int)).Pointer()))</p><br />
<br />
<p>The unsafe Package in Golang<br />
Golang的unsafe包是一个很特殊的包。 为什么这样说呢？ 本文将详细解释。</p><br />
<br />
<p>来自go语言官方文档的警告<br />
unsafe包的文档是这么说的：</p><br />
<br />
<p>导入unsafe的软件包可能不可移植，并且不受Go 1兼容性指南的保护。<br />
Go 1 兼容性指南这么说：</p><br />
<br />
<p>导入unsafe软件包可能取决于Go实现的内部属性。 我们保留对可能导致程序崩溃的实现进行更改的权利。<br />
当然包名称暗示unsafe包是不安全的。 但这个包有多危险呢？ 让我们先看看unsafe包的作用。</p><br />
<br />
<p>Unsafe包的作用<br />
直到现在（Go1.7），unsafe包含以下资源：</p><br />
<br />
<p>三个函数：</p><br />
<br />
<p>func Alignof（variable ArbitraryType）uintptr<br />
func Offsetof（selector ArbitraryType）uintptr<br />
func Sizeof（variable ArbitraryType）uintptr<br />
和一种类型：</p><br />
<br />
<p>类型Pointer * ArbitraryType<br />
这里，ArbitraryType不是一个真正的类型，它只是一个占位符。</p><br />
<br />
<p>与Golang中的大多数函数不同，上述三个函数的调用将始终在编译时求值，而不是运行时。 这意味着它们的返回结果可以分配给常量。</p><br />
<br />
<p>（BTW，unsafe包中的函数中非唯一调用将在编译时求值。当传递给len和cap的参数是一个数组值时，内置函数和cap函数的调用也可以在编译时被求值。）</p><br />
<br />
<p>除了这三个函数和一个类型外，指针在unsafe包也为编译器服务。</p><br />
<br />
<p>出于安全原因，Golang不允许以下之间的直接转换：</p><br />
<br />
<p>两个不同指针类型的值，例如 int64和 float64。</p><br />
<br />
<p>指针类型和uintptr的值。<br />
但是借助unsafe.Pointer，我们可以打破Go类型和内存安全性，并使上面的转换成为可能。这怎么可能发生？让我们阅读unsafe包文档中列出的规则：</p><br />
<br />
<p>任何类型的指针值都可以转换为unsafe.Pointer。<br />
unsafe.Pointer可以转换为任何类型的指针值。<br />
uintptr可以转换为unsafe.Pointer。<br />
unsafe.Pointer可以转换为uintptr。<br />
这些规则与Go规范一致：</p><br />
<br />
<p>底层类型uintptr的任何指针或值都可以转换为指针类型，反之亦然。<br />
规则表明unsafe.Pointer类似于c语言中的void 。当然，void 在C语言里是危险的！</p><br />
<br />
<p>在上述规则下，对于两种不同类型T1和T2，可以使 T1值与unsafe.Pointer值一致，然后将unsafe.Pointer值转换为 T2值（或uintptr值）。通过这种方式可以绕过Go类型系统和内存安全性。当然，滥用这种方式是很危险的。</p><br />
<br />
<p>举个例子：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “unsafe”<br />
)<br />
func main() {<br />
    var n int64 = 5<br />
    var pn = &amp;n<br />
    var pf = (<em>float64)(unsafe.Pointer(pn))<br />
    // now, pn and pf are pointing at the same memory address<br />
    fmt.Println(</em>pf) // 2.5e-323<br />
    *pf = 3.14159<br />
    fmt.Println(n) // 4614256650576692846<br />
}<br />
在这个例子中的转换可能是无意义的，但它是安全和合法的（为什么它是安全的？）。</p><br />
<br />
<p>因此，资源在unsafe包中的作用是为Go编译器服务，unsafe.Pointer类型的作用是绕过Go类型系统和内存安全。</p><br />
<br />
<p>再来一点 unsafe.Pointer 和 uintptr<br />
这里有一些关于unsafe.Pointer和uintptr的事实：</p><br />
<br />
<p>uintptr是一个整数类型。<br />
即使uintptr变量仍然有效，由uintptr变量表示的地址处的数据也可能被GC回收。<br />
unsafe.Pointer是一个指针类型。<br />
但是unsafe.Pointer值不能被取消引用。<br />
如果unsafe.Pointer变量仍然有效，则由unsafe.Pointer变量表示的地址处的数据不会被GC回收。<br />
unsafe.Pointer是一个通用的指针类型，就像* int等。<br />
由于uintptr是一个整数类型，uintptr值可以进行算术运算。 所以通过使用uintptr和unsafe.Pointer，我们可以绕过限制，* T值不能在Golang中计算偏移量：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “unsafe”<br />
)</p><br />
<br />
<p>func main() {<br />
    a := [4]int{0, 1, 2, 3}<br />
    p1 := unsafe.Pointer(&amp;a[1])<br />
    p3 := unsafe.Pointer(uintptr(p1) + 2 * unsafe.Sizeof(a[0]))<br />
    <em>(</em>int)(p3) = 6<br />
    fmt.Println(“a =”, a) // a = [0 1 2 6]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ...<br />
<br />
type Person struct {<br />
    name   string<br />
    age    int<br />
    gender bool<br />
}<br />
<br />
who := Person{"John", 30, true}<br />
pp := unsafe.Pointer(&amp;who)<br />
pname := (*string)(unsafe.Pointer(uintptr(pp) + unsafe.Offsetof(who.name)))<br />
page := (*int)(unsafe.Pointer(uintptr(pp) + unsafe.Offsetof(who.age)))<br />
pgender := (*bool)(unsafe.Pointer(uintptr(pp) + unsafe.Offsetof(who.gender)))<br />
*pname = "Alice"<br />
*page = 28<br />
*pgender = false<br />
fmt.Println(who) // {Alice 28 false} } unsafe包有多危险 关于unsafe包，Ian，Go团队的核心成员之一，已经确认：<br />
</code></pre></div></div><br />
<br />
<p>在unsafe包中的函数的签名将不会在以后的Go版本中更改，</p><br />
<br />
<p>并且unsafe.Pointer类型将在以后的Go版本中始终存在。<br />
所以，unsafe包中的三个函数看起来不危险。 go team leader甚至想把它们放在别的地方。 unsafe包中这几个函数唯一不安全的是它们调用结果可能在后来的版本中返回不同的值。 很难说这种不安全是一种危险。</p><br />
<br />
<p>看起来所有的unsafe包的危险都与使用unsafe.Pointer有关。 unsafe包docs列出了一些使用unsafe.Pointer合法或非法的情况。 这里只列出部分非法使用案例：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “unsafe”<br />
)</p><br />
<br />
<p>// case A: conversions between unsafe.Pointer and uintptr <br />
//         don’t appear in the same expression<br />
func illegalUseA() {<br />
    fmt.Println(“===================== illegalUseA”)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pa := new([4]int)<br />
<br />
// split the legal use<br />
// p1 := unsafe.Pointer(uintptr(unsafe.Pointer(pa)) + unsafe.Sizeof(pa[0]))<br />
// into two expressions (illegal use):<br />
ptr := uintptr(unsafe.Pointer(pa))<br />
p1 := unsafe.Pointer(ptr + unsafe.Sizeof(pa[0]))<br />
// "go vet" will make a warning for the above line:<br />
// possible misuse of unsafe.Pointer<br />
<br />
// the unsafe package docs, https://golang.org/pkg/unsafe/#Pointer,<br />
// thinks above splitting is illegal.<br />
// but the current Go compiler and runtime (1.7.3) can't detect<br />
// this illegal use.<br />
// however, to make your program run well for later Go versions,<br />
// it is best to comply with the unsafe package docs.<br />
<br />
*(*int)(p1) = 123<br />
fmt.Println("*(*int)(p1)  :", *(*int)(p1)) // }    <br />
</code></pre></div></div><br />
<br />
<p>// case B: pointers are pointing at unknown addresses<br />
func illegalUseB() {<br />
    fmt.Println(“===================== illegalUseB”)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a := [4]int{0, 1, 2, 3}<br />
p := unsafe.Pointer(&amp;a)<br />
p = unsafe.Pointer(uintptr(p) + uintptr(len(a)) * unsafe.Sizeof(a[0]))<br />
// now p is pointing at the end of the memory occupied by value a.<br />
// up to now, although p is invalid, it is no problem.<br />
// but it is illegal if we modify the value pointed by p<br />
*(*int)(p) = 123<br />
fmt.Println("*(*int)(p)  :", *(*int)(p)) // 123 or not 123<br />
// the current Go compiler/runtime (1.7.3) and "go vet" <br />
// will not detect the illegal use here.<br />
<br />
// however, the current Go runtime (1.7.3) will <br />
// detect the illegal use and panic for the below code.<br />
p = unsafe.Pointer(&amp;a)<br />
for i := 0; i &lt;= len(a); i++ {<br />
    *(*int)(p) = 123 // Go runtime (1.7.3) never panic here in the tests<br />
<br />
    fmt.Println(i, ":", *(*int)(p))<br />
    // panic at the above line for the last iteration, when i==4.<br />
    // runtime error: invalid memory address or nil pointer dereference<br />
<br />
    p = unsafe.Pointer(uintptr(p) + unsafe.Sizeof(a[0]))<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>func main() {<br />
    illegalUseA()<br />
    illegalUseB()<br />
}<br />
编译器很难检测Go程序中非法的unsafe.Pointer使用。 运行“go vet”可以帮助找到一些潜在的错误，但不是所有的都能找到。 同样是Go运行时，也不能检测所有的非法使用。 非法unsafe.Pointer使用可能会使程序崩溃或表现得怪异（有时是正常的，有时是异常的）。 这就是为什么使用不安全的包是危险的。</p><br />
<br />
<p>转换T1 为 T2<br />
对于将 T1转换为unsafe.Pointer，然后转换为 T2，unsafe包docs说：</p><br />
<br />
<p>如果T2比T1大，并且两者共享等效内存布局，则该转换允许将一种类型的数据重新解释为另一类型的数据。<br />
这种“等效内存布局”的定义是有一些模糊的。 看起来go团队故意如此。 这使得使用unsafe包更危险。</p><br />
<br />
<p>由于Go团队不愿意在这里做出准确的定义，本文也不尝试这样做。 这里，列出了已确认的合法用例的一小部分，</p><br />
<br />
<p>合法用例1：在[]T和[]MyT之间转换<br />
在这个例子里，我们用int作为T：</p><br />
<br />
<p>type MyInt int<br />
在Golang中，[] int和[] MyInt是两种不同的类型，它们的底层类型是自身。 因此，[] int的值不能转换为[] MyInt，反之亦然。 但是在unsafe.Pointer的帮助下，转换是可能的：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “unsafe”<br />
)</p><br />
<br />
<p>func main() {<br />
    type MyInt int</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a := []MyInt{0, 1, 2}<br />
// b := ([]int)(a) // error: cannot convert a (type []MyInt) to type []int<br />
b := *(*[]int)(unsafe.Pointer(&amp;a))<br />
<br />
b[0]= 3<br />
<br />
fmt.Println("a =", a) // a = [3 1 2]<br />
fmt.Println("b =", b) // b = [3 1 2]<br />
<br />
a[2] = 9<br />
<br />
fmt.Println("a =", a) // a = [3 1 9]<br />
fmt.Println("b =", b) // b = [3 1 9] } 合法用例2: 调用sync/atomic包中指针相关的函数 sync / atomic包中的以下函数的大多数参数和结果类型都是unsafe.Pointer或*unsafe.Pointer：<br />
</code></pre></div></div><br />
<br />
<p>func CompareAndSwapPointer（addr * unsafe.Pointer，old，new unsafe.Pointer）（swapped bool）<br />
func LoadPointer（addr * unsafe.Pointer）（val unsafe.Pointer）<br />
func StorePointer（addr * unsafe.Pointer，val unsafe.Pointer）<br />
func SwapPointer（addr * unsafe.Pointer，new unsafe.Pointer）（old unsafe.Pointer）<br />
要使用这些功能，必须导入unsafe包。 注意： unsafe.Pointer是一般类型，因此 unsafe.Pointer的值可以转换为unsafe.Pointer，反之亦然。</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “log”<br />
    “time”<br />
    “unsafe”<br />
    “sync/atomic”<br />
    “sync”<br />
    “math/rand”<br />
)</p><br />
<br />
<p>var data *string</p><br />
<br />
<p>// get data atomically<br />
func Data() string {<br />
    p := (<em>string)(atomic.LoadPointer(<br />
            (</em>unsafe.Pointer)(unsafe.Pointer(&amp;data)),<br />
        ))<br />
    if p == nil {<br />
        return “”<br />
    } else {<br />
        return *p<br />
    }<br />
}</p><br />
<br />
<p>// set data atomically<br />
func SetData(d string) {<br />
    atomic.StorePointer(<br />
            (*unsafe.Pointer)(unsafe.Pointer(&amp;data)), <br />
            unsafe.Pointer(&amp;d),<br />
        )<br />
}</p><br />
<br />
<p>func main() {<br />
    var wg sync.WaitGroup<br />
    wg.Add(200)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for range [100]struct{}{} {<br />
    go func() {<br />
        time.Sleep(time.Second * time.Duration(rand.Intn(1000)) / 1000)<br />
<br />
        log.Println(Data())<br />
        wg.Done()<br />
    }()<br />
}<br />
<br />
for i := range [100]struct{}{} {<br />
    go func(i int) {<br />
        time.Sleep(time.Second * time.Duration(rand.Intn(1000)) / 1000)<br />
        s := fmt.Sprint("#", i)<br />
        log.Println("====", s)<br />
<br />
        SetData(s)<br />
        wg.Done()<br />
    }(i)<br />
}<br />
<br />
wg.Wait()<br />
<br />
fmt.Println("final data = ", *data) } 结论 unsafe包用于Go编译器，而不是Go运行时。 使用unsafe作为程序包名称只是让你在使用此包是更加小心。 使用unsafe.Pointer并不总是一个坏主意，有时我们必须使用它。 Golang的类型系统是为了安全和效率而设计的。 但是在Go类型系统中，安全性比效率更重要。 通常Go是高效的，但有时安全真的会导致Go程序效率低下。 unsafe包用于有经验的程序员通过安全地绕过Go类型系统的安全性来消除这些低效。 unsafe包可能被滥用并且是危险的。<br />
</code></pre></div></div><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>