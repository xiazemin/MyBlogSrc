<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">mutex</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-04-22T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 22, 2019</time></p>
					</div>
					 <p>二. golang 最新版本的 sync.Mutex</p><br />
<br />
<p>你可以大致扫描一下最新版本的实现，如果你第一眼就看的很懂了，每步的操作？为什么这样操作？有没有更加合理的操作？那恭喜你，你的水平已经超过google实现 sync.Mutex 的程序员了，甚至是大部分的程序员，因为这个程序历经几年的演化，才到了今天的样子，你第一眼就能看的如此透彻，那真的是很了不起。下面的章节是为没有看懂的人准备的。</p><br />
<br />
<p>// Copyright 2009 The Go Authors. All rights reserved.<br />
// Use of this source code is governed by a BSD-style<br />
// license that can be found in the LICENSE file.</p><br />
<br />
<p>// Package sync provides basic synchronization primitives such as mutual<br />
// exclusion locks.  Other than the Once and WaitGroup types, most are intended<br />
// for use by low-level library routines.  Higher-level synchronization is<br />
// better done via channels and communication.<br />
//<br />
// Values containing the types defined in this package should not be copied.<br />
package sync</p><br />
<br />
<p>import (<br />
    “sync/atomic”<br />
    “unsafe”<br />
)</p><br />
<br />
<p>// A Mutex is a mutual exclusion lock.<br />
// Mutexes can be created as part of other structures;<br />
// the zero value for a Mutex is an unlocked mutex.<br />
type Mutex struct {<br />
    state int32<br />
    sema  uint32<br />
}</p><br />
<br />
<p>// A Locker represents an object that can be locked and unlocked.<br />
type Locker interface {<br />
    Lock()<br />
    Unlock()<br />
}</p><br />
<br />
<p>const (<br />
    mutexLocked = 1 « iota // mutex is locked<br />
    mutexWoken<br />
    mutexWaiterShift = iota<br />
)</p><br />
<br />
<p>// Lock locks m.<br />
// If the lock is already in use, the calling goroutine<br />
// blocks until the mutex is available.<br />
func (m *Mutex) Lock() {<br />
    // Fast path: grab unlocked mutex.<br />
    if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {<br />
        if raceenabled {<br />
            raceAcquire(unsafe.Pointer(m))<br />
        }<br />
        return<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>awoke := false<br />
for {<br />
    old := m.state<br />
    new := old | mutexLocked<br />
    if old&amp;mutexLocked != 0 {<br />
        new = old + 1&lt;&lt;mutexWaiterShift<br />
    }<br />
    if awoke {<br />
        // The goroutine has been woken from sleep,<br />
        // so we need to reset the flag in either case.<br />
        new &amp;^= mutexWoken<br />
    }<br />
    if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {<br />
        if old&amp;mutexLocked == 0 {<br />
            break<br />
        }<br />
        runtime_Semacquire(&amp;m.sema)<br />
        awoke = true<br />
    }<br />
}<br />
<br />
if raceenabled {<br />
    raceAcquire(unsafe.Pointer(m))<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>// Unlock unlocks m.<br />
// It is a run-time error if m is not locked on entry to Unlock.<br />
//<br />
// A locked Mutex is not associated with a particular goroutine.<br />
// It is allowed for one goroutine to lock a Mutex and then<br />
// arrange for another goroutine to unlock it.<br />
func (m *Mutex) Unlock() {<br />
    if raceenabled {<br />
        _ = m.state<br />
        raceRelease(unsafe.Pointer(m))<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Fast path: drop lock bit.<br />
new := atomic.AddInt32(&amp;m.state, -mutexLocked)<br />
if (new+mutexLocked)&amp;mutexLocked == 0 {<br />
    panic("sync: unlock of unlocked mutex")<br />
}<br />
<br />
old := new<br />
for {<br />
    // If there are no waiters or a goroutine has already<br />
    // been woken or grabbed the lock, no need to wake anyone.<br />
    if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken) != 0 {<br />
        return<br />
    }<br />
    // Grab the right to wake someone.<br />
    new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken<br />
    if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {<br />
        runtime_Semrelease(&amp;m.sema)<br />
        return<br />
    }<br />
    old = m.state<br />
} } 三. 有没有更加简洁的实现方法？<br />
</code></pre></div></div><br />
<br />
<p>有点操作系统知识的都知道，独占锁是一种特殊的PV 操作，就 0 – 1 PV操作。那我想，如果不考虑任何性能问题的话，用信号量应该就可以这样实现Mutex：</p><br />
<br />
<p>type Mutex struct {<br />
    sema uint32<br />
}</p><br />
<br />
<p>func NewMutex() *Mutex {<br />
    var mu Mutex<br />
    mu.sema = 1<br />
    return &amp;mu<br />
}</p><br />
<br />
<p>func (m *Mutex) Lock() {<br />
        runtime_Semacquire(&amp;m.sema)<br />
}</p><br />
<br />
<p>func (m *Mutex2) Unlock() {<br />
    runtime_Semrelease(&amp;m.sema)<br />
}<br />
当然，这个实现有点不符合要求。如果有个家伙不那么靠谱，加锁了一次，但是解锁了两次。第二次解锁的时候，应该报出一个错误，而不是让错误隐藏。于是乎，我们想到用一个变量表示加锁的次数。这样就可以判断有没有多次解锁。于是乎，我就想到了下面的解决方案：</p><br />
<br />
<p>type Mutex struct {<br />
        key  int32<br />
        sema uint32<br />
}</p><br />
<br />
<p>func (m *Mutex) Lock() {<br />
        if atomic.AddInt32(&amp;m.key, 1) == 1 {<br />
                // changed from 0 to 1; we hold lock<br />
                return<br />
        }<br />
        runtime_Semacquire(&amp;m.sema)<br />
}</p><br />
<br />
<p>func (m *Mutex) Unlock() {<br />
        switch v := atomic.AddInt32(&amp;m.key, -1); {<br />
        case v == 0:<br />
                // changed from 1 to 0; no contention<br />
                return<br />
        case v == -1:<br />
                // changed from 0 to -1: wasn’t locked<br />
                // (or there are 4 billion goroutines waiting)<br />
                panic(“sync: unlock of unlocked mutex”)<br />
        }<br />
        runtime_Semrelease(&amp;m.sema)<br />
}<br />
这个解决方案除了解决了我们前面说的重复加锁的问题外，还对我们初始化工作做了简化，不需要构造函数了。注意，这也是golang里面一个常见的设计模式，叫做 零初始化。</p><br />
<br />
<p>表示多线程复杂状态，最好的办法就是抽象出 状态 和 操作，忽略掉线程，让问题变成一个状态机问题。这样的图不仅仅用于分析Mutex<br />
<!-- more --><br />
Mutex can be in 2 modes of operations: normal and starvation.<br />
 In normal mode waiters are queued in FIFO order, but a woken up waiter does not own the mutex and competes with new arriving goroutines over the ownership. New arriving goroutines have an advantage – they are already running on CPU and there can be lots of them, so a woken up waiter has good chances of losing. In such case it is queued at front of the wait queue. If a waiter fails to acquire the mutex for more than 1ms, it switches mutex to the starvation mode.</p><br />
<br />
<p>In starvation mode ownership of the mutex is directly handed off from the unlocking goroutine to the waiter at the front of the queue. New arriving goroutines don’t try to acquire the mutex even if it appears  to be unlocked, and don’t try to spin. Instead they queue themselves at  the tail of the wait queue.</p><br />
<br />
<p>If a waiter receives ownership of the mutex and sees that either (1) it is the last waiter in the queue, or (2) it waited for less than 1 ms, it switches mutex back to normal operation mode.</p><br />
<br />
<p>Normal mode has considerably better performance as a goroutine can acquire a mutex several times in a row even if there are blocked waiters.<br />
Starvation mode is important to prevent pathological cases of tail latency.</p><br />
<br />
<p>互斥量可分为两种操作模式:正常和饥饿。<br />
在正常模式下，等待的goroutines按照FIFO（先进先出）顺序排队，但是goroutine被唤醒之后并不能立即得到mutex锁，它需要与新到达的goroutine争夺mutex锁。<br />
因为新到达的goroutine已经在CPU上运行了，所以被唤醒的goroutine很大概率是争夺mutex锁是失败的。出现这样的情况时候，被唤醒的goroutine需要排队在队列的前面。<br />
如果被唤醒的goroutine有超过1ms没有获取到mutex锁，那么它就会变为饥饿模式。<br />
在饥饿模式中，mutex锁直接从解锁的goroutine交给队列前面的goroutine。新达到的goroutine也不会去争夺mutex锁（即使没有锁，也不能去自旋），而是到等待队列尾部排队。<br />
在饥饿模式下，有一个goroutine获取到mutex锁了，如果它满足下条件中的任意一个，mutex将会切换回去正常模式：</p><br />
<ol><br />
  <li>是等待队列中的最后一个goroutine</li><br />
  <li>它的等待时间不超过1ms。<br />
正常模式有更好的性能，因为goroutine可以连续多次获得mutex锁；<br />
饥饿模式对于预防队列尾部goroutine一致无法获取mutex锁的问题。</li><br />
</ol><br />
<br />
<p>Mutex struct {<br />
	state int32    // 将一个32位整数拆分为 当前阻塞的goroutine数(29位)|饥饿状态(1位)|唤醒状态(1位)|锁状态(1位) 的形式，来简化字段设计<br />
	sema  uint32   // 信号量<br />
}</p><br />
<br />
<p>const (<br />
	mutexLocked = 1 « iota      // 1 0001 含义：用最后一位表示当前对象锁的状态，0-未锁住 1-已锁住<br />
	mutexWoken                   // 2 0010 含义：用倒数第二位表示当前对象是否被唤醒 0-唤醒 1-未唤醒<br />
	mutexStarving                // 4 0100 含义：用倒数第三位表示当前对象是否为饥饿模式，0为正常模式，1为饥饿模式。<br />
	mutexWaiterShift = iota      // 3，从倒数第四位往前的bit位表示在排队等待的goroutine数<br />
	starvationThresholdNs = 1e6  // 1ms</p><br />
<br />
<p>可以看到Mutex中含有：</p><br />
<br />
<p>一个非负数信号量sema；<br />
state表示Mutex的状态。<br />
常量：</p><br />
<br />
<p>mutexLocked表示锁是否可用（0可用，1被别的goroutine占用）<br />
mutexWoken=2表示mutex是否被唤醒<br />
mutexWaiterShift=4表示统计阻塞在该mutex上的goroutine数目需要移位的数值。<br />
将3个常量映射到state上就是</p><br />
<br />
<p>state:   |32|31|…| |3|2|1|<br />
         _<strong>__</strong>___/ | | |<br />
              |       | | |<br />
              |       | |  mutex的占用状态（1被占用，0可用）<br />
              |       | |<br />
              |       |  mutex的当前goroutine是否被唤醒<br />
              |       |<br />
              |       饥饿位，0正常，1饥饿<br />
              |<br />
               等待唤醒以尝试锁定的goroutine的计数，0表示没有等待者<br />
如果同学们熟悉Java的锁，就会发现与AQS的设计是类似，只是没有AQS设计的那么精致，不得不感叹，JAVA的牛逼。 有同学是否会有疑问为什么使用的是int32而不是int64呢，因为32位原子性操作更好,当然也满足的需求。</p><br />
<br />
<p>Mutex在1.9版本中就两个函数Lock()和Unlock()。 下面我们先来分析最难的Lock()函数：</p><br />
<br />
<p>func (m *Mutex) Lock() {<br />
	// 如果m.state=0，说明当前的对象还没有被锁住，进行原子性赋值操作设置为mutexLocked状态，CompareAnSwapInt32返回true<br />
	// 否则说明对象已被其他goroutine锁住，不会进行原子赋值操作设置，CopareAndSwapInt32返回false<br />
	if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) <br />
		if race.Enabled {<br />
			race.Acquire(unsafe.Pointer(m))<br />
		}<br />
		return<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 开始等待时间戳<br />
var waitStartTime int64<br />
// 饥饿模式标识<br />
starving := false<br />
// 唤醒标识<br />
awoke := false<br />
// 自旋次数<br />
iter := 0<br />
// 保存当前对象锁状态<br />
old := m.state<br />
// 看到这个for {}说明使用了cas算法<br />
for {<br />
	// 相当于xxxx...x0xx &amp; 0101 = 01，当前对象锁被使用<br />
	if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; <br />
		// 判断当前goroutine是否可以进入自旋锁<br />
		runtime_canSpin(iter) {<br />
			<br />
	    // 主动旋转是有意义的。试着设置mutexwake标志，告知解锁，不要唤醒其他阻塞的goroutines。<br />
		if !awoke &amp;&amp;<br />
		// 再次确定是否被唤醒： xxxx...xx0x &amp; 0010 = 0<br />
		old&amp;mutexWoken == 0 &amp;&amp;<br />
		// 查看是否有goroution在排队<br />
		old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;<br />
			// 将对象锁改为唤醒状态：xxxx...xx0x | 0010 = xxxx...xx1x <br />
			atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {<br />
			awoke = true<br />
		}//END_IF_Lock<br />
		<br />
		// 进入自旋锁后当前goroutine并不挂起，仍然在占用cpu资源，所以重试一定次数后，不会再进入自旋锁逻辑<br />
		runtime_doSpin()<br />
		// 自加，表示自旋次数<br />
		iter++<br />
		// 保存mutex对象即将被设置成的状态<br />
		old = m.state<br />
		continue<br />
	}// END_IF_spin<br />
	<br />
	// 以下代码是不使用**自旋**的情况<br />
	new := old<br />
	<br />
	// 不要试图获得饥饿的互斥，新来的goroutines必须排队。<br />
	// 对象锁饥饿位被改变，说明处于饥饿模式<br />
	// xxxx...x0xx &amp; 0100 = 0xxxx...x0xx<br />
	if old&amp;mutexStarving == 0 {<br />
		// xxxx...x0xx | 0001 = xxxx...x0x1，标识对象锁被锁住<br />
		new |= mutexLocked<br />
	}<br />
	// xxxx...x1x1 &amp; (0001 | 0100) =&gt; xxxx...x1x1 &amp; 0101 != 0;当前mutex处于饥饿模式并且锁已被占用，新加入进来的goroutine放到队列后面<br />
	if old&amp;(mutexLocked|mutexStarving) != 0 {<br />
		// 更新阻塞goroutine的数量,表示mutex的等待goroutine数目加1<br />
		new += 1 &lt;&lt; mutexWaiterShift<br />
	}<br />
<br />
	// 当前的goroutine将互斥锁转换为饥饿模式。但是，如果互斥锁当前没有解锁，就不要打开开关,设置mutex状态为饥饿模式。Unlock预期有饥饿的goroutine<br />
	if starving &amp;&amp; <br />
		// xxxx...xxx1 &amp; 0001 != 0；锁已经被占用<br />
		old&amp;mutexLocked != 0 {<br />
		// xxxx...xxx | 0101 =&gt;   xxxx...x1x1，标识对象锁被锁住<br />
		new |= mutexStarving<br />
	}<br />
<br />
	// goroutine已经被唤醒，因此需要在两种情况下重设标志<br />
	if awoke {<br />
		// xxxx...xx1x &amp; 0010 = 0,如果唤醒标志为与awoke不相协调就panic<br />
		if new&amp;mutexWoken == 0 {<br />
			panic("sync: inconsistent mutex state")<br />
		}<br />
		// new &amp; (^mutexWoken) =&gt; xxxx...xxxx &amp; (^0010) =&gt; xxxx...xxxx &amp; 1101 = xxxx...xx0x  ：设置唤醒状态位0,被唤醒<br />
		new &amp;^= mutexWoken<br />
	}<br />
	// 获取锁成功<br />
	if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {<br />
		// xxxx...x0x0 &amp; 0101 = 0，已经获取对象锁<br />
		if old&amp;(mutexLocked|mutexStarving) == 0 {<br />
			// 结束cas<br />
			break<br />
		}<br />
		// 以下的操作都是为了判断是否从饥饿模式中恢复为正常模式<br />
		// 判断处于FIFO还是LIFO模式<br />
		queueLifo := waitStartTime != 0<br />
		if waitStartTime == 0 {<br />
			waitStartTime = runtime_nanotime()<br />
		}<br />
		runtime_SemacquireMutex(&amp;m.sema, queueLifo)<br />
		starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs<br />
		old = m.state<br />
		// xxxx...x1xx &amp; 0100 != 0<br />
		if old&amp;mutexStarving != 0 {<br />
			// xxxx...xx11 &amp; 0011 != 0<br />
			if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {<br />
				panic("sync: inconsistent mutex state")<br />
			}<br />
			delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)<br />
			if !starving || old&gt;&gt;mutexWaiterShift == 1 {<br />
				delta -= mutexStarving<br />
			}<br />
			atomic.AddInt32(&amp;m.state, delta)<br />
			break<br />
		}<br />
		awoke = true<br />
		iter = 0<br />
	} else {<br />
		// 保存mutex对象状态<br />
		old = m.state<br />
	}<br />
}// cas结束<br />
<br />
if race.Enabled {<br />
	race.Acquire(unsafe.Pointer(m))<br />
} } 看了Lock()函数之后是不是觉得一片懵逼状态，告诉大家一个方法，看Lock()函数时候需要想着如何Unlock。下面就开始看看Unlock()函数。<br />
</code></pre></div></div><br />
<br />
<p>func (m *Mutex) Unlock() {<br />
	if race.Enabled {<br />
		_ = m.state<br />
		race.Release(unsafe.Pointer(m))<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// state-1标识解锁<br />
new := atomic.AddInt32(&amp;m.state, -mutexLocked)<br />
// 验证锁状态是否符合<br />
if (new+mutexLocked)&amp;mutexLocked == 0 {<br />
	panic("sync: unlock of unlocked mutex")<br />
}<br />
// xxxx...x0xx &amp; 0100 = 0 ;判断是否处于正常模式<br />
if new&amp;mutexStarving == 0 {<br />
	old := new<br />
	for {<br />
		// 如果没有等待的goroutine或goroutine已经解锁完成<br />
		if old&gt;&gt;mutexWaiterShift == 0 || <br />
		// xxxx...x0xx &amp; (0001 | 0010 | 0100) =&gt; xxxx...x0xx &amp; 0111 != 0<br />
		old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {<br />
			return<br />
		}<br />
		// Grab the right to wake someone.<br />
		new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken<br />
		if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {<br />
			runtime_Semrelease(&amp;m.sema, false)<br />
			return<br />
		}<br />
		old = m.state<br />
	}<br />
} else {<br />
	// 饥饿模式:将mutex所有权移交给下一个等待的goroutine<br />
	// 注意:mutexlock没有设置，goroutine会在唤醒后设置。<br />
	// 但是互斥锁仍然被认为是锁定的，如果互斥对象被设置，所以新来的goroutines不会得到它<br />
	runtime_Semrelease(&amp;m.sema, true)<br />
} } 在网上还会有一些基于go1.6的分析，但是与go 1.9的差距有点大。<br />
</code></pre></div></div><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>