<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">gc</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-04-20T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 20, 2019</time></p>
					</div>
					 <p>go在程序启动时会分配一块虚拟内存地址是连续的内存, 结构如下:<br />
spans 512M  bitmap 16G arena  512G<br />
这一块内存分为了3个区域, 在X64上大小分别是512M, 16G和512G, 它们的作用如下:</p><br />
<br />
<p>arena</p><br />
<br />
<p>arena区域就是我们通常说的heap, go从heap分配的内存都在这个区域中.</p><br />
<br />
<p>bitmap</p><br />
<br />
<p>bitmap区域用于表示arena区域中哪些地址保存了对象, 并且对象中哪些地址包含了指针.<br />
bitmap区域中一个byte(8 bit)对应了arena区域中的四个指针大小的内存, 也就是2 bit对应一个指针大小的内存.<br />
所以bitmap区域的大小是 512GB / 指针大小(8 byte) / 4 = 16GB.</p><br />
<br />
<p>bitmap区域中的一个byte对应arena区域的四个指针大小的内存的结构如下,<br />
每一个指针大小的内存都会有两个bit分别表示是否应该继续扫描和是否包含指针:<br />
	<img src="https://xiazemin.github.io/MyBlog/img/bitmap.png" /><br />
	bitmap中的byte和arena的对应关系从末尾开始, 也就是随着内存分配会向两边扩展:<br />
		<img src="https://xiazemin.github.io/MyBlog/img/bitmap_arena.png" /><br />
<!-- more --><br />
spans</p><br />
<br />
<p>spans区域用于表示arena区中的某一页(Page)属于哪个span, 什么是span将在下面介绍.<br />
spans区域中一个指针(8 byte)对应了arena区域中的一页(在go中一页=8KB).<br />
所以spans的大小是 512GB / 页大小(8KB) * 指针大小(8 byte) = 512MB.</p><br />
<br />
<p>spans区域的一个指针对应arena区域的一页的结构如下, 和bitmap不一样的是对应关系会从开头开始:<br />
<img src="https://xiazemin.github.io/MyBlog/img/span_arena.png" /><br />
什么时候从Heap分配对象<br />
很多讲解go的文章和书籍中都提到过, go会自动确定哪些对象应该放在栈上, 哪些对象应该放在堆上.<br />
简单的来说, 当一个对象的内容可能在生成该对象的函数结束后被访问, 那么这个对象就会分配在堆上.<br />
在堆上分配对象的情况包括:</p><br />
<br />
<p>返回对象的指针<br />
传递了对象的指针到其他函数<br />
在闭包中使用了对象并且需要修改对象<br />
使用new<br />
在C语言中函数返回在栈上的对象的指针是非常危险的事情, 但在go中却是安全的, 因为这个对象会自动在堆上分配.<br />
go决定是否使用堆分配对象的过程也叫”逃逸分析”.</p><br />
<br />
<p>GC Bitmap<br />
GC在标记时需要知道哪些地方包含了指针, 例如上面提到的bitmap区域涵盖了arena区域中的指针信息.<br />
除此之外, GC还需要知道栈空间上哪些地方包含了指针,<br />
因为栈空间不属于arena区域, 栈空间的指针信息将会在函数信息里面.<br />
另外, GC在分配对象时也需要根据对象的类型设置bitmap区域, 来源的指针信息将会在类型信息里面.</p><br />
<br />
<p>总结起来go中有以下的GC Bitmap:</p><br />
<br />
<p>bitmap区域: 涵盖了arena区域, 使用2 bit表示一个指针大小的内存<br />
函数信息: 涵盖了函数的栈空间, 使用1 bit表示一个指针大小的内存 (位于stackmap.bytedata)<br />
类型信息: 在分配对象时会复制到bitmap区域, 使用1 bit表示一个指针大小的内存 (位于_type.gcdata)<br />
Span<br />
span是用于分配对象的区块, 下图是简单说明了Span的内部结构:<br />
<img src="https://xiazemin.github.io/MyBlog/img/span_bit.png" /><br />
通常一个span包含了多个大小相同的元素, 一个元素会保存一个对象, 除非:</p><br />
<br />
<p>span用于保存大对象, 这种情况span只有一个元素<br />
span用于保存极小对象且不包含指针的对象(tiny object), 这种情况span会用一个元素保存多个对象<br />
span中有一个freeindex标记下一次分配对象时应该开始搜索的地址, 分配后freeindex会增加,<br />
在freeindex之前的元素都是已分配的, 在freeindex之后的元素有可能已分配, 也有可能未分配.</p><br />
<br />
<p>span每次GC以后都可能会回收掉一些元素, allocBits用于标记哪些元素是已分配的, 哪些元素是未分配的.<br />
使用freeindex + allocBits可以在分配时跳过已分配的元素, 把对象设置在未分配的元素中,<br />
但因为每次都去访问allocBits效率会比较慢, span中有一个整数型的allocCache用于缓存freeindex开始的bitmap, 缓存的bit值与原值相反.</p><br />
<br />
<p>gcmarkBits用于在gc时标记哪些对象存活, 每次gc以后gcmarkBits会变为allocBits.<br />
需要注意的是span结构本身的内存是从系统分配的, 上面提到的spans区域和bitmap区域都只是一个索引.</p><br />
<br />
<p>Span的类型<br />
span根据大小可以分为67个类型, 如下:</p><br />
<br />
<p>// class  bytes/obj  bytes/span  objects  tail waste  max waste<br />
//     1          8        8192     1024           0     87.50%<br />
//     2         16        8192      512           0     43.75%<br />
//     3         32        8192      256           0     46.88%<br />
//     4         48        8192      170          32     31.52%<br />
//     5         64        8192      128           0     23.44%<br />
//     6         80        8192      102          32     19.07%<br />
//     7         96        8192       85          32     15.95%<br />
//     8        112        8192       73          16     13.56%<br />
//     9        128        8192       64           0     11.72%<br />
//    10        144        8192       56         128     11.82%<br />
//    11        160        8192       51          32      9.73%<br />
//    12        176        8192       46          96      9.59%<br />
//    13        192        8192       42         128      9.25%<br />
//    14        208        8192       39          80      8.12%<br />
//    15        224        8192       36         128      8.15%<br />
//    16        240        8192       34          32      6.62%<br />
//    17        256        8192       32           0      5.86%<br />
//    18        288        8192       28         128     12.16%<br />
//    19        320        8192       25         192     11.80%<br />
//    20        352        8192       23          96      9.88%<br />
//    21        384        8192       21         128      9.51%<br />
//    22        416        8192       19         288     10.71%<br />
//    23        448        8192       18         128      8.37%<br />
//    24        480        8192       17          32      6.82%<br />
//    25        512        8192       16           0      6.05%<br />
//    26        576        8192       14         128     12.33%<br />
//    27        640        8192       12         512     15.48%<br />
//    28        704        8192       11         448     13.93%<br />
//    29        768        8192       10         512     13.94%<br />
//    30        896        8192        9         128     15.52%<br />
//    31       1024        8192        8           0     12.40%<br />
//    32       1152        8192        7         128     12.41%<br />
//    33       1280        8192        6         512     15.55%<br />
//    34       1408       16384       11         896     14.00%<br />
//    35       1536        8192        5         512     14.00%<br />
//    36       1792       16384        9         256     15.57%<br />
//    37       2048        8192        4           0     12.45%<br />
//    38       2304       16384        7         256     12.46%<br />
//    39       2688        8192        3         128     15.59%<br />
//    40       3072       24576        8           0     12.47%<br />
//    41       3200       16384        5         384      6.22%<br />
//    42       3456       24576        7         384      8.83%<br />
//    43       4096        8192        2           0     15.60%<br />
//    44       4864       24576        5         256     16.65%<br />
//    45       5376       16384        3         256     10.92%<br />
//    46       6144       24576        4           0     12.48%<br />
//    47       6528       32768        5         128      6.23%<br />
//    48       6784       40960        6         256      4.36%<br />
//    49       6912       49152        7         768      3.37%<br />
//    50       8192        8192        1           0     15.61%<br />
//    51       9472       57344        6         512     14.28%<br />
//    52       9728       49152        5         512      3.64%<br />
//    53      10240       40960        4           0      4.99%<br />
//    54      10880       32768        3         128      6.24%<br />
//    55      12288       24576        2           0     11.45%<br />
//    56      13568       40960        3         256      9.99%<br />
//    57      14336       57344        4           0      5.35%<br />
//    58      16384       16384        1           0     12.49%<br />
//    59      18432       73728        4           0     11.11%<br />
//    60      19072       57344        3         128      3.57%<br />
//    61      20480       40960        2           0      6.87%<br />
//    62      21760       65536        3         256      6.25%<br />
//    63      24576       24576        1           0     11.45%<br />
//    64      27264       81920        3         128     10.00%<br />
//    65      28672       57344        2           0      4.91%<br />
//    66      32768       32768        1           0     12.50%<br />
以类型(class)为1的span为例,<br />
span中的元素大小是8 byte, span本身占1页也就是8K, 一共可以保存1024个对象.</p><br />
<br />
<p>在分配对象时, 会根据对象的大小决定使用什么类型的span,<br />
例如16 byte的对象会使用span 2, 17 byte的对象会使用span 3, 32 byte的对象会使用span 3.<br />
从这个例子也可以看到, 分配17和32 byte的对象都会使用span 3, 也就是说部分大小的对象在分配时会浪费一定的空间.</p><br />
<br />
<p>有人可能会注意到, 上面最大的span的元素大小是32K, 那么分配超过32K的对象会在哪里分配呢?<br />
超过32K的对象称为”大对象”, 分配大对象时, 会直接从heap分配一个特殊的span,<br />
这个特殊的span的类型(class)是0, 只包含了一个大对象, span的大小由对象的大小决定.</p><br />
<br />
<p>特殊的span加上的66个标准的span, 一共组成了67个span类型.</p><br />
<br />
<p>Span的位置<br />
在前一篇中我提到了P是一个虚拟的资源, 同一时间只能有一个线程访问同一个P, 所以P中的数据不需要锁.<br />
为了分配对象时有更好的性能, 各个P中都有span的缓存(也叫mcache), 缓存的结构如下:<br />
<img src="https://xiazemin.github.io/MyBlog/img/span_p.png" /><br />
各个P中按span类型的不同, 有67*2=134个span的缓存,</p><br />
<br />
<p>其中scan和noscan的区别在于,<br />
如果对象包含了指针, 分配对象时会使用scan的span,<br />
如果对象不包含指针, 分配对象时会使用noscan的span.<br />
把span分为scan和noscan的意义在于,<br />
GC扫描对象的时候对于noscan的span可以不去查看bitmap区域来标记子对象, 这样可以大幅提升标记的效率.</p><br />
<br />
<p>在分配对象时将会从以下的位置获取适合的span用于分配:</p><br />
<br />
<p>首先从P的缓存(mcache)获取, 如果有缓存的span并且未满则使用, 这个步骤不需要锁<br />
然后从全局缓存(mcentral)获取, 如果获取成功则设置到P, 这个步骤需要锁<br />
最后从mheap获取, 获取后设置到全局缓存, 这个步骤需要锁<br />
在P中缓存span的做法跟CoreCLR中线程缓存分配上下文(Allocation Context)的做法相似,<br />
都可以让分配对象时大部分时候不需要线程锁, 改进分配的性能.</p><br />
<br />
<p>分配对象的处理<br />
分配对象的流程<br />
go从堆分配对象时会调用newobject函数, 这个函数的流程大致如下:<br />
<img src="https://xiazemin.github.io/MyBlog/img/span_malloc.png" /><br />
首先会检查GC是否在工作中, 如果GC在工作中并且当前的G分配了一定大小的内存则需要协助GC做一定的工作,<br />
这个机制叫GC Assist, 用于防止分配内存太快导致GC回收跟不上的情况发生.</p><br />
<br />
<p>之后会判断是小对象还是大对象, 如果是大对象则直接调用largeAlloc从堆中分配,<br />
如果是小对象分3个阶段获取可用的span, 然后从span中分配对象:</p><br />
<br />
<p>首先从P的缓存(mcache)获取<br />
然后从全局缓存(mcentral)获取, 全局缓存中有可用的span的列表<br />
最后从mheap获取, mheap中也有span的自由列表, 如果都获取失败则从arena区域分配<br />
这三个阶段的详细结构如下图:<br />
<img src="https://xiazemin.github.io/MyBlog/img/mcentral.png" /><br />
数据类型的定义<br />
分配对象涉及的数据类型包含:</p><br />
<br />
<p>p: 前一篇提到过, P是协程中的用于运行go代码的虚拟资源<br />
m: 前一篇提到过, M目前代表系统线程<br />
g: 前一篇提到过, G就是goroutine<br />
mspan: 用于分配对象的区块<br />
mcentral: 全局的mspan缓存, 一共有67*2=134个<br />
mheap: 用于管理heap的对象, 全局只有一个</p><br />
<br />
<p>源代码分析<br />
go从堆分配对象时会调用newobject函数, 先从这个函数看起:</p><br />
<br />
<p>// implementation of new builtin<br />
// compiler (both frontend and SSA backend) knows the signature<br />
// of this function<br />
func newobject(typ *_type) unsafe.Pointer {<br />
    return mallocgc(typ.size, typ, true)<br />
}<br />
newobject调用了mallocgc函数:</p><br />
<br />
<p>// Allocate an object of size bytes.<br />
// Small objects are allocated from the per-P cache’s free lists.<br />
// Large objects (&gt; 32 kB) are allocated straight from the heap.<br />
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {<br />
    if gcphase == _GCmarktermination {<br />
        throw(“mallocgc called with gcphase == _GCmarktermination”)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if size == 0 {<br />
    return unsafe.Pointer(&amp;zerobase)<br />
}<br />
<br />
if debug.sbrk != 0 {<br />
    align := uintptr(16)<br />
    if typ != nil {<br />
        align = uintptr(typ.align)<br />
    }<br />
    return persistentalloc(size, align, &amp;memstats.other_sys)<br />
}<br />
<br />
// 判断是否要辅助GC工作<br />
// gcBlackenEnabled在GC的标记阶段会开启<br />
// assistG is the G to charge for this allocation, or nil if<br />
// GC is not currently active.<br />
var assistG *g<br />
if gcBlackenEnabled != 0 {<br />
    // Charge the current user G for this allocation.<br />
    assistG = getg()<br />
    if assistG.m.curg != nil {<br />
        assistG = assistG.m.curg<br />
    }<br />
    // Charge the allocation against the G. We'll account<br />
    // for internal fragmentation at the end of mallocgc.<br />
    assistG.gcAssistBytes -= int64(size)<br />
<br />
    // 会按分配的大小判断需要协助GC完成多少工作<br />
    // 具体的算法将在下面讲解收集器时说明<br />
    if assistG.gcAssistBytes &lt; 0 {<br />
        // This G is in debt. Assist the GC to correct<br />
        // this before allocating. This must happen<br />
        // before disabling preemption.<br />
        gcAssistAlloc(assistG)<br />
    }<br />
}<br />
<br />
// 增加当前G对应的M的lock计数, 防止这个G被抢占<br />
// Set mp.mallocing to keep from being preempted by GC.<br />
mp := acquirem()<br />
if mp.mallocing != 0 {<br />
    throw("malloc deadlock")<br />
}<br />
if mp.gsignal == getg() {<br />
    throw("malloc during signal")<br />
}<br />
mp.mallocing = 1<br />
<br />
shouldhelpgc := false<br />
dataSize := size<br />
// 获取当前G对应的M对应的P的本地span缓存(mcache)<br />
// 因为M在拥有P后会把P的mcache设到M中, 这里返回的是getg().m.mcache<br />
c := gomcache()<br />
var x unsafe.Pointer<br />
noscan := typ == nil || typ.kind&amp;kindNoPointers != 0<br />
// 判断是否小对象, maxSmallSize当前的值是32K<br />
if size &lt;= maxSmallSize {<br />
    // 如果对象不包含指针, 并且对象的大小小于16 bytes, 可以做特殊处理<br />
    // 这里是针对非常小的对象的优化, 因为span的元素最小只能是8 byte, 如果对象更小那么很多空间都会被浪费掉<br />
    // 非常小的对象可以整合在"class 2 noscan"的元素(大小为16 byte)中<br />
    if noscan &amp;&amp; size &lt; maxTinySize {<br />
        // Tiny allocator.<br />
        //<br />
        // Tiny allocator combines several tiny allocation requests<br />
        // into a single memory block. The resulting memory block<br />
        // is freed when all subobjects are unreachable. The subobjects<br />
        // must be noscan (don't have pointers), this ensures that<br />
        // the amount of potentially wasted memory is bounded.<br />
        //<br />
        // Size of the memory block used for combining (maxTinySize) is tunable.<br />
        // Current setting is 16 bytes, which relates to 2x worst case memory<br />
        // wastage (when all but one subobjects are unreachable).<br />
        // 8 bytes would result in no wastage at all, but provides less<br />
        // opportunities for combining.<br />
        // 32 bytes provides more opportunities for combining,<br />
        // but can lead to 4x worst case wastage.<br />
        // The best case winning is 8x regardless of block size.<br />
        //<br />
        // Objects obtained from tiny allocator must not be freed explicitly.<br />
        // So when an object will be freed explicitly, we ensure that<br />
        // its size &gt;= maxTinySize.<br />
        //<br />
        // SetFinalizer has a special case for objects potentially coming<br />
        // from tiny allocator, it such case it allows to set finalizers<br />
        // for an inner byte of a memory block.<br />
        //<br />
        // The main targets of tiny allocator are small strings and<br />
        // standalone escaping variables. On a json benchmark<br />
        // the allocator reduces number of allocations by ~12% and<br />
        // reduces heap size by ~20%.<br />
        off := c.tinyoffset<br />
        // Align tiny pointer for required (conservative) alignment.<br />
        if size&amp;7 == 0 {<br />
            off = round(off, 8)<br />
        } else if size&amp;3 == 0 {<br />
            off = round(off, 4)<br />
        } else if size&amp;1 == 0 {<br />
            off = round(off, 2)<br />
        }<br />
        if off+size &lt;= maxTinySize &amp;&amp; c.tiny != 0 {<br />
            // The object fits into existing tiny block.<br />
            x = unsafe.Pointer(c.tiny + off)<br />
            c.tinyoffset = off + size<br />
            c.local_tinyallocs++<br />
            mp.mallocing = 0<br />
            releasem(mp)<br />
            return x<br />
        }<br />
        // Allocate a new maxTinySize block.<br />
        span := c.alloc[tinySpanClass]<br />
        v := nextFreeFast(span)<br />
        if v == 0 {<br />
            v, _, shouldhelpgc = c.nextFree(tinySpanClass)<br />
        }<br />
        x = unsafe.Pointer(v)<br />
        (*[2]uint64)(x)[0] = 0<br />
        (*[2]uint64)(x)[1] = 0<br />
        // See if we need to replace the existing tiny block with the new one<br />
        // based on amount of remaining free space.<br />
        if size &lt; c.tinyoffset || c.tiny == 0 {<br />
            c.tiny = uintptr(x)<br />
            c.tinyoffset = size<br />
        }<br />
        size = maxTinySize<br />
    } else {<br />
        // 否则按普通的小对象分配<br />
        // 首先获取对象的大小应该使用哪个span类型<br />
        var sizeclass uint8<br />
        if size &lt;= smallSizeMax-8 {<br />
            sizeclass = size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]<br />
        } else {<br />
            sizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]<br />
        }<br />
        size = uintptr(class_to_size[sizeclass])<br />
        // 等于sizeclass * 2 + (noscan ? 1 : 0)<br />
        spc := makeSpanClass(sizeclass, noscan)<br />
        span := c.alloc[spc]<br />
        // 尝试快速的从这个span中分配<br />
        v := nextFreeFast(span)<br />
        if v == 0 {<br />
            // 分配失败, 可能需要从mcentral或者mheap中获取<br />
            // 如果从mcentral或者mheap获取了新的span, 则shouldhelpgc会等于true<br />
            // shouldhelpgc会等于true时会在下面判断是否要触发GC<br />
            v, span, shouldhelpgc = c.nextFree(spc)<br />
        }<br />
        x = unsafe.Pointer(v)<br />
        if needzero &amp;&amp; span.needzero != 0 {<br />
            memclrNoHeapPointers(unsafe.Pointer(v), size)<br />
        }<br />
    }<br />
} else {<br />
    // 大对象直接从mheap分配, 这里的s是一个特殊的span, 它的class是0<br />
    var s *mspan<br />
    shouldhelpgc = true<br />
    systemstack(func() {<br />
        s = largeAlloc(size, needzero, noscan)<br />
    })<br />
    s.freeindex = 1<br />
    s.allocCount = 1<br />
    x = unsafe.Pointer(s.base())<br />
    size = s.elemsize<br />
}<br />
<br />
// 设置arena对应的bitmap, 记录哪些位置包含了指针, GC会使用bitmap扫描所有可到达的对象<br />
var scanSize uintptr<br />
if !noscan {<br />
    // If allocating a defer+arg block, now that we've picked a malloc size<br />
    // large enough to hold everything, cut the "asked for" size down to<br />
    // just the defer header, so that the GC bitmap will record the arg block<br />
    // as containing nothing at all (as if it were unused space at the end of<br />
    // a malloc block caused by size rounding).<br />
    // The defer arg areas are scanned as part of scanstack.<br />
    if typ == deferType {<br />
        dataSize = unsafe.Sizeof(_defer{})<br />
    }<br />
    // 这个函数非常的长, 有兴趣的可以看<br />
    // https://github.com/golang/go/blob/go1.9.2/src/runtime/mbitmap.go#L855<br />
    // 虽然代码很长但是设置的内容跟上面说过的bitmap区域的结构一样<br />
    // 根据类型信息设置scan bit跟pointer bit, scan bit成立表示应该继续扫描, pointer bit成立表示该位置是指针<br />
    // 需要注意的地方有<br />
    // - 如果一个类型只有开头的地方包含指针, 例如[ptr, ptr, large non-pointer data]<br />
    //   那么后面的部分的scan bit将会为0, 这样可以大幅提升标记的效率<br />
    // - 第二个slot的scan bit用途比较特殊, 它并不用于标记是否继续scan, 而是标记checkmark<br />
    // 什么是checkmark<br />
    // - 因为go的并行GC比较复杂, 为了检查实现是否正确, go需要在有一个检查所有应该被标记的对象是否被标记的机制<br />
    //   这个机制就是checkmark, 在开启checkmark时go会在标记阶段的最后停止整个世界然后重新执行一次标记<br />
    //   上面的第二个slot的scan bit就是用于标记对象在checkmark标记中是否被标记的<br />
    // - 有的人可能会发现第二个slot要求对象最少有两个指针的大小, 那么只有一个指针的大小的对象呢?<br />
    //   只有一个指针的大小的对象可以分为两种情况<br />
    //   对象就是指针, 因为大小刚好是1个指针所以并不需要看bitmap区域, 这时第一个slot就是checkmark<br />
    //   对象不是指针, 因为有tiny alloc的机制, 不是指针且只有一个指针大小的对象会分配在两个指针的span中<br />
    //               这时候也不需要看bitmap区域, 所以和上面一样第一个slot就是checkmark<br />
    heapBitsSetType(uintptr(x), size, dataSize, typ)<br />
    if dataSize &gt; typ.size {<br />
        // Array allocation. If there are any<br />
        // pointers, GC has to scan to the last<br />
        // element.<br />
        if typ.ptrdata != 0 {<br />
            scanSize = dataSize - typ.size + typ.ptrdata<br />
        }<br />
    } else {<br />
        scanSize = typ.ptrdata<br />
    }<br />
    c.local_scan += scanSize<br />
}<br />
<br />
// 内存屏障, 因为x86和x64的store不会乱序所以这里只是个针对编译器的屏障, 汇编中是ret<br />
// Ensure that the stores above that initialize x to<br />
// type-safe memory and set the heap bits occur before<br />
// the caller can make x observable to the garbage<br />
// collector. Otherwise, on weakly ordered machines,<br />
// the garbage collector could follow a pointer to x,<br />
// but see uninitialized memory or stale heap bits.<br />
publicationBarrier()<br />
<br />
// 如果当前在GC中, 需要立刻标记分配后的对象为"黑色", 防止它被回收<br />
// Allocate black during GC.<br />
// All slots hold nil so no scanning is needed.<br />
// This may be racing with GC so do it atomically if there can be<br />
// a race marking the bit.<br />
if gcphase != _GCoff {<br />
    gcmarknewobject(uintptr(x), size, scanSize)<br />
}<br />
<br />
// Race Detector的处理(用于检测线程冲突问题)<br />
if raceenabled {<br />
    racemalloc(x, size)<br />
}<br />
<br />
// Memory Sanitizer的处理(用于检测危险指针等内存问题)<br />
if msanenabled {<br />
    msanmalloc(x, size)<br />
}<br />
<br />
// 重新允许当前的G被抢占<br />
mp.mallocing = 0<br />
releasem(mp)<br />
<br />
// 除错记录<br />
if debug.allocfreetrace != 0 {<br />
    tracealloc(x, size, typ)<br />
}<br />
<br />
// Profiler记录<br />
if rate := MemProfileRate; rate &gt; 0 {<br />
    if size &lt; uintptr(rate) &amp;&amp; int32(size) &lt; c.next_sample {<br />
        c.next_sample -= int32(size)<br />
    } else {<br />
        mp := acquirem()<br />
        profilealloc(mp, x, size)<br />
        releasem(mp)<br />
    }<br />
}<br />
<br />
// gcAssistBytes减去"实际分配大小 - 要求分配大小", 调整到准确值<br />
if assistG != nil {<br />
    // Account for internal fragmentation in the assist<br />
    // debt now that we know it.<br />
    assistG.gcAssistBytes -= int64(size - dataSize)<br />
}<br />
<br />
// 如果之前获取了新的span, 则判断是否需要后台启动GC<br />
// 这里的判断逻辑(gcTrigger)会在下面详细说明<br />
if shouldhelpgc {<br />
    if t := (gcTrigger{kind: gcTriggerHeap}); t.test() {<br />
        gcStart(gcBackgroundMode, t)<br />
    }<br />
}<br />
<br />
return x } 接下来看看如何从span里面分配对象, 首先会调用nextFreeFast尝试快速分配:<br />
</code></pre></div></div><br />
<br />
<p>// nextFreeFast returns the next free object if one is quickly available.<br />
// Otherwise it returns 0.<br />
func nextFreeFast(s <em>mspan) gclinkptr {<br />
    // 获取第一个非0的bit是第几个bit, 也就是哪个元素是未分配的<br />
    theBit := sys.Ctz64(s.allocCache) // Is there a free object in the allocCache?<br />
    // 找到未分配的元素<br />
    if theBit &lt; 64 {<br />
        result := s.freeindex + uintptr(theBit)<br />
        // 要求索引值小于元素数量<br />
        if result &lt; s.nelems {<br />
            // 下一个freeindex<br />
            freeidx := result + 1<br />
            // 可以被64整除时需要特殊处理(参考nextFree)<br />
            if freeidx%64 == 0 &amp;&amp; freeidx != s.nelems {<br />
                return 0<br />
            }<br />
            // 更新freeindex和allocCache(高位都是0, 用尽以后会更新)<br />
            s.allocCache »= uint(theBit + 1)<br />
            s.freeindex = freeidx<br />
            // 返回元素所在的地址<br />
            v := gclinkptr(result</em>s.elemsize + s.base())<br />
            // 添加已分配的元素计数<br />
            s.allocCount++<br />
            return v<br />
        }<br />
    }<br />
    return 0<br />
}<br />
如果在freeindex后无法快速找到未分配的元素, 就需要调用nextFree做出更复杂的处理:</p><br />
<br />
<p>// nextFree returns the next free object from the cached span if one is available.<br />
// Otherwise it refills the cache with a span with an available object and<br />
// returns that object along with a flag indicating that this was a heavy<br />
// weight allocation. If it is a heavy weight allocation the caller must<br />
// determine whether a new GC cycle needs to be started or if the GC is active<br />
// whether this goroutine needs to assist the GC.<br />
func (c *mcache) nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc bool) {<br />
    // 找到下一个freeindex和更新allocCache<br />
    s = c.alloc[spc]<br />
    shouldhelpgc = false<br />
    freeIndex := s.nextFreeIndex()<br />
    // 如果span里面所有元素都已分配, 则需要获取新的span<br />
    if freeIndex == s.nelems {<br />
        // The span is full.<br />
        if uintptr(s.allocCount) != s.nelems {<br />
            println(“runtime: s.allocCount=”, s.allocCount, “s.nelems=”, s.nelems)<br />
            throw(“s.allocCount != s.nelems &amp;&amp; freeIndex == s.nelems”)<br />
        }<br />
        // 申请新的span<br />
        systemstack(func() {<br />
            c.refill(spc)<br />
        })<br />
        // 获取申请后的新的span, 并设置需要检查是否执行GC<br />
        shouldhelpgc = true<br />
        s = c.alloc[spc]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    freeIndex = s.nextFreeIndex()<br />
}<br />
<br />
if freeIndex &gt;= s.nelems {<br />
    throw("freeIndex is not valid")<br />
}<br />
<br />
// 返回元素所在的地址<br />
v = gclinkptr(freeIndex*s.elemsize + s.base())<br />
// 添加已分配的元素计数<br />
s.allocCount++<br />
if uintptr(s.allocCount) &gt; s.nelems {<br />
    println("s.allocCount=", s.allocCount, "s.nelems=", s.nelems)<br />
    throw("s.allocCount &gt; s.nelems")<br />
}<br />
return } 如果mcache中指定类型的span已满, 就需要调用refill函数申请新的span:<br />
</code></pre></div></div><br />
<br />
<p>// Gets a span that has a free object in it and assigns it<br />
// to be the cached span for the given sizeclass. Returns this span.<br />
func (c *mcache) refill(spc spanClass) *mspan {<br />
    <em>g</em> := getg()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 防止G被抢占<br />
_g_.m.locks++<br />
// Return the current cached span to the central lists.<br />
s := c.alloc[spc]<br />
<br />
// 确保当前的span所有元素都已分配<br />
if uintptr(s.allocCount) != s.nelems {<br />
    throw("refill of span with free space remaining")<br />
}<br />
<br />
// 设置span的incache属性, 除非是全局使用的空span(也就是mcache里面span指针的默认值)<br />
if s != &amp;emptymspan {<br />
    s.incache = false<br />
}<br />
<br />
// 向mcentral申请一个新的span<br />
// Get a new cached span from the central lists.<br />
s = mheap_.central[spc].mcentral.cacheSpan()<br />
if s == nil {<br />
    throw("out of memory")<br />
}<br />
<br />
if uintptr(s.allocCount) == s.nelems {<br />
    throw("span has no free space")<br />
}<br />
<br />
// 设置新的span到mcache中<br />
c.alloc[spc] = s<br />
// 允许G被抢占<br />
_g_.m.locks--<br />
return s } 向mcentral申请一个新的span会通过cacheSpan函数: mcentral首先尝试从内部的链表复用原有的span, 如果复用失败则向mheap申请.<br />
</code></pre></div></div><br />
<br />
<p>// Allocate a span to use in an MCache.<br />
func (c *mcentral) cacheSpan() *mspan {<br />
    // 让当前G协助一部分的sweep工作<br />
    // Deduct credit for this span allocation and sweep if necessary.<br />
    spanBytes := uintptr(class_to_allocnpages[c.spanclass.sizeclass()]) * _PageSize<br />
    deductSweepCredit(spanBytes, 0)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 对mcentral上锁, 因为可能会有多个M(P)同时访问<br />
lock(&amp;c.lock)<br />
traceDone := false<br />
if trace.enabled {<br />
    traceGCSweepStart()<br />
}<br />
sg := mheap_.sweepgen retry:<br />
// mcentral里面有两个span的链表<br />
// - nonempty表示确定该span最少有一个未分配的元素<br />
// - empty表示不确定该span最少有一个未分配的元素<br />
// 这里优先查找nonempty的链表<br />
// sweepgen每次GC都会增加2<br />
// - sweepgen == 全局sweepgen, 表示span已经sweep过<br />
// - sweepgen == 全局sweepgen-1, 表示span正在sweep<br />
// - sweepgen == 全局sweepgen-2, 表示span等待sweep<br />
var s *mspan<br />
for s = c.nonempty.first; s != nil; s = s.next {<br />
    // 如果span等待sweep, 尝试原子修改sweepgen为全局sweepgen-1<br />
    if s.sweepgen == sg-2 &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg-2, sg-1) {<br />
        // 修改成功则把span移到empty链表, sweep它然后跳到havespan<br />
        c.nonempty.remove(s)<br />
        c.empty.insertBack(s)<br />
        unlock(&amp;c.lock)<br />
        s.sweep(true)<br />
        goto havespan<br />
    }<br />
    // 如果这个span正在被其他线程sweep, 就跳过<br />
    if s.sweepgen == sg-1 {<br />
        // the span is being swept by background sweeper, skip<br />
        continue<br />
    }<br />
    // span已经sweep过<br />
    // 因为nonempty链表中的span确定最少有一个未分配的元素, 这里可以直接使用它<br />
    // we have a nonempty span that does not require sweeping, allocate from it<br />
    c.nonempty.remove(s)<br />
    c.empty.insertBack(s)<br />
    unlock(&amp;c.lock)<br />
    goto havespan<br />
}<br />
<br />
// 查找empty的链表<br />
for s = c.empty.first; s != nil; s = s.next {<br />
    // 如果span等待sweep, 尝试原子修改sweepgen为全局sweepgen-1<br />
    if s.sweepgen == sg-2 &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg-2, sg-1) {<br />
        // 把span放到empty链表的最后<br />
        // we have an empty span that requires sweeping,<br />
        // sweep it and see if we can free some space in it<br />
        c.empty.remove(s)<br />
        // swept spans are at the end of the list<br />
        c.empty.insertBack(s)<br />
        unlock(&amp;c.lock)<br />
        // 尝试sweep<br />
        s.sweep(true)<br />
        // sweep以后还需要检测是否有未分配的对象, 如果有则可以使用它<br />
        freeIndex := s.nextFreeIndex()<br />
        if freeIndex != s.nelems {<br />
            s.freeindex = freeIndex<br />
            goto havespan<br />
        }<br />
        lock(&amp;c.lock)<br />
        // the span is still empty after sweep<br />
        // it is already in the empty list, so just retry<br />
        goto retry<br />
    }<br />
    // 如果这个span正在被其他线程sweep, 就跳过<br />
    if s.sweepgen == sg-1 {<br />
        // the span is being swept by background sweeper, skip<br />
        continue<br />
    }<br />
    // 找不到有未分配对象的span<br />
    // already swept empty span,<br />
    // all subsequent ones must also be either swept or in process of sweeping<br />
    break<br />
}<br />
if trace.enabled {<br />
    traceGCSweepDone()<br />
    traceDone = true<br />
}<br />
unlock(&amp;c.lock)<br />
<br />
// 找不到有未分配对象的span, 需要从mheap分配<br />
// 分配完成后加到empty链表中<br />
// Replenish central list if empty.<br />
s = c.grow()<br />
if s == nil {<br />
    return nil<br />
}<br />
lock(&amp;c.lock)<br />
c.empty.insertBack(s)<br />
unlock(&amp;c.lock)<br />
<br />
// At this point s is a non-empty span, queued at the end of the empty list,<br />
// c is unlocked. havespan:<br />
if trace.enabled &amp;&amp; !traceDone {<br />
    traceGCSweepDone()<br />
}<br />
// 统计span中未分配的元素数量, 加到mcentral.nmalloc中<br />
// 统计span中未分配的元素总大小, 加到memstats.heap_live中<br />
cap := int32((s.npages &lt;&lt; _PageShift) / s.elemsize)<br />
n := cap - int32(s.allocCount)<br />
if n == 0 || s.freeindex == s.nelems || uintptr(s.allocCount) == s.nelems {<br />
    throw("span has no free objects")<br />
}<br />
// Assume all objects from this span will be allocated in the<br />
// mcache. If it gets uncached, we'll adjust this.<br />
atomic.Xadd64(&amp;c.nmalloc, int64(n))<br />
usedBytes := uintptr(s.allocCount) * s.elemsize<br />
atomic.Xadd64(&amp;memstats.heap_live, int64(spanBytes)-int64(usedBytes))<br />
// 跟踪处理<br />
if trace.enabled {<br />
    // heap_live changed.<br />
    traceHeapAlloc()<br />
}<br />
// 如果当前在GC中, 因为heap_live改变了, 重新调整G辅助标记工作的值<br />
// 详细请参考下面对revise函数的解析<br />
if gcBlackenEnabled != 0 {<br />
    // heap_live changed.<br />
    gcController.revise()<br />
}<br />
// 设置span的incache属性, 表示span正在mcache中<br />
s.incache = true<br />
// 根据freeindex更新allocCache<br />
freeByteBase := s.freeindex &amp;^ (64 - 1)<br />
whichByte := freeByteBase / 8<br />
// Init alloc bits cache.<br />
s.refillAllocCache(whichByte)<br />
<br />
// Adjust the allocCache so that s.freeindex corresponds to the low bit in<br />
// s.allocCache.<br />
s.allocCache &gt;&gt;= s.freeindex % 64<br />
<br />
return s } mcentral向mheap申请一个新的span会使用grow函数:<br />
</code></pre></div></div><br />
<br />
<p>// grow allocates a new empty span from the heap and initializes it for c’s size class.<br />
func (c *mcentral) grow() *mspan {<br />
    // 根据mcentral的类型计算需要申请的span的大小(除以8K = 有多少页)和可以保存多少个元素<br />
    npages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])<br />
    size := uintptr(class_to_size[c.spanclass.sizeclass()])<br />
    n := (npages « _PageShift) / size</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 向mheap申请一个新的span, 以页(8K)为单位<br />
s := mheap_.alloc(npages, c.spanclass, false, true)<br />
if s == nil {<br />
    return nil<br />
}<br />
<br />
p := s.base()<br />
s.limit = p + size*n<br />
<br />
// 分配并初始化span的allocBits和gcmarkBits<br />
heapBitsForSpan(s.base()).initSpan(s)<br />
return s } mheap分配span的函数是alloc:<br />
</code></pre></div></div><br />
<br />
<p>func (h *mheap) alloc(npage uintptr, spanclass spanClass, large bool, needzero bool) *mspan {<br />
    // 在g0的栈空间中调用alloc_m函数<br />
    // 关于systemstack的说明请看前一篇文章<br />
    // Don’t do any operations that lock the heap on the G stack.<br />
    // It might trigger stack growth, and the stack growth code needs<br />
    // to be able to allocate heap.<br />
    var s *mspan<br />
    systemstack(func() {<br />
        s = h.alloc_m(npage, spanclass, large)<br />
    })</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if s != nil {<br />
    if needzero &amp;&amp; s.needzero != 0 {<br />
        memclrNoHeapPointers(unsafe.Pointer(s.base()), s.npages&lt;&lt;_PageShift)<br />
    }<br />
    s.needzero = 0<br />
}<br />
return s } alloc函数会在g0的栈空间中调用alloc_m函数:<br />
</code></pre></div></div><br />
<br />
<p>// Allocate a new span of npage pages from the heap for GC’d memory<br />
// and record its size class in the HeapMap and HeapMapCache.<br />
func (h *mheap) alloc_m(npage uintptr, spanclass spanClass, large bool) *mspan {<br />
    <em>g</em> := getg()<br />
    if <em>g</em> != <em>g</em>.m.g0 {<br />
        throw(“_mheap_alloc not on g0 stack”)<br />
    }<br />
    // 对mheap上锁, 这里的锁是全局锁<br />
    lock(&amp;h.lock)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 为了防止heap增速太快, 在分配n页之前要先sweep和回收n页<br />
// 会先枚举busy列表然后再枚举busyLarge列表进行sweep, 具体参考reclaim和reclaimList函数<br />
// To prevent excessive heap growth, before allocating n pages<br />
// we need to sweep and reclaim at least n pages.<br />
if h.sweepdone == 0 {<br />
    // TODO(austin): This tends to sweep a large number of<br />
    // spans in order to find a few completely free spans<br />
    // (for example, in the garbage benchmark, this sweeps<br />
    // ~30x the number of pages its trying to allocate).<br />
    // If GC kept a bit for whether there were any marks<br />
    // in a span, we could release these free spans<br />
    // at the end of GC and eliminate this entirely.<br />
    if trace.enabled {<br />
        traceGCSweepStart()<br />
    }<br />
    h.reclaim(npage)<br />
    if trace.enabled {<br />
        traceGCSweepDone()<br />
    }<br />
}<br />
<br />
// 把mcache中的本地统计数据加到全局<br />
// transfer stats from cache to global<br />
memstats.heap_scan += uint64(_g_.m.mcache.local_scan)<br />
_g_.m.mcache.local_scan = 0<br />
memstats.tinyallocs += uint64(_g_.m.mcache.local_tinyallocs)<br />
_g_.m.mcache.local_tinyallocs = 0<br />
<br />
// 调用allocSpanLocked分配span, allocSpanLocked函数要求当前已经对mheap上锁<br />
s := h.allocSpanLocked(npage, &amp;memstats.heap_inuse)<br />
if s != nil {<br />
    // Record span info, because gc needs to be<br />
    // able to map interior pointer to containing span.<br />
    // 设置span的sweepgen = 全局sweepgen<br />
    atomic.Store(&amp;s.sweepgen, h.sweepgen)<br />
    // 放到全局span列表中, 这里的sweepSpans的长度是2<br />
    // sweepSpans[h.sweepgen/2%2]保存当前正在使用的span列表<br />
    // sweepSpans[1-h.sweepgen/2%2]保存等待sweep的span列表<br />
    // 因为每次gcsweepgen都会加2, 每次gc这两个列表都会交换<br />
    h.sweepSpans[h.sweepgen/2%2].push(s) // Add to swept in-use list.<br />
    // 初始化span成员<br />
    s.state = _MSpanInUse<br />
    s.allocCount = 0<br />
    s.spanclass = spanclass<br />
    if sizeclass := spanclass.sizeclass(); sizeclass == 0 {<br />
        s.elemsize = s.npages &lt;&lt; _PageShift<br />
        s.divShift = 0<br />
        s.divMul = 0<br />
        s.divShift2 = 0<br />
        s.baseMask = 0<br />
    } else {<br />
        s.elemsize = uintptr(class_to_size[sizeclass])<br />
        m := &amp;class_to_divmagic[sizeclass]<br />
        s.divShift = m.shift<br />
        s.divMul = m.mul<br />
        s.divShift2 = m.shift2<br />
        s.baseMask = m.baseMask<br />
    }<br />
<br />
    // update stats, sweep lists<br />
    h.pagesInUse += uint64(npage)<br />
    // 上面grow函数会传入true, 也就是通过grow调用到这里large会等于true<br />
    // 添加已分配的span到busy列表, 如果页数超过_MaxMHeapList(128页=8K*128=1M)则放到busylarge列表<br />
    if large {<br />
        memstats.heap_objects++<br />
        mheap_.largealloc += uint64(s.elemsize)<br />
        mheap_.nlargealloc++<br />
        atomic.Xadd64(&amp;memstats.heap_live, int64(npage&lt;&lt;_PageShift))<br />
        // Swept spans are at the end of lists.<br />
        if s.npages &lt; uintptr(len(h.busy)) {<br />
            h.busy[s.npages].insertBack(s)<br />
        } else {<br />
            h.busylarge.insertBack(s)<br />
        }<br />
    }<br />
}<br />
// 如果当前在GC中, 因为heap_live改变了, 重新调整G辅助标记工作的值<br />
// 详细请参考下面对revise函数的解析<br />
// heap_scan and heap_live were updated.<br />
if gcBlackenEnabled != 0 {<br />
    gcController.revise()<br />
}<br />
<br />
// 跟踪处理<br />
if trace.enabled {<br />
    traceHeapAlloc()<br />
}<br />
<br />
// h.spans is accessed concurrently without synchronization<br />
// from other threads. Hence, there must be a store/store<br />
// barrier here to ensure the writes to h.spans above happen<br />
// before the caller can publish a pointer p to an object<br />
// allocated from s. As soon as this happens, the garbage<br />
// collector running on another processor could read p and<br />
// look up s in h.spans. The unlock acts as the barrier to<br />
// order these writes. On the read side, the data dependency<br />
// between p and the index in h.spans orders the reads.<br />
unlock(&amp;h.lock)<br />
return s } 继续查看allocSpanLocked函数:<br />
</code></pre></div></div><br />
<br />
<p>// Allocates a span of the given size.  h must be locked.<br />
// The returned span has been removed from the<br />
// free list, but its state is still MSpanFree.<br />
func (h *mheap) allocSpanLocked(npage uintptr, stat *uint64) *mspan {<br />
    var list *mSpanList<br />
    var s *mspan</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 尝试在mheap中的自由列表分配<br />
// 页数小于_MaxMHeapList(128页=1M)的自由span都会在free列表中<br />
// 页数大于_MaxMHeapList的自由span都会在freelarge列表中<br />
// Try in fixed-size lists up to max.<br />
for i := int(npage); i &lt; len(h.free); i++ {<br />
    list = &amp;h.free[i]<br />
    if !list.isEmpty() {<br />
        s = list.first<br />
        list.remove(s)<br />
        goto HaveSpan<br />
    }<br />
}<br />
// free列表找不到则查找freelarge列表<br />
// 查找不到就向arena区域申请一个新的span加到freelarge中, 然后再查找freelarge列表<br />
// Best fit in list of large spans.<br />
s = h.allocLarge(npage) // allocLarge removed s from h.freelarge for us<br />
if s == nil {<br />
    if !h.grow(npage) {<br />
        return nil<br />
    }<br />
    s = h.allocLarge(npage)<br />
    if s == nil {<br />
        return nil<br />
    }<br />
}<br />
</code></pre></div></div><br />
<br />
<p>HaveSpan:<br />
    // Mark span in use.<br />
    if s.state != _MSpanFree {<br />
        throw(“MHeap_AllocLocked - MSpan not free”)<br />
    }<br />
    if s.npages &lt; npage {<br />
        throw(“MHeap_AllocLocked - bad npages”)<br />
    }<br />
    // 如果span有已释放(解除虚拟内存和物理内存关系)的页, 提醒这些页会被使用然后更新统计数据<br />
    if s.npreleased &gt; 0 {<br />
        sysUsed(unsafe.Pointer(s.base()), s.npages«_PageShift)<br />
        memstats.heap_released -= uint64(s.npreleased « _PageShift)<br />
        s.npreleased = 0<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 如果获取到的span页数比要求的页数多<br />
// 分割剩余的页数到另一个span并且放到自由列表中<br />
if s.npages &gt; npage {<br />
    // Trim extra and put it back in the heap.<br />
    t := (*mspan)(h.spanalloc.alloc())<br />
    t.init(s.base()+npage&lt;&lt;_PageShift, s.npages-npage)<br />
    s.npages = npage<br />
    p := (t.base() - h.arena_start) &gt;&gt; _PageShift<br />
    if p &gt; 0 {<br />
        h.spans[p-1] = s<br />
    }<br />
    h.spans[p] = t<br />
    h.spans[p+t.npages-1] = t<br />
    t.needzero = s.needzero<br />
    s.state = _MSpanManual // prevent coalescing with s<br />
    t.state = _MSpanManual<br />
    h.freeSpanLocked(t, false, false, s.unusedsince)<br />
    s.state = _MSpanFree<br />
}<br />
s.unusedsince = 0<br />
<br />
// 设置spans区域, 哪些地址对应哪个mspan对象<br />
p := (s.base() - h.arena_start) &gt;&gt; _PageShift<br />
for n := uintptr(0); n &lt; npage; n++ {<br />
    h.spans[p+n] = s<br />
}<br />
<br />
// 更新统计数据<br />
*stat += uint64(npage &lt;&lt; _PageShift)<br />
memstats.heap_idle -= uint64(npage &lt;&lt; _PageShift)<br />
<br />
//println("spanalloc", hex(s.start&lt;&lt;_PageShift))<br />
if s.inList() {<br />
    throw("still in list")<br />
}<br />
return s } 继续查看allocLarge函数:<br />
</code></pre></div></div><br />
<br />
<p>// allocLarge allocates a span of at least npage pages from the treap of large spans.<br />
// Returns nil if no such span currently exists.<br />
func (h *mheap) allocLarge(npage uintptr) *mspan {<br />
    // Search treap for smallest span with &gt;= npage pages.<br />
    return h.freelarge.remove(npage)<br />
}<br />
freelarge的类型是mTreap, 调用remove函数会在树里面搜索一个至少npage且在树中的最小的span返回:</p><br />
<br />
<p>// remove searches for, finds, removes from the treap, and returns the smallest<br />
// span that can hold npages. If no span has at least npages return nil.<br />
// This is slightly more complicated than a simple binary tree search<br />
// since if an exact match is not found the next larger node is<br />
// returned.<br />
// If the last node inspected &gt; npagesKey not holding<br />
// a left node (a smaller npages) is the “best fit” node.<br />
func (root *mTreap) remove(npages uintptr) *mspan {<br />
    t := root.treap<br />
    for t != nil {<br />
        if t.spanKey == nil {<br />
            throw(“treap node with nil spanKey found”)<br />
        }<br />
        if t.npagesKey &lt; npages {<br />
            t = t.right<br />
        } else if t.left != nil &amp;&amp; t.left.npagesKey &gt;= npages {<br />
            t = t.left<br />
        } else {<br />
            result := t.spanKey<br />
            root.removeNode(t)<br />
            return result<br />
        }<br />
    }<br />
    return nil<br />
}<br />
向arena区域申请新span的函数是mheap类的grow函数:</p><br />
<br />
<p>// Try to add at least npage pages of memory to the heap,<br />
// returning whether it worked.<br />
//<br />
// h must be locked.<br />
func (h *mheap) grow(npage uintptr) bool {<br />
    // Ask for a big chunk, to reduce the number of mappings<br />
    // the operating system needs to track; also amortizes<br />
    // the overhead of an operating system mapping.<br />
    // Allocate a multiple of 64kB.<br />
    npage = round(npage, (64«10)/_PageSize)<br />
    ask := npage « _PageShift<br />
    if ask &lt; _HeapAllocChunk {<br />
        ask = _HeapAllocChunk<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 调用mheap.sysAlloc函数申请<br />
v := h.sysAlloc(ask)<br />
if v == nil {<br />
    if ask &gt; npage&lt;&lt;_PageShift {<br />
        ask = npage &lt;&lt; _PageShift<br />
        v = h.sysAlloc(ask)<br />
    }<br />
    if v == nil {<br />
        print("runtime: out of memory: cannot allocate ", ask, "-byte block (", memstats.heap_sys, " in use)\n")<br />
        return false<br />
    }<br />
}<br />
<br />
// 创建一个新的span并加到自由列表中<br />
// Create a fake "in use" span and free it, so that the<br />
// right coalescing happens.<br />
s := (*mspan)(h.spanalloc.alloc())<br />
s.init(uintptr(v), ask&gt;&gt;_PageShift)<br />
p := (s.base() - h.arena_start) &gt;&gt; _PageShift<br />
for i := p; i &lt; p+s.npages; i++ {<br />
    h.spans[i] = s<br />
}<br />
atomic.Store(&amp;s.sweepgen, h.sweepgen)<br />
s.state = _MSpanInUse<br />
h.pagesInUse += uint64(s.npages)<br />
h.freeSpanLocked(s, false, true, 0)<br />
return true } 继续查看mheap的sysAlloc函数:<br />
</code></pre></div></div><br />
<br />
<p>// sysAlloc allocates the next n bytes from the heap arena. The<br />
// returned pointer is always _PageSize aligned and between<br />
// h.arena_start and h.arena_end. sysAlloc returns nil on failure.<br />
// There is no corresponding free function.<br />
func (h *mheap) sysAlloc(n uintptr) unsafe.Pointer {<br />
    // strandLimit is the maximum number of bytes to strand from<br />
    // the current arena block. If we would need to strand more<br />
    // than this, we fall back to sysAlloc’ing just enough for<br />
    // this allocation.<br />
    const strandLimit = 16 « 20</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 如果arena区域当前已提交的区域不足, 则调用sysReserve预留更多的空间, 然后更新arena_end<br />
// sysReserve在linux上调用的是mmap函数<br />
// mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)<br />
if n &gt; h.arena_end-h.arena_alloc {<br />
    // If we haven't grown the arena to _MaxMem yet, try<br />
    // to reserve some more address space.<br />
    p_size := round(n+_PageSize, 256&lt;&lt;20)<br />
    new_end := h.arena_end + p_size // Careful: can overflow<br />
    if h.arena_end &lt;= new_end &amp;&amp; new_end-h.arena_start-1 &lt;= _MaxMem {<br />
        // TODO: It would be bad if part of the arena<br />
        // is reserved and part is not.<br />
        var reserved bool<br />
        p := uintptr(sysReserve(unsafe.Pointer(h.arena_end), p_size, &amp;reserved))<br />
        if p == 0 {<br />
            // TODO: Try smaller reservation<br />
            // growths in case we're in a crowded<br />
            // 32-bit address space.<br />
            goto reservationFailed<br />
        }<br />
        // p can be just about anywhere in the address<br />
        // space, including before arena_end.<br />
        if p == h.arena_end {<br />
            // The new block is contiguous with<br />
            // the current block. Extend the<br />
            // current arena block.<br />
            h.arena_end = new_end<br />
            h.arena_reserved = reserved<br />
        } else if h.arena_start &lt;= p &amp;&amp; p+p_size-h.arena_start-1 &lt;= _MaxMem &amp;&amp; h.arena_end-h.arena_alloc &lt; strandLimit {<br />
            // We were able to reserve more memory<br />
            // within the arena space, but it's<br />
            // not contiguous with our previous<br />
            // reservation. It could be before or<br />
            // after our current arena_used.<br />
            //<br />
            // Keep everything page-aligned.<br />
            // Our pages are bigger than hardware pages.<br />
            h.arena_end = p + p_size<br />
            p = round(p, _PageSize)<br />
            h.arena_alloc = p<br />
            h.arena_reserved = reserved<br />
        } else {<br />
            // We got a mapping, but either<br />
            //<br />
            // 1) It's not in the arena, so we<br />
            // can't use it. (This should never<br />
            // happen on 32-bit.)<br />
            //<br />
            // 2) We would need to discard too<br />
            // much of our current arena block to<br />
            // use it.<br />
            //<br />
            // We haven't added this allocation to<br />
            // the stats, so subtract it from a<br />
            // fake stat (but avoid underflow).<br />
            //<br />
            // We'll fall back to a small sysAlloc.<br />
            stat := uint64(p_size)<br />
            sysFree(unsafe.Pointer(p), p_size, &amp;stat)<br />
        }<br />
    }<br />
}<br />
<br />
// 预留的空间足够时只需要增加arena_alloc<br />
if n &lt;= h.arena_end-h.arena_alloc {<br />
    // Keep taking from our reservation.<br />
    p := h.arena_alloc<br />
    sysMap(unsafe.Pointer(p), n, h.arena_reserved, &amp;memstats.heap_sys)<br />
    h.arena_alloc += n<br />
    if h.arena_alloc &gt; h.arena_used {<br />
        h.setArenaUsed(h.arena_alloc, true)<br />
    }<br />
<br />
    if p&amp;(_PageSize-1) != 0 {<br />
        throw("misrounded allocation in MHeap_SysAlloc")<br />
    }<br />
    return unsafe.Pointer(p)<br />
}<br />
<br />
// 预留空间失败后的处理 reservationFailed:<br />
// If using 64-bit, our reservation is all we have.<br />
if sys.PtrSize != 4 {<br />
    return nil<br />
}<br />
<br />
// On 32-bit, once the reservation is gone we can<br />
// try to get memory at a location chosen by the OS.<br />
p_size := round(n, _PageSize) + _PageSize<br />
p := uintptr(sysAlloc(p_size, &amp;memstats.heap_sys))<br />
if p == 0 {<br />
    return nil<br />
}<br />
<br />
if p &lt; h.arena_start || p+p_size-h.arena_start &gt; _MaxMem {<br />
    // This shouldn't be possible because _MaxMem is the<br />
    // whole address space on 32-bit.<br />
    top := uint64(h.arena_start) + _MaxMem<br />
    print("runtime: memory allocated by OS (", hex(p), ") not in usable range [", hex(h.arena_start), ",", hex(top), ")\n")<br />
    sysFree(unsafe.Pointer(p), p_size, &amp;memstats.heap_sys)<br />
    return nil<br />
}<br />
<br />
p += -p &amp; (_PageSize - 1)<br />
if p+n &gt; h.arena_used {<br />
    h.setArenaUsed(p+n, true)<br />
}<br />
<br />
if p&amp;(_PageSize-1) != 0 {<br />
    throw("misrounded allocation in MHeap_SysAlloc")<br />
}<br />
return unsafe.Pointer(p) } 以上就是分配对象的完整流程了, 接下来分析GC标记和回收对象的处理.<br />
</code></pre></div></div><br />
<br />
<p>回收对象的处理<br />
回收对象的流程<br />
GO的GC是并行GC, 也就是GC的大部分处理和普通的go代码是同时运行的, 这让GO的GC流程比较复杂.<br />
首先GC有四个阶段, 它们分别是:</p><br />
<br />
<p>Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC<br />
Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收<br />
Mark Termination: 完成标记工作, 重新扫描部分根对象(要求STW)<br />
Sweep: 按标记结果清扫span<br />
下图是比较完整的GC流程, 并按颜色对这四个阶段进行了分类:<br />
<img src="https://xiazemin.github.io/MyBlog/img/gc_stw.png" /><br />
在GC过程中会有两种后台任务(G), 一种是标记用的后台任务, 一种是清扫用的后台任务.<br />
标记用的后台任务会在需要时启动, 可以同时工作的后台任务数量大约是P的数量的25%, 也就是go所讲的让25%的cpu用在GC上的根据.<br />
清扫用的后台任务在程序启动时会启动一个, 进入清扫阶段时唤醒.</p><br />
<br />
<p>目前整个GC流程会进行两次STW(Stop The World), 第一次是Mark阶段的开始, 第二次是Mark Termination阶段.<br />
第一次STW会准备根对象的扫描, 启动写屏障(Write Barrier)和辅助GC(mutator assist).<br />
第二次STW会重新扫描部分根对象, 禁用写屏障(Write Barrier)和辅助GC(mutator assist).<br />
需要注意的是, 不是所有根对象的扫描都需要STW, 例如扫描栈上的对象只需要停止拥有该栈的G.<br />
从go 1.9开始, 写屏障的实现使用了Hybrid Write Barrier, 大幅减少了第二次STW的时间.</p><br />
<br />
<p>GC的触发条件<br />
GC在满足一定条件后会被触发, 触发条件有以下几种:</p><br />
<br />
<p>gcTriggerAlways: 强制触发GC<br />
gcTriggerHeap: 当前分配的内存达到一定值就触发GC<br />
gcTriggerTime: 当一定时间没有执行过GC就触发GC<br />
gcTriggerCycle: 要求启动新一轮的GC, 已启动则跳过, 手动触发GC的runtime.GC()会使用这个条件<br />
触发条件的判断在gctrigger的test函数.<br />
其中gcTriggerHeap和gcTriggerTime这两个条件是自然触发的, gcTriggerHeap的判断代码如下:</p><br />
<br />
<p>return memstats.heap_live &gt;= memstats.gc_trigger<br />
heap_live的增加在上面对分配器的代码分析中可以看到, 当值达到gc_trigger就会触发GC, 那么gc_trigger是如何决定的?<br />
gc_trigger的计算在gcSetTriggerRatio函数中, 公式是:</p><br />
<br />
<p>trigger = uint64(float64(memstats.heap_marked) * (1 + triggerRatio))<br />
当前标记存活的大小乘以1+系数triggerRatio, 就是下次出发GC需要的分配量.<br />
triggerRatio在每次GC后都会调整, 计算triggerRatio的函数是encCycle, 公式是:</p><br />
<br />
<p>const triggerGain = 0.5<br />
// 目标Heap增长率, 默认是1.0<br />
goalGrowthRatio := float64(gcpercent) / 100<br />
// 实际Heap增长率, 等于总大小/存活大小-1<br />
actualGrowthRatio := float64(memstats.heap_live)/float64(memstats.heap_marked) - 1<br />
// GC标记阶段的使用时间(因为endCycle是在Mark Termination阶段调用的)<br />
assistDuration := nanotime() - c.markStartTime<br />
// GC标记阶段的CPU占用率, 目标值是0.25<br />
utilization := gcGoalUtilization<br />
if assistDuration &gt; 0 {<br />
    // assistTime是G辅助GC标记对象所使用的时间合计<br />
    // (nanosecnds spent in mutator assists during this cycle)<br />
    // 额外的CPU占用率 = 辅助GC标记对象的总时间 / (GC标记使用时间 * P的数量)<br />
    utilization += float64(c.assistTime) / float64(assistDuration<em>int64(gomaxprocs))<br />
}<br />
// 触发系数偏移值 = 目标增长率 - 原触发系数 - CPU占用率 / 目标CPU占用率 * (实际增长率 - 原触发系数)<br />
// 参数的分析:<br />
// 实际增长率越大, 触发系数偏移值越小, 小于0时下次触发GC会提早<br />
// CPU占用率越大, 触发系数偏移值越小, 小于0时下次触发GC会提早<br />
// 原触发系数越大, 触发系数偏移值越小, 小于0时下次触发GC会提早<br />
triggerError := goalGrowthRatio - memstats.triggerRatio - utilization/gcGoalUtilization</em>(actualGrowthRatio-memstats.triggerRatio)<br />
// 根据偏移值调整触发系数, 每次只调整偏移值的一半(渐进式调整)<br />
triggerRatio := memstats.triggerRatio + triggerGain*triggerError<br />
公式中的”目标Heap增长率”可以通过设置环境变量”GOGC”调整, 默认值是100, 增加它的值可以减少GC的触发.<br />
设置”GOGC=off”可以彻底关掉GC.</p><br />
<br />
<p>gcTriggerTime的判断代码如下:</p><br />
<br />
<p>lastgc := int64(atomic.Load64(&amp;memstats.last_gc_nanotime))<br />
return lastgc != 0 &amp;&amp; t.now-lastgc &gt; forcegcperiod<br />
forcegcperiod的定义是2分钟, 也就是2分钟内没有执行过GC就会强制触发.</p><br />
<br />
<p>三色的定义(黑, 灰, 白)<br />
我看过的对三色GC的”三色”这个概念解释的最好的文章就是这一篇了, 强烈建议先看这一篇中的讲解.<br />
“三色”的概念可以简单的理解为:</p><br />
<br />
<p>黑色: 对象在这次GC中已标记, 且这个对象包含的子对象也已标记<br />
灰色: 对象在这次GC中已标记, 但这个对象包含的子对象未标记<br />
白色: 对象在这次GC中未标记<br />
在go内部对象并没有保存颜色的属性, 三色只是对它们的状态的描述,<br />
白色的对象在它所在的span的gcmarkBits中对应的bit为0,<br />
灰色的对象在它所在的span的gcmarkBits中对应的bit为1, 并且对象在标记队列中,<br />
黑色的对象在它所在的span的gcmarkBits中对应的bit为1, 并且对象已经从标记队列中取出并处理.<br />
gc完成后, gcmarkBits会移动到allocBits然后重新分配一个全部为0的bitmap, 这样黑色的对象就变为了白色.</p><br />
<br />
<p>写屏障(Write Barrier)<br />
因为go支持并行GC, GC的扫描和go代码可以同时运行, 这样带来的问题是GC扫描的过程中go代码有可能改变了对象的依赖树,<br />
例如开始扫描时发现根对象A和B, B拥有C的指针, GC先扫描A, 然后B把C的指针交给A, GC再扫描B, 这时C就不会被扫描到.<br />
为了避免这个问题, go在GC的标记阶段会启用写屏障(Write Barrier).</p><br />
<br />
<p>启用了写屏障(Write Barrier)后, 当B把C的指针交给A时, GC会认为在这一轮的扫描中C的指针是存活的,<br />
即使A可能会在稍后丢掉C, 那么C就在下一轮回收.<br />
写屏障只针对指针启用, 而且只在GC的标记阶段启用, 平时会直接把值写入到目标地址.</p><br />
<br />
<p>go在1.9开始启用了混合写屏障(Hybrid Write Barrier), 伪代码如下:</p><br />
<br />
<p>writePointer(slot, ptr):<br />
    shade(*slot)<br />
    if any stack is grey:<br />
        shade(ptr)<br />
    *slot = ptr<br />
混合写屏障会同时标记指针写入目标的”原指针”和“新指针”.</p><br />
<br />
<p>标记原指针的原因是, 其他运行中的线程有可能会同时把这个指针的值复制到寄存器或者栈上的本地变量,<br />
因为复制指针到寄存器或者栈上的本地变量不会经过写屏障, 所以有可能会导致指针不被标记, 试想下面的情况:</p><br />
<br />
<p>[go] b = obj<br />
[go] oldx = nil<br />
[gc] scan oldx…<br />
[go] oldx = b.x // 复制b.x到本地变量, 不进过写屏障<br />
[go] b.x = ptr // 写屏障应该标记b.x的原值<br />
[gc] scan b…<br />
如果写屏障不标记原值, 那么oldx就不会被扫描到.<br />
标记新指针的原因是, 其他运行中的线程有可能会转移指针的位置, 试想下面的情况:</p><br />
<br />
<p>[go] a = ptr<br />
[go] b = obj<br />
[gc] scan b…<br />
[go] b.x = a // 写屏障应该标记b.x的新值<br />
[go] a = nil<br />
[gc] scan a…<br />
如果写屏障不标记新值, 那么ptr就不会被扫描到.<br />
混合写屏障可以让GC在并行标记结束后不需要重新扫描各个G的堆栈, 可以减少Mark Termination中的STW时间.<br />
除了写屏障外, 在GC的过程中所有新分配的对象都会立刻变为黑色, 在上面的mallocgc函数中可以看到.</p><br />
<br />
<p>辅助GC(mutator assist)<br />
为了防止heap增速太快, 在GC执行的过程中如果同时运行的G分配了内存, 那么这个G会被要求辅助GC做一部分的工作.<br />
在GC的过程中同时运行的G称为”mutator”, “mutator assist”机制就是G辅助GC做一部分工作的机制.</p><br />
<br />
<p>辅助GC做的工作有两种类型, 一种是标记(Mark), 另一种是清扫(Sweep).<br />
辅助标记的触发可以查看上面的mallocgc函数, 触发时G会帮助扫描”工作量”个对象, 工作量的计算公式是:</p><br />
<br />
<p>debtBytes * assistWorkPerByte<br />
意思是分配的大小乘以系数assistWorkPerByte, assistWorkPerByte的计算在函数revise中, 公式是:</p><br />
<br />
<p>// 等待扫描的对象数量 = 未扫描的对象数量 - 已扫描的对象数量<br />
scanWorkExpected := int64(memstats.heap_scan) - c.scanWork<br />
if scanWorkExpected &lt; 1000 {<br />
    scanWorkExpected = 1000<br />
}<br />
// 距离触发GC的Heap大小 = 期待触发GC的Heap大小 - 当前的Heap大小<br />
// 注意next_gc的计算跟gc_trigger不一样, next_gc等于heap_marked * (1 + gcpercent / 100)<br />
heapDistance := int64(memstats.next_gc) - int64(atomic.Load64(&amp;memstats.heap_live))<br />
if heapDistance &lt;= 0 {<br />
    heapDistance = 1<br />
}<br />
// 每分配1 byte需要辅助扫描的对象数量 = 等待扫描的对象数量 / 距离触发GC的Heap大小<br />
c.assistWorkPerByte = float64(scanWorkExpected) / float64(heapDistance)<br />
c.assistBytesPerWork = float64(heapDistance) / float64(scanWorkExpected)<br />
和辅助标记不一样的是, 辅助清扫申请新span时才会检查, 而辅助标记是每次分配对象时都会检查.<br />
辅助清扫的触发可以看上面的cacheSpan函数, 触发时G会帮助回收”工作量”页的对象, 工作量的计算公式是:</p><br />
<br />
<p>spanBytes * sweepPagesPerByte // 不完全相同, 具体看deductSweepCredit函数<br />
意思是分配的大小乘以系数sweepPagesPerByte, sweepPagesPerByte的计算在函数gcSetTriggerRatio中, 公式是:</p><br />
<br />
<p>// 当前的Heap大小<br />
heapLiveBasis := atomic.Load64(&amp;memstats.heap_live)<br />
// 距离触发GC的Heap大小 = 下次触发GC的Heap大小 - 当前的Heap大小<br />
heapDistance := int64(trigger) - int64(heapLiveBasis)<br />
heapDistance -= 1024 * 1024<br />
if heapDistance &lt; <em>PageSize {<br />
    heapDistance = _PageSize<br />
}<br />
// 已清扫的页数<br />
pagesSwept := atomic.Load64(&amp;mheap</em>.pagesSwept)<br />
// 未清扫的页数 = 使用中的页数 - 已清扫的页数<br />
sweepDistancePages := int64(mheap_.pagesInUse) - int64(pagesSwept)<br />
if sweepDistancePages &lt;= 0 {<br />
    mheap_.sweepPagesPerByte = 0<br />
} else {<br />
    // 每分配1 byte(的span)需要辅助清扫的页数 = 未清扫的页数 / 距离触发GC的Heap大小<br />
    mheap_.sweepPagesPerByte = float64(sweepDistancePages) / float64(heapDistance)<br />
}<br />
根对象<br />
在GC的标记阶段首先需要标记的就是”根对象”, 从根对象开始可到达的所有对象都会被认为是存活的.<br />
根对象包含了全局变量, 各个G的栈上的变量等, GC会先扫描根对象然后再扫描根对象可到达的所有对象.<br />
扫描根对象包含了一系列的工作, 它们定义在[https://github.com/golang/go/blob/go1.9.2/src/runtime/mgcmark.go#L54]函数:</p><br />
<br />
<p>Fixed Roots: 特殊的扫描工作<br />
fixedRootFinalizers: 扫描析构器队列<br />
fixedRootFreeGStacks: 释放已中止的G的栈<br />
Flush Cache Roots: 释放mcache中的所有span, 要求STW<br />
Data Roots: 扫描可读写的全局变量<br />
BSS Roots: 扫描只读的全局变量<br />
Span Roots: 扫描各个span中特殊对象(析构器列表)<br />
Stack Roots: 扫描各个G的栈<br />
标记阶段(Mark)会做其中的”Fixed Roots”, “Data Roots”, “BSS Roots”, “Span Roots”, “Stack Roots”.<br />
完成标记阶段(Mark Termination)会做其中的”Fixed Roots”, “Flush Cache Roots”.</p><br />
<br />
<p>标记队列<br />
GC的标记阶段会使用”标记队列”来确定所有可从根对象到达的对象都已标记, 上面提到的”灰色”的对象就是在标记队列中的对象.<br />
举例来说, 如果当前有[A, B, C]这三个根对象, 那么扫描根对象时就会把它们放到标记队列:</p><br />
<br />
<p>work queue: [A, B, C]<br />
后台标记任务从标记队列中取出A, 如果A引用了D, 则把D放入标记队列:</p><br />
<br />
<p>work queue: [B, C, D]<br />
后台标记任务从标记队列取出B, 如果B也引用了D, 这时因为D在gcmarkBits中对应的bit已经是1所以会跳过:</p><br />
<br />
<p>work queue: [C, D]<br />
如果并行运行的go代码分配了一个对象E, 对象E会被立刻标记, 但不会进入标记队列(因为确定E没有引用其他对象).<br />
然后并行运行的go代码把对象F设置给对象E的成员, 写屏障会标记对象F然后把对象F加到运行队列:</p><br />
<br />
<p>work queue: [C, D, F]<br />
后台标记任务从标记队列取出C, 如果C没有引用其他对象, 则不需要处理:</p><br />
<br />
<p>work queue: [D, F]<br />
后台标记任务从标记队列取出D, 如果D引用了X, 则把X放入标记队列:</p><br />
<br />
<p>work queue: [F, X]<br />
后台标记任务从标记队列取出F, 如果F没有引用其他对象, 则不需要处理.<br />
后台标记任务从标记队列取出X, 如果X没有引用其他对象, 则不需要处理.<br />
最后标记队列为空, 标记完成, 存活的对象有[A, B, C, D, E, F, X].</p><br />
<br />
<p>实际的状况会比上面介绍的状况稍微复杂一点.<br />
标记队列会分为全局标记队列和各个P的本地标记队列, 这点和协程中的运行队列相似.<br />
并且标记队列为空以后, 还需要停止整个世界并禁止写屏障, 然后再次检查是否为空.</p><br />
<br />
<p>源代码分析<br />
go触发gc会从gcStart函数开始:</p><br />
<br />
<p>// gcStart transitions the GC from _GCoff to _GCmark (if<br />
// !mode.stwMark) or _GCmarktermination (if mode.stwMark) by<br />
// performing sweep termination and GC initialization.<br />
//<br />
// This may return without performing this transition in some cases,<br />
// such as when called on a system stack or with locks held.<br />
func gcStart(mode gcMode, trigger gcTrigger) {<br />
    // 判断当前G是否可抢占, 不可抢占时不触发GC<br />
    // Since this is called from malloc and malloc is called in<br />
    // the guts of a number of libraries that might be holding<br />
    // locks, don’t attempt to start GC in non-preemptible or<br />
    // potentially unstable situations.<br />
    mp := acquirem()<br />
    if gp := getg(); gp == mp.g0 || mp.locks &gt; 1 || mp.preemptoff != “” {<br />
        releasem(mp)<br />
        return<br />
    }<br />
    releasem(mp)<br />
    mp = nil</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 并行清扫上一轮GC未清扫的span<br />
// Pick up the remaining unswept/not being swept spans concurrently<br />
//<br />
// This shouldn't happen if we're being invoked in background<br />
// mode since proportional sweep should have just finished<br />
// sweeping everything, but rounding errors, etc, may leave a<br />
// few spans unswept. In forced mode, this is necessary since<br />
// GC can be forced at any point in the sweeping cycle.<br />
//<br />
// We check the transition condition continuously here in case<br />
// this G gets delayed in to the next GC cycle.<br />
for trigger.test() &amp;&amp; gosweepone() != ^uintptr(0) {<br />
    sweep.nbgsweep++<br />
}<br />
<br />
// 上锁, 然后重新检查gcTrigger的条件是否成立, 不成立时不触发GC<br />
// Perform GC initialization and the sweep termination<br />
// transition.<br />
semacquire(&amp;work.startSema)<br />
// Re-check transition condition under transition lock.<br />
if !trigger.test() {<br />
    semrelease(&amp;work.startSema)<br />
    return<br />
}<br />
<br />
// 记录是否强制触发, gcTriggerCycle是runtime.GC用的<br />
// For stats, check if this GC was forced by the user.<br />
work.userForced = trigger.kind == gcTriggerAlways || trigger.kind == gcTriggerCycle<br />
<br />
// 判断是否指定了禁止并行GC的参数<br />
// In gcstoptheworld debug mode, upgrade the mode accordingly.<br />
// We do this after re-checking the transition condition so<br />
// that multiple goroutines that detect the heap trigger don't<br />
// start multiple STW GCs.<br />
if mode == gcBackgroundMode {<br />
    if debug.gcstoptheworld == 1 {<br />
        mode = gcForceMode<br />
    } else if debug.gcstoptheworld == 2 {<br />
        mode = gcForceBlockMode<br />
    }<br />
}<br />
<br />
// Ok, we're doing it!  Stop everybody else<br />
semacquire(&amp;worldsema)<br />
<br />
// 跟踪处理<br />
if trace.enabled {<br />
    traceGCStart()<br />
}<br />
<br />
// 启动后台扫描任务(G)<br />
if mode == gcBackgroundMode {<br />
    gcBgMarkStartWorkers()<br />
}<br />
<br />
// 重置标记相关的状态<br />
gcResetMarkState()<br />
<br />
// 重置参数<br />
work.stwprocs, work.maxprocs = gcprocs(), gomaxprocs<br />
work.heap0 = atomic.Load64(&amp;memstats.heap_live)<br />
work.pauseNS = 0<br />
work.mode = mode<br />
<br />
// 记录开始时间<br />
now := nanotime()<br />
work.tSweepTerm = now<br />
work.pauseStart = now<br />
<br />
// 停止所有运行中的G, 并禁止它们运行<br />
systemstack(stopTheWorldWithSema)<br />
<br />
// !!!!!!!!!!!!!!!!<br />
// 世界已停止(STW)...<br />
// !!!!!!!!!!!!!!!!<br />
<br />
// 清扫上一轮GC未清扫的span, 确保上一轮GC已完成<br />
// Finish sweep before we start concurrent scan.<br />
systemstack(func() {<br />
    finishsweep_m()<br />
})<br />
// 清扫sched.sudogcache和sched.deferpool<br />
// clearpools before we start the GC. If we wait they memory will not be<br />
// reclaimed until the next GC cycle.<br />
clearpools()<br />
<br />
// 增加GC计数<br />
work.cycles++<br />
<br />
// 判断是否并行GC模式<br />
if mode == gcBackgroundMode { // Do as much work concurrently as possible<br />
    // 标记新一轮GC已开始<br />
    gcController.startCycle()<br />
    work.heapGoal = memstats.next_gc<br />
<br />
    // 设置全局变量中的GC状态为_GCmark<br />
    // 然后启用写屏障<br />
    // Enter concurrent mark phase and enable<br />
    // write barriers.<br />
    //<br />
    // Because the world is stopped, all Ps will<br />
    // observe that write barriers are enabled by<br />
    // the time we start the world and begin<br />
    // scanning.<br />
    //<br />
    // Write barriers must be enabled before assists are<br />
    // enabled because they must be enabled before<br />
    // any non-leaf heap objects are marked. Since<br />
    // allocations are blocked until assists can<br />
    // happen, we want enable assists as early as<br />
    // possible.<br />
    setGCPhase(_GCmark)<br />
<br />
    // 重置后台标记任务的计数<br />
    gcBgMarkPrepare() // Must happen before assist enable.<br />
<br />
    // 计算扫描根对象的任务数量<br />
    gcMarkRootPrepare()<br />
<br />
    // 标记所有tiny alloc等待合并的对象<br />
    // Mark all active tinyalloc blocks. Since we're<br />
    // allocating from these, they need to be black like<br />
    // other allocations. The alternative is to blacken<br />
    // the tiny block on every allocation from it, which<br />
    // would slow down the tiny allocator.<br />
    gcMarkTinyAllocs()<br />
<br />
    // 启用辅助GC<br />
    // At this point all Ps have enabled the write<br />
    // barrier, thus maintaining the no white to<br />
    // black invariant. Enable mutator assists to<br />
    // put back-pressure on fast allocating<br />
    // mutators.<br />
    atomic.Store(&amp;gcBlackenEnabled, 1)<br />
<br />
    // 记录标记开始的时间<br />
    // Assists and workers can start the moment we start<br />
    // the world.<br />
    gcController.markStartTime = now<br />
<br />
    // 重新启动世界<br />
    // 前面创建的后台标记任务会开始工作, 所有后台标记任务都完成工作后, 进入完成标记阶段<br />
    // Concurrent mark.<br />
    systemstack(startTheWorldWithSema)<br />
    <br />
    // !!!!!!!!!!!!!!!<br />
    // 世界已重新启动...<br />
    // !!!!!!!!!!!!!!!<br />
    <br />
    // 记录停止了多久, 和标记阶段开始的时间<br />
    now = nanotime()<br />
    work.pauseNS += now - work.pauseStart<br />
    work.tMark = now<br />
} else {<br />
    // 不是并行GC模式<br />
    // 记录完成标记阶段开始的时间<br />
    t := nanotime()<br />
    work.tMark, work.tMarkTerm = t, t<br />
    work.heapGoal = work.heap0<br />
<br />
    // 跳过标记阶段, 执行完成标记阶段<br />
    // 所有标记工作都会在世界已停止的状态执行<br />
    // (标记阶段会设置work.markrootDone=true, 如果跳过则它的值是false, 完成标记阶段会执行所有工作)<br />
    // 完成标记阶段会重新启动世界<br />
    // Perform mark termination. This will restart the world.<br />
    gcMarkTermination(memstats.triggerRatio)<br />
}<br />
<br />
semrelease(&amp;work.startSema) } 接下来一个个分析gcStart调用的函数, 建议配合上面的"回收对象的流程"中的图理解.<br />
</code></pre></div></div><br />
<br />
<p>函数gcBgMarkStartWorkers用于启动后台标记任务, 先分别对每个P启动一个:</p><br />
<br />
<p>// gcBgMarkStartWorkers prepares background mark worker goroutines.<br />
// These goroutines will not run until the mark phase, but they must<br />
// be started while the work is not stopped and from a regular G<br />
// stack. The caller must hold worldsema.<br />
func gcBgMarkStartWorkers() {<br />
    // Background marking is performed by per-P G’s. Ensure that<br />
    // each P has a background GC G.<br />
    for _, p := range &amp;allp {<br />
        if p == nil || p.status == _Pdead {<br />
            break<br />
        }<br />
        // 如果已启动则不重复启动<br />
        if p.gcBgMarkWorker == 0 {<br />
            go gcBgMarkWorker(p)<br />
            // 启动后等待该任务通知信号量bgMarkReady再继续<br />
            notetsleepg(&amp;work.bgMarkReady, -1)<br />
            noteclear(&amp;work.bgMarkReady)<br />
        }<br />
    }<br />
}<br />
这里虽然为每个P启动了一个后台标记任务, 但是可以同时工作的只有25%, 这个逻辑在协程M获取G时调用的findRunnableGCWorker中:</p><br />
<br />
<p>// findRunnableGCWorker returns the background mark worker for <em>p</em> if it<br />
// should be run. This must only be called when gcBlackenEnabled != 0.<br />
func (c *gcControllerState) findRunnableGCWorker(<em>p</em> *p) *g {<br />
    if gcBlackenEnabled == 0 {<br />
        throw(“gcControllerState.findRunnable: blackening not enabled”)<br />
    }<br />
    if <em>p</em>.gcBgMarkWorker == 0 {<br />
        // The mark worker associated with this P is blocked<br />
        // performing a mark transition. We can’t run it<br />
        // because it may be on some other run or wait queue.<br />
        return nil<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if !gcMarkWorkAvailable(_p_) {<br />
    // No work to be done right now. This can happen at<br />
    // the end of the mark phase when there are still<br />
    // assists tapering off. Don't bother running a worker<br />
    // now because it'll just return immediately.<br />
    return nil<br />
}<br />
<br />
// 原子减少对应的值, 如果减少后大于等于0则返回true, 否则返回false<br />
decIfPositive := func(ptr *int64) bool {<br />
    if *ptr &gt; 0 {<br />
        if atomic.Xaddint64(ptr, -1) &gt;= 0 {<br />
            return true<br />
        }<br />
        // We lost a race<br />
        atomic.Xaddint64(ptr, +1)<br />
    }<br />
    return false<br />
}<br />
<br />
// 减少dedicatedMarkWorkersNeeded, 成功时后台标记任务的模式是Dedicated<br />
// dedicatedMarkWorkersNeeded是当前P的数量的25%去除小数点<br />
// 详见startCycle函数<br />
if decIfPositive(&amp;c.dedicatedMarkWorkersNeeded) {<br />
    // This P is now dedicated to marking until the end of<br />
    // the concurrent mark phase.<br />
    _p_.gcMarkWorkerMode = gcMarkWorkerDedicatedMode<br />
} else {<br />
    // 减少fractionalMarkWorkersNeeded, 成功是后台标记任务的模式是Fractional<br />
    // 上面的计算如果小数点后有数值(不能够整除)则fractionalMarkWorkersNeeded为1, 否则为0<br />
    // 详见startCycle函数<br />
    // 举例来说, 4个P时会执行1个Dedicated模式的任务, 5个P时会执行1个Dedicated模式和1个Fractional模式的任务<br />
    if !decIfPositive(&amp;c.fractionalMarkWorkersNeeded) {<br />
        // No more workers are need right now.<br />
        return nil<br />
    }<br />
<br />
    // 按Dedicated模式的任务的执行时间判断cpu占用率是否超过预算值, 超过时不启动<br />
    // This P has picked the token for the fractional worker.<br />
    // Is the GC currently under or at the utilization goal?<br />
    // If so, do more work.<br />
    //<br />
    // We used to check whether doing one time slice of work<br />
    // would remain under the utilization goal, but that has the<br />
    // effect of delaying work until the mutator has run for<br />
    // enough time slices to pay for the work. During those time<br />
    // slices, write barriers are enabled, so the mutator is running slower.<br />
    // Now instead we do the work whenever we're under or at the<br />
    // utilization work and pay for it by letting the mutator run later.<br />
    // This doesn't change the overall utilization averages, but it<br />
    // front loads the GC work so that the GC finishes earlier and<br />
    // write barriers can be turned off sooner, effectively giving<br />
    // the mutator a faster machine.<br />
    //<br />
    // The old, slower behavior can be restored by setting<br />
    //  gcForcePreemptNS = forcePreemptNS.<br />
    const gcForcePreemptNS = 0<br />
<br />
    // TODO(austin): We could fast path this and basically<br />
    // eliminate contention on c.fractionalMarkWorkersNeeded by<br />
    // precomputing the minimum time at which it's worth<br />
    // next scheduling the fractional worker. Then Ps<br />
    // don't have to fight in the window where we've<br />
    // passed that deadline and no one has started the<br />
    // worker yet.<br />
    //<br />
    // TODO(austin): Shorter preemption interval for mark<br />
    // worker to improve fairness and give this<br />
    // finer-grained control over schedule?<br />
    now := nanotime() - gcController.markStartTime<br />
    then := now + gcForcePreemptNS<br />
    timeUsed := c.fractionalMarkTime + gcForcePreemptNS<br />
    if then &gt; 0 &amp;&amp; float64(timeUsed)/float64(then) &gt; c.fractionalUtilizationGoal {<br />
        // Nope, we'd overshoot the utilization goal<br />
        atomic.Xaddint64(&amp;c.fractionalMarkWorkersNeeded, +1)<br />
        return nil<br />
    }<br />
    _p_.gcMarkWorkerMode = gcMarkWorkerFractionalMode<br />
}<br />
<br />
// 安排后台标记任务执行<br />
// Run the background mark worker<br />
gp := _p_.gcBgMarkWorker.ptr()<br />
casgstatus(gp, _Gwaiting, _Grunnable)<br />
if trace.enabled {<br />
    traceGoUnpark(gp, 0)<br />
}<br />
return gp } gcResetMarkState函数会重置标记相关的状态:<br />
</code></pre></div></div><br />
<br />
<p>// gcResetMarkState resets global state prior to marking (concurrent<br />
// or STW) and resets the stack scan state of all Gs.<br />
//<br />
// This is safe to do without the world stopped because any Gs created<br />
// during or after this will start out in the reset state.<br />
func gcResetMarkState() {<br />
    // This may be called during a concurrent phase, so make sure<br />
    // allgs doesn’t change.<br />
    lock(&amp;allglock)<br />
    for _, gp := range allgs {<br />
        gp.gcscandone = false  // set to true in gcphasework<br />
        gp.gcscanvalid = false // stack has not been scanned<br />
        gp.gcAssistBytes = 0<br />
    }<br />
    unlock(&amp;allglock)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>work.bytesMarked = 0<br />
work.initialHeapLive = atomic.Load64(&amp;memstats.heap_live)<br />
work.markrootDone = false } stopTheWorldWithSema函数会停止整个世界, 这个函数必须在g0中运行:<br />
</code></pre></div></div><br />
<br />
<p>// stopTheWorldWithSema is the core implementation of stopTheWorld.<br />
// The caller is responsible for acquiring worldsema and disabling<br />
// preemption first and then should stopTheWorldWithSema on the system<br />
// stack:<br />
//<br />
//  semacquire(&amp;worldsema, 0)<br />
//  m.preemptoff = “reason”<br />
//  systemstack(stopTheWorldWithSema)<br />
//<br />
// When finished, the caller must either call startTheWorld or undo<br />
// these three operations separately:<br />
//<br />
//  m.preemptoff = “”<br />
//  systemstack(startTheWorldWithSema)<br />
//  semrelease(&amp;worldsema)<br />
//<br />
// It is allowed to acquire worldsema once and then execute multiple<br />
// startTheWorldWithSema/stopTheWorldWithSema pairs.<br />
// Other P’s are able to execute between successive calls to<br />
// startTheWorldWithSema and stopTheWorldWithSema.<br />
// Holding worldsema causes any other goroutines invoking<br />
// stopTheWorld to block.<br />
func stopTheWorldWithSema() {<br />
    <em>g</em> := getg()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// If we hold a lock, then we won't be able to stop another M<br />
// that is blocked trying to acquire the lock.<br />
if _g_.m.locks &gt; 0 {<br />
    throw("stopTheWorld: holding locks")<br />
}<br />
<br />
lock(&amp;sched.lock)<br />
<br />
// 需要停止的P数量<br />
sched.stopwait = gomaxprocs<br />
<br />
// 设置gc等待标记, 调度时看见此标记会进入等待<br />
atomic.Store(&amp;sched.gcwaiting, 1)<br />
<br />
// 抢占所有运行中的G<br />
preemptall()<br />
<br />
// 停止当前的P<br />
// stop current P<br />
_g_.m.p.ptr().status = _Pgcstop // Pgcstop is only diagnostic.<br />
<br />
// 减少需要停止的P数量(当前的P算一个)<br />
sched.stopwait--<br />
<br />
// 抢占所有在Psyscall状态的P, 防止它们重新参与调度<br />
// try to retake all P's in Psyscall status<br />
for i := 0; i &lt; int(gomaxprocs); i++ {<br />
    p := allp[i]<br />
    s := p.status<br />
    if s == _Psyscall &amp;&amp; atomic.Cas(&amp;p.status, s, _Pgcstop) {<br />
        if trace.enabled {<br />
            traceGoSysBlock(p)<br />
            traceProcStop(p)<br />
        }<br />
        p.syscalltick++<br />
        sched.stopwait--<br />
    }<br />
}<br />
<br />
// 防止所有空闲的P重新参与调度<br />
// stop idle P's<br />
for {<br />
    p := pidleget()<br />
    if p == nil {<br />
        break<br />
    }<br />
    p.status = _Pgcstop<br />
    sched.stopwait--<br />
}<br />
wait := sched.stopwait &gt; 0<br />
unlock(&amp;sched.lock)<br />
<br />
// 如果仍有需要停止的P, 则等待它们停止<br />
// wait for remaining P's to stop voluntarily<br />
if wait {<br />
    for {<br />
        // 循环等待 + 抢占所有运行中的G<br />
        // wait for 100us, then try to re-preempt in case of any races<br />
        if notetsleep(&amp;sched.stopnote, 100*1000) {<br />
            noteclear(&amp;sched.stopnote)<br />
            break<br />
        }<br />
        preemptall()<br />
    }<br />
}<br />
<br />
// 逻辑正确性检查<br />
// sanity checks<br />
bad := ""<br />
if sched.stopwait != 0 {<br />
    bad = "stopTheWorld: not stopped (stopwait != 0)"<br />
} else {<br />
    for i := 0; i &lt; int(gomaxprocs); i++ {<br />
        p := allp[i]<br />
        if p.status != _Pgcstop {<br />
            bad = "stopTheWorld: not stopped (status != _Pgcstop)"<br />
        }<br />
    }<br />
}<br />
if atomic.Load(&amp;freezing) != 0 {<br />
    // Some other thread is panicking. This can cause the<br />
    // sanity checks above to fail if the panic happens in<br />
    // the signal handler on a stopped thread. Either way,<br />
    // we should halt this thread.<br />
    lock(&amp;deadlock)<br />
    lock(&amp;deadlock)<br />
}<br />
if bad != "" {<br />
    throw(bad)<br />
}<br />
<br />
// 到这里所有运行中的G都会变为待运行, 并且所有的P都不能被M获取<br />
// 也就是说所有的go代码(除了当前的)都会停止运行, 并且不能运行新的go代码 } finishsweep_m函数会清扫上一轮GC未清扫的span, 确保上一轮GC已完成:<br />
</code></pre></div></div><br />
<br />
<p>// finishsweep_m ensures that all spans are swept.<br />
//<br />
// The world must be stopped. This ensures there are no sweeps in<br />
// progress.<br />
//<br />
//go:nowritebarrier<br />
func finishsweep_m() {<br />
    // sweepone会取出一个未sweep的span然后执行sweep<br />
    // 详细将在下面sweep阶段时分析<br />
    // Sweeping must be complete before marking commences, so<br />
    // sweep any unswept spans. If this is a concurrent GC, there<br />
    // shouldn’t be any spans left to sweep, so this should finish<br />
    // instantly. If GC was forced before the concurrent sweep<br />
    // finished, there may be spans to sweep.<br />
    for sweepone() != ^uintptr(0) {<br />
        sweep.npausesweep++<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 所有span都sweep完成后, 启动一个新的markbit时代<br />
// 这个函数是实现span的gcmarkBits和allocBits的分配和复用的关键, 流程如下<br />
// - span分配gcmarkBits和allocBits<br />
// - span完成sweep<br />
//   - 原allocBits不再被使用<br />
//   - gcmarkBits变为allocBits<br />
//   - 分配新的gcmarkBits<br />
// - 开启新的markbit时代<br />
// - span完成sweep, 同上<br />
// - 开启新的markbit时代<br />
//   - 2个时代之前的bitmap将不再被使用, 可以复用这些bitmap<br />
nextMarkBitArenaEpoch() } clearpools函数会清理sched.sudogcache和sched.deferpool, 让它们的内存可以被回收:<br />
</code></pre></div></div><br />
<br />
<p>func clearpools() {<br />
    // clear sync.Pools<br />
    if poolcleanup != nil {<br />
        poolcleanup()<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Clear central sudog cache.<br />
// Leave per-P caches alone, they have strictly bounded size.<br />
// Disconnect cached list before dropping it on the floor,<br />
// so that a dangling ref to one entry does not pin all of them.<br />
lock(&amp;sched.sudoglock)<br />
var sg, sgnext *sudog<br />
for sg = sched.sudogcache; sg != nil; sg = sgnext {<br />
    sgnext = sg.next<br />
    sg.next = nil<br />
}<br />
sched.sudogcache = nil<br />
unlock(&amp;sched.sudoglock)<br />
<br />
// Clear central defer pools.<br />
// Leave per-P pools alone, they have strictly bounded size.<br />
lock(&amp;sched.deferlock)<br />
for i := range sched.deferpool {<br />
    // disconnect cached list before dropping it on the floor,<br />
    // so that a dangling ref to one entry does not pin all of them.<br />
    var d, dlink *_defer<br />
    for d = sched.deferpool[i]; d != nil; d = dlink {<br />
        dlink = d.link<br />
        d.link = nil<br />
    }<br />
    sched.deferpool[i] = nil<br />
}<br />
unlock(&amp;sched.deferlock) } startCycle标记开始了新一轮的GC:<br />
</code></pre></div></div><br />
<br />
<p>// startCycle resets the GC controller’s state and computes estimates<br />
// for a new GC cycle. The caller must hold worldsema.<br />
func (c *gcControllerState) startCycle() {<br />
    c.scanWork = 0<br />
    c.bgScanCredit = 0<br />
    c.assistTime = 0<br />
    c.dedicatedMarkTime = 0<br />
    c.fractionalMarkTime = 0<br />
    c.idleMarkTime = 0</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 伪装heap_marked的值如果gc_trigger的值很小, 防止后面对triggerRatio做出错误的调整<br />
// If this is the first GC cycle or we're operating on a very<br />
// small heap, fake heap_marked so it looks like gc_trigger is<br />
// the appropriate growth from heap_marked, even though the<br />
// real heap_marked may not have a meaningful value (on the<br />
// first cycle) or may be much smaller (resulting in a large<br />
// error response).<br />
if memstats.gc_trigger &lt;= heapminimum {<br />
    memstats.heap_marked = uint64(float64(memstats.gc_trigger) / (1 + memstats.triggerRatio))<br />
}<br />
<br />
// 重新计算next_gc, 注意next_gc的计算跟gc_trigger不一样<br />
// Re-compute the heap goal for this cycle in case something<br />
// changed. This is the same calculation we use elsewhere.<br />
memstats.next_gc = memstats.heap_marked + memstats.heap_marked*uint64(gcpercent)/100<br />
if gcpercent &lt; 0 {<br />
    memstats.next_gc = ^uint64(0)<br />
}<br />
<br />
// 确保next_gc和heap_live之间最少有1MB<br />
// Ensure that the heap goal is at least a little larger than<br />
// the current live heap size. This may not be the case if GC<br />
// start is delayed or if the allocation that pushed heap_live<br />
// over gc_trigger is large or if the trigger is really close to<br />
// GOGC. Assist is proportional to this distance, so enforce a<br />
// minimum distance, even if it means going over the GOGC goal<br />
// by a tiny bit.<br />
if memstats.next_gc &lt; memstats.heap_live+1024*1024 {<br />
    memstats.next_gc = memstats.heap_live + 1024*1024<br />
}<br />
<br />
// 计算可以同时执行的后台标记任务的数量<br />
// dedicatedMarkWorkersNeeded等于P的数量的25%去除小数点<br />
// 如果可以整除则fractionalMarkWorkersNeeded等于0否则等于1<br />
// totalUtilizationGoal是GC所占的P的目标值(例如P一共有5个时目标是1.25个P)<br />
// fractionalUtilizationGoal是Fractiona模式的任务所占的P的目标值(例如P一共有5个时目标是0.25个P)<br />
// Compute the total mark utilization goal and divide it among<br />
// dedicated and fractional workers.<br />
totalUtilizationGoal := float64(gomaxprocs) * gcGoalUtilization<br />
c.dedicatedMarkWorkersNeeded = int64(totalUtilizationGoal)<br />
c.fractionalUtilizationGoal = totalUtilizationGoal - float64(c.dedicatedMarkWorkersNeeded)<br />
if c.fractionalUtilizationGoal &gt; 0 {<br />
    c.fractionalMarkWorkersNeeded = 1<br />
} else {<br />
    c.fractionalMarkWorkersNeeded = 0<br />
}<br />
<br />
// 重置P中的辅助GC所用的时间统计<br />
// Clear per-P state<br />
for _, p := range &amp;allp {<br />
    if p == nil {<br />
        break<br />
    }<br />
    p.gcAssistTime = 0<br />
}<br />
<br />
// 计算辅助GC的参数<br />
// 参考上面对计算assistWorkPerByte的公式的分析<br />
// Compute initial values for controls that are updated<br />
// throughout the cycle.<br />
c.revise()<br />
<br />
if debug.gcpacertrace &gt; 0 {<br />
    print("pacer: assist ratio=", c.assistWorkPerByte,<br />
        " (scan ", memstats.heap_scan&gt;&gt;20, " MB in ",<br />
        work.initialHeapLive&gt;&gt;20, "-&gt;",<br />
        memstats.next_gc&gt;&gt;20, " MB)",<br />
        " workers=", c.dedicatedMarkWorkersNeeded,<br />
        "+", c.fractionalMarkWorkersNeeded, "\n")<br />
} } setGCPhase函数会修改表示当前GC阶段的全局变量和是否开启写屏障的全局变量:<br />
</code></pre></div></div><br />
<br />
<p>//go:nosplit<br />
func setGCPhase(x uint32) {<br />
    atomic.Store(&amp;gcphase, x)<br />
    writeBarrier.needed = gcphase == _GCmark || gcphase == _GCmarktermination<br />
    writeBarrier.enabled = writeBarrier.needed || writeBarrier.cgo<br />
}<br />
gcBgMarkPrepare函数会重置后台标记任务的计数:</p><br />
<br />
<p>// gcBgMarkPrepare sets up state for background marking.<br />
// Mutator assists must not yet be enabled.<br />
func gcBgMarkPrepare() {<br />
    // Background marking will stop when the work queues are empty<br />
    // and there are no more workers (note that, since this is<br />
    // concurrent, this may be a transient state, but mark<br />
    // termination will clean it up). Between background workers<br />
    // and assists, we don’t really know how many workers there<br />
    // will be, so we pretend to have an arbitrarily large number<br />
    // of workers, almost all of which are “waiting”. While a<br />
    // worker is working it decrements nwait. If nproc == nwait,<br />
    // there are no workers.<br />
    work.nproc = ^uint32(0)<br />
    work.nwait = ^uint32(0)<br />
}<br />
gcMarkRootPrepare函数会计算扫描根对象的任务数量:</p><br />
<br />
<p>// gcMarkRootPrepare queues root scanning jobs (stacks, globals, and<br />
// some miscellany) and initializes scanning-related state.<br />
//<br />
// The caller must have call gcCopySpans().<br />
//<br />
// The world must be stopped.<br />
//<br />
//go:nowritebarrier<br />
func gcMarkRootPrepare() {<br />
    // 释放mcache中的所有span的任务, 只在完成标记阶段(mark termination)中执行<br />
    if gcphase == _GCmarktermination {<br />
        work.nFlushCacheRoots = int(gomaxprocs)<br />
    } else {<br />
        work.nFlushCacheRoots = 0<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 计算block数量的函数, rootBlockBytes是256KB<br />
// Compute how many data and BSS root blocks there are.<br />
nBlocks := func(bytes uintptr) int {<br />
    return int((bytes + rootBlockBytes - 1) / rootBlockBytes)<br />
}<br />
<br />
work.nDataRoots = 0<br />
work.nBSSRoots = 0<br />
<br />
// data和bss每一轮GC只扫描一次<br />
// 并行GC中会在后台标记任务中扫描, 完成标记阶段(mark termination)中不扫描<br />
// 非并行GC会在完成标记阶段(mark termination)中扫描<br />
// Only scan globals once per cycle; preferably concurrently.<br />
if !work.markrootDone {<br />
    // 计算扫描可读写的全局变量的任务数量<br />
    for _, datap := range activeModules() {<br />
        nDataRoots := nBlocks(datap.edata - datap.data)<br />
        if nDataRoots &gt; work.nDataRoots {<br />
            work.nDataRoots = nDataRoots<br />
        }<br />
    }<br />
<br />
    // 计算扫描只读的全局变量的任务数量<br />
    for _, datap := range activeModules() {<br />
        nBSSRoots := nBlocks(datap.ebss - datap.bss)<br />
        if nBSSRoots &gt; work.nBSSRoots {<br />
            work.nBSSRoots = nBSSRoots<br />
        }<br />
    }<br />
}<br />
<br />
// span中的finalizer和各个G的栈每一轮GC只扫描一次<br />
// 同上<br />
if !work.markrootDone {<br />
    // 计算扫描span中的finalizer的任务数量<br />
    // On the first markroot, we need to scan span roots.<br />
    // In concurrent GC, this happens during concurrent<br />
    // mark and we depend on addfinalizer to ensure the<br />
    // above invariants for objects that get finalizers<br />
    // after concurrent mark. In STW GC, this will happen<br />
    // during mark termination.<br />
    //<br />
    // We're only interested in scanning the in-use spans,<br />
    // which will all be swept at this point. More spans<br />
    // may be added to this list during concurrent GC, but<br />
    // we only care about spans that were allocated before<br />
    // this mark phase.<br />
    work.nSpanRoots = mheap_.sweepSpans[mheap_.sweepgen/2%2].numBlocks()<br />
<br />
    // 计算扫描各个G的栈的任务数量<br />
    // On the first markroot, we need to scan all Gs. Gs<br />
    // may be created after this point, but it's okay that<br />
    // we ignore them because they begin life without any<br />
    // roots, so there's nothing to scan, and any roots<br />
    // they create during the concurrent phase will be<br />
    // scanned during mark termination. During mark<br />
    // termination, allglen isn't changing, so we'll scan<br />
    // all Gs.<br />
    work.nStackRoots = int(atomic.Loaduintptr(&amp;allglen))<br />
} else {<br />
    // We've already scanned span roots and kept the scan<br />
    // up-to-date during concurrent mark.<br />
    work.nSpanRoots = 0<br />
<br />
    // The hybrid barrier ensures that stacks can't<br />
    // contain pointers to unmarked objects, so on the<br />
    // second markroot, there's no need to scan stacks.<br />
    work.nStackRoots = 0<br />
<br />
    if debug.gcrescanstacks &gt; 0 {<br />
        // Scan stacks anyway for debugging.<br />
        work.nStackRoots = int(atomic.Loaduintptr(&amp;allglen))<br />
    }<br />
}<br />
<br />
// 计算总任务数量<br />
// 后台标记任务会对markrootNext进行原子递增, 来决定做哪个任务<br />
// 这种用数值来实现锁自由队列的办法挺聪明的, 尽管google工程师觉得不好(看后面markroot函数的分析)<br />
work.markrootNext = 0<br />
work.markrootJobs = uint32(fixedRootCount + work.nFlushCacheRoots + work.nDataRoots + work.nBSSRoots + work.nSpanRoots + work.nStackRoots) } gcMarkTinyAllocs函数会标记所有tiny alloc等待合并的对象:<br />
</code></pre></div></div><br />
<br />
<p>// gcMarkTinyAllocs greys all active tiny alloc blocks.<br />
//<br />
// The world must be stopped.<br />
func gcMarkTinyAllocs() {<br />
    for _, p := range &amp;allp {<br />
        if p == nil || p.status == _Pdead {<br />
            break<br />
        }<br />
        c := p.mcache<br />
        if c == nil || c.tiny == 0 {<br />
            continue<br />
        }<br />
        // 标记各个P中的mcache中的tiny<br />
        // 在上面的mallocgc函数中可以看到tiny是当前等待合并的对象<br />
        _, hbits, span, objIndex := heapBitsForObject(c.tiny, 0, 0)<br />
        gcw := &amp;p.gcw<br />
        // 标记一个对象存活, 并把它加到标记队列(该对象变为灰色)<br />
        greyobject(c.tiny, 0, 0, hbits, span, gcw, objIndex)<br />
        // gcBlackenPromptly变量表示当前是否禁止本地队列, 如果已禁止则把标记任务flush到全局队列<br />
        if gcBlackenPromptly {<br />
            gcw.dispose()<br />
        }<br />
    }<br />
}<br />
startTheWorldWithSema函数会重新启动世界:</p><br />
<br />
<p>func startTheWorldWithSema() {<br />
    <em>g</em> := getg()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 禁止G被抢占<br />
_g_.m.locks++        // disable preemption because it can be holding p in a local var<br />
<br />
// 判断收到的网络事件(fd可读可写或错误)并添加对应的G到待运行队列<br />
gp := netpoll(false) // non-blocking<br />
injectglist(gp)<br />
<br />
// 判断是否要启动gc helper<br />
add := needaddgcproc()<br />
lock(&amp;sched.lock)<br />
<br />
// 如果要求改变gomaxprocs则调整P的数量<br />
// procresize会返回有可运行任务的P的链表<br />
procs := gomaxprocs<br />
if newprocs != 0 {<br />
    procs = newprocs<br />
    newprocs = 0<br />
}<br />
p1 := procresize(procs)<br />
<br />
// 取消GC等待标记<br />
sched.gcwaiting = 0<br />
<br />
// 如果sysmon在等待则唤醒它<br />
if sched.sysmonwait != 0 {<br />
    sched.sysmonwait = 0<br />
    notewakeup(&amp;sched.sysmonnote)<br />
}<br />
unlock(&amp;sched.lock)<br />
<br />
// 唤醒有可运行任务的P<br />
for p1 != nil {<br />
    p := p1<br />
    p1 = p1.link.ptr()<br />
    if p.m != 0 {<br />
        mp := p.m.ptr()<br />
        p.m = 0<br />
        if mp.nextp != 0 {<br />
            throw("startTheWorld: inconsistent mp-&gt;nextp")<br />
        }<br />
        mp.nextp.set(p)<br />
        notewakeup(&amp;mp.park)<br />
    } else {<br />
        // Start M to run P.  Do not start another M below.<br />
        newm(nil, p)<br />
        add = false<br />
    }<br />
}<br />
<br />
// 如果有空闲的P，并且没有自旋中的M则唤醒或者创建一个M<br />
// Wakeup an additional proc in case we have excessive runnable goroutines<br />
// in local queues or in the global queue. If we don't, the proc will park itself.<br />
// If we have lots of excessive work, resetspinning will unpark additional procs as necessary.<br />
if atomic.Load(&amp;sched.npidle) != 0 &amp;&amp; atomic.Load(&amp;sched.nmspinning) == 0 {<br />
    wakep()<br />
}<br />
<br />
// 启动gc helper<br />
if add {<br />
    // If GC could have used another helper proc, start one now,<br />
    // in the hope that it will be available next time.<br />
    // It would have been even better to start it before the collection,<br />
    // but doing so requires allocating memory, so it's tricky to<br />
    // coordinate. This lazy approach works out in practice:<br />
    // we don't mind if the first couple gc rounds don't have quite<br />
    // the maximum number of procs.<br />
    newm(mhelpgc, nil)<br />
}<br />
<br />
// 允许G被抢占<br />
_g_.m.locks--<br />
<br />
// 如果当前G要求被抢占则重新尝试<br />
if _g_.m.locks == 0 &amp;&amp; _g_.preempt { // restore the preemption request in case we've cleared it in newstack<br />
    _g_.stackguard0 = stackPreempt<br />
} } 重启世界后各个M会重新开始调度, 调度时会优先使用上面提到的findRunnableGCWorker函数查找任务, 之后就有大约25%的P运行后台标记任务. 后台标记任务的函数是gcBgMarkWorker:<br />
</code></pre></div></div><br />
<br />
<p>func gcBgMarkWorker(<em>p</em> *p) {<br />
    gp := getg()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 用于休眠后重新获取P的构造体<br />
type parkInfo struct {<br />
    m      muintptr // Release this m on park.<br />
    attach puintptr // If non-nil, attach to this p on park.<br />
}<br />
// We pass park to a gopark unlock function, so it can't be on<br />
// the stack (see gopark). Prevent deadlock from recursively<br />
// starting GC by disabling preemption.<br />
gp.m.preemptoff = "GC worker init"<br />
park := new(parkInfo)<br />
gp.m.preemptoff = ""<br />
<br />
// 设置当前的M并禁止抢占<br />
park.m.set(acquirem())<br />
// 设置当前的P(需要关联到的P)<br />
park.attach.set(_p_)<br />
<br />
// 通知gcBgMarkStartWorkers可以继续处理<br />
// Inform gcBgMarkStartWorkers that this worker is ready.<br />
// After this point, the background mark worker is scheduled<br />
// cooperatively by gcController.findRunnable. Hence, it must<br />
// never be preempted, as this would put it into _Grunnable<br />
// and put it on a run queue. Instead, when the preempt flag<br />
// is set, this puts itself into _Gwaiting to be woken up by<br />
// gcController.findRunnable at the appropriate time.<br />
notewakeup(&amp;work.bgMarkReady)<br />
<br />
for {<br />
    // 让当前G进入休眠<br />
    // Go to sleep until woken by gcController.findRunnable.<br />
    // We can't releasem yet since even the call to gopark<br />
    // may be preempted.<br />
    gopark(func(g *g, parkp unsafe.Pointer) bool {<br />
        park := (*parkInfo)(parkp)<br />
        <br />
        // 重新允许抢占<br />
        // The worker G is no longer running, so it's<br />
        // now safe to allow preemption.<br />
        releasem(park.m.ptr())<br />
        <br />
        // 设置关联的P<br />
        // 把当前的G设到P的gcBgMarkWorker成员, 下次findRunnableGCWorker会使用<br />
        // 设置失败时不休眠<br />
        // If the worker isn't attached to its P,<br />
        // attach now. During initialization and after<br />
        // a phase change, the worker may have been<br />
        // running on a different P. As soon as we<br />
        // attach, the owner P may schedule the<br />
        // worker, so this must be done after the G is<br />
        // stopped.<br />
        if park.attach != 0 {<br />
            p := park.attach.ptr()<br />
            park.attach.set(nil)<br />
            // cas the worker because we may be<br />
            // racing with a new worker starting<br />
            // on this P.<br />
            if !p.gcBgMarkWorker.cas(0, guintptr(unsafe.Pointer(g))) {<br />
                // The P got a new worker.<br />
                // Exit this worker.<br />
                return false<br />
            }<br />
        }<br />
        return true<br />
    }, unsafe.Pointer(park), "GC worker (idle)", traceEvGoBlock, 0)<br />
    <br />
    // 检查P的gcBgMarkWorker是否和当前的G一致, 不一致时结束当前的任务<br />
    // Loop until the P dies and disassociates this<br />
    // worker (the P may later be reused, in which case<br />
    // it will get a new worker) or we failed to associate.<br />
    if _p_.gcBgMarkWorker.ptr() != gp {<br />
        break<br />
    }<br />
    <br />
    // 禁止G被抢占<br />
    // Disable preemption so we can use the gcw. If the<br />
    // scheduler wants to preempt us, we'll stop draining,<br />
    // dispose the gcw, and then preempt.<br />
    park.m.set(acquirem())<br />
    <br />
    if gcBlackenEnabled == 0 {<br />
        throw("gcBgMarkWorker: blackening not enabled")<br />
    }<br />
    <br />
    // 记录开始时间<br />
    startTime := nanotime()<br />
    <br />
    decnwait := atomic.Xadd(&amp;work.nwait, -1)<br />
    if decnwait == work.nproc {<br />
        println("runtime: work.nwait=", decnwait, "work.nproc=", work.nproc)<br />
        throw("work.nwait was &gt; work.nproc")<br />
    }<br />
    <br />
    // 切换到g0运行<br />
    systemstack(func() {<br />
        // 设置G的状态为等待中这样它的栈可以被扫描(两个后台标记任务可以互相扫描对方的栈)<br />
        // Mark our goroutine preemptible so its stack<br />
        // can be scanned. This lets two mark workers<br />
        // scan each other (otherwise, they would<br />
        // deadlock). We must not modify anything on<br />
        // the G stack. However, stack shrinking is<br />
        // disabled for mark workers, so it is safe to<br />
        // read from the G stack.<br />
        casgstatus(gp, _Grunning, _Gwaiting)<br />
        <br />
        // 判断后台标记任务的模式<br />
        switch _p_.gcMarkWorkerMode {<br />
        default:<br />
            throw("gcBgMarkWorker: unexpected gcMarkWorkerMode")<br />
        case gcMarkWorkerDedicatedMode:<br />
            // 这个模式下P应该专心执行标记<br />
            // 执行标记, 直到被抢占, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G<br />
            gcDrain(&amp;_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)<br />
            // 被抢占时把本地运行队列中的所有G都踢到全局运行队列<br />
            if gp.preempt {<br />
                // We were preempted. This is<br />
                // a useful signal to kick<br />
                // everything out of the run<br />
                // queue so it can run<br />
                // somewhere else.<br />
                lock(&amp;sched.lock)<br />
                for {<br />
                    gp, _ := runqget(_p_)<br />
                    if gp == nil {<br />
                        break<br />
                    }<br />
                    globrunqput(gp)<br />
                }<br />
                unlock(&amp;sched.lock)<br />
            }<br />
            // 继续执行标记, 直到无更多任务, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G<br />
            // Go back to draining, this time<br />
            // without preemption.<br />
            gcDrain(&amp;_p_.gcw, gcDrainNoBlock|gcDrainFlushBgCredit)<br />
        case gcMarkWorkerFractionalMode:<br />
            // 这个模式下P应该适当执行标记<br />
            // 执行标记, 直到被抢占, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G<br />
            gcDrain(&amp;_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)<br />
        case gcMarkWorkerIdleMode:<br />
            // 这个模式下P只在空闲时执行标记<br />
            // 执行标记, 直到被抢占或者达到一定的量, 并且需要计算后台的扫描量来减少辅助GC和唤醒等待中的G<br />
            gcDrain(&amp;_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)<br />
        }<br />
        <br />
        // 恢复G的状态到运行中<br />
        casgstatus(gp, _Gwaiting, _Grunning)<br />
    })<br />
    <br />
    // 如果标记了禁止本地标记队列则flush到全局标记队列<br />
    // If we are nearing the end of mark, dispose<br />
    // of the cache promptly. We must do this<br />
    // before signaling that we're no longer<br />
    // working so that other workers can't observe<br />
    // no workers and no work while we have this<br />
    // cached, and before we compute done.<br />
    if gcBlackenPromptly {<br />
        _p_.gcw.dispose()<br />
    }<br />
    <br />
    // 累加所用时间<br />
    // Account for time.<br />
    duration := nanotime() - startTime<br />
    switch _p_.gcMarkWorkerMode {<br />
    case gcMarkWorkerDedicatedMode:<br />
        atomic.Xaddint64(&amp;gcController.dedicatedMarkTime, duration)<br />
        atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, 1)<br />
    case gcMarkWorkerFractionalMode:<br />
        atomic.Xaddint64(&amp;gcController.fractionalMarkTime, duration)<br />
        atomic.Xaddint64(&amp;gcController.fractionalMarkWorkersNeeded, 1)<br />
    case gcMarkWorkerIdleMode:<br />
        atomic.Xaddint64(&amp;gcController.idleMarkTime, duration)<br />
    }<br />
    <br />
    // Was this the last worker and did we run out<br />
    // of work?<br />
    incnwait := atomic.Xadd(&amp;work.nwait, +1)<br />
    if incnwait &gt; work.nproc {<br />
        println("runtime: p.gcMarkWorkerMode=", _p_.gcMarkWorkerMode,<br />
            "work.nwait=", incnwait, "work.nproc=", work.nproc)<br />
        throw("work.nwait &gt; work.nproc")<br />
    }<br />
    <br />
    // 判断是否所有后台标记任务都完成, 并且没有更多的任务<br />
    // If this worker reached a background mark completion<br />
    // point, signal the main GC goroutine.<br />
    if incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil) {<br />
        // 取消和P的关联<br />
        // Make this G preemptible and disassociate it<br />
        // as the worker for this P so<br />
        // findRunnableGCWorker doesn't try to<br />
        // schedule it.<br />
        _p_.gcBgMarkWorker.set(nil)<br />
        <br />
        // 允许G被抢占<br />
        releasem(park.m.ptr())<br />
        <br />
        // 准备进入完成标记阶段<br />
        gcMarkDone()<br />
        <br />
        // 休眠之前会重新关联P<br />
        // 因为上面允许被抢占, 到这里的时候可能就会变成其他P<br />
        // 如果重新关联P失败则这个任务会结束<br />
        // Disable preemption and prepare to reattach<br />
        // to the P.<br />
        //<br />
        // We may be running on a different P at this<br />
        // point, so we can't reattach until this G is<br />
        // parked.<br />
        park.m.set(acquirem())<br />
        park.attach.set(_p_)<br />
    }<br />
} } gcDrain函数用于执行标记:<br />
</code></pre></div></div><br />
<br />
<p>// gcDrain scans roots and objects in work buffers, blackening grey<br />
// objects until all roots and work buffers have been drained.<br />
//<br />
// If flags&amp;gcDrainUntilPreempt != 0, gcDrain returns when g.preempt<br />
// is set. This implies gcDrainNoBlock.<br />
//<br />
// If flags&amp;gcDrainIdle != 0, gcDrain returns when there is other work<br />
// to do. This implies gcDrainNoBlock.<br />
//<br />
// If flags&amp;gcDrainNoBlock != 0, gcDrain returns as soon as it is<br />
// unable to get more work. Otherwise, it will block until all<br />
// blocking calls are blocked in gcDrain.<br />
//<br />
// If flags&amp;gcDrainFlushBgCredit != 0, gcDrain flushes scan work<br />
// credit to gcController.bgScanCredit every gcCreditSlack units of<br />
// scan work.<br />
//<br />
//go:nowritebarrier<br />
func gcDrain(gcw *gcWork, flags gcDrainFlags) {<br />
    if !writeBarrier.needed {<br />
        throw(“gcDrain phase incorrect”)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gp := getg().m.curg<br />
<br />
// 看到抢占标志时是否要返回<br />
preemptible := flags&amp;gcDrainUntilPreempt != 0<br />
<br />
// 没有任务时是否要等待任务<br />
blocking := flags&amp;(gcDrainUntilPreempt|gcDrainIdle|gcDrainNoBlock) == 0<br />
<br />
// 是否计算后台的扫描量来减少辅助GC和唤醒等待中的G<br />
flushBgCredit := flags&amp;gcDrainFlushBgCredit != 0<br />
<br />
// 是否只执行一定量的工作<br />
idle := flags&amp;gcDrainIdle != 0<br />
<br />
// 记录初始的已扫描数量<br />
initScanWork := gcw.scanWork<br />
<br />
// 扫描idleCheckThreshold(100000)个对象以后检查是否要返回<br />
// idleCheck is the scan work at which to perform the next<br />
// idle check with the scheduler.<br />
idleCheck := initScanWork + idleCheckThreshold<br />
<br />
// 如果根对象未扫描完, 则先扫描根对象<br />
// Drain root marking jobs.<br />
if work.markrootNext &lt; work.markrootJobs {<br />
    // 如果标记了preemptible, 循环直到被抢占<br />
    for !(preemptible &amp;&amp; gp.preempt) {<br />
        // 从根对象扫描队列取出一个值(原子递增)<br />
        job := atomic.Xadd(&amp;work.markrootNext, +1) - 1<br />
        if job &gt;= work.markrootJobs {<br />
            break<br />
        }<br />
        // 执行根对象扫描工作<br />
        markroot(gcw, job)<br />
        // 如果是idle模式并且有其他工作, 则返回<br />
        if idle &amp;&amp; pollWork() {<br />
            goto done<br />
        }<br />
    }<br />
}<br />
<br />
// 根对象已经在标记队列中, 消费标记队列<br />
// 如果标记了preemptible, 循环直到被抢占<br />
// Drain heap marking jobs.<br />
for !(preemptible &amp;&amp; gp.preempt) {<br />
    // 如果全局标记队列为空, 把本地标记队列的一部分工作分过去<br />
    // (如果wbuf2不为空则移动wbuf2过去, 否则移动wbuf1的一半过去)<br />
    // Try to keep work available on the global queue. We used to<br />
    // check if there were waiting workers, but it's better to<br />
    // just keep work available than to make workers wait. In the<br />
    // worst case, we'll do O(log(_WorkbufSize)) unnecessary<br />
    // balances.<br />
    if work.full == 0 {<br />
        gcw.balance()<br />
    }<br />
    <br />
    // 从本地标记队列中获取对象, 获取不到则从全局标记队列获取<br />
    var b uintptr<br />
    if blocking {<br />
        // 阻塞获取<br />
        b = gcw.get()<br />
    } else {<br />
        // 非阻塞获取<br />
        b = gcw.tryGetFast()<br />
        if b == 0 {<br />
            b = gcw.tryGet()<br />
        }<br />
    }<br />
    <br />
    // 获取不到对象, 标记队列已为空, 跳出循环<br />
    if b == 0 {<br />
        // work barrier reached or tryGet failed.<br />
        break<br />
    }<br />
    <br />
    // 扫描获取到的对象<br />
    scanobject(b, gcw)<br />
    <br />
    // 如果已经扫描了一定数量的对象(gcCreditSlack的值是2000)<br />
    // Flush background scan work credit to the global<br />
    // account if we've accumulated enough locally so<br />
    // mutator assists can draw on it.<br />
    if gcw.scanWork &gt;= gcCreditSlack {<br />
        // 把扫描的对象数量添加到全局<br />
        atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)<br />
        // 减少辅助GC的工作量和唤醒等待中的G<br />
        if flushBgCredit {<br />
            gcFlushBgCredit(gcw.scanWork - initScanWork)<br />
            initScanWork = 0<br />
        }<br />
        idleCheck -= gcw.scanWork<br />
        gcw.scanWork = 0<br />
        <br />
        // 如果是idle模式且达到了检查的扫描量, 则检查是否有其他任务(G), 如果有则跳出循环<br />
        if idle &amp;&amp; idleCheck &lt;= 0 {<br />
            idleCheck += idleCheckThreshold<br />
            if pollWork() {<br />
                break<br />
            }<br />
        }<br />
    }<br />
}<br />
<br />
// In blocking mode, write barriers are not allowed after this<br />
// point because we must preserve the condition that the work<br />
// buffers are empty.<br />
</code></pre></div></div><br />
<br />
<p>done:<br />
    // 把扫描的对象数量添加到全局<br />
    // Flush remaining scan work credit.<br />
    if gcw.scanWork &gt; 0 {<br />
        atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)<br />
        // 减少辅助GC的工作量和唤醒等待中的G<br />
        if flushBgCredit {<br />
            gcFlushBgCredit(gcw.scanWork - initScanWork)<br />
        }<br />
        gcw.scanWork = 0<br />
    }<br />
}<br />
markroot函数用于执行根对象扫描工作:</p><br />
<br />
<p>// markroot scans the i’th root.<br />
//<br />
// Preemption must be disabled (because this uses a gcWork).<br />
//<br />
// nowritebarrier is only advisory here.<br />
//<br />
//go:nowritebarrier<br />
func markroot(gcw *gcWork, i uint32) {<br />
    // 判断取出的数值对应哪种任务<br />
    // (google的工程师觉得这种办法可笑)<br />
    // TODO(austin): This is a bit ridiculous. Compute and store<br />
    // the bases in gcMarkRootPrepare instead of the counts.<br />
    baseFlushCache := uint32(fixedRootCount)<br />
    baseData := baseFlushCache + uint32(work.nFlushCacheRoots)<br />
    baseBSS := baseData + uint32(work.nDataRoots)<br />
    baseSpans := baseBSS + uint32(work.nBSSRoots)<br />
    baseStacks := baseSpans + uint32(work.nSpanRoots)<br />
    end := baseStacks + uint32(work.nStackRoots)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Note: if you add a case here, please also update heapdump.go:dumproots.<br />
switch {<br />
// 释放mcache中的所有span, 要求STW<br />
case baseFlushCache &lt;= i &amp;&amp; i &lt; baseData:<br />
    flushmcache(int(i - baseFlushCache))<br />
<br />
// 扫描可读写的全局变量<br />
// 这里只会扫描i对应的block, 扫描时传入包含哪里有指针的bitmap数据<br />
case baseData &lt;= i &amp;&amp; i &lt; baseBSS:<br />
    for _, datap := range activeModules() {<br />
        markrootBlock(datap.data, datap.edata-datap.data, datap.gcdatamask.bytedata, gcw, int(i-baseData))<br />
    }<br />
<br />
// 扫描只读的全局变量<br />
// 这里只会扫描i对应的block, 扫描时传入包含哪里有指针的bitmap数据<br />
case baseBSS &lt;= i &amp;&amp; i &lt; baseSpans:<br />
    for _, datap := range activeModules() {<br />
        markrootBlock(datap.bss, datap.ebss-datap.bss, datap.gcbssmask.bytedata, gcw, int(i-baseBSS))<br />
    }<br />
<br />
// 扫描析构器队列<br />
case i == fixedRootFinalizers:<br />
    // Only do this once per GC cycle since we don't call<br />
    // queuefinalizer during marking.<br />
    if work.markrootDone {<br />
        break<br />
    }<br />
    for fb := allfin; fb != nil; fb = fb.alllink {<br />
        cnt := uintptr(atomic.Load(&amp;fb.cnt))<br />
        scanblock(uintptr(unsafe.Pointer(&amp;fb.fin[0])), cnt*unsafe.Sizeof(fb.fin[0]), &amp;finptrmask[0], gcw)<br />
    }<br />
<br />
// 释放已中止的G的栈<br />
case i == fixedRootFreeGStacks:<br />
    // Only do this once per GC cycle; preferably<br />
    // concurrently.<br />
    if !work.markrootDone {<br />
        // Switch to the system stack so we can call<br />
        // stackfree.<br />
        systemstack(markrootFreeGStacks)<br />
    }<br />
<br />
// 扫描各个span中特殊对象(析构器列表)<br />
case baseSpans &lt;= i &amp;&amp; i &lt; baseStacks:<br />
    // mark MSpan.specials<br />
    markrootSpans(gcw, int(i-baseSpans))<br />
<br />
// 扫描各个G的栈<br />
default:<br />
    // 获取需要扫描的G<br />
    // the rest is scanning goroutine stacks<br />
    var gp *g<br />
    if baseStacks &lt;= i &amp;&amp; i &lt; end {<br />
        gp = allgs[i-baseStacks]<br />
    } else {<br />
        throw("markroot: bad index")<br />
    }<br />
<br />
    // 记录等待开始的时间<br />
    // remember when we've first observed the G blocked<br />
    // needed only to output in traceback<br />
    status := readgstatus(gp) // We are not in a scan state<br />
    if (status == _Gwaiting || status == _Gsyscall) &amp;&amp; gp.waitsince == 0 {<br />
        gp.waitsince = work.tstart<br />
    }<br />
<br />
    // 切换到g0运行(有可能会扫到自己的栈)<br />
    // scang must be done on the system stack in case<br />
    // we're trying to scan our own stack.<br />
    systemstack(func() {<br />
        // 判断扫描的栈是否自己的<br />
        // If this is a self-scan, put the user G in<br />
        // _Gwaiting to prevent self-deadlock. It may<br />
        // already be in _Gwaiting if this is a mark<br />
        // worker or we're in mark termination.<br />
        userG := getg().m.curg<br />
        selfScan := gp == userG &amp;&amp; readgstatus(userG) == _Grunning<br />
        <br />
        // 如果正在扫描自己的栈则切换状态到等待中防止死锁<br />
        if selfScan {<br />
            casgstatus(userG, _Grunning, _Gwaiting)<br />
            userG.waitreason = "garbage collection scan"<br />
        }<br />
        <br />
        // 扫描G的栈<br />
        // TODO: scang blocks until gp's stack has<br />
        // been scanned, which may take a while for<br />
        // running goroutines. Consider doing this in<br />
        // two phases where the first is non-blocking:<br />
        // we scan the stacks we can and ask running<br />
        // goroutines to scan themselves; and the<br />
        // second blocks.<br />
        scang(gp, gcw)<br />
        <br />
        // 如果正在扫描自己的栈则把状态切换回运行中<br />
        if selfScan {<br />
            casgstatus(userG, _Gwaiting, _Grunning)<br />
        }<br />
    })<br />
} } scang函数负责扫描G的栈:<br />
</code></pre></div></div><br />
<br />
<p>// scang blocks until gp’s stack has been scanned.<br />
// It might be scanned by scang or it might be scanned by the goroutine itself.<br />
// Either way, the stack scan has completed when scang returns.<br />
func scang(gp *g, gcw *gcWork) {<br />
    // Invariant; we (the caller, markroot for a specific goroutine) own gp.gcscandone.<br />
    // Nothing is racing with us now, but gcscandone might be set to true left over<br />
    // from an earlier round of stack scanning (we scan twice per GC).<br />
    // We use gcscandone to record whether the scan has been done during this round.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 标记扫描未完成<br />
gp.gcscandone = false<br />
<br />
// See http://golang.org/cl/21503 for justification of the yield delay.<br />
const yieldDelay = 10 * 1000<br />
var nextYield int64<br />
<br />
// 循环直到扫描完成<br />
// Endeavor to get gcscandone set to true,<br />
// either by doing the stack scan ourselves or by coercing gp to scan itself.<br />
// gp.gcscandone can transition from false to true when we're not looking<br />
// (if we asked for preemption), so any time we lock the status using<br />
// castogscanstatus we have to double-check that the scan is still not done. loop:<br />
for i := 0; !gp.gcscandone; i++ {<br />
    // 判断G的当前状态<br />
    switch s := readgstatus(gp); s {<br />
    default:<br />
        dumpgstatus(gp)<br />
        throw("stopg: invalid status")<br />
<br />
    // G已中止, 不需要扫描它<br />
    case _Gdead:<br />
        // No stack.<br />
        gp.gcscandone = true<br />
        break loop<br />
<br />
    // G的栈正在扩展, 下一轮重试<br />
    case _Gcopystack:<br />
    // Stack being switched. Go around again.<br />
<br />
    // G不是运行中, 首先需要防止它运行<br />
    case _Grunnable, _Gsyscall, _Gwaiting:<br />
        // Claim goroutine by setting scan bit.<br />
        // Racing with execution or readying of gp.<br />
        // The scan bit keeps them from running<br />
        // the goroutine until we're done.<br />
        if castogscanstatus(gp, s, s|_Gscan) {<br />
            // 原子切换状态成功时扫描它的栈<br />
            if !gp.gcscandone {<br />
                scanstack(gp, gcw)<br />
                gp.gcscandone = true<br />
            }<br />
            // 恢复G的状态, 并跳出循环<br />
            restartg(gp)<br />
            break loop<br />
        }<br />
<br />
    // G正在扫描它自己, 等待扫描完毕<br />
    case _Gscanwaiting:<br />
    // newstack is doing a scan for us right now. Wait.<br />
<br />
    // G正在运行<br />
    case _Grunning:<br />
        // Goroutine running. Try to preempt execution so it can scan itself.<br />
        // The preemption handler (in newstack) does the actual scan.<br />
<br />
        // 如果已经有抢占请求, 则抢占成功时会帮我们处理<br />
        // Optimization: if there is already a pending preemption request<br />
        // (from the previous loop iteration), don't bother with the atomics.<br />
        if gp.preemptscan &amp;&amp; gp.preempt &amp;&amp; gp.stackguard0 == stackPreempt {<br />
            break<br />
        }<br />
<br />
        // 抢占G, 抢占成功时G会扫描它自己<br />
        // Ask for preemption and self scan.<br />
        if castogscanstatus(gp, _Grunning, _Gscanrunning) {<br />
            if !gp.gcscandone {<br />
                gp.preemptscan = true<br />
                gp.preempt = true<br />
                gp.stackguard0 = stackPreempt<br />
            }<br />
            casfrom_Gscanstatus(gp, _Gscanrunning, _Grunning)<br />
        }<br />
    }<br />
<br />
    // 第一轮休眠10毫秒, 第二轮休眠5毫秒<br />
    if i == 0 {<br />
        nextYield = nanotime() + yieldDelay<br />
    }<br />
    if nanotime() &lt; nextYield {<br />
        procyield(10)<br />
    } else {<br />
        osyield()<br />
        nextYield = nanotime() + yieldDelay/2<br />
    }<br />
}<br />
<br />
// 扫描完成, 取消抢占扫描的请求<br />
gp.preemptscan = false // cancel scan request if no longer needed } 设置preemptscan后, 在抢占G成功时会调用scanstack扫描它自己的栈, 具体代码在这里. 扫描栈用的函数是scanstack:<br />
</code></pre></div></div><br />
<br />
<p>// scanstack scans gp’s stack, greying all pointers found on the stack.<br />
//<br />
// scanstack is marked go:systemstack because it must not be preempted<br />
// while using a workbuf.<br />
//<br />
//go:nowritebarrier<br />
//go:systemstack<br />
func scanstack(gp *g, gcw *gcWork) {<br />
    if gp.gcscanvalid {<br />
        return<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if readgstatus(gp)&amp;_Gscan == 0 {<br />
    print("runtime:scanstack: gp=", gp, ", goid=", gp.goid, ", gp-&gt;atomicstatus=", hex(readgstatus(gp)), "\n")<br />
    throw("scanstack - bad status")<br />
}<br />
<br />
switch readgstatus(gp) &amp;^ _Gscan {<br />
default:<br />
    print("runtime: gp=", gp, ", goid=", gp.goid, ", gp-&gt;atomicstatus=", readgstatus(gp), "\n")<br />
    throw("mark - bad status")<br />
case _Gdead:<br />
    return<br />
case _Grunning:<br />
    print("runtime: gp=", gp, ", goid=", gp.goid, ", gp-&gt;atomicstatus=", readgstatus(gp), "\n")<br />
    throw("scanstack: goroutine not stopped")<br />
case _Grunnable, _Gsyscall, _Gwaiting:<br />
    // ok<br />
}<br />
<br />
if gp == getg() {<br />
    throw("can't scan our own stack")<br />
}<br />
mp := gp.m<br />
if mp != nil &amp;&amp; mp.helpgc != 0 {<br />
    throw("can't scan gchelper stack")<br />
}<br />
<br />
// Shrink the stack if not much of it is being used. During<br />
// concurrent GC, we can do this during concurrent mark.<br />
if !work.markrootDone {<br />
    shrinkstack(gp)<br />
}<br />
<br />
// Scan the stack.<br />
var cache pcvalueCache<br />
scanframe := func(frame *stkframe, unused unsafe.Pointer) bool {<br />
    // scanframeworker会根据代码地址(pc)获取函数信息<br />
    // 然后找到函数信息中的stackmap.bytedata, 它保存了函数的栈上哪些地方有指针<br />
    // 再调用scanblock来扫描函数的栈空间, 同时函数的参数也会这样扫描<br />
    scanframeworker(frame, &amp;cache, gcw)<br />
    return true<br />
}<br />
// 枚举所有调用帧, 分别调用scanframe函数<br />
gentraceback(^uintptr(0), ^uintptr(0), 0, gp, 0, nil, 0x7fffffff, scanframe, nil, 0)<br />
// 枚举所有defer的调用帧, 分别调用scanframe函数<br />
tracebackdefers(gp, scanframe, nil)<br />
gp.gcscanvalid = true } scanblock函数是一个通用的扫描函数, 扫描全局变量和栈空间都会用它, 和scanobject不同的是bitmap需要手动传入:<br />
</code></pre></div></div><br />
<br />
<p>// scanblock scans b as scanobject would, but using an explicit<br />
// pointer bitmap instead of the heap bitmap.<br />
//<br />
// This is used to scan non-heap roots, so it does not update<br />
// gcw.bytesMarked or gcw.scanWork.<br />
//<br />
//go:nowritebarrier<br />
func scanblock(b0, n0 uintptr, ptrmask *uint8, gcw *gcWork) {<br />
    // Use local copies of original parameters, so that a stack trace<br />
    // due to one of the throws below shows the original block<br />
    // base and extent.<br />
    b := b0<br />
    n := n0</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>arena_start := mheap_.arena_start<br />
arena_used := mheap_.arena_used<br />
<br />
// 枚举扫描的地址<br />
for i := uintptr(0); i &lt; n; {<br />
    // 找到bitmap中对应的byte<br />
    // Find bits for the next word.<br />
    bits := uint32(*addb(ptrmask, i/(sys.PtrSize*8)))<br />
    if bits == 0 {<br />
        i += sys.PtrSize * 8<br />
        continue<br />
    }<br />
    // 枚举byte<br />
    for j := 0; j &lt; 8 &amp;&amp; i &lt; n; j++ {<br />
        // 如果该地址包含指针<br />
        if bits&amp;1 != 0 {<br />
            // 标记在该地址的对象存活, 并把它加到标记队列(该对象变为灰色)<br />
            // Same work as in scanobject; see comments there.<br />
            obj := *(*uintptr)(unsafe.Pointer(b + i))<br />
            if obj != 0 &amp;&amp; arena_start &lt;= obj &amp;&amp; obj &lt; arena_used {<br />
                // 找到该对象对应的span和bitmap<br />
                if obj, hbits, span, objIndex := heapBitsForObject(obj, b, i); obj != 0 {<br />
                    // 标记一个对象存活, 并把它加到标记队列(该对象变为灰色)<br />
                    greyobject(obj, b, i, hbits, span, gcw, objIndex)<br />
                }<br />
            }<br />
        }<br />
        // 处理下一个指针下一个bit<br />
        bits &gt;&gt;= 1<br />
        i += sys.PtrSize<br />
    }<br />
} } greyobject用于标记一个对象存活, 并把它加到标记队列(该对象变为灰色):<br />
</code></pre></div></div><br />
<br />
<p>// obj is the start of an object with mark mbits.<br />
// If it isn’t already marked, mark it and enqueue into gcw.<br />
// base and off are for debugging only and could be removed.<br />
//go:nowritebarrierrec<br />
func greyobject(obj, base, off uintptr, hbits heapBits, span *mspan, gcw *gcWork, objIndex uintptr) {<br />
    // obj should be start of allocation, and so must be at least pointer-aligned.<br />
    if obj&amp;(sys.PtrSize-1) != 0 {<br />
        throw(“greyobject: obj not pointer-aligned”)<br />
    }<br />
    mbits := span.markBitsForIndex(objIndex)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if useCheckmark {<br />
    // checkmark是用于检查是否所有可到达的对象都被正确标记的机制, 仅除错使用<br />
    if !mbits.isMarked() {<br />
        printlock()<br />
        print("runtime:greyobject: checkmarks finds unexpected unmarked object obj=", hex(obj), "\n")<br />
        print("runtime: found obj at *(", hex(base), "+", hex(off), ")\n")<br />
<br />
        // Dump the source (base) object<br />
        gcDumpObject("base", base, off)<br />
<br />
        // Dump the object<br />
        gcDumpObject("obj", obj, ^uintptr(0))<br />
<br />
        getg().m.traceback = 2<br />
        throw("checkmark found unmarked object")<br />
    }<br />
    if hbits.isCheckmarked(span.elemsize) {<br />
        return<br />
    }<br />
    hbits.setCheckmarked(span.elemsize)<br />
    if !hbits.isCheckmarked(span.elemsize) {<br />
        throw("setCheckmarked and isCheckmarked disagree")<br />
    }<br />
} else {<br />
    if debug.gccheckmark &gt; 0 &amp;&amp; span.isFree(objIndex) {<br />
        print("runtime: marking free object ", hex(obj), " found at *(", hex(base), "+", hex(off), ")\n")<br />
        gcDumpObject("base", base, off)<br />
        gcDumpObject("obj", obj, ^uintptr(0))<br />
        getg().m.traceback = 2<br />
        throw("marking free object")<br />
    }<br />
<br />
    // 如果对象所在的span中的gcmarkBits对应的bit已经设置为1则可以跳过处理<br />
    // If marked we have nothing to do.<br />
    if mbits.isMarked() {<br />
        return<br />
    }<br />
    <br />
    // 设置对象所在的span中的gcmarkBits对应的bit为1<br />
    // mbits.setMarked() // Avoid extra call overhead with manual inlining.<br />
    atomic.Or8(mbits.bytep, mbits.mask)<br />
    <br />
    // 如果确定对象不包含指针(所在span的类型是noscan), 则不需要把对象放入标记队列<br />
    // If this is a noscan object, fast-track it to black<br />
    // instead of greying it.<br />
    if span.spanclass.noscan() {<br />
        gcw.bytesMarked += uint64(span.elemsize)<br />
        return<br />
    }<br />
}<br />
<br />
// 把对象放入标记队列<br />
// 先放入本地标记队列, 失败时把本地标记队列中的部分工作转移到全局标记队列, 再放入本地标记队列<br />
// Queue the obj for scanning. The PREFETCH(obj) logic has been removed but<br />
// seems like a nice optimization that can be added back in.<br />
// There needs to be time between the PREFETCH and the use.<br />
// Previously we put the obj in an 8 element buffer that is drained at a rate<br />
// to give the PREFETCH time to do its work.<br />
// Use of PREFETCHNTA might be more appropriate than PREFETCH<br />
if !gcw.putFast(obj) {<br />
    gcw.put(obj)<br />
} } gcDrain函数扫描完根对象, 就会开始消费标记队列, 对从标记队列中取出的对象调用scanobject函数:<br />
</code></pre></div></div><br />
<br />
<p>// scanobject scans the object starting at b, adding pointers to gcw.<br />
// b must point to the beginning of a heap object or an oblet.<br />
// scanobject consults the GC bitmap for the pointer mask and the<br />
// spans for the size of the object.<br />
//<br />
//go:nowritebarrier<br />
func scanobject(b uintptr, gcw <em>gcWork) {<br />
    // Note that arena_used may change concurrently during<br />
    // scanobject and hence scanobject may encounter a pointer to<br />
    // a newly allocated heap object that is *not</em> in<br />
    // [start,used). It will not mark this object; however, we<br />
    // know that it was just installed by a mutator, which means<br />
    // that mutator will execute a write barrier and take care of<br />
    // marking it. This is even more pronounced on relaxed memory<br />
    // architectures since we access arena_used without barriers<br />
    // or synchronization, but the same logic applies.<br />
    arena_start := mheap_.arena_start<br />
    arena_used := mheap_.arena_used</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Find the bits for b and the size of the object at b.<br />
//<br />
// b is either the beginning of an object, in which case this<br />
// is the size of the object to scan, or it points to an<br />
// oblet, in which case we compute the size to scan below.<br />
// 获取对象对应的bitmap<br />
hbits := heapBitsForAddr(b)<br />
<br />
// 获取对象所在的span<br />
s := spanOfUnchecked(b)<br />
<br />
// 获取对象的大小<br />
n := s.elemsize<br />
if n == 0 {<br />
    throw("scanobject n == 0")<br />
}<br />
<br />
// 对象大小过大时(maxObletBytes是128KB)需要分割扫描<br />
// 每次最多只扫描128KB<br />
if n &gt; maxObletBytes {<br />
    // Large object. Break into oblets for better<br />
    // parallelism and lower latency.<br />
    if b == s.base() {<br />
        // It's possible this is a noscan object (not<br />
        // from greyobject, but from other code<br />
        // paths), in which case we must *not* enqueue<br />
        // oblets since their bitmaps will be<br />
        // uninitialized.<br />
        if s.spanclass.noscan() {<br />
            // Bypass the whole scan.<br />
            gcw.bytesMarked += uint64(n)<br />
            return<br />
        }<br />
<br />
        // Enqueue the other oblets to scan later.<br />
        // Some oblets may be in b's scalar tail, but<br />
        // these will be marked as "no more pointers",<br />
        // so we'll drop out immediately when we go to<br />
        // scan those.<br />
        for oblet := b + maxObletBytes; oblet &lt; s.base()+s.elemsize; oblet += maxObletBytes {<br />
            if !gcw.putFast(oblet) {<br />
                gcw.put(oblet)<br />
            }<br />
        }<br />
    }<br />
<br />
    // Compute the size of the oblet. Since this object<br />
    // must be a large object, s.base() is the beginning<br />
    // of the object.<br />
    n = s.base() + s.elemsize - b<br />
    if n &gt; maxObletBytes {<br />
        n = maxObletBytes<br />
    }<br />
}<br />
<br />
// 扫描对象中的指针<br />
var i uintptr<br />
for i = 0; i &lt; n; i += sys.PtrSize {<br />
    // 获取对应的bit<br />
    // Find bits for this word.<br />
    if i != 0 {<br />
        // Avoid needless hbits.next() on last iteration.<br />
        hbits = hbits.next()<br />
    }<br />
    // Load bits once. See CL 22712 and issue 16973 for discussion.<br />
    bits := hbits.bits()<br />
    <br />
    // 检查scan bit判断是否继续扫描, 注意第二个scan bit是checkmark<br />
    // During checkmarking, 1-word objects store the checkmark<br />
    // in the type bit for the one word. The only one-word objects<br />
    // are pointers, or else they'd be merged with other non-pointer<br />
    // data into larger allocations.<br />
    if i != 1*sys.PtrSize &amp;&amp; bits&amp;bitScan == 0 {<br />
        break // no more pointers in this object<br />
    }<br />
    <br />
    // 检查pointer bit, 不是指针则继续<br />
    if bits&amp;bitPointer == 0 {<br />
        continue // not a pointer<br />
    }<br />
<br />
    // 取出指针的值<br />
    // Work here is duplicated in scanblock and above.<br />
    // If you make changes here, make changes there too.<br />
    obj := *(*uintptr)(unsafe.Pointer(b + i))<br />
<br />
    // 如果指针在arena区域中, 则调用greyobject标记对象并把对象放到标记队列中<br />
    // At this point we have extracted the next potential pointer.<br />
    // Check if it points into heap and not back at the current object.<br />
    if obj != 0 &amp;&amp; arena_start &lt;= obj &amp;&amp; obj &lt; arena_used &amp;&amp; obj-b &gt;= n {<br />
        // Mark the object.<br />
        if obj, hbits, span, objIndex := heapBitsForObject(obj, b, i); obj != 0 {<br />
            greyobject(obj, b, i, hbits, span, gcw, objIndex)<br />
        }<br />
    }<br />
}<br />
<br />
// 统计扫描过的大小和对象数量<br />
gcw.bytesMarked += uint64(n)<br />
gcw.scanWork += int64(i) } 在所有后台标记任务都把标记队列消费完毕时, 会执行gcMarkDone函数准备进入完成标记阶段(mark termination): 在并行GC中gcMarkDone会被执行两次, 第一次会禁止本地标记队列然后重新开始后台标记任务, 第二次会进入完成标记阶段(mark termination)。<br />
</code></pre></div></div><br />
<br />
<p>// gcMarkDone transitions the GC from mark 1 to mark 2 and from mark 2<br />
// to mark termination.<br />
//<br />
// This should be called when all mark work has been drained. In mark<br />
// 1, this includes all root marking jobs, global work buffers, and<br />
// active work buffers in assists and background workers; however,<br />
// work may still be cached in per-P work buffers. In mark 2, per-P<br />
// caches are disabled.<br />
//<br />
// The calling context must be preemptible.<br />
//<br />
// Note that it is explicitly okay to have write barriers in this<br />
// function because completion of concurrent mark is best-effort<br />
// anyway. Any work created by write barriers here will be cleaned up<br />
// by mark termination.<br />
func gcMarkDone() {<br />
top:<br />
    semacquire(&amp;work.markDoneSema)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Re-check transition condition under transition lock.<br />
if !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil)) {<br />
    semrelease(&amp;work.markDoneSema)<br />
    return<br />
}<br />
<br />
// 暂时禁止启动新的后台标记任务<br />
// Disallow starting new workers so that any remaining workers<br />
// in the current mark phase will drain out.<br />
//<br />
// TODO(austin): Should dedicated workers keep an eye on this<br />
// and exit gcDrain promptly?<br />
atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, -0xffffffff)<br />
atomic.Xaddint64(&amp;gcController.fractionalMarkWorkersNeeded, -0xffffffff)<br />
<br />
// 判断本地标记队列是否已禁用<br />
if !gcBlackenPromptly {<br />
    // 本地标记队列是否未禁用, 禁用然后重新开始后台标记任务<br />
    // Transition from mark 1 to mark 2.<br />
    //<br />
    // The global work list is empty, but there can still be work<br />
    // sitting in the per-P work caches.<br />
    // Flush and disable work caches.<br />
<br />
    // 禁用本地标记队列<br />
    // Disallow caching workbufs and indicate that we're in mark 2.<br />
    gcBlackenPromptly = true<br />
<br />
    // Prevent completion of mark 2 until we've flushed<br />
    // cached workbufs.<br />
    atomic.Xadd(&amp;work.nwait, -1)<br />
<br />
    // GC is set up for mark 2. Let Gs blocked on the<br />
    // transition lock go while we flush caches.<br />
    semrelease(&amp;work.markDoneSema)<br />
<br />
    // 把所有本地标记队列中的对象都推到全局标记队列<br />
    systemstack(func() {<br />
        // Flush all currently cached workbufs and<br />
        // ensure all Ps see gcBlackenPromptly. This<br />
        // also blocks until any remaining mark 1<br />
        // workers have exited their loop so we can<br />
        // start new mark 2 workers.<br />
        forEachP(func(_p_ *p) {<br />
            _p_.gcw.dispose()<br />
        })<br />
    })<br />
<br />
    // 除错用<br />
    // Check that roots are marked. We should be able to<br />
    // do this before the forEachP, but based on issue<br />
    // #16083 there may be a (harmless) race where we can<br />
    // enter mark 2 while some workers are still scanning<br />
    // stacks. The forEachP ensures these scans are done.<br />
    //<br />
    // TODO(austin): Figure out the race and fix this<br />
    // properly.<br />
    gcMarkRootCheck()<br />
<br />
    // 允许启动新的后台标记任务<br />
    // Now we can start up mark 2 workers.<br />
    atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, 0xffffffff)<br />
    atomic.Xaddint64(&amp;gcController.fractionalMarkWorkersNeeded, 0xffffffff)<br />
<br />
    // 如果确定没有更多的任务则可以直接跳到函数顶部<br />
    // 这样就当作是第二次调用了<br />
    incnwait := atomic.Xadd(&amp;work.nwait, +1)<br />
    if incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil) {<br />
        // This loop will make progress because<br />
        // gcBlackenPromptly is now true, so it won't<br />
        // take this same "if" branch.<br />
        goto top<br />
    }<br />
} else {<br />
    // 记录完成标记阶段开始的时间和STW开始的时间<br />
    // Transition to mark termination.<br />
    now := nanotime()<br />
    work.tMarkTerm = now<br />
    work.pauseStart = now<br />
    <br />
    // 禁止G被抢占<br />
    getg().m.preemptoff = "gcing"<br />
    <br />
    // 停止所有运行中的G, 并禁止它们运行<br />
    systemstack(stopTheWorldWithSema)<br />
    <br />
    // !!!!!!!!!!!!!!!!<br />
    // 世界已停止(STW)...<br />
    // !!!!!!!!!!!!!!!!<br />
    <br />
    // The gcphase is _GCmark, it will transition to _GCmarktermination<br />
    // below. The important thing is that the wb remains active until<br />
    // all marking is complete. This includes writes made by the GC.<br />
    <br />
    // 标记对根对象的扫描已完成, 会影响gcMarkRootPrepare中的处理<br />
    // Record that one root marking pass has completed.<br />
    work.markrootDone = true<br />
    <br />
    // 禁止辅助GC和后台标记任务的运行<br />
    // Disable assists and background workers. We must do<br />
    // this before waking blocked assists.<br />
    atomic.Store(&amp;gcBlackenEnabled, 0)<br />
    <br />
    // 唤醒所有因为辅助GC而休眠的G<br />
    // Wake all blocked assists. These will run when we<br />
    // start the world again.<br />
    gcWakeAllAssists()<br />
    <br />
    // Likewise, release the transition lock. Blocked<br />
    // workers and assists will run when we start the<br />
    // world again.<br />
    semrelease(&amp;work.markDoneSema)<br />
    <br />
    // 计算下一次触发gc需要的heap大小<br />
    // endCycle depends on all gcWork cache stats being<br />
    // flushed. This is ensured by mark 2.<br />
    nextTriggerRatio := gcController.endCycle()<br />
    <br />
    // 进入完成标记阶段, 会重新启动世界<br />
    // Perform mark termination. This will restart the world.<br />
    gcMarkTermination(nextTriggerRatio)<br />
} } gcMarkTermination函数会进入完成标记阶段:<br />
</code></pre></div></div><br />
<br />
<p>func gcMarkTermination(nextTriggerRatio float64) {<br />
    // World is stopped.<br />
    // Start marktermination which includes enabling the write barrier.<br />
    // 禁止辅助GC和后台标记任务的运行<br />
    atomic.Store(&amp;gcBlackenEnabled, 0)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 重新允许本地标记队列(下次GC使用)<br />
gcBlackenPromptly = false<br />
<br />
// 设置当前GC阶段到完成标记阶段, 并启用写屏障<br />
setGCPhase(_GCmarktermination)<br />
<br />
// 记录开始时间<br />
work.heap1 = memstats.heap_live<br />
startTime := nanotime()<br />
<br />
// 禁止G被抢占<br />
mp := acquirem()<br />
mp.preemptoff = "gcing"<br />
_g_ := getg()<br />
_g_.m.traceback = 2<br />
<br />
// 设置G的状态为等待中这样它的栈可以被扫描<br />
gp := _g_.m.curg<br />
casgstatus(gp, _Grunning, _Gwaiting)<br />
gp.waitreason = "garbage collection"<br />
<br />
// 切换到g0运行<br />
// Run gc on the g0 stack. We do this so that the g stack<br />
// we're currently running on will no longer change. Cuts<br />
// the root set down a bit (g0 stacks are not scanned, and<br />
// we don't need to scan gc's internal state).  We also<br />
// need to switch to g0 so we can shrink the stack.<br />
systemstack(func() {<br />
    // 开始STW中的标记<br />
    gcMark(startTime)<br />
    <br />
    // 必须立刻返回, 因为外面的G的栈有可能被移动, 不能在这之后访问外面的变量<br />
    // Must return immediately.<br />
    // The outer function's stack may have moved<br />
    // during gcMark (it shrinks stacks, including the<br />
    // outer function's stack), so we must not refer<br />
    // to any of its variables. Return back to the<br />
    // non-system stack to pick up the new addresses<br />
    // before continuing.<br />
})<br />
<br />
// 重新切换到g0运行<br />
systemstack(func() {<br />
    work.heap2 = work.bytesMarked<br />
    <br />
    // 如果启用了checkmark则执行检查, 检查是否所有可到达的对象都有标记<br />
    if debug.gccheckmark &gt; 0 {<br />
        // Run a full stop-the-world mark using checkmark bits,<br />
        // to check that we didn't forget to mark anything during<br />
        // the concurrent mark process.<br />
        gcResetMarkState()<br />
        initCheckmarks()<br />
        gcMark(startTime)<br />
        clearCheckmarks()<br />
    }<br />
<br />
    // 设置当前GC阶段到关闭, 并禁用写屏障<br />
    // marking is complete so we can turn the write barrier off<br />
    setGCPhase(_GCoff)<br />
    <br />
    // 唤醒后台清扫任务, 将在STW结束后开始运行<br />
    gcSweep(work.mode)<br />
<br />
    // 除错用<br />
    if debug.gctrace &gt; 1 {<br />
        startTime = nanotime()<br />
        // The g stacks have been scanned so<br />
        // they have gcscanvalid==true and gcworkdone==true.<br />
        // Reset these so that all stacks will be rescanned.<br />
        gcResetMarkState()<br />
        finishsweep_m()<br />
<br />
        // Still in STW but gcphase is _GCoff, reset to _GCmarktermination<br />
        // At this point all objects will be found during the gcMark which<br />
        // does a complete STW mark and object scan.<br />
        setGCPhase(_GCmarktermination)<br />
        gcMark(startTime)<br />
        setGCPhase(_GCoff) // marking is done, turn off wb.<br />
        gcSweep(work.mode)<br />
    }<br />
})<br />
<br />
// 设置G的状态为运行中<br />
_g_.m.traceback = 0<br />
casgstatus(gp, _Gwaiting, _Grunning)<br />
<br />
// 跟踪处理<br />
if trace.enabled {<br />
    traceGCDone()<br />
}<br />
<br />
// all done<br />
mp.preemptoff = ""<br />
<br />
if gcphase != _GCoff {<br />
    throw("gc done but gcphase != _GCoff")<br />
}<br />
<br />
// 更新下一次触发gc需要的heap大小(gc_trigger)<br />
// Update GC trigger and pacing for the next cycle.<br />
gcSetTriggerRatio(nextTriggerRatio)<br />
<br />
// 更新用时记录<br />
// Update timing memstats<br />
now := nanotime()<br />
sec, nsec, _ := time_now()<br />
unixNow := sec*1e9 + int64(nsec)<br />
work.pauseNS += now - work.pauseStart<br />
work.tEnd = now<br />
atomic.Store64(&amp;memstats.last_gc_unix, uint64(unixNow)) // must be Unix time to make sense to user<br />
atomic.Store64(&amp;memstats.last_gc_nanotime, uint64(now)) // monotonic time for us<br />
memstats.pause_ns[memstats.numgc%uint32(len(memstats.pause_ns))] = uint64(work.pauseNS)<br />
memstats.pause_end[memstats.numgc%uint32(len(memstats.pause_end))] = uint64(unixNow)<br />
memstats.pause_total_ns += uint64(work.pauseNS)<br />
<br />
// 更新所用cpu记录<br />
// Update work.totaltime.<br />
sweepTermCpu := int64(work.stwprocs) * (work.tMark - work.tSweepTerm)<br />
// We report idle marking time below, but omit it from the<br />
// overall utilization here since it's "free".<br />
markCpu := gcController.assistTime + gcController.dedicatedMarkTime + gcController.fractionalMarkTime<br />
markTermCpu := int64(work.stwprocs) * (work.tEnd - work.tMarkTerm)<br />
cycleCpu := sweepTermCpu + markCpu + markTermCpu<br />
work.totaltime += cycleCpu<br />
<br />
// Compute overall GC CPU utilization.<br />
totalCpu := sched.totaltime + (now-sched.procresizetime)*int64(gomaxprocs)<br />
memstats.gc_cpu_fraction = float64(work.totaltime) / float64(totalCpu)<br />
<br />
// 重置清扫状态<br />
// Reset sweep state.<br />
sweep.nbgsweep = 0<br />
sweep.npausesweep = 0<br />
<br />
// 统计强制开始GC的次数<br />
if work.userForced {<br />
    memstats.numforcedgc++<br />
}<br />
<br />
// 统计执行GC的次数然后唤醒等待清扫的G<br />
// Bump GC cycle count and wake goroutines waiting on sweep.<br />
lock(&amp;work.sweepWaiters.lock)<br />
memstats.numgc++<br />
injectglist(work.sweepWaiters.head.ptr())<br />
work.sweepWaiters.head = 0<br />
unlock(&amp;work.sweepWaiters.lock)<br />
<br />
// 性能统计用<br />
// Finish the current heap profiling cycle and start a new<br />
// heap profiling cycle. We do this before starting the world<br />
// so events don't leak into the wrong cycle.<br />
mProf_NextCycle()<br />
<br />
// 重新启动世界<br />
systemstack(startTheWorldWithSema)<br />
<br />
// !!!!!!!!!!!!!!!<br />
// 世界已重新启动...<br />
// !!!!!!!!!!!!!!!<br />
<br />
// 性能统计用<br />
// Flush the heap profile so we can start a new cycle next GC.<br />
// This is relatively expensive, so we don't do it with the<br />
// world stopped.<br />
mProf_Flush()<br />
<br />
// 移动标记队列使用的缓冲区到自由列表, 使得它们可以被回收<br />
// Prepare workbufs for freeing by the sweeper. We do this<br />
// asynchronously because it can take non-trivial time.<br />
prepareFreeWorkbufs()<br />
<br />
// 释放未使用的栈<br />
// Free stack spans. This must be done between GC cycles.<br />
systemstack(freeStackSpans)<br />
<br />
// 除错用<br />
// Print gctrace before dropping worldsema. As soon as we drop<br />
// worldsema another cycle could start and smash the stats<br />
// we're trying to print.<br />
if debug.gctrace &gt; 0 {<br />
    util := int(memstats.gc_cpu_fraction * 100)<br />
<br />
    var sbuf [24]byte<br />
    printlock()<br />
    print("gc ", memstats.numgc,<br />
        " @", string(itoaDiv(sbuf[:], uint64(work.tSweepTerm-runtimeInitTime)/1e6, 3)), "s ",<br />
        util, "%: ")<br />
    prev := work.tSweepTerm<br />
    for i, ns := range []int64{work.tMark, work.tMarkTerm, work.tEnd} {<br />
        if i != 0 {<br />
            print("+")<br />
        }<br />
        print(string(fmtNSAsMS(sbuf[:], uint64(ns-prev))))<br />
        prev = ns<br />
    }<br />
    print(" ms clock, ")<br />
    for i, ns := range []int64{sweepTermCpu, gcController.assistTime, gcController.dedicatedMarkTime + gcController.fractionalMarkTime, gcController.idleMarkTime, markTermCpu} {<br />
        if i == 2 || i == 3 {<br />
            // Separate mark time components with /.<br />
            print("/")<br />
        } else if i != 0 {<br />
            print("+")<br />
        }<br />
        print(string(fmtNSAsMS(sbuf[:], uint64(ns))))<br />
    }<br />
    print(" ms cpu, ",<br />
        work.heap0&gt;&gt;20, "-&gt;", work.heap1&gt;&gt;20, "-&gt;", work.heap2&gt;&gt;20, " MB, ",<br />
        work.heapGoal&gt;&gt;20, " MB goal, ",<br />
        work.maxprocs, " P")<br />
    if work.userForced {<br />
        print(" (forced)")<br />
    }<br />
    print("\n")<br />
    printunlock()<br />
}<br />
<br />
semrelease(&amp;worldsema)<br />
// Careful: another GC cycle may start now.<br />
<br />
// 重新允许当前的G被抢占<br />
releasem(mp)<br />
mp = nil<br />
<br />
// 如果是并行GC, 让当前M继续运行(会回到gcBgMarkWorker然后休眠)<br />
// 如果不是并行GC, 则让当前M开始调度<br />
// now that gc is done, kick off finalizer thread if needed<br />
if !concurrentSweep {<br />
    // give the queued finalizers, if any, a chance to run<br />
    Gosched()<br />
} } gcSweep函数会唤醒后台清扫任务: 后台清扫任务会在程序启动时调用的gcenable函数中启动.<br />
</code></pre></div></div><br />
<br />
<p>func gcSweep(mode gcMode) {<br />
    if gcphase != _GCoff {<br />
        throw(“gcSweep being done but phase is not GCoff”)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 增加sweepgen, 这样sweepSpans中两个队列角色会交换, 所有span都会变为"待清扫"的span<br />
lock(&amp;mheap_.lock)<br />
mheap_.sweepgen += 2<br />
mheap_.sweepdone = 0<br />
if mheap_.sweepSpans[mheap_.sweepgen/2%2].index != 0 {<br />
    // We should have drained this list during the last<br />
    // sweep phase. We certainly need to start this phase<br />
    // with an empty swept list.<br />
    throw("non-empty swept list")<br />
}<br />
mheap_.pagesSwept = 0<br />
unlock(&amp;mheap_.lock)<br />
<br />
// 如果非并行GC则在这里完成所有工作(STW中)<br />
if !_ConcurrentSweep || mode == gcForceBlockMode {<br />
    // Special case synchronous sweep.<br />
    // Record that no proportional sweeping has to happen.<br />
    lock(&amp;mheap_.lock)<br />
    mheap_.sweepPagesPerByte = 0<br />
    unlock(&amp;mheap_.lock)<br />
    // Sweep all spans eagerly.<br />
    for sweepone() != ^uintptr(0) {<br />
        sweep.npausesweep++<br />
    }<br />
    // Free workbufs eagerly.<br />
    prepareFreeWorkbufs()<br />
    for freeSomeWbufs(false) {<br />
    }<br />
    // All "free" events for this mark/sweep cycle have<br />
    // now happened, so we can make this profile cycle<br />
    // available immediately.<br />
    mProf_NextCycle()<br />
    mProf_Flush()<br />
    return<br />
}<br />
<br />
// 唤醒后台清扫任务<br />
// Background sweep.<br />
lock(&amp;sweep.lock)<br />
if sweep.parked {<br />
    sweep.parked = false<br />
    ready(sweep.g, 0, true)<br />
}<br />
unlock(&amp;sweep.lock) } 后台清扫任务的函数是bgsweep:<br />
</code></pre></div></div><br />
<br />
<p>func bgsweep(c chan int) {<br />
    sweep.g = getg()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 等待唤醒<br />
lock(&amp;sweep.lock)<br />
sweep.parked = true<br />
c &lt;- 1<br />
goparkunlock(&amp;sweep.lock, "GC sweep wait", traceEvGoBlock, 1)<br />
<br />
// 循环清扫<br />
for {<br />
    // 清扫一个span, 然后进入调度(一次只做少量工作)<br />
    for gosweepone() != ^uintptr(0) {<br />
        sweep.nbgsweep++<br />
        Gosched()<br />
    }<br />
    // 释放一些未使用的标记队列缓冲区到heap<br />
    for freeSomeWbufs(true) {<br />
        Gosched()<br />
    }<br />
    // 如果清扫未完成则继续循环<br />
    lock(&amp;sweep.lock)<br />
    if !gosweepdone() {<br />
        // This can happen if a GC runs between<br />
        // gosweepone returning ^0 above<br />
        // and the lock being acquired.<br />
        unlock(&amp;sweep.lock)<br />
        continue<br />
    }<br />
    // 否则让后台清扫任务进入休眠, 当前M继续调度<br />
    sweep.parked = true<br />
    goparkunlock(&amp;sweep.lock, "GC sweep wait", traceEvGoBlock, 1)<br />
} } gosweepone函数会从sweepSpans中取出单个span清扫:<br />
</code></pre></div></div><br />
<br />
<p>//go:nowritebarrier<br />
func gosweepone() uintptr {<br />
    var ret uintptr<br />
    // 切换到g0运行<br />
    systemstack(func() {<br />
        ret = sweepone()<br />
    })<br />
    return ret<br />
}<br />
sweepone函数如下:</p><br />
<br />
<p>// sweeps one span<br />
// returns number of pages returned to heap, or ^uintptr(0) if there is nothing to sweep<br />
//go:nowritebarrier<br />
func sweepone() uintptr {<br />
    <em>g</em> := getg()<br />
    sweepRatio := mheap_.sweepPagesPerByte // For debugging</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 禁止G被抢占<br />
// increment locks to ensure that the goroutine is not preempted<br />
// in the middle of sweep thus leaving the span in an inconsistent state for next GC<br />
_g_.m.locks++<br />
<br />
// 检查是否已完成清扫<br />
if atomic.Load(&amp;mheap_.sweepdone) != 0 {<br />
    _g_.m.locks--<br />
    return ^uintptr(0)<br />
}<br />
<br />
// 更新同时执行sweep的任务数量<br />
atomic.Xadd(&amp;mheap_.sweepers, +1)<br />
<br />
npages := ^uintptr(0)<br />
sg := mheap_.sweepgen<br />
for {<br />
    // 从sweepSpans中取出一个span<br />
    s := mheap_.sweepSpans[1-sg/2%2].pop()<br />
    // 全部清扫完毕时跳出循环<br />
    if s == nil {<br />
        atomic.Store(&amp;mheap_.sweepdone, 1)<br />
        break<br />
    }<br />
    // 其他M已经在清扫这个span时跳过<br />
    if s.state != mSpanInUse {<br />
        // This can happen if direct sweeping already<br />
        // swept this span, but in that case the sweep<br />
        // generation should always be up-to-date.<br />
        if s.sweepgen != sg {<br />
            print("runtime: bad span s.state=", s.state, " s.sweepgen=", s.sweepgen, " sweepgen=", sg, "\n")<br />
            throw("non in-use span in unswept list")<br />
        }<br />
        continue<br />
    }<br />
    // 原子增加span的sweepgen, 失败表示其他M已经开始清扫这个span, 跳过<br />
    if s.sweepgen != sg-2 || !atomic.Cas(&amp;s.sweepgen, sg-2, sg-1) {<br />
        continue<br />
    }<br />
    // 清扫这个span, 然后跳出循环<br />
    npages = s.npages<br />
    if !s.sweep(false) {<br />
        // Span is still in-use, so this returned no<br />
        // pages to the heap and the span needs to<br />
        // move to the swept in-use list.<br />
        npages = 0<br />
    }<br />
    break<br />
}<br />
<br />
// 更新同时执行sweep的任务数量<br />
// Decrement the number of active sweepers and if this is the<br />
// last one print trace information.<br />
if atomic.Xadd(&amp;mheap_.sweepers, -1) == 0 &amp;&amp; atomic.Load(&amp;mheap_.sweepdone) != 0 {<br />
    if debug.gcpacertrace &gt; 0 {<br />
        print("pacer: sweep done at heap size ", memstats.heap_live&gt;&gt;20, "MB; allocated ", (memstats.heap_live-mheap_.sweepHeapLiveBasis)&gt;&gt;20, "MB during sweep; swept ", mheap_.pagesSwept, " pages at ", sweepRatio, " pages/byte\n")<br />
    }<br />
}<br />
// 允许G被抢占<br />
_g_.m.locks--<br />
// 返回清扫的页数<br />
return npages } span的sweep函数用于清扫单个span:<br />
</code></pre></div></div><br />
<br />
<p>// Sweep frees or collects finalizers for blocks not marked in the mark phase.<br />
// It clears the mark bits in preparation for the next GC round.<br />
// Returns true if the span was returned to heap.<br />
// If preserve=true, don’t return it to heap nor relink in MCentral lists;<br />
// caller takes care of it.<br />
//TODO go:nowritebarrier<br />
func (s *mspan) sweep(preserve bool) bool {<br />
    // It’s critical that we enter this function with preemption disabled,<br />
    // GC must not start while we are in the middle of this function.<br />
    <em>g</em> := getg()<br />
    if <em>g</em>.m.locks == 0 &amp;&amp; <em>g</em>.m.mallocing == 0 &amp;&amp; <em>g</em> != <em>g</em>.m.g0 {<br />
        throw(“MSpan_Sweep: m is not locked”)<br />
    }<br />
    sweepgen := mheap_.sweepgen<br />
    if s.state != mSpanInUse || s.sweepgen != sweepgen-1 {<br />
        print(“MSpan_Sweep: state=”, s.state, “ sweepgen=”, s.sweepgen, “ mheap.sweepgen=”, sweepgen, “\n”)<br />
        throw(“MSpan_Sweep: bad span state”)<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if trace.enabled {<br />
    traceGCSweepSpan(s.npages * _PageSize)<br />
}<br />
<br />
// 统计已清理的页数<br />
atomic.Xadd64(&amp;mheap_.pagesSwept, int64(s.npages))<br />
<br />
spc := s.spanclass<br />
size := s.elemsize<br />
res := false<br />
<br />
c := _g_.m.mcache<br />
freeToHeap := false<br />
<br />
// The allocBits indicate which unmarked objects don't need to be<br />
// processed since they were free at the end of the last GC cycle<br />
// and were not allocated since then.<br />
// If the allocBits index is &gt;= s.freeindex and the bit<br />
// is not marked then the object remains unallocated<br />
// since the last GC.<br />
// This situation is analogous to being on a freelist.<br />
<br />
// 判断在special中的析构器, 如果对应的对象已经不再存活则标记对象存活防止回收, 然后把析构器移到运行队列<br />
// Unlink &amp; free special records for any objects we're about to free.<br />
// Two complications here:<br />
// 1. An object can have both finalizer and profile special records.<br />
//    In such case we need to queue finalizer for execution,<br />
//    mark the object as live and preserve the profile special.<br />
// 2. A tiny object can have several finalizers setup for different offsets.<br />
//    If such object is not marked, we need to queue all finalizers at once.<br />
// Both 1 and 2 are possible at the same time.<br />
specialp := &amp;s.specials<br />
special := *specialp<br />
for special != nil {<br />
    // A finalizer can be set for an inner byte of an object, find object beginning.<br />
    objIndex := uintptr(special.offset) / size<br />
    p := s.base() + objIndex*size<br />
    mbits := s.markBitsForIndex(objIndex)<br />
    if !mbits.isMarked() {<br />
        // This object is not marked and has at least one special record.<br />
        // Pass 1: see if it has at least one finalizer.<br />
        hasFin := false<br />
        endOffset := p - s.base() + size<br />
        for tmp := special; tmp != nil &amp;&amp; uintptr(tmp.offset) &lt; endOffset; tmp = tmp.next {<br />
            if tmp.kind == _KindSpecialFinalizer {<br />
                // Stop freeing of object if it has a finalizer.<br />
                mbits.setMarkedNonAtomic()<br />
                hasFin = true<br />
                break<br />
            }<br />
        }<br />
        // Pass 2: queue all finalizers _or_ handle profile record.<br />
        for special != nil &amp;&amp; uintptr(special.offset) &lt; endOffset {<br />
            // Find the exact byte for which the special was setup<br />
            // (as opposed to object beginning).<br />
            p := s.base() + uintptr(special.offset)<br />
            if special.kind == _KindSpecialFinalizer || !hasFin {<br />
                // Splice out special record.<br />
                y := special<br />
                special = special.next<br />
                *specialp = special<br />
                freespecial(y, unsafe.Pointer(p), size)<br />
            } else {<br />
                // This is profile record, but the object has finalizers (so kept alive).<br />
                // Keep special record.<br />
                specialp = &amp;special.next<br />
                special = *specialp<br />
            }<br />
        }<br />
    } else {<br />
        // object is still live: keep special record<br />
        specialp = &amp;special.next<br />
        special = *specialp<br />
    }<br />
}<br />
<br />
// 除错用<br />
if debug.allocfreetrace != 0 || raceenabled || msanenabled {<br />
    // Find all newly freed objects. This doesn't have to<br />
    // efficient; allocfreetrace has massive overhead.<br />
    mbits := s.markBitsForBase()<br />
    abits := s.allocBitsForIndex(0)<br />
    for i := uintptr(0); i &lt; s.nelems; i++ {<br />
        if !mbits.isMarked() &amp;&amp; (abits.index &lt; s.freeindex || abits.isMarked()) {<br />
            x := s.base() + i*s.elemsize<br />
            if debug.allocfreetrace != 0 {<br />
                tracefree(unsafe.Pointer(x), size)<br />
            }<br />
            if raceenabled {<br />
                racefree(unsafe.Pointer(x), size)<br />
            }<br />
            if msanenabled {<br />
                msanfree(unsafe.Pointer(x), size)<br />
            }<br />
        }<br />
        mbits.advance()<br />
        abits.advance()<br />
    }<br />
}<br />
<br />
// 计算释放的对象数量<br />
// Count the number of free objects in this span.<br />
nalloc := uint16(s.countAlloc())<br />
if spc.sizeclass() == 0 &amp;&amp; nalloc == 0 {<br />
    // 如果span的类型是0(大对象)并且其中的对象已经不存活则释放到heap<br />
    s.needzero = 1<br />
    freeToHeap = true<br />
}<br />
nfreed := s.allocCount - nalloc<br />
if nalloc &gt; s.allocCount {<br />
    print("runtime: nelems=", s.nelems, " nalloc=", nalloc, " previous allocCount=", s.allocCount, " nfreed=", nfreed, "\n")<br />
    throw("sweep increased allocation count")<br />
}<br />
<br />
// 设置新的allocCount<br />
s.allocCount = nalloc<br />
<br />
// 判断span是否无未分配的对象<br />
wasempty := s.nextFreeIndex() == s.nelems<br />
<br />
// 重置freeindex, 下次分配从0开始搜索<br />
s.freeindex = 0 // reset allocation index to start of span.<br />
if trace.enabled {<br />
    getg().m.p.ptr().traceReclaimed += uintptr(nfreed) * s.elemsize<br />
}<br />
<br />
// gcmarkBits变为新的allocBits<br />
// 然后重新分配一块全部为0的gcmarkBits<br />
// 下次分配对象时可以根据allocBits得知哪些元素是未分配的<br />
// gcmarkBits becomes the allocBits.<br />
// get a fresh cleared gcmarkBits in preparation for next GC<br />
s.allocBits = s.gcmarkBits<br />
s.gcmarkBits = newMarkBits(s.nelems)<br />
<br />
// 更新freeindex开始的allocCache<br />
// Initialize alloc bits cache.<br />
s.refillAllocCache(0)<br />
<br />
// 如果span中已经无存活的对象则更新sweepgen到最新<br />
// 下面会把span加到mcentral或者mheap<br />
// We need to set s.sweepgen = h.sweepgen only when all blocks are swept,<br />
// because of the potential for a concurrent free/SetFinalizer.<br />
// But we need to set it before we make the span available for allocation<br />
// (return it to heap or mcentral), because allocation code assumes that a<br />
// span is already swept if available for allocation.<br />
if freeToHeap || nfreed == 0 {<br />
    // The span must be in our exclusive ownership until we update sweepgen,<br />
    // check for potential races.<br />
    if s.state != mSpanInUse || s.sweepgen != sweepgen-1 {<br />
        print("MSpan_Sweep: state=", s.state, " sweepgen=", s.sweepgen, " mheap.sweepgen=", sweepgen, "\n")<br />
        throw("MSpan_Sweep: bad span state after sweep")<br />
    }<br />
    // Serialization point.<br />
    // At this point the mark bits are cleared and allocation ready<br />
    // to go so release the span.<br />
    atomic.Store(&amp;s.sweepgen, sweepgen)<br />
}<br />
<br />
if nfreed &gt; 0 &amp;&amp; spc.sizeclass() != 0 {<br />
    // 把span加到mcentral, res等于是否添加成功<br />
    c.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)<br />
    res = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)<br />
    // freeSpan会更新sweepgen<br />
    // MCentral_FreeSpan updates sweepgen<br />
} else if freeToHeap {<br />
    // 把span释放到mheap<br />
    // Free large span to heap<br />
<br />
    // NOTE(rsc,dvyukov): The original implementation of efence<br />
    // in CL 22060046 used SysFree instead of SysFault, so that<br />
    // the operating system would eventually give the memory<br />
    // back to us again, so that an efence program could run<br />
    // longer without running out of memory. Unfortunately,<br />
    // calling SysFree here without any kind of adjustment of the<br />
    // heap data structures means that when the memory does<br />
    // come back to us, we have the wrong metadata for it, either in<br />
    // the MSpan structures or in the garbage collection bitmap.<br />
    // Using SysFault here means that the program will run out of<br />
    // memory fairly quickly in efence mode, but at least it won't<br />
    // have mysterious crashes due to confused memory reuse.<br />
    // It should be possible to switch back to SysFree if we also<br />
    // implement and then call some kind of MHeap_DeleteSpan.<br />
    if debug.efence &gt; 0 {<br />
        s.limit = 0 // prevent mlookup from finding this span<br />
        sysFault(unsafe.Pointer(s.base()), size)<br />
    } else {<br />
        mheap_.freeSpan(s, 1)<br />
    }<br />
    c.local_nlargefree++<br />
    c.local_largefree += size<br />
    res = true<br />
}<br />
<br />
// 如果span未加到mcentral或者未释放到mheap, 则表示span仍在使用<br />
if !res {<br />
    // 把仍在使用的span加到sweepSpans的"已清扫"队列中<br />
    // The span has been swept and is still in-use, so put<br />
    // it on the swept in-use list.<br />
    mheap_.sweepSpans[sweepgen/2%2].push(s)<br />
}<br />
return res } 从bgsweep和前面的分配器可以看出扫描阶段的工作是十分懒惰(lazy)的, 实际可能会出现前一阶段的扫描还未完成, 就需要开始新一轮的GC的情况, 所以每一轮GC开始之前都需要完成前一轮GC的扫描工作(Sweep Termination阶段).<br />
</code></pre></div></div><br />
<br />
<p>GC的整个流程都分析完毕了, 最后贴上写屏障函数writebarrierptr的实现:</p><br />
<br />
<p>// NOTE: Really dst *unsafe.Pointer, src unsafe.Pointer,<br />
// but if we do that, Go inserts a write barrier on *dst = src.<br />
//go:nosplit<br />
func writebarrierptr(dst *uintptr, src uintptr) {<br />
    if writeBarrier.cgo {<br />
        cgoCheckWriteBarrier(dst, src)<br />
    }<br />
    if !writeBarrier.needed {<br />
        *dst = src<br />
        return<br />
    }<br />
    if src != 0 &amp;&amp; src &lt; minPhysPageSize {<br />
        systemstack(func() {<br />
            print(“runtime: writebarrierptr *”, dst, “ = “, hex(src), “\n”)<br />
            throw(“bad pointer in write barrier”)<br />
        })<br />
    }<br />
    // 标记指针<br />
    writebarrierptr_prewrite1(dst, src)<br />
    // 设置指针到目标<br />
    *dst = src<br />
}<br />
writebarrierptr_prewrite1函数如下:</p><br />
<br />
<p>// writebarrierptr_prewrite1 invokes a write barrier for *dst = src<br />
// prior to the write happening.<br />
//<br />
// Write barrier calls must not happen during critical GC and scheduler<br />
// related operations. In particular there are times when the GC assumes<br />
// that the world is stopped but scheduler related code is still being<br />
// executed, dealing with syscalls, dealing with putting gs on runnable<br />
// queues and so forth. This code cannot execute write barriers because<br />
// the GC might drop them on the floor. Stopping the world involves removing<br />
// the p associated with an m. We use the fact that m.p == nil to indicate<br />
// that we are in one these critical section and throw if the write is of<br />
// a pointer to a heap object.<br />
//go:nosplit<br />
func writebarrierptr_prewrite1(dst *uintptr, src uintptr) {<br />
    mp := acquirem()<br />
    if mp.inwb || mp.dying &gt; 0 {<br />
        releasem(mp)<br />
        return<br />
    }<br />
    systemstack(func() {<br />
        if mp.p == 0 &amp;&amp; memstats.enablegc &amp;&amp; !mp.inwb &amp;&amp; inheap(src) {<br />
            throw(“writebarrierptr_prewrite1 called with mp.p == nil”)<br />
        }<br />
        mp.inwb = true<br />
        gcmarkwb_m(dst, src)<br />
    })<br />
    mp.inwb = false<br />
    releasem(mp)<br />
}<br />
gcmarkwb_m函数如下:</p><br />
<br />
<p>func gcmarkwb_m(slot *uintptr, ptr uintptr) {<br />
    if writeBarrier.needed {<br />
        // Note: This turns bad pointer writes into bad<br />
        // pointer reads, which could be confusing. We avoid<br />
        // reading from obviously bad pointers, which should<br />
        // take care of the vast majority of these. We could<br />
        // patch this up in the signal handler, or use XCHG to<br />
        // combine the read and the write. Checking inheap is<br />
        // insufficient since we need to track changes to<br />
        // roots outside the heap.<br />
        //<br />
        // Note: profbuf.go omits a barrier during signal handler<br />
        // profile logging; that’s safe only because this deletion barrier exists.<br />
        // If we remove the deletion barrier, we’ll have to work out<br />
        // a new way to handle the profile logging.<br />
        if slot1 := uintptr(unsafe.Pointer(slot)); slot1 &gt;= minPhysPageSize {<br />
            if optr := *slot; optr != 0 {<br />
                // 标记旧指针<br />
                shade(optr)<br />
            }<br />
        }<br />
        // TODO: Make this conditional on the caller’s stack color.<br />
        if ptr != 0 &amp;&amp; inheap(ptr) {<br />
            // 标记新指针<br />
            shade(ptr)<br />
        }<br />
    }<br />
}<br />
shade函数如下:</p><br />
<br />
<p>// Shade the object if it isn’t already.<br />
// The object is not nil and known to be in the heap.<br />
// Preemption must be disabled.<br />
//go:nowritebarrier<br />
func shade(b uintptr) {<br />
    if obj, hbits, span, objIndex := heapBitsForObject(b, 0, 0); obj != 0 {<br />
        gcw := &amp;getg().m.p.ptr().gcw<br />
        // 标记一个对象存活, 并把它加到标记队列(该对象变为灰色)<br />
        greyobject(obj, 0, 0, hbits, span, gcw, objIndex)<br />
        // 如果标记了禁止本地标记队列则flush到全局标记队列<br />
        if gcphase == _GCmarktermination || gcBlackenPromptly {<br />
            // Ps aren’t allowed to cache work during mark<br />
            // termination.<br />
            gcw.dispose()<br />
        }<br />
    }<br />
}<br />
参考链接<br />
https://github.com/golang/go<br />
https://making.pusher.com/golangs-real-time-gc-in-theory-and-practice<br />
https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md<br />
https://golang.org/s/go15gcpacing<br />
https://golang.org/ref/mem<br />
https://talks.golang.org/2015/go-gc.pdf<br />
https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#heading=h.x4kziklnb8fr<br />
https://go-review.googlesource.com/c/go/+/21503<br />
http://www.cnblogs.com/diegodu/p/5803202.html<br />
http://legendtkl.com/2017/04/28/golang-gc<br />
https://lengzzz.com/note/gc-in-golang</p><br />
<br />
<p>Golang的GC和CoreCLR的GC对比<br />
因为我之前已经对CoreCLR的GC做过分析(看这一篇和这一篇), 这里我可以简单的对比一下CoreCLR和GO的GC实现:</p><br />
<br />
<p>CoreCLR的对象带有类型信息, GO的对象不带, 而是通过bitmap区域记录哪些地方包含指针<br />
CoreCLR分配对象的速度明显更快, GO分配对象需要查找span和写入bitmap区域<br />
CoreCLR的收集器需要做的工作比GO多很多<br />
CoreCLR不同大小的对象都会放在一个segment中, 只能线性扫描<br />
CoreCLR判断对象引用要访问类型信息, 而go只需要访问bitmap<br />
CoreCLR清扫时要一个个去标记为自由对象, 而go只需要切换allocBits<br />
CoreCLR的停顿时间比GO要长<br />
虽然CoreCLR支持并行GC, 但是没有GO彻底, GO连扫描根对象都不需要完全停顿<br />
CoreCLR支持分代GC<br />
虽然Full GC时CoreCLR的效率不如GO, 但是CoreCLR可以在大部分时候只扫描第0和第1代的对象<br />
因为支持分代GC, 通常CoreCLR花在GC上的CPU时间会比GO要少<br />
CoreCLR的分配器和收集器通常比GO要高效, 也就是说CoreCLR会有更高的吞吐量.<br />
但CoreCLR的最大停顿时间不如GO短, 这是因为GO的GC整个设计都是为了减少停顿时间.</p><br />
<br />
<p>现在分布式计算和横向扩展越来越流行,<br />
比起追求单机吞吐量, 追求低延迟然后让分布式解决吞吐量问题无疑是更明智的选择,<br />
GO的设计目标使得它比其他语言都更适合编写网络服务程序.</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>