<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">GC</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-10-13T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Oct 13, 2019</time></p>
					</div>
					 <p>https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md<br />
Go的垃圾回收官方形容为 非分代 非紧缩 写屏障 三色并发标记清理算法。<br />
非分代：不像Java那样分为年轻代和年老代，自然也没有minor gc和maj o gc的区别。<br />
非紧缩：在垃圾回收之后不会进行内存整理以清除内存碎片。<br />
写屏障：在并发标记的过程中，如果应用程序（mutator）修改了对象图，就可能出现标记遗漏的可能，写屏障就是为了处理标记遗漏的问题。<br />
三色：将GC中的对象按照搜索的情况分成三种：</p><br />
<br />
<p>黑色: 对象在这次GC中已标记,且这个对象包含的子对象也已标记<br />
灰色: 对象在这次GC中已标记, 但这个对象包含的子对象未标记<br />
白色: 对象在这次GC中未标记<br />
并发：可以和应用程序（mutator）在一定程度上并发执行。<br />
标记清理：GC算法分为两个大步骤：标记阶段找出要回收的对象，清理阶段则回收未被标记的对象（要被回收的对象）<br />
<!-- more --><br />
 }<br />
    releasem(mp)<br />
    mp = nil</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 检查GC条件是否满足，和下面的test()构成双检查锁，如果满足GC条件但目前处于GC清理阶段，那就参与清理<br />
for trigger.test() &amp;&amp; gosweepone() != ^uintptr(0) {<br />
    sweep.nbgsweep++<br />
}<br />
<br />
// 加锁检查<br />
semacquire(&amp;work.startSema)<br />
if !trigger.test() {<br />
    semrelease(&amp;work.startSema)<br />
    return<br />
}<br />
/***************  .....  *****************/<br />
</code></pre></div></div><br />
<br />
<p>}<br />
在trigger.test()函数中，检查是否满足GC触发的条件</p><br />
<br />
<p>func (t gcTrigger) test() bool {<br />
    if !memstats.enablegc || panicking != 0 {<br />
        return false<br />
    }<br />
    if t.kind == gcTriggerAlways {<br />
        return true<br />
    }<br />
    if gcphase != _GCoff {<br />
        return false<br />
    }<br />
    switch t.kind {<br />
    case gcTriggerHeap:<br />
        // Non-atomic access to heap_live for performance. If<br />
        // we are going to trigger on this, this thread just<br />
        // atomically wrote heap_live anyway and we’ll see our<br />
        // own write.<br />
        return memstats.heap_live &gt;= memstats.gc_trigger<br />
    case gcTriggerTime:<br />
        if gcpercent &lt; 0 {<br />
            return false<br />
        }<br />
        lastgc := int64(atomic.Load64(&amp;memstats.last_gc_nanotime))<br />
        // forcegcperiod = 2分钟<br />
        return lastgc != 0 &amp;&amp; t.now-lastgc &gt; forcegcperiod<br />
    case gcTriggerCycle:<br />
        // t.n &gt; work.cycles, but accounting for wraparound.<br />
        return int32(t.n-work.cycles) &gt; 0<br />
    }<br />
    return true<br />
}<br />
const (<br />
    // gcTriggerAlways indicates that a cycle should be started<br />
    // unconditionally, even if GOGC is off or we’re in a cycle<br />
    // right now. This cannot be consolidated with other cycles.<br />
    gcTriggerAlways gcTriggerKind = iota</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// gcTriggerHeap indicates that a cycle should be started when<br />
// the heap size reaches the trigger heap size computed by the<br />
// controller.<br />
gcTriggerHeap<br />
<br />
// gcTriggerTime indicates that a cycle should be started when<br />
// it's been more than forcegcperiod nanoseconds since the<br />
// previous GC cycle.<br />
gcTriggerTime<br />
<br />
// gcTriggerCycle indicates that a cycle should be started if<br />
// we have not yet started cycle number gcTrigger.n (relative<br />
// to work.cycles).<br />
gcTriggerCycle ) 算法过程 Sweep Termination: 对未清扫的span进行清扫, 只有上一轮的GC的清扫工作完成才可以开始新一轮的GC Mark: 扫描所有根对象, 和根对象可以到达的所有对象, 标记它们不被回收 Mark Termination: 完成标记工作, 重新扫描部分根对象(要求STW) Sweep: 按标记结果清扫span<br />
</code></pre></div></div><br />
<br />
<p>func gcStart(mode gcMode, trigger gcTrigger) {<br />
    // 拿到锁，保证只有一个执行流进入到这个临界区<br />
    semacquire(&amp;worldsema)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 启动后台扫描任务(G)<br />
if mode == gcBackgroundMode {<br />
    gcBgMarkStartWorkers()<br />
}<br />
<br />
gcResetMarkState()<br />
<br />
work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs<br />
if work.stwprocs &gt; ncpu {<br />
    work.stwprocs = ncpu<br />
}<br />
work.heap0 = atomic.Load64(&amp;memstats.heap_live)<br />
work.pauseNS = 0<br />
work.mode = mode<br />
<br />
now := nanotime()<br />
work.tSweepTerm = now<br />
work.pauseStart = now<br />
if trace.enabled {<br />
    traceGCSTWStart(1)<br />
}<br />
systemstack(stopTheWorldWithSema)<br />
// Finish sweep before we start concurrent scan.<br />
systemstack(func() {<br />
    finishsweep_m()<br />
})<br />
// clearpools before we start the GC. If we wait they memory will not be<br />
// reclaimed until the next GC cycle.<br />
clearpools()<br />
<br />
work.cycles++<br />
if mode == gcBackgroundMode { // Do as much work concurrently as possible<br />
    gcController.startCycle()<br />
    work.heapGoal = memstats.next_gc<br />
<br />
    // Enter concurrent mark phase and enable<br />
    // write barriers.<br />
    setGCPhase(_GCmark)<br />
<br />
    gcBgMarkPrepare() // Must happen before assist enable.<br />
    gcMarkRootPrepare()<br />
<br />
    // Mark all active tinyalloc blocks. Since we're<br />
    // allocating from these, they need to be black like<br />
    // other allocations. The alternative is to blacken<br />
    // the tiny block on every allocation from it, which<br />
    // would slow down the tiny allocator.<br />
    gcMarkTinyAllocs()<br />
<br />
    // At this point all Ps have enabled the write<br />
    // barrier, thus maintaining the no white to<br />
    // black invariant. Enable mutator assists to<br />
    // put back-pressure on fast allocating<br />
    // mutators.<br />
    atomic.Store(&amp;gcBlackenEnabled, 1)<br />
<br />
    // Assists and workers can start the moment we start<br />
    // the world.<br />
    gcController.markStartTime = now<br />
<br />
    // Concurrent mark.<br />
    systemstack(func() {<br />
        now = startTheWorldWithSema(trace.enabled)<br />
    })<br />
    work.pauseNS += now - work.pauseStart<br />
    work.tMark = now<br />
}<br />
<br />
semrelease(&amp;work.startSema) } 关键函数及路径：<br />
</code></pre></div></div><br />
<br />
<p>gcBgMarkStartWorkers():准备后台标记工作goroutine（allp）， 启动后等待该任务通知信号量bgMarkReady再继续，notewakeup(&amp;work.bgMarkReady)<br />
gcResetMarkState():重置一些全局状态和所有gorontine的栈（一种根对象）扫描状态<br />
systemstack(stopTheWorldWithSema):启动stop the world<br />
systemstack(func(){finishsweep_m()}): 不断去除要清理的span进行清理，然后重置gcmark位<br />
clearpools(): 清扫sched.sudogcache和sched.deferpool，不知道在干嘛……<br />
gcController.startCycle():启动新一轮GC，设置gc controller的状态位和计算一些估计值<br />
setGCPhase(<em>GCmark):设置GC阶段，启用写屏障<br />
gcBgMarkPrepare():设置后台标记任务计数；work.nproc = ^uint32(0)，work.nwait = ^uint32(0)<br />
gcMarkRootPrepare(): 计算扫描根对象的任务数量<br />
gcMarkTinyAllocs(): 标记所有tiny alloc等待合并的对象<br />
atomic.Store(&amp;gcBlackenEnabled, 1): 启用辅助GC<br />
systemstack(func(){now=startTheWorldWithSema(trace.enable)}): 停止stop the world<br />
func gcBgMarkWorker(_p</em> <em>p) {<br />
    /</em><strong>**</strong><strong>*  …….  **</strong><strong>**</strong>*/<br />
    // 通知gcBgMarkStartWorkers可以继续处理<br />
    notewakeup(&amp;work.bgMarkReady)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {<br />
<br />
    // 切换到g0运行<br />
    systemstack(func() {<br />
        // Mark our goroutine preemptible so its stack<br />
        // can be scanned. This lets two mark workers<br />
        // scan each other (otherwise, they would<br />
        // deadlock). We must not modify anything on<br />
        // the G stack. However, stack shrinking is<br />
        // disabled for mark workers, so it is safe to<br />
        // read from the G stack.<br />
        casgstatus(gp, _Grunning, _Gwaiting)<br />
        switch _p_.gcMarkWorkerMode {<br />
        default:<br />
            throw("gcBgMarkWorker: unexpected gcMarkWorkerMode")<br />
        case gcMarkWorkerDedicatedMode:<br />
            gcDrain(&amp;_p_.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)<br />
            if gp.preempt {<br />
                lock(&amp;sched.lock)<br />
                for {<br />
                    gp, _ := runqget(_p_)<br />
                    if gp == nil {<br />
                        break<br />
                    }<br />
                    globrunqput(gp)<br />
                }<br />
                unlock(&amp;sched.lock)<br />
            }<br />
            // Go back to draining, this time<br />
            // without preemption.<br />
            gcDrain(&amp;_p_.gcw, gcDrainNoBlock|gcDrainFlushBgCredit)<br />
        case gcMarkWorkerFractionalMode:<br />
            gcDrain(&amp;_p_.gcw, gcDrainFractional|gcDrainUntilPreempt|gcDrainFlushBgCredit)<br />
        case gcMarkWorkerIdleMode:<br />
            gcDrain(&amp;_p_.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)<br />
        }<br />
        casgstatus(gp, _Gwaiting, _Grunning)<br />
    })<br />
<br />
    /********   ......  ***********/<br />
    // 判断是否所有后台标记任务都完成, 并且没有更多的任务<br />
    if incnwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil) {<br />
        gcMarkDone()<br />
    }<br />
} } gcDrain()是执行标记的函数 当所有标记任务完成时，执行gcMarkDone()函数 func gcDrain(gcw *gcWork, flags gcDrainFlags) {<br />
initScanWork := gcw.scanWork<br />
// 如果根对象未扫描完，则先扫描根对象，Jobs为根对象总数，next相当于一个对象任务的取数器<br />
if work.markrootNext &lt; work.markrootJobs {<br />
    for !(preemptible &amp;&amp; gp.preempt) {<br />
        job := atomic.Xadd(&amp;work.markrootNext, +1) - 1<br />
        if job &gt;= work.markrootJobs {<br />
            break<br />
        }<br />
        // 将会扫描根对象，并把它加入到标记队列gcWork中之中，也就是把对象变成灰色<br />
        markroot(gcw, job)<br />
        if check != nil &amp;&amp; check() {<br />
            goto done<br />
        }<br />
    }<br />
}<br />
<br />
// 当根对象全部put到标记队列中, 消费标记队列，根据对象图进行消费<br />
for !(preemptible &amp;&amp; gp.preempt) {<br />
    if work.full == 0 {<br />
        gcw.balance()<br />
    }<br />
<br />
    var b uintptr<br />
    if blocking {<br />
        b = gcw.get()<br />
    } else {<br />
        b = gcw.tryGetFast()<br />
        if b == 0 {<br />
            b = gcw.tryGet()<br />
        }<br />
    }<br />
    if b == 0 {<br />
        // work barrier reached or tryGet failed.<br />
        break<br />
    }<br />
    scanobject(b, gcw)<br />
<br />
    // 如果已经扫描了一定数量的对象(gcCreditSlack的值是2000)<br />
    if gcw.scanWork &gt;= gcCreditSlack {<br />
        // 把扫描的对象数量添加到全局<br />
        atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)<br />
        // 减少辅助GC的工作量和唤醒等待中的G<br />
        if flushBgCredit {<br />
            gcFlushBgCredit(gcw.scanWork - initScanWork)<br />
            initScanWork = 0<br />
        }<br />
        idleCheck -= gcw.scanWork<br />
        gcw.scanWork = 0<br />
        <br />
        // 如果是idle模式且达到了检查的扫描量, 则检查是否有其他任务(G), 如果有则跳出循环<br />
        if idle &amp;&amp; idleCheck &lt;= 0 {<br />
            idleCheck += idleCheckThreshold<br />
            if pollWork() {<br />
                break<br />
            }<br />
        }<br />
    }<br />
}<br />
</code></pre></div></div><br />
<br />
<p>done:<br />
    // 把扫描的对象数量添加到全局<br />
    if gcw.scanWork &gt; 0 {<br />
        atomic.Xaddint64(&amp;gcController.scanWork, gcw.scanWork)<br />
        // 减少辅助GC的工作量和唤醒等待中的G<br />
        if flushBgCredit {<br />
            gcFlushBgCredit(gcw.scanWork - initScanWork)<br />
        }<br />
        gcw.scanWork = 0<br />
    }<br />
}<br />
func gcMarkDone() {<br />
    semacquire(&amp;work.markDoneSema)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Re-check transition condition under transition lock.<br />
if !(gcphase == _GCmark &amp;&amp; work.nwait == work.nproc &amp;&amp; !gcMarkWorkAvailable(nil)) {<br />
    semrelease(&amp;work.markDoneSema)<br />
    return<br />
}<br />
<br />
// 暂时禁止启动新的后台标记任务<br />
atomic.Xaddint64(&amp;gcController.dedicatedMarkWorkersNeeded, -0xffffffff)<br />
prevFractionalGoal := gcController.fractionalUtilizationGoal<br />
gcController.fractionalUtilizationGoal = 0<br />
// 转换到Mark Termination阶段，进入STW阶段<br />
systemstack(stopTheWorldWithSema)<br />
// 标记对根对象的扫描已完成<br />
work.markrootDone = true<br />
// 禁止辅助GC和后台任务<br />
atomic.Store(&amp;gcBlackenEnabled, 0)<br />
// 唤醒所有因为辅助GC而休眠的G<br />
gcWakeAllAssists()<br />
<br />
semrelease(&amp;work.markDoneSema)<br />
// 计算下一次触发gc需要的heap大小<br />
nextTriggerRatio := gcController.endCycle()<br />
<br />
// 计算下一次触发gc需要的heap大小<br />
gcMarkTermination(nextTriggerRatio) }<br />
</code></pre></div></div><br />
<br />
<ol><br />
  <li>Golang GC 发展<br />
Golang 从第一个版本以来，GC 一直是大家诟病最多的。但是每一个版本的发布基本都伴随着 GC 的改进。下面列出一些比较重要的改动。</li><br />
</ol><br />
<br />
<p>v1.1 STW<br />
v1.3 Mark STW, Sweep 并行<br />
v1.5 三色标记法<br />
v1.8 hybrid write barrier</p><br />
<ol><br />
  <li>GC 算法简介<br />
这一小节介绍三种经典的 GC 算法：引用计数（reference counting）、标记-清扫（mark &amp; sweep）、节点复制（Copying Garbage Collection），分代收集（Generational Garbage Collection）。</li><br />
</ol><br />
<br />
<p>2.1 引用计数<br />
引用计数的思想非常简单：每个单元维护一个域，保存其它单元指向它的引用数量（类似有向图的入度）。当引用数量为 0 时，将其回收。引用计数是渐进式的，能够将内存管理的开销分布到整个程序之中。C++ 的 share_ptr 使用的就是引用计算方法。</p><br />
<br />
<p>引用计数算法实现一般是把所有的单元放在一个单元池里，比如类似 free list。这样所有的单元就被串起来了，就可以进行引用计数了。新分配的单元计数值被设置为 1（注意不是 0，因为申请一般都说 ptr = new object 这种）。每次有一个指针被设为指向该单元时，该单元的计数值加 1；而每次删除某个指向它的指针时，它的计数值减 1。当其引用计数为 0 的时候，该单元会被进行回收。虽然这里说的比较简单，实现的时候还是有很多细节需要考虑，比如删除某个单元的时候，那么它指向的所有单元都需要对引用计数减 1。那么如果这个时候，发现其中某个指向的单元的引用计数又为 0，那么是递归的进行还是采用其他的策略呢？递归处理的话会导致系统颠簸。关于这些细节这里就不讨论了，可以参考文章后面的给的参考资料。</p><br />
<br />
<p>优点<br />
渐进式。内存管理与用户程序的执行交织在一起，将 GC 的代价分散到整个程序。不像标记-清扫算法需要 STW (Stop The World，GC 的时候挂起用户程序)。<br />
算法易于实现。<br />
内存单元能够很快被回收。相比于其他垃圾回收算法，堆被耗尽或者达到某个阈值才会进行垃圾回收。<br />
缺点<br />
原始的引用计数不能处理循环引用。大概这是被诟病最多的缺点了。不过针对这个问题，也除了很多解决方案，比如强引用等。<br />
维护引用计数降低运行效率。内存单元的更新删除等都需要维护相关的内存单元的引用计数，相比于一些追踪式的垃圾回收算法并不需要这些代价。<br />
单元池 free list 实现的话不是 cache-friendly 的，这样会导致频繁的 cache miss，降低程序运行效率。<br />
2.2 标记-清扫<br />
标记-清扫算法是第一种自动内存管理，基于追踪的垃圾收集算法。算法思想在 70 年代就提出了，是一种非常古老的算法。内存单元并不会在变成垃圾立刻回收，而是保持不可达状态，直到到达某个阈值或者固定时间长度。这个时候系统会挂起用户程序，也就是 STW，转而执行垃圾回收程序。垃圾回收程序对所有的存活单元进行一次全局遍历确定哪些单元可以回收。算法分两个部分：标记（mark）和清扫（sweep）。标记阶段表明所有的存活单元，清扫阶段将垃圾单元回收<br />
<img src="https://xiazemin.github.io/MyBlog/img/Mark_and_Sweep_Garbage.gif" /><br />
标记-清扫算法的优点也就是基于追踪的垃圾回收算法具有的优点：避免了引用计数算法的缺点（不能处理循环引用，需要维护指针）。缺点也很明显，需要 STW。</p><br />
<br />
<p>三色标记算法<br />
三色标记算法是对标记阶段的改进，原理如下：</p><br />
<br />
<p>起初所有对象都是白色。<br />
从根出发扫描所有可达对象，标记为灰色，放入待处理队列。<br />
从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。<br />
重复 3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。<br />
可视化如下。<br />
<img src="https://xiazemin.github.io/MyBlog/img/tri-color_garbage_collection.gif" /></p><br />
<br />
<p>2.3 节点复制<br />
节点复制也是基于追踪的算法。其将整个堆等分为两个半区（semi-space），一个包含现有数据，另一个包含已被废弃的数据。节点复制式垃圾收集从切换（flip）两个半区的角色开始，然后收集器在老的半区，也就是 Fromspace 中遍历存活的数据结构，在第一次访问某个单元时把它复制到新半区，也就是 Tospace 中去。在 Fromspace 中所有存活单元都被访问过之后，收集器在 Tospace 中建立一个存活数据结构的副本，用户程序可以重新开始运行了。</p><br />
<br />
<p>优点<br />
所有存活的数据结构都缩并地排列在 Tospace 的底部，这样就不会存在内存碎片的问题。<br />
获取新内存可以简单地通过递增自由空间指针来实现。<br />
缺点<br />
内存得不到充分利用，总有一半的内存空间处于浪费状态。<br />
2.4 分代收集<br />
基于追踪的垃圾回收算法（标记-清扫、节点复制）一个主要问题是在生命周期较长的对象上浪费时间（长生命周期的对象是不需要频繁扫描的）。同时，内存分配存在这么一个事实 “most object die young”。基于这两点，分代垃圾回收算法将对象按生命周期长短存放到堆上的两个（或者更多）区域，这些区域就是分代（generation）。对于新生代的区域的垃圾回收频率要明显高于老年代区域。</p><br />
<br />
<p>分配对象的时候从新生代里面分配，如果后面发现对象的生命周期较长，则将其移到老年代，这个过程叫做 promote。随着不断 promote，最后新生代的大小在整个堆的占用比例不会特别大。收集的时候集中主要精力在新生代就会相对来说效率更高，STW 时间也会更短。</p><br />
<br />
<p>优点<br />
性能更优。<br />
缺点<br />
实现复杂</p><br />
<ol><br />
  <li><br />
    <p>Golang GC<br />
3.1 Overview<br />
在说 Golang 的具体垃圾回收流程时，我们先来看一下几个基本的问题。</p><br />
  </li><br />
  <li>何时触发 GC<br />
在堆上分配大于 32K byte 对象的时候进行检测此时是否满足垃圾回收条件，如果满足则进行垃圾回收。<br />
func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {<br />
 …<br />
 shouldhelpgc := false<br />
 // 分配的对象小于 32K byte<br />
 if size &lt;= maxSmallSize {<br />
     …<br />
 } else {<br />
     shouldhelpgc = true<br />
     …<br />
 }<br />
 …<br />
 // gcShouldStart() 函数进行触发条件检测<br />
 if shouldhelpgc &amp;&amp; gcShouldStart(false) {<br />
     // gcStart() 函数进行垃圾回收<br />
     gcStart(gcBackgroundMode, false)<br />
 }<br />
}<br />
上面是自动垃圾回收，还有一种是主动垃圾回收，通过调用 runtime.GC()，这是阻塞式的。<br />
// GC runs a garbage collection and blocks the caller until the<br />
// garbage collection is complete. It may also block the entire<br />
// program.<br />
func GC() {<br />
 gcStart(gcForceBlockMode, false)<br />
}</li><br />
  <li>GC 触发条件<br />
触发条件主要关注下面代码中的中间部分：forceTrigger || memstats.heap_live &gt;= memstats.gc_trigger 。forceTrigger 是 forceGC 的标志；后面半句的意思是当前堆上的活跃对象大于我们初始化时候设置的 GC 触发阈值。在 malloc 以及 free 的时候 heap_live 会一直进行更新，这里就不再展开了。<br />
// gcShouldStart returns true if the exit condition for the _GCoff<br />
// phase has been met. The exit condition should be tested when<br />
// allocating.<br />
//<br />
// If forceTrigger is true, it ignores the current heap size, but<br />
// checks all other conditions. In general this should be false.<br />
func gcShouldStart(forceTrigger bool) bool {<br />
 return gcphase == _GCoff &amp;&amp; (forceTrigger || memstats.heap_live &gt;= memstats.gc_trigger) &amp;&amp; memstats.enablegc &amp;&amp; panicking == 0 &amp;&amp; gcpercent &gt;= 0<br />
}</li><br />
</ol><br />
<br />
<p>//初始化的时候设置 GC 的触发阈值<br />
func gcinit() {<br />
    _ = setGCPercent(readgogc())<br />
    memstats.gc_trigger = heapminimum<br />
    …<br />
}<br />
// 启动的时候通过 GOGC 传递百分比 x<br />
// 触发阈值等于 x * defaultHeapMinimum (defaultHeapMinimum 默认是 4M)<br />
func readgogc() int32 {<br />
    p := gogetenv(“GOGC”)<br />
    if p == “off” {<br />
        return -1<br />
    }<br />
    if n, ok := atoi32(p); ok {<br />
        return n<br />
    }<br />
    return 100<br />
}</p><br />
<ol><br />
  <li>垃圾回收的主要流程<br />
三色标记法，主要流程如下：</li><br />
</ol><br />
<br />
<p>所有对象最开始都是白色。<br />
从 root 开始找到所有可达对象，标记为灰色，放入待处理队列。<br />
遍历灰色对象队列，将其引用对象标记为灰色放入待处理队列，自身标记为黑色。<br />
处理完灰色对象队列，执行清扫工作。<br />
<img src="https://xiazemin.github.io/MyBlog/img/gc_tri.png" /><br />
关于上图有几点需要说明的是。</p><br />
<br />
<p>首先从 root 开始遍历，root 包括全局指针和 goroutine 栈上的指针。<br />
mark 有两个过程。<br />
从 root 开始遍历，标记为灰色。遍历灰色队列。<br />
re-scan 全局指针和栈。因为 mark 和用户程序是并行的，所以在过程 1 的时候可能会有新的对象分配，这个时候就需要通过写屏障（write barrier）记录下来。re-scan 再完成检查一下。<br />
Stop The World 有两个过程。<br />
第一个是 GC 将要开始的时候，这个时候主要是一些准备工作，比如 enable write barrier。<br />
第二个过程就是上面提到的 re-scan 过程。如果这个时候没有 stw，那么 mark 将无休止。<br />
另外针对上图各个阶段对应 GCPhase 如下：</p><br />
<br />
<p>Off: _GCoff<br />
Stack scan ~ Mark: _GCmark<br />
Mark termination: _GCmarktermination<br />
3.2 写屏障 (write barrier)<br />
关于 write barrier，完全可以另外写成一篇文章，所以这里只简单介绍一下，这篇文章的重点还是 Golang 的 GC。垃圾回收中的 write barrier 可以理解为编译器在写操作时特意插入的一段代码，对应的还有 read barrier。</p><br />
<br />
<p>为什么需要 write barrier，很简单，对于和用户程序并发运行的垃圾回收算法，用户程序会一直修改内存，所以需要记录下来。</p><br />
<br />
<p>Golang 1.7 之前的 write barrier 使用的经典的 Dijkstra-style insertion write barrier [Dijkstra ‘78]， STW 的主要耗时就在 stack re-scan 的过程。自 1.8 之后采用一种混合的 write barrier 方式 （Yuasa-style deletion write barrier [Yuasa ‘90] 和 Dijkstra-style insertion write barrier [Dijkstra ‘78]）来避免 re-scan。具体的可以参考 17503-eliminate-rescan。</p><br />
<br />
<p>3.3 标记<br />
下面的源码还是基于 go1.8rc3。这个版本的 GC 代码相比之前改动还是挺大的，我们下面尽量只关注主流程。垃圾回收的代码主要集中在函数 gcStart() 中。<br />
// gcStart 是 GC 的入口函数，根据 gcMode 做处理。<br />
// 1. gcMode == gcBackgroundMode（后台运行，也就是并行）, _GCoff -&gt; _GCmark<br />
// 2. 否则 GCoff -&gt; _GCmarktermination，这个时候就是主动 GC <br />
func gcStart(mode gcMode, forceTrigger bool) {<br />
    …<br />
}</p><br />
<ol><br />
  <li><br />
    <p>STW phase 1<br />
在 GC 开始之前的准备工作。<br />
func gcStart(mode gcMode, forceTrigger bool) {<br />
 …<br />
 //在后台启动 mark worker <br />
 if mode == gcBackgroundMode {<br />
     gcBgMarkStartWorkers()<br />
 }<br />
 …<br />
 // Stop The World<br />
 systemstack(stopTheWorldWithSema)<br />
 …<br />
 if mode == gcBackgroundMode {<br />
     // GC 开始前的准备工作</p><br />
<br />
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> //处理设置 GCPhase，setGCPhase 还会 enable write barrier<br />
 setGCPhase(_GCmark)<br />
  	<br />
 gcBgMarkPrepare() // Must happen before assist enable.<br />
 gcMarkRootPrepare()<br />
<br />
 // Mark all active tinyalloc blocks. Since we're<br />
 // allocating from these, they need to be black like<br />
 // other allocations. The alternative is to blacken<br />
 // the tiny block on every allocation from it, which<br />
 // would slow down the tiny allocator.<br />
 gcMarkTinyAllocs()<br />
  	<br />
 // Start The World<br />
 systemstack(startTheWorldWithSema)  } else {<br />
 ...  } }<br />
</code></pre></div>    </div><br />
  </li><br />
  <li><br />
    <p>Mark<br />
Mark 阶段是并行的运行，通过在后台一直运行 mark worker 来实现。<br />
func gcStart(mode gcMode, forceTrigger bool) {<br />
 …<br />
 //在后台启动 mark worker <br />
 if mode == gcBackgroundMode {<br />
     gcBgMarkStartWorkers()<br />
 }<br />
}</p><br />
  </li><br />
</ol><br />
<br />
<p>func gcBgMarkStartWorkers() {<br />
    // Background marking is performed by per-P G’s. Ensure that<br />
    // each P has a background GC G.<br />
    for <em>, p := range &amp;allp {<br />
        if p == nil || p.status == _Pdead {<br />
            break<br />
        }<br />
        if p.gcBgMarkWorker == 0 {<br />
            go gcBgMarkWorker(p)<br />
            notetsleepg(&amp;work.bgMarkReady, -1)<br />
            noteclear(&amp;work.bgMarkReady)<br />
        }<br />
    }<br />
}<br />
// gcBgMarkWorker 是一直在后台运行的，大部分时候是休眠状态，通过 gcController 来调度<br />
func gcBgMarkWorker(_p</em> *p) {<br />
    for {<br />
        // 将当前 goroutine 休眠，直到满足某些条件<br />
        gopark(…)<br />
        …<br />
        // mark 过程<br />
        systemstack(func() {<br />
        // Mark our goroutine preemptible so its stack<br />
        // can be scanned. This lets two mark workers<br />
        // scan each other (otherwise, they would<br />
        // deadlock). We must not modify anything on<br />
        // the G stack. However, stack shrinking is<br />
        // disabled for mark workers, so it is safe to<br />
        // read from the G stack.<br />
        casgstatus(gp, <em>Grunning, _Gwaiting)<br />
        switch _p</em>.gcMarkWorkerMode {<br />
        default:<br />
            throw(“gcBgMarkWorker: unexpected gcMarkWorkerMode”)<br />
        case gcMarkWorkerDedicatedMode:<br />
            gcDrain(&amp;<em>p</em>.gcw, gcDrainNoBlock|gcDrainFlushBgCredit)<br />
        case gcMarkWorkerFractionalMode:<br />
            gcDrain(&amp;<em>p</em>.gcw, gcDrainUntilPreempt|gcDrainFlushBgCredit)<br />
        case gcMarkWorkerIdleMode:<br />
            gcDrain(&amp;<em>p</em>.gcw, gcDrainIdle|gcDrainUntilPreempt|gcDrainFlushBgCredit)<br />
        }<br />
        casgstatus(gp, _Gwaiting, _Grunning)<br />
        })<br />
        …<br />
    }<br />
}<br />
Mark 阶段的标记代码主要在函数 gcDrain() 中实现。<br />
// gcDrain scans roots and objects in work buffers, blackening grey<br />
// objects until all roots and work buffers have been drained.<br />
func gcDrain(gcw *gcWork, flags gcDrainFlags) {<br />
    …	<br />
    // Drain root marking jobs.<br />
    if work.markrootNext &lt; work.markrootJobs {<br />
        for !(preemptible &amp;&amp; gp.preempt) {<br />
            job := atomic.Xadd(&amp;work.markrootNext, +1) - 1<br />
            if job &gt;= work.markrootJobs {<br />
                break<br />
            }<br />
            markroot(gcw, job)<br />
            if idle &amp;&amp; pollWork() {<br />
                goto done<br />
            }<br />
        }<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 处理 heap 标记<br />
// Drain heap marking jobs.<br />
for !(preemptible &amp;&amp; gp.preempt) {<br />
    ...<br />
    //从灰色列队中取出对象<br />
    var b uintptr<br />
    if blocking {<br />
        b = gcw.get()<br />
    } else {<br />
        b = gcw.tryGetFast()<br />
        if b == 0 {<br />
            b = gcw.tryGet()<br />
        }<br />
    }<br />
    if b == 0 {<br />
        // work barrier reached or tryGet failed.<br />
        break<br />
    }<br />
    //扫描灰色对象的引用对象，标记为灰色，入灰色队列<br />
    scanobject(b, gcw)<br />
} } 3. Mark termination (STW phase 2) mark termination 阶段会 stop the world。函数实现在 gcMarkTermination()。1.8 版本已经不会再对 goroutine stack 进行 re-scan 了。细节有点多，这里不细说了。 func gcMarkTermination() {<br />
// World is stopped.<br />
// Run gc on the g0 stack. We do this so that the g stack<br />
// we're currently running on will no longer change. Cuts<br />
// the root set down a bit (g0 stacks are not scanned, and<br />
// we don't need to scan gc's internal state).  We also<br />
// need to switch to g0 so we can shrink the stack.<br />
systemstack(func() {<br />
    gcMark(startTime)<br />
    // Must return immediately.<br />
    // The outer function's stack may have moved<br />
    // during gcMark (it shrinks stacks, including the<br />
    // outer function's stack), so we must not refer<br />
    // to any of its variables. Return back to the<br />
    // non-system stack to pick up the new addresses<br />
    // before continuing.<br />
})<br />
... } 3.4 清扫 清扫相对来说就简单很多了。 func gcSweep(mode gcMode) {<br />
...<br />
//阻塞式<br />
if !_ConcurrentSweep || mode == gcForceBlockMode {<br />
    // Special case synchronous sweep.<br />
    ...<br />
    // Sweep all spans eagerly.<br />
    for sweepone() != ^uintptr(0) {<br />
        sweep.npausesweep++<br />
    }<br />
    // Do an additional mProf_GC, because all 'free' events are now real as well.<br />
    mProf_GC()<br />
    mProf_GC()<br />
    return<br />
}<br />
  	<br />
// 并行式<br />
// Background sweep.<br />
lock(&amp;sweep.lock)<br />
if sweep.parked {<br />
    sweep.parked = false<br />
    ready(sweep.g, 0, true)<br />
}<br />
unlock(&amp;sweep.lock) } 对于并行式清扫，在 GC 初始化的时候就会启动 bgsweep()，然后在后台一直循环。<br />
</code></pre></div></div><br />
<br />
<p>func bgsweep(c chan int) {<br />
    sweep.g = getg()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lock(&amp;sweep.lock)<br />
sweep.parked = true<br />
c &lt;- 1<br />
goparkunlock(&amp;sweep.lock, "GC sweep wait", traceEvGoBlock, 1)<br />
<br />
for {<br />
    for gosweepone() != ^uintptr(0) {<br />
        sweep.nbgsweep++<br />
        Gosched()<br />
    }<br />
    lock(&amp;sweep.lock)<br />
    if !gosweepdone() {<br />
        // This can happen if a GC runs between<br />
        // gosweepone returning ^0 above<br />
        // and the lock being acquired.<br />
        unlock(&amp;sweep.lock)<br />
        continue<br />
    }<br />
    sweep.parked = true<br />
    goparkunlock(&amp;sweep.lock, "GC sweep wait", traceEvGoBlock, 1)<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>func gosweepone() uintptr {<br />
    var ret uintptr<br />
    systemstack(func() {<br />
        ret = sweepone()<br />
    })<br />
    return ret<br />
}<br />
不管是阻塞式还是并行式，都是通过 sweepone()函数来做清扫工作的。如果对于上篇文章 Golang 内存管理 熟悉的话，这个地方就很好理解。内存管理都是基于 span 的，mheap_ 是一个全局的变量，所有分配的对象都会记录在 mheap_ 中。在标记的时候，我们只要找到对对象对应的 span 进行标记，清扫的时候扫描 span，没有标记的 span 就可以回收了。<br />
// sweeps one span<br />
// returns number of pages returned to heap, or ^uintptr(0) if there is nothing to sweep<br />
func sweepone() uintptr {<br />
    …<br />
    for {<br />
        s := mheap_.sweepSpans[1-sg/2%2].pop()<br />
        …<br />
        if !s.sweep(false) {<br />
            // Span is still in-use, so this returned no<br />
            // pages to the heap and the span needs to<br />
            // move to the swept in-use list.<br />
            npages = 0<br />
        }<br />
    }<br />
}</p><br />
<br />
<p>// Sweep frees or collects finalizers for blocks not marked in the mark phase.<br />
// It clears the mark bits in preparation for the next GC round.<br />
// Returns true if the span was returned to heap.<br />
// If preserve=true, don’t return it to heap nor relink in MCentral lists;<br />
// caller takes care of it.<br />
func (s *mspan) sweep(preserve bool) bool {<br />
    …<br />
}<br />
3.5 其他</p><br />
<ol><br />
  <li>gcWork<br />
这里介绍一下任务队列，或者说灰色对象管理。每个 P 上都有一个 gcw 用来管理灰色对象（get 和 put），gcw 的结构就是 gcWork。gcWork 中的核心是 wbuf1 和 wbuf2，里面存储就是灰色对象，或者说是 work（下面就全部统一叫做 work）。<br />
type p struct {<br />
 …<br />
 gcw gcWork<br />
}</li><br />
</ol><br />
<br />
<p>type gcWork struct {<br />
    // wbuf1 and wbuf2 are the primary and secondary work buffers.<br />
    wbuf1, wbuf2 wbufptr</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Bytes marked (blackened) on this gcWork. This is aggregated<br />
// into work.bytesMarked by dispose.<br />
bytesMarked uint64<br />
<br />
// Scan work performed on this gcWork. This is aggregated into<br />
// gcController by dispose and may also be flushed by callers.<br />
scanWork int64 } 既然每个 P 上有一个 work buffer，那么是不是还有一个全局的 work list 呢？是的。通过在每个 P 上绑定一个 work buffer 的好处和 cache 一样，不需要加锁。 var work struct {<br />
full  uint64                   // lock-free list of full blocks workbuf<br />
empty uint64                   // lock-free list of empty blocks workbuf<br />
pad0  [sys.CacheLineSize]uint8 // prevents false-sharing between full/empty and nproc/nwait<br />
... } 那么为什么使用两个 work buffer （wbuf1 和 wbuf2）呢？我下面举个例子。比如我现在要 get 一个 work 出来，先从 wbuf1 中取，wbuf1 为空的话则与 wbuf2 swap 再 get。在其他时间将 work buffer 中的 full 或者 empty buffer 移到 global 的 work 中。这样的好处在于，在 get 的时候去全局的 work 里面取（多个 goroutine 去取会有竞争）。这里有趣的是 global 的 work list 是 lock-free 的，通过原子操作 cas 等实现。下面列举几个函数看一下 gcWrok。<br />
</code></pre></div></div><br />
<br />
<p>初始化。<br />
func (w *gcWork) init() {<br />
    w.wbuf1 = wbufptrOf(getempty())<br />
    wbuf2 := trygetfull()<br />
    if wbuf2 == nil {<br />
        wbuf2 = getempty()<br />
    }<br />
    w.wbuf2 = wbufptrOf(wbuf2)<br />
}<br />
put。<br />
// put enqueues a pointer for the garbage collector to trace.<br />
// obj must point to the beginning of a heap object or an oblet.<br />
func (w *gcWork) put(obj uintptr) {<br />
    wbuf := w.wbuf1.ptr()<br />
    if wbuf == nil {<br />
        w.init()<br />
        wbuf = w.wbuf1.ptr()<br />
        // wbuf is empty at this point.<br />
    } else if wbuf.nobj == len(wbuf.obj) {<br />
        w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1<br />
        wbuf = w.wbuf1.ptr()<br />
        if wbuf.nobj == len(wbuf.obj) {<br />
            putfull(wbuf)<br />
            wbuf = getempty()<br />
            w.wbuf1 = wbufptrOf(wbuf)<br />
            flushed = true<br />
        }<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wbuf.obj[wbuf.nobj] = obj<br />
wbuf.nobj++ } get。<br />
</code></pre></div></div><br />
<br />
<p>// get dequeues a pointer for the garbage collector to trace, blocking<br />
// if necessary to ensure all pointers from all queues and caches have<br />
// been retrieved.  get returns 0 if there are no pointers remaining.<br />
//go:nowritebarrier<br />
func (w *gcWork) get() uintptr {<br />
    wbuf := w.wbuf1.ptr()<br />
    if wbuf == nil {<br />
        w.init()<br />
        wbuf = w.wbuf1.ptr()<br />
        // wbuf is empty at this point.<br />
    }<br />
    if wbuf.nobj == 0 {<br />
        w.wbuf1, w.wbuf2 = w.wbuf2, w.wbuf1<br />
        wbuf = w.wbuf1.ptr()<br />
        if wbuf.nobj == 0 {<br />
            owbuf := wbuf<br />
            wbuf = getfull()<br />
            if wbuf == nil {<br />
                return 0<br />
            }<br />
            putempty(owbuf)<br />
            w.wbuf1 = wbufptrOf(wbuf)<br />
        }<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// TODO: This might be a good place to add prefetch code<br />
<br />
wbuf.nobj--<br />
return wbuf.obj[wbuf.nobj] } 2. forcegc 我们上面讲了两种 GC 触发方式：自动检测和用户主动调用。除此之后 Golang 本身还会对运行状态进行监控，如果超过两分钟没有 GC，则触发 GC。监控函数是 sysmon()，在主 goroutine 中启动。<br />
</code></pre></div></div><br />
<br />
<p>// The main goroutine<br />
func main() {<br />
    …<br />
    systemstack(func() {<br />
      	newm(sysmon, nil)<br />
    })<br />
}<br />
// Always runs without a P, so write barriers are not allowed.<br />
func sysmon() {<br />
    …<br />
    for {<br />
        now := nanotime()<br />
        unixnow := unixnanotime()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    lastgc := int64(atomic.Load64(&amp;memstats.last_gc))<br />
    if gcphase == _GCoff &amp;&amp; lastgc != 0 &amp;&amp; unixnow-lastgc &gt; forcegcperiod &amp;&amp; atomic.Load(&amp;forcegc.idle) != 0 {<br />
        lock(&amp;forcegc.lock)<br />
        forcegc.idle = 0<br />
        forcegc.g.schedlink = 0<br />
        injectglist(forcegc.g)	// 将 forcegc goroutine 加入 runnable queue<br />
        unlock(&amp;forcegc.lock)<br />
    }<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>var forcegcperiod int64 = 2 * 60 *1e9	//两分钟<br />
4.参考资料<br />
《Go 语言学习笔记》<br />
《垃圾收集》 - 豆瓣<br />
Tracing Garbage Collection - wikipedia<br />
《On-the-fly garbage collection: an exercise in cooperation.》 — Edsger W. Dijkstra, Leslie Lamport, A. J. Martin<br />
Garbage Collection)<br />
Tracing Garbage Collection<br />
Copying Garbage Collection – youtube<br />
Generational Garbage Collection – youtube<br />
golang gc talk<br />
17503-eliminate-rescan</p><br />
<br />
<p>Go 内存分配<br />
Go 运行时的内存分配算法主要源自 Google 为 C 语言开发的 TCMalloc 算法，全称 Thread-Caching Malloc。该算法的特色在于其将可用的堆内存采用二级分配的形式进行管理：每个线程都会自行维护一个独立的内存池，进行内存分配时优先从该内存池中分配，当内存池不足时才向全局内存池申请，以避免不同线程对全局内存池的频繁竞争。除此以外，该算法会对小对象和大对象采用不同的内存分配过程。</p><br />
<br />
<p>Go 运行时的内存分配算法在很大程度上与该算法保持一致。首先，Go 在为小对象（大小小于 32 KB）分配内存时会对对象的实际大小向上取整，将对象分类到大约 70 个不同大小的 Size Class 中，并按照 Size Class 的大小为对象分配空间。每个 Size Class 的具体数值系考虑各项约束后自动生成，最小的 Size Class 为 8B，最大为 32KB。详见 mksizeclasses.go 和 sizeclasses.go。</p><br />
<br />
<p>在明确这一概念后，我们便可以开始了解 Go 内存分配算法主要使用的数据结构了：</p><br />
<br />
<p>mheap：代表 Go 程序所持有的所有堆空间，可视为由若干个大小为 8 KB 的内存页组成的数组<br />
mspan：一个 mspan 从属于某个指定的 Size Class，在 mheap 上占据若干个连续的内存页，其内部根据所属 Size Class 的大小被平均划分为若干个 object。每个 mspan 会使用一个 bitmap 来标记其内部尚可用的 object<br />
mcache：Goroutine 本地缓存的可用 mspan，是上一节所提到的 P 的一部分<br />
mcentral：全局可用的 mspan 列表。Goroutine 在需要时会从 mcentral 获取 mspan<br />
如此一来，Go 运行时进行内存分配的过程就十分清晰了。当 Go 需要为小对象分配对象时，小对象会被向上取整至最近的 Size Class，并执行如下步骤：</p><br />
<br />
<p>从当前 P 的 mcache 中获取属于该 Class 且仍有空闲位置的 mspan<br />
若 mcache 已空，则从 mcentral 获取一整个 mspan 到当前 P 的 mcache 中<br />
若 mcentral 已空，则从 mheap 中获取若干个连续内存页，构建新的 mspan 并放入到 mcentral 中<br />
若 mheap 已空，则从操作系统申请若干个内存页到 mheap 中<br />
对于大对象而言，Go 则会跳过 mcache 和 mcentral，直接在 mheap 上构建一个合适大小的 mspan 进行分配</p><br />
<br />
<p>Go 垃圾回收<br />
在了解了 Go 如何为对象分配内存后，我们便可以开始学习 Go 是如何进行垃圾回收的了。</p><br />
<br />
<p>当前 Go 的最新版本为 1.8.3，Go 采用的是并发、三色的标记 - 清除垃圾收集器。这个垃圾收集器在 Go 1.5 版的时候引入，并在当时将 Go 的 GC Pause 时间缩短到了 1.4 版的几百分之一。尽管做出了不少的修改，Go 的垃圾收集算法参考了 Dijkstra 在 1978 年写的论文：《On-the-Fly Garbage Collection: An Exercise in Cooperation》。</p><br />
<br />
<p>标记 - 清除算法可以说是最经典的垃圾回收算法。该算法的回收过程分为两个步骤：</p><br />
<br />
<p>标记：从 GC Root 对象开始，沿着对象中包含的所有指针递归地标记所有可达的对象。GC Root 对象包括所有在标记前便确定可达的对象，如全局变量、位于栈帧中的本地变量等<br />
清除：在标记阶段结束后，未被标记的对象意味着不可达。清除阶段将清除所有未被标记的对象，释放它们所占用的内存。<br />
标记 - 清除算法作为最经典也是最基础的算法存在着它的不足，最主要的不足在于它在清除阶段会对未被标记的对象原地进行释放，被释放对象所留下的空隙便形成了内存碎片，而内存碎片的存在会导致程序的内存空间利用率下降。</p><br />
<br />
<p>实际上，Go 所谓的并发、三色的标记 - 清除垃圾收集算法并不新鲜，JVM 和 V8 中都有类似的收集算法。在 JVM 中，该收集器被称为 CMS 收集器（Concurrent Mark-Sweep）。JVM 的 CMS 收集器执行过程与 Go 的收集器类似，也有着和 Go 的收集器相似的特性：以降低程序计算吞吐量为代价，减少 GC Pause 的时间。</p><br />
<br />
<p>Go 垃圾收集器的一次收集过程可归纳为如下几个步骤：</p><br />
<br />
<p>_GcOff：两次 GC 间，Go 程序将处于 _GcOff 状态。GC 发生的过程中会把所有处于 mcache 中的 mspan 放回 mcentral，以让 Goroutine 申请内存时需要重新从 mcentral 获取 mspan。Goroutine 获取 mspan 时会 lazy 地清除 mspan 中在上一次 GC 中未被标记的对象。除此以外，另一个 GC Bg Worker Goroutine 也会主动地清扫未被清扫地 mspan；<br />
清除终止：开始 GC 前的准备工作。此时程序会 Stop the world，并清扫所有仍未被清扫的 mspan。通常 GC 会在程序的内存占用达到一定阈值时被触发，通常此时应当已经不存在仍未被清扫的 mspan。若此次 GC 是由 runtime.GC() 等方式手动触发的则情况可能有所不同；<br />
_GcMark：标记阶段。此时 Go 收集器会利用之前开启的 Stop the world，为所有用户 Goroutine 启动写屏障（Write Barrier）。然后，Go 收集器会把 GC Root 对象的标记工作放入到标记作业队列（置为灰色）。之后 Go 收集器便会恢复用户 Goroutine 的执行。开启了写屏障的 Goroutine 在每次修改指针变量的值时会使得新旧指针指向的对象均被置为灰色，而新创建的对象这会直接被置为黑色（已标记）。除此以外，位于后台运行的 Mark Worker Goroutine 会开始从标记作业队列中获取颜色为灰色的对象，对其进行标记（置为黑色），并将其指向的其他结点置为灰色（放入标记作业队列），直到作业队列被耗尽；<br />
_GcMarkTermination：标记阶段的收尾工作。Stop the world，并完成队列中剩余的标记作业。通常此时队列已为空。完成标记作业后将继续完成其他 GC 收尾工作，如将 Goroutine mcache 中的 mspan 放回到 mcentral；<br />
_GcOff：GC 结束，恢复用户 Goroutine 的执行，由用户 Goroutine 和 GC Worker Goroutine 对 mspan 中未被标记的对象进行回收</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>