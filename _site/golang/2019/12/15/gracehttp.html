<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">gracehttp</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-12-15T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Dec 15, 2019</time></p>
					</div>
					 <p>经典平滑升级方案</p><br />
<br />
<p>服务器开发运维中，平滑升级是一个老生常谈的话题。拿一个http server来说，最常见的方案就是在http server前面加挂一个lvs负载，通过健康检查接口决定负载的导入与摘除。具体来说就是http server 提供一个/status 接口，服务器返回一个status文件，内容为ok，lvs负载定时访问这个接口，判断服务健康状况决定导入流量和切断流量。一般都会定一些策略，比如：访问间隔5秒，健康阈值2，异常阈值2之类的。意思就是每隔5秒访问一次/status接口，2次成功后，确认服务正常，开始导入流量，2次失败确认服务异常切断流量。当服务升级时，修改status文件内容为off，等待lvs健康检查确认服务为异常状态时主动切断流量，此时进行服务器的升级操作，服务重启完毕后，将status文件内容修改回ok，等待lvs健康检查确认服务正常后导入流量，以此步骤逐步完成剩余的机器的发布操作。将以上步骤完善成脚本，拆分为pre（预升级，ok修改为off）、post（发布代码，重启服务）、check（服务检查）、online（上线，off修改为ok）几个动作，与代码发布平台结合基本就实现了一般服务的自动化发版管理。360内部的代码发布平台Furion就是基于此原理工作的。</p><br />
<br />
<p>经典平滑升级方案的问题</p><br />
<br />
<p>一般的web服务使用上述平滑升级方案，基本上已经够用了。那这个方案还有什么问题吗？吹毛求疵的讲，还是有的。</p><br />
<br />
<p>发布过程中，正在发布的机器被摘除，其他机器承压增大。</p><br />
<br />
<p>发布过程仍然花费一些时间，按照上述策略指定的参数，发布一次至少需要20秒，当然我们可以调整参数，但是要面临浪费资源或者网络抖动误判导致切断流量的问题。</p><br />
<br />
<p>切断流量瞬间会导致未完成请求返回不完整。</p><br />
<br />
<p>这些问题一般来说都不算大问题，服务器资源做好冗余就够了，但是当服务器数量很大，服务器QPS很高的情况，小问题也会变大问题。所有寻求完美无缝重启的方案就是解决问题的关键了。<br />
https://mp.weixin.qq.com/s?__biz=MzU4ODgyMDI0Mg==&amp;mid=2247487071&amp;idx=1&amp;sn=c0098f0ea50f6b1fc5c94ea9e68e8bfb<br />
<!-- more --><br />
优雅重启</p><br />
<br />
<p>golang语言http服务的优雅重启开源库也有一些，我们选择Facebook开源的库进行研究。代码地址https://github.com/facebookarchive/grace.git。网上的开源库的实现或简单或复杂，其实原理都差不多，执行优雅重启的过程基本如下：</p><br />
<br />
<p>发布新的bin文件去覆盖老的bin文件</p><br />
<br />
<p>发送一个信号量，告诉正在运行的进程，进行重启</p><br />
<br />
<p>正在运行的进程收到信号后，会以子进程的方式启动新的bin文件</p><br />
<br />
<p>新进程接受新请求，并处理</p><br />
<br />
<p>老进程不再接受请求，但是要等正在处理的请求处理完成，所有在处理的请求处理完之后，便自动退出<br />
其实我总结了一下，就两个关键点，一个是子进程继承端口监听启动，接受新请求处理；另一个是父进程优雅关闭。通过以上两个步骤基本上就实现了服务的无缝重启，发布过程中流量无损，发布消耗时间理论上最大也就是一个请求的超时时间，回滚服务也很简单，将旧版本服务重发一次就好了。</p><br />
<br />
<p>源码分析</p><br />
<br />
<p>1</p><br />
<br />
<p>使用方法</p><br />
<br />
<p>示例使用了流行的http库 gin，我们一般用法如下</p><br />
<br />
<p>func main<br />
()</p><br />
<br />
<p>{</p><br />
<br />
<p>engine <br />
:=<br />
 gin<br />
.<br />
New<br />
()</p><br />
<br />
<p>engine<br />
.<br />
Use<br />
(<br />
httpserver<br />
.<br />
NewAccessLogger<br />
(),<br />
 gin<br />
.<br />
Recovery<br />
())</p><br />
<br />
<p>controller<br />
.<br />
Regist<br />
(<br />
engine<br />
)</p><br />
<br />
<p>srv <br />
:=</p><br />
<br />
<p>&amp;<br />
http<br />
.<br />
Server<br />
{</p><br />
<br />
<p>Addr<br />
:</p><br />
<br />
<p>“:80”<br />
,</p><br />
<br />
<p>Handler<br />
:<br />
      engine<br />
,</p><br />
<br />
<p>ReadTimeout<br />
:</p><br />
<br />
<p>30</p><br />
<br />
<p>*<br />
 time<br />
.<br />
Second<br />
,</p><br />
<br />
<p>WriteTimeout<br />
:</p><br />
<br />
<p>30</p><br />
<br />
<p>*<br />
 time<br />
.<br />
Second<br />
,</p><br />
<br />
<p>}</p><br />
<br />
<p>monitor<br />
.<br />
Init<br />
()</p><br />
<br />
<p>srvMonitor <br />
:=</p><br />
<br />
<p>&amp;<br />
http<br />
.<br />
Server<br />
{</p><br />
<br />
<p>Addr<br />
:</p><br />
<br />
<p>“:9900”<br />
,</p><br />
<br />
<p>Handler<br />
:</p><br />
<br />
<p>nil<br />
,</p><br />
<br />
<p>ReadTimeout<br />
:</p><br />
<br />
<p>30</p><br />
<br />
<p>*<br />
 time<br />
.<br />
Second<br />
,</p><br />
<br />
<p>WriteTimeout<br />
:</p><br />
<br />
<p>30</p><br />
<br />
<p>*<br />
 time<br />
.<br />
Second<br />
,</p><br />
<br />
<p>}</p><br />
<br />
<p>grace<br />
.<br />
Serve<br />
(<br />
srv<br />
,<br />
 srvMonitor<br />
)</p><br />
<br />
<p>}</p><br />
<br />
<p>grace.Serve函数参数是一个切片，可以处理多个server的端口监听继承与优雅关闭。此外还提供了关闭前的hook，使用方法如下：</p><br />
<br />
<p>gracehttp<br />
.<br />
ServeWithOptions<br />
([]*<br />
http<br />
.<br />
Server<br />
{<br />
srv<br />
,<br />
 srvMonitor<br />
},<br />
 gracehttp<br />
.<br />
PreStartProcess<br />
(<br />
func<br />
()<br />
 error <br />
{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    logger . Info ( "do PreStartProcess\n" )<br />
</code></pre></div></div><br />
<br />
<p>return</p><br />
<br />
<p>nil</p><br />
<br />
<p>}))</p><br />
<br />
<p>在调研中我发现项目上有错误的使用方法，如下：</p><br />
<br />
<p>func startHttp<br />
()</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>engine  :=  gin . New ()<br />
<br />
engine . Use ( httpserver . NewAccessLogger (),  gin . Recovery ())<br />
<br />
controller . Regist ( engine )<br />
<br />
srv  :=<br />
</code></pre></div></div><br />
<br />
<p>&amp;<br />
http<br />
.<br />
Server<br />
{</p><br />
<br />
<p>Addr<br />
:</p><br />
<br />
<p>“:80”<br />
,</p><br />
<br />
<p>Handler<br />
:<br />
      engine<br />
,</p><br />
<br />
<p>ReadTimeout<br />
:</p><br />
<br />
<p>30</p><br />
<br />
<p>*<br />
 time<br />
.<br />
Second<br />
,</p><br />
<br />
<p>WriteTimeout<br />
:</p><br />
<br />
<p>30</p><br />
<br />
<p>*<br />
 time<br />
.<br />
Second<br />
,</p><br />
<br />
<p>}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>monitor . Init ()<br />
<br />
srvMonitor  :=<br />
</code></pre></div></div><br />
<br />
<p>&amp;<br />
http<br />
.<br />
Server<br />
{</p><br />
<br />
<p>Addr<br />
:</p><br />
<br />
<p>“:9900”<br />
,</p><br />
<br />
<p>Handler<br />
:</p><br />
<br />
<p>nil<br />
,</p><br />
<br />
<p>ReadTimeout<br />
:</p><br />
<br />
<p>30</p><br />
<br />
<p>*<br />
 time<br />
.<br />
Second<br />
,</p><br />
<br />
<p>WriteTimeout<br />
:</p><br />
<br />
<p>30</p><br />
<br />
<p>*<br />
 time<br />
.<br />
Second<br />
,</p><br />
<br />
<p>}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>grace . Serve ( srv ,  srvMonitor )<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>func main<br />
()</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go startHttp ()<br />
</code></pre></div></div><br />
<br />
<p>//注册信号</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go signalHandler ()<br />
</code></pre></div></div><br />
<br />
<p>&lt;-<br />
quiet</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logger . Info ( "Close Server" )<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>func signalHandler<br />
()</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c  :=  make ( chan os . Signal )<br />
<br />
signal . Notify ( c ,  syscall . SIGHUP ,  syscall . SIGINT ,  syscall . SIGTERM ,  syscall . SIGKILL ,  syscall . SIGQUIT )<br />
<br />
s  :=<br />
</code></pre></div></div><br />
<br />
<p>&lt;-<br />
c</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>logger . Info ( "get siginal  siginal=%v" ,  s )<br />
<br />
quiet  &lt;-<br />
</code></pre></div></div><br />
<br />
<p>1</p><br />
<br />
<p>}</p><br />
<br />
<p>这里为什么出错了呢，是因为他将grace.Serve(srv,srvMonitor) 放在goroutine里面了，并且自己又监听了一遍信号，这样会导致旧进程优雅关闭前，父进程已经已经退出了，优雅关闭就失效了。</p><br />
<br />
<p>2</p><br />
<br />
<p>关键代码</p><br />
<br />
<p>我们按照程序启动的顺序逻辑来讲，大体如下：</p><br />
<br />
<p>执行启动端口监听，挂载server，判断当前进程如果是子进程就向父进程发送SIGTERM信号。</p><br />
<br />
<p>goroutine 执行wg.Add 和wg.Wait() ，等待所有挂载的server停止工作后执行退出进程。</p><br />
<br />
<p>goroutine 执行 signalHandler，等待SIGTERM和SIGUSR2信号。收到SIGTERM信号执行每个server的优雅关闭，关闭完后执行wg.Done()，wg全部Done之后在2中执行了退出进程操作；收到SIGUSR2信号时，执行启动子进程操作。</p><br />
<br />
<p>子进程启动执行1，会向父进程发送SIGTERM信号，父进程收到SIGTERM信号执行3，进行优雅关闭操作。</p><br />
<br />
<p>总结起来就是执行启动重启时，执行shell命令：</p><br />
<br />
<p>pgrep <br />
(你的项目名)</p><br />
<br />
<p>|<br />
xargs kill <br />
-<br />
SIGUSR2</p><br />
<br />
<p>#(注意：要使用bash)。</p><br />
<br />
<p>你的项目会启动子进程，并继承父进程监听的端口，启动成功后再向父进程发送SIGTERM信号， 旧进程执行优雅关闭。我们看关键的struct</p><br />
<br />
<p>// gracehttp/http.go</p><br />
<br />
<p>type app <br />
struct</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>servers          []* http . Server<br />
<br />
http             * httpdown . HTTP<br />
<br />
net              * gracenet . Net<br />
<br />
listeners        [] net . Listener<br />
<br />
sds              [] httpdown . Server<br />
<br />
preStartProcess func ()  error<br />
<br />
errors          chan error<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>// httpdown/httpdown.go</p><br />
<br />
<p>type HTTP <br />
struct</p><br />
<br />
<p>{</p><br />
<br />
<p>// StopTimeout is the duration before we begin force closing connections.</p><br />
<br />
<p>// Defaults to 1 minute.</p><br />
<br />
<p>StopTimeout<br />
 time<br />
.<br />
Duration</p><br />
<br />
<p>// KillTimeout is the duration before which we completely give up and abort</p><br />
<br />
<p>// even though we still have connected clients. This is useful when a large</p><br />
<br />
<p>// number of client connections exist and closing them can take a long time.</p><br />
<br />
<p>// Note, this is in addition to the StopTimeout. Defaults to 1 minute.</p><br />
<br />
<p>KillTimeout<br />
 time<br />
.<br />
Duration</p><br />
<br />
<p>// Stats is optional. If provided, it will be used to record various metrics.</p><br />
<br />
<p>Stats<br />
 stats<br />
.<br />
Client</p><br />
<br />
<p>// Clock allows for testing timing related functionality. Do not specify this</p><br />
<br />
<p>// in production code.</p><br />
<br />
<p>Clock<br />
 clock<br />
.<br />
Clock</p><br />
<br />
<p>}</p><br />
<br />
<p>// gracenet/net.go</p><br />
<br />
<p>type <br />
Net</p><br />
<br />
<p>struct</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inherited    [] net . Listener<br />
<br />
active       [] net . Listener<br />
<br />
mutex       sync . Mutex<br />
<br />
inheritOnce sync . Once<br />
</code></pre></div></div><br />
<br />
<p>// used in tests to override the default behavior of starting from fd 3.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fdStart  int<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>我们知道函数调用是从grace.Serve(srv, srvMonitor)开始的,Serve函数会new一个app，一路执行下去关键函数如下：a.run()、a.listen()、a.serve()、 a.wait()、a.signalHandler()、 a.term()、a.net.StartProcess()。</p><br />
<br />
<p>a.run() 大体逻辑如下：</p><br />
<br />
<p>var</p><br />
<br />
<p>(</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>didInherit  =  os . Getenv ( "LISTEN_FDS" )<br />
</code></pre></div></div><br />
<br />
<p>!=</p><br />
<br />
<p>””</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ppid        =  os . Getppid ()<br />
</code></pre></div></div><br />
<br />
<p>)</p><br />
<br />
<p>func <br />
(<br />
a <br />
*<br />
app<br />
)<br />
 run<br />
()<br />
 error <br />
{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a . listen ()<br />
<br />
a . serve ()<br />
</code></pre></div></div><br />
<br />
<p>if<br />
 didInherit <br />
&amp;&amp;<br />
 ppid <br />
!=</p><br />
<br />
<p>1</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>syscall . Kill ( ppid ,  syscall . SIGTERM )<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>waitdone  :=  make ( chan  struct {})<br />
<br />
go func ()<br />
</code></pre></div></div><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defer close ( waitdone )<br />
<br />
a . wait ()<br />
</code></pre></div></div><br />
<br />
<p>}()</p><br />
<br />
<p>select</p><br />
<br />
<p>{</p><br />
<br />
<p>case<br />
 err <br />
:=</p><br />
<br />
<p>&lt;-<br />
a<br />
.<br />
errors<br />
:</p><br />
<br />
<p>…</p><br />
<br />
<p>case</p><br />
<br />
<p>&lt;-<br />
waitdone<br />
:</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    logger . Printf ( "Exiting pid %d." ,  os . Getpid ())<br />
</code></pre></div></div><br />
<br />
<p>return</p><br />
<br />
<p>nil</p><br />
<br />
<p>}</p><br />
<br />
<p>}</p><br />
<br />
<p>启动监听、挂载server，通过环境变量LISTEN_FDS判断当前进程是否为子进程，如果是就发送信号杀父进程。goroutine中执行wait()函数等待优雅关闭或者平滑启动子进程。</p><br />
<br />
<p>a.listen() 关键逻辑如下：</p><br />
<br />
<p>func <br />
(<br />
a <br />
*<br />
app<br />
)<br />
 listen<br />
()<br />
 error <br />
{</p><br />
<br />
<p>for<br />
 _<br />
,<br />
 s <br />
:=<br />
 range a<br />
.<br />
servers <br />
{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    l ,  err  :=  a . net . Listen ( "tcp" ,  s . Addr )<br />
</code></pre></div></div><br />
<br />
<p>……</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a . listeners  =  append ( a . listeners ,  l )<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>return</p><br />
<br />
<p>nil</p><br />
<br />
<p>}</p><br />
<br />
<p>这里看出app struct 中listeners用来存储监听的net.Listener的数组 ，net就是Net，封装了net.ListenTCP等逻辑（这里我只关注了TCP逻辑），inherited 和 active 两个数组分别用来存储继承自父进程的net.Listener 和 启动的net.Listener，这块父进程启动，即首次启动时逻辑很简单，略过，子进程启动，即非首次启动在介绍a.net.StartProccess时细讲。</p><br />
<br />
<p>a.serve() 关键逻辑如下：</p><br />
<br />
<p>func <br />
(<br />
a <br />
*<br />
app<br />
)<br />
 serve<br />
()</p><br />
<br />
<p>{</p><br />
<br />
<p>for<br />
 i<br />
,<br />
 s <br />
:=<br />
 range a<br />
.<br />
servers <br />
{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    a . sds  =  append ( a . sds ,  a . http . Serve ( s ,  a . listeners [ i ]))<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>}</p><br />
<br />
<p>这里涉及了app struct里面的两个字段，http和sds。http即 HTTP struct， 这里面封装了http server优雅关闭相关的逻辑，具体的细节很繁琐，我用一个简单的模型来说明一下吧。a.http.Serve(srv,l) 函数封装执行了srv.Serve(l)，即挂载srv， 并返回了一个httpdown.server的实例， 这个实例实现了httpdown.Server 接口，如下：</p><br />
<br />
<p>// httpdown/httpdown.go</p><br />
<br />
<p>type <br />
Server</p><br />
<br />
<p>interface</p><br />
<br />
<p>{</p><br />
<br />
<p>// Wait waits for the serving loop to finish. This will happen when Stop is</p><br />
<br />
<p>// called, at which point it returns no error, or if there is an error in the</p><br />
<br />
<p>// serving loop. You must call Wait after calling Serve or ListenAndServe.</p><br />
<br />
<p>Wait<br />
()<br />
 error</p><br />
<br />
<p>// Stop stops the listener. It will block until all connections have been</p><br />
<br />
<p>// closed.</p><br />
<br />
<p>Stop<br />
()<br />
 error</p><br />
<br />
<p>}</p><br />
<br />
<p>精简后实现的模型如下：</p><br />
<br />
<p>func <br />
(<br />
s <br />
*<br />
server<br />
)<br />
 serve<br />
()</p><br />
<br />
<p>{</p><br />
<br />
<p>// 即前面提到的 srv.Serve(l)，被封装的挂载srv的代码</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s . serveErr  &lt;-  s . server . Serve ( s . listener )<br />
<br />
close ( s . serveDone )<br />
<br />
close ( s . serveErr )<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>func <br />
(<br />
s <br />
*<br />
server<br />
)</p><br />
<br />
<p>Wait<br />
()<br />
 error <br />
{</p><br />
<br />
<p>if<br />
 err <br />
:=</p><br />
<br />
<p>&lt;-<br />
s<br />
.<br />
serveErr<br />
;</p><br />
<br />
<p>!<br />
isUseOfClosedError<br />
(<br />
err<br />
)</p><br />
<br />
<p>{</p><br />
<br />
<p>return<br />
 err</p><br />
<br />
<p>}</p><br />
<br />
<p>return</p><br />
<br />
<p>nil</p><br />
<br />
<p>}</p><br />
<br />
<p>func <br />
(<br />
s <br />
*<br />
server<br />
)</p><br />
<br />
<p>Stop<br />
()<br />
 error <br />
{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>s . stopOnce . Do ( func ()<br />
</code></pre></div></div><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    closeErr  :=  s . listener . Close ()<br />
</code></pre></div></div><br />
<br />
<p>&lt;-<br />
s<br />
.<br />
serveDone</p><br />
<br />
<p>……</p><br />
<br />
<p>// 等待连接关闭或者超时后强杀连接等复杂逻辑</p><br />
<br />
<p>……</p><br />
<br />
<p>if<br />
 closeErr <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>&amp;&amp;</p><br />
<br />
<p>!<br />
isUseOfClosedError<br />
(<br />
closeErr<br />
)</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        s . stopErr  =  closeErr<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>})</p><br />
<br />
<p>return<br />
 s<br />
.<br />
stopErr</p><br />
<br />
<p>}</p><br />
<br />
<p>s.serveErr &lt;- s.server.Serve(s.listener) 启动成功后会在这里挂住，失败直接返回错误，Wait() 函数提供给a.wait()调用，正常情况也是挂住，等Stop() 里面 closeErr := s.listener.Close() 执行后返回。这块的逻辑要结合 a.wait()、 a.signalHandler()、 a.term() 一起来分析</p><br />
<br />
<p>a.wait() 和 a.term() 的代码</p><br />
<br />
<p>func <br />
(<br />
a <br />
*<br />
app<br />
)<br />
 wait<br />
()</p><br />
<br />
<p>{</p><br />
<br />
<p>var<br />
 wg sync<br />
.<br />
WaitGroup</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wg . Add ( len ( a . sds )<br />
</code></pre></div></div><br />
<br />
<p>*</p><br />
<br />
<p>2<br />
)</p><br />
<br />
<p>// Wait &amp; Stop</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>go a . signalHandler (&amp; wg )<br />
</code></pre></div></div><br />
<br />
<p>for<br />
 _<br />
,<br />
 s <br />
:=<br />
 range a<br />
.<br />
sds <br />
{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    go func ( s httpdown . Server )<br />
</code></pre></div></div><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        defer wg . Done ()<br />
</code></pre></div></div><br />
<br />
<p>if<br />
 err <br />
:=<br />
 s<br />
.<br />
Wait<br />
();<br />
 err <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            a . errors  &lt;-  err<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>}(<br />
s<br />
)</p><br />
<br />
<p>}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wg . Wait ()<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>func <br />
(<br />
a <br />
*<br />
app<br />
)<br />
 term<br />
(<br />
wg <br />
*<br />
sync<br />
.<br />
WaitGroup<br />
)</p><br />
<br />
<p>{</p><br />
<br />
<p>for<br />
 _<br />
,<br />
 s <br />
:=<br />
 range a<br />
.<br />
sds <br />
{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    go func ( s httpdown . Server )<br />
</code></pre></div></div><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        defer wg . Done ()<br />
</code></pre></div></div><br />
<br />
<p>if<br />
 err <br />
:=<br />
 s<br />
.<br />
Stop<br />
();<br />
 err <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            a . errors  &lt;-  err<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>}(<br />
s<br />
)</p><br />
<br />
<p>}</p><br />
<br />
<p>}</p><br />
<br />
<p>a.run() 函数里面会goroutine 执行 a.wait()，它会goroutine执行信号处理 a.signalHandler() 函数，创建一个WaitGroup 等待所有的httpdown.server执行s.Wait()函数返回。a.signalHandler() 函数基本上逻辑就是监听signal.Notify信号，收到SIGTERM信号执行a.term() ，收到SIGUSR2信号执行a.net.StartProcess()。a.term() 函数就是遍历执行所有httpdown.server的s.Stop()，进行优雅关闭，结合上面的代码来看，每一个s.Stop() 会导致s.Wait() 返回，即执行了两次wg.Done()， 所有httpdown.server 优雅关闭后导致a.wait()返回，进而waitdone关闭， 进程最后退出。下面是a.signalHandler()函数的代码</p><br />
<br />
<p>func <br />
(<br />
a <br />
*<br />
app<br />
)<br />
 signalHandler<br />
(<br />
wg <br />
*<br />
sync<br />
.<br />
WaitGroup<br />
)</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ch  :=  make ( chan os . Signal ,<br />
</code></pre></div></div><br />
<br />
<p>10<br />
)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>signal . Notify ( ch ,  syscall . SIGINT ,  syscall . SIGTERM ,  syscall . SIGUSR2 )<br />
</code></pre></div></div><br />
<br />
<p>for</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    sig  :=<br />
</code></pre></div></div><br />
<br />
<p>&lt;-<br />
ch</p><br />
<br />
<p>switch<br />
 sig <br />
{</p><br />
<br />
<p>case<br />
 syscall<br />
.<br />
SIGINT<br />
,<br />
 syscall<br />
.<br />
SIGTERM<br />
:</p><br />
<br />
<p>// this ensures a subsequent INT/TERM will trigger standard go behaviour of</p><br />
<br />
<p>// terminating.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        signal . Stop ( ch )<br />
<br />
        a . term ( wg )<br />
</code></pre></div></div><br />
<br />
<p>return</p><br />
<br />
<p>case<br />
 syscall<br />
.<br />
SIGUSR2<br />
:</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        err  :=  a . preStartProcess ()<br />
</code></pre></div></div><br />
<br />
<p>if<br />
 err <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            a . errors  &lt;-  err<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>// we only return here if there’s an error, otherwise the new process</p><br />
<br />
<p>// will send us a TERM when it’s ready to trigger the actual shutdown.</p><br />
<br />
<p>if<br />
 _<br />
,<br />
 err <br />
:=<br />
 a<br />
.<br />
net<br />
.<br />
StartProcess<br />
();<br />
 err <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            a . errors  &lt;-  err<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>}</p><br />
<br />
<p>}</p><br />
<br />
<p>}</p><br />
<br />
<p>a.net.StartProcess() 函数是启动子进程的逻辑，这里需要详细介绍一下</p><br />
<br />
<p>const</p><br />
<br />
<p>(</p><br />
<br />
<p>// Used to indicate a graceful restart in the new process.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>envCountKey        =<br />
</code></pre></div></div><br />
<br />
<p>“LISTEN_FDS”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>envCountKeyPrefix  =  envCountKey  +<br />
</code></pre></div></div><br />
<br />
<p>”=”</p><br />
<br />
<p>)</p><br />
<br />
<p>type filer <br />
interface</p><br />
<br />
<p>{</p><br />
<br />
<p>File<br />
()</p><br />
<br />
<p>(*<br />
os<br />
.<br />
File<br />
,<br />
 error<br />
)</p><br />
<br />
<p>}</p><br />
<br />
<p>func <br />
(<br />
n <br />
*<br />
Net<br />
)</p><br />
<br />
<p>StartProcess<br />
()</p><br />
<br />
<p>(<br />
int<br />
,<br />
 error<br />
)</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>listeners ,  err  :=  n . activeListeners ()<br />
</code></pre></div></div><br />
<br />
<p>if<br />
 err <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<p>return</p><br />
<br />
<p>0<br />
,<br />
 err</p><br />
<br />
<p>}</p><br />
<br />
<p>// Extract the fds from the listeners.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>files  :=  make ([]* os . File ,  len ( listeners ))<br />
</code></pre></div></div><br />
<br />
<p>for<br />
 i<br />
,<br />
 l <br />
:=<br />
 range listeners <br />
{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    files [ i ],  err  =  l .( filer ). File ()<br />
</code></pre></div></div><br />
<br />
<p>if<br />
 err <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<p>return</p><br />
<br />
<p>0<br />
,<br />
 err</p><br />
<br />
<p>}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    defer files [ i ]. Close ()<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>// Use the original binary location. This works with symlinks such that if</p><br />
<br />
<p>// the file it points to has been changed we will use the updated symlink.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>argv0 ,  err  :=<br />
</code></pre></div></div><br />
<br />
<p>exec<br />
.<br />
LookPath<br />
(<br />
os<br />
.<br />
Args<br />
[<br />
0<br />
])</p><br />
<br />
<p>if<br />
 err <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<p>return</p><br />
<br />
<p>0<br />
,<br />
 err</p><br />
<br />
<p>}</p><br />
<br />
<p>// Pass on the environment and replace the old count key with the new one.</p><br />
<br />
<p>var<br />
 env <br />
[]<br />
string</p><br />
<br />
<p>for<br />
 _<br />
,<br />
 v <br />
:=<br />
 range os<br />
.<br />
Environ<br />
()</p><br />
<br />
<p>{</p><br />
<br />
<p>if</p><br />
<br />
<p>!<br />
strings<br />
.<br />
HasPrefix<br />
(<br />
v<br />
,<br />
 envCountKeyPrefix<br />
)</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        env  =  append ( env ,  v )<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>env  =  append ( env ,  fmt . Sprintf ( "%s%d" ,  envCountKeyPrefix ,  len ( listeners )))<br />
<br />
<br />
<br />
allFiles  :=  append ([]* os . File { os . Stdin ,  os . Stdout ,  os . Stderr },  files ...)<br />
<br />
process ,  err  :=  os . StartProcess ( argv0 ,  os . Args ,<br />
</code></pre></div></div><br />
<br />
<p>&amp;<br />
os<br />
.<br />
ProcAttr<br />
{</p><br />
<br />
<p>Dir<br />
:<br />
   originalWD<br />
,</p><br />
<br />
<p>Env<br />
:<br />
   env<br />
,</p><br />
<br />
<p>Files<br />
:<br />
 allFiles<br />
,</p><br />
<br />
<p>})</p><br />
<br />
<p>if<br />
 err <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<p>return</p><br />
<br />
<p>0<br />
,<br />
 err</p><br />
<br />
<p>}</p><br />
<br />
<p>return<br />
 process<br />
.<br />
Pid<br />
,</p><br />
<br />
<p>nil</p><br />
<br />
<p>}</p><br />
<br />
<p>n.activeListeners()返回 n.active中的net.Listener 数组的副本，files是从中提取出的fd列表。注意allFiles在files前面拼接了3个标准输入输出，记住这个数字。env 中修改了环境变量LISTEN_FDS等于listener的数量。这里的启动子进程的方法是os.StartProcess()，我看了其他的开源库都用syscall.ForkExec</p><br />
<br />
<p>fork<br />
,<br />
 err <br />
:=<br />
 syscall<br />
.<br />
ForkExec<br />
(<br />
os<br />
.<br />
Args<br />
[<br />
0<br />
],<br />
 os<br />
.<br />
Args<br />
,</p><br />
<br />
<p>&amp;<br />
os<br />
.<br />
ProcAttr<br />
{</p><br />
<br />
<p>Dir<br />
:<br />
   originalWD<br />
,</p><br />
<br />
<p>Env<br />
:<br />
   env<br />
,</p><br />
<br />
<p>Files<br />
:<br />
 allFiles<br />
,</p><br />
<br />
<p>})</p><br />
<br />
<p>两种的区别后续还有待研究。还记得前面没有展开的Net中的inherited 和 active么，这里我们细讲一下。</p><br />
<br />
<p>func <br />
(<br />
n <br />
*<br />
Net<br />
)</p><br />
<br />
<p>Listen<br />
(<br />
nett<br />
,<br />
 laddr <br />
string<br />
)</p><br />
<br />
<p>(<br />
net<br />
.<br />
Listener<br />
,<br />
 error<br />
)</p><br />
<br />
<p>{</p><br />
<br />
<p>……</p><br />
<br />
<p>// 仅关注tcp逻辑</p><br />
<br />
<p>return<br />
 n<br />
.<br />
ListenTCP<br />
(<br />
nett<br />
,<br />
 addr<br />
)</p><br />
<br />
<p>}</p><br />
<br />
<p>func <br />
(<br />
n <br />
*<br />
Net<br />
)</p><br />
<br />
<p>ListenTCP<br />
(<br />
nett <br />
string<br />
,<br />
 laddr <br />
*<br />
net<br />
.<br />
TCPAddr<br />
)</p><br />
<br />
<p>(*<br />
net<br />
.<br />
TCPListener<br />
,<br />
 error<br />
)</p><br />
<br />
<p>{</p><br />
<br />
<p>if<br />
 err <br />
:=<br />
 n<br />
.<br />
inherit<br />
();<br />
 err <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<p>return</p><br />
<br />
<p>nil<br />
,<br />
 err</p><br />
<br />
<p>}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n . mutex . Lock ()<br />
<br />
defer n . mutex . Unlock ()<br />
</code></pre></div></div><br />
<br />
<p>// look for an inherited listener</p><br />
<br />
<p>for<br />
 i<br />
,<br />
 l <br />
:=<br />
 range n<br />
.<br />
inherited <br />
{</p><br />
<br />
<p>if<br />
 l <br />
==</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<p>// we nil used inherited listeners</p><br />
<br />
<p>continue</p><br />
<br />
<p>}</p><br />
<br />
<p>if<br />
 isSameAddr<br />
(<br />
l<br />
.<br />
Addr<br />
(),<br />
 laddr<br />
)</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        n . inherited [ i ]<br />
</code></pre></div></div><br />
<br />
<p>=</p><br />
<br />
<p>nil</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        n . active  =  append ( n . active ,  l )<br />
</code></pre></div></div><br />
<br />
<p>return<br />
 l<br />
.(*<br />
net<br />
.<br />
TCPListener<br />
),</p><br />
<br />
<p>nil</p><br />
<br />
<p>}</p><br />
<br />
<p>}</p><br />
<br />
<p>// make a fresh listener</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>l ,  err  :=  net . ListenTCP ( nett ,  laddr )<br />
</code></pre></div></div><br />
<br />
<p>if<br />
 err <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<p>return</p><br />
<br />
<p>nil<br />
,<br />
 err</p><br />
<br />
<p>}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n . active  =  append ( n . active ,  l )<br />
</code></pre></div></div><br />
<br />
<p>return<br />
 l<br />
,</p><br />
<br />
<p>nil</p><br />
<br />
<p>}</p><br />
<br />
<p>func <br />
(<br />
n <br />
*<br />
Net<br />
)<br />
 inherit<br />
()<br />
 error <br />
{</p><br />
<br />
<p>var<br />
 retErr error</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n . inheritOnce . Do ( func ()<br />
</code></pre></div></div><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    n . mutex . Lock ()<br />
<br />
    defer n . mutex . Unlock ()<br />
<br />
    countStr  :=  os . Getenv ( envCountKey )<br />
</code></pre></div></div><br />
<br />
<p>if<br />
 countStr <br />
==</p><br />
<br />
<p>””</p><br />
<br />
<p>{</p><br />
<br />
<p>return</p><br />
<br />
<p>}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    count ,  err  :=  strconv . Atoi ( countStr )<br />
</code></pre></div></div><br />
<br />
<p>// In tests this may be overridden.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    fdStart  :=  n . fdStart<br />
</code></pre></div></div><br />
<br />
<p>if<br />
 fdStart <br />
==</p><br />
<br />
<p>0</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        fdStart  =<br />
</code></pre></div></div><br />
<br />
<p>3</p><br />
<br />
<p>}</p><br />
<br />
<p>for<br />
 i <br />
:=<br />
 fdStart<br />
;<br />
 i <br />
&lt;<br />
 fdStart<br />
+<br />
count<br />
;<br />
 i<br />
++</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        file  :=  os . NewFile ( uintptr ( i ),<br />
</code></pre></div></div><br />
<br />
<p>“listener”<br />
)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        l ,  err  :=  net . FileListener ( file )<br />
</code></pre></div></div><br />
<br />
<p>if<br />
 err <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            file . Close ()<br />
<br />
            retErr  =  fmt . Errorf ( "error inheriting socket fd %d: %s" ,  i ,  err )<br />
</code></pre></div></div><br />
<br />
<p>return</p><br />
<br />
<p>}</p><br />
<br />
<p>if<br />
 err <br />
:=<br />
 file<br />
.<br />
Close<br />
();<br />
 err <br />
!=</p><br />
<br />
<p>nil</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            retErr  =  fmt . Errorf ( "error closing inherited socket fd %d: %s" ,  i ,  err )<br />
</code></pre></div></div><br />
<br />
<p>return</p><br />
<br />
<p>}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        n . inherited  =  append ( n . inherited ,  l )<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>})</p><br />
<br />
<p>return<br />
 retErr</p><br />
<br />
<p>}</p><br />
<br />
<p>这里ListenTCP 先执行inherit() 将继承来的net.Listener 保存在n.inherited里面，启动时判断是否是继承的listener，没有才 make a fresh listener呢，这里的fdStart 初始值设置为3，就是前面提到的那个数字3 （三个标准输入输出占了3位）。</p><br />
<br />
<p>总结起来启动子进程流程如下：</p><br />
<br />
<p>1、提取listener的fd，修改LISTENFDS环境变量为listener的数量，os.StartProcess启动子进程.</p><br />
<br />
<p>files<br />
[<br />
i<br />
],<br />
 err <br />
=<br />
 l<br />
.(<br />
filer<br />
).<br />
File<br />
()</p><br />
<br />
<p>2、子进程启动执行a.net.Listen()时，根据环境变量LISTENFDS和fdStart 变量取出listener</p><br />
<br />
<p>file <br />
:=<br />
 os<br />
.<br />
NewFile<br />
(<br />
uintptr<br />
(<br />
i<br />
),</p><br />
<br />
<p>“listener”<br />
)</p><br />
<br />
<p>l<br />
,<br />
 err <br />
:=<br />
 net<br />
.<br />
FileListener<br />
(<br />
file<br />
)</p><br />
<br />
<p>file<br />
.<br />
Close<br />
()</p><br />
<br />
<p>根据fd创建一个文件，通过文件拿到listener的副本，然后关闭文件。最终a.net.Listen()的逻辑是如果是继承端口就返回一个listener副本，如果不是就启动一个新的listener。3、后续执行a.serve() 挂载server，然后通知父进程优雅关闭等逻辑。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>