<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">golang 和php float 计算结果不一致的坑</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-12-20T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Dec 20, 2019</time></p>
					</div>
					 <p>php &gt; $f=(93.000-20.0000)/(140.0-20.0);<br />
php &gt; php &gt;  var_dump($f<em>300.0,(93.0-20.0)/(140.0-20.0)</em>300.0,$f);<br />
float(182.5)<br />
float(182.5)<br />
float(0.60833333333333)</p><br />
<br />
<p>package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br />
	f := (93.0 - 20.0) / (140.0 - 20.0)<br />
	fmt.Println(f,f<em>300.0, (93.0-20.0)/(140.0-20.0)</em>300.0)<br />
}</p><br />
<br />
<p>0.6083333333333333 182.49999999999997 182.5<br />
问题来了第二个结果不一样<br />
会导致<br />
func round(x float64){<br />
    return int(math.Floor(x + 0/5))<br />
}<br />
计算的结果和php round（）函数不一致<br />
<!-- more --><br />
package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br />
    p := (float32(93) - float32(20)) / (float32(140) - float32(20))<br />
    fmt.Println((float64(93)-float64(20))/(float64(140)-float64(20))<em>float64(300), (float32(93)-float32(20))/(float32(140)-float32(20))</em>float32(300), p*float32(300))<br />
}</p><br />
<br />
<p>182.49999999999997 182.5 182.5<br />
可以发现，使用float32 两者结果一样了，回过头来看，php的float是float32，double 是float64</p><br />
<br />
<p>1 浮点数为什么不精确<br />
先看两个case</p><br />
<br />
<p>// case1: 135.90<em>100 ====<br />
// float32<br />
var f1 float32 = 135.90<br />
fmt.Println(f1 * 100) // output:13589.999<br />
// float64<br />
var f2 float64 = 135.90<br />
fmt.Println(f2 * 100) // output:13590<br />
浮点数在单精度下, 135.9</em>100即出现了偏差, 双精度下结果正确.</p><br />
<br />
<p>// case2: 0.1 add 10 times ===<br />
// float32<br />
var f3 float32 = 0<br />
for i := 0; i &lt; 10; i++ {<br />
    f3 += 0.1<br />
}<br />
fmt.Println(f3) //output:1.0000001</p><br />
<br />
<p>// float64<br />
var f4 float64 = 0<br />
for i := 0; i &lt; 10; i++ {<br />
    f4 += 0.1<br />
}<br />
fmt.Println(f4) //output:0.9999999999999999<br />
0.1加10次, 这下无论是float32和float64都出现了偏差.</p><br />
<br />
<p>为什么呢, Go和大多数语言一样, 使用标准的IEEE754表示浮点数, 0.1使用二进制表示结果是一个无限循环数, 只能舍入后表示, 累加10次之后就会出现偏差.</p><br />
<br />
<p>此外, 还有几个隐藏的坑https://play.golang.org/p/bQPbirROmN</p><br />
<br />
<p>float32和float64直接互转会精度丢失, 四舍五入后错误.<br />
int64转float64在数值很大的时候出现偏差.<br />
合理但须注意: 两位小数乘100强转int, 比期望值少了1.<br />
package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
)</p><br />
<br />
<p>func main() {<br />
    // case: float32==&gt;float64<br />
    // 从数据库中取出80.45, 历史代码用float32接收<br />
    var a float32 = 80.45<br />
    var b float64<br />
    // 有些函数只能接收float64, 只能强转<br />
    b = float64(a)<br />
    // 打印出值, 强转后出现偏差<br />
    fmt.Println(a) //output:80.45<br />
    fmt.Println(b) //output:80.44999694824219<br />
    // … 四舍五入保留小数点后1位, 期望80.5, 结果是80.4</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// case: int64==&gt;float64<br />
var c int64 = 987654321098765432<br />
fmt.Printf("%.f\n", float64(c)) //output:987654321098765440<br />
<br />
// case: int(float64(xx.xx*100))<br />
var d float64 = 1129.6<br />
var e int64 = int64(d * 100)<br />
fmt.Println(e) //output:112959 } ##2 数据库是怎么做的 MySQL提供了decimal(p,d)/numberlic(p,d)类型的定点数表示法, 由p位数字(不包括符号、小数点)组成, 小数点后面有d位数字, 占p+2个字节, 计算性能会比double/float类型弱一些.<br />
</code></pre></div></div><br />
<br />
<p>##3 Go代码如何实现Decimal<br />
Java有成熟的标准库java.lang.BigDecimal,Python有标准库Decimal, 可惜GO没有. 在GitHub搜decimal, star数量比较多的是TiDB里的MyDecimal和ithub.com/shopspring/decimal的实现.</p><br />
<br />
<p>shopspring的Decimal实现比较简单, 思路是使用十进制定点数表示法, 有多少位小数就小数点后移多少位, value保存移之后的整数, exp保存小数点后的数位个数, number=value*10^exp, 因为移小数点后的整数可能很大, 所以这里借用标准包里的math/big表示这个大整数. exp使用了int32, 所以这个包最多能表示小数点后有32个十进制数位的情况.</p><br />
<br />
<p>Decimal结构体的定义如下</p><br />
<br />
<p>// Decimal represents a fixed-point decimal. It is immutable.<br />
// number = value * 10 ^ exp<br />
type Decimal struct {<br />
    value *big.Int</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// NOTE(vadim): this must be an int32, because we cast it to float64 during<br />
// calculations. If exp is 64 bit, we might lose precision.<br />
// If we cared about being able to represent every possible decimal, we<br />
// could make exp a *big.Int but it would hurt performance and numbers<br />
// like that are unrealistic.<br />
exp int32 } TiDB里的MyDecimal定义位于github.com/pingcap/tidb/util/types/mydecimal.go, 实现比shopspring的Decimal复杂多了, 也更底层(不依赖math/big), 性能也更好(见下面的benchmark). 其思路是: digitsInt保存数字的整数部分数字个数, digitsFrac保存数字的小数部分数字个数, resultFrac保存计算及序列化时保留至小数点后几位, negative标明数字是否为负数, wordBuf是一个定长的int32数组(长度为9), 数字去掉小数点的主体保存在这里, 一个int32有32个bit, 最大值为(2**31-1)2147483647(10个十进制数), 所以一个int32最多能表示9个十进制数位, 因此wordBuf 最多能容纳9*9个十进制数位.<br />
</code></pre></div></div><br />
<br />
<p>// MyDecimal represents a decimal value.<br />
type MyDecimal struct {<br />
    digitsInt int8 // the number of <em>decimal</em> digits before the point.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>digitsFrac int8 // the number of decimal digits after the point.<br />
<br />
resultFrac int8 // result fraction digits.<br />
<br />
negative bool<br />
<br />
//  wordBuf is an array of int32 words.<br />
// A word is an int32 value can hold 9 digits.(0 &lt;= word &lt; wordBase)<br />
wordBuf [maxWordBufLen]int32 } 看看这两种decimal类型在文首的两个case下的结果, 同时跑个分.<br />
</code></pre></div></div><br />
<br />
<p>main_test.go</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “testing”<br />
    “github.com/shopspring/decimal”<br />
    “github.com/pingcap/tidb/util/types”<br />
    “log”<br />
)</p><br />
<br />
<p>var case1String = “135.90”<br />
var case1Bytes = []byte(case1String)<br />
var case2String = “0”<br />
var case2Bytes = []byte(“0”)</p><br />
<br />
<p>func ShopspringDecimalCase1() decimal.Decimal {<br />
    dec1, err := decimal.NewFromString(case1String)<br />
    if err != nil {<br />
        log.Fatal(err)<br />
    }<br />
    dec2 := decimal.NewFromFloat(100)<br />
    dec3 := dec1.Mul(dec2)<br />
    return dec3<br />
}</p><br />
<br />
<p>func TidbDecimalCase1() *types.MyDecimal {<br />
    dec1 := new(types.MyDecimal)<br />
    err := dec1.FromString(case1Bytes)<br />
    if err != nil {<br />
        log.Fatal(err)<br />
    }<br />
    dec2 := new(types.MyDecimal).FromInt(100)<br />
    dec3 := new(types.MyDecimal)<br />
    err = types.DecimalMul(dec1, dec2, dec3)<br />
    if err != nil {<br />
        log.Fatal(err)<br />
    }<br />
    return dec3<br />
}</p><br />
<br />
<p>func ShopspringDecimalCase2() decimal.Decimal {<br />
    dec1, err := decimal.NewFromString(case2String)<br />
    if err != nil {<br />
        log.Fatal(err)<br />
    }<br />
    dec2 := decimal.NewFromFloat(0.1)<br />
    for i := 0; i &lt; 10; i++ {<br />
        dec1 = dec1.Add(dec2)<br />
    }<br />
    return dec1<br />
}</p><br />
<br />
<p>func TidbDecimalCase2() *types.MyDecimal {<br />
    dec1 := new(types.MyDecimal)<br />
    dec1.FromString(case2Bytes)<br />
    dec2 := new(types.MyDecimal)<br />
    dec2.FromFloat64(0.1)<br />
    for i := 0; i &lt; 10; i++ {<br />
        types.DecimalAdd(dec1, dec2, dec1)<br />
    }<br />
    return dec1</p><br />
<br />
<p>}</p><br />
<br />
<p>// case1: 135.90*100 ====<br />
func BenchmarkShopspringDecimalCase1(b *testing.B) {<br />
    for i := 0; i &lt; b.N; i++ {<br />
        ShopspringDecimalCase1()<br />
    }<br />
    b.Log(ShopspringDecimalCase1()) // output: 13590<br />
}</p><br />
<br />
<p>func BenchmarkTidbDecimalCase1(b *testing.B) {<br />
    for i := 0; i &lt; b.N; i++ {<br />
        TidbDecimalCase1()<br />
    }<br />
    b.Log(TidbDecimalCase1()) //  output: 13590.00<br />
}</p><br />
<br />
<p>// case2: 0.1 add 10 times ===<br />
func BenchmarkShopspringDecimalCase2(b *testing.B) {<br />
    for i := 0; i &lt; b.N; i++ {<br />
        ShopspringDecimalCase2()<br />
    }<br />
    b.Log(ShopspringDecimalCase2()) //  output: 1<br />
}</p><br />
<br />
<p>func BenchmarkTidbDecimalCase2(b *testing.B) {<br />
    for i := 0; i &lt; b.N; i++ {<br />
        TidbDecimalCase2()<br />
    }<br />
    b.Log(TidbDecimalCase2()) //  output: 1.0<br />
}<br />
BenchmarkShopspringDecimalCase1-8        2000000               664 ns/op             340 B/op         10 allocs/op</p><br />
<br />
<p>BenchmarkTidbDecimalCase1-8             20000000                99.2 ns/op            48 B/op          1 allocs/op</p><br />
<br />
<p>BenchmarkShopspringDecimalCase2-8         300000              5210 ns/op            4294 B/op        111 allocs/op</p><br />
<br />
<p>BenchmarkTidbDecimalCase2-8              3000000               517 ns/op              83 B/op          3 allocs/op<br />
可见两种实现在上面两个case下表示准确, TiDB的decimal实现的性能高于shopspring的实现, 堆内存分配次数也更少.</p><br />
<br />
<p>##4. MyDecimal的已知问题</p><br />
<br />
<p>用了一段时间后, tidb.MyDecimal也有一些问题</p><br />
<br />
<p>原版除法有bug, 可以通过除数和被除数同时放大一定倍数临时修复, 更好的解决方法需要官方人员解决, 已提issue, 这个bug真是匪夷所思. https://github.com/pingcap/tidb/issues/4873, 2017.11.3官方修复decimal除法问题:https://github.com/pingcap/tidb/pull/4995/files.<br />
原版乘法有小问题, 行为不一致, 原版的from1和to不能为同一个指针, 但 Add Sub Div却可以. 可以通过copy参数修复.<br />
移位小坑, 右移属于扩大数值, 没有问题. 左移有问题, 注意1左移两位不会变成0.01, 所以shift不要传负数.<br />
round, 目前这个库的Round模式ModeHalfEven实际上是ModeHalfUp, 正常的四舍五入, 不是float的ModeHalfEven. 3.5=&gt;4, 4.5=&gt;5, 5.5=&gt;6, 注意后期是否有变更.</p><br />
<br />
<p>php在使用加减乘除等运算符计算浮点数的时候，经常会出现意想不到的结果，特别是关于财务数据方面的计算，给不少工程师惹了很多的麻烦。比如今天工作终于到的一个案例：</p><br />
<br />
<p>$a = 2586;<br />
$b = 2585.98;<br />
var_dump($a-$b);<br />
期望的结果是：float(0.02)<br />
实际结果：</p><br />
<br />
<p>float(0.019999999999982)</p><br />
<br />
<p>二、防坑攻略：<br />
1、通过乘100的方式转化为整数加减，然后在除以100转化回来……<br />
2、使用number_format转化成字符串，然后在使用（float）强转回来……<br />
3、php提供了高精度计算的函数库，实际上就是为了解决这个浮点数计算问题而生的。</p><br />
<br />
<p>三、为啥有坑：<br />
php的bug?不是，这是所有语言基本上都会遇到的问题，所以基本上大部分语言都提供了精准计算的类库或函数库。</p><br />
<br />
<p>要搞明白这个原因, 首先我们要知道浮点数的表示(IEEE 754):</p><br />
<br />
<p>浮点数, 以64位的长度(双精度)为例, 会采用1位符号位(E), 11指数位(Q), 52位尾数(M)表示(一共64位).</p><br />
<br />
<p>符号位：最高位表示数据的正负，0表示正数，1表示负数。<br />
指数位：表示数据以2为底的幂，指数采用偏移码表示<br />
尾数：表示数据小数点后的有效数字.</p><br />
<br />
<p>这里的关键点就在于, 小数在二进制的表示, 小数如何转化为二进制呢？</p><br />
<br />
<p>算法是乘以2直到没有了小数为止。</p><br />
<br />
<p>0.9二进制表示为(从上往下): 1100100100100……</p><br />
<br />
<p>注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了”减不尽”的精度丢失问题。</p><br />
<br />
<p>换句话说：我们看到十进制小数，在计算机内存储的不是一个精确的数字，也不可能精确。所以在数字加减乘除后出现意想不到的结果。</p><br />
<br />
<p>所以要比较两个浮点数，需要将其控制在我们需要的精度范围内再行比较，因此使用 bcadd() 函数来对浮点数想加并进行精度转换（为字符串）：</p><br />
<br />
<p>var_dump(bcadd(0.2,0.7,1) == 0.9);	// 输出：bool(true)</p><br />
<br />
<p>浮点数的存储精度跟系统有关，PHP 通常使用 IEEE 754 双精度格式，默认是20位有效精度。Floating point numbers</p><br />
<br />
<p>&lt;?php<br />
echo (int) ( (0.1+0.7) * 10 ); // 显示 7!</p><br />
<br />
<p>http://blog.100dos.com/2016/08/23/deep-understanding-of-float-type-in-PHP/</p><br />
<br />
<p>浮点数转换为整型<br />
从浮点数转换成整数时，将向下取整。</p><br />
<br />
<p>向上取整：不管四舍五入的规则 只要后面有小数前面的整数就加1<br />
向下取整：不管四舍五入的规则 只要后面有小数忽略小数</p><br />
<br />
<p>弱类型语言变量的实现</p><br />
<br />
<p>/* zend.h  <em>/<br />
struct _zval_struct {<br />
    zvalue_value value;  /</em> 值 <em>/<br />
    zend_uint refcount__gc;<br />
    zend_uchar type; /</em> 活动类型 */<br />
    zend_uchar is_ref__gc;  <br /><br />
}<br />
PHP中的一个变量，zend虚拟机中，使用的是 _zval_struct 的结构体来描述，变量的值也是一个就结构体来描述.</p><br />
<br />
<p>_zval_struct的结构体是由 四个字段/域 (可以理解成关联数组)</p><br />
<br />
<p>zvalue_value value; /* 值 */</p><br />
<br />
<p>PHP变量的值，存储这个字段中。</p><br />
<br />
<p>具体存储的位置：</p><br />
<br />
<p>/* value 值 是一个 联合 <em>/<br />
/</em> zend.h <em>/<br />
typedef union _zval_value {<br />
    long lval; /</em> long value <em>/<br />
    double dval; /</em> double value <em>/<br />
    struct {<br />
        char * val;<br />
        int len;<br />
    } str;<br />
    HashTable *ht; /</em> hash table 指针 */<br />
    zend_object_value obj;<br />
} zvalue_value;<br />
Zend对变量的表示</p><br />
<br />
<p>zend实现了 zval结构体</p><br />
<br />
<p>{<br />
    value: [联合体] /* 联合体的内容可能是C语言中的long,double,hashtable(<em>ht),obj, 联合体只能是其中一种类型，是一个枚举 */<br />
    type: 变量类型 , /</em> IS_NULL,IS_BOOL,IS_STRING, IS_LONG,IS_DOUBLE,IS_ARRAY,IS_OBJECT,IS_RESOURCE */<br />
    refcount_gc<br />
    is_ref_gc <br />
}<br />
C语言中类型对应PHP中的数据类型：</p><br />
<br />
<p>long -&gt; int<br />
double -&gt; double<br />
hashtable -&gt; array<br />
struct -&gt; string<br />
obj -&gt; object<br />
例如：</p><br />
<br />
<p>$a = 3;<br />
{<br />
    value: [long lval = 3]<br />
    type: IS_LONG<br />
}</p><br />
<br />
<p>$a = 3.5;<br />
{<br />
    value: [double dval = 3.5]<br />
    type: IS_DOUBLE<br />
}<br />
变量类型的实现<br />
zend_uchar type; /* 活动类型 */</p><br />
<br />
<p>可以根据上下文环境来强制转换。<br />
例如：需要echo 的时候 就转换成 string<br />
需要加减运算就 转换成 int</p><br />
<br />
<p>PHP 中有8中数据类型，为什么zval-&gt;value 联合体中，只有5中 ?<br />
1: NULL，直接 zval-&gt;type = IS_NULL, 就可以表示，不必设置 value 的值。<br />
2：BOOL， zval-&gt;type = IS_BOOL. 再设置 zval.value.lval = 1/0; (C语言中没有布尔值，都是通过1，0，来表示)<br />
3: resource ，资源型，往往是服务器上打开一个接口，如果 文件读取接口。 zval-&gt;type = IS_RESOURCE, zval-&gt;type.lval = 服务器上打开的接口编号。</p><br />
<br />
<p>struct {<br />
    char * val;<br />
    int len;<br />
} str;<br />
PHP中，字符串类型，长度是已经缓存的，调用strlen时，系统可以直接返回其长度，不需要计算。</p><br />
<br />
<p>$b = ‘hello’;</p><br />
<br />
<p>/**</p><br />
<ul><br />
  <li></li><br />
  <li>{</li><br />
  <li>union_zvalue {</li><br />
  <li>// 字符串的指针</li><br />
  <li>struct{</li><br />
  <li>char: ‘hello’;</li><br />
  <li>len: 5</li><br />
  <li>} str;</li><br />
  <li>}</li><br />
  <li>type: IS_STRING;</li><br />
  <li>refcount_gc: 1,</li><br />
  <li>is_ref_gc: 0</li><br />
  <li>}</li><br />
  <li>*/</li><br />
</ul><br />
<br />
<p>//在PHP中字符串的长度，是直接体现在其结构体中,所以调用strlen(); 速度非常快，时间复杂度为0(1)</p><br />
<br />
<p>echo strlen($b);</p><br />
<br />
<p>符号表<br />
符号表symbol_table，变量的花名册</p><br />
<br />
<p>符号表是什么?</p><br />
<br />
<p>符号表示一张哈希表(哈希结构理解成关联数组)<br />
里面存储了变量名-&gt; 变量zval结构体的地址</p><br />
<br />
<p>struct _zend_executor_globals {<br />
    …<br />
    …<br />
    HashTable * active_symbol_table /* 活动符号表 <em>/<br />
    HashTable symbol_table /</em> 全局符号表 <em>/<br />
    HashTable included_files; /</em> files already included */<br />
}<br />
// 变量花名册<br />
$a = 3;<br />
$b = 1.223;<br />
$c = ‘hello’;</p><br />
<br />
<p>/**</p><br />
<ul><br />
  <li></li><br />
  <li>生成了3个结构体</li><br />
  <li>同时，全局符号表，中多了三条记录</li><br />
  <li></li><br />
  <li>a —&gt; 0x123 —&gt; 结构体 { 3 }</li><br />
  <li>b —&gt; 0x21a —&gt; 结构体 { 1.223 }</li><br />
  <li>c —&gt; 0x1A0 —&gt; 结构体 { hello }<br />
 *<br />
 */</li><br />
</ul><br />
<br />
<p>// 变量声明 <br />
 // 第一：结构体生成<br />
 // 第二：符号表中多了记录，变量的花名册<br />
 // 第三：指向结构体 <br />
传值赋值<br />
传值赋值发生了什么</p><br />
<br />
<p>在传值赋值时：<br />
以：b = $a;为例：<br />
并没有再次产生结构体，而是2个变量共用1个结构体<br />
此时，2个变量，指向同1个结构体<br />
refcount_gc 值为 2 (如果没有指针指引，会有垃圾回收机制清除)</p><br />
<br />
<p>写时复制<br />
cow写时复制特性</p><br />
<br />
<p>$a = 3;<br />
$b = $a;</p><br />
<br />
<p>/**</p><br />
<ul><br />
  <li></li><br />
  <li>是否产生了2 个结构体?</li><br />
  <li>不是，共用1个， refcount_gc = 2;</li><br />
  <li>*/</li><br />
</ul><br />
<br />
<p>$b = 5;</p><br />
<br />
<p>echo $a, $b; // 3, 5<br />
// $a,$b 指向同一个结构体，那么，修改$b或$a，对方会不会受干扰 ? 没有干扰到对方。具有写时复制的特性 <br />
如果有一方修改，将会造成结构体的分裂</p><br />
<br />
<p>结构体一开始共用，到某一方要修改值时，才分裂。这种特性称为：COW 。Copy On Write。</p><br />
<br />
<p>引用赋值<br />
引用赋值发生了什么</p><br />
<br />
<p>当引用赋值时，双方共用一个结构体(is_ref_gc=1)<br />
强制分裂<br />
&lt;?php</p><br />
<br />
<p>// 强制分裂</p><br />
<br />
<p>$a = 3;<br />
/**</p><br />
<ul><br />
  <li>{</li><br />
  <li>value: 3;</li><br />
  <li>type: IS_LONG;</li><br />
  <li>refcount_gc: 1;</li><br />
  <li>is_ref_gc: 0;</li><br />
  <li>}<br />
 */<br />
$b = $a;<br />
/**</li><br />
  <li>{</li><br />
  <li>value: 3;</li><br />
  <li>type: IS_LONG;</li><br />
  <li>refcount_gc: 2;</li><br />
  <li>is_ref_gc: 0;</li><br />
  <li>}<br />
 */<br />
$c = &amp;$a;<br />
// 不会按照 底下结构体变化<br />
/**</li><br />
  <li>{</li><br />
  <li>value: 3;</li><br />
  <li>type: IS_LONG;</li><br />
  <li>refcount_gc: 3;</li><br />
  <li>is_ref_gc: 1;</li><br />
  <li>} <br />
 */</li><br />
</ul><br />
<br />
<p>// 正确的结构体变化<br />
// 如果is_ref_gc  0-&gt;1 的过程中(从0到1,表示想引用变量)。refcount_gc&gt;1。多个变量共享一个变量值。将会产生强制分裂<br />
/**</p><br />
<ul><br />
  <li>// $a $c 结构体</li><br />
  <li>{</li><br />
  <li>value: 3;</li><br />
  <li>type: IS_LONG;</li><br />
  <li>refcount_gc: 2;</li><br />
  <li>is_ref_gc: 1;</li><br />
  <li>}</li><br />
  <li></li><br />
  <li>// $b 结构体</li><br />
  <li>{</li><br />
  <li>value: 3;</li><br />
  <li>type: IS_LONG;</li><br />
  <li>refcount_gc: 1;</li><br />
  <li>is_ref_gc: 0;</li><br />
  <li>}</li><br />
  <li>*/</li><br />
</ul><br />
<br />
<p>$c = 5;<br />
// a c<br />
/**</p><br />
<ul><br />
  <li>value: 5</li><br />
  <li>type: IS_LONG;</li><br />
  <li>refcount_gc: 2;</li><br />
  <li>is_ref_gc: 1;<br />
 */</li><br />
</ul><br />
<br />
<p>// b<br />
/**</p><br />
<ul><br />
  <li>value: 3</li><br />
  <li>type: IS_LONG;</li><br />
  <li>refcount_gc: 1;</li><br />
  <li>is_ref_gc: 0;<br />
 */</li><br />
</ul><br />
<br />
<p>echo $a, $b, $c; // 5 , 3 , 5</p><br />
<br />
<p>引用数组时的一些奇怪现象</p><br />
<br />
<p>// 引用数组时的怪现象</p><br />
<br />
<p>$arr = array(0, 1, 2, 3);</p><br />
<br />
<p>$tmp = $arr;</p><br />
<br />
<p>$arr[1] = 11;</p><br />
<br />
<p>echo $tmp[1]; // 1</p><br />
<br />
<p>// 数组不会比较细致的检查，多维数组存在。 因此，判断的时候，只会判断外面 一层的 结构体。</p><br />
<br />
<p>数组不会比较细致的检查</p><br />
<br />
<p>// 先 引用 后 赋值<br />
$arr = array(0, 1, 2, 3);</p><br />
<br />
<p>$x = &amp;$arr[1];</p><br />
<br />
<p>$tmp = $arr;</p><br />
<br />
<p>$arr[1] = 999;</p><br />
<br />
<p>echo $tmp[1]; // 999 . hash表中的zvalue结构体中会变成引用类型。  // 只去关注外面一层结构体，而不去关注 hash表中的值。</p><br />
<br />
<p>echo ‘<br />’;</p><br />
<br />
<p>// 先赋值，后引用<br />
$arr = array(0, 1, 2, 3);</p><br />
<br />
<p>$tmp = $arr;</p><br />
<br />
<p>$x = &amp;$arr[1];</p><br />
<br />
<p>$arr[1] = 999;</p><br />
<br />
<p>echo $tmp[1]; // 1   <br /><br />
循环数组<br />
循环数组时的怪现象</p><br />
<br />
<p>// 循环数组时的怪现象<br />
$arr = array(0, 1, 2, 3);</p><br />
<br />
<p>foreach ( $arr as $v ) {</p><br />
<br />
<p>}</p><br />
<br />
<p>var_dump(current($arr));  // 数组指针停留在数组结尾处， 取不到值. false</p><br />
<br />
<p>echo ‘<br />’;</p><br />
<br />
<p>$arr = array(0, 1, 2, 3);</p><br />
<br />
<p>foreach ( $arr as $val=&gt;$key ) { // foreach 使用的 $arr 是   $arr的副本.<br />
    $arr[$key] = $val;  // 修改之后，就会产生分裂。 foreach 遍历的是 $arr 的副本。 但是原数组的指针已经走了一步. <br />
}</p><br />
<br />
<p>var_dump(current($arr)); // 1</p><br />
<br />
<p>$arr = array(‘a’, ‘b’, ‘c’, ‘d’);</p><br />
<br />
<p>foreach ( $arr as &amp;$val ) {  // 该foreach 会导致 $val = &amp;$arr[3];</p><br />
<br />
<p>}</p><br />
<br />
<p>foreach ( $arr as $val ) {<br />
    print_r($arr);<br />
    echo ‘<br />’;<br />
}<br />
// 两个问题： <br />
// 数组使用时，要慎用引用。<br />
// foreach 使用后，不会把数组的内部指针重置, 使用数组时，不要假想内部指针指向数组头部. 也可以在foreach 之后 reset(); 指针。<br />
符号表与作用域<br />
当执行到函数时，会生成函数的“执行环境结构体”，包含函数名，参数，执行步骤，所在的类（如果是方法），以及为这个函数生成一个符号表。<br />
符号表统一放在栈上，并把active_symbol_table指向刚产生的符号表。</p><br />
<br />
<p>// Zend/zend_compiles.h 文件中</p><br />
<br />
<p>// 源码：<br />
struct _zend_execute_data {<br />
    struct _zend_op <em>opline;<br />
    zend_function_state function_state;<br />
    zend_op_array *op_array;<br />
    zval *object;<br />
    HashTable *symbol_table;<br />
    struct _zend_execute_data *prev_execute_data;<br />
    zval *old_error_reporting;<br />
    zend_bool nested;<br />
    zval **original_return_value;<br />
    zend_class_entry *current_scope;<br />
    zend_class_entry *current_called_scope;<br />
    zval *current_this;<br />
    struct _zend_op *fast_ret; /</em> used by FAST_CALL/FAST_RET (finally keyword) */<br />
    zval *delayed_exception;<br />
    call_slot *call_slots;<br />
    call_slot *call;<br />
};<br />
// 简化：</p><br />
<br />
<p>struct _zend_execute_data {<br />
    …<br />
    zend_op_array *op_array;     // 函数的执行步骤. 如果是函数调用。是函数调用的后的opcode<br />
    HashTable *symbol_table; // 此函数的符号表地址<br />
    zend_class_entry *current_scope; // 执行当前作用域<br />
    zval * current_this;  // 对象 调用 this绑定 <br />
    zval * current_object;  // object 的指向<br />
    …<br />
}</p><br />
<br />
<p>一个函数调用多次，会有多少个<em>op_array ?<br />
一个函数产生 一个</em>op_array. 调用多次，会产生多个 环境结构体， 会依次入栈，然后顺序执行。<br />
调用多少次，就会入栈多少次。不同的执行环境，靠 唯一的 *op_array 来执行。</p><br />
<br />
<p>函数什么时候调用， 函数编译后的 opcode 什么时候执行。</p><br />
<br />
<p>$age = 23;</p><br />
<br />
<p>function t() {<br />
    $age = 3;<br />
    echo $age;<br />
}</p><br />
<br />
<p>t();</p><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>t 函数 在执行时，根据函数的参数，局部变量等，生成一个执行环境结构体。</li><br />
  <li>结构体 入栈，函数编译后的 opcode， 称为 op_array （就是执行逻辑）。开始执行， 以入栈的环境结构体为环境来执行。</li><br />
  <li>并生成此函数的 符号表， 函数寻找变量， 就在符号表中寻找。即局部变量。(一个环境结构体，就对应一张符号表)</li><br />
  <li></li><br />
  <li></li><br />
  <li>注意： 函数可能调用多次。栈中可能有某函数的多个执行环境 入栈。但是 op_array 只有一个。</li><br />
  <li>*/<br />
静态变量<br />
静态变量的实现</li><br />
</ul><br />
<br />
<p>// Zend/zend_compile.h<br /><br />
struct _zend_op_array {<br />
    /* Common elements <em>/<br />
    zend_uchar type;<br />
    const char *function_name;<br />
    zend_class_entry *scope;<br />
    zend_uint fn_flags;<br />
    union _zend_function *prototype;<br />
    zend_uint num_args;<br />
    zend_uint required_num_args;<br />
    zend_arg_info *arg_info;<br />
    /</em> END of common elements */</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zend_uint *refcount;<br />
<br />
zend_op *opcodes;<br />
zend_uint last;<br />
<br />
zend_compiled_variable *vars;<br />
int last_var;<br />
<br />
zend_uint T;<br />
<br />
zend_uint nested_calls;<br />
zend_uint used_stack;<br />
<br />
zend_brk_cont_element *brk_cont_array;<br />
int last_brk_cont;<br />
<br />
zend_try_catch_element *try_catch_array;<br />
int last_try_catch;<br />
zend_bool has_finally_block;<br />
<br />
/* static variables support */<br />
HashTable *static_variables;<br />
<br />
zend_uint this_var;<br />
<br />
const char *filename;<br />
zend_uint line_start;<br />
zend_uint line_end;<br />
const char *doc_comment;<br />
zend_uint doc_comment_len;<br />
zend_uint early_binding; /* the linked list of delayed declarations */<br />
<br />
zend_literal *literals;<br />
int last_literal;<br />
<br />
void **run_time_cache;<br />
int  last_cache_slot;<br />
<br />
void *reserved[ZEND_MAX_RESERVED_RESOURCES]; }; // 简化 struct _zend_op_array {<br />
... <br />
HashTable *static_variables;    // 静态变量<br />
... } 编译后的 op_array 只有一份。 静态变量并没有存储在符号表(symbol_table)中.而是存放在op_array中。<br />
</code></pre></div></div><br />
<br />
<p>function t() {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static $age = 1;<br />
<br />
return $age += 1;<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>echo t();<br />
echo t();<br />
echo t();</p><br />
<br />
<p>// 静态变量 不再和 执行的结构体， 也不再和 入栈的符号表有关。</p><br />
<br />
<p>常量</p><br />
<br />
<p>// Zend/zend_constants.h<br />
// 常量结构体 <br />
typedef struct _zend_constant {<br />
    zval value; // 变量结构体<br />
    int flags; // 标志，是否大小写敏感等<br />
    char *name; // 常量名<br />
    uint name_len; // <br />
    int module_number; // 模块名<br />
} zend_constant;<br />
define函数的实现<br />
define函数当然是 调用zend_register_constant声明的常量<br />
具体如下：Zend/zend_builtin_functions.c</p><br />
<br />
<p>// 源码：</p><br />
<br />
<p>ZEND_FUNCTION(define)<br />
{<br />
    char *name;<br />
    int name_len;<br />
    zval *val;<br />
    zval *val_free = NULL;<br />
    zend_bool non_cs = 0;<br />
    int case_sensitive = CONST_CS;<br />
    zend_constant c;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "sz|b", &amp;name, &amp;name_len, &amp;val, &amp;non_cs) == FAILURE) {<br />
    return;<br />
}<br />
<br />
if(non_cs) {<br />
    case_sensitive = 0;<br />
}<br />
<br />
/* class constant, check if there is name and make sure class is valid &amp; exists */<br />
if (zend_memnstr(name, "::", sizeof("::") - 1, name + name_len)) {<br />
    zend_error(E_WARNING, "Class constants cannot be defined or redefined");<br />
    RETURN_FALSE;<br />
}<br />
</code></pre></div></div><br />
<br />
<p>repeat:<br />
    switch (Z_TYPE_P(val)) {<br />
        case IS_LONG:<br />
        case IS_DOUBLE:<br />
        case IS_STRING:<br />
        case IS_BOOL:<br />
        case IS_RESOURCE:<br />
        case IS_NULL:<br />
            break;<br />
        case IS_OBJECT:<br />
            if (!val_free) {<br />
                if (Z_OBJ_HT_P(val)-&gt;get) {<br />
                    val_free = val = Z_OBJ_HT_P(val)-&gt;get(val TSRMLS_CC);<br />
                    goto repeat;<br />
                } else if (Z_OBJ_HT_P(val)-&gt;cast_object) {<br />
                    ALLOC_INIT_ZVAL(val_free);<br />
                    if (Z_OBJ_HT_P(val)-&gt;cast_object(val, val_free, IS_STRING TSRMLS_CC) == SUCCESS) {<br />
                        val = val_free;<br />
                        break;<br />
                    }<br />
                }<br />
            }<br />
            /* no break */<br />
        default:<br />
            zend_error(E_WARNING,”Constants may only evaluate to scalar values”);<br />
            if (val_free) {<br />
                zval_ptr_dtor(&amp;val_free);<br />
            }<br />
            RETURN_FALSE;<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c.value = *val;<br />
zval_copy_ctor(&amp;c.value);<br />
if (val_free) {<br />
    zval_ptr_dtor(&amp;val_free);<br />
}<br />
c.flags = case_sensitive; /* non persistent */<br />
c.name = str_strndup(name, name_len);<br />
if(c.name == NULL) {<br />
    RETURN_FALSE;<br />
}<br />
c.name_len = name_len+1;<br />
c.module_number = PHP_USER_CONSTANT;<br />
if (zend_register_constant(&amp;c TSRMLS_CC) == SUCCESS) {<br />
    RETURN_TRUE;<br />
} else {<br />
    RETURN_FALSE;<br />
} } // 关键代码：<br />
</code></pre></div></div><br />
<br />
<p>c.value = <em>val;<br />
zval_copy_ctor(&amp;c.value);<br />
if (val_free) {<br />
    zval_ptr_dtor(&amp;val_free);<br />
}<br />
c.flags = case_sensitive; /</em> 大小写敏感 <em>/<br />
c.name = str_strndup(name, name_len);<br />
if(c.name == NULL) {<br />
    RETURN_FALSE;<br />
}<br />
c.name_len = name_len+1;<br />
c.module_number = PHP_USER_CONSTANT; /</em> 用户定义常量 */<br />
if (zend_register_constant(&amp;c TSRMLS_CC) == SUCCESS) {<br />
    RETURN_TRUE;<br />
} else {<br />
    RETURN_FALSE;<br />
}<br />
常量就一个符号(哈希)表. 都使用一个符号表。所以全局有效。</p><br />
<br />
<p>常量的生成</p><br />
<br />
<p>int zend_register_constant(zend_constant <em>c TSRMLS_DC) {<br />
    …<br />
    …<br />
    zend_hash_add(EG(zend_constants), name, c-&gt;name_len, (vaid</em>)c,sizeof(zend_constant, NULL) == FAILURE);<br />
    …<br />
    …<br />
}<br />
对象定义常量</p><br />
<br />
<p>class Dog {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public $name = 'kitty';<br />
<br />
public function __toString () {<br />
    return $this-&gt;name;<br />
}<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>$dog = new Dog();</p><br />
<br />
<p>define(‘DOG’, $dog);</p><br />
<br />
<p>print_r(DOG);</p><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>define 值为对象时，会把对象装成标量来存储，需要类有 __toString魔术方法<br />
 */</li><br />
</ul><br />
<br />
<p>对象<br />
对象的底层实现</p><br />
<br />
<p>Zend/zend.h</p><br />
<br />
<p>struct _zval_struct {<br />
    /* Variable information <em>/<br />
    zvalue_value value;        /</em> value <em>/<br />
    zend_uint refcount__gc;<br />
    zend_uchar type;    /</em> active type */<br />
    zend_uchar is_ref__gc;<br />
};</p><br />
<br />
<p>// zvalue<br />
typedef union _zvalue_value {<br />
    long lval;                    /* long value <em>/<br />
    double dval;                /</em> double value <em>/<br />
    struct {<br />
        char *val;<br />
        int len;<br />
    } str;<br />
    HashTable *ht;                /</em> hash table value */<br />
    zend_object_value obj;<br />
    zend_ast *ast;<br />
} zvalue_value;</p><br />
<br />
<p>// 在 zend.h 中 查看到 <code class="language-plaintext highlighter-rouge">zend_object_value obj;</code>  是以zend_object_value 定义. 在Zend/zend_types.h 文件中继续查看</p><br />
<br />
<p>// Zend/zend_types.h<br />
定义zend_object_value 结构体</p><br />
<br />
<p>typedef struct _zend_object_value {<br />
    zend_object_handle handle;<br />
    const zend_object_handlers *handlers;<br />
} zend_object_value;<br />
通过new出来的对象，返回的是什么。是zend_object_value. 并不是真正的对象，而是对象的指针。</p><br />
<br />
<p>返回的 handle再次指向对象。</p><br />
<br />
<p>每次new一个对象，对象就存入一张hash表中。(形象的称之为对象池)</p><br />
<br />
<p>对象存储时的特点：</p><br />
<br />
<p>// 对象</p><br />
<br />
<p>class Dog {<br />
    public $leg = 4;<br />
    public $wei = 20;<br />
}</p><br />
<br />
<p>$dog = new Dog();</p><br />
<br />
<p>// $dog 是一个对象么?<br />
// 严格说，并不是对象.<br />
/**</p><br />
<ul><br />
  <li>{</li><br />
  <li>handle –指向–&gt;  [hash表 {leg: 4, wei: 20}] // hash表中存在 对象</li><br />
  <li>}<br />
 */</li><br />
</ul><br />
<br />
<p>$d2 = $dog;</p><br />
<br />
<p>$d2-&gt;leg = 5;</p><br />
<br />
<p>echo $dog-&gt;leg, ‘<code class="language-plaintext highlighter-rouge">', $d2-&gt;leg; // 5</code>5</p><br />
<br />
<p>// 对象并不是 引用赋值. 主要原因  zval 结构体 是再次指向一个hash表中的 对象池<br />
$d2 = false;</p><br />
<br />
<p>echo $dog-&gt;leg; // 5</p><br />
<br />
<p>内存分层<br />
内存管理与垃圾回收</p><br />
<br />
<p>PHP封装了对系统内存的请求<br />
不要直接使用malloc直接请求内存</p><br />
<br />
<p>PHP函数需要内存的时候，是通过emalloc,efree.<br />
emalloc,efree向 mm_heap索要空间。</p><br />
<br />
<p>zend 中底层都离不开hash表。PHP中的HashTable太强大。</p><br />
<br />
<p>PHP 底层 所有的变量都是 放在 zend_mm_heap 中。 然后通过 各自的hash表来指向或跟踪。</p><br />
<br />
<p>zend虚拟机的运行原理</p><br />
<br />
<p>PHP语法实现</p><br />
<br />
<p>Zend/zend_language_scanner.l<br />
Zend/zend_language_parser.y<br />
OPcode编译</p><br />
<br />
<p>Zend/zend.compile.c<br />
执行引擎</p><br />
<br />
<p>Zend/zend_vm_*<br />
Zend/zend_execute.c</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>