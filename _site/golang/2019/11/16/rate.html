<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">time/rate</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-11-16T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Nov 16, 2019</time></p>
					</div>
					 <p>限流器是后台服务中的非常重要的组件，可以用来限制请求速率，保护服务，以免服务过载。<br />
限流器的实现方法有很多种，例如滑动窗口法、Token Bucket、Leaky Bucket等。</p><br />
<br />
<p>其实golang标准库中就自带了限流算法的实现，即golang.org/x/time/rate。<br />
该限流器是基于Token Bucket(令牌桶)实现的。</p><br />
<br />
<p>简单来说，令牌桶就是想象有一个固定大小的桶，系统会以恒定速率向桶中放Token，桶满则暂时不放。<br />
而用户则从桶中取Token，如果有剩余Token就可以一直取。如果没有剩余Token，则需要等到系统中被放置了Token才行。<br />
<!-- more --><br />
构造一个限流器<br />
我们可以使用以下方法构造一个限流器对象：</p><br />
<br />
<p>limiter := NewLimiter(10, 1);<br />
这里有两个参数：</p><br />
<br />
<p>第一个参数是r Limit。代表每秒可以向Token桶中产生多少token。Limit实际上是float64的别名。<br />
第二个参数是b int。b代表Token桶的容量大小。<br />
那么，对于以上例子来说，其构造出的限流器含义为，其令牌桶大小为1, 以每秒10个Token的速率向桶中放置Token。</p><br />
<br />
<p>除了直接指定每秒产生的Token个数外，还可以用Every方法来指定向Token桶中放置Token的间隔，例如：</p><br />
<br />
<p>limit := Every(100 * time.Millisecond);<br />
limiter := NewLimiter(limit, 1);<br />
以上就表示每100ms往桶中放一个Token。本质上也就是一秒钟产生10个。</p><br />
<br />
<p>Limiter提供了三类方法供用户消费Token，用户可以每次消费一个Token，也可以一次性消费多个Token。<br />
而每种方法代表了当Token不足时，各自不同的对应手段。</p><br />
<br />
<p>Wait/WaitN<br />
func (lim *Limiter) Wait(ctx context.Context) (err error)<br />
func (lim *Limiter) WaitN(ctx context.Context, n int) (err error)<br />
Wait实际上就是WaitN(ctx,1)。</p><br />
<br />
<p>当使用Wait方法消费Token时，如果此时桶内Token数组不足(小于N)，那么Wait方法将会阻塞一段时间，直至Token满足条件。如果充足则直接返回。</p><br />
<br />
<p>这里可以看到，Wait方法有一个context参数。<br />
我们可以设置context的Deadline或者Timeout，来决定此次Wait的最长时间。</p><br />
<br />
<p>Allow/AllowN<br />
func (lim *Limiter) Allow() bool<br />
func (lim *Limiter) AllowN(now time.Time, n int) bool<br />
Allow实际上就是AllowN(time.Now(),1)。</p><br />
<br />
<p>AllowN方法表示，截止到某一时刻，目前桶中数目是否至少为n个，满足则返回true，同时从桶中消费n个token。<br />
反之返回不消费Token，false。</p><br />
<br />
<p>通常对应这样的线上场景，如果请求速率过快，就直接丢到某些请求。</p><br />
<br />
<p>Reserve/ReserveN<br />
func (lim *Limiter) Reserve() *Reservation<br />
func (lim *Limiter) ReserveN(now time.Time, n int) *Reservation<br />
Reserve相当于ReserveN(time.Now(), 1)。</p><br />
<br />
<p>ReserveN的用法就相对来说复杂一些，当调用完成后，无论Token是否充足，都会返回一个Reservation*对象。</p><br />
<br />
<p>你可以调用该对象的Delay()方法，该方法返回了需要等待的时间。如果等待时间为0，则说明不用等待。<br />
必须等到等待时间之后，才能进行接下来的工作。</p><br />
<br />
<p>或者，如果不想等待，可以调用Cancel()方法，该方法会将Token归还。</p><br />
<br />
<p>举一个简单的例子，我们可以这么使用Reserve方法。</p><br />
<br />
<p>r := lim.Reserve()<br />
f !r.OK() {<br />
    // Not allowed to act! Did you remember to set lim.burst to be &gt; 0 ?<br />
    return<br />
}<br />
time.Sleep(r.Delay())<br />
Act() // 执行相关逻辑<br />
动态调整速率<br />
Limiter支持可以调整速率和桶大小：</p><br />
<br />
<p>SetLimit(Limit) 改变放入Token的速率<br />
SetBurst(int) 改变Token桶大小<br />
有了这两个方法，可以根据现有环境和条件，根据我们的需求，动态的改变Token桶大小和速率。</p><br />
<br />
<p>ber在Github上开源了一套用于服务限流的go语言库ratelimit, 该组件基于Leaky Bucket(漏桶)实现。</p><br />
<br />
<p>我在之前写过《Golang限流器time/rate实现剖析》，讲了Golang标准库中提供的基于Token Bucket实现限流组件的time/rate原理，同时也讲了限流的一些背景。</p><br />
<br />
<p>相比于TokenBucket，只要桶内还有剩余令牌，调用方就可以一直消费。而Leaky Bucket相对来说比较严格，调用方只能严格按照这个间隔顺序进行消费调用。(实际上，uber-go对这个限制也做了一些优化，具体可以看下文详解)</p><br />
<br />
<p>还是老规矩，在正式讲其实现之前，我们先看下ratelimit的使用方法。</p><br />
<br />
<p>ratelimit的使用<br />
我们直接看下uber-go官方库给的例子：</p><br />
<br />
<p>rl := ratelimit.New(100) // per second</p><br />
<br />
<p>prev := time.Now()<br />
for i := 0; i &lt; 10; i++ {<br />
  now := rl.Take()<br />
  fmt.Println(i, now.Sub(prev))<br />
  prev = now<br />
}<br />
在这个例子中，我们给定限流器每秒可以通过100个请求，也就是平均每个请求间隔10ms。<br />
因此，最终会每10ms打印一行数据。输出结果如下：</p><br />
<br />
<p>// Output:<br />
// 0 0<br />
// 1 10ms<br />
// 2 10ms<br />
// 3 10ms<br />
// 4 10ms<br />
// 5 10ms<br />
// 6 10ms<br />
// 7 10ms<br />
// 8 10ms<br />
// 9 10ms<br />
基本实现<br />
要实现以上每秒固定速率的目的，其实还是比较简单的。</p><br />
<br />
<p>在ratelimit的New函数中，传入的参数是每秒允许请求量(RPS)。<br />
我们可以很轻易的换算出每个请求之间的间隔：</p><br />
<br />
<p>limiter.perRequest = time.Second / time.Duration(rate)<br />
以上limiter.perRequest指的就是每个请求之间的间隔时间。</p><br />
<br />
<p>如下图，当请求1处理结束后, 我们记录下请求1的处理完成的时刻, 记为limiter.last。<br />
稍后请求2到来, 如果此刻的时间与limiter.last相比并没有达到perRequest的间隔大小，那么sleep一段时间即可。</p><br />
<br />
<p>漏桶示例图</p><br />
<br />
<p>对应ratelimit的实现代码如下：</p><br />
<br />
<p>sleepFor = t.perRequest - now.Sub(t.last)<br />
if sleepFor &gt; 0 {<br />
	t.clock.Sleep(sleepFor)<br />
	t.last = now.Add(sleepFor)<br />
} else {<br />
	t.last = now<br />
}<br />
最大松弛量<br />
我们讲到，传统的Leaky Bucket，每个请求的间隔是固定的，然而，在实际上的互联网应用中，流量经常是突发性的。对于这种情况，uber-go对Leaky Bucket做了一些改良，引入了最大松弛量(maxSlack)的概念。</p><br />
<br />
<p>我们先理解下整体背景: 假如我们要求每秒限定100个请求，平均每个请求间隔10ms。但是实际情况下，有些请求间隔比较长，有些请求间隔比较短。如下图所示：</p><br />
<br />
<p>请求1完成后，15ms后，请求2才到来，可以对请求2立即处理。请求2完成后，5ms后，请求3到来，这个时候距离上次请求还不足10ms，因此还需要等待5ms。</p><br />
<br />
<p>但是，对于这种情况，实际上三个请求一共消耗了25ms才完成，并不是预期的20ms。在uber-go实现的ratelimit中，可以把之前间隔比较长的请求的时间，匀给后面的使用，保证每秒请求数(RPS)即可。</p><br />
<br />
<p>对于以上case，因为请求2相当于多等了5ms，我们可以把这5ms移给请求3使用。加上请求3本身就是5ms之后过来的，一共刚好10ms，所以请求3无需等待，直接可以处理。此时三个请求也恰好一共是20ms。<br />
如下图所示：</p><br />
<br />
<p>在ratelimit的对应实现中很简单，是把每个请求多余出来的等待时间累加起来，以给后面的抵消使用。</p><br />
<br />
<p>t.sleepFor += t.perRequest - now.Sub(t.last)<br />
if t.sleepFor &gt; 0 {<br />
  t.clock.Sleep(t.sleepFor)<br />
  t.last = now.Add(t.sleepFor)<br />
  t.sleepFor = 0<br />
} else {<br />
  t.last = now<br />
}<br />
注意：这里跟上述代码不同的是，这里是+=。而同时t.perRequest - now.Sub(t.last)是可能为负值的，负值代表请求间隔时间比预期的长。</p><br />
<br />
<p>当t.sleepFor &gt; 0，代表此前的请求多余出来的时间，无法完全抵消此次的所需量，因此需要sleep相应时间, 同时将t.sleepFor置为0。</p><br />
<br />
<p>当t.sleepFor &lt; 0，说明此次请求间隔大于预期间隔，将多出来的时间累加到t.sleepFor即可。</p><br />
<br />
<p>但是，对于某种情况，请求1完成后，请求2过了很久到达(好几个小时都有可能)，那么此时对于请求2的请求间隔now.Sub(t.last)，会非常大。以至于即使后面大量请求瞬时到达，也无法抵消完这个时间。那这样就失去了限流的意义。</p><br />
<br />
<p>为了防止这种情况，ratelimit就引入了最大松弛量(maxSlack)的概念, 该值为负值，表示允许抵消的最长时间，防止以上情况的出现。</p><br />
<br />
<p>if t.sleepFor &lt; t.maxSlack {<br />
  t.sleepFor = t.maxSlack<br />
}<br />
ratelimit中maxSlack的值为-10 * time.Second / time.Duration(rate), 是十个请求的间隔大小。我们也可以理解为ratelimit允许的最大瞬时请求为10。</p><br />
<br />
<p>高级用法<br />
ratelimit的New函数，除了可以配置每秒请求数(QPS)， 其实还提供了一套可选配置项Option。</p><br />
<br />
<p>func New(rate int, opts …Option) Limiter<br />
Option的类型为type Option func(l *limiter), 也就是说我们可以提供一些这样类型的函数，作为Option，传给ratelimit, 定制相关需求。</p><br />
<br />
<p>但实际上，自定义Option的用处比较小，因为limiter结构体本身就是个私有类型，我们并不能拿它做任何事情。</p><br />
<br />
<p>我们只需要了解ratelimit目前提供的两个配置项即可：</p><br />
<br />
<p>WithoutSlack<br />
我们上文讲到ratelimit中引入了最大松弛量的概念，而且默认的最大松弛量为10个请求的间隔时间。</p><br />
<br />
<p>但是确实会有这样需求场景，需要严格的限制请求的固定间隔。那么我们就可以利用WithoutSlack来取消松弛量的影响。</p><br />
<br />
<p>limiter := ratelimit.New(100, ratelimit.WithoutSlack)<br />
WithClock(clock Clock)<br />
我们上文讲到，ratelimit的实现时，会计算当前时间与上次请求时间的差值，并sleep相应时间。<br />
在ratelimit基于go标准库的time实现时间相关计算。如果有精度更高或者特殊需求的计时场景，可以用WithClock来替换默认时钟。</p><br />
<br />
<p>通过该方法，只要实现了Clock的interface，就可以自定义时钟了。</p><br />
<br />
<p>type Clock interface {<br />
	Now() time.Time<br />
	Sleep(time.Duration)<br />
}<br />
clock &amp;= MyClock{}<br />
limiter := ratelimit.New(100, ratelimit.WithClock(clock))</p><br />
<br />
<p>限流器是微服务中必不缺少的一环，可以起到保护下游服务，防止服务过载等作用。上一篇文章《Golang限流器time/rate使用介绍》简单介绍了time/rate的使用方法，本文则着重分析下其实现原理。建议在正式阅读本文之前，先阅读下上一篇文章。</p><br />
<br />
<p>上一篇文章讲到，time/rate是基于Token Bucket(令牌桶)算法实现的限流。本文将会基于源码，深入剖析下Golang是如何实现Token Bucket的。其代码也非常简洁，去除注释后，也就200行左右的代码量。</p><br />
<br />
<p>同时，我也提供了time/rate注释版，辅助大家理解该组件的实现。</p><br />
<br />
<p>背景<br />
简单来说，令牌桶就是想象有一个固定大小的桶，系统会以恒定速率向桶中放Token，桶满则暂时不放。<br />
而用户则从桶中取Token，如果有剩余Token就可以一直取。如果没有剩余Token，则需要等到系统中被放置了Token才行。</p><br />
<br />
<p>一般介绍Token Bucket的时候，都会有一张这样的原理图：<br />
Token Bucket原理图</p><br />
<br />
<p>从这个图中看起来，似乎令牌桶实现应该是这样的：</p><br />
<br />
<p>有一个Timer和一个BlockingQueue。Timer固定的往BlockingQueue中放token。用户则从BlockingQueue中取数据。</p><br />
<br />
<p>这固然是Token Bucket的一种实现方式，这么做也非常直观，但是效率太低了：我们需要不仅多维护一个Timer和BlockingQueue，而且还耗费了一些不必要的内存。</p><br />
<br />
<p>在Golang的timer/rate中的实现, 并没有单独维护一个Timer，而是采用了lazyload的方式，直到每次消费之前才根据时间差更新Token数目，而且也不是用BlockingQueue来存放Token，而是仅仅通过计数的方式。</p><br />
<br />
<p>Token的生成和消费<br />
我们在上一篇文章中讲到，Token的消费方式有三种。但其实在内部实现，最终三种消费方式都调用了reserveN函数来生成和消费Token。</p><br />
<br />
<p>我们看下reserveN函数的具体实现，整个过程非常简单。在正式讲之前，我们先了解一个简单的概念：</p><br />
<br />
<p>在time/rate中，NewLimiter的第一个参数是速率limit，代表了一秒钟可以产生多少Token。<br />
那么简单换算一下，我们就可以知道一个Token的生成间隔是多少。</p><br />
<br />
<p>有了这个生成间隔，我们就可以轻易地得到两个数据：</p><br />
<ol><br />
  <li>生成N个新的Token一共需要多久。time/rate中对应的实现函数为durationFromTokens。</li><br />
  <li>给定一段时长，这段时间一共可以生成多少个Token。time/rate中对应的实现函数为tokensFromDuration。</li><br />
</ol><br />
<br />
<p>那么，有了这些转换函数，整个过程就很清晰了，如下：</p><br />
<br />
<p>计算从上次取Token的时间到当前时刻，期间一共新产生了多少Token：<br />
我们只在取Token之前生成新的Token，也就意味着每次取Token的间隔，实际上也是生成Token的间隔。我们可以利用tokensFromDuration, 轻易的算出这段时间一共产生Token的数目。<br />
那么，当前Token数目 = 新产生的Token数目 + 之前剩余的Token数目 - 要消费的Token数目。</p><br />
<br />
<p>如果消费后剩余Token数目大于零，说明此时Token桶内仍不为空，此时Token充足，无需调用侧等待。<br />
如果Token数目小于零，则需等待一段时间。<br />
那么这个时候，我们可以利用durationFromTokens将当前负值的Token数转化为需要等待的时间。</p><br />
<br />
<p>将需要等待的时间等相关结果返回给调用方。</p><br />
<br />
<p>从上面可以看出，其实整个过程就是利用了Token数可以和时间相互转化的原理。而如果Token数为负，则需要等待相应时间即可。</p><br />
<br />
<p>注意：如果当消费时，Token桶中的Token数目已经为负值了，依然可以按照上述流程进行消费。随着负值越来越小，等待的时间将会越来越长。<br />
从结果来看，这个行为跟用Timer+BlockQueue实现是一样的。</p><br />
<br />
<p>此外，整个过程为了保证线程安全，更新令牌桶相关数据时都用了mutex加锁。</p><br />
<br />
<p>对于Allow函数实现时，只要判断需要等待的时间是否为0即可，如果大于0说明需要等待，则返回False，反之返回True。</p><br />
<br />
<p>对于Wait函数，直接t := time.NewTimer(delay)，等待对应的时间即可。</p><br />
<br />
<p>float精度问题<br />
从上面原理讲述可以看出，在Token和时间的相互转化函数durationFromTokens和tokensFromDuration中，涉及到float64的乘除运算。<br />
一谈到float的乘除，我们就需要小心精度问题了。</p><br />
<br />
<p>而Golang在这里也踩了坑，以下是tokensFromDuration最初的实现版本</p><br />
<br />
<p>func (limit Limit) tokensFromDuration(d time.Duration) float64 {<br />
	return d.Seconds() * float64(limit)<br />
}<br />
这个操作看起来一点问题都没：每秒生成的Token数乘于秒数。<br />
然而，这里的问题在于，d.Seconds()已经是小数了。两个小数相乘，会带来精度的损失。</p><br />
<br />
<p>所以就有了这个issue:golang.org/issues/34861。</p><br />
<br />
<p>修改后新的版本如下：</p><br />
<br />
<p>func (limit Limit) tokensFromDuration(d time.Duration) float64 {<br />
	sec := float64(d/time.Second) * float64(limit)<br />
	nsec := float64(d%time.Second) * float64(limit)<br />
	return sec + nsec/1e9<br />
}<br />
time.Duration是int64的别名，代表纳秒。分别求出秒的整数部分和小数部分，进行相乘后再相加，这样可以得到最精确的精度。</p><br />
<br />
<p>数值溢出问题<br />
我们讲reserveN函数的具体实现时，第一步就是计算从当前时间到上次取Token的时刻，期间一共新产生了多少Token，同时也可得出当前的Token是多少。</p><br />
<br />
<p>我最开始的理解是，直接可以这么做：</p><br />
<br />
<p>// elapsed表示过去的时间差<br />
elapsed := now.Sub(lim.last)<br />
// delta表示这段时间一共新产生了多少Token<br />
delta = tokensFromDuration(now.Sub(lim.last))</p><br />
<br />
<p>tokens := lim.tokens + delta<br />
if(token &gt; lim.burst){<br />
	token = lim.burst<br />
}<br />
其中，lim.tokens是当前剩余的Token，lim.last是上次取token的时刻。lim.burst是Token桶的大小。<br />
使用tokensFromDuration计算出新生成了多少Token，累加起来后，不能超过桶的容量即可。</p><br />
<br />
<p>这么做看起来也没什么问题，然而并不是这样。</p><br />
<br />
<p>在time/rate里面是这么做的，如下代码所示：</p><br />
<br />
<p>maxElapsed := lim.limit.durationFromTokens(float64(lim.burst) - lim.tokens)<br />
elapsed := now.Sub(last)<br />
if elapsed &gt; maxElapsed {<br />
	elapsed = maxElapsed<br />
}</p><br />
<br />
<p>delta := lim.limit.tokensFromDuration(elapsed)</p><br />
<br />
<p>tokens := lim.tokens + delta<br />
if burst := float64(lim.burst); tokens &gt; burst {<br />
	tokens = burst<br />
}<br />
与我们最开始的代码不一样的是，它没有直接用now.Sub(lim.last)来转化为对应的Token数，而是<br />
先用lim.limit.durationFromTokens(float64(lim.burst) - lim.tokens)，计算把桶填满的时间maxElapsed。<br />
取elapsed和maxElapsed的最小值。</p><br />
<br />
<p>这么做算出的结果肯定是正确的，但是这么做相比于我们的做法，好处在哪里？</p><br />
<br />
<p>对于我们的代码，当last非常小的时候（或者当其为初始值0的时候），此时now.Sub(lim.last)的值就会非常大，如果lim.limit即每秒生成的Token数目也非常大时，直接将二者进行乘法运算，结果有可能会溢出。</p><br />
<br />
<p>因此，time/rate先计算了把桶填满的时间，将其作为时间差值的上限，这样就规避了溢出的问题。</p><br />
<br />
<p>Token的归还<br />
而对于Reserve函数，返回的结果中，我们可以通过Reservation.Delay()函数，得到需要等待时间。<br />
同时调用方可以根据返回条件和现有情况，可以调用Reservation.Cancel()函数，取消此次消费。<br />
当调用Cancel()函数时，消费的Token数将会尽可能归还给Token桶。</p><br />
<br />
<p>此外，我们在上一篇文章中讲到，Wait函数可以通过Context进行取消或者超时等，<br />
当通过Context进行取消或超时时，此时消费的Token数也会归还给Token桶。</p><br />
<br />
<p>然而，归还Token的时候，并不是简单的将Token数直接累加到现有Token桶的数目上，这里还有一些注意点：</p><br />
<br />
<p>restoreTokens := float64(r.tokens) - r.limit.tokensFromDuration(r.lim.lastEvent.Sub(r.timeToAct))<br />
if restoreTokens &lt;= 0 {<br />
	return<br />
}<br />
以上代码就是计算需要归还多少的Token。其中：</p><br />
<br />
<p>r.tokens指的是本次消费的Token数<br />
r.timeToAct指的是Token桶可以满足本次消费数目的时刻，也就是消费的时刻+等待的时长。<br />
r.lim.lastEvent指的是最近一次消费的timeToAct值<br />
其中：r.limit.tokensFromDuration(r.lim.lastEvent.Sub(r.timeToAct)) 指的是，从该次消费到当前时间，一共又新消费了多少Token数目。</p><br />
<br />
<p>根据代码来看，要归还的Token要是该次消费的Token减去新消费的Token。<br />
不过这里我还没有想明白，为什么归还的时候，要减去新消费数目。</p><br />
<br />
<p>按照我的理解，直接归还全部Token数目，这样对于下一次消费是无感知影响的。这块的具体原因还需要进一步探索。</p><br />
<br />
<p>总结<br />
Token Bucket其实非常适合互联网突发式请求的场景，其请求Token时并不是严格的限制为固定的速率，而是中间有一个桶作为缓冲。<br />
只要桶中还有Token，请求就还可以一直进行。当突发量激增到一定程度，则才会按照预定速率进行消费。</p><br />
<br />
<p>此外在维基百科中，也提到了分层Token Bucket(HTB)作为传统Token Bucket的进一步优化，Linux内核中也用它进行流量控制。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>