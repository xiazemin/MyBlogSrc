<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">Panic/Recover Mechanism</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-11-16T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Nov 16, 2019</time></p>
					</div>
					 <p>https://go101.org/article/control-flows-more.html#panic-recover</p><br />
<br />
<p>Panic and recover mechanism has been introduced before, and several panic/recover use cases are shown in the last article. This current article will explain panic/recover mechanism in detail. Exiting phases of function calls will also be explained detailedly.</p><br />
<br />
<p>Exiting Phases of Function Calls<br />
In Go, a function call may undergo an exiting phase before it fully exits. In the exiting phase, the deferred function calls pushed into the defer-call stack in executing the function call will be executed (in the inverse pushing order). When all of the deferred calls fully exit, the exiting phase ends and the function call also fully exits.</p><br />
<br />
<p>A funciton call may enter its exiting phase (or exit directly) through three ways:<br />
after the call returns normally.<br />
when a panic occurs in the call.<br />
after the runtime.Goexit function is called and fully exits in the call.<br />
<!-- more --><br />
For example, in the following code snippet,<br />
a call to the function f0 or f1 will enter its existing phase after it returns normally.<br />
a call to the function f2 will enter its exiting phase after the divided-by-zero panic happens.<br />
a call to the function f3 will enter its exiting phase after the runtime.Goexit function call fully exits.<br />
import (<br />
	“fmt”<br />
	“runtime”<br />
)</p><br />
<br />
<p>func f0() int {<br />
	var x = 1<br />
	defer fmt.Println(“exits normally:”, x)<br />
	x++<br />
	return x<br />
}</p><br />
<br />
<p>func f1() {<br />
	var x = 1<br />
	defer fmt.Println(“exits normally:”, x)<br />
	x++<br />
}</p><br />
<br />
<p>func f2() {<br />
	var x, y = 1, 0<br />
	defer fmt.Println(“exits for panicking:”, x)<br />
	x = x / y // will panic<br />
	x++       // unreachable<br />
}</p><br />
<br />
<p>func f3() int {<br />
	x := 1<br />
	defer fmt.Println(“exits for Goexiting:”, x)<br />
	x++<br />
	runtime.Goexit()<br />
	return x+x // unreachable<br />
}<br />
Assosiating Panics and Goexit Signals of Function Calls<br />
When a panic occurs directly in a function call, we say the (unrecovered) panic starts associating with the function call. Similarly, when the runtime.Goexit function is called in a function call, we say a Goexit signal starts associating with the function call after the the runtime.Goexit call fully exits. A panic and a Goexit signal are independent of each other. As explained in the last section, associating either a panic or a Goexit signal with a funciton call will make the function call enter its exiting phase immediately.</p><br />
<br />
<p>We have learned that panics can be recovered. However, there are no ways to cancel a Goexit signal.</p><br />
<br />
<p>At any give time, a function call may associate with at most one unrecovered panic. If a call is associating with an unrecovered panic, then<br />
the call will associate with no panics when the unrecovered panic is recovered.<br />
when a new panic occurs in the function call, the new one will replace the old one to be the associating unrecovered panic of the function call.<br />
For example, in the following program, the recovered panic is panic 3, which is the last panic associating with the main function call.<br />
package main</p><br />
<br />
<p>import “fmt”</p><br />
<br />
<p>func main() {<br />
	defer func() {<br />
		fmt.Println(recover()) // 3<br />
	}()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>defer panic(3) // will replace panic 2<br />
defer panic(2) // will replace panic 1<br />
defer panic(1) // will replace panic 0<br />
panic(0) } As Goexit signals can't be cancelled, arguing whether a function call may associate with at most one or more than one Goexit signal is unecessary.<br />
</code></pre></div></div><br />
<br />
<p>Although it is unusual, there might be multiple unrecovered panics coexisting in a goroutine at a time. Each one associates with one non-exited function call in the call stack of the goroutine. When a nested call still associating with an unrecovered panic fully exits, the unrecovered panic will spread to the nesting call (the caller of the nested call). The effect is the same as a panic occurs directly in the nesting call. That says,<br />
if there was an old unrecovered panic associating with the nesting call before, the old one will be replaced by the spread one. For this case, the nesting call has already entered its exiting phase for sure, so the next deferred function call in the defer-call stack will be invoked.<br />
if there was not an unrecovered panic associating with the nesting call before, the spread one will associates with the the nesting call. For this case, the nesting call might has entered its exiting phase or not. If it hasn’t, it will enter its exiting phase immediately.<br />
So, when a goroutine finishes to exit, there may be at most one unrecovered panic in the goroutine. If a goroutine exits with an unrecovered panic, the whole program crashes. The information of the unrecovered panic will be reported when the program crashes.</p><br />
<br />
<p>When a function is invoked, there is neither a panic nor Goexit signals associating with its call initially, no matter whether its caller (the nesting call) has entered exiting phase or not. Surely, panics might occur or the runtime.Goexit function might be called later in the process of executing the call, so panics and Goexit signals might associate with the call later.</p><br />
<br />
<p>The following example program will crash if it runs, because the panic 2 is still not recovered when the new goroutine exits.<br />
package main</p><br />
<br />
<p>func main() {<br />
	// The new goroutine.<br />
	go func() {<br />
		// The anonymous deferred call.<br />
		// When it fully exits, the panic 2 will spread<br />
		// to the entry function call of the new<br />
		// goroutine, and replace the panic 0. The<br />
		// panic 2 will never be recovered.<br />
		defer func() {<br />
			// As explained in the last example,<br />
			// panic 2 will replace panic 1.<br />
			defer panic(2)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		// When the anonymous function call fully<br />
		// exits, panic 1 will spread to (and<br />
		// associate with) the nesting anonymous<br />
		// deferred call.<br />
		func () {<br />
			panic(1)<br />
			// Once the panic 1 occurs, there will<br />
			// be two unrecovered panics coexisting<br />
			// in the new goroutine. One (panic 0)<br />
			// associates with the entry function<br />
			// call of the new goroutine, the other<br />
			// (panic 1) accosiates with the<br />
			// current anonymous function call.<br />
		}()<br />
	}()<br />
	panic(0)<br />
}()<br />
<br />
select{} } The output (when the above program is compiled with the standad Go compiler v1.13): panic: 0<br />
panic: 1<br />
panic: 2<br />
</code></pre></div></div><br />
<br />
<p>goroutine 5 [running]:<br />
…<br />
The format of the output is not perfect, it is prone to make some people think that the panic 0 is the final unrecovered panic, whereas the final unrecovered panic is panic 2 actually.</p><br />
<br />
<p>Similarly, when a nested call fully exits and it is associating with a Goexit signal, then the Goexit signal will also spread to (and associate with) the nesting call. This will make the nesting call enter (if it hasn’t entered) its exiting phase immediately.</p><br />
<br />
<p>The above has mentioned that a panic and a Goexit signal are independent of each other. In other words, an unrecovered panic should not cancel a Goexit signal, and a Goexit signal should not shadow an unrecovered panic or be cancelled. However, both of the current official Go compiler (gc, v1.13) and gccgo (v8.0) don’t implement this rule correctly. For example, the following program should crash but it doesn’t if it is compiled with the current versions of gc and gccgo.<br />
package main</p><br />
<br />
<p>import “runtime”</p><br />
<br />
<p>func main() {<br />
	c := make(chan struct{})<br />
	go func() {<br />
		defer close(c)<br />
		// The Goexit signal shadows the<br />
		// “bye” panic, but it should not.<br />
		defer runtime.Goexit()<br />
		panic(“bye”)<br />
	}()<br />
	&lt;-c<br />
}<br />
The following is another example neither gc nor gccgo compiles it correctly. The example program should exit quickly in running, but in fact it never exit if it is compiled with the current versions of gc and gccgo.<br />
package main</p><br />
<br />
<p>import “runtime”</p><br />
<br />
<p>func f() {<br />
	defer func() {<br />
		recover()<br />
	}()<br />
	defer panic(“will cancel Goexit but should not”)<br />
	runtime.Goexit()<br />
}</p><br />
<br />
<p>func main() {<br />
	c := make(chan struct{})<br />
	go func() {<br />
		defer close(c)<br />
		f()<br />
		for {<br />
			runtime.Gosched()<br />
		}<br />
	}()<br />
	&lt;-c<br />
}<br />
The problems in the current versions of gc and gccgo will be fixed later.</p><br />
<br />
<p>Some recover Calls Are No-Ops<br />
The builtin recover funciton must be called at proper places to take effect. Otherwise, the calls are no-ops. For example, none of the recover calls in the following exmaple recover the bye panic.<br />
package main</p><br />
<br />
<p>func main() {<br />
	defer func() {<br />
		defer func() {<br />
			recover() // no-op<br />
		}()<br />
	}()<br />
	defer func() {<br />
		func() {<br />
			recover() // no-op<br />
		}()<br />
	}()<br />
	func() {<br />
		defer func() {<br />
			recover() // no-op<br />
		}()<br />
	}()<br />
	func() {<br />
		defer recover() // no-op<br />
	}()<br />
	func() {<br />
		recover() // no-op<br />
	}()<br />
	recover()       // no-op<br />
	defer recover() // no-op<br />
	panic(“bye”)<br />
}<br />
We have already known that the following recover call takes effect.<br />
package main</p><br />
<br />
<p>func main() {<br />
	defer func() {<br />
		recover() // take effect<br />
	}()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>panic("bye") } Then why don't those recover calls in the first example in the current section take effect? Let's read the current verson of Go specification: The return value of recover is nil if any of the following conditions holds: panic's argument was nil; the goroutine is not panicking; recover was not called directly by a deferred function. There is an example showing the first condition case in the last article.<br />
</code></pre></div></div><br />
<br />
<p>Most of the recover calls in the first example in the current section satisfy either the second or the third conditions mentioned in Go specification, except the first one. Yes, the current descriptions are not precise yet. It is still being improved now.</p><br />
<br />
<p>In fact, the current Go specification also doesn’t explain well why the second recover call, which is expected to recover panic 1, in the following example doesn’t take effect.<br />
// This program exits without panic 1 being recovered.<br />
package main</p><br />
<br />
<p>func demo() {<br />
	defer func() {<br />
		defer func() {<br />
			recover() // this one recovers panic 2<br />
		}()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	defer recover() // no-op<br />
<br />
	panic(2)<br />
}()<br />
panic(1) }<br />
</code></pre></div></div><br />
<br />
<p>func main() {<br />
	demo()<br />
}<br />
What Go specification doesn’t mention is that, at any given time, only the newest unrecovered panic in a goroutine is recoverable. In other words, each recover call is viewed as an attempt to recover the newest unrecovered panic in the currrent goroutine. This is why the second recover call in the above example is a no-op.</p><br />
<br />
<p>OK, now, let’s try to make an explanation on which recover calls will take effect:<br />
A recover call takes effect only if the direct caller of the recover call is a deferred call and the direct caller of the deferred call associates with the newest unrecovered panic in the current goroutine. An effective recover call disassociates the newest unrecovered panic from its associating function call, and returns the value passed to the panic call which produced the newest unrecovered panic.</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>