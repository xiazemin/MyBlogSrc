<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">netpoll</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-11-16T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Nov 16, 2019</time></p>
					</div>
					 <p>Go 基于 I/O multiplexing 和 goroutine 构建了一个简洁而高性能的原生网络模型(基于 Go 的 I/O 多路复用 netpoll)，提供了 goroutine-per-connection 这样简单的网络编程模式。在这种模式下，开发者使用的是同步的模式去编写异步的逻辑，极大地降低了开发者编写网络应用时的心智负担，且借助于 Go runtime scheduler 对 goroutines 的高效调度，这个原生网络模型不论从适用性还是性能上都足以满足绝大部分的应用场景。</p><br />
<br />
<p>然而，在工程性上能做到如此高的普适性和兼容性，最终暴露给开发者提供接口/模式如此简洁，其底层必然是基于非常复杂的封装，做了很多取舍，也有可能放弃了一些『极致』的设计和理念。事实上netpoll底层就是基于 epoll/kqueue/iocp 这些系统调用来做封装的，最终暴露出 goroutine-per-connection 这样的极简的开发模式给使用者。</p><br />
<br />
<p>Go netpoll 在不同的操作系统，其底层使用的 I/O 多路复用技术也不一样，可以从 Go 源码目录结构和对应代码文件了解 Go 在不同平台下的网络 I/O 模式的实现。比如，在 Linux 系统下基于 epoll，freeBSD 系统下基于 kqueue，以及 Windows 系统下基于 iocp。</p><br />
<br />
<p>本文将基于 Linux 平台来解析 Go netpoll 之 I/O 多路复用的底层是如何基于 epoll 封装实现的，从源码层层推进，全面而深度地解析 Go netpoll 的设计理念和实现原理，以及 Go 是如何利用netpoll来构建它的原生网络模型的。主要涉及到的一些概念：I/O 模式、用户/内核空间、epoll、Linux 源码、goroutine scheduler 等等，<br />
<!-- more --><br />
用户空间与内核空间<br />
现在操作系统都是采用虚拟存储器，那么对 32 位操作系统而言，它的寻址空间（虚拟存储空间）为 4G（2 的 32 次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对 Linux 操作系统而言，将最高的 1G 字节（从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，称为内核空间，而将较低的 3G 字节（从虚拟地址 0x00000000 到 0xBFFFFFFF），供各个进程使用，称为用户空间。</p><br />
<br />
<p>I/O 多路复用<br />
在神作《UNIX 网络编程》里，总结归纳了 5 种 I/O 模型，包括同步和异步 I/O：</p><br />
<br />
<p>阻塞 I/O (Blocking I/O)<br />
非阻塞 I/O (Nonblocking I/O)<br />
I/O 多路复用 (I/O multiplexing)<br />
信号驱动 I/O (Signal driven I/O)<br />
异步 I/O (Asynchronous I/O)<br />
操作系统上的 I/O 是用户空间和内核空间的数据交互，因此 I/O 操作通常包含以下两个步骤：</p><br />
<br />
<p>等待网络数据到达网卡(读就绪)/等待网卡可写(写就绪) –&gt; 读取/写入到内核缓冲区<br />
从内核缓冲区复制数据 –&gt; 用户空间(读)/从用户空间复制数据 -&gt; 内核缓冲区(写)<br />
而判定一个 I/O 模型是同步还是异步，主要看第二步：数据在用户和内核空间之间复制的时候是不是会阻塞当前进程，如果会，则是同步 I/O，否则，就是异步 I/O。基于这个原则，这 5 种 I/O 模型中只有一种异步 I/O 模型：Asynchronous I/O，其余都是同步 I/O 模型</p><br />
<br />
<p>所谓 I/O 多路复用指的就是 select/poll/epoll 这一系列的多路选择器：支持单一线程同时监听多个文件描述符（I/O 事件），阻塞等待，并在其中某个文件描述符可读写时收到通知。 I/O 复用其实复用的不是 I/O 连接，而是复用线程，让一个 thread of control 能够处理多个连接（I/O 事件）。</p><br />
<br />
<p>select &amp; poll<br />
#include &lt;sys/select.h&gt;</p><br />
<br />
<p>/* According to earlier standards */<br />
#include &lt;sys/time.h&gt;<br />
#include &lt;sys/types.h&gt;<br />
#include <unistd.h></unistd.h></p><br />
<br />
<p>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</p><br />
<br />
<p>// 和 select 紧密结合的四个宏：<br />
void FD_CLR(int fd, fd_set *set);<br />
int FD_ISSET(int fd, fd_set *set);<br />
void FD_SET(int fd, fd_set *set);<br />
void FD_ZERO(fd_set *set);<br />
select 是 epoll 之前 Linux 使用的 I/O 事件驱动技术。</p><br />
<br />
<p>理解 select 的关键在于理解 fd_set，为说明方便，取 fd_set 长度为 1 字节，fd_set 中的每一 bit 可以对应一个文件描述符 fd，则 1 字节长的 fd_set 最大可以对应 8 个 fd。select 的调用过程如下：</p><br />
<br />
<p>执行 FD_ZERO(&amp;set), 则 set 用位表示是 0000,0000<br />
若 fd＝5, 执行 FD_SET(fd, &amp;set); 后 set 变为 0001,0000(第 5 位置为 1)<br />
再加入 fd＝2, fd=1，则 set 变为 0001,0011<br />
执行 select(6, &amp;set, 0, 0, 0) 阻塞等待<br />
若 fd=1, fd=2 上都发生可读事件，则 select 返回，此时 set 变为 0000,0011 (注意：没有事件发生的 fd=5 被清空)<br />
基于上面的调用过程，可以得出 select 的特点：</p><br />
<br />
<p>可监控的文件描述符个数取决于 sizeof(fd_set) 的值。假设服务器上 sizeof(fd_set)＝512，每 bit 表示一个文件描述符，则服务器上支持的最大文件描述符是 512*8=4096。fd_set 的大小调整可参考 【原创】技术系列之 网络模型（二） 中的模型 2，可以有效突破 select 可监控的文件描述符上限<br />
将 fd 加入 select 监控集的同时，还要再使用一个数据结构 array 保存放到 select 监控集中的 fd，一是用于在 select 返回后，array 作为源数据和 fd_set 进行 FD_ISSET 判断。二是 select 返回后会把以前加入的但并无事件发生的 fd 清空，则每次开始 select 前都要重新从 array 取得 fd 逐一加入（FD_ZERO 最先），扫描 array 的同时取得 fd 最大值 maxfd，用于 select 的第一个参数<br />
可见 select 模型必须在 select 前循环 array（加 fd，取 maxfd），select 返回后循环 array（FD_ISSET 判断是否有事件发生）<br />
所以，select 有如下的缺点：</p><br />
<br />
<p>最大并发数限制：使用 32 个整数的 32 位，即 32*32=1024 来标识 fd，虽然可修改，但是有以下第 2, 3 点的瓶颈<br />
每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大<br />
性能衰减严重：每次 kernel 都需要线性扫描整个 fd_set，所以随着监控的描述符 fd 数量增长，其 I/O 性能会线性下降<br />
poll 的实现和 select 非常相似，只是描述 fd 集合的方式不同，poll 使用 pollfd 结构而不是 select 的 fd_set 结构，poll 解决了最大文件描述符数量限制的问题，但是同样需要从用户态拷贝所有的 fd 到内核态，也需要线性遍历所有的 fd 集合，所以它和 select 只是实现细节上的区分，并没有本质上的区别。</p><br />
<br />
<p>epoll<br />
epoll 是 Linux kernel 2.6 之后引入的新 I/O 事件驱动技术，I/O 多路复用的核心设计是 1 个线程处理所有连接的等待消息准备好I/O 事件，这一点上 epoll 和 select&amp;poll 是大同小异的。但 select&amp;poll 预估错误了一件事，当数十万并发连接存在时，可能每一毫秒只有数百个活跃的连接，同时其余数十万连接在这一毫秒是非活跃的。select&amp;poll 的使用方法是这样的：返回的活跃连接 == select（全部待监控的连接）。</p><br />
<br />
<p>什么时候会调用 select&amp;poll 呢？在你认为需要找出有报文到达的活跃连接时，就应该调用。所以，select&amp;poll 在高并发时是会被频繁调用的。这样，这个频繁调用的方法就很有必要看看它是否有效率，因为，它的轻微效率损失都会被高频二字所放大。它有效率损失吗？显而易见，全部待监控连接是数以十万计的，返回的只是数百个活跃连接，这本身就是无效率的表现。被放大后就会发现，处理并发上万个连接时，select&amp;poll 就完全力不从心了。这个时候就该 epoll 上场了，epoll 通过一些新的设计和优化，基本上解决了 select&amp;poll 的问题。</p><br />
<br />
<p>epoll 的 API 非常简洁，涉及到的只有 3 个系统调用：</p><br />
<br />
<p>#include &lt;sys/epoll.h&gt;<br /><br />
int epoll_create(int size); // int epoll_create1(int flags);<br />
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);<br />
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);<br />
其中，epoll_create 创建一个 epoll 实例并返回 epollfd；epoll_ctl 注册 file descriptor 等待的 I/O 事件(比如 EPOLLIN、EPOLLOUT 等) 到 epoll 实例上；epoll_wait 则是阻塞监听 epoll 实例上所有的 file descriptor 的 I/O 事件，它接收一个用户空间上的一块内存地址 (events 数组)，kernel 会在有 I/O 事件发生的时候把文件描述符列表复制到这块内存地址上，然后 epoll_wait 解除阻塞并返回，最后用户空间上的程序就可以对相应的 fd 进行读写了：</p><br />
<br />
<p>#include <unistd.h><br />
ssize_t read(int fd, void *buf, size_t count);<br />
ssize_t write(int fd, const void *buf, size_t count);<br />
epoll 的工作原理如下：<br />
<img src="https://xiazemin.github.io/MyBlog/img/epoll-principle.png" /><br />
与 select&amp;poll 相比，epoll 分清了高频调用和低频调用。例如，epoll_ctl 相对来说就是不太频繁被调用的，而 epoll_wait 则是非常频繁被调用的。所以 epoll 利用 epoll_ctl 来插入或者删除一个 fd，实现用户态到内核态的数据拷贝，这确保了每一个 fd 在其生命周期只需要被拷贝一次，而不是每次调用 epoll_wait 的时候都拷贝一次。 epoll_wait 则被设计成几乎没有入参的调用，相比 select&amp;poll 需要把全部监听的 fd 集合从用户态拷贝至内核态的做法，epoll 的效率就高出了一大截。</unistd.h></p><br />
<br />
<p>在实现上 epoll 采用红黑树来存储所有监听的 fd，而红黑树本身插入和删除性能比较稳定，时间复杂度 O(logN)。通过 epoll_ctl 函数添加进来的 fd 都会被放在红黑树的某个节点内，所以，重复添加是没有用的。当把 fd 添加进来的时候时候会完成关键的一步：该 fd 都会与相应的设备（网卡）驱动程序建立回调关系，也就是在内核中断处理程序为它注册一个回调函数，在 fd 相应的事件触发（中断）之后（设备就绪了），内核就会调用这个回调函数，该回调函数在内核中被称为：ep_poll_callback，这个回调函数其实就是把这个 fd 添加到 rdllist 这个双向链表（就绪链表）中。epoll_wait 实际上就是去检查 rdlist 双向链表中是否有就绪的 fd，当 rdlist 为空（无就绪 fd）时挂起当前进程，直到 rdlist 非空时进程才被唤醒并返回。</p><br />
<br />
<p>相比于 select&amp;poll 调用时会将全部监听的 fd 从用户态空间拷贝至内核态空间并线性扫描一遍找出就绪的 fd 再返回到用户态，epoll_wait 则是直接返回已就绪 fd，因此 epoll 的 I/O 性能不会像 select&amp;poll 那样随着监听的 fd 数量增加而出现线性衰减，是一个非常高效的 I/O 事件驱动技术。</p><br />
<br />
<p>由于使用 epoll 的 I/O 多路复用需要用户进程自己负责 I/O 读写，从用户进程的角度看，读写过程是阻塞的，所以 select&amp;poll&amp;epoll 本质上都是同步 I/O 模型，而像 Windows 的 IOCP 这一类的异步 I/O，只需要在调用 WSARecv 或 WSASend 方法读写数据的时候把用户空间的内存 buffer 提交给 kernel，kernel 负责数据在用户空间和内核空间拷贝，完成之后就会通知用户进程，整个过程不需要用户进程参与，所以是真正的异步 I/O。</p><br />
<br />
<p>延伸<br />
另外，我看到有些文章说 epoll 之所以性能高是因为利用了 Linux 的 mmap 内存映射让内核和用户进程共享了一片物理内存，用来存放就绪 fd 列表和它们的数据 buffer，所以用户进程在 epoll_wait返回之后用户进程就可以直接从共享内存那里读取/写入数据了，这让我很疑惑，因为首先看epoll_wait的函数声明：</p><br />
<br />
<p>int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);<br />
第二个参数：就绪事件列表，是需要在用户空间分配内存然后再传给epoll_wait的，如果内核会用 mmap 设置共享内存，直接传递一个指针进去就行了，根本不需要在用户态分配内存，多此一举。其次，内核和用户进程通过 mmap 共享内存是一件极度危险的事情，内核无法确定这块共享内存什么时候会被回收，而且这样也会赋予用户进程直接操作内核数据的权限和入口，非常容易出现大的系统漏洞，因此一般极少会这么做。所以我很怀疑 epoll 是不是真的在 Linux kernel 里用了 mmap，我就去看了下最新版本（5.3.9）的 Linux kernel 源码：</p><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Implement the event wait interface for the eventpoll file. It is the kernel</li><br />
  <li><br />
    <p>part of the user space epoll_wait(2).<br />
 */<br />
static int do_epoll_wait(int epfd, struct epoll_event __user *events,<br />
          int maxevents, int timeout)<br />
{<br />
 // …</p><br />
<br />
    <p>/* Time to fish for events … */<br />
 error = ep_poll(ep, events, maxevents, timeout);<br />
}</p><br />
  </li><br />
</ul><br />
<br />
<p>// 如果 epoll_wait 入参时设定 timeout == 0, 那么直接通过 ep_events_available 判断当前是否有用户感兴趣的事件发生，如果有则通过 ep_send_events 进行处理<br />
// 如果设置 timeout &gt; 0，并且当前没有用户关注的事件发生，则进行休眠，并添加到 ep-&gt;wq 等待队列的头部；对等待事件描述符设置 WQ_FLAG_EXCLUSIVE 标志<br />
// ep_poll 被事件唤醒后会重新检查是否有关注事件，如果对应的事件已经被抢走，那么 ep_poll 会继续休眠等待<br />
static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events, int maxevents, long timeout)<br />
{<br />
	// …</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>send_events:<br />
/*<br />
 * Try to transfer events to user space. In case we get 0 events and<br />
 * there's still timeout left over, we go trying again in search of<br />
 * more luck.<br />
 */<br />
  <br />
// 如果一切正常, 有 event 发生, 就开始准备数据 copy 给用户空间了<br />
// 如果有就绪的事件发生，那么就调用 ep_send_events 将就绪的事件 copy 到用户态内存中，<br />
// 然后返回到用户态，否则判断是否超时，如果没有超时就继续等待就绪事件发生，如果超时就返回用户态。<br />
// 从 ep_poll 函数的实现可以看到，如果有就绪事件发生，则调用 ep_send_events 函数做进一步处理<br />
if (!res &amp;&amp; eavail &amp;&amp;<br />
		!(res = ep_send_events(ep, events, maxevents)) &amp;&amp; !timed_out)<br />
	goto fetch_events;<br />
  <br />
// ... }<br />
</code></pre></div></div><br />
<br />
<p>// ep_send_events 函数是用来向用户空间拷贝就绪 fd 列表的，它将用户传入的就绪 fd 列表内存简单封装到<br />
// ep_send_events_data 结构中，然后调用 ep_scan_ready_list 将就绪队列中的事件写入用户空间的内存；<br />
// 用户进程就可以访问到这些数据进行处理<br />
static int ep_send_events(struct eventpoll *ep,<br />
				struct epoll_event __user *events, int maxevents)<br />
{<br />
	struct ep_send_events_data esed;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>esed.maxevents = maxevents;<br />
esed.events = events;<br />
// 调用 ep_scan_ready_list 函数检查 epoll 实例 eventpoll 中的 rdllist 就绪链表，<br />
// 并注册一个回调函数 ep_send_events_proc，如果有就绪 fd，则调用 ep_send_events_proc 进行处理<br />
ep_scan_ready_list(ep, ep_send_events_proc, &amp;esed, 0, false);<br />
return esed.res; }<br />
</code></pre></div></div><br />
<br />
<p>// 调用 ep_scan_ready_list 的时候会传递指向 ep_send_events_proc 函数的函数指针作为回调函数，<br />
// 一旦有就绪 fd，就会调用 ep_send_events_proc 函数<br />
static __poll_t ep_send_events_proc(struct eventpoll *ep, struct list_head *head, void *priv)<br />
{<br />
	// …</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*<br />
 * If the event mask intersect the caller-requested one,<br />
 * deliver the event to userspace. Again, ep_scan_ready_list()<br />
 * is holding ep-&gt;mtx, so no operations coming from userspace<br />
 * can change the item.<br />
 */<br />
revents = ep_item_poll(epi, &amp;pt, 1);<br />
// 如果 revents 为 0，说明没有就绪的事件，跳过，否则就将就绪事件拷贝到用户态内存中<br />
if (!revents)<br />
	continue;<br />
// 将当前就绪的事件和用户进程传入的数据都通过 __put_user 拷贝回用户空间,   // 也就是调用 epoll_wait 之时用户进程传入的 fd 列表的内存<br />
if (__put_user(revents, &amp;uevent-&gt;events) || __put_user(epi-&gt;event.data, &amp;uevent-&gt;data)) {<br />
	list_add(&amp;epi-&gt;rdllink, head);<br />
	ep_pm_stay_awake(epi);<br />
	if (!esed-&gt;res)<br />
		esed-&gt;res = -EFAULT;<br />
	return 0;<br />
}<br />
  <br />
// ... } 从do_epoll_wait开始层层跳转，我们可以很清楚地看到最后内核是通过__put_user函数把就绪 fd 列表和事件返回到用户空间，而__put_user正是内核用来拷贝数据到用户空间的标准函数。此外，我并没有在 Linux kernel 的源码中和 epoll 相关的代码里找到 mmap 系统调用做内存映射的逻辑，所以基本可以得出结论：epoll 在 Linux kernel 里并没有使用 mmap 来做用户空间和内核空间的内存共享，所以那些说 epoll 使用了 mmap 的文章都是误解。<br />
</code></pre></div></div><br />
<br />
<p>Non-blocking I/O<br />
什么叫非阻塞 I/O，顾名思义就是：所有 I/O 操作都是立刻返回而不会阻塞当前用户进程。I/O 多路复用通常情况下需要和非阻塞 I/O 搭配使用，否则可能会产生意想不到的问题。比如，epoll 的 ET(边缘触发) 模式下，如果不使用非阻塞 I/O，有极大的概率会导致阻塞 event-loop 线程，从而降低吞吐量，甚至导致 bug。</p><br />
<br />
<p>Linux 下，我们可以通过 fcntl 系统调用来设置 O_NONBLOCK标志位，从而把 socket 设置成 non-blocking。当对一个 non-blocking socket 执行读操作时，流程是这个样子：<br />
当用户进程发出 read 操作时，如果 kernel 中的数据还没有准备好，那么它并不会 block 用户进程，而是立刻返回一个 EAGAIN error。从用户进程角度讲 ，它发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦 kernel 中的数据准备好了，并且又再次收到了用户进程的 system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><br />
<br />
<p>所以，non-blocking I/O 的特点是用户进程需要不断的主动询问 kernel 数据好了没有。</p><br />
<br />
<p>Go netpoll<br />
一个典型的 Go TCP server:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
	“fmt”<br />
	“net”<br />
)</p><br />
<br />
<p>func main() {<br />
	listen, err := net.Listen(“tcp”, “:8888”)<br />
	if err != nil {<br />
		fmt.Println(“listen error: “, err)<br />
		return<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {<br />
	conn, err := listen.Accept()<br />
	if err != nil {<br />
		fmt.Println("accept error: ", err)<br />
		break<br />
	}<br />
<br />
	// start a new goroutine to handle the new connection<br />
	go HandleConn(conn)<br />
} } func HandleConn(conn net.Conn) {<br />
defer conn.Close()<br />
packet := make([]byte, 1024)<br />
for {<br />
	// 如果没有可读数据，也就是读 buffer 为空，则阻塞<br />
	_, _ = conn.Read(packet)<br />
	// 同理，不可写则阻塞<br />
	_, _ = conn.Write(packet)<br />
} } 上面是一个基于 Go 原生网络模型（基于 netpoll）编写的一个 TCP server，模式是 goroutine-per-connection，在这种模式下，开发者使用的是同步的模式去编写异步的逻辑而且对于开发者来说 I/O 是否阻塞是无感知的，也就是说开发者无需考虑 goroutines 甚至更底层的线程、进程的调度和上下文切换。而 Go netpoll 最底层的事件驱动技术肯定是基于 epoll/kqueue/iocp 这一类的 I/O 事件驱动技术，只不过是把这些调度和上下文切换的工作转移到了 runtime 的 Go scheduler，让它来负责调度 goroutines，从而极大地降低了程序员的心智负担！<br />
</code></pre></div></div><br />
<br />
<p>Go netpoll 核心</p><br />
<br />
<p>Go netpoll 通过在底层对 epoll/kqueue/iocp 的封装，从而实现了使用同步编程模式达到异步执行的效果。总结来说，所有的网络操作都以网络描述符 netFD 为中心实现。netFD 与底层 PollDesc 结构绑定，当在一个 netFD 上读写遇到 EAGAIN 错误时，就将当前 goroutine 存储到这个 netFD 对应的 PollDesc 中，同时调用 gopark 把当前 goroutine 给 park 住，直到这个 netFD 上再次发生读写事件，才将此 goroutine 给 ready 激活重新运行。显然，在底层通知 goroutine 再次发生读写等事件的方式就是 epoll/kqueue/iocp 等事件驱动机制。</p><br />
<br />
<p>接下来我们通过分析最新的 Go 源码（v1.13.4），解读一下整个 netpoll 的运行流程。</p><br />
<br />
<p>上面的示例代码中相关的在源码里的几个数据结构和方法：</p><br />
<br />
<p>// TCPListener is a TCP network listener. Clients should typically<br />
// use variables of type Listener instead of assuming TCP.<br />
type TCPListener struct {<br />
	fd *netFD<br />
	lc ListenConfig<br />
}</p><br />
<br />
<p>// Accept implements the Accept method in the Listener interface; it<br />
// waits for the next call and returns a generic Conn.<br />
func (l *TCPListener) Accept() (Conn, error) {<br />
	if !l.ok() {<br />
		return nil, syscall.EINVAL<br />
	}<br />
	c, err := l.accept()<br />
	if err != nil {<br />
		return nil, &amp;OpError{Op: “accept”, Net: l.fd.net, Source: nil, Addr: l.fd.laddr, Err: err}<br />
	}<br />
	return c, nil<br />
}</p><br />
<br />
<p>func (ln <em>TCPListener) accept() (</em>TCPConn, error) {<br />
	fd, err := ln.fd.accept()<br />
	if err != nil {<br />
		return nil, err<br />
	}<br />
	tc := newTCPConn(fd)<br />
	if ln.lc.KeepAlive &gt;= 0 {<br />
		setKeepAlive(fd, true)<br />
		ka := ln.lc.KeepAlive<br />
		if ln.lc.KeepAlive == 0 {<br />
			ka = defaultTCPKeepAlive<br />
		}<br />
		setKeepAlivePeriod(fd, ka)<br />
	}<br />
	return tc, nil<br />
}</p><br />
<br />
<p>// TCPConn is an implementation of the Conn interface for TCP network<br />
// connections.<br />
type TCPConn struct {<br />
	conn<br />
}</p><br />
<br />
<p>// Conn<br />
type conn struct {<br />
	fd *netFD<br />
}</p><br />
<br />
<p>type conn struct {<br />
	fd *netFD<br />
}</p><br />
<br />
<p>func (c *conn) ok() bool { return c != nil &amp;&amp; c.fd != nil }</p><br />
<br />
<p>// Implementation of the Conn interface.</p><br />
<br />
<p>// Read implements the Conn Read method.<br />
func (c *conn) Read(b []byte) (int, error) {<br />
	if !c.ok() {<br />
		return 0, syscall.EINVAL<br />
	}<br />
	n, err := c.fd.Read(b)<br />
	if err != nil &amp;&amp; err != io.EOF {<br />
		err = &amp;OpError{Op: “read”, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}<br />
	}<br />
	return n, err<br />
}</p><br />
<br />
<p>// Write implements the Conn Write method.<br />
func (c *conn) Write(b []byte) (int, error) {<br />
	if !c.ok() {<br />
		return 0, syscall.EINVAL<br />
	}<br />
	n, err := c.fd.Write(b)<br />
	if err != nil {<br />
		err = &amp;OpError{Op: “write”, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}<br />
	}<br />
	return n, err<br />
}<br />
netFD<br />
net.Listen(“tcp”, “:8888”) 方法返回了一个 *TCPListener，它是一个实现了 net.Listener 接口的 struct，而通过 listen.Accept() 接收的新连接 *TCPConn 则是一个实现了 net.Conn 接口的 struct，它内嵌了 net.conn struct。仔细阅读上面的源码可以发现，不管是 Listener 的 Accept 还是 Conn 的 Read/Write 方法，都是基于一个 netFD 的数据结构的操作，netFD 是一个网络描述符，类似于 Linux 的文件描述符的概念，netFD 中包含一个 poll.FD 数据结构，而 poll.FD 中包含两个重要的数据结构 Sysfd 和 pollDesc，前者是真正的系统文件描述符，后者对是底层事件驱动的封装，所有的读写超时等操作都是通过调用后者的对应方法实现的。</p><br />
<br />
<p>netFD和poll.FD的源码：</p><br />
<br />
<p>// Network file descriptor.<br />
type netFD struct {<br />
	pfd poll.FD</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// immutable until Close<br />
family      int<br />
sotype      int<br />
isConnected bool // handshake completed or use of association with peer<br />
net         string<br />
laddr       Addr<br />
raddr       Addr }<br />
</code></pre></div></div><br />
<br />
<p>// FD is a file descriptor. The net and os packages use this type as a<br />
// field of a larger type representing a network connection or OS file.<br />
type FD struct {<br />
	// Lock sysfd and serialize access to Read and Write methods.<br />
	fdmu fdMutex</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// System file descriptor. Immutable until Close.<br />
Sysfd int<br />
<br />
// I/O poller.<br />
pd pollDesc<br />
<br />
// Writev cache.<br />
iovecs *[]syscall.Iovec<br />
<br />
// Semaphore signaled when file is closed.<br />
csema uint32<br />
<br />
// Non-zero if this file has been set to blocking mode.<br />
isBlocking uint32<br />
<br />
// Whether this is a streaming descriptor, as opposed to a<br />
// packet-based descriptor like a UDP socket. Immutable.<br />
IsStream bool<br />
<br />
// Whether a zero byte read indicates EOF. This is false for a<br />
// message based socket connection.<br />
ZeroReadIsEOF bool<br />
<br />
// Whether this is a file rather than a network socket.<br />
isFile bool } pollDesc 前面提到了 pollDesc 是底层事件驱动的封装，netFD 通过它来完成各种 I/O 相关的操作，它的定义如下：<br />
</code></pre></div></div><br />
<br />
<p>type pollDesc struct {<br />
	runtimeCtx uintptr<br />
}<br />
这里的 struct 只包含了一个指针，而通过 pollDesc 的 init 方法，我们可以找到它具体的定义是在runtime.pollDesc这里：</p><br />
<br />
<p>func (pd *pollDesc) init(fd *FD) error {<br />
	serverInit.Do(runtime_pollServerInit)<br />
	ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))<br />
	if errno != 0 {<br />
		if ctx != 0 {<br />
			runtime_pollUnblock(ctx)<br />
			runtime_pollClose(ctx)<br />
		}<br />
		return syscall.Errno(errno)<br />
	}<br />
	pd.runtimeCtx = ctx<br />
	return nil<br />
}</p><br />
<br />
<p>// Network poller descriptor.<br />
//<br />
// No heap pointers.<br />
//<br />
//go:notinheap<br />
type pollDesc struct {<br />
	link *pollDesc // in pollcache, protected by pollcache.lock</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// The lock protects pollOpen, pollSetDeadline, pollUnblock and deadlineimpl operations.<br />
// This fully covers seq, rt and wt variables. fd is constant throughout the PollDesc lifetime.<br />
// pollReset, pollWait, pollWaitCanceled and runtime·netpollready (IO readiness notification)<br />
// proceed w/o taking the lock. So closing, everr, rg, rd, wg and wd are manipulated<br />
// in a lock-free way by all operations.<br />
// NOTE(dvyukov): the following code uses uintptr to store *g (rg/wg),<br />
// that will blow up when GC starts moving objects.<br />
lock    mutex // protects the following fields<br />
fd      uintptr<br />
closing bool<br />
everr   bool    // marks event scanning error happened<br />
user    uint32  // user settable cookie<br />
rseq    uintptr // protects from stale read timers<br />
rg      uintptr // pdReady, pdWait, G waiting for read or nil<br />
rt      timer   // read deadline timer (set if rt.f != nil)<br />
rd      int64   // read deadline<br />
wseq    uintptr // protects from stale write timers<br />
wg      uintptr // pdReady, pdWait, G waiting for write or nil<br />
wt      timer   // write deadline timer<br />
wd      int64   // write deadline } runtime.pollDesc包含自身类型的一个指针，用来保存下一个runtime.pollDesc的地址，以此来实现链表，可以减少数据结构的大小，所有的runtime.pollDesc保存在runtime.pollCache结构中，定义如下：<br />
</code></pre></div></div><br />
<br />
<p>type pollCache struct {<br />
   lock  mutex<br />
   first *pollDesc<br />
   // PollDesc objects must be type-stable,<br />
   // because we can get ready notification from epoll/kqueue<br />
   // after the descriptor is closed/reused.<br />
   // Stale notifications are detected using seq variable,<br />
   // seq is incremented when deadlines are changed or descriptor is reused.<br />
}<br />
net.Listen<br />
调用 net.Listen之后，底层会通过 Linux 的系统调用socket 方法创建一个 fd 分配给 listener，并用以来初始化 listener 的 netFD，接着调用 netFD 的listenStream方法完成对 socket 的 bind&amp;listen 操作以及对 netFD 的初始化（主要是对 netFD 里的 pollDesc 的初始化），相关源码如下：</p><br />
<br />
<p>// 调用 linux 系统调用 socket 创建 listener fd 并设置为为阻塞 I/O	<br />
s, err := socketFunc(family, sotype|syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC, proto)<br />
// On Linux the SOCK_NONBLOCK and SOCK_CLOEXEC flags were<br />
// introduced in 2.6.27 kernel and on FreeBSD both flags were<br />
// introduced in 10 kernel. If we get an EINVAL error on Linux<br />
// or EPROTONOSUPPORT error on FreeBSD, fall back to using<br />
// socket without them.</p><br />
<br />
<p>socketFunc        func(int, int, int) (int, error)  = syscall.Socket</p><br />
<br />
<p>// 用上面创建的 listener fd 初始化 listener netFD<br />
if fd, err = newFD(s, family, sotype, net); err != nil {<br />
	poll.CloseFunc(s)<br />
	return nil, err<br />
}</p><br />
<br />
<p>// 对 listener fd 进行 bind&amp;listen 操作，并且调用 init 方法完成初始化<br />
func (fd *netFD) listenStream(laddr sockaddr, backlog int, ctrlFn func(string, string, syscall.RawConn) error) error {<br />
	// …</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 完成绑定操作<br />
if err = syscall.Bind(fd.pfd.Sysfd, lsa); err != nil {<br />
	return os.NewSyscallError("bind", err)<br />
}<br />
  <br />
// 完成监听操作<br />
if err = listenFunc(fd.pfd.Sysfd, backlog); err != nil {<br />
	return os.NewSyscallError("listen", err)<br />
}<br />
  <br />
// 调用 init，内部会调用 poll.FD.Init，最后调用 pollDesc.init<br />
if err = fd.init(); err != nil {<br />
	return err<br />
}<br />
lsa, _ = syscall.Getsockname(fd.pfd.Sysfd)<br />
fd.setAddr(fd.addrFunc()(lsa), nil)<br />
return nil }<br />
</code></pre></div></div><br />
<br />
<p>// 使用 sync.Once 来确保一个 listener 只持有一个 epoll 实例<br />
var serverInit sync.Once</p><br />
<br />
<p>// netFD.init 会调用 poll.FD.Init 并最终调用到 pollDesc.init，<br />
// 它会创建 epoll 实例并把 listener fd 加入监听队列<br />
func (pd *pollDesc) init(fd *FD) error {<br />
  // runtime_pollServerInit 内部调用了 netpollinit 来创建 epoll 实例<br />
	serverInit.Do(runtime_pollServerInit)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// runtime_pollOpen 内部调用了 netpollopen 来将 listener fd 注册到 <br />
// epoll 实例中，另外，它会初始化一个 pollDesc 并返回<br />
ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd))<br />
if errno != 0 {<br />
	if ctx != 0 {<br />
		runtime_pollUnblock(ctx)<br />
		runtime_pollClose(ctx)<br />
	}<br />
	return syscall.Errno(errno)<br />
}<br />
// 把真正初始化完成的 pollDesc 实例赋值给当前的 pollDesc 代表自身的指针，<br />
// 后续使用直接通过该指针操作<br />
pd.runtimeCtx = ctx<br />
return nil }<br />
</code></pre></div></div><br />
<br />
<p>// netpollopen 会被 runtime_pollOpen，注册 fd 到 epoll 实例，<br />
// 同时会利用万能指针把 pollDesc 保存到 epollevent 的一个 8 位的字节数组 data 里<br />
func netpollopen(fd uintptr, pd *pollDesc) int32 {<br />
	var ev epollevent<br />
	ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET<br />
	*(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd<br />
	return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;ev)<br />
}<br />
我们前面提到的 epoll 的三个基本调用，Go 在源码里实现了对那三个调用的封装：</p><br />
<br />
<p>#include &lt;sys/epoll.h&gt;<br /><br />
int epoll_create(int size);<br /><br />
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);<br /><br />
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p><br />
<br />
<p>// Go 对上面三个调用的封装<br />
func netpollinit()<br />
func netpollopen(fd uintptr, pd *pollDesc) int32<br />
func netpoll(block bool) gList<br />
netFD 就是通过这三个封装来对 epoll 进行创建实例、注册 fd 和等待事件操作的。</p><br />
<br />
<p>Listener.Accept()<br />
netpoll accept socket 的工作流程如下：</p><br />
<br />
<p>服务端的 netFD 在listen时会创建 epoll 的实例，并将 listenerFD 加入 epoll 的事件队列<br />
netFD 在accept时将返回的 connFD 也加入 epoll 的事件队列<br />
netFD 在读写时出现syscall.EAGAIN错误，通过 pollDesc 的 waitRead 方法将当前的 goroutine park 住，直到 ready，从 pollDesc 的waitRead中返回<br />
Listener.Accept()接收来自客户端的新连接，具体还是调用netFD.accept方法来完成这个功能：</p><br />
<br />
<p>// Accept implements the Accept method in the Listener interface; it<br />
// waits for the next call and returns a generic Conn.<br />
func (l *TCPListener) Accept() (Conn, error) {<br />
	if !l.ok() {<br />
		return nil, syscall.EINVAL<br />
	}<br />
	c, err := l.accept()<br />
	if err != nil {<br />
		return nil, &amp;OpError{Op: “accept”, Net: l.fd.net, Source: nil, Addr: l.fd.laddr, Err: err}<br />
	}<br />
	return c, nil<br />
}</p><br />
<br />
<p>func (ln <em>TCPListener) accept() (</em>TCPConn, error) {<br />
	fd, err := ln.fd.accept()<br />
	if err != nil {<br />
		return nil, err<br />
	}<br />
	tc := newTCPConn(fd)<br />
	if ln.lc.KeepAlive &gt;= 0 {<br />
		setKeepAlive(fd, true)<br />
		ka := ln.lc.KeepAlive<br />
		if ln.lc.KeepAlive == 0 {<br />
			ka = defaultTCPKeepAlive<br />
		}<br />
		setKeepAlivePeriod(fd, ka)<br />
	}<br />
	return tc, nil<br />
}<br />
而netFD.accept方法里再调用poll.FD.Accept，最后会使用 Linux 的系统调用accept来完成新连接的接收，并且会把 accept 的 socket 设置成非阻塞 I/O 模式：</p><br />
<br />
<p>// Accept wraps the accept network call.<br />
func (fd *FD) Accept() (int, syscall.Sockaddr, string, error) {<br />
	if err := fd.readLock(); err != nil {<br />
		return -1, nil, “”, err<br />
	}<br />
	defer fd.readUnlock()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if err := fd.pd.prepareRead(fd.isFile); err != nil {<br />
	return -1, nil, "", err<br />
}<br />
for {<br />
	// 使用 linux 系统调用 accept 接收新连接，创建对应的 socket<br />
	s, rsa, errcall, err := accept(fd.Sysfd)<br />
	// 因为 listener fd 在创建的时候已经设置成非阻塞的了，<br />
	// 所以 accept 方法会直接返回，不管有没有新连接到来；如果 err == nil 则表示正常建立新连接，直接返回<br />
	if err == nil {<br />
		return s, rsa, "", err<br />
	}<br />
	// 如果 err != nil，则判断 err == syscall.EAGAIN，符合条件则进入 pollDesc.waitRead 方法<br />
	switch err {<br />
	case syscall.EAGAIN:<br />
		if fd.pd.pollable() {<br />
			// 如果当前没有发生期待的 I/O 事件，那么 waitRead 会通过 park goroutine 让逻辑 block 在这里<br />
			if err = fd.pd.waitRead(fd.isFile); err == nil {<br />
				continue<br />
			}<br />
		}<br />
	case syscall.ECONNABORTED:<br />
		// This means that a socket on the listen<br />
		// queue was closed before we Accept()ed it;<br />
		// it's a silly error, so try again.<br />
		continue<br />
	}<br />
	return -1, nil, errcall, err<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>// 使用 linux 的 accept 系统调用接收新连接并把这个 socket fd 设置成非阻塞 I/O<br />
ns, sa, err := Accept4Func(s, syscall.SOCK_NONBLOCK|syscall.SOCK_CLOEXEC)<br />
// On Linux the accept4 system call was introduced in 2.6.28<br />
// kernel and on FreeBSD it was introduced in 10 kernel. If we<br />
// get an ENOSYS error on both Linux and FreeBSD, or EINVAL<br />
// error on Linux, fall back to using accept.</p><br />
<br />
<p>// Accept4Func is used to hook the accept4 call.<br />
var Accept4Func func(int, int) (int, syscall.Sockaddr, error) = syscall.Accept4<br />
pollDesc.waitRead方法主要负责检测当前这个 pollDesc 的上层 netFD 对应的 fd 是否有『期待的』I/O 事件发生，如果有就直接返回，否则就 park 住当前的 goroutine 并持续等待直至对应的 fd 上发生可读/可写或者其他『期待的』I/O 事件为止，然后它就会返回到外层的 for 循环，让 goroutine 继续执行逻辑。</p><br />
<br />
<p>Conn.Read/Conn.Write<br />
我们先来看看Conn.Read方法是如何实现的，原理其实和 Listener.Accept 是一样的，具体调用链还是首先调用 conn 的netFD.Read ，然后内部再调用 poll.FD.Read，最后使用 Linux 的系统调用 read: syscall.Read完成数据读取：</p><br />
<br />
<p>// Implementation of the Conn interface.</p><br />
<br />
<p>// Read implements the Conn Read method.<br />
func (c *conn) Read(b []byte) (int, error) {<br />
	if !c.ok() {<br />
		return 0, syscall.EINVAL<br />
	}<br />
	n, err := c.fd.Read(b)<br />
	if err != nil &amp;&amp; err != io.EOF {<br />
		err = &amp;OpError{Op: “read”, Net: c.fd.net, Source: c.fd.laddr, Addr: c.fd.raddr, Err: err}<br />
	}<br />
	return n, err<br />
}</p><br />
<br />
<p>func (fd *netFD) Read(p []byte) (n int, err error) {<br />
	n, err = fd.pfd.Read(p)<br />
	runtime.KeepAlive(fd)<br />
	return n, wrapSyscallError(“read”, err)<br />
}</p><br />
<br />
<p>// Read implements io.Reader.<br />
func (fd *FD) Read(p []byte) (int, error) {<br />
	if err := fd.readLock(); err != nil {<br />
		return 0, err<br />
	}<br />
	defer fd.readUnlock()<br />
	if len(p) == 0 {<br />
		// If the caller wanted a zero byte read, return immediately<br />
		// without trying (but after acquiring the readLock).<br />
		// Otherwise syscall.Read returns 0, nil which looks like<br />
		// io.EOF.<br />
		// TODO(bradfitz): make it wait for readability? (Issue 15735)<br />
		return 0, nil<br />
	}<br />
	if err := fd.pd.prepareRead(fd.isFile); err != nil {<br />
		return 0, err<br />
	}<br />
	if fd.IsStream &amp;&amp; len(p) &gt; maxRW {<br />
		p = p[:maxRW]<br />
	}<br />
	for {<br />
		// 尝试从该 socket 读取数据，因为 socket 在被 listener accept 的时候设置成<br />
		// 了非阻塞 I/O，所以这里同样也是直接返回，不管有没有可读的数据<br />
		n, err := syscall.Read(fd.Sysfd, p)<br />
		if err != nil {<br />
			n = 0<br />
			// err == syscall.EAGAIN 表示当前没有期待的 I/O 事件发生，也就是 socket 不可读<br />
			if err == syscall.EAGAIN &amp;&amp; fd.pd.pollable() {<br />
				// 如果当前没有发生期待的 I/O 事件，那么 waitRead <br />
				// 会通过 park goroutine 让逻辑 block 在这里<br />
				if err = fd.pd.waitRead(fd.isFile); err == nil {<br />
					continue<br />
				}<br />
			}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		// On MacOS we can see EINTR here if the user<br />
		// pressed ^Z.  See issue #22838.<br />
		if runtime.GOOS == "darwin" &amp;&amp; err == syscall.EINTR {<br />
			continue<br />
		}<br />
	}<br />
	err = fd.eofError(n, err)<br />
	return n, err<br />
} } conn.Write和conn.Read的原理是一致的，它也是通过类似 pollDesc.waitRead的pollDesc.waitWrite来 park 住 goroutine 直至期待的 I/O 事件发生才返回，而 pollDesc.waitWrite的内部实现原理和pollDesc.waitRead是一样的，都是基于runtime_pollWait，这里就不再赘述。<br />
</code></pre></div></div><br />
<br />
<p>pollDesc.waitRead<br />
pollDesc.waitRead内部调用了 runtime_pollWait来达成无 I/O 事件时 park 住 goroutine 的目的：</p><br />
<br />
<p>//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait<br />
func poll_runtime_pollWait(pd *pollDesc, mode int) int {<br />
	err := netpollcheckerr(pd, int32(mode))<br />
	if err != 0 {<br />
		return err<br />
	}<br />
	// As for now only Solaris, illumos, and AIX use level-triggered IO.<br />
	if GOOS == “solaris” || GOOS == “illumos” || GOOS == “aix” {<br />
		netpollarm(pd, mode)<br />
	}<br />
	// 进入 netpollblock 并且判断是否有期待的 I/O 事件发生，<br />
	// 这里的 for 循环是为了一直等到 io ready<br />
	for !netpollblock(pd, int32(mode), false) {<br />
		err = netpollcheckerr(pd, int32(mode))<br />
		if err != 0 {<br />
			return err<br />
		}<br />
		// Can happen if timeout has fired and unblocked us,<br />
		// but before we had a chance to run, timeout has been reset.<br />
		// Pretend it has not happened and retry.<br />
	}<br />
	return 0<br />
}</p><br />
<br />
<p>// returns true if IO is ready, or false if timedout or closed<br />
// waitio - wait only for completed IO, ignore errors<br />
func netpollblock(pd *pollDesc, mode int32, waitio bool) bool {<br />
	// gpp 保存的是 goroutine 的数据结构 g，这里会根据 mode 的值决定是 rg 还是 wg<br />
	// 后面调用 gopark 之后，会把当前的 goroutine 的抽象数据结构 g 存入 gpp 这个指针<br />
	gpp := &amp;pd.rg<br />
	if mode == ‘w’ {<br />
		gpp = &amp;pd.wg<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// set the gpp semaphore to WAIT<br />
// 这个 for 循环是为了等待 io ready 或者 io wait<br />
for {<br />
	old := *gpp<br />
	// gpp == pdReady 表示此时已有期待的 I/O 事件发生，<br />
	// 可以直接返回 unblock 当前 goroutine 并执行响应的 I/O 操作<br />
	if old == pdReady {<br />
		*gpp = 0<br />
		return true<br />
	}<br />
	if old != 0 {<br />
		throw("runtime: double wait")<br />
	}<br />
	// 如果没有期待的 I/O 事件发生，则通过原子操作把 gpp 的值置为 pdWait 并退出 for 循环<br />
	if atomic.Casuintptr(gpp, 0, pdWait) {<br />
		break<br />
	}<br />
}<br />
<br />
// need to recheck error states after setting gpp to WAIT<br />
// this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl<br />
// do the opposite: store to closing/rd/wd, membarrier, load of rg/wg<br />
  <br />
// waitio 此时是 false，netpollcheckerr 方法会检查当前 pollDesc 对应的 fd 是否是正常的，<br />
// 通常来说  netpollcheckerr(pd, mode) == 0 是成立的，所以这里会执行 gopark <br />
// 把当前 goroutine 给 park 住，直至对应的 fd 上发生可读/可写或者其他『期待的』I/O 事件为止，<br />
// 然后 unpark 返回，在 gopark 内部会把当前 goroutine 的抽象数据结构 g 存入<br />
// gpp(pollDesc.rg/pollDesc.wg) 指针里，以便在后面的 netpoll 函数取出 pollDesc 之后，<br />
// 把 g 添加到链表里返回，接着重新调度 goroutine<br />
if waitio || netpollcheckerr(pd, mode) == 0 {<br />
	// 注册 netpollblockcommit 回调给 gopark，在 gopark 内部会执行它，保存当前 goroutine 到 gpp<br />
	gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5)<br />
}<br />
// be careful to not lose concurrent READY notification<br />
old := atomic.Xchguintptr(gpp, 0)<br />
if old &gt; pdWait {<br />
	throw("runtime: corrupted polldesc")<br />
}<br />
return old == pdReady }<br />
</code></pre></div></div><br />
<br />
<p>// gopark 会停住当前的 goroutine 并且调用传递进来的回调函数 unlockf，从上面的源码我们可以知道这个函数是<br />
// netpollblockcommit<br />
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {<br />
	if reason != waitReasonSleep {<br />
		checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy<br />
	}<br />
	mp := acquirem()<br />
	gp := mp.curg<br />
	status := readgstatus(gp)<br />
	if status != _Grunning &amp;&amp; status != _Gscanrunning {<br />
		throw(“gopark: bad g status”)<br />
	}<br />
	mp.waitlock = lock<br />
	mp.waitunlockf = unlockf<br />
	gp.waitreason = reason<br />
	mp.waittraceev = traceEv<br />
	mp.waittraceskip = traceskip<br />
	releasem(mp)<br />
	// can’t do anything that might move the G between Ms here.<br />
  // gopark 最终会调用 park_m，在这个函数内部会调用 unlockf，也就是 netpollblockcommit，<br />
	// 然后会把当前的 goroutine，也就是 g 数据结构保存到 pollDesc 的 rg 或者 wg 指针里<br />
	mcall(park_m)<br />
}</p><br />
<br />
<p>// park continuation on g0.<br />
func park_m(gp *g) {<br />
	<em>g</em> := getg()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if trace.enabled {<br />
	traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)<br />
}<br />
<br />
casgstatus(gp, _Grunning, _Gwaiting)<br />
dropg()<br />
<br />
if fn := _g_.m.waitunlockf; fn != nil {<br />
	// 调用 netpollblockcommit，把当前的 goroutine，<br />
	// 也就是 g 数据结构保存到 pollDesc 的 rg 或者 wg 指针里<br />
	ok := fn(gp, _g_.m.waitlock)<br />
	_g_.m.waitunlockf = nil<br />
	_g_.m.waitlock = nil<br />
	if !ok {<br />
		if trace.enabled {<br />
			traceGoUnpark(gp, 2)<br />
		}<br />
		casgstatus(gp, _Gwaiting, _Grunnable)<br />
		execute(gp, true) // Schedule it back, never returns.<br />
	}<br />
}<br />
schedule() }<br />
</code></pre></div></div><br />
<br />
<p>// netpollblockcommit 在 gopark 函数里被调用<br />
func netpollblockcommit(gp <em>g, gpp unsafe.Pointer) bool {<br />
	// 通过原子操作把当前 goroutine 抽象的数据结构 g，也就是这里的参数 gp 存入 gpp 指针，<br />
	// 此时 gpp 的值是 pollDesc 的 rg 或者 wg 指针<br />
	r := atomic.Casuintptr((</em>uintptr)(gpp), pdWait, uintptr(unsafe.Pointer(gp)))<br />
	if r {<br />
		// Bump the count of goroutines waiting for the poller.<br />
		// The scheduler uses this to decide whether to block<br />
		// waiting for the poller if there is nothing else to do.<br />
		atomic.Xadd(&amp;netpollWaiters, 1)<br />
	}<br />
	return r<br />
}<br />
netpoll<br />
前面已经从源码的角度分析完了 netpoll 是如何通过 park goroutine 从而达到阻塞 Accept/Read/Write 的效果，而通过调用 gopark，goroutine 会被放置在某个等待队列中(如 channel 的 waitq ，此时 G 的状态由_Grunning为_Gwaitting)，因此 G 必须被手动唤醒(通过 goready )，否则会丢失任务，应用层阻塞通常使用这种方式。</p><br />
<br />
<p>所以，最后还有一个非常关键的问题是：当 I/O 事件发生之后，netpoll 是通过什么方式唤醒那些在 I/O wait 的 goroutine 的？答案是通过 epoll_wait，在 Go 源码中的 src/runtime/netpoll_epoll.go文件中有一个 func netpoll(block bool) gList 方法，它会内部调用epoll_wait获取就绪的 fd 列表，并将每个 fd 对应的 goroutine 添加到链表返回：</p><br />
<br />
<p>// polls for ready network connections<br />
// returns list of goroutines that become runnable<br />
func netpoll(block bool) gList {<br />
	if epfd == -1 {<br />
		return gList{}<br />
	}<br />
	waitms := int32(-1)<br />
	// 是否以阻塞模式调用 epoll_wait<br />
	if !block {<br />
		waitms = 0<br />
	}<br />
	var events [128]epollevent<br />
retry:<br />
	// 获取就绪的 fd 列表<br />
	n := epollwait(epfd, &amp;events[0], int32(len(events)), waitms)<br />
	if n &lt; 0 {<br />
		if n != -_EINTR {<br />
			println(“runtime: epollwait on fd”, epfd, “failed with”, -n)<br />
			throw(“runtime: netpoll failed”)<br />
		}<br />
		goto retry<br />
	}<br />
	// toRun 是一个 g 的链表，存储要恢复的 goroutines，最后返回给调用方<br />
	var toRun gList<br />
	for i := int32(0); i &lt; n; i++ {<br />
		ev := &amp;events[i]<br />
		if ev.events == 0 {<br />
			continue<br />
		}<br />
		var mode int32<br />
		// 判断发生的事件类型，读类型或者写类型<br />
		if ev.events&amp;(_EPOLLIN|_EPOLLRDHUP|_EPOLLHUP|_EPOLLERR) != 0 {<br />
			mode += ‘r’<br />
		}<br />
		if ev.events&amp;(_EPOLLOUT|_EPOLLHUP|_EPOLLERR) != 0 {<br />
			mode += ‘w’<br />
		}<br />
		if mode != 0 {<br />
			// 取出保存在 epollevent 里的 pollDesc<br />
			pd := *(**pollDesc)(unsafe.Pointer(&amp;ev.data))<br />
			pd.everr = false<br />
			if ev.events == _EPOLLERR {<br />
				pd.everr = true<br />
			}<br />
			// 调用 netpollready，传入就绪 fd 的 pollDesc，把 fd 对应的 goroutine 添加到链表 toRun 中<br />
			netpollready(&amp;toRun, pd, mode)<br />
		}<br />
	}<br />
	if block &amp;&amp; toRun.empty() {<br />
		goto retry<br />
	}<br />
	return toRun<br />
}</p><br />
<br />
<p>// netpollready 调用 netpollunblock 返回就绪 fd 对应的 goroutine 的抽象数据结构 g<br />
func netpollready(toRun *gList, pd *pollDesc, mode int32) {<br />
	var rg, wg *g<br />
	if mode == ‘r’ || mode == ‘r’+’w’ {<br />
		rg = netpollunblock(pd, ‘r’, true)<br />
	}<br />
	if mode == ‘w’ || mode == ‘r’+’w’ {<br />
		wg = netpollunblock(pd, ‘w’, true)<br />
	}<br />
	if rg != nil {<br />
		toRun.push(rg)<br />
	}<br />
	if wg != nil {<br />
		toRun.push(wg)<br />
	}<br />
}</p><br />
<br />
<p>// netpollunblock 会依据传入的 mode 决定从 pollDesc 的 rg 或者 wg 取出当时 gopark 之时存入的<br />
// goroutine 抽象数据结构 g 并返回<br />
func netpollunblock(pd *pollDesc, mode int32, ioready bool) *g {<br />
	// mode == ‘r’ 代表当时 gopark 是为了等待读事件，而 mode == ‘w’ 则代表是等待写事件<br />
	gpp := &amp;pd.rg<br />
	if mode == ‘w’ {<br />
		gpp = &amp;pd.wg<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {<br />
	// 取出 gpp 存储的 g<br />
	old := *gpp<br />
	if old == pdReady {<br />
		return nil<br />
	}<br />
	if old == 0 &amp;&amp; !ioready {<br />
		// Only set READY for ioready. runtime_pollWait<br />
		// will check for timeout/cancel before waiting.<br />
		return nil<br />
	}<br />
	var new uintptr<br />
	if ioready {<br />
		new = pdReady<br />
	}<br />
	// 重置 pollDesc 的 rg 或者 wg<br />
	if atomic.Casuintptr(gpp, old, new) {<br />
		if old == pdReady || old == pdWait {<br />
			old = 0<br />
		}<br />
		// 通过万能指针还原成 g 并返回<br />
		return (*g)(unsafe.Pointer(old))<br />
	}<br />
} } 而 Go 在多种场景下都可能会调用netpoll检查文件描述符状态。寻找到 I/O 就绪的 socket fd，并找到这些 socket fd 对应的轮询器中附带的信息，根据这些信息将之前等待这些 socket fd 就绪的 goroutine 状态修改为 _Grunnable。执行完netpoll之后，会返回一个就绪 fd 列表对应的 goroutine 列表，接下来将就绪的 goroutine 加入到调度队列中，等待调度运行。<br />
</code></pre></div></div><br />
<br />
<p>首先，在 Go runtime scheduler 正常调度 goroutine 之时就有可能会调用netpoll获取到已就绪的 fd 对应的 goroutine 来调度执行：</p><br />
<br />
<p>// One round of scheduler: find a runnable goroutine and execute it.<br />
// Never returns.<br />
func schedule() {<br />
	// …</p><br />
<br />
<p>if gp == nil {<br />
		gp, inheritTime = findrunnable() // blocks until work is available<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ... }<br />
</code></pre></div></div><br />
<br />
<p>// Finds a runnable goroutine to execute.<br />
// Tries to steal from other P’s, get g from global queue, poll network.<br />
func findrunnable() (gp *g, inheritTime bool) {<br />
  // …</p><br />
<br />
<p>// Poll network.<br />
	// This netpoll is only an optimization before we resort to stealing.<br />
	// We can safely skip it if there are no waiters or a thread is blocked<br />
	// in netpoll already. If there is any kind of logical race with that<br />
	// blocked thread (e.g. it has already returned from netpoll, but does<br />
	// not set lastpoll yet), this thread will do blocking netpoll below<br />
	// anyway.<br />
	if netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; 0 &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != 0 {<br />
		if list := netpoll(false); !list.empty() { // non-blocking<br />
			gp := list.pop()<br />
			injectglist(&amp;list)<br />
			casgstatus(gp, _Gwaiting, _Grunnable)<br />
			if trace.enabled {<br />
				traceGoUnpark(gp, 0)<br />
			}<br />
			return gp, false<br />
		}<br />
	}</p><br />
<br />
<p>// …<br />
}<br />
Go scheduler 的核心方法schedule里会调用一个叫findrunable()的方法获取可运行的 goroutine 来执行，而在 findrunable()方法里就调用了netpoll获取已就绪的 fd 列表对应的 goroutine 列表。</p><br />
<br />
<p>另外， sysmon监控线程也可能会调用到netpoll：</p><br />
<br />
<p>// Always runs without a P, so write barriers are not allowed.<br />
//<br />
//go:nowritebarrierrec<br />
func sysmon() {<br />
		// …<br />
		now := nanotime()<br />
		if netpollinited() &amp;&amp; lastpoll != 0 &amp;&amp; lastpoll+10<em>1000</em>1000 &lt; now {<br />
			atomic.Cas64(&amp;sched.lastpoll, uint64(lastpoll), uint64(now))<br />
			// 以非阻塞的方式调用 netpoll 获取就绪 fd 列表<br />
			list := netpoll(false) // non-blocking - returns list of goroutines<br />
			if !list.empty() {<br />
				// Need to decrement number of idle locked M’s<br />
				// (pretending that one more is running) before injectglist.<br />
				// Otherwise it can lead to the following situation:<br />
				// injectglist grabs all P’s but before it starts M’s to run the P’s,<br />
				// another M returns from syscall, finishes running its G,<br />
				// observes that there is no work to do and no other running M’s<br />
				// and reports deadlock.<br />
				incidlelocked(-1)<br />
				// 将其插入调度器的runnable列表中（全局），等待被调度执行<br />
				injectglist(&amp;list)<br />
				incidlelocked(1)<br />
			}<br />
		}<br />
		// retake P’s blocked in syscalls<br />
		// and preempt long running G’s<br />
		if retake(now) != 0 {<br />
			idle = 0<br />
		} else {<br />
			idle++<br />
		}<br />
		// check if we need to force a GC<br />
		if t := (gcTrigger{kind: gcTriggerTime, now: now}); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != 0 {<br />
			lock(&amp;forcegc.lock)<br />
			forcegc.idle = 0<br />
			var list gList<br />
			list.push(forcegc.g)<br />
			injectglist(&amp;list)<br />
			unlock(&amp;forcegc.lock)<br />
		}<br />
		if debug.schedtrace &gt; 0 &amp;&amp; lasttrace+int64(debug.schedtrace)*1000000 &lt;= now {<br />
			lasttrace = now<br />
			schedtrace(debug.scheddetail &gt; 0)<br />
		}<br />
	}<br />
}<br />
Go runtime 在程序启动的时候会创建一个独立的 M 作为监控线程，叫sysmon，这个线程为系统级的 daemon 线程，无需 P 即可运行，sysmon每 20us~10ms 运行一次。sysmon中以轮询的方式执行以下操作（如上面的代码所示）：</p><br />
<br />
<p>以非阻塞的方式调用runtime.netpoll，从中找出能从网络 I/O 中唤醒的 G，并调用injectglist，将其插入调度器的 runnable 列表中（全局），调度触发时，有可能从这个全局 runnable 列表获取 G。然后再循环调用startm，直到所有 P 都不处于 _Pidle 状态。<br />
调用retake，抢占长时间处于_Psyscall状态的 P。<br />
综上，Go 借助于 epoll/kqueue/iocp 和 runtime scheduler 等的帮助，设计出了自己的 I/O 多路复用 netpoll，成功地让 Listener.Accept/conn.Read/conn.Write等方法从开发者的角度看来是同步模式。</p><br />
<br />
<p>Go netpoll 的价值<br />
通过前面对源码的分析，我们现在知道 Go netpoll 依托于 runtime scheduler，为开发者提供了一种强大的同步网络编程模式；然而，Go netpoll 存在的意义却远不止于此，Go netpoll I/O 多路复用搭配 Non-blocking I/O 而打造出来的这个原生网络模型，它最大的价值是把网络 I/O 的控制权牢牢掌握在 Go 自己的 runtime 里，关于这一点我们需要从 Go 的 runtime scheduler 说起，Go 的 G-P-M 调度模型如下：</p><br />
<br />
<p>G 在运行过程中如果被阻塞在某个 system call 操作上，那么不光 G 会阻塞，执行该 G 的 M 也会解绑 P(实质是被 sysmon 抢走了)，与 G 一起进入 sleep 状态。如果此时有 idle 的 M，则 P 与其绑定继续执行其他 G；如果没有 idle M，但仍然有其他 G 要去执行，那么就会创建一个新的 M。当阻塞在 system call 上的 G 完成 syscall 调用后，G 会去尝试获取一个可用的 P，如果没有可用的 P，那么 G 会被标记为_Grunnable并把它放入全局的 runqueue 中等待调度，之前的那个 sleep 的 M 将再次进入 sleep。</p><br />
<br />
<p>现在清楚为什么 netpoll 为什么一定要使用非阻塞 I/O 了吧？就是为了避免让操作网络 I/O 的 goroutine 陷入到系统调用从而进入内核态，因为一旦进入内核态，整个程序的控制权就会发生转移(到内核)，不再属于用户进程了，那么也就无法借助于 Go 强大的 runtime scheduler 来调度业务程序的并发了；而有了 netpoll 之后，借助于非阻塞 I/O ，G 就再也不会因为系统调用的读写而陷入内核态，当 G 被阻塞在某个 network I/O 操作上时，实际上它不是因为陷入内核态被阻塞住了，而是被 Go runtime 调用 gopark 给 park 住了，此时 G 会被放置到某个 wait queue 中，而 M 会尝试运行下一个_Grunnable的 G，如果此时没有_Grunnable的 G 供 M 运行，那么 M 将解绑 P，并进入 sleep 状态。当 I/O available，在 wait queue 中的 G 会被唤醒，标记为_Grunnable，放入某个可用的 P 的 local 队列中，绑定一个 M 恢复执行。</p><br />
<br />
<p>Go netpoll 的问题<br />
Go netpoll 的设计不可谓不精巧、性能也不可谓不高效，配合 goroutine 写网络程序是真的爽：简洁高效。然而，没有任何一种设计和架构是完美的，goroutine-per-connection这种模式虽然简单高效，但是在某些极端的场景下也会暴露出问题：goroutine 虽然非常轻量，它的自定义栈内存初始值仅为 2KB，后面按需扩容；海量连接的业务场景下，goroutine-per-connection，此时 goroutine 数量以及消耗的资源就会呈线性趋势暴涨，首先给 Go runtime scheduler 造成极大的压力和侵占系统资源，然后资源被侵占又反过来影响 runtime 的调度，导致性能大幅下降。</p><br />
<br />
<p>Reactor 模式<br />
目前在 Linux 平台下构建的高性能网络程序中，大都使用 Reactor 模式，比如 netty、libevent、libev、ACE，POE(Perl)、Twisted(Python)等。</p><br />
<br />
<p>Reactor 模式本质上指的是使用I/O 多路复用(I/O multiplexing) + 非阻塞 I/O(non-blocking I/O)的模式。</p><br />
<br />
<p>通常设置一个主线程负责做 event-loop 事件循环和 I/O 读写，通过 select/poll/epoll_wait 等系统调用监听 I/O 事件，业务逻辑提交给其他工作线程去做。而所谓『非阻塞 I/O』的核心思想是指避免阻塞在 read() 或者 write() 或者其他的 I/O 系统调用上，这样可以最大限度的复用 event-loop 线程，让一个线程能服务于多个 sockets。在 Reactor 模式中，I/O 线程只能阻塞在 I/O multiplexing 函数上（select/poll/epoll_wait）。</p><br />
<br />
<p>Reactor 模式通常的工作流程如下：</p><br />
<br />
<p>Server 端完成在bind&amp;listen之后，将 listenfd 注册到 epollfd 中，最后进入 event-loop 事件循环。循环过程中会调用select/poll/epoll_wait阻塞等待，若有在 listenfd 上的新连接事件则解除阻塞返回，并调用socket.accept接收新连接 connfd，并将 connfd 加入到 epollfd 的 I/O 复用（监听）队列。<br />
当 connfd 上发生可读/可写事件也会解除select/poll/epoll_wait的阻塞等待，然后进行 I/O 读写操作，这里读写 I/O 都是非阻塞 I/O，这样才不会阻塞 event-loop 的下一个循环。然而，这样容易割裂业务逻辑，不易理解和维护。<br />
调用read读取数据之后进行解码并放入队列中，等待工作线程处理。<br />
工作线程处理完数据之后，返回到 event-loop 线程，由这个线程负责调用write把数据写回 client。<br />
accept 连接以及 conn 上的读写操作若是在主线程完成，则要求是非阻塞 I/O，因为 Reactor 模式一条最重要的原则就是：I/O 操作不能阻塞 event-loop 事件循环。实际上 event loop 可能也可以是多线程的，只是一个线程里只有一个 select/poll/epoll_wait。</p><br />
<br />
<p>上面提到了 Go netpoll 在某些场景下可能因为创建太多的 goroutine 而过多地消耗系统资源，而在现实世界的网络业务中，服务器持有的海量连接中在极短的时间窗口内只有极少数是 active 而大多数则是 idle，就像这样（非真实数据，仅仅是为了比喻）：</p><br />
<br />
<p>那么为每一个连接指派一个 goroutine 就显得太过奢侈了，而 Reactor 模式这种利用 I/O 多路复用进而只需要使用少量线程即可管理海量连接的设计就可以在这样网络业务中大显身手了：</p><br />
<br />
<p>在绝大部分应用场景下，我推荐大家还是遵循 Go 的 best practices，以这种 netpoll 模式来构建自己的网络应用。然而，在某些极度追求性能、压榨系统资源以及技术栈必须是原生 Go （不考虑 C/C++ 写中间层而 Go 写业务层）的业务场景下，我们可以考虑自己构建 Reactor 网络模型。</p><br />
<br />
<p>gnet<br />
gnet 是一个基于事件驱动的高性能和轻量级网络框架，支持多种协议：TCP/UDP/Unix-Socket。它直接使用 epoll 和 kqueue 系统调用而非标准 Golang 网络包：net 来构建网络应用，它的工作原理类似两个开源的网络库：netty 和 libuv。</p><br />
<br />
<p>gnet 的亮点在于它是一个高性能、轻量级、非阻塞的纯 Go 实现的传输层（TCP/UDP/Unix-Socket）网络框架，开发者可以使用 gnet 来实现自己的应用层网络协议，从而构建出自己的应用层网络应用：比如在 gnet 上实现 HTTP 协议就可以创建出一个 HTTP 服务器 或者 Web 开发框架，实现 Redis 协议就可以创建出自己的 Redis 服务器等等。</p><br />
<br />
<p>gnet，在某些极端的网络业务场景，比如海量连接、高频创建销毁连接等等场景，gnet 在性能和资源占用上都远超 Go 原生的 net 包（基于 netpoll）。</p><br />
<br />
<p>gnet已经实现了Multi-Reactors和Multi-Reactors + Goroutine Pool两种网络模型，也得益于这些网络模型，使得gnet成为一个高性能和低损耗的 Go 网络框架：</p><br />
<br />
<p>🚀 功能<br />
 高性能 的基于多线程/Go 程网络模型的 event-loop 事件驱动<br />
 内置 Round-Robin 轮询负载均衡算法<br />
 内置 goroutine 池，由开源库 ants 提供支持<br />
 内置 bytes 内存池，由开源库 pool 提供支持<br />
 简洁的 APIs<br />
 基于 Ring-Buffer 的高效内存利用<br />
 支持多种网络协议：TCP、UDP、Unix Sockets<br />
 支持两种事件驱动机制：Linux 里的 epoll 以及 FreeBSD 里的 kqueue<br />
 支持异步写操作<br />
 灵活的事件定时器<br />
 SO_REUSEPORT 端口重用<br />
 内置多种编解码器，支持对 TCP 数据流分包：LineBasedFrameCodec, DelimiterBasedFrameCodec, FixedLengthFrameCodec 和 LengthFieldBasedFrameCodec，参考自 netty codec，而且支持自定制编解码器<br />
 支持 Windows 平台，基于 IOCP 事件驱动机制 Go 标准网络库<br />
 加入更多的负载均衡算法：随机、最少连接、一致性哈希等等<br />
 支持 TLS<br />
 实现 gnet 客户端<br />
参考<br />
Linux I/O模式及 select、poll、epoll详解<br />
IO多路复用与Go网络库的实现<br />
聊聊 Linux IO<br />
Go 调度模型<br />
linux 用户空间与内核空间——高端内存详解<br />
Goroutine 并发调度模型深度解析之手撸一个高性能协程池<br />
Go语言实现(2)：调度<br />
关于select函数中timeval和fd_set重新设置的问题<br />
也谈goroutine调度器</p><br />
<br />
<p>https://github.com/panjf2000/gnet</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>