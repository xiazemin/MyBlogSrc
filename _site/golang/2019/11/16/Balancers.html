<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">Balancers</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-11-16T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Nov 16, 2019</time></p>
					</div>
					 <p>Load Balancers plays a key role in Web Architecture. They allow distributing load among a set of backends. This makes services more scalable. Also since there are multiple backends configured the service become highly available as load balancer can pick up a working server in case of a failure.</p><br />
<br />
<p>After playing with professional Load Balancers like NGINX I tried creating a simple Load Balancer for fun. I implemented it using Golang. Go is a modern language which supports concurrency as a first-class citizen. Go has a rich standard library which allows writing high-performance applications with fewer lines of codes. It also produces a statically linked single binary for easy distributions.<br />
<!-- more --><br />
How does our simple load balancer work<br />
Load Balancers have different strategies for distributing the load across a set of backends.</p><br />
<br />
<p>For example,</p><br />
<br />
<p>Round Robin - Distribute load equally, assumes all backends have the same processing power<br />
Weighted Round Robin - Additional weights can be given considering the backend’s processing power<br />
Least Connections - Load is distributed to the servers with least active connections<br />
For our simple load balancer, we would try implementing the simplest one among these methods, Round Robin.</p><br />
<br />
<p>A Round Robin Load Balancer<br />
A Round Robin Load Balancer</p><br />
<br />
<p>Round Robin Selection<br />
Round Robin is simple in terms. It gives equal opportunities for workers to perform tasks in turns.</p><br />
<br />
<p>Round Robin Selection on incoming requests<br />
Round Robin Selection on incoming requests</p><br />
<br />
<p>As shown in the figure about this happens cyclically. But we can’t directly use that aren’t we?</p><br />
<br />
<p>What if a backend is down? We probably don’t want to route traffic there. So this cannot be directly used unless we put some conditions on it. We need to route traffic only to backends which are up and running.</p><br />
<br />
<p>Lets define some structs<br />
After revising the plan, we know now we want a way to track all the details about a Backend. We need to track whether it’s alive or dead and also keep track of the Url as well.</p><br />
<br />
<p>We can simply define a struct like this to hold our backends.</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
type Backend struct {<br />
  URL          *url.URL<br />
  Alive        bool<br />
  mux          sync.RWMutex<br />
  ReverseProxy *httputil.ReverseProxy<br />
}<br />
Don’t worry I will reason about the fields in the Backend.</p><br />
<br />
<p>Now we need a way to track all the backends in our load balancer, for that we can simply use a Slice. And also a counter variable. We can define it as ServerPool</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
type ServerPool struct {<br />
  backends []*Backend<br />
  current  uint64<br />
}<br />
Use of the ReverseProxy<br />
As we already identified, the sole purpose of the load balancer is to route traffic to different backends and return the results to the original client.</p><br />
<br />
<p>According to Go’s documentation,</p><br />
<br />
<p>ReverseProxy is an HTTP Handler that takes an incoming request and sends it to another server, proxying the response back to the client.</p><br />
<br />
<p>Which is exactly what we want. There is no need to reinvent the wheel. We can simply relay our original requests through the ReverseProxy.</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
u, _ := url.Parse(“http://localhost:8080”)<br />
rp := httputil.NewSingleHostReverseProxy(u)</p><br />
<br />
<p>// initialize your server and add this as handler<br />
http.HandlerFunc(rp.ServeHTTP)<br />
With httputil.NewSingleHostReverseProxy(url) we can initialize a reverse proxy which would relay requests to the passed url. In the above example, all the requests are now passed to localhost:8080 and the results are sent back to the original client. You can find more examples here.</p><br />
<br />
<p>If we take a look at ServeHTTP method signature, it has the signature of an HTTP handler, that’s why we could pass it to the HandlerFunc in http.</p><br />
<br />
<p>You can find more examples in docs.</p><br />
<br />
<p>For our simple load balancer we could initiate the ReverseProxy with the associated URL in the Backend, so that ReverseProxy will route our requests to the URL.</p><br />
<br />
<p>Selection Process<br />
We need to skip dead backends during the next pick. But to do anything we need a way to count.</p><br />
<br />
<p>Multiple clients will connect to the load balancer and when each of them requests a next peer to pass the traffic on race conditions could occur. To prevent it we could lock the ServerPool with a mutex. But that would be an overkill, besides we don’t want to lock the ServerPool at all. We just want to increase the counter by one</p><br />
<br />
<p>To meet that requirement, the ideal solution is to make this increment atomically. And Go supports that well via atomic package.</p><br />
<br />
<p>1<br />
2<br />
3<br />
func (s *ServerPool) NextIndex() int {<br />
  return int(atomic.AddUint64(&amp;s.current, uint64(1)) % uint64(len(s.backends)))<br />
}<br />
In here, we are increasing the current value by one atomically and returns the index by modding with the length of the slice. Which means the value always will be between 0 and length of the slice. In the end, we are interested in a particular index, not the total count.</p><br />
<br />
<p>Picking up an alive backend.<br />
We already know that our requests are routed in a cycle for each backend. All we have to skip dead ones, that’s it.</p><br />
<br />
<p>GetNext() always return a value that’s capped between 0 and the length of the slice. At any point, we get a next peer and if it’s not alive we would have to search through the slice in a cycle.</p><br />
<br />
<p>Traverse the slice as a cycle<br />
Traverse the slice as a cycle</p><br />
<br />
<p>As shown in the figure above, we want to traverse from next to the entire list, which can be done simply by traversing next + length But to pick an index, we want to cap it between slice length. It can be easily done with modding operation.</p><br />
<br />
<p>After we find a working backend through the search, we mark it as the current one.</p><br />
<br />
<p>Below you can see the code for the above operation.</p><br />
<br />
<p>1<br />
 2<br />
 3<br />
 4<br />
 5<br />
 6<br />
 7<br />
 8<br />
 9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
// GetNextPeer returns next active peer to take a connection<br />
func (s *ServerPool) GetNextPeer() *Backend {<br />
  // loop entire backends to find out an Alive backend<br />
  next := s.NextIndex()<br />
  l := len(s.backends) + next // start from next and move a full cycle<br />
  for i := next; i &lt; l; i++ {<br />
    idx := i % len(s.backends) // take an index by modding with length<br />
    // if we have an alive backend, use it and store if its not the original one<br />
    if s.backends[idx].IsAlive() {<br />
      if i != next {<br />
        atomic.StoreUint64(&amp;s.current, uint64(idx)) // mark the current one<br />
      }<br />
      return s.backends[idx]<br />
    }<br />
  }<br />
  return nil<br />
}<br />
Avoid Race Conditions in Backend struct<br />
There is a serious issue we need to consider. Our Backend structure has a variable which could be modified or accessed by different goroutines same time.</p><br />
<br />
<p>We know there would be more goroutines reading from this rather than writing to it. So we have picked RWMutex to serialize the access to the Alive.</p><br />
<br />
<p>1<br />
 2<br />
 3<br />
 4<br />
 5<br />
 6<br />
 7<br />
 8<br />
 9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
// SetAlive for this backend<br />
func (b *Backend) SetAlive(alive bool) {<br />
  b.mux.Lock()<br />
  b.Alive = alive<br />
  b.mux.Unlock()<br />
}</p><br />
<br />
<p>// IsAlive returns true when backend is alive<br />
func (b *Backend) IsAlive() (alive bool) {<br />
  b.mux.RLock()<br />
  alive = b.Alive<br />
  b.mux.RUnlock()<br />
  return<br />
}<br />
Lets load balance requests<br />
With all the background we created, we can formulate the following simple method to load balance our requests. It will only fail when our all backends are offline.</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
// lb load balances the incoming request<br />
func lb(w http.ResponseWriter, r *http.Request) {<br />
  peer := serverPool.GetNextPeer()<br />
  if peer != nil {<br />
    peer.ReverseProxy.ServeHTTP(w, r)<br />
    return<br />
  }<br />
  http.Error(w, “Service not available”, http.StatusServiceUnavailable)<br />
}<br />
This method can be simply passed as a HandlerFunc to the http server.</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
server := http.Server{<br />
  Addr:    fmt.Sprintf(“:%d”, port),<br />
  Handler: http.HandlerFunc(lb),<br />
}<br />
Route traffic only to healthy backends<br />
Our current lb has a serious issue. We don’t know if a backend is healthy or not. To know this we have to try out a backend and check whether it is alive.</p><br />
<br />
<p>We can do this in two ways,</p><br />
<br />
<p>Active: While performing the current request, we find the selected backend is unresponsive, mark it as down.<br />
Passive: We can ping backends on fixed intervals and check status<br />
Actively checking for healthy backends<br />
ReverseProxy triggers a callback function, ErrorHandler on any error. We can use that to detect any failure. Here is the implementation</p><br />
<br />
<p>1<br />
 2<br />
 3<br />
 4<br />
 5<br />
 6<br />
 7<br />
 8<br />
 9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
proxy.ErrorHandler = func(writer http.ResponseWriter, request *http.Request, e error) {<br />
  log.Printf(“[%s] %s\n”, serverUrl.Host, e.Error())<br />
  retries := GetRetryFromContext(request)<br />
  if retries &lt; 3 {<br />
    select {<br />
      case &lt;-time.After(10 * time.Millisecond):<br />
        ctx := context.WithValue(request.Context(), Retry, retries+1)<br />
        proxy.ServeHTTP(writer, request.WithContext(ctx))<br />
      }<br />
      return<br />
    }</p><br />
<br />
<p>// after 3 retries, mark this backend as down<br />
  serverPool.MarkBackendStatus(serverUrl, false)</p><br />
<br />
<p>// if the same request routing for few attempts with different backends, increase the count<br />
  attempts := GetAttemptsFromContext(request)<br />
  log.Printf(“%s(%s) Attempting retry %d\n”, request.RemoteAddr, request.URL.Path, attempts)<br />
  ctx := context.WithValue(request.Context(), Attempts, attempts+1)<br />
  lb(writer, request.WithContext(ctx))<br />
}<br />
In here we leverage the power of closures to design this error handler. It allows us to capture outer variables like server url into our method. It will check for existing retry count and if it is less than 3, we again send the same request to the same backend. The reason behind this is due to temporary errors the server may reject your requests and it may be available after a short delay(possibly the server ran out of sockets to accept more clients). So we have put a timer to delay the retry for around 10 milliseconds. We increases the retry count with every request.</p><br />
<br />
<p>After every retry failed, we mark this backend as down.</p><br />
<br />
<p>Next thing we want to do is attempting a new backend to the same request. We do it by keeping a count of the attempts using the context package. After increasing the attempt count, we pass it back to lb to pick a new peer to process the request.</p><br />
<br />
<p>Now we can’t do this indefinitely, thus we need to check from lb whether the maximum attempts already taken before processing the request further.</p><br />
<br />
<p>We can simply get the attempt count from the request and if it has exceeded the max count, eliminate the request.</p><br />
<br />
<p>1<br />
 2<br />
 3<br />
 4<br />
 5<br />
 6<br />
 7<br />
 8<br />
 9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
// lb load balances the incoming request<br />
func lb(w http.ResponseWriter, r *http.Request) {<br />
  attempts := GetAttemptsFromContext(r)<br />
  if attempts &gt; 3 {<br />
    log.Printf(“%s(%s) Max attempts reached, terminating\n”, r.RemoteAddr, r.URL.Path)<br />
    http.Error(w, “Service not available”, http.StatusServiceUnavailable)<br />
    return<br />
  }</p><br />
<br />
<p>peer := serverPool.GetNextPeer()<br />
  if peer != nil {<br />
    peer.ReverseProxy.ServeHTTP(w, r)<br />
    return<br />
  }<br />
  http.Error(w, “Service not available”, http.StatusServiceUnavailable)<br />
}<br />
This implementation is recursive.</p><br />
<br />
<p>Use of context<br />
context package allows you to store useful data in an Http request. We heavily utilized this to track request specific data such as Attempt count and Retry count.</p><br />
<br />
<p>First, we need to specify keys for the context. It is recommended to use non-colliding integer keys rather than strings. Go provides iota keyword to implement constants incrementally, each containing a unique value. That is a perfect solution defining integer keys.</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
const (<br />
  Attempts int = iota<br />
  Retry<br />
)<br />
Then we can retrieve the value as usually we do with a HashMap like follows. The default return value may depend on the use case.</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
// GetAttemptsFromContext returns the attempts for request<br />
func GetRetryFromContext(r *http.Request) int {<br />
  if retry, ok := r.Context().Value(Retry).(int); ok {<br />
    return retry<br />
  }<br />
  return 0<br />
}<br />
Passive health checks<br />
Passive health checks allow to recover dead backends or identify them. We ping the backends with fixed intervals to check their status.</p><br />
<br />
<p>To ping, we try to establish a TCP connection. If the backend responses, we mark it as alive. This method can be changed to call a specific endpoint like /status if you like. Make sure to close the connection once it established to reduce the additional load in the server. Otherwise, it will try to maintain the connection and it would run out of resources eventually.</p><br />
<br />
<p>1<br />
 2<br />
 3<br />
 4<br />
 5<br />
 6<br />
 7<br />
 8<br />
 9<br />
10<br />
11<br />
// isAlive checks whether a backend is Alive by establishing a TCP connection<br />
func isBackendAlive(u *url.URL) bool {<br />
  timeout := 2 * time.Second<br />
  conn, err := net.DialTimeout(“tcp”, u.Host, timeout)<br />
  if err != nil {<br />
    log.Println(“Site unreachable, error: “, err)<br />
    return false<br />
  }<br />
  _ = conn.Close() // close it, we dont need to maintain this connection<br />
  return true<br />
}<br />
Now we can iterate the servers and mark their status like follows,</p><br />
<br />
<p>1<br />
 2<br />
 3<br />
 4<br />
 5<br />
 6<br />
 7<br />
 8<br />
 9<br />
10<br />
11<br />
12<br />
// HealthCheck pings the backends and update the status<br />
func (s *ServerPool) HealthCheck() {<br />
  for _, b := range s.backends {<br />
    status := “up”<br />
    alive := isBackendAlive(b.URL)<br />
    b.SetAlive(alive)<br />
    if !alive {<br />
      status = “down”<br />
    }<br />
    log.Printf(“%s [%s]\n”, b.URL, status)<br />
  }<br />
}<br />
To run this periodically we can start a timer in Go. Once a timer created it allows you to listen for the event using a channel.</p><br />
<br />
<p>1<br />
 2<br />
 3<br />
 4<br />
 5<br />
 6<br />
 7<br />
 8<br />
 9<br />
10<br />
11<br />
12<br />
// healthCheck runs a routine for check status of the backends every 2 mins<br />
func healthCheck() {<br />
  t := time.NewTicker(time.Second * 20)<br />
  for {<br />
    select {<br />
    case &lt;-t.C:<br />
      log.Println(“Starting health check…”)<br />
      serverPool.HealthCheck()<br />
      log.Println(“Health check completed”)<br />
    }<br />
  }<br />
}<br />
In the above snippet, &lt;-t.C channel will return a value per 20s. select allows to detect this event. select waits until at least one case statement could be executed if there is no default case.</p><br />
<br />
<p>Finally, run this in a separate goroutine.</p><br />
<br />
<p>1<br />
go healthCheck()<br />
Conclusion<br />
We covered a lot of stuff in this article.</p><br />
<br />
<p>Round Robin Selection<br />
ReverseProxy from the standard library<br />
Mutexes<br />
Atomic Operations<br />
Closures<br />
Callbacks<br />
Select Operation<br />
There is a lot we can do to improve our tiny load balancer.</p><br />
<br />
<p>For example,</p><br />
<br />
<p>Use a heap for sort out alive backends to reduce search surface<br />
Collect statistics<br />
Implement weighted round-robin/least connections<br />
Add support for a configuration file</p><br />
<br />
<p>https://github.com/kasvith/simplelb/</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>