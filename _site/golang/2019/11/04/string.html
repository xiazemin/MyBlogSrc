<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">字符串高效拼接</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-11-04T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Nov 4, 2019</time></p>
					</div>
					 <p>在我们变成的时候，和字符串打交道是必不可少的，我们对数据库里文本的处理，Web文本的显示，文本数据的存储等都需要和字符串打交道，那么对于字符串来说，查找、拼接这些都是常用的操作，尤其是以拼接使用的比较多，比如把一个人的姓名和年龄拼接在一起显示。</p><br />
<br />
<p>在Go语言（golang）中，对于字符串的拼接处理有很多种方法，那么那种方法才是效率最高的呢？因为内存很贵、性能很重要，有时候不慎字符串的转换和拷贝，就可以把你的内存吃光，性能低下，不得不考虑。<br />
<!-- more --><br />
+号拼接<br />
这种拼接最简单，也最容易被我们使用，因为它是不限编程语言的，比如Go语言有，Java也有，它们是+号运算符，在运行时计算的。现在演示下这种拼接的代码，虽然比较简单。</p><br />
<br />
<p>func StringPlus() string{<br />
	var s string<br />
	s+=”昵称”+”:”+”飞雪无情”+”\n”<br />
	s+=”博客”+”:”+”http://www.flysnow.org/”+”\n”<br />
	s+=”微信公众号”+”:”+”flysnow_org”<br />
	return s<br />
}<br />
我们可以自己写个用例测试下，可以打印出和我们例子中一样的内容。那么这种最常见的字符串拼接的方式性能怎么样的呢，我们测试下：</p><br />
<br />
<p>func BenchmarkStringPlus(b *testing.B) {<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringPlus()<br />
	}<br />
}<br />
运行go test -bench=. -benchmem 查看性能输出如下：</p><br />
<br />
<p>BenchmarkStringPlus-8   20000000    108 ns/op   144 B/op    2 allocs/op<br />
每次操作需要108ns,进行2次内存分配，分配114字节的内存。</p><br />
<br />
<p>fmt 拼接<br />
这种拼接，借助于fmt.Sprint系列函数进行拼接，然后返回拼接的字符串。</p><br />
<br />
<p>func StringFmt() string{<br />
	return fmt.Sprint(“昵称”,”:”,”飞雪无情”,”\n”,”博客”,”:”,”http://www.flysnow.org/”,”\n”,”微信公众号”,”:”,”flysnow_org”)<br />
}<br />
为了演示，代码没有换行，可能在手机上影响阅读体验，见谅。它的性能我们也测试一下看看效果。</p><br />
<br />
<p>func BenchmarkStringFmt(b *testing.B) {<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringFmt()<br />
	}<br />
}<br />
运行查看测试结果：</p><br />
<br />
<p>BenchmarkStringFmt-8    5000000     385 ns/op   80 B/op     1 allocs/op<br />
虽然每次操作内存分配只有1次，分配80字节也不多，但是每次操作耗时太长，性能远没有+号操作快。</p><br />
<br />
<p>Join 拼接<br />
这个是利用strings.Join函数进行拼接，接受一个字符串数组，转换为一个拼接好的字符串。</p><br />
<br />
<p>func StringJoin() string{<br />
	s:=[]string{“昵称”,”:”,”飞雪无情”,”\n”,”博客”,”:”,”http://www.flysnow.org/”,”\n”,”微信公众号”,”:”,”flysnow_org”}<br />
	return strings.Join(s,””)<br />
}</p><br />
<br />
<p>func BenchmarkStringJoin(b *testing.B) {<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringJoin()<br />
	}<br />
}<br />
为了方便，把性能测试的代码放一起了，现在看看性能测试的效果。</p><br />
<br />
<p>BenchmarkStringJoin-8   10000000    177 ns/op   160 B/op    2 allocs/op<br />
整体和+操作相差不了太多，大概低0.5倍的样子。</p><br />
<br />
<p>http://www.flysnow.org/2018/10/28/golang-concat-strings-performance-analysis.html</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>Go语言字符串高效拼接（一）</td><br />
      <td>飞雪无情的博客</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>buffer 拼接<br />
这种被用的也很多，使用的是bytes.Buffer进行的字符串拼接，它是非常灵活的一个结构体，不止可以拼接字符串，还是可以byte,rune等，并且实现了io.Writer接口，写入也非常方便。</p><br />
<br />
<p>func StringBuffer() string {<br />
	var b bytes.Buffer<br />
	b.WriteString(“昵称”)<br />
	b.WriteString(“:”)<br />
	b.WriteString(“飞雪无情”)<br />
	b.WriteString(“\n”)<br />
	b.WriteString(“博客”)<br />
	b.WriteString(“:”)<br />
	b.WriteString(“http://www.flysnow.org/”)<br />
	b.WriteString(“\n”)<br />
	b.WriteString(“微信公众号”)<br />
	b.WriteString(“:”)<br />
	b.WriteString(“flysnow_org”)<br />
	return b.String()<br />
}</p><br />
<br />
<p>func BenchmarkStringBuffer(b *testing.B) {<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringBuffer()<br />
	}<br />
}<br />
看看他的性能，运行输出即可：</p><br />
<br />
<p>BenchmarkStringBuffer-8     5000000     291 ns/op   336 B/op    3 allocs/op<br />
好像并不是太好,和最差的fmt拼接差不多，和+号，Join拼接差好远，内存分配也比较多。每次操作耗时也很长。</p><br />
<br />
<p>builder 拼接<br />
为了改进buffer拼接的性能，从go 1.10 版本开始，增加了一个builder类型，用于提升字符串拼接的性能。它的使用和buffer几乎一样。</p><br />
<br />
<p>func StringBuilder() string {<br />
	var b strings.Builder<br />
	b.WriteString(“昵称”)<br />
	b.WriteString(“:”)<br />
	b.WriteString(“飞雪无情”)<br />
	b.WriteString(“\n”)<br />
	b.WriteString(“博客”)<br />
	b.WriteString(“:”)<br />
	b.WriteString(“http://www.flysnow.org/”)<br />
	b.WriteString(“\n”)<br />
	b.WriteString(“微信公众号”)<br />
	b.WriteString(“:”)<br />
	b.WriteString(“flysnow_org”)<br />
	return b.String()<br />
}</p><br />
<br />
<p>func BenchmarkStringBuilder(b *testing.B) {<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringBuilder()<br />
	}<br />
}<br />
官方都说比buffer性能好了，我们看看性能测试的结果。</p><br />
<br />
<p>BenchmarkStringBuilder-8    10000000    170 ns/op   232 B/op    4 allocs/op<br />
的确提升了，提升了一倍，虽然每次分配的内存次数有点多，但是每次分配的内存大小比buffer要少。</p><br />
<br />
<p>性能对比<br />
以上就是常用的字符串拼接的方式，现在我们把这些测试结果，汇总到一起，对比下看看,因为Benchmark的测试，对于性能只显示，我把测试的时间设置为3s（秒），把时间拉长便于对比测试，同时生成了cpu profile文件，用于性能分析。</p><br />
<br />
<p>运行go test -bench=. -benchmem -benchtime=3s -cpuprofile=profile.out得到如下测试结果：</p><br />
<br />
<p>StringPlus-8    50000000    112 ns/op   144 B/op    2 allocs/op<br />
StringFmt-8     20000000    344 ns/op   80 B/op     1 allocs/op<br />
StringJoin-8    30000000    171 ns/op   160 B/op    2 allocs/op<br />
StringBuffer-8  20000000    302 ns/op   336 B/op    3 allocs/op<br />
StringBuilder-8 30000000    171 ns/op   232 B/op    4 allocs/op<br />
我们通过go tool pprof profile.out 看下我们输出的cpu profile信息。这里主要使用top命令。</p><br />
<br />
<p>Showing top 15 nodes out of 89<br />
      flat  flat%   sum%        cum   cum%<br />
    11.99s 42.55% 42.55%     11.99s 42.55%  runtime.kevent<br />
     6.30s 22.36% 64.90%      6.30s 22.36%  runtime.pthread_cond_wait<br />
     1.65s  5.86% 70.76%      1.65s  5.86%  runtime.pthread_cond_signal<br />
     1.11s  3.94% 74.70%      1.11s  3.94%  runtime.usleep<br />
     1.10s  3.90% 78.60%      1.10s  3.90%  runtime.pthread_cond_timedwait_relative_np<br />
     0.58s  2.06% 80.66%      0.62s  2.20%  runtime.wbBufFlush1<br />
     0.51s  1.81% 82.47%      0.51s  1.81%  runtime.memmove<br />
     0.44s  1.56% 84.03%      1.81s  6.42%  fmt.(<em>pp).printArg<br />
     0.39s  1.38% 85.42%      2.36s  8.37%  fmt.(</em>pp).doPrint<br />
     0.36s  1.28% 86.69%      0.70s  2.48%  fmt.(<em>buffer).WriteString (inline)<br />
     0.34s  1.21% 87.90%      0.93s  3.30%  runtime.mallocgc<br />
     0.20s  0.71% 88.61%      1.20s  4.26%  fmt.(</em>fmt).fmtS<br />
     0.18s  0.64% 89.25%      0.18s  0.64%  fmt.(<em>fmt).truncate<br />
     0.16s  0.57% 89.82%      0.16s  0.57%  runtime.memclrNoHeapPointers<br />
     0.15s  0.53% 90.35%      1.35s  4.79%  fmt.(</em>pp).fmtString<br />
前15个，可以看到fmt拼接的方式是最差的，因为fmt里很多方法耗时排在了最前面。buffer的WriteString方法也比较耗时。</p><br />
<br />
<p>以上的TOP可能还不是太直观，如果大家看火焰图的话，就会更清晰。性能最好的是+号拼接、Join拼接，最慢的是fmt拼接，这里的builder和buffer拼接差不多，并没有发挥出其能力。</p><br />
<br />
<p>总结<br />
从整个性能的测试和分析来看，我们期待的builder并没有发挥出来，这是不是意味着builder不实用了呢？还不如+号和Join拼接呢？我们下一篇继续接着分析，这里提前透漏一些：比如:</p><br />
<br />
<p>拼接的字符串大小<br />
拼接的字符串数量<br />
以上这两个很关键，可以看下我上面的例子是属于哪一种。</p><br />
<br />
<p>拼接函数改造<br />
在上一篇的文章的末尾，我已经提出了2个可能性：拼接字符串的数量和拼接字符串的大小，现在我们就开始证明这两种情况，为了演示方便，我们把原来的拼接函数修改一下，可以接受一个[]string类型的参数，这样我们就可以对切片数组进行字符串拼接，这里直接给出所有的拼接方法的改造后实现。</p><br />
<br />
<p>func StringPlus(p []string) string{<br />
	var s string<br />
	l:=len(p)<br />
	for i:=0;i&lt;l;i++{<br />
		s+=p[i]<br />
	}<br />
	return s<br />
}</p><br />
<br />
<p>func StringFmt(p []interface{}) string{<br />
	return fmt.Sprint(p…)<br />
}</p><br />
<br />
<p>func StringJoin(p []string) string{<br />
	return strings.Join(p,””)<br />
}</p><br />
<br />
<p>func StringBuffer(p []string) string {<br />
	var b bytes.Buffer<br />
	l:=len(p)<br />
	for i:=0;i&lt;l;i++{<br />
		b.WriteString(p[i])<br />
	}<br />
	return b.String()<br />
}</p><br />
<br />
<p>func StringBuilder(p []string) string {<br />
	var b strings.Builder<br />
	l:=len(p)<br />
	for i:=0;i&lt;l;i++{<br />
		b.WriteString(p[i])<br />
	}<br />
	return b.String()<br />
}<br />
以上实现中的for循环我并没有使用for range,为了提高性能，具体原因请参考我的 Go语言性能优化- For Range 性能研究 。</p><br />
<br />
<p>测试用例<br />
以上的字符串拼接函数修改后，我们就可以构造不同大小的切片进行字符串拼接测试了。为了模拟上次的效果，我们先用10个切片大小的字符串进行拼接测试，和上一篇的测试情形差不多（也是大概10个字符串拼接）。</p><br />
<br />
<p>const BLOG  = “http://www.flysnow.org/”</p><br />
<br />
<p>func initStrings(N int) []string{<br />
	s:=make([]string,N)<br />
	for i:=0;i&lt;N;i++{<br />
		s[i]=BLOG<br />
	}<br />
	return s;<br />
}</p><br />
<br />
<p>func initStringi(N int) []interface{}{<br />
	s:=make([]interface{},N)<br />
	for i:=0;i&lt;N;i++{<br />
		s[i]=BLOG<br />
	}<br />
	return s;<br />
}<br />
这是两个构建测试用力切片数组的函数，可以生成N个大小的切片。第二个initStringi函数返回的是[]interface{}，这是专门为StringFmt(p []interface{})拼接函数准备的，减少类型之间的转换。</p><br />
<br />
<p>有了这两个生成测试用例的函数，我们就可以构建我们的Go语言性能测试了，我们先测试10个大小的切片。</p><br />
<br />
<p>func BenchmarkStringPlus10(b *testing.B) {<br />
	p:= initStrings(10)<br />
	b.ResetTimer()<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringPlus(p)<br />
	}<br />
}</p><br />
<br />
<p>func BenchmarkStringFmt10(b *testing.B) {<br />
	p:= initStringi(10)<br />
	b.ResetTimer()<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringFmt(p)<br />
	}<br />
}</p><br />
<br />
<p>func BenchmarkStringJoin10(b *testing.B) {<br />
	p:= initStrings(10)<br />
	b.ResetTimer()<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringJoin(p)<br />
	}<br />
}</p><br />
<br />
<p>func BenchmarkStringBuffer10(b *testing.B) {<br />
	p:= initStrings(10)<br />
	b.ResetTimer()<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringBuffer(p)<br />
	}<br />
}</p><br />
<br />
<p>func BenchmarkStringBuilder10(b *testing.B) {<br />
	p:= initStrings(10)<br />
	b.ResetTimer()<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringBuilder(p)<br />
	}<br />
}<br />
在每个性能测试函数中，我们都会调用b.ResetTimer()，这是为了避免测试用例准备时间不同，带来的性能测试效果偏差问题，具体可以参考我的一篇文章 Go语言实战笔记（二十二）| Go 基准测试 。</p><br />
<br />
<p>我们运行go test -bench=. -run=NONE -benchmem 查看结果。</p><br />
<br />
<p>BenchmarkStringPlus10-8     3000000     593 ns/op   1312 B/op   9 allocs/op<br />
BenchmarkStringFmt10-8      5000000     335 ns/op   240 B/op    1 allocs/op<br />
BenchmarkStringJoin10-8     10000000    200 ns/op   480 B/op    2 allocs/op<br />
BenchmarkStringBuffer10-8   3000000     452 ns/op   864 B/op    4 allocs/op<br />
BenchmarkStringBuilder10-8  10000000    231 ns/op   480 B/op    4 allocs/op<br />
通过这次我们可以看到，+号拼接不再具有优势，因为string是不可变的，每次拼接都会生成一个新的string,也就是会进行一次内存分配，我们现在是10个大小的切片，每次操作要进行9次进行分配，占用内存，所以每次操作时间都比较长，自然性能就低下。</p><br />
<br />
<p>Go语言字符串高效拼接（二）</p><br />
<br />
<p>http://www.flysnow.org/2018/11/05/golang-concat-strings-performance-analysis.html</p><br />
<br />
<p>可能有读者记得，我们上一篇文章 Go语言字符串高效拼接（一） 中，+加号拼接的性能测试中显示的只有2次内存分配，但是我们用了好多个+的。</p><br />
<br />
<p>func StringPlus() string{<br />
	var s string<br />
	s+=”昵称”+”:”+”飞雪无情”+”\n”<br />
	s+=”博客”+”:”+”http://www.flysnow.org/”+”\n”<br />
	s+=”微信公众号”+”:”+”flysnow_org”<br />
	return s<br />
}<br />
再来回顾下这段代码，的确是有很多+的，但是只有2次内存分配，我们可以大胆猜测,是3次s+=导致的，正常和我们今天测试的10个长度的切片，只有9次内存分配一样。下面我们通过运行如下命令看下Go编译器对这段代码的优化：go build -gcflags=”-m -m” main.go,输出中有如下内容：</p><br />
<br />
<p>can inline StringPlus as: func() string { var s string; s = <N>; s += "昵称:飞雪无情\n"; s += "博客:http://www.flysnow.org/\n"; s += "微信公众号:flysnow_org"; return s }<br />
现在一目了然了，其实是编译器帮我们把字符串做了优化，只剩下3个s+=</N></p><br />
<br />
<p>这次，采用长度为10个切片进行测试，也很明显测试出了Builder要比Buffer性能好很多，这个问题原因主要还是[]byte和string之间的转换，Builder恰恰解决了这个问题。</p><br />
<br />
<p>func (b <em>Builder) String() string {<br />
	return *(</em>string)(unsafe.Pointer(&amp;b.buf))<br />
}<br />
很高效的解决方案。</p><br />
<br />
<p>100个字符串<br />
现在我们测试下100个字符串拼接的情况，对于我们上面的代码，要改造非常容易，这里直接给出测试代码。</p><br />
<br />
<p>func BenchmarkStringPlus100(b *testing.B) {<br />
	p:= initStrings(100)<br />
	b.ResetTimer()<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringPlus(p)<br />
	}<br />
}</p><br />
<br />
<p>func BenchmarkStringFmt100(b *testing.B) {<br />
	p:= initStringi(100)<br />
	b.ResetTimer()<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringFmt(p)<br />
	}<br />
}</p><br />
<br />
<p>func BenchmarkStringJoin100(b *testing.B) {<br />
	p:= initStrings(100)<br />
	b.ResetTimer()<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringJoin(p)<br />
	}<br />
}</p><br />
<br />
<p>func BenchmarkStringBuffer100(b *testing.B) {<br />
	p:= initStrings(100)<br />
	b.ResetTimer()<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringBuffer(p)<br />
	}<br />
}</p><br />
<br />
<p>func BenchmarkStringBuilder100(b *testing.B) {<br />
	p:= initStrings(100)<br />
	b.ResetTimer()<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringBuilder(p)<br />
	}<br />
}<br />
现在运行性能测试，看看100个字符串连接的性能怎么样，哪个函数最高效。</p><br />
<br />
<p>BenchmarkStringPlus100-8    100000  19711 ns/op     123168 B/op     99 allocs/op<br />
BenchmarkStringFmt100-8     500000  2615 ns/op      2304 B/op       1 allocs/op<br />
BenchmarkStringJoin100-8    1000000 1516 ns/op      4608 B/op       2 allocs/op<br />
BenchmarkStringBuffer100-8  500000  2333 ns/op      8112 B/op       7 allocs/op<br />
BenchmarkStringBuilder100-8 1000000 1714 ns/op      6752 B/op       8 allocs/op<br />
+号和我们上面分析得一样，这次是99次内存分配，性能体验越来越差，在后面的测试中，会排除掉。</p><br />
<br />
<p>fmt和bufrer已经的性能也没有提升，继续走低。剩下比较坚挺的是Join和Builder。</p><br />
<br />
<p>1000 个字符串。<br />
测试用力和上面章节的大同小异，所以我们直接看测试结果。</p><br />
<br />
<p>BenchmarkStringPlus1000-8       1000    1611985 ns/op   12136228 B/op   999 allocs/op<br />
BenchmarkStringFmt1000-8        50000   28510 ns/op     24590 B/op      1 allocs/op<br />
BenchmarkStringJoin1000-8       100000  15050 ns/op     49152 B/op      2 allocs/op<br />
BenchmarkStringBuffer1000-8     100000  23534 ns/op     122544 B/op     11 allocs/op<br />
BenchmarkStringBuilder1000-8    100000  17996 ns/op     96224 B/op      16 allocs/op<br />
整体和100个字符串的时候差不多，表现好的还是Join和Builder。这两个方法的使用侧重点有些不一样， 如果有现成的数组、切片那么可以直接使用Join,但是如果没有，并且追求灵活性拼接，还是选择Builder。 Join还是定位于有现成切片、数组的（毕竟拼接成数组也要时间），并且使用固定方式进行分解的，比如逗号、空格等，局限比较大。</p><br />
<br />
<p>小结<br />
至于10000个字符串拼接我这里就不做测试了，大家可以自己试试，看看是不是大同小异的。</p><br />
<br />
<p>从最近的这两篇文章的分析来看，我们大概可以总结出。</p><br />
<br />
<ul><br />
  <li>连接适用于短小的、常量字符串（明确的，非变量），因为编译器会给我们优化。<br />
Join是比较统一的拼接，不太灵活<br />
fmt和buffer基本上不推荐<br />
builder从性能和灵活性上，都是上佳的选择</li><br />
</ul><br />
<br />
<p>Builder 慢在哪<br />
既然要优化Builder拼接，那么我们起码知道他慢在哪，我们继续使用我们上篇文章的测试用例，运行看下性能。</p><br />
<br />
<p>Builder10-8     5000000     258 ns/op       480 B/op        4 allocs/op<br />
Builder100-8    1000000     2012 ns/op      6752 B/op       8 allocs/op<br />
Builder1000-8   100000      21016 ns/op     96224 B/op      16 allocs/op<br />
Builder10000-8  10000       195098 ns/op    1120226 B/op    25 allocs/op<br />
针对既然要优化Builder拼接,采取了10、100、1000、10000四种不同数量的字符串进行拼接测试。我们发现每次操作都有不同次数的内存分配，内存分配越多，越慢，如果引起GC，就更慢了，首先我们先优化这个，减少内存分配的次数。</p><br />
<br />
<p>内存分配优化<br />
通过cpuprofile，查看生成的火焰图可以得知，runtime.growslice函数会被频繁的调用，并且时间占比也比较长。我们查看Builder.WriteString的源代码：</p><br />
<br />
<p>func (b *Builder) WriteString(s string) (int, error) {<br />
	b.copyCheck()<br />
	b.buf = append(b.buf, s…)<br />
	return len(s), nil<br />
}<br />
可以肯定是append方法触发了runtime.growslice，因为b.buf的容量cap不足，所以需要调用runtime.growslice扩充b.buf的容量，然后才可以追加新的元素s…。扩容容量自然会涉及到内存的分配，而且追加的内容越多，内容分配的次数越多，这和我们上面性能测试的数据是一样的。</p><br />
<br />
<p>既然问题的原因找到了，那么我们就可以优化了，核心手段就是减少runtime.growslice调用，甚至不调用。照着这个思路的话，我们就要提前为b.buf分配好容量cap。幸好Builder为我们提供了扩充容量的方法Grow，我们在进行WriteString之前，先通过Grow方法，扩充好容量即可。</p><br />
<br />
<p>现在开始改造我们的StringBuilder函数。</p><br />
<br />
<p>//blog:www.flysnow.org<br />
//微信公众号:flysnow_org<br />
func StringBuilder(p []string,cap int) string {<br />
	var b strings.Builder<br />
	l:=len(p)<br />
	b.Grow(cap)<br />
	for i:=0;i&lt;l;i++{<br />
		b.WriteString(p[i])<br />
	}<br />
	return b.String()<br />
}<br />
增加一个参数cap，让使用者告诉我们需要的容量大小。Grow方法的实现非常简单，就是一个通过make函数，扩充b.buf大小，然后再拷贝b.buf的过程。</p><br />
<br />
<p>func (b <em>Builder) grow(n int) {<br />
	buf := make([]byte, len(b.buf), 2</em>cap(b.buf)+n)<br />
	copy(buf, b.buf)<br />
	b.buf = buf<br />
}<br />
那么现在我们的性能测试用例变成如下：</p><br />
<br />
<p>func BenchmarkStringBuilder10(b <em>testing.B) {<br />
	p:= initStrings(10)<br />
	cap:=10</em>len(BLOG)<br />
	b.ResetTimer()<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringBuilder(p,cap)<br />
	}<br />
}</p><br />
<br />
<p>func BenchmarkStringBuilder1000(b <em>testing.B) {<br />
	p:= initStrings(1000)<br />
	cap:=1000</em>len(BLOG)<br />
	b.ResetTimer()<br />
	for i:=0;i&lt;b.N;i++{<br />
		StringBuilder(p,cap)<br />
	}<br />
}</p><br />
<br />
<p>为了说明情况和简短代码，这里只有10和1000个元素的用例，其他类似。为了把性能优化到极致，我一次性把需要的容量分配足够。现在我们再运行性能（Benchmark）测试代码。</p><br />
<br />
<p>Builder10-8     10000000    123 ns/op       352 B/op    1 allocs/op<br />
Builder100-8    2000000     898 ns/op       2688 B/op   1 allocs/op<br />
Builder1000-8   200000      7729 ns/op      24576 B/op  1 allocs/op<br />
Builder10000-8  20000       78678 ns/op     237568 B/op 1 allocs/op<br />
性能足足翻了1倍多，只有1次内存分配，每次操作占用的内存也减少了一半多，降低了GC。</p><br />
<br />
<p>小结<br />
这次优化，到了这里，算是结束了，写出来后，大家也会觉得不难，其背后的原理也非常情况，就是预先分配内存，减少append过程中的内存重新分配和数据拷贝，这样我们就可以提升很多的性能。所以对于可以预见的长度的切，都可以提前申请申请好内存。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>