<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">HandleFunc</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-11-28T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Nov 28, 2019</time></p>
					</div>
					 <p>golang http的handle模块（一般也称为钩子模块），通过高级语言的匿名函数很容易实现这种内嵌功能的handle</p><br />
<br />
<p>我们一般这样使用golang的http HandleFunc来为http的server端做相应的处理</p><br />
<br />
<p>/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong><em>/<br />
        http.HandleFunc(“/”, xxx_FUN)<br />
	err := http.ListenAndServe(“:8080”, nil)<br />
	if err != nil {<br />
		log.Fatal(“ListenAndServe: “, err)<br />
	}<br />
  /</em></strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>/<br />
<!-- more --><br />
源码仔细看看http.HandleFunc的实现</p><br />
<br />
<p>func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {<br />
	DefaultServeMux.HandleFunc(pattern, handler)<br />
}</p><br />
<br />
<p>// NewServeMux allocates and returns a new ServeMux.<br />
var DefaultServeMux = NewServeMux()<br />
func NewServeMux() *ServeMux { return &amp;ServeMux{m: make(map[string]muxEntry)} }</p><br />
<br />
<p>type ServeMux struct {<br />
	mu    sync.RWMutex                   //一个读写锁<br />
	m     map[string]muxEntry            //一个path(patterns)的映射map<br />
	hosts bool                          // whether any patterns contain hostnames<br />
}<br />
再来看看ListenAndServe的具体实现</p><br />
<br />
<p>func ListenAndServe(addr string, handler Handler) error {<br />
	server := &amp;Server{Addr: addr, Handler: handler}<br />
	return server.ListenAndServe()<br />
}</p><br />
<br />
<p>func (srv <em>Server) ListenAndServe() error {<br />
	addr := srv.Addr<br />
	if addr == “” {<br />
		addr = “:http”<br />
	}<br />
	ln, err := net.Listen(“tcp”, addr)<br />
	if err != nil {<br />
		return err<br />
	}<br />
	return srv.Serve(tcpKeepAliveListener{ln.(</em>net.TCPListener)})<br />
}</p><br />
<br />
<p>// Serve accepts incoming connections on the Listener l, creating a<br />
// new service goroutine for each.  The service goroutines read requests and<br />
// then call srv.Handler to reply to them.<br />
func (srv *Server) Serve(l net.Listener) error {<br />
	defer l.Close()<br />
	var tempDelay time.Duration // how long to sleep on accept failure<br />
	for {<br />
		rw, e := l.Accept()<br />
		if e != nil {<br />
			if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() {<br />
				if tempDelay == 0 {<br />
					tempDelay = 5 * time.Millisecond<br />
				} else {<br />
					tempDelay *= 2<br />
				}<br />
				if max := 1 * time.Second; tempDelay &gt; max {<br />
					tempDelay = max<br />
				}<br />
				srv.logf(“http: Accept error: %v; retrying in %v”, e, tempDelay)<br />
				time.Sleep(tempDelay)<br />
				continue<br />
			}<br />
			return e<br />
		}<br />
		tempDelay = 0<br />
		c, err := srv.newConn(rw)<br />
		if err != nil {<br />
			continue<br />
		}<br />
		c.setState(c.rwc, StateNew) // before Serve can return<br />
		go c.serve() //看来这个c.serve是处理的入口<br />
	}<br />
}<br />
看来这个c.serve是处理的入口</p><br />
<br />
<p>// Serve a new connection.<br />
func (c *conn) serve() {<br />
	origConn := c.rwc // copy it before it’s set nil on Close or Hijack<br />
	defer func() {<br />
		if err := recover(); err != nil {<br />
			const size = 64 « 10<br />
			buf := make([]byte, size)<br />
			buf = buf[:runtime.Stack(buf, false)]<br />
			c.server.logf(“http: panic serving %v: %v\n%s”, c.remoteAddr, err, buf)<br />
		}<br />
		if !c.hijacked() {<br />
			c.close()<br />
			c.setState(origConn, StateClosed)<br />
		}<br />
	}()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if tlsConn, ok := c.rwc.(*tls.Conn); ok {<br />
	if d := c.server.ReadTimeout; d != 0 {<br />
		c.rwc.SetReadDeadline(time.Now().Add(d))<br />
	}<br />
	if d := c.server.WriteTimeout; d != 0 {<br />
		c.rwc.SetWriteDeadline(time.Now().Add(d))<br />
	}<br />
	if err := tlsConn.Handshake(); err != nil {<br />
		c.server.logf("http: TLS handshake error from %s: %v", c.rwc.RemoteAddr(), err)<br />
		return<br />
	}<br />
	c.tlsState = new(tls.ConnectionState)<br />
	*c.tlsState = tlsConn.ConnectionState()<br />
	if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {<br />
		if fn := c.server.TLSNextProto[proto]; fn != nil {<br />
			h := initNPNRequest{tlsConn, serverHandler{c.server}}<br />
			fn(c.server, tlsConn, h)<br />
		}<br />
		return<br />
	}<br />
}<br />
<br />
for {<br />
	w, err := c.readRequest()<br />
	if c.lr.N != c.server.initialLimitedReaderSize() {<br />
		// If we read any bytes off the wire, we're active.<br />
		c.setState(c.rwc, StateActive)<br />
	}<br />
	if err != nil {<br />
		if err == errTooLarge {<br />
			// Their HTTP client may or may not be<br />
			// able to read this if we're<br />
			// responding to them and hanging up<br />
			// while they're still writing their<br />
			// request.  Undefined behavior.<br />
			io.WriteString(c.rwc, "HTTP/1.1 413 Request Entity Too Large\r\n\r\n")<br />
			c.closeWriteAndWait()<br />
			break<br />
		} else if err == io.EOF {<br />
			break // Don't reply<br />
		} else if neterr, ok := err.(net.Error); ok &amp;&amp; neterr.Timeout() {<br />
			break // Don't reply<br />
		}<br />
		io.WriteString(c.rwc, "HTTP/1.1 400 Bad Request\r\n\r\n")<br />
		break<br />
	}<br />
<br />
	// Expect 100 Continue support<br />
	req := w.req<br />
	if req.expectsContinue() {<br />
		if req.ProtoAtLeast(1, 1) &amp;&amp; req.ContentLength != 0 {<br />
			// Wrap the Body reader with one that replies on the connection<br />
			req.Body = &amp;expectContinueReader{readCloser: req.Body, resp: w}<br />
		}<br />
		req.Header.Del("Expect")<br />
	} else if req.Header.get("Expect") != "" {<br />
		w.sendExpectationFailed()<br />
		break<br />
	}<br />
<br />
	// HTTP cannot have multiple simultaneous active requests.[*]<br />
	// Until the server replies to this request, it can't read another,<br />
	// so we might as well run the handler in this goroutine.<br />
	// [*] Not strictly true: HTTP pipelining.  We could let them all process<br />
	// in parallel even if their responses need to be serialized.<br />
	serverHandler{c.server}.ServeHTTP(w, w.req) //这个是入口<br />
	if c.hijacked() {<br />
		return<br />
	}<br />
	w.finishRequest()<br />
	if w.closeAfterReply {<br />
		if w.requestBodyLimitHit {<br />
			c.closeWriteAndWait()<br />
		}<br />
		break<br />
	}<br />
	c.setState(c.rwc, StateIdle)<br />
} } Handler处理的入口就是serverHandler{c.server}.ServerHTTP(w,w.req)，最终到HandleFunc的执行<br />
</code></pre></div></div><br />
<br />
<p>func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {<br />
	if r.Method != “CONNECT” {<br />
		if p := cleanPath(r.URL.Path); p != r.URL.Path {<br />
			_, pattern = mux.handler(r.Host, p) //接下来处理<br />
			url := *r.URL<br />
			url.Path = p<br />
			return RedirectHandler(url.String(), StatusMovedPermanently), pattern<br />
		}<br />
	}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return mux.handler(r.Host, r.URL.Path) //接下来处理 }<br />
</code></pre></div></div><br />
<br />
<p>func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {<br />
	mux.mu.RLock()<br />
	defer mux.mu.RUnlock()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Host-specific pattern takes precedence over generic ones<br />
if mux.hosts {<br />
	h, pattern = mux.match(host + path)<br />
}<br />
if h == nil {<br />
	h, pattern = mux.match(path)<br />
}<br />
if h == nil {<br />
	h, pattern = NotFoundHandler(), "" //如果handler对应的匿名函数为空,则返回默认的匿名函数<br />
}<br />
return }<br />
</code></pre></div></div><br />
<br />
<p>// ServeHTTP dispatches the request to the handler whose<br />
// pattern most closely matches the request URL.<br />
func (mux <em>ServeMux) ServeHTTP(w ResponseWriter, r *Request) {<br />
	if r.RequestURI == “</em>” {<br />
		if r.ProtoAtLeast(1, 1) {                               <br /><br />
			w.Header().Set(“Connection”, “close”)<br />
		}<br />
		w.WriteHeader(StatusBadRequest)<br />
		return<br />
	}<br />
	h, _ := mux.Handler(r) //接下来处理<br />
	h.ServeHTTP(w, r) //接下来处理<br />
}</p><br />
<br />
<p>//接下来就初始时候执行的操作<br />
func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {<br />
	mux.Handle(pattern, HandlerFunc(handler))<br />
}<br />
func (mux *ServeMux) Handle(pattern string, handler Handler) {  //处理pattern<br />
	mux.mu.Lock()<br />
	defer mux.mu.Unlock()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if pattern == "" {<br />
	panic("http: invalid pattern " + pattern)<br />
}<br />
if handler == nil {<br />
	panic("http: nil handler")<br />
}<br />
if mux.m[pattern].explicit {<br />
	panic("http: multiple registrations for " + pattern)<br />
}<br />
<br />
mux.m[pattern] = muxEntry{explicit: true, h: handler, pattern: pattern} //设置ServeMux的map<br />
<br />
if pattern[0] != '/' {<br />
	mux.hosts = true<br />
}<br />
<br />
// Helpful behavior:<br />
// If pattern is /tree/, insert an implicit permanent redirect for /tree.<br />
// It can be overridden by an explicit registration.<br />
n := len(pattern)<br />
if n &gt; 0 &amp;&amp; pattern[n-1] == '/' &amp;&amp; !mux.m[pattern[0:n-1]].explicit {<br />
	// If pattern contains a host name, strip it and use remaining<br />
	// path for redirect.<br />
	path := pattern<br />
	if pattern[0] != '/' {<br />
		// In pattern, at least the last character is a '/', so<br />
		// strings.Index can't be -1.<br />
		path = pattern[strings.Index(pattern, "/"):]<br />
	}<br />
	mux.m[pattern[0:n-1]] = muxEntry{h: RedirectHandler(path, StatusMovedPermanently), pattern: pattern}<br />
} } 最后再看看通过mux匹配获取对应的map的操作：<br />
</code></pre></div></div><br />
<br />
<p>func (mux *ServeMux) match(path string) (h Handler, pattern string) {<br />
	var n = 0<br />
	for k, v := range mux.m {<br />
		if !pathMatch(k, path) {   //匹配<br />
			continue<br />
		}<br />
		if h == nil || len(k) &gt; n {<br />
			n = len(k)<br />
			h = v.h<br />
			pattern = v.pattern<br />
		}<br />
	}<br />
	return<br />
}</p><br />
<br />
<p>type Server struct {<br />
    Addr              string        // 要监听的 TCP 地址<br />
    Handler           Handler       // 调用的 handler, 如果为空则用 http.DefaultServeMux<br />
    TLSConfig         <em>tls.Config   // 用于 ServeTLS 和 ListenAndServeTLS<br />
    ReadTimeout       time.Duration // 读取完整 request (包括 body) 的最大时长，可以和 ReadHeaderTimeout 同时使用<br />
    ReadHeaderTimeout time.Duration // 读取 request headers 的最大时长<br />
    WriteTimeout      time.Duration // 写 response 的最大时长<br />
    IdleTimeout       time.Duration // 当 keepalive 开启时等待下个 request 的最大时长，此值为空时使用 ReadTimeout 值代替，ReadTimeout 也为空使用 ReadHeaderTimeout 代替<br />
    MaxHeaderBytes    int           // 解析 request headers 里键值对的最大字节数 (包含请求行)，不限制 body. 如果为 0, 使用 DefaultMaxHeaderBytes 代替<br />
    TLSNextProto      map[string]func(</em>Server, <em>tls.Conn, Handler) // 当 ‘应用层协议协商 (NPN/ALPN)’ 时发生协议升级时，TLSNextProto 需要指定可选的 function 去接管 TLS 连接<br />
    ConnState         func(net.Conn, ConnState) // 指定一个可选的钩子函数，由 client 连接状态改变触发<br />
    ErrorLog          *log.Logger   // 指定一个可选的 logger 接收错误日志. 如果为空则由 log 包接管<br />
    disableKeepAlives int32         // 在 SetKeepAlivesEnabled 中设置，为 1 表示取消长连接，为 0 保持长连接 (默认)<br />
    inShutdown        int32         // 非零代表 in Shutdown<br />
    nextProtoOnce     sync.Once     // 设置 HTTP/2<br />
    nextProtoErr      error         // http2.ConfigureServer 的结果<br />
    mu                sync.Mutex<br />
    listeners         map[net.Listener]struct{}<br />
    activeConn        map[</em>conn]struct{}<br />
    doneChan          chan struct{} // doneChan 代表任务结束<br />
    onShutdown        []func()      // 通过 RegisterOnShutdown 注册，在 Shutdown 时调用当中的钩子函数<br />
}</p><br />
<br />
<p>// 此接口由 ResponseWriters 执行去检测连接是否已断开，此机制允许客户端断开后服务端取消一个长连接<br />
type CloseNotifier interface {<br />
    CloseNotify() &lt;-chan bool<br />
}</p><br />
<br />
<p>// conn 代表服务端的 HTTP 连接<br />
type conn struct {<br />
    server     *Server<br />
    cancelCtx  context.CancelFunc   // 撤销连接层的 context，读写出错时会调用<br />
    rwc        net.Conn             //<br />
    remoteAddr string               // rwc.RemoteAddr().String()<br />
    tlsState   *tls.ConnectionState // TLS 连接状态，nil 代表非 TSL<br />
    werr       error                // rwc 写入时的首个错误 (bufw 写入时)<br />
    r          *connReader          // 一个 *conn 使用的 io.reader 封装，存有 bufr 的读取内容<br />
    bufr       *bufio.Reader        // 从 r 读取<br />
    bufw       *bufio.Writer        // 要写入 checkConnErrorWriter{c} 的缓冲<br />
    lastMethod string<br />
    curReq     atomic.Value // 存入 *response (response 中包含 request)<br />
    curState   atomic.Value // 存入 ConnState<br />
    mu         sync.Mutex   // 保护 hijackedv<br />
    hijackedv  bool         // 代表连接是否已经被 hijacke<br />
}</p><br />
<br />
<p>// 一个 ctx 带有一个截止期限，一个取消信号，或者其他绑定值<br />
// 其函数可以被多个 goroutines 同时使用<br />
// 一个请求过来时可能会涉及到多个 goroutines，Ctx 可以控制关闭与之相关联和派生出的子 ctx 相关联的 goroutines<br />
type Context interface {<br />
    // Deadline 方法是获取设置的截止时间，第一个返回值是截止时间，到了这个时间点，Context 会自动发起取消请求；<br />
    // 第二个返回值 ok==false 时表示没有设置截止时间，如果需要取消的话，需要调用 cancel 函数进行取消，取消操作包括派生出去的子 Ctx<br />
    Deadline() (deadline time.Time, ok bool)<br />
    // 在 goroutine 中，如果该方法返回的 chan 可以读取，则意味着 parent context 已经发起了取消请求，<br />
    // 我们通过 Done 方法收到这个信号后，就应该做清理操作，然后退出 goroutine，释放资源<br />
    Done() &lt;-chan struct{}<br />
    // 如果 Done 还没关闭，Err 返回 nil<br />
    // 如果 Done 已经关闭，返回非空 err，告知 Ctx 因何取消<br />
    Err() error<br />
    Value(key interface{}) interface{} // 键值对形式，与 Ctx 绑定，可以为空<br />
}<br />
监听函数<br />
// Serve 接收 listener 上过来的连接，并为每个连接创建 service 线程<br />
// 在 service 线程中会读取 request 并调用 srv.Handler 进行服务<br />
// handler 参数一般传 nil 就行，代表使用的是 DefaultServeMux<br />
func Serve(l net.Listener, handler Handler) error { // HTTPS: ServeTLS(l net.Listener, handler Handler, certFile, keyFile string) error<br />
    srv := &amp;Server{Handler: handler}<br />
    return srv.Serve(l) // HTTPS: srv.ServeTLS(l, certFile, keyFile)<br />
}</p><br />
<br />
<p>// func HelloServer(w http.ResponseWriter, req *http.Request) {<br />
//     io.WriteString(w, “hello, world!\n”)<br />
// }<br />
//<br />
// func main() {<br />
//     http.HandleFunc(“/hello”, HelloServer)<br />
//     log.Fatal(http.ListenAndServe(“:12345”, nil))<br />
// }<br />
func ListenAndServe(addr string, handler Handler) error {<br />
    server := &amp;Server{Addr: addr, Handler: handler}<br />
    return server.ListenAndServe()<br />
}</p><br />
<br />
<p>// err := http.ListenAndServeTLS(“:10443”, “cert.pem”, “key.pem”, nil)<br />
// HTTPS 方式，可以使用 crypto/tls 中的 generate_cert.go 生成 cert.pem 和 key.pem<br />
func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error {<br />
    server := &amp;Server{Addr: addr, Handler: handler}<br />
    return server.ListenAndServeTLS(certFile, keyFile)<br />
}</p><br />
<br />
<p>// ListenAndServe 监听 srv.Addr 地址上的 tcp 网络，然后调用 Serve 服务连接，连接会设置 keep-alives<br />
// 如果 srv.Addr 为空则用 “:http” 代替<br />
// ListenAndServe 总是返回非空 err<br />
func (srv <em>Server) ListenAndServe() error {<br />
    addr := srv.Addr<br />
    if addr == “” {<br />
        addr = “:http”<br />
    }<br />
    ln, err := net.Listen(“tcp”, addr)<br />
    if err != nil {<br />
        return err<br />
    }<br />
    // HTTP:<br />
    return srv.Serve(tcpKeepAliveListener{ln.(</em>net.TCPListener)})</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// HTTPS 方式调用 ListenAndServeTLS(certFile, keyFile string) error<br />
// 与 ListenAndServe 类似，只是最后要关闭 ln 并返回 srv.ServeTLS<br />
// defer ln.Close()<br />
// return srv.ServeTLS(tcpKeepAliveListener{ln.(*net.TCPListener)}, certFile, keyFile) } server 的服务函数 func (srv *Server) ServeTLS(l net.Listener, certFile, keyFile string) error {<br />
// 在 srv.Serve 之前尝试设置 HTTP/2<br />
// setupHTTP2_ServeTLS 中调用 onceSetNextProtoDefaults_Serve，只有 srv.TLSNextProto 为 nil 时才可以设置 HTTP/2<br />
if err := srv.setupHTTP2_ServeTLS(); err != nil {<br />
    return err<br />
}<br />
<br />
config := cloneTLSConfig(srv.TLSConfig)<br />
if !strSliceContains(config.NextProtos, "http/1.1") { // strSliceContains 判断是否包含字符串<br />
    config.NextProtos = append(config.NextProtos, "http/1.1")<br />
}<br />
<br />
configHasCert := len(config.Certificates) &gt; 0 || config.GetCertificate != nil<br />
if !configHasCert || certFile != "" || keyFile != "" {<br />
    var err error<br />
    config.Certificates = make([]tls.Certificate, 1)<br />
    config.Certificates[0], err = tls.LoadX509KeyPair(certFile, keyFile) // LoadX509KeyPair 解析证书，文件中必须含有 PEM 编码数据<br />
    // PEM (Privacy Enhancement Message)，定义见 RFC1421，是一种基于 base64 的编码格式<br />
    if err != nil {<br />
        return err<br />
    }<br />
}<br />
<br />
tlsListener := tls.NewListener(l, config)<br />
return srv.Serve(tlsListener) }<br />
</code></pre></div></div><br />
<br />
<p>// 若启用 HTTP/2，在调用 Serve 前需要根据 listener’s TLS Config 初始化 srv.TLSConfig<br />
// Serve 总是返回非空的 err，在 Shutdown 或 Close 后返回 ErrServerClosed<br />
// Close 是立即关闭 Server 和与之相关的 listeners 和 connections，而 shutdown 是逐步关闭 listeners 和闲置的 connections，两者不会管已被 hijack 的连接<br />
func (srv *Server) Serve(l net.Listener) error {<br />
    defer l.Close()<br />
    if fn := testHookServerServe; fn != nil { // 如果钩子函数 testHookServerServe 非空则调用<br />
        fn(srv, l)<br />
    }<br />
    var tempDelay time.Duration // accept 失败时 sleep 多长时间</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// setupHTTP2_Serve 和 setupHTTP2_ServeTLS 两者都是调用 onceSetNextProtoDefaults() 去尝试设置 HTTP/2<br />
// 只是考虑到多并发情况下的 Serve 请求，setupHTTP2_Serve 采用了更保守的政策去设置 HTTP/2<br />
// setupHTTP2_Serve 先调用 shouldConfigureHTTP2ForServe 判断是否应该为 Server.Serve 设置 HTTP/2<br />
// shouldConfigureHTTP2ForServe 中如果 srv.TLSConfig 为 nil 或者 srv.TLSConfig.NextProtos 包含 "h2" 字样返回真，否则返回假，<br />
if err := srv.setupHTTP2_Serve(); err != nil {<br />
    return err<br />
}<br />
<br />
srv.trackListener(l, true) // 将 l 添加进 server.listeners<br />
defer srv.trackListener(l, false) // 结束后删去 l<br />
<br />
baseCtx := context.Background() // baseContext 会一直存在，但没有值也没有 deadline，用于主函数或者初始化或者测试或者顶层接收请求的 context<br />
ctx := context.WithValue(baseCtx, ServerContextKey, srv)<br />
// WithValue 返回 baseCtx 的副本，副本内的值是一个键值对 ServerContextKey - srv<br />
// ServerContextKey = &amp;contextKey{"http-server"} 与其绑定的 value 类型为 *Server<br />
for {<br />
    rw, e := l.Accept() // 接收到连接<br />
    if e != nil {<br />
        select {<br />
        case &lt;-srv.getDoneChan(): // server 已关闭<br />
            return ErrServerClosed<br />
        default:<br />
        }<br />
        if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() {<br />
            if tempDelay == 0 {<br />
                tempDelay = 5 * time.Millisecond<br />
            } else {<br />
                tempDelay *= 2<br />
            }<br />
            if max := 1 * time.Second; tempDelay &gt; max {<br />
                tempDelay = max<br />
            }<br />
            srv.logf("http: Accept error: %v; retrying in %v", e, tempDelay)<br />
            time.Sleep(tempDelay)<br />
            continue<br />
        }<br />
        return e<br />
    }<br />
    tempDelay = 0<br />
    c := srv.newConn(rw)<br />
    // conn.setState 根据传入的状态调用 trackConn 来设置 server.activeConn 集合，再改变当前 conn.curState<br />
    // 如果 server 设置了 ConnState 这个钩子函数，就调用<br />
    c.setState(c.rwc, StateNew)<br />
    go c.serve(ctx)<br />
} } server.Serve 最后调用 conn.serve 在此函数中调用 serverHandler{c.server}.ServeHTTP(w, w.req) 转入路由模块<br />
</code></pre></div></div><br />
<br />
<p>func (c *conn) serve(ctx context.Context) {<br />
    c.remoteAddr = c.rwc.RemoteAddr().String()<br />
    ctx = context.WithValue(ctx, LocalAddrContextKey, c.rwc.LocalAddr())<br />
    // LocalAddrContextKey = &amp;contextKey{“local-addr”} 与其绑定的 value 类型是 net.Addr<br />
    defer func() {<br />
        if err := recover(); err != nil &amp;&amp; err != ErrAbortHandler {<br />
            const size = 64 « 10 // 64 KB<br />
            buf := make([]byte, size)<br />
            buf = buf[:runtime.Stack(buf, false)]<br />
            c.server.logf(“http: panic serving %v: %v\n%s”, c.remoteAddr, err, buf)<br />
        }<br />
        if !c.hijacked() { // 已经被 hijack 的连接不用管理，由 hijack 的调用者处理<br />
            c.close()<br />
            c.setState(c.rwc, StateClosed)<br />
        }<br />
    }()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if tlsConn, ok := c.rwc.(*tls.Conn); ok { // HTTPS<br />
    if d := c.server.ReadTimeout; d != 0 {<br />
        c.rwc.SetReadDeadline(time.Now().Add(d))<br />
    }<br />
    if d := c.server.WriteTimeout; d != 0 {<br />
        c.rwc.SetWriteDeadline(time.Now().Add(d))<br />
    }<br />
    if err := tlsConn.Handshake(); err != nil {<br />
        c.server.logf("http: TLS handshake error from %s: %v", c.rwc.RemoteAddr(), err)<br />
        return<br />
    }<br />
    c.tlsState = new(tls.ConnectionState)<br />
    *c.tlsState = tlsConn.ConnectionState() // 获取当前 TLS 连接的详细信息<br />
    // NegotiatedProtocol 协商的协议，validNPN 判断 proto 是否属于 "", "http/1.1", "http/1.0" 之一，不属于返回真<br />
    if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) {<br />
        if fn := c.server.TLSNextProto[proto]; fn != nil {<br />
            h := initNPNRequest{tlsConn, serverHandler{c.server}}<br />
            fn(c.server, tlsConn, h) // 发生协议切换时触发钩子函数<br />
        }<br />
        return<br />
    }<br />
}<br />
<br />
// HTTP/1.x following<br />
<br />
ctx, cancelCtx := context.WithCancel(ctx)<br />
// WithCancel 返回 &amp;c, func() { c.cancel(true, Canceled) }<br />
// ctx.cancel close ctx.done 取消所有 ctx 的 children，如果第一个参数为 true，则把 ctx 从其 parent 的 children 列表删去<br />
c.cancelCtx = cancelCtx<br />
defer cancelCtx() // 关闭 ctx，以及相关 goroutines<br />
<br />
c.r = &amp;connReader{conn: c}<br />
c.bufr = newBufioReader(c.r)<br />
c.bufw = newBufioWriterSize(checkConnErrorWriter{c}, 4&lt;&lt;10)<br />
<br />
for {<br />
    w, err := c.readRequest(ctx) // 读取 request 返回 response 和可能的 err<br />
    if c.r.remain != c.server.initialReadLimitSize() { // remain 代表 io.reader 剩余空间，initialReadLimitSize 返回 int64(srv.MaxHeaderBytes &gt; 0 ? srv.MaxHeaderBytes : DefaultMaxHeaderBytes) + 4096<br />
        c.setState(c.rwc, StateActive) // StateActive 代表连接已经从 request 读到数据<br />
    }<br />
    if err != nil {<br />
        const errorHeaders = "\r\nContent-Type: text/plain; charset=utf-8\r\nConnection: close\r\n\r\n"<br />
<br />
        if err == errTooLarge { // errors.New("http: request too large")<br />
            const publicErr = "431 Request Header Fields Too Large"<br />
            fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)<br />
            c.closeWriteAndWait()<br />
            // closewrite flush 所有缓存的数据并发送一个 FIN 包（如果客户端是通过 TCP 连接的），表示我们这边已结束，然后 sleep 500 ms<br />
            return<br />
        }<br />
        if isCommonNetReadError(err) {<br />
            // err 是否是 io.EOF 或者是网络超时 (net.Error) 或者是读 request 的 net.OpError 之一<br />
            return<br />
        }<br />
<br />
        publicErr := "400 Bad Request"<br />
        if v, ok := err.(badRequestError); ok {<br />
            publicErr = publicErr + ": " + string(v)<br />
        }<br />
<br />
        fmt.Fprintf(c.rwc, "HTTP/1.1 "+publicErr+errorHeaders+publicErr)<br />
        return<br />
    }<br />
<br />
    // request Header : Expect 100 Continue<br />
    req := w.req<br />
    if req.expectsContinue() {<br />
        if req.ProtoAtLeast(1, 1) &amp;&amp; req.ContentLength != 0 {<br />
            // after first '100 Continue' request, wrapper response with 'HTTP/1.1 100 Continue'<br />
            req.Body = &amp;expectContinueReader{readCloser: req.Body, resp: w}<br />
        }<br />
    } else if req.Header.get("Expect") != "" {<br />
        w.sendExpectationFailed() // response with status code 417 (Expectation Failed)<br />
        return<br />
    }<br />
<br />
    c.curReq.Store(w)<br />
<br />
    if requestBodyRemains(req.Body) { // 之后是否还能从 body 读取到数据，true 表示能继续读 (未到 io.EOF)<br />
        registerOnHitEOF(req.Body, w.conn.r.startBackgroundRead) // 当 body 读到 EOF，调用传入的 startBackgroundRead 函数<br />
    } else { // 长连接下 HTTP 管线化请求时的处理<br />
        if w.conn.bufr.Buffered() &gt; 0 {<br />
            // [HTTP pipelining](https://zh.wikipedia.org/wiki/HTTP%E7%AE%A1%E7%B7%9A%E5%8C%96)<br />
            w.conn.r.closeNotifyFromPipelinedRequest() // closeNotify()<br />
        }<br />
        w.conn.r.startBackgroundRead()<br />
    }<br />
<br />
    serverHandler{c.server}.ServeHTTP(w, w.req) // server.Handler == nil -&gt; DefaultServeMux.ServeHTTP<br />
    w.cancelCtx()<br />
    if c.hijacked() {<br />
        return<br />
    }<br />
    w.finishRequest()<br />
    if !w.shouldReuseConnection() { // tcp 连接是否可以继续使用<br />
        if w.requestBodyLimitHit || w.closedRequestBodyEarly() {<br />
            // requestBodyLimitHit 在 requestTooLarge 函数中设置，当此值为真，停止读取后续的 request 和输入<br />
            // closedRequestBodyEarly 表示连接之前是否已关闭<br />
            c.closeWriteAndWait()<br />
        }<br />
        return<br />
    }<br />
    c.setState(c.rwc, StateIdle) // StateIdle 表示此连接已处理完一个 request 并处于 keep-alive 状态，等待后续 request<br />
    c.curReq.Store((*response)(nil))<br />
<br />
    if !w.conn.server.doKeepAlives() { // doKeepAlives 判断是否满足 disableKeepAlives == 0 &amp;&amp; inShutdown == 0 (处于 keep-alive 模式且不在 shutdown 状态)<br />
        // We're in shutdown mode. We might've replied<br />
        // to the user without "Connection: close" and<br />
        // they might think they can send another<br />
        // request, but such is life with HTTP/1.1.<br />
        return<br />
    }<br />
<br />
    if d := c.server.idleTimeout(); d != 0 {<br />
        c.rwc.SetReadDeadline(time.Now().Add(d))<br />
        if _, err := c.bufr.Peek(4); err != nil {<br />
            return<br />
        }<br />
    }<br />
    // SetReadDeadline 设置后续读去调用的截止时间，如果传入零值表示不会 timeout<br />
    c.rwc.SetReadDeadline(time.Time{})<br />
} } 流程： 当一个请求 request 进来的时候，server 会依次根据 ServeMux.m 中的 string（路由表达式）来一个一个匹配， 如果找到了可以匹配的 muxEntry，就取出 muxEntry.h，这是个 handler， 调用 handler 中的 ServeHTTP（ResponseWriter, *Request）来组装 Response，并返回。<br />
</code></pre></div></div><br />
<br />
<p>路由接口<br />
// ResponseWriter 接口用于 HTTP handler 生成 response<br />
// 在 Handler.ServeHTTP 返回后，ResponseWriter 不应该再被使用<br />
type ResponseWriter interface {<br />
    Header() Header             // Header() 返回 WriteHeader 要发送的 Header map 集合<br />
    Write([]byte) (int, error)  // Write 写入响应的 body<br />
    WriteHeader(statusCode int) // 这个方法发送 Response 的 Header 和传入的 HTTP 状态码<br />
}</p><br />
<br />
<p>// Flusher 由 ResponseWriters 执行去允许 HTTP handler 将缓存中的数据推给客户端, 默认的 HTTP/1.x 和 HTTP/2 ResponseWriter 支持 Flusher，<br />
// 但是 ResponseWriter 的封装可能会不支持，Handlers 在运行时需要测试是否支持此函数<br />
// 即使 ResponseWriters 支持 Flush，如果客户端使用了 HTTP proxy，直到响应结束，缓存的数据也有可能到达不了客户端<br />
type Flusher interface {<br />
    Flush()<br />
}</p><br />
<br />
<p>// Hijacker 接口由 ResponseWriters 执行去允许 HTTP handler 接管连接<br />
// 默认的 ResponseWriter 支持 HTTP/1.x 连接下的 Hijacker，但是 HTTP/2 连接不支持，HTTP/2 多路复用等情况不适合使用 Hijack 。<br />
// ResponseWriter 封装也可能不支持 Hijacker. Handlers 在运行时需要测试是否支持此函数<br />
type Hijacker interface {<br />
    Hijack() (net.Conn, *bufio.ReadWriter, error)<br />
}</p><br />
<br />
<p>// ServeMux 类型是 HTTP 请求的路由规则转换器。它会将每一个接收的请求的 URL 与一个注册路由的列表进行匹配，并调用和 URL 最匹配的 handler.<br />
// 匹配到多个时较长的模式优先于较短的模式，模式也可以主机名开始，表示只匹配该主机上的路径，指定主机的模式优先于一般的模式，<br />
// ServeMux 还会规范化请求的 URL 路径，将任何包含 “.” 或 “..” 元素的请求重定向到等价的没有这两种元素的 URL<br />
type ServeMux struct {<br />
    mu    sync.RWMutex // 读写锁<br />
    m     map[string]muxEntry // 路由规则，一个 string 对应一个 mux 实体，这里的 string 就是注册的路由表达式<br />
    hosts bool // 是否在任意的规则中带有 host 信息<br />
}</p><br />
<br />
<p>type muxEntry struct {<br />
    h        Handler // 这个路由表达式对应哪个 handler<br />
    pattern  string  // 固定的、由根开始的路径，如 “/favicon.ico”，或由根开始的子树，如 “/images/”，也可以主机名开头<br />
}</p><br />
<br />
<p>// 一个 Handler 响应一个 HTTP 请求<br />
// ServeHTTP 应该将回复的头域和数据写入 ResponseWriter 接口然后返回。返回标志着该请求已经结束，HTTP 服务端可以转移向该连接上的下一个请求。<br />
// 在 ServeHTTP 调用结束之后或者并发执行时，使用 ResponseWriter 或者读取请求体是不可取的<br />
// handler 应该第一时间读取请求体并作出应答，在向 ResponseWriter 写入数据后就不能读取 request body 了. 同时 handler 不应该修改传入的 request<br />
type Handler interface {<br />
    ServeHTTP(ResponseWriter, *Request)<br />
}</p><br />
<br />
<p>// HandlerFunc(f) 是一个调用 f 的 handler<br />
type HandlerFunc func(ResponseWriter, *Request)</p><br />
<br />
<p>// ServeHTTP calls f(w, r).<br />
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {<br />
    f(w, r)<br />
}<br />
请求 - 响应实例<br />
这里实现了一个 404 not found 响应<br />
func NotFound(w ResponseWriter, r *Request) { Error(w, “404 page not found”, StatusNotFound) } // 定义 handler</p><br />
<br />
<p>func NotFoundHandler() Handler { return HandlerFunc(NotFound) }<br />
server 导出的注册函数使用 DefaultServeMux 相应方法<br />
func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }</p><br />
<br />
<p>func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {<br />
    DefaultServeMux.HandleFunc(pattern, handler)<br />
}</p><br />
<br />
<p>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {<br />
    mux.Handle(pattern, HandlerFunc(handler))<br />
}</p><br />
<br />
<p>func (mux *ServeMux) Handle(pattern string, handler Handler) {<br />
    mux.mu.Lock()<br />
    defer mux.mu.Unlock()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if pattern == "" {<br />
    panic("http: invalid pattern")<br />
}<br />
if handler == nil {<br />
    panic("http: nil handler")<br />
}<br />
if _, exist := mux.m[pattern]; exist {<br />
    panic("http: multiple registrations for " + pattern)<br />
}<br />
<br />
if mux.m == nil {<br />
    mux.m = make(map[string]muxEntry)<br />
}<br />
mux.m[pattern] = muxEntry{h: handler, pattern: pattern} // 注册成功<br />
<br />
if pattern[0] != '/' {<br />
    mux.hosts = true<br />
} } ServeHTTP 调用 Handler() 给 request 分派与 request URL 最匹配的 handler func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {<br />
if r.RequestURI == "*" {<br />
    if r.ProtoAtLeast(1, 1) { // ProtoAtLeast 判断是否大于等于协议最低标准，第一个参数是 major 版本号，第二个参数是 minor 版本号，即 http/1.1<br />
        w.Header().Set("Connection", "close") // 小于要求则在响应头返回关闭信息<br />
    }<br />
    w.WriteHeader(StatusBadRequest) // 状态码 400<br />
    return<br />
}<br />
h, _ := mux.Handler(r)<br />
h.ServeHTTP(w, r) // 调用对应 handler 的 ServeHTTP，即执行注册好的 handler 函数，比如 NotFound 函数 } // Handler 通过判断 r.Method, r.Host, and r.URL.Path 返回与 request 对应的 handler // 此函数总会返回非空的 handler. 如果 path 不符合规范形式，返回的是内部生成的重定向到规范路径的 handler // 如果 host 包含端口，匹配 handlers 时会忽略端口。第二个参数返回已注册的与请求匹配的路由 // 如果没有已注册的 handler 与请求匹配, 则返回 ``page not found'' handler 和空的 pattern func (mux *ServeMux) Handler(r *Request) (h Handler, pattern string) {<br />
if r.Method == "CONNECT" {<br />
    // redirectToPathSlash 判断 path 是否需要追加 "/"，因为存在 "path + /" 已注册但 "path"<br />
    // 本身未注册的情况。如果需要追加 "/"，则返回追加的 url 和 true<br />
    if u, ok := mux.redirectToPathSlash(r.URL.Host, r.URL.Path, r.URL); ok {<br />
        return RedirectHandler(u.String(), StatusMovedPermanently), u.Path<br />
    }<br />
<br />
    return mux.handler(r.Host, r.URL.Path)<br />
}<br />
<br />
host := stripHostPort(r.Host) // 去掉 ":&lt;port&gt;"<br />
path := cleanPath(r.URL.Path) // 规范 path 格式，比如缺失多余 '/'、存在相对路径'.'、'..' 等<br />
<br />
if u, ok := mux.redirectToPathSlash(host, path, r.URL); ok {<br />
    return RedirectHandler(u.String(), StatusMovedPermanently), u.Path<br />
}<br />
<br />
// 修改 request 的不规范路径<br />
if path != r.URL.Path {<br />
    _, pattern = mux.handler(host, path)<br />
    url := *r.URL<br />
    url.Path = path<br />
    return RedirectHandler(url.String(), StatusMovedPermanently), pattern<br />
}<br />
<br />
return mux.handler(host, r.URL.Path) }<br />
</code></pre></div></div><br />
<br />
<p>// 在 ServerMux.handler 中当匹配不到注册的路由时返回 NotFoundHandler<br />
func (mux *ServeMux) handler(host, path string) (h Handler, pattern string) {<br />
    mux.mu.RLock()<br />
    defer mux.mu.RUnlock()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if mux.hosts {<br />
    h, pattern = mux.match(host + path) // match 根据完整 URL 优先匹配 handler<br />
}<br />
if h == nil {<br />
    h, pattern = mux.match(path) // 如果 URL 匹配不到再根据路径匹配<br />
}<br />
if h == nil {<br />
    h, pattern = NotFoundHandler(), ""<br />
}<br />
return }<br />
</code></pre></div></div><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>