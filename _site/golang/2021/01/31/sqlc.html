<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">sqlc</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2021-01-31T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jan 31, 2021</time></p>
					</div>
					 <p>https://github.com/kyleconroy/sqlc</p><br />
<br />
<p>database/sql标准库提供的都是比较底层的接口。我们需要编写大量重复的代码。大量的模板代码不仅写起来烦，而且还容易出错。有时候字段类型修改了一下，可能就需要改动很多地方；添加了一个新字段，之前使用select *查询语句的地方都要修改。如果有些地方有遗漏，可能就会造成运行时panic。即使使用 ORM 库，这些问题也不能完全解决！这时候，sqlc来了！sqlc可以根据我们编写的 SQL 语句生成类型安全的、地道的 Go 接口代码，我们要做的只是调用这些方法。<br />
<!-- more --></p><br />
<br />
<p>安装：</p><br />
<br />
<p>$ go get github.com/kyleconroy/sqlc/cmd/sqlc<br />
当然还有对应的数据库驱动：</p><br />
<br />
<p>$ go get github.com/lib/pq<br />
$ go get github.com/go-sql-driver/mysql<br />
sqlc是一个命令行工具，上面代码会将可执行程序sqlc放到$GOPATH/bin目录下。我习惯把$GOPATH/bin目录加入到系统PATH中。所以可以执行使用这个命令。</p><br />
<br />
<p>因为sqlc用到了一个 linux 下的库，在 windows 上无法正常编译。在 windows 上我们可以使用 docker 镜像kjconroy/sqlc。docker 的安装就不介绍了，网上有很多教程。拉取kjconroy/sqlc镜像：</p><br />
<br />
<p>$ docker pull kjconroy/sqlc<br />
然后，编写 SQL 语句。在schema.sql文件中编写建表语句：</p><br />
<br />
<p>CREATE TABLE authors (<br />
  id   BIGSERIAL PRIMARY KEY,<br />
  name TEXT NOT NULL,<br />
  bio  TEXT<br />
);<br />
在query.sql文件中编写查询语句：</p><br />
<br />
<p>– name: GetAuthor :one<br />
SELECT * FROM authors<br />
WHERE id = $1 LIMIT 1;</p><br />
<br />
<p>– name: ListAuthors :many<br />
SELECT * FROM authors<br />
ORDER BY name;</p><br />
<br />
<p>– name: CreateAuthor :exec<br />
INSERT INTO authors (<br />
  name, bio<br />
) VALUES (<br />
  $1, $2<br />
)<br />
RETURNING *;</p><br />
<br />
<p>– name: DeleteAuthor :exec<br />
DELETE FROM authors<br />
WHERE id = $1;<br />
sqlc支持 PostgreSQL 和 MySQL，不过对 MySQL 的支持是实验性的。期待后续完善对 MySQL 的支持，增加对其它数据库的支持。本文我们使用的是 PostgreSQL。编写数据库程序时，上面两个 sql 文件是少不了的。sqlc额外只需要一个小小的配置文件sqlc.yaml：</p><br />
<br />
<p>version: “1”<br />
packages:</p><br />
<ul><br />
  <li>name: “db”<br />
path: “./db”<br />
queries: “./query.sql”<br />
schema: “./schema.sql”<br />
version：版本；<br />
packages：</li><br />
</ul><br />
<br />
<p>name：生成的包名；<br />
path：生成文件的路径；<br />
queries：查询 SQL 文件；<br />
schema：建表 SQL 文件。<br />
在 windows 上执行下面的命令生成对应的 Go 代码：</p><br />
<br />
<p>docker run –rm -v CONFIG_PATH:/src -w /src kjconroy/sqlc generate<br />
上面的CONFIG_PATH替换成配置所在目录，我的是D:\code\golang\src\github.com\darjun\go-daily-lib\sqlc\get-started。sqlc为我们在同级目录下生成了数据库操作代码，目录结构如下：</p><br />
<br />
<p>db<br />
├── db.go<br />
├── models.go<br />
└── query.sql.go<br />
sqlc根据我们schema.sql和query.sql生成了模型对象结构：</p><br />
<br />
<p>// models.go<br />
type Author struct {<br />
  ID   int64<br />
  Name string<br />
  Bio  sql.NullString<br />
}<br />
和操作接口：</p><br />
<br />
<p>// query.sql.go<br />
func (q *Queries) CreateAuthor(ctx context.Context, arg CreateAuthorParams) (Author, error)<br />
func (q *Queries) DeleteAuthor(ctx context.Context, id int64) error<br />
func (q *Queries) GetAuthor(ctx context.Context, id int64) (Author, error)<br />
func (q *Queries) ListAuthors(ctx context.Context) ([]Author, error)<br />
其中Queries是sqlc封装的一个结构。</p><br />
<br />
<p>说了这么多，来看看如何使用：</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
  “database/sql”<br />
  “fmt”<br />
  “log”</p><br />
<br />
<p>_ “github.com/lib/pq”<br />
  “golang.org/x/net/context”</p><br />
<br />
<p>“github.com/darjun/go-daily-lib/sqlc/get-started/db”<br />
)</p><br />
<br />
<p>func main() {<br />
  pq, err := sql.Open(“postgres”, “dbname=sqlc sslmode=disable”)<br />
  if err != nil {<br />
    log.Fatal(err)<br />
  }</p><br />
<br />
<p>queries := db.New(pq)</p><br />
<br />
<p>authors, err := queries.ListAuthors(context.Background())<br />
  if err != nil {<br />
    log.Fatal(“ListAuthors error:”, err)<br />
  }<br />
  fmt.Println(authors)</p><br />
<br />
<p>insertedAuthor, err := queries.CreateAuthor(context.Background(), db.CreateAuthorParams{<br />
    Name: “Brian Kernighan”,<br />
    Bio:  sql.NullString{String: “Co-author of The C Programming Language and The Go Programming Language”, Valid: true},<br />
  })<br />
  if err != nil {<br />
    log.Fatal(“CreateAuthor error:”, err)<br />
  }<br />
  fmt.Println(insertedAuthor)</p><br />
<br />
<p>fetchedAuthor, err := queries.GetAuthor(context.Background(), insertedAuthor.ID)<br />
  if err != nil {<br />
    log.Fatal(“GetAuthor error:”, err)<br />
  }<br />
  fmt.Println(fetchedAuthor)</p><br />
<br />
<p>err = queries.DeleteAuthor(context.Background(), insertedAuthor.ID)<br />
  if err != nil {<br />
    log.Fatal(“DeleteAuthor error:”, err)<br />
  }<br />
}<br />
生成的代码在包db下（由packages.name选项指定），首先调用db.New()将sql.Open()的返回值sql.DB作为参数传入，得到Queries对象。我们对authors表的操作都需要通过该对象的方法。</p><br />
<br />
<p>上面程序要运行，还需要启动 PostgreSQL，创建数据库和表：</p><br />
<br />
<p>$ createdb sqlc<br />
$ psql -f schema.sql -d sqlc<br />
上面第一条命令创建一个名为sqlc的数据库，第二条命令在数据库sqlc中执行schema.sql文件中的语句，即创建表。</p><br />
<br />
<p>最后运行程序（多文件程序不能用go run main.go）：</p><br />
<br />
<p>$ go run .<br />
[]<br />
{1 Brian Kernighan {Co-author of The C Programming Language and The Go Programming Language true}}<br />
{1 Brian Kernighan {Co-author of The C Programming Language and The Go Programming Language true}}<br />
代码生成<br />
除了 SQL 语句本身，sqlc需要我们在编写 SQL 语句的时候通过注释的方式为生成的程序提供一些基本信息。语法为：</p><br />
<br />
<p>– name: <name> <cmd><br />
name为生成的方法名，如上面的CreateAuthor/ListAuthors/GetAuthor/DeleteAuthor等，cmd可以有以下取值：</cmd></name></p><br />
<br />
<p>:one：表示 SQL 语句返回一个对象，生成的方法的返回值为(对象类型, error)，对象类型可以从表名得出；<br />
:many：表示 SQL 语句会返回多个对象，生成的方法的返回值为([]对象类型, error)；<br />
:exec：表示 SQL 语句不返回对象，只返回一个error；<br />
:execrows：表示 SQL 语句需要返回受影响的行数。<br />
:one<br />
– name: GetAuthor :one<br />
SELECT id, name, bio FROM authors<br />
WHERE id = $1 LIMIT 1<br />
注释中–name指示生成方法GetAuthor，从表名得出返回的基础类型为Author。:one又表示只返回一个对象。故最终的返回值为(Author, error)：</p><br />
<br />
<p>// db/query.sql.go<br />
const getAuthor = <code class="language-plaintext highlighter-rouge">-- name: GetAuthor :one<br />
SELECT id, name, bio FROM authors<br />
WHERE id = $1 LIMIT 1<br />
</code></p><br />
<br />
<p>func (q *Queries) GetAuthor(ctx context.Context, id int64) (Author, error) {<br />
  row := q.db.QueryRowContext(ctx, getAuthor, id)<br />
  var i Author<br />
  err := row.Scan(&amp;i.ID, &amp;i.Name, &amp;i.Bio)<br />
  return i, err<br />
}<br />
:many<br />
– name: ListAuthors :many<br />
SELECT * FROM authors<br />
ORDER BY name;<br />
注释中–name指示生成方法ListAuthors，从表名authors得到返回的基础类型为Author。:many表示返回一个对象的切片。故最终的返回值为([]Author, error)：</p><br />
<br />
<p>// db/query.sql.go<br />
const listAuthors = <code class="language-plaintext highlighter-rouge">-- name: ListAuthors :many<br />
SELECT id, name, bio FROM authors<br />
ORDER BY name<br />
</code></p><br />
<br />
<p>func (q *Queries) ListAuthors(ctx context.Context) ([]Author, error) {<br />
  rows, err := q.db.QueryContext(ctx, listAuthors)<br />
  if err != nil {<br />
    return nil, err<br />
  }<br />
  defer rows.Close()<br />
  var items []Author<br />
  for rows.Next() {<br />
    var i Author<br />
    if err := rows.Scan(&amp;i.ID, &amp;i.Name, &amp;i.Bio); err != nil {<br />
      return nil, err<br />
    }<br />
    items = append(items, i)<br />
  }<br />
  if err := rows.Close(); err != nil {<br />
    return nil, err<br />
  }<br />
  if err := rows.Err(); err != nil {<br />
    return nil, err<br />
  }<br />
  return items, nil<br />
}<br />
这里注意一个细节，即使我们使用了select *，生成的代码中 SQL 语句被也改写成了具体的字段：</p><br />
<br />
<p>SELECT id, name, bio FROM authors<br />
ORDER BY name<br />
这样后续如果我们需要添加或删除字段，只要执行了sqlc命令，这个 SQL 语句和ListAuthors()方法就能保持一致！是不是很方便？</p><br />
<br />
<p>:exec<br />
– name: DeleteAuthor :exec<br />
DELETE FROM authors<br />
WHERE id = $1<br />
注释中–name指示生成方法DeleteAuthor，从表名authors得到返回的基础类型为Author。:exec表示不返回对象。故最终的返回值为error：</p><br />
<br />
<p>// db/query.sql.go<br />
const deleteAuthor = <code class="language-plaintext highlighter-rouge">-- name: DeleteAuthor :exec<br />
DELETE FROM authors<br />
WHERE id = $1<br />
</code></p><br />
<br />
<p>func (q *Queries) DeleteAuthor(ctx context.Context, id int64) error {<br />
  _, err := q.db.ExecContext(ctx, deleteAuthor, id)<br />
  return err<br />
}<br />
:execrows<br />
– name: DeleteAuthorN :execrows<br />
DELETE FROM authors<br />
WHERE id = $1<br />
注释中–name指示生成方法DeleteAuthorN，从表名authors得到返回的基础类型为Author。:exec表示返回受影响的行数（即删除了多少行）。故最终的返回值为(int64, error)：</p><br />
<br />
<p>// db/query.sql.go<br />
const deleteAuthorN = <code class="language-plaintext highlighter-rouge">-- name: DeleteAuthorN :execrows<br />
DELETE FROM authors<br />
WHERE id = $1<br />
</code></p><br />
<br />
<p>func (q *Queries) DeleteAuthorN(ctx context.Context, id int64) (int64, error) {<br />
  result, err := q.db.ExecContext(ctx, deleteAuthorN, id)<br />
  if err != nil {<br />
    return 0, err<br />
  }<br />
  return result.RowsAffected()<br />
}<br />
不管编写的 SQL 多复杂，总是逃不过上面的规则。我们只需要在编写 SQL 语句时额外添加一行注释，sqlc就能为我们生成地道的 SQL 操作方法。生成的代码与我们自己手写的没什么不同，错误处理都很完善，而且了避免手写的麻烦与错误。</p><br />
<br />
<p>模型对象<br />
sqlc为所有的建表语句生成对应的模型结构。结构名为表名的单数形式，且首字母大写。例如：</p><br />
<br />
<p>CREATE TABLE authors (<br />
  id   SERIAL PRIMARY KEY,<br />
  name text   NOT NULL<br />
);<br />
生成对应的结构：</p><br />
<br />
<p>type Author struct {<br />
  ID   int<br />
  Name string<br />
}<br />
而且sqlc可以解析ALTER TABLE语句，它会根据最终的表结构来生成模型对象的结构。例如：</p><br />
<br />
<p>CREATE TABLE authors (<br />
  id          SERIAL PRIMARY KEY,<br />
  birth_year  int    NOT NULL<br />
);</p><br />
<br />
<p>ALTER TABLE authors ADD COLUMN bio text NOT NULL;<br />
ALTER TABLE authors DROP COLUMN birth_year;<br />
ALTER TABLE authors RENAME TO writers;<br />
上面的 SQL 语句中，建表时有两列id和birth_year。第一条ALTER TABLE语句添加了一列bio，第二条删除了birth_year列，第三条将表名authors改为writers。sqlc依据最终的表名writers和表中的列id、bio生成代码：</p><br />
<br />
<p>package db</p><br />
<br />
<p>type Writer struct {<br />
  ID  int<br />
  Bio string<br />
}<br />
配置字段<br />
sqlc.yaml文件中还可以设置其他的配置字段。</p><br />
<br />
<p>emit_json_tags<br />
默认为false，设置该字段为true可以为生成的模型对象结构添加 JSON 标签。例如：</p><br />
<br />
<p>CREATE TABLE authors (<br />
  id         SERIAL    PRIMARY KEY,<br />
  created_at timestamp NOT NULL<br />
);<br />
生成：</p><br />
<br />
<p>package db</p><br />
<br />
<p>import (<br />
  “time”<br />
)</p><br />
<br />
<p>type Author struct {<br />
  ID        int       <code class="language-plaintext highlighter-rouge">json:"id"</code><br />
  CreatedAt time.Time <code class="language-plaintext highlighter-rouge">json:"created_at"</code><br />
}<br />
emit_prepared_queries<br />
默认为false，设置该字段为true，会为 SQL 生成对应的prepared statement。例如，在快速开始的示例中设置这个选项，最终生成的结构Queries中会添加所有 SQL 对应的prepared statement对象：</p><br />
<br />
<p>type Queries struct {<br />
  db                DBTX<br />
  tx                *sql.Tx<br />
  createAuthorStmt  *sql.Stmt<br />
  deleteAuthorStmt  *sql.Stmt<br />
  getAuthorStmt     *sql.Stmt<br />
  listAuthorsStmt   *sql.Stmt<br />
}<br />
和一个Prepare()方法：</p><br />
<br />
<p>func Prepare(ctx context.Context, db DBTX) (*Queries, error) {<br />
  q := Queries{db: db}<br />
  var err error<br />
  if q.createAuthorStmt, err = db.PrepareContext(ctx, createAuthor); err != nil {<br />
    return nil, fmt.Errorf(“error preparing query CreateAuthor: %w”, err)<br />
  }<br />
  if q.deleteAuthorStmt, err = db.PrepareContext(ctx, deleteAuthor); err != nil {<br />
    return nil, fmt.Errorf(“error preparing query DeleteAuthor: %w”, err)<br />
  }<br />
  if q.getAuthorStmt, err = db.PrepareContext(ctx, getAuthor); err != nil {<br />
    return nil, fmt.Errorf(“error preparing query GetAuthor: %w”, err)<br />
  }<br />
  if q.listAuthorsStmt, err = db.PrepareContext(ctx, listAuthors); err != nil {<br />
    return nil, fmt.Errorf(“error preparing query ListAuthors: %w”, err)<br />
  }<br />
  return &amp;q, nil<br />
}<br />
生成的其它方法都使用了这些对象，而非直接使用 SQL 语句：</p><br />
<br />
<p>func (q *Queries) CreateAuthor(ctx context.Context, arg CreateAuthorParams) (Author, error) {<br />
  row := q.queryRow(ctx, q.createAuthorStmt, createAuthor, arg.Name, arg.Bio)<br />
  var i Author<br />
  err := row.Scan(&amp;i.ID, &amp;i.Name, &amp;i.Bio)<br />
  return i, err<br />
}<br />
我们需要在程序初始化时调用这个Prepare()方法。</p><br />
<br />
<p>emit_interface<br />
默认为false，设置该字段为true，会为查询结构生成一个接口。例如，在快速开始的示例中设置这个选项，最终生成的代码会多出一个文件querier.go：</p><br />
<br />
<p>// db/querier.go<br />
type Querier interface {<br />
  CreateAuthor(ctx context.Context, arg CreateAuthorParams) (Author, error)<br />
  DeleteAuthor(ctx context.Context, id int64) error<br />
  DeleteAuthorN(ctx context.Context, id int64) (int64, error)<br />
  GetAuthor(ctx context.Context, id int64) (Author, error)<br />
  ListAuthors(ctx context.Context) ([]Author, error)<br />
}<br />
覆写类型<br />
sqlc在生成模型对象结构时会根据数据库表的字段类型推算出一个 Go 语言类型，例如text对应string。我们也可以在配置文件中指定这种类型映射。</p><br />
<br />
<p>version: “1”<br />
packages:</p><br />
<ul><br />
  <li>name: “db”<br />
path: “./db”<br />
queries: “./query.sql”<br />
schema: “./schema.sql”<br />
overrides:</li><br />
  <li>go_type: “github.com/uniplaces/carbon.Time”<br />
db_type: “pg_catalog.timestamp”<br />
在overrides下go_type表示使用的 Go 类型。如果是非标准类型，必须指定全限定类型（即包路径 + 类型名）。db_type设置为要映射的数据库类型。sqlc会自动导入对应的标准包或第三方包。生成代码如下：</li><br />
</ul><br />
<br />
<p>package db</p><br />
<br />
<p>import (<br />
  “github.com/uniplaces/carbon”<br />
)</p><br />
<br />
<p>type Author struct {<br />
  ID       int32<br />
  Name     string<br />
  CreateAt carbon.Time<br />
}<br />
需要注意的是db_type的表示，文档这里一笔带过，使用上还是有些晦涩。我也是看源码才找到如何覆写timestamp类型的，需要将db_type设置为pg_catalog.timestamp。同理timestamptz、timetz等类型也需要加上这个前缀。一般复杂类型都需要加上前缀，一般的基础类型可以加也可以不加。遇到不确定的情况，可以去看看源码gen.go#L634。</p><br />
<br />
<p>也可以设定某个字段的类型，例如我们要将创建时间字段created_at设置为使用carbon.Time：</p><br />
<br />
<p>version: “1”<br />
packages:</p><br />
<ul><br />
  <li>name: “db”<br />
path: “./db”<br />
queries: “./query.sql”<br />
schema: “./schema.sql”<br />
overrides:</li><br />
  <li>column: “authors.create_at”<br />
go_type: “github.com/uniplaces/carbon.Time”<br />
生成代码如下：</li><br />
</ul><br />
<br />
<p>// db/models.go<br />
package db</p><br />
<br />
<p>import (<br />
  “github.com/uniplaces/carbon”<br />
)</p><br />
<br />
<p>type Author struct {<br />
  ID       int32<br />
  Name     string<br />
  CreateAt carbon.Time<br />
}<br />
最后我们还可以给生成的结构字段命名：</p><br />
<br />
<p>version: “1”<br />
packages:</p><br />
<ul><br />
  <li>name: “db”<br />
path: “./db”<br />
queries: “./query.sql”<br />
schema: “./schema.sql”<br />
rename:<br />
id: “Id”<br />
name: “UserName”<br />
create_at: “CreateTime”<br />
上面配置为生成的结构设置字段名，生成代码：</li><br />
</ul><br />
<br />
<p>package db</p><br />
<br />
<p>import (<br />
  “time”<br />
)</p><br />
<br />
<p>type Author struct {<br />
  Id         int32<br />
  UserName   string<br />
  CreateTime time.Time<br />
}<br />
安装 PostgreSQL<br />
我之前使用 MySQL 较多。由于sqlc对 MySQL 的支持不太好，在体验这个库的时候还是选择支持较好的 PostgreSQL。不得不说，在 win10 上，PostgreSQL 的安装门槛实在是太高了！我摸索了很久最后只能在https://www.enterprisedb.com/download-postgresql-binaries下载可执行文件。我选择了 10.12 版本，下载、解压、将文件夹中的bin加入系统PATH。创建一个data目录，然后执行下面的命令初始化数据：</p><br />
<br />
<p>$ initdb data<br />
注册 PostgreSQL 服务，这样每次系统重启后会自动启动：</p><br />
<br />
<p>$ pg_ctl register -N “pgsql” -D D:\data<br />
这里的data目录就是上面创建的，并且一定要使用绝对路径！</p><br />
<br />
<p>启动服务：</p><br />
<br />
<p>$ sc start pgsql<br />
最后使用我们前面介绍的命令创建数据库和表即可</p><br />
<br />
<p>需要注意的是sql 语法支持不全面，复杂的语法不支持，比如in关键字</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>