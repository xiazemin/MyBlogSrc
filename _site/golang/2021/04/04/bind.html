<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">bind echo 数据绑定</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2021-04-04T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 4, 2021</time></p>
					</div>
					 <p>echo v4.1.17升级到v4.2.1后数据绑定失败<br />
我们知道http的参数传递的形式有很多，header、path、query、body，body( json,form)等等，针对各种形式的参数，通过bind方式来解析是比较清晰的方式，但是echo的bind 方式也是在从不完完善到逐渐完善的过程中，实践中你会发现，不同版本的echo，会出现诡异的结果，我将以下面的例子，针对v3.3.10、v4.1.17、v4.2.1三个版本的echo进行分析。</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
  “fmt”<br />
  “net/http”</p><br />
<br />
<p>“github.com/labstack/echo/v4”<br />
)</p><br />
<br />
<p>type User struct {<br />
  Name  string <code class="language-plaintext highlighter-rouge">json:"name" xml:"name</code> //param:”name” query:”name” form:”name”   //curl -XGET http://localhost:1323/users/Joe\?email=joe_email<br />
  Email string <code class="language-plaintext highlighter-rouge">json:"email" form:"email" query:"email"</code><br />
}</p><br />
<br />
<p>func main() {<br />
  e := echo.New()<br />
  e.GET(“/users/:name”, func(c echo.Context) error {<br />
    u := new(User)<br />
    u.Name = c.Param(“name”)<br />
    if err := c.Bind(u); err != nil {<br />
      return c.JSON(http.StatusBadRequest, nil)<br />
    }<br />
    return c.JSON(http.StatusOK, u)<br />
  })<br />
  fmt.Println(“——————–”)<br />
  e.GET(“/users/:name/share/:id”, func(c echo.Context) error {<br />
    u := new(User)<br />
    //u.Name = c.Param(“name”)<br />
    if err := c.Bind(u); err != nil {<br />
      return c.JSON(http.StatusBadRequest, nil)<br />
    }<br />
    return c.JSON(http.StatusOK, u)<br />
  })<br />
  fmt.Println(“——————–”)<br />
  e.GET(“/users/names”, func(c echo.Context) error {<br />
    u := new(User)<br />
    if err := c.Bind(u); err != nil {<br />
      return c.JSON(http.StatusBadRequest, nil)<br />
    }<br />
    return c.JSON(http.StatusOK, u)<br />
  })<br />
  fmt.Println(“——————–”)<br />
  e.GET(“/users/names/*”, func(c echo.Context) error {<br />
    u := new(User)<br />
    if err := c.Bind(u); err != nil {<br />
      return c.JSON(http.StatusBadRequest, nil)<br />
    }<br />
    return c.JSON(http.StatusOK, u)<br />
  })<br />
  fmt.Println(e.Start(“:1336”))<br />
}<br />
如果我们引用</p><br />
<br />
<p>“github.com/labstack/echo”<br />
默认版本是v3.3.10</p><br />
<br />
<p>如果引用</p><br />
<br />
<p>“github.com/labstack/echo/v4”<br />
默认是最新版v4.2.1，但是v4.2.1和v4.1.17版本差异比较大，所以分析上述三个版本。</p><br />
<br />
<p>首先看下路由注册的过程</p><br />
<br />
<p>e.GET(“/users/:name”, func(c echo.Context) error {<br />
    u := new(User)<br />
    u.Name = c.Param(“name”)<br />
    if err := c.Bind(u); err != nil {<br />
      return c.JSON(http.StatusBadRequest, nil)<br />
    }<br />
    return c.JSON(http.StatusOK, u)<br />
  })<br />
func (e *Echo) Add(method, path string, handler HandlerFunc, middleware …MiddlewareFunc) *Route {<br />
  name := handlerName(handler)<br />
  e.router.Add(method, path, func(c Context) error {<br />
    h := handler<br />
    // Chain middleware<br />
    for i := len(middleware) - 1; i &gt;= 0; i– {<br />
      h = middleware<a href="h">i</a><br />
    }<br />
    return h(c)<br />
  })<br />
  r := &amp;Route{<br />
    Method: method,<br />
    Path:   path,<br />
    Name:   name,<br />
  }<br />
  e.router.routes[method+path] = r<br />
  return r<br />
}<br />
func (r *Router) Add(method, path string, h HandlerFunc) {<br />
  // Validate path<br />
  if path == “” {<br />
    panic(“echo: path cannot be empty”)<br />
  }<br />
  if path[0] != ‘/’ {<br />
    path = “/” + path<br />
  }<br />
  pnames := []string{} // Param names<br />
  ppath := path        // Pristine path</p><br />
<br />
<p>for i, l := 0, len(path); i &lt; l; i++ {<br />
    if path[i] == ‘:’ {<br />
      j := i + 1</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  r.insert(method, path[:i], nil, skind, "", nil)<br />
  for ; i &lt; l &amp;&amp; path[i] != '/'; i++ {<br />
  }<br />
<br />
  pnames = append(pnames, path[j:i])<br />
  path = path[:j] + path[i:]<br />
  i, l = j, len(path)<br />
<br />
  if i == l {<br />
    r.insert(method, path[:i], h, pkind, ppath, pnames)<br />
    return<br />
  }<br />
  r.insert(method, path[:i], nil, pkind, "", nil)<br />
} else if path[i] == '*' {<br />
  r.insert(method, path[:i], nil, skind, "", nil)<br />
  pnames = append(pnames, "*")<br />
  r.insert(method, path[:i+1], h, akind, ppath, pnames)<br />
  return<br />
}   }<br />
</code></pre></div></div><br />
<br />
<p>r.insert(method, path, h, skind, ppath, pnames)<br />
}<br />
这里可以看到，在路由注册构建前缀树的过程中会把路由解析规整为三个类型，路径参数类型（：），精确匹配路由（/），正则匹配路由（*）</p><br />
<br />
<p>同时针对路径参数类型（：），会将路径中的参数名字保存在变量pnames里面，最终存在router的tree上</p><br />
<br />
<p>func (r *Router) insert(method, path string, h HandlerFunc, t kind, ppath string, pnames []string) {<br />
  // Adjust max param<br />
  l := len(pnames)<br />
  if *r.echo.maxParam &lt; l {<br />
    *r.echo.maxParam = l<br />
  }</p><br />
<br />
<p>cn := r.tree // Current node as root<br />
  if cn == nil {<br />
    panic(“echo: invalid method”)<br />
  }<br />
  search := path</p><br />
<br />
<p>for {<br />
    sl := len(search)<br />
    pl := len(cn.prefix)<br />
    l := 0</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// LCP<br />
max := pl<br />
if sl &lt; max {<br />
  max = sl<br />
}<br />
for ; l &lt; max &amp;&amp; search[l] == cn.prefix[l]; l++ {<br />
}<br />
<br />
if l == 0 {<br />
  // At root node<br />
  cn.label = search[0]<br />
  cn.prefix = search<br />
  if h != nil {<br />
    cn.kind = t<br />
    cn.addHandler(method, h)<br />
    cn.ppath = ppath<br />
    cn.pnames = pnames<br />
  }<br />
} else if l &lt; pl {<br />
  // Split node<br />
  n := newNode(cn.kind, cn.prefix[l:], cn, cn.children, cn.methodHandler, cn.ppath, cn.pnames)<br />
<br />
  // Reset parent node<br />
  cn.kind = skind<br />
  cn.label = cn.prefix[0]<br />
  cn.prefix = cn.prefix[:l]<br />
  cn.children = nil<br />
  cn.methodHandler = new(methodHandler)<br />
  cn.ppath = ""<br />
  cn.pnames = nil<br />
<br />
  cn.addChild(n)<br />
<br />
  if l == sl {<br />
    // At parent node<br />
    cn.kind = t<br />
    cn.addHandler(method, h)<br />
    cn.ppath = ppath<br />
    cn.pnames = pnames<br />
  } else {<br />
    // Create child node<br />
    n = newNode(t, search[l:], cn, nil, new(methodHandler), ppath, pnames)<br />
    n.addHandler(method, h)<br />
    cn.addChild(n)<br />
  }<br />
} else if l &lt; sl {<br />
  search = search[l:]<br />
  c := cn.findChildWithLabel(search[0])<br />
  if c != nil {<br />
    // Go deeper<br />
    cn = c<br />
    continue<br />
  }<br />
  // Create child node<br />
  n := newNode(t, search, cn, nil, new(methodHandler), ppath, pnames)<br />
  n.addHandler(method, h)<br />
  cn.addChild(n)<br />
} else {<br />
  // Node already exists<br />
  if h != nil {<br />
    cn.addHandler(method, h)<br />
    cn.ppath = ppath<br />
    if len(cn.pnames) == 0 { // Issue #729<br />
      cn.pnames = pnames<br />
    }<br />
  }<br />
}<br />
return   } } 接着我们看下，请求到来的时候，参数匹配的过程<br />
</code></pre></div></div><br />
<br />
<p>func (e <em>Echo) ServeHTTP(w http.ResponseWriter, r *http.Request) {<br />
  // Acquire context<br />
  c := e.pool.Get().(</em>context)<br />
  c.Reset(r, w)</p><br />
<br />
<p>h := NotFoundHandler</p><br />
<br />
<p>if e.premiddleware == nil {<br />
    e.router.Find(r.Method, getPath(r), c)<br />
    h = c.Handler()<br />
    for i := len(e.middleware) - 1; i &gt;= 0; i– {<br />
      h = e.middleware<a href="h">i</a><br />
    }<br />
  } else {<br />
    h = func(c Context) error {<br />
      e.router.Find(r.Method, getPath(r), c)<br />
      h := c.Handler()<br />
      for i := len(e.middleware) - 1; i &gt;= 0; i– {<br />
        h = e.middleware<a href="h">i</a><br />
      }<br />
      return h(c)<br />
    }<br />
    for i := len(e.premiddleware) - 1; i &gt;= 0; i– {<br />
      h = e.premiddleware<a href="h">i</a><br />
    }<br />
  }</p><br />
<br />
<p>// Execute chain<br />
  if err := h(c); err != nil {<br />
    e.HTTPErrorHandler(err, c)<br />
  }</p><br />
<br />
<p>// Release context<br />
  e.pool.Put(c)<br />
}<br />
其实就是到router中通过最长前缀匹配算法进行匹配</p><br />
<br />
<p>e.router.Find(r.Method, getPath(r), c)<br />
其中getPath函数定义如下</p><br />
<br />
<p>func getPath(r *http.Request) string {<br />
  path := r.URL.RawPath<br />
  if path == “” {<br />
    path = r.URL.Path<br />
  }<br />
  return path<br />
}<br />
find是路径匹配的过程</p><br />
<br />
<p>func (r <em>Router) Find(method, path string, c Context) {<br />
  ctx := c.(</em>context)<br />
  ctx.path = path<br />
  cn := r.tree // Current node as root</p><br />
<br />
<p>var (<br />
    search  = path<br />
    child   *node         // Child node<br />
    n       int           // Param counter<br />
    nk      kind          // Next kind<br />
    nn      *node         // Next node<br />
    ns      string        // Next search<br />
    pvalues = ctx.pvalues // Use the internal slice so the interface can keep the illusion of a dynamic slice<br />
  )</p><br />
<br />
<p>// Search order static &gt; param &gt; any<br />
  for {<br />
    if search == “” {<br />
      break<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pl := 0 // Prefix length<br />
l := 0  // LCP length<br />
<br />
if cn.label != ':' {<br />
  sl := len(search)<br />
  pl = len(cn.prefix)<br />
<br />
  // LCP<br />
  max := pl<br />
  if sl &lt; max {<br />
    max = sl<br />
  }<br />
  for ; l &lt; max &amp;&amp; search[l] == cn.prefix[l]; l++ {<br />
  }<br />
}<br />
<br />
if l == pl {<br />
  // Continue search<br />
  search = search[l:]<br />
} else {<br />
  cn = nn<br />
  search = ns<br />
  if nk == pkind {<br />
    goto Param<br />
  } else if nk == akind {<br />
    goto Any<br />
  }<br />
  // Not found<br />
  return<br />
}<br />
<br />
if search == "" {<br />
  break<br />
}<br />
<br />
// Static node<br />
if child = cn.findChild(search[0], skind); child != nil {<br />
  // Save next<br />
  if cn.prefix[len(cn.prefix)-1] == '/' { // Issue #623<br />
    nk = pkind<br />
    nn = cn<br />
    ns = search<br />
  }<br />
  cn = child<br />
  continue<br />
}<br />
<br />
// Param node   Param:<br />
if child = cn.findChildByKind(pkind); child != nil {<br />
  // Issue #378<br />
  if len(pvalues) == n {<br />
    continue<br />
  }<br />
<br />
  // Save next<br />
  if cn.prefix[len(cn.prefix)-1] == '/' { // Issue #623<br />
    nk = akind<br />
    nn = cn<br />
    ns = search<br />
  }<br />
<br />
  cn = child<br />
  i, l := 0, len(search)<br />
  for ; i &lt; l &amp;&amp; search[i] != '/'; i++ {<br />
  }<br />
  pvalues[n] = search[:i]<br />
  n++<br />
  search = search[i:]<br />
  continue<br />
}<br />
<br />
// Any node   Any:<br />
if cn = cn.findChildByKind(akind); cn == nil {<br />
  if nn != nil {<br />
    cn = nn<br />
    nn = cn.parent // Next (Issue #954)<br />
    search = ns<br />
    if nk == pkind {<br />
      goto Param<br />
    } else if nk == akind {<br />
      goto Any<br />
    }<br />
  }<br />
  // Not found<br />
  return<br />
}<br />
pvalues[len(cn.pnames)-1] = search<br />
break   }<br />
</code></pre></div></div><br />
<br />
<p>ctx.handler = cn.findHandler(method)<br />
  ctx.path = cn.ppath<br />
  ctx.pnames = cn.pnames</p><br />
<br />
<p>// NOTE: Slow zone…<br />
  if ctx.handler == nil {<br />
    ctx.handler = cn.checkMethodNotAllowed()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Dig further for any, might have an empty value for *, e.g.<br />
// serving a directory. Issue #207.<br />
if cn = cn.findChildByKind(akind); cn == nil {<br />
  return<br />
}<br />
if h := cn.findHandler(method); h != nil {<br />
  ctx.handler = h<br />
} else {<br />
  ctx.handler = cn.checkMethodNotAllowed()<br />
}<br />
ctx.path = cn.ppath<br />
ctx.pnames = cn.pnames<br />
pvalues[len(cn.pnames)-1] = ""   }<br />
</code></pre></div></div><br />
<br />
<p>return<br />
}<br />
可以看到，将匹配到的值和路径参数名一一对应保存到了pvalues里面，最终是保存再来ctx里面</p><br />
<br />
<p>可以看到匹配过程中，会根据路径参数类型来进行处理</p><br />
<br />
<p>func (n *node) findChild(l byte, t kind) *node {<br />
  for _, c := range n.children {<br />
    if c.label == l &amp;&amp; c.kind == t {<br />
      return c<br />
    }<br />
  }<br />
  return nil<br />
}<br />
有没有简单直接的方法来查看我们最终路由注册后pnames的存储结果和请求路径匹配过程中pvalues的参数匹配结果呢？可以在echo中，加下面几行代码，进行打印</p><br />
<br />
<p>func (e *Echo) Add(method, path string, handler HandlerFunc, middleware …MiddlewareFunc) *Route {<br />
  e.router.routes[method+path] = r<br />
  printTree(e.router.tree)<br />
  return r<br />
}<br />
其中printTree的定义如下</p><br />
<br />
<p>func printTree(tree *node) {<br />
  v1, err1 := json.Marshal(struct {<br />
    Kind          kind<br />
    Label         byte<br />
    Prefix        string<br />
    Parent        *node<br />
    Children      children<br />
    ChildrenNum   int<br />
    Ppath         string<br />
    Pnames        []string<br />
    MethodHandler *methodHandler<br />
  }{<br />
    Kind:          tree.kind,<br />
    Label:         tree.label,<br />
    Prefix:        tree.prefix,<br />
    Parent:        tree.parent,<br />
    Children:      tree.children,<br />
    ChildrenNum:   len(tree.children),<br />
    Ppath:         tree.ppath,<br />
    Pnames:        tree.pnames,<br />
    MethodHandler: tree.methodHandler,<br />
  })<br />
  fmt.Println(string(v1), err1)<br />
  for i, v := range tree.children {<br />
    fmt.Println(i)<br />
    printTree(v)<br />
  }<br />
}<br />
可以看到我们的路由注册结果</p><br />
<br />
<p>{“Kind”:0,”Label”:47,”Prefix”:”/users/”,”Parent”:null,”Children”:[{}],”ChildrenNum”:1,”Ppath”:””,”Pnames”:null,”MethodHandler”:{}} <nil><br />
0<br />
{"Kind":1,"Label":58,"Prefix":":","Parent":{},"Children":null,"ChildrenNum":0,"Ppath":"/users/:name","Pnames":["name"],"MethodHandler":{}} <nil><br />
--------------------<br />
{"Kind":0,"Label":47,"Prefix":"/users/","Parent":null,"Children":[{}],"ChildrenNum":1,"Ppath":"","Pnames":null,"MethodHandler":{}} <nil><br />
0<br />
{"Kind":1,"Label":58,"Prefix":":","Parent":{},"Children":[{}],"ChildrenNum":1,"Ppath":"/users/:name","Pnames":["name"],"MethodHandler":{}} <nil><br />
0<br />
{"Kind":0,"Label":47,"Prefix":"/share/","Parent":{},"Children":[{}],"ChildrenNum":1,"Ppath":"","Pnames":null,"MethodHandler":{}} <nil><br />
0<br />
{"Kind":1,"Label":58,"Prefix":":","Parent":{},"Children":null,"ChildrenNum":0,"Ppath":"/users/:name/share/:id","Pnames":["name","id"],"MethodHandler":{}} <nil><br />
--------------------<br />
{"Kind":0,"Label":47,"Prefix":"/users/","Parent":null,"Children":[{},{}],"ChildrenNum":2,"Ppath":"","Pnames":null,"MethodHandler":{}} <nil><br />
0<br />
{"Kind":1,"Label":58,"Prefix":":","Parent":{},"Children":[{}],"ChildrenNum":1,"Ppath":"/users/:name","Pnames":["name"],"MethodHandler":{}} <nil><br />
0<br />
{"Kind":0,"Label":47,"Prefix":"/share/","Parent":{},"Children":[{}],"ChildrenNum":1,"Ppath":"","Pnames":null,"MethodHandler":{}} <nil><br />
0<br />
{"Kind":1,"Label":58,"Prefix":":","Parent":{},"Children":null,"ChildrenNum":0,"Ppath":"/users/:name/share/:id","Pnames":["name","id"],"MethodHandler":{}} <nil><br />
1<br />
{"Kind":0,"Label":110,"Prefix":"names","Parent":{},"Children":null,"ChildrenNum":0,"Ppath":"/users/names","Pnames":[],"MethodHandler":{}} <nil><br />
--------------------<br />
{"Kind":0,"Label":47,"Prefix":"/users/","Parent":null,"Children":[{},{}],"ChildrenNum":2,"Ppath":"","Pnames":null,"MethodHandler":{}} <nil><br />
0<br />
{"Kind":1,"Label":58,"Prefix":":","Parent":{},"Children":[{}],"ChildrenNum":1,"Ppath":"/users/:name","Pnames":["name"],"MethodHandler":{}} <nil><br />
0<br />
{"Kind":0,"Label":47,"Prefix":"/share/","Parent":{},"Children":[{}],"ChildrenNum":1,"Ppath":"","Pnames":null,"MethodHandler":{}} <nil><br />
0<br />
{"Kind":1,"Label":58,"Prefix":":","Parent":{},"Children":null,"ChildrenNum":0,"Ppath":"/users/:name/share/:id","Pnames":["name","id"],"MethodHandler":{}} <nil><br />
1<br />
{"Kind":0,"Label":110,"Prefix":"names","Parent":{},"Children":[{}],"ChildrenNum":1,"Ppath":"/users/names","Pnames":[],"MethodHandler":{}} <nil><br />
0<br />
{"Kind":0,"Label":47,"Prefix":"/","Parent":{},"Children":[{}],"ChildrenNum":1,"Ppath":"","Pnames":null,"MethodHandler":{}} <nil><br />
0<br />
{"Kind":2,"Label":42,"Prefix":"*","Parent":{},"Children":null,"ChildrenNum":0,"Ppath":"/users/names/*","Pnames":["*"],"MethodHandler":{}} <nil><br />
如何看参数匹配结果呢？同样处理</nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></nil></p><br />
<br />
<p>func (e *Echo) ServeHTTP(w http.ResponseWriter, r *http.Request) {<br />
  e.router.Find(r.Method, getPath(r), c)<br />
}<br />
在find函数里加下面代码</p><br />
<br />
<p>func (r *Router) Find(method, path string, c Context) {<br />
  v, err := json.Marshal(struct {<br />
    //Request *http.Request<br />
    //Response *Response<br />
    Path    string<br />
    Pnames  []string<br />
    Pvalues []string<br />
    Query   url.Values<br />
    //Handler HandlerFunc<br />
    Store Map<br />
  }{<br />
    //Request: ctx.request,<br />
    //Response: ctx.response,<br />
    Path:    ctx.path,<br />
    Pnames:  ctx.pnames,<br />
    Pvalues: ctx.pvalues,<br />
    Query:   ctx.query,<br />
    //Handler: ctx.handler,<br />
    Store: ctx.store,<br />
  })<br />
  fmt.Println(string(v), err)<br />
  return<br />
}</p><br />
<br />
<p>//{“Path”:”/users/:name”,”Pnames”:[“name”],”Pvalues”:[“Joe”,””],”Query”:null,”Store”:null} <nil><br />
//{"Path":"/users/:name/share/:id","Pnames":["name","id"],"Pvalues":["Joe","1"],"Query":null,"Store":null} <nil><br />
这时候我们切换不同版本的echo，可以看到不同的结果</nil></nil></p><br />
<br />
<p>% curl -XGET http://localhost:1336/users/Joe/share\?email=joe_email<br />
{“message”:”Not Found”}<br />
% curl -XGET http://localhost:1336/users/Joe/share/1\?email=joe_email<br />
{“name”:”Joe”,”email”:”joe_email”}<br />
首先看v3.3.10的实现</p><br />
<br />
<p>func (b *DefaultBinder) Bind(i interface{}, c Context) (err error) {<br />
  if req.ContentLength == 0 {<br />
        if err = b.bindData(i, c.QueryParams(), “query”); err != nil {<br />
        }<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ctype := req.Header.Get(HeaderContentType)   switch {   case strings.HasPrefix(ctype, MIMEApplicationJSON):<br />
if err = json.NewDecoder(req.Body).Decode(i); err != nil {<br />
<br />
    }<br />
} } 这个实现是有问题的，因为即使是get请求，ContentLength也不会是0<br />
</code></pre></div></div><br />
<br />
<p>% curl -i -XGET http://localhost:1336/users/Joe/share/1\?email=joe_email<br />
HTTP/1.1 200 OK<br />
Content-Type: application/json; charset=UTF-8<br />
Date: Tue, 30 Mar 2021 03:40:22 GMT<br />
Content-Length: 35<br />
{“name”:””,”email”:”joe_email”}<br />
针对contentlength=0的情况，调用了bindData方法</p><br />
<br />
<p>func (b *DefaultBinder) bindData(ptr interface{}, data map[string][]string, tag string) error {<br />
  typ := reflect.TypeOf(ptr).Elem()<br />
  val := reflect.ValueOf(ptr).Elem()<br />
    for i := 0; i &lt; typ.NumField(); i++ {<br />
        inputFieldName := typeField.Tag.Get(tag)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>          // If tag is nil, we inspect if the field is a struct.<br />
  if _, ok := bindUnmarshaler(structField); !ok &amp;&amp; structFieldKind == reflect.Struct {<br />
    if err := b.bindData(structField.Addr().Interface(), data, tag); err != nil {<br />
            }<br />
        }<br />
<br />
        inputValue, exists := data[inputFieldName]<br />
<br />
} } 里面其实是应用了反射，对结构体的值进行了修改，可以看到，如果header里contentlength不为零，路径里的参数根本匹配不上<br />
</code></pre></div></div><br />
<br />
<p>其中QueryParams()返回的是url里面的值</p><br />
<br />
<p>QueryParams() url.Values<br />
我们升级到v4.1.17看看</p><br />
<br />
<p>% go get -u github.com/labstack/echo/v4@v4.1.17<br />
go: finding module for package github.com/labstack/echo<br />
代码里引用的地方也要由<br />
“github.com/labstack/echo”<br />
改成<br />
“github.com/labstack/echo/v4”<br />
否则会<br />
go: found github.com/labstack/echo in github.com/labstack/echo v3.3.10+incompatible<br />
路径参数绑定成功了</p><br />
<br />
<p>% curl -i -XGET http://localhost:1336/users/Joe/share/1\?email=joe_email<br />
HTTP/1.1 200 OK<br />
Content-Type: application/json; charset=UTF-8<br />
Date: Tue, 30 Mar 2021 05:21:10 GMT<br />
Content-Length: 35</p><br />
<br />
<p>{“name”:”Joe”,”email”:”joe_email”}<br />
我们发现参数绑定方法已经重写了</p><br />
<br />
<p>// Bind implements the <code class="language-plaintext highlighter-rouge">Binder#Bind</code> function.<br />
func (b *DefaultBinder) Bind(i interface{}, c Context) (err error) {<br />
  req := c.Request()</p><br />
<br />
<p>names := c.ParamNames()<br />
  values := c.ParamValues()<br />
  params := map[string][]string{}<br />
  for i, name := range names {<br />
    params[name] = []string{values[i]}<br />
  }<br />
  if err := b.bindData(i, params, “param”); err != nil {<br />
    return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)<br />
  }<br />
  if err = b.bindData(i, c.QueryParams(), “query”); err != nil {<br />
    return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)<br />
  }<br />
  if req.ContentLength == 0 {<br />
    return<br />
  }<br />
  ctype := req.Header.Get(HeaderContentType)<br />
  switch {<br />
  case strings.HasPrefix(ctype, MIMEApplicationJSON):<br />
    if err = json.NewDecoder(req.Body).Decode(i); err != nil {<br />
      if ute, ok := err.(<em>json.UnmarshalTypeError); ok {<br />
        return NewHTTPError(http.StatusBadRequest, fmt.Sprintf(“Unmarshal type error: expected=%v, got=%v, field=%v, offset=%v”, ute.Type, ute.Value, ute.Field, ute.Offset)).SetInternal(err)<br />
      } else if se, ok := err.(</em>json.SyntaxError); ok {<br />
        return NewHTTPError(http.StatusBadRequest, fmt.Sprintf(“Syntax error: offset=%v, error=%v”, se.Offset, se.Error())).SetInternal(err)<br />
      }<br />
      return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)<br />
    }<br />
  }<br />
  return<br />
}<br />
依次会对路径参数param，query参数query，以及body进行绑定，body绑定依赖http的header</p><br />
<br />
<p>下面是bindData函数</p><br />
<br />
<p>func (b *DefaultBinder) bindData(ptr interface{}, data map[string][]string, tag string) error {<br />
  if ptr == nil || len(data) == 0 {<br />
    return nil<br />
  }<br />
  typ := reflect.TypeOf(ptr).Elem()<br />
  val := reflect.ValueOf(ptr).Elem()</p><br />
<br />
<p>// Map<br />
  if typ.Kind() == reflect.Map {<br />
    for k, v := range data {<br />
      val.SetMapIndex(reflect.ValueOf(k), reflect.ValueOf(v[0]))<br />
    }<br />
    return nil<br />
  }</p><br />
<br />
<p>// !struct<br />
  if typ.Kind() != reflect.Struct {<br />
    return errors.New(“binding element must be a struct”)<br />
  }</p><br />
<br />
<p>for i := 0; i &lt; typ.NumField(); i++ {<br />
    typeField := typ.Field(i)<br />
    structField := val.Field(i)<br />
    if !structField.CanSet() {<br />
      continue<br />
    }<br />
    structFieldKind := structField.Kind()<br />
    inputFieldName := typeField.Tag.Get(tag)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if inputFieldName == "" {<br />
  inputFieldName = typeField.Name //在4.2.1中删除了这个字段<br />
  // If tag is nil, we inspect if the field is a struct.<br />
  if _, ok := structField.Addr().Interface().(BindUnmarshaler); !ok &amp;&amp; structFieldKind == reflect.Struct {<br />
    if err := b.bindData(structField.Addr().Interface(), data, tag); err != nil {<br />
      return err<br />
    }<br />
    continue<br />
  }<br />
}<br />
<br />
inputValue, exists := data[inputFieldName]<br />
if !exists {<br />
  // Go json.Unmarshal supports case insensitive binding.  However the<br />
  // url params are bound case sensitive which is inconsistent.  To<br />
  // fix this we must check all of the map values in a<br />
  // case-insensitive search.<br />
  for k, v := range data {<br />
    if strings.EqualFold(k, inputFieldName) {<br />
      inputValue = v<br />
      exists = true<br />
      break<br />
    }<br />
  }<br />
}<br />
<br />
if !exists {<br />
  continue<br />
}<br />
<br />
// Call this first, in case we're dealing with an alias to an array type<br />
if ok, err := unmarshalField(typeField.Type.Kind(), inputValue[0], structField); ok {<br />
  if err != nil {<br />
    return err<br />
  }<br />
  continue<br />
}<br />
<br />
numElems := len(inputValue)<br />
if structFieldKind == reflect.Slice &amp;&amp; numElems &gt; 0 {<br />
  sliceOf := structField.Type().Elem().Kind()<br />
  slice := reflect.MakeSlice(structField.Type(), numElems, numElems)<br />
  for j := 0; j &lt; numElems; j++ {<br />
    if err := setWithProperType(sliceOf, inputValue[j], slice.Index(j)); err != nil {<br />
      return err<br />
    }<br />
  }<br />
  val.Field(i).Set(slice)<br />
} else if err := setWithProperType(typeField.Type.Kind(), inputValue[0], structField); err != nil {<br />
  return err<br />
<br />
}   }   return nil } 可以看到，在匹配路径参数的过程中，如果结构体的tag里没有param，会选取结构体的参数名，到路径参数里去取对应的value<br />
<br />
inputFieldName := typeField.Tag.Get(tag)<br />
<br />
if inputFieldName == "" {<br />
  inputFieldName = typeField.Name //在4.2.1中删除了这个字段<br />
  // If tag is nil, we inspect if the field is a struct.<br />
  if _, ok := structField.Addr().Interface().(BindUnmarshaler); !ok &amp;&amp; structFieldKind == reflect.Struct {<br />
    if err := b.bindData(structField.Addr().Interface(), data, tag); err != nil {<br />
      return err<br />
    }<br />
    continue<br />
  }<br />
} 也就是说，struct的tag即使不正确，也是可能匹配到正确参数的<br />
</code></pre></div></div><br />
<br />
<p>最后看看v4.2.1的实现</p><br />
<br />
<p>go get -u github.com/labstack/echo/v4<br />
func (b *DefaultBinder) Bind(i interface{}, c Context) (err error) {<br />
  if err := b.BindPathParams(c, i); err != nil {<br />
    return err<br />
  }<br />
      if c.Request().Method == http.MethodGet || c.Request().Method == http.MethodDelete {<br />
    if err = b.BindQueryParams(c, i); err != nil {<br />
      return err<br />
    }<br />
  }<br />
  return b.BindBody(c, i)<br />
}</p><br />
<br />
<p>func (b *DefaultBinder) BindPathParams(c Context, i interface{}) error {<br />
  names := c.ParamNames()<br />
  values := c.ParamValues()<br />
  params := map[string][]string{}<br />
  for i, name := range names {<br />
    params[name] = []string{values[i]}<br />
  }<br />
  if err := b.bindData(i, params, “param”); err != nil {<br />
    return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)<br />
  }<br />
  return nil<br />
}</p><br />
<br />
<p>func (b *DefaultBinder) BindQueryParams(c Context, i interface{}) error {<br />
  if err := b.bindData(i, c.QueryParams(), “query”); err != nil {<br />
    return NewHTTPError(http.StatusBadRequest, err.Error()).SetInternal(err)<br />
  }<br />
  return nil<br />
}</p><br />
<br />
<p>func (b *DefaultBinder) BindBody(c Context, i interface{}) (err error) {<br />
  req := c.Request()<br />
  if req.ContentLength == 0 {<br />
    return<br />
  }</p><br />
<br />
<p>ctype := req.Header.Get(HeaderContentType)<br />
  switch {<br />
  case strings.HasPrefix(ctype, MIMEApplicationJSON):<br />
    if err = json.NewDecoder(req.Body).Decode(i); err != nil {<br />
        }<br />
    }<br />
}</p><br />
<br />
<p>func (b *DefaultBinder) bindData(destination interface{}, data map[string][]string, tag string) error {<br />
  if destination == nil || len(data) == 0 {<br />
    return nil<br />
  }<br />
  typ := reflect.TypeOf(destination).Elem()<br />
  val := reflect.ValueOf(destination).Elem()</p><br />
<br />
<p>// Map<br />
  if typ.Kind() == reflect.Map {<br />
    for k, v := range data {<br />
      val.SetMapIndex(reflect.ValueOf(k), reflect.ValueOf(v[0]))<br />
    }<br />
    return nil<br />
  }</p><br />
<br />
<p>// !struct<br />
  if typ.Kind() != reflect.Struct {<br />
    return errors.New(“binding element must be a struct”)<br />
  }</p><br />
<br />
<p>for i := 0; i &lt; typ.NumField(); i++ {<br />
    typeField := typ.Field(i)<br />
    structField := val.Field(i)<br />
    if !structField.CanSet() {<br />
      continue<br />
    }<br />
    structFieldKind := structField.Kind()<br />
    inputFieldName := typeField.Tag.Get(tag)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if inputFieldName == "" {<br />
  // If tag is nil, we inspect if the field is a not BindUnmarshaler struct and try to bind data into it (might contains fields with tags).<br />
  // structs that implement BindUnmarshaler are binded only when they have explicit tag<br />
  if _, ok := structField.Addr().Interface().(BindUnmarshaler); !ok &amp;&amp; structFieldKind == reflect.Struct {<br />
    if err := b.bindData(structField.Addr().Interface(), data, tag); err != nil {<br />
      return err<br />
    }<br />
  }<br />
  // does not have explicit tag and is not an ordinary struct - so move to next field<br />
  continue  //注意从哪部移动出来了，所以，没有tag就不继续了<br />
}<br />
<br />
inputValue, exists := data[inputFieldName]<br />
if !exists {<br />
  // Go json.Unmarshal supports case insensitive binding.  However the<br />
  // url params are bound case sensitive which is inconsistent.  To<br />
  // fix this we must check all of the map values in a<br />
  // case-insensitive search.<br />
  for k, v := range data {<br />
    if strings.EqualFold(k, inputFieldName) {<br />
      inputValue = v<br />
      exists = true<br />
      break<br />
    }<br />
  }<br />
}<br />
<br />
if !exists {<br />
  continue<br />
}<br />
<br />
// Call this first, in case we're dealing with an alias to an array type<br />
if ok, err := unmarshalField(typeField.Type.Kind(), inputValue[0], structField); ok {<br />
  if err != nil {<br />
    return err<br />
  }<br />
  continue<br />
}<br />
<br />
numElems := len(inputValue)<br />
if structFieldKind == reflect.Slice &amp;&amp; numElems &gt; 0 {<br />
  sliceOf := structField.Type().Elem().Kind()<br />
  slice := reflect.MakeSlice(structField.Type(), numElems, numElems)<br />
  for j := 0; j &lt; numElems; j++ {<br />
    if err := setWithProperType(sliceOf, inputValue[j], slice.Index(j)); err != nil {<br />
      return err<br />
    }<br />
  }<br />
  val.Field(i).Set(slice)<br />
} else if err := setWithProperType(typeField.Type.Kind(), inputValue[0], structField); err != nil {<br />
  return err<br />
<br />
}   }   return nil } 可以看到，匹配过程更严格了，严格要求按照结构体tag定义来匹配<br />
</code></pre></div></div><br />
<br />
<p>inputFieldName := typeField.Tag.Get(tag)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if inputFieldName == "" {<br />
  // If tag is nil, we inspect if the field is a not BindUnmarshaler struct and try to bind data into it (might contains fields with tags).<br />
  // structs that implement BindUnmarshaler are binded only when they have explicit tag<br />
  if _, ok := structField.Addr().Interface().(BindUnmarshaler); !ok &amp;&amp; structFieldKind == reflect.Struct {<br />
    if err := b.bindData(structField.Addr().Interface(), data, tag); err != nil {<br />
      return err<br />
    }<br />
  }<br />
  // does not have explicit tag and is not an ordinary struct - so move to next field<br />
  continue  //注意从哪部移动出来了，所以，没有tag就不继续了<br />
} 好处是什么呢？可以处理同名参数<br />
</code></pre></div></div><br />
<br />
<p>这两个版本可以具体diff一下看看改动</p><br />
<br />
<p>vimdiff</p><br />
<br />
<!-- more --><br />
<p>https://github.com/labstack/echo/issues/1337</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>