<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">groupcache 源码分析</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2021-08-15T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Aug 15, 2021</time></p>
					</div>
					 <p>https://github.com/golang/groupcache</p><br />
<br />
<p>雪崩就是指缓存中大批量热点数据过期 或 缓存机器意外发生了全盘宕机后系统涌入大量查询请求，因为大部分数据在Redis层已经失效，请求渗透到数据库层，大批量请求犹如洪水一般涌入，引起数据库压力造成查询堵塞甚至宕机。</p><br />
<br />
<p>解决办法：</p><br />
<br />
<p>将缓存失效时间分散开，比如每个key的过期时间是随机，防止同一时间大量数据过期现象发生，这样不会出现同一时间全部请求都落在数据库层，如果缓存数据库是分布式部署，将热点数据均匀分布在不同Redis和数据库中，有效分担压力，别一个人扛。<br />
简单粗暴，让Redis数据永不过期（如果业务准许，比如不用更新的名单类）。当然，如果业务数据准许的情况下可以，比如中奖名单用户，每期用户开奖后，名单不可能会变了，无需更新。</p><br />
<br />
<p>缓存雪崩的事前事中事后的解决方案如下。 - 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。 - 事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。 - 事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</p><br />
<br />
<p>缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。</p><br />
<br />
<p>解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</p><br />
<br />
<p>缓存穿透 <br />
假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。<br />
　　黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。<br />
　　举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。</p><br />
<br />
<p>解决方式很简单，每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。</p><br />
<br />
<p>https://www.cnblogs.com/myseries/p/12853369.html<br />
https://blog.csdn.net/kongtiao5/article/details/82771694<br />
https://www.jianshu.com/p/b7f822935e28</p><br />
<br />
<p>Package singleflight provides a duplicate function call suppression mechanism.</p><br />
<br />
<p>翻译过来就是：singleflight包提供了一种抑制重复函数调用的机制。</p><br />
<br />
<p>具体到Go程序运行的层面来说，SingleFlight的作用是在处理多个goroutine同时调用同一个函数的时候，只让一个goroutine去实际调用这个函数，等到这个goroutine返回结果的时候，再把结果返回给其他几个同时调用了相同函数的goroutine，这样可以减少并发调用的数量。在实际应用中也是，它能够在一个服务中减少对下游的并发重复请求。还有一个比较常见的使用场景是用来防止缓存击穿。</p><br />
<br />
<p>Go提供的SingleFlight<br />
Go扩展库里用singleflight.Group结构体类型提供了SingleFlight并发原语的功能。</p><br />
<br />
<p>singleflight.Group类型提供了三个方法：</p><br />
<br />
<p>func (g *Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool)</p><br />
<br />
<p>func (g *Group) DoChan(key string, fn func() (interface{}, error)) &lt;-chan Result</p><br />
<br />
<p>func (g *Group) Forget(key string)<br />
Do方法，接受一个字符串Key和一个待调用的函数，会返回调用函数的结果和错误。使用Do方法的时候，它会根据提供的Key判断是否去真正调用fn函数。同一个 key，在同一时间只有第一次调用Do方法时才会去执行fn函数，其他并发的请求会等待调用的执行结果。</p><br />
<br />
<p>DoChan方法：类似Do方法，只不过是一个异步调用。它会返回一个通道，等fn函数执行完，产生了结果以后，就能从这个 chan 中接收这个结果。</p><br />
<br />
<p>Forget方法：在SingleFlight中删除一个Key。这样一来，之后这个Key的Do方法调用会执行fn函数，而不是等待前一个未完成的fn 函数的结果。</p><br />
<br />
<!-- more --><br />
<p>应用场景<br />
了解了Go语言提供的 SingleFlight并发原语都有哪些方法可以调用后 ，下面介绍两个它的应用场景。</p><br />
<br />
<p>查询DNS记录<br />
Go语言的net标准库里使用的lookupGroup结构，就是Go扩展库提供的原语singleflight.Group</p><br />
<br />
<p>type Resolver struct {<br />
  ……<br />
 // 源码地址 https://github.com/golang/go/blob/master/src/net/lookup.go#L151<br />
 // lookupGroup merges LookupIPAddr calls together for lookups for the same<br />
 // host. The lookupGroup key is the LookupIPAddr.host argument.<br />
 // The return values are ([]IPAddr, error).<br />
 lookupGroup singleflight.Group<br />
}</p><br />
<br />
<p>防止缓存击穿<br />
在项目里使用缓存时，一个常见的用法是查询一个数据先去查询缓存，如果没有就去数据库里查到数据并缓存到Redis里。那么缓存击穿问题是指，高并发的系统中，大量的请求同时查询一个缓存Key 时，如果这个 Key 正好过期失效，就会导致大量的请求都打到数据库上，这就是缓存击穿。用 SingleFlight 来解决缓存击穿问题再合适不过，这个时候只要这些对同一个 Key 的并发请求的其中一个到数据库中查询就可以了，这些并发的请求可以共享同一个结果</p><br />
<br />
<p>Do方法<br />
SingleFlight 定义一个call结构体，每个结构体都保存了fn调用对应的信息。</p><br />
<br />
<p>Do方法的执行逻辑是每次调用Do方法都会先去获取互斥锁，随后判断在映射表里是否已经有Key对应的fn函数调用信息的call结构体。</p><br />
<br />
<p>当不存在时，证明是这个Key的第一次请求，那么会初始化一个call结构体指针，增加SingleFlight内部持有的sync.WaitGroup计数器到1。释放互斥锁，然后阻塞的等待doCall方法执行fn函数的返回结果</p><br />
<br />
<p>当存在时，增加call结构体内代表fn重复调用次数的计数器dups，释放互斥锁，然后使用WaitGroup等待fn函数执行完成。</p><br />
<br />
<p>call结构体的val 和 err 两个字段只会在 doCall方法中执行fn有返回结果后才赋值，所以当 doCall方法 和 WaitGroup.Wait返回时，函数调用的结果和错误会返回给Do方法的所有调用者。</p><br />
<br />
<p>https://blog.csdn.net/kevin_tech/article/details/111878251</p><br />
<br />
<p>https://www.jianshu.com/p/7f3792549346</p><br />
<br />
<p>缓存击穿<br />
什么是缓存击穿<br />
平常在高并发系统中，会出现大量的请求同时查询一个key的情况，假如此时这个热key刚好失效了，就会导致大量的请求都打到数据库上面去，这种现象就是缓存击穿。缓存击穿和缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿则是指一个key非常热点，在不停的扛着高并发，高并发集中对着这一个点进行访问，如果这个key在失效的瞬间，持续的并发到来就会穿破缓存，直接请求到数据库，就像一个完好无损的桶上凿开了一个洞，造成某一时刻数据库请求量过大，压力剧增!</p><br />
<br />
<p>如何解决<br />
方法一<br />
我们简单粗暴点，直接让热点数据永远不过期，定时任务定期去刷新数据就可以了。不过这样设置需要区分场景，比如某宝首页可以这么做。</p><br />
<br />
<p>方法二<br />
为了避免出现缓存击穿的情况，我们可以在第一个请求去查询数据库的时候对他加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，后面的线程进来发现已经有缓存了，就直接走缓存，从而保护数据库。但是也是由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做。</p><br />
<br />
<p>方法三<br />
方法三就是singleflight的设计思路，也会使用互斥锁，但是相对于方法二的加锁粒度会更细，这里先简单总结一下singleflight的设计原理，后面看源码在具体分析。</p><br />
<br />
<p>singleflightd的设计思路就是将一组相同的请求合并成一个请求，使用map存储，只会有一个请求到达mysql，使用sync.waitgroup包进行同步，对所有的请求返回相同的结果。</p><br />
<br />
<p>ype call struct { <br />
 wg sync.WaitGroup <br />
 // 存储返回值，在wg done之前只会写入一次 <br />
 val interface{} <br />
  // 存储返回的错误信息 <br />
 err error</p><br />
<br />
<p>// 标识别是否调用了Forgot方法 <br />
 forgotten bool</p><br />
<br />
<p>// 统计相同请求的次数，在wg done之前写入 <br />
 dups  int <br />
  // 使用DoChan方法使用，用channel进行通知 <br />
 chans []chan&lt;- Result <br />
} <br />
// Dochan方法时使用 <br />
type Result struct { <br />
 Val    interface{} // 存储返回值 <br />
 Err    error // 存储返回的错误信息 <br />
 Shared bool // 标示结果是否是共享结果 <br />
}</p><br />
<br />
<p>// 入参：key：标识相同请求，fn：要执行的函数 <br />
// 返回值：v: 返回结果 err: 执行的函数错误信息 shard: 是否是共享结果 <br />
func (g <em>Group) Do(key string, fn func() (interface{}, error)) (v interface{}, err error, shared bool) { <br />
 // 代码块加锁 <br />
 g.mu.Lock() <br />
 // map进行懒加载 <br />
 if g.m == nil { <br />
   // map初始化 <br />
  g.m = make(map[string]</em>call) <br />
 } <br />
 // 判断是否有相同请求 <br />
 if c, ok := g.m[key]; ok { <br />
   // 相同请求次数+1 <br />
  c.dups++ <br />
  // 解锁就好了，只需要等待执行结果了，不会有写入操作了 <br />
  g.mu.Unlock() <br />
  // 已有请求在执行，只需要等待就好了 <br />
  c.wg.Wait() <br />
  // 区分panic错误和runtime错误 <br />
  if e, ok := c.err.(*panicError); ok { <br />
   panic(e) <br />
  } else if c.err == errGoexit { <br />
   runtime.Goexit() <br />
  } <br />
  return c.val, c.err, true <br />
 } <br />
 // 之前没有这个请求，则需要new一个指针类型 <br />
 c := new(call) <br />
 // sync.waitgroup的用法，只有一个请求运行，其他请求等待，所以只需要add(1) <br />
 c.wg.Add(1) <br />
 // m赋值 <br />
 g.m[key] = c <br />
 // 没有写入操作了，解锁即可 <br />
 g.mu.Unlock() <br />
 // 唯一的请求该去执行函数了 <br />
 g.doCall(c, key, fn) <br />
 return c.val, c.err, c.dups &gt; 0 <br />
}</p><br />
<br />
<p>https://developer.51cto.com/art/202107/672248.htm</p><br />
<br />
<p>https://www.cnblogs.com/xiaozhe97/p/13702010.html</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/343761986</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import "sync"<br />
<br />
// call is an in-flight or completed Do call<br />
type call struct {<br />
    wg  sync.WaitGroup<br />
    val interface{}<br />
    err error<br />
}<br />
<br />
// Group represents a class of work and forms a namespace in which<br />
// units of work can be executed with duplicate suppression.<br />
type Group struct {<br />
    mu sync.Mutex       // protects m<br />
    m  map[string]*call // lazily initialized<br />
}<br />
<br />
// Do executes and returns the results of the given function, making<br />
// sure that only one execution is in-flight for a given key at a<br />
// time. If a duplicate comes in, the duplicate caller waits for the<br />
// original to complete and receives the same results.<br />
//同一个对象多次同时多次调用这个逻辑的时候，可以使用其中的一个去执行<br />
func (g *Group) Do(key string, fn func()(interface{},error)) (interface{}, error ){<br />
    g.mu.Lock() //加锁保护存放key的map，因为要并发执行<br />
    if g.m == nil { //lazing make 方式建立<br />
        g.m = make(map[string]*call)<br />
    }<br />
    if c, ok := g.m[key]; ok { //如果map中已经存在对这个key的处理那就等着吧<br />
        g.mu.Unlock() //解锁，对map的操作已经完毕<br />
        c.wg.Wait()<br />
        return c.val,c.err //map中只有一份key，所以只有一个c<br />
    }<br />
    c := new(call) //创建一个工作单元，只负责处理一种key<br />
    c.wg.Add(1)<br />
    g.m[key] = c //将key注册到map中<br />
    g.mu.Unlock() //map的操做完成，解锁<br />
    <br />
    c.val, c.err = fn()//第一个注册者去执行<br />
    c.wg.Done()<br />
    <br />
    g.mu.Lock()<br />
    delete(g.m,key) //对map进行操作，需要枷锁<br />
    g.mu.Unlock()<br />
    <br />
    return c.val, c.err //给第一个注册者返回结果<br />
}<br />
</code></pre></div></div><br />
<p>https://www.jianshu.com/p/f47feb4720f9<br />
https://www.cnblogs.com/softlin/p/14133635.html</p><br />
<br />
<p>https://segmentfault.com/a/1190000039712358?utm_source=sf-similar-article</p><br />
<br />
<p>代码的结构：</p><br />
<br />
<p>consistanthash        实现一致性hash功能</p><br />
<br />
<p>lru                   实现缓存的置换算法（最近最少使用）</p><br />
<br />
<p>singleflight          实现多个同请求的合并，保证“同时”多个同参数的get请求只执行一次操作功能</p><br />
<br />
<p>groupcachepb          grpc生成的代码，用于远程调用</p><br />
<br />
<p>byteview.go           将byte于string进行了一次封装，对外提供不区分两者的接口</p><br />
<br />
<p>groupcache.go         groupcache的主API函数</p><br />
<br />
<p>http.go               http相关的代码</p><br />
<br />
<p>peers.go              单个节点的一些接口实现</p><br />
<br />
<p>sinks.go              暂时没太搞明白</p><br />
<br />
<p>https://blog.csdn.net/mrbuffoon/article/details/83510799</p><br />
<br />
<p>https://www.cnblogs.com/B0-1/p/5799094.html</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category golang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>