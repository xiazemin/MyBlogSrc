<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">php execute_ex</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-03-01T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Mar 1, 2020</time></p>
					</div>
					 <p>php扩展实践zend_execute_ex层获取实参<br />
其实在实现的 php 函数里面是很容易获取到的，参考 php 的 builtin 函数 func_get_args() 就可以知道了。<br />
void **p;<br />
int arg_count;<br />
int i;<br />
zend_execute_data *ex = EG(current_execute_data);</p><br />
<br />
<p>if (!ex || !ex-&gt;function_state.arguments) {<br />
    RETURN_FALSE;<br />
}</p><br />
<br />
<p>p = ex-&gt;function_state.arguments;<br />
arg_count = (int)(zend_uintptr_t) *p;</p><br />
<br />
<p>for (i = 0; i &lt; arg_count; i++) {<br />
    zval *element, *arg;<br />
    arg = *((zval **) (p - (arg_count - i)));<br />
    php_var_dump(&amp;arg, 1 TSRMLS_CC);<br />
}</p><br />
<br />
<p>但是在 zend_execute_ex 中，是不能使用 function_state.arguments 来获取参数的，需要从 argument_stack 中获取调用函数的实参。</p><br />
<br />
<p>static void (*old_zend_execute_ex) (zend_execute_data *execute_data TSRMLS_DC);</p><br />
<br />
<p>ZEND_API void learn_execute_ex (zend_execute_data *execute_data TSRMLS_DC)<br />
{<br />
    php_printf(“====== extension debug start ======\n”);<br />
    php_printf(“function name: %s\n”, get_active_function_name(TSRMLS_C));</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>old_zend_execute_ex(execute_data TSRMLS_CC);<br />
<br />
int stacked = 0;<br />
void **top;<br />
void **bottom;<br />
zval *arguments;<br />
smart_str buf = {0};<br />
<br />
array_init(arguments);<br />
<br />
top = zend_vm_stack_top(TSRMLS_C) - 1;<br />
if (top) {<br />
    stacked = (int)(zend_uintptr_t) *top; // argc<br />
    if (stacked) {<br />
        bottom = zend_vm_stack_top(TSRMLS_C);<br />
        EG(argument_stack)-&gt;top = top + 1;<br />
        if (zend_copy_parameters_array(stacked, arguments TSRMLS_CC) == SUCCESS) {<br />
            php_json_encode(&amp;buf, arguments, 0 TSRMLS_CC);<br />
        }<br />
        EG(argument_stack)-&gt;top = bottom;<br />
    }<br />
}<br />
<br />
smart_str_0(&amp;buf);<br />
<br />
php_printf("%s\n", buf.c);<br />
<br />
smart_str_free(&amp;buf);<br />
zval_dtor(arguments);<br />
<br />
php_printf("====== extension debug end ======\n"); }<br />
</code></pre></div></div><br />
<br />
<p>PHP_MINIT_FUNCTION(learn)<br />
{<br />
    old_zend_execute_ex = zend_execute_ex;<br />
    zend_execute_ex = learn_execute_ex;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return SUCCESS; }<br />
</code></pre></div></div><br />
<br />
<p>PHP_MSHUTDOWN_FUNCTION(learn)<br />
{<br />
    zend_execute_ex = old_zend_execute_ex;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return SUCCESS; } 2015-11-04 00:38 更新 后来看到，其实不用上面这中方法就可以实现, php 5.5之后要从 prev 里面去取<br />
</code></pre></div></div><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>php_var_dump defined in this head file.<br />
 */<br />
#include “ext/standard/php_var.h”</li><br />
</ul><br />
<br />
<p>zend_execute_data *real_execute_data = execute_data-&gt;prev_execute_data;</p><br />
<br />
<p>void **p = real_execute_data-&gt;function_state.arguments;<br />
int arg_count = (int) (zend_uintptr_t) * p;<br />
zval *argument_element;<br />
int i;<br />
// zval *obj = real_execute_data-&gt;object;<br />
unsigned long start = mach_absolute_time();<br />
for (i = 0; i &lt; arg_count; i++) {<br />
    argument_element = *(p - (arg_count - i));<br />
    php_var_dump(&amp;argument_element, 1);<br />
}<br />
<!-- more --><br />
字节码在 Zend 虚拟机中的解释执行 之 概述</p><br />
<br />
<p>execute_ex<br />
我们来看看执行一个简单的脚本 test.php 的调用栈</p><br />
<br />
<p>execute_ex @ zend_vm_execute.h : 411<br />
zend_execute @ zend_vm_execute.h : 474<br />
php_execute_script @ zend.c : 1474<br />
do_cli @ php_cli.c : 993<br />
main @ php_cli.c : 1381 <br />
由于是执行脚本文件，所以 do_cli 调用了 php_execute_script 函数，最终调用 execute_ex 函数：</p><br />
<br />
<p>ZEND_API void execute_ex(zend_execute_data *ex)<br />
{<br />
    DCL_OPLINE</p><br />
<br />
<p>#ifdef ZEND_VM_IP_GLOBAL_REG<br />
    const zend_op *orig_opline = opline;<br />
#endif<br />
#ifdef ZEND_VM_FP_GLOBAL_REG<br />
    zend_execute_data *orig_execute_data = execute_data;<br />
    execute_data = ex;<br />
#else<br />
    zend_execute_data *execute_data = ex;<br />
#endif</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOAD_OPLINE();<br />
ZEND_VM_LOOP_INTERRUPT_CHECK();<br />
<br />
while (1) { #if !defined(ZEND_VM_FP_GLOBAL_REG) || !defined(ZEND_VM_IP_GLOBAL_REG)<br />
        int ret; #endif #if defined(ZEND_VM_FP_GLOBAL_REG) &amp;&amp; defined(ZEND_VM_IP_GLOBAL_REG)<br />
    ((opcode_handler_t)OPLINE-&gt;handler)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);<br />
    if (UNEXPECTED(!OPLINE)) { #else<br />
    if (UNEXPECTED((ret = ((opcode_handler_t)OPLINE-&gt;handler)www.90168.org(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU)) != 0)) { #endif #ifdef ZEND_VM_FP_GLOBAL_REG<br />
        execute_data = orig_execute_data; # ifdef ZEND_VM_IP_GLOBAL_REG<br />
        opline = orig_opline; # endif<br />
        return; #else<br />
        if (EXPECTED(ret &gt; 0)) {<br />
            execute_data = EG(current_execute_data);<br />
            ZEND_VM_LOOP_INTERRUPT_CHECK();<br />
        } else { # ifdef ZEND_VM_IP_GLOBAL_REG<br />
            opline = orig_opline; # endif<br />
            return;<br />
        } #endif<br />
    }<br />
<br />
}<br />
zend_error_noreturn(E_CORE_ERROR, "Arrived at end of main loop which shouldn't happen"); } 和其它 C 语言编写的系统软件类似，函数中使用了大量的宏定义，通过宏定义的名字还是能大概看出其用途<br />
</code></pre></div></div><br />
<br />
<p>DCL_OPLINE，变量声明</p><br />
<br />
<p>LOAD_OPLINE()，加载指令字节码</p><br />
<br />
<p>ZEND_VM_LOOP_INTERRUPT_CHECK()，interrupt 检测</p><br />
<br />
<p>解释器引擎最终执行op的函数是zend_execute，实际上zend_execute是一个函数指针，在引擎初始化的时候zend_execute默认指向了execute,这个execute定义在{PHPSRC}/Zend/zend_vm_execute.h：</p><br />
<br />
<p>Zend引擎主要包含两个核心部分：编译、执行：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>执行阶段主要用到的数据结构：<br />
<br />
      opcode： php代码编译产生的zend虚拟机可识别的指令，php7有173个opcode，定义在 zend_vm_opcodes.hPHP中的所有语法实现都是由这些opcode组成的。<br />
</code></pre></div></div><br />
<br />
<p>复制代码<br />
struct _zend_op {<br />
    const void *handler; //对应执行的C语言function，即每条opcode都有一个C function处理<br />
    znode_op op1;   //操作数1<br />
    znode_op op2;   //操作数2<br />
    znode_op result; //返回值<br />
    uint32_t extended_value; <br />
    uint32_t lineno; <br />
    zend_uchar opcode;  //opcode指令<br />
    zend_uchar op1_type; //操作数1类型<br />
    zend_uchar op2_type; //操作数2类型<br />
    zend_uchar result_type; //返回值类型<br />
};<br />
复制代码<br />
         zend_op_array : zend引擎执行阶段的输入数据结构，整个执行阶段都是操作这个数据结构。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  　　　　　　 zend_op_array有三个核心部分：opcode指令(对应c的指令)<br />
<br />
                                               字面量存储(变量初始值、调用的函数名称、类名称、常量名称等等称之为字面量)<br />
<br />
                                               变量分配的情况 (当前array定义的变量 临时变量的数量 编号，执行初始化一次性分配zval，使用时完全按照标号索引不是根据变量名)<br />
<br />
     <br />
<br />
       zend_executor_globals     PHP整个生命周期中最主要的一个结构，是一个全局变量，在main执行前分配(非ZTS下)，直到PHP退出，它记录着当前请求全部的信息，经常见到的一个宏EG操作的就是这个结构。<br />
<br />
                            定义在zend_globals.h中：<br />
<br />
 <br />
<br />
                               <br />
<br />
 <br />
<br />
            <br />
<br />
           zend_execute_data  是执行过程中最核心的一个结构，每次函数的调用、include/require、eval等都会生成一个新的结构，它表示当前的作用域、代码的执行位置以及局部变量的分配等等，等同于机器码执行过程中stack的角色，后面分析具体执行流程的时候会详细分析其作用。 <br />
<br />
          zend_execute_data与zend_op_array的关联关系：<br />
</code></pre></div></div><br />
<br />
<p>2.执行过程</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Zend的executor与linux二进制程序执行的过程是非常类似的。<br />
<br />
    在C程序执行时有两个寄存器ebp、esp分别指向当前作用栈的栈顶、栈底，局部变量全部分配在当前栈，函数调用、返回通过call、ret指令完成，调用时call将当前执行位置压入栈中，返回时ret将之前执行位置出栈，跳回旧的位置继续执行。<br />
<br />
    Zend VM中zend_execute_data就扮演了这两个角色，zend_execute_data.prev_execute_data保存的是调用方的信息，实现了call/ret，zend_execute_data后面会分配额外的内存空间用于局部变量的存储，实现了ebp/esp的作用。<br />
<br />
                a. 为当前作用域分配一块内存，充当运行栈，zend_execute_data结构、所有局部变量、中间变量等等都在此内存上分配<br />
<br />
                b.初始化全局变量符号表，然后将全局执行位置指针EG(current_execute_data)指向步骤a新分配的zend_execute_data，然后将zend_execute_data.opline指向op_array的起始位置<br />
<br />
                c.从EX(opline)开始调用各opcode的C处理handler(即_zend_op.handler)，每执行完一条opcode将EX(opline)++继续执行下一条，直到执行完全部opcode<br />
<br />
                            if语句将根据条件的成立与否决定EX(opline) + offset所加的偏移量，实现跳转<br />
<br />
                            如果是函数调用，则首先从EG(function_table)中根据function_name取出此function对应的编译完成的zend_op_array，然后像步骤a一样新分配一个zend_execute_data结构，将EG(current_execute_data)赋值给新结构的prev_execute_data，再将EG(current_execute_data)指向新的zend_execute_data，最后从新的zend_execute_data.opline开始执行，切换到函数内部，函数执行完以后将EG(current_execute_data)重新指向EX(prev_execute_data)，释放分配的运行栈，销毁局部变量，继续从原来函数调用的位置执行<br />
<br />
                            类方法的调用与函数基本相同<br />
<br />
                d.全部opcode执行完成后将步骤a分配的内存释放，这个过程会将所有的局部变量"销毁"，执行阶段结束<br />
<br />
                                <br />
<br />
 <br />
<br />
                          首先根据zend_execute_data、当前zend_op_array中局部/临时变量数计算需要的内存空间，编译阶段zend_op_array的结果，在编译过程中已经确定当前作用域下有多少个局部变量(func-&gt;op_array.last_var)、临时/中间/无用变量(func-&gt;op_array.T)，从而在执行之初就将他们全部分配完成。<br />
</code></pre></div></div><br />
<br />
<p>PHP xhprof 扩展原理<br />
由于公司项目，最近需要分析后端PHP接口的性能数据，就采用了FACEBOOK之前开源的一个扩展，现在市面上很多分支都是基于FB最开始的线开发的，但是由于FB已经停止维护，所以现在其他线都是自己个人在维护。</p><br />
<br />
<p>今天我分析的这个分支是兼容PHP7+的版本收集性能数据，先贴出GITHUB的链接  https://github.com/longxinH/xhprof</p><br />
<br />
<p>扩展的安装方式和PHP调用的API用法在github上readme.md上有详细说明，可以参考，我现在做的项目就是用这个来收集的，因为是私人维护的，不敢保证以后会不会启用，所以先自己了解下XHPROF扩展源码，防止后面维护人不维护，可以自己在继续维护起来。</p><br />
<br />
<p> </p><br />
<br />
<p>分析：</p><br />
<br />
<p>起始外部扩展就是相当于内核一个模块，都是zend_module_entry结构体, 收集性能数据的原理，就是在模块初始化的时候代理了这个，代理了这个编译和执行OPCODE 的函数，覆盖了一层，加了自己的处理，自己的处理就是C代码的执行时间和PHP申请堆内存的计算。</p><br />
<br />
<p>/* Replace zend_compile with our proxy */</p><br />
<br />
<p>_zend_compile_file = zend_compile_file;</p><br />
<br />
<p>zend_compile_file = hp_compile_file;</p><br />
<br />
<p>/* Replace zend_compile_string with our proxy */</p><br />
<br />
<p>_zend_compile_string = zend_compile_string;</p><br />
<br />
<p>zend_compile_string = hp_compile_string;</p><br />
<br />
<p>/* Replace zend_execute with our proxy */</p><br />
<br />
<p>_zend_execute_ex = zend_execute_ex;</p><br />
<br />
<p>zend_execute_ex = hp_execute_ex;<br />
这是zend_module_entry，第三方扩展都需要实现这个结构体，用来保存扩展的基本信息，类似设计模式里面的实现接口<br />
/* Callback functions for the xhprof extension <em>/<br />
zend_module_entry xhprof_module_entry = {<br />
#if ZEND_MODULE_API_NO &gt;= 20010901<br />
        STANDARD_MODULE_HEADER,<br />
#endif<br />
        “xhprof”,                        /</em> Name of the extension <em>/<br />
        xhprof_functions,                /</em> List of functions exposed <em>/<br />
        PHP_MINIT(xhprof),               /</em> Module init callback <em>/<br />
        PHP_MSHUTDOWN(xhprof),           /</em> Module shutdown callback <em>/<br />
        PHP_RINIT(xhprof),               /</em> Request init callback <em>/<br />
        PHP_RSHUTDOWN(xhprof),           /</em> Request shutdown callback <em>/<br />
        PHP_MINFO(xhprof),               /</em> Module info callback */<br />
#if ZEND_MODULE_API_NO &gt;= 20010901<br />
        XHPROF_VERSION,<br />
#endif<br />
        STANDARD_MODULE_PROPERTIES<br />
};<br />
 </p><br />
<br />
<p>/* Xhprof’s global state.<br />
 *</p><br />
<ul><br />
  <li>This structure is instantiated once.  Initialize defaults for attributes in</li><br />
  <li>hp_init_profiler_state() Cleanup/free attributes in</li><br />
  <li><br />
    <p>hp_clean_profiler_state() */<br />
存储扩展性能数据，是否开启，等信息的结构体<br />
ZEND_BEGIN_MODULE_GLOBALS(xhprof)</p><br />
<br />
    <p>/*       ———-   Global attributes:  ———–       */</p><br />
<br />
    <p>/* Indicates if xhprof is currently enabled */<br />
 int              enabled;</p><br />
<br />
    <p>/* Indicates if xhprof was ever enabled during this request */<br />
 int              ever_enabled;</p><br />
<br />
    <p>/* Holds all the xhprof statistics */<br />
 zval            stats_count;</p><br />
<br />
    <p>/* Indicates the current xhprof mode or level */<br />
 int              profiler_level;</p><br />
<br />
    <p>/* Top of the profile stack */<br />
 hp_entry_t      *entries;</p><br />
<br />
    <p>/* freelist of hp_entry_t chunks for reuse… */<br />
 hp_entry_t      *entry_free_list;</p><br />
<br />
    <p>/* Callbacks for various xhprof modes */<br />
 hp_mode_cb       mode_cb;</p><br />
<br />
    <p>/*       ———-   Mode specific attributes:  ———–       */</p><br />
<br />
    <p>/* Global to track the time of the last sample in time and ticks <em>/<br />
 struct timeval   last_sample_time;<br />
 uint64           last_sample_tsc;<br />
 /</em> XHPROF_SAMPLING_INTERVAL in ticks <em>/<br />
 long             sampling_interval;<br />
 uint64           sampling_interval_tsc;<br />
 int              sampling_depth;<br />
 /</em> XHProf flags */<br />
 uint32 xhprof_flags;</p><br />
<br />
    <p>char *root;</p><br />
<br />
    <p>/* counter table indexed by hash value of function names. */<br />
 uint8  func_hash_counters[256];</p><br />
<br />
    <p>HashTable *trace_callbacks;</p><br />
<br />
    <p>/* Table of ignored function names and their filter */<br />
 hp_ignored_functions *ignored_functions;</p><br />
  </li><br />
</ul><br />
<br />
<p>ZEND_END_MODULE_GLOBALS(xhprof)<br />
/**<br />
static const zend_ini_entry_def ini_entries[] = {<br />
    { xhprof.output_dir, NULL, arg1, arg2, arg3, ‘’, displayer, 7, sizeof(name)-1, sizeof(‘’)-1 },<br />
    { xhprof.collect_additional_info, NULL, arg1, arg2, arg3, ‘0’, displayer, 7, sizeof(name)-1, sizeof(‘’)-1 },<br />
    { xhprof.sampling_interval, NULL, arg1, arg2, arg3, ‘100000’, displayer, 7, sizeof(name)-1, sizeof(‘’)-1 },<br />
    { xhprof.sampling_depth, NULL, arg1, arg2, arg3, ‘100000’, displayer, 7, sizeof(name)-1, sizeof(‘’)-1 },<br />
    { NULL, NULL, NULL, NULL, NULL, NULL, NULL, 0, 0, 0}</p><br />
<br />
<p>}<br />
 */<br />
这是注册xhprof扩展所有的php.ini配置项<br />
PHP_INI_BEGIN()</p><br />
<br />
<p>/* output directory:</p><br />
<ul><br />
  <li>Currently this is not used by the extension itself.</li><br />
  <li>But some implementations of iXHProfRuns interface might</li><br />
  <li>choose to save/restore XHProf profiler runs in the</li><br />
  <li>directory specified by this ini setting.<br />
 */<br />
PHP_INI_ENTRY(“xhprof.output_dir”, “”, PHP_INI_ALL, NULL)</li><br />
</ul><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>collect_additional_info</li><br />
  <li>Collect mysql_query, curl_exec internal info. The default is 0.<br />
 */<br />
PHP_INI_ENTRY(“xhprof.collect_additional_info”, “0”, PHP_INI_ALL, NULL)</li><br />
</ul><br />
<br />
<p>/* sampling_interval:</p><br />
<ul><br />
  <li>Sampling interval to be used by the sampling profiler, in microseconds.<br />
 */<br />
#define STRINGIFY_(X) #X<br />
#define STRINGIFY(X) STRINGIFY_(X)</li><br />
</ul><br />
<br />
<p>STD_PHP_INI_ENTRY(“xhprof.sampling_interval”, STRINGIFY(XHPROF_DEFAULT_SAMPLING_INTERVAL), PHP_INI_ALL, OnUpdateLong, sampling_interval, zend_xhprof_globals, xhprof_globals)</p><br />
<br />
<p>/* sampling_depth:</p><br />
<ul><br />
  <li>Depth to trace call-chain by the sampling profiler<br />
 */<br />
STD_PHP_INI_ENTRY(“xhprof.sampling_depth”, STRINGIFY(INT_MAX), PHP_INI_ALL, OnUpdateLong, sampling_depth, zend_xhprof_globals, xhprof_globals)<br />
PHP_INI_END()<br />
/**</li><br />
  <li>Module init callback.<br />
 *</li><br />
  <li><br />
    <p>@author cjiang<br />
 */<br />
模块初始化的调用的函数<br />
//int zm_startup_xhprof(xhprof)(int type, int module_number)<br />
PHP_MINIT_FUNCTION(xhprof)<br />
{<br />
 ZEND_INIT_MODULE_GLOBALS(xhprof, php_xhprof_init_globals, NULL);</p><br />
<br />
    <p>REGISTER_INI_ENTRIES();</p><br />
<br />
    <p>hp_register_constants(INIT_FUNC_ARGS_PASSTHRU);</p><br />
<br />
    <p>/* Replace zend_compile with our proxy */<br />
 _zend_compile_file = zend_compile_file;<br />
 zend_compile_file  = hp_compile_file;</p><br />
<br />
    <p>/* Replace zend_compile_string with our proxy */<br />
 _zend_compile_string = zend_compile_string;<br />
 zend_compile_string = hp_compile_string;</p><br />
<br />
    <p>/* Replace zend_execute with our proxy */<br />
 _zend_execute_ex = zend_execute_ex;<br />
 zend_execute_ex  = hp_execute_ex;</p><br />
<br />
    <p>/* Replace zend_execute_internal with our proxy */<br />
 _zend_execute_internal = zend_execute_internal;<br />
 zend_execute_internal = hp_execute_internal;</p><br />
  </li><br />
</ul><br />
<br />
<p>#if defined(DEBUG)<br />
    /* To make it random number generator repeatable to ease testing. */<br />
    srand(0);<br />
#endif<br />
    return SUCCESS;<br />
}</p><br />
<br />
<p>/**</p><br />
<ul><br />
  <li><br />
    <p>Module shutdown callback.<br />
 <em>/<br />
模块关闭的调用的函数<br />
//int zm_shutdown_xhprof(xhprof)(int type, int module_number)<br />
PHP_MSHUTDOWN_FUNCTION(xhprof)<br />
{<br />
 /</em> free any remaining items in the free list */<br />
 hp_free_the_free_list();</p><br />
<br />
    <p>/* Remove proxies, restore the originals */<br />
 zend_execute_ex       = _zend_execute_ex;<br />
 zend_execute_internal = _zend_execute_internal;<br />
 zend_compile_file     = _zend_compile_file;<br />
 zend_compile_string   = _zend_compile_string;</p><br />
<br />
    <p>UNREGISTER_INI_ENTRIES();</p><br />
<br />
    <p>return SUCCESS;<br />
}</p><br />
  </li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li><br />
    <p>Request init callback. Nothing to do yet!<br />
 */<br />
请求初始化的调用的函数<br />
//int zm_activate_xhprof(xhprof)(int type, int module_number)<br />
PHP_RINIT_FUNCTION(xhprof)<br />
{<br />
#if defined(ZTS) &amp;&amp; defined(COMPILE_DL_XHPROF)<br />
 ZEND_TSRMLS_CACHE_UPDATE();<br />
#endif</p><br />
<br />
    <p>return SUCCESS;<br />
}</p><br />
  </li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Request shutdown callback. Stop profiling and return.<br />
 */<br />
//int zm_deactivate_xhprof(xhprof)(int type, int module_number)<br />
请求完成的调用的函数<br />
PHP_RSHUTDOWN_FUNCTION(xhprof)<br />
{<br />
 hp_end();<br />
 return SUCCESS;<br />
}</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Module info callback. Returns the xhprof version.<br />
 */<br />
phpinfo显示模块基本信息调用的函数<br />
//int zm_info_xhprof(xhprof)(zend_module_entry *zend_module)<br />
PHP_MINFO_FUNCTION(xhprof)<br />
{<br />
 php_info_print_table_start();<br />
 php_info_print_table_header(2, “xhprof support”, “enabled”);<br />
 php_info_print_table_row(2, “Version”, XHPROF_VERSION);<br />
 php_info_print_table_end();<br />
 DISPLAY_INI_ENTRIES();<br />
}</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Start XHProf profiling in hierarchical mode.<br />
 *</li><br />
  <li>@param  long $flags  flags for hierarchical mode</li><br />
  <li>@return void</li><br />
  <li><br />
    <p>@author kannan<br />
 <em>/<br />
PHP语言中 xhprof_enable函数<br />
//zif_xhprof_enable(zend_execute_data *execute_data, zval *return_value)<br />
PHP_FUNCTION(xhprof_enable)<br />
{<br />
 long  xhprof_flags = 0;              /</em> XHProf flags <em>/<br />
 zval *optional_array = NULL;         /</em> optional array arg: for future use */</p><br />
<br />
    <p>if (zend_parse_parameters(ZEND_NUM_ARGS(), “|lz”, &amp;xhprof_flags, &amp;optional_array) == FAILURE) {<br />
     return;<br />
 }</p><br />
<br />
    <p>hp_get_ignored_functions_from_arg(optional_array);</p><br />
<br />
    <p>hp_begin(XHPROF_MODE_HIERARCHICAL, xhprof_flags);<br />
}</p><br />
  </li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Stops XHProf from profiling in hierarchical mode anymore and returns the</li><br />
  <li>profile info.<br />
 *</li><br />
  <li>@param  void</li><br />
  <li>@return array  hash-array of XHProf’s profile info</li><br />
  <li>@author kannan, hzhao<br />
 <em>/<br />
PHP语言中 xhprof_disable函数<br />
//zif_xhprof_disable(zend_execute_data *execute_data, zval *return_value)<br />
PHP_FUNCTION(xhprof_disable)<br />
{<br />
 if (XHPROF_G(enabled)) {<br />
     hp_stop();<br />
     RETURN_ZVAL(&amp;XHPROF_G(stats_count), 1, 0);<br />
 }<br />
 /</em> else null is returned */<br />
}</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Start XHProf profiling in sampling mode.<br />
 *</li><br />
  <li>@return void</li><br />
  <li>@author cjiang<br />
 <em>/<br />
PHP语言中 xhprof_sample_enable函数<br />
//zif_xhprof_sample_enable(zend_execute_data *execute_data, zval *return_value)<br />
PHP_FUNCTION(xhprof_sample_enable)<br />
{<br />
 long xhprof_flags = 0;    /</em> XHProf flags */<br />
 hp_get_ignored_functions_from_arg(NULL);<br />
 hp_begin(XHPROF_MODE_SAMPLED, xhprof_flags);<br />
}</li><br />
</ul><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Stops XHProf from profiling in sampling mode anymore and returns the profile</li><br />
  <li>info.<br />
 *</li><br />
  <li>@param  void</li><br />
  <li>@return array  hash-array of XHProf’s profile info</li><br />
  <li>@author cjiang<br />
 <em>/<br />
PHP语言中 xhprof_sample_disable函数<br />
//zif_xhprof_sample_disable(zend_execute_data *execute_data, zval *return_value)<br />
PHP_FUNCTION(xhprof_sample_disable)<br />
{<br />
 if (XHPROF_G(enabled)) {<br />
     hp_stop();<br />
     RETURN_ZVAL(&amp;XHPROF_G(stats_count), 1, 0);<br />
 }<br />
  /</em> else null is returned */<br />
}<br />
这个扩展的基本接口就是上面这些代码，接下来用一个例子来详细解释一下，怎么收集性能数据的。</li><br />
</ul><br />
<br />
<p>贴出一段PHP代码</p><br />
<br />
<p>&lt;?php<br />
//phpinfo();</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>xhprof_enable(XHPROF_FLAGS_NO_BUILTINS</td><br />
      <td>XHPROF_FLAGS_CPU</td><br />
      <td>XHPROF_FLAGS_MEMORY);</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>aaa();</p><br />
<br />
<p>$xhprof_data = xhprof_disable();</p><br />
<br />
<p>print_r($xhprof_data);</p><br />
<br />
<p>function aaa()<br />
{<br />
	bbb();<br />
}</p><br />
<br />
<p>function bbb()<br />
{</p><br />
<br />
<p>}<br />
收集数据的过程其实针对函数嵌套调用递归收集的过程，xhprof_enable开启的这一行解析成 OPCODE，然后执行之前代理的hp_execute_ex函数，初始化main节点，下面就以图的形式来看下具体生成的结构，和调用链。</p><br />
<br />
<p>在xhprof_enable 和  xhprof_disable 之前的PHP代码，每一行都会被翻译成OPCODE，都会执行hp_execute_ex函数。</p><br />
<br />
<p>所以每次如果执行的是函数就会收集对应的性能数据<br />
ZEND_DLEXPORT void hp_execute_ex (zend_execute_data *execute_data)<br />
{<br />
    if (!XHPROF_G(enabled)) {<br />
        _zend_execute_ex(execute_data);<br />
        return;<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char *func = NULL;<br />
int hp_profile_flag = 1;<br />
 <br />
func = hp_get_function_name(execute_data);<br />
 <br />
if (!func) {<br />
    _zend_execute_ex(execute_data);<br />
    return;<br />
}<br />
 <br />
zend_execute_data *real_execute_data = execute_data-&gt;prev_execute_data;<br />
 <br />
BEGIN_PROFILING(&amp;XHPROF_G(entries), func, hp_profile_flag, real_execute_data);<br />
 <br />
_zend_execute_ex(execute_data);<br />
 <br />
if (XHPROF_G(entries)) {<br />
    END_PROFILING(&amp;XHPROF_G(entries), hp_profile_flag);<br />
}<br />
 <br />
efree(func); } 输出：<br />
</code></pre></div></div><br />
<br />
<p>Array<br />
(<br />
    [aaa==&gt;bbb] =&gt; Array<br />
        (<br />
            [ct] =&gt; 1<br />
            [wt] =&gt; 23<br />
            [cpu] =&gt; 29<br />
            [mu] =&gt; 832<br />
            [pmu] =&gt; 0<br />
        )</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[main()==&gt;aaa] =&gt; Array<br />
    (<br />
        [ct] =&gt; 1<br />
        [wt] =&gt; 88<br />
        [cpu] =&gt; 89<br />
        [mu] =&gt; 1408<br />
        [pmu] =&gt; 0<br />
    )<br />
 <br />
[main()] =&gt; Array<br />
    (<br />
        [ct] =&gt; 1<br />
        [wt] =&gt; 99<br />
        [cpu] =&gt; 99<br />
        [mu] =&gt; 1976<br />
        [pmu] =&gt; 0<br />
    )<br />
</code></pre></div></div><br />
<br />
<p>)<br />
xhprof_enable(XHPROF_FLAGS_NO_BUILTINS  | XHPROF_FLAGS_CPU | XHPROF_FLAGS_MEMORY);<br />
这个函数相当于执行了扩展里面的，这个函数相当自己造了一个虚拟的 main()节点，<br />
来存当前调用PHP函数的性能数据  ct wt mu pmu等数据</p><br />
<br />
<p>PHP_FUNCTION(xhprof_enable)<br />
{<br />
    long  xhprof_flags = 0;              /* XHProf flags <em>/<br />
    zval *optional_array = NULL;         /</em> optional array arg: for future use */</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (zend_parse_parameters(ZEND_NUM_ARGS(), "|lz", &amp;xhprof_flags, &amp;optional_array) == FAILURE) {<br />
    return;<br />
}<br />
 <br />
hp_get_ignored_functions_from_arg(optional_array);<br />
//以main为根节点存储性能数据<br />
hp_begin(XHPROF_MODE_HIERARCHICAL, xhprof_flags); }<br />
</code></pre></div></div><br />
<br />
<p>static void hp_begin(long level, long xhprof_flags)<br />
{<br />
    if (!XHPROF_G(enabled)) {<br />
        int hp_profile_flag = 1;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    XHPROF_G(enabled)      = 1;<br />
    XHPROF_G(xhprof_flags) = (uint32)xhprof_flags;<br />
    //先绑定每个函数开始，结束的回调函数，用来记录当时的性能点数据<br />
    /* Initialize with the dummy mode first Having these dummy callbacks saves<br />
     * us from checking if any of the callbacks are NULL everywhere. */<br />
    XHPROF_G(mode_cb).init_cb     = hp_mode_dummy_init_cb;<br />
    XHPROF_G(mode_cb).exit_cb     = hp_mode_dummy_exit_cb;<br />
    XHPROF_G(mode_cb).begin_fn_cb = hp_mode_dummy_beginfn_cb;<br />
    XHPROF_G(mode_cb).end_fn_cb   = hp_mode_dummy_endfn_cb;<br />
 <br />
    /* Register the appropriate callback functions Override just a subset of<br />
    * all the callbacks is OK. */<br />
    switch (level) {<br />
        case XHPROF_MODE_HIERARCHICAL:<br />
            XHPROF_G(mode_cb).begin_fn_cb = hp_mode_hier_beginfn_cb;<br />
            XHPROF_G(mode_cb).end_fn_cb   = hp_mode_hier_endfn_cb;<br />
            break;<br />
        case XHPROF_MODE_SAMPLED:<br />
            XHPROF_G(mode_cb).init_cb     = hp_mode_sampled_init_cb;<br />
            XHPROF_G(mode_cb).begin_fn_cb = hp_mode_sampled_beginfn_cb;<br />
            XHPROF_G(mode_cb).end_fn_cb   = hp_mode_sampled_endfn_cb;<br />
            break;<br />
    }<br />
 <br />
    /* one time initializations */<br />
    hp_init_profiler_state(level);<br />
 <br />
    /* start profiling from fictitious main() */<br />
    XHPROF_G(root) = estrdup(ROOT_SYMBOL);<br />
 <br />
    /* start profiling from fictitious main() */<br />
    BEGIN_PROFILING(&amp;XHPROF_G(entries), XHPROF_G(root), hp_profile_flag, NULL);<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>#define BEGIN_PROFILING(entries, symbol, profile_curr, execute_data)        <br /><br />
do {                                                                     <br /><br />
    /* Use a hash code to filter most of the string comparisons. <em>/     <br /><br />
    uint8 hash_code  = hp_inline_hash(symbol);                          <br /><br />
    profile_curr = !hp_ignore_entry_work(hash_code, symbol);                 <br /><br />
    if (profile_curr) {                                                 <br /><br />
        if (execute_data != NULL) {                                     <br /><br />
            symbol = hp_get_trace_callback(symbol, execute_data); <br /><br />
        }                                                               <br /><br />
        hp_entry_t *cur_entry = hp_fast_alloc_hprof_entry();            <br /><br />
        (cur_entry)-&gt;hash_code = hash_code;                             <br /><br />
        (cur_entry)-&gt;name_hprof = symbol;                               <br /><br />
        (cur_entry)-&gt;prev_hprof = (</em>(entries));                         <br /><br />
        /* Call the universal callback <em>/                               <br /><br />
        hp_mode_common_beginfn((entries), (cur_entry));                 <br /><br />
        /</em> Call the mode’s beginfn callback <em>/                          <br /><br />
        XHPROF_G(mode_cb).begin_fn_cb((entries), (cur_entry));         <br /><br />
        /</em> Update entries linked list <em>/                                <br /><br />
        (</em>(entries)) = (cur_entry);                                     <br /><br />
    }                                                               <br /><br />
} while (0)</p><br />
<br />
<p>begin_fn_cb<br />
||   这个就是记录当前函数开始，记录的CPU和内存大小<br />
void hp_mode_hier_beginfn_cb(hp_entry_t <em>*entries, hp_entry_t  *current)<br />
{<br />
    /</em> Get start tsc counter */<br />
    current-&gt;tsc_start = cycle_timer();</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Get CPU usage */<br />
if (XHPROF_G(xhprof_flags) &amp; XHPROF_FLAGS_CPU) {<br />
    current-&gt;cpu_start = cpu_timer();<br />
}<br />
 <br />
/* Get memory usage */<br />
if (XHPROF_G(xhprof_flags) &amp; XHPROF_FLAGS_MEMORY) {<br />
    current-&gt;mu_start_hprof  = zend_memory_usage(0);<br />
    current-&gt;pmu_start_hprof = zend_memory_peak_usage(0);<br />
} }  <br />
</code></pre></div></div><br />
<br />
<p>$xhprof_data = xhprof_disable(); 结束收集数据<br />
PHP这个函数对应的就是扩展里下面的这个函数，是用来停止收集，并且RETURN_ZVAL(&amp;XHPROF_G(stats_count), 1, 0); <br />
返回已经收集到的数据，<br />
数据格式在内核里面是一个二级HASHTABLE，对应PHP是一个二维数组</p><br />
<br />
<p>这个结束过程是对应这之前xhprof_enable的执行过程，是对main虚拟的节点做回源处理。<br />
//zif_xhprof_disable(zend_execute_data <em>execute_data, zval *return_value)<br />
PHP_FUNCTION(xhprof_disable)<br />
{<br />
    if (XHPROF_G(enabled)) {<br />
        hp_stop();<br />
        RETURN_ZVAL(&amp;XHPROF_G(stats_count), 1, 0);<br />
    }<br />
    /</em> else null is returned */<br />
}</p><br />
<br />
<p>static void hp_stop()<br />
{<br />
    int   hp_profile_flag = 1;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* End any unfinished calls */<br />
while (XHPROF_G(entries)) {<br />
    END_PROFILING(&amp;XHPROF_G(entries), hp_profile_flag);<br />
}<br />
 <br />
if (XHPROF_G(root)) {<br />
    efree(XHPROF_G(root));<br />
    XHPROF_G(root) = NULL;<br />
}<br />
 <br />
/* Stop profiling */<br />
XHPROF_G(enabled) = 0; } GDB调试的过程<br />
</code></pre></div></div><br />
<br />
<p>(gdb) p *xhprof_globals.entries<br />
$33 = {name_hprof = 0x7ffff1279230 “bbb”, rlvl_hprof = 0, tsc_start = 594813346976, cpu_start = 56435, mu_start_hprof = 390296, pmu_start_hprof = 427056, prev_hprof = 0x1aad3b0, hash_code = 224 ‘\340’}<br />
(gdb) p *xhprof_globals.entries-&gt;prev_hprof<br />
$34 = {name_hprof = 0x7ffff12791e0 “aaa”, rlvl_hprof = 0, tsc_start = 594308864680, cpu_start = 55591, mu_start_hprof = 390216, pmu_start_hprof = 427056, prev_hprof = 0x1aad360, hash_code = 104 ‘h’}<br />
(gdb) p *xhprof_globals.entries-&gt;prev_hprof-&gt;prev_hprof<br />
$35 = {name_hprof = 0x7ffff1202058 “main()”, rlvl_hprof = 0, tsc_start = 594156065161, cpu_start = 54939, mu_start_hprof = 390136, pmu_start_hprof = 427056, prev_hprof = 0x0, hash_code = 32 ‘ ‘}</p><br />
<br />
<p>(gdb) p *xhprof_globals.entries-&gt;prev_hprof-&gt;prev_hprof-&gt;prev_hprof</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category php
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>