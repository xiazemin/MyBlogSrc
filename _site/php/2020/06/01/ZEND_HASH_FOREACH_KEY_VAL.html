<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">ZEND_HASH_FOREACH_KEY_VAL php扩展hashtable操作</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-06-01T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jun 1, 2020</time></p>
					</div>
					 <p>php7的遍历数组和php5差很多，7提供了一些专门的宏来遍历元素（或keys）。宏的第一个参数是HashTable，其他的变量被分配到每一步迭代：</p><br />
<br />
<p>ZEND_HASH_FOREACH_VAL(ht, val)<br />
ZEND_HASH_FOREACH_KEY(ht, h, key)<br />
ZEND_HASH_FOREACH_PTR(ht, ptr)<br />
ZEND_HASH_FOREACH_NUM_KEY(ht, h)<br />
ZEND_HASH_FOREACH_STR_KEY(ht, key)<br />
ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, val)<br />
ZEND_HASH_FOREACH_KEY_VAL(ht, h, key, val)<br />
<!-- more --><br />
https://segmentfault.com/a/1190000007575322</p><br />
<br />
<p>https://www.cnblogs.com/CoderK/articles/6943291.html</p><br />
<br />
<p>http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html</p><br />
<br />
<p>1.1     使用数组<br />
曾讲到，PHP数组本质上就是个HashTable，因此访问数组就是对HashTable进行操作，Zend为我们提供的一组数组函数也只是对HashTable操作进行了简单包装而已。</p><br />
<br />
<p>来看创建数组，由于数组也是存在于zval里的，因此要先用MAKE_STD_ZVAL()宏创建一个zval，之后调用如下宏将其转化为一个空数组：</p><br />
<br />
<p>array_init(zval*)<br />
接下来是朝数组中添加元素，这对关联数组元素和非关联数组元素要采用不同操作。</p><br />
<br />
<p>1.1.1 关联数组元素<br />
关联数组采用char<em>作为key，zval</em>作为value，可以使用如下宏将已有的zval加入数组或者更新已有元素：</p><br />
<br />
<p>int add_assoc_zval(zval *arr, char *key, zval *value)<br />
需要特别注意的是，Zend不会复制zval，只会简单的储存其指针，并且不关心任何引用计数，因此不能将其他变量的zval或者是栈上的zval传给它，只能用MAKE_STD_ZVAL()宏构建。</p><br />
<br />
<p>Zend为常用的类型定义了相应的API，以简化我们的操作：</p><br />
<br />
<p>add_assoc_long(zval *array, char *key, long n);<br />
add_assoc_bool(zval *array, char *key, int b);<br />
add_assoc_resource(zval *array, char *key, int r);<br />
add_assoc_double(zval *array, char *key, double d);<br />
add_assoc_string(zval *array, char *key, char *str, int duplicate);<br />
add_assoc_stringl(zval *array, char *key, char *str, uint length, int duplicate);<br />
add_assoc_null(zval *array, char *key);<br />
当函数发现目标元素已经存在时，会首先递减其原zval的refcount，然后才插入新zval，这就保证了原zval引用信息的正确性。这种行为是通过HashTable.pDestructor（参见1.2.1）实现的，每次删除一个元素时，HashTable都将对被删元素调用这个函数指针，而数组为其HashTable设置的函数指针就是用来处理被删除zval的引用信息。</p><br />
<br />
<p>另外，查看这些函数的源代码可以发现一个有意思的现象，它们没有直接使用HashTable操作，而是使用变量符号表操作，可见关联数组和变量符号表就是一种东西。</p><br />
<br />
<p>Zend没有提供删除和获取数组元素的函数，此类操作只能使用HashTable函数或者是2.6节的变量符号表操作。</p><br />
<br />
<p>1.1.2非关联数组元素<br />
非关联数组没有key，使用index作为hash，相应函数和上面关联数组的十分类似：</p><br />
<br />
<p>add_index_zval(zval *array, uint idx, zval *value);<br />
add_index_long(zval *array, uint idx, long n);<br />
add_index_bool(zval *array, uint idx, int b);<br />
add_index_resource(zval *array, uint idx, int r);<br />
add_index_double(zval *array, uint idx, double d);<br />
add_index_string(zval *array, uint idx, char *str, int duplicate);<br />
add_index_stringl(zval *array, uint idx, char *str, uint length, int duplicate);<br />
add_index_null(zval *array, uint idx);<br />
如果只是想插入值，而不指定index的话，可以使用如下函数：</p><br />
<br />
<p>add_next_index_zval(zval *array, zval *value);<br />
add_next_index_long(zval *array, long n);<br />
add_next_index_bool(zval *array, int b);<br />
add_next_index_resource(zval *array, int r);<br />
add_next_index_double(zval *array, double d);<br />
add_next_index_string(zval *array, char *str, int duplicate);<br />
add_next_index_stringl(zval *array, char *str, uint length, int duplicate);<br />
add_next_index_null(zval *array);<br />
1.2      使用资源<br />
1.2.1  注册资源类型<br />
1.1.1节曾经提到，所谓资源就是内部数据的handle（但是这句话并不全对），使用资源是比较简单的，首先是注册一个资源类型：</p><br />
<br />
<p>int zend_register_list_destructors_ex(<br />
rsrc_dtor_func_t ld,<br />
rsrc_dtor_func_t pld,<br />
char <em>type_name,<br />
int module_number);<br />
第一个参数是函数指针，当资源不再被使用或者模块将被卸载时，Zend使用它来销毁资源，稍候再作介绍；第二个参数和第一个类似，只是它被用来销毁持久性资源(</em>)；type_name是资源名称，用户可以使用var_dump函数来读取；module_number是模块号，在启动函数中可以获取该值。</p><br />
<br />
<p>注册过程其实就是将我们传入的参数放到一个内部数据结构，然后把这个数据结构放入一个没有使用key的HashTable里，该函数返回的值，也就是所谓“资源类型id”，其实就是HashTable的index。</p><br />
<br />
<p>1.2.1  注册资源<br />
注册完资源类型后，就可以注册一个该类型的资源了：</p><br />
<br />
<p>1<br />
ZEND_REGISTER_RESOURCE(<br />
2<br />
rsrc_result,<br />
3<br />
rsrc_pointer,<br />
4<br />
rsrc_type)<br />
src_pointer是个指针类型，就是你的资源的handle, 通常是指向内部数据的指针，当然也可以是index或者其它标志符；rsrc_type是上面获取的资源类型id；rsrc_result是个已有的zval，注册完成后，资源的id就被放入该zval，同时其type也被设为IS_RESOURCE，通常是传入return_value，以将资源返回给用户。</p><br />
<br />
<p>在内部，Zend使用如下数据结构表示一个资源：</p><br />
<br />
<p>1<br />
typedef struct _zend_rsrc_list_entry {<br />
2<br />
    void *ptr;<br />
3<br />
    int type;<br />
4<br />
    int refcount;<br />
5<br />
} zend_rsrc_list_entry;<br />
ptr和type就是我们在上面传入的参数；refcount是引用计数，由Zend维护，当引用减到0时，Zend会销毁该资源。不出所料的是，这个数据结构也被组织在一个HashTable里，并且没有使用key，仅仅使用index——这就是zval里存放的东西。现在资源的整个脉络已经清晰：通过zval可以获得资源id，通过资源id可以获得资源handle和资源类型id，通过资源类型id可以获得资源的销毁函数。<br />
现在讲一下销毁函数：</p><br />
<br />
<p>1<br />
typedef void (*rsrc_dtor_func_t)(<br />
2<br />
zend_rsrc_list_entry *rsrc<br />
3<br />
TSRMLS_DC);<br />
rsrc是需要被销毁的资源，我们在函数的实现中可以通过它获得资源的handle，并且加以处理，比如释放内存块、关闭数据库连接或是关闭文件描述符等。</p><br />
<br />
<p>1.2.3  获取资源<br />
当创建了资源后，用户通常都要调用创建者提供的函数来操作资源，此时我们需要从用户传入的zval中取出资源：</p><br />
<br />
<p>1<br />
ZEND_FETCH_RESOURCE(<br />
2<br />
rsrc,  rsrc_type,<br />
3<br />
passed_id, default_id,<br />
4<br />
resource_type_name, resource_type)<br />
首个参数用于接收handle值，第二个参数是handle值的类型，这个函数会扩展成“rsrc = (rsrc_type) zend_fetch_resource(…)”，因此应该保证rsrc是rsrc_type类型的；passed_id是用户传入的zval，这里使用zval**类型，函数从中取得资源id；default_id用来直接指定资源id，如果该值不是-1，则使用它，并且忽略passed_id，所以通常应该使用-1；resource_type_name是资源名称，当获取资源失败时，函数使用它来输出错误信息；resource_type是资源类型，如果取得的资源不是该类型的，则函数返回NULL，这用于防止用户传入一个其他类型资源的zval。</p><br />
<br />
<p>不过，这个宏确实比较难用，用其底层的宏反倒更加容易些：</p><br />
<br />
<p>1<br />
zend_list_find(id, type)<br />
id是要查找的资源id；type是int*类型，用于接收取出的资源的类型，可以用它来判断这是不是我们想要的资源；函数最后返回资源的handle，失败返回NULL。</p><br />
<br />
<p>1.2.4  维护引用计数<br />
通常，当用户对资源类型的PHP变量执行赋值或是unset之类操作时，Zend会自动维护资源的引用计数。但有时，我们也需要手动进行，比如我们要复用一个数据库连接或者用户调用我们提供的close操作关闭一个文件，此时可以使用如下宏：</p><br />
<br />
<p>1<br />
zend_list_addref(id)<br />
2<br />
zend_list_delete(id)<br />
id是资源id，这两个宏分别增加和减少目标资源的引用计数，第二个宏还会在引用计数减到0时，调用先前注册的函数销毁资源。</p><br />
<br />
<p>https://blog.csdn.net/tonysz126/article/details/6993665</p><br />
<br />
<p>https://www.cnblogs.com/ling-diary/p/10676109.html</p><br />
<br />
<p>https://www.laruence.com/2020/02/25/3182.html</p><br />
<br />
<p>https://blog.csdn.net/ligupeng7929/article/details/90521059</p><br />
<br />
<p>https://stackoverflow.com/questions/56429192/convert-php-two-dimensional-arrays-to-php-extension/56453407?r=SearchResults#56453407</p><br />
<br />
<p>https://segmentfault.com/q/1010000007890184</p><br />
<br />
<p>https://segmentfault.com/a/1190000007575322</p><br />
<br />
<p>到这已经能声明简单函数，返回静态或者动态值了。定义INI选项，声明内部数值或全局数值。本章节将介绍如何接收从调用脚本(php文件)传入参数的数值，以及 PHP内核 和 Zend引擎 如何操作内部变量。</p><br />
<br />
<p>接收参数</p><br />
<br />
<p>与用户控件的代码不同，内部函数的参数实际上并不是在函数头部声明的，函数声明都形如: PHP_FUNCTION(func_name) 的形式，参数声明不在其中。参数的传入是通过参数列表的地址传入的，并且是传入每一个函数，不论是否存在参数。</p><br />
<br />
<p>通过定义函数hello_str()来看一下，它将接收一个参数然后把它与问候的文本一起输出。</p><br />
<br />
<p>PHP_FUNCTION(hello_greetme){ char*name = NULL; size_tname_len; zend_string *strg; if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, “s”, &amp;name, &amp;name_len) == FAILURE) { RETURN_NULL(); } strg = strpprintf( 0, “你好: %s”, name); RETURN_STR(strg);}</p><br />
<br />
<p>大多数 zend_parse_parameters() 块看起来都差不多。 ZEND_NUM_ARGS() 告诉Zend引擎要取的参数的信息， TSRMLS_CC 用来确保线程安全，返回值检测是SUCCESS还是FAILURE。通常情况下返回是SUCCESS的。除非传入的参数太少或太多或者参数不能被转为适当的类型，Zend会自动输出一条错误信息并将控制权还给调用脚本。</p><br />
<br />
<p>指定 “s” 表明此函数期望只传入一个参数，并且该参数被转化为string数据类型，地址传入char * 变量。</p><br />
<br />
<p>此外，还有一个int变量通过地址传递到 zend_parse_parameters() 。这使Zend引擎提供字符串的字节长度，如此二进制安全的函数不再依赖strlen(name)来确定字符串的长度。因为实际上使用strlen(name)甚至得不到正确的结果，因为name可能在字符串结束之前包含了NULL字符。</p><br />
<br />
<p>在php7中，提供另一种获取参数的方式FAST_ZPP，是为了提高参数解析的性能。</p><br />
<br />
<p>#ifdefFAST_ZPPZEND_PARSE_PARAMETERS_START( 1, 2) Z_PARAM_STR(type) Z_PARAM_OPTIONALZ_PARAM_ZVAL_EX(value, 0, 1) ZEND_PARSE_PARAMETERS_END(); #endif</p><br />
<br />
<p>参数类型表</p><br />
<br />
<p>类型	代码	变量类型<br />
Boolean	b	zend_bool<br />
Long	l	long<br />
Double	d	double<br />
String	s	char*, int<br />
Resource	r	zval *<br />
Array	a	zval *<br />
Object	o	zval *<br />
zval	z	zval *<br />
最后四个类型都是zvals *.这是因为在php的实际使用中，zval数据类型存储所有的用户空间变量。三种“复杂”数据类型：资源、数组、对象。当它们的数据类型代码被用于zend_parse_parameters()时，Zend引擎会进行类型检查，但是因为在C中没有与它们对应的数据类型，所以不会执行类型转换。</p><br />
<br />
<p>Zval</p><br />
<br />
<p>一般而言，zval和php用户空间变量是很伤脑筋的，概念很难懂。到了PHP7，它的结构在Zend/zend_types.h中有定义：</p><br />
<br />
<p>struct_zval_struct { zend_value value; /* value <em>/union{ struct{ ZEND_ENDIAN_LOHI_4( zend_uchar type, /</em> active type <em>/zend_uchar type_flags, zend_uchar const_flags, zend_uchar reserved) /</em> call info for EX(This) <em>/} v; uint32_ttype_info; } u1; union{ uint32_tnext; /</em> hash collision chain <em>/uint32_tcache_slot; /</em> literal cache slot <em>/uint32_tlineno; /</em> line number (for ast nodes) <em>/uint32_tnum_args; /</em> arguments number for EX(This) <em>/uint32_tfe_pos; /</em> foreach position <em>/uint32_tfe_iter_idx; /</em> foreach iterator index <em>/uint32_taccess_flags; /</em> class constant access flags <em>/uint32_tproperty_guard; /</em> single property guard */} u2;};</p><br />
<br />
<p>可以看到，变量是通过_zval_struct结构体存储的，而变量的值是zend_value类型的：</p><br />
<br />
<p>typedefunion_zend_value { zend_long lval; /* long value <em>/doubledval; /</em> double value <em>/zend_refcounted *counted; zend_string *str; zend_array *arr; zend_object *obj; zend_resource *res; zend_reference *ref; zend_ast_ref *ast; zval *zv; void</em>ptr; zend_class_entry *ce; zend_function *func; struct{ uint32_tw1; uint32_tw2; } ww;} zend_value;</p><br />
<br />
<p>虽然结构体看起来很大，但细细看，其实都是联合体，value的扩充，u1是type_info，u2是其他各种辅助字段。</p><br />
<br />
<p>zval 类型</p><br />
<br />
<p>变量存储的数据是有数据类型的，php7中总体有以下类型,Zend/zend_types.h中有定义：</p><br />
<br />
<p>/* regular data types <em>/#defineIS_UNDEF 0#defineIS_NULL 1#defineIS_FALSE 2#defineIS_TRUE 3#defineIS_LONG 4#defineIS_DOUBLE 5#defineIS_STRING 6#defineIS_ARRAY 7#defineIS_OBJECT 8#defineIS_RESOURCE 9#defineIS_REFERENCE 10/</em> constant expressions <em>/#defineIS_CONSTANT 11#defineIS_CONSTANT_AST 12/</em> fake types <em>/#define_IS_BOOL 13#defineIS_CALLABLE 14#defineIS_ITERABLE 19#defineIS_VOID 18/</em> internal types */#defineIS_INDIRECT 15#defineIS_PTR 17#define_IS_ERROR 20</p><br />
<br />
<p>测试</p><br />
<br />
<p>书写一个类似gettype()来取得变量的类型的hello_typeof():</p><br />
<br />
<p>PHP_FUNCTION(hello_typeof){ zval *userval = NULL; if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, “z”, &amp;userval) == FAILURE) { RETURN_NULL(); } switch(Z_TYPE_P(userval)) { caseIS_NULL: RETVAL_STRING( “NULL”); break; caseIS_TRUE: RETVAL_STRING( “true”); break; caseIS_FALSE: RETVAL_STRING( “false”); break; caseIS_LONG: RETVAL_STRING( “integer”); break; caseIS_DOUBLE: RETVAL_STRING( “double”); break; caseIS_STRING: RETVAL_STRING( “string”); break; caseIS_ARRAY: RETVAL_STRING( “array”); break; caseIS_OBJECT: RETVAL_STRING( “object”); break; caseIS_RESOURCE: RETVAL_STRING( “resource”); break; default: RETVAL_STRING( “unknown type”); }}</p><br />
<br />
<p>这里使用RETVAL_STRING()与之前的RETURN_STRING()差别并不大,它们都是宏。只不过RETURN_STRING中包含了RETVAL_STRING的宏代替，详细在 Zend/zend_API.h 中有定义:</p><br />
<br />
<p>#defineRETVAL_STRING(s) ZVAL_STRING(return_value, s)#defineRETVAL_STRINGL(s, l) ZVAL_STRINGL(return_value, s, l)#defineRETURN_STRING(s) { RETVAL_STRING(s); return; }#defineRETURN_STRINGL(s, l) { RETVAL_STRINGL(s, l); return; }</p><br />
<br />
<p>创建zval</p><br />
<br />
<p>前面用到的zval是由Zend引擎分配空间，也通过同样的途径释放。然而有时候需要创建自己的zval，可以参考如下代码：</p><br />
<br />
<p>{ zval temp; ZVAL_LONG(&amp;temp, 1234);}</p><br />
<br />
<p>数组</p><br />
<br />
<p>数组作为运载其他变量的变量。内部实现上使用了众所周知的 HashTable .要创建将被返回PPHP的数组，最简单的方法：</p><br />
<br />
<p>PHP语法	C语法（arr是zval*）	意义<br />
$arr = array();	array_init(arr);	初始化一个新数组<br />
$arr[] = NULL;	add_next_index_null(arr);	向数字索引的数组增加指定类型的值<br />
$arr[] = 42;	add_next_index_long(arr, 42);	<br />
$arr[] = true;	add_next_index_bool(arr, 1);	<br />
$arr[] = 3.14;	add_next_index_double(arr, 3.14);	<br />
$arr[] = ‘foo’;	add_next_index_string(arr, “foo”, 1);	<br />
$arr[] = $myvar;	add_next_index_zval(arr, myvar);	<br />
$arr[0] = NULL;	add_index_null(arr, 0);	向数组中指定的数字索引增加指定类型的值<br />
$arr[1] = 42;	add_index_long(arr, 1, 42);	<br />
$arr[2] = true;	add_index_bool(arr, 2, 1);	<br />
$arr[3] = 3.14;	add_index_double(arr, 3, 3.14);	<br />
$arr[4] = ‘foo’;	add_index_string(arr, 4, “foo”, 1);	<br />
$arr[5] = $myvar;	add_index_zval(arr, 5, myvar);	<br />
$arr[‘abc’] = NULL;	add_assoc_null(arr, “abc”);	<br />
$arr[‘def’] = 711;	add_assoc_long(arr, “def”, 711);	向关联索引的数组增加指定类型的值<br />
$arr[‘ghi’] = true;	add_assoc_bool(arr, “ghi”, 1);	<br />
$arr[‘jkl’] = 1.44;	add_assoc_double(arr, “jkl”, 1.44);	<br />
$arr[‘mno’] = ‘baz’;	add_assoc_string(arr, “mno”, “baz”, 1);	<br />
$arr[‘pqr’] = $myvar;	add_assoc_zval(arr, “pqr”, myvar);	<br />
做一个测试：</p><br />
<br />
<p>PHP_FUNCTION(hello_get_arr){ array_init(return_value); add_next_index_null(return_value); add_next_index_long(return_value, 42); add_next_index_bool(return_value, 1); add_next_index_double(return_value, 3.14); add_next_index_string(return_value, “foo”); add_assoc_string(return_value, “mno”, “baz”); add_assoc_bool(return_value, “ghi”, 1);}</p><br />
<br />
<p>add_*_string()函数参数从四个改为了三个。</p><br />
<br />
<p>数组遍历</p><br />
<br />
<p>假设我们需要一个取代以下功能的拓展：</p><br />
<br />
<p>&lt;?phpfunctionhello_array_strings($arr){ if(!is_array($arr)) { returnNULL; } printf(“The array passed contains %d elementsn”, count($arr)); foreach($arr as$data) { if(is_string($data)) echo$data.’n’; }}</p><br />
<br />
<p>php7的遍历数组和php5差很多，7提供了一些专门的宏来遍历元素（或keys）。宏的第一个参数是HashTable，其他的变量被分配到每一步迭代：</p><br />
<br />
<p>ZEND_HASH_FOREACH_VAL(ht, val)</p><br />
<br />
<p>ZEND_HASH_FOREACH_KEY(ht, h, key)</p><br />
<br />
<p>ZEND_HASH_FOREACH_PTR(ht, ptr)</p><br />
<br />
<p>ZEND_HASH_FOREACH_NUM_KEY(ht, h)</p><br />
<br />
<p>ZEND_HASH_FOREACH_STR_KEY(ht, key)</p><br />
<br />
<p>ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, val)</p><br />
<br />
<p>ZEND_HASH_FOREACH_KEY_VAL(ht, h, key, val)</p><br />
<br />
<p>因此它的对应函数实现如下：</p><br />
<br />
<p>PHP_FUNCTION(hello_array_strings){ ulongnum_key; zend_string *key; zval *val, *arr; HashTable *arr_hash; intarray_count; if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, “a”, &amp;arr) == FAILURE) { RETURN_NULL(); } arr_hash = Z_ARRVAL_P(arr); array_count = zend_hash_num_elements(arr_hash); php_printf( “The array passed contains %d elementsn”, array_count); ZEND_HASH_FOREACH_KEY_VAL(arr_hash, num_key, key, val) { //if (key) { //HASH_KEY_IS_STRING//}PHPWRITE(Z_STRVAL_P(val), Z_STRLEN_P(val)); php_printf( “n”); }ZEND_HASH_FOREACH_END();}</p><br />
<br />
<p>因为这是新的遍历方法，而我看的还是php5的处理方式，调试出上面的代码花了不少功夫，总的来说，用宏的方式遍历大大减少了编码体积。哈希表是php中很重要的一个内容，有时间再好好研究一下。</p><br />
<br />
<p>遍历数组的其他方式</p><br />
<br />
<p>遍历 HashTable 还有其他方法。Zend引擎针对这个任务展露了三个非常类似的函数：zend_hash_apply(), zend_hash_apply_with_argument(), zend_hash_apply_with_arguments。第一个形式仅仅遍历HashTable，第二种形式允许传入单个void*参数，第三种形式通过var arg列表允许数量不限的参数。hello_array_walk()展示个他们各自的行为。</p><br />
<br />
<p>staticintphp_hello_array_walk(zval <em>ele TSRMLS_DC){ zval temp = *ele; // 临时zval，避免convert_to_string 污染原元素zval_copy_ctor(&amp;temp); // 分配新 zval 空间并复制 ele 的值convert_to_string(&amp;temp); // 字符串类型转换//简单的打印PHPWRITE(Z_STRVAL(temp), Z_STRLEN(temp)); php_printf( “n”); zval_dtor(&amp;temp); //释放临时的 tempreturnZEND_HASH_APPLY_KEEP;} staticintphp_hello_array_walk_arg(zval *ele, char</em>greeting TSRMLS_DC){ php_printf( “%s”, greeting); php_hello_array_walk(ele TSRMLS_CC); returnZEND_HASH_APPLY_KEEP;} staticintphp_hello_array_walk_args(zval <em>ele, intnum_args, va_list args, zend_hash_key *hash_key){ char</em>prefix = va_arg(args, char<em>); char</em>suffix = va_arg(args, char*); TSRMLS_FETCH(); php_printf( “%s”, prefix); // 打印键值对结果php_printf( “key is : [ “); if(hash_key-&gt;key) { PHPWRITE(ZSTR_VAL(hash_key-&gt;key), ZSTR_LEN(hash_key-&gt;key)); } else{ php_printf( “%ld”, hash_key-&gt;h); } php_printf( “ ]”); php_hello_array_walk(ele TSRMLS_CC); php_printf( “%sn”, suffix); returnZEND_HASH_APPLY_KEEP;}</p><br />
<br />
<p>用户调用的函数：</p><br />
<br />
<p>PHP_FUNCTION(hello_array_walk){ zval *arr; HashTable *arr_hash; if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, “a”, &amp;arr) == FAILURE) { RETURN_NULL(); } arr_hash = Z_ARRVAL_P(arr); //第一种遍历 简单遍历各个元素zend_hash_apply(arr_hash, ( apply_func_t)php_hello_array_walk TSRMLS_CC); //第二种遍历 带一个参数的简单遍历各个元素zend_hash_apply_with_argument(arr_hash, ( apply_func_arg_t)php_hello_array_walk_arg, “Hello “TSRMLS_CC); //第三种遍历 带多参数的遍历key-&gt;valuezend_hash_apply_with_arguments(arr_hash, ( apply_func_args_t)php_hello_array_walk_args, 2, “Hello “, “Welcome to my extension!”); RETURN_TRUE;}</p><br />
<br />
<p>为了复用，在输出值时调用php_hello_array_walk(ele TSRMLS_CC)。传入hello_array_walk()的数组被遍历了三次,一次不带参数，一次带单个参数，一次带两给参数。三个遍历的函数返回了ZEND_HASH_APPLY_KEEP。这告诉zend_hash_apply()函数离开HashTable中的（当前）元素，继续处理下一个。</p><br />
<br />
<p>这儿也可以返回其他值：ZEND_HASH_APPLY_REMOVE删</p><br />
<br />
<p>除当前元素并继续应用到下一个；ZEND_HASH_APPLY_STOP在当前元素中止数组的遍历并退出zend_hash_apply()函数。</p><br />
<br />
<p>TSRMLS_FETCH() 是一个关于线程安全的动作，用于避免各线程的作用域被其他的侵入。因为zend_hash_apply()的多线程版本用了vararg列表，tsrm_ls标记没有传入walk()函数。</p><br />
<br />
<p>&lt;?php$arr = [“99”, “fff”, “key1”=&gt;”888”, “key2”=&gt;”aaa”];hello_array_walk($arr);</p><br />
<br />
<p>val<br />
zval结构体是Zend内核的非常核心的结构，在PHP5和PHP7之间的差别非常大，我给出2处文章供大家学习，基本上可以代表这块知识点最权威的介绍了。</p><br />
<br />
<p>深入理解PHP7之zval（鸟哥）<br />
变量在 PHP7 内部的实现（Nikita Popov）中文版<br />
PHP7不再使用zval的二级指针，大多数场景下出现的zval<em>变量都改成zval，相应的使用在这些变量上的宏Z_PP也需要改成Z_P。<br />
在大部分场景下，PHP7是在栈上直接使用zval，不需要去堆上分配内存。这时，zval 就需要改成zval，宏也需要从Z__P改成Z_，创建宏从ZVAL_(var)转换成ZVAL_</em>(&amp;var)。所以，分配zval内存的宏</p><br />
<br />
<p>ALLOC_ZVAL、ALLOC_INIT_ZVAL、MAKE_STD_ZVAL都被删掉了。</p><br />
<ul><br />
  <li>zval *zv;</li><br />
  <li>MAKE_STD_ZVAL(zv);</li><br />
  <li>array_init(zv);</li><br />
  <li>zval zv;</li><br />
  <li><br />
    <p>array_init(&amp;zv);<br />
PHP7中zval的long和double类型是不需要引用计数的，所以相关的宏要做调整。</p><br />
  </li><br />
  <li>Z_ADDREF_P(zv)</li><br />
  <li><br />
    <p>Z_TRY_ADDREF_P(zv);<br />
PHP7中zval的类型，删除了IS_BOOL，增加了IS_TRUE和IS_FALSE。</p><br />
  </li><br />
  <li>if (Z_TYPE_P(zv) == IS_BOOL) {</li><br />
  <li>}</li><br />
  <li>if (Z_TYPE_P(zv) == IS_TRUE) {</li><br />
  <li>} else if (Z_TYPE_P(zv) == IS_FALSE) {</li><br />
  <li>}<br />
zend_string<br />
PHP7中增加了一个新的内置字符串类型zend_string，下面是Zend内核中的结构体定义。</li><br />
</ul><br />
<br />
<p>struct _zend_string {<br />
zend_refcounted_h gc; /* 垃圾回收结构体 <em>/<br />
zend_ulong h; /</em> 字符串哈希值 <em>/<br />
size_t len; /</em> 字符串长度 <em>/<br />
char val[1]; /</em> 字符串内容 */<br />
};<br />
gc是PHP7中的所有非标量结构都包含的垃圾回收结构体变量；h是字符串哈希值，作为HashTable的key时不需要每次都重新计算哈希值，提高了效率；len是字符串长度，同理每次使用到字符串的长度时不需要再计算，提高了效率；val[1]是C语言的黑科技，此处按照char *理解即可。这里有三个宏帮助我们方便的使用zend_string的变量。</p><br />
<br />
<p>#define ZSTR_VAL(zstr) (zstr)-&gt;val<br />
#define ZSTR_LEN(zstr) (zstr)-&gt;len<br />
#define ZSTR_H(zstr) (zstr)-&gt;h<br />
创建和销毁zend_string使用以下方法。</p><br />
<br />
<p>zend_string *zend_string_init(const char *str, size_t len, int persistent)<br />
void zend_string_release(zend_string *s)<br />
zend_string用来替代PHP5中使用char *和int的场景，尤其是很多API的参数和返回值都做了调整。</p><br />
<br />
<ul><br />
  <li>int zend_hash_find(const HashTable *ht, const char *arKey, uint nKeyLength, void **pData)</li><br />
  <li>zval* ZEND_FASTCALL zend_hash_find(const HashTable *ht, zend_string *key)</li><br />
  <li>void zend_mangle_property_name(char **dest, int *dest_length, const char *src1, int src1_length, const char *src2, int src2_length, int internal);</li><br />
  <li><br />
    <p>zend_string *zend_mangle_property_name(const char *src1, size_t src1_length, const char *src2, size_t src2_length, int internal)<br />
HashTable API<br />
在PHP7中使用HashTable的API方法时，有了非常明显的变化。<br />
查询方法，PHP5使用引用传参的方式，同时返回SUCCESS/FAILURE；PHP7直接返回结果，查询无结果时返回NULL。</p><br />
  </li><br />
  <li>int zend_hash_find(const HashTable *ht, const char *arKey, uint nKeyLength, void **pData)</li><br />
  <li><br />
    <p>zval* ZEND_FASTCALL zend_hash_find(const HashTable *ht, zend_string *key)<br />
HashTable的API方法中的key，PHP5中使用char 和int代表的字符串；PHP7中使用zend_string代表的字符串，同时提供了对char 和int支持的一组方法，但是需要注意的是这里的字符串长度是不包括结尾的’0’的，在升级扩展时难免会碰到很多地方需要加减一。</p><br />
  </li><br />
  <li>int zend_hash_exists(const HashTable *ht, const char *arKey, uint nKeyLength)</li><br />
  <li>zend_bool zend_hash_exists(const HashTable *ht, zend_string *key)</li><br />
  <li>zend_bool zend_hash_str_exists(const HashTable *ht, const char *str, size_t len)<br />
PHP7为HashTable的value为指针时设计了一组API，在常规的API方法后添加后缀_ptr即可。</li><br />
</ul><br />
<br />
<p>void *zend_hash_find_ptr(const HashTable *ht, zend_string *key)<br />
void *zend_hash_update_ptr(HashTable *ht, zend_string *key, void *pData)<br />
PHP7为HashTable的轮询设计了一组宏，使用起来非常方便。</p><br />
<br />
<p>ZEND_HASH_FOREACH_VAL(ht, val)<br />
ZEND_HASH_FOREACH_KEY(ht, h, key)<br />
ZEND_HASH_FOREACH_PTR(ht, ptr)<br />
ZEND_HASH_FOREACH_NUM_KEY(ht, h)<br />
ZEND_HASH_FOREACH_STR_KEY(ht, key)<br />
ZEND_HASH_FOREACH_STR_KEY_VAL(ht, key, val)<br />
ZEND_HASH_FOREACH_KEY_VAL(ht, h, key, val)<br />
自定义对象<br />
这里有点复杂，我直接附上我的代码，结合代码来做详细说明。</p><br />
<br />
<p>typedef struct{<br />
int max;<br />
int offset;<br />
zend_object zo;<br />
} php_protocolbuffers_unknown_field_set;<br />
static zend_object_handlers php_protocolbuffers_unknown_field_set_object_handlers;<br />
static void php_protocolbuffers_unknown_field_set_free_storage(php_protocolbuffers_unknown_field_set <em>object TSRMLS_DC)<br />
{<br />
php_protocolbuffers_unknown_field_set *unknown_field_set;<br />
unknown_field_set = (php_protocolbuffers_unknown_field_set</em>)((char *) object - XtOffsetOf(php_protocolbuffers_unknown_field_set, zo))；<br />
zend_object_std_dtor(&amp;unknown_field_set-&gt;zo TSRMLS_CC);<br />
}<br />
zend_object *php_protocolbuffers_unknown_field_set_new(zend_class_entry *ce TSRMLS_DC)<br />
{<br />
php_protocolbuffers_unknown_field_set *intern;<br />
intern = ecalloc(1, sizeof(php_protocolbuffers_unknown_field_set) + zend_object_properties_size(ce));<br />
zend_object_std_init(&amp;intern-&gt;zo, ce);<br />
object_properties_init(&amp;intern-&gt;zo, ce);<br />
intern-&gt;zo.handlers = &amp;php_protocolbuffers_unknown_field_set_object_handlers;<br />
intern-&gt;max = 0;<br />
intern-&gt;offset = 0;<br />
return &amp;intern-&gt;zo;<br />
}<br />
void php_protocolbuffers_unknown_field_set_class(TSRMLS_D)<br />
{<br />
// 此处有省略<br />
php_protocol_buffers_unknown_field_set_class_entry-&gt;create_object = php_protocolbuffers_unknown_field_set_new;<br />
memcpy(&amp;php_protocolbuffers_unknown_field_set_object_handlers, zend_get_std_object_handlers(), sizeof(zend_object_handlers));<br />
php_protocolbuffers_unknown_field_set_object_handlers.offset = XtOffsetOf(php_protocolbuffers_unknown_field_set, zo);<br />
php_protocolbuffers_unknown_field_set_object_handlers.free_obj = php_protocolbuffers_unknown_field_set_free_storage;<br />
}<br />
我们想自定义一个php_protocolbuffers_unknown_field_set的对象，在它的结构体里面除了zend_object，还有自定义的max和offset，务必把zend_object放在最后。<br />
实际生成对象的地方基本就是标准写法，先分配内存，包括php_protocolbuffers_unknown_field_set结构体的内存和对象属性的内存；然后对zend_object的handlers赋值；最后再对自己自定义的变量初始化。<br />
实际生成对象handler的地方也是标准写法，先分配内存，offset是必须设置的，可选的设置项有free_obj，dtor_obj，clone_obj。<br />
想取到zend_object，需要(STRUCT_NAME )((char )OBJECT - XtOffsetOf(STRUCT_NAME, zo))</p><br />
<br />
<p>https://www.qdchaoyi.com/hacbv/67623.html</p><br />
<br />
<p>https://blog.csdn.net/caohao0591/article/details/82191001</p><br />
<br />
<p>https://www.sohu.com/a/120741342_505802</p><br />
<br />
<p>https://blog.csdn.net/u013474436/article/details/53485140</p><br />
<br />
<p>https://www.cnblogs.com/CoderK/articles/6943274.html</p><br />
<br />
<p>https://www.sohu.com/a/120741342_505802</p><br />
<br />
<p>https://blog.csdn.net/weixin_33816946/article/details/90590457</p><br />
<br />
<p>https://www.cnblogs.com/natian-ws/p/9105338.html</p><br />
<br />
<p>https://blog.csdn.net/nomius/article/details/94028034</p><br />
<br />
<p>https://www.cnblogs.com/sohuhome/p/9800977.html</p><br />
<br />
<p>https://www.laruence.com/2018/04/08/3170.html</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category php
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>