<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">current_execute_data</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-06-06T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jun 6, 2020</time></p>
					</div>
					 <ol><br />
  <li><br />
    <p>Zend引擎主要包含两个核心部分：编译、执行：</p><br />
<br />
    <p>执行阶段主要用到的数据结构：</p><br />
<br />
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   opcode： php代码编译产生的zend虚拟机可识别的指令，php7有173个opcode，定义在 zend_vm_opcodes.hPHP中的所有语法实现都是由这些opcode组成的。<br />
</code></pre></div>    </div><br />
  </li><br />
</ol><br />
<br />
<p>复制代码<br />
struct _zend_op {<br />
    const void *handler; //对应执行的C语言function，即每条opcode都有一个C function处理<br />
    znode_op op1;   //操作数1<br />
    znode_op op2;   //操作数2<br />
    znode_op result; //返回值<br />
    uint32_t extended_value; <br />
    uint32_t lineno; <br />
    zend_uchar opcode;  //opcode指令<br />
    zend_uchar op1_type; //操作数1类型<br />
    zend_uchar op2_type; //操作数2类型<br />
    zend_uchar result_type; //返回值类型<br />
};<br />
复制代码<br />
         zend_op_array : zend引擎执行阶段的输入数据结构，整个执行阶段都是操作这个数据结构。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  　　　　　　 zend_op_array有三个核心部分：opcode指令(对应c的指令)<br />
<br />
                                               字面量存储(变量初始值、调用的函数名称、类名称、常量名称等等称之为字面量)<br />
<br />
                                               变量分配的情况 (当前array定义的变量 临时变量的数量 编号，执行初始化一次性分配zval，使用时完全按照标号索引不是根据变量名)<br />
<br />
     <br />
<br />
       zend_executor_globals     PHP整个生命周期中最主要的一个结构，是一个全局变量，在main执行前分配(非ZTS下)，直到PHP退出，它记录着当前请求全部的信息，经常见到的一个宏EG操作的就是这个结构。<br />
<br />
                            定义在zend_globals.h中：<br />
<br />
 <br />
<br />
                               <br />
<br />
 <br />
<br />
            <br />
<br />
           zend_execute_data  是执行过程中最核心的一个结构，每次函数的调用、include/require、eval等都会生成一个新的结构，它表示当前的作用域、代码的执行位置以及局部变量的分配等等，等同于机器码执行过程中stack的角色，后面分析具体执行流程的时候会详细分析其作用。 <br />
<br />
          zend_execute_data与zend_op_array的关联关系：<br />
</code></pre></div></div><br />
<br />
<p>2.执行过程</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Zend的executor与linux二进制程序执行的过程是非常类似的。<br />
<br />
    在C程序执行时有两个寄存器ebp、esp分别指向当前作用栈的栈顶、栈底，局部变量全部分配在当前栈，函数调用、返回通过call、ret指令完成，调用时call将当前执行位置压入栈中，返回时ret将之前执行位置出栈，跳回旧的位置继续执行。<br />
<br />
    Zend VM中zend_execute_data就扮演了这两个角色，zend_execute_data.prev_execute_data保存的是调用方的信息，实现了call/ret，zend_execute_data后面会分配额外的内存空间用于局部变量的存储，实现了ebp/esp的作用。<br />
<br />
                a. 为当前作用域分配一块内存，充当运行栈，zend_execute_data结构、所有局部变量、中间变量等等都在此内存上分配<br />
<br />
                b.初始化全局变量符号表，然后将全局执行位置指针EG(current_execute_data)指向步骤a新分配的zend_execute_data，然后将zend_execute_data.opline指向op_array的起始位置<br />
<br />
                c.从EX(opline)开始调用各opcode的C处理handler(即_zend_op.handler)，每执行完一条opcode将EX(opline)++继续执行下一条，直到执行完全部opcode<br />
<br />
                            if语句将根据条件的成立与否决定EX(opline) + offset所加的偏移量，实现跳转<br />
<br />
                            如果是函数调用，则首先从EG(function_table)中根据function_name取出此function对应的编译完成的zend_op_array，然后像步骤a一样新分配一个zend_execute_data结构，将EG(current_execute_data)赋值给新结构的prev_execute_data，再将EG(current_execute_data)指向新的zend_execute_data，最后从新的zend_execute_data.opline开始执行，切换到函数内部，函数执行完以后将EG(current_execute_data)重新指向EX(prev_execute_data)，释放分配的运行栈，销毁局部变量，继续从原来函数调用的位置执行<br />
<br />
                            类方法的调用与函数基本相同<br />
<br />
                d.全部opcode执行完成后将步骤a分配的内存释放，这个过程会将所有的局部变量"销毁"，执行阶段结束<br />
<br />
                                <br />
<br />
 <br />
<br />
                          首先根据zend_execute_data、当前zend_op_array中局部/临时变量数计算需要的内存空间，编译阶段zend_op_array的结果，在编译过程中已经确定当前作用域下有多少个局部变量(func-&gt;op_array.last_var)、临时/中间/无用变量(func-&gt;op_array.T)，从而在执行之初就将他们全部分配完成。 &lt;!-- more --&gt;<br />
</code></pre></div></div><br />
<br />
<p>https://www.cnblogs.com/hellohell/p/9101803.html<br />
http://www.lvesu.com/blog/php/migration55.internals.php</p><br />
<br />
<p>先打印一下php调用过程：</p><br />
<br />
<p>在增加一张异常调用的流程图：</p><br />
<br />
<p>今天稍微对php做下总结，首先介绍最重要的两个数据结构，以及两个结构间的数据传递</p><br />
<br />
<p>struct _zend_op_array {<br />
/* Common elements <em>/<br />
zend_uchar type;<br />
const char *function_name;<br />
zend_class_entry *scope;<br />
zend_uint fn_flags;<br />
union _zend_function *prototype;<br />
zend_uint num_args;<br />
zend_uint required_num_args;<br />
zend_arg_info *arg_info;<br />
/</em> END of common elements */</p><br />
<br />
<p>zend_uint *refcount;</p><br />
<br />
<p>zend_op *opcodes;<br />
zend_uint last;</p><br />
<br />
<p>zend_compiled_variable *vars;<br />
int last_var;</p><br />
<br />
<p>zend_uint T;</p><br />
<br />
<p>zend_literal *literals;<br />
int last_literal;</p><br />
<br />
<p>…<br />
};</p><br />
<br />
<p>不重点介绍的属性暂时省略</p><br />
<br />
<p>struct _zend_execute_data {<br />
struct _zend_op <em>opline;<br />
zend_function_state function_state;<br />
zend_op_array *op_array;<br />
zval *object;<br />
HashTable *symbol_table;<br />
struct _zend_execute_data *prev_execute_data;<br />
zval *old_error_reporting;<br />
zend_bool nested;<br />
zval **original_return_value;<br />
zend_class_entry *current_scope;<br />
zend_class_entry *current_called_scope;<br />
zval *current_this;<br />
struct _zend_op *fast_ret; /</em> used by FAST_CALL/FAST_RET (finally keyword) */<br />
zval *delayed_exception;<br />
call_slot *call_slots;<br />
call_slot *call;<br />
};</p><br />
<br />
<p>zend_execute_data的数据结构大部分是指针，指针指向的内容是这样分配的<br />
5.6很清楚的画出了内存分配图<br />
/*<br />
 * Stack Frame Layout (the whole stack frame is allocated at once)<br />
 * ==================<br />
 *<br />
 *                             +========================================+<br />
 *                             | zend_execute_data                      |&lt;—+<br />
 *                             |     EX(function_state).arguments       |–+ |<br />
 *                             |  …                                   |  | |<br />
 *                             | ARGUMENT [1]                           |  | |<br />
 *                             | …                                    |  | |<br />
 *                             | ARGUMENT [ARGS_NUMBER]                 |  | |<br />
 *                             | ARGS_NUMBER                            |&lt;-+ |<br />
 *                             +========================================+    |<br />
 *                                                                           |<br />
 *                             +========================================+    |<br />
 *                             | TMP_VAR[op_arrat-&gt;T-1]                 |    |<br />
 *                             | …                                    |    |<br />
 *     EX_TMP_VAR_NUM(0) —-&gt; | TMP_VAR[0]                             |    |<br />
 *                             +—————————————-+    |<br />
 * EG(current_execute_data) -&gt; | zend_execute_data                      |    |<br />
 *                             |     EX(prev_execute_data)              |—-+<br />
 *                             +—————————————-+<br />
 *     EX_CV_NUM(0) ———&gt; | CV[0]                                  |–+<br />
 *                             | …                                    |  |<br />
 *                             | CV[op_array-&gt;last_var-1]               |  |<br />
 *                             +—————————————-+  |<br />
 *                             | Optional slot for CV[0] zval*          |&lt;-+<br />
 *                             | …                                    |<br />
 *                             | …for CV [op_array-&gt;last_var-1] zval* |<br />
 *                             +—————————————-+<br />
 *           EX(call_slots) -&gt; | CALL_SLOT[0]                           |<br />
 *                             | …                                    |<br />
 *                             | CALL_SLOT[op_array-&gt;nested_calls-1]    |<br />
 *                             +—————————————-+<br />
 * zend_vm_stack_frame_base -&gt; | ARGUMENTS STACK [0]                    |<br />
 *                             | …                                    |<br />
 * zend_vm_stack_top ——–&gt; | …                                    |<br />
 *                             | …                                    |<br />
 *                             | ARGUMENTS STACK [op_array-&gt;used_stack] |<br />
 *                             +—————————————-+<br />
 */<br />
这里分配有个条件判断在5.2是没有的<br />
(op_array-&gt;fn_flags &amp; ZEND_ACC_GENERATOR) != 0<br />
当如果用到了yield函数时就会触发该逻辑，从而再分配上面的堆栈结构是会给prev_execute_data单独分配空间，并且指向TMP_VAR变量的上面的内存位置。<br />
这个数据结构重要的是三个属性EX_TMP_VAR_NUM(临时变量的空间)，EX_CV_NUM(缓存变量的空间)，zend_vm_stack_top(函数参数的空间)</p><br />
<br />
<p>注释下php7的结构简化了不少</p><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Stack Frame Layout (the whole stack frame is allocated at once)</li><br />
  <li>==================<br />
 *</li><br />
  <li>+========================================+</li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>EG(current_execute_data) -&gt;</td><br />
          <td>zend_execute_data</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li>+—————————————-+</li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>EX_CV_NUM(0) ———&gt;</td><br />
          <td>VAR[0] = ARG[1]</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>…</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>VAR[op_array-&gt;num_args-1] = ARG[N]</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>…</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>VAR[op_array-&gt;last_var-1]</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>VAR[op_array-&gt;last_var] = TMP[0]</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>…</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>VAR[op_array-&gt;last_var+op_array-&gt;T-1]</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>ARG[N+1] (extra_args)</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>…</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li>+—————————————-+<br />
 */</li><br />
</ul><br />
<br />
<p>稍微了解了上面两个数据结构后，下面就讲zend_op_array与zend_execute之间的相互关系<br />
php分为几个阶段包括生成opcode阶段和执行opcode阶段，其实分别对应的就是上面两个数据结构，<br />
并且两个数据结构都是在解析到新的函数时分配新的空间，然后层层嵌套，最外层总是有个大的op_array与execute_data,具体点说就是这两个数据结构存储的是当前函数下的变量环境。<br />
然后就是上面两个不同阶段存储该阶段应该存储的数据，然后可供下一层调用。</p><br />
<br />
<p>第一个例子$var = 1<br />
此处省略掉语法解析(| variable ‘=’ expr{ zend_check_writable_variable(&amp;$1); zend_do_assign(&amp;$$, &amp;$1, &amp;$3 TSRMLS_CC); })，</p><br />
<br />
<p>直接到opconde生成阶段</p><br />
<br />
<p>以下代码是var该字符串代表的变量的信息，为什么这么说因为现在它还不能成为变量，opconde解析的$var的返回值才是变量<br />
fetch_simple_variable -&gt; lookup_cv<br />
核心代码<br />
i = op_array-&gt;last_var;<br />
op_array-&gt;last_var++;</p><br />
<br />
<p>void fetch_simple_variable_ex(znode <em>result, znode *varname, int bp, zend_uchar op TSRMLS_DC) /</em> {{{ */<br />
{<br />
	zend_op opline;<br />
	zend_op *opline_ptr;<br />
	zend_llist *fetch_list_ptr;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (varname-&gt;op_type == IS_CONST) {<br />
	ulong hash;<br />
 <br />
	if (Z_TYPE(varname-&gt;u.constant) != IS_STRING) {<br />
		convert_to_string(&amp;varname-&gt;u.constant);<br />
	}<br />
 <br />
	hash = str_hash(Z_STRVAL(varname-&gt;u.constant), Z_STRLEN(varname-&gt;u.constant));<br />
	if (!zend_is_auto_global_quick(Z_STRVAL(varname-&gt;u.constant), Z_STRLEN(varname-&gt;u.constant), hash TSRMLS_CC) &amp;&amp;<br />
	    !(Z_STRLEN(varname-&gt;u.constant) == (sizeof("this")-1) &amp;&amp;<br />
	      !memcmp(Z_STRVAL(varname-&gt;u.constant), "this", sizeof("this") - 1)) &amp;&amp;<br />
	    (CG(active_op_array)-&gt;last == 0 ||<br />
	     CG(active_op_array)-&gt;opcodes[CG(active_op_array)-&gt;last-1].opcode != ZEND_BEGIN_SILENCE)) {<br />
		result-&gt;op_type = IS_CV;<br />
		result-&gt;u.op.var = lookup_cv(CG(active_op_array), Z_STRVAL(varname-&gt;u.constant), Z_STRLEN(varname-&gt;u.constant), hash TSRMLS_CC);<br />
		Z_STRVAL(varname-&gt;u.constant) = (char*)CG(active_op_array)-&gt;vars[result-&gt;u.op.var].name;<br />
		result-&gt;EA = 0;<br />
		return;<br />
	}<br />
}<br />
 <br />
if (bp) {<br />
	opline_ptr = &amp;opline;<br />
	init_op(opline_ptr TSRMLS_CC);<br />
} else {<br />
	opline_ptr = get_next_op(CG(active_op_array) TSRMLS_CC);<br />
}<br />
 <br />
opline_ptr-&gt;opcode = op;<br />
opline_ptr-&gt;result_type = IS_VAR;<br />
opline_ptr-&gt;result.var = get_temporary_variable(CG(active_op_array));<br />
SET_NODE(opline_ptr-&gt;op1, varname);<br />
GET_NODE(result, opline_ptr-&gt;result);<br />
SET_UNUSED(opline_ptr-&gt;op2);<br />
opline_ptr-&gt;extended_value = ZEND_FETCH_LOCAL;<br />
 <br />
if (varname-&gt;op_type == IS_CONST) {<br />
	CALCULATE_LITERAL_HASH(opline_ptr-&gt;op1.constant);<br />
	if (zend_is_auto_global_quick(Z_STRVAL(varname-&gt;u.constant), Z_STRLEN(varname-&gt;u.constant), Z_HASH_P(&amp;CONSTANT(opline_ptr-&gt;op1.constant)) TSRMLS_CC)) {<br />
		opline_ptr-&gt;extended_value = ZEND_FETCH_GLOBAL;<br />
	}<br />
}<br />
 <br />
if (bp) {<br />
	zend_stack_top(&amp;CG(bp_stack), (void **) &amp;fetch_list_ptr);<br />
	zend_llist_add_element(fetch_list_ptr, opline_ptr);<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>如果是$$var就会走到下面逻辑进行opline赋值，当execute阶段就会执行ZEND_FETCH_W_SPEC_CV_VAR_HANDLER找到$var变量的值再进行变量查询.</p><br />
<br />
<p>op_array-&gt;vars[i].name = zend_new_interned_string(name, name_len + 1, 1 TSRMLS_CC);<br />
op_array-&gt;vars[i].name_len = name_len;<br />
op_array-&gt;vars[i].hash_value = hash_value;<br />
很好理解，为$var这个变量属性分配了空间而不是为变量分配空间，利用了op_array两个属性last_var变量位置和vars数组的对应关系</p><br />
<br />
<p>那$var返回值是什么呢<br />
result-&gt;op_type = IS_CV;<br />
result-&gt;u.op.var = op_array-&gt;last_var;<br />
但是前提大家需要知道语法解析时将字符串或者整形统一解析到znode-&gt;u.constant中，</p><br />
<br />
<p>result的数据结构是zonde，</p><br />
<br />
<p>后续opcode阶段如果是变量赋值的是znode_op的var属性，即偏移量，znode_op.zv属性，即常量信息(该值有pass_two赋值)</p><br />
<br />
<p>typedef union _znode_op {<br />
	zend_uint      constant;<br />
	zend_uint      var;<br />
	zend_uint      num;<br />
	zend_ulong     hash;<br />
	zend_uint      opline_num; /*  Needs to be signed <em>/<br />
	zend_op       *jmp_addr;<br />
	zval          *zv;<br />
	zend_literal  *literal;<br />
	void          *ptr;        /</em> Used for passing pointers from the compile to execution phase, currently used for traits */<br />
} znode_op;</p><br />
<br />
<p>typedef struct _znode { /* used only during compilation <em>/<br />
	int op_type;<br />
	union {<br />
		znode_op op;<br />
		zval constant; /</em> replaced by literal/zv <em>/<br />
		zend_op_array *op_array;<br />
		zend_ast *ast;<br />
	} u;<br />
	zend_uint EA;      /</em> extended attributes */<br />
} znode;</p><br />
<br />
<p>这里补充下，语法扫描获取znode后，进入语法解析阶段，此刻op_array中有个特殊属性literals，该属性是个数组会提前分配好，最终可进行opcode阶段优化见update_op1_const函数，将变量转为常量。</p><br />
<br />
<p>accel_startup:<br />
accelerator_orig_compile_file = zend_compile_file; // 保存原生handle<br />
zend_compile_file = persistent_compile_file; //赋值新的handle<br />
用persistent_compile_file -&gt; compile_and_cache_file -&gt; cache_script_in_shared_memory -&gt; zend_accel_script_optimize<br />
-&gt;zend_accel_optimize-&gt;zend_optimize-&gt;replace_var_by_const-&gt;update_op1_const最后会利用literals数组将变量转换为常量更改opline的op1或者op2</p><br />
<br />
<p>该数组index与value方式进行存储</p><br />
<br />
<p>#define SET_NODE(target, src) do { <br /><br />
		target ## _type = (src)-&gt;op_type; <br /><br />
		if ((src)-&gt;op_type == IS_CONST) { <br /><br />
			target.constant = zend_add_literal(CG(active_op_array), &amp;(src)-&gt;u.constant TSRMLS_CC); <br /><br />
		} else { <br /><br />
			target = (src)-&gt;u.op; <br /><br />
		} <br /><br />
	} while (0)</p><br />
<br />
<p>如果是常量op1-&gt;constant = index,  其种value存在将数据存到literals中，接下来的用途见pass_two;</p><br />
<br />
<p>compile-&gt;pass_two 此时会生成opcode的回调op-&gt;handler，并且会从constant的index中将value赋值给opline中的op1.zv，</p><br />
<br />
<p>这样在真正execute阶段用的就是op1.zv获取常量信息</p><br />
<br />
<p>while (opline &lt; end) {<br />
		if (opline-&gt;op1_type == IS_CONST) {<br />
			opline-&gt;op1.zv = &amp;op_array-&gt;literals[opline-&gt;op1.constant].constant;<br />
		}<br />
		if (opline-&gt;op2_type == IS_CONST) {<br />
			opline-&gt;op2.zv = &amp;op_array-&gt;literals[opline-&gt;op2.constant].constant;<br />
		}<br />
		。。。。。。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	ZEND_VM_SET_OPCODE_HANDLER(opline);<br />
	opline++;<br />
} #define IS_CONST	(1&lt;&lt;0) #define IS_TMP_VAR	(1&lt;&lt;1) #define IS_VAR		(1&lt;&lt;2) #define IS_UNUSED	(1&lt;&lt;3)	/* Unused variable */ #define IS_CV		(1&lt;&lt;4)	/* Compiled variable */ 如： opline-&gt;result_type = IS_TMP_VAR; // opline-&gt;result.var = get_temporary_variable(CG(active_op_array)); opline-&gt;result_type = IS_VAR; opline-&gt;result.var = get_temporary_variable(CG(active_op_array)); 最后生成的函数就是 ZEND_ASSIGN_SPEC_VAR_TMP_HANDLER VAR与TMP均来自临时变量，但是两者用的数据结构不同，具体可见以下两个函数 value = _get_zval_ptr_tmp(opline-&gt;op2.var, execute_data, &amp;free_op2 TSRMLS_CC); variable_ptr_ptr = _get_zval_ptr_ptr_var(opline-&gt;op1.var, execute_data, &amp;free_op1 TSRMLS_CC); 完！<br />
</code></pre></div></div><br />
<br />
<p>//又利用了op_array的一个属性op_array&gt;T++,//此刻仍然是个位置变量，要知道一个op_array可以有n多变量，这个属性就像一个全局数组，所以位置var//足可以代表一个变量。</p><br />
<br />
<p>上面分析的是($)(var)的过程<br />
接下来该赋值了通过语法解析知道调用的是zend_do_assign函数<br />
原型zend_do_assign(znode *result, znode *variable, znode *value TSRMLS_DC)<br />
result是返回值，variable就是上面介绍的变量的返回值(result.op_type)，value就是常量1<br />
opline-&gt;handle = ZEND_ASSIGN_SPEC_CV_CONST_HANDLER</p><br />
<br />
<p>刚才说过opcode的解析阶段完成，接下来就是要执行opcode了<br />
ZEND_ASSIGN_SPEC_CV_CONST_HANDLER -&gt; _get_zval_ptr_ptr_cv_BP_VAR_W -&gt; _get_zval_cv_lookup_BP_VAR_W -&gt; zend_assign_const_to_variable</p><br />
<br />
<p>variable_ptr_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline-&gt;op1.var TSRMLS_CC);<br />
该函数原型：<br />
static zend_always_inline zval <em>*_get_zval_ptr_ptr_cv_BP_VAR_W(const zend_execute_data *execute_data, zend_uint var TSRMLS_DC)<br />
{<br />
zval **</em>ptr = EX_CV_NUM(execute_data, var); //这是execute_data的cv第一部分CV[i]的值其实是个指针</p><br />
<br />
<p>if (UNEXPECTED(*ptr == NULL)) {<br />
return _get_zval_cv_lookup_BP_VAR_W(ptr, var TSRMLS_CC);//这是execute_data的cv第一部分CV[i]的值其实是个指针,这个指针真正分配的空间(该空间可能是execute_data的cv分配，也可能是符号表来分配，两者只能选其一，所以代码里可以看到size_t CVs_size = ZEND_MM_ALIGNED_SIZE(sizeof(zval **) * op_array-&gt;last_var * (EG(active_symbol_table) ? 1 : 2));如果没有符号表就需要分配两倍空间)<br />
}<br />
return *ptr;<br />
}<br />
可以看到就是这个函数做了execute_data与op_array之间的关联</p><br />
<br />
<p>总结第一个例子，opcode解析阶段op_array存放的是变量的一些基本信息，opcode的执行阶段execute_data分配空间存放数据,两者联系就是通过opcode的变量位置等</p><br />
<br />
<p>接下来第二个例子函数调用我们关注的是参数的传递，分两部分(仍然忽视掉语法解析直接到达opcode生成)，1 函数解析 2 函数调用：<br />
&lt;?php<br />
function foo($arg1)<br />
{<br />
    print($arg1);<br />
}</p><br />
<br />
<p>$bar = ‘hello php’;<br />
foo($bar);</p><br />
<br />
<p>函数解析:<br />
zend_do_begin_function_declaration(进行CG(active_op_array)的切换，并且将新的函数注册到CG(function_table)全局变量中) -&gt; zend_do_receive_param -&gt; zend_do_end_function_declaration(退出当前，将之前的op_array重置)</p><br />
<br />
<p>zend_do_receive_param:<br />
(同上对$arg1变量信息进行存储，然后每一个参数就会调用一次receive)<br />
该函数利用到了op_array的两个属性num_args与arg_info</p><br />
<br />
<p>CG(active_op_array)-&gt;num_args++; 作用显而易见<br />
以及cur_arg_info = &amp;CG(active_op_array)-&gt;arg_info[CG(active_op_array)-&gt;num_args-1];<br />
将参数信息进行存储，将来用来进行参数类型的对比检查</p><br />
<br />
<p>函数调用：<br />
zend_do_begin_function_call –&gt;  zend_do_pass_param() –&gt; zend_do_end_function_call</p><br />
<br />
<p>zend_do_begin_function_call:<br />
函数解析时曾经注册到函数表，此函数会判断函数名是否存在<br />
获取函数后，会将函数压入堆栈，方便处理下面容易获取函数本身<br />
zend_stack_push(&amp;CG(function_call_stack), (void *) &amp;function, sizeof(zend_function *));</p><br />
<br />
<p>zend_do_pass_param：<br />
会将$bar如同前面介绍的一样进行变量处理，然后生成<br />
op-&gt;handle=ZEND_SEND_VAR_NO_REF</p><br />
<br />
<p>在解析opcode时调用的是ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER函数：<br />
该函数如同上面介绍一样分配了$bar的存储空间，然后需要注意的是zend_vm_stack_push(varptr TSRMLS_CC);<br />
用到了zend_excute结构中的堆栈，将函数空间的指针压入到了堆栈中。</p><br />
<br />
<p>zend_do_end_function_call：<br />
op-&gt;handle=ZEND_DO_FCALL_BY_NAME</p><br />
<br />
<p>在解析opcode时调用的是ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER函数：<br />
会将参数的数量压入到堆栈中，如同c的函数调用压入参数一样，arg1，arg2，argnum<br />
zend_vm_stack_push_args(num_args TSRMLS_CC);//注意先压入参数才切换op_array<br />
然后zend_execute(op_array);<br />
调用完后回到本函数调用zend_vm_stack_clear_multiple进行堆栈释放</p><br />
<br />
<p>从这一步开始进入了函数中，还记得函数的zend_do_receive_param中的op-&gt;handle=ZEND_RECV_SPEC_HANDLER:<br />
zval **param = zend_vm_stack_get_arg(arg_num TSRMLS_CC);</p><br />
<br />
<p>static zend_always_inline zval** zend_vm_stack_get_arg(int requested_arg TSRMLS_DC)<br />
{<br />
return zend_vm_stack_get_arg_ex(EG(current_execute_data)-&gt;prev_execute_data, requested_arg);<br />
}</p><br />
<br />
<p>为什么要用prev_execute_data因为函数压栈是在当前excute_data之前的excute_data完成，<br />
实际上，在真正执行函数之前，php会将参数个数入栈。</p><br />
<br />
<p>先根据参数个数把堆栈中的参数列表取出来，然后进行参数验证，<br />
顺便var_ptr = _get_zval_ptr_ptr_cv_BP_VAR_W(execute_data, opline-&gt;result.var TSRMLS_CC);<br />
将函数的参数变量$arg1进行赋值</p><br />
<br />
<p>整个过程结束</p><br />
<br />
<p>上面是拆分讲解一个函数的调用过程，当将所有程序解析成op_array数组后，就会调用execute_ex来执行所有的opcode数组。</p><br />
<br />
<p>zend_execute_scripts -&gt; zend_execute -&gt; zend_execute_ex -&gt; execute_ex -&gt; i_create_execute_data_from_op_array</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (0) { zend_vm_enter:<br />
	execute_data = i_create_execute_data_from_op_array(EG(active_op_array), 1 TSRMLS_CC);<br />
}<br />
 <br />
LOAD_REGS();<br />
LOAD_OPLINE();<br />
 <br />
while (1) {<br />
	int ret; #ifdef ZEND_WIN32<br />
	if (EG(timed_out)) {<br />
		zend_timeout(0);<br />
	} #endif<br />
 <br />
	if ((ret = OPLINE-&gt;handler(execute_data TSRMLS_CC)) &gt; 0) {<br />
		switch (ret) {<br />
			case 1:<br />
				EG(in_execution) = original_in_execution;<br />
				return;<br />
			case 2:<br />
				goto zend_vm_enter;<br />
				break;<br />
			case 3:<br />
				execute_data = EG(current_execute_data);<br />
				break;<br />
			default:<br />
				break;<br />
		}<br />
	}<br />
 <br />
}<br />
zend_error_noreturn(E_ERROR, "Arrived at end of main loop which shouldn't happen"); } 以上是个死循环，解析op_array数组，需要注意的是返回值 #define ZEND_VM_CONTINUE()         return 0 #define ZEND_VM_RETURN()           return 1   返回return是函数终止， #define ZEND_VM_ENTER()            return 2  函数调用 #define ZEND_VM_LEAVE()            return 3  函数退出 ZEND_VM_RETURN函数返回returen终止，5.2版本很少有返回1，但是5.3增加了yield调用后，yield调用的opcode基本上都会返回1，从而 函数终止，有个疑问，return了后下面如何执行？ 这里面有个需要注意的点就是，当我们调用函数的时候大家知道opcode解析的函数是 zend_do_fcall_common_helper_SPEC  该函数分为两部分， typedef union _zend_function { zend_uchar type; /* ...﹚... #define ZEND_USER_FUNCTION 2 MUST be the first element of this struct! */ struct { zend_uchar type; /* never used */ char *function_name; //ㄧ.. zend_class_entry *scope; //ㄧ.┮..办 zend_uint fn_flags; // ..猭....单ZEND_ACC_STATIC单 union _zend_function *prototype; //ㄧ. zend_uint num_args; //.... zend_uint required_num_args; //惠璶.... zend_arg_info *arg_info; //..獺. zend_bool pass_rest_by_reference; unsigned char return_reference; // } common; zend_op_array op_array; //ㄧ.い巨 zend_internal_function internal_function; } zend_function;<br />
</code></pre></div></div><br />
<br />
<p>1 内部C函数(ZEND_INTERNAL_FUNCTION):内部函数在zend_register_functions时候就注册到了函数表，其中internal_function.handler指向C函数(函数指针)<br />
通过opcode解析函数名到函数表中查找即可获取到函数指针，进行调用<br />
2 php函数(ZEND_USER_FUNCTION):会继续调用zend_execute，所以刚才说的ZEND_VM_RETURN终止的只是具体某个函数而已，大家如果在一个函数<br />
中写yield，函数就不会继续执行了，就是这个道理。</p><br />
<br />
<p>顺带着介绍下词法解析过程</p><br />
<br />
<p>Zend/zend_language_scanner.l  词法解析规则文件<br />
Zend/zend_language_parser.y   语法分析规则文件</p><br />
<br />
<p>bison -o zend_language_parser.c zend_language_parser.y<br />
在Zend目录下就会生成语法解析器zend_language_parser.c。<br />
yyarse（）是bison生成的分析器的主函数。 调用yyarse()，如果一切顺利，那么上例中的g_root将指向一个完成的语法树。<br />
#define yylex zendlex<br />
#define YYSTYPE znode<br />
yyparse -&gt; zendlex -&gt; lex_scan<br />
lex_scan会解析YYSTYPE字段，并且将znode.u.constant进行词法解析赋值数据</p><br />
<br />
<p>语法扫描(lex_scan)前都会进行该函数调用进行准备，可以参考函数token_get_all的实现</p><br />
<br />
<p>static void yy_scan_buffer(char <em>str, unsigned int len TSRMLS_DC)<br />
{<br />
	YYCURSOR = (YYCTYPE</em>)str;<br />
	SCNG(yy_start) = YYCURSOR;<br />
	YYLIMIT  = YYCURSOR + len;<br />
}</p><br />
<br />
<p>顺便说一下php7：</p><br />
<br />
<p>compile_file -&gt; zendparse(yyparse) -&gt; zend_compile_top_stmt -&gt; zend_compile_stmt 生成opcode，因为php7中间用了抽象语法树，<br />
需要根据抽象语法树的节点进行分析后获得最的opcode<br />
在这里补充下一个知识点:<br />
ZEND_ASSIGN_ADD_SPEC_VAR_CONST_HANDLER <br />
	if (RETURN_VALUE_USED(opline)) {<br />
		PZVAL_LOCK(<em>var_ptr);<br />
		EX_T(opline-&gt;result.var).var.ptr = *var_ptr;<br />
	}<br />
这里放的是临时变量的var属性ptr，为什么是指针，而不是下面的tmp_var,是因为ptr指向的zval是不能立马释放的，是需要assign<br />
赋值给其他变量用，也就是多个</em>zal 共同指向的结构，这个时候采用的就是存放到临时变量的var中的ptr属性。<br />
再看个例子<br />
ZEND_ADD_SPEC_CV_TMP_HANDLER<br />
static int ZEND_FASTCALL  ZEND_ADD_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<br />
{<br />
	USE_OPLINE<br />
	zend_free_op free_op2;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SAVE_OPLINE();<br />
fast_add_function(&amp;EX_T(opline-&gt;result.var).tmp_var,<br />
	_get_zval_ptr_cv_BP_VAR_R(execute_data, opline-&gt;op1.var TSRMLS_CC),<br />
	_get_zval_ptr_tmp(opline-&gt;op2.var, execute_data, &amp;free_op2 TSRMLS_CC) TSRMLS_CC);<br />
 <br />
zval_dtor(free_op2.var);<br />
CHECK_EXCEPTION();<br />
ZEND_VM_NEXT_OPCODE(); } 很明显放到了赋值给了临时变量，为什么是临时变量，因为该变量不引用其他指针数据，所以释放比较简单<br />
</code></pre></div></div><br />
<br />
<p>a++的opcode<br />
zend_do_post_incdec 的opcode opline-&gt;result_type = IS_TMP_VAR;很明显是个tmp变量</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>opline = get_next_op(CG(active_op_array) TSRMLS_CC);<br />
opline-&gt;opcode = op;<br />
SET_NODE(opline-&gt;op1, op1);<br />
SET_UNUSED(opline-&gt;op2);<br />
opline-&gt;result_type = IS_TMP_VAR;<br />
opline-&gt;result.var = get_temporary_variable(CG(active_op_array));<br />
GET_NODE(result, opline-&gt;result);<br />
</code></pre></div></div><br />
<br />
<p>static int ZEND_FASTCALL  ZEND_POST_INC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)<br />
{<br />
	USE_OPLINE<br />
	zend_free_op free_op1;<br />
	zval **var_ptr, *retval;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SAVE_OPLINE();<br />
var_ptr = _get_zval_ptr_ptr_var(opline-&gt;op1.var, execute_data, &amp;free_op1 TSRMLS_CC);<br />
 <br />
if (IS_VAR == IS_VAR &amp;&amp; UNEXPECTED(var_ptr == NULL)) {<br />
	zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");<br />
}<br />
if (IS_VAR == IS_VAR &amp;&amp; UNEXPECTED(*var_ptr == &amp;EG(error_zval))) {<br />
	ZVAL_NULL(&amp;EX_T(opline-&gt;result.var).tmp_var);<br />
	if (free_op1.var) {zval_ptr_dtor_nogc(&amp;free_op1.var);};<br />
	CHECK_EXCEPTION();<br />
	ZEND_VM_NEXT_OPCODE();<br />
}<br />
 <br />
retval = &amp;EX_T(opline-&gt;result.var).tmp_var;<br />
ZVAL_COPY_VALUE(retval, *var_ptr);<br />
zendi_zval_copy_ctor(*retval); 当返回的是tmp_var变量时，说明该变量只是个临时值不会做额外的操作，所以也不需要增加gc_recount++等操作，直接堆栈释放即可。 ++a的opcode：opline-&gt;result_type = IS_VAR; IS_VAR类型<br />
<br />
opline = get_next_op(CG(active_op_array) TSRMLS_CC);<br />
opline-&gt;opcode = op;<br />
SET_NODE(opline-&gt;op1, op1);<br />
SET_UNUSED(opline-&gt;op2);<br />
opline-&gt;result_type = IS_VAR;<br />
opline-&gt;result.var = get_temporary_variable(CG(active_op_array));<br />
GET_NODE(result, opline-&gt;result);<br />
</code></pre></div></div><br />
<br />
<p>解析后：<br />
	if (RETURN_VALUE_USED(opline)) {<br />
		PZVAL_LOCK(*var_ptr);<br />
		EX_T(opline-&gt;result.var).var.ptr = *var_ptr;<br />
	}</p><br />
<br />
<p>此时返回的var的临时变量增加了gc_recount++，所以该返回值被别人用的时候，就需要有个释放的过程，<br />
static zend_always_inline zval <strong>_get_zval_ptr_ptr_var(zend_uint var, const zend_execute_data *execute_data, zend_free_op *should_free TSRMLS_DC)<br />
{<br />
	zval</strong> ptr_ptr = EX_T(var).var.ptr_ptr;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (EXPECTED(ptr_ptr != NULL)) {<br />
	PZVAL_UNLOCK(*ptr_ptr, should_free);<br />
} else {<br />
	/* string offset */<br />
	PZVAL_UNLOCK(EX_T(var).str_offset.str, should_free);<br />
}<br />
return ptr_ptr; } 获取该变量值通过该函数，所以就会进行释放gc_recount--. var和tmp类型的区别是什么，大家都是放在tmp分配的堆栈中，区别就是，var.ptr_ptr是个指针，为了节省空间大家目前先共用，比如++a，返回的临时变量和变量a返回值一样，所以就用指针指向同一个zval，比如a++，返回值的临时变量和变量a返回值不一样，所以必须重新申请一个zval，所以就干脆扔到了tmp中，可以随时释放。<br />
</code></pre></div></div><br />
<br />
<p>https://blog.csdn.net/xiaolei1982/article/details/52140544<br />
https://blog.csdn.net/xiaolei1982/article/details/20584291<br />
http://www.phppan.com/2012/02/php-execute-data/</p><br />
<br />
<p>https://type.so/c/php-extension-in-action-get-arguments-after-zend-execute-ex.html</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category php
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>