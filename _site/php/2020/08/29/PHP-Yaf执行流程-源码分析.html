<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">PHP-Yaf执行流程-源码分析</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-08-29T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Aug 29, 2020</time></p>
					</div>
					 <p>在application目录下有个Bootstrap.php文件，这个就是图中的第一个环节，如果存在Bootstrap()就会先执行该文件，该文件包含了一系列的初始化环节，并返回一个Yaf_Application对象，紧接着调用了它的run方法，run里面包含了图中所有环节，run首先是调用路由，路由的主要目的其实就是找到controllers文件，然后执行里面的init和action方法，或者找到所有actions的地址然后加载，在去执行对应的execute方法，如果设置了autoRender在返回的时候会执行render方法，就是view自动渲染，图中有六个双横线标出的环节，就是六个插件方法，用户可以自定义实现这几个方法，然后Yaf框架会在图中相应的步骤处调用对应的HOOK方法。<br />
https://www.jianshu.com/p/130389235abc</p><br />
<br />
<p>Breakpoint 3, 0x0000000101078c44 in yaf_application_new () from /usr/local/lib/php/extensions/no-debug-non-zts-20170718/yaf.so<br />
(gdb) c<br />
Continuing.</p><br />
<br />
<p>Breakpoint 11, 0x0000000101079a14 in yaf_dispatcher_instance () from /usr/local/lib/php/extensions/no-debug-non-zts-20170718/yaf.so<br />
(gdb) b yaf_router_route<br />
Breakpoint 12 at 0x10108add4<br />
(gdb) bt<br />
#0  0x0000000101079a14 in yaf_dispatcher_instance () from /usr/local/lib/php/extensions/no-debug-non-zts-20170718/yaf.so<br />
#1  0x0000000101077d69 in zim_yaf_application___construct () from /usr/local/lib/php/extensions/no-debug-non-zts-20170718/yaf.so<br />
#2  0x000000010044b6d7 in ZEND_DO_FCALL_SPEC_RETVAL_UNUSED_HANDLER (execute_data=0x101678120) at Zend/zend_vm_execute.h:911<br />
#3  0x000000010040c8c8 in execute_ex (ex=<optimized out="">) at Zend/zend_vm_execute.h:59767<br />
#4  0x000000010040ca73 in zend_execute (op_array=0x10109ea50 &lt;yaf_globals+16&gt;, return_value=<optimized out="">) at Zend/zend_vm_execute.h:63804<br />
#5  0x00000001003c4dfb in zend_execute_scripts (type=<optimized out="">, retval=0x0, file_count=<optimized out="">) at Zend/zend.c:1498<br />
#6  0x0000000100359685 in php_execute_script (primary_file=<optimized out="">) at main/main.c:2599<br />
#7  0x00000001004a0ec4 in do_cli (argc=<optimized out="">, argv=<optimized out="">) at sapi/cli/php_cli.c:1011<br />
#8  0x000000010049fdd6 in main (argc=<optimized out="">, argv=<optimized out="">) at sapi/cli/php_cli.c:1403</optimized></optimized></optimized></optimized></optimized></optimized></optimized></optimized></optimized></p><br />
<br />
<p>https://www.iteye.com/blog/kenby-1979833<br />
https://www.laruence.com/manual/<br />
http://www.phpinternalsbook.com/<br />
https://crispgm.com/page/php7-new-hashtable-implementation.html<br />
<!-- more --><br />
yaf源码阅读之 – 框架基本生命周期 (yaf.c)<br />
MINIT<br />
php-fpm启动master时会启动php扩展，在yaf源码中，这里对应的是MINIT及之前的操作，相关源码位于yaf.c ：</p><br />
<br />
<p>读取php.ini中的yaf配置<br />
在PHP_INI_BEGIN()和PHP_INI_END()之间定义相关参数的默认值、作用域、回调函数等</p><br />
<br />
<p>在MINIT中定义YAF常量，如YAF_VERSION等</p><br />
<br />
<p>在MINIT中载入yaf框架各个组件，自此YAF框架就常驻内存，yaf的快的优势也源于此。</p><br />
<br />
<p>PHP_MINIT_FUNCTION(yaf)<br />
{<br />
	REGISTER_INI_ENTRIES();<br />
	if (YAF_G(use_namespace)) {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	REGISTER_STRINGL_CONSTANT("YAF\\VERSION", PHP_YAF_VERSION, 	sizeof(PHP_YAF_VERSION) - 1, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_STRINGL_CONSTANT("YAF\\ENVIRON", YAF_G(environ_name), strlen(YAF_G(environ_name)), CONST_PERSISTENT | CONST_CS);<br />
<br />
	REGISTER_LONG_CONSTANT("YAF\\ERR\\STARTUP_FAILED", 		YAF_ERR_STARTUP_FAILED, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF\\ERR\\ROUTE_FAILED", 		YAF_ERR_ROUTE_FAILED, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF\\ERR\\DISPATCH_FAILED", 	YAF_ERR_DISPATCH_FAILED, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF\\ERR\\AUTOLOAD_FAILED", 	YAF_ERR_AUTOLOAD_FAILED, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF\\ERR\\NOTFOUND\\MODULE", 	YAF_ERR_NOTFOUND_MODULE, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF\\ERR\\NOTFOUND\\CONTROLLER",YAF_ERR_NOTFOUND_CONTROLLER, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF\\ERR\\NOTFOUND\\ACTION", 	YAF_ERR_NOTFOUND_ACTION, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF\\ERR\\NOTFOUND\\VIEW", 		YAF_ERR_NOTFOUND_VIEW, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF\\ERR\\CALL_FAILED",			YAF_ERR_CALL_FAILED, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF\\ERR\\TYPE_ERROR",			YAF_ERR_TYPE_ERROR, CONST_PERSISTENT | CONST_CS);<br />
<br />
} else {<br />
	REGISTER_STRINGL_CONSTANT("YAF_VERSION", PHP_YAF_VERSION, 	sizeof(PHP_YAF_VERSION) - 1, 	CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_STRINGL_CONSTANT("YAF_ENVIRON", YAF_G(environ_name),strlen(YAF_G(environ_name)), 	CONST_PERSISTENT | CONST_CS);<br />
<br />
	REGISTER_LONG_CONSTANT("YAF_ERR_STARTUP_FAILED", 		YAF_ERR_STARTUP_FAILED, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF_ERR_ROUTE_FAILED", 			YAF_ERR_ROUTE_FAILED, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF_ERR_DISPATCH_FAILED", 		YAF_ERR_DISPATCH_FAILED, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF_ERR_AUTOLOAD_FAILED", 		YAF_ERR_AUTOLOAD_FAILED, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF_ERR_NOTFOUND_MODULE", 		YAF_ERR_NOTFOUND_MODULE, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF_ERR_NOTFOUND_CONTROLLER", 	YAF_ERR_NOTFOUND_CONTROLLER, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF_ERR_NOTFOUND_ACTION", 		YAF_ERR_NOTFOUND_ACTION, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF_ERR_NOTFOUND_VIEW", 		YAF_ERR_NOTFOUND_VIEW, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF_ERR_CALL_FAILED",			YAF_ERR_CALL_FAILED, CONST_PERSISTENT | CONST_CS);<br />
	REGISTER_LONG_CONSTANT("YAF_ERR_TYPE_ERROR",			YAF_ERR_TYPE_ERROR, CONST_PERSISTENT | CONST_CS);<br />
}<br />
<br />
/* startup components */<br />
YAF_STARTUP(application);<br />
YAF_STARTUP(bootstrap);<br />
YAF_STARTUP(dispatcher);<br />
YAF_STARTUP(loader);<br />
YAF_STARTUP(request);<br />
YAF_STARTUP(response);<br />
YAF_STARTUP(controller);<br />
YAF_STARTUP(action);<br />
YAF_STARTUP(config);<br />
YAF_STARTUP(view);<br />
YAF_STARTUP(router);<br />
YAF_STARTUP(plugin);<br />
YAF_STARTUP(registry);<br />
YAF_STARTUP(session);<br />
YAF_STARTUP(exception);<br />
<br />
return SUCCESS; }    RINIT 请求初始化只是对yaf用户应用级别的配置做了初始化<br />
</code></pre></div></div><br />
<br />
<p>PHP_RINIT_FUNCTION(yaf)<br />
{<br />
	YAF_G(throw_exception) = 1;<br />
	YAF_G(ext) = zend_string_init(YAF_DEFAULT_EXT, sizeof(YAF_DEFAULT_EXT) - 1, 0);<br />
	YAF_G(view_ext) = zend_string_init(YAF_DEFAULT_VIEW_EXT, sizeof(YAF_DEFAULT_VIEW_EXT) - 1, 0);<br />
	YAF_G(default_module) = zend_string_init(<br />
			YAF_ROUTER_DEFAULT_MODULE, sizeof(YAF_ROUTER_DEFAULT_MODULE) - 1, 0);<br />
	YAF_G(default_controller) = zend_string_init(<br />
			YAF_ROUTER_DEFAULT_CONTROLLER, sizeof(YAF_ROUTER_DEFAULT_CONTROLLER) - 1, 0);<br />
	YAF_G(default_action) = zend_string_init(<br />
			YAF_ROUTER_DEFAULT_ACTION, sizeof(YAF_ROUTER_DEFAULT_ACTION) - 1, 0);<br />
	return SUCCESS;<br />
}<br />
RSHUTDOWN<br />
销毁用户应用级别的配置</p><br />
<br />
<p>PHP_RSHUTDOWN_FUNCTION(yaf)<br />
{<br />
	YAF_G(running) = 0;<br />
	YAF_G(in_exception)	= 0;<br />
	YAF_G(catch_exception) = 0;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (YAF_G(directory)) {<br />
	zend_string_release(YAF_G(directory));<br />
	YAF_G(directory) = NULL;<br />
}<br />
if (YAF_G(local_library)) {<br />
	zend_string_release(YAF_G(local_library));<br />
	YAF_G(local_library) = NULL;<br />
}<br />
if (YAF_G(local_namespaces)) {<br />
	zend_string_release(YAF_G(local_namespaces));<br />
	YAF_G(local_namespaces) = NULL;<br />
}<br />
if (YAF_G(bootstrap)) {<br />
	zend_string_release(YAF_G(bootstrap));<br />
	YAF_G(bootstrap) = NULL;<br />
}<br />
if (Z_TYPE(YAF_G(modules)) == IS_ARRAY) {<br />
	zval_ptr_dtor(&amp;YAF_G(modules));<br />
	ZVAL_UNDEF(&amp;YAF_G(modules));<br />
}<br />
if (YAF_G(base_uri)) {<br />
	zend_string_release(YAF_G(base_uri));<br />
	YAF_G(base_uri) = NULL;<br />
}<br />
if (YAF_G(view_directory)) {<br />
	zend_string_release(YAF_G(view_directory));<br />
	YAF_G(view_directory) = NULL;<br />
}<br />
if (YAF_G(view_ext)) {<br />
	zend_string_release(YAF_G(view_ext));<br />
}<br />
if (YAF_G(default_module)) {<br />
	zend_string_release(YAF_G(default_module));<br />
}<br />
if (YAF_G(default_controller)) {<br />
	zend_string_release(YAF_G(default_controller));<br />
}<br />
if (YAF_G(default_action)) {<br />
	zend_string_release(YAF_G(default_action));<br />
}<br />
if (YAF_G(ext)) {<br />
	zend_string_release(YAF_G(ext));<br />
}<br />
YAF_G(default_route) = NULL;<br />
<br />
return SUCCESS; } MSHUTDOWN 销毁yaf配置<br />
</code></pre></div></div><br />
<br />
<p>PHP_MSHUTDOWN_FUNCTION(yaf)<br />
{<br />
	UNREGISTER_INI_ENTRIES();</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (YAF_G(configs)) {<br />
	zend_hash_destroy(YAF_G(configs));<br />
	pefree(YAF_G(configs), 1);<br />
}<br />
<br />
return SUCCESS; }<br />
</code></pre></div></div><br />
<br />
<p>yaf_dispatcher_get_controller() 获取 controller 类</p><br />
<br />
<p>zend_class_entry * yaf_dispatcher_get_controller(char* app_dir, char *module, char *controller, int len, int def_module TSRMLS_DC) {<br />
    char     *directory     = NULL;<br />
    int  directory_len  = 0;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//这块之前说过，如果def_module等于1走默认的路径<br />
//如果等于0则走modules下的路径<br />
if (def_module) {<br />
    // directory = app_dir/controllers<br />
    directory_len = spprintf(&amp;directory, 0, "%s%c%s", app_dir, DEFAULT_SLASH, YAF_CONTROLLER_DIRECTORY_NAME);<br />
} else {<br />
    // directory = app_dir/modules/mymodule/controllers<br />
    directory_len = spprintf(&amp;directory, 0, "%s%c%s%c%s%c%s", app_dir, DEFAULT_SLASH,<br />
            YAF_MODULE_DIRECTORY_NAME, DEFAULT_SLASH, module, DEFAULT_SLASH, YAF_CONTROLLER_DIRECTORY_NAME);<br />
}<br />
 <br />
if (directory_len) {<br />
    char *class         = NULL;<br />
    char *class_lowercase   = NULL;<br />
    int class_len       = 0;<br />
    zend_class_entry **ce   = NULL;<br />
    // 这里根据配置区分前缀模式还是后缀模式 <br />
    // Controller_Index 或者 Index_Controller <br />
    // ControllerIndex 或者 IndexController <br />
    if (YAF_G(name_suffix)) {<br />
        class_len = spprintf(&amp;class, 0, "%s%s%s", controller, YAF_G(name_separator), "Controller");<br />
    } else {<br />
        class_len = spprintf(&amp;class, 0, "%s%s%s", "Controller", YAF_G(name_separator), controller);<br />
    }<br />
    //转小写<br />
    class_lowercase = zend_str_tolower_dup(class, class_len);<br />
   <br />
    //是否存在这个Controller类<br />
    if (zend_hash_find(EG(class_table), class_lowercase, class_len + 1, (void **)&amp;ce) != SUCCESS) {<br />
        //加载这个Controller类<br />
        if (!yaf_internal_autoload(controller, len, &amp;directory TSRMLS_CC)) {<br />
            yaf_trigger_error(YAF_ERR_NOTFOUND_CONTROLLER TSRMLS_CC, "Failed opening controller script %s: %s", directory, strerror(errno));<br />
            efree(class);<br />
            efree(class_lowercase);<br />
            efree(directory);<br />
            return NULL;<br />
        //获取这个Controller类指针<br />
        } else if (zend_hash_find(EG(class_table), class_lowercase, class_len + 1, (void **) &amp;ce) != SUCCESS)  {<br />
            yaf_trigger_error(YAF_ERR_AUTOLOAD_FAILED TSRMLS_CC, "Could not find class %s in controller script %s", class, directory);<br />
            efree(class);<br />
            efree(class_lowercase);<br />
            efree(directory);<br />
            return 0;<br />
        //判断是否继承 Yaf_Controller_Abstract<br />
        } else if (!instanceof_function(*ce, yaf_controller_ce TSRMLS_CC)) {<br />
            yaf_trigger_error(YAF_ERR_TYPE_ERROR TSRMLS_CC, "Controller must be an instance of %s", yaf_controller_ce-&gt;name);<br />
            efree(class);<br />
            efree(class_lowercase);<br />
            efree(directory);<br />
            return 0;<br />
        }<br />
    }<br />
<br />
    efree(class);<br />
    efree(class_lowercase);<br />
    efree(directory);<br />
<br />
    return *ce;<br />
}<br />
<br />
return NULL; } yaf_dispatcher_handle() 调用了yaf_dispatcher_get_controller()<br />
</code></pre></div></div><br />
<br />
<p>if (strncasecmp(Z_STRVAL_P(dmodule), Z_STRVAL_P(module), Z_STRLEN_P(module)) == 0) {<br />
            is_def_module = 1;<br />
        }</p><br />
<br />
<p>//找到对应的controller类<br />
ce = yaf_dispatcher_get_controller(app_dir, Z_STRVAL_P(module), Z_STRVAL_P(controller), Z_STRLEN_P(controller), is_def_module TSRMLS_CC);</p><br />
<br />
<p>https://note.youdao.com/ynoteshare1/index.html?id=506a5d51332ac354fdbaa5fb902b2e1f&amp;type=note</p><br />
<br />
<p>https://blog.wislay.com/articles/543<br />
本篇主要简单记录了：</p><br />
<br />
<p>yaf.c<br />
yaf_application.c<br />
yaf_bootstrap.c<br />
yaf_controller.c<br />
yaf_dispatcher.c<br />
yaf_exception.c<br />
yaf_loader.c<br />
yaf_plugin.c<br />
yaf_registry.c<br />
源码阅读过程中的一些问题和理解。</p><br />
<br />
<p>config.m4<br />
扩展源码阅读，从 config.m4 文件开始。</p><br />
<br />
<p>对于这个文件，最值得注意的应该是 PHP_NEW_EXTENSION 这一个函数声明了。声明了这一个扩展的名称是 yaf，需要编译 yaf.c 等多个文件，以及是否 build 到 PHP 的二进制文件中。</p><br />
<br />
<p>yaf.c<br />
yaf.c 这一个文件中，主要做了如下的工作：</p><br />
<br />
<p>定义各个生命周期的回调函数（MINIT/RINIT/RSHUTDOWN/MSHUTDOWN）<br />
定义 ini 中可配置的项目<br />
声明依赖<br />
加载所需模块<br />
定义各个生命周期的回调方法<br />
PHP 扩展的生命周期可以简单的概括为如下几个步骤：</p><br />
<br />
<p>MINIT<br />
RINIT<br />
RSHUTDOWN<br />
MSHUTDOWN<br />
其中 RINIT/RSHUTDOWN 在每次请求 PHP 代码执行过程中都会执行一次。</p><br />
<br />
<p>资源和全局的一些初始化工作可以在 MINIT 回调函数中进行。如 yaf 的 MINIT 方法中，就完成了声明 ini 可配置项目（REGISTER_INI_ENTRIES()），常量定义，以及模记载。</p><br />
<br />
<p>与 MINIT 相对的，MSHUTDOWN 阶段的回调函数则做了资源释放额操作，如释放了读取配置所需要使用的内存空间。</p><br />
<br />
<p>定义 ini 中可配置的项目<br />
定义 ini 文件中的可配置项目代码段自 PHP_INI_BEGIN() 开始，到 PHP_INI_END() 结束，通过名如 STD_PHP_INI_* 的宏进行设定。</p><br />
<br />
<p>PHP_INI_BEGIN()<br />
    STD_PHP_INI_ENTRY(“yaf.library”,            “”,  PHP_INI_ALL, OnUpdateString, global_library, zend_yaf_globals, yaf_globals)<br />
    …<br />
    STD_PHP_INI_BOOLEAN(“yaf.use_namespace”,    “0”, PHP_INI_SYSTEM, OnUpdateBool, use_namespace, zend_yaf_globals, yaf_globals)<br />
#endif<br />
PHP_INI_END();</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
PHP_INI_BEGIN()<br />
    STD_PHP_INI_ENTRY(“yaf.library”,            “”,  PHP_INI_ALL, OnUpdateString, global_library, zend_yaf_globals, yaf_globals)<br />
    …<br />
    STD_PHP_INI_BOOLEAN(“yaf.use_namespace”,    “0”, PHP_INI_SYSTEM, OnUpdateBool, use_namespace, zend_yaf_globals, yaf_globals)<br />
#endif<br />
PHP_INI_END();</p><br />
<br />
<p>这里需要注意的是，宏的第三个参数有 PHP_INI_ALL 和 PHP_INI_SYSTEM 两种值，这两个值决定了是否可以在运行时修改这类参数。设定为 PHP_INI_SYSTEM 的配置项是不允许在运行时改变的。</p><br />
<br />
<p>所以，想要启用 yaf 的命名空间模式，就必须在 ini 中进行开启。</p><br />
<br />
<p>yaf_application.c<br />
这一文件主要定义了 Yaf_Application 这一个 class。</p><br />
<br />
<p>定义的内容包括：</p><br />
<br />
<p>类名与命名空间名称<br />
类属性与访问权限控制（Yaf_Application 这一个 class 被定义为 final class，即不能再被继承）<br />
类的方法与访问权限控制<br />
除了上述内容，还实现了配置项解析和初始化功能。下面会对一些重要的方法进行简单的描述。</p><br />
<br />
<p>__construct()<br />
构造方法中主要完成了如下的一些工作：</p><br />
<br />
<p>解析构造方法中的参数<br />
初始化 request/dispatcher/loader 等对象<br />
读取解析配置文件<br />
从手册上可以得知构造方法的原型为：</p><br />
<br />
<p>public void Yaf_Application::__construct(mixed  $config,<br />
                                         string $section = ap.environ);</p><br />
<br />
<p>1<br />
2<br />
3<br />
public void Yaf_Application::__construct(mixed  $config,<br />
                                         string $section = ap.environ);</p><br />
<br />
<p>根据传递的字符串作为本应用 ini 配置文件的文件名，进行解析。</p><br />
<br />
<p>第二个参数 section 存在的情况下，会只读取 section: 开头的配置项目。</p><br />
<br />
<p>如，设定 section 为 product 之后，读取到的数据库端口配置项应为 3306。</p><br />
<br />
<p>[common]<br />
application.directory = APPLICATION_PATH  “/application”<br />
application.dispatcher.catchException = TRUE</p><br />
<br />
<p>[product:common]<br />
database.driver    = “mysql”<br />
database.host      = “127.0.0.1”<br />
database.port      = “3306”<br />
database.database  = “learn”<br />
database.username  = “learn”<br />
database.password  = “123456”<br />
database.charset   = “utf8”<br />
database.collation = “utf8_general_ci”<br />
database.prefix    = “”</p><br />
<br />
<p>[dev:common]<br />
database.driver    = “mysql”<br />
database.host      = “127.0.0.1”<br />
database.port      = “13306”<br />
database.database  = “learn”<br />
database.username  = “learn”<br />
database.password  = “123456”<br />
database.charset   = “utf8”<br />
database.collation = “utf8_general_ci”<br />
database.prefix    = “”</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
25<br />
26<br />
[common]<br />
application.directory = APPLICATION_PATH  “/application”<br />
application.dispatcher.catchException = TRUE</p><br />
<br />
<p>[product:common]<br />
database.driver    = “mysql”<br />
database.host      = “127.0.0.1”<br />
database.port      = “3306”<br />
database.database  = “learn”<br />
database.username  = “learn”<br />
database.password  = “123456”<br />
database.charset   = “utf8”<br />
database.collation = “utf8_general_ci”<br />
database.prefix    = “”</p><br />
<br />
<p>[dev:common]<br />
database.driver    = “mysql”<br />
database.host      = “127.0.0.1”<br />
database.port      = “13306”<br />
database.database  = “learn”<br />
database.username  = “learn”<br />
database.password  = “123456”<br />
database.charset   = “utf8”<br />
database.collation = “utf8_general_ci”<br />
database.prefix    = “”</p><br />
<br />
<p>根据方法原型中传入的配置文件路径，会解析出如 bootstrap 类所在文件路径之类的配置，并赋值到全局变量中，供其他功能使用。</p><br />
<br />
<p>在读取配置文件的过程中，还会通过 yaf_loader_register() 函数注册默认的自动加载方法: Yaf_Loader::autoload()。</p><br />
<br />
<p>run()<br />
run() 方法完成的工作比较简单，判断当前 app 对象是否已经在运行中，如果在运行中则产生错误，否则执行 dispatch 过程，获得 response 对象。</p><br />
<br />
<p>bootstrap()<br />
bootstrap() 方法是一个比较重要的方法，这个方法可以对 yaf 进行一些全局的初始化操作。</p><br />
<br />
<p>首先会在类名表（EG(class_table)）中查找名为 YAF_DEFAULT_BOOTSTRAP_LOWER 即名为 bootstrap 的类。</p><br />
<br />
<p>如果不存在这样的一个 class，则通过读取名为 bootstrap 的全局变量（YAF_G(bootstrap)），来确定具体的需要执行的类所在的文件。如果全局变量也没有配置，则会在当前目录中查找是否存在 Bootstrap.php 的文件。bootstrap 这一个全局变量，对应的是传入的 ini 文件中的 application.bootstrap 配置项的值。</p><br />
<br />
<p>在确定需要执行的 bootstrap 的文件路径之后，通过 yaf_loader_import() 函数加载文件。并会再次尝试在类名表（EG(class_table)）中查找名为 YAF_DEFAULT_BOOTSTRAP_LOWER 的类，最后判断这个类是否继承了 Yaf_Bootstrap_Abstract，任何一项不满足，都会触发错误。</p><br />
<br />
<p>摘录一下上述这段源码：</p><br />
<br />
<p>if (!yaf_loader_import(bootstrap_path, len + 1, 0 TSRMLS_CC)) {<br />
    php_error_docref(NULL TSRMLS_CC, E_WARNING, “Couldn’t find bootstrap file %s”, bootstrap_path);<br />
    retval = 0;<br />
} else if (zend_hash_find(EG(class_table), YAF_DEFAULT_BOOTSTRAP_LOWER, YAF_DEFAULT_BOOTSTRAP_LEN, (void <em>*) &amp;ce) != SUCCESS)  {<br />
    php_error_docref(NULL TSRMLS_CC, E_WARNING, “Couldn’t find class %s in %s”, YAF_DEFAULT_BOOTSTRAP, bootstrap_path);<br />
    retval = 0;<br />
} else if (!instanceof_function(</em>ce, yaf_bootstrap_ce TSRMLS_CC)) {<br />
    php_error_docref(NULL TSRMLS_CC, E_WARNING, “Expect a %s instance, %s give”, yaf_bootstrap_ce-&gt;name, (*ce)-&gt;name);<br />
    retval = 0;<br />
}</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
if (!yaf_loader_import(bootstrap_path, len + 1, 0 TSRMLS_CC)) {<br />
    php_error_docref(NULL TSRMLS_CC, E_WARNING, “Couldn’t find bootstrap file %s”, bootstrap_path);<br />
    retval = 0;<br />
} else if (zend_hash_find(EG(class_table), YAF_DEFAULT_BOOTSTRAP_LOWER, YAF_DEFAULT_BOOTSTRAP_LEN, (void <em>*) &amp;ce) != SUCCESS)  {<br />
    php_error_docref(NULL TSRMLS_CC, E_WARNING, “Couldn’t find class %s in %s”, YAF_DEFAULT_BOOTSTRAP, bootstrap_path);<br />
    retval = 0;<br />
} else if (!instanceof_function(</em>ce, yaf_bootstrap_ce TSRMLS_CC)) {<br />
    php_error_docref(NULL TSRMLS_CC, E_WARNING, “Expect a %s instance, %s give”, yaf_bootstrap_ce-&gt;name, (*ce)-&gt;name);<br />
    retval = 0;<br />
}</p><br />
<br />
<p>yaf_loader_import() 成功加载之后返回值是1，zend_hash_find() 执行成功之后返回值是 SUCCESS 即0，instanceof_function() 判断为真时返回值是1，所以，上述一段代码，在一切正常的逻辑下，三个 if/else 判断中的语句都会执行。</p><br />
<br />
<p>所以，上述步骤说明了两点：</p><br />
<br />
<p>bootstrap 文件的绝对路径是可以配置的<br />
bootstrap 类名必须是 Bootstrap（因为只会在类名表中查找这一个值）<br />
在类加载完成后，会逐个调用 _init 开头的方法，完成初始化操作，所有方法会接收 dispatcher 作为参数。</p><br />
<br />
<p>yaf_bootstrap.c<br />
这一文件主要是声明了 Yaf_Bootstrap_Abstract 这一个抽象类。</p><br />
<br />
<p>yaf_controller.c<br />
这一文件声明了 Yaf_Controller_Abstract 这一个抽象类。同时也定义了视图层的 render 与 display 操作，二者区别在于 render 返回渲染好的视图字符串（准确来说是一个 zval）。</p><br />
<br />
<p>yaf_dispatcher.c<br />
这是 yaf 执行过程中的关键部分之一。</p><br />
<br />
<p>一个请求到来，Yaf_Application 对象在执行 run() 方法时，最后一步就是通过已经设置好的 dispatcher 开始对请求进行处理，即调用 yaf_dispatcher_dispatch() 函数。</p><br />
<br />
<p>yaf_dispatcher_dispatch()<br />
路由<br />
yaf_dispatcher_dispatch() 函数在处理过程中，会先判断当前请求是否已经被路由过，如果没有被路由过，则通过 yaf_dispatcher_route() 函数对当前请求执行路由操作。</p><br />
<br />
<p>在执行路由之前，yaf 的钩子机制会通过 YAF_PLUGIN_HANDLE 这个宏逐个调用已注册插件中 routerstartup 回调方法，调用顺序为注册插件的顺序。</p><br />
<br />
<p>Yaf_Dispatcher 中包含一个成员变量 _router (即 YAF_DISPATCHER_PROPERTY_NAME_ROUTER)，此处记录了当前 app 已注册的各个路由规则。在初始化阶段（调用 yaf_router_instance() 函数），会注册默认路由，如果不设定，则使用的是 static 路由。</p><br />
<br />
<p>同样的，一个 app 的 Dispatcher 对象的默认 Controller/Module/Action 等等参数，以及需要执行的插件，也都在这一个阶段完成了默认值的设定。</p><br />
<br />
<p>如果有多个路由规则，这里要注意，后加入的路由规则会先被执行，此处在手册中也可以获知，从代码上来看，原因是 yaf_router_route() 函数在遍历 HashTable 时从 HashTable 的末端开始进行遍历：</p><br />
<br />
<p>…<br />
ht = Z_ARRVAL_P(routers);<br />
for(zend_hash_internal_pointer_end(ht);<br />
        zend_hash_has_more_elements(ht) == SUCCESS;<br />
        zend_hash_move_backwards(ht)) {<br />
…</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
…<br />
ht = Z_ARRVAL_P(routers);<br />
for(zend_hash_internal_pointer_end(ht);<br />
        zend_hash_has_more_elements(ht) == SUCCESS;<br />
        zend_hash_move_backwards(ht)) {<br />
…</p><br />
<br />
<p>一旦路由规则命中，则结束路由过程。</p><br />
<br />
<p>在执行路由之后，yaf 的钩子机制会通过 YAF_PLUGIN_HANDLE 这个宏逐个调用已注册插件中 routershutdown 回调方法，调用顺序为注册插件的顺序。</p><br />
<br />
<p>分发<br />
分发开始之前，yaf 的钩子机制会通过 YAF_PLUGIN_HANDLE 这个宏逐个调用已注册插件中 dispatchloopstartup 回调方法，调用顺序为注册插件的顺序。</p><br />
<br />
<p>之后会执行视图的初始化操作。</p><br />
<br />
<p>请求在分发过程中有最大 forward 次数（将请求交给指定的 module / controller / action 处理），即配置文件中 yaf.forward_limit 这一个配置项，这个配置可以避免让用户请求陷入无限循环处理的问题之中（如用户权限系统出现bug，无限转入登录逻辑）。</p><br />
<br />
<p>每一次分发过程中，yaf 的钩子机制会先通过 YAF_PLUGIN_HANDLE 这个宏逐个调用已注册插件中 predispatch 回调方法，之后通过 yaf_dispatcher_handle() 函数实际处理请求，请求完成之后在通过 YAF_PLUGIN_HANDLE 这个宏逐个调用已注册插件中 postdispatch 回调方法。</p><br />
<br />
<p>在请求执行完成之后，向用户发送对应的请求结果。</p><br />
<br />
<p>yaf_dispatcher_handle()<br />
yaf_dispatcher_handle() 这一方法完成的工作是从 request 对象中得知当前的 module 与 controller，之后找到对应的文件，实例化对应的 Controller，为对应的 Controller 设定好模板目录等这类基础属性。</p><br />
<br />
<p>之后会从 request 对象中获取 action，即实际需要执行的方法。</p><br />
<br />
<p>执行完对应的action之后，如果执行结果的返回值不为真值（非0），则不会执行渲染页面以及输出等工作。</p><br />
<br />
<p>如果 Dispatcher 中设置了名为 $_auto_render 且值为真的成员变量（yaf_dispatcher.h 中的 #define YAF_DISPATCHER_PROPERTY_NAME_RENDER “_auto_render”），当前 Controller 可能会触发自动输出。</p><br />
<br />
<p>这里说可能，是因为 Controller 中的成员变量也会影响到这一行为。</p><br />
<br />
<p>如果 Controller 中设置了名为 $yafAutoRender 且值为真的成员变量（yaf_controller.h 中的 #define YAF_CONTROLLER_PROPERTY_NAME_RENDER “yafAutoRender”），当前 Controller 会触发自动输出。只有 Controller 中没有设定这一个成员变量，Dispatcher 中的配置才会产生影响。</p><br />
<br />
<p>实际上，Yaf_Dispatcher 中的 enableView()/disableView() 方法所做的就是修改这一成员变量的值。</p><br />
<br />
<p>yaf_exception.c<br />
主要定义了各种类型的异常类。</p><br />
<br />
<p>yaf_loader.c<br />
Yaf 的又一核心组成部分，代码与类自动加载器。</p><br />
<br />
<p>import()<br />
import() 方法主要完成的工作是加载对应的 PHP 文件到当前执行环境。实际上仍然调用的是 yaf_loader_import() 函数进行加载工作。</p><br />
<br />
<p>autoload()<br />
当代码遇到当前文件中未定义的类时，需要自动加载器完成对应代码的加载工作。</p><br />
<br />
<p>从这个方法的逻辑可以看到 yaf 自动加载的规律。</p><br />
<br />
<p>在未做特殊配置的情况下，在默认模块下进行开发，简单来说可以概括成如下几个：</p><br />
<br />
<p>代码的起始查找目录都在于在ini中定义的application.directory(此处值可以使用PHP代码中的预定义常量)<br />
_表示目录分隔符，class Foo_BarBar_Var等同于目录Foo/BarBar/Var.php<br />
Controller为结尾的类会在controllers目录下进行查找<br />
Model为结尾的类会在models目录下进行查找<br />
Plugin为结尾的类会在plugins目录下进行查找<br />
其他类会在library目录下进行查找<br />
use_spl_autoload 配置项作用<br />
手册里面提及：</p><br />
<br />
<p>在use_spl_autoload关闭的情况下, Yaf Autoloader在一次找不到的情况下, 会立即返回, 而剥夺其后的自动加载器的执行机会.</p><br />
<br />
<p>从代码执行逻辑上来看，确实如此，spl_autoload_register() 这一函数在注册的回调方法返回 TRUE 时，不会调用已注册函数列表中的下一个加载函数。</p><br />
<br />
<p>Yaf 在设置这一个值为空或者关闭时（0）,做法是无论何种情况都返回真值：</p><br />
<br />
<p>if (!YAF_G(use_spl_autoload)) {<br />
        /** directory might be NULL since we passed a NULL */<br />
        if (yaf_internal_autoload(file_name, file_name_len, &amp;directory TSRMLS_CC)) {<br />
            char *lc_classname = zend_str_tolower_dup(origin_classname, class_name_len);<br />
            if (zend_hash_exists(EG(class_table), lc_classname, class_name_len + 1)) {<br />
…<br />
                RETURN_TRUE; // 注意<br />
            } else {<br />
                efree(lc_classname);<br />
                php_error_docref(NULL TSRMLS_CC, E_STRICT, “Could not find class %s in %s”, class_name, directory);<br />
            }<br />
        }  else {<br />
            php_error_docref(NULL TSRMLS_CC, E_WARNING, “Failed opening script %s: %s”, directory, strerror(errno));<br />
        }</p><br />
<br />
<p>…<br />
        RETURN_TRUE; // 注意<br />
    }</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
if (!YAF_G(use_spl_autoload)) {<br />
        /** directory might be NULL since we passed a NULL */<br />
        if (yaf_internal_autoload(file_name, file_name_len, &amp;directory TSRMLS_CC)) {<br />
            char *lc_classname = zend_str_tolower_dup(origin_classname, class_name_len);<br />
            if (zend_hash_exists(EG(class_table), lc_classname, class_name_len + 1)) {<br />
…<br />
                RETURN_TRUE; // 注意<br />
            } else {<br />
                efree(lc_classname);<br />
                php_error_docref(NULL TSRMLS_CC, E_STRICT, “Could not find class %s in %s”, class_name, directory);<br />
            }<br />
        }  else {<br />
            php_error_docref(NULL TSRMLS_CC, E_WARNING, “Failed opening script %s: %s”, directory, strerror(errno));<br />
        }</p><br />
<br />
<p>…<br />
        RETURN_TRUE; // 注意<br />
    }</p><br />
<br />
<p>但是在集成 Eloquent 的尝试里，在配置文件中并没有配置这一个项目为1（即开启），按照扩展源码的逻辑，Composer 生成的加载器应该不起作用，这个和实际情况不符，因为 Eloquent 在样例程序中表现正常。</p><br />
<br />
<p>究其原因，其实很简单，即 Composer 生成的自动加载器在注册时要求注册到了加载函数队列的首位。</p><br />
<br />
<p>先来看 spl_autoload_register() 方法的原型：</p><br />
<br />
<p>bool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] )</p><br />
<br />
<p>1<br />
2<br />
bool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] )</p><br />
<br />
<p>让人值得注意的是 $prepend 参数：</p><br />
<br />
<p>prepend<br />
    如果是 true，spl_autoload_register() 会添加函数到队列之首，而不是队列尾部。</p><br />
<br />
<p>1<br />
2<br />
3<br />
prepend<br />
    如果是 true，spl_autoload_register() 会添加函数到队列之首，而不是队列尾部。</p><br />
<br />
<p>进入到 vendor 目录，翻看 autoload_real.php 源码，可以看到：</p><br />
<br />
<p>class ComposerAutoloaderInit4604f3b23b635a9f5adc52f8616258a1<br />
{<br />
    private static $loader;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static function loadClassLoader($class)<br />
{<br />
    if ('Composer\Autoload\ClassLoader' === $class) {<br />
        require __DIR__ . '/ClassLoader.php';<br />
    }<br />
}<br />
<br />
public static function getLoader()<br />
{<br />
    if (null !== self::$loader) {<br />
        return self::$loader;<br />
    }<br />
<br />
    ...<br />
<br />
    $loader-&gt;register(true); // 注意，这里为 true<br />
    <br />
    ...<br />
<br />
    return $loader;<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
25<br />
26<br />
27<br />
class ComposerAutoloaderInit4604f3b23b635a9f5adc52f8616258a1<br />
{<br />
    private static $loader;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static function loadClassLoader($class)<br />
{<br />
    if ('Composer\Autoload\ClassLoader' === $class) {<br />
        require __DIR__ . '/ClassLoader.php';<br />
    }<br />
}<br />
 <br />
public static function getLoader()<br />
{<br />
    if (null !== self::$loader) {<br />
        return self::$loader;<br />
    }<br />
 <br />
    ...<br />
 <br />
    $loader-&gt;register(true); // 注意，这里为 true<br />
    <br />
    ...<br />
 <br />
    return $loader;<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>这个 register 方法的定义为：</p><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Registers this instance as an autoloader.<br />
 *</li><br />
  <li>@param bool $prepend Whether to prepend the autoloader or not<br />
 */<br />
public function register($prepend = false)<br />
{<br />
 spl_autoload_register(array($this, ‘loadClass’), true, $prepend);<br />
}</li><br />
</ul><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
/**</p><br />
<ul><br />
  <li>Registers this instance as an autoloader.<br />
 *</li><br />
  <li>@param bool $prepend Whether to prepend the autoloader or not<br />
 */<br />
public function register($prepend = false)<br />
{<br />
 spl_autoload_register(array($this, ‘loadClass’), true, $prepend);<br />
}</li><br />
</ul><br />
<br />
<p>至此，可以看到，我们通过 Composer 生成的自动加载方法，实际上会优先于 yaf 自身的自动加载方法，由于 yaf 的自动加载方法也是通过 spl_autoload_register() 方法注册的，处于同一个加载函数队列，在 Composer 声明优先的情况下，加载函数执行顺序就会发生变化。</p><br />
<br />
<p>yaf_plugin.c<br />
插件抽象类 Yaf_Plugin_Abstract 的定义。在这里，可以看到一个插件可以实现的 hook 方法：</p><br />
<br />
<p>zend_function_entry yaf_plugin_methods[] = {<br />
    PHP_ME(yaf_plugin, routerStartup,        plugin_arg, ZEND_ACC_PUBLIC)<br />
    PHP_ME(yaf_plugin, routerShutdown,       plugin_arg, ZEND_ACC_PUBLIC)<br />
    PHP_ME(yaf_plugin, dispatchLoopStartup,  plugin_arg, ZEND_ACC_PUBLIC)<br />
    PHP_ME(yaf_plugin, dispatchLoopShutdown, plugin_arg, ZEND_ACC_PUBLIC)<br />
    PHP_ME(yaf_plugin, preDispatch,          plugin_arg, ZEND_ACC_PUBLIC)<br />
    PHP_ME(yaf_plugin, postDispatch,         plugin_arg, ZEND_ACC_PUBLIC)<br />
    PHP_ME(yaf_plugin, preResponse,          plugin_arg, ZEND_ACC_PUBLIC)<br />
    {NULL, NULL, NULL}<br />
};</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
zend_function_entry yaf_plugin_methods[] = {<br />
    PHP_ME(yaf_plugin, routerStartup,        plugin_arg, ZEND_ACC_PUBLIC)<br />
    PHP_ME(yaf_plugin, routerShutdown,       plugin_arg, ZEND_ACC_PUBLIC)<br />
    PHP_ME(yaf_plugin, dispatchLoopStartup,  plugin_arg, ZEND_ACC_PUBLIC)<br />
    PHP_ME(yaf_plugin, dispatchLoopShutdown, plugin_arg, ZEND_ACC_PUBLIC)<br />
    PHP_ME(yaf_plugin, preDispatch,          plugin_arg, ZEND_ACC_PUBLIC)<br />
    PHP_ME(yaf_plugin, postDispatch,         plugin_arg, ZEND_ACC_PUBLIC)<br />
    PHP_ME(yaf_plugin, preResponse,          plugin_arg, ZEND_ACC_PUBLIC)<br />
    {NULL, NULL, NULL}<br />
};</p><br />
<br />
<p>他们都只接受两个参数：request 与 response。</p><br />
<br />
<p>ZEND_BEGIN_ARG_INFO_EX(plugin_arg, 0, 0, 2)<br />
    ZEND_ARG_OBJ_INFO(0, request, Yaf_Request_Abstract, 0)<br />
    ZEND_ARG_OBJ_INFO(0, response, Yaf_Response_Abstract, 0)<br />
ZEND_END_ARG_INFO()</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
ZEND_BEGIN_ARG_INFO_EX(plugin_arg, 0, 0, 2)<br />
    ZEND_ARG_OBJ_INFO(0, request, Yaf_Request_Abstract, 0)<br />
    ZEND_ARG_OBJ_INFO(0, response, Yaf_Response_Abstract, 0)<br />
ZEND_END_ARG_INFO()</p><br />
<br />
<p>yaf_registry.c<br />
Yaf 全局存储类 Yaf_Registry 定义。用于在整个 app 声明周期内存储共有数据。所有数据都会存储到一个 zval 之中。</p><br />
<br />
<p>https://blog.wislay.com/articles/549</p><br />
<br />
<p>Yaf 版本为 2.3.0。</p><br />
<br />
<p>本篇主要简单记录了：</p><br />
<br />
<p>yaf_request.c<br />
yaf_response.c<br />
yaf_router.c<br />
yaf_session.c<br />
源码阅读过程中的一些问题和理解。</p><br />
<br />
<p>yaf_request.c<br />
定义了 Yaf_Request_Abstract 这一抽象类。同时以及声明了这些类型的 getter / setter 方法。</p><br />
<br />
<p>一个 yaf 的 request 包含了需要调用的 Controller / Action 等等信息。</p><br />
<br />
<p>一个应用场景是在开发过程中，可以通过插件在分发前根据特定情况改动 request 的信息，使得可以更改请求触发的操作对象。</p><br />
<br />
<p>yaf_response.c<br />
定义了 Yaf_Response_Abstract 这一抽象类。</p><br />
<br />
<p>Response 对象中关键的操作是返回内容的操作以及实际返回内容的方法。</p><br />
<br />
<p>返回内容可以在多次的 foward 等过程中，在当前返回数据之前或者之后进行追加操作，也可以直接替换最终返回的数据。这些操作都通过 yaf_response_alter_body() 函数实现，这一函数可以支持：</p><br />
<br />
<p>YAF_RESPONSE_PREPEND 添加到头部<br />
YAF_RESPONSE_APPEND 追加到尾部<br />
YAF_RESPONSE_REPLACE 修改数据<br />
相对应的就是 response 对象中的 prependBody() / appendBody() / setBody() 方法。</p><br />
<br />
<p>对于 HTTP 协议上诸如 Header 等内容的操作，也在这个文件中进行了定义。</p><br />
<br />
<p>yaf_router.c<br />
这是 yaf 框架最为重要的组成部分之一。</p><br />
<br />
<p>在此文件中，定义了 Yaf_Router 这一 class。同时也定义了 static / simple / supervar / rewrite / regex / map 这几个路由规则。</p><br />
<br />
<p>路由过程与添加路由规则的顺序相反，在上一篇文章中有所提及。</p><br />
<br />
<p>无论是内置路由规则，还是新增的路由规则，都需要实现 Yaf_Route_Interface 这一个接口，实现 route() 方法，接受 request 对象，认定为匹配之后，修改当前请求对象的 module / controller / action，并返回真值。</p><br />
<br />
<p>如果没有设定，则使用 static 路由规则。</p><br />
<br />
<p>实际使用过程中，可以通过当前 app 的 dispatcher 中的 router 添加一个实例化的路由规则，实现自己路由的目的。</p><br />
<br />
<p>assemble()<br />
assemble() 方法是一个根据自身路由规则拼装出合理 url 的工具，每一个路由类型都需要结合自身的规则，来实现这个方法。</p><br />
<br />
<p>Yaf 路由时需要知道 module / controller / action，所以在调用 assemble() 时，自然也要通过数组的方式，传递这些参数，即源码中的：</p><br />
<br />
<p>YAF_ROUTE_ASSEMBLE_MOUDLE_FORMAT :m<br />
YAF_ROUTE_ASSEMBLE_CONTROLLER_FORMAT :c<br />
YAF_ROUTE_ASSEMBLE_ACTION_FORMAT :a<br />
这是一个了解各个路由的手段。</p><br />
<br />
<p>关于具体路由的使用，另起篇幅。</p><br />
<br />
<p>yaf_session.c<br />
定义了 Yaf_Session 这一个类。</p><br />
<br />
<p>可以通过 getInstance() 方法获得单例。</p><br />
<br />
<p>Yaf_Session 类只是对 $_SESSION 进行了封装，实际上操作的还是 $_SESSION 变量，在初始化过程中将 $_SESSION 变量和成员属性 sess 进行了关联</p><br />
<br />
<p>https://www.kancloud.cn/wuzhc/note/798302</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category php
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>