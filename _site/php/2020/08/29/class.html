<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">php扩展实现一个class</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-08-29T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Aug 29, 2020</time></p>
					</div>
					 <p>$./ext_skel –extname=myClass<br />
Creating directory myClass<br />
Creating basic files: config.m4 config.w32 .gitignore myClass.c php_myClass.h CREDITS EXPERIMENTAL tests/001.phpt myClass.php [done].</p><br />
<br />
<p>To use your new extension, you will have to execute the following steps:</p><br />
<br />
<ol><br />
  <li>$ cd ..</li><br />
  <li>$ vi ext/myClass/config.m4</li><br />
  <li>$ ./buildconf</li><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>$ ./configure –[with</td><br />
          <td>enable]-myClass</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li>$ make</li><br />
  <li>$ ./sapi/cli/php -f ext/myClass/myClass.php</li><br />
  <li>$ vi ext/myClass/myClass.c</li><br />
  <li>$ make</li><br />
</ol><br />
<br />
<p>两种加载方式 with 和 enable<br />
enable方式 需要重新编译PHP ,这样是非常浪费时间的,所以我把它编译为so模块..<br />
所以就用 with啦</p><br />
<br />
<p>PHP_ARG_WITH(myClass, for myClass support,<br />
 Make sure that the comment is aligned:<br />
 [  –with-myClass             Include myClass support])</p><br />
<br />
<p>https://www.cnblogs.com/orlion/p/5466155.html</p><br />
<br />
<p>假设我们要用PHP扩展实 现一个类Person，它有一个private的成员变量$_name和两个public的实例方法getName()和setName()，可以用 PHP代码表示如下：<br />
&lt;?php class Person<br />
{<br />
    private $_name;<br />
    public function getName()<br />
    {<br />
        return $this -&gt; _name;<br />
    } <br />
    public function setName($name)<br />
    {<br />
        $this -&gt; _name = $name;<br />
    } <br />
}</p><br />
<br />
<ol><br />
  <li>声明方法：首先在头文件php_myClass.h里加入方法声明。</li><br />
</ol><br />
<br />
<p>PHP_METHOD(Person, __construct);<br />
PHP_METHOD(Person, __destruct);<br />
PHP_METHOD(Person, getName);<br />
PHP_METHOD(Person, setName);<br />
前面的扩展在声明函数时使用PHP_FUNCTION宏，而在实现类扩展时我们使用PHP_METHOD宏，第一个参数指定类名，第二个参数指定方法名。<br />
<!-- more --></p><br />
<br />
<ol><br />
  <li>方法实现：在fetion_echo.c文件中实现这几个方法，构造函数和析构函数中只是输出一些文本<br />
PHP_METHOD(Person, __construct) {<br />
 php_printf(“__construct called.”);<br />
}</li><br />
</ol><br />
<br />
<p>PHP_METHOD(Person, __destruct) {<br />
 php_printf(“__destruct called.<br />”);<br />
}</p><br />
<br />
<p>PHP_METHOD(Person, getName) {<br />
 zval *self, *name;<br />
 self = getThis();<br />
 name = zend_read_property(Z_OBJCE_P(self), self, ZEND_STRL(“_name”), 0 TSRMLS_CC);<br />
 RETURN_STRING(Z_STRVAL_P(name), 0);<br />
}</p><br />
<br />
<p>PHP_METHOD(Person, setName) {<br />
 char *arg = NULL;<br />
 int arg_len;<br />
 zval *value, *self;<br />
 if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, “s”, &amp;arg, &amp;arg_len) == FAILURE) {<br />
 WRONG_PARAM_COUNT;<br />
 }<br />
 self = getThis();<br />
 MAKE_STD_ZVAL(value);<br />
 ZVAL_STRINGL(value, arg, arg_len, 0);<br />
 SEPARATE_ZVAL_TO_MAKE_IS_REF(&amp;value);<br />
 zend_update_property(Z_OBJCE_P(self), self, ZEND_STRL(“_name”), value TSRMLS_CC);<br />
 RETURN_TRUE;<br />
}<br />
对上面的代码做一些解释：</p><br />
<br />
<p>A. 获取方法的参数信息，仍然使用zend_parse_parameters函数，与之前我们介绍过的一样；</p><br />
<br />
<p>B. 获取this指针（相对于PHP代码而言，在PHP扩展中仍然使用zval结构表示）使用getThis()函数；</p><br />
<br />
<p>C. 使用MAKE_STD_ZVAL宏申请并初始化一个zval结构，在PHP扩展中，所有的数据类型其实都是用zval结构来表示的，在本系列文章中我会单独写一篇来介绍zval。</p><br />
<br />
<p>D. 获取属性值使用zend_read_property()函数，使用zend_update_property()函数更新属性值。</p><br />
<br />
<ol><br />
  <li>初始化类：在扩展初始化函数中，注册并初始化类。</li><br />
</ol><br />
<br />
<p>zend_class_entry *person_ce;</p><br />
<br />
<p>PHP_MINIT_FUNCTION(fetion_echo)<br />
{ <br />
    zend_class_entry person; INIT_CLASS_ENTRY(person, “Person”, fetion_echo_functions);<br />
    person_ce = zend_register_internal_class_ex(&amp;person, NULL, NULL TSRMLS_CC);</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zend_declare_property_null(person_ce, ZEND_STRL("_name"), ZEND_ACC_PRIVATE TSRMLS_CC); return SUCCESS; } 使用INIT_CLASS_ENTRY宏初始化类，第二个参数指定类名，第三个参数是函数表。<br />
</code></pre></div></div><br />
<br />
<ol><br />
  <li>注册到函数：声明方法的参数，并注册到函数表中。</li><br />
</ol><br />
<br />
<p>ZEND_BEGIN_ARG_INFO(arg_person_setname, 0)<br />
    ZEND_ARG_INFO(0, name)<br />
ZEND_END_ARG_INFO() const zend_function_entry fetion_echo_functions[] = {<br />
    PHP_ME(Person, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)<br />
    PHP_ME(Person, __destruct,  NULL, ZEND_ACC_PUBLIC|ZEND_ACC_DTOR)<br />
    PHP_ME(Person, getName,     NULL, ZEND_ACC_PUBLIC)<br />
    PHP_ME(Person, setName,     arg_person_setname, ZEND_ACC_PUBLIC)<br />
    {NULL, NULL, NULL} /* Must be the last line in fetion_echo_functions[] */ };<br />
类方法参数的声明与之前我们函数参数声明方式一致，在注册类方法到函数表中时使用PHP_ME宏，而不是之前使用的PHP_FE宏。</p><br />
<br />
<p>ZEND_ACC_PUBLIC：指定方法的访问修饰符</p><br />
<br />
<p>ZEND_ACC_CTOR：指定该方法为构造函数</p><br />
<br />
<p>ZEND_ACC_DTOR：指定该方法为析构函数</p><br />
<br />
<ol><br />
  <li>运行测试：编译安装扩展后，编写一段简单的测试脚本：</li><br />
</ol><br />
<br />
<p>&lt;?php $person = new Person();<br />
    $person-&gt;setName(“mickelfeng”); echo $person-&gt;getName().’<br />’;<br />
运行后可以看到如下输出，说明扩展工作正常：</p><br />
<br />
<p>__construct called.<br />
mickelfeng<br />
__destruct called.</p><br />
<br />
<p>https://www.cnblogs.com/orlion/p/5459053.html</p><br />
<br />
<p>$phpize<br />
$./configure<br />
$make<br />
myClass.c:87:81: error: too few arguments to function call, expected 6, have 5<br />
name = zend_read_property(Z_OBJCE_P(self), self, ZEND_STRL(“_name”), 0 TSRMLS_CC);</p><br />
<br />
<p>解决办法<br />
//name = zend_read_property(Z_OBJCE_P(self), self, ZEND_STRL(“_name”), 0 TSRMLS_CC);<br />
zval *length = zend_read_property(Z_OBJCE_P(self), self, ZEND_STRL(“_name”), 0 TSRMLS_CC,name);</p><br />
<br />
<p>myClass.c:89:33: error: too many arguments provided to function-like macro invocation<br />
RETURN_STRING(Z_STRVAL_P(name), 0);<br />
                                ^</p><br />
<br />
<p>//RETURN_STRING(Z_STRVAL_P(name), 0);<br />
RETURN_STRING(Z_STRVAL_P(name));</p><br />
<br />
<p>myClass.c:102:35: error: too many arguments provided to function-like macro invocation<br />
ZVAL_STRINGL(value, arg, arg_len, 0);</p><br />
<br />
<p>//ZVAL_STRINGL(value, arg, arg_len, 0);<br />
ZVAL_STRINGL(value, arg, arg_len);</p><br />
<br />
<p>myClass.c:126:62: error: use of undeclared identifier ‘fetion_echo_functions’<br />
        zend_class_entry person; INIT_CLASS_ENTRY(person, “Person”, fetion_echo_functions);</p><br />
<br />
<p>改变名字fetion_echo_functions ＝》  myClass_functions<br />
移动声明到前面<br />
ZEND_END_ARG_INFO() const zend_function_entry myClass_functions[] = {</p><br />
<br />
<p>/myClass.c:136:61: error: too many arguments to function call, expected 2, have 3<br />
        person_ce = zend_register_internal_class_ex(&amp;person, NULL, NULL TSRMLS_CC);</p><br />
<br />
<p>/myClass.c:193:27: error: redefinition of ‘myClass_functions’<br />
const zend_function_entry myClass_functions[] = {</p><br />
<br />
<p>//const zend_function_entry myClass_functions[] = {<br />
//	PHP_FE(confirm_myClass_compiled,	NULL)		/* For testing, remove later. <em>/<br />
//	PHP_FE_END	/</em> Must be the last line in myClass_functions[] */<br />
//};</p><br />
<br />
<p>$php test.php<br />
__construct called.dyld: lazy symbol binding failed: Symbol not found: _MAKE_STD_ZVAL<br />
  Referenced from: /usr/local/lib/php/extensions/no-debug-non-zts-20170718/myClass.so<br />
  Expected in: flat namespace</p><br />
<br />
<p>dyld: Symbol not found: _MAKE_STD_ZVAL<br />
  Referenced from: /usr/local/lib/php/extensions/no-debug-non-zts-20170718/myClass.so<br />
  Expected in: flat namespace</p><br />
<br />
<p>Trace/BPT trap: 5</p><br />
<br />
<p>php扩展函数返回值MAKE_STD_ZVAL(zv) 宏替换过程如下：</p><br />
<br />
<p>替换之前：<br />
MAKE_STD_ZVAL(zv);<br />
—————————<br />
第1次替换：<br />
ALLOC_ZVAL(zv);<br />
INIT_PZVAL(zv);<br />
—————————<br />
第2次替换：<br />
(zv) = (zval *) emalloc(sizeof(zval));<br />
(zv)-&gt;refcount__gc = 1;<br />
(zv)-&gt;is_ref__gc = 0;;</p><br />
<br />
<p>替换完之后，MAKE_STD_ZVAL宏的用途就不言而喻了</p><br />
<br />
<p>myClass.c:101:1: warning: implicit declaration of function ‘MAKE_STD_ZVAL’ is invalid<br />
      in C99 [-Wimplicit-function-declaration]<br />
MAKE_STD_ZVAL(value);</p><br />
<p>/Users/didi/PhpstormProjects/c/php-src/ext/myClass/myClass.c:104:1: warning: implicit declaration of function<br />
      ‘SEPARATE_ZVAL_TO_MAKE_IS_REF’ is invalid in C99 [-Wimplicit-function-declaration]</p><br />
<br />
<p>https://www.laruence.com/2018/04/08/3170.html<br />
在PHP7开始, 我们移除了MAKE_STD_ZVAL/ALLOC_ZVAL宏, 不再支持存堆内存上申请zval. 函数内部使用的zval要么来自外面输入, 要么使用在栈上分配的临时zval.</p><br />
<br />
<p>zval 的创建<br />
MAKE_STD_ZVAL(pzv). 这个宏将会以一种优化的方式为zval分配空间， 自动的处理超出内存错误，并初始化新zval的refcount和is_ref属性，除此之外，还有宏 ALLOC_INIT_ZVAL(). 这个宏和MAKE_STD_ZVAL唯一的区别是它会将zval *的数据类型初始化为IS_NULL。</p><br />
<br />
<p>MAKE_STD_ZVAL例子（注意：在PHP7下，已经不允许我们在堆上去分配 zval 空间，我们通常的做法是， 定义一个临时变量(栈上)，然后将 p 的指针指向这个临时变量的地址，注意在使用完之后销毁zval，通常，我们可以在.h文件中做一个php5和php7版本的适配， 让你的代码能同时在php5 和 php7 上编译通过）</p><br />
<br />
<p>—-php7_wrapper.h—-<br />
#if PHP_MAJOR_VERSION &lt; 7 /* PHP Version 5<em>/<br />
	#define SW_MAKE_STD_ZVAL(p)               MAKE_STD_ZVAL(p)<br />
	#define SW_ALLOC_INIT_ZVAL(p)             ALLOC_INIT_ZVAL(p)<br />
	#define sw_zval_ptr_dtor(p)	          zval_ptr_dtor(</em>p) //zval销毁</p><br />
<br />
<p>#else /* PHP Version 7 <em>/<br />
        //栈上分配空间<br />
	#define SW_MAKE_STD_ZVAL(p)             zval _stack_zval_##p; p = &amp;(_stack_zval_##p)<br />
	#define SW_ALLOC_INIT_ZVAL(p)           do{p = (zval *)emalloc(sizeof(zval)); bzero(p, sizeof(zval));}while(0)<br />
	#define sw_zval_ptr_dtor(p)	        zval_ptr_dtor(</em>p) //zval销毁</p><br />
<br />
<p>#endif</p><br />
<br />
<p>https://blog.csdn.net/caohao0591/article/details/82187030</p><br />
<br />
<p>解决办法<br />
//MAKE_STD_ZVAL(value);</p><br />
<br />
<p>myClass.c:105:1: warning: implicit declaration of function<br />
      ‘SEPARATE_ZVAL_TO_MAKE_IS_REF’ is invalid in C99 [-Wimplicit-function-declaration]<br />
SEPARATE_ZVAL_TO_MAKE_IS_REF(&amp;value);</p><br />
<br />
<p>// 变量分离，此处重新copy了一份array专门用于key函数<br />
    SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr_ptr);<br />
    varptr = *varptr_ptr;<br />
    Z_ADDREF_P(varptr);</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 压栈<br />
zend_vm_stack_push(varptr TSRMLS_CC);<br />
ZEND_VM_NEXT_OPCODE(); }<br />
</code></pre></div></div><br />
<br />
<p>上述代码中的SEPARATE_ZVAL_TO_MAKE_IS_REF是一个宏：<br />
复制代码 代码如下:</p><br />
<br />
<p>#define SEPARATE_ZVAL_TO_MAKE_IS_REF(ppzv)    <br /><br />
    if (!PZVAL_IS_REF(*ppzv)) {                <br /><br />
        SEPARATE_ZVAL(ppzv);                <br /><br />
        Z_SET_ISREF_PP((ppzv));                <br /><br />
    }</p><br />
<br />
<p>SEPARATE_ZVAL_TO_MAKE_IS_REF的主要作用为，如果变量不是一个引用，则在内存中copy出一份新的。本例中它将array(‘a’,’b’,’c’)复制了一份。因此变量分离之后的内存为：<br />
注意，变量分离完成之后，CV数组中的指针指向了新copy出来的数据，而通过zend_execute_data-&gt;Ts中的指针则依然可以获取旧的数据。<br />
接下来的循环就不一一赘述了，结合上图来说：<br />
•foreach结构使用的是下方蓝色的array，会依次遍历a，b，c<br />
•key、current使用的是上方黄色的array，它的内部指针永远指向b<br />
至此我们明白了为何key和current一直返回array的第二个元素，由于没有外部代码作用于copy出来的array，它的内部指针便永远不会移动。</p><br />
<br />
<p>https://blog.csdn.net/Inite/article/details/74157330</p><br />
<br />
<p>https://bugs.php.net/bug.php?id=11970<br />
$php test.php<br />
__construct called.Segmentation fault: 11</p><br />
<br />
<p>https://my.oschina.net/u/4321424/blog/3714297<br />
php7的文档中有这样的描述：<br />
Both mistakes might cause memory corruptions and segfaults:<br />
1)<br />
char *str;<br />
long str_len; <br />
zend_parse_parameters(ZEND_NUM_ARGS(), “s”, &amp;str, &amp;str_len)</p><br />
<br />
<p>2)<br />
int num; <br />
zend_parse_parameters(ZEND_NUM_ARGS(), “l”, &amp;num)<br />
上面的例子应该改成：<br />
int str_len; ==&gt; size_t str_len;</p><br />
<br />
<p>The following characters also have a meaning in the specifier string:<br />
| - indicates that the remaining parameters are optional, they<br />
should be initialized to default values by the extension since they<br />
will not be touched by the parsing function if they are not<br />
passed to it.<br />
/ - use SEPARATE_ZVAL_IF_NOT_REF() on the parameter it follows<br />
! - the parameter it follows can be of specified type or NULL. If NULL is<br />
passed and the output for such type is a pointer, then the output<br />
pointer is set to a native NULL pointer.<br />
For ‘b’, ‘l’ and ‘d’, an extra argument of type zend_bool* must be<br />
passed after the corresponding bool<em>, zend_long</em> or double* arguments,<br />
respectively. A non-zero value will be written to the zend_bool if a<br />
PHP NULL is passed.</p><br />
<br />
<p>//int arg_len;<br />
size_t arg_len;</p><br />
<br />
<p>https://www.cnblogs.com/djhull/p/5359650.html</p><br />
<br />
<p>在php_person.h头中加上</p><br />
<br />
<p>extern zend_class_entry *person_ce;PHP_METHOD(person_ce,__construct);PHP_METHOD(person_ce,saying);PHP_METHOD(person_ce,doing);<br />
在person.c头中加上</p><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>声明构造函数</li><br />
  <li>@param</li><br />
  <li><br />
    <p>@return<br />
 */ZEND_METHOD(person,__construct){</p><br />
<br />
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> zval *pThis;<br />
 pThis = getThis();<br />
</code></pre></div>    </div><br />
<br />
    <p>zend_printf(“construct\n”);}/**</p><br />
  </li><br />
  <li>声明析造函数</li><br />
  <li>@param</li><br />
  <li><br />
    <p>@return<br />
 */ZEND_METHOD(person,__destruct){</p><br />
<br />
    <p>zend_printf(“destruct\n”);}ZEND_METHOD(person,doing){</p><br />
<br />
    <p>zend_printf(“doing\n”);}ZEND_METHOD(person,saying){</p><br />
<br />
    <p>zend_printf(“saying\n”);}//这个函数需要加上声明，去掉了没用的test函数const zend_function_entry person_functions[] = {</p><br />
<br />
    <p>ZEND_ME(person, __construct, global_config_arg, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)<br />
 ZEND_ME(person,doing,NULL,ZEND_ACC_PUBLIC) ZEND_ME(person,saying,NULL,ZEND_ACC_PUBLIC)<br />
 ZEND_ME(person,__destruct,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_DTOR)</p><br />
<br />
    <p>PHP_FE_END  /* Must be the last line in person_functions[] */};//将类和方法注册到zendPHP_MINIT_FUNCTION(person){<br />
    zend_class_entry ce;<br />
    INIT_CLASS_ENTRY(ce, “person”, person_functions);<br />
    person_ce = zend_register_internal_class(&amp;ce TSRMLS_CC);</p><br />
<br />
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zend_declare_property_null(person_ce,"saying",strlen("saying"),ZEND_ACC_PUBLIC);<br />
zend_declare_property_null(person_ce,"doing",strlen("doing"),ZEND_ACC_PUBLIC);<br />
</code></pre></div>    </div><br />
<br />
    <p>return SUCCESS;}</p><br />
  </li><br />
</ul><br />
<br />
<p>https://blog.csdn.net/weixin_33743880/article/details/91618240</p><br />
<br />
<p>https://blog.csdn.net/caohao0591/article/details/82187030</p><br />
<br />
<p>1， zend_class_entry 是php内核中一个类的原型，如果我们想创建一个类，只要将它注册到minit中去即可</p><br />
<br />
<p>2，类都有方法，方法要注册到 zend_function_entry这个结构中去</p><br />
<br />
<p>ZEND_METHOD(myclass, __construct)<br />
{<br />
    php_printf(“初始化完成”);<br />
}<br />
ZEND_METHOD(myclass, public_func)<br />
{<br />
    php_printf(“执行public_func”);<br />
}<br />
static zend_function_entry walu_functions[] = {<br />
    ZEND_ME(myclass, __construct, NULL, ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)<br />
    ZEND_ME(myclass, public_func, NULL, ZEND_ACC_PUBLIC)<br />
    {NULL,  NULL,   NULL}<br />
};</p><br />
<br />
<p>ZEND_MINIT_FUNCTION(walu)<br />
{<br />
    zend_class_entry ce;<br />
    INIT_CLASS_ENTRY(ce, “myclass”, walu_functions);<br />
    zend_register_internal_class(&amp;ce TSRMLS_CC);<br />
    return SUCCESS;</p><br />
<br />
<p>｝</p><br />
<br />
<p>https://blog.csdn.net/qq_32783703/article/details/80641355</p><br />
<br />
<p>https://www.cnblogs.com/yulibostu/articles/8421830.html</p><br />
<br />
<p>1.在php_siren.h里面声明类</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
PHP_METHOD(Person,__construct);<br />
PHP_METHOD(Person,__destruct);<br />
PHP_METHOD(Person,setproperty);<br />
PHP_METHOD(Person,getproperty);<br />
PHP_METHOD宏.<br />
PHP_METHOD 等于ZEND_METHOD<br />
这个宏接受两个参数,第一个是类名,第二个是类的方法</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
#define ZEND_METHOD(classname, name)    ZEND_NAMED_FUNCTION(ZEND_MN(classname##_##name))<br />
#define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_v    alue_used TSRMLS_DC<br />
//最后等于<br />
void name(int ht, zval *return_value, zval **return_value_ptr, zval *this_ptr, int return_v    alue_used TSRMLS_DC )<br />
这个宏是用来声明我们的方法…<br />
2.设置接收的参数<br />
我们的方法如果需要接受参数.那么就要执行</p><br />
<br />
<p>1<br />
2<br />
3<br />
ZEND_BEGIN_ARG_INFO_EX(arg_person_info,0,0,2) <br />
        ZEND_ARG_INFO(0,name)<br />
ZEND_END_ARG_INFO()<br />
详细讲这几个宏之前先看看zend_arg_info</p><br />
<br />
<p>typedef struct _zend_arg_info {<br />
        const char *name; //参数名称<br />
        zend_uint name_len;//长度<br />
        const char *class_name;  //所属类名<br />
        zend_uint class_name_len;  //类名长度<br />
        zend_bool array_type_hint;<br />
        zend_bool allow_null; //允许为空<br />
        zend_bool pass_by_reference;  //引用传值<br />
        zend_bool return_reference;   //引用返回<br />
        int required_num_args;   //参数个数<br />
} zend_arg_info;<br />
ZEND_BEGIN_ARG_INFO_EX定义在Zend/zend_API.h</p><br />
<br />
<p>1<br />
2<br />
3<br />
#define ZEND_BEGIN_ARG_INFO_EX(name, pass_rest_by_reference, return_reference, required_num_args)       <br /><br />
        static const zend_arg_info name[] = {                                                                                                                                           <br /><br />
                { NULL, 0, NULL, 0, 0, 0, pass_rest_by_reference, return_reference, required_num_args },<br />
很明显 声明一个zend_arg_info的数组name,然后初始化结构体的值<br />
ZEND_ARG_INFO(0,name)的定义如下</p><br />
<br />
<p>1<br />
#define ZEND_ARG_INFO(pass_by_ref, name)  { #name, sizeof(#name)-1, NULL, 0, 0, 0, pass_by_ref, 0, 0 },<br />
这三个宏 执行代码 等于</p><br />
<br />
<p>1<br />
2<br />
3<br />
static const zend_arg_info name[] = {                                                                                                                                                    { NULL, 0, NULL, 0, 0, 0, pass_rest_by_reference, return_reference, required_num_args },<br />
{ #name, sizeof(#name)-1, NULL, 0, 0, 0, pass_by_ref, 0, 0 },<br />
};<br />
3.创建zend_function_entry结构数组</p><br />
<br />
<p>const zend_function_entry person_functions[]={<br />
        PHP_ME(Person,__construct,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_CTOR)<br />
        PHP_ME(Person,__destruct,NULL,ZEND_ACC_PUBLIC|ZEND_ACC_DTOR)<br />
        PHP_ME(Person,getproperty,arg_person_info,ZEND_ACC_PUBLIC)<br />
        PHP_ME(Person,setproperty,arg_person_info,ZEND_ACC_PUBLIC)<br />
        PHP_FE_END<br />
};<br />
zend_function_entry定义如下</p><br />
<br />
<p>typedef struct _zend_function_entry {<br />
        const char <em>fname; //函数名称<br />
        void (</em>handler)(INTERNAL_FUNCTION_PARAMETERS);<br />
        const struct _zend_arg_info *arg_info;//参数<br />
        zend_uint num_args;//参数个数<br />
        zend_uint flags;//标示PUBLIC ?PRIVATE ?PROTECTED<br />
} zend_function_entry;<br />
PHP_ME宏接收四个参数<br />
1 类名,<br />
2 方法名,<br />
3 zend_arg_info 的参数列表,</p><br />
<br />
<p>ZEND_ACC_PUBLIC ZEND_ACC_PRIVATE ZEND_ACC_PROTECTED是我们类里面的三个访问权限<br />
ZEND_ACC_CTOR标示构造函数<br />
ZEND_ACC_DTOR标示析构函数<br />
4.修改PHP_MINIT_FUNCTION<br />
前面我们说过 PHP_MINIT_FUNCTION是在模块启动的时候执行的函数<br />
首先创建一个全局指针 zend_class_entry *person_ce;<br />
在PHP_MINIT_FUNCTION加入如下代码<br />
zend_class_entry person;<br />
INIT_CLASS_ENTRY(person,”Person”,person_functions);<br />
person_ce=zend_register_internal_class_ex(&amp;person,NULL,NULL TSRMLS_CC);<br />
zend_declare_property_null(person_ce,ZEND_STRL(“name”),ZEND_ACC_PUBLIC TSRMLS_CC);<br />
1行创建一个zend_class_entry对象person.<br />
zend_class_entry这个结构体前面也讲过 PHP内核研究之类的实现<br />
2行初始化zend_class_entry 它执行了如下代码</p><br />
<br />
<p>{                                                                                                                       <br /><br />
        int _len = class_name_len;                                                              <br /><br />
        class_container.name = zend_strndup(class_name, _len);  <br /><br />
        class_container.name_length = _len;                                             <br /><br />
        class_container.builtin_functions = functions;                  <br /><br />
        class_container.constructor = NULL;                                             <br /><br />
        class_container.destructor = NULL;                                              <br /><br />
        class_container.clone = NULL;                                                   <br /><br />
        class_container.serialize = NULL;                                               <br /><br />
        class_container.unserialize = NULL;                                             <br /><br />
        class_container.create_object = NULL;                                   <br /><br />
        class_container.interface_gets_implemented = NULL;              <br /><br />
        class_container.get_static_method = NULL;                               <br /><br />
        class_container.__call = handle_fcall;                                  <br /><br />
        class_container.__callstatic = NULL;                                    <br /><br />
        class_container.__tostring = NULL;                                              <br /><br />
        class_container.__get = handle_propget;                                 <br /><br />
        class_container.__set = handle_propset;                                 <br /><br />
        class_container.__unset = handle_propunset;                             <br /><br />
        class_container.__isset = handle_propisset;                             <br /><br />
        class_container.serialize_func = NULL;                                  <br /><br />
        class_container.unserialize_func = NULL;                                <br /><br />
        class_container.serialize = NULL;                                               <br /><br />
        class_container.unserialize = NULL;                                             <br /><br />
        class_container.parent = NULL;                                                  <br /><br />
        class_container.num_interfaces = 0;                                             <br /><br />
        class_container.interfaces = NULL;                                              <br /><br />
        class_container.get_iterator = NULL;                                    <br /><br />
        class_container.iterator_funcs.funcs = NULL;                    <br /><br />
        class_container.module = NULL;                                                  <br /><br />
}<br />
可以对应文章» PHP内核研究之类的实现来分析<br />
zend_declare_property_null(person_ce,ZEND_STRL(“name”),ZEND_ACC_PUBLIC TSRMLS_CC);<br />
创建一个值为NULL的属性<br />
第一个参数是类名,第二个参数是 属性名称,第三个参数是属性名的长度,因为ZEND_STRL宏定义了长度,所以这里不用再传递长度.<br />
第四个参数是属性的访问权限.<br />
还有其他几个函数用来创建不同类型的属性</p><br />
<br />
<p>zend_declare_property_bool<br />
zend_declare_property_double<br />
zend_declare_property_ex<br />
zend_declare_property_long<br />
zend_declare_property_null<br />
zend_declare_property_string<br />
zend_declare_property_stringl<br />
5.创建 php_siren.h头文件中的方法体</p><br />
<br />
<p>PHP_METHOD(Person,__construct){<br />
        php_printf(“construct is running<br />”);<br />
}<br />
PHP_METHOD(Person,__destruct){<br />
        php_printf(“destruct is running<br />”);<br />
}<br />
PHP_METHOD(Person,setproperty){</p><br />
<br />
<p>}<br />
PHP_METHOD(Person,getproperty){</p><br />
<br />
<p>}<br />
6.最后make&amp;&amp; make install<br />
编译我们的扩展,<br />
重新启动apache.</p><br />
<br />
<p>https://www.cnblogs.com/yulibostu/articles/8421830.html</p><br />
<br />
<p>https://www.cnblogs.com/orlion/p/5466164.html</p><br />
<br />
<p>https://my.oschina.net/mickelfeng/blog/122519/print</p><br />
<br />
<p>https://www.php.cn/php-weizijiaocheng-254920.html</p><br />
<br />
<p>https://blog.csdn.net/u013474436/article/details/79020159?utm_source=blogxgwz4</p><br />
<br />
<p>类使用 PHP_ME和PHP_METHOD 宏，与方法最大的不同的地方是类需要注册</p><br />
<br />
<p>这里我写了一个 init_class 方法，PHP_MINIT_FUNCTION中调用，主要是需要注册类</p><br />
<br />
<p>$php test.php<br />
__construct called.PHP Fatal error:  Person::setName() must be derived from ::setName in Unknown on line 0</p><br />
<br />
<p>https://blog.icodef.com/2018/09/25/1508</p><br />
<br />
<p>http://blog.sina.com.cn/s/blog_c039eb5001016mpx.html</p><br />
<br />
<p>而每一个参数的定义可以是下列宏定义中的一个：</p><br />
<br />
<p>ZEND_ARG_INFO	声明普通参数<br />
ZEND_ARG_OBJ_INFO	声明对象类型的参数<br />
ZEND_ARG_ARRAY_INFO	声明数组类型的参数<br />
ZEND_ARG_PASS_INFO(pass_by_ref)	pass_by_ref为1时，强制设置后续的参数为引用类型</p><br />
<br />
<p>https://xueyuanjun.com/post/7239.html</p><br />
<br />
<p>ZEND_API void zend_update_property_stringl(zend_class_entry <em>scope, zval *object, const char *name, size_t name_length, const char *value, size_t value_len) /</em> {{{ */<br />
{<br />
	zval tmp;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ZVAL_STRINGL(&amp;tmp, value, value_len);<br />
Z_SET_REFCOUNT(tmp, 0);<br />
zend_update_property(scope, object, name, name_length, &amp;tmp); }<br />
</code></pre></div></div><br />
<br />
<p>ZEND_API void zend_update_property_null(zend_class_entry *scope, zval *object, char *name, int name_length TSRMLS_DC);<br />
ZEND_API void zend_update_property_bool(zend_class_entry *scope, zval *object, char *name, int name_length, long value TSRMLS_DC);<br />
ZEND_API void zend_update_property_long(zend_class_entry *scope, zval *object, char *name, int name_length, long value TSRMLS_DC);<br />
ZEND_API void zend_update_property_double(zend_class_entry *scope, zval *object, char *name, int name_length, double value TSRMLS_DC);<br />
ZEND_API void zend_update_property_string(zend_class_entry *scope, zval *object, char *name, int name_length, const char *value TSRMLS_DC);<br />
ZEND_API void zend_update_property_stringl(zend_class_entry *scope, zval *object, char *name, int name_length, const char *value, int value_length TSRMLS_DC);</p><br />
<br />
<p>ZEND_API int zend_update_static_property_null(zend_class_entry *scope, char *name, int name_length TSRMLS_DC);<br />
ZEND_API int zend_update_static_property_bool(zend_class_entry *scope, char *name, int name_length, long value TSRMLS_DC);<br />
ZEND_API int zend_update_static_property_long(zend_class_entry *scope, char *name, int name_length, long value TSRMLS_DC);<br />
ZEND_API int zend_update_static_property_double(zend_class_entry *scope, char *name, int name_length, double value TSRMLS_DC);<br />
ZEND_API int zend_update_static_property_string(zend_class_entry *scope, char *name, int name_length, const char *value TSRMLS_DC);<br />
ZEND_API int zend_update_static_property_stringl(zend_class_entry *scope, char</p><br />
<br />
<p>更新对象的属性：</p><br />
<br />
<p>ZEND_API void zend_update_property(zend_class_entry *scope, zval *object, char *name, int name_length, zval *value TSRMLS_DC);<br />
ZEND_API int zend_update_static_property(zend_class_entry *scope, char *name, int name_length, zval *value TSRMLS_DC);<br />
zend_update_property用来更新对象的属性，zend_update_static_property用来更新类的静态属性。如果对象或者类中没有相关的属性，函数将自动的添加上。</p><br />
<br />
<p>读写对象与类属性的实例<br />
假设我们已经在扩展中定义好下面的类：</p><br />
<br />
<p>class baby<br />
{<br />
	public $age;<br />
	public static $area;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public function __construct($age, $area)<br />
{<br />
	$this-&gt;age = $age;<br />
	self::$area = $area;<br />
<br />
	var_dump($this-&gt;age, self::$area);<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>ZEND_METHOD(baby, __construct)<br />
{<br />
	zval *age, *area;<br />
	zend_class_entry *ce;<br />
	ce = Z_OBJCE_P(getThis());<br />
	if( zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, “zz”, &amp;age, &amp;area) == FAILURE )<br />
	{<br />
		printf(“Errorn”);<br />
		RETURN_NULL();<br />
	}<br />
	zend_update_property(ce, getThis(), “age”, sizeof(“age”)-1, age TSRMLS_CC);<br />
	zend_update_static_property(ce, “area”, sizeof(“area”)-1, area TSRMLS_CC);</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>age = NULL;<br />
area = NULL;<br />
<br />
age = zend_read_property(ce, getThis(), "age", sizeof("age")-1, 0 TSRMLS_DC);<br />
php_var_dump(&amp;age, 1 TSRMLS_CC);<br />
<br />
area = zend_read_static_property(ce, "area", sizeof("area")-1, 0 TSRMLS_DC);<br />
php_var_dump(&amp;area, 1 TSRMLS_CC);<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>http://www.4u4v.net/the-php-core-exploration-object-properties-literacy.html</p><br />
<br />
<p>在php扩展程序的开发中，涉及参数接受处理时，第一步便是要对传入参数进行判断，如生成的扩展示例代码：<br />
if (zend_parse_parameters(ZEND_NUM_ARGS(), “s”, &amp;arg, &amp;arg_len) == FAILURE) {<br />
        return;<br />
    }如上述示例代码，其判断有<br />
1：判断是否有入参，如果没有入参就会报缺少参数错误。<br />
2：判断入参是不是字符串，如果不是字符串就会把参数类型错误。<br />
    先说一下参数类型吧，上面的例子中只有字符串，没有其它类型。实际PHP扩展程序中的类型不少，有整型，浮点型，还有zval类型。zval是Zend引擎的值容器，无论这个变量是个简单的布尔值，字符串或者其他任何类型值，其信息总是一个完整的zval结构。可以认为是一个简单数据的底层复杂描述的结构。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://www.04007.cn/article/614.html<br />
<br />
https://xueyuanjun.com/post/7233.html<br />
</code></pre></div></div><br />
<br />
<p>http://www.nowamagic.net/librarys/veda/detail/1467</p><br />
<br />
<p>https://blog.csdn.net/pzqingchong/article/details/70859634?locationNum=2&amp;fps=1</p><br />
<br />
<p>b Boolean<br />
l Integer 整型<br />
d Floating point 浮点型<br />
s String 字符串<br />
r Resource 资源<br />
a Array 数组<br />
o Object instance 对象<br />
O Object instance of a specified type 特定类型的对象<br />
z Non-specific zval 任意类型～<br />
Z zval**类型<br />
f 表示函数、方法名称，PHP5.3之前没有的</p><br />
<br />
<p>b   zend_bool<br />
l   long<br />
d   double<br />
s   char<em>, int 前者接收指针，后者接收长度<br />
r   zval</em><br />
a   zval*<br />
o   zval*<br />
O   zval<em>, zend_class_entry</em><br />
z   zval*<br />
Z   zval**</p><br />
<br />
<p>https://www.cnblogs.com/chenpingzhao/p/4498829.html</p><br />
<br />
<p>//if (zend_parse_method_parameters(ZEND_NUM_ARGS(), getThis(), “s”,&amp;name, &amp;name_len) == FAILURE) {<br />
if(zend_parse_method_parameters(ZEND_NUM_ARGS(),getThis(),”s”,Z_OBJCE_P(getThis()),person_ce,&amp;name)==FAILURE){</p><br />
<br />
<p>https://blog.icodef.com/2018/09/25/1508</p><br />
<br />
<p>PHP Warning:  Person::setName() expects exactly 0 parameters, 1 given in /Users/didi/PhpstormProjects/c/php-src/ext/myClass/test.php on line 4<br />
https://www.cnblogs.com/chenpingzhao/p/4498829.html</p><br />
<br />
<p>https://www.cnblogs.com/djhull/p/5359650.html</p><br />
<br />
<p>https://www.cnblogs.com/yhl664123701/p/5311387.html</p><br />
<br />
<p>https://segmentfault.com/a/1190000007575322</p><br />
<br />
<p>zend_parse_method_parameters 和 zend_parse_parameters 区别</p><br />
<br />
<p>zend_parse_method_parameters 必须第一个格式字符串是 O</p><br />
<br />
<p>this_ptr作为返回值 返回（赋值给obj_ptr) 且必须是 mchessian_service_ce_ptr类型实例</p><br />
<br />
<p>if (FAILURE == zend_parse_method_parameters(ZEND_NUM_ARGS() TSRMLS_CC, p_this, “O|o”, &amp;obj_ptr, mcphessian_service_ce_ptr, &amp;obj2_ptr)) {<br />
zend_error(E_WARNING, “parse parameters error.”);<br />
//return;<br />
}</p><br />
<br />
<p>ZEND_API int zend_parse_method_parameters(int num_args TSRMLS_DC, zval <em>this_ptr, const char *type_spec, …) /</em> {{{ */<br />
{<br />
va_list va;<br />
int retval;<br />
const char *p = type_spec;<br />
zval **object;<br />
zend_class_entry *ce;</p><br />
<br />
<p>if (!this_ptr) {<br />
RETURN_IF_ZERO_ARGS(num_args, p, 0);</p><br />
<br />
<p>va_start(va, type_spec);<br />
retval = zend_parse_va_args(num_args, type_spec, &amp;va, 0 TSRMLS_CC);<br />
va_end(va);<br />
} else {<br />
p++;<br />
RETURN_IF_ZERO_ARGS(num_args, p, 0);</p><br />
<br />
<p>va_start(va, type_spec);</p><br />
<br />
<p>object = va_arg(va, zval **);<br />
ce = va_arg(va, zend_class_entry *);<br />
*object = this_ptr;</p><br />
<br />
<p>if (ce &amp;&amp; !instanceof_function(Z_OBJCE_P(this_ptr), ce TSRMLS_CC)) {<br />
zend_error(E_CORE_ERROR, “%s::%s() must be derived from %s::%s”,<br />
ce-&gt;name, get_active_function_name(TSRMLS_C), Z_OBJCE_P(this_ptr)-&gt;name, get_active_function_name(TSRMLS_C));<br />
}</p><br />
<br />
<p>retval = zend_parse_va_args(num_args, p, &amp;va, 0 TSRMLS_CC);<br />
va_end(va);<br />
}<br />
return retval;</p><br />
<br />
<p>https://www.laruence.com/2009/04/28/719.html</p><br />
<br />
<p>https://www.laruence.com/2008/04/16/19.html<br />
https://www.laruence.com/2011/09/13/2139.html</p><br />
<br />
<p>https://blog.icodef.com/2018/09/25/1508</p><br />
<br />
<p>类参数<br />
其实和函数的参数一样，还有一个类似的zend_parse_method_parameters我用的时候总是错误，还没明白这个函数是干什么的，而且找不到说明的资料=_=，后面附上两个源码的区别再看看</p><br />
<br />
<p>PHP_METHOD(study_ext_class,sum)<br />
{<br />
    zend_long parma_num=0;<br />
    zval* this=getThis();<br />
    zval* static_num=zend_read_static_property(Z_OBJCE_P(this),”num”,sizeof(“num”)-1,0);<br />
    if(zend_parse_parameters(ZEND_NUM_ARGS(),”l”,&amp;parma_num)==FAILURE){<br />
        RETURN_LONG(-1)<br />
    }<br />
    if(Z_TYPE_P(static_num)==IS_LONG){<br />
        RETURN_LONG(static_num-&gt;value.lval+parma_num)<br />
    }<br />
    RETURN_LONG(-1)<br />
}<br />
ZEND_BEGIN_ARG_INFO(sum_arg,0)<br />
ZEND_ARG_INFO(0,num)<br />
ZEND_END_ARG_INFO()<br />
C<br />
探究<br />
如果我们的第二个参数this_ptr为NULL或者不是OBJECT类型的话，那么效果和zend_parse_parameters一样，我之前填的是this指针，所以跳到了else分支</p><br />
<br />
<p>else分之第一句就是p++;表示字符串往后面移动一位，我填的参数是是一个单独的 l 然后一移动….没啦，后面还有两个va_arg</p><br />
<br />
<p>通过后面这两个得知，我们的两个参数，一个是 zval 的，一个是 zend_class_entry* 我们传入的 this_ptr 参数会赋值给 object 也就是我们后面的第四个参数，第五个是我们类的指针</p><br />
<br />
<p>object = va_arg(va, zval **);<br />
ce = va_arg(va, zend_class_entry *);<br />
*object = this_ptr;<br />
C<br />
看后面这一段，好像是校验类的，所以我觉得这个zend_parse_method_parameters和zend_parse_parameters的区别就在这里，method能够对类进行校验</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if (ce &amp;&amp; !instanceof_function(Z_OBJCE_P(this_ptr), ce)) {<br />
        zend_error_noreturn(E_CORE_ERROR, "%s::%s() must be derived from %s::%s",<br />
            ZSTR_VAL(Z_OBJCE_P(this_ptr)-&gt;name), get_active_function_name(), ZSTR_VAL(ce-&gt;name), get_active_function_name());<br />
    }<br />
</code></pre></div></div><br />
<br />
<p>ZEND_API zend_bool ZEND_FASTCALL instanceof_function(const zend_class_entry <em>instance_ce, const zend_class_entry *ce) /</em> {{{ */<br />
{<br />
    if (ce-&gt;ce_flags &amp; ZEND_ACC_INTERFACE) {<br />
        return instanceof_interface(instance_ce, ce);<br />
    } else {<br />
        return instanceof_class(instance_ce, ce);<br />
    }<br />
}</p><br />
<br />
<p>static zend_always_inline zend_bool instanceof_class(const zend_class_entry <em>instance_ce, const zend_class_entry *ce) /</em> {{{ <em>/<br />
{<br />
    while (instance_ce) {<br />
        if (instance_ce == ce) {//会循环校验父类是否相等<br />
            return 1;<br />
        }<br />
        instance_ce = instance_ce-&gt;parent;<br />
    }<br />
    return 0;<br />
}<br />
C<br />
ZEND_API int zend_parse_parameters(int num_args, const char *type_spec, …) /</em> {{{ */<br />
{<br />
    va_list va;<br />
    int retval;<br />
    int flags = 0;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>va_start(va, type_spec);<br />
retval = zend_parse_va_args(num_args, type_spec, &amp;va, flags);<br />
va_end(va);<br />
<br />
return retval; } /* }}} */<br />
</code></pre></div></div><br />
<br />
<p>ZEND_API int zend_parse_method_parameters(int num_args, zval <em>this_ptr, const char *type_spec, …) /</em> {{{ */<br />
{<br />
    va_list va;<br />
    int retval;<br />
    int flags = 0;<br />
    const char *p = type_spec;<br />
    zval **object;<br />
    zend_class_entry *ce;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* Just checking this_ptr is not enough, because fcall_common_helper does not set<br />
 * Z_OBJ(EG(This)) to NULL when calling an internal function with common.scope == NULL.<br />
 * In that case EG(This) would still be the $this from the calling code and we'd take the<br />
 * wrong branch here. */<br />
zend_bool is_method = EG(current_execute_data)-&gt;func-&gt;common.scope != NULL;<br />
<br />
if (!is_method || !this_ptr || Z_TYPE_P(this_ptr) != IS_OBJECT) {<br />
    va_start(va, type_spec);<br />
    retval = zend_parse_va_args(num_args, type_spec, &amp;va, flags);<br />
    va_end(va);<br />
} else {<br />
    p++;<br />
<br />
    va_start(va, type_spec);<br />
<br />
    object = va_arg(va, zval **);<br />
    ce = va_arg(va, zend_class_entry *);<br />
    *object = this_ptr;<br />
<br />
    if (ce &amp;&amp; !instanceof_function(Z_OBJCE_P(this_ptr), ce)) {<br />
        zend_error_noreturn(E_CORE_ERROR, "%s::%s() must be derived from %s::%s",<br />
            ZSTR_VAL(Z_OBJCE_P(this_ptr)-&gt;name), get_active_function_name(), ZSTR_VAL(ce-&gt;name), get_active_function_name());<br />
    }<br />
<br />
    retval = zend_parse_va_args(num_args, p, &amp;va, flags);<br />
    va_end(va);<br />
}<br />
return retval; } /* }}} */ C 使用 这里的type_spec我还加了一个O，因为在源码中，p++;这里跳过了一个字符，那么我们后面retval = zend_parse_va_args(num_args, p, &amp;va, flags);的时候传入的就是 l 了， O 这里应该是可以乱填一个字符的<br />
</code></pre></div></div><br />
<br />
<p>&amp;this 又传回来了- -</p><br />
<br />
<p>PHP_METHOD(study_ext_class,sum)<br />
{<br />
    zend_long parma_num=0;<br />
    zval* this=getThis();<br />
    zval* static_num=zend_read_static_property(Z_OBJCE_P(this),”num”,sizeof(“num”)-1,0);<br />
    // zval<br />
    if(zend_parse_method_parameters(ZEND_NUM_ARGS(),this,”Ol”,&amp;this,study_ce,&amp;parma_num)==FAILURE){<br />
        RETURN_LONG(-1)<br />
    }<br />
    if(Z_TYPE_P(static_num)==IS_LONG){<br />
        RETURN_LONG(static_num-&gt;value.lval+parma_num)<br />
    }<br />
    RETURN_LONG(-1)</p><br />
<br />
<p>https://github.com/php/php-src/commit/8664ff7ae174c610769c36a712eeea80cc3ad933</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category php
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>