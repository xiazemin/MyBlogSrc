<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">dynasm</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-07-23T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jul 23, 2020</time></p>
					</div>
					 <p>https://luajit.org/dynasm.html</p><br />
<br />
<p>DynASM is a Dynamic Assembler for code generation engines.</p><br />
<br />
<p>DynASM has been developed primarily as a tool for LuaJIT, but might be useful for other projects, too.</p><br />
<br />
<p>If you are writing a just-in-time compiler or need to generate code on the fly (e.g. for high-performance graphics or other CPU-intensive computations), DynASM might be just what you are looking for.</p><br />
<br />
<p>Please have a look at the list of Features to find out whether DynASM could be useful for your project.</p><br />
<br />
<p>这玩意儿没啥好介绍的啊, 就是一个框架, 方便你写汇编, 核心还是要你自己学点汇编… 我们目前基于PHP7的JIT就是用的Dynasm, 有兴趣可以参考:zendtech/php-src在写这个过程中, 我只看了: The Unofficial DynASM Documentation 剩下的都是在用的时候慢慢体会…</p><br />
<br />
<p>https://www.zhihu.com/question/27199764</p><br />
<br />
<p>http://luajit.org/dynasm.html<br />
http://luajit.org/download.html</p><br />
<br />
<p>http://corsix.github.io/dynasm-doc/<br />
http://corsix.github.io/dynasm-doc/tutorial.html<br />
http://corsix.github.io/dynasm-doc/tutorial.html<br />
https://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html</p><br />
<br />
<!-- more --><br />
<p>https://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html</p><br />
<br />
<p>https://github.com/zendtech/php-src/blob/jit-dynasm/ext/opcache/jit/zend_jit_x86.dasc</p><br />
<br />
<p>http://corsix.github.io/dynasm-doc/</p><br />
<br />
<p>https://blog.reverberate.org/2012/12/hello-jit-world-joy-of-simple-jits.html</p><br />
<br />
<p>http://corsix.github.io/dynasm-doc/index.html</p><br />
<br />
<p>http://www.360doc.com/content/14/0112/21/9200790_344687869.shtml</p><br />
<br />
<p>最近正在用 DynASM, 顺便翻译了下 DynASM 非官方文档教程. DynASM 是为 luajit 编写的 JIT 汇编预处理器和微型运行时库 (简单来讲, DynASM完成两个工作, 一个是预处理, 把你写的汇编指令 (对, 没有Elixir, DynASM并不能直接把逻辑变成汇编, 需要你手动把你的逻辑用汇编语言重写一遍, 因此性能也取决于你的汇编代码写的好坏) 变成真正的二进制机器码, 另一个是提供一个微型运行时, 来处理那些必须推迟到运行时才能执行的代码).</p><br />
<br />
<p>一些C或C++编写的语言, 甚至协议解释程序 (比如正则解释器或 json 解释器) 均可以用 DynASM JIT 化来提升性能. 比如这个项目 https://github.com/openresty/sregex 就是 <br />
@agentzh<br />
 写的 JIT 化的正则解释器, 用于 nginx 的配置中的各种正则匹配.</p><br />
<br />
<p>本教程把 brainfuck 语言的解释器 (C语言实现) 用 DynASM 修改成了 brainfuck JIT 解释器, 性能提升了17倍 (运行Mandelbrot set测试).</p><br />
<br />
<p>说实话这个教程也不能太算得上”教程”, 需要理解 DynASM 的一些基础设计, 阅读并理解 brainfuck 解释器源码, 以及适当的汇编基础和了解什么是JIT. 后续我还会翻译一些简单的教程供感兴趣的同学阅读.</p><br />
<br />
<p>repo 地址: https://github.com/karminski/dynasm-doc</p><br />
<br />
<p>翻译版在: https://karminski.github.io/dynasm-doc/</p><br />
<br />
<p>原版文档在: http://corsix.github.io/dynasm-doc/</p><br />
<br />
<p>Introduction<br />
我们从brainfsck 解释器开始我们的教程:</p><br />
<br />
<p>#include <stdio.h><br />
#include <stdlib.h></stdlib.h></stdio.h></p><br />
<br />
<p>#define TAPE_SIZE 30000<br />
#define MAX_NESTING 100</p><br />
<br />
<p>typedef struct bf_state<br />
{<br />
  unsigned char* tape;<br />
  unsigned char (<em>get_ch)(struct bf_state</em>);<br />
  void (<em>put_ch)(struct bf_state</em>, unsigned char);<br />
} bf_state_t;</p><br />
<br />
<p>#define bad_program(s) exit(fprintf(stderr, “bad program near %.16s: %s\n”, program, s))</p><br />
<br />
<p>static void bf_interpret(const char* program, bf_state_t* state)<br />
{<br />
  const char* loops[MAX_NESTING];<br />
  int nloops = 0;<br />
  int n;<br />
  int nskip = 0;<br />
  unsigned char* tape_begin = state-&gt;tape - 1;<br />
  unsigned char* ptr = state-&gt;tape;<br />
  unsigned char* tape_end = state-&gt;tape + TAPE_SIZE - 1;<br />
  for(;;) {<br />
    switch(<em>program++) {<br />
    case ‘&lt;’:<br />
      for(n = 1; *program == ‘&lt;’; ++n, ++program);<br />
      if(!nskip) {<br />
        ptr -= n;<br />
        while(ptr &lt;= tape_begin)<br />
          ptr += TAPE_SIZE;<br />
      }<br />
      break;<br />
    case ‘&gt;’:<br />
      for(n = 1; *program == ‘&gt;’; ++n, ++program);<br />
      if(!nskip) {<br />
        ptr += n;<br />
        while(ptr &gt; tape_end)<br />
          ptr -= TAPE_SIZE;<br />
      }<br />
      break;<br />
    case ‘+’:<br />
      for(n = 1; *program == ‘+’; ++n, ++program);<br />
      if(!nskip)<br />
        *ptr += n;<br />
      break;<br />
    case ‘-‘:<br />
      for(n = 1; *program == ‘-‘; ++n, ++program);<br />
      if(!nskip)<br />
        *ptr -= n;<br />
      break;<br />
    case ‘,’:<br />
      if(!nskip)<br />
        *ptr = state-&gt;get_ch(state);<br />
      break;<br />
    case ‘.’:<br />
      if(!nskip)<br />
        state-&gt;put_ch(state, *ptr);<br />
      break;<br />
    case ‘[’:<br />
      if(nloops == MAX_NESTING)<br />
        bad_program(“Nesting too deep”);<br />
      loops[nloops++] = program;<br />
      if(!</em>ptr)<br />
        ++nskip;<br />
      break;<br />
    case ‘]’:<br />
      if(nloops == 0)<br />
        bad_program(“] without matching [”);<br />
      if(*ptr)<br />
        program = loops[nloops-1];<br />
      else<br />
        –nloops;<br />
      if(nskip)<br />
        –nskip;<br />
      break;<br />
    case 0:<br />
      if(nloops != 0)<br />
        program = “<EOF>", bad_program("[ without matching ]");<br />
      return;<br />
    }<br />
  }<br />
}</EOF></p><br />
<br />
<p>static void bf_putchar(bf_state_t* s, unsigned char c)<br />
{<br />
  putchar((int)c);<br />
}</p><br />
<br />
<p>static unsigned char bf_getchar(bf_state_t* s)<br />
{<br />
  return (unsigned char)getchar();<br />
}</p><br />
<br />
<p>static void bf_run(const char* program)<br />
{<br />
  bf_state_t state;<br />
  unsigned char tape[TAPE_SIZE] = {0};<br />
  state.tape = tape;<br />
  state.get_ch = bf_getchar;<br />
  state.put_ch = bf_putchar;<br />
  bf_interpret(program, &amp;state);<br />
}</p><br />
<br />
<p>int main(int argc, char** argv)<br />
{<br />
  if(argc == 2) {<br />
    long sz;<br />
    char* program;<br />
    FILE* f = fopen(argv[1], “r”);<br />
    if(!f) {<br />
      fprintf(stderr, “Cannot open %s\n”, argv[1]);<br />
      return 1;<br />
    }<br />
    fseek(f, 0, SEEK_END);<br />
    sz = ftell(f);<br />
    program = (char*)malloc(sz + 1);<br />
    fseek(f, 0, SEEK_SET);<br />
    program[fread(program, 1, sz, f)] = 0;<br />
    fclose(f);<br />
    bf_run(program);<br />
    return 0;<br />
  } else {<br />
    fprintf(stderr, “Usage: %s INFILE.bf\n”, argv[0]);<br />
    return 1;<br />
  }<br />
}<br />
我们在这个教程里, 用 DynASM 将这个 brainfuck 解释器编写成 brainfuck JIT 编译器. 来看看是否会提升运行速度.</p><br />
<br />
<p>首先, clone 这个 repo, 然后从bf_c.c开始:</p><br />
<br />
<p>git clone https://github.com/corsix/dynasm-doc.git<br />
cd dynasm-doc<br />
git submodule update –init<br />
cp bf_c.c tutorial.c<br />
我们通过运行这个程序来演示功能, 这个程序会缓慢的渲染曼德博集合(Mandelbrot set):</p><br />
<br />
<p>gcc -o tutorial tutorial.c<br />
./tutorial mandelbrot.bf<br />
(译者我的CPU是 Intel(R) Xeon(R) CPU E5-2680 v2 @ 2.80GHz, 最高 3.5GHz, 下面是输出结果, 渲染需要35.4s)</p><br />
<br />
<p>[root@m01 dynasm-doc]# time ./tutorial mandelbrot.bf<br />
AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDEGFFEEEEDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB<br />
AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB<br />
AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB<br />
AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB<br />
AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB<br />
AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB<br />
AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB<br />
AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB<br />
AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB<br />
AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB<br />
AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB<br />
AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB<br />
AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB<br />
AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB<br />
AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB<br />
AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC<br />
ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC<br />
ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC<br />
ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC<br />
A                                                                                                 PLJHGGFFEEEDDDDDDDCCCCCCCCCCCCC<br />
ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC<br />
ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC<br />
ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC<br />
AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC<br />
AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB<br />
AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB<br />
AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB<br />
AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB<br />
AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB<br />
AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB<br />
AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB<br />
AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB<br />
AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB<br />
AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB<br />
AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB<br />
AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB<br />
AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB<br />
AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB<br />
AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB</p><br />
<br />
<p>real	0m35.466s<br />
user	0m35.462s<br />
sys	0m0.002s<br />
Groundwork<br />
好戏上演之前, 我们先要做一些基础工作.</p><br />
<br />
<p>Includes<br />
首先, 我们需要 #include DynASM 的头文件:</p><br />
<br />
<p>#include “luajit-2.0/dynasm/dasm_proto.h”<br />
#include “luajit-2.0/dynasm/dasm_x86.h”<br />
正如参考文档中写的, dasm_proto.h 定义 DynASM API, dasm_x86.h 则包含了上述 API 的实现 (x86/ x64).</p><br />
<br />
<p>Types<br />
接下来, 我们将 bf_interpret 重命名为 bf_compile, 并更改它的类型定义:</p><br />
<br />
<p>static void bf_interpret(const char* program, bf_state_t* state)<br />
static void(* bf_compile(const char* program) )(bf_state_t<em>)<br />
修改前 bf_interpret 可以接受参数 const char</em> 和 bf_state_t<em>, 修改后的 bf_compile 只接受参数 const char</em> 部分, 并且返回 JIT 编译后的代码的函数指针.</p><br />
<br />
<p>bf_interpret 函数也需要修改:</p><br />
<br />
<p>bf_interpret(program, &amp;state);<br />
bf_compile(program)(&amp;state);<br />
Initialisation<br />
搞定基础工作后, 下一步就是创建和初始化一个 DynASM state.</p><br />
<br />
<p>Variables<br />
我们需要一个类型为 dasm_State* 的变量包含 DynASM state, 还需要两个其他的我们一会再解释. 并且还需要移除一个解释器变量:</p><br />
<br />
<p>int nskip = 0;<br />
dasm_State* d;<br />
unsigned npc = 8;<br />
unsigned nextpc = 0;<br />
.arch<br />
现在我们将第一次接触 DynASM 指令, 这个是 DynASM 预处理器指令. 在这里我们定义生成目标机器码的平台架构, x86 或 x64:</p><br />
<br />
<p>|.if X64<br />
|.arch x64<br />
|.else<br />
|.arch x86<br />
|.endif<br />
开头的竖线会被 DynASM 预处理器识别. .if, .else, 和 .endif 指令会被 DynASM 的预处理器处理, 处理方式与 C 语言预处理中的 #if, #else, 和 #endif. 相似, 执行结果就是只有一个 .arch 指令会生效.</p><br />
<br />
<p>dasm_init<br />
我们定义了 dasm_State*, 现在我们要分配内存空间把它装进去. 调用 dasm_init即可:</p><br />
<br />
<p>|.section code<br />
dasm_init(&amp;d, DASM_MAXSECTION);<br />
注意跟 dasm_State** 一样, dasm_init 需要一个 integer 参数, 定义生成的机器码的 section. 我们只需要一个 code section, 所以我们传入一个参数给 .section , 这样 DynASM 预处理器就会处理成 #define DASM_MAXSECTION 1 (amongst other things). 也许给 dasm_init 传 DASM_MAXSECTION 没有直接传 1 那么直观, 但是这是个好的实践, 因为说不定将来我们就会需要更多的 section.</p><br />
<br />
<p>dasm_setupglobal<br />
dasm_init 将会分配 dasm_State, 但这并不是完全的初始化. 想要初始化 state 我们还需要调用几个函数. 第一个就是 dasm_setupglobal:</p><br />
<br />
<p>|.globals lbl_<br />
void* labels[lbl__MAX];<br />
dasm_setupglobal(&amp;d, labels, lbl__MAX);<br />
带者参数 lbl_ 的 .globals 指令会被 DynASM 预处理为一个包含一些结构的 enum 类型, 其中一个是 lbl__MAX. 这个值必须与相同长度的 void* 数组传入到 dasm_setupglobal, 后续我们将使用 labels 数组.</p><br />
<br />
<p>dasm_setup<br />
接下来在初始化过程调用的是 dasm_setup:</p><br />
<br />
<p>|.actionlist bf_actions<br />
dasm_setup(&amp;d, bf_actions);<br />
带 bf_actions 参数的 .actionlist 指令会被 DynASM 预处理器重写为 bf_actions 变量, 并且需要传入到 dasm_setup.</p><br />
<br />
<p>dasm_growpc<br />
正常情况下 dasm_State 在这个节点已经完全初始化. 不过由于我们还要用动态 labels, 所以还要调用 dasm_growpc 再初始化一下:</p><br />
<br />
<p>dasm_growpc(&amp;d, npc);<br />
我们传入了之前定义的 npc 参数, 这个参数代表动态 lable 的数量. 还有个依赖的变量叫 nextpc 是用来记录我们使用的 lable 的数量的. 这些动态 lable 将在我们编译 [ 和 ] 时起作用.</p><br />
<br />
<p>Abstractions<br />
在我们执行机器码之前, 先定义一些抽象(abstraction), 先定义一些让寄存器更具有意义的抽象概念:</p><br />
<br />
<p>AbstractionCorresponding Interpreter VariableDefinitionaStatestateebxorrbxaPtrptrebporr12aTapeBegintape_beginesiorrsiorr13aTapeEndtape_endediorrdiorr14</p><br />
<br />
<p>接下来再定义一些函数调用:</p><br />
<br />
<p>AbstractionDescriptionprologueSet up the stack frame, and setaStatefrom the passed parameter.prepcall1 arg1Prepare to call a function with one argument,arg1.prepcall2 arg1, arg2Prepare to call a function with two arguments,arg1andarg2.postcall nDo cleanup after a call to a function withnarguments.epilogueTear down the stack frame.</p><br />
<br />
<p>这些定义都是通过 .define (通常情况下) 或 .macro (更复杂情况下), 并且 x86, x64 POSIX, x64 Windows 下的定义也有所不同:</p><br />
<br />
<p>|.if X64<br />
  |.define aPtr, rbx<br />
  |.define aState, r12<br />
  |.if WIN<br />
    |.define aTapeBegin, rsi<br />
    |.define aTapeEnd, rdi<br />
    |.define rArg1, rcx<br />
    |.define rArg2, rdx<br />
  |.else<br />
    |.define aTapeBegin, r13<br />
    |.define aTapeEnd, r14<br />
    |.define rArg1, rdi<br />
    |.define rArg2, rsi<br />
  |.endif<br />
  |.macro prepcall1, arg1<br />
    | mov rArg1, arg1<br />
  |.endmacro<br />
  |.macro prepcall2, arg1, arg2<br />
    | mov rArg1, arg1<br />
    | mov rArg2, arg2<br />
  |.endmacro<br />
  |.define postcall, .nop<br />
  |.macro prologue<br />
    | push aPtr<br />
    | push aState<br />
    | push aTapeBegin<br />
    | push aTapeEnd<br />
    | push rax<br />
    | mov aState, rArg1<br />
  |.endmacro<br />
  |.macro epilogue<br />
    | pop rax<br />
    | pop aTapeEnd<br />
    | pop aTapeBegin<br />
    | pop aState<br />
    | pop aPtr<br />
    | ret<br />
  |.endmacro<br />
|.else<br />
  |.define aPtr, ebx<br />
  |.define aState, ebp<br />
  |.define aTapeBegin, esi<br />
  |.define aTapeEnd, edi<br />
  |.macro prepcall1, arg1<br />
    | push arg1<br />
  |.endmacro<br />
  |.macro prepcall2, arg1, arg2<br />
    | push arg2<br />
    | push arg1<br />
  |.endmacro<br />
  |.macro postcall, n<br />
    | add esp, 4*n<br />
  |.endmacro<br />
  |.macro prologue<br />
    | push aPtr<br />
    | push aState<br />
    | push aTapeBegin<br />
    | push aTapeEnd<br />
    | mov aState, [esp+20]<br />
  |.endmacro<br />
  |.macro epilogue<br />
    | pop aTapeEnd<br />
    | pop aTapeBegin<br />
    | pop aState<br />
    | pop aPtr<br />
    | ret 4<br />
  |.endmacro<br />
|.endif<br />
为 DynASM 定义了所有这些体系结构和系统有关的定义之后, 还需要检查这些为 DynASM 指定的体系结构和系统是否与 C 预处理器已知的这些是否相匹配:</p><br />
<br />
<p>||#if ((defined(_M_X64) || defined(<strong>amd64</strong>)) != X64) || (defined(_WIN32) != WIN)<br />
#error “Wrong DynASM flags used: pass <code class="language-plaintext highlighter-rouge">-D X64</code> and/or <code class="language-plaintext highlighter-rouge">-D WIN</code> to dynasm.lua as appropriate”<br />
#endif<br />
这些以两条竖线开头的将由 DynASM 预处理器替换为 .define (同样如果有的话也可以替换为 .macro), 但其他的不会被 DynASM 预处理器更改. 在特定情况下, 如果 X64 和/或 WIN 在 DynASM 预处理时被定义 (这里为 1) 那么就会被替换成 1.如果在 DynASM 预处理时没有被定义, 那就会保持原样, 并由 C 预处理器替换为 0 .</p><br />
<br />
<p>Emitting Code<br />
完成所有这些操作之后，我们终于可以执行一些机器码了.</p><br />
<br />
<p>Prologue<br />
我们首先要执行的是一些初始化代码, 这些代码替换了一部分之前的解释器的代码:</p><br />
<br />
<p>unsigned char* tape_begin = state-&gt;tape - 1;<br />
unsigned char* ptr = state-&gt;tape;<br />
unsigned char* tape_end = state-&gt;tape + TAPE_SIZE - 1;<br />
|.type state, bf_state_t, aState</p><br />
<br />
<p>dasm_State** Dst = &amp;d;<br />
|.code<br />
|-&gt;bf_main:<br />
| prologue<br />
| mov aPtr, state-&gt;tape<br />
| lea aTapeBegin, [aPtr-1]<br />
| lea aTapeEnd, [aPtr+TAPE_SIZE-1]<br />
我们首先看 .type 指令, 这个指令可以让我们用 state-&gt;tape 作为速记符来表达 [aState + offsetof(bf_state_t,tape)].</p><br />
<br />
<p>接下来这一行定义了 Dst, 并且用 &amp;d 初始化. 这样做是因为DynASM预处理器将把后续行重写为 dasm_put(Dst, …)形式的调用, 并且跟我们之前处理那些 dasm_ 函数一样, 第一个参数需要是 &amp;d.</p><br />
<br />
<p>接下来是包含 .code 这一行. 这里指代的指令由先前的 .section code 指令引入, 并且执行的 states 需要放到 code section (这也正好是我们在处理的部分).</p><br />
<br />
<p>再之后我们定义了 -&gt;bf_main. 当我们执行完机器码后, 就可以获取这个 global lable 的地址, 并且转换为函数指针.</p><br />
<br />
<p>然后, 我们调用前面定义的 prologue 宏, 执行那些指令.</p><br />
<br />
<p>最后这几行是 mov 和 lea 指令, 对应删掉的那几行解释器的代码. 像刚才说的那样, state-&gt;tape 变成操作数 mov 最终执行的是 [aState + offsetof(bf_state_t,tape)]. 注意 offsetof(bf_state_t,tape) 和 TAPE_SIZE-1 (lea 操作数的一部分) 是所谓的编码时常量: DynASM 并不知道这是什么, 所以到 C 编译器中才会计算. 这两个值都是 C 语言中的编译时常量, 编码时常量不必是编译时常量 (稍后有例子解释).</p><br />
<br />
<p>Tape Movement<br />
现在进入解释器阶段, 首要任务是将解释 &lt; 部分的代码替换掉:</p><br />
<br />
<p>if(!nskip) {<br />
  ptr -= n;<br />
  while(ptr &lt;= tape_begin)<br />
    ptr += TAPE_SIZE;<br />
}<br />
| sub aPtr, n%TAPE_SIZE<br />
| cmp aPtr, aTapeBegin<br />
| ja &gt;1<br />
| add aPtr, TAPE_SIZE<br />
|1:<br />
注意，编译器没有像解释器那样跳过代码的概念, 所以把上面的 if 部分完全删除了. ptr -= n; 和下面的循环都变成了 | sub aPtr, n%TAPE_SIZE. Note that n%TAPE_SIZE 则是一个 编码阶段常量, 不是一个C编译阶段常量:DynASM 也不理解操作数的意义. 但是在这种情况下，当 bf_compile 最终运行时会计算操作数的最终值.</p><br />
<br />
<p>编译时当循环过 %TAPE_SIZE, 定义的周期后, 在运行时可能仍然需要执行一次迭代, 这是因为还有 cmp, ja, 和 add 指令. 注意语句 &gt;1 跳转到定义 lable 1 的位置, 即 add 的下一行.</p><br />
<br />
<blockquote><br />
  <p>操作符也一样, 只不过是 add 和 sub 这部分倒过来:</p><br />
</blockquote><br />
<br />
<p>if(!nskip) {<br />
  ptr += n;<br />
  while(ptr &gt; tape_end)<br />
    ptr -= TAPE_SIZE;<br />
}<br />
| add aPtr, n%TAPE_SIZE<br />
| cmp aPtr, aTapeEnd<br />
| jbe &gt;1<br />
| sub aPtr, TAPE_SIZE<br />
|1:<br />
Arithmetic<br />
接下来要改写的指令是 +, 相对简单:</p><br />
<br />
<p>if(!nskip)<br />
  *ptr += n;<br />
| add byte [aPtr], n<br />
值得注意的只有内存操作符 [aPtr] 前面的内存大小描述符 byte. 因为内存操作数和立即操作数都不具有真实的操作数大小, 所以需要明确告知 DynASM. 请注意，我们先前使用的内存操作数不需要内存大小说明符: lea 指令并不需要, 内存操作数并不是内存访问. 并且 mov aPtr, state-&gt;tape 也不需要, 因为可以根据寄存器操作数的大小推断出内存操作数的大小. 他们是相等的.</p><br />
<br />
<ul><br />
  <li>指令也一样:</li><br />
</ul><br />
<br />
<p>if(!nskip)<br />
  *ptr -= n;<br />
| sub byte [aPtr], n<br />
I/O<br />
接下来是 , (read char) 和 . (write char), 值得注意的是它们需要调用其他函数. 首先是 ,:</p><br />
<br />
<p>if(!nskip)<br />
  *ptr = state-&gt;get_ch(state);<br />
| prepcall1 aState<br />
| call aword state-&gt;get_ch<br />
| postcall 1<br />
| mov byte [aPtr], al<br />
注意调用的抽象定义 prepcall1 和 postcall 我们之前定义过了. 同时也要注意 state-&gt;get_ch 是 [aState + offsetof(bf_state_t,get_ch)] 的速记表述, 之前介绍 .type 的时候我们说过了. 并且使用这些速记符号的时候仍然需要内存大小说明符. 内存操作数的大小不会自动推断为同等大小的 C 语言同名结构体成员. aword (address-sized word) 说明符指的是 4 字节 x86 或 8 字节 x64.</p><br />
<br />
<p>. 的转换也一样:</p><br />
<br />
<p>if(!nskip)<br />
  state-&gt;put_ch(state, *ptr);<br />
| movzx r0, byte [aPtr]<br />
| prepcall2 aState, r0<br />
| call aword state-&gt;put_ch<br />
| postcall 2<br />
注意 r0 用作寄存器操作数: 指的是 eax x86 或 rax x64.</p><br />
<br />
<p>Loops<br />
现在轮到了最有趣的指令: [ 和 ]. 其中 [ 相当复杂:</p><br />
<br />
<p>loops[nloops++] = program;<br />
if(!*ptr)<br />
  ++nskip;<br />
if(program[0] == ‘-‘ &amp;&amp; program[1] == ‘]’) {<br />
  program += 2;<br />
  | xor eax, eax<br />
  | mov byte [aPtr], al<br />
} else {<br />
  if(nextpc == npc) {<br />
    npc *= 2;<br />
    dasm_growpc(&amp;d, npc);<br />
  }<br />
  | cmp byte [aPtr], 0<br />
  | jz =&gt;nextpc+1<br />
  |=&gt;nextpc:<br />
  loops[nloops++] = nextpc;<br />
  nextpc += 2;<br />
}<br />
首先, 我们识别指令 [-] 并为其生成优化后的机器码. 但要排除特殊情况, 一般情况下需要两个动态标签: 一个需要从 [ 跳到 ] 的后面 (之前是通过解释器中的 nskip 实现的), 另一个是从 ] 跳到 [ 的后面 (之前是通过 loops 的栈实现的).</p><br />
<br />
<p>如果我们已经用了我们分配的数量的动态 lable, 还可以调用 dasm_growpc 继续分配.然后我们发出 cmp 指令, 它的作用正如其字面意义. 如果 [aPtr] 中的 byte 是 0, 我们跳到动态 =&gt;nextpc+1 (我们在稍后的 ] 操作符的逻辑中定义). 然后, 我们定义动态 label =&gt;nextpc (] 需要跳回的地方). 注意 nextpc+1 和 nextpc 是编码时常量.</p><br />
<br />
<p>然后是 ]:</p><br />
<br />
<p>if(*ptr)<br />
  program = loops[nloops-1];<br />
else<br />
  –nloops;<br />
if(nskip)<br />
  –nskip;<br />
–nloops;<br />
| cmp byte [aPtr], 0<br />
| jnz =&gt;loops[nloops]<br />
|=&gt;loops[nloops]+1:<br />
注意条件跳转到动态 label =&gt;loops[nloops] (相应的在 [ 的定义是跳转到 =&gt;nextpc), 然后动态 label =&gt;loops[nloops]+1 (相应的在 [ 中的定义是跳转到 jz =&gt;nextpc+1).</p><br />
<br />
<p>Epilogue<br />
涵盖了所有指令之后，剩下的就是收尾并从 DynASM 中提取函数指针:</p><br />
<br />
<p>return;<br />
| epilogue<br />
link_and_encode(&amp;d);<br />
dasm_free(&amp;d);<br />
return (void(<em>)(bf_state_t</em>))labels[lbl_bf_main];<br />
第一行调用了我们定义的 epilogue 宏. 下一行调用 link_and_encode, 一会给出. 然后调用 dasm_free, 用来释放 DynASM state. 最后, 我们将之前定义的 labels 数组传递到 dasm_setupglobal, 数组的索引是 lbl_bf_main (由 .globals lbl_ 定义, 并与全局标签 -&gt;bf_main 对应), 并将其转换为函数指针.</p><br />
<br />
<p>link_and_encode 函数的定义如下:</p><br />
<br />
<p>#if _WIN32<br />
#include <Windows.h><br />
#else<br />
#include &lt;sys/mman.h&gt;<br />
#if !defined(MAP_ANONYMOUS) &amp;&amp; defined(MAP_ANON)<br />
#define MAP_ANONYMOUS MAP_ANON<br />
#endif<br />
#endif</Windows.h></p><br />
<br />
<p>static void* link_and_encode(dasm_State** d)<br />
{<br />
  size_t sz;<br />
  void* buf;<br />
  dasm_link(d, &amp;sz);<br />
#ifdef _WIN32<br />
  buf = VirtualAlloc(0, sz, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);<br />
#else<br />
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);<br />
#endif<br />
  dasm_encode(d, buf);<br />
#ifdef _WIN32<br />
  {DWORD dwOld; VirtualProtect(buf, sz, PAGE_EXECUTE_READ, &amp;dwOld); }<br />
#else<br />
  mprotect(buf, sz, PROT_READ | PROT_EXEC);<br />
#endif<br />
  return buf;<br />
}<br />
值得注意的是dasm_link 和 dasm_encode 调用. 其余的函数调用使用操作系统功能来分配一个 读-写 内存块, 然后将其转换为 读-执行. 注意, 我们可以分配一个 读-写-执行 内存块, 但是通常同时具有可写和可执行的内存不是好的的形式.</p><br />
<br />
<p>Compiling<br />
根据上面的教程, 现在 tutorial.c 是这个样子的:</p><br />
<br />
<p>||#if ((defined(_M_X64) || defined(<strong>amd64</strong>)) != X64) || (defined(_WIN32) != WIN)<br />
#error “Wrong DynASM flags used: pass <code class="language-plaintext highlighter-rouge">-D X64</code> and/or <code class="language-plaintext highlighter-rouge">-D WIN</code> to dynasm.lua as appropriate”<br />
#endif<br />
#include <stdio.h><br />
#include <stdlib.h><br />
#include "luajit-2.0/dynasm/dasm_proto.h"<br />
#include "luajit-2.0/dynasm/dasm_x86.h"<br />
#if _WIN32<br />
#include <Windows.h><br />
#else<br />
#include &lt;sys/mman.h&gt;<br />
#if !defined(MAP_ANONYMOUS) &amp;&amp; defined(MAP_ANON)<br />
#define MAP_ANONYMOUS MAP_ANON<br />
#endif<br />
#endif</Windows.h></stdlib.h></stdio.h></p><br />
<br />
<p>static void* link_and_encode(dasm_State** d)<br />
{<br />
  size_t sz;<br />
  void* buf;<br />
  dasm_link(d, &amp;sz);<br />
#ifdef _WIN32<br />
  buf = VirtualAlloc(0, sz, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);<br />
#else<br />
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);<br />
#endif<br />
  dasm_encode(d, buf);<br />
#ifdef _WIN32<br />
  {DWORD dwOld; VirtualProtect(buf, sz, PAGE_EXECUTE_READ, &amp;dwOld); }<br />
#else<br />
  mprotect(buf, sz, PROT_READ | PROT_EXEC);<br />
#endif<br />
  return buf;<br />
}</p><br />
<br />
<p>#define TAPE_SIZE 30000<br />
#define MAX_NESTING 100</p><br />
<br />
<p>typedef struct bf_state<br />
{<br />
  unsigned char* tape;<br />
  unsigned char (<em>get_ch)(struct bf_state</em>);<br />
  void (<em>put_ch)(struct bf_state</em>, unsigned char);<br />
} bf_state_t;</p><br />
<br />
<p>#define bad_program(s) exit(fprintf(stderr, “bad program near %.16s: %s\n”, program, s))</p><br />
<br />
<p>static void(* bf_compile(const char* program) )(bf_state_t<em>)<br />
{<br />
  unsigned loops[MAX_NESTING];<br />
  int nloops = 0;<br />
  int n;<br />
  dasm_State</em> d;<br />
  unsigned npc = 8;<br />
  unsigned nextpc = 0;<br />
  |.if X64<br />
  |.arch x64<br />
  |.else<br />
  |.arch x86<br />
  |.endif<br />
  |.section code<br />
  dasm_init(&amp;d, DASM_MAXSECTION);<br />
  |.globals lbl_<br />
  void* labels[lbl__MAX];<br />
  dasm_setupglobal(&amp;d, labels, lbl__MAX);<br />
  |.actionlist bf_actions<br />
  dasm_setup(&amp;d, bf_actions);<br />
  dasm_growpc(&amp;d, npc);<br />
  |.if X64<br />
    |.define aPtr, rbx<br />
    |.define aState, r12<br />
    |.if WIN<br />
      |.define aTapeBegin, rsi<br />
      |.define aTapeEnd, rdi<br />
      |.define rArg1, rcx<br />
      |.define rArg2, rdx<br />
    |.else<br />
      |.define aTapeBegin, r13<br />
      |.define aTapeEnd, r14<br />
      |.define rArg1, rdi<br />
      |.define rArg2, rsi<br />
    |.endif<br />
    |.macro prepcall1, arg1<br />
      | mov rArg1, arg1<br />
    |.endmacro<br />
    |.macro prepcall2, arg1, arg2<br />
      | mov rArg1, arg1<br />
      | mov rArg2, arg2<br />
    |.endmacro<br />
    |.define postcall, .nop<br />
    |.macro prologue<br />
      | push aPtr<br />
      | push aState<br />
      | push aTapeBegin<br />
      | push aTapeEnd<br />
      | push rax<br />
      | mov aState, rArg1<br />
    |.endmacro<br />
    |.macro epilogue<br />
      | pop rax<br />
      | pop aTapeEnd<br />
      | pop aTapeBegin<br />
      | pop aState<br />
      | pop aPtr<br />
      | ret<br />
    |.endmacro<br />
  |.else<br />
    |.define aPtr, ebx<br />
    |.define aState, ebp<br />
    |.define aTapeBegin, esi<br />
    |.define aTapeEnd, edi<br />
    |.macro prepcall1, arg1<br />
      | push arg1<br />
    |.endmacro<br />
    |.macro prepcall2, arg1, arg2<br />
      | push arg2<br />
      | push arg1<br />
    |.endmacro<br />
    |.macro postcall, n<br />
      | add esp, 4*n<br />
    |.endmacro<br />
    |.macro prologue<br />
      | push aPtr<br />
      | push aState<br />
      | push aTapeBegin<br />
      | push aTapeEnd<br />
      | mov aState, [esp+20]<br />
    |.endmacro<br />
    |.macro epilogue<br />
      | pop aTapeEnd<br />
      | pop aTapeBegin<br />
      | pop aState<br />
      | pop aPtr<br />
      | ret 4<br />
    |.endmacro<br />
  |.endif</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>.type state, bf_state_t, aState</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>dasm_State** Dst = &amp;d;<br />
  |.code<br />
  |-&gt;bf_main:<br />
  | prologue<br />
  | mov aPtr, state-&gt;tape<br />
  | lea aTapeBegin, [aPtr-1]<br />
  | lea aTapeEnd, [aPtr+TAPE_SIZE-1]<br />
  for(;;) {<br />
    switch(*program++) {<br />
    case ‘&lt;’:<br />
      for(n = 1; *program == ‘&lt;’; ++n, ++program);<br />
      | sub aPtr, n%TAPE_SIZE<br />
      | cmp aPtr, aTapeBegin<br />
      | ja &gt;1<br />
      | add aPtr, TAPE_SIZE<br />
      |1:<br />
      break;<br />
    case ‘&gt;’:<br />
      for(n = 1; *program == ‘&gt;’; ++n, ++program);<br />
      | add aPtr, n%TAPE_SIZE<br />
      | cmp aPtr, aTapeEnd<br />
      | jbe &gt;1<br />
      | sub aPtr, TAPE_SIZE<br />
      |1:<br />
      break;<br />
    case ‘+’:<br />
      for(n = 1; *program == ‘+’; ++n, ++program);<br />
      | add byte [aPtr], n<br />
      break;<br />
    case ‘-‘:<br />
      for(n = 1; *program == ‘-‘; ++n, ++program);<br />
      | sub byte [aPtr], n<br />
      break;<br />
    case ‘,’:<br />
      | prepcall1 aState<br />
      | call aword state-&gt;get_ch<br />
      | postcall 1<br />
      | mov byte [aPtr], al<br />
      break;<br />
    case ‘.’:<br />
      | movzx r0, byte [aPtr]<br />
      | prepcall2 aState, r0<br />
      | call aword state-&gt;put_ch<br />
      | postcall 2<br />
      break;<br />
    case ‘[’:<br />
      if(nloops == MAX_NESTING)<br />
        bad_program(“Nesting too deep”);<br />
      if(program[0] == ‘-‘ &amp;&amp; program[1] == ‘]’) {<br />
        program += 2;<br />
        | xor eax, eax<br />
        | mov byte [aPtr], al<br />
      } else {<br />
        if(nextpc == npc) {<br />
          npc *= 2;<br />
          dasm_growpc(&amp;d, npc);<br />
        }<br />
        | cmp byte [aPtr], 0<br />
        | jz =&gt;nextpc+1<br />
        |=&gt;nextpc:<br />
        loops[nloops++] = nextpc;<br />
        nextpc += 2;<br />
      }<br />
      break;<br />
    case ‘]’:<br />
      if(nloops == 0)<br />
        bad_program(“] without matching [”);<br />
      –nloops;<br />
      | cmp byte [aPtr], 0<br />
      | jnz =&gt;loops[nloops]<br />
      |=&gt;loops[nloops]+1:<br />
      break;<br />
    case 0:<br />
      if(nloops != 0)<br />
        program = “<EOF>", bad_program("[ without matching ]");<br />
      | epilogue<br />
      link_and_encode(&amp;d);<br />
      dasm_free(&amp;d);<br />
      return (void(*)(bf_state_t*))labels[lbl_bf_main];<br />
    }<br />
  }<br />
}</EOF></p><br />
<br />
<p>static void bf_putchar(bf_state_t* s, unsigned char c)<br />
{<br />
  putchar((int)c);<br />
}</p><br />
<br />
<p>static unsigned char bf_getchar(bf_state_t* s)<br />
{<br />
  return (unsigned char)getchar();<br />
}</p><br />
<br />
<p>static void bf_run(const char* program)<br />
{<br />
  bf_state_t state;<br />
  unsigned char tape[TAPE_SIZE] = {0};<br />
  state.tape = tape;<br />
  state.get_ch = bf_getchar;<br />
  state.put_ch = bf_putchar;<br />
  bf_compile(program)(&amp;state);<br />
}</p><br />
<br />
<p>int main(int argc, char** argv)<br />
{<br />
  if(argc == 2) {<br />
    long sz;<br />
    char* program;<br />
    FILE* f = fopen(argv[1], “r”);<br />
    if(!f) {<br />
      fprintf(stderr, “Cannot open %s\n”, argv[1]);<br />
      return 1;<br />
    }<br />
    fseek(f, 0, SEEK_END);<br />
    sz = ftell(f);<br />
    program = (char*)malloc(sz + 1);<br />
    fseek(f, 0, SEEK_SET);<br />
    program[fread(program, 1, sz, f)] = 0;<br />
    fclose(f);<br />
    bf_run(program);<br />
    return 0;<br />
  } else {<br />
    fprintf(stderr, “Usage: %s INFILE.bf\n”, argv[0]);<br />
    return 1;<br />
  }<br />
}<br />
如果没跟上, 还可以从这里获取代码:</p><br />
<br />
<p>git clone https://github.com/corsix/dynasm-doc.git<br />
cd dynasm-doc<br />
git submodule update –init<br />
cp bf_dynasm.c tutorial.c<br />
为了编译 tutorial.c, 我们首先需要通过 DynASM 预处理程序运行它. 预处理器是用 Lua 编写的, 因此我们首先编译一个 minimal Lua 解释器 (如果有luajit也可以直接用luajit运行dynasm.lua, 就可以省略这一步):</p><br />
<br />
<p>gcc -o minilua luajit-2.0/src/host/minilua.c<br />
然后运行 DynASM 预处理器:</p><br />
<br />
<p>./minilua luajit-2.0/dynasm/dynasm.lua -o tutorial.posix64.c -D X64 tutorial.c<br />
完成预处理后, 调用 C 编译器:</p><br />
<br />
<p>gcc -o tutorial tutorial.posix64.c<br />
然后, 我们可以运行生成的可执行文件, 该可执行文件将很快运行 Mandelbrot set:</p><br />
<br />
<p>./tutorial mandelbrot.bf<br />
(译者我的运行结果, 2.129s, 源程序是 35.466s, 耗时是原来的 6%, 性能提升了17倍)</p><br />
<br />
<p>[root@m01 dynasm-doc]# time ./tutorial mandelbrot.bf<br />
AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDEGFFEEEEDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB<br />
AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB<br />
AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB<br />
AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB<br />
AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB<br />
AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB<br />
AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB<br />
AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB<br />
AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB<br />
AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB<br />
AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB<br />
AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB<br />
AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB<br />
AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB<br />
AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB<br />
AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC<br />
ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC<br />
ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC<br />
ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC<br />
A                                                                                                 PLJHGGFFEEEDDDDDDDCCCCCCCCCCCCC<br />
ADEEEEFFFGHIGGGGGGHHHHIJJLNY                                                                        TJHGFFEEEDDDDDDDCCCCCCCCCCCCC<br />
ACDDDDDDDDDDEFFFFFFFGGGGHIKZOOPPS                                                                      HGFEEEDDDDDDCCCCCCCCCCCCCC<br />
ABCDDDDDDDDDDDEEEEEFFFFFGIPJIIJKMQ                   VX                                                 HFFEEDDDDDDCCCCCCCCCCCCCC<br />
AACCDDDDDDDDDDDDEEEEEEEEEFGGGHHKONSZ                QPR                                                NJGFEEDDDDDDCCCCCCCCCCCCCC<br />
AACCCDDDDDDDDDDDDDEEEEEEEEEFGGGHIJMR              RMLMN                                                 NTFEEDDDDDDCCCCCCCCCCCCCB<br />
AABCCCCCDDDDDDDDDDDDEEEEEEEFFGGHIJKOU  O O   PR LLJJJKL                                                OIHFFEDDDDDCCCCCCCCCCCCCCB<br />
AABCCCCCCCCDDDDDDDDDDDEEEEEEFFFHKQMRKNJIJLVS JJKIIIIIIJLR                                               YNHFEDDDDDCCCCCCCCCCCCCBB<br />
AAABCCCCCCCCCCCDDDDDDDDDDEEEEFFHLKHHGGGGHHMJHGGGGGGHHHIKRR                                           UQ L HFEDDDDCCCCCCCCCCCCCCBB<br />
AAABCCCCCCCCCCCCCCCCCDDDDDDDEEFJIHFFFFFFFFFFFFFFGGGGGGHIJN                                            JHHGFEEDDDDCCCCCCCCCCCCCBBB<br />
AAAABCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEEFFFFFFGGHYV RQU                                     QMJHGGFEEEDDDCCCCCCCCCCCCCBBBB<br />
AAAABBCCCCCCCCCCCCCCCCCCCCCCCCCDDDDEEEEEEEEEEEEEEEFFFFFFGHIJKLOT                                     [JGFFEEEDDCCCCCCCCCCCCCBBBBB<br />
AAAAABBCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDEEEEEEEEEEEEFFFFFGHHIN                                 Q     UMWGEEEDDDCCCCCCCCCCCCBBBBBB<br />
AAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDEEEEEEEEEFFFFGH O    TN S                       NKJKR LLQMNHEEDDDCCCCCCCCCCCCBBBBBBB<br />
AAAAAABBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDEEEEEEFFGHK   MKJIJO  N R  X      YUSR PLV LHHHGGHIOJGFEDDDCCCCCCCCCCCCBBBBBBBB<br />
AAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEEFGGHIIHHHHHIIIJKMR        VMKJIHHHGFFFFFFGSGEDDDDCCCCCCCCCCCCBBBBBBBBB<br />
AAAAAAABBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEFFFFFFGGGGHIKP           KHHGGFFFFEEEEEEDDDDDCCCCCCCCCCCBBBBBBBBBBB<br />
AAAAAAAABBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEFFFFFGGHJLZ         UKHGFFEEEEEEEEDDDDDCCCCCCCCCCCCBBBBBBBBBBBB<br />
AAAAAAAAABBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGQPUVOTY   ZQL[MHFEEEEEEEDDDDDDDCCCCCCCCCCCBBBBBBBBBBBBBB<br />
AAAAAAAAAABBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDEEEEEEFFGHIJKS  X KHHGFEEEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAABBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEEFGGHHIKPPKIHGFFEEEDDDDDDDDDCCCCCCCCCCBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAAABBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDEEEEEFFGHIMTKLZOGFEEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAAAABBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDEEEEFFFI KHGGGHGEDDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBB<br />
AAAAAAAAAAAAAAABBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDEEEFGIIGFFEEEDDDDDDDDCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBB<br />
real 0m2.129s<br />
user 0m2.126s<br />
sys 0m0.003s</p><br />
<br />
<p>https://github.com/openresty/sregex</p><br />
<br />
<p>https://blog.csdn.net/weixin_34009794/article/details/92320734</p><br />
<br />
<p>https://www.jianshu.com/p/a1f394aba9b2</p><br />
<br />
<p>http://luajit.org/dynasm_examples.html</p><br />
<br />
<p>http://www.digimons.net/digimon/dynasmon/index.html</p><br />
<br />
<p>https://blog.codingnow.com/2006/02/lua_51_final_release.html</p><br />
<br />
<p>HHVM 是 Facebook 开发的高性能 PHP 虚拟机，宣称比官方的快9倍，我很好奇，于是抽空简单了解了一下，并整理出这篇文章，希望能回答清楚两方面的问题：</p><br />
<br />
<p>HHVM 到底靠谱么？是否可以用到产品中？</p><br />
<br />
<p>它为什么比官方的 PHP 快很多？到底是如何优化的？</p><br />
<br />
<p>你会怎么做？<br />
在讨论 HHVM 实现原理前，我们先设身处地想想：假设你有个 PHP 写的网站遇到了性能问题，经分析后发现很大一部分资源就耗在 PHP 上，这时你会怎么优化 PHP 性能？</p><br />
<br />
<p>比如可以有以下几种方式：</p><br />
<br />
<p>方案1，迁移到性能更好的语言上，如 Java、C++、Go。</p><br />
<br />
<p>方案2，通过 RPC 将功能分离出来用其它语言实现，让 PHP 做更少的事情，比如 Twitter 就将大量业务逻辑放到了 Scala 中，前端的 Rails 只负责展现。</p><br />
<br />
<p>方案3，写 PHP 扩展，在性能瓶颈地方换 C/C++。</p><br />
<br />
<p>方案4，优化 PHP 的性能。</p><br />
<br />
<p>方案1几乎不可行，十年前 Joel 就拿 Netscape 的例子警告过，你将放弃是多年的经验积累，尤其是像 Facebook 这种业务逻辑复杂的产品，PHP 代码实在太多了，据称有2千万行（引用自 [PHP on the Metal with HHVM]），修改起来的成本恐怕比写个虚拟机还大，而且对于一个上千人的团队，从头开始学习也是不可接受的。</p><br />
<br />
<p>方案2是最保险的方案，可以逐步迁移，事实上 Facebook 也在朝这方面努力了，而且还开发了 Thrift 这样的 RPC 解决方案，Facebook 内部主要使用的另一个语言是 C++，从早期的 Thrift 代码就能看出来，因为其它语言的实现都很简陋，没法在生产环境下使用。</p><br />
<br />
<p>目前在 Facebook 中据称 PHP:C++ 已经从 9:1 增加到 7:3 了，加上有 Andrei Alexandrescu 的存在，C++ 在 Facebook 中越来越流行，但这只能解决部分问题，毕竟 C++ 开发成本比 PHP 高得多，不适合用在经常修改的地方，而且太多 RPC 的调用也会严重影响性能。</p><br />
<br />
<p>方案3看起来美好，实际执行起来却很难，一般来说性能瓶颈并不会很显著，大多是不断累加的结果，加上 PHP 扩展开发成本高，这种方案一般只用在公共且变化不大的基础库上，所以这种方案解决不了多少问题。</p><br />
<br />
<p>可以看到，前面3个方案并不能很好地解决问题，所以 Facebook 其实没有选择的余地，只能去考虑 PHP 本身的优化了。</p><br />
<br />
<p>更快的 PHP<br />
既然要优化 PHP，那如何去优化呢？在我看来可以有以下几种方法：</p><br />
<br />
<p>方案1，PHP 语言层面的优化。</p><br />
<br />
<p>方案2，优化 PHP 的官方实现（也就是 Zend）。</p><br />
<br />
<p>方案3，将 PHP 编译成其它语言的 bytecode（字节码），借助其它语言的虚拟机（如 JVM）来运行。</p><br />
<br />
<p>方案4，将 PHP 转成 C/C++，然后编译成本地代码。</p><br />
<br />
<p>方案5，开发更快的 PHP 虚拟机。</p><br />
<br />
<p>PHP 语言层面的优化是最简单可行的，Facebook 当然想到了，而且还开发了 XHProf 这样的性能分析工具，对于定位性能瓶颈是很有帮助的。</p><br />
<br />
<p>不过 XHProf 还是没能很好解决 Facebook 的问题，所以我们继续看，接下来是方案2，简单来看，Zend 的执行过程可以分为两部分：将 PHP 编译为 opcode、执行 opcode，所以优化 Zend 可以从这两方面来考虑。</p><br />
<br />
<p>优化 opcode 是一种常见的做法，可以避免重复解析 PHP，而且还能做一些静态的编译优化，比如 Zend Optimizer Plus，但由于 PHP 语言的动态性，这种优化方法是有局限性的，乐观估计也只能提升20%的性能。另一种考虑是优化 opcode 架构本身，如基于寄存器的方式，但这种做法修改起来工作量太大，性能提升也不会特别明显（可能30%？），所以投入产出比不高。</p><br />
<br />
<p>另一个方法是优化 opcode 的执行，首先简单提一下 Zend 是如何执行的，Zend 的 interpreter（也叫解释器）在读到 opcode 后，会根据不同的 opcode 调用不同函数（其实有些是 switch，不过为了描述方便我简化了），然后在这个函数中执行各种语言相关的操作（感兴趣的话可看看深入理解 PHP 内核这本书），所以 Zend 中并没有什么复杂封装和间接调用，作为一个解释器来说已经做得很好了。</p><br />
<br />
<p>想要提升 Zend 的执行性能，就需要对程序的底层执行有所解，比如函数调用其实是有开销的，所以能通过 Inline threading 来优化掉，它的原理就像 C 语言中的 inline 关键字那样，但它是在运行时将相关的函数展开，然后依次执行（只是打个比方，实际实现不太一样），同时还避免了 CPU 流水线预测失败导致的浪费。</p><br />
<br />
<p>另外还可以像 JavaScriptCore 和 LuaJIT 那样使用汇编来实现 interpreter，具体细节建议看看 Mike 的解释</p><br />
<br />
<p>但这两种做法修改代价太大，甚至比重写一个还难，尤其是要保证向下兼容，后面提到 PHP 的特点时你就知道了。</p><br />
<br />
<p>开发一个高性能的虚拟机不是件简单的事情，JVM 花了10多年才达到现在的性能，那是否能直接利用这些高性能的虚拟机来优化 PHP 的性能呢？这就是方案3的思路。</p><br />
<br />
<p>其实这种方案早就有人尝试过了，比如 Quercus 和 IBM 的 P8，Quercus 几乎没见有人使用，而 P8 也已经死掉了。Facebook 也曾经调研过这种方式，甚至还出现过不靠谱的传闻 ，但其实 Facebook 在2011年就放弃了。</p><br />
<br />
<p>因为方案3看起来美好，但实际效果却不理想，按照很多大牛的说法（比如 Mike），VM 总是为某个语言优化的，其它语言在上面实现会遇到很多瓶颈，比如动态的方法调用，关于这点在 Dart 的文档中有过介绍，而且据说 Quercus 的性能与 Zend+APC 比差不了太多（[来自The HipHop Compiler for PHP]），所以没太大意义。</p><br />
<br />
<p>不过 OpenJDK 这几年也在努力，最近的 Grall 项目看起来还不错，也有语言在上面取得了显著的效果，但我还没空研究 Grall，所以这里无法判断。</p><br />
<br />
<p>https://www.cnblogs.com/liangxiaofeng/p/5115039.html</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category php
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>