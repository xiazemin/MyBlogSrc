<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">file_get_contents</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-01-10T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jan 10, 2020</time></p>
					</div>
					 <p>1: 用file_get_contents 以get方式获取内容</p><br />
<br />
<p>&lt;?php <br />
$url=’http://www.baidu.com/’; <br />
$html=file_get_contents($url); <br />
//print_r($http_response_header); <br />
ec($html); <br />
printhr(); <br />
printarr($http_response_header); <br />
printhr(); <br />
?&gt;</p><br />
<br />
<p>示例代码2: 用fopen打开url, 以get方式获取内容</p><br />
<br />
<p>&lt;? <br />
$fp=fopen($url,’r’); <br />
printarr(stream_get_meta_data($fp)); <br />
printhr(); <br />
while(!feof($fp)){ <br />
$result.=fgets($fp,1024); <br />
} <br />
echo”url body: $result”; <br />
printhr(); <br />
fclose($fp); <br />
?&gt;</p><br />
<br />
<p>示例代码3：用file_get_contents函数,以post方式获取url</p><br />
<br />
<p>&lt;?php <br />
$data=array(‘foo’=&gt;’bar’); <br />
$data=http_build_query($data);</p><br />
<br />
<p>$opts=array( <br />
‘http’=&gt;array( <br />
‘method’=&gt;’POST’, <br />
‘header’=&gt;”Content-type: application/x-www-form-urlencoded\r\n”. <br />
“Content-Length: “.strlen($data).”\r\n”, <br />
‘content’=&gt;$data <br />
), <br />
); <br />
$context=stream_context_create($opts); <br />
$html=file_get_contents(‘http://localhost/e/admin/test.html’,false,$context); <br />
echo$html; <br />
?&gt;</p><br />
<br />
<p>示例代码4：用fsockopen函数打开url，以get方式获取完整的数据，包括header和body</p><br />
<br />
<p>&lt;? <br />
functionget_url($url,$cookie=false){ <br />
$url=parse_url($url); <br />
$query=$url[path].”?”.$url[query]; <br />
ec(“Query:”.$query); <br />
$fp=fsockopen($url[host],$url[port]?$url[port]:80,$errno,$errstr,30); <br />
if(!$fp){ <br />
returnfalse; <br />
}else{ <br />
$request=”GET$queryHTTP/1.1\r\n”; <br />
$request.=”Host:$url[host]\r\n”; <br />
$request.=”Connection: Close\r\n”; <br />
if($cookie)$request.=”Cookie: $cookie\n”; <br />
$request.=”\r\n”; <br />
fwrite($fp,$request); <br />
while(!@feof($fp)){ <br />
$result.=@fgets($fp,1024); <br />
} <br />
fclose($fp); <br />
return$result; <br />
} <br />
} <br />
//获取url的html部分，去掉header <br />
functionGetUrlHTML($url,$cookie=false){ <br />
$rowdata=get_url($url,$cookie); <br />
if($rowdata) <br />
{ <br />
$body=stristr($rowdata,”\r\n\r\n”); <br />
$body=substr($body,4,strlen($body)); <br />
return$body; <br />
} <br />
returnfalse; <br />
} <br />
?&gt;</p><br />
<br />
<p>示例代码5：用fsockopen函数打开url，以POST方式获取完整的数据，包括header和body</p><br />
<br />
<p>&lt;? <br />
functionHTTP_Post($URL,$data,$cookie,$referrer=””){ <br />
// parsing the given URL <br />
$URL_Info=parse_url($URL);</p><br />
<br />
<p>// Building referrer <br />
if($referrer==””)// if not given use this script. as referrer <br />
$referrer=”111”;</p><br />
<br />
<p>// making string from $data <br />
foreach($dataas$key=&gt;$value) <br />
$values[]=”$key=”.urlencode($value); <br />
$data_string=implode(“&amp;”,$values);</p><br />
<br />
<p>// Find out which port is needed - if not given use standard (=80) <br />
if(!isset($URL_Info[“port”])) <br />
$URL_Info[“port”]=80;</p><br />
<br />
<p>// building POST-request: <br />
$request.=”POST “.$URL_Info[“path”].” HTTP/1.1\n”; <br />
$request.=”Host: “.$URL_Info[“host”].”\n”; <br />
$request.=”Referer:$referer\n”; <br />
$request.=”Content-type: application/x-www-form-urlencoded\n”; <br />
$request.=”Content-length: “.strlen($data_string).”\n”; <br />
$request.=”Connection: close\n”; <br />
$request.=”Cookie: $cookie\n”; <br />
$request.=”\n”; <br />
$request.=$data_string.”\n”;</p><br />
<br />
<p>$fp=fsockopen($URL_Info[“host”],$URL_Info[“port”]); <br />
fputs($fp,$request); <br />
while(!feof($fp)){ <br />
$result.=fgets($fp,1024); <br />
} <br />
fclose($fp); <br />
return$result; <br />
} <br />
printhr(); <br />
?&gt;</p><br />
<br />
<p>示例代码6:使用curl库，使用curl库之前，你可能需要查看一下php.ini，查看是否已经打开了curl扩展</p><br />
<br />
<p>&lt;? <br />
$ch = curl_init(); <br />
$timeout = 5; <br />
curl_setopt ($ch, CURLOPT_URL, ‘http://www.baidu.com/’); <br />
curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1); <br />
curl_setopt ($ch, CURLOPT_CONNECTTIMEOUT, $timeout); <br />
$file_contents = curl_exec($ch); <br />
curl_close($ch); <br />
echo $file_contents; <br />
?&gt;</p><br />
<br />
<p>关于curl库：<br />
curl官方网站http://curl.haxx.se/<br />
curl 是使用URL语法的传送文件工具，支持FTP、FTPS、HTTP HTPPS SCP SFTP TFTP TELNET DICT FILE和LDAP。curl 支持SSL证书、HTTP POST、HTTP PUT 、FTP 上传，kerberos、基于HTT格式的上传、代理、cookie、用户＋口令证明、文件传送恢复、http代理通道和大量其他有用的技巧</p><br />
<br />
<p>&lt;? <br />
functionprintarr(array$arr) <br />
{ <br />
echo”<br /> Row field count: “.count($arr).”<br />”; <br />
foreach($arras$key=&gt;$value) <br />
{ <br />
echo”$key=$value <br />”; <br />
} <br />
} <br />
?&gt;</p><br />
<br />
<p>PHP抓取远程网站数据的代码<br />
现在可能还有很多程序爱好者都会遇到同样的疑问,就是要如何像搜索引擎那样去抓取别人网站的HTML代码,然后把代码收集整理成为自己有用的数据!今天就等我介绍一些简单例子吧.</p><br />
<br />
<p>Ⅰ.抓取远程网页标题的例子:<br />
以下是代码片段：</p><br />
<br />
<p>&lt;?php <br />
/* <br />
+————————————————————- <br />
+抓取网页标题的代码,直接拷贝本代码片段,另存为.php文件执行即可. <br />
+————————————————————- <br />
*/</p><br />
<br />
<p>error_reporting(7); <br />
$file = fopen (“http://www.jb51.net/”, “r”); <br />
if (!$file) { <br />
echo “<font color="red">Unable to open remote file.</font>\n”; <br />
exit; <br />
} <br />
while (!feof ($file)) { <br />
$line = fgets ($file, 1024); <br />
if (eregi (“<title>(.*)</title>”, $line, $out)) { <br />
$title = $out[1]; <br />
echo “”.$title.””; <br />
break; <br />
} <br />
} <br />
fclose($file);</p><br />
<br />
<p>//End <br />
?&gt;</p><br />
<br />
<p>Ⅱ.抓取远程网页HTML代码的例子:</p><br />
<br />
<p>&lt;? php <br />
/* <br />
+—————- <br />
+DNSing Sprider <br />
+—————- <br />
*/</p><br />
<br />
<p>$fp = fsockopen(“www.dnsing.com”, 80, $errno, $errstr, 30); <br />
if (!$fp) { <br />
echo “$errstr ($errno)<br />\n”; <br />
} else { <br />
$out = “GET / HTTP/1.1\r\n”; <br />
$out .= “Host:www.dnsing.com\r\n”; <br />
$out .= “Connection: Close \r\n\r\n”; <br />
fputs($fp, $out); <br />
while (!feof($fp)) { <br />
echo fgets($fp, 128); <br />
} <br />
fclose($fp); <br />
} <br />
//End <br />
?&gt;</p><br />
<br />
<p>以上两个代码片段都直接Copy回去运行就知道效果了,上面的例子只是抓取网页数据的雏形,要使其更适合自己的使用,情况有各异.所以,在此各位程序爱好者自己好好研究一下吧.</p><br />
<br />
<p>===============================</p><br />
<br />
<p>稍微有点意义的函数是：get_content_by_socket(), get_url(), get_content_url(), get_content_object 几个函数，也许能够给你点什么想法。</p><br />
<br />
<p>&lt;?php</p><br />
<br />
<p>//获取所有内容url保存到文件 <br />
function get_index($save_file, $prefix=”index_”){ <br />
$count = 68; <br />
$i = 1; <br />
if (file_exists($save_file)) @unlink($save_file); <br />
$fp = fopen($save_file, “a+”) or die(“Open “. $save_file .” failed”); <br />
while($i&lt;$count){ <br />
$url = $prefix . $i .”.htm”; <br />
echo “Get “. $url .”…”; <br />
$url_str = get_content_url(get_url($url)); <br />
echo “ OK\n”; <br />
fwrite($fp, $url_str); <br />
++$i; <br />
} <br />
fclose($fp); <br />
}</p><br />
<br />
<p>//获取目标多媒体对象 <br />
function get_object($url_file, $save_file, $split=”|–:**:–|”){ <br />
if (!file_exists($url_file)) die($url_file .” not exist”); <br />
$file_arr = file($url_file); <br />
if (!is_array($file_arr) || empty($file_arr)) die($url_file .” not content”); <br />
$url_arr = array_unique($file_arr); <br />
if (file_exists($save_file)) @unlink($save_file); <br />
$fp = fopen($save_file, “a+”) or die(“Open save file “. $save_file .” failed”); <br />
foreach($url_arr as $url){ <br />
if (empty($url)) continue; <br />
echo “Get “. $url .”…”; <br />
$html_str = get_url($url); <br />
echo $html_str; <br />
echo $url; <br />
exit; <br />
$obj_str = get_content_object($html_str); <br />
echo “ OK\n”; <br />
fwrite($fp, $obj_str); <br />
} <br />
fclose($fp); <br />
}</p><br />
<br />
<p>//遍历目录获取文件内容 <br />
function get_dir($save_file, $dir){ <br />
$dp = opendir($dir); <br />
if (file_exists($save_file)) @unlink($save_file); <br />
$fp = fopen($save_file, “a+”) or die(“Open save file “. $save_file .” failed”); <br />
while(($file = readdir($dp)) != false){ <br />
if ($file!=”.” &amp;&amp; $file!=”..”){ <br />
echo “Read file “. $file .”…”; <br />
$file_content = file_get_contents($dir . $file); <br />
$obj_str = get_content_object($file_content); <br />
echo “ OK\n”; <br />
fwrite($fp, $obj_str); <br />
} <br />
} <br />
fclose($fp); <br />
}</p><br />
<br />
<p>//获取指定url内容 <br />
function get_url($url){ <br />
$reg = ‘/^http:\/\/[^\/].+$/’; <br />
if (!preg_match($reg, $url)) die($url .” invalid”); <br />
$fp = fopen($url, “r”) or die(“Open url: “. $url .” failed.”); <br />
while($fc = fread($fp, 8192)){ <br />
$content .= $fc; <br />
} <br />
fclose($fp); <br />
if (empty($content)){ <br />
die(“Get url: “. $url .” content failed.”); <br />
} <br />
return $content; <br />
}</p><br />
<br />
<p>//使用socket获取指定网页 <br />
function get_content_by_socket($url, $host){ <br />
$fp = fsockopen($host, 80) or die(“Open “. $url .” failed”); <br />
$header = “GET /”.$url .” HTTP/1.1\r\n”; <br />
$header .= “Accept: <em>/</em>\r\n”; <br />
$header .= “Accept-Language: zh-cn\r\n”; <br />
$header .= “Accept-Encoding: gzip, deflate\r\n”; <br />
$header .= “User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; Maxthon; InfoPath.1; .NET CLR 2.0.50727)\r\n”; <br />
$header .= “Host: “. $host .”\r\n”; <br />
$header .= “Connection: Keep-Alive\r\n”; <br />
//$header .= “Cookie: cnzz02=2; rtime=1; ltime=1148456424859; cnzz_eid=56601755-\r\n\r\n”; <br />
$header .= “Connection: Close\r\n\r\n”;</p><br />
<br />
<p>fwrite($fp, $header); <br />
while (!feof($fp)) { <br />
$contents .= fgets($fp, 8192); <br />
} <br />
fclose($fp); <br />
return $contents; <br />
}</p><br />
<br />
<p>//获取指定内容里的url <br />
function get_content_url($host_url, $file_contents){</p><br />
<br />
<p>//$reg = ‘/^(#|javascript.<em>?|ftp:\/\/.+|http:\/\/.+|.</em>?href.<em>?|play.</em>?|index.<em>?|.</em>?asp)+$/i’; <br />
//$reg = ‘/^(down.<em>?.html|\d+_\d+.htm.</em>?)$/i’; <br />
$rex = “/([hH][rR][eE][Ff])\s<em>=\s</em>[’"]<em>([^&gt;’"\s]+)["’&gt;]</em>\s<em>/i”; <br />
$reg = ‘/^(down.</em>?.html)$/i’; <br />
preg_match_all ($rex, $file_contents, $r); <br />
$result = “”; //array(); <br />
foreach($r as $c){ <br />
if (is_array($c)){ <br />
foreach($c as $d){ <br />
if (preg_match($reg, $d)){ $result .= $host_url . $d.”\n”; } <br />
} <br />
} <br />
} <br />
return $result; <br />
}</p><br />
<br />
<p>//获取指定内容中的多媒体文件 <br />
function get_content_object($str, $split=”|–:<em>*:–|”){ <br />
$regx = “/href\s</em>=\s<em>[’"]</em>([^&gt;’"\s]+)["’&gt;]<em>\s</em>(<b>.*?&lt;\/b&gt;)/i”; <br />
preg_match_all($regx, $str, $result);</b></p><br />
<br />
<p>if (count($result) == 3){ <br />
$result[2] = str_replace(“<b>多媒体： “, “”, $result[2]); <br />
$result[2] = str_replace(“</b>”, “”, $result[2]); <br />
$result = $result[1][0] . $split .$result[2][0] . “\n”; <br />
} <br />
return $result; <br />
}</p><br />
<br />
<p>?&gt; <br />
同一域名对应多个IP时，PHP获取远程网页内容的函数</p><br />
<br />
<p>fgc就是简单的读取过来，把一切操作封装了<br />
fopen也进行了一些封装，但是需要你循环读取得到所有数据。<br />
fsockopen这是直板板的socket操作。<br />
如果仅仅是读取一个html页面，fgc更好。<br />
如果公司是通过防火墙上网，一 般的file_get_content函数就不行了。当然，通过一些socket操作，直接向proxy写http请求也是可以的，但是比较麻烦。<br />
如果你能确认文件很小，可以任选以上两种方式fopen ,join(’’,file($file));。比如，你只操作小于1k的文件，那最好还是用file_get_contents吧。</p><br />
<br />
<p>如果确定文件很大，或者不能确定文件的大小，那就最好使用文件流了。fopen一个1K的文件和fopen一个1G的文件没什么明显的区别。内容长，就可以花更长的时间去读，而不是让脚本死掉。</p><br />
<br />
<hr /><br />
<p>http://www.phpcake.cn/archives/tag/fsockopen<br />
PHP获取远程网页内容有多种方式，例如用自带的file_get_contents、fopen等函数。</p><br />
<br />
<p>&lt;?php</p><br />
<br />
<p>echo file_get_contents(“http://img.jb51.net/abc.php”); <br />
?&gt; <br />
1<br />
2<br />
3<br />
4<br />
但是，在DNS轮询等负载均衡中，同一域名，可能对应多台服务器，多个IP。假设img.jb51.net被DNS解析到 72.249.146.213、72.249.146.214、72.249.146.215三个IP，用户每次访问img.jb51.net，系统会根据负载均衡的相应算法访问其中的一台服务器。<br />
　　上周做一个视频项目时，就碰到这样一类需求：需要依次访问每台服务器上的一个PHP接口程序（假设为abc.php），查询这台服务器的传输状态。</p><br />
<br />
<p>这时就不能直接用file_get_contents访问http://img.jb51.net/abc.php了，因为它可能一直重复访问某一台服务器。</p><br />
<br />
<p>而采用依次访问http://72.249.146.213/abc.php、http://72.249.146.214/abc.php、http://72.249.146.215/abc.php的方法，在这三台服务器上的Web Server配有多个虚拟主机时，也是不行的。</p><br />
<br />
<p>通过设置本地hosts也不行，因为hosts不能设置多个IP对应同一个域名。</p><br />
<br />
<p>那就只有通过PHP和HTTP协议来实现：访问abc.php时，在header头中加上img.jb51.net域名。于是，我写了下面这个PHP函数：</p><br />
<br />
<p>&lt;?php</p><br />
<br />
<p>/<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong></p><br />
<ul><br />
  <li>函数用途：同一域名对应多个IP时，获取指定服务器的远程网页内容</li><br />
  <li>创建时间：2008-12-09</li><br />
  <li>创建人：张宴（img.jb51.net）</li><br />
  <li>参数说明：</li><br />
  <li>$ip 服务器的IP地址</li><br />
  <li>$host 服务器的host名称</li><br />
  <li>$url 服务器的URL地址（不含域名）</li><br />
  <li>返回值：</li><br />
  <li>获取到的远程网页内容</li><br />
  <li>false 访问远程网页失败 <br />
<strong>**</strong><strong>**</strong><strong>**</strong><strong>**</strong>/ <br />
function HttpVisit($ip, $host, $url) <br />
{ <br />
$errstr = ‘’; <br />
$errno = ‘’; <br />
$fp = fsockopen ($ip, 80, $errno, $errstr, 90); <br />
if (!$fp) <br />
{ <br />
return false; <br />
} <br />
else <br />
{ <br />
$out = “GET {$url} HTTP/1.1\r\n”; <br />
$out .= “Host:{$host}\r\n”; <br />
$out .= “Connection: close\r\n\r\n”; <br />
fputs ($fp, $out);</li><br />
</ul><br />
<br />
<p>while($line = fread($fp, 4096)){ <br />
$response .= $line; <br />
} <br />
fclose( $fp );</p><br />
<br />
<p>//去掉Header头信息 <br />
$pos = strpos($response, “\r\n\r\n”); <br />
$response = substr($response, $pos + 4);</p><br />
<br />
<p>return $response; <br />
} <br />
}</p><br />
<br />
<p>//调用方法： <br />
$server_info1 = HttpVisit(“72.249.146.213”, “img.jb51.net”, “/abc.php”); <br />
$server_info2 = HttpVisit(“72.249.146.214”, “img.jb51.net”, “/abc.php”); <br />
$server_info3 = HttpVisit(“72.249.146.215”, “img.jb51.net”, “/abc.php”); <br />
?&gt; <br />
<!-- more --><br />
https://www.php.net/manual/en/function.file-get-contents.php</p><br />
<br />
<p>早在2010年时候遇到过这样的事情，因为file_get_contents函数造成服务器挂掉的情况，现在觉得很有必要总结下。</p><br />
<br />
<p>公司里有经常有这样的业务，需要调用第三方公司提供的HTTP接口，在把接口提供的信息显示到网页上，代码是这样写的: file_get_contents(“http://example.com/”) 。<br />
有一天突然接到运维同事的报告，说是服务器挂了，查出原因说是因为file_get_contents函数造成的，那么为什么一个函数会把服务器给搞挂掉呢？<br />
经过详细的查询发现第三方公司提供接口已经坏掉了，就是因为接口坏掉了，才导致服务器挂掉。<br />
问题分析如下：<br />
    我们代码是“file_get_contents(“http://example.com/”) “获取一个 URL 的返回内容，如果第三方公司提供的URL响应速度慢，或者出现问题，我们服务器的PHP程序将会一直执行去获得这个URL，我 们知道，在 php.ini 中，有一个参数 max_execution_time 可以设置 PHP 脚本的最大执行时间，但是，在 php-cgi(php-fpm) 中，该参数不会起效。真正能够控制 PHP 脚本最大执行时间的是 php-fpm.conf 配置文件中的以下参数： <value name="request_terminate_timeout">0s</value>  　默认值为 0 秒，也就是说，PHP 脚本会一直执行下去，当请求越来越多的情况下会导致php-cgi 进程都卡在 file_get_contents() 函数时，这台 Nginx+PHP 的 WebServer 已经无法再处理新的 PHP 请求了，Nginx 将给用户返回“502 Bad Gateway”。CPU的利用率达到100% ，时间一长服务器就会挂掉。<br />
问题的解决：<br />
     已经找到问题，那么我们该怎么解决呢？<br />
     当时想到的解决问题的办法就是设置PHP的超时时间，用set_time_limit; 设置超时时间，这样就不会卡住了。代码上线后发现服务器还是会挂掉，好像根本不起作用。后来查了资料才知道，set_time_limit设置的是PHP程序的超时时间，而不是file_get_contents函数读取URL的超时时间。set_time_limit和修改php.ini文件里max_execution_time  效果是一样的。<br />
要设置file_get_contents函数的超时时间，可以用resource $context的timeout参数，代码如下：<br />
复制代码<br />
复制代码<br />
1 $opts = array(<br />
2 　　’http’=&gt;array(<br />
3 　　　　’method’=&gt;”GET”,<br />
4　　　　 ‘timeout’=&gt;10,<br />
5　　 )<br />
6 );<br />
7 $context = stream_context_create($opts);<br />
8 $html =file_get_contents(‘http://www.example.com’, false, $context);<br />
9 echo $html;<br />
复制代码<br />
复制代码<br />
代码中的timeout就是file_get_contents读取url的超时时间。</p><br />
<br />
<p>另外还有一个说法也可以改变读取url的超时时间，就是修改php.ini中的default_socket_timeout的值，或者 ini_set(‘default_socket_timeout’,    10);  但是我没有测试过不知道行不行。<br />
有了解决方法之后，服务器就不会挂掉了。<br />
在解决的过程中我还发现起到关键作用的是stream_context_create方法，里面method 可以是GET，那么能否可以POST呢？还有没有其他的参数？<br />
还有一个为老同事告诉我们还有一个比file_get_contents更好的办法，就是用CURL。<br />
请看下面两篇。</p><br />
<br />
<p>目录(?)[+]</p><br />
<br />
<p>file_get_contents函数<br />
一般的也就是使用file_get_contents($url)，但是关于这个函数还有很多没有注意到的地方。</p><br />
<br />
<p>先看关于手册：</p><br />
<br />
<p>file_get_contents(path,include_path,context,start,max_length)<br />
参数</p><br />
<br />
<p>描述</p><br />
<br />
<p>path</p><br />
<br />
<p>必需。规定要读取的文件。</p><br />
<br />
<p>include_path</p><br />
<br />
<p>可选。如果也想在 include_path 中搜寻文件的话，可以将该参数设为 “1″。</p><br />
<br />
<p>context</p><br />
<br />
<p>可选。规定文件句柄的环境。</p><br />
<br />
<p>context 是一套可以修改流的行为的选项。若使用 null，则忽略。</p><br />
<br />
<p>start</p><br />
<br />
<p>可选。规定在文件中开始读取的位置。该参数是 PHP 5.1 新加的。</p><br />
<br />
<p>max_length</p><br />
<br />
<p>可选。规定读取的字节数。该参数是 PHP 5.1 新加的。</p><br />
<br />
<p>——————-可以选择读取文件位置和长度这个选项不错。但是关于context的选项是做什么用的呢？</p><br />
<br />
<p>强大的context——stream_context_create<br />
context 就是文本流的意思。而在php中创建文本流的函数是：stream_context_create</p><br />
<br />
<p>参看官方手册：http://php.net/manual/en/function.stream-context-create.php</p><br />
<br />
<p>stream_context_create是用来创建打开文件的上下文件选项的，比如用POST访问，使用代理，发送header等。看到没有之前用 curl实现的所谓代理，post，header方法都可以使用file_get_contents+stream_context_create来实 现。</p><br />
<br />
<p>之前在《PHP批量采集下载美女图片》中抱怨file_get_contents采集图片时候经常会遇到慢资源造成cpu负载过高，不能设置超时时间，最后使用curl来实现，其实file_get_contents也可以设置超时时间。</p><br />
<br />
<p>file_get_contents超时设置<br />
1<br />
$opts  = array(‘http’=&gt;array(‘timeout’=&gt;10));<br />
2<br />
$context  = stream_context_create($opts);<br />
3<br />
echo  file_get_contents($url,false,$context);<br />
这样就可以实现设置10s的超时时间</p><br />
<br />
<p>更强大的file_get_contents</p><br />
<br />
<p>file_get_contents实现post<br />
参看官方手册的例子</p><br />
<br />
<p>1<br />
$opts  = array(‘http’  =&gt;<br />
2<br />
  array(<br />
3<br />
    ‘method’   =&gt; ‘POST’,<br />
4<br />
    ‘header’   =&gt; “Content-Type: text/xmlrn”.<br />
5<br />
      “Authorization: Basic “.base64_encode(“$https_user:$https_password”).”rn”,<br />
6<br />
    ‘content’  =&gt; $body,<br />
7<br />
    ‘timeout’  =&gt; 60<br />
8<br />
  )<br />
9<br />
);<br />
10</p><br />
<br />
<p>11<br />
$context   = stream_context_create($opts);<br />
12<br />
$url  = ‘https://’.$https_server;<br />
13<br />
$result  = file_get_contents($url, false, $context, -1, 40000);<br />
还可以实现get请求，header代理等等功能，理论上curl可以实现的功能file_get_contents都可以实现，但是关于 stream_context_create的解释网络上资源不是很多，也注定在采集程序方面curl的应用更广，另外curl是一种通信模式，不是单纯 的php-curl。</p><br />
<br />
<p>之前写过关于解决gzip乱码的问题《:file_get_contents获取gzip网页乱码》</p><br />
<br />
<p>更多高级使用方法参看官方手册的实例：http://php.net/manual/en/function.stream-context-create.php，http://php.net/manual/en/function.file-get-contents.php</p><br />
<br />
<p>file_put_contents函数<br />
语法：</p><br />
<br />
<p>file_put_contents(file,data,mode,context)<br />
参数</p><br />
<br />
<p>描述</p><br />
<br />
<p>file</p><br />
<br />
<p>必需。规定要写入数据的文件。如果文件不存在，则创建一个新文件。</p><br />
<br />
<p>data</p><br />
<br />
<p>可选。规定要写入文件的数据。可以是字符串、数组或数据流。</p><br />
<br />
<p>mode</p><br />
<br />
<p>可选。规定如何打开/写入文件。可能的值：</p><br />
<br />
<p>FILE_USE_INCLUDE_PATH<br />
FILE_APPEND<br />
LOCK_EX<br />
context</p><br />
<br />
<p>可选。规定文件句柄的环境。</p><br />
<br />
<p>context 是一套可以修改流的行为的选项。若使用 null，则忽略。</p><br />
<br />
<p>注意事项：<br />
file_put_contents等于依次调用 fopen()，fwrite() 以及 fclose() 功能一样，但是效率要更高。<br />
data不仅仅是字符串，也包括数组格式和文本流，当是数组格式的时候（只能是一维数组，不能是多维数组），需要把数组分割implode(”, $array)， 其实还是转换为字符串，如果不分割的话文本存储的内容就是$array[0]$array[1]$array[2]$array[3]这种，不利于读取。 文本流这个就更好理解了，例如存储file_get_contents(‘aa.jpg’)这一张图片的二进制流也是可以存储的。<br />
模式：FILE_APPEND 是追加模式，默认的写入方式是覆盖之前的内容，但是使用FILE_APPEND 模式后就可以不覆盖之前的内容了。LOCK_EX是文本锁，防止并行写入冲突。<br />
context 和上面的file_get_contents一样，可以增加文本流选项，官方的一个例子<br />
1<br />
&lt;?php<br />
2<br />
 /* set the FTP hostname */<br />
3<br />
 $user  = “test”;<br />
4<br />
 $pass  = “myFTP”;<br />
5<br />
 $host  = “example.com”;<br />
6<br />
 $file  = “test.txt”;<br />
7<br />
 $hostname  = $user  . “:”  . $pass  . “@”  . $host  . “/”  . $file; <br />
8</p><br />
<br />
<p>9<br />
 /* the file content */<br />
10<br />
 $content  = “this is just a test.”; <br />
11</p><br />
<br />
<p>12<br />
 /* create a stream context telling PHP to overwrite the file */<br />
13<br />
 $options  = array(‘ftp’  =&gt; array(‘overwrite’  =&gt; true));<br />
14<br />
 $stream  = stream_context_create($options); <br />
15</p><br />
<br />
<p>16<br />
 /* and finally, put the contents */<br />
17<br />
 file_put_contents($hostname, $content, 0, $stream);<br />
18<br />
?&gt;<br />
PHP中使用CURL实现GET和POST请求<br />
AloneMonkey 2014年7月3日 11<br />
一、什么是CURL？</p><br />
<br />
<p>cURL 是一个利用URL语法规定来传输文件和数据的工具，支持很多协议，如HTTP、FTP、TELNET等。最爽的是，PHP也支持 cURL 库。使用PHP的cURL库可以简单和有效地去抓网页。你只需要运行一个脚本，然后分析一下你所抓取的网页，然后就可以以程序的方式得到你想要的数据了。 无论是你想从从一个链接上取部分数据，或是取一个XML文件并把其导入数据库，那怕就是简单的获取网页内容，cURL 是一个功能强大的PHP库。</p><br />
<br />
<p>二、CURL函数库。</p><br />
<br />
<p>curl_close — 关闭一个curl会话<br />
curl_copy_handle — 拷贝一个curl连接资源的所有内容和参数<br />
curl_errno — 返回一个包含当前会话错误信息的数字编号<br />
curl_error — 返回一个包含当前会话错误信息的字符串<br />
curl_exec — 执行一个curl会话<br />
curl_getinfo — 获取一个curl连接资源句柄的信息<br />
curl_init — 初始化一个curl会话<br />
curl_multi_add_handle — 向curl批处理会话中添加单独的curl句柄资源<br />
curl_multi_close — 关闭一个批处理句柄资源<br />
curl_multi_exec — 解析一个curl批处理句柄<br />
curl_multi_getcontent — 返回获取的输出的文本流<br />
curl_multi_info_read — 获取当前解析的curl的相关传输信息<br />
curl_multi_init — 初始化一个curl批处理句柄资源<br />
curl_multi_remove_handle — 移除curl批处理句柄资源中的某个句柄资源<br />
curl_multi_select — Get all the sockets associated with the cURL extension, which can then be “selected”<br />
curl_setopt_array — 以数组的形式为一个curl设置会话参数<br />
curl_setopt — 为一个curl设置会话参数<br />
curl_version — 获取curl相关的版本信息</p><br />
<br />
<p>curl_init()函数的作用初始化一个curl会话，curl_init()函数唯一的一个参数是可选的，表示一个url地址。<br />
curl_exec()函数的作用是执行一个curl会话，唯一的参数是curl_init()函数返回的句柄。<br />
curl_close()函数的作用是关闭一个curl会话，唯一的参数是curl_init()函数返回的句柄。</p><br />
<br />
<p>三、PHP建立CURL请求的基本步骤</p><br />
<br />
<p>①：初始化</p><br />
<br />
<p>curl_init()</p><br />
<br />
<p>②：设置属性</p><br />
<br />
<p>curl_setopt().有一长串cURL参数可供设置，它们能指定URL请求的各个细节。</p><br />
<br />
<p>③：执行并获取结果</p><br />
<br />
<p>curl_exec()</p><br />
<br />
<p>④：释放句柄</p><br />
<br />
<p>curl_close()</p><br />
<br />
<p>四、CURL实现GET和POST</p><br />
<br />
<p>①：GET方式实现</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
&lt;?php<br />
    //初始化<br />
    $curl = curl_init();<br />
    //设置抓取的url<br />
    curl_setopt($curl, CURLOPT_URL, ‘http://www.baidu.com’);<br />
    //设置头文件的信息作为数据流输出<br />
    curl_setopt($curl, CURLOPT_HEADER, 1);<br />
    //设置获取的信息以文件流的形式返回，而不是直接输出。<br />
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);<br />
    //执行命令<br />
    $data = curl_exec($curl);<br />
    //关闭URL请求<br />
    curl_close($curl);<br />
    //显示获得的数据<br />
    print_r($data);<br />
?&gt;<br />
运行结果：</p><br />
<br />
<p>image</p><br />
<br />
<p>②：POST方式实现</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
&lt;?php<br />
    //初始化<br />
    $curl = curl_init();<br />
    //设置抓取的url<br />
    curl_setopt($curl, CURLOPT_URL, ‘http://www.baidu.com’);<br />
    //设置头文件的信息作为数据流输出<br />
    curl_setopt($curl, CURLOPT_HEADER, 1);<br />
    //设置获取的信息以文件流的形式返回，而不是直接输出。<br />
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);<br />
    //设置post方式提交<br />
    curl_setopt($curl, CURLOPT_POST, 1);<br />
    //设置post数据<br />
    $post_data = array(<br />
        “username” =&gt; “coder”,<br />
        “password” =&gt; “12345”<br />
        );<br />
    curl_setopt($curl, CURLOPT_POSTFIELDS, $post_data);<br />
    //执行命令<br />
    $data = curl_exec($curl);<br />
    //关闭URL请求<br />
    curl_close($curl);<br />
    //显示获得的数据<br />
    print_r($data);<br />
?&gt;<br />
③：如果获得的数据时json格式的，使用json_decode函数解释成数组。</p><br />
<br />
<p>$output_array = json_decode($output,true);</p><br />
<br />
<p>如果使用json_decode($output)解析的话，将会得到object类型的数据。</p><br />
<br />
<p>五、我自己封装的一个函数</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
25<br />
26<br />
27<br />
28<br />
29<br />
30<br />
31<br />
32<br />
33<br />
 //参数1：访问的URL，参数2：post数据(不填则为GET)，参数3：提交的$cookies,参数4：是否返回$cookies<br />
 function curl_request($url,$post=’’,$cookie=’’, $returnCookie=0){<br />
        $curl = curl_init();<br />
        curl_setopt($curl, CURLOPT_URL, $url);<br />
        curl_setopt($curl, CURLOPT_USERAGENT, ‘Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)’);<br />
        curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1);<br />
        curl_setopt($curl, CURLOPT_AUTOREFERER, 1);<br />
        curl_setopt($curl, CURLOPT_REFERER, “http://XXX”);<br />
        if($post) {<br />
            curl_setopt($curl, CURLOPT_POST, 1);<br />
            curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($post));<br />
        }<br />
        if($cookie) {<br />
            curl_setopt($curl, CURLOPT_COOKIE, $cookie);<br />
        }<br />
        curl_setopt($curl, CURLOPT_HEADER, $returnCookie);<br />
        curl_setopt($curl, CURLOPT_TIMEOUT, 10);<br />
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);<br />
        $data = curl_exec($curl);<br />
        if (curl_errno($curl)) {<br />
            return curl_error($curl);<br />
        }<br />
        curl_close($curl);<br />
        if($returnCookie){<br />
            list($header, $body) = explode(“\r\n\r\n”, $data, 2);<br />
            preg_match_all(“/Set-Cookie:([^;]*);/”, $header, $matches);<br />
            $info[‘cookie’]  = substr($matches[1][0], 1);<br />
            $info[‘content’] = $body;             return $info;         }else{             return $data;         } }</p><br />
<br />
<p>附可选参数说明：</p><br />
<br />
<p>第一类：<br />
对于下面的这些option的可选参数，value应该被设置一个bool类型的值：<br />
选项<br />
可选value值<br />
备注<br />
CURLOPT_AUTOREFERER<br />
当根据Location:重定向时，自动设置header中的Referer:信息。<br />
CURLOPT_BINARYTRANSFER<br />
在启用CURLOPT_RETURNTRANSFER的时候，返回原生的（Raw）输出。<br />
CURLOPT_COOKIESESSION<br />
启用时curl会仅仅传递一个session cookie，忽略其他的cookie，默认状况下cURL会将所有的cookie返回给服务端。session cookie是指那些用来判断服务器端的session是否有效而存在的cookie。<br />
CURLOPT_CRLF<br />
启用时将Unix的换行符转换成回车换行符。<br />
CURLOPT_DNS_USE_GLOBAL_CACHE<br />
启用时会启用一个全局的DNS缓存，此项为线程安全的，并且默认启用。<br />
CURLOPT_FAILONERROR<br />
显示HTTP状态码，默认行为是忽略编号小于等于400的HTTP信息。<br />
CURLOPT_FILETIME<br />
启用时会尝试修改远程文档中的信息。结果信息会通过 curl_getinfo()函数的CURLINFO_FILETIME选项返回。curl_getinfo().<br />
CURLOPT_FOLLOWLOCATION<br />
启用时会将服务器服务器返回的”Location: “放在header中递归的返回给服务器，使用CURLOPT_MAXREDIRS可以限定递归返回的数量。<br />
CURLOPT_FORBID_REUSE<br />
在完成交互以后强迫断开连接，不能重用。<br />
CURLOPT_FRESH_CONNECT<br />
强制获取一个新的连接，替代缓存中的连接。<br />
CURLOPT_FTP_USE_EPRT<br />
启用时当FTP下载时，使用EPRT (或 LPRT)命令。设置为FALSE时禁用EPRT和LPRT，使用PORT命令 only.<br />
CURLOPT_FTP_USE_EPSV<br />
启用时，在FTP传输过程中回复到PASV模式前首先尝试EPSV命令。设置为FALSE时禁用EPSV命令。<br />
CURLOPT_FTPAPPEND<br />
启用时追加写入文件而不是覆盖它。<br />
CURLOPT_FTPASCII<br />
CURLOPT_TRANSFERTEXT的别名。<br />
CURLOPT_FTPLISTONLY<br />
启用时只列出FTP目录的名字。<br />
CURLOPT_HEADER<br />
启用时会将头文件的信息作为数据流输出。<br />
CURLINFO_HEADER_OUT<br />
启用时追踪句柄的请求字符串。<br />
从 PHP 5.1.3 开始可用。CURLINFO_前缀是故意的(intentional)。<br />
CURLOPT_HTTPGET<br />
启用时会设置HTTP的method为GET，因为GET是默认是，所以只在被修改的情况下使用。<br />
CURLOPT_HTTPPROXYTUNNEL<br />
启用时会通过HTTP代理来传输。<br />
CURLOPT_MUTE<br />
启用时将cURL函数中所有修改过的参数恢复默认值。<br />
CURLOPT_NETRC<br />
在连接建立以后，访问~/.netrc文件获取用户名和密码信息连接远程站点。<br />
CURLOPT_NOBODY<br />
启用时将不对HTML中的BODY部分进行输出。<br />
CURLOPT_NOPROGRESS<br />
启用时关闭curl传输的进度条，此项的默认设置为启用。<br />
Note:<br />
PHP自动地设置这个选项为TRUE，这个选项仅仅应当在以调试为目的时被改变。<br />
CURLOPT_NOSIGNAL<br />
启用时忽略所有的curl传递给php进行的信号。在SAPI多线程传输时此项被默认启用。<br />
cURL 7.10时被加入。<br />
CURLOPT_POST<br />
启用时会发送一个常规的POST请求，类型为：application/x-www-form-urlencoded，就像表单提交的一样。<br />
CURLOPT_PUT<br />
启用时允许HTTP发送文件，必须同时设置CURLOPT_INFILE和CURLOPT_INFILESIZE。<br />
CURLOPT_RETURNTRANSFER<br />
将 curl_exec()获取的信息以文件流的形式返回，而不是直接输出。<br />
CURLOPT_SSL_VERIFYPEER<br />
禁 用后cURL将终止从服务端进行验证。使用CURLOPT_CAINFO选项设置证书使用CURLOPT_CAPATH选项设置证书目录 如果CURLOPT_SSL_VERIFYPEER(默认值为2)被启用，CURLOPT_SSL_VERIFYHOST需要被设置成TRUE否则设置为 FALSE。<br />
自cURL 7.10开始默认为TRUE。从cURL 7.10开始默认绑定安装。<br />
CURLOPT_TRANSFERTEXT<br />
启用后对FTP传输使用ASCII模式。对于LDAP，它检索纯文本信息而非HTML。在Windows系统上，系统不会把STDOUT设置成binary模式。<br />
CURLOPT_UNRESTRICTED_AUTH<br />
在使用CURLOPT_FOLLOWLOCATION产生的header中的多个locations中持续追加用户名和密码信息，即使域名已发生改变。<br />
CURLOPT_UPLOAD<br />
启用后允许文件上传。<br />
CURLOPT_VERBOSE<br />
启用时会汇报所有的信息，存放在STDERR或指定的CURLOPT_STDERR中。</p><br />
<br />
<p>第二类：<br />
对于下面的这些option的可选参数，value应该被设置一个integer类型的值：<br />
选项<br />
可选value值<br />
备注<br />
CURLOPT_BUFFERSIZE<br />
每次获取的数据中读入缓存的大小，但是不保证这个值每次都会被填满。<br />
在cURL 7.10中被加入。<br />
CURLOPT_CLOSEPOLICY<br />
不是CURLCLOSEPOLICY_LEAST_RECENTLY_USED就是CURLCLOSEPOLICY_OLDEST，还存在另外三个CURLCLOSEPOLICY_，但是cURL暂时还不支持。<br />
CURLOPT_CONNECTTIMEOUT<br />
在发起连接前等待的时间，如果设置为0，则无限等待。<br />
CURLOPT_CONNECTTIMEOUT_MS<br />
尝试连接等待的时间，以毫秒为单位。如果设置为0，则无限等待。<br />
在cURL 7.16.2中被加入。从PHP 5.2.3开始可用。<br />
CURLOPT_DNS_CACHE_TIMEOUT<br />
设置在内存中保存DNS信息的时间，默认为120秒。<br />
CURLOPT_FTPSSLAUTH<br />
FTP验证方式：CURLFTPAUTH_SSL (首先尝试SSL)，CURLFTPAUTH_TLS (首先尝试TLS)或CURLFTPAUTH_DEFAULT (让cURL自动决定)。<br />
在cURL 7.12.2中被加入。<br />
CURLOPT_HTTP_VERSION<br />
CURL_HTTP_VERSION_NONE (默认值，让cURL自己判断使用哪个版本)，CURL_HTTP_VERSION_1<em>0 (强制使用 HTTP/1.0)或CURL_HTTP_VERSION_1_1 (强制使用 HTTP/1.1)。<br />
CURLOPT_HTTPAUTH<br />
使用的HTTP验证方法，可选的值有：CURLAUTH_BASIC、CURLAUTH_DIGEST、CURLAUTH_GSSNEGOTIATE、CURLAUTH_NTLM、CURLAUTH_ANY和CURLAUTH_ANYSAFE。<br />
可以使用|位域(或)操作符分隔多个值，cURL让服务器选择一个支持最好的值。<br />
CURLAUTH_ANY等价于CURLAUTH_BASIC | CURLAUTH_DIGEST | CURLAUTH_GSSNEGOTIATE | CURLAUTH_NTLM.<br />
CURLAUTH_ANYSAFE等价于CURLAUTH_DIGEST | CURLAUTH_GSSNEGOTIATE | CURLAUTH_NTLM.<br />
CURLOPT_INFILESIZE<br />
设定上传文件的大小限制，字节(byte)为单位。<br />
CURLOPT_LOW_SPEED_LIMIT<br />
当传输速度小于CURLOPT_LOW_SPEED_LIMIT时(bytes/sec)，PHP会根据CURLOPT_LOW_SPEED_TIME来判断是否因太慢而取消传输。<br />
CURLOPT_LOW_SPEED_TIME<br />
当传输速度小于CURLOPT_LOW_SPEED_LIMIT时(bytes/sec)，PHP会根据CURLOPT_LOW_SPEED_TIME来判断是否因太慢而取消传输。<br />
CURLOPT_MAXCONNECTS<br />
允许的最大连接数量，超过是会通过CURLOPT_CLOSEPOLICY决定应该停止哪些连接。<br />
CURLOPT_MAXREDIRS<br />
指定最多的HTTP重定向的数量，这个选项是和CURLOPT_FOLLOWLOCATION一起使用的。<br />
CURLOPT_PORT<br />
用来指定连接端口。（可选项）<br />
CURLOPT_PROTOCOLS<br />
CURLPROTO</em>* 的位域指。如果被启用，位域值会限定libcurl在传输过程中有哪些可使用的协议。这将允许你在编译libcurl时支持众多协议，但是限制只是用它们 中被允许使用的一个子集。默认libcurl将会使用全部它支持的协议。参见CURLOPT_REDIR_PROTOCOLS.<br />
可用的协议选项 为：CURLPROTO_HTTP、CURLPROTO_HTTPS、CURLPROTO_FTP、CURLPROTO_FTPS、 CURLPROTO_SCP、CURLPROTO_SFTP、CURLPROTO_TELNET、CURLPROTO_LDAP、 CURLPROTO_LDAPS、CURLPROTO_DICT、CURLPROTO_FILE、CURLPROTO_TFTP、 CURLPROTO_ALL<br />
在cURL 7.19.4中被加入。<br />
CURLOPT_PROXYAUTH<br />
HTTP代理连接的验证方式。使用在CURLOPT_HTTPAUTH中的位域标志来设置相应选项。对于代理验证只有CURLAUTH_BASIC和CURLAUTH_NTLM当前被支持。<br />
在cURL 7.10.7中被加入。<br />
CURLOPT_PROXYPORT<br />
代理服务器的端口。端口也可以在CURLOPT_PROXY中进行设置。<br />
CURLOPT_PROXYTYPE<br />
不是CURLPROXY_HTTP (默认值) 就是CURLPROXY_SOCKS5。<br />
在cURL 7.10中被加入。<br />
CURLOPT_REDIR_PROTOCOLS<br />
CURLPROTO_* 中的位域值。如果被启用，位域值将会限制传输线程在CURLOPT_FOLLOWLOCATION开启时跟随某个重定向时可使用的协议。这将使你对重定向 时限制传输线程使用被允许的协议子集默认libcurl将会允许除FILE和SCP之外的全部协议。这个和7.19.4预发布版本种无条件地跟随所有支持 的协议有一些不同。关于协议常量，请参照CURLOPT_PROTOCOLS。<br />
在cURL 7.19.4中被加入。<br />
CURLOPT_RESUME_FROM<br />
在恢复传输时传递一个字节偏移量（用来断点续传）。<br />
CURLOPT_SSL_VERIFYHOST<br />
1 检查服务器SSL证书中是否存在一个公用名(common name)。译者注：公用名(Common Name)一般来讲就是填写你将要申请SSL证书的域名 (domain)或子域名(sub domain)。2 检查公用名是否存在，并且是否与提供的主机名匹配。<br />
CURLOPT_SSLVERSION<br />
使用的SSL版本(2 或 3)。默认情况下PHP会自己检测这个值，尽管有些情况下需要手动地进行设置。<br />
CURLOPT_TIMECONDITION<br />
如 果在CURLOPT_TIMEVALUE指定的某个时间以后被编辑过，则使用CURL_TIMECOND_IFMODSINCE返回页面，如果没有被修改 过，并且CURLOPT_HEADER为true，则返回一个”304 Not Modified”的header，        CURLOPT_HEADER为false，则使用CURL_TIMECOND_IFUNMODSINCE，默认值为 CURL_TIMECOND_IFUNMODSINCE。<br />
CURLOPT_TIMEOUT<br />
设置cURL允许执行的最长秒数。<br />
CURLOPT_TIMEOUT_MS<br />
设置cURL允许执行的最长毫秒数。<br />
在cURL 7.16.2中被加入。从PHP 5.2.3起可使用。<br />
CURLOPT_TIMEVALUE<br />
设置一个CURLOPT_TIMECONDITION使用的时间戳，在默认状态下使用的是CURL_TIMECOND_IFMODSINCE。</p><br />
<br />
<p>第三类：<br />
对于下面的这些option的可选参数，value应该被设置一个string类型的值：<br />
选项<br />
可选value值<br />
备注<br />
CURLOPT_CAINFO<br />
一个保存着1个或多个用来让服务端验证的证书的文件名。这个参数仅仅在和CURLOPT_SSL_VERIFYPEER一起使用时才有意义。 .<br />
CURLOPT_CAPATH<br />
一个保存着多个CA证书的目录。这个选项是和CURLOPT_SSL_VERIFYPEER一起使用的。<br />
CURLOPT_COOKIE<br />
设定HTTP请求中”Cookie: “部分的内容。多个cookie用分号分隔，分号后带一个空格(例如， “fruit=apple; colour=red”)。<br />
CURLOPT_COOKIEFILE<br />
包含cookie数据的文件名，cookie文件的格式可以是Netscape格式，或者只是纯HTTP头部信息存入文件。<br />
CURLOPT_COOKIEJAR<br />
连接结束后保存cookie信息的文件。<br />
CURLOPT_CUSTOMREQUEST<br />
使 用一个自定义的请求信息来代替”GET”或”HEAD”作为HTTP请求。这对于执行”DELETE” 或者其他更隐蔽的HTTP请求。有效值如”GET”，”POST”，”CONNECT”等等。也就是说，不要在这里输入整个HTTP请求。例如输 入”GET /index.html HTTP/1.0\r\n\r\n”是不正确的。<br />
Note:<br />
在确定服务器支持这个自定义请求的方法前不要使用。<br />
CURLOPT_EGDSOCKET<br />
类似CURLOPT_RANDOM_FILE，除了一个Entropy Gathering Daemon套接字。<br />
CURLOPT_ENCODING<br />
HTTP请求头中”Accept-Encoding: “的值。支持的编码有”identity”，”deflate”和”gzip”。如果为空字符串””，请求头会发送所有支持的编码类型。<br />
在cURL 7.10中被加入。<br />
CURLOPT_FTPPORT<br />
这个值将被用来获取供FTP”POST”指令所需要的IP地址。”POST”指令告诉远程服务器连接到我们指定的IP地址。这个字符串可以是纯文本的IP地址、主机名、一个网络接口名（UNIX下）或者只是一个’-’来使用默认的IP地址。<br />
CURLOPT_INTERFACE<br />
网络发送接口名，可以是一个接口名、IP地址或者是一个主机名。<br />
CURLOPT_KRB4LEVEL<br />
KRB4 (Kerberos 4) 安全级别。下面的任何值都是有效的(从低到高的顺序)：”clear”、”safe”、”confidential”、”private”.。如果字符串 和这些都不匹配，将使用”private”。这个选项设置为NULL时将禁用KRB4 安全认证。目前KRB4 安全认证只能用于FTP传输。<br />
CURLOPT_POSTFIELDS<br />
全 部数据使用HTTP协议中的”POST”操作来发送。要发送文件，在文件名前面加上@前缀并使用完整路径。这个参数可以通过urlencoded后的字符 串类似’para1=val1¶2=val2&amp;…’或使用一个以字段名为键值，字段数据为值的数组。如果value是一个数组，Content- Type头将会被设置成multipart/form-data。<br />
CURLOPT_PROXY<br />
HTTP代理通道。<br />
CURLOPT_PROXYUSERPWD<br />
一个用来连接到代理的”[username]:[password]“格式的字符串。<br />
CURLOPT_RANDOM_FILE<br />
一个被用来生成SSL随机数种子的文件名。<br />
CURLOPT_RANGE<br />
以”X-Y”的形式，其中X和Y都是可选项获取数据的范围，以字节计。HTTP传输线程也支持几个这样的重复项中间用逗号分隔如”X-Y,N-M”。<br />
CURLOPT_REFERER<br />
在HTTP请求头中”Referer: “的内容。<br />
CURLOPT_SSL_CIPHER_LIST<br />
一个SSL的加密算法列表。例如RC4-SHA和TLSv1都是可用的加密列表。<br />
CURLOPT_SSLCERT<br />
一个包含PEM格式证书的文件名。<br />
CURLOPT_SSLCERTPASSWD<br />
使用CURLOPT_SSLCERT证书需要的密码。<br />
CURLOPT_SSLCERTTYPE<br />
证书的类型。支持的格式有”PEM” (默认值), “DER”和”ENG”。<br />
在cURL 7.9.3中被加入。<br />
CURLOPT_SSLENGINE<br />
用来在CURLOPT_SSLKEY中指定的SSL私钥的加密引擎变量。<br />
CURLOPT_SSLENGINE_DEFAULT<br />
用来做非对称加密操作的变量。<br />
CURLOPT_SSLKEY<br />
包含SSL私钥的文件名。<br />
CURLOPT_SSLKEYPASSWD<br />
在CURLOPT_SSLKEY中指定了的SSL私钥的密码。<br />
Note:<br />
由于这个选项包含了敏感的密码信息，记得保证这个PHP脚本的安全。<br />
CURLOPT_SSLKEYTYPE<br />
CURLOPT_SSLKEY中规定的私钥的加密类型，支持的密钥类型为”PEM”(默认值)、”DER”和”ENG”。<br />
CURLOPT_URL<br />
需要获取的URL地址，也可以在 curl_init()函数中设置。<br />
CURLOPT_USERAGENT<br />
在HTTP请求中包含一个”User-Agent: “头的字符串。<br />
CURLOPT_USERPWD<br />
传递一个连接中需要的用户名和密码，格式为：”[username]:[password]“。</p><br />
<br />
<p>第四类<br />
对于下面的这些option的可选参数，value应该被设置一个数组：<br />
选项<br />
可选value值<br />
备注</p><br />
<br />
<p>CURLOPT_HTTP200ALIASES<br />
200响应码数组，数组中的响应吗被认为是正确的响应，否则被认为是错误的。<br />
在cURL 7.10.3中被加入。<br />
CURLOPT_HTTPHEADER<br />
一个用来设置HTTP头字段的数组。使用如下的形式的数组进行设置： array(‘Content-type: text/plain’, ‘Content-length: 100′)<br />
CURLOPT_POSTQUOTE<br />
在FTP请求执行完成后，在服务器上执行的一组FTP命令。<br />
CURLOPT_QUOTE<br />
一组先于FTP请求的在服务器上执行的FTP命令。</p><br />
<br />
<p>对于下面的这些option的可选参数，value应该被设置一个流资源 （例如使用 fopen()）：<br />
选项<br />
可选value值<br />
CURLOPT_FILE<br />
设置输出文件的位置，值是一个资源类型，默认为STDOUT (浏览器)。<br />
CURLOPT_INFILE<br />
在上传文件的时候需要读取的文件地址，值是一个资源类型。<br />
CURLOPT_STDERR<br />
设置一个错误输出地址，值是一个资源类型，取代默认的STDERR。<br />
CURLOPT_WRITEHEADER<br />
设置header部分内容的写入的文件地址，值是一个资源类型。<br />
对于下面的这些option的可选参数，value应该被设置为一个回调函数名：<br />
选项<br />
可选value值<br />
CURLOPT_HEADERFUNCTION<br />
设置一个回调函数，这个函数有两个参数，第一个是cURL的资源句柄，第二个是输出的header数据。header数据的输出必须依赖这个函数，返回已写入的数据大小。<br />
CURLOPT_PASSWDFUNCTION<br />
设置一个回调函数，有三个参数，第一个是cURL的资源句柄，第二个是一个密码提示符，第三个参数是密码长度允许的最大值。返回密码的值。<br />
CURLOPT_PROGRESSFUNCTION<br />
设置一个回调函数，有三个参数，第一个是cURL的资源句柄，第二个是一个文件描述符资源，第三个是长度。返回包含的数据。</p><br />
<br />
<p>CURLOPT_READFUNCTION<br />
拥有两个参数的回调函数，第一个是参数是会话句柄，第二是HTTP响应头信息的字符串。使用此函数，将自行处理返回的数据。返回值为数据大小，以字节计。返回0代表EOF信号。<br />
CURLOPT_WRITEFUNCTION<br />
拥有两个参数的回调函数，第一个是参数是会话句柄，第二是HTTP响应头信息的字符串。使用此回调函数，将自行处理响应头信息。响应头信息是整个字符串。设置返回值为精确的已写入字符串长度。发生错误时传输线程终止。</p><br />
<br />
<p>PHP中fopen,file_get_contents,curl函数的区别：</p><br />
<br />
<p>1.fopen /file_get_contents 每次请求都会重新做DNS查询，并不对 DNS信息进行缓存。但是CURL会自动对DNS信息进行缓存。对同一域名下的网页或者图片的请求只需要一次DNS查询。这大大减少了DNS查询的次数。所以CURL的性能比fopen /file_get_contents 好很多。</p><br />
<br />
<p>2.fopen /file_get_contents 在请求HTTP时，使用的是http_fopen_wrapper，不会keeplive。而curl却可以。这样在多次请求多个链接时，curl效率会好一些。</p><br />
<br />
<p>3.fopen / file_get_contents 函数会受到php.ini文件中allow_url_open选项配置的影响。如果该配置关闭了，则该函数也就失效了。而curl不受该配置的影响。</p><br />
<br />
<p>4.curl 可以模拟多种请求，例如：POST数据，表单提交等，用户可以按照自己的需求来定制请求。而fopen / file_get_contents只能使用get方式获取数据。<br />
file_get_contents 获取远程文件时会把结果都存在一个字符串中 fiels函数则会储存成数组形式</p><br />
<br />
<p>因此，我还是比较倾向于使用curl来访问远程url。Php有curl模块扩展，功能很是强大。</p><br />
<br />
<p>这是别人做过的关于curl和file_get_contents的测试：</p><br />
<br />
<p>file_get_contents抓取google.com需用秒数：<br />
2.31319094<br />
2.30374217<br />
2.21512604<br />
3.30553889<br />
2.30124092</p><br />
<br />
<p>curl使用的时间：<br />
0.68719101<br />
0.64675593<br />
0.64326<br />
0.81983113<br />
0.63956594</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category php
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>