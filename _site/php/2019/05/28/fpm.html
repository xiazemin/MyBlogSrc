<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">php-fpm</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-05-28T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> May 28, 2019</time></p>
					</div>
					 <p>https://github.com/xiazemin/php7-internal/blob/master/1/fpm.md</p><br />
<br />
<p>https://github.com/xiazemin/php-fpm-code-analysis</p><br />
<br />
<p>php-fpm是一个内置php解析器，采用prefork+异步IO 模型的高性能服务器程序<br />
php-fpm从php5.3.3开始已经进入到php源代码包，之前是作为patch存在的<br />
php-fpm 采用 prefork的方式 （listen同一个地址，然后fork出若干子进程)<br />
在子进程里面，采用异步IO处理客户端请求<br />
event模型可以在php-fpm.conf中配置<br />
; Specify the event mechanism FPM will use. The following <br />
is available:<br />
; - select     (any POSIX os)<br />
; - poll       (any POSIX os)<br />
; - epoll      (linux &gt;= 2.5.44)<br />
; - kqueue     (FreeBSD &gt;= 4.1, OpenBSD &gt;= 2.9, NetBSD &gt;= 2.0)<br />
; - /dev/poll  (Solaris &gt;= 7)<br />
; - port       (Solaris &gt;= 10)<br />
; Default Value: not set (auto detection)<br />
;events.mechanism = epoll<br />
<!-- more --><br />
在linux服务器上，如果不设置events.mechanism,那么默认就是采用epoll，所以</p><br />
<br />
<p>php-fpm的IO模型&amp;并发处理能力和nginx是完全一致</p><br />
<br />
<p>nginx以性能卓越闻名，大部分程序员都认为php效率低下，看了源代码，才知道这是传奇啊</p><br />
<br />
<p>在高性能部署的时候，大家往往会针对性的优化nginx 。我自己之前部署php程序也犯了错误，8G内存的server，php-fpm的max children都会设置128+，现在看来太多了，参考nginx的部署:<br />
nginx的worker_process一般设置为 2 * cpu-core<br />
php-fpm配置为 3倍 cpu core number就可以了</p><br />
<br />
<p>php-fpm稳定性比nginx稍差<br />
这是因为php-fpm内置了一个php解析器,php-fpm进程就和php程序捆绑了，如果php脚本写的不好，有死循环或者阻塞在某个远端资源上，会拖累加载它的php-fpm进程</p><br />
<br />
<p>而nginx和后端应用服务器之间通过网络连接，可以设置timeout，不容易堵死的</p><br />
<br />
<p>php-fpm的fastcgi是短连接<br />
我原以为是长连接的，看了代码才知道也是短连接，处理一个request就关闭掉</p><br />
<br />
<p>php-fpm接口采用fastcgi<br />
非常遗憾，php-fpm和fastcgi完全绑定了，无法独立使用 。只能部署在支持http-fcgi协议转换程序背后(nginx）。其实可以考虑在php-fpm代码包里面引入http协议支持，这样php-fpm可以独立运行，让nodejs无话可说</p><br />
<br />
<p>php-fpm等同于OpenResty<br />
OpenResty是一个国人开发的nginx模块，就是在nginx引入lua解释器. 实际上，它和php-fpm的唯一差别就是一个采用php语法，一个用lua，所以OpenResty要作为nginx增强包使用还可以，要选择它作为一个主要编程工具，没有任何必要</p><br />
<br />
<p>从架构上来说，php-fpm已经做到最好</p><br />
<br />
<p>PHP 只是一个脚本解析器，你可以把它理解为一个普通的函数，输入是 PHP 脚本。输出是执行结果，假如我们想用 PHP 代替 shell，在命令行中执行一个文件，那么就可以写一个程序来嵌入 PHP 解析器，这就是 cli 模式，这种模式下 PHP 就是普通的一个命令工具。接着我们又想：能不能让 PHP 处理 http 请求呢？这时就涉及到了网络处理，PHP 需要接收请求、解析协议，然后处理完成返回请求。在网络应用场景下，PHP 并没有像 Golang 那样实现 http 网络库，而是实现了 FastCGI 协议，然后与 web 服务器配合实现了 http 的处理，web 服务器来处理 http 请求，然后将解析的结果再通过 FastCGI 协议转发给处理程序，处理程序处理完成后将结果返回给 web 服务器，web 服务器再返回给用户</p><br />
<br />
<p>PHP 实现了 FastCGI 协议的解析，但是并没有具体实现网络处理，一般的处理模型：多进程、多线程，多进程模型通常是主进程只负责管理子进程，而基本的网络事件由各个子进程处理，nginx、fpm 就是这种模式；另一种多线程模型与多进程类似，只是它是线程粒度，通常会由主线程监听、接收请求，然后交由子线程处理，memcached 就是这种模式，有的也是采用多进程那种模式：主线程只负责管理子线程不处理网络事件，各个子线程监听、接收、处理请求，memcached 使用 udp 协议时采用的是这种模式。</p><br />
<br />
<p>fpm 的实现就是创建一个 master 进程，在 master 进程中创建并监听 socket，然后 fork 出多个子进程，这些子进程各自 accept 请求，子进程的处理非常简单，它在启动后阻塞在 accept 上，有请求到达后开始读取请求数据，读取完成后开始处理然后再返回，在这期间是不会接收其它请求的，也就是说 fpm 的子进程同时只能响应一个请求，只有把这个请求处理完成后才会 accept 下一个请求，这一点与 nginx 的事件驱动有很大的区别，nginx 的子进程通过 epoll 管理套接字，如果一个请求数据还未发送完成则会处理下一个请求，即一个进程会同时连接多个请求，它是非阻塞的模型，只处理活跃的套接字。</p><br />
<br />
<p>fpm 的 master 进程与 worker 进程之间不会直接进行通信，master 通过共享内存获取 worker 进程的信息，比如 worker 进程当前状态、已处理请求数等，当 master 进程要杀掉一个 worker 进程时则通过发送信号的方式通知 worker 进程。</p><br />
<br />
<p>fpm 可以同时监听多个端口，每个端口对应一个 worker pool，而每个 pool 下对应多个 worker 进程，类似 nginx 中 server 概念。</p><br />
<br />
<p>在 php-fpm.conf 中通过[pool name]声明一个 worker pool：</p><br />
<br />
<p>[web1]<br />
listen = 127.0.0.1:9000<br />
…</p><br />
<br />
<p>[web2]<br />
listen = 127.0.0.1:9001<br />
…</p><br />
<br />
<p>具体实现上 worker pool 通过fpm_worker_pool_s这个结构表示，多个 worker pool 组成一个单链表：</p><br />
<br />
<p>struct fpm_worker_pool_s {<br />
    struct fpm_worker_pool_s *next; //指向下一个worker pool<br />
    struct fpm_worker_pool_config_s *config; //conf配置:pm、max_children、start_servers…<br />
    int listening_socket; //监听的套接字<br />
    …</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//以下这个值用于master定时检查、记录worker数<br />
struct fpm_child_s *children; //当前pool的worker链表<br />
int running_children; //当前pool的worker运行总数<br />
int idle_spawn_rate;<br />
int warn_max_children;<br />
<br />
struct fpm_scoreboard_s *scoreboard; //记录worker的运行信息，比如空闲、忙碌worker数<br />
... }<br />
</code></pre></div></div><br />
<br />
<p>FPM的初始化<br />
接下来看下 fpm 的启动流程，从main()函数开始：</p><br />
<br />
<p>//sapi/fpm/fpm/fpm_main.c<br />
int main(int argc, char *argv[])<br />
{<br />
    …<br />
    //注册SAPI:将全局变量sapi_module设置为cgi_sapi_module<br />
    sapi_startup(&amp;cgi_sapi_module);<br />
    …<br />
    //执行php_module_starup()<br />
    if (cgi_sapi_module.startup(&amp;cgi_sapi_module) == FAILURE) {<br />
        return FPM_EXIT_SOFTWARE;<br />
    }<br />
    …<br />
    //初始化<br />
    if(0 &gt; fpm_init(…)){<br />
        …<br />
    }<br />
    …<br />
    fpm_is_running = 1;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fcgi_fd = fpm_run(&amp;max_requests);//后面都是worker进程的操作，master进程不会走到下面<br />
parent = 0;<br />
... } fpm_init()主要有以下几个关键操作：<br />
</code></pre></div></div><br />
<br />
<p>(1) fpm_conf_init_main():</p><br />
<br />
<p>解析 php-fpm.conf 配置文件，分配 worker pool 内存结构并保存到全局变量中：fpm_worker_all_pools，各 worker pool 配置解析到fpm_worker_pool_s-&gt;config中。</p><br />
<br />
<p>(2)fpm_scoreboard_init_main():</p><br />
<br />
<p>分配用于记录 worker 进程运行信息的共享内存，按照 worker pool 的最大 worker 进程数分配，每个 worker pool 分配一个fpm_scoreboard_s结构，pool 下对应的每个 worker 进程分配一个fpm_scoreboard_proc_s结构，各结构的对应关系如下图。<br />
<img src="https://xiazemin.github.io/MyBlog/img/fpm_worker_all_pools.png" /><br />
(3)fpm_signals_init_main():</p><br />
<br />
<p>static int sp[2];</p><br />
<br />
<p>int fpm_signals_init_main()<br />
{<br />
    struct sigaction act;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//创建一个全双工管道<br />
if (0 &gt; socketpair(AF_UNIX, SOCK_STREAM, 0, sp)) {<br />
    return -1;<br />
}<br />
//注册信号处理handler<br />
act.sa_handler = sig_handler;<br />
sigfillset(&amp;act.sa_mask);<br />
if (0 &gt; sigaction(SIGTERM,  &amp;act, 0) ||<br />
    0 &gt; sigaction(SIGINT,   &amp;act, 0) ||<br />
    0 &gt; sigaction(SIGUSR1,  &amp;act, 0) ||<br />
    0 &gt; sigaction(SIGUSR2,  &amp;act, 0) ||<br />
    0 &gt; sigaction(SIGCHLD,  &amp;act, 0) ||<br />
    0 &gt; sigaction(SIGQUIT,  &amp;act, 0)) {<br />
    return -1;<br />
}<br />
return 0; } 这里会通过socketpair()创建一个管道，这个管道并不是用于 master 与 worker 进程通信的，它只在 master 进程中使用，具体用途在稍后介绍 event 事件处理时再作说明。另外设置 master 的信号处理 handler，当 master 收到 SIGTERM、SIGINT、SIGUSR1、SIGUSR2、SIGCHLD、SIGQUIT 这些信号时将调用sig_handler()处理：<br />
</code></pre></div></div><br />
<br />
<p>static void sig_handler(int signo)<br />
{<br />
    static const char sig_chars[NSIG + 1] = {<br />
        [SIGTERM] = ‘T’,<br />
        [SIGINT]  = ‘I’,<br />
        [SIGUSR1] = ‘1’,<br />
        [SIGUSR2] = ‘2’,<br />
        [SIGQUIT] = ‘Q’,<br />
        [SIGCHLD] = ‘C’<br />
    };<br />
    char s;<br />
    …<br />
    s = sig_chars[signo];<br />
    //将信号通知写入管道sp[1]端<br />
    write(sp[1], &amp;s, sizeof(s));<br />
    …<br />
}<br />
(4)fpm_sockets_init_main()</p><br />
<br />
<p>创建每个 worker pool 的 socket 套接字。</p><br />
<br />
<p>(5)fpm_event_init_main():</p><br />
<br />
<p>启动 master 的事件管理，fpm 实现了一个事件管理器用于管理 IO、定时事件，其中 IO 事件通过 kqueue、epoll、poll、select 等管理，定时事件就是定时器，一定时间后触发某个事件。</p><br />
<br />
<p>在fpm_init()初始化完成后接下来就是最关键的fpm_run()操作了，此环节将 fork 子进程，启动进程管理器，另外 master 进程将不会再返回，只有各 worker 进程会返回，也就是说fpm_run()之后的操作均是 worker 进程的。</p><br />
<br />
<p>int fpm_run(int *max_requests)<br />
{<br />
    struct fpm_worker_pool_s *wp;<br />
    for (wp = fpm_worker_all_pools; wp; wp = wp-&gt;next) {<br />
        //调用fpm_children_make() fork子进程<br />
        is_parent = fpm_children_create_initial(wp);</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if (!is_parent) {<br />
        goto run_child;<br />
    }<br />
}<br />
//master进程将进入event循环，不再往下走<br />
fpm_event_loop(0);<br />
</code></pre></div></div><br />
<br />
<p>run_child: //只有worker进程会到这里</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*max_requests = fpm_globals.max_requests;<br />
return fpm_globals.listening_socket; //返回监听的套接字 } 在 fork 后 worker 进程返回了监听的套接字继续 main() 后面的处理，而 master 将永远阻塞在fpm_event_loop()，接下来分别介绍 master、worker 进程的后续操作。<br />
</code></pre></div></div><br />
<br />
<p>请求处理<br />
fpm_run()执行后将 fork 出 worker 进程，worker 进程返回main()中继续向下执行，后面的流程就是 worker 进程不断 accept 请求，然后执行 PHP 脚本并返回。整体流程如下：</p><br />
<br />
<p>(1)等待请求： worker 进程阻塞在 fcgi_accept_request() 等待请求；<br />
(2)解析请求： fastcgi 请求到达后被 worker 接收，然后开始接收并解析请求数据，直到 request 数据完全到达；<br />
(3)请求初始化： 执行 php_request_startup()，此阶段会调用每个扩展的：PHP_RINIT_FUNCTION()；<br />
(4)编译、执行： 由 php_execute_script() 完成 PHP 脚本的编译、执行；<br />
(5)关闭请求： 请求完成后执行 php_request_shutdown()，此阶段会调用每个扩展的：PHP_RSHUTDOWN_FUNCTION()，然后进入步骤 (1) 等待下一个请求。<br />
int main(int argc, char *argv[])<br />
{<br />
    …<br />
    fcgi_fd = fpm_run(&amp;max_requests);<br />
    parent = 0;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//初始化fastcgi请求<br />
request = fpm_init_request(fcgi_fd);<br />
<br />
//worker进程将阻塞在这，等待请求<br />
while (EXPECTED(fcgi_accept_request(request) &gt;= 0)) {<br />
    SG(server_context) = (void *) request;<br />
    init_request_info();<br />
    <br />
    //请求开始<br />
    if (UNEXPECTED(php_request_startup() == FAILURE)) {<br />
        ...<br />
    }<br />
    ...<br />
<br />
    fpm_request_executing();<br />
    //编译、执行PHP脚本<br />
    php_execute_script(&amp;file_handle);<br />
    ...<br />
    //请求结束<br />
    php_request_shutdown((void *) 0);<br />
    ...<br />
}<br />
...<br />
//worker进程退出<br />
php_module_shutdown();<br />
... } worker 进程一次请求的处理被划分为 5 个阶段：<br />
</code></pre></div></div><br />
<br />
<p>FPM_REQUEST_ACCEPTING: 等待请求阶段<br />
FPM_REQUEST_READING_HEADERS: 读取 fastcgi 请求 header 阶段<br />
FPM_REQUEST_INFO: 获取请求信息阶段，此阶段是将请求的 method、query stirng、request uri 等信息保存到各 worker 进程的 fpm_scoreboard_proc_s 结构中，此操作需要加锁，因为 master 进程也会操作此结构<br />
FPM_REQUEST_EXECUTING: 执行请求阶段<br />
FPM_REQUEST_END: 没有使用<br />
FPM_REQUEST_FINISHED: 请求处理完成<br />
worker 处理到各个阶段时将会把当前阶段更新到fpm_scoreboard_proc_s-&gt;request_stage，master 进程正是通过这个标识判断 worker 进程是否空闲的。</p><br />
<br />
<p>进程管理<br />
这一节我们来看下 master 是如何管理 worker 进程的，首先介绍下三种不同的进程管理方式：</p><br />
<br />
<p>static: 这种方式比较简单，在启动时 master 按照pm.max_children配置 fork 出相应数量的 worker 进程，即 worker 进程数是固定不变的；<br />
dynamic: 动态进程管理，首先在 fpm 启动时按照pm.start_servers初始化一定数量的 worker，运行期间如果 master 发现空闲 worker 数低于pm.min_spare_servers配置数（表示请求比较多，worker 处理不过来了）则会 fork worker 进程，但总的 worker 数不能超过pm.max_children，如果 master 发现空闲 worker 数超过了pm.max_spare_servers(表示闲着的 worker 太多了)则会杀掉一些 worker，避免占用过多资源，master 通过这 4 个值来控制 worker 数；<br />
ondemand: 这种方式一般很少用，在启动时不分配 worker 进程，等到有请求了后再通知 master 进程 fork worker 进程，总的 worker 数不超过pm.max_children，处理完成后 worker 进程不会立即退出，当空闲时间超过pm.process_idle_timeout后再退出；<br />
前面介绍到在fpm_run()中 master 进程将进入fpm_event_loop()：</p><br />
<br />
<p>void fpm_event_loop(int err)<br />
{<br />
    //创建一个io read的监听事件，这里监听的就是在fpm_init()阶段中通过socketpair()创建管道sp[0]<br />
    //当sp[0]可读时将回调fpm_got_signal()<br />
    fpm_event_set(&amp;signal_fd_event, fpm_signals_get_fd(), FPM_EV_READ, &amp;fpm_got_signal, NULL);<br />
    fpm_event_add(&amp;signal_fd_event, 0);</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//如果在php-fpm.conf配置了request_terminate_timeout则启动心跳检查<br />
if (fpm_globals.heartbeat &gt; 0) {<br />
    fpm_pctl_heartbeat(NULL, 0, NULL);<br />
}<br />
//定时触发进程管理<br />
fpm_pctl_perform_idle_server_maintenance_heartbeat(NULL, 0, NULL);<br />
<br />
//进入事件循环，master进程将阻塞在此<br />
while (1) {<br />
    ...<br />
    //等待IO事件<br />
    ret = module-&gt;wait(fpm_event_queue_fd, timeout);<br />
    ...<br />
    //检查定时器事件<br />
    ...<br />
} } 这就是 master 整体的处理，其进程管理主要依赖注册的几个事件，接下来我们详细分析下这几个事件的功能。<br />
</code></pre></div></div><br />
<br />
<p>(1)sp[1]管道可读事件：</p><br />
<br />
<p>在fpm_init()阶段 master 曾创建了一个全双工的管道：sp，然后在这里创建了一个 sp[0] 可读的事件，当 sp[0] 可读时将交由fpm_got_signal()处理，向 sp[1] 写数据时 sp[0] 才会可读，那么什么时机会向 sp[1] 写数据呢？前面已经提到了：当 master 收到注册的那几种信号时会写入 sp[1] 端，这个时候将触发 sp[0] 可读事件。</p><br />
<br />
<p>这个事件是 master 用于处理信号的，我们根据 master 注册的信号逐个看下不同用途：</p><br />
<br />
<p>SIGINT/SIGTERM/SIGQUIT: 退出 fpm，在 master 收到退出信号后将向所有的 worker 进程发送退出信号，然后 master 退出；<br />
SIGUSR1: 重新加载日志文件，生产环境中通常会对日志进行切割，切割后会生成一个新的日志文件，如果 fpm 不重新加载将无法继续写入日志，这个时候就需要向 master 发送一个 USR1 的信号；<br />
SIGUSR2: 重启 fpm，首先 master 也是会向所有的 worker 进程发送退出信号，然后 master 会调用 execvp() 重新启动 fpm ，最后旧的 master 退出；<br />
SIGCHLD: 这个信号是子进程退出时操作系统发送给父进程的，子进程退出时，内核将子进程置为僵尸状态，这个进程称为僵尸进程，它只保留最小的一些内核数据结构，以便父进程查询子进程的退出状态，只有当父进程调用 wait 或者 waitpid 函数查询子进程退出状态后子进程才告终止， fpm 中当 worker 进程因为异常原因（比如 coredump 了）退出而非 master 主动杀掉时 master 将受到此信号，这个时候父进程将调用 waitpid() 查下子进程的退出，然后检查下是不是需要重新 fork 新的 worker；<br />
具体处理逻辑在fpm_got_signal()函数中，这里不再罗列。</p><br />
<br />
<p>(2)fpm_pctl_perform_idle_server_maintenance_heartbeat():</p><br />
<br />
<p>这是进程管理实现的主要事件，master 启动了一个定时器，每隔 1s 触发一次，主要用于 dynamic、ondemand 模式下的 worker 管理，master 会定时检查各 worker pool 的 worker 进程数，通过此定时器实现 worker 数量的控制，处理逻辑如下：</p><br />
<br />
<p>static void fpm_pctl_perform_idle_server_maintenance(struct timeval *now)<br />
{<br />
    for (wp = fpm_worker_all_pools; wp; wp = wp-&gt;next) {<br />
        struct fpm_child_s *last_idle_child = NULL; //空闲时间最久的worker<br />
        int idle = 0; //空闲worker数<br />
        int active = 0; //忙碌worker数</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    for (child = wp-&gt;children; child; child = child-&gt;next) {<br />
        //根据worker进程的fpm_scoreboard_proc_s-&gt;request_stage判断<br />
        if (fpm_request_is_idle(child)) {<br />
            //找空闲时间最久的worker<br />
            ...<br />
            idle++;<br />
        }else{<br />
            active++;<br />
        }<br />
    }<br />
    ...<br />
    //ondemand模式<br />
    if (wp-&gt;config-&gt;pm == PM_STYLE_ONDEMAND) {<br />
        if (!last_idle_child) continue;<br />
<br />
        fpm_request_last_activity(last_idle_child, &amp;last);<br />
        fpm_clock_get(&amp;now);<br />
        if (last.tv_sec &lt; now.tv_sec - wp-&gt;config-&gt;pm_process_idle_timeout) {<br />
            //如果空闲时间最长的worker空闲时间超过了process_idle_timeout则杀掉该worker<br />
            last_idle_child-&gt;idle_kill = 1;<br />
            fpm_pctl_kill(last_idle_child-&gt;pid, FPM_PCTL_QUIT);<br />
        } <br />
        continue;<br />
    }<br />
    //dynamic<br />
    if (wp-&gt;config-&gt;pm != PM_STYLE_DYNAMIC) continue;<br />
    if (idle &gt; wp-&gt;config-&gt;pm_max_spare_servers &amp;&amp; last_idle_child) {<br />
        //空闲worker太多了，杀掉<br />
        last_idle_child-&gt;idle_kill = 1;<br />
        fpm_pctl_kill(last_idle_child-&gt;pid, FPM_PCTL_QUIT);<br />
        wp-&gt;idle_spawn_rate = 1;<br />
        continue;<br />
    }<br />
    if (idle &lt; wp-&gt;config-&gt;pm_min_spare_servers) {<br />
        //空闲worker太少了，如果总worker数未达到max数则fork<br />
        ...<br />
    }<br />
} } (3)fpm_pctl_heartbeat():<br />
</code></pre></div></div><br />
<br />
<p>这个事件是用于限制 worker 处理单个请求最大耗时的，php-fpm.conf 中有一个request_terminate_timeout的配置项，如果 worker 处理一个请求的总时长超过了这个值那么 master 将会向此 worker 进程发送kill -TERM信号杀掉 worker 进程，此配置单位为秒，默认值为 0 表示关闭此机制，另外 fpm 打印的 slow log 也是在这里完成的。</p><br />
<br />
<p>static void fpm_pctl_check_request_timeout(struct timeval *now)<br />
{ <br /><br />
    struct fpm_worker_pool_s *wp;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (wp = fpm_worker_all_pools; wp; wp = wp-&gt;next) {<br />
    int terminate_timeout = wp-&gt;config-&gt;request_terminate_timeout;<br />
    int slowlog_timeout = wp-&gt;config-&gt;request_slowlog_timeout;<br />
    struct fpm_child_s *child;<br />
<br />
    if (terminate_timeout || slowlog_timeout) { <br />
        for (child = wp-&gt;children; child; child = child-&gt;next) {<br />
            //检查当前当前worker处理的请求是否超时<br />
            fpm_request_check_timed_out(child, now, terminate_timeout, slowlog_timeout);<br />
        }<br />
    }<br />
} } 除了上面这几个事件外还有一个没有提到，那就是 ondemand 模式下 master 监听的新请求到达的事件，因为 ondemand 模式下 fpm 启动时是不会预创建 worker 的，有请求时才会生成子进程，所以请求到达时需要通知 master 进程，这个事件是在fpm_children_create_initial()时注册的，事件处理函数为fpm_pctl_on_socket_accept()，具体逻辑这里不再展开，比较容易理解。<br />
</code></pre></div></div><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category php
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>