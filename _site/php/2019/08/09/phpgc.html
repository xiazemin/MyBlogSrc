<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">phpgc</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-08-09T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Aug 9, 2019</time></p>
					</div>
					 <p>以前的 php 用到的引用计数内存机制，无法处理循环的引用内存泄漏。然而 5.3.0 PHP 使用文章» 引用计数系统中的同步周期回收(Concurrent Cycle Collection in Reference Counted Systems)中的同步算法，来处理这个内存泄漏问题。</p><br />
<br />
<p>对算法的完全说明有点超出这部分内容的范围，将只介绍其中基础部分。首先，我们先要建立一些基本规则，如果一个引用计数增加，它将继续被使用，当然就不再在垃圾中。如果引用计数减少到零，所在变量容器将被清除(free)。就是说，仅仅在引用计数减少到非零值时，才会产生垃圾周期(garbage cycle)。其次，在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾。<br />
<!-- more --><br />
为避免不得不检查所有引用计数可能减少的垃圾周期，这个算法把所有可能根(possible roots 都是zval变量容器),放在根缓冲区(root buffer)中(用紫色来标记，称为疑似垃圾)，这样可以同时确保每个可能的垃圾根(possible garbage root)在缓冲区中只出现一次。仅仅在根缓冲区满了时，才对缓冲区内部所有不同的变量容器执行垃圾回收操作</p><br />
<br />
<p>模拟删除每个紫色变量。模拟删除时可能将不是紫色的普通变量引用数减”1”，如果某个普通变量引用计数变成0了，就对这个普通变量再做一次模拟删除。每个变量只能被模拟删除一次，模拟删除后标记为灰（原文说确保不会对同一个变量容器减两次”1”,不对的吧）。</p><br />
<br />
<p>模拟恢复每个紫色变量。恢复是有条件的，当变量的引用计数大于0时才对其做模拟恢复。同样每个变量只能恢复一次，恢复后标记为黑，基本就是步骤 B 的逆运算。这样剩下的一堆没能恢复的就是该删除的蓝色节点了，在步骤 D 中遍历出来真的删除掉。</p><br />
<br />
<p>算法中都是模拟删除、模拟恢复、真的删除，都使用简单的遍历即可（最典型的深搜遍历）。复杂度为执行模拟操作的节点数正相关，不只是紫色的那些疑似垃圾变量。</p><br />
<br />
<p>现在，你已经对这个算法有了基本了解，我们回头来看这个如何与PHP集成。默认的，PHP的垃圾回收机制是打开的，然后有个 php.ini 设置允许你修改它：zend.enable_gc 。</p><br />
<br />
<p>当垃圾回收机制打开时，每当根缓存区存满时，就会执行上面描述的循环查找算法。根缓存区有固定的大小，可存10,000个可能根,当然你可以通过修改PHP源码文件Zend/zend_gc.c中的常量GC_ROOT_BUFFER_MAX_ENTRIES，然后重新编译PHP，来修改这个10,000值。当垃圾回收机制关闭时，循环查找算法永不执行，然而，可能根将一直存在根缓冲区中，不管在配置中垃圾回收机制是否激活。</p><br />
<br />
<p>当垃圾回收机制关闭时，如果根缓冲区存满了可能根，更多的可能根显然不会被记录。那些没被记录的可能根，将不会被这个算法来分析处理。如果他们是循环引用周期的一部分，将永不能被清除进而导致内存泄漏。</p><br />
<br />
<p>即使在垃圾回收机制不可用时，可能根也被记录的原因是，相对于每次找到可能根后检查垃圾回收机制是否打开而言，记录可能根的操作更快。不过垃圾回收和分析机制本身要耗不少时间。</p><br />
<br />
<p>除了修改配置zend.enable_gc ，也能通过分别调用gc_enable() 和 gc_disable()函数来打开和关闭垃圾回收机制。调用这些函数，与修改配置项来打开或关闭垃圾回收机制的效果是一样的。即使在可能根缓冲区还没满时，也能强制执行周期回收。你能调用gc_collect_cycles()函数达到这个目的。这个函数将返回使用这个算法回收的周期数。</p><br />
<br />
<p>允许打开和关闭垃圾回收机制并且允许自主的初始化的原因，是由于你的应用程序的某部分可能是高时效性的。在这种情况下，你可能不想使用垃圾回收机制。当然，对你的应用程序的某部分关闭垃圾回收机制，是在冒着可能内存泄漏的风险，因为一些可能根也许存不进有限的根缓冲区。因此，就在你调用gc_disable()函数释放内存之前，先调用gc_collect_cycles()函数可能比较明智。因为这将清除已存放在根缓冲区中的所有可能根，然后在垃圾回收机制被关闭时，可留下空缓冲区以有更多空间存储可能根。</p><br />
<br />
<p>在5.2及更早版本的PHP中，没有专门的垃圾回收器GC（Garbage Collection），引擎在判断一个变量空间是否能够被释放的时候是依据这个变量的zval的refcount的值，如果refcount为0，那么变量的空间可以被释放，否则就不释放，这是一种非常简单的GC实现。然而在这种简单的GC实现方案中，出现了意想不到的变量内存泄漏情况（Bug:http://bugs.php.net/bug.php?id=33595），引擎将无法回收这些内存，于是在PHP5.3中出现了新的GC，新的GC有专门的机制负责清理垃圾数据，防止内存泄漏。本文将详细的阐述PHP5.3中新的GC运行机制。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>目前很少有详细的资料介绍新的GC，本文将是目前国内最为详细的从源码角度介绍PHP5.3中GC原理的文章。其中关于垃圾产生以及算法简介部分由笔者根据手册翻译而来，当然其中融入了本人的一些看法。手册中相关内容：Garbage Collection<br />
<br />
在介绍这个新的GC之前，读者必须先了解PHP中变量的内部存储相关知识，请先阅读 变量的内部存储：引用和计数 <br />
</code></pre></div></div><br />
<br />
<p>什么算垃圾</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>首先我们需要定义一下“垃圾”的概念，新的GC负责清理的垃圾是指变量的容器zval还存在，但是又没有任何变量名指向此zval。因此GC判断是否为垃圾的一个重要标准是有没有变量名指向变量容器zval。<br />
<br />
假设我们有一段PHP代码，使用了一个临时变量$tmp存储了一个字符串，在处理完字符串之后，就不需要这个$tmp变量了，$tmp变量对于我们来说可以算是一个“垃圾”了，但是对于GC来说，$tmp其实并不是一个垃圾，$tmp变量对我们没有意义，但是这个变量实际还存在，$tmp符号依然指向它所对应的zval，GC会认为PHP代码中可能还会使用到此变量，所以不会将其定义为垃圾。<br />
<br />
那么如果我们在PHP代码中使用完$tmp后，调用unset删除这个变量，那么$tmp是不是就成为一个垃圾了呢。很可惜，GC仍然不认为$tmp是一个垃圾，因为$tmp在unset之后，refcount减少1变成了0(这里假设没有别的变量和$tmp指向相同的zval),这个时候GC会直接将$tmp对应的zval的内存空间释放，$tmp和其对应的zval就根本不存在了。此时的$tmp也不是新的GC所要对付的那种“垃圾”。那么新的GC究竟要对付什么样的垃圾呢，下面我们将生产一个这样的垃圾。  <br />
</code></pre></div></div><br />
<br />
<p>顽固垃圾的产生过程</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>如果读者已经阅读了变量内部存储相关的内容，想必对refcount和isref这些变量内部的信息有了一定的了解。这里我们将结合手册中的一个例子来介绍垃圾的产生过程：<br />
</code></pre></div></div><br />
<br />
<p>&lt;?php</p><br />
<br />
<p>$a = “new string”;</p><br />
<br />
<p>?&gt;</p><br />
<br />
<p>在这么简单的一个代码中，$a变量内部存储信息为</p><br />
<br />
<p>a: (refcount=1, is_ref=0)=’new string’</p><br />
<br />
<p>当把$a赋值给另外一个变量的时候，$a对应的zval的refcount会加1</p><br />
<br />
<p>&lt;?php</p><br />
<br />
<p>$a = “new string”;</p><br />
<br />
<p>$b = $a;</p><br />
<br />
<p>?&gt;<br />
此时$a和$b变量对应的内部存储信息为</p><br />
<br />
<p>a,b: (refcount=2, is_ref=0)=’new string’</p><br />
<br />
<p>当我们用unset删除$b变量的时候，$b对应的zval的refcount会减少1</p><br />
<br />
<p>&lt;?php</p><br />
<br />
<p>$a = “new string”; //a: (refcount=1, is_ref=0)=’new string’</p><br />
<br />
<p>$b = $a;                 //a,b: (refcount=2, is_ref=0)=’new string’</p><br />
<br />
<p>unset($b);              //a: (refcount=1, is_ref=0)=’new string’</p><br />
<br />
<p>?&gt;</p><br />
<br />
<p>对于普通的变量来说，这一切似乎很正常，但是在复合类型变量（数组和对象）中，会发生比较有意思的事情：</p><br />
<br />
<p>&lt;?php</p><br />
<br />
<p>$a = array(‘meaning’ =&gt; ‘life’, ‘number’ =&gt; 42);</p><br />
<br />
<p>?&gt;</p><br />
<br />
<p>a的内部存储信息为:</p><br />
<br />
<p>a: (refcount=1, is_ref=0)=array (<br />
   ‘meaning’ =&gt; (refcount=1, is_ref=0)=’life’,<br />
   ‘number’ =&gt; (refcount=1, is_ref=0)=42<br />
)</p><br />
<br />
<p>数组变量本身($a)在引擎内部实际上是一个哈希表，这张表中有两个zval项 meaning和number，</p><br />
<br />
<p>所以实际上那一行代码中一共生成了3个zval,这3个zval都遵循变量的引用和计数原则，<br />
下面在$a中添加一个元素，并将现有的一个元素的值赋给新的元素:</p><br />
<br />
<p>&lt;?php</p><br />
<br />
<p>$a = array(‘meaning’ =&gt; ‘life’, ‘number’ =&gt; 42);</p><br />
<br />
<p>$a[‘life’] = $a[‘meaning’];</p><br />
<br />
<p>?&gt;</p><br />
<br />
<p>那么$a的内部存储为:</p><br />
<br />
<p>a: (refcount=1, is_ref=0)=array (<br />
   ‘meaning’ =&gt; (refcount=2, is_ref=0)=’life’,<br />
   ‘number’ =&gt; (refcount=1, is_ref=0)=42,<br />
   ‘life’ =&gt; (refcount=2, is_ref=0)=’life’<br />
)<br />
其中的meaning元素和life元素之指向同一个zval的：</p><br />
<br />
<p>现在，如果我们试一下，将数组的引用赋值给数组中的一个元素，有意思的事情就发生了：</p><br />
<br />
<p>&lt;?php</p><br />
<br />
<p>$a = array(‘one’);</p><br />
<br />
<p>$a[] = &amp;$a;</p><br />
<br />
<p>?&gt;</p><br />
<br />
<p>这样$a数组就有两个元素，一个索引为0，值为字符one,另外一个索引为1，为$a自身的引用，内部存储如下:</p><br />
<br />
<p>a: (refcount=2, is_ref=1)=array (<br />
   0 =&gt; (refcount=1, is_ref=0)=’one’,<br />
   1 =&gt; (refcount=2, is_ref=1)=…<br />
)</p><br />
<br />
<p>“…”表示1指向a自身，是一个环形引用：</p><br />
<br />
<p>这个时候我们对$a进行unset,那么$a会从符号表中删除，同时$a指向的zval的refcount减少1</p><br />
<br />
<p>&lt;?php</p><br />
<br />
<p>$a = array(‘one’);</p><br />
<br />
<p>$a[] = &amp;$a;</p><br />
<br />
<p>unset($a);</p><br />
<br />
<p>?&gt;</p><br />
<br />
<p>那么问题也就产生了，$a已经不在符号表中了，用户无法再访问此变量，但是$a之前指向的zval的refcount变为1而不是0，因此不能被回收，这样产生了内存泄露</p><br />
<br />
<p>这样，这么一个zval就成为了一个真是意义的垃圾了，新的GC要做的工作就是清理这种垃圾。</p><br />
<br />
<p>为解决这种垃圾，产生了新的GC</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在PHP5.3版本中，使用了专门GC机制清理垃圾，在之前的版本中是没有专门的GC，那么垃圾产生的时候，没有办法清理，内存就白白浪费掉了。在PHP5.3源代码中多了以下文件:{PHPSRC}/Zend/zend_gc.h {PHPSRC}/Zend/zend_gc.c, 这里就是新的GC的实现，我们先简单的介绍一下算法思路，然后再从源码的角度详细介绍引擎中如何实现这个算法的。<br />
</code></pre></div></div><br />
<br />
<p>新的GC算法</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在较新的PHP手册中有简单的介绍新的GC使用的垃圾清理算法，这个算法名为 Concurrent Cycle Collection in Reference Counted Systems ， 这里不详细介绍此算法，根据手册中的内容来先简单的介绍一下思路：<br />
</code></pre></div></div><br />
<br />
<p>首先我们有几个基本的准则：</p><br />
<br />
<p>1：如果一个zval的refcount增加，那么此zval还在使用，不属于垃圾</p><br />
<br />
<p>2：如果一个zval的refcount减少到0， 那么zval可以被释放掉，不属于垃圾</p><br />
<br />
<p>3：如果一个zval的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾</p><br />
<br />
<p>只有在准则3下，GC才会把zval收集起来，然后通过新的算法来判断此zval是否为垃圾。那么如何判断这么一个变量是否为真正的垃圾呢？</p><br />
<br />
<p>简单的说，就是对此zval中的每个元素进行一次refcount减1操作，操作完成之后，如果zval的refcount=0，那么这个zval就是一个垃圾。这个原理咋看起来很简单，但是又不是那么容易理解，起初笔者也无法理解其含义，直到挖掘了源代码之后才算是了解。如果你现在不理解没有关系，后面会详细介绍，这里先把这算法的几个步骤描叙一下,首先引用手册中的一张图:</p><br />
<br />
<p>A：为了避免每次变量的refcount减少的时候都调用GC的算法进行垃圾判断，此算法会先把所有前面准则3情况下的zval节点放入一个节点(root)缓冲区(root buffer)，并且将这些zval节点标记成紫色，同时算法必须确保每一个zval节点在缓冲区中之出现一次。当缓冲区被节点塞满的时候，GC才开始开始对缓冲区中的zval节点进行垃圾判断。</p><br />
<br />
<p>B：当缓冲区满了之后，算法以深度优先对每一个节点所包含的zval进行减1操作，为了确保不会对同一个zval的refcount重复执行减1操作，一旦zval的refcount减1之后会将zval标记成灰色。需要强调的是，这个步骤中，起初节点zval本身不做减1操作，但是如果节点zval中包含的zval又指向了节点zval（环形引用），那么这个时候需要对节点zval进行减1操作。</p><br />
<br />
<p>C：算法再次以深度优先判断每一个节点包含的zval的值，如果zval的refcount等于0，那么将其标记成白色(代表垃圾)，如果zval的refcount大于0，那么将对此zval以及其包含的zval进行refcount加1操作，这个是对非垃圾的还原操作，同时将这些zval的颜色变成黑色（zval的默认颜色属性）</p><br />
<br />
<p>D：遍历zval节点，将C中标记成白色的节点zval释放掉。</p><br />
<br />
<p>这ABCD四个过程是手册中对这个算法的介绍，这还不是那么容易理解其中的原理，这个算法到底是个什么意思呢？我自己的理解是这样的：</p><br />
<br />
<p>比如还是前面那个变成垃圾的数组$a对应的zval,命名为zval_a,  如果没有执行unset， zval_a的refcount为2,分别由$a和$a中的索引1指向这个zval。  用算法对这个数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，由于索引1对应的就是zval_a，所以这个时候zval_a的refcount应该变成了1，这样zval_a就不是一个垃圾。如果执行了unset操作，zval_a的refcount就是1，由zval_a中的索引1指向zval_a,用算法对数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，这样zval_a的refcount就会变成0，于是就发现zval_a是一个垃圾了。 算法就这样发现了顽固的垃圾数据。</p><br />
<br />
<p>举了这个例子，读者大概应该能够知道其中的端倪：</p><br />
<br />
<p>对于一个包含环形引用的数组，对数组中包含的每个元素的zval进行减1操作，之后如果发现数组自身的zval的refcount变成了0，那么可以判断这个数组是一个垃圾。</p><br />
<br />
<p>这个道理其实很简单，假设数组a的refcount等于m, a中有n个元素又指向a,如果m等于n,那么算法的结果是m减n，m-n=0，那么a就是垃圾，如果m&gt;n,那么算法的结果m-n&gt;0,所以a就不是垃圾了</p><br />
<br />
<p>m=n代表什么？  代表a的refcount都来自数组a自身包含的zval元素,代表a之外没有任何变量指向它，代表用户代码空间中无法再访问到a所对应的zval，代表a是泄漏的内存，因此GC将a这个垃圾回收了。</p><br />
<br />
<p>PHP中运用新的GC的算法</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在PHP中，GC默认是开启的，你可以通过ini文件中的 zend.enable_gc 项来开启或则关闭GC。当GC开启的时候，垃圾分析算法将在节点缓冲区(roots buffer)满了之后启动。缓冲区默认可以放10,000个节点，当然你也可以通过修改Zend/zend_gc.c中的GC_ROOT_BUFFER_MAX_ENTRIES 来改变这个数值，需要重新编译链接PHP。当GC关闭的时候，垃圾分析算法就不会运行，但是相关节点还会被放入节点缓冲区，这个时候如果缓冲区节点已经放满，那么新的节点就不会被记录下来，这些没有被记录下来的节点就永远也不会被垃圾分析算法分析。如果这些节点中有循环引用，那么有可能产生内存泄漏。之所以在GC关闭的时候还要记录这些节点，是因为简单的记录这些节点比在每次产生节点的时候判断GC是否开启更快，另外GC是可以在脚本运行中开启的，所以记录下这些节点，在代码运行的某个时候如果又开启了GC，这些节点就能被分析算法分析。当然垃圾分析算法是一个比较耗时的操作。<br />
<br />
在PHP代码中我们可以通过gc_enable()和gc_disable()函数来开启和关闭GC，也可以通过调用gc_collect_cycles()在节点缓冲区未满的情况下强制执行垃圾分析算法。这样用户就可以在程序的某些部分关闭或则开启GC，也可强制进行垃圾分析算法。 <br />
</code></pre></div></div><br />
<br />
<p>新的GC算法的性能</p><br />
<br />
<p>1.防止泄漏节省内存</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>新的GC算法的目的就是为了防止循环引用的变量引起的内存泄漏问题，在PHP中GC算法，当节点缓冲区满了之后，垃圾分析算法会启动，并且会释放掉发现的垃圾，从而回收内存，在PHP手册上给了一段代码和内存使用状况图：<br />
</code></pre></div></div><br />
<br />
<p>&lt;?php<br />
class Foo<br />
{<br />
    public $var = ‘3.1415962654’;<br />
}</p><br />
<br />
<p>$baseMemory = memory_get_usage();</p><br />
<br />
<p>for ( $i = 0; $i &lt;= 100000; $i++ )<br />
{<br />
    $a = new Foo;<br />
    $a-&gt;self = $a;<br />
    if ( $i % 500 === 0 )<br />
    {<br />
        echo sprintf( ‘%8d: ‘, $i ), memory_get_usage() - $baseMemory, “/n”;<br />
    }<br />
}<br />
?&gt;</p><br />
<br />
<p>这段代码的循环体中，新建了一个对象变量，并且用对象的一个成员指向了自己，这样就形成了一个循环引用，当进入下一次循环的时候，又一次给对象变量重新赋值，这样会导致之前的对象变量内存泄漏，在这个例子里面有两个变量泄漏了，一个是对象本身，另外一个是对象中的成员self，但是这两个变量只有对象会作为垃圾收集器的节点被放入缓冲区(因为重新赋值相当于对它进行了unset操作，满足前面的准则3)。在这里我们进行了100,000次循环，而GC在缓冲区中有10,000节点的时候会启动垃圾分析算法，所以这里一共会进行10次的垃圾分析算法。从图中可以清晰的看到，在5.3版本PHP中，每次GC的垃圾分析算法被触发后，内存会有一个明显的减少。而在5.2版本的PHP中，内存使用量会一直增加。</p><br />
<br />
<p>2：运行效率影响</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>启用了新的GC后，垃圾分析算法将是一个比较耗时的操作，手册中给了一段测试代码：<br />
</code></pre></div></div><br />
<br />
<p>&lt;?php<br />
class Foo<br />
{<br />
    public $var = ‘3.1415962654’;<br />
}</p><br />
<br />
<p>for ( $i = 0; $i &lt;= 1000000; $i++ )<br />
{<br />
    $a = new Foo;<br />
    $a-&gt;self = $a;<br />
}</p><br />
<br />
<p>echo memory_get_peak_usage(), “/n”;<br />
?&gt;</p><br />
<br />
<p>然后分别在GC开启和关闭的情况下执行这段代码：</p><br />
<br />
<p>time php -dzend.enable_gc=0 -dmemory_limit=-1 -n example2.php</p><br />
<h1 id="and">and</h1><br />
<p>time php -dzend.enable_gc=1 -dmemory_limit=-1 -n example2.php</p><br />
<br />
<p>最终在该机器上，第一次执行大概使用10.7秒，第二次执行大概使用11.4秒，性能大约降低7%,不过内存的使用量降低了98%,从931M降低到了10M。当然这并不是一个比较科学的测试方法，但是也能说明一定的问题。这种代码测试的是一种极端恶劣条件，实际代码中，特别是在WEB的应用中，很难出现大量循环引用，GC的分析算法的启动不会这么频繁，小规模的代码中甚至很少有机会启动GC分析算法。</p><br />
<br />
<p>总结：</p><br />
<br />
<p>当GC的垃圾分析算法执行的时候，PHP脚本的效率会受到一定的影响，但是小规模的代码一般不会有这个机会运行这个算法。如果一旦脚本中GC分析算法开始运行了，那么将花费少量的时间节省出来了大量的内存，是一件非常划算的事情。新的GC对一些长期运行的PHP脚本效果更好，比如PHP的DAEMON守护进程，或则PHP-GTK进程等等。</p><br />
<br />
<p>引擎内部GC的实现</p><br />
<br />
<p>前面已经介绍了新的GC的基本原理以及性能相关的内容，其中一些都是在手册中有简单介绍了，那么这里我们将从源代码的角度来分析一下PHP如何实现新的GC。</p><br />
<br />
<p>1.zval的变化</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>在文件Zend/zend_gc.h中，重新定义了分配一个zval结构的宏:<br />
</code></pre></div></div><br />
<br />
<p>[cpp] view plain copy</p><br />
<br />
<p>#undef  ALLOC_ZVAL</p><br />
<br />
<p>#define ALLOC_ZVAL(z)                                   /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>do {                                                /  <br />
<br />
    (z) = (zval*)emalloc(sizeof(zval_gc_info));     /  <br />
<br />
    GC_ZVAL_INIT(z);                                /  <br />
<br />
} while (0)  <br />
</code></pre></div></div><br />
<br />
<p>ALLOC_ZVAL的原始定义是在Zend/zend_alloc.h中，原始的定义只是分配一个zval结构的内存空间，然后在新的GC使用后，分配一个zval空间实际上是分配了一个zval_gc_info结构的空间，下面看看zval_gc_info结构定义:</p><br />
<br />
<p>[cpp] view plain copy</p><br />
<br />
<p>typedef struct _zval_gc_info {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zval z;  <br />
<br />
union {  <br />
<br />
    gc_root_buffer       *buffered;  <br />
<br />
    struct _zval_gc_info *next;  <br />
<br />
} u;  <br />
</code></pre></div></div><br />
<br />
<p>} zval_gc_info;</p><br />
<br />
<p>zval_gc_info这个结构的第一个成员就是一个zval结构，第二个成员是一个联合体u，是一个指向gc_root_buffer的指针和一个指向_zval_gc_info的指针。  第一个成员为zval结构，这就保证了对zval_gc_info类型指针做类型转换后和zval等价。在ALLOC_ZVAL宏中，分配了一个zval_gc_info的空间后，是将空间的指针转换成了(zval *)。这样就相当于分配了一个zval的空间。然后GC_ZVAL_INIT宏会把zval_gc_info中的成员u的buffered字段设置成NULL:</p><br />
<br />
<p>[cpp] view plain copy</p><br />
<br />
<p>#define GC_ZVAL_INIT(z) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>((zval_gc_info*)(z))-&gt;u.buffered = NULL  <br />
</code></pre></div></div><br />
<br />
<p>这个u.buffered指针就是用来表示这个zval对应的节点信息指针。</p><br />
<br />
<p>新的GC会为所有的zval分配一个空间存放节点信息指针，只有当zval被GC放入节点缓冲区的时候，节点信息指针才会被指向一个节点信息结构，否则节点信息指针一直是NULL。</p><br />
<br />
<p>具体方式是通过分配一个zval_gc_info结构来实现，这个结构包含了zval和节点信息指针buffered。</p><br />
<br />
<p>2.节点信息</p><br />
<br />
<p>zval的节点信息指针buffered指向一个gc_root_buffer类型，这个类型的定义如下:</p><br />
<br />
<p>[cpp] view plain copy</p><br />
<br />
<p>typedef struct _gc_root_buffer {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>struct _gc_root_buffer   *prev;     /* double-linked list               */  <br />
<br />
struct _gc_root_buffer   *next;  <br />
<br />
zend_object_handle        handle;   /* must be 0 for zval               */  <br />
<br />
union {  <br />
<br />
    zval                 *pz;  <br />
<br />
    zend_object_handlers *handlers;  <br />
<br />
} u;  <br />
</code></pre></div></div><br />
<br />
<p>} gc_root_buffer;</p><br />
<br />
<p>这是一个双链表的节点结构类型，prev和next用来指向前一个节点和后一个节点，handel是和对象相关的，对象类型的变量比较特殊，我们这里不讨论，u是一个联合体，u.pz用来指向这个节点所对应的zval结构。 这样每一个zval结构和zval对应的节点信息互相被关联在一起了:</p><br />
<br />
<p>通过一个zval指针pz找到节点指针: pr = ((zval_gc_info *)pz)-&gt;u.buffered</p><br />
<br />
<p>通过一个节点指针pr找到zval指针: pz = pr-&gt;u.pz</p><br />
<br />
<p>3.为zval设置节点信息以及节点颜色信息</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>这里GC应用了一些小技巧，先看看下面相关的宏:<br />
</code></pre></div></div><br />
<br />
<p>[cpp] view plain copy</p><br />
<br />
<p>#define GC_COLOR  0x03</p><br />
<br />
<p>#define GC_BLACK  0x00</p><br />
<br />
<p>#define GC_WHITE  0x01</p><br />
<br />
<p>#define GC_GREY   0x02</p><br />
<br />
<p>#define GC_PURPLE 0x03</p><br />
<br />
<p>#define GC_ADDRESS(v) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>((gc_root_buffer*)(((zend_uintptr_t)(v)) &amp; ~GC_COLOR))  <br />
</code></pre></div></div><br />
<br />
<p>#define GC_SET_ADDRESS(v, a) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(v) = ((gc_root_buffer*)((((zend_uintptr_t)(v)) &amp; GC_COLOR) | ((zend_uintptr_t)(a))))  <br />
</code></pre></div></div><br />
<br />
<p>#define GC_GET_COLOR(v) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(((zend_uintptr_t)(v)) &amp; GC_COLOR)  <br />
</code></pre></div></div><br />
<br />
<p>#define GC_SET_COLOR(v, c) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(v) = ((gc_root_buffer*)((((zend_uintptr_t)(v)) &amp; ~GC_COLOR) | (c)))  <br />
</code></pre></div></div><br />
<br />
<p>#define GC_SET_BLACK(v) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(v) = ((gc_root_buffer*)(((zend_uintptr_t)(v)) &amp; ~GC_COLOR))  <br />
</code></pre></div></div><br />
<br />
<p>#define GC_SET_PURPLE(v) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(v) = ((gc_root_buffer*)(((zend_uintptr_t)(v)) | GC_PURPLE))  <br />
</code></pre></div></div><br />
<br />
<p>#define GC_ZVAL_INIT(z) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>((zval_gc_info*)(z))-&gt;u.buffered = NULL  <br />
</code></pre></div></div><br />
<br />
<p>#define GC_ZVAL_ADDRESS(v) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GC_ADDRESS(((zval_gc_info*)(v))-&gt;u.buffered)  <br />
</code></pre></div></div><br />
<br />
<p>#define GC_ZVAL_SET_ADDRESS(v, a) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GC_SET_ADDRESS(((zval_gc_info*)(v))-&gt;u.buffered, (a))  <br />
</code></pre></div></div><br />
<br />
<p>#define GC_ZVAL_GET_COLOR(v) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GC_GET_COLOR(((zval_gc_info*)(v))-&gt;u.buffered)  <br />
</code></pre></div></div><br />
<br />
<p>#define GC_ZVAL_SET_COLOR(v, c) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GC_SET_COLOR(((zval_gc_info*)(v))-&gt;u.buffered, (c))  <br />
</code></pre></div></div><br />
<br />
<p>#define GC_ZVAL_SET_BLACK(v) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GC_SET_BLACK(((zval_gc_info*)(v))-&gt;u.buffered)  <br />
</code></pre></div></div><br />
<br />
<p>#define GC_ZVAL_SET_PURPLE(v) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GC_SET_PURPLE(((zval_gc_info*)(v))-&gt;u.buffered)  <br />
</code></pre></div></div><br />
<br />
<p>其中宏GC_ZVAL_SET_ADDRESS(v, a)是为v这个zval设置节点信息的指针a，这个宏先得到v中的节点信息指针字段u.buffered，然后调用GC_ADDRESS(v,a)宏，将u.buffered字段设置成指针a。</p><br />
<br />
<p>GC_ADDRESS(v, a)宏的功能是将地址a赋给v，但是它的实现很奇怪:</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>(v) = ((gc_root_buffer*)((((zend_uintptr_t)(v)) &amp; GC_COLOR)</td><br />
      <td>((zend_uintptr_t)(a))))</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>为什么需要这么一个复杂的过程，而且设置指针值为何还要牵扯到GC_COLOR颜色这个宏？</p><br />
<br />
<p>这里就得先说说节点的颜色信息保存方式。</p><br />
<br />
<p>在前面GC的算法简介中，提到了需要为节点上色，而实际在我们节点结构gc_root_buffer中并没有哪一个字段用来标识节点的颜色，这里GC运用了一个小的技巧：利用节点指针的低两位来标识颜色属性。可能读者会有疑问，用指针中的位来保存颜色属性，那么设置颜色后，指针不就变化了吗，那么还能查找到指针对应的结构吗？ 这个还真能查到！ 为什么？ 这个和malloc分配的内存地址属性有一定的关系，glib的malloc分配的内存地址都会有一定的对齐，这个对齐值为2 * SIZE_SZ,在不同位的机器上这个值是不一样的，但是可以确保的是分配出来的指针的最低两位肯定是0，然后看看颜色相关的宏，GC_COLOR为0x03, 3只需要两个二进制位就能够保存，所以拿指针的最低两位来保存颜色值是没有任何问题的，但是在使用指针的时候一定要先把指针最低的两位还原成0，否则指针指向的值是错误的。</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>这样我们就能理解为什么GC_ADDRESS需要这么复杂了。因为v中的低2位保存了v的颜色信息，如果直接把a赋给v会覆盖掉颜色信息，通过((zend_uintptr_t)(v)) &amp; GC_COLOR可以保留低两位的颜色信息，同时其它的位都变成了0，将这个结果同a进行”</td><br />
      <td>“操作，就能将a的赋给v,同时保留了v的颜色信息。</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>知道了颜色信息的存储方式，那么就应该很容易理解如何设置和获取颜色信息，这里就不多介绍了。</p><br />
<br />
<p>4.节点缓冲区</p><br />
<br />
<p>GC会将收集到的节点存放到一个缓冲区中，缓冲区满的时候就开始进行垃圾分析算法。这个缓冲区实际上放在一个全局的结构中：</p><br />
<br />
<p>[cpp] view plain copy</p><br />
<br />
<p>typedef struct _zend_gc_globals {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zend_bool         gc_enabled;  <br />
<br />
zend_bool         gc_active;  <br />
<br />
  <br />
<br />
gc_root_buffer   *buf;              /* preallocated arrays of buffers   */  <br />
<br />
gc_root_buffer    roots;            /* list of possible roots of cycles */  <br />
<br />
gc_root_buffer   *unused;           /* list of unused buffers           */  <br />
<br />
gc_root_buffer   *first_unused;     /* pointer to first unused buffer   */  <br />
<br />
gc_root_buffer   *last_unused;      /* pointer to last unused buffer    */  <br />
<br />
  <br />
<br />
zval_gc_info     *zval_to_free;     /* temporaryt list of zvals to free */  <br />
<br />
zval_gc_info     *free_list;  <br />
<br />
zval_gc_info     *next_to_free;  <br />
<br />
  <br />
<br />
zend_uint gc_runs;  <br />
<br />
zend_uint collected;  <br />
</code></pre></div></div><br />
<br />
<p>#if GC_BENCH</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zend_uint root_buf_length;  <br />
<br />
zend_uint root_buf_peak;  <br />
<br />
zend_uint zval_possible_root;  <br />
<br />
zend_uint zobj_possible_root;  <br />
<br />
zend_uint zval_buffered;  <br />
<br />
zend_uint zobj_buffered;  <br />
<br />
zend_uint zval_remove_from_buffer;  <br />
<br />
zend_uint zobj_remove_from_buffer;  <br />
<br />
zend_uint zval_marked_grey;  <br />
<br />
zend_uint zobj_marked_grey;  <br />
</code></pre></div></div><br />
<br />
<p>#endif</p><br />
<br />
<p>} zend_gc_globals;</p><br />
<br />
<p>用宏GC_G(v)可以访问结构中的v字段。</p><br />
<br />
<p>简单的介绍这个结构中几个重要的字段的含义:</p><br />
<br />
<p>zend_bool  gc_enabled:</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>是否开启GC<br />
</code></pre></div></div><br />
<br />
<p>zend_bool  gc_active:</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GC是否正在进行垃圾分析<br />
</code></pre></div></div><br />
<br />
<p>gc_root_buffer   *buf：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 节点缓冲区指针，在GC初始化的时候，会分配10,000个gc_root_buffer结构的空间，buf为第1个节点的地址<br />
</code></pre></div></div><br />
<br />
<p>gc_root_buffer    roots;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  GC每次开始垃圾分析算法的时候，都是从这个节点开始进行(注意不是直接在缓冲区中按顺序来分析节点，缓冲区值是存放节点信息内容，roots是分析的节点入口，是一个双链表的入口)<br />
</code></pre></div></div><br />
<br />
<p>其他节点和垃圾分析过程中的一些临时数据有关，这里暂不介绍。</p><br />
<br />
<p>5.GC的初始化</p><br />
<br />
<p>[cpp] view plain copy</p><br />
<br />
<p>ZEND_API void gc_init(TSRMLS_D)</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (GC_G(buf) == NULL &amp;&amp; GC_G(gc_enabled)) {  <br />
<br />
    GC_G(buf) = (gc_root_buffer*) malloc(sizeof(gc_root_buffer) * GC_ROOT_BUFFER_MAX_ENTRIES);  <br />
<br />
    GC_G(last_unused) = &amp;GC_G(buf)[GC_ROOT_BUFFER_MAX_ENTRIES];  <br />
<br />
    gc_reset(TSRMLS_C);  <br />
<br />
}  <br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>首先在初始化之前会有一个全局变量</p><br />
<br />
<p>extern ZEND_API zend_gc_globals gc_globals;</p><br />
<br />
<p>在整个GC运行期间都依赖这个全局变量结构。</p><br />
<br />
<p>初始化是调用的gc_init函数，如果缓冲区指针字段为空并且GC开启，那么就分配缓冲区，然后调用gc_reset初始化全局结构gc_globals中的相关字段。</p><br />
<br />
<p>6.节点放入缓冲区的时机</p><br />
<br />
<p>那么现在就是一个比较关键的一步了，GC何时为zval设置节点信息，并将节点信息设置放入缓冲区等待分析处理。从前面介绍的GC算法的原理中，准则3：“如果一个zval的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾”。我们大概可以知道当一个zval的refcount减少的时候，GC有可能为zval分配节点并放入缓冲区。那么在什么情况下zval的refcount会减少。 在我们调用unset的时候，会从当前符号的哈希表中删除变量名对应的项，并对该项调用一个析构函数，所以这个refcount减少的操作发生在这个析构函数中。通过建立变量符号哈希表的代码段可以知道这个析构函数是什么。这个析构函数最终的实现在Zend/zend_execute_API.c中：</p><br />
<br />
<p>[cpp] view plain copy</p><br />
<br />
<p>ZEND_API void _zval_ptr_dtor(zval <em>*zval_ptr ZEND_FILE_LINE_DC) /</em> {{{ */</p><br />
<br />
<p>{</p><br />
<br />
<p>#if DEBUG_ZEND&gt;=2</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printf("Reducing refcount for %x (%x): %d-&gt;%d/n", *zval_ptr, zval_ptr, Z_REFCOUNT_PP(zval_ptr), Z_REFCOUNT_PP(zval_ptr) – 1);  <br />
</code></pre></div></div><br />
<br />
<p>#endif</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Z_DELREF_PP(zval_ptr);  <br />
<br />
if (Z_REFCOUNT_PP(zval_ptr) == 0) {  <br />
<br />
    TSRMLS_FETCH();  <br />
<br />
  <br />
<br />
    if (*zval_ptr != &amp;EG(uninitialized_zval)) {  <br />
<br />
        GC_REMOVE_ZVAL_FROM_BUFFER(*zval_ptr);  <br />
<br />
        zval_dtor(*zval_ptr);  <br />
<br />
        efree_rel(*zval_ptr);  <br />
<br />
    }  <br />
<br />
} else {  <br />
<br />
    TSRMLS_FETCH();  <br />
<br />
  <br />
<br />
    if (Z_REFCOUNT_PP(zval_ptr) == 1) {  <br />
<br />
        Z_UNSET_ISREF_PP(zval_ptr);  <br />
<br />
    }  <br />
<br />
  <br />
<br />
    GC_ZVAL_CHECK_POSSIBLE_ROOT(*zval_ptr);  <br />
<br />
}  <br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>这个函数中：</p><br />
<br />
<p>Z_DELREF_PP(zval_ptr) ：对zval的refcount减1，减1之后</p><br />
<br />
<p>1.如果zval的refcount等于0,根据前面的准则2，这个变量的空间可以直接被释放掉，在释放之前需要注意，有可能这个变量在之前已经被放入了节点缓冲区，所以需要调用GC_REMOVE_ZVAL_FROM_BUFFER(*zval_ptr)从节点缓冲区中删除相关节点信息，然后调用zval_dtor和efree_rel释放掉变量zval中变量占用的空间和zval结构自身的空间。</p><br />
<br />
<p>2.如果zval的refcount等于1,根据前面的准则3，这个变量有可能会成为一个垃圾，于是调用GC_ZVAL_CHECK_POSSIBLE_ROOT(*zval_ptr)为其设置节点信息并放入缓冲区</p><br />
<br />
<p>因此，最终是通过GC_ZVAL_CHECK_POSSIBLE_ROOT宏来产生节点并放入缓冲等待处理，相关的宏和函数代码为：</p><br />
<br />
<p>[cpp] view plain copy</p><br />
<br />
<p>#define GC_ZVAL_CHECK_POSSIBLE_ROOT(z) /</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gc_zval_check_possible_root((z) TSRMLS_CC)  <br />
</code></pre></div></div><br />
<br />
<p>static zend_always_inline void gc_zval_check_possible_root(zval *z TSRMLS_DC)</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (z-&gt;type == IS_ARRAY || z-&gt;type == IS_OBJECT) {  <br />
<br />
    gc_zval_possible_root(z TSRMLS_CC);  <br />
<br />
}  <br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>ZEND_API void gc_zval_possible_root(zval *zv TSRMLS_DC)</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (UNEXPECTED(GC_G(free_list) != NULL &amp;&amp;  <br />
<br />
               GC_ZVAL_ADDRESS(zv) != NULL &amp;&amp;  <br />
<br />
               GC_ZVAL_GET_COLOR(zv) == GC_BLACK) &amp;&amp;  <br />
<br />
               (GC_ZVAL_ADDRESS(zv) &lt; GC_G(buf) ||  <br />
<br />
                GC_ZVAL_ADDRESS(zv) &gt;= GC_G(last_unused))) {  <br />
<br />
    /* The given zval is a garbage that is going to be deleted by <br />
<br />
     * currently running GC */  <br />
<br />
    return;  <br />
<br />
}  <br />
<br />
  <br />
<br />
if (zv-&gt;type == IS_OBJECT) {  <br />
<br />
    GC_ZOBJ_CHECK_POSSIBLE_ROOT(zv);  <br />
<br />
    return;  <br />
<br />
}  <br />
<br />
  <br />
<br />
GC_BENCH_INC(zval_possible_root);  <br />
<br />
  <br />
<br />
if (GC_ZVAL_GET_COLOR(zv) != GC_PURPLE) {  <br />
<br />
    GC_ZVAL_SET_PURPLE(zv);  <br />
<br />
  <br />
<br />
    if (!GC_ZVAL_ADDRESS(zv)) {  <br />
<br />
        gc_root_buffer *newRoot = GC_G(unused);  <br />
<br />
  <br />
<br />
        if (newRoot) {  <br />
<br />
            GC_G(unused) = newRoot-&gt;prev;  <br />
<br />
        } else if (GC_G(first_unused) != GC_G(last_unused)) {  <br />
<br />
            newRoot = GC_G(first_unused);  <br />
<br />
            GC_G(first_unused)++;  <br />
<br />
        } else {  <br />
<br />
            if (!GC_G(gc_enabled)) {  <br />
<br />
                GC_ZVAL_SET_BLACK(zv);  <br />
<br />
                return;  <br />
<br />
            }  <br />
<br />
            zv-&gt;refcount__gc++;  <br />
<br />
            gc_collect_cycles(TSRMLS_C);  <br />
<br />
            zv-&gt;refcount__gc–;  <br />
<br />
            newRoot = GC_G(unused);  <br />
<br />
            if (!newRoot) {  <br />
<br />
                return;  <br />
<br />
            }  <br />
<br />
            GC_ZVAL_SET_PURPLE(zv);  <br />
<br />
            GC_G(unused) = newRoot-&gt;prev;  <br />
<br />
        }  <br />
<br />
  <br />
<br />
        newRoot-&gt;next = GC_G(roots).next;  <br />
<br />
        newRoot-&gt;prev = &amp;GC_G(roots);  <br />
<br />
        GC_G(roots).next-&gt;prev = newRoot;  <br />
<br />
        GC_G(roots).next = newRoot;  <br />
<br />
  <br />
<br />
        GC_ZVAL_SET_ADDRESS(zv, newRoot);  <br />
<br />
  <br />
<br />
        newRoot-&gt;handle = 0;  <br />
<br />
        newRoot-&gt;u.pz = zv;  <br />
<br />
  <br />
<br />
        GC_BENCH_INC(zval_buffered);  <br />
<br />
        GC_BENCH_INC(root_buf_length);  <br />
<br />
        GC_BENCH_PEAK(root_buf_peak, root_buf_length);  <br />
<br />
    }  <br />
<br />
}  <br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>内联函数gc_zval_check_possible_root会先判断zval的类型，如果是数组或则对象类型才有可能给zval分配节点信息并放入缓冲区。只有这两种类型才可能产生环形引用。虽然GC直接处理对象是数组和对象类型，但是在这些数组和对象中包含的任何类型变量都在GC的职责范围之内，这个内联函数最终掉用的是gc_zval_possible_root函数，下面重点分析此函数中的主要流程：</p><br />
<br />
<p>1：</p><br />
<br />
<p>if (UNEXPECTED(GC_G(free_list) != NULL &amp;&amp;<br />
                GC_ZVAL_ADDRESS(zv) != NULL &amp;&amp;<br />
             GC_ZVAL_GET_COLOR(zv) == GC_BLACK) &amp;&amp;<br />
             (GC_ZVAL_ADDRESS(zv) &lt; GC_G(buf) ||<br />
              GC_ZVAL_ADDRESS(zv) &gt;= GC_G(last_unused))) {<br />
  /* The given zval is a garbage that is going to be deleted by</p><br />
<ul><br />
  <li>currently running GC */<br />
  return;<br />
 }</li><br />
</ul><br />
<br />
<p>首先检查zval节点信息是否已经放入到节点缓冲区，如果已经放入到节点缓冲区，则直接返回，这样保证节点缓冲区中的每个zval节点只出现一次。</p><br />
<br />
<p>2：</p><br />
<br />
<p>if (zv-&gt;type == IS_OBJECT) {<br />
  GC_ZOBJ_CHECK_POSSIBLE_ROOT(zv);<br />
  return;<br />
 }</p><br />
<br />
<p>如果zval是对象类型，则走对象类型相关的流程，本文只以数组类型为例讲解，所以这个流程不阐述，读者可以举一反三。</p><br />
<br />
<p>3:</p><br />
<br />
<p>if (GC_ZVAL_GET_COLOR(zv) != GC_PURPLE) {<br />
  GC_ZVAL_SET_PURPLE(zv);</p><br />
<br />
<p>…</p><br />
<br />
<p>}</p><br />
<br />
<p>如果zval没有被标记为紫色，就将其标记为紫色，表示zval被放入到节点缓冲，否则不做后面的操作。</p><br />
<br />
<p>4:</p><br />
<br />
<p>如果zval的节点信息指针为空，则需要为zval分配一个gc_root_buffer节点信息。这之后会有一些判断机制，如果发现节点缓冲区已经满了说明需要启动垃圾分析流程了，垃圾分析流程在函数gc_collect_cycles(TSRMLS_C);  如果缓冲区没有满，则不会进入垃圾分析流程，为zval分配的节点信息会被加入到GC_G(roots)为入口的双链表中。</p><br />
<br />
<p>从这个函数我们发现了垃圾分析算法是当发现缓冲区满的时候就立即触发，垃圾分析跟代码执行流是同步过程，也就是只有垃圾分析结束之后，代码才会继续执行。所以在我们的PHP代码中，如果某个unset正好使GC的节点缓冲区满，触发了垃圾分析流程，那么这个unset耗费的时间将比一般的unset多很多。</p><br />
<br />
<p>gc_collect_cycles函数是真正的垃圾分析流程，这个函数定义为:</p><br />
<br />
<p>[cpp] view plain copy</p><br />
<br />
<p>ZEND_API int gc_collect_cycles(TSRMLS_D)</p><br />
<br />
<p>{</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>int count = 0;  <br />
<br />
  <br />
<br />
if (GC_G(roots).next != &amp;GC_G(roots)) {  <br />
<br />
    zval_gc_info *p, *q, *orig_free_list, *orig_next_to_free;  <br />
<br />
  <br />
<br />
    if (GC_G(gc_active)) {  <br />
<br />
        return 0;  <br />
<br />
    }  <br />
<br />
    GC_G(gc_runs)++;  <br />
<br />
    GC_G(zval_to_free) = FREE_LIST_END;  <br />
<br />
    GC_G(gc_active) = 1;  <br />
<br />
    gc_mark_roots(TSRMLS_C);  <br />
<br />
    gc_scan_roots(TSRMLS_C);  <br />
<br />
    gc_collect_roots(TSRMLS_C);  <br />
<br />
  <br />
<br />
    orig_free_list = GC_G(free_list);  <br />
<br />
    orig_next_to_free = GC_G(next_to_free);  <br />
<br />
    p = GC_G(free_list) = GC_G(zval_to_free);  <br />
<br />
    GC_G(zval_to_free) = NULL;  <br />
<br />
    GC_G(gc_active) = 0;  <br />
<br />
  <br />
<br />
    /* First call destructors */  <br />
<br />
    while (p != FREE_LIST_END) {  <br />
<br />
        if (Z_TYPE(p-&gt;z) == IS_OBJECT) {  <br />
<br />
            if (EG(objects_store).object_buckets &amp;&amp;  <br />
<br />
                EG(objects_store).object_buckets[Z_OBJ_HANDLE(p-&gt;z)].valid &amp;&amp;  <br />
<br />
                EG(objects_store).object_buckets[Z_OBJ_HANDLE(p-&gt;z)].bucket.obj.refcount &lt;= 0 &amp;&amp;  <br />
<br />
                EG(objects_store).object_buckets[Z_OBJ_HANDLE(p-&gt;z)].bucket.obj.dtor &amp;&amp;  <br />
<br />
                !EG(objects_store).object_buckets[Z_OBJ_HANDLE(p-&gt;z)].destructor_called) {  <br />
<br />
  <br />
<br />
                EG(objects_store).object_buckets[Z_OBJ_HANDLE(p-&gt;z)].destructor_called = 1;  <br />
<br />
                EG(objects_store).object_buckets[Z_OBJ_HANDLE(p-&gt;z)].bucket.obj.refcount++;  <br />
<br />
                EG(objects_store).object_buckets[Z_OBJ_HANDLE(p-&gt;z)].bucket.obj.dtor(EG(objects_store).object_buckets[Z_OBJ_HANDLE(p-&gt;z)].bucket.obj.object, Z_OBJ_HANDLE(p-&gt;z) TSRMLS_CC);  <br />
<br />
                EG(objects_store).object_buckets[Z_OBJ_HANDLE(p-&gt;z)].bucket.obj.refcount–;  <br />
<br />
            }  <br />
<br />
        }  <br />
<br />
        count++;  <br />
<br />
        p = p-&gt;u.next;  <br />
<br />
    }  <br />
<br />
  <br />
<br />
    /* Destroy zvals */  <br />
<br />
    p = GC_G(free_list);  <br />
<br />
    while (p != FREE_LIST_END) {  <br />
<br />
        GC_G(next_to_free) = p-&gt;u.next;  <br />
<br />
        if (Z_TYPE(p-&gt;z) == IS_OBJECT) {  <br />
<br />
            if (EG(objects_store).object_buckets &amp;&amp;  <br />
<br />
                EG(objects_store).object_buckets[Z_OBJ_HANDLE(p-&gt;z)].valid &amp;&amp;  <br />
<br />
                EG(objects_store).object_buckets[Z_OBJ_HANDLE(p-&gt;z)].bucket.obj.refcount &lt;= 0) {  <br />
<br />
                EG(objects_store).object_buckets[Z_OBJ_HANDLE(p-&gt;z)].bucket.obj.refcount = 1;  <br />
<br />
                Z_TYPE(p-&gt;z) = IS_NULL;  <br />
<br />
                zend_objects_store_del_ref_by_handle_ex(Z_OBJ_HANDLE(p-&gt;z), Z_OBJ_HT(p-&gt;z) TSRMLS_CC);  <br />
<br />
            }  <br />
<br />
        } else if (Z_TYPE(p-&gt;z) == IS_ARRAY) {  <br />
<br />
            Z_TYPE(p-&gt;z) = IS_NULL;  <br />
<br />
            zend_hash_destroy(Z_ARRVAL(p-&gt;z));  <br />
<br />
            FREE_HASHTABLE(Z_ARRVAL(p-&gt;z));  <br />
<br />
        } else {  <br />
<br />
            zval_dtor(&amp;p-&gt;z);  <br />
<br />
            Z_TYPE(p-&gt;z) = IS_NULL;  <br />
<br />
        }  <br />
<br />
        p = GC_G(next_to_free);  <br />
<br />
    }  <br />
<br />
  <br />
<br />
    /* Free zvals */  <br />
<br />
    p = GC_G(free_list);  <br />
<br />
    while (p != FREE_LIST_END) {  <br />
<br />
        q = p-&gt;u.next;  <br />
<br />
        FREE_ZVAL_EX(&amp;p-&gt;z);  <br />
<br />
        p = q;  <br />
<br />
    }  <br />
<br />
    GC_G(collected) += count;  <br />
<br />
    GC_G(free_list) = orig_free_list;  <br />
<br />
    GC_G(next_to_free) = orig_next_to_free;  <br />
<br />
}  <br />
<br />
  <br />
<br />
return count;  <br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>这里只简单的介绍其中关键的流程:</p><br />
<br />
<p>1.gc_mark_roots（）</p><br />
<br />
<p>这个函数对节点信息的链表进行一次深度优先遍历，将其中的zval的refcount减1，为了避免对同一个zval重复减操作，在操作之后将zval标记成灰色。（对节点自身的zval可以重复减操作，这个是此算法的基础）</p><br />
<br />
<p>2.gc_scan_roots()</p><br />
<br />
<p>这个函数对节点信息的链表再次进行深度优先遍历，如果发现zval的refcount大于等于1，则对该zval和其包含的zval的refcount加1操作，这个是对非垃圾的一个信息还原，然后将这些zval颜色属性去掉(设置成black)。如果发现zval的refcount等于0，则就标记成白色，这些是后面将要清理掉的垃圾。</p><br />
<br />
<p>3.gc_collect_roots()</p><br />
<br />
<p>遍历节点信息链表,将前面一个步骤中标记为白色的节点信息放到GC_G(zval_to_free)为入口的链表中，这个链表用来存放将要释放的垃圾。 然后释放掉全部的节点信息，缓冲区被清空。分析结束后将重新收集节点信息。</p><br />
<br />
<p>4.释放步骤3中收集到垃圾数据</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category php
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>