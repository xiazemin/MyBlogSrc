<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">JSON解析学习</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-07-04T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jul 4, 2020</time></p>
					</div>
					 <p>https://zhuanlan.zhihu.com/p/22457315<br />
https://github.com/miloyip/json-tutorial<br />
从零开始写一个 JSON 库，其特性如下：</p><br />
<br />
<p>符合标准的 JSON 解析器和生成器<br />
手写的递归下降解析器（recursive descent parser）<br />
使用标准 C 语言（C89）<br />
跨平台／编译器（如 Windows／Linux／OS X，vc／gcc／clang）<br />
仅支持 UTF-8 JSON 文本<br />
仅支持以 double 存储 JSON number 类型<br />
解析器和生成器的代码合共少于 500 行<br />
除了围绕 JSON 作为例子，希望能在教程中讲述一些课题：</p><br />
<br />
<p>测试驱动开发（test driven development, TDD）<br />
C 语言编程风格<br />
数据结构<br />
API 设计<br />
断言<br />
Unicode<br />
浮点数<br />
Github、CMake、valgrind、Doxygen 等工具<br />
教程大纲<br />
本教程预计分为 9 个单元，第 1-8 个单元附带练习和解答。</p><br />
<br />
<p>启程（2016/9/15 完成）：编译环境、JSON 简介、测试驱动开发、解析器主要函数及各数据结构。练习 JSON 布尔类型的解析。启程解答篇（2016/9/17 完成）。<br />
解析数字（2016/9/18 完成）：JSON number 的语法。练习 JSON number 类型的校验。解析数字解答篇（2016/9/20 完成）<br />
解析字符串（2016/9/22 完成）：使用 union 存储 variant、自动扩展的堆栈、JSON string 的语法、valgrind。练习最基本的 JSON string 类型的解析、内存释放。解析字符串解答篇 （2016/9/27 完成）<br />
Unicode（2016/10/2 完成）：Unicode 和 UTF-8 的基本知识、JSON string 的 unicode 处理。练习完成 JSON string 类型的解析。Unicode 解答篇（2016/10/6 完成）<br />
解析数组（2016/10/8 完成）：JSON array 的语法。练习完成 JSON array 类型的解析、相关内存释放。解析数组解答篇（2016/10/13 完成）<br />
解析对象（2016/10/29 完成）：JSON object 的语法、重构 string 解析函数。练习完成 JSON object 的解析、相关内存释放。解析对象解答篇（2016/11/15 完成）<br />
生成器（2016/12/20 完成）：JSON 生成过程、注意事项。练习完成 JSON 生成器。生成器解答篇（2017/1/6 完成）<br />
访问：JSON array／object 的访问及修改。练习完成相关功能。<br />
终点及新开始：加入 nativejson-benchmark 测试，与 RapidJSON 对比及展望。<br />
https://github.com/miloyip/json-tutorial<br />
<!-- more --><br />
https://zhuanlan.zhihu.com/p/22460835<br />
本单元内容：</p><br />
<br />
<p>JSON 是什么<br />
搭建编译环境<br />
头文件与 API 设计<br />
JSON 语法子集<br />
单元测试<br />
宏的编写技巧<br />
实现解析器<br />
关于断言<br />
总结与练习<br />
常见问答</p><br />
<br />
<ol><br />
  <li>JSON 是什么<br />
JSON（JavaScript Object Notation）是一个用于数据交换的文本格式，现时的标准为ECMA-404。</li><br />
</ol><br />
<br />
<p>虽然 JSON 源至于 JavaScript 语言，但它只是一种数据格式，可用于任何编程语言。现时具类似功能的格式有 XML、YAML，当中以 JSON 的语法最为简单。</p><br />
<br />
<p>例如，一个动态网页想从服务器获得数据时，服务器从数据库查找数据，然后把数据转换成 JSON 文本格式：</p><br />
<br />
<p>{<br />
    “title”: “Design Patterns”,<br />
    “subtitle”: “Elements of Reusable Object-Oriented Software”,<br />
    “author”: [<br />
        “Erich Gamma”,<br />
        “Richard Helm”,<br />
        “Ralph Johnson”,<br />
        “John Vlissides”<br />
    ],<br />
    “year”: 2009,<br />
    “weight”: 1.8,<br />
    “hardcover”: true,<br />
    “publisher”: {<br />
        “Company”: “Pearson Education”,<br />
        “Country”: “India”<br />
    },<br />
    “website”: null<br />
}<br />
网页的脚本代码就可以把此 JSON 文本解析为内部的数据结构去使用。</p><br />
<br />
<p>从此例子可看出，JSON 是树状结构，而 JSON 只包含 6 种数据类型：</p><br />
<br />
<p>null: 表示为 null<br />
boolean: 表示为 true 或 false<br />
number: 一般的浮点数表示方式，在下一单元详细说明<br />
string: 表示为 “…”<br />
array: 表示为 [ … ]<br />
object: 表示为 { … }<br />
我们要实现的 JSON 库，主要是完成 3 个需求：</p><br />
<br />
<p>把 JSON 文本解析为一个树状数据结构（parse）。<br />
提供接口访问该数据结构（access）。<br />
把数据结构转换成 JSON 文本（stringify）。</p><br />
<br />
<p>我们会逐步实现这些需求。在本单元中，我们只实现最简单的 null 和 boolean 解析。</p><br />
<br />
<ol><br />
  <li>搭建编译环境<br />
我们要做的库是跨平台、跨编译器的，同学可使用任意平台进行练习。</li><br />
</ol><br />
<br />
<p>练习源代码位于 json-tutorial，当中 tutorial01 为本单元的练习代码。建议同学登记为 GitHub 用户，把项目 fork 一个自己的版本，然后在上面进行修改。不了解版本管理的同学，也可以按右方「Clone or download」按钮，简单下载一个 zip 文件。</p><br />
<br />
<p>我们的 JSON 库名为 leptjson，代码文件只有 3 个：</p><br />
<br />
<p>leptjson.h：leptjson 的头文件（header file），含有对外的类型和 API 函数声明。<br />
leptjson.c：leptjson 的实现文件（implementation file），含有内部的类型声明和函数实现。此文件会编译成库。<br />
test.c：我们使用测试驱动开发（test driven development, TDD）。此文件包含测试程序，需要链接 leptjson 库。<br />
为了方便跨平台开发，我们会使用一个现时最流行的软件配置工具 CMake。</p><br />
<br />
<p>先在 “Where is the source code” 选择 json-tutorial/tutorial01，再在 “Where to build the binary” 键入上一个目录加上 /build。</p><br />
<br />
<p>按 Configure，选择编译器，然后按 Generate 便会生成 Visual Studio 的 .sln 和 .vcproj 等文件。注意这个 build 目录都是生成的文件，可以随时删除，也不用上传至仓库。</p><br />
<br />
<p>在 OS X 下，建议安装 Homebrew，然后在命令行键入：</p><br />
<br />
<p>$ brew install cmake<br />
$ cd github/json-tutorial/tutorial01<br />
$ mkdir build<br />
$ cd build<br />
$ cmake -DCMAKE_BUILD_TYPE=Debug ..<br />
$ make<br />
这样会使用 GNU make 来生成项目，把 Debug 改成 Release 就会生成 Release 配置的 makefile。</p><br />
<br />
<p>若你喜欢的话，CMake 也可以生成 Xcode 项目：</p><br />
<br />
<p>$ cmake -G Xcode ..<br />
$ open leptjson_test.xcodeproj<br />
而在 Ubuntu 下，可使用 apt-get 来安装：</p><br />
<br />
<p>$ apt-get install cmake<br />
无论使用什么平台及编译环境，编译运行后会出现：</p><br />
<br />
<p>$ ./leptjson_test<br />
/Users/miloyip/github/json-tutorial/tutorial01/test.c:56: expect: 3 actual: 0<br />
11/12 (91.67%) passed<br />
若看到类似以上的结果，说明已成功搭建编译环境，我们可以去看看那几个代码文件的内容了。</p><br />
<br />
<ol><br />
  <li>头文件与 API 设计<br />
C 语言有头文件的概念，需要使用 #include 去引入头文件中的类型声明和函数声明。但由于头文件也可以 #include 其他头文件，为避免重复声明，通常会利用宏加入 #include 防范（include guard）：</li><br />
</ol><br />
<br />
<p>#ifndef LEPTJSON_H__<br />
#define LEPTJSON_H__</p><br />
<br />
<p>/* … */</p><br />
<br />
<p>#endif /* LEPTJSON_H__ */<br />
宏的名字必须是唯一的，通常习惯以 _H__ 作为后缀。由于 leptjson 只有一个头文件，可以简单命名为 LEPTJSON_H__。如果项目有多个文件或目录结构，可以用 项目名称_目录_文件名称_H__ 这种命名方式。</p><br />
<br />
<p>如前所述，JSON 中有 6 种数据类型，如果把 true 和 false 当作两个类型就是 7 种，我们为此声明一个枚举类型（enumeration type）：</p><br />
<br />
<p>typedef enum { LEPT_NULL, LEPT_FALSE, LEPT_TRUE, LEPT_NUMBER, LEPT_STRING, LEPT_ARRAY, LEPT_OBJECT } lept_type;<br />
因为 C 语言没有 C++ 的命名空间（namespace）功能，一般会使用项目的简写作为标识符的前缀。通常枚举值用全大写（如 LEPT_NULL），而类型及函数则用小写（如 lept_type）。</p><br />
<br />
<p>接下来，我们声明 JSON 的数据结构。JSON 是一个树形结构，我们最终需要实现一个树的数据结构，每个节点使用 lept_value 结构体表示，我们会称它为一个 JSON 值（JSON value）。 在此单元中，我们只需要实现 null, true 和 false 的解析，因此该结构体只需要存储一个 lept_type。之后的单元会逐步加入其他数据。</p><br />
<br />
<p>typedef struct {<br />
    lept_type type;<br />
}lept_value;<br />
C 语言的结构体是以 struct X {} 形式声明的，定义变量时也要写成 struct X x;。为方便使用，上面的代码使用了 typedef。</p><br />
<br />
<p>然后，我们现在只需要两个 API 函数，一个是解析 JSON：</p><br />
<br />
<p>int lept_parse(lept_value* v, const char* json);<br />
传入的 JSON 文本是一个 C 字符串（空结尾字符串／null-terminated string），由于我们不应该改动这个输入字符串，所以使用 const char* 类型。</p><br />
<br />
<p>另一注意点是，传入的根节点指针 v 是由使用方负责分配的，所以一般用法是：</p><br />
<br />
<p>lept_value v;<br />
const char json[] = …;<br />
int ret = lept_parse(&amp;v, json);<br />
返回值是以下这些枚举值，无错误会返回 LEPT_PARSE_OK，其他值在下节解释。</p><br />
<br />
<p>enum {<br />
    LEPT_PARSE_OK = 0,<br />
    LEPT_PARSE_EXPECT_VALUE,<br />
    LEPT_PARSE_INVALID_VALUE,<br />
    LEPT_PARSE_ROOT_NOT_SINGULAR<br />
};<br />
现时我们只需要一个访问结果的函数，就是获取其类型：</p><br />
<br />
<p>lept_type lept_get_type(const lept_value* v);</p><br />
<ol><br />
  <li>JSON 语法子集<br />
下面是此单元的 JSON 语法子集，使用 RFC7159 中的 ABNF 表示：</li><br />
</ol><br />
<br />
<p>JSON-text = ws value ws<br />
ws = <em>(%x20 / %x09 / %x0A / %x0D)<br />
value = null / false / true <br />
null  = “null”<br />
false = “false”<br />
true  = “true”<br />
当中 %xhh 表示以 16 进制表示的字符，/ 是多选一，</em> 是零或多个，( ) 用于分组。</p><br />
<br />
<p>那么第一行的意思是，JSON 文本由 3 部分组成，首先是空白（whitespace），接着是一个值，最后是空白。</p><br />
<br />
<p>第二行告诉我们，所谓空白，是由零或多个空格符（space U+0020）、制表符（tab U+0009）、换行符（LF U+000A）、回车符（CR U+000D）所组成。</p><br />
<br />
<p>第三行是说，我们现时的值只可以是 null、false 或 true，它们分别有对应的字面值（literal）。</p><br />
<br />
<p>我们的解析器应能判断输入是否一个合法的 JSON。如果输入的 JSON 不合符这个语法，我们要产生对应的错误码，方便使用者追查问题。</p><br />
<br />
<p>在这个 JSON 语法子集下，我们定义 3 种错误码：</p><br />
<br />
<p>若一个 JSON 只含有空白，传回 LEPT_PARSE_EXPECT_VALUE。<br />
若一个值之后，在空白之后还有其他字符，传回 LEPT_PARSE_ROOT_NOT_SINGULAR。<br />
若值不是那三种字面值，传回 LEPT_PARSE_INVALID_VALUE。</p><br />
<ol><br />
  <li>单元测试<br />
许多同学在做练习或刷题时，都是以 printf／cout 打印结果，再用肉眼对比结果是否乎合预期。但当软件项目越来越复杂，这个做法会越来越低效。一般我们会采用自动的测试方式，例如单元测试（unit testing）。单元测试也能确保其他人修改代码后，原来的功能维持正确（这称为回归测试／regression testing）。</li><br />
</ol><br />
<br />
<p>常用的单元测试框架有 xUnit 系列，如 C++ 的 Google Test、C# 的 NUnit。我们为了简单起见，会编写一个极简单的单元测试方式。</p><br />
<br />
<p>一般来说，软件开发是以周期进行的。例如，加入一个功能，再写关于该功能的单元测试。但也有另一种软件开发方法论，称为测试驱动开发（test-driven development, TDD），它的主要循环步骤是：</p><br />
<br />
<p>加入一个测试。<br />
运行所有测试，新的测试应该会失败。<br />
编写实现代码。<br />
运行所有测试，若有测试失败回到3。<br />
重构代码。<br />
回到 1。<br />
TDD 是先写测试，再实现功能。好处是实现只会刚好满足测试，而不会写了一些不需要的代码，或是没有被测试的代码。</p><br />
<br />
<p>但无论我们是采用 TDD，或是先实现后测试，都应尽量加入足够覆盖率的单元测试。</p><br />
<br />
<p>回到 leptjson 项目，test.c 包含了一个极简的单元测试框架：</p><br />
<br />
<p>#include <stdio.h><br />
#include <stdlib.h><br />
#include <string.h><br />
#include "leptjson.h"</string.h></stdlib.h></stdio.h></p><br />
<br />
<p>static int main_ret = 0;<br />
static int test_count = 0;<br />
static int test_pass = 0;</p><br />
<br />
<p>#define EXPECT_EQ_BASE(equality, expect, actual, format) <br /><br />
    do {<br /><br />
        test_count++;<br /><br />
        if (equality)<br /><br />
            test_pass++;<br /><br />
        else {<br /><br />
            fprintf(stderr, “%s:%d: expect: “ format “ actual: “ format “\n”, <strong>FILE</strong>, <strong>LINE</strong>, expect, actual);<br /><br />
            main_ret = 1;<br /><br />
        }<br /><br />
    } while(0)</p><br />
<br />
<p>#define EXPECT_EQ_INT(expect, actual) EXPECT_EQ_BASE((expect) == (actual), expect, actual, “%d”)</p><br />
<br />
<p>static void test_parse_null() {<br />
    lept_value v;<br />
    v.type = LEPT_TRUE;<br />
    EXPECT_EQ_INT(LEPT_PARSE_OK, lept_parse(&amp;v, “null”));<br />
    EXPECT_EQ_INT(LEPT_NULL, lept_get_type(&amp;v));<br />
}</p><br />
<br />
<p>/* … */</p><br />
<br />
<p>static void test_parse() {<br />
    test_parse_null();<br />
    /* … */<br />
}</p><br />
<br />
<p>int main() {<br />
    test_parse();<br />
    printf(“%d/%d (%3.2f%%) passed\n”, test_pass, test_count, test_pass * 100.0 / test_count);<br />
    return main_ret;<br />
}<br />
现时只提供了一个 EXPECT_EQ_INT(expect, actual) 的宏，每次使用这个宏时，如果 expect != actual（预期值不等于实际值），便会输出错误信息。 若按照 TDD 的步骤，我们先写一个测试，如上面的 test_parse_null()，而 lept_parse() 只返回 LEPT_PARSE_OK：</p><br />
<br />
<p>/Users/miloyip/github/json-tutorial/tutorial01/test.c:27: expect: 0 actual: 1<br />
1/2 (50.00%) passed<br />
第一个返回 LEPT_PARSE_OK，所以是通过的。第二个测试因为 lept_parse() 没有把 v.type 改成 LEPT_NULL，造成失败。我们再实现 lept_parse() 令到它能通过测试。</p><br />
<br />
<p>然而，完全按照 TDD 的步骤来开发，是会减慢开发进程。所以我个人会在这两种极端的工作方式取平衡。通常会在设计 API 后，先写部分测试代码，再写满足那些测试的实现。</p><br />
<br />
<ol><br />
  <li>宏的编写技巧<br />
有些同学可能不了解 EXPECT_EQ_BASE 宏的编写技巧，简单说明一下。反斜线代表该行未结束，会串接下一行。而如果宏里有多过一个语句（statement），就需要用 do { /<em>…</em>/ } while(0) 包裹成单个语句，否则会有如下的问题：</li><br />
</ol><br />
<br />
<p>#define M() a(); b()<br />
if (cond)<br />
    M();<br />
else<br />
    c();</p><br />
<br />
<p>/* 预处理后 */</p><br />
<br />
<p>if (cond)<br />
    a(); b();<br />
else /* &lt;- else 缺乏对应 if */<br />
    c();<br />
只用 {} 也不行：</p><br />
<br />
<p>#define M() { a(); b(); }</p><br />
<br />
<p>/* 预处理后 */</p><br />
<br />
<p>if (cond)<br />
    { a(); b(); }; /* 最后的分号代表 if 语句结束 <em>/<br />
else               /</em> else 缺乏对应 if */<br />
    c();<br />
用 do while 就行了：</p><br />
<br />
<p>#define M() do { a(); b(); } while(0)</p><br />
<br />
<p>/* 预处理后 */</p><br />
<br />
<p>if (cond)<br />
    do { a(); b(); } while(0);<br />
else<br />
    c();</p><br />
<ol><br />
  <li>实现解析器<br />
有了 API 的设计、单元测试，终于要实现解析器了。</li><br />
</ol><br />
<br />
<p>首先为了减少解析函数之间传递多个参数，我们把这些数据都放进一个 lept_context 结构体：</p><br />
<br />
<p>typedef struct {<br />
    const char* json;<br />
}lept_context;</p><br />
<br />
<p>/* … */</p><br />
<br />
<p>/* 提示：这里应该是 JSON-text = ws value ws，<em>/<br />
/</em> 以下实现没处理最后的 ws 和 LEPT_PARSE_ROOT_NOT_SINGULAR <em>/<br />
int lept_parse(lept_value</em> v, const char* json) {<br />
    lept_context c;<br />
    assert(v != NULL);<br />
    c.json = json;<br />
    v-&gt;type = LEPT_NULL;<br />
    lept_parse_whitespace(&amp;c);<br />
    return lept_parse_value(&amp;c, v);<br />
}<br />
暂时我们只储存 json 字符串当前位置，之后的单元我们需要加入更多内容。</p><br />
<br />
<p>lept_parse() 若失败，会把 v 设为 null 类型，所以这里先把它设为 null，让 lept_parse_value() 写入解析出来的根值。</p><br />
<br />
<p>leptjson 是一个手写的递归下降解析器（recursive descent parser）。由于 JSON 语法特别简单，我们不需要写分词器（tokenizer），只需检测下一个字符，便可以知道它是哪种类型的值，然后调用相关的分析函数。对于完整的 JSON 语法，跳过空白后，只需检测当前字符：</p><br />
<br />
<p>n ➔ null<br />
t ➔ true<br />
f ➔ false<br />
“ ➔ string<br />
0-9/- ➔ number<br />
[ ➔ array<br />
{ ➔ object<br />
所以，我们可以按照 JSON 语法一节的 EBNF 简单翻译成解析函数：</p><br />
<br />
<p>#define EXPECT(c, ch) do { assert(*c-&gt;json == (ch)); c-&gt;json++; } while(0)</p><br />
<br />
<p>/* ws = <em>(%x20 / %x09 / %x0A / %x0D) */<br />
static void lept_parse_whitespace(lept_context</em> c) {<br />
    const char <em>p = c-&gt;json;<br />
    while (</em>p == ‘ ‘ || *p == ‘\t’ || *p == ‘\n’ || *p == ‘\r’)<br />
        p++;<br />
    c-&gt;json = p;<br />
}</p><br />
<br />
<p>/* null  = “null” <em>/<br />
static int lept_parse_null(lept_context</em> c, lept_value* v) {<br />
    EXPECT(c, ‘n’);<br />
    if (c-&gt;json[0] != ‘u’ || c-&gt;json[1] != ‘l’ || c-&gt;json[2] != ‘l’)<br />
        return LEPT_PARSE_INVALID_VALUE;<br />
    c-&gt;json += 3;<br />
    v-&gt;type = LEPT_NULL;<br />
    return LEPT_PARSE_OK;<br />
}</p><br />
<br />
<p>/* value = null / false / true <em>/<br />
/</em> 提示：下面代码没处理 false / true，将会是练习之一 <em>/<br />
static int lept_parse_value(lept_context</em> c, lept_value* v) {<br />
    switch (*c-&gt;json) {<br />
        case ‘n’:  return lept_parse_null(c, v);<br />
        case ‘\0’: return LEPT_PARSE_EXPECT_VALUE;<br />
        default:   return LEPT_PARSE_INVALID_VALUE;<br />
    }<br />
}<br />
由于 lept_parse_whitespace() 是不会出现错误的，返回类型为 void。其它的解析函数会返回错误码，传递至顶层。</p><br />
<br />
<ol><br />
  <li>关于断言<br />
断言（assertion）是 C 语言中常用的防御式编程方式，减少编程错误。最常用的是在函数开始的地方，检测所有参数。有时候也可以在调用函数后，检查上下文是否正确。</li><br />
</ol><br />
<br />
<p>C 语言的标准库含有 assert() 这个宏（需 #include ），提供断言功能。当程序以 release 配置编译时（定义了 NDEBUG 宏），assert() 不会做检测；而当在 debug 配置时（没定义 NDEBUG 宏），则会在运行时检测 assert(cond) 中的条件是否为真（非 0），断言失败会直接令程序崩溃。</p><br />
<br />
<p>初使用断言的同学，可能会把有副作用的代码放在 assert() 中：</p><br />
<br />
<p>assert(x++ == 0); /* 这是错误的! */<br />
因为这样会导致 debug 和 release 版的行为不一样。</p><br />
<br />
<p>另一个问题是，初学者可能会难于分辨何时使用断言，何时处理运行时错误（如返回错误值或在 C++ 中抛出异常）。简单的答案是，如果那个错误是由于程序员错误编码所造成的（例如传入不合法的参数），那么应用断言；如果那个错误是程序员无法避免，而是由运行时的环境所造成的，就要处理运行时错误（例如开启文件失败）。</p><br />
<br />
<ol><br />
  <li>总结与练习<br />
本文介绍了如何配置一个编程环境，单元测试的重要性，以至于一个 JSON 解析器的子集实现。如果你读到这里，还未动手，建议你快点试一下。以下是本单元的练习，很容易的，但我也会在稍后发出解答篇。</li><br />
</ol><br />
<br />
<p>修正关于 LEPT_PARSE_ROOT_NOT_SINGULAR 的单元测试，若 json 在一个值之后，空白之后还有其它字符，则要返回 LEPT_PARSE_ROOT_NOT_SINGULAR。<br />
参考 test_parse_null()，加入 test_parse_true()、test_parse_false() 单元测试。<br />
参考 lept_parse_null() 的实现和调用方，解析 true 和 false 值。</p><br />
<ol><br />
  <li>常见问答<br />
为什么把例子命名为 leptjson？</li><br />
</ol><br />
<br />
<p>来自于标准模型中的轻子（lepton），意为很轻量的 JSON 库。另外，建议大家为项目命名时，先 google 一下是否够独特，有很多同名的话搜寻时难以命中。</p><br />
<br />
<p>为什么使用宏而不用函数或内联函数？</p><br />
<br />
<p>因为这个测试框架使用了 <strong>LINE</strong> 这个编译器提供的宏，代表编译时该行的行号。如果用函数或内联函数，每次的行号便都会相同。另外，内联函数是 C99 的新增功能，本教程使用 C89。</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/22482061</p><br />
<br />
<ol><br />
  <li>修正 LEPT_PARSE_ROOT_NOT_SINGULAR<br />
单元测试失败的是这一行：</li><br />
</ol><br />
<br />
<p>EXPECT_EQ_INT(LEPT_PARSE_ROOT_NOT_SINGULAR, lept_parse(&amp;v, “null x”));<br />
我们从 JSON 语法发现，JSON 文本应该有 3 部分：</p><br />
<br />
<p>JSON-text = ws value ws<br />
但原来的 lept_parse() 只处理了前两部分。我们只需要加入第三部分，解析空白，然后检查 JSON 文本是否完结：</p><br />
<br />
<p>int lept_parse(lept_value* v, const char* json) {<br />
    lept_context c;<br />
    int ret;<br />
    assert(v != NULL);<br />
    c.json = json;<br />
    v-&gt;type = LEPT_NULL;<br />
    lept_parse_whitespace(&amp;c);<br />
    if ((ret = lept_parse_value(&amp;c, v)) == LEPT_PARSE_OK) {<br />
        lept_parse_whitespace(&amp;c);<br />
        if (*c.json != ‘\0’)<br />
            ret = LEPT_PARSE_ROOT_NOT_SINGULAR;<br />
    }<br />
    return ret;<br />
}<br />
有一些 JSON 解析器完整解析一个值之后就会顺利返回，这是不符合标准的。但有时候也有另一种需求，文本中含多个 JSON 或其他文本串接在一起，希望当完整解析一个值之后就停下来。因此，有一些 JSON 解析器会提供这种选项，例如 RapidJSON 的 kParseStopWhenDoneFlag。</p><br />
<br />
<ol><br />
  <li>true/false 单元测试<br />
此问题很简单，只需参考 test_parse_null() 加入两个测试函数：</li><br />
</ol><br />
<br />
<p>static void test_parse_true() {<br />
    lept_value v;<br />
    v.type = LEPT_FALSE;<br />
    EXPECT_EQ_INT(LEPT_PARSE_OK, lept_parse(&amp;v, “true”));<br />
    EXPECT_EQ_INT(LEPT_TRUE, lept_get_type(&amp;v));<br />
}</p><br />
<br />
<p>static void test_parse_false() {<br />
    lept_value v;<br />
    v.type = LEPT_TRUE;<br />
    EXPECT_EQ_INT(LEPT_PARSE_OK, lept_parse(&amp;v, “false”));<br />
    EXPECT_EQ_INT(LEPT_FALSE, lept_get_type(&amp;v));<br />
}</p><br />
<br />
<p>static void test_parse() {<br />
    test_parse_null();<br />
    test_parse_true();<br />
    test_parse_false();<br />
    test_parse_expect_value();<br />
    test_parse_invalid_value();<br />
    test_parse_root_not_singular();<br />
}<br />
但要记得在上一级的测试函数 test_parse() 调用这函数，否则会不起作用。还好如果我们记得用 static 修饰这两个函数，编译器会发出告警：</p><br />
<br />
<p>test.c:30:13: warning: unused function ‘test_parse_true’ [-Wunused-function]<br />
static void test_parse_true() {<br />
            ^<br />
因为 static 函数的意思是指，该函数只作用于编译单元中，那么没有被调用时，编译器是能发现的。</p><br />
<br />
<ol><br />
  <li>true/false 解析<br />
这部分很简单，只要参考 lept_parse_null()，再写两个函数，然后在 lept_parse_value 按首字符分派。</li><br />
</ol><br />
<br />
<p>static int lept_parse_true(lept_context* c, lept_value* v) {<br />
    EXPECT(c, ‘t’);<br />
    if (c-&gt;json[0] != ‘r’ || c-&gt;json[1] != ‘u’ || c-&gt;json[2] != ‘e’)<br />
        return LEPT_PARSE_INVALID_VALUE;<br />
    c-&gt;json += 3;<br />
    v-&gt;type = LEPT_TRUE;<br />
    return LEPT_PARSE_OK;<br />
}</p><br />
<br />
<p>static int lept_parse_false(lept_context* c, lept_value* v) {<br />
    EXPECT(c, ‘f’);<br />
    if (c-&gt;json[0] != ‘a’ || c-&gt;json[1] != ‘l’ || c-&gt;json[2] != ‘s’ || c-&gt;json[3] != ‘e’)<br />
        return LEPT_PARSE_INVALID_VALUE;<br />
    c-&gt;json += 4;<br />
    v-&gt;type = LEPT_FALSE;<br />
    return LEPT_PARSE_OK;<br />
}</p><br />
<br />
<p>static int lept_parse_value(lept_context* c, lept_value* v) {<br />
    switch (*c-&gt;json) {<br />
        case ‘t’:  return lept_parse_true(c, v);<br />
        case ‘f’:  return lept_parse_false(c, v);<br />
        case ‘n’:  return lept_parse_null(c, v);<br />
        case ‘\0’: return LEPT_PARSE_EXPECT_VALUE;<br />
        default:   return LEPT_PARSE_INVALID_VALUE;<br />
    }<br />
}<br />
其实这 3 种类型都是解析字面量，可以使用单一个函数实现，例如用这种方式调用：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    case 'n': return lept_parse_literal(c, v, "null", LEPT_NULL); 这样可以减少一些重复代码，不过可能有少许额外性能开销。<br />
</code></pre></div></div><br />
<br />
<p>https://zhuanlan.zhihu.com/p/22497369<br />
解析数字</p><br />
<br />
<p>初探重构<br />
JSON 数字语法<br />
数字表示方式<br />
单元测试<br />
十进制转换至二进制<br />
总结与练习<br />
参考<br />
常见问题</p><br />
<br />
<ol><br />
  <li>初探重构<br />
在讨论解析数字之前，我们再补充 TDD 中的一个步骤──重构（refactoring）。根据[1]，重构是一个这样的过程：</li><br />
</ol><br />
<br />
<p>在不改变代码外在行为的情况下，对代码作出修改，以改进程序的内部结构。</p><br />
<br />
<p>在 TDD 的过程中，我们的目标是编写代码去通过测试。但由于这个目标的引导性太强，我们可能会忽略正确性以外的软件品质。在通过测试之后，代码的正确性得以保证，我们就应该审视现时的代码，看看有没有地方可以改进，而同时能维持测试顺利通过。我们可以安心地做各种修改，因为我们有单元测试，可以判断代码在修改后是否影响原来的行为。</p><br />
<br />
<p>那么，哪里要作出修改？Beck 和 Fowler（[1] 第 3 章）认为程序员要培养一种判断能力，找出程序中的坏味道。例如，在第一单元的练习中，可能大部分人都会复制 lept_parse_null() 的代码，作一些修改，成为 lept_parse_true() 和lept_parse_false()。如果我们再审视这 3 个函数，它们非常相似。这违反编程中常说的 DRY（don’t repeat yourself）原则。本单元的第一个练习题，就是尝试合并这 3 个函数。</p><br />
<br />
<p>另外，我们也可能发现，单元测试代码也有很重复的代码，例如 test_parse_invalid_value() 中我们每次测试一个不合法的 JSON 值，都有 4 行相似的代码。我们可以把它用宏的方式把它们简化：</p><br />
<br />
<p>#define TEST_ERROR(error, json)<br /><br />
    do {<br /><br />
        lept_value v;<br /><br />
        v.type = LEPT_FALSE;<br /><br />
        EXPECT_EQ_INT(error, lept_parse(&amp;v, json));<br /><br />
        EXPECT_EQ_INT(LEPT_NULL, lept_get_type(&amp;v));<br /><br />
    } while(0)</p><br />
<br />
<p>static void test_parse_expect_value() {<br />
    TEST_ERROR(LEPT_PARSE_EXPECT_VALUE, “”);<br />
    TEST_ERROR(LEPT_PARSE_EXPECT_VALUE, “ “);<br />
}<br />
最后，我希望指出，软件的架构难以用单一标准评分，重构时要考虑平衡各种软件品质。例如上述把 3 个函数合并后，优点是减少重复的代码，维护较容易，但缺点可能是带来性能的少量影响。</p><br />
<br />
<ol><br />
  <li>JSON 数字语法<br />
回归正题，本单元的重点在于解析 JSON number 类型。我们先看看它的语法：</li><br />
</ol><br />
<br />
<p>number = [ “-“ ] int [ frac ] [ exp ]<br />
int = “0” / digit1-9 <em>digit<br />
frac = “.” 1</em>digit<br />
exp = (“e” / “E”) [”-“ / “+”] 1*digit<br />
number 是以十进制表示，它主要由 4 部分顺序组成：负号、整数、小数、指数。只有整数是必需部分。注意和直觉可能不同的是，正号是不合法的。</p><br />
<br />
<p>整数部分如果是 0 开始，只能是单个 0；而由 1-9 开始的话，可以加任意数量的数字（0-9）。也就是说，0123 不是一个合法的 JSON 数字。</p><br />
<br />
<p>小数部分比较直观，就是小数点后是一或多个数字（0-9）。</p><br />
<br />
<p>JSON 可使用科学记数法，指数部分由大写 E 或小写 e 开始，然后可有正负号，之后是一或多个数字（0-9）。</p><br />
<br />
<p>JSON 标准 ECMA-404 采用图的形式表示语法，也可以更直观地看到解析时可能经过的路径：</p><br />
<br />
<p>上一单元的 null、false、true 在解析后，我们只需把它们存储为类型。但对于数字，我们要考虑怎么存储解析后的结果。</p><br />
<br />
<ol><br />
  <li>数字表示方式<br />
从 JSON 数字的语法，我们可能直观地会认为它应该表示为一个浮点数（floating point number），因为它带有小数和指数部分。然而，标准中并没有限制数字的范围或精度。为简单起见，leptjson 选择以双精度浮点数（C 中的 double 类型）来存储 JSON 数字。</li><br />
</ol><br />
<br />
<p>我们为 lept_value 添加成员：</p><br />
<br />
<p>typedef struct {<br />
    double n;<br />
    lept_type type;<br />
}lept_value;<br />
仅当 type == LEPT_NUMBER 时，n 才表示 JSON 数字的数值。所以获取该值的 API 是这么实现的：</p><br />
<br />
<p>double lept_get_number(const lept_value* v) {<br />
    assert(v != NULL &amp;&amp; v-&gt;type == LEPT_NUMBER);<br />
    return v-&gt;n;<br />
}<br />
使用者应确保类型正确，才调用此 API。我们继续使用断言来保证。</p><br />
<br />
<ol><br />
  <li>单元测试<br />
我们定义了 API 之后，按照 TDD，我们可以先写一些单元测试。这次我们使用多行的宏的减少重复代码：</li><br />
</ol><br />
<br />
<p>#define TEST_NUMBER(expect, json)<br /><br />
    do {<br /><br />
        lept_value v;<br /><br />
        EXPECT_EQ_INT(LEPT_PARSE_OK, lept_parse(&amp;v, json));<br /><br />
        EXPECT_EQ_INT(LEPT_NUMBER, lept_get_type(&amp;v));<br /><br />
        EXPECT_EQ_DOUBLE(expect, lept_get_number(&amp;v));<br /><br />
    } while(0)</p><br />
<br />
<p>static void test_parse_number() {<br />
    TEST_NUMBER(0.0, “0”);<br />
    TEST_NUMBER(0.0, “-0”);<br />
    TEST_NUMBER(0.0, “-0.0”);<br />
    TEST_NUMBER(1.0, “1”);<br />
    TEST_NUMBER(-1.0, “-1”);<br />
    TEST_NUMBER(1.5, “1.5”);<br />
    TEST_NUMBER(-1.5, “-1.5”);<br />
    TEST_NUMBER(3.1416, “3.1416”);<br />
    TEST_NUMBER(1E10, “1E10”);<br />
    TEST_NUMBER(1e10, “1e10”);<br />
    TEST_NUMBER(1E+10, “1E+10”);<br />
    TEST_NUMBER(1E-10, “1E-10”);<br />
    TEST_NUMBER(-1E10, “-1E10”);<br />
    TEST_NUMBER(-1e10, “-1e10”);<br />
    TEST_NUMBER(-1E+10, “-1E+10”);<br />
    TEST_NUMBER(-1E-10, “-1E-10”);<br />
    TEST_NUMBER(1.234E+10, “1.234E+10”);<br />
    TEST_NUMBER(1.234E-10, “1.234E-10”);<br />
    TEST_NUMBER(0.0, “1e-10000”); /* must underflow */<br />
}<br />
以上这些都是很基本的测试用例，也可供调试用。大部分情况下，测试案例不能穷举所有可能性。因此，除了加入一些典型的用例，我们也常会使用一些边界值，例如最大值等。练习中会让同学找一些边界值作为用例。</p><br />
<br />
<p>除了这些合法的 JSON，我们也要写一些不合语法的用例：</p><br />
<br />
<p>static void test_parse_invalid_value() {<br />
    /* … <em>/<br />
    /</em> invalid number <em>/<br />
    TEST_ERROR(LEPT_PARSE_INVALID_VALUE, “+0”);<br />
    TEST_ERROR(LEPT_PARSE_INVALID_VALUE, “+1”);<br />
    TEST_ERROR(LEPT_PARSE_INVALID_VALUE, “.123”); /</em> at least one digit before ‘.’ <em>/<br />
    TEST_ERROR(LEPT_PARSE_INVALID_VALUE, “1.”);   /</em> at least one digit after ‘.’ */<br />
    TEST_ERROR(LEPT_PARSE_INVALID_VALUE, “INF”);<br />
    TEST_ERROR(LEPT_PARSE_INVALID_VALUE, “inf”);<br />
    TEST_ERROR(LEPT_PARSE_INVALID_VALUE, “NAN”);<br />
    TEST_ERROR(LEPT_PARSE_INVALID_VALUE, “nan”);<br />
}</p><br />
<ol><br />
  <li>十进制转换至二进制<br />
我们需要把十进制的数字转换成二进制的 double。这并不是容易的事情 [2]。为了简单起见，leptjson 将使用标准库的strtod() 来进行转换。strtod() 可转换 JSON 所要求的格式，但问题是，一些 JSON 不容许的格式，strtod() 也可转换，所以我们需要自行做格式校验。</li><br />
</ol><br />
<br />
<p>#include <stdlib.h>  /* NULL, strtod() */</stdlib.h></p><br />
<br />
<p>static int lept_parse_number(lept_context* c, lept_value* v) {<br />
    char* end;<br />
    /* \TODO validate number */<br />
    v-&gt;n = strtod(c-&gt;json, &amp;end);<br />
    if (c-&gt;json == end)<br />
        return LEPT_PARSE_INVALID_VALUE;<br />
    c-&gt;json = end;<br />
    v-&gt;type = LEPT_NUMBER;<br />
    return LEPT_PARSE_OK;<br />
}<br />
加入了 number 后，value 的语法变成：</p><br />
<br />
<p>value = null / false / true / number<br />
记得在第一单元中，我们说可以用一个字符就能得知 value 是什么类型，有 11 个字符可判断 number：</p><br />
<br />
<p>0-9/- ➔ number<br />
但是，由于我们在 lept_parse_number() 内部将会校验输入是否正确的值，我们可以简单地把余下的情况都交给lept_parse_number()：</p><br />
<br />
<p>static int lept_parse_value(lept_context* c, lept_value* v) {<br />
    switch (*c-&gt;json) {<br />
        case ‘t’:  return lept_parse_true(c, v);<br />
        case ‘f’:  return lept_parse_false(c, v);<br />
        case ‘n’:  return lept_parse_null(c, v);<br />
        default:   return lept_parse_number(c, v);<br />
        case ‘\0’: return LEPT_PARSE_EXPECT_VALUE;<br />
    }<br />
}</p><br />
<ol><br />
  <li>总结与练习<br />
本单元讲述了 JSON 数字类型的语法，以及 leptjson 所采用的自行校验＋strtod()转换为 double 的方案。实际上一些 JSON 库会采用更复杂的方案，例如支持 64 位带符号／无符号整数，自行实现转换。以我的个人经验，解析／生成数字类型可以说是 RapidJSON 中最难实现的部分，也是 RapidJSON 高效性能的原因，有机会再另外撰文解释。</li><br />
</ol><br />
<br />
<p>此外我们谈及，重构与单元测试是互相依赖的软件开发技术，适当地运用可提升软件的品质。之后的单元还会有相关的话题。</p><br />
<br />
<p>重构合并 lept_parse_null()、lept_parse_false()、lept_parse_true 为 lept_parse_literal()。<br />
加入 维基百科双精度浮点数 的一些边界值至单元测试，如 min subnormal positive double、max double 等。<br />
去掉 test_parse_invalid_value() 和 test_parse_root_not_singular 中的 #if 0 … #endif，执行测试，证实测试失败。按 JSON number 的语法在 lept_parse_number() 校验，不符合标准的程况返回LEPT_PARSE_INVALID_VALUE　错误码。<br />
去掉 test_parse_number_too_big 中的 #if 0 … #endif，执行测试，证实测试失败。仔细阅读 strtod()，看看怎样从返回值得知数值是否过大，以返回 LEPT_PARSE_NUMBER_TOO_BIG 错误码。（提示：这里需要 #include 额外两个标准库头文件。）<br />
以上最重要的是第 3 条题目，就是要校验 JSON 的数字语法。建议可使用以下两个宏去简化一下代码：</p><br />
<br />
<p>#define ISDIGIT(ch)         ((ch) &gt;= ‘0’ &amp;&amp; (ch) &lt;= ‘9’)<br />
#define ISDIGIT1TO9(ch)     ((ch) &gt;= ‘1’ &amp;&amp; (ch) &lt;= ‘9’)<br />
另一提示，在校验成功以后，我们不再使用 end 指针去检测 strtod() 的正确性，第二个参数可传入 NULL。</p><br />
<br />
<p>如果你遇到问题，有不理解的地方，或是有建议，都欢迎在评论或 issue 中提出，让所有人一起讨论。</p><br />
<br />
<ol><br />
  <li><br />
    <p>参考<br />
[1] Fowler, Martin. Refactoring: improving the design of existing code. Pearson Education India, 2009. 中译本：《重构：改善既有代码的设计》，熊节译，人民邮电出版社，2010年。 [2] Gay, David M. “Correctly rounded binary-decimal and decimal-binary conversions.” Numerical Analysis Manuscript 90-10 (1990).</p><br />
  </li><br />
  <li><br />
    <p>常见问题<br />
为什么要把一些测试代码以 #if 0 … #endif 禁用？</p><br />
  </li><br />
</ol><br />
<br />
<p>因为在做第 1 个练习题时，我希望能 100% 通过测试，方便做重构。另外，使用 #if 0 … #endif 而不使用 /* … */，是因为 C 的注释不支持嵌套（nested），而 #if … #endif 是支持嵌套的。代码中已有注释时，用 #if 0 … #endif 去禁用代码是一个常用技巧，而且可以把 0 改为 1 去恢复。</p><br />
<br />
<p>科学计数法的指数部分没有对前导零作限制吗？1E012 也是合法的吗？</p><br />
<br />
<p>是的，这是合法的。JSON 源自于 JavaScript（ECMA-262, 3rd edition），数字语法取自 JavaScript 的十进位数字的语法（§7.8.3 Numeric Literals）。整数不容许前导零（leading zero），是因为更久的 JavaScript 版本容许以前导零来表示八进位数字，如 052 == 42，这种八进位常数表示方式来自于 C 语言。禁止前导零避免了可能出现的歧义。但是在指数里就不会出现这个问题。多谢 @Smallay 提出及协助解答这个问题。</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/22538880</p><br />
<ol><br />
  <li>重构合并<br />
由于 true / false / null 的字符数量不一样，这个答案以 for 循环作比较，直至 ‘\0’。</li><br />
</ol><br />
<br />
<p>static int lept_parse_literal(lept_context* c, lept_value* v,<br />
    const char* literal, lept_type type)<br />
{<br />
    size_t i;<br />
    EXPECT(c, literal[0]);<br />
    for (i = 0; literal[i + 1]; i++)<br />
        if (c-&gt;json[i] != literal[i + 1])<br />
            return LEPT_PARSE_INVALID_VALUE;<br />
    c-&gt;json += i;<br />
    v-&gt;type = type;<br />
    return LEPT_PARSE_OK;<br />
}</p><br />
<br />
<p>static int lept_parse_value(lept_context* c, lept_value* v) {<br />
    switch (<em>c-&gt;json) {<br />
        case ‘t’: return lept_parse_literal(c, v, “true”, LEPT_TRUE);<br />
        case ‘f’: return lept_parse_literal(c, v, “false”, LEPT_FALSE);<br />
        case ‘n’: return lept_parse_literal(c, v, “null”, LEPT_NULL);<br />
        /</em> … */<br />
    }<br />
}<br />
注意在 C 语言中，数组长度、索引值最好使用 size_t 类型，而不是 int 或 unsigned。</p><br />
<br />
<p>你也可以直接传送长度参数 4、5、4，只要能通过测试就行了。</p><br />
<br />
<ol><br />
  <li>边界值测试<br />
这问题其实涉及一些浮点数类型的细节，例如 IEEE-754 浮点数中，有所谓的 normal 和 subnormal 值，这里暂时不展开讨论了。以下是我加入的一些边界值，可能和同学的不完全一样。</li><br />
</ol><br />
<br />
<p>/* the smallest number &gt; 1 <em>/<br />
TEST_NUMBER(1.0000000000000002, “1.0000000000000002”);<br />
/</em> minimum denormal <em>/<br />
TEST_NUMBER( 4.9406564584124654e-324, “4.9406564584124654e-324”);<br />
TEST_NUMBER(-4.9406564584124654e-324, “-4.9406564584124654e-324”);<br />
/</em> Max subnormal double <em>/<br />
TEST_NUMBER( 2.2250738585072009e-308, “2.2250738585072009e-308”);<br />
TEST_NUMBER(-2.2250738585072009e-308, “-2.2250738585072009e-308”);<br />
/</em> Min normal positive double <em>/<br />
TEST_NUMBER( 2.2250738585072014e-308, “2.2250738585072014e-308”);<br />
TEST_NUMBER(-2.2250738585072014e-308, “-2.2250738585072014e-308”);<br />
/</em> Max double */<br />
TEST_NUMBER( 1.7976931348623157e+308, “1.7976931348623157e+308”);<br />
TEST_NUMBER(-1.7976931348623157e+308, “-1.7976931348623157e+308”);<br />
另外，这些加入的测试用例，正常的 strtod() 都能通过。所以不能做到测试失败、修改实现、测试成功的 TDD 步骤。</p><br />
<br />
<p>有一些 JSON 解析器不使用 strtod() 而自行转换，例如在校验的同时，记录负号、尾数（整数和小数）和指数，然后 naive 地计算：</p><br />
<br />
<p>int negative = 0;<br />
int64_t mantissa = 0;<br />
int exp = 0;</p><br />
<br />
<p>/* 解析… 并存储 negative, mantissa, exp */<br />
v-&gt;n = (negative ? -mantissa : mantissa) * pow(10.0, exp);<br />
这种做法会有精度问题。实现正确的答案是很复杂的，RapidJSON 的初期版本也是 naive 的，后来 RapidJSON 就内部实现了三种算法（使用 kParseFullPrecision 选项开启），最后一种算法用到了大整数（高精度计算）。有兴趣的同学也可以先尝试做一个 naive 版本，不使用 strtod()。之后可再参考 Google 的 double-conversion 开源项目及相关论文。</p><br />
<br />
<ol><br />
  <li>校验数字<br />
这条题目是本单元的重点，考验同学是否能把语法手写为校验规则。我详细说明。</li><br />
</ol><br />
<br />
<p>首先，如同 lept_parse_whitespace()，我们使用一个指针 p 来表示当前的解析字符位置。这样做有两个好处，一是代码更简单，二是在某些编译器下性能更好（因为不能确定 c 会否被改变，从而每次更改 c-&gt;json 都要做一次间接访问）。如果校验成功，才把 p 赋值至 c-&gt;json。</p><br />
<br />
<p>static int lept_parse_number(lept_context* c, lept_value* v) {<br />
    const char* p = c-&gt;json;<br />
    /* 负号 … <em>/<br />
    /</em> 整数 … <em>/<br />
    /</em> 小数 … <em>/<br />
    /</em> 指数 … */<br />
    v-&gt;n = strtod(c-&gt;json, NULL);<br />
    v-&gt;type = LEPT_NUMBER;<br />
    c-&gt;json = p;<br />
    return LEPT_PARSE_OK;<br />
}<br />
我们把语法再看一遍：</p><br />
<br />
<p>number = [ “-“ ] int [ frac ] [ exp ]<br />
int = “0” / digit1-9 <em>digit<br />
frac = “.” 1</em>digit<br />
exp = (“e” / “E”) [”-“ / “+”] 1*digit<br />
负号最简单，有的话跳过便行：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (*p == '-') p++; 整数部分有两种合法情况，一是单个 0，否则是一个 1-9 再加上任意数量的 digit。对于第一种情况，我们像负数般跳过便行。对于第二种情况，第一个字符必须为 1-9，如果否定的就是不合法的，可立即返回错误码。然后，有多少个 digit 就跳过多少个。<br />
<br />
<br />
if (*p == '0') p++;<br />
else {<br />
    if (!ISDIGIT1TO9(*p)) return LEPT_PARSE_INVALID_VALUE;<br />
    for (p++; ISDIGIT(*p); p++);<br />
} 如果出现小数点，我们跳过该小数点，然后检查它至少应有一个 digit，不是 digit 就返回错误码。跳过首个 digit，我们再检查有没有 digit，有多少个跳过多少个。这里用了 for 循环技巧来做这件事。<br />
<br />
<br />
if (*p == '.') {<br />
    p++;<br />
    if (!ISDIGIT(*p)) return LEPT_PARSE_INVALID_VALUE;<br />
    for (p++; ISDIGIT(*p); p++);<br />
} 最后，如果出现大小写 e，就表示有指数部分。跳过那个 e 之后，可以有一个正或负号，有的话就跳过。然后和小数的逻辑是一样的。<br />
<br />
<br />
if (*p == 'e' || *p == 'E') {<br />
    p++;<br />
    if (*p == '+' || *p == '-') p++;<br />
    if (!ISDIGIT(*p)) return LEPT_PARSE_INVALID_VALUE;<br />
    for (p++; ISDIGIT(*p); p++);<br />
} 这里用了 18 行代码去做这个校验。当中把一些 if 用一行来排版，而没用采用传统两行缩进风格，我个人认为在不影响阅读时可以这样弹性处理。当然那些 for 也可分拆成三行：<br />
<br />
<br />
    p++;<br />
    while (ISDIGIT(*p))<br />
        p++; 4. 数字过大的处理 最后这题纯粹是阅读理解题。<br />
</code></pre></div></div><br />
<br />
<p>#include <errno.h>   /* errno, ERANGE */<br />
#include <math.h>    /* HUGE_VAL */</math.h></errno.h></p><br />
<br />
<p>static int lept_parse_number(lept_context* c, lept_value* v) {<br />
    /* … <em>/<br />
    errno = 0;<br />
    v-&gt;n = strtod(c-&gt;json, NULL);<br />
    if (errno == ERANGE &amp;&amp; (v-&gt;n == HUGE_VAL || v-&gt;n == -HUGE_VAL))<br />
        return LEPT_PARSE_NUMBER_TOO_BIG;<br />
    /</em> … */<br />
}<br />
许多时候课本／书籍也不会把每个标准库功能说得很仔细，我想藉此提醒同学要好好看参考文档，学会读文档编程就简单得多！cppreference.com 是 C/C++ 程序员的宝库。</p><br />
<br />
<ol><br />
  <li>总结<br />
本单元的习题比上个单元较有挑战性一些，所以我花了多一些篇幅在解答篇。纯以语法来说，数字类型已经是 JSON 中最复杂的类型。如果同学能完成本单元的练习（特别是第 3 条），之后的字符串、数组和对象的语法一定难不到你。然而，接下来也会有一些新挑战，例如内存管理、数据结构、编码等，希望你能满载而归。</li><br />
</ol><br />
<br />
<p>如果你遇到问题，有不理解的地方，或是有建议，都欢迎在评论或 issue 中提出，让所有人一起讨论。</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/22566705<br />
解析字符串<br />
JSON 字符串语法<br />
字符串表示<br />
内存管理<br />
缓冲区与堆栈<br />
解析字符串<br />
总结和练习<br />
参考<br />
常见问题</p><br />
<br />
<ol><br />
  <li>JSON 字符串语法<br />
JSON 的字符串语法和 C 语言很相似，都是以双引号把字符括起来，如 “Hello”。但字符串采用了双引号作分隔，那么怎样可以在字符串中插入一个双引号？ 把 a”b 写成 “a”b” 肯定不行，都不知道那里是字符串的结束了。因此，我们需要引入转义字符（escape character），C 语言和 JSON 都使用 \（反斜线）作为转义字符，那么 “ 在字符串中就表示为"，a”b 的 JSON 字符串则写成 “a"b”。如以下的字符串语法所示，JSON 共支持 9 种转义序列：</li><br />
</ol><br />
<br />
<p>string = quotation-mark *char quotation-mark<br />
char = unescaped /<br />
   escape (<br />
       %x22 /          ; “    quotation mark  U+0022<br />
       %x5C /          ; \    reverse solidus U+005C<br />
       %x2F /          ; /    solidus         U+002F<br />
       %x62 /          ; b    backspace       U+0008<br />
       %x66 /          ; f    form feed       U+000C<br />
       %x6E /          ; n    line feed       U+000A<br />
       %x72 /          ; r    carriage return U+000D<br />
       %x74 /          ; t    tab             U+0009<br />
       %x75 4HEXDIG )  ; uXXXX                U+XXXX<br />
escape = %x5C          ; <br /><br />
quotation-mark = %x22  ; “<br />
unescaped = %x20-21 / %x23-5B / %x5D-10FFFF<br />
简单翻译一下，JSON 字符串是由前后两个双引号夹着零至多个字符。字符分开无转义字符或转义序列。转义序列有 9 种，都是以反斜线开始，如常见的 \n 代表换行符。比较特殊的是 \uXXXX，当中 XXXX 为 16 进位的 UTF-16 编码，本单元将不处理这种转义序列，留待下回分解。</p><br />
<br />
<p>无转义字符就是普通的字符，语法中列出了合法的码点范围（码点还是在下单元才介绍）。要注意的是，该范围不包括 0 至 31、双引号和反斜线，这些码点都必须要使用转义方式表示。</p><br />
<br />
<ol><br />
  <li>字符串表示<br />
在 C 语言中，字符串一般表示为空结尾字符串（null-terminated string），即以空字符（’\0’）代表字符串的结束。然而，JSON 字符串是允许含有空字符的，例如这个 JSON “Hello\u0000World” 就是单个字符串，解析后为11个字符。如果纯粹使用空结尾字符来表示 JSON 解析后的结果，就没法处理空字符。</li><br />
</ol><br />
<br />
<p>因此，我们可以分配内存来储存解析后的字符，以及记录字符的数目（即字符串长度）。由于大部分 C 程序都假设字符串是空结尾字符串，我们还是在最后加上一个空字符，那么不需处理 \u0000 这种字符的应用可以简单地把它当作是空结尾字符串。</p><br />
<br />
<p>了解需求后，我们考虑实现。lept_value 事实上是一种变体类型（variant type），我们通过 type 来决定它现时是哪种类型，而这也决定了哪些成员是有效的。首先我们简单地在这个结构中加入两个成员：</p><br />
<br />
<p>typedef struct {<br />
    char* s;<br />
    size_t len;<br />
    double n;<br />
    lept_type type;<br />
}lept_value;<br />
然而我们知道，一个值不可能同时为数字和字符串，因此我们可使用 C 语言的 union 来节省内存：</p><br />
<br />
<p>typedef struct {<br />
    union {<br />
        struct { char* s; size_t len; }s;  /* string <em>/<br />
        double n;                          /</em> number */<br />
    }u;<br />
    lept_type type;<br />
}lept_value;<br />
这两种设计在 32 位平台时的内存布局如下，可看出右方使用 union 的能省下内存。</p><br />
<br />
<p>我们要把之前的 v-&gt;n 改成 v-&gt;u.n。而要访问字符串的数据，则要使用 v-&gt;u.s.s 和 v-&gt;u.s.len。这种写法比较麻烦吧，其实 C11 新增了匿名 struct/union 语法，就可以采用 v-&gt;n、v-&gt;s、v-&gt;len 来作访问。</p><br />
<br />
<ol><br />
  <li>内存管理<br />
由于字符串的长度不是固定的，我们要动态分配内存。为简单起见，我们使用标准库 <stdlib.h> 中的malloc()、realloc() 和 free() 来分配／释放内存。</stdlib.h></li><br />
</ol><br />
<br />
<p>当设置一个值为字符串时，我们需要把参数中的字符串复制一份：</p><br />
<br />
<p>void lept_set_string(lept_value* v, const char* s, size_t len) {<br />
    assert(v != NULL &amp;&amp; (s != NULL || len == 0));<br />
    lept_free(v);<br />
    v-&gt;u.s.s = (char*)malloc(len + 1);<br />
    memcpy(v-&gt;u.s.s, s, len);<br />
    v-&gt;u.s.s[len] = ‘\0’;<br />
    v-&gt;u.s.len = len;<br />
    v-&gt;type = LEPT_STRING;<br />
}<br />
断言中的条件是，非空指针（有具体的字符串）或是零长度的字符串都是合法的。</p><br />
<br />
<p>注意，在设置这个 v 之前，我们需要先调用 lept_free(v) 去清空 v 可能分配到的内存。例如原来已有一字符串，我们要先把它释放。然后就是简单地用 malloc() 分配及用 memcpy() 复制，并补上结尾空字符。malloc(len + 1) 中的 1 是因为结尾空字符。</p><br />
<br />
<p>那么，再看看 lept_free()：</p><br />
<br />
<p>void lept_free(lept_value* v) {<br />
    assert(v != NULL);<br />
    if (v-&gt;type == LEPT_STRING)<br />
        free(v-&gt;u.s.s);<br />
    v-&gt;type = LEPT_NULL;<br />
}<br />
现时仅当值是字符串类型，我们才要处理，之后我们还要加上对数组及对象的释放。lept_free(v) 之后，会把它的类型变成 null。这个设计能避免重复释放。</p><br />
<br />
<p>但也由于我们会检查 v 的类型，在调用所有访问函数之前，我们必须初始化该类型。所以我们加入 lept_init(v)，因非常简单我们用宏实现：</p><br />
<br />
<p>#define lept_init(v) do { (v)-&gt;type = LEPT_NULL; } while(0)<br />
用上 do { … } while(0) 是为了把表达式转为语句，模仿无返回值的函数。</p><br />
<br />
<p>其实在前两个单元中，我们只提供读取值的 API，没有写入的 API，就是因为写入时我们还要考虑释放内存。我们在本单元中把它们补全：</p><br />
<br />
<p>#define lept_set_null(v) lept_free(v)</p><br />
<br />
<p>int lept_get_boolean(const lept_value* v);<br />
void lept_set_boolean(lept_value* v, int b);</p><br />
<br />
<p>double lept_get_number(const lept_value* v);<br />
void lept_set_number(lept_value* v, double n);</p><br />
<br />
<p>const char* lept_get_string(const lept_value* v);<br />
size_t lept_get_string_length(const lept_value* v);<br />
void lept_set_string(lept_value* v, const char* s, size_t len);<br />
由于 lept_free() 实际上也会把 v 变成 null 值，我们只用一个宏来提供 lept_set_null() 这个 API。</p><br />
<br />
<p>应用方的代码在调用 lept_parse() 之后，最终也应该调用 lept_free() 去释放内存。我们把之前的单元测试也加入此调用。</p><br />
<br />
<p>如果不使用 lept_parse()，我们需要初始化值，那么就像以下的单元测试，先 lept_init()，最后 lept_free()。</p><br />
<br />
<p>static void test_access_string() {<br />
    lept_value v;<br />
    lept_init(&amp;v);<br />
    lept_set_string(&amp;v, “”, 0);<br />
    EXPECT_EQ_STRING(“”, lept_get_string(&amp;v), lept_get_string_length(&amp;v));<br />
    lept_set_string(&amp;v, “Hello”, 5);<br />
    EXPECT_EQ_STRING(“Hello”, lept_get_string(&amp;v), lept_get_string_length(&amp;v));<br />
    lept_free(&amp;v);<br />
}</p><br />
<ol><br />
  <li>缓冲区与堆栈<br />
我们解析字符串（以及之后的数组、对象）时，需要把解析的结果先储存在一个临时的缓冲区，最后再用lept_set_string() 把缓冲区的结果设进值之中。在完成解析一个字符串之前，这个缓冲区的大小是不能预知的。因此，我们可以采用动态数组（dynamic array）这种数据结构，即数组空间不足时，能自动扩展。C++ 标准库的 std::vector 也是一种动态数组。</li><br />
</ol><br />
<br />
<p>如果每次解析字符串时，都重新建一个动态数组，那么是比较耗时的。我们可以重用这个动态数组，每次解析 JSON 时就只需要创建一个。而且我们将会发现，无论是解析字符串、数组或对象，我们也只需要以先进后出的方式访问这个动态数组。换句话说，我们需要一个动态的堆栈数据结构。</p><br />
<br />
<p>我们把一个动态堆栈的数据放进 lept_context 里：</p><br />
<br />
<p>typedef struct {<br />
    const char* json;<br />
    char* stack;<br />
    size_t size, top;<br />
}lept_context;<br />
当中 size 是当前的堆栈容量，top 是栈顶的位置（由于我们会扩展 stack，所以不要把 top 用指针形式存储）。</p><br />
<br />
<p>然后，我们在创建 lept_context 的时候初始化 stack 并最终释放内存：</p><br />
<br />
<p>int lept_parse(lept_value* v, const char* json) {<br />
    lept_context c;<br />
    int ret;<br />
    assert(v != NULL);<br />
    c.json = json;<br />
    c.stack = NULL;        /* &lt;- <em>/<br />
    c.size = c.top = 0;    /</em> &lt;- <em>/<br />
    lept_init(v);<br />
    lept_parse_whitespace(&amp;c);<br />
    if ((ret = lept_parse_value(&amp;c, v)) == LEPT_PARSE_OK) {<br />
        /</em> … <em>/<br />
    }<br />
    assert(c.top == 0);    /</em> &lt;- <em>/<br />
    free(c.stack);         /</em> &lt;- */<br />
    return ret;<br />
}<br />
在释放时，加入了断言确保所有数据都被弹出。</p><br />
<br />
<p>然后，我们实现堆栈的压入及弹出操作。和普通的堆栈不一样，我们这个堆栈是以字节储存的。每次可要求压入任意大小的数据，它会返回数据起始的指针（会 C++ 的同学可再参考[1]）：</p><br />
<br />
<p>#ifndef LEPT_PARSE_STACK_INIT_SIZE<br />
#define LEPT_PARSE_STACK_INIT_SIZE 256<br />
#endif</p><br />
<br />
<p>static void* lept_context_push(lept_context* c, size_t size) {<br />
    void* ret;<br />
    assert(size &gt; 0);<br />
    if (c-&gt;top + size &gt;= c-&gt;size) {<br />
        if (c-&gt;size == 0)<br />
            c-&gt;size = LEPT_PARSE_STACK_INIT_SIZE;<br />
        while (c-&gt;top + size &gt;= c-&gt;size)<br />
            c-&gt;size += c-&gt;size » 1;  /* c-&gt;size * 1.5 <em>/<br />
        c-&gt;stack = (char</em>)realloc(c-&gt;stack, c-&gt;size);<br />
    }<br />
    ret = c-&gt;stack + c-&gt;top;<br />
    c-&gt;top += size;<br />
    return ret;<br />
}</p><br />
<br />
<p>static void* lept_context_pop(lept_context* c, size_t size) {<br />
    assert(c-&gt;top &gt;= size);<br />
    return c-&gt;stack + (c-&gt;top -= size);<br />
}<br />
压入时若空间不足，便回以 1.5 倍大小扩展。为什么是 1.5 倍而不是两倍？可参考我在 STL 的 vector 有哪些封装上的技巧？的答案。</p><br />
<br />
<p>注意到这里使用了 realloc() 来重新分配内存，c-&gt;stack 在初始化时为 NULL，realloc(NULL, size) 的行为是等价于malloc(size) 的，所以我们不需要为第一次分配内存作特别处理。</p><br />
<br />
<p>另外，我们把初始大小以宏 LEPT_PARSE_STACK_INIT_SIZE 的形式定义，使用 #ifndef X #define X … #endif 方式的好处是，使用者可在编译选项中自行设置宏，没设置的话就用缺省值。</p><br />
<br />
<ol><br />
  <li>解析字符串<br />
有了以上的工具，解析字符串的任务就变得很简单。我们只需要先备份栈顶，然后把解析到的字符压栈，最后计算出长度并一次性把所有字符弹出，再设置至值里便可以。以下是部分实现，没有处理转义和一些不合法字符的校验。</li><br />
</ol><br />
<br />
<p>#define PUTC(c, ch) do { <em>(char</em>)lept_context_push(c, sizeof(char)) = (ch); } while(0)</p><br />
<br />
<p>static int lept_parse_string(lept_context* c, lept_value* v) {<br />
    size_t head = c-&gt;top, len;<br />
    const char* p;<br />
    EXPECT(c, ‘"’);<br />
    p = c-&gt;json;<br />
    for (;;) {<br />
        char ch = <em>p++;<br />
        switch (ch) {<br />
            case ‘"’:<br />
                len = c-&gt;top - head;<br />
                lept_set_string(v, (const char</em>)lept_context_pop(c, len), len);<br />
                c-&gt;json = p;<br />
                return LEPT_PARSE_OK;<br />
            case ‘\0’:<br />
                c-&gt;top = head;<br />
                return LEPT_PARSE_MISS_QUOTATION_MARK;<br />
            default:<br />
                PUTC(c, ch);<br />
        }<br />
    }<br />
}</p><br />
<ol><br />
  <li>总结和练习<br />
之前的单元都是固定长度的数据类型（fixed length data type），而字符串类型是可变长度的数据类型（variable length data type），因此本单元花了较多篇幅讲述内存管理和数据结构的设计和实现。字符串的解析相对数字简单，以下的习题难度不高，同学们应该可轻松完成。</li><br />
</ol><br />
<br />
<p>编写 lept_get_boolean() 等访问函数的单元测试，然后实现。<br />
实现除了 \u 以外的转义序列解析，令 test_parse_string() 中所有测试通过。<br />
解决 test_parse_invalid_string_escape() 和 test_parse_invalid_string_char() 中的失败测试。<br />
思考如何优化 lept_parse_string() 的性能，那些优化方法有没有缺点。<br />
如果你遇到问题，有不理解的地方，或是有建议，都欢迎在评论或 issue 中提出，让所有人一起讨论。</p><br />
<br />
<ol><br />
  <li>参考<br />
[1] RapidJSON 代码剖析（一）：混合任意类型的堆栈<br />
https://zhuanlan.zhihu.com/p/20029820</li><br />
</ol><br />
<br />
<p>https://zhuanlan.zhihu.com/p/22664202</p><br />
<ol><br />
  <li>访问的单元测试<br />
在编写单元测试时，我们故意先把值设为字符串，那么做可以测试设置其他类型时，有没有调用 lept_free() 去释放内存。</li><br />
</ol><br />
<br />
<p>static void test_access_boolean() {<br />
    lept_value v;<br />
    lept_init(&amp;v);<br />
    lept_set_string(&amp;v, “a”, 1);<br />
    lept_set_boolean(&amp;v, 1);<br />
    EXPECT_TRUE(lept_get_boolean(&amp;v));<br />
    lept_set_boolean(&amp;v, 0);<br />
    EXPECT_FALSE(lept_get_boolean(&amp;v));<br />
    lept_free(&amp;v);<br />
}</p><br />
<br />
<p>static void test_access_number() {<br />
    lept_value v;<br />
    lept_init(&amp;v);<br />
    lept_set_string(&amp;v, “a”, 1);<br />
    lept_set_number(&amp;v, 1234.5);<br />
    EXPECT_EQ_DOUBLE(1234.5, lept_get_number(&amp;v));<br />
    lept_free(&amp;v);<br />
}<br />
以下是访问函数的实现：</p><br />
<br />
<p>int lept_get_boolean(const lept_value* v) {<br />
    assert(v != NULL &amp;&amp; (v-&gt;type == LEPT_TRUE || v-&gt;type == LEPT_FALSE));<br />
    return v-&gt;type == LEPT_TRUE;<br />
}</p><br />
<br />
<p>void lept_set_boolean(lept_value* v, int b) {<br />
    lept_free(v);<br />
    v-&gt;type = b ? LEPT_TRUE : LEPT_FALSE;<br />
}</p><br />
<br />
<p>double lept_get_number(const lept_value* v) {<br />
    assert(v != NULL &amp;&amp; v-&gt;type == LEPT_NUMBER);<br />
    return v-&gt;u.n;<br />
}</p><br />
<br />
<p>void lept_set_number(lept_value* v, double n) {<br />
    lept_free(v);<br />
    v-&gt;u.n = n;<br />
    v-&gt;type = LEPT_NUMBER;<br />
}<br />
那问题是，如果我们没有调用 lept_free()，怎样能发现这些内存泄漏？</p><br />
<br />
<p>1A. Windows 下的内存泄漏检测方法<br />
在 Windows 下，可使用 Visual C++ 的 C Runtime Library（CRT） 检测内存泄漏。</p><br />
<br />
<p>首先，我们在两个 .c 文件首行插入这一段代码：</p><br />
<br />
<p>#ifdef _WINDOWS<br />
#define _CRTDBG_MAP_ALLOC<br />
#include <crtdbg.h><br />
#endif<br />
并在 main() 开始位置插入：</crtdbg.h></p><br />
<br />
<p>int main() {<br />
#ifdef _WINDOWS<br />
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);<br />
#endif<br />
在 Debug 配置下按 F5 生成、开始调试程序，没有任何异样。</p><br />
<br />
<p>然后，我们删去 lept_set_boolean() 中的 lept_free(v)：</p><br />
<br />
<p>void lept_set_boolean(lept_value* v, int b) {<br />
    /* lept_free(v); */<br />
    v-&gt;type = b ? LEPT_TRUE : LEPT_FALSE;<br />
}<br />
再次按 F5 生成、开始调试程序，在输出会看到内存泄漏信息：</p><br />
<br />
<p>Detected memory leaks!<br />
Dumping objects -&gt;<br />
C:\GitHub\json-tutorial\tutorial03_answer\leptjson.c(212) : {79} normal block at 0x013D9868, 2 bytes long.<br />
 Data: <a> 61 00 <br />
Object dump complete.<br />
这正是我们在单元测试中，先设置字符串，然后设布尔值时没释放字符串所分配的内存。比较麻烦的是，它没有显示调用堆栈。从输出信息中 … {79} … 我们知道是第 79 次分配的内存做成问题，我们可以加上 _CrtSetBreakAlloc(79); 来调试，那么它便会在第 79 次时中断于分配调用的位置，那时候就能从调用堆栈去找出来龙去脉。</a></p><br />
<br />
<p>1B. Linux/OSX 下的内存泄漏检测方法<br />
在 Linux、OS X 下，我们可以使用 valgrind 工具（用 apt-get install valgrind、 brew install valgrind）。我们完全不用修改代码，只要在命令行执行：</p><br />
<br />
<p>$ valgrind –leak-check=full  ./leptjson_test<br />
==22078== Memcheck, a memory error detector<br />
==22078== Copyright (C) 2002-2015, and GNU GPL’d, by Julian Seward et al.<br />
==22078== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info<br />
==22078== Command: ./leptjson_test<br />
==22078== <br />
–22078– run: /usr/bin/dsymutil “./leptjson_test”<br />
160/160 (100.00%) passed<br />
==22078== <br />
==22078== HEAP SUMMARY:<br />
==22078==     in use at exit: 27,728 bytes in 209 blocks<br />
==22078==   total heap usage: 301 allocs, 92 frees, 34,966 bytes allocated<br />
==22078== <br />
==22078== 2 bytes in 1 blocks are definitely lost in loss record 1 of 79<br />
==22078==    at 0x100012EBB: malloc (in /usr/local/Cellar/valgrind/3.11.0/lib/valgrind/vgpreload_memcheck-amd64-darwin.so)<br />
==22078==    by 0x100008F36: lept_set_string (leptjson.c:208)<br />
==22078==    by 0x100008415: test_access_boolean (test.c:187)<br />
==22078==    by 0x100001849: test_parse (test.c:229)<br />
==22078==    by 0x1000017A3: main (test.c:235)<br />
==22078== <br />
…<br />
它发现了在 test_access_boolean() 中，由 lept_set_string() 分配的 2 个字节（”a”）泄漏了。</p><br />
<br />
<p>Valgrind 还有很多功能，例如可以发现未初始化变量。我们若在应用程序或测试程序中，忘了调用 lept_init(&amp;v)，那么v.type 的值没被初始化，其值是不确定的（indeterministic），一些函数如果读取那个值就会出现问题：</p><br />
<br />
<p>static void test_access_boolean() {<br />
    lept_value v;<br />
    /* lept_init(&amp;v); */<br />
    lept_set_string(&amp;v, “a”, 1);<br />
    …<br />
}<br />
这种错误有时候测试时能正确运行（刚好 v.type 被设为 0），使我们误以为程序正确，而在发布后一些机器上却可能崩溃。这种误以为正确的假像是很危险的，我们可利用 valgrind 能自动测出来：</p><br />
<br />
<p>$ valgrind –leak-check=full  ./leptjson_test<br />
…<br />
==22174== Conditional jump or move depends on uninitialised value(s)<br />
==22174==    at 0x100008B5D: lept_free (leptjson.c:164)<br />
==22174==    by 0x100008F26: lept_set_string (leptjson.c:207)<br />
==22174==    by 0x1000083FE: test_access_boolean (test.c:187)<br />
==22174==    by 0x100001839: test_parse (test.c:229)<br />
==22174==    by 0x100001793: main (test.c:235)<br />
==22174== <br />
它发现 lept_free() 中依靠了一个未初始化的值来跳转，就是 v.type，而错误是沿自 test_access_boolean()。</p><br />
<br />
<p>编写单元测试时，应考虑哪些执行次序会有机会出错，例如内存相关的错误。然后我们可以利用 TDD 的步骤，先令测试失败（以内存工具检测），修正代码，再确认测试是否成功。</p><br />
<br />
<ol><br />
  <li>转义序列的解析<br />
转义序列的解析很直观，对其他不合法的字符返回 LEPT_PARSE_INVALID_STRING_ESCAPE：</li><br />
</ol><br />
<br />
<p>static int lept_parse_string(lept_context* c, lept_value* v) {<br />
    /* … <em>/<br />
    for (;;) {<br />
        char ch = *p++;<br />
        switch (ch) {<br />
            /</em> … <em>/<br />
            case ‘\’:<br />
                switch (</em>p++) {<br />
                    case ‘"’: PUTC(c, ‘"’); break;<br />
                    case ‘\’: PUTC(c, ‘\’); break;<br />
                    case ‘/’:  PUTC(c, ‘/’ ); break;<br />
                    case ‘b’:  PUTC(c, ‘\b’); break;<br />
                    case ‘f’:  PUTC(c, ‘\f’); break;<br />
                    case ‘n’:  PUTC(c, ‘\n’); break;<br />
                    case ‘r’:  PUTC(c, ‘\r’); break;<br />
                    case ‘t’:  PUTC(c, ‘\t’); break;<br />
                    default:<br />
                        c-&gt;top = head;<br />
                        return LEPT_PARSE_INVALID_STRING_ESCAPE;<br />
                }<br />
                break;<br />
           /* … */<br />
       }<br />
   }<br />
 }</p><br />
<ol><br />
  <li>不合法的字符串<br />
上面已解决不合法转义，余下部分的唯一难度，是要从语法中知道哪些是不合法字符：</li><br />
</ol><br />
<br />
<p>unescaped = %x20-21 / %x23-5B / %x5D-10FFFF<br />
当中空缺的 %x22 是双引号，%x5C 是反斜线，都已经处理。所以不合法的字符是 %x00 至 %x1F。我们简单地在 default 里处理：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    /* ... */<br />
        default:<br />
            if ((unsigned char)ch &lt; 0x20) { <br />
                c-&gt;top = head;<br />
                return LEPT_PARSE_INVALID_STRING_CHAR;<br />
            }<br />
            PUTC(c, ch);<br />
    /* ... */ 注意到 char 带不带符号，是实现定义的。如果编译器定义 char 为带符号的话，(unsigned char)ch &gt;= 0x80 的字符，都会变成负数，并产生 LEPT_PARSE_INVALID_STRING_CHAR 错误。我们现时还没有测试 ASCII 以外的字符，所以有没有转型至不带符号都不影响，但下一单元开始处理 Unicode 的时候就要考虑了。<br />
</code></pre></div></div><br />
<br />
<ol><br />
  <li>性能优化的思考<br />
这是本教程第一次的开放式问题，没有标准答案。以下列出一些我想到的。</li><br />
</ol><br />
<br />
<p>如果整个字符串都没有转义符，我们不就是把字符复制了两次？第一次是从 json 到 stack，第二次是从 stack 到 v-&gt;u.s.s。我们可以在 json 掃描 ‘\0’、’"’ 和 ‘\’ 3 个字符（ ch &lt; 0x20 还是要检查），直至它们其中一个出现，才开始用现在的解析方法。这样做的话，前半没转义的部分可以只复制一次。缺点是，代码变得复杂一些，我们也不能使用 lept_set_string()。<br />
对于掃描没转义部分，我们可考虑用 SIMD 加速，如 RapidJSON 代码剖析（二）：使用 SSE4.2 优化字符串扫描 的做法。这类底层优化的缺点是不跨平台，需要设置编译选项等。<br />
在 gcc/clang 上使用 __builtin_expect() 指令来处理低概率事件，例如需要对每个字符做LEPT_PARSE_INVALID_STRING_CHAR 检测，我们可以假设出现不合法字符是低概率事件，然后用这个指令告之编译器，那么编译器可能可生成较快的代码。然而，这类做法明显是不跨编译器，甚至是某个版本后的 gcc 才支持。</p><br />
<ol><br />
  <li>总结<br />
本解答篇除了给出一些建议方案，也介绍了内存泄漏的检测方法。JSON 字符串本身的语法并不复杂，但它需要相关的内存分配与数据结构的设计，还好这些设计都能用于之后的数组和对象类型。下一单元专门针对 Unicode，这部分也是许多 JSON 库没有妥善处理的地方。</li><br />
</ol><br />
<br />
<p>如果你遇到问题，有不理解的地方，或是有建议，都欢迎在评论或 issue 中提出，让所有人一起讨论。</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/22731540</p><br />
<br />
<p>Unicode<br />
需求<br />
UTF-8 编码<br />
实现 \uXXXX 解析<br />
总结与练习</p><br />
<br />
<ol><br />
  <li>Unicode<br />
在上一个单元，我们已经能解析「一般」的 JSON 字符串，仅仅没有处理 \uXXXX 这种转义序列。为了解析这种序列，我们必须了解有关 Unicode 的基本概念。</li><br />
</ol><br />
<br />
<p>读者应该知道 ASCII，它是一种字符编码，把 128 个字符映射至整数 0 ~ 127。例如，1 → 49，A → 65，B → 66 等等。这种 7-bit 字符编码系统非常简单，在计算机中以一个字节存储一个字符。然而，它仅适合美国英语，甚至一些英语中常用的标点符号、重音符号都不能表示，无法表示各国语言，特别是中日韩语等表意文字。</p><br />
<br />
<p>在 Unicode 出现之前，各地区制定了不同的编码系统，如中文主要用 GB 2312 和大五码、日文主要用 JIS 等。这样会造成很多不便，例如一个文本信息很难混合各种语言的文字。</p><br />
<br />
<p>因此，在上世纪80年代末，Xerox、Apple 等公司开始研究，是否能制定一套多语言的统一编码系统。后来，多个机构成立了 Unicode 联盟，在 1991 年释出 Unicode 1.0，收录了 24 种语言共 7161 个字符。在四分之一个世纪后的 2016年，Unicode 已释出 9.0 版本，收录 135 种语言共 128237 个字符。</p><br />
<br />
<p>这些字符被收录为统一字符集（Universal Coded Character Set, UCS），每个字符映射至一个整数码点（code point），码点的范围是 0 至 0x10FFFF，码点又通常记作 U+XXXX，当中 XXXX 为 16 进位数字。例如 劲 → U+52B2、峰 → U+5CF0。很明显，UCS 中的字符无法像 ASCII 般以一个字节存储。</p><br />
<br />
<p>因此，Unicode 还制定了各种储存码点的方式，这些方式称为 Unicode 转换格式（Uniform Transformation Format, UTF）。现时流行的 UTF 为 UTF-8、UTF-16 和 UTF-32。每种 UTF 会把一个码点储存为一至多个编码单元（code unit）。例如 UTF-8 的编码单元是 8 位的字节、UTF-16 为 16 位、UTF-32 为 32 位。除 UTF-32 外，UTF-8 和 UTF-16 都是可变长度编码。</p><br />
<br />
<p>UTF-8 成为现时互联网上最流行的格式，有几个原因：</p><br />
<br />
<p>它采用字节为编码单元，不会有字节序（endianness）的问题。<br />
每个 ASCII 字符只需一个字节去储存。<br />
如果程序原来是以字节方式储存字符，理论上不需要特别改动就能处理 UTF-8 的数据。</p><br />
<ol><br />
  <li>需求<br />
由于 UTF-8 的普及性，大部分的 JSON 也通常会以 UTF-8 存储。我们的 JSON 库也会只支持 UTF-8。（RapidJSON 同时支持 UTF-8、UTF-16LE/BE、UTF-32LE/BE、ASCII。）</li><br />
</ol><br />
<br />
<p>C 标准库没有关于 Unicode 的处理功能（C++11 有），我们会实现 JSON 库所需的字符编码处理功能。</p><br />
<br />
<p>对于非转义（unescaped）的字符，只要它们不少于 32（0 ~ 31 是不合法的编码单元），我们可以直接复制至结果，这一点我们稍后再说明。我们假设输入是以合法 UTF-8 编码。</p><br />
<br />
<p>而对于 JSON字符串中的 \uXXXX 是以 16 进制表示码点 U+0000 至 U+FFFF，我们需要：</p><br />
<br />
<p>解析 4 位十六进制整数为码点；<br />
由于字符串是以 UTF-8 存储，我们要把这个码点编码成 UTF-8。<br />
同学可能会发现，4 位的 16 进制数字只能表示 0 至 0xFFFF，但之前我们说 UCS 的码点是从 0 至 0x10FFFF，那怎么能表示多出来的码点？</p><br />
<br />
<p>其实，U+0000 至 U+FFFF 这组 Unicode 字符称为基本多文种平面（basic multilingual plane, BMP），还有另外 16 个平面。那么 BMP 以外的字符，JSON 会使用代理对（surrogate pair）表示 \uXXXX\uYYYY。在 BMP 中，保留了 2048 个代理码点。如果第一个码点是 U+D800 至 U+DBFF，我们便知道它的代码对的高代理项（high surrogate），之后应该伴随一个 U+DC00 至 U+DFFF 的低代理项（low surrogate）。然后，我们用下列公式把代理对 (H, L) 变换成真实的码点：</p><br />
<br />
<p>codepoint = 0x10000 + (H − 0xD800) × 0x400 + (L − 0xDC00)<br />
举个例子，高音谱号字符 ? → U+1D11E 不是 BMP 之内的字符。在 JSON 中可写成转义序列 \uD834\uDD1E，我们解析第一个 \uD834 得到码点 U+D834，我们发现它是 U+D800 至 U+DBFF 内的码点，所以它是高代理项。然后我们解析下一个转义序列 \uDD1E 得到码点 U+DD1E，它在 U+DC00 至 U+DFFF 之内，是合法的低代理项。我们计算其码点：</p><br />
<br />
<p>H = 0xD834, L = 0xDD1E<br />
codepoint = 0x10000 + (H − 0xD800) × 0x400 + (L − 0xDC00)<br />
          = 0x10000 + (0xD834 - 0xD800) × 0x400 + (0xDD1E − 0xDC00)<br />
          = 0x10000 + 0x34 × 0x400 + 0x11E<br />
          = 0x10000 + 0xD000 + 0x11E<br />
          = 0x1D11E<br />
这样就得出这转义序列的码点，然后我们再把它编码成 UTF-8。如果只有高代理项而欠缺低代理项，或是低代理项不在合法码点范围，我们都返回 LEPT_PARSE_INVALID_UNICODE_SURROGATE 错误。如果 \u 后不是 4 位十六进位数字，则返回LEPT_PARSE_INVALID_UNICODE_HEX 错误。</p><br />
<br />
<ol><br />
  <li>UTF-8 编码<br />
UTF-8 在网页上的使用率势无可挡：</li><br />
</ol><br />
<br />
<p>（图片来自 Wikipedia Common，数据来自 Google 对网页字符编码的统计。）</p><br />
<br />
<p>由于我们的 JSON 库也只支持 UTF-8，我们需要把码点编码成 UTF-8。这里简单介绍一下 UTF-8 的编码方式。</p><br />
<br />
<p>UTF-8 的编码单元是 8 位字节，每个码点编码成 1 至 4 个字节。它的编码方式很简单，按照码点的范围，把码点的二进位分拆成 1 至最多 4 个字节：</p><br />
<br />
<p>这个编码方法的好处之一是，码点范围 U+0000 ~ U+007F 编码为一个字节，与 ASCII 编码兼容。这范围的 Unicode 码点也是和 ASCII 字符相同的。因此，一个 ASCII 文本也是一个 UTF-8 文本。</p><br />
<br />
<p>我们举一个例子解析多字节的情况，欧元符号 € → U+20AC：</p><br />
<br />
<p>U+20AC 在 U+0800 ~ U+FFFF 的范围内，应编码成 3 个字节。<br />
U+20AC 的二进位为 10000010101100<br />
3 个字节的情况我们要 16 位的码点，所以在前面补两个 0，成为 0010000010101100<br />
按上表把二进位分成 3 组：0010, 000010, 101100<br />
加上每个字节的前缀：11100010, 10000010, 10101100<br />
用十六进位表示即：0xE2, 0x82, 0xAC<br />
对于这例子的范围，对应的 C 代码是这样的：</p><br />
<br />
<p>if (u &gt;= 0x0800 &amp;&amp; u &lt;= 0xFFFF) {<br />
    OutputByte(0xE0 | ((u » 12) &amp; 0xFF)); /* 0xE0 = 11100000 <em>/<br />
    OutputByte(0x80 | ((u »  6) &amp; 0x3F)); /</em> 0x80 = 10000000 <em>/<br />
    OutputByte(0x80 | ( u        &amp; 0x3F)); /</em> 0x3F = 00111111 */<br />
}<br />
UTF-8 的解码稍复杂一点，但我们的 JSON 库不会校验 JSON 文本是否符合 UTF-8，所以这里也不展开了。</p><br />
<br />
<ol><br />
  <li>实现 \uXXXX 解析<br />
我们只需要在其它转义符的处理中加入对 \uXXXX 的处理：</li><br />
</ol><br />
<br />
<p>static int lept_parse_string(lept_context* c, lept_value* v) {<br />
    unsigned u;<br />
    /* … <em>/<br />
    for (;;) {<br />
        char ch = *p++;<br />
        switch (ch) {<br />
            /</em> … <em>/<br />
            case ‘\’:<br />
                switch (</em>p++) {<br />
                    /* … <em>/<br />
                    case ‘u’:<br />
                        if (!(p = lept_parse_hex4(p, &amp;u)))<br />
                            STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_HEX);<br />
                        /</em> \TODO surrogate handling <em>/<br />
                        lept_encode_utf8(c, u);<br />
                        break;<br />
                    /</em> … <em>/<br />
                }<br />
            /</em> … */<br />
        }<br />
    }<br />
}<br />
上面代码的过程很简单，遇到 \u 转义时，调用 lept_parse_hex4() 解析 4 位十六进数字，存储为码点 u。这个函数在成功时返回解析后的文本指针，失败返回 NULL。如果失败，就返回 LEPT_PARSE_INVALID_UNICODE_HEX 错误。最后，把码点编码成 UTF-8，写进缓冲区。这里没有处理代理对，留作练习。</p><br />
<br />
<p>顺带一提，我为 lept_parse_string() 做了个简单的重构，把返回错误码的处理抽取为宏：</p><br />
<br />
<p>#define STRING_ERROR(ret) do { c-&gt;top = head; return ret; } while(0)</p><br />
<ol><br />
  <li>总结与练习<br />
本单元介绍了 Unicode 的基本知识，同学应该了解到一些常用的 Unicode 术语，如码点、编码单元、UTF-8、代理对等。这次的练习代码只有个空壳，要由同学填充。完成后应该能通过所有单元测试，届时我们的 JSON 字符串解析就完全符合标准了。</li><br />
</ol><br />
<br />
<p>实现 lept_parse_hex4()，不合法的十六进位数返回 LEPT_PARSE_INVALID_UNICODE_HEX。<br />
按第 3 节谈到的 UTF-8 编码原理，实现 lept_encode_utf8()。这函数假设码点在正确范围 U+0000 ~ U+10FFFF（用断言检测）。<br />
加入对代理对的处理，不正确的代理对范围要返回 LEPT_PARSE_INVALID_UNICODE_SURROGATE 错误。<br />
如果你遇到问题，有不理解的地方，或是有建议，都欢迎在评论或 issue 中提出，让所有人一起讨论</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/22784011</p><br />
<br />
<ol><br />
  <li>实现 lept_parse_hex4()<br />
这个函数只是读 4 位 16 进制数字，可以简单地自行实现：</li><br />
</ol><br />
<br />
<p>static const char* lept_parse_hex4(const char* p, unsigned* u) {<br />
    int i;<br />
    *u = 0;<br />
    for (i = 0; i &lt; 4; i++) {<br />
        char ch = *p++;<br />
        *u «= 4;<br />
        if      (ch &gt;= ‘0’ &amp;&amp; ch &lt;= ‘9’)  *u |= ch - ‘0’;<br />
        else if (ch &gt;= ‘A’ &amp;&amp; ch &lt;= ‘F’)  *u |= ch - (‘A’ - 10);<br />
        else if (ch &gt;= ‘a’ &amp;&amp; ch &lt;= ‘f’)  *u |= ch - (‘a’ - 10);<br />
        else return NULL;<br />
    }<br />
    return p;<br />
}<br />
可能有同学想到用标准库的 strtol()，因为它也能解析 16 进制数字，那么可以简短的写成：</p><br />
<br />
<p>static const char* lept_parse_hex4(const char* p, unsigned* u) {<br />
    char* end;<br />
    <em>u = (unsigned)strtol(p, &amp;end, 16);<br />
    return end == p + 4 ? end : NULL;<br />
}<br />
但这个实现会错误地接受 “\u 123” 这种不合法的 JSON，因为 strtol() 会跳过开始的空白。要解决的话，还需要检测第一个字符是否 [0-9A-Fa-f]，或者 !isspace(</em>p)。但为了 strtol() 做多余的检测，而且自行实现也很简单，我个人会选择首个方案。（前两个单元用 strtod() 就没辨法，因为它的实现要复杂得多。）</p><br />
<br />
<ol><br />
  <li>实现 lept_encode_utf8()<br />
这个函数只需要根据那个 UTF-8 编码表就可以实现：</li><br />
</ol><br />
<br />
<p>static void lept_encode_utf8(lept_context* c, unsigned u) {<br />
    if (u &lt;= 0x7F) <br />
        PUTC(c, u &amp; 0xFF);<br />
    else if (u &lt;= 0x7FF) {<br />
        PUTC(c, 0xC0 | ((u » 6) &amp; 0xFF));<br />
        PUTC(c, 0x80 | ( u       &amp; 0x3F));<br />
    }<br />
    else if (u &lt;= 0xFFFF) {<br />
        PUTC(c, 0xE0 | ((u » 12) &amp; 0xFF));<br />
        PUTC(c, 0x80 | ((u »  6) &amp; 0x3F));<br />
        PUTC(c, 0x80 | ( u        &amp; 0x3F));<br />
    }<br />
    else {<br />
        assert(u &lt;= 0x10FFFF);<br />
        PUTC(c, 0xF0 | ((u » 18) &amp; 0xFF));<br />
        PUTC(c, 0x80 | ((u » 12) &amp; 0x3F));<br />
        PUTC(c, 0x80 | ((u »  6) &amp; 0x3F));<br />
        PUTC(c, 0x80 | ( u        &amp; 0x3F));<br />
    }<br />
}<br />
有同学可能觉得奇怪，最终也是写进一个 char，为什么要做 x &amp; 0xFF 这种操作呢？这是因为 u 是 unsigned 类型，一些编译器可能会警告这个转型可能会截断数据。但实际上，配合了范围的检测然后右移之后，可以保证写入的是 0~255 内的值。为了避免一些编译器的警告误判，我们加上 x &amp; 0xFF。一般来说，编译器在优化之后，这与操作是会被消去的，不会影响性能。</p><br />
<br />
<p>其实超过 1 个字符输出时，可以只调用 1 次 lept_context_push()。这里全用 PUTC() 只是为了代码看上去简单一点。</p><br />
<br />
<ol><br />
  <li>代理对的处理<br />
遇到高代理项，就需要把低代理项 \uxxxx 也解析进来，然后用这两个项去计算出码点：</li><br />
</ol><br />
<br />
<p>case ‘u’:<br />
    if (!(p = lept_parse_hex4(p, &amp;u)))<br />
        STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_HEX);<br />
    if (u &gt;= 0xD800 &amp;&amp; u &lt;= 0xDBFF) { /* surrogate pair <em>/<br />
        if (</em>p++ != ‘\’)<br />
            STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_SURROGATE);<br />
        if (*p++ != ‘u’)<br />
            STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_SURROGATE);<br />
        if (!(p = lept_parse_hex4(p, &amp;u2)))<br />
            STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_HEX);<br />
        if (u2 &lt; 0xDC00 || u2 &gt; 0xDFFF)<br />
            STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_SURROGATE);<br />
        u = (((u - 0xD800) « 10) | (u2 - 0xDC00)) + 0x10000;<br />
    }<br />
    lept_encode_utf8(c, u);<br />
    break;</p><br />
<ol><br />
  <li>总结<br />
JSON 的字符串解析终于完成了。但更重要的是，同学通过教程和练习后，应该对于 Unicode 和 UTF-8 编码有基本了解。使用 Unicode 标准去处理文本数据已是世界潮流。虽然 C11/C++11 引入了 Unicode 字符串字面量及少量函数，但仍然有很多不足，一般需要借助第三方库。</li><br />
</ol><br />
<br />
<p>我们在稍后的单元还要处理生成时的 Unicode 问题，接下来我们要继续讨论数组和对象的解析。</p><br />
<br />
<p>如果你遇到问题，有不理解的地方，或是有建议，都欢迎在评论或 issue 中提出，让所有人一起讨论。</p><br />
<br />
<p>解析数组<br />
https://zhuanlan.zhihu.com/p/22804068<br />
JSON 数组<br />
数据结构<br />
解析过程<br />
实现<br />
总结与练习</p><br />
<ol><br />
  <li>JSON 数组<br />
从零到这第五单元，我们终于要解析一个 JSON 的复合数据类型了。一个 JSON 数组可以包含零至多个元素，而这些元素也可以是数组类型。换句话说，我们可以表示嵌套（nested）的数据结构。先来看看 JSON 数组的语法：</li><br />
</ol><br />
<br />
<p>array = %x5B ws [ value *( ws %x2C ws value ) ] ws %x5D<br />
当中，%x5B 是左中括号 [，%x2C 是逗号 ,，%x5D 是右中括号 ] ，ws 是空白字符。一个数组可以包含零至多个值，以逗号分隔，例如 []、[1,2,true]、[[1,2],[3,4],”abc”] 都是合法的数组。但注意 JSON 不接受末端额外的逗号，例如 [1,2,] 是不合法的（许多编程语言如 C/C++、Javascript、Java、C# 都容许数组初始值包含末端逗号）。</p><br />
<br />
<p>JSON 数组的语法很简单，实现的难点不在语法上，而是怎样管理内存。</p><br />
<br />
<ol><br />
  <li>数据结构</li><br />
</ol><br />
<br />
<p>首先，我们需要设计存储 JSON 数组类型的数据结构。</p><br />
<br />
<p>JSON 数组存储零至多个元素，最简单就是使用 C 语言的数组。数组最大的好处是能以 [公式] 用索引访问任意元素，次要好处是内存布局紧凑，省内存之余还有高缓存一致性（cache coherence）。但数组的缺点是不能快速插入元素，而且我们在解析 JSON 数组的时候，还不知道应该分配多大的数组才合适。</p><br />
<br />
<p>另一个选择是链表（linked list），它的最大优点是可快速地插入元素（开端、末端或中间），但需要以 [公式] 时间去经索引取得内容。如果我们只需顺序遍历，那么是没有问题的。还有一个小缺点，就是相对数组而言，链表在存储每个元素时有额外内存开销（存储下一节点的指针），而且遍历时元素所在的内存可能不连续，令缓存不命中（cache miss）的机会上升。</p><br />
<br />
<p>我见过一些 JSON 库选择了链表，而这里则选择了数组。我们将会通过之前在解析字符串时实现的堆栈，来解决解析 JSON 数组时未知数组大小的问题。</p><br />
<br />
<p>决定之后，我们在 lept_value 的 union 中加入数组的结构：</p><br />
<br />
<p>typedef struct lept_value lept_value;</p><br />
<br />
<p>struct lept_value {<br />
    union {<br />
        struct { lept_value* e; size_t size; }a; /* array <em>/<br />
        struct { char</em> s; size_t len; }s;<br />
        double n;<br />
    }u;<br />
    lept_type type;<br />
};<br />
由于 lept_value 内使用了自身类型的指针，我们必须前向声明（forward declare）此类型。</p><br />
<br />
<p>另外，注意这里 size 是元素的个数，不是字节单位。我们增加两个 API 去访问 JSON 数组类型的值：</p><br />
<br />
<p>size_t lept_get_array_size(const lept_value* v) {<br />
    assert(v != NULL &amp;&amp; v-&gt;type == LEPT_ARRAY);<br />
    return v-&gt;u.a.size;<br />
}</p><br />
<br />
<p>lept_value* lept_get_array_element(const lept_value* v, size_t index) {<br />
    assert(v != NULL &amp;&amp; v-&gt;type == LEPT_ARRAY);<br />
    assert(index &lt; v-&gt;u.a.size);<br />
    return &amp;v-&gt;u.a.e[index];<br />
}<br />
暂时我们不考虑增删数组元素，这些功能留待第八单元讨论。</p><br />
<br />
<p>然后，我们写一个单元测试去试用这些 API（练习需要更多测试）。</p><br />
<br />
<p>#if defined(_MSC_VER)<br />
#define EXPECT_EQ_SIZE_T(expect, actual) EXPECT_EQ_BASE((expect) == (actual), (size_t)expect, (size_t)actual, “%Iu”)<br />
#else<br />
#define EXPECT_EQ_SIZE_T(expect, actual) EXPECT_EQ_BASE((expect) == (actual), (size_t)expect, (size_t)actual, “%zu”)<br />
#endif</p><br />
<br />
<p>static void test_parse_array() {<br />
    lept_value v;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lept_init(&amp;v);<br />
EXPECT_EQ_INT(LEPT_PARSE_OK, lept_parse(&amp;v, "[ ]"));<br />
EXPECT_EQ_INT(LEPT_ARRAY, lept_get_type(&amp;v));<br />
EXPECT_EQ_SIZE_T(0, lept_get_array_size(&amp;v));<br />
lept_free(&amp;v); } 在之前的单元中，作者已多次重申，C 语言的数组大小应该使用 size_t 类型。因为我们要验证 lept_get_array_size() 返回值是否正确，所以再为单元测试框架添加一个宏 EXPECT_EQ_SIZE_T。麻烦之处在于，ANSI C（C89）并没有的 size_t打印方法，在 C99 则加入了 "%zu"，但 VS2015 中才有，之前的 VC 版本使用非标准的 "%Iu"。因此，上面的代码使用条件编译去区分 VC 和其他编译器。虽然这部分不跨平台也不是 ANSI C 标准，但它只在测试程序中，不太影响程序库的跨平台性。<br />
</code></pre></div></div><br />
<br />
<ol><br />
  <li>解析过程<br />
我们在解析 JSON 字符串时，因为在开始时不能知道字符串的长度，而又需要进行转义，所以需要一个临时缓冲区去存储解析后的结果。我们为此实现了一个动态增长的堆栈，可以不断压入字符，最后一次性把整个字符串弹出，复制至新分配的内存之中。</li><br />
</ol><br />
<br />
<p>对于 JSON 数组，我们也可以用相同的方法，而且，我们可以用同一个堆栈！我们只需要把每个解析好的元素压入堆栈，解析到数组结束时，再一次性把所有元素弹出，复制至新分配的内存之中。</p><br />
<br />
<p>但和字符串有点不一样，如果把 JSON 当作一棵树的数据结构，JSON 字符串是叶节点，而 JSON 数组是中间节点。在叶节点的解析函数中，我们怎样使用那个堆栈也可以，只要最后还原就好了。但对于数组这样的中间节点，共用这个堆栈没问题么？</p><br />
<br />
<p>答案是：只要在解析函数结束时还原堆栈的状态，就没有问题。为了直观地了解这个解析过程，我们用连环图去展示 [“abc”,[1,2],3] 的解析过程。</p><br />
<br />
<p>首先，我们遇到 [，进入 lept_parse_array()：</p><br />
<br />
<p>生成一个临时的 lept_value，用于存储之后的元素。我们再调用 lept_parse_value() 去解析这个元素值，因为遇到 “ 进入 lept_parse_string()：</p><br />
<br />
<p>在 lept_parse_string() 中，不断解析字符直至遇到 “，过程中把每个字符压栈：</p><br />
<br />
<p>最后在 lept_parse_string() 中，把栈上 3 个字符弹出，分配内存，生成字符串值：</p><br />
<br />
<p>返回上一层 lept_parse_array()，把临时元素压栈：</p><br />
<br />
<p>然后我们再遇到 [，进入另一个 lept_parse_array()。它发现第一个元素是数字类型，所认调用 lept_parse_number()，生成一个临时的元素值：</p><br />
<br />
<p>之后把该临时的元素值压栈：</p><br />
<br />
<p>接着再解析第二个元素。我们遇到了 ]，从栈上弹出 2 个元素，分配内存，生成数组（虚线代表是连续的内存）：</p><br />
<br />
<p>那个数组是上层数组的元素，我们把它压栈。现时栈内已有两个元素，我们再继续解析下一个元素：</p><br />
<br />
<p>最后，遇到了 ]，可以弹出栈内 3 个元素，分配内存，生成数组：</p><br />
<br />
<ol><br />
  <li>实现<br />
经过这个详细的图解，实现 lept_parse_array() 应该没有难度。以下是半制成品：</li><br />
</ol><br />
<br />
<p>static int lept_parse_value(lept_context* c, lept_value* v);/<em>前向声明</em>/</p><br />
<br />
<p>static int lept_parse_array(lept_context* c, lept_value* v) {<br />
    size_t size = 0;<br />
    int ret;<br />
    EXPECT(c, ‘[’);<br />
    if (<em>c-&gt;json == ‘]’) {<br />
        c-&gt;json++;<br />
        v-&gt;type = LEPT_ARRAY;<br />
        v-&gt;u.a.size = 0;<br />
        v-&gt;u.a.e = NULL;<br />
        return LEPT_PARSE_OK;<br />
    }<br />
    for (;;) {<br />
        lept_value e;<br />
        lept_init(&amp;e);<br />
        if ((ret = lept_parse_value(c, &amp;e)) != LEPT_PARSE_OK)<br />
            return ret;<br />
        memcpy(lept_context_push(c, sizeof(lept_value)), &amp;e, sizeof(lept_value));<br />
        size++;<br />
        if (</em>c-&gt;json == ‘,’)<br />
            c-&gt;json++;<br />
        else if (<em>c-&gt;json == ‘]’) {<br />
            c-&gt;json++;<br />
            v-&gt;type = LEPT_ARRAY;<br />
            v-&gt;u.a.size = size;<br />
            size *= sizeof(lept_value);<br />
            memcpy(v-&gt;u.a.e = (lept_value</em>)malloc(size), lept_context_pop(c, size), size);<br />
            return LEPT_PARSE_OK;<br />
        }<br />
        else<br />
            return LEPT_PARSE_MISS_COMMA_OR_SQUARE_BRACKET;<br />
    }<br />
}</p><br />
<br />
<p>static int lept_parse_value(lept_context* c, lept_value* v) {<br />
    switch (<em>c-&gt;json) {<br />
        /</em> … */<br />
        case ‘[’:  return lept_parse_array(c, v);<br />
    }<br />
}<br />
简单说明的话，就是在循环中建立一个临时值（lept_value e），然后调用 lept_parse_value() 去把元素解析至这个临时值，完成后把临时值压栈。当遇到 ]，把栈内的元素弹出，分配内存，生成数组值。</p><br />
<br />
<p>注意到，lept_parse_value() 会调用 lept_parse_array()，而 lept_parse_array() 又会调用 lept_parse_value()，这是互相引用，所以必须要加入函数前向声明。</p><br />
<br />
<p>最后，我想告诉同学，实现这个函数时，我曾经制造一个不明显的 bug。这个函数有两个 memcpy()，第一个「似乎」是可以避免的，先压栈取得元素的指针，给 lept_parse_value：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for (;;) {<br />
    /* bug! */<br />
    lept_value* e = lept_context_push(c, sizeof(lept_value));<br />
    lept_init(e);<br />
    size++;<br />
    if ((ret = lept_parse_value(c, e)) != LEPT_PARSE_OK)<br />
        return ret;<br />
    /* ... */<br />
} 这种写法为什么会有 bug？这是第 5 条练习题。<br />
</code></pre></div></div><br />
<br />
<ol><br />
  <li>总结与练习<br />
编写 test_parse_array() 单元测试，解析以下 2 个 JSON。由于数组是复合的类型，不能使用一个宏去测试结果，请使用各个 API 检查解析后的内容。<br />
[ null , false , true , 123 , “abc” ]<br />
[ [ ] , [ 0 ] , [ 0 , 1 ] , [ 0 , 1 , 2 ] ]<br />
现时的测试结果应该是失败的，因为 lept_parse_array() 里没有处理空白字符，加进合适的lept_parse_whitespace() 令测试通过。<br />
使用第三单元解答篇介绍的检测内存泄漏工具，会发现测试中有内存泄漏。很明显在 lept_parse_array() 中使用到malloc() 分配内存，但却没有对应的 free()。应该在哪里释放内存？修改代码，使工具不再检测到相关的内存泄漏。</li><br />
</ol><br />
<br />
<p>开启 test.c 中两处被 #if 0 … #endif 关闭的测试，本来 test_parse_array() 已经能处理这些测试。然而，运行时会发现 Assertion failed: (c.top == 0) 断言失败。这是由于，当错误发生时，仍然有一些临时值在堆栈里，既没有放进数组，也没有被释放。修改 test_parse_array()，当遇到错误时，从堆栈中弹出并释放那些临时值，然后才返回错误码。</p><br />
<br />
<p>第 4 节那段代码为什么会有 bug？</p><br />
<br />
<p>如果你遇到问题，有不理解的地方，或是有建议，都欢迎在评论或 issue 中提出，让所有人一起讨论。</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/22924642</p><br />
<ol><br />
  <li>编写 test_parse_array() 单元测试<br />
这个练习纯粹为了熟习数组的访问 API。新增的第一个 JSON 只需平凡的检测。第二个 JSON 有特定模式，第 i 个子数组的长度为 i，每个子数组的第 j 个元素是数字值 j，所以可用两层 for 循环测试。</li><br />
</ol><br />
<br />
<p>static void test_parse_array() {<br />
    size_t i, j;<br />
    lept_value v;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* ... */<br />
<br />
lept_init(&amp;v);<br />
EXPECT_EQ_INT(LEPT_PARSE_OK, lept_parse(&amp;v, "[ null , false , true , 123 , \"abc\" ]"));<br />
EXPECT_EQ_INT(LEPT_ARRAY, lept_get_type(&amp;v));<br />
EXPECT_EQ_SIZE_T(5, lept_get_array_size(&amp;v));<br />
EXPECT_EQ_INT(LEPT_NULL,   lept_get_type(lept_get_array_element(&amp;v, 0)));<br />
EXPECT_EQ_INT(LEPT_FALSE,  lept_get_type(lept_get_array_element(&amp;v, 1)));<br />
EXPECT_EQ_INT(LEPT_TRUE,   lept_get_type(lept_get_array_element(&amp;v, 2)));<br />
EXPECT_EQ_INT(LEPT_NUMBER, lept_get_type(lept_get_array_element(&amp;v, 3)));<br />
EXPECT_EQ_INT(LEPT_STRING, lept_get_type(lept_get_array_element(&amp;v, 4)));<br />
EXPECT_EQ_DOUBLE(123.0, lept_get_number(lept_get_array_element(&amp;v, 3)));<br />
EXPECT_EQ_STRING("abc", lept_get_string(lept_get_array_element(&amp;v, 4)), lept_get_string_length(lept_get_array_element(&amp;v, 4)));<br />
lept_free(&amp;v);<br />
<br />
lept_init(&amp;v);<br />
EXPECT_EQ_INT(LEPT_PARSE_OK, lept_parse(&amp;v, "[ [ ] , [ 0 ] , [ 0 , 1 ] , [ 0 , 1 , 2 ] ]"));<br />
EXPECT_EQ_INT(LEPT_ARRAY, lept_get_type(&amp;v));<br />
EXPECT_EQ_SIZE_T(4, lept_get_array_size(&amp;v));<br />
for (i = 0; i &lt; 4; i++) {<br />
    lept_value* a = lept_get_array_element(&amp;v, i);<br />
    EXPECT_EQ_INT(LEPT_ARRAY, lept_get_type(a));<br />
    EXPECT_EQ_SIZE_T(i, lept_get_array_size(a));<br />
    for (j = 0; j &lt; i; j++) {<br />
        lept_value* e = lept_get_array_element(a, j);<br />
        EXPECT_EQ_INT(LEPT_NUMBER, lept_get_type(e));<br />
        EXPECT_EQ_DOUBLE((double)j, lept_get_number(e));<br />
    }<br />
}<br />
lept_free(&amp;v); } 2. 解析空白字符 按现时的 lept_parse_array() 的编写方式，需要加入 3 个 lept_parse_whitespace() 调用，分别是解析 [ 之后，元素之后，以及 , 之后：<br />
</code></pre></div></div><br />
<br />
<p>static int lept_parse_array(lept_context* c, lept_value* v) {<br />
    /* … <em>/<br />
    EXPECT(c, ‘[’);<br />
    lept_parse_whitespace(c);<br />
    /</em> … <em>/<br />
    for (;;) {<br />
        /</em> … <em>/<br />
        if ((ret = lept_parse_value(c, &amp;e)) != LEPT_PARSE_OK)<br />
            return ret;<br />
        /</em> … <em>/<br />
        lept_parse_whitespace(c);<br />
        if (</em>c-&gt;json == ‘,’) {<br />
            c-&gt;json++;<br />
            lept_parse_whitespace(c);<br />
        }<br />
        /* … */<br />
    }<br />
}</p><br />
<ol><br />
  <li>内存泄漏<br />
成功测试那 3 个 JSON 后，使用内存泄漏检测工具会发现 lept_parse_array() 用 malloc()分配的内存没有被释放：</li><br />
</ol><br />
<br />
<p>==154== 124 (120 direct, 4 indirect) bytes in 1 blocks are definitely lost in loss record 2 of 4<br />
==154==    at 0x4C28C20: malloc (vg_replace_malloc.c:296)<br />
==154==    by 0x409D82: lept_parse_array (in /json-tutorial/tutorial05/build/leptjson_test)<br />
==154==    by 0x409E91: lept_parse_value (in /json-tutorial/tutorial05/build/leptjson_test)<br />
==154==    by 0x409F14: lept_parse (in /json-tutorial/tutorial05/build/leptjson_test)<br />
==154==    by 0x405261: test_parse_array (in /json-tutorial/tutorial05/build/leptjson_test)<br />
==154==    by 0x408C72: test_parse (in /json-tutorial/tutorial05/build/leptjson_test)<br />
==154==    by 0x40916A: main (in /json-tutorial/tutorial05/build/leptjson_test)<br />
==154== <br />
==154== 240 (96 direct, 144 indirect) bytes in 1 blocks are definitely lost in loss record 4 of 4<br />
==154==    at 0x4C28C20: malloc (vg_replace_malloc.c:296)<br />
==154==    by 0x409D82: lept_parse_array (in /json-tutorial/tutorial05/build/leptjson_test)<br />
==154==    by 0x409E91: lept_parse_value (in /json-tutorial/tutorial05/build/leptjson_test)<br />
==154==    by 0x409F14: lept_parse (in /json-tutorial/tutorial05/build/leptjson_test)<br />
==154==    by 0x40582C: test_parse_array (in /json-tutorial/tutorial05/build/leptjson_test)<br />
==154==    by 0x408C72: test_parse (in /json-tutorial/tutorial05/build/leptjson_test)<br />
==154==    by 0x40916A: main (in /json-tutorial/tutorial05/build/leptjson_test)<br />
很明显，有 malloc() 就要有对应的 free()。正确的释放位置应该放置在 lept_free()，当值被释放时，该值拥有的内存也在那里释放。之前字符串的释放也是放在这里：</p><br />
<br />
<p>void lept_free(lept_value* v) {<br />
    assert(v != NULL);<br />
    if (v-&gt;type == LEPT_STRING)<br />
        free(v-&gt;u.s.s);<br />
    v-&gt;type = LEPT_NULL;<br />
}<br />
但对于数组，我们应该先把数组内的元素通过递归调用 lept_free() 释放，然后才释放本身的 v-&gt;u.a.e：</p><br />
<br />
<p>void lept_free(lept_value* v) {<br />
    size_t i;<br />
    assert(v != NULL);<br />
    switch (v-&gt;type) {<br />
        case LEPT_STRING:<br />
            free(v-&gt;u.s.s);<br />
            break;<br />
        case LEPT_ARRAY:<br />
            for (i = 0; i &lt; v-&gt;u.a.size; i++)<br />
                lept_free(&amp;v-&gt;u.a.e[i]);<br />
            free(v-&gt;u.a.e);<br />
            break;<br />
        default: break;<br />
    }<br />
    v-&gt;type = LEPT_NULL;<br />
}<br />
修改之后，再运行内存泄漏检测工具，确保问题已被修正。</p><br />
<br />
<ol><br />
  <li>解析错误时的内存处理<br />
遇到解析错误时，我们可能在之前已压入了一些值在自定堆栈上。如果没有处理，最后会在 lept_parse() 中发现堆栈上还有一些值，做成断言失败。所以，遇到解析错误时，我们必须弹出并释放那些值。</li><br />
</ol><br />
<br />
<p>在 lept_parse_array 中，原本遇到解析失败时，会直接返回错误码。我们把它改为 break 离开循环，在循环结束后的地方用 lept_free() 释放从堆栈弹出的值，然后才返回错误码：</p><br />
<br />
<p>static int lept_parse_array(lept_context* c, lept_value* v) {<br />
    /* … <em>/<br />
    for (;;) {<br />
        /</em> … <em>/<br />
        if ((ret = lept_parse_value(c, &amp;e)) != LEPT_PARSE_OK)<br />
            break;<br />
        /</em> … <em>/<br />
        if (</em>c-&gt;json == ‘,’) {<br />
            /* … <em>/<br />
        }<br />
        else if (</em>c-&gt;json == ‘]’) {<br />
            /* … <em>/<br />
        }<br />
        else {<br />
            ret = LEPT_PARSE_MISS_COMMA_OR_SQUARE_BRACKET;<br />
            break;<br />
        }<br />
    }<br />
    /</em> Pop and free values on the stack <em>/<br />
    for (i = 0; i &lt; size; i++)<br />
        lept_free((lept_value</em>)lept_context_pop(c, sizeof(lept_value)));<br />
    return ret;<br />
}</p><br />
<ol><br />
  <li><br />
    <p>bug 的解释<br />
这个 bug 源于压栈时，会获得一个指针 e，指向从堆栈分配到的空间：</p><br />
<br />
    <p>for (;;) {<br />
     /* bug! <em>/<br />
     lept_value</em> e = lept_context_push(c, sizeof(lept_value));<br />
     lept_init(e);<br />
     size++;<br />
     if ((ret = lept_parse_value(c, e)) != LEPT_PARSE_OK)<br />
         return ret;<br />
     /* … */<br />
 }<br />
然后，我们把这个指针调用 lept_parse_value(c, e)，这里会出现问题，因为 lept_parse_value() 及之下的函数都需要调用 lept_context_push()，而 lept_context_push() 在发现栈满了的时候会用 realloc() 扩容。这时候，我们上层的e 就会失效，变成一个悬挂指针（dangling pointer），而且 lept_parse_value(c, e) 会通过这个指针写入解析结果，造成非法访问。</p><br />
  </li><br />
</ol><br />
<br />
<p>在使用 C++ 容器时，也会遇到类似的问题。从容器中取得的迭代器（iterator）后，如果改动容器内容，之前的迭代器会失效。这里的悬挂指针问题也是相同的。</p><br />
<br />
<p>但这种 bug 有时可能在简单测试中不能自动发现，因为问题只有堆栈满了才会出现。从测试的角度看，我们需要一些压力测试（stress test），测试更大更复杂的数据。但从编程的角度看，我们要谨慎考虑变量的生命周期，尽量从编程阶段避免出现问题。例如把 lept_context_push() 的 API 改为：</p><br />
<br />
<p>static void lept_context_push(<br />
    lept_context* c, const void* data, size_t size);<br />
这样就确把数据压入栈内，避免了返回指针的生命周期问题。但我们之后会发现，原来的 API 设计在一些情况会更方便一些，例如在把字符串值转化（stringify）为 JSON 时，我们可以预先在堆栈分配字符串所需的最大空间，而当时是未有数据填充进去的。</p><br />
<br />
<p>无论如何，我们编程时都要考虑清楚变量的生命周期，特别是指针的生命周期。</p><br />
<br />
<p>解析对象<br />
https://zhuanlan.zhihu.com/p/23288484<br />
JSON 对象<br />
数据结构<br />
重构字符串解析<br />
实现<br />
总结与练习<br />
（题图 Photo by Azrul Aziz）</p><br />
<br />
<ol><br />
  <li>JSON 对象<br />
此单元是本教程最后一个关于 JSON 解析器的部分。JSON 对象和 JSON 数组非常相似，区别包括 JSON 对象以花括号 {}（U+007B、U+007D）包裹表示，另外 JSON 对象由对象成员（member）组成，而 JSON 数组由 JSON 值组成。所谓对象成员，就是键值对，键必须为 JSON 字符串，然后值是任何 JSON 值，中间以冒号 :（U+003A）分隔。完整语法如下：</li><br />
</ol><br />
<br />
<p>member = string ws %x3A ws value<br />
object = %x7B ws [ member *( ws %x2C ws member ) ] ws %x7D</p><br />
<ol><br />
  <li>数据结构<br />
要表示键值对的集合，有很多数据结构可供选择，例如：</li><br />
</ol><br />
<br />
<p>动态数组（dynamic array）：可扩展容量的数组，如 C++ 的 std::vector。<br />
有序动态数组（sorted dynamic array）：和动态数组相同，但保证元素已排序，可用二分搜寻查询成员。<br />
平衡树（balanced tree）：平衡二叉树可有序地遍历成员，如红黑树和 C++ 的 std::map（std::multi_map 支持重复键）。<br />
哈希表（hash table）：通过哈希函数能实现平均 O(1) 查询，如 C++11 的 std::unordered_map（unordered_multimap 支持重复键）。<br />
设一个对象有 n 个成员，数据结构的容量是 m，n ⩽ m，那么一些常用操作的时间／空间复杂度如下：</p><br />
<br />
<p>在 ECMA-404 标准中，并没有规定对象中每个成员的键一定要唯一的，也没有规定是否需要维持成员的次序。</p><br />
<br />
<p>为了简单起见，我们的 leptjson 选择用动态数组的方案。我们将在单元八才加入动态功能，所以这单元中，每个对象仅仅是成员的数组。那么它跟上一单元的数组非常接近：</p><br />
<br />
<p>typedef struct lept_value lept_value;<br />
typedef struct lept_member lept_member;</p><br />
<br />
<p>struct lept_value {<br />
    union {<br />
        struct { lept_member* m; size_t size; }o;<br />
        struct { lept_value* e; size_t size; }a;<br />
        struct { char* s; size_t len; }s;<br />
        double n;<br />
    }u;<br />
    lept_type type;<br />
};</p><br />
<br />
<p>struct lept_member {<br />
    char* k; size_t klen;   /* member key string, key string length <em>/<br />
    lept_value v;           /</em> member value */<br />
};<br />
成员结构 lept_member 是一个 lept_value 加上键的字符串。如同 JSON 字符串的值，我们也需要同时保留字符串的长度，因为字符串本身可能包含空字符 \u0000。</p><br />
<br />
<p>在这单元中，我们仅添加了最基本的访问函数，用于撰写单元测试：</p><br />
<br />
<p>size_t lept_get_object_size(const lept_value* v);<br />
const char* lept_get_object_key(const lept_value* v, size_t index);<br />
size_t lept_get_object_key_length(const lept_value* v, size_t index);<br />
lept_value* lept_get_object_value(const lept_value* v, size_t index);<br />
在软件开发过程中，许多时候，选择合适的数据结构后已等于完成一半工作。没有完美的数据结构，所以最好考虑多一些应用的场合，看看时间／空间复杂度以至相关系数是否合适。</p><br />
<br />
<p>接下来，我们就可以着手实现。</p><br />
<br />
<ol><br />
  <li>重构字符串解析<br />
在软件工程中，代码重构（code refactoring）是指在不改变软件外在行为时，修改代码以改进结构。代码重构十分依赖于单元测试，因为我们是通过单元测试去维护代码的正确性。有了足够的单元测试，我们可以放胆去重构，尝试并评估不同的改进方式，找到合乎心意而且能通过单元测试的改动，我们才提交它。</li><br />
</ol><br />
<br />
<p>我们知道，成员的键也是一个 JSON 字符串，然而，我们不使用 lept_value 存储键，因为这样会浪费了当中 type 这个无用的字段。由于 lept_parse_string() 是直接地把解析的结果写进一个 lept_value，所以我们先用「提取方法（extract method，见下注）」的重构方式，把解析 JSON 字符串及写入 lept_value 分拆成两部分：</p><br />
<br />
<p>/* 解析 JSON 字符串，把结果写入 str 和 len <em>/<br />
/</em> str 指向 c-&gt;stack 中的元素，需要在 c-&gt;stack  <em>/<br />
static int lept_parse_string_raw(lept_context</em> c, char** str, size_t* len) {<br />
    /* \todo */<br />
}</p><br />
<br />
<p>static int lept_parse_string(lept_context* c, lept_value* v) {<br />
    int ret;<br />
    char* s;<br />
    size_t len;<br />
    if ((ret = lept_parse_string_raw(c, &amp;s, &amp;len)) == LEPT_PARSE_OK)<br />
        lept_set_string(v, s, len);<br />
    return ret;<br />
}<br />
这样的话，我们实现对象的解析时，就可以使用 lept_parse_string_raw()　来解析 JSON 字符串，然后把结果复制至 lept_member 的 k 和 klen 字段。</p><br />
<br />
<p>注：在 Fowler 的经典著作 [1] 中，把各种重构方式分门别类，每个方式都有详细的步骤说明。由于书中以 Java 为例子，所以方式的名称使用了 Java 的述语，例如方法（method）。在 C 语言中，「提取方法」其实应该称为「提取函数」。</p><br />
<br />
<p>[1] Fowler, Martin. Refactoring: improving the design of existing code. Pearson Education India, 2009. 中译本：熊节译，《重构——改善既有代码的设计》，人民邮电出版社，2010年。</p><br />
<br />
<ol><br />
  <li>实现<br />
解析对象与解析数组非常相似，所以我留空了几段作为练习。在解析数组时，我们把当前的元素以 lept_value 压入栈中，而在这里，我们则是以 lept_member 压入：</li><br />
</ol><br />
<br />
<p>static int lept_parse_object(lept_context* c, lept_value* v) {<br />
    size_t size;<br />
    lept_member m;<br />
    int ret;<br />
    EXPECT(c, ‘{‘);<br />
    lept_parse_whitespace(c);<br />
    if (<em>c-&gt;json == ‘}’) {<br />
        c-&gt;json++;<br />
        v-&gt;type = LEPT_OBJECT;<br />
        v-&gt;u.o.m = 0;<br />
        v-&gt;u.o.size = 0;<br />
        return LEPT_PARSE_OK;<br />
    }<br />
    m.k = NULL;<br />
    size = 0;<br />
    for (;;) {<br />
        lept_init(&amp;m.v);<br />
        /</em> \todo parse key to m.k, m.klen <em>/<br />
        /</em> \todo parse ws colon ws <em>/<br />
        /</em> parse value <em>/<br />
        if ((ret = lept_parse_value(c, &amp;m.v)) != LEPT_PARSE_OK)<br />
            break;<br />
        memcpy(lept_context_push(c, sizeof(lept_member)), &amp;m, sizeof(lept_member));<br />
        size++;<br />
        m.k = NULL; /</em> ownership is transferred to member on stack <em>/<br />
        /</em> \todo parse ws [comma | right-curly-brace] ws <em>/<br />
    }<br />
    /</em> \todo Pop and free members on the stack */<br />
    return ret;<br />
}<br />
要注意的是，我们要为 m.k 分配内存去存储键的字符串，若在整个对象解析时发生错误，也要记得释放栈中的 lept_member 的 k。</p><br />
<br />
<p>我们为解析对象定义了几个新的错误码：</p><br />
<br />
<p>enum {<br />
    /* … */<br />
    LEPT_PARSE_MISS_KEY,<br />
    LEPT_PARSE_MISS_COLON,<br />
    LEPT_PARSE_MISS_COMMA_OR_CURLY_BRACKET<br />
};<br />
在此不再赘述它们的意义了，可从以下的单元测试看到例子：</p><br />
<br />
<p>static void test_parse_miss_key() {<br />
    TEST_ERROR(LEPT_PARSE_MISS_KEY, “:1,”);<br />
    TEST_ERROR(LEPT_PARSE_MISS_KEY, “{"a":1,”);<br />
}</p><br />
<br />
<p>static void test_parse_miss_colon() {<br />
    TEST_ERROR(LEPT_PARSE_MISS_COLON, “{"a"}”);<br />
    TEST_ERROR(LEPT_PARSE_MISS_COLON, “{"a","b"}”);<br />
}</p><br />
<br />
<p>static void test_parse_miss_comma_or_curly_bracket() {<br />
    TEST_ERROR(LEPT_PARSE_MISS_COMMA_OR_CURLY_BRACKET, “{"a":1”);<br />
    TEST_ERROR(LEPT_PARSE_MISS_COMMA_OR_CURLY_BRACKET, “{"a":1]”);<br />
    TEST_ERROR(LEPT_PARSE_MISS_COMMA_OR_CURLY_BRACKET, “{"a":1 "b"”);<br />
    TEST_ERROR(LEPT_PARSE_MISS_COMMA_OR_CURLY_BRACKET, “{"a":{}”);<br />
}</p><br />
<ol><br />
  <li>总结与练习<br />
在本单元中，除了谈及 JSON 对象的语法、可选的数据结构、实现方式，我们也轻轻谈及了重构的概念。有赖于测试驱动开发（TDD），我们可以不断重塑软件的内部结构。</li><br />
</ol><br />
<br />
<p>完成这次练习之后，恭喜你，你已经完整地实现了一个符合标准的 JSON 解析器了。之后我们会完成更简单的生成器及其他访问功能。</p><br />
<br />
<p>由于对象和数组的相似性，此单元留空了较多实现部分作为练习：</p><br />
<br />
<p>依第 3 节所述，重构 lept_parse_string()。重构前运行单元测试，重构后确保单元测试仍保持通过。<br />
打开 test.c 中两个 #if 0，运行单元测试，证实单元测试不通过。然后实现 lept_parse_object() 中的 \todo 部分。验证实现能通过单元测试。<br />
使用工具检测内存泄漏，解决它们。</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/23681202<br />
解析对象解答篇</p><br />
<ol><br />
  <li>重构 lept_parse_string()<br />
这个「提取方法」重构练习很简单，只需要把原来调用 lept_set_string 的地方，改为写入参数变量。因此，原来的 lept_parse_string() 和 答案中的 lept_parse_string_raw() 的 diff 仅是两处：</li><br />
</ol><br />
<br />
<p>130,131c130,131<br />
&lt; static int lept_parse_string(lept_context* c, lept_value* v) {<br />
&lt;     size_t head = c-&gt;top, len;<br />
—</p><br />
<blockquote><br />
  <p>static int lept_parse_string_raw(lept_context* c, char** str, size_t* len) {<br />
    size_t head = c-&gt;top;<br />
140,141c140,141<br />
&lt;                 len = c-&gt;top - head;<br />
&lt;                 lept_set_string(v, (const char*)lept_context_pop(c, len), len);<br />
—<br />
                *len = c-&gt;top - head;<br />
                *str = lept_context_pop(c, *len);<br />
以 TDD 方式开发软件，因为有单元测试确保软件的正确性，面对新需求可以安心重构，改善软件架构。</p><br />
</blockquote><br />
<br />
<ol><br />
  <li>实现 lept_parse_object()<br />
有了 lept_parse_array() 的经验，实现 lept_parse_object() 几乎是一样的，分别只是每个迭代要多处理一个键和冒号。我们把这个实现过程分为 5 步曲。</li><br />
</ol><br />
<br />
<p>第 1 步是利用刚才重构出来的 lept_parse_string_raw() 去解析键的字符串。由于 lept_parse_string_raw() 假设第一个字符为 “，我们要先作校检，失败则要返回 LEPT_PARSE_MISS_KEY 错误。若字符串解析成功，它会把结果存储在我们的栈之中，需要把结果写入临时 lept_member 的 k 和 klen 字段中：</p><br />
<br />
<p>static int lept_parse_object(lept_context* c, lept_value* v) {<br />
    size_t i, size;<br />
    lept_member m;<br />
    int ret;<br />
    /* … <em>/<br />
    m.k = NULL;<br />
    size = 0;<br />
    for (;;) {<br />
        char</em> str;<br />
        lept_init(&amp;m.v);<br />
        /* 1. parse key <em>/<br />
        if (</em>c-&gt;json != ‘”’) {<br />
            ret = LEPT_PARSE_MISS_KEY;<br />
            break;<br />
        }<br />
        if ((ret = lept_parse_string_raw(c, &amp;str, &amp;m.klen)) != LEPT_PARSE_OK)<br />
            break;<br />
        memcpy(m.k = (char<em>)malloc(m.klen + 1), str, m.klen);<br />
        m.k[m.klen] = ‘\0’;<br />
        /</em> 2. parse ws colon ws <em>/<br />
        /</em> … <em>/<br />
    }<br />
    /</em> 5. Pop and free members on the stack <em>/<br />
    /</em> … */<br />
}<br />
第 2 步是解析冒号，冒号前后可有空白字符：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    /* 2. parse ws colon ws */<br />
    lept_parse_whitespace(c);<br />
    if (*c-&gt;json != ':') {<br />
        ret = LEPT_PARSE_MISS_COLON;<br />
        break;<br />
    }<br />
    c-&gt;json++;<br />
    lept_parse_whitespace(c); 第 3 步是解析任意的 JSON 值。这部分与解析数组一样，递归调用 lept_parse_value()，把结果写入临时 lept_member 的 v 字段，然后把整个 lept_member 压入栈：<br />
<br />
<br />
    /* 3. parse value */<br />
    if ((ret = lept_parse_value(c, &amp;m.v)) != LEPT_PARSE_OK)<br />
        break;<br />
    memcpy(lept_context_push(c, sizeof(lept_member)), &amp;m, sizeof(lept_member));<br />
    size++;<br />
    m.k = NULL; /* ownership is transferred to member on stack */ 但有一点要注意，如果之前缺乏冒号，或是这里解析值失败，在函数返回前我们要释放 m.k。如果我们成功地解析整个成员，那么就要把 m.k 设为空指针，其意义是说明该键的字符串的拥有权已转移至栈，之后如遇到错误，我们不会重覆释放栈里成员的键和这个临时成员的键。<br />
</code></pre></div></div><br />
<br />
<p>第 4 步，解析逗号或右花括号。遇上右花括号的话，当前的 JSON 对象就解析完结了，我们把栈上的成员复制至结果，并直接返回：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    /* 4. parse ws [comma | right-curly-brace] ws */<br />
    lept_parse_whitespace(c);<br />
    if (*c-&gt;json == ',') {<br />
        c-&gt;json++;<br />
        lept_parse_whitespace(c);<br />
    }<br />
    else if (*c-&gt;json == '}') {<br />
        size_t s = sizeof(lept_member) * size;<br />
        c-&gt;json++;<br />
        v-&gt;type = LEPT_OBJECT;<br />
        v-&gt;u.o.size = size;<br />
        memcpy(v-&gt;u.o.m = (lept_member*)malloc(s), lept_context_pop(c, s), s);<br />
        return LEPT_PARSE_OK;<br />
    }<br />
    else {<br />
        ret = LEPT_PARSE_MISS_COMMA_OR_CURLY_BRACKET;<br />
        break;<br />
    } 最后，当 for (;;) 中遇到任何错误便会到达这第 5 步，要释放临时的 key 字符串及栈上的成员：<br />
<br />
<br />
/* 5. Pop and free members on the stack */<br />
free(m.k);<br />
for (i = 0; i &lt; size; i++) {<br />
    lept_member* m = (lept_member*)lept_context_pop(c,<br />
        sizeof(lept_member));<br />
    free(m-&gt;k);<br />
    lept_free(&amp;m-&gt;v);<br />
}<br />
v-&gt;type = LEPT_NULL;<br />
return ret; 注意我们不需要先检查 m.k != NULL，因为 free(NULL) 是完全合法的。<br />
</code></pre></div></div><br />
<br />
<ol><br />
  <li>释放内存<br />
使用工具检测内存泄漏时，我们会发现以下这行代码造成内存泄漏：</li><br />
</ol><br />
<br />
<p>memcpy(v-&gt;u.o.m = (lept_member*)malloc(s), lept_context_pop(c, s), s);<br />
类似数组，我们也需要在 lept_free() 释放 JSON 对象的成员（包括键及值）：</p><br />
<br />
<p>void lept_free(lept_value* v) {<br />
    size_t i;<br />
    assert(v != NULL);<br />
    switch (v-&gt;type) {<br />
        /* … */<br />
        case LEPT_OBJECT:<br />
            for (i = 0; i &lt; v-&gt;u.o.size; i++) {<br />
                free(v-&gt;u.o.m[i].k);<br />
                lept_free(&amp;v-&gt;u.o.m[i].v);<br />
            }<br />
            free(v-&gt;u.o.m);<br />
            break;<br />
        default: break;<br />
    }<br />
    v-&gt;type = LEPT_NULL;<br />
}</p><br />
<ol><br />
  <li>总结<br />
至此，你已实现一个完整的 JSON 解析器，可解析任何合法的 JSON。统计一下，不计算空行及注释，现时 leptjson.c 只有 405 行代码，lept_json.h 54 行，test.c 309 行。</li><br />
</ol><br />
<br />
<p>另一方面，一些程序也需要生成 JSON。也许最初读者会以为生成 JSON 只需直接 sprintf()/fprintf() 就可以，但深入了解 JSON 的语法之后，我们应该知道 JSON 语法还是需做一些处理，例如字符串的转义、数字的格式等。然而，实现生成器还是要比解析器容易得多。而且，假设我们有一个正确的解析器，可以简单使用 roundtrip 方式实现测试。请期待下回分解。</p><br />
<br />
<p>如果你遇到问题，有不理解的地方，或是有建议，都欢迎在评论或 issue 中提出，让所有人一起讨论。</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/24466402</p><br />
<br />
<p>JSON 生成器<br />
再利用 lept_context 做动态数组<br />
生成 null、false 和 true<br />
生成数字<br />
总结与练习</p><br />
<br />
<ol><br />
  <li>JSON 生成器<br />
我们在前 6 个单元实现了一个合乎标准的 JSON 解析器，它把 JSON 文本解析成一个树形数据结构，整个结构以 lept_value 的节点组成。</li><br />
</ol><br />
<br />
<p>JSON 生成器（generator）负责相反的事情，就是把树形数据结构转换成 JSON 文本。这个过程又称为「字符串化（stringify）」。</p><br />
<br />
<ol><br />
  <li>JSON 生成器<br />
我们在前 6 个单元实现了一个合乎标准的 JSON 解析器，它把 JSON 文本解析成一个树形数据结构，整个结构以 lept_value 的节点组成。</li><br />
</ol><br />
<br />
<p>JSON 生成器（generator）负责相反的事情，就是把树形数据结构转换成 JSON 文本。这个过程又称为「字符串化（stringify）」。</p><br />
<br />
<p>相对于解析器，通常生成器更容易实现，而且生成器几乎不会造成运行时错误。因此，生成器的 API 设计为以下形式，直接返回 JSON 的字符串：</p><br />
<br />
<p>char* lept_stringify(const lept_value* v, size_t* length);<br />
length 参数是可选的，它会存储 JSON 的长度，传入 NULL 可忽略此参数。使用方需负责用 free() 释放内存。</p><br />
<br />
<p>为了简单起见，我们不做换行、缩进等美化（prettify）处理，因此它生成的 JSON 会是单行、无空白字符的最紧凑形式。</p><br />
<br />
<ol><br />
  <li>再利用 lept_context 做动态数组<br />
在实现 JSON 解析时，我们加入了一个动态变长的堆栈，用于存储临时的解析结果。而现在，我们也需要存储生成的结果，所以最简单是再利用该数据结构，作为输出缓冲区。</li><br />
</ol><br />
<br />
<p>#ifndef LEPT_PARSE_STRINGIFY_INIT_SIZE<br />
#define LEPT_PARSE_STRINGIFY_INIT_SIZE 256<br />
#endif</p><br />
<br />
<p>int lept_stringify(const lept_value* v, char** json, size_t* length) {<br />
    lept_context c;<br />
    int ret;<br />
    assert(v != NULL);<br />
    assert(json != NULL);<br />
    c.stack = (char*)malloc(c.size = LEPT_PARSE_STRINGIFY_INIT_SIZE);<br />
    c.top = 0;<br />
    if ((ret = lept_stringify_value(&amp;c, v)) != LEPT_STRINGIFY_OK) {<br />
        free(c.stack);<br />
        *json = NULL;<br />
        return ret;<br />
    }<br />
    if (length)<br />
        *length = c.top;<br />
    PUTC(&amp;c, ‘\0’);<br />
    *json = c.stack;<br />
    return LEPT_STRINGIFY_OK;<br />
}<br />
生成根节点的值之后，我需还需要加入一个空字符作结尾。</p><br />
<br />
<p>如前所述，此 API 还提供了 length 可选参数，当传入非空指针时，就能获得生成 JSON 的长度。或许读者会疑问，为什么需要获得长度，我们不是可以用 strlen() 获得么？是的，因为 JSON 不会含有空字符（若 JSON 字符串中含空字符，必须转义为 \u0000），用 strlen() 是没有问题的。但这样做会带来不必要的性能消耗，理想地是避免调用方有额外消耗。</p><br />
<br />
<ol><br />
  <li>生成 null、false 和 true<br />
接下来，我们生成最简单的 JSON 类型，就是 3 种 JSON 字面值。为贯彻 TDD，先写测试：</li><br />
</ol><br />
<br />
<p>#define TEST_ROUNDTRIP(json)<br /><br />
    do {<br /><br />
        lept_value v;<br /><br />
        char* json2;<br /><br />
        size_t length;<br /><br />
        lept_init(&amp;v);<br /><br />
        EXPECT_EQ_INT(LEPT_PARSE_OK, lept_parse(&amp;v, json));<br /><br />
        EXPECT_EQ_INT(LEPT_STRINGIFY_OK, lept_stringify(&amp;v, &amp;json2, &amp;length));<br /><br />
        EXPECT_EQ_STRING(json, json2, length);<br /><br />
        lept_free(&amp;v);<br /><br />
        free(json2);<br /><br />
    } while(0)</p><br />
<br />
<p>static void test_stringify() {<br />
    TEST_ROUNDTRIP(“null”);<br />
    TEST_ROUNDTRIP(“false”);<br />
    TEST_ROUNDTRIP(“true”);<br />
    /* … */<br />
}<br />
这里我们采用一个最简单的测试方式，把一个 JSON 解析，然后再生成另一 JSON，逐字符比较两个 JSON 是否一模一样。这种测试可称为往返（roundtrip）测试。但需要注意，同一个 JSON 的内容可以有多种不同的表示方式，例如可以插入不定数量的空白字符，数字 1.0 和 1 也是等价的。所以另一种测试方式，是比较两次解析的结果（lept_value 的树）是否相同，此功能将会在下一单元讲解。</p><br />
<br />
<p>然后，我们实现 lept_stringify_value，加入一个 PUTS() 宏去输出字符串：</p><br />
<br />
<p>#define PUTS(c, s, len)     memcpy(lept_context_push(c, len), s, len)</p><br />
<br />
<p>static int lept_stringify_value(lept_context* c, const lept_value* v) {<br />
    size_t i;<br />
    int ret;<br />
    switch (v-&gt;type) {<br />
        case LEPT_NULL:   PUTS(c, “null”,  4); break;<br />
        case LEPT_FALSE:  PUTS(c, “false”, 5); break;<br />
        case LEPT_TRUE:   PUTS(c, “true”,  4); break;<br />
        /* … */<br />
    }<br />
    return LEPT_STRINGIFY_OK;<br />
}</p><br />
<ol><br />
  <li>生成数字<br />
为了简单起见，我们使用 sprintf(“%.17g”, …) 来把浮点数转换成文本。”%.17g” 是足够把双精度浮点转换成可还原的文本。</li><br />
</ol><br />
<br />
<p>最简单的实现方式可能是这样的：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    case LEPT_NUMBER:<br />
        {<br />
            char buffer[32];<br />
            int length = sprintf(buffer, "%.17g", v-&gt;u.n);<br />
            PUTS(c, buffer, length);<br />
        }<br />
        break; 但这样需要在 PUTS() 中做一次 memcpy()，实际上我们可以避免这次复制，只需要生成的时候直接写进 c 里的推栈，然后再按实际长度调查 c-&gt;top：<br />
<br />
<br />
    case LEPT_NUMBER:<br />
        {<br />
            char* buffer = lept_context_push(c, 32);<br />
            int length = sprintf(buffer, "%.17g", v-&gt;u.n);<br />
            c-&gt;top -= 32 - length;<br />
        }<br />
        break; 因每个临时变量只用了一次，我们可以把代码压缩成一行：<br />
<br />
<br />
    case LEPT_NUMBER:<br />
        c-&gt;top -= 32 - sprintf(lept_context_push(c, 32), "%.17g", v-&gt;u.n);<br />
        break; 5. 总结与练习 我们在此单元中简介了 JSON 的生成功能和 leptjson 中的实现方式。<br />
</code></pre></div></div><br />
<br />
<p>leptjson 重复利用了 lept_context 中的数据结构作为输出缓冲，可以节省代码量。</p><br />
<br />
<p>生成通常比解析简单（一个例外是 RapidJSON 自行实现了浮点数至字符串的算法），余下的 3 种 JSON 类型就当作练习吧：</p><br />
<br />
<p>由于有两个地方需要生成字符串（JSON 字符串和对象类型），所以先实现 lept_stringify_string()。注意，字符串的语法比较复杂，一些字符必须转义，其他少于 0x20 的字符需要转义为 \u00xx 形式。</p><br />
<br />
<p>直接在 lept_stringify_value() 的 switch 内实现 JSON 数组和对象类型的生成。这些实现里都会递归调用 lept_stringify_value() 。</p><br />
<br />
<p>在你的 lept_stringify_string() 是否使用了多次 PUTC()？如果是，它每次输出一个字符时，都要检测缓冲区是否有足够空间（不够时需扩展）。能否优化这部分的性能？这种优化有什么代价么？</p><br />
<br />
<p>如果你遇到问题，有不理解的地方，或是有建议，都欢迎在评论或 issue 中提出，让所有人一起讨论。</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/24729153</p><br />
<ol><br />
  <li>生成字符串<br />
我们需要对一些字符进行转义，最简单的实现如下：</li><br />
</ol><br />
<br />
<p>static void lept_stringify_string(lept_context* c, const char* s, size_t len) {<br />
    size_t i;<br />
    assert(s != NULL);<br />
    PUTC(c, ‘”’);<br />
    for (i = 0; i &lt; len; i++) {<br />
        unsigned char ch = (unsigned char)s[i];<br />
        switch (ch) {<br />
            case ‘"’: PUTS(c, “\"”, 2); break;<br />
            case ‘\’: PUTS(c, “\\”, 2); break;<br />
            case ‘\b’: PUTS(c, “\b”,  2); break;<br />
            case ‘\f’: PUTS(c, “\f”,  2); break;<br />
            case ‘\n’: PUTS(c, “\n”,  2); break;<br />
            case ‘\r’: PUTS(c, “\r”,  2); break;<br />
            case ‘\t’: PUTS(c, “\t”,  2); break;<br />
            default:<br />
                if (ch &lt; 0x20) {<br />
                    char buffer[7];<br />
                    sprintf(buffer, “\u%04X”, ch);<br />
                    PUTS(c, buffer, 6);<br />
                }<br />
                else<br />
                    PUTC(c, s[i]);<br />
        }<br />
    }<br />
    PUTC(c, ‘”’);<br />
}</p><br />
<br />
<p>static void lept_stringify_value(lept_context* c, const lept_value* v) {<br />
    switch (v-&gt;type) {<br />
        /* … <em>/<br />
        case LEPT_STRING: lept_stringify_string(c, v-&gt;u.s.s, v-&gt;u.s.len); break;<br />
        /</em> … */<br />
    }<br />
}<br />
注意到，十六进位输出的字母可以用大写或小写，我们这里选择了大写，所以 roundstrip 测试时也用大写。但这个并不是必然的，输出小写（用 “\u%04x”）也可以。</p><br />
<br />
<ol><br />
  <li>生成数组和对象<br />
生成数组也是非常简单，只要输出 [ 和 ]，中间对逐个子值递归调用 lept_stringify_value()。只要注意在第一个元素后才加入 ,。而对象也仅是多了一个键和 :。</li><br />
</ol><br />
<br />
<p>static void lept_stringify_value(lept_context* c, const lept_value* v) {<br />
    size_t i;<br />
    switch (v-&gt;type) {<br />
        /* … <em>/<br />
        case LEPT_ARRAY:<br />
            PUTC(c, ‘[’);<br />
            for (i = 0; i &lt; v-&gt;u.a.size; i++) {<br />
                if (i &gt; 0)<br />
                    PUTC(c, ‘,’);<br />
                lept_stringify_value(c, &amp;v-&gt;u.a.e[i]);<br />
            }<br />
            PUTC(c, ‘]’);<br />
            break;<br />
        case LEPT_OBJECT:<br />
            PUTC(c, ‘{‘);<br />
            for (i = 0; i &lt; v-&gt;u.o.size; i++) {<br />
                if (i &gt; 0)<br />
                    PUTC(c, ‘,’);<br />
                lept_stringify_string(c, v-&gt;u.o.m[i].k, v-&gt;u.o.m[i].klen);<br />
                PUTC(c, ‘:’);<br />
                lept_stringify_value(c, &amp;v-&gt;u.o.m[i].v);<br />
            }<br />
            PUTC(c, ‘}’);<br />
            break;<br />
        /</em> … */<br />
    }<br />
}</p><br />
<ol><br />
  <li>优化 lept_stringify_string()<br />
最后，我们讨论一下优化。上面的 lept_stringify_string() 实现中，每次输出一个字符／字符串，都要调用 lept_context_push()。如果我们使用一些性能剖测工具，也可能会发现这个函数消耗较多 CPU。</li><br />
</ol><br />
<br />
<p>static void* lept_context_push(lept_context* c, size_t size) {<br />
    void* ret;<br />
    assert(size &gt; 0);<br />
    if (c-&gt;top + size &gt;= c-&gt;size) { // (1)<br />
        if (c-&gt;size == 0)<br />
            c-&gt;size = LEPT_PARSE_STACK_INIT_SIZE;<br />
        while (c-&gt;top + size &gt;= c-&gt;size)<br />
            c-&gt;size += c-&gt;size » 1;  /* c-&gt;size * 1.5 <em>/<br />
        c-&gt;stack = (char</em>)realloc(c-&gt;stack, c-&gt;size);<br />
    }<br />
    ret = c-&gt;stack + c-&gt;top;       // (2)<br />
    c-&gt;top += size;                // (3)<br />
    return ret;                    // (4)<br />
}<br />
中间最花费时间的，应该会是 (1)，需要计算而且作分支检查。即使使用 C99 的 inline 关键字（或使用宏）去减少函数调用的开销，这个分支也无法避免。</p><br />
<br />
<p>所以，一个优化的点子是，预先分配足够的内存，每次加入字符就不用做这个检查了。但多大的内存才足够呢？我们可以看到，每个字符可生成最长的形式是 \u00XX，占 6 个字符，再加上前后两个双引号，也就是共 len * 6 + 2 个输出字符。那么，使用 char* p = lept_context_push() 作一次分配后，便可以用 *p++ = c 去输出字符了。最后，再按实际输出量调整堆栈指针。</p><br />
<br />
<p>另一个小优化点，是自行编写十六进位输出，避免了 printf() 内解析格式的开销。</p><br />
<br />
<p>static void lept_stringify_string(lept_context* c, const char* s, size_t len) {<br />
    static const char hex_digits[] = { ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’, ‘A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’ };<br />
    size_t i, size;<br />
    char* head, <em>p;<br />
    assert(s != NULL);<br />
    p = head = lept_context_push(c, size = len * 6 + 2); /</em> “\u00xx…” */<br />
    *p++ = ‘”’;<br />
    for (i = 0; i &lt; len; i++) {<br />
        unsigned char ch = (unsigned char)s[i];<br />
        switch (ch) {<br />
            case ‘"’: *p++ = ‘\’; *p++ = ‘"’; break;<br />
            case ‘\’: *p++ = ‘\’; *p++ = ‘\’; break;<br />
            case ‘\b’: *p++ = ‘\’; *p++ = ‘b’;  break;<br />
            case ‘\f’: *p++ = ‘\’; *p++ = ‘f’;  break;<br />
            case ‘\n’: *p++ = ‘\’; *p++ = ‘n’;  break;<br />
            case ‘\r’: *p++ = ‘\’; *p++ = ‘r’;  break;<br />
            case ‘\t’: *p++ = ‘\’; *p++ = ‘t’;  break;<br />
            default:<br />
                if (ch &lt; 0x20) {<br />
                    *p++ = ‘\’; *p++ = ‘u’; *p++ = ‘0’; *p++ = ‘0’;<br />
                    *p++ = hex_digits[ch » 4];<br />
                    *p++ = hex_digits[ch &amp; 15];<br />
                }<br />
                else<br />
                    *p++ = s[i];<br />
        }<br />
    }<br />
    *p++ = ‘”’;<br />
    c-&gt;top -= size - (p - head);<br />
}<br />
要注意的是，很多优化都是有代价的。第一个优化采取空间换时间的策略，对于只含一个字符串的 JSON，很可能会分配多 6 倍内存；但对于正常含多个值的 JSON，多分配的内存可在之后的值所利用，不会造成太多浪费。</p><br />
<br />
<p>而第二个优化的缺点，就是有稍增加了一点程序体积。也许有人会问，为什么 hex_digits 不用字符串字面量 “0123456789ABCDEF”？其实是可以的，但这会多浪费 1 个字节（实际因数据对齐可能会浪费 4 个或更多）。</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category lang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>