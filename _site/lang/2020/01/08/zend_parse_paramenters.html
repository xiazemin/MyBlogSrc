<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">zend_parse_paramenters</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-01-08T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jan 8, 2020</time></p>
					</div>
					 <p>基本参数<br />
最简单的获取函数调用者传递过来的参数便是使用 zend_parse_parameters() 函数。 zend_parse_parameters() 函数的前几个参数我们直接用内核里的宏来生成便可以了，形式为：ZEND_NUM_ARGS() TSRMLS_CC，注意两者之间有个空格，但是没有逗号。从名字可以看出，ZEND_NUM_ARGS() 代表着参数的个数。紧接着需要传递给 zend_parse_parameters() 函数的参数是一个用于格式化的字符串，就像 printf 的第一个参数一样。下面列出了最常用的几个符号：</p><br />
<br />
<p>参数	代表着的类型<br />
b	Boolean<br />
l	Integer<br />
d	Float<br />
s	String<br />
r	Resource<br />
a	Array<br />
o	Object<br />
O	特定类型的Object<br />
z	任意类型<br />
Z	zval**类型<br />
f	表示函数、方法名称<br />
这个函数就像 printf() 函数一样，后面的参数是与格式化字符串里的格式一一对应的。一些基础类型的数据会直接映射成 C 语言里的类型。</p><br />
<br />
<p>1<br />
ZEND_FUNCTION(sample_getlong) {<br />
2<br />
    long foo;<br />
3<br />
    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, “l”, &amp;foo) == FAILURE)<br />
4<br />
    {<br />
5<br />
        RETURN_NULL();<br />
6<br />
    }<br />
7<br />
    php_printf(“The integer value of the parameter is: %ld\n”, foo);<br />
8<br />
    RETURN_TRUE;<br />
9<br />
}<br />
一般来说，int 和 long 这两种数据类型的数据往往是相同的，但也有例外情况。所以我们不应该把long 的数组放在一个 int 里，尤其是在 64 位平台里，那将引发一些不容易排查的 Bug。所以通过zend_parse_parameter() 函数接收参数时，我们应该使用内核约定好的类型变量作为载体：</p><br />
<br />
<p>参数	对应C里的数据类型<br />
b	zend_bool<br />
l	long<br />
d	double<br />
s	char<em>, int 前者接收指针，后者接收长度<br />
r	zval</em><br />
a	zval*<br />
o	zval*<br />
O	zval<em>, zend_class_entry</em><br />
z	zval*<br />
Z	zval**<br />
注意，所有的 PHP 语言中的复合类型参数都需要 zval* 类型来作为载体，因为它们都是内核自定义的一些数据结构。我们一定要确认参数和载体的类型一致，如果需要，它可以进行类型转换，比如把 array 转换成 stdClass 对象。 s 和 O (字母大写)类型需要特殊一些，因为它们都需要两个载体。我们将在接下来的章节里了解 PHP 中对象的具体实现。这样我们改写一下我们之前定义的一个函数：</p><br />
<br />
<p>1<br />
&lt;?php<br />
2<br />
function sample_hello_world($name) {<br />
3<br />
    echo “Hello $name!\n”;<br />
4<br />
}<br />
在编写扩展时，我们需要用 zend_parse_parameters() 来接收这个字符串:</p><br />
<br />
<p>1<br />
ZEND_FUNCTION(sample_hello_world) <br />
2<br />
{<br />
3<br />
    char *name;<br />
4<br />
    int name_len;<br />
5<br />
​<br />
6<br />
    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, “s”, &amp;name, &amp;name_len) == FAILURE)<br />
7<br />
    {<br />
8<br />
            RETURN_NULL();<br />
9<br />
    }<br />
10<br />
       php_printf(“Hello “);<br />
11<br />
       PHPWRITE(name, name_len);<br />
12<br />
       php_printf(“!\n”);<br />
13<br />
}<br />
如果传递给函数的参数数量小于 zend_parse_parameters() 要接收的参数数量，它便会执行失败，并返回 FAILURE。</p><br />
<br />
<p>如果我们需要接收多个参数，可以直接在 zend_parse_paramenters() 的参数里罗列接收载体便可以了，如：</p><br />
<br />
<p>1<br />
&lt;?php<br />
2<br />
function sample_hello_world($name, $greeting) {<br />
3<br />
    echo “Hello $greeting $name!\n”;<br />
4<br />
}<br />
5<br />
sample_hello_world(‘John Smith’, ‘Mr.’);<br />
在 PHP 扩展里应该这样来实现：</p><br />
<br />
<p>1<br />
ZEND_FUNCTION(sample_hello_world) {<br />
2<br />
    char *name;<br />
3<br />
    int name_len;<br />
4<br />
    char *greeting;<br />
5<br />
    int greeting_len;<br />
6<br />
​<br />
7<br />
    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, “ss”, &amp;name, &amp;name_len, &amp;greeting, &amp;greeting_len) == FAILURE) {<br />
8<br />
        RETURN_NULL();<br />
9<br />
    }<br />
10<br />
​<br />
11<br />
    php_printf(“Hello “);<br />
12<br />
    PHPWRITE(greeting, greeting_len);<br />
13<br />
    php_printf(“ “);<br />
14<br />
    PHPWRITE(name, name_len);<br />
15<br />
    php_printf(“!\n”);<br />
16<br />
}<br />
除了上面定义的参数，还有其它的三个参数来增强我们接收参数的能力,如下：</p><br />
<br />
<p>|：它之前的参数都是必须的，之后的都是非必须的，也就是有默认值的。<br />
!：如果接收了一个 PHP 语言里的 NULL 变量，则直接把其转成 C 语言里的 NULL，而不是封装成IS_NULL 类型的 zval。<br />
/：如果传递过来的变量与别的变量共用一个 zval，而且不是引用，则进行强制分离，新的 zval 的is_ref__gc 等于 0，并且 refcount__gc 等于 1。<br />
默认参数值<br />
现在让我们继续改写 sample_hello_world(), 接下来我们使用一些参数的默认值，在 PHP 语言里就像下面这样：</p><br />
<br />
<p>1<br />
&lt;?php<br />
2<br />
function sample_hello_world($name, $greeting=’Mr./Ms.’) {<br />
3<br />
    echo “Hello $greeting $name!\n”;<br />
4<br />
}<br />
5<br />
sample_hello_world(‘Ginger Rogers’,’Ms.’);<br />
6<br />
sample_hello_world(‘Fred Astaire’);<br />
此时既可以只向 sample_hello_world 中传递一个参数，也可以传递完整的两个参数。那同样的功能我们怎样在扩展函数里实现呢？我们需要借助 zend_parse_parameters 中的 | 参数，这个参数之前的参数被认为是必须的，之后的便认为是非必须的了，如果没有传递，则不会去修改载体。</p><br />
<br />
<p>1<br />
ZEND_FUNCTION(sample_hello_world) {<br />
2<br />
    char *name;<br />
3<br />
    int name_len;<br />
4<br />
    char *greeting = “Mr./Mrs.”;<br />
5<br />
    int greeting_len = sizeof(“Mr./Mrs.”) - 1;<br />
6<br />
​<br />
7<br />
    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, “s|s”,<br />
8<br />
      &amp;name, &amp;name_len, &amp;greeting, &amp;greeting_len) == FAILURE) {<br />
9<br />
        RETURN_NULL();<br />
10<br />
    }<br />
11<br />
​<br />
12<br />
    php_printf(“Hello “);<br />
13<br />
    PHPWRITE(greeting, greeting_len);<br />
14<br />
    php_printf(“ “);<br />
15<br />
    PHPWRITE(name, name_len);<br />
16<br />
    php_printf(“!\n”);<br />
17<br />
}<br />
如果你不传递第二个参数，则扩展函数会被认为默认而不去修改载体。所以，我们需要自己来预先设置有载体的值，它往往是 NULL，或者一个与函数逻辑有关的值。</p><br />
<br />
<p>NULL参数值<br />
每个 zval，包括 IS_NULL 型的 zval，都需要占用一定的内存空间，并且需要 CPU 的计算资源来为它申请内存、初始化，并在它们完成工作后释放掉。但是很多代码都没有意识到这一点。有很多代码都会把一个 NULL 类型的值包裹成 zval 的 IS_NULL 类型，在扩展开发里这种操作是可以优化的，我们可以把参数接收成 C 语言里的 NULL。我们就这一个问题看以下代码：</p><br />
<br />
<p>1<br />
ZEND_FUNCTION(sample_arg_fullnull) {<br />
2<br />
    zval *val;<br />
3<br />
    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, “z”, &amp;val) == FAILURE) {<br />
4<br />
        RETURN_NULL();<br />
5<br />
    }<br />
6<br />
    if (Z_TYPE_P(val) == IS_NULL) {<br />
7<br />
        val = php_sample_make_defaultval(TSRMLS_C);<br />
8<br />
    }<br />
9<br />
    …<br />
10<br />
}<br />
11<br />
​<br />
12<br />
ZEND_FUNCTION(sample_arg_nullok) {<br />
13<br />
    zval *val;<br />
14<br />
    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, “z!”, &amp;val) == FAILURE) {<br />
15<br />
        RETURN_NULL();<br />
16<br />
    }<br />
17<br />
    if (!val) {<br />
18<br />
        val = php_sample_make_defaultval(TSRMLS_C);<br />
19<br />
    }<br />
20<br />
}<br />
这两段代码乍看起来并没有什么很大的不同，但是第一段代码确实需要更多的 CPU 和内存资源。可能这个技巧在平时并没多大用，不过技多不压身，知道总比不知道好。</p><br />
<br />
<p>非引用参数强制分离<br />
当一个变量被传递给函数时候，无论它是否被引用，它的 refcoung__gc 属性都会加 1，至少成为 2：一份是它自己，另一份是传递给函数的拷贝。在改变这个 zval 之前，有时会需要提前把它分离成实际意义上的两份拷贝。这就是 / 修饰符的作用。它把写时复制的 zval 提前分离成两个完整独立的拷贝，从而使我们可以在后面的代码中随意对其进行操作，否则我们可能需要不停的提醒自己对接收的参数进行分离等操作。和 ! 一样，该修饰符位于其所影响的类型之后。</p><br />
<br />
<p>zend_get_arguments()<br />
如果你想让你的扩展能够兼容老版本的 PHP，或者你只想以 zval 为载体来接收参数，可以考虑使用zend_get_parameters() 函数来接收参数。zend_get_parameters() 与zend_parse_parameters() 不同，从名字上我们便可以看出，它直接获取，而不做解析。</p><br />
<br />
<p>首先，它不会自动进行类型转换，所有的参数在扩展实现中的载体都需要是 zval 类型的，下面让我们来看一个最简单的例子：</p><br />
<br />
<p>1<br />
ZEND_FUNCTION(sample_onearg) {<br />
2<br />
    zval <em>firstarg;<br />
3<br />
​<br />
4<br />
    if (zend_get_parameters(ZEND_NUM_ARGS(), 1, &amp;firstarg)== FAILURE) {<br />
5<br />
        php_error_docref(NULL TSRMLS_CC, E_WARNING, “Expected at least 1 parameter.”);<br />
6<br />
        RETURN_NULL();<br />
7<br />
    }<br />
8<br />
    /</em> Do something with firstarg… <em>/<br />
9<br />
}<br />
其次，zend_get_parameters() 在接收失败的时候，并不会自己抛出错误，它也不能方便地处理具有默认值的参数。最后一点与 zend_parse_parameters 不同的是，它会自动的把所有符合写时复制的 zval 进行强制分离，生成一个崭新的拷贝送到函数内部。如果你希望用它其它的特性，而唯独不需要这个功能，可以去尝试一下用 zend_get_parameters_ex() 函数来接收参数。为了不对写时复制的变量进行分离操作，zend_get_parameters_ex() 的参数是 zval** 类型的，而不是zval</em>。这个函数不太经常用，可能只会在你碰到一些极端问题时候才会想到它，而它用起来却很简单：</p><br />
<br />
<p>1<br />
ZEND_FUNCTION(sample_onearg) {<br />
2<br />
    zval <em>*firstarg;<br />
3<br />
    if (zend_get_parameters_ex(1, &amp;firstarg) == FAILURE) {<br />
4<br />
        WRONG_PARAM_COUNT;<br />
5<br />
    }<br />
6<br />
    /</em> Do something with firstarg… */<br />
7<br />
}<br />
注：zend_get_parameters_ex 不需要 ZEND_NUM_ARGS() 作为参数，因为它是在是在后期加入的，那个参数已经不再需要了。</p><br />
<br />
<p>上面例子中还使用了 WRONG_PARAM_COUNT 宏，它的功能是抛出一个 E_WARNING 级别的错误信息，并自动 return。</p><br />
<br />
<p>可变参数实现<br />
还有一种 zend_get_parameter_** 函数，专门用来解决参数很多或者无法提前知道参数数目的问题。试想一下 PHP 语言中 var_dump() 函数的用法，我们可以向其传递任意数量的参数，它在内核中的实现其实是这样的：</p><br />
<br />
<p>1<br />
ZEND_FUNCTION(var_dump) {<br />
2<br />
    int i, argc = ZEND_NUM_ARGS();<br />
3<br />
    zval <em>**args;<br />
4<br />
​<br />
5<br />
    args = (zval **</em>)safe_emalloc(argc, sizeof(zval **), 0);<br />
6<br />
    if (ZEND_NUM_ARGS() == 0 || zend_get_parameters_array_ex(argc, args) == FAILURE) {<br />
7<br />
        efree(args);<br />
8<br />
        WRONG_PARAM_COUNT;<br />
9<br />
    }<br />
10<br />
​<br />
11<br />
    for (i = 0; i &lt; argc; i++) {<br />
12<br />
            php_var_dump(args[i], 1 TSRMLS_CC);<br />
13<br />
    }<br />
14<br />
​<br />
15<br />
    efree(args);<br />
16<br />
}<br />
https://xueyuanjun.com/link/7233#bkmrk-%E7%A8%8B%E5%BA%8F%E9%A6%96%E5%85%88%E8%8E%B7%E5%8F%96%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87-safe</p><br />
<br />
<p>程序首先获取参数数量，然后通过 safe_emalloc 函数申请了相应大小的内存来存放这些 zval** 类型的参数。这里使用了 zend_get_parameters_array_ex() 函数来把传递给函数的参数填充到 args 中。你可能已经立即想到，还存在一个名为 zend_get_parameters_array() 的函数，唯一不同的是它将 zval* 类型的参数填充到 args 中，并且需要 ZEND_NUM_ARGS() 作为参数。<br />
<!-- more --><br />
在经过词语分析，语法分析后，我们知道对于函数的参数检查是通过 zend_do_receive_arg 函数来实现的。在此函数中对于参数的关键代码如下：</p><br />
<br />
<p>CG(active_op_array)-&gt;arg_info = erealloc(CG(active_op_array)-&gt;arg_info,<br />
        <a href="http://www.php.net/sizeof">sizeof</a>(zend_arg_info)*(CG(active_op_array)-&gt;num_args));<br />
cur_arg_info = &amp;CG(active_op_array)-&gt;arg_info[CG(active_op_array)-&gt;num_args-1];<br />
cur_arg_info-&gt;name = estrndup(varname-&gt;u.<a href="http://www.php.net/constant">constant</a>.value.str.val,<br />
        varname-&gt;u.<a href="http://www.php.net/constant">constant</a>.value.str.len);<br />
cur_arg_info-&gt;name_len = varname-&gt;u.<a href="http://www.php.net/constant">constant</a>.value.str.len;<br />
cur_arg_info-&gt;array_type_hint = 0;<br />
cur_arg_info-&gt;allow_null = 1;<br />
cur_arg_info-&gt;pass_by_reference = pass_by_reference;<br />
cur_arg_info-&gt;class_name = NULL;<br />
cur_arg_info-&gt;class_name_len = 0;<br />
整个参数的传递是通过给中间代码的arg_info字段执行赋值操作完成。关键点是在arg_info字段。arg_info字段的结构如下：</p><br />
<br />
<p>typedef struct _zend_arg_info {<br />
    const char <em>name;   /</em> 参数的名称<em>/<br />
    zend_uint name_len;     /</em> 参数名称的长度<em>/<br />
    const char *class_name; /</em> 类名 <em>/<br />
    zend_uint class_name_len;   /</em> 类名长度<em>/<br />
    zend_bool array_type_hint;  /</em> 数组类型提示 <em>/<br />
    zend_bool allow_null;   /</em> 是否允许为NULL　<em>/<br />
    zend_bool pass_by_reference;    /</em>　是否引用传递 */<br />
    zend_bool return_reference; <br />
    int required_num_args;<br /><br />
} zend_arg_info;<br />
参数的值传递和参数传递的区分是通过 pass_by_reference参数在生成中间代码时实现的。</p><br />
<br />
<p>对于参数的个数，中间代码中包含的arg_nums字段在每次执行 **zend_do_receive_arg×× 时都会加1.如下代码：</p><br />
<br />
<p>CG(active_op_array)-&gt;num_args++;<br />
并且当前参数的索引为CG(active_op_array)-&gt;num_args-1 .如下代码：</p><br />
<br />
<p>cur_arg_info = &amp;CG(active_op_array)-&gt;arg_info[CG(active_op_array)-&gt;num_args-1];<br />
以上的分析是针对函数定义时的参数设置，这些参数是固定的。而在实际编写程序时可能我们会用到可变参数。此时我们会使用到函数 func_num_args 和 func_get_args。它们是以内部函数存在。在 Zend\zend_builtin_functions.c 文件中找到这两个函数的实现。首先我们来看func_num_args函数的实现。其代码如下：</p><br />
<br />
<p>/* {{{ proto int func_num_args(void) Get the number of arguments that were passed to the function */<br />
ZEND_FUNCTION(func_num_args)<br />
{<br />
    zend_execute_data *ex = EG(current_execute_data)-&gt;prev_execute_data;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (ex &amp;&amp; ex-&gt;function_state.arguments) {<br />
    RETURN_LONG((long)(zend_uintptr_t)*(ex-&gt;function_state.arguments));<br />
} else {<br />
    zend_error(E_WARNING, "func_num_args(): Called from the global scope - no function context");<br />
    RETURN_LONG(-1);<br />
} } /* }}} */ 在存在 ex-&gt;function_state.arguments的情况下，即函数调用时，返回ex-&gt;function_state.arguments转化后的值 ，否则显示错误并返回-1。这里最关键的一点是EG(current_execute_data)。这个变量存放的是当前执行程序或函数的数据。此时我们需要取前一个执行程序的数据，为什么呢？因为这个函数的调用是在进入函数后执行的。函数的相关数据等都在之前执行过程中。于是调用的是：<br />
</code></pre></div></div><br />
<br />
<p>zend_execute_data *ex = EG(current_execute_data)-&gt;prev_execute_data;<br />
function_state等结构请参照本章第一小节。</p><br />
<br />
<p>在了解func_num_args函数的实现后，func_get_args函数的实现过程就简单了，它们的数据源是一样的，只是前面返回的是长度，而这里返回了一个创建的数组。数组中存放的是从ex-&gt;function_state.arguments转化后的数据。</p><br />
<br />
<p>内部函数的参数<br />
以上我们所说的都是用户自定义函数中对于参数的相关内容。下面我们开始讲解内部函数是如何传递参数的。以常见的count函数为例。其参数处理部分的代码如下：</p><br />
<br />
<p>/* {{{ proto int count(mixed var [, int mode]) Count the number of elements in a variable (usually an array) */<br />
PHP_FUNCTION(count)<br />
{<br />
    zval *array;<br />
    long mode = COUNT_NORMAL;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z|l",<br />
     &amp;array, &amp;mode) == FAILURE) {<br />
    return;<br />
}<br />
... //省略 } 这包括了两个操作：一个是取参数的个数，一个是解析参数列表。<br />
</code></pre></div></div><br />
<br />
<p>取参数的个数</p><br />
<br />
<p>取参数的个数是通过ZEND_NUM_ARGS()宏来实现的。其定义如下：</p><br />
<br />
<p>#define ZEND_NUM_ARGS() (ht)<br />
PHP3 中使用的是宏 ARG_COUNT</p><br />
<br />
<p>ht是在 Zend/zend.h文件中定义的宏 INTERNAL_FUNCTION_PARAMETERS 中的ht，如下：</p><br />
<br />
<p>#define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value,<br />
zval **return_value_ptr, zval *this_ptr, int return_value_used TSRMLS_DC<br />
解析参数列表</p><br />
<br />
<p>PHP内部函数在解析参数时使用的是 zend_parse_parameters。它可以大大简化参数的接收处理工作，虽然它在处理可变参数时还有点弱。</p><br />
<br />
<p>其声明如下：</p><br />
<br />
<p>ZEND_API int zend_parse_parameters(int num_args TSRMLS_DC, char *type_spec, …)<br />
第一个参数num_args表明表示想要接收的参数个数，我们经常使用ZEND_NUM_ARGS() 来表示对传入的参数“有多少要多少”。<br />
第二参数应该总是宏 TSRMLS_CC 。<br />
第三个参数 type_spec 是一个字符串，用来指定我们所期待接收的各个参数的类型，有点类似于 printf 中指定输出格式的那个格式化字符串。<br />
剩下的参数就是我们用来接收PHP参数值的变量的指针。<br />
zend_parse_parameters() 在解析参数的同时会尽可能地转换参数类型，这样就可以确保我们总是能得到所期望的类型的变量。任何一种标量类型都可以转换为另外一种标量类型，但是不能在标量类型与复杂类型（比如数组、对象和资源等）之间进行转换。如果成功地解析和接收到了参数并且在转换期间也没出现错误，那么这个函数就会返回 SUCCESS，否则返回 FAILURE。如果这个函数不能接收到所预期的参数个数或者不能成功转换参数类型时就会抛出一些错误信息。</p><br />
<br />
<p>第三个参数指定的各个参数类型列表如下所示：</p><br />
<br />
<p>l - 长整形<br />
d - 双精度浮点类型<br />
s - 字符串 (也可能是空字节)和其长度<br />
b - 布尔型<br />
r - 资源，保存在 zval*<br />
a - 数组，保存在 zval*<br />
o - （任何类的）对象，保存在 zval *<br />
O - （由class entry 指定的类的）对象，保存在 zval *<br />
z - 实际的 zval*<br />
除了各个参数类型，第三个参数还可以包含下面一些字符，它们的含义如下：</p><br />
<br />
<p>| - 表明剩下的参数都是可选参数。如果用户没有传进来这些参数值，那么这些值就会被初始化成默认值。<br />
/ - 表明参数解析函数将会对剩下的参数以 SEPARATE_ZVAL_IF_NOT_REF() 的方式来提供这个参数的一份拷贝，除非这些参数是一个引用。<br />
! - 表明剩下的参数允许被设定为 NULL（仅用在 a、o、O、r和z身上）。如果用户传进来了一个 NULL 值，则存储该参数的变量将会设置为 NULL。<br />
参数的传递<br />
在PHP的运行过程中，如果函数有参数，当执行参数传递时，所传递参数的引用计数会发生变化。如和Xdebug的作者Derick Rethans在其文章php variables中的示例的类似代码：</p><br />
<br />
<p>function do_something($s) {<br />
       xdebug_debug_zval(‘s’);<br />
        $s = 100;<br />
        return $s;<br />
}</p><br />
<br />
<p>$a = 1111;<br />
$b = do_something($a);<br />
<a href="http://www.php.net/echo">echo</a> $b;<br />
如果你安装了xdebug，此时会输出s变量的refcount为3，如果使用debug_zval_dump，会输出4。因为此内部函数调用也对refcount执行了加1操作。这里的三个引用计数分别是：</p><br />
<br />
<p>function stack中的引用<br />
function symbol table中引用<br />
原变量$a的引用。<br />
这个函数符号表只有用户定义的函数才需要，内置和扩展里的函数不需要此符号表。debug_zval_dump()是内置函数，并不需要符号表，所以只增加了1。 xdebug_debug_zval()传递的是变量名字符串，所以没有增加refcount。</p><br />
<br />
<p>每个PHP脚本都有自己专属的全局符号表，而每个用户自定义的函数也有自己的符号表，这个符号表用来存储在这个函数作用域下的属于它自己的变量。当调用每个用户自定义的函数时，都会为这个函数创建一个符号表，当这个函数返回时都会释放这个符号表。</p><br />
<br />
<p>当执行一个拥有参数的用户自定义的函数时，其实它相当于赋值一个操作，即$s = $a;只是这个赋值操作的引用计数会执行两次，除了给函数自定义的符号表，还有一个是给函数栈。</p><br />
<br />
<p>参数的传递的第一步是SEND_VAR操作，这一步操作是在函数调用这一层级，如示例的PHP代码通过VLD生成的中间代码:</p><br />
<br />
<p>compiled vars:  !0 = $a, !1 = $b<br />
line     # *  op                           fetch          ext  return  operands<br />
——————————————————————————–<br />
-<br />
   2     0  &gt;   EXT_STMT<br />
         1      NOP<br />
   7     2      EXT_STMT<br />
         3      ASSIGN                                                   !0, 1111<br />
   8     4      EXT_STMT<br />
         5      EXT_FCALL_BEGIN<br />
         6      SEND_VAR                                                 !0<br />
         7      DO_FCALL                                      1          ‘demo’<br />
         8      EXT_FCALL_END<br />
         9      ASSIGN                                                   !1, $1<br />
   9    10      EXT_STMT<br />
        11      ECHO                                                     !1<br />
        12    &gt; RETURN                                                   1</p><br />
<br />
<p>branch: #  0; line:     2-    9; sop:     0; eop:    12<br />
path #1: 0,<br />
Function demo:<br />
函数调用是DO_FCALL，在此中间代码之前有一个SEND_VAR操作，此操作的作用是将实参传递给函数，并且将它添加到函数栈中。最终调用的具体代码参见zend_send_by_var_helper_SPEC_CV函数，在此函数中执行了引用计数加1（Z_ADDREF_P）操作和函数栈入栈操作（zend_vm_stack_push）。</p><br />
<br />
<p>与第一步的SEND操作对应，第二步是RECV操作。RECV操作和SEND_VAR操作不同，它是归属于当前函数的操作，仅为此函数服务。它的作用是接收SEND过来的变量，并将它们添加到当前函数的符号表。示例函数生成的中间代码如下：</p><br />
<br />
<p>compiled vars:  !0 = $s<br />
line     # *  op                           fetch          ext  return  operands<br />
——————————————————————————–<br />
-<br />
   2     0  &gt;   EXT_NOP<br />
         1      RECV                                                     1<br />
   3     2      EXT_STMT<br />
         3      ASSIGN                                                   !0, 10<br />
   4     4      EXT_STMT<br />
         5    &gt; RETURN                                                   !0<br />
   5     6*     EXT_STMT<br />
         7*   &gt; RETURN                                                   null</p><br />
<br />
<p>branch: #  0; line:     2-    5; sop:     0; eop:     7<br />
参数和普通局部变量一样 ，都需要进行操作，都需要保存在符号表（或CVs里，不过查找一般都是直接从变量变量数组里查找的）。如果函数只是需要读这个变量，如果我们将这个变量复制一份给当前函数使用的话，在内存使用和性能方面都会有问题，而现在的方案却避免了这个问题，如我们的示例：使用类似于赋值的操作，将原变量的引用计数加一，将有变化时才将原变量引用计数减一，并新建变量。其最终调用是ZEND_RECV_SPEC_HANDLER。</p><br />
<br />
<p>参数的压栈操作用户自定义的函数和内置函数都需要，而RECV操作仅用户自定义函数需要。</p><br />
<br />
<p>函数参数解析<br />
之前我们定义的函数没有接收任何参数，那么扩展定义的内部函数如何读取参数呢？用户自定义函数在编译时会为每个参数创建一个zend_arg_info结构，这个结构用来记录参数的名称、是否引用传参、是否为可变参数等，在存储上函数参数与局部变量相同，都分配在zend_execute_data上，且最先分配的就是函数参数，调用函数时首先会进行参数传递，按参数次序依次将参数的value从调用空间传递到被调函数的zend_execute_data，函数内部像访问普通局部变量一样通过存储位置访问参数，这是用户自定义函数的参数实现。</p><br />
<br />
<p>/* arg_info for user functions */<br />
typedef struct _zend_arg_info {<br />
	zend_string *name;//参数名<br />
	zend_string *class_name;<br />
	zend_uchar type_hint;//显式声明的参数类型，比如(array $param_1)<br />
	zend_uchar pass_by_reference;//是否引用传参，参数前加&amp;的这个值就是1<br />
	zend_bool allow_null;//是否允许为NULL,注意：这个值并不是用来表示参数是否为必传的<br />
	zend_bool is_variadic;//是否为可变参数，即…用法，与golang的用法相同，5.6以上新增的一个用法：function my_func($a, …$b){…}<br />
} zend_arg_info;<br />
PHP中通过 zend_parse_parameters() 这个函数解析zend_execute_data上保存的参数：</p><br />
<br />
<p>zend_parse_parameters(int num_args, const char *type_spec, …);<br />
num_args为实际传参数，通过 ZEND_NUM_ARGS()获取；<br />
type_spec是一个字符串，用来标识解析参数的类型，比如:”la”表示第一个参数为整形，第二个为数组，将按照这个解析到指定变量；<br />
后面是一个可变参数，用来指定解析到的变量，这个值与type_spec配合使用，即type_spec用来指定解析的变量类型，可变参数用来指定要解析到的变量，这个值必须是指针。<br />
解析的过程也比较容易理解，调用函数时首先会把参数拷贝到调用函数的zend_execute_data上，所以解析的过程就是按照type_spec指定的各个类型，依次从zend_execute_data上获取参数，然后将参数地址赋给目标变量。</p><br />
<br />
<p>参数类型</p><br />
<br />
<p>整形：l、L</p><br />
<br />
<p>整形通过”l”或”L”标识，表示解析的参数为整形，解析到的变量类型必须是 zend_long ，不能解析其它类型，如果输入的参数不是整形将按照类型转换规则将其转为整形：</p><br />
<br />
<p>zend_long lval;<br />
if(zend_parse_parameters(ZEND_NUM_ARGS(), “l”, &amp;lval){<br />
…<br />
}<br />
printf(“lval:%d\n”, lval);<br />
如果在标识符后加”!”，即：”l!”、”L!”，则必须再提供一个zend_bool变量的地址，通过这个值可以判断传入的参数是否为NULL，如果为NULL则将要解析到的zend_long值设置为0，同时zend_bool设置为1：</p><br />
<br />
<p>zend_long lval; //如果参数为NULL则此值被设为0<br />
zend_bool is_null;//如果参数为NULL则此值为1，否则为0<br />
if(zend_parse_parameters(ZEND_NUM_ARGS(), “l!”, &amp;lval, &amp;is_null){<br />
..<br />
}<br />
布尔型：b</p><br />
<br />
<p>通过”b”标识符表示将传入的参数解析为布尔型，解析到的变量必须是zend_bool：</p><br />
<br />
<p>zend_bool ok;<br />
if(zend_parse_parameters(ZEND_NUM_ARGS(), “b”, &amp;ok, &amp;is_null) == FAILURE){<br />
..<br />
}<br />
“b!”的用法与整形的完全相同，也必须再提供一个zend_bool的地址用于获取传参是否为NULL，如果为NULL，则zend_bool为0，用于获取是否NULL的zend_bool为1。</p><br />
<br />
<p>浮点型：d<br />
通过”d”标识符表示将参数解析为浮点型，解析的变量类型必须为double：</p><br />
<br />
<p>double dval;</p><br />
<br />
<p>if(zend_parse_parameters(ZEND_NUM_ARGS(), “d”, &amp;dval) == FAILURE){<br />
..<br />
}<br />
具体解析过程不再展开，”d!”与整形、布尔型用法完全相同。</p><br />
<br />
<p>字符串：s、S、p、P<br />
字符串解析有两种形式：char、zend_string，其中”s”将参数解析到<code class="language-plaintext highlighter-rouge">char</code>，且需要额外提供一个size_t类型的变量用于获取字符串长度，”S”将解析到zend_string：</p><br />
<br />
<p>char <em>str;<br />
size_t str_len;<br />
if(zend_parse_parameters(ZEND_NUM_ARGS(), “s”, &amp;str, &amp;str_len) == FAILURE){<br />
…<br />
}<br />
zend_string *str;<br />
if(zend_parse_parameters(ZEND_NUM_ARGS(), “S”, &amp;str) == FAILURE){<br />
…<br />
}<br />
“s!”、”S!”与整形、布尔型用法不同，字符串时不需要额外提供zend_bool的地址，如果参数为NULL，则char</em>、zend_string将设置为NULL。除了”s”、”S”之外还有两个类似的：”p”、”P”，从解析规则来看主要用于解析路径，实际与普通字符串没什么区别，尚不清楚这俩有什么特殊用法。</p><br />
<br />
<p>数组：a、A、h、H<br />
数组的解析也有两类，一类是解析到zval层面，另一类是解析到HashTable，其中”a”、”A”解析到的变量必须是zval，”h”、”H”解析到HashTable，这两类是等价的：</p><br />
<br />
<p>zval *arr; //必须是zval指针，不能是zval arr，因为参数保存在zend_execute_data上，arr为此空间上参数的地址<br />
HashTable *ht;<br />
if(zend_parse_parameters(ZEND_NUM_ARGS(), “ah”, &amp;arr, &amp;ht) == FAILURE){<br />
…<br />
}<br />
“a!”、”A!”、”h!”、”H!”的用法与字符串一致，也不需要额外提供别的地址，如果传参为NULL，则对应解析到的zval、HashTable也为NULL.</p><br />
<br />
<p>对象：o、O<br />
如果参数是一个对象则可以通过”o”、”O”将其解析到目标变量，注意：只能解析为zval，无法解析为zend_object。</p><br />
<br />
<p>zval *obj;<br />
if(zend_parse_parameters(ZEND_NUM_ARGS(), “o”, &amp;obj) == FAILURE){<br />
…<br />
}<br />
O”是要求解析指定类或其子类的对象，类似传参时显式的声明了参数类型的用法function my_func(MyClass $obj){…} ，如果参数不是指定类的实例化对象则无法解析。<br />
“o!”、”O!”与字符串用法相同</p><br />
<br />
<p>资源：r<br />
如果参数为资源则可以通过”r”获取其zval的地址，但是无法直接解析到zend_resource的地址，与对象相同。</p><br />
<br />
<p>zval *res;<br />
if(zend_parse_parameters(ZEND_NUM_ARGS(), “r”, &amp;res) == FAILURE){<br />
…<br />
}<br />
“r!”与字符串用法相。</p><br />
<br />
<p>类：C<br />
如果参数是一个类则可以通过”C”解析出zend_class_entry地址：function my_func(stdClass){…} ，这里有个地方比较特殊，解析到的变量可以设定为一个类，这种情况下解析时将会找到的类与指定的类之间的父子关系，只有存在父子关系才能解析，如果只是想根据参数获取类型的zend_class_entry地址，记得将解析到的地址初始化为NULL，否则将会不可预料的错误。</p><br />
<br />
<p>zend_class_entry *ce = NULL; //初始为NULL<br />
if(zend_parse_parameters(ZEND_NUM_ARGS(), “C”, &amp;ce) == FAILURE){<br />
RETURN_FALSE;<br />
}<br />
callable：f<br />
callable指函数或成员方法，如果参数是函数名称字符串、array(对象/类,成员方法)，则可以通过”f”标识符解析出 zend_fcall_info 结构，这个结构是调用函数、成员方法时的唯一输入。</p><br />
<br />
<p>zend_fcall_info callable; //注意，这两个结构不能是指针<br />
zend_fcall_info_cache call_cache;<br />
if(zend_parse_parameters(ZEND_NUM_ARGS(), “f”, &amp;callable, &amp;call_cache) ==FAILURE){<br />
RETURN_FALSE;<br />
}<br />
函数调用：</p><br />
<br />
<p>my_func_1(“func_name”);//或<br />
my_func_1(array(‘class_name’, ‘static_method’));//或<br />
my_func_1(array($object, ‘method’));<br />
解析出 zend_fcall_info 后就可以通过 zend_call_function() 调用函数、成员方法了，提供”f”解析到 zend_fcall_info 的用意是简化函数调用的操作，否则需要我们自己去查找函数、检查是否可被调用等工作，关于这个结构稍后介绍函数调用时再作详细说明。</p><br />
<br />
<p>任意类型：z<br />
“z”表示按参数实际类型解析，比如参数为字符串就解析为字符串，参数为数组就解析为数组，这种实际就是将zend_execute_data上的参数地址拷贝到目的变量了，没有做任何转化。<br />
“z!”与字符串用法相同。<br />
 </p><br />
<br />
<p>引用传参<br />
函数中解析参数还有一种就是引用传参。</p><br />
<br />
<p>如果函数需要使用引用类型的参数或返回引用就需要创建函数的参数数组，这个数组通过：</p><br />
<br />
<p>ZEND_BEGIN_ARG_INFO()或ZEND_BEGIN_ARG_INFO_EX() 、<br />
ZEND_END_ARG_INFO() 宏定义：</p><br />
<br />
<p>#define ZEND_BEGIN_ARG_INFO_EX(name, _unused, return_reference, required_num_args)<br />
#define ZEND_BEGIN_ARG_INFO(name, _unused)<br />
name: 参数数组名，注册函数 PHP_FE(function, arg_info) 会用到<br />
_unused: 保留值，暂时无用<br />
<strong>return_reference:</strong> 返回值是否为引用，一般很少会用到<br />
required_num_args: required参数数<br />
这两个宏需要与 ZEND_END_ARG_INFO() 配合使用：</p><br />
<br />
<p>ZEND_BEGIN_ARG_INFO_EX(arginfo_my_func_1, 0, 0, 2)<br />
…<br />
ZEND_END_ARG_INFO</p><br />
<br />
<p>接着就是在上面两个宏中间定义每一个参数的zend_internal_arg_info，PHP提供的宏有：</p><br />
<br />
<p>//pass_by_ref表示是否引用传参，name为参数名称<br />
#define ZEND_ARG_INFO(pass_by_ref, name) { #name, NULL, 0, pass_by_ref, 0, 0 },</p><br />
<br />
<p>//只声明此参数为引用传参<br />
#define ZEND_ARG_PASS_INFO(pass_by_ref) { NULL, NULL, 0, pass_by_ref, 0, 0 },</p><br />
<br />
<p>//显式声明此参数的类型为指定类的对象，等价于PHP中这样声明：MyClass $obj<br />
#define ZEND_ARG_OBJ_INFO(pass_by_ref, name, classname, allow_null) { #name, #classname, IS_OBJECT, pass_by_ref, allow_null, 0 },</p><br />
<br />
<p>//显式声明此参数类型为数组，等价于：array $arr<br />
#define ZEND_ARG_ARRAY_INFO(pass_by_ref, name, allow_null) { #name, NULL, IS_ARRAY, pass_by_ref, allow_null, 0 },</p><br />
<br />
<p>//显式声明为callable，将检查函数、成员方法是否可调<br />
#define ZEND_ARG_CALLABLE_INFO(pass_by_ref, name, allow_null) { #name, NULL, IS_CALLABLE, pass_by_ref, allow_null, 0 },</p><br />
<br />
<p>//通用宏，自定义各个字段<br />
#define ZEND_ARG_TYPE_INFO(pass_by_ref, name, type_hint, allow_null) { #name, NULL, type_hint, pass_by_ref, allow_null, 0 },</p><br />
<br />
<p>//声明为可变参数<br />
#define ZEND_ARG_VARIADIC_INFO(pass_by_ref, name) { #name, NULL, 0, pass_by_ref, 0, 1 },<br />
看个例子：</p><br />
<br />
<p>function my_func_1(&amp;$a, Exception $c){..}<br />
用内核实现则可以这么定义：</p><br />
<br />
<p>ZEND_BEGIN_ARG_INFO_EX(arginfo_my_func_1, 0, 0, 1)<br />
	ZEND_ARG_INFO(1, a) //引用<br />
	ZEND_ARG_OBJ_INFO(0, b, Exception, 0) //注意：这里不要把字符串加””<br />
ZEND_END_ARG_INFO()<br />
展开后：</p><br />
<br />
<p>static const zend_internal_arg_info name[] = {<br />
	//多出来的这个是给返回值用的<br />
	{ (const char*)(zend_uintptr_t)(2), NULL, 0, 0, 0, 0 },<br />
	{ “a”, NULL, 0, 0, 0, 0 },<br />
	{ “b”, “Exception”, 8, 1, 0, 0 },<br />
}<br />
第一个数组元素用于记录必传参数的数量以及返回值是否为引用。定义完这个数组接下来就需要把这个数组告诉函数：</p><br />
<br />
<p>const zend_function_entry mytest_functions[] = {<br />
	PHP_FE(my_func_1, arginfo_my_func_1)<br />
	PHP_FE(my_func_2, NULL)<br />
	PHP_FE_END //末尾必须加这个<br />
};<br />
引用参数通过 zend_parse_parameters() 解析时只能使用”z”解析，不能再直接解析为zend_value了，否则引用将失效：</p><br />
<br />
<p>PHP_FUNCTION(my_func_1)<br />
{<br />
	zval *lval; //必须为zval，定义为zend_long也能解析出，但不是引用<br />
	zval *obj;<br />
	if(zend_parse_parameters(ZEND_NUM_ARGS(), “zo”, &amp;lval, &amp;obj) == FAILURE){<br />
	    RETURN_FALSE;<br />
	}<br />
	//lval的类型为IS_REFERENCE<br />
	zval *real_val = Z_REFVAL_P(lval); //获取实际引用的zval地址：&amp;(lval.value-&gt;ref.val)<br />
	Z_LVAL_P(real_val) = 100; //设置实际引用的类型<br />
}<br />
$a = 90;<br />
$b = new Exception;<br />
my_func_1($a, $b);<br />
echo $a; //100<br />
函数返回值<br />
调用内部函数时其返回值指针作为参数传入，这个参数为 zval *return_value ，如果函数有返回值直接设置此指针即可，需要特别注意的是设置返回值时需要增加其引用计数，举个例子来看:</p><br />
<br />
<p>PHP_FUNCTION(my_func_1)<br />
{<br />
    zval *arr;<br />
    if(zend_parse_parameters(ZEND_NUM_ARGS(), “a”, &amp;arr) == FAILURE){<br />
        RETURN_FALSE;<br />
    }<br />
    //增加引用计数<br />
    Z_ADDREF_P(arr);<br />
    //设置返回值为数组：<br />
    ZVAL_ARR(return_value, Z_ARR_P(arr));<br />
}<br />
此函数接收一个数组，然后直接返回该数组，相当于：</p><br />
<br />
<p>function my_func_1($arr){<br />
    return $arr;<br />
}<br />
虽然可以直接设置return_value，但实际使用时并不建议这么做，因为PHP提供了很多专门用于设置返回值的宏，这些宏定义在 zend_API.h 中：</p><br />
<br />
<p>//返回布尔型，b：IS_FALSE、IS_TRUE<br />
#define RETURN_BOOL(b) { RETVAL_BOOL(b); return; }</p><br />
<br />
<p>//返回NULL<br />
#define RETURN_NULL() { RETVAL_NULL(); return;}</p><br />
<br />
<p>//返回整形，l类型：zend_long<br />
#define RETURN_LONG(l) { RETVAL_LONG(l); return; }</p><br />
<br />
<p>//返回浮点值，d类型：double<br />
#define RETURN_DOUBLE(d) { RETVAL_DOUBLE(d); return; }</p><br />
<br />
<p>//返回字符串，可返回内部字符串，s类型为：zend_string *<br />
#define RETURN_STR(s) { RETVAL_STR(s); return; }</p><br />
<br />
<p>//返回内部字符串，这种变量将不会被回收，s类型为：zend_string *<br />
#define RETURN_INTERNED_STR(s) { RETVAL_INTERNED_STR(s); return;<br />
}</p><br />
<br />
<p>//返回普通字符串，非内部字符串，s类型为：zend_string *<br />
#define RETURN_NEW_STR(s) { RETVAL_NEW_STR(s); return; }</p><br />
<br />
<p>//拷贝字符串用于返回，这个会自己加引用计数，s类型为：zend_string *<br />
#define RETURN_STR_COPY(s) { RETVAL_STR_COPY(s); return; }</p><br />
<br />
<p>//返回char *类型的字符串，s类型为char *<br />
#define RETURN_STRING(s) { RETVAL_STRING(s); return; }</p><br />
<br />
<p>//返回char *类型的字符串，s类型为char *，l为字符串长度，类型为size_t<br />
#define RETURN_STRINGL(s, l) { RETVAL_STRINGL(s, l); return; }</p><br />
<br />
<p>//返回空字符串<br />
#define RETURN_EMPTY_STRING() { RETVAL_EMPTY_STRING(); return;<br />
}</p><br />
<br />
<p>//返回资源，r类型：zend_resource *<br />
#define RETURN_RES(r) { RETVAL_RES(r); return; }</p><br />
<br />
<p>//返回数组，r类型：zend_array *<br />
#define RETURN_ARR(r) { RETVAL_ARR(r); return; }</p><br />
<br />
<p>//返回对象，r类型：zend_object *<br />
#define RETURN_OBJ(r) { RETVAL_OBJ(r); return; }</p><br />
<br />
<p>//返回zval<br />
#define RETURN_ZVAL(zv, copy, dtor) { RETVAL_ZVAL(zv, copy, dtor); re<br />
turn; }</p><br />
<br />
<p>//返回false<br />
#define RETURN_FALSE { RETVAL_FALSE; return; }</p><br />
<br />
<p>//返回true<br />
#define RETURN_TRUE { RETVAL_TRUE; return;}</p><br />
<br />
<p>https://www.fzb.me/2015-2-27-zend-api-manual.html</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category lang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>