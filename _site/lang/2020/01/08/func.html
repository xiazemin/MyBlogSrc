<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">php 函数在vm执行流程</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-01-08T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jan 8, 2020</time></p>
					</div>
					 <p>https://www.cnblogs.com/driftcloudy/p/3296525.html<br />
https://www.cnblogs.com/driftcloudy/p/5400994.html</p><br />
<br />
<p>只探讨纯粹的函数，并不包含方法。对于方法，会放到类、对象中一起研究。</p><br />
<br />
<p>想讲清楚在zend vm中，函数如何被正确的编译成op指令、如何发生参数传递、如何模拟调用栈、如何切换作用域等等，的确是一个很大范畴的话题。但为了弄明白php的原理，必须要攻克它。</p><br />
<br />
<p>对函数的研究，大致可以分成两块。第一块是函数体的编译，主要涉及到如何将函数转化成zend_op指令。第二块是研究函数的调用，涉及到函数调用语句的编译，以及函数如何被执行等topic。这里先来看看函数如何被编译，我们下一篇再讲函数的调用。<br />
<!-- more --><br />
函数的编译<br />
对函数进行编译，最终目的是为了生成一份对应的zend op指令集，除了zend op指令集，编译函数还会产生其他一些相关的数据，比如说函数名称、参数列表信息、compiled variables，甚至函数所在文件、起始行数等等。这些信息作为编译的产出，都需要保存起来。</p><br />
<br />
<p>保存这些编译产出的数据结构，正是上一节中所描述的zend_op_array。在这个系列的文章中，均会以op_array作为简称。</p><br />
<br />
<p>下面列出了一个简单的例子：</p><br />
<br />
<p>&lt;?php<br />
function foo($arg1)<br />
{<br />
    print($arg1);<br />
}</p><br />
<br />
<p>$bar = ‘hello php’;<br />
foo($bar);<br />
这段代码包含了一个最简单的函数示例。</p><br />
<br />
<p>在这样一份php脚本中，最终其实会产生两个op_array。一个是由函数foo编译而来，另一个则是由除去函数foo之外代码编译生成的。同理可以推出，假如一份php脚本其中包含有2个函数和若干语句，则最终会产生3个op_array。也就是说，每个函数最终都会被编译成一个对应的op_array。</p><br />
<br />
<p>刚才提到，op_array中有一些字段是和函数息息相关的。比如function_name代表着函数的名称，比如num_args代表了函数的参数个数，比如required_num_args代表了必须的参数个数，比如arg_info代表着函数的参数信息…etc。</p><br />
<br />
<p>下面会继续结合这段代码，来研究foo函数详细的编译过程。</p><br />
<br />
<p>1、语法定义<br />
从zend_language_parser.y文件中可以看出，函数的语法分析大致涉及如下几个推导式：</p><br />
<br />
<p>top_statement:<br />
        statement                          { zend_verify_namespace(TSRMLS_C); }<br />
    |    function_declaration_statement    { zend_verify_namespace(TSRMLS_C); zend_do_early_binding(TSRMLS_C); }<br />
    |    class_declaration_statement       { zend_verify_namespace(TSRMLS_C); zend_do_early_binding(TSRMLS_C); }<br />
    …</p><br />
<br />
<p>function_declaration_statement:<br />
	unticked_function_declaration_statement	{ DO_TICKS(); }<br />
;</p><br />
<br />
<p>unticked_function_declaration_statement:<br />
	function is_reference T_STRING { zend_do_begin_function_declaration(&amp;$1, &amp;$3, 0, $2.op_type, NULL TSRMLS_CC); }<br />
	‘(‘ parameter_list ‘)’ ‘{‘ inner_statement_list ‘}’ { zend_do_end_function_declaration(&amp;$1 TSRMLS_CC); }<br />
;</p><br />
<br />
<p>is_reference:<br />
        /* empty */    { \(.op_type = ZEND_RETURN_VAL; }<br />
    |    '&amp;'            {\).op_type = ZEND_RETURN_REF; }<br />
;</p><br />
<br />
<p>parameter_list:<br />
        non_empty_parameter_list<br />
    |    /* empty */<br />
;</p><br />
<br />
<p>non_empty_parameter_list:<br />
		optional_class_type T_VARIABLE				{ znode tmp;  fetch_simple_variable(&amp;tmp, &amp;$2, 0 TSRMLS_CC); \(.op_type = IS_CONST; Z_LVAL(\).u.constant)=1; Z_TYPE(\(.u.constant)=IS_LONG; INIT_PZVAL(&amp;\).u.constant); zend_do_receive_arg(ZEND_RECV, &amp;tmp, &amp;\(, NULL, &amp;$1, &amp;$2, 0 TSRMLS_CC); }<br />
	|	optional_class_type '&amp;' T_VARIABLE			{ znode tmp;  fetch_simple_variable(&amp;tmp, &amp;$3, 0 TSRMLS_CC);\).op_type = IS_CONST; Z_LVAL(\(.u.constant)=1; Z_TYPE(\).u.constant)=IS_LONG; INIT_PZVAL(&amp;\(.u.constant); zend_do_receive_arg(ZEND_RECV, &amp;tmp, &amp;\), NULL, &amp;$1, &amp;$3, 1 TSRMLS_CC); }<br />
	|	optional_class_type ‘&amp;’ T_VARIABLE ‘=’ static_scalar	{ znode tmp;  fetch_simple_variable(&amp;tmp, &amp;$3, 0 TSRMLS_CC); \(.op_type = IS_CONST; Z_LVAL(\).u.constant)=1; Z_TYPE(\(.u.constant)=IS_LONG; INIT_PZVAL(&amp;\).u.constant); zend_do_receive_arg(ZEND_RECV_INIT, &amp;tmp, &amp;\(, &amp;$5, &amp;$1, &amp;$3, 1 TSRMLS_CC); }<br />
	|	optional_class_type T_VARIABLE '=' static_scalar	{ znode tmp;  fetch_simple_variable(&amp;tmp, &amp;$2, 0 TSRMLS_CC);\).op_type = IS_CONST; Z_LVAL(\(.u.constant)=1; Z_TYPE(\).u.constant)=IS_LONG; INIT_PZVAL(&amp;\(.u.constant); zend_do_receive_arg(ZEND_RECV_INIT, &amp;tmp, &amp;\), &amp;$4, &amp;$1, &amp;$2, 0 TSRMLS_CC); }<br />
	|	non_empty_parameter_list ‘,’ optional_class_type T_VARIABLE　　　　　　　　　　　　　　{ znode tmp;  fetch_simple_variable(&amp;tmp, &amp;$4, 0 TSRMLS_CC); \(=$1; Z_LVAL(\).u.constant)++; zend_do_receive_arg(ZEND_RECV, &amp;tmp, &amp;\(, NULL, &amp;$3, &amp;$4, 0 TSRMLS_CC); }<br />
	|	non_empty_parameter_list ',' optional_class_type '&amp;' T_VARIABLE　　　　　　　　　　　　{ znode tmp;  fetch_simple_variable(&amp;tmp, &amp;$5, 0 TSRMLS_CC);\)=$1; Z_LVAL(\(.u.constant)++; zend_do_receive_arg(ZEND_RECV, &amp;tmp, &amp;\), NULL, &amp;$3, &amp;$5, 1 TSRMLS_CC); }<br />
	|	non_empty_parameter_list ‘,’ optional_class_type ‘&amp;’ T_VARIABLE	 ‘=’ static_scalar　{ znode tmp;  fetch_simple_variable(&amp;tmp, &amp;$5, 0 TSRMLS_CC); \(=$1; Z_LVAL(\).u.constant)++; zend_do_receive_arg(ZEND_RECV_INIT, &amp;tmp, &amp;\(, &amp;$7, &amp;$3, &amp;$5, 1 TSRMLS_CC); }<br />
	|	non_empty_parameter_list ',' optional_class_type T_VARIABLE '=' static_scalar　　　　{ znode tmp;  fetch_simple_variable(&amp;tmp, &amp;$4, 0 TSRMLS_CC);\)=$1; Z_LVAL(\(.u.constant)++; zend_do_receive_arg(ZEND_RECV_INIT, &amp;tmp, &amp;\), &amp;$6, &amp;$3, &amp;$4, 0 TSRMLS_CC); }<br />
;<br />
这里并没有截取完整，主要是缺少函数体内语句的语法分析，但已经足够我们弄清楚编译过程中的一些细节。</p><br />
<br />
<p>函数体内的语句，其对应的语法为inner_statement_list。inner_statement_list和函数体之外一般的语句并无二致，可以简单当成普通的语句来编译。</p><br />
<br />
<p>最重要的是看下unticked_function_declaration_statement，它定义了函数语法的骨架，同时还可以看出，函数编译中会执行zend_do_begin_function_declaration以及zend_do_end_function_declaration。这两步分别对应着下文提到的开始编译和结束编译。我们先来看zend_do_begin_function_declaration。</p><br />
<br />
<p>2、开始编译<br />
当zend vm的语法分析器遇到一段函数声明时，会尝试开始编译函数，这是通过执行zend_do_begin_function_declaration来完成的。</p><br />
<br />
<p>有两点：</p><br />
<br />
<p>1，函数是否返回引用，通过is_reference判断。可以看到在对is_reference进行语法分析时，可能会将op_type赋予ZEND_RETURN_VAL或ZEND_RETURN_REF。根据我们文章开始给出的php代码示例，函数foo并不返回引用，因此这里$2.op_type为ZEND_RETURN_VAL。</p><br />
<br />
<p>话说由 function &amp; func_name() { … } 这种形式来决定是否返回引用，已经很古老了，还是在CI框架中见过，现在很少这么写。但是php做了兼容，所以即使采用这种很陈旧的语法，也能够被正确识别。</p><br />
<br />
<p>2，zend_do_begin_function_declaration接受的第一个参数，是对function字面进行词法分析生成的znode。这个znode被使用得非常巧妙，因为在编译函数时，zend vm必须将CG(active_op_array)切换成函数自己的op_array，以便于存储函数的编译结果，当函数编译完成之后，zend vm又需要将将CG(active_op_array)恢复成函数体外层的op_array。利用该znode保存函数体外的op_array，可以很方便的在函数编译结束时进行CG(active_op_array)恢复，具体后面会讲到。</p><br />
<br />
<p>研究下zend_do_begin_function_declaration的实现，比较长，我们分段来看：</p><br />
<br />
<p>// 声明函数会变编译成的op_array<br />
zend_op_array op_array;</p><br />
<br />
<p>// 函数名、长度、起始行数<br />
char *name = function_name-&gt;u.constant.value.str.val;<br />
int name_len = function_name-&gt;u.constant.value.str.len;<br />
int function_begin_line = function_token-&gt;u.opline_num;<br />
zend_uint fn_flags;<br />
char *lcname;<br />
zend_bool orig_interactive;<br />
ALLOCA_FLAG(use_heap)</p><br />
<br />
<p>if (is_method) {<br />
    …<br />
} else {<br />
    fn_flags = 0;<br />
}</p><br />
<br />
<p>// 对函数来说，fn_flags没用，对方法来说，fn_flags指定了方法的修饰符<br />
if ((fn_flags &amp; ZEND_ACC_STATIC) &amp;&amp; (fn_flags &amp; ZEND_ACC_ABSTRACT) &amp;&amp; !(CG(active_class_entry)-&gt;ce_flags &amp; ZEND_ACC_INTERFACE)) {<br />
    zend_error(E_STRICT, “Static function %s%s%s() should not be abstract”, is_method ? CG(active_class_entry)-&gt;name : “”, is_method ? “::” : “”, Z_STRVAL(function_name-&gt;u.constant));<br />
}<br />
这段代码一开始就印证了我们先前的说法，每个函数都有一份自己的op_array。所以会在开头先声明一个op_array变量。</p><br />
<br />
<p>// 第一个znode参数的妙处，它记录了当前的CG(active_op_array)<br />
function_token-&gt;u.op_array = CG(active_op_array);<br />
lcname = zend_str_tolower_dup(name, name_len);</p><br />
<br />
<p>// 对op_array进行初始化，强制op_array.fn_flags会被初始化为0<br />
orig_interactive = CG(interactive);<br />
CG(interactive) = 0;<br />
init_op_array(&amp;op_array, ZEND_USER_FUNCTION, INITIAL_OP_ARRAY_SIZE TSRMLS_CC);<br />
CG(interactive) = orig_interactive;</p><br />
<br />
<p>// 对op_array的一些设置<br />
op_array.function_name = name;<br />
op_array.return_reference = return_reference;<br />
op_array.fn_flags |= fn_flags;<br />
op_array.pass_rest_by_reference = 0;<br />
op_array.scope = is_method ? CG(active_class_entry):NULL;<br />
op_array.prototype = NULL;<br />
op_array.line_start = zend_get_compiled_lineno(TSRMLS_C);<br />
function_token便是对function字面进行词法分析而生成的znode。这段代码一开始，就让它保存当前的CG(active_op_array)，即函数体之外的op_array。保存好CG(active_op_array)之后，便会开始对函数自己的op_array进行初始化。</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>op_array.fn_flags是个多功能字段，还记得上一篇中提到的交互式么，如果php以交互式打开，则op_array.fn_flags会被初始化为ZEND_ACC_INTERACTIVE，否则会被初始化为0。这里在init_op_array之前设置CG(interactive) = 0，便是确保op_array.fn_flags初始化为0。随后会进一步执行op_array.fn_flags</td><br />
      <td>= fn_flags，如果是在方法中，则op_array.fn_flags含义为static、abstract、final等修饰符，对函数来讲，op_array.fn_flags依然是0。</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>zend_op *opline = get_next_op(CG(active_op_array) TSRMLS_CC);</p><br />
<br />
<p>// 如果处于命名空间，则函数名还需要加上命名空间<br />
if (CG(current_namespace)) {<br />
    /* Prefix function name with current namespace name */<br />
    znode tmp;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>tmp.u.constant = *CG(current_namespace);<br />
zval_copy_ctor(&amp;tmp.u.constant);<br />
zend_do_build_namespace_name(&amp;tmp, &amp;tmp, function_name TSRMLS_CC);<br />
op_array.function_name = Z_STRVAL(tmp.u.constant);<br />
efree(lcname);<br />
name_len = Z_STRLEN(tmp.u.constant);<br />
lcname = zend_str_tolower_dup(Z_STRVAL(tmp.u.constant), name_len); }<br />
</code></pre></div></div><br />
<br />
<p>// 设置opline<br />
opline-&gt;opcode = ZEND_DECLARE_FUNCTION;<br />
// 第一个操作数<br />
opline-&gt;op1.op_type = IS_CONST;<br />
build_runtime_defined_function_key(&amp;opline-&gt;op1.u.constant, lcname, name_len TSRMLS_CC);<br />
// 第二个操作数<br />
opline-&gt;op2.op_type = IS_CONST;<br />
opline-&gt;op2.u.constant.type = IS_STRING;<br />
opline-&gt;op2.u.constant.value.str.val = lcname;<br />
opline-&gt;op2.u.constant.value.str.len = name_len;<br />
Z_SET_REFCOUNT(opline-&gt;op2.u.constant, 1);<br />
opline-&gt;extended_value = ZEND_DECLARE_FUNCTION;</p><br />
<br />
<p>// 切换CG(active_op_array)成函数自己的op_array<br />
zend_hash_update(CG(function_table), opline-&gt;op1.u.constant.value.str.val, opline-&gt;op1.u.constant.value.str.len, &amp;op_array, sizeof(zend_op_array), (void **) &amp;CG(active_op_array));<br />
上面这段代码很关键。有几点要说明的：</p><br />
<br />
<p>1，如果函数是处于命名空间中，则其名称会被扩展成命名空间\函数名。比如：</p><br />
<br />
<p>&lt;?php<br />
namespace MyProject;</p><br />
<br />
<p>function foo($arg1, $arg2 = 100)<br />
{<br />
    print($arg1);<br />
}<br />
则会将函数名改为MyProject\foo。扩展工作由zend_do_build_namespace_name来完成。</p><br />
<br />
<p>2，build_runtime_defined_function_key会生成一个“key”。除了用到函数名称之外，还用到了函数所在文件路径、代码在内存中的地址等等。具体的实现可以自行阅读。将函数放进CG(function_table)时，用的键便是这个“key”。</p><br />
<br />
<p>以我的机器为例，上述函数foo生成的key为：</p><br />
<br />
<p>00foo/home/work/foo.php00ABEBBF<br />
从这个key中能直观的看出函数名，所在文件路径这两个信息。</p><br />
<br />
<p>3，代码中的op_line获取时，尚未发生CG(active_op_array)的切换。也就是说，op_line依然是外层op_array的一条指令。该指令具体为ZEND_DECLARE_FUNCTION，有两个操作数，第一个操作数保存了第二点中提到的“key”，第二个操作数则保存了形如”myproject\foo”这样的函数名（小写）。</p><br />
<br />
<p>4，这段代码的最后，将函数自身对应的op_array存放进了CG(function_table)，同时，完成了CG(active_op_array)的切换。从这条语句开始，CG(active_op_array)便开始指向函数自己的op_array，而不再是函数体外层的op_array了。</p><br />
<br />
<p>继续来看zend_do_begin_function_declaration的最后一段：</p><br />
<br />
<p>// 需要debuginfo，则函数体内的第一条zend_op，为ZEND_EXT_NOP<br />
if (CG(compiler_options) &amp; ZEND_COMPILE_EXTENDED_INFO) {<br />
    zend_op *opline = get_next_op(CG(active_op_array) TSRMLS_CC);</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>opline-&gt;opcode = ZEND_EXT_NOP;<br />
opline-&gt;lineno = function_begin_line;<br />
SET_UNUSED(opline-&gt;op1);<br />
SET_UNUSED(opline-&gt;op2); }<br />
</code></pre></div></div><br />
<br />
<p>// 控制switch和foreach内声明的函数<br />
{<br />
    /* Push a seperator to the switch and foreach stacks */<br />
    zend_switch_entry switch_entry;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>switch_entry.cond.op_type = IS_UNUSED;<br />
switch_entry.default_case = 0;<br />
switch_entry.control_var = 0;<br />
<br />
zend_stack_push(&amp;CG(switch_cond_stack), (void *) &amp;switch_entry, sizeof(switch_entry));<br />
<br />
{<br />
    /* Foreach stack separator */<br />
    zend_op dummy_opline;<br />
<br />
    dummy_opline.result.op_type = IS_UNUSED;<br />
    dummy_opline.op1.op_type = IS_UNUSED;<br />
<br />
    zend_stack_push(&amp;, (void *) &amp;dummy_opline, sizeof(zend_op));<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>// 保存函数的注释语句<br />
if (CG(doc_comment)) {<br />
    CG(active_op_array)-&gt;doc_comment = CG(doc_comment);<br />
    CG(active_op_array)-&gt;doc_comment_len = CG(doc_comment_len);<br />
    CG(doc_comment) = NULL;<br />
    CG(doc_comment_len) = 0;<br />
}</p><br />
<br />
<p>// 作用和上面switch，foreach是一样的，函数体内的语句并不属于函数体外的label<br />
zend_stack_push(&amp;CG(labels_stack), (void <em>) &amp;CG(labels), sizeof(HashTable</em>));<br />
CG(labels) = NULL;<br />
可能初学者会对CG(switch_cond_stack)，CG(foreach_copy_stack)，CG(labels_stack)等字段有疑惑。其实也很好理解。以CG(labels_stack)为例，由于进入函数体内之后，op_array发生了切换，外层的CG(active_op_array)被保存到function znode的u.op_array中（如果记不清楚了回头看上文:-)）。因此函数外层已经被parse出的一些label也需要被保存下来，用的正是CG(labels_stack)来保存。当函数体完成编译之后，zend vm可以从CG(labels_stack)中恢复出原先的label。举例来说，</p><br />
<br />
<p>&lt;?php<br />
label1:<br />
function foo($arg1)<br />
{<br />
    print($arg1);<br />
    goto label2;</p><br />
<br />
<p>label2:<br />
    exit;<br />
}</p><br />
<br />
<p>$bar = ‘hello php’;<br />
foo($bar);<br />
解释器在进入zend_do_begin_function_declaration时，CG(labels)中保存的是“label1”。当解释器开始编译函数foo，则需要将“label1”保存到CG(labels_stack)中，同时清空CG(labels)。因为在编译foo的过程中，CG(labels)会保存“labe2”。当foo编译完成，会利用CG(labels_stack)来恢复CG(labels)，则CG(labels)再次变成“label1”。</p><br />
<br />
<p>至此，整个zend_do_begin_function_declaration过程已经全部分析完成。最重要的是，一旦完成zend_do_begin_function_declaration，CG(active_op_array)就指向了函数自身对应的op_array。同时，也利用生成的“key”在CG(function_table)中替函数占了一个位。</p><br />
<br />
<p>3、编译参数列表<br />
函数可以定义为不接受任何参数，对于参数列表为空的情况，其实不做任何处理。我们前文的例子foo函数，接受了一个参数$arg1，我们下面还是分析有参数的情况。</p><br />
<br />
<p>根据语法推导式non_empty_parameter_list的定义，参数列表一共有8种，前4种对应的是一个参数，后4种对应多个参数。我们只关心前4种，后4种编译的过程，仅仅是重复前4种的步骤而已。</p><br />
<br />
<p>optional_class_type T_VARIABLE				{ znode tmp;  fetch_simple_variable(&amp;tmp, &amp;$2, 0 TSRMLS_CC); \(.op_type = IS_CONST; Z_LVAL(\).u.constant)=1; Z_TYPE(\(.u.constant)=IS_LONG; INIT_PZVAL(&amp;\).u.constant); zend_do_receive_arg(ZEND_RECV, &amp;tmp, &amp;\(, NULL, &amp;$1, &amp;$2, 0 TSRMLS_CC); }<br />
optional_class_type '&amp;' T_VARIABLE			{ znode tmp;  fetch_simple_variable(&amp;tmp, &amp;$3, 0 TSRMLS_CC);\).op_type = IS_CONST; Z_LVAL(\(.u.constant)=1; Z_TYPE(\).u.constant)=IS_LONG; INIT_PZVAL(&amp;\(.u.constant); zend_do_receive_arg(ZEND_RECV, &amp;tmp, &amp;\), NULL, &amp;$1, &amp;$3, 1 TSRMLS_CC); }<br />
optional_class_type ‘&amp;’ T_VARIABLE ‘=’ static_scalar	{ znode tmp;  fetch_simple_variable(&amp;tmp, &amp;$3, 0 TSRMLS_CC); \(.op_type = IS_CONST; Z_LVAL(\).u.constant)=1; Z_TYPE(\(.u.constant)=IS_LONG; INIT_PZVAL(&amp;\).u.constant); zend_do_receive_arg(ZEND_RECV_INIT, &amp;tmp, &amp;\(, &amp;$5, &amp;$1, &amp;$3, 1 TSRMLS_CC); }<br />
optional_class_type T_VARIABLE '=' static_scalar	{ znode tmp;  fetch_simple_variable(&amp;tmp, &amp;$2, 0 TSRMLS_CC);\).op_type = IS_CONST; Z_LVAL(\(.u.constant)=1; Z_TYPE(\).u.constant)=IS_LONG; INIT_PZVAL(&amp;\(.u.constant); zend_do_receive_arg(ZEND_RECV_INIT, &amp;tmp, &amp;\), &amp;$4, &amp;$1, &amp;$2, 0 TSRMLS_CC); }<br />
前4种情况，具体又可以分为2类，1类没有默认值，区别只在于参数的传递是否采用引用，而另1类，都有默认值“static_scalar”。</p><br />
<br />
<p>实际上区别并不大，它们的语法分析的处理过程也几乎一致。都是先调用fetch_simple_variable，再执行zend_do_receive_arg。有没有默认值，区别也仅仅在于zend_do_receive_arg的参数，会不会将默认值传递进去。先来看fetch_simple_variable。</p><br />
<br />
<p>3.1 fetch_simple_variable<br />
fetch_simple_variable是用来获取compiled variables索引的。compiled variables被视作php的性能提升手段之一，因为它利用数组存储了变量，而并非内核中普遍使用的HashTable。这里可以看出，函数的任何一个参数，均会被编译为compiled variables，compiled variables被保存在函数体op_array-&gt;vars数组中。虽然根据变量名称去HashTable查询，效率并不低。但显然根据索引去op_array-&gt;vars数组中获取变量，会更加高效。</p><br />
<br />
<p>void fetch_simple_variable_ex(znode <em>result, znode *varname, int bp, zend_uchar op TSRMLS_DC) /</em> {{{ */<br />
{<br />
    zend_op opline;<br />
    …</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (varname-&gt;op_type == IS_CONST) {<br />
    if (Z_TYPE(varname-&gt;u.constant) != IS_STRING) {<br />
        convert_to_string(&amp;varname-&gt;u.constant);<br />
    }<br />
    if (!zend_is_auto_global(varname-&gt;u.constant.value.str.val, varname-&gt;u.constant.value.str.len TSRMLS_CC) &amp;&amp;<br />
        !(varname-&gt;u.constant.value.str.len == (sizeof("this")-1) &amp;&amp; !memcmp(varname-&gt;u.constant.value.str.val, "this", sizeof("this"))) &amp;&amp;<br />
        (CG(active_op_array)-&gt;last == 0 || CG(active_op_array)-&gt;opcodes[CG(active_op_array)-&gt;last-1].opcode != ZEND_BEGIN_SILENCE)) {<br />
        <br />
        // 节点的类型为IS_CV，表明是compiled variables<br />
        result-&gt;op_type = IS_CV;<br />
        <br />
        // 用u.var来记录compiled variables在CG(active_op_array)-&gt;vars中的索引<br />
        result-&gt;u.var = lookup_cv(CG(active_op_array), varname-&gt;u.constant.value.str.val, varname-&gt;u.constant.value.str.len);<br />
        result-&gt;u.EA.type = 0;<br />
        varname-&gt;u.constant.value.str.val = CG(active_op_array)-&gt;vars[result-&gt;u.var].name;<br />
        return;<br />
    }<br />
}<br />
... } 这里不做详细的分析了。当fetch_simple_variable获取索引之后，znode中就不必再保存变量的名称，取而代之的是变量在vars数组中的索引，即znode-&gt;u.var，其类型为int。fetch_simple_variable完成，会进入zend_do_receive_arg。<br />
</code></pre></div></div><br />
<br />
<p>3.2 zend_do_receive_arg<br />
zend_do_receive_arg目的是生成一条zend op指令，可以称作RECV。</p><br />
<br />
<p>一般而言，除非函数不存在参数，否则RECV是函数的第一条指令（这里表述不准，有extend info时也不是第一条）。该指令的opcode可能为ZEND_RECV或者ZEND_RECV_INIT，取决于是否有默认值。如果参数没有默认值，指令等于ZEND_RECV，有默认值，则为ZEND_RECV_INIT。zend_do_receive_arg的第二个参数，就是上面提到的compiled variables节点。</p><br />
<br />
<p>分析下zend_do_receive_arg的源码，也是分几段来看：</p><br />
<br />
<p>zend_op *opline;<br />
zend_arg_info *cur_arg_info;</p><br />
<br />
<p>// class_type主要用于限制函数参数的类型<br />
if (class_type-&gt;op_type == IS_CONST &amp;&amp; Z_TYPE(class_type-&gt;u.constant) == IS_STRING &amp;&amp; Z_STRLEN(class_type-&gt;u.constant) == 0) {<br />
    /* Usage of namespace as class name not in namespace */<br />
    zval_dtor(&amp;class_type-&gt;u.constant);<br />
    zend_error(E_COMPILE_ERROR, “Cannot use ‘namespace’ as a class name”);<br />
    return;<br />
}</p><br />
<br />
<p>// 对静态方法来说，参数不能为this<br />
if (var-&gt;op_type == IS_CV &amp;&amp; var-&gt;u.var == CG(active_op_array)-&gt;this_var &amp;&amp; (CG(active_op_array)-&gt;fn_flags &amp; ZEND_ACC_STATIC) == 0) {<br />
    zend_error(E_COMPILE_ERROR, “Cannot re-assign $this”);<br />
} else if (var-&gt;op_type == IS_VAR &amp;&amp; CG(active_op_array)-&gt;scope &amp;&amp; ((CG(active_op_array)-&gt;fn_flags &amp; ZEND_ACC_STATIC) == 0) &amp;&amp; (Z_TYPE(varname-&gt;u.constant) == IS_STRING) &amp;&amp; (Z_STRLEN(varname-&gt;u.constant) == sizeof(“this”)-1) &amp;&amp; (memcmp(Z_STRVAL(varname-&gt;u.constant), “this”, sizeof(“this”)) == 0)) {<br />
    zend_error(E_COMPILE_ERROR, “Cannot re-assign $this”);<br />
}</p><br />
<br />
<p>// CG(active_op_array)此时已经是函数体的op_array了，这里拿一条指令<br />
opline = get_next_op(CG(active_op_array) TSRMLS_CC);<br />
CG(active_op_array)-&gt;num_args++;<br />
opline-&gt;opcode = op;<br />
opline-&gt;result = *var;</p><br />
<br />
<p>// op1节点表明是第几个参数<br />
opline-&gt;op1 = *offset;</p><br />
<br />
<p>// op2节点可能为初始值，也可能为UNUSED<br />
if (op == ZEND_RECV_INIT) {<br />
    opline-&gt;op2 = *initialization;<br />
} else {<br />
    CG(active_op_array)-&gt;required_num_args = CG(active_op_array)-&gt;num_args;<br />
    SET_UNUSED(opline-&gt;op2);<br />
}<br />
上面这段代码，首先通过get_next_op(CG(active_op_array) TSRMLS_CC)一句获取了opline，opline是未被使用的一条zend_op指令。紧接着，会对opline的各个字段进行设置。opline-&gt;op1表明这是第几个参数，opline-&gt;op2可能为初始值，也可能被设置为UNUSED。</p><br />
<br />
<p>如果一个参数有默认值，那么在调用函数时，其实是可以不用传递该参数的。所以，required_num_args不会将这类非必须的参数算进去的。可以看到，在op == ZEND_RECV_INIT这段逻辑分支中，并没有处理required_num_args。</p><br />
<br />
<p>继续来看：</p><br />
<br />
<p>// 这里采用erealloc进行分配，因为期望最终会形成一个参数信息的数组<br />
CG(active_op_array)-&gt;arg_info = erealloc(CG(active_op_array)-&gt;arg_info, sizeof(zend_arg_info)*(CG(active_op_array)-&gt;num_args));</p><br />
<br />
<p>// 设置当前的zend_arg_info<br />
cur_arg_info = &amp;CG(active_op_array)-&gt;arg_info[CG(active_op_array)-&gt;num_args-1];<br />
cur_arg_info-&gt;name = estrndup(varname-&gt;u.constant.value.str.val, varname-&gt;u.constant.value.str.len);<br />
cur_arg_info-&gt;name_len = varname-&gt;u.constant.value.str.len;<br />
cur_arg_info-&gt;array_type_hint = 0;<br />
cur_arg_info-&gt;allow_null = 1;<br />
cur_arg_info-&gt;pass_by_reference = pass_by_reference;<br />
cur_arg_info-&gt;class_name = NULL;<br />
cur_arg_info-&gt;class_name_len = 0;</p><br />
<br />
<p>// 如果需要对参数做类型限定<br />
if (class_type-&gt;op_type != IS_UNUSED) {<br />
    cur_arg_info-&gt;allow_null = 0;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 限定为类<br />
if (class_type-&gt;u.constant.type == IS_STRING) {<br />
    if (ZEND_FETCH_CLASS_DEFAULT == zend_get_class_fetch_type(Z_STRVAL(class_type-&gt;u.constant), Z_STRLEN(class_type-&gt;u.constant))) {<br />
        zend_resolve_class_name(class_type, &amp;opline-&gt;extended_value, 1 TSRMLS_CC);<br />
    }<br />
    cur_arg_info-&gt;class_name = class_type-&gt;u.constant.value.str.val;<br />
    cur_arg_info-&gt;class_name_len = class_type-&gt;u.constant.value.str.len;<br />
    <br />
    // 如果限定为类，则参数的默认值只能为NULL<br />
    if (op == ZEND_RECV_INIT) {<br />
        if (Z_TYPE(initialization-&gt;u.constant) == IS_NULL || (Z_TYPE(initialization-&gt;u.constant) == IS_CONSTANT &amp;&amp; !strcasecmp(Z_STRVAL(initialization-&gt;u.constant), "NULL"))) {<br />
            cur_arg_info-&gt;allow_null = 1;<br />
        } else {<br />
            zend_error(E_COMPILE_ERROR, "Default value for parameters with a class type hint can only be NULL");<br />
        }<br />
    }<br />
}<br />
// 限定为数组<br />
else {<br />
    // 将array_type_hint设置为1<br />
    cur_arg_info-&gt;array_type_hint = 1;<br />
    cur_arg_info-&gt;class_name = NULL;<br />
    cur_arg_info-&gt;class_name_len = 0;<br />
    <br />
    // 如果限定为数组，则参数的默认值只能为数组或NULL<br />
    if (op == ZEND_RECV_INIT) {<br />
        if (Z_TYPE(initialization-&gt;u.constant) == IS_NULL || (Z_TYPE(initialization-&gt;u.constant) == IS_CONSTANT &amp;&amp; !strcasecmp(Z_STRVAL(initialization-&gt;u.constant), "NULL"))) {<br />
            cur_arg_info-&gt;allow_null = 1;<br />
        } else if (Z_TYPE(initialization-&gt;u.constant) != IS_ARRAY &amp;&amp; Z_TYPE(initialization-&gt;u.constant) != IS_CONSTANT_ARRAY) {<br />
            zend_error(E_COMPILE_ERROR, "Default value for parameters with array type hint can only be an array or NULL");<br />
        }<br />
    }<br />
} } opline-&gt;result.u.EA.type |= EXT_TYPE_UNUSED; 这部分代码写的很清晰。注意，对于限定为数组的情况，class_type的op_type会被设置为IS_CONST，而u.constant.type会被设置为IS_NULL：<br />
</code></pre></div></div><br />
<br />
<p>optional_class_type:<br />
		/* empty */			{ \(.op_type = IS_UNUSED; }<br />
	|	fully_qualified_class_name	{\) = $1; }<br />
	|	T_ARRAY				{ \(.op_type = IS_CONST; Z_TYPE(\).u.constant)=IS_NULL;}<br />
因此，zend_do_receive_arg中区分限定为类还是数组，是利用class_type-&gt;u.constant.type == IS_STRING来判断的。如果类型限定为数组，则cur_arg_info-&gt;array_type_hint会被设置为1。</p><br />
<br />
<p>还有另一个地方需要了解，zend_resolve_class_name函数会修正类名。举例来说：</p><br />
<br />
<p>&lt;?php<br />
namespace A;<br />
class B { }<br />
function foo(B $arg1, $arg2 = 100)<br />
{<br />
    print($arg1);<br />
}<br />
我们期望参数arg1的类型为B，class_type中也保存了B。但是因为位于命名空间A下，所以，zend_resolve_class_name会将class_type中保存的类名B，修正为A\B。</p><br />
<br />
<p>OK，到这里，zend_do_receive_arg已经全部分析完。zend vm在分析函数参数时，每遇见一个参数，便会调用一次zend_do_receive_arg，生成一条RECV指令。因此，函数有几个参数，就会编译出几条RECV指令。</p><br />
<br />
<p>4、编译函数体<br />
当编译完参数列表，zend vm便会进入函数内部了。函数体的编译其实和正常语句的编译一样。zend vm只需要将函数体内部的php语句，按照正常的statment，进行词法分析、语法分析来处理，最终形成一条条zend_op指令。</p><br />
<br />
<p>来看下语法文件：</p><br />
<br />
<p>unticked_function_declaration_statement:<br />
	function is_reference T_STRING { zend_do_begin_function_declaration(&amp;$1, &amp;$3, 0, $2.op_type, NULL TSRMLS_CC); }<br />
	‘(‘ parameter_list ‘)’ ‘{‘ inner_statement_list ‘}’ { zend_do_end_function_declaration(&amp;$1 TSRMLS_CC); }<br />
;<br />
函数体内部的语句，表示为inner_statement_list。</p><br />
<br />
<p>inner_statement_list:<br />
		inner_statement_list  { zend_do_extended_info(TSRMLS_C); } inner_statement { HANDLE_INTERACTIVE(); }<br />
	|	/* empty */<br />
;<br />
而inner_statment正是由语句、函数声明、类声明组成的。</p><br />
<br />
<p>inner_statement:<br />
		statement<br />
	|	function_declaration_statement<br />
	|	class_declaration_statement<br />
	|	T_HALT_COMPILER ‘(‘ ‘)’ ‘;’   { zend_error(E_COMPILE_ERROR, “__HALT_COMPILER() can only be used from the outermost scope”); }<br />
;<br />
inner_statement并非专门用于函数，其他譬如foreach，while循环等有block语句块中，都会被识别为inner_statement。从这里其实还能看到一些有意思的语法，比如说我们可以在函数里声明一个类。inner_statement就不展开叙述了，否则相当于将整个php的语法捋一遍，情况太多了。</p><br />
<br />
<p>5、结束编译<br />
我们最后来看下结束编译的过程。结束函数编译是通过zend_do_end_function_declaration来完成的。</p><br />
<br />
<p>zend_do_end_function_declaration接收的参数function_token，其实就是前面提到过的function字面对应的znode。根据我们在“开始编译”一节所述，function_token中保留了函数体之外的op_array。</p><br />
<br />
<p>char lcname[16];<br />
int name_len;</p><br />
<br />
<p>zend_do_extended_info(TSRMLS_C);</p><br />
<br />
<p>// 返回NULL<br />
zend_do_return(NULL, 0 TSRMLS_CC);</p><br />
<br />
<p>// 通过op指令设置对应的handler函数<br />
pass_two(CG(active_op_array) TSRMLS_CC);</p><br />
<br />
<p>// 释放当前函数的CG(labels)，并从CG(labels_stack)中还原之前的CG(labels)<br />
zend_release_labels(TSRMLS_C);</p><br />
<br />
<p>if (CG(active_class_entry)) {<br />
    // 检查魔术方法的参数是否合法<br />
    zend_check_magic_method_implementation(CG(active_class_entry), (zend_function<em>)CG(active_op_array), E_COMPILE_ERROR TSRMLS_CC);<br />
} else {<br />
    /</em> we don’t care if the function name is longer, in fact lowercasing only <br />
     * the beginning of the name speeds up the check process <em>/<br />
    name_len = strlen(CG(active_op_array)-&gt;function_name);<br />
    zend_str_tolower_copy(lcname, CG(active_op_array)-&gt;function_name, MIN(name_len, sizeof(lcname)-1));<br />
    lcname[sizeof(lcname)-1] = ‘\0’; /</em> zend_str_tolower_copy won’t necessarily set the zero byte */</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 检查__autoload函数的参数是否合法<br />
if (name_len == sizeof(ZEND_AUTOLOAD_FUNC_NAME) - 1 &amp;&amp; !memcmp(lcname, ZEND_AUTOLOAD_FUNC_NAME, sizeof(ZEND_AUTOLOAD_FUNC_NAME)) &amp;&amp; CG(active_op_array)-&gt;num_args != 1) {<br />
    zend_error(E_COMPILE_ERROR, "%s() must take exactly 1 argument", ZEND_AUTOLOAD_FUNC_NAME);<br />
}         }<br />
</code></pre></div></div><br />
<br />
<p>CG(active_op_array)-&gt;line_end = zend_get_compiled_lineno(TSRMLS_C);</p><br />
<br />
<p>// 很关键！将CG(active_op_array)还原成函数外层的op_array<br />
CG(active_op_array) = function_token-&gt;u.op_array;</p><br />
<br />
<p>/* Pop the switch and foreach seperators */<br />
zend_stack_del_top(&amp;CG(switch_cond_stack));<br />
zend_stack_del_top(&amp;CG(foreach_copy_stack));<br />
有3处值得注意：</p><br />
<br />
<p>1，zend_do_end_function_declaration中会对CG(active_op_array)进行还原。用的正是function_token-&gt;u.op_array。一旦zend_do_end_function_declaration完成，函数的整个编译过程就已经结束了。zend vm会继续看接下来函数之外的代码，所以需要将CG(active_op_array)切换成原先的。</p><br />
<br />
<p>2，zend_do_return负责在函数最后添加上一条RETURN指令，因为我们传进去的是NULL，所以这条RETURN指令的操作数被强制设置为UNUSED。注意，不管函数本身是否有return语句，最后这条RETURN指令是必然存在的。假如函数有return语句，return语句也会产生一条RETURN指令，所以会导致可能出现多条RETURN指令。举例来说：</p><br />
<br />
<p>function foo()<br />
{<br />
    return true;<br />
}<br />
编译出来的OP指令最后两条如下：</p><br />
<br />
<p>RETURN        true<br />
 RETURN        null<br />
我们可以很明显在最后看到两条RETURN。一条是通过return true编译出来的。另一条，就是在zend_do_end_function_declaration阶段，强制插入的RETURN。</p><br />
<br />
<p>3，我们刚才讲解的所有步骤中，都只是设置了每条指令的opcode，而并没有设置这条指令具体的handle函数。pass_two会负责遍历每条zend_op指令，根据opcode，以及操作数op1和op2，去查找并且设置对应的handle函数。这项工作，是通过ZEND_VM_SET_OPCODE_HANDLER(opline)宏来完成的。</p><br />
<br />
<p>#define ZEND_VM_SET_OPCODE_HANDLER(opline) zend_vm_set_opcode_handler(opline)<br />
zend_vm_set_opcode_handler的实现很简单：</p><br />
<br />
<p>void zend_init_opcodes_handlers(void)<br />
{<br />
    // 超大的数组，里面存放了所有的handler<br />
    static const opcode_handler_t labels[] = {<br />
        ZEND_NOP_SPEC_HANDLER,<br />
        ZEND_NOP_SPEC_HANDLER,<br />
        ZEND_NOP_SPEC_HANDLER,<br />
        ZEND_NOP_SPEC_HANDLER,<br />
        ZEND_NOP_SPEC_HANDLER,<br />
        ZEND_NOP_SPEC_HANDLER,<br />
        …<br />
    };<br />
    zend_opcode_handlers = (opcode_handler_t*)labels;<br />
}</p><br />
<br />
<p>static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode, zend_op* op)<br />
{<br />
        static const int zend_vm_decode[] = {<br />
            _UNUSED_CODE, /* 0              <em>/<br />
            _CONST_CODE,  /</em> 1 = IS_CONST   <em>/<br />
            _TMP_CODE,    /</em> 2 = IS_TMP_VAR <em>/<br />
            _UNUSED_CODE, /</em> 3              <em>/<br />
            _VAR_CODE,    /</em> 4 = IS_VAR     <em>/<br />
            _UNUSED_CODE, /</em> 5              <em>/<br />
            _UNUSED_CODE, /</em> 6              <em>/<br />
            _UNUSED_CODE, /</em> 7              <em>/<br />
            _UNUSED_CODE, /</em> 8 = IS_UNUSED  <em>/<br />
            _UNUSED_CODE, /</em> 9              <em>/<br />
            _UNUSED_CODE, /</em> 10             <em>/<br />
            _UNUSED_CODE, /</em> 11             <em>/<br />
            _UNUSED_CODE, /</em> 12             <em>/<br />
            _UNUSED_CODE, /</em> 13             <em>/<br />
            _UNUSED_CODE, /</em> 14             <em>/<br />
            _UNUSED_CODE, /</em> 15             <em>/<br />
            _CV_CODE      /</em> 16 = IS_CV     */<br />
        };</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // 去handler数组里找到对应的处理函数<br />
    return zend_opcode_handlers[opcode * 25 + zend_vm_decode[op-&gt;op1.op_type] * 5 + zend_vm_decode[op-&gt;op2.op_type]]; }<br />
</code></pre></div></div><br />
<br />
<p>ZEND_API void zend_vm_set_opcode_handler(zend_op* op)<br />
{<br />
    // 给zend op设置对应的handler函数<br />
    op-&gt;handler = zend_vm_get_opcode_handler(zend_user_opcodes[op-&gt;opcode], op);<br />
}<br />
所有的opcode都定义在zend_vm_opcodes.h里，从php5.3-php5.6，大概从150增长到170个opcode。上面可以看到通过opcode查找handler的准确算法：</p><br />
<br />
<p>zend_opcode_handlers[opcode * 25 + zend_vm_decode[op-&gt;op1.op_type] * 5 + zend_vm_decode[op-&gt;op2.op_type]<br />
不过zend_opcode_handlers数组太大了…找起来很麻烦。</p><br />
<br />
<p>下面回到文章开始的那段php代码，我们将函数foo进行编译，最终得到的指令如下：</p><br />
<br />
<p>可以看出，因为foo指接受一个参数，所以这里只有一条RECV指令。</p><br />
<br />
<p>print语句的参数为!0，!0是一个compiled variables，其实就是参数中的arg1。0代表着索引，回忆一下，函数的op_array有一个数组专门用于保存compiled variables，0表明arg1位于该数组的开端。</p><br />
<br />
<p>print语句有返回值，所以会存在一个临时变量保存其返回值，即~0。由于我们在函数中并未使用~0，所以随即便会有一条FREE指令对其进行释放。</p><br />
<br />
<p>在函数的最后，是一条RETURN指令。</p><br />
<br />
<p>6、绑定<br />
函数编译完成之后，还需要进行的一步是绑定。zend vm通过zend_do_early_binding来实现绑定。这个名字容易让人产生疑惑，其实只有在涉及到类和方法的时候，才会有早期绑定，与之相对的是延迟绑定，或者叫后期绑定。纯粹函数谈不上这种概念，不过zend_do_early_binding是多功能的，并非仅仅为绑定方法而实现。</p><br />
<br />
<p>来看下zend_do_early_binding：</p><br />
<br />
<p>// 拿到的是最近一条zend op，对于函数来说，就是ZEND_DECLARE_FUNCTION<br />
zend_op *opline = &amp;CG(active_op_array)-&gt;opcodes[CG(active_op_array)-&gt;last-1];<br />
HashTable *table;</p><br />
<br />
<p>while (opline-&gt;opcode == ZEND_TICKS &amp;&amp; opline &gt; CG(active_op_array)-&gt;opcodes) {<br />
    opline–;<br />
}</p><br />
<br />
<p>switch (opline-&gt;opcode) {<br />
    case ZEND_DECLARE_FUNCTION:<br />
        // 真正绑定函数<br />
        if (do_bind_function(opline, CG(function_table), 1) == FAILURE) {<br />
            return;<br />
        }<br />
        table = CG(function_table);<br />
        break;<br />
    case ZEND_DECLARE_CLASS:<br />
        …<br />
    case ZEND_DECLARE_INHERITED_CLASS:<br />
        …<br />
}</p><br />
<br />
<p>// op1中保存的是函数的key，这里其从将CG(function_table)中删除<br />
zend_hash_del(table, opline-&gt;op1.u.constant.value.str.val, opline-&gt;op1.u.constant.value.str.len);<br />
zval_dtor(&amp;opline-&gt;op1.u.constant);<br />
zval_dtor(&amp;opline-&gt;op2.u.constant);</p><br />
<br />
<p>// opline置为NOP<br />
MAKE_NOP(opline);<br />
这个函数实现也很简单，主要就是调用了do_bind_function。</p><br />
<br />
<p>ZEND_API int do_bind_function(zend_op <em>opline, HashTable *function_table, zend_bool compile_time) /</em> {{{ */<br />
{<br />
    zend_function *function;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 找出函数<br />
zend_hash_find(function_table, opline-&gt;op1.u.constant.value.str.val, opline-&gt;op1.u.constant.value.str.len, (void *) &amp;function);<br />
<br />
// 以函数名称作为key，重新加入function_table<br />
if (zend_hash_add(function_table, opline-&gt;op2.u.constant.value.str.val, opline-&gt;op2.u.constant.value.str.len+1, function, sizeof(zend_function), NULL)==FAILURE) {<br />
    int error_level = compile_time ? E_COMPILE_ERROR : E_ERROR;<br />
    zend_function *old_function;<br />
<br />
    // 加入失败，可能发生重复定义了<br />
    if (zend_hash_find(function_table, opline-&gt;op2.u.constant.value.str.val, opline-&gt;op2.u.constant.value.str.len+1, (void *) &amp;old_function)==SUCCESS<br />
        &amp;&amp; old_function-&gt;type == ZEND_USER_FUNCTION<br />
        &amp;&amp; old_function-&gt;op_array.last &gt; 0) {<br />
        zend_error(error_level, "Cannot redeclare %s() (previously declared in %s:%d)",<br />
                    function-&gt;common.function_name, old_function-&gt;op_array.filename, old_function-&gt;op_array.opcodes[0].lineno);<br />
    } else {<br />
        zend_error(error_level, "Cannot redeclare %s()", function-&gt;common.function_name);<br />
    }<br />
    return FAILURE;<br />
} else {<br />
    (*function-&gt;op_array.refcount)++;<br />
    function-&gt;op_array.static_variables = NULL; /* NULL out the unbound function */<br />
    return SUCCESS;<br />
} } 在进入do_bind_function之前，其实CG(function_table)中已经有了函数的op_array。不过用的键并非函数名，而是build_runtime_defined_function_key生成的“key”，这点在前面“开始编译”一节中有过介绍。do_bind_function所做的事情，正是利用这个“key”，将函数查找出来，并且以真正的函数名为键，重新插入到CG(function_table)中。<br />
</code></pre></div></div><br />
<br />
<p>因此当do_bind_function完成时，function_table中有2个键可以查询到该函数。一个是“key”为索引的，另一个是以函数名为索引的。在zend_do_early_binding的最后，会通过zend_hash_del来删除“key”，从而保证function_table中，该函数只能够以函数名为键值查询到。</p><br />
<br />
<p>7、总结<br />
这篇其实主要是为了弄清楚，函数如何被编译成op_array。一些关键的步骤如下图：<br />
<img src="https://xiazemin.github.io/MyBlog/img/func_opcode.png" /><br />
们前面的章节弄明白了函数体会被编译生成哪些zend_op指令，本章会研究函数调用语句会生成哪些zend_op指，等后面的章节再根据这些op指令，来剖析php运行时的细节。</p><br />
<br />
<p>源码依然取自php5.3.29。</p><br />
<br />
<p>函数调用<br />
回顾之前用的php代码示例：</p><br />
<br />
<p>&lt;?php<br />
function foo($arg1)<br />
{<br />
    print($arg1);<br />
}</p><br />
<br />
<p>$bar = ‘hello php’;<br />
foo($bar);<br />
在函数编译一章里已经分析过，函数foo最终会编译生成对应的zend_function，存放于函数表(CG(function_table))中。</p><br />
<br />
<p>现在开始看 foo($bar); 一句，这应该是最简单的函数调用语句了。其他还有一些形式更为复杂的函数调用，例如以可变变量作为函数名，例如导入的函数以别名进行调用（涉及到命名空间），再例如以引用作为参数，以表达式作为参数，以函数调用本身作为参数等等。</p><br />
<br />
<p>我们从简单的来入手，弄清楚调用语句的编译过程及产出，对于复杂的一些调用，下文也争取都能谈到一些。</p><br />
<br />
<p>1、语法推导<br />
就 foo($bar); 而言，其主要部分语法树为<br />
<img src="https://xiazemin.github.io/MyBlog/img/func_call_opcode.png" /><br />
绿色的节点表示最后对应到php代码中的字面。红色的部分是语法推导过程中最重要的几步，特别是function_call。</p><br />
<br />
<p>我们从语法分析文件zend_language_parser.y中挑出相关的：</p><br />
<br />
<p>function_call:<br />
		namespace_name ‘(‘ { $2.u.opline_num = zend_do_begin_function_call(&amp;$1, 1 TSRMLS_CC); }<br />
				function_call_parameter_list<br />
				‘)’ { zend_do_end_function_call(&amp;$1, &amp;\(, &amp;$4, 0, $2.u.opline_num TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C); }<br />
	|	T_NAMESPACE T_NS_SEPARATOR namespace_name '(' { $1.op_type = IS_CONST; ZVAL_EMPTY_STRING(&amp;$1.u.constant);  zend_do_build_namespace_name(&amp;$1, &amp;$1, &amp;$3 TSRMLS_CC); $4.u.opline_num = zend_do_begin_function_call(&amp;$1, 0 TSRMLS_CC); }<br />
				function_call_parameter_list<br />
				')' { zend_do_end_function_call(&amp;$1, &amp;\), &amp;$6, 0, $4.u.opline_num TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C); }<br />
	|	T_NS_SEPARATOR namespace_name ‘(‘ { $3.u.opline_num = zend_do_begin_function_call(&amp;$2, 0 TSRMLS_CC); }<br />
				function_call_parameter_list<br />
				‘)’ { zend_do_end_function_call(&amp;$2, &amp;\(, &amp;$5, 0, $3.u.opline_num TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C); }<br />
	|	class_name T_PAAMAYIM_NEKUDOTAYIM T_STRING '(' { $4.u.opline_num = zend_do_begin_class_member_function_call(&amp;$1, &amp;$3 TSRMLS_CC); }<br />
			function_call_parameter_list<br />
			')' { zend_do_end_function_call($4.u.opline_num?NULL:&amp;$3, &amp;\), &amp;$6, $4.u.opline_num, $4.u.opline_num TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C);}<br />
	|	class_name T_PAAMAYIM_NEKUDOTAYIM variable_without_objects ‘(‘ { zend_do_end_variable_parse(&amp;$3, BP_VAR_R, 0 TSRMLS_CC); zend_do_begin_class_member_function_call(&amp;$1, &amp;$3 TSRMLS_CC); }<br />
			function_call_parameter_list<br />
			‘)’ { zend_do_end_function_call(NULL, &amp;\(, &amp;$6, 1, 1 TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C);}<br />
	|	variable_class_name T_PAAMAYIM_NEKUDOTAYIM T_STRING '(' { zend_do_begin_class_member_function_call(&amp;$1, &amp;$3 TSRMLS_CC); }<br />
			function_call_parameter_list<br />
			')' { zend_do_end_function_call(NULL, &amp;\), &amp;$6, 1, 1 TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C);}<br />
	|	variable_class_name T_PAAMAYIM_NEKUDOTAYIM variable_without_objects ‘(‘ { zend_do_end_variable_parse(&amp;$3, BP_VAR_R, 0 TSRMLS_CC); zend_do_begin_class_member_function_call(&amp;$1, &amp;$3 TSRMLS_CC); }<br />
			function_call_parameter_list<br />
			‘)’ { zend_do_end_function_call(NULL, &amp;\(, &amp;$6, 1, 1 TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C);}<br />
	|	variable_without_objects  '(' { zend_do_end_variable_parse(&amp;$1, BP_VAR_R, 0 TSRMLS_CC); zend_do_begin_dynamic_function_call(&amp;$1, 0 TSRMLS_CC); }<br />
			function_call_parameter_list ')'<br />
			{ zend_do_end_function_call(&amp;$1, &amp;\), &amp;$4, 0, 1 TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C);}<br />
;</p><br />
<br />
<p>function_call_parameter_list:<br />
        non_empty_function_call_parameter_list    { \(= $1; }<br />
    |    /* empty */                　　　　　　　　{ Z_LVAL(\).u.constant) = 0; }<br />
;</p><br />
<br />
<p>non_empty_function_call_parameter_list:<br />
        expr_without_variable    { Z_LVAL(\(.u.constant) = 1;  zend_do_pass_param(&amp;$1, ZEND_SEND_VAL, Z_LVAL(\).u.constant) TSRMLS_CC); }<br />
    |    variable                { Z_LVAL(\(.u.constant) = 1;  zend_do_pass_param(&amp;$1, ZEND_SEND_VAR, Z_LVAL(\).u.constant) TSRMLS_CC); }<br />
    |    ‘&amp;’ w_variable          { Z_LVAL(\(.u.constant) = 1;  zend_do_pass_param(&amp;$2, ZEND_SEND_REF, Z_LVAL(\).u.constant) TSRMLS_CC); }<br />
    |    non_empty_function_call_parameter_list ‘,’ expr_without_variable    { Z_LVAL(\(.u.constant)=Z_LVAL($1.u.constant)+1;  zend_do_pass_param(&amp;$3, ZEND_SEND_VAL, Z_LVAL(\).u.constant) TSRMLS_CC); }<br />
    |    non_empty_function_call_parameter_list ‘,’ variable                 { Z_LVAL(\(.u.constant)=Z_LVAL($1.u.constant)+1;  zend_do_pass_param(&amp;$3, ZEND_SEND_VAR, Z_LVAL(\).u.constant) TSRMLS_CC); }<br />
    |    non_empty_function_call_parameter_list ‘,’ ‘&amp;’ w_variable           { Z_LVAL(\(.u.constant)=Z_LVAL($1.u.constant)+1;  zend_do_pass_param(&amp;$4, ZEND_SEND_REF, Z_LVAL(\).u.constant) TSRMLS_CC); }<br />
;<br />
其结构并不复杂：</p><br />
<br />
<p>1）function_call这条推导，代表了一个完整的函数调用。</p><br />
<br />
<p>2）namespace_name是指经过命名空间修饰过之后的函数名，由于我们的例子中，函数foo并没有处于任何一个命名空间里，所以namespace_name其实就是foo。如果我们的函数定义在命名空间中，则namespace_name是一个类似“全路径”的fullname。</p><br />
<br />
<p>namespace MyProject<br />
{<br />
function foo($arg1)<br />
{<br />
    print($arg1);<br />
}<br />
}</p><br />
<br />
<p>namespace<br />
{<br />
$bar = ‘hello php’;<br />
MyProject\foo($bar);// 以类似“全路径”的fullname来调用函数，则namespace_name为MyProject\foo <br />
}<br />
3）function_call_parameter_list是函数的参数列表，而non_empty_function_call_parameter_list则代表了非空参数列表。</p><br />
<br />
<p>4）从这些推导产生式里，我们还能看出编译时的所运用的一些关键处理：</p><br />
<br />
<p>zend_do_begin_function_call–&gt;zend_do_pass_param–&gt;zend_do_end_function_call</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    开始                        解析参数                     结束 和编译function语句块时的几步（zend_do_begin_function_declaration-&gt;zend_do_receive_arg-&gt;zend_do_end_function_declaration等）顺序上比较类似。<br />
</code></pre></div></div><br />
<br />
<p>上面提到语法树我们仅仅画了一部分，准确讲，没有将namespace以及function_call_parameter_list以下的推导过程进一步画出来。原因一是namespace的推导比较简单。第二，由于function_call_parameter_list–&gt;variable这步会回到variable上，而variable经过若干步一直到产生变量$bar的推导比较复杂，也不是本文的重点，所以这里就不一进步探究了。</p><br />
<br />
<p>2、开始编译<br />
看下function_call的推导式，一开始，zend vm会执行zend_do_begin_function_call做一些函数调用的准备。</p><br />
<br />
<p>2.1、 zend_do_begin_function_call<br />
代码注解如下：</p><br />
<br />
<p>zend_function *function;<br />
char *lcname;<br />
char *is_compound = memchr(Z_STRVAL(function_name-&gt;u.constant), ‘\’, Z_STRLEN(function_name-&gt;u.constant));</p><br />
<br />
<p>// 将函数名进行修正，例如带上命名空间作为前缀等<br />
zend_resolve_non_class_name(function_name, check_namespace TSRMLS_CC);</p><br />
<br />
<p>// 能进入该分支，说明在一个命名空间下以shortname调用函数，会生成一条DO_FCALL_BY_NAME指令<br />
if (check_namespace &amp;&amp; CG(current_namespace) &amp;&amp; !is_compound) {<br />
        /* We assume we call function from the current namespace<br />
        if it is not prefixed. */</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    /* In run-time PHP will check for function with full name and<br />
    internal function with short name */<br />
    zend_do_begin_dynamic_function_call(function_name, 1 TSRMLS_CC);<br />
    return 1; } <br />
</code></pre></div></div><br />
<br />
<p>// 转成小写，因为CG(function_table)中的函数名都是小写<br />
lcname = zend_str_tolower_dup(function_name-&gt;u.constant.value.str.val, function_name-&gt;u.constant.value.str.len);</p><br />
<br />
<p>// 如果function_table中找不到该函数，则也尝试生成DO_FCALL_BY_NAME指令<br />
if ((zend_hash_find(CG(function_table), lcname, function_name-&gt;u.constant.value.str.len+1, (void <em>*) &amp;function) == FAILURE) ||<br />
    ((CG(compiler_options) &amp; ZEND_COMPILE_IGNORE_INTERNAL_FUNCTIONS) &amp;&amp; (function-&gt;type == ZEND_INTERNAL_FUNCTION))) {<br />
        zend_do_begin_dynamic_function_call(function_name, 0 TSRMLS_CC);<br />
        efree(lcname);<br />
        return 1; /</em> Dynamic */<br />
} <br />
efree(function_name-&gt;u.constant.value.str.val);<br />
function_name-&gt;u.constant.value.str.val = lcname;</p><br />
<br />
<p>// 压入CG(function_call_stack)<br />
zend_stack_push(&amp;CG(function_call_stack), (void *) &amp;function, sizeof(zend_function *));<br />
zend_do_extended_fcall_begin(TSRMLS_C);<br />
return 0;<br />
有几点需要理解的：</p><br />
<br />
<p>1，zend_resolve_non_class_name。由于php支持命名空间、也支持别名/导入等特性，因此首先要做的是将函数名称进行修正，否则在CG(function_table)中找不到。例如，函数处于一个命名空间中，则可能需要将函数名添加上命名空间作为前缀，最终形成完整的函数名，也就是我们前文提到的以一种类似“全路径”的fullname作为函数名。再例如，函数名只是一个设置的别名，它实际指向了另一个命名空间中的某个函数，则需要将其改写成真正被调用函数的名称。这些工作，均由zend_resolve_non_class_name完成。命名空间添加了不少复杂度，下面是一些简单的例子：</p><br />
<br />
<p>&lt;?php<br />
namespace MyProject;</p><br />
<br />
<p>function foo($arg1)<br />
{<br />
    print($arg1);<br />
}</p><br />
<br />
<p>$bar = ‘hello php’;</p><br />
<br />
<p>foo($bar);                 // zend_resolve_non_class_name会将foo处理成MyProject\foo<br />
namespace\foo($bar);       // 在进入zend_do_begin_function_call之前，函数名已经被扩展成\MyProject\foo，再经过zend_resolve_non_class_name，将\MyProject\foo处理成MyProject\foo<br />
\MyProject\foo($bar);      // zend_resolve_non_class_name会将\MyProject\foo处理成MyProject\foo<br />
总之，zend_resolve_non_class_name是力图生成一个最精确、最完整的函数名。</p><br />
<br />
<p>2，CG(current_namespace)存储了当前的命名空间。check_namespace和!is_compound一起说明被调用函数在当前命名空间下的，并且以shortname名称被调用。所谓shortname，是和上述的fullname相对，shorname的函数名，不存在”"。</p><br />
<br />
<p>就像上面的例子中，我们在MyProject命名空间下，以foo为函数名来调用。这种情况下，check_namespace=1，is_compound = NULL，CG(current_namespace) = MyProject。因此，会走到zend_do_begin_dynamic_function_call里进一步处理。zend_do_begin_dynamic_function_call我们下面再具体描述。</p><br />
<br />
<p>&lt;?php<br />
namespace MyProject\sub;</p><br />
<br />
<p>function foo($arg1)<br />
{<br />
    print($arg1);<br />
}</p><br />
<br />
<p>namespace MyProject;<br />
$bar = ‘hello php’;<br />
sub\foo($bar);      // 以sub\foo调用函数，并不算shortname，因为存在<br /><br />
注意上述例子，我们以sub\foo来调用函数。zend_resolve_non_class_name会将函数名处理成MyProject\sub\foo。不过is_compound是在zend_resolve_non_class_name之前算的，由于sub\foo存在”"，所以is_compound为”\foo”，!is_compound是false，因而不能进入zend_do_begin_dynamic_function_call。</p><br />
<br />
<p>3，同样，如果CG(function_table)中找不到函数，也会进入zend_do_begin_dynamic_function_call进一步处理。为什么在函数表中找不到函数，因为php允许我们先调用，再去定义函数。例如：</p><br />
<br />
<p>&lt;?php<br />
$bar = ‘hello php’;</p><br />
<br />
<p>// 先调用<br />
foo($bar);</p><br />
<br />
<p>// 后定义<br />
function foo($arg1)<br />
{<br />
    print($arg1);<br />
}<br />
4，在zend_do_begin_function_call的最后，我们将函数压入CG(function_call_stack)。这是一个栈，因为在后续对传参的编译，我们仍然需要用到函数，所以这里将其压亚入栈中，方便后面获取使用。之所以用栈，是因为调用函数传递的参数，可能是另一次函数调用。为了确保参数总是能找到对应的函数，所以用栈。</p><br />
<br />
<p>&lt;?php<br />
function foo($arg1)<br />
{<br />
    print($arg1);<br />
}</p><br />
<br />
<p>$bar = ‘hello php’;<br />
foo(strlen($bar));   // 首先foo入栈，然后分析参数strlen($bar)，发现依然是个函数，于是strlen入栈，再分析参数$bar，此时弹出对应的函数正好为strlen。<br />
2.2、 zend_do_begin_dynamic_function_call<br />
前面提到，正常的调用，会先执行zend_do_begin_function_call，在zend_do_begin_function_call中有两种情况会进一步调用zend_do_begin_dynamic_function_call来处理。</p><br />
<br />
<p>一是，在命名空间中，以shortname调用函数；</p><br />
<br />
<p>二是，在调用函数时，尚未定义函数。</p><br />
<br />
<p>其实还有第三种情况会走到zend_do_begin_dynamic_function_call，就是当我们调用函数的时候，函数名并非直接写成字面，而是通过变量等形式来间接确定。这种情况下，zend vm会直接执行zend_do_begin_dynamic_function_call。</p><br />
<br />
<p>举例1：</p><br />
<br />
<p>&lt;?php<br />
function foo($arg1)<br />
{<br />
    print($arg1);<br />
}</p><br />
<br />
<p>$bar = ‘hello php’;<br />
$func = ‘foo’;<br />
$func($bar);          // 我们以变量$func作为函数名，试图调用函数foo，$func类型是IS_CV<br />
此时， $func($bar) 对应function_call语法推导式的最后一条：</p><br />
<br />
<p>function_call:<br />
        …<br />
	|	variable_without_objects  ‘(‘ { zend_do_end_variable_parse(&amp;$1, BP_VAR_R, 0 TSRMLS_CC); zend_do_begin_dynamic_function_call(&amp;$1, 0 TSRMLS_CC); }<br />
			function_call_parameter_list ‘)’<br />
			{ zend_do_end_function_call(&amp;$1, &amp;$$, &amp;$4, 0, 1 TSRMLS_CC); zend_do_extended_fcall_end(TSRMLS_C);}<br />
推导式中的variable_without_objects对应的就是变量 $func 。$func其实是一个compiled_variable，并且在op_array-&gt;vars数组中索引为1，索引为0的是在它之前定义的变量 $bar 。</p><br />
<br />
<p>举例2：</p><br />
<br />
<p>function foo($arg1)<br />
{<br />
    print($arg1);<br />
}</p><br />
<br />
<p>$bar = ‘hello php’;<br />
$func = ‘foo’;<br />
$ref_func = ‘func’;<br />
\(ref_func($bar); // 以可变变量的形式来调用函数，\)ref_func类型是IS_VAR<br />
该例是以可变变量来调用函数，和例1一样， \(ref_func($bar)也是对应function_call语法推导式的最后一条，所以不会走进zend_do_begin_function_call，而是直接进入zend_do_begin_dynamic_function_call。不同的点在于\)ref_func 节点类型不再是compiled_variable，而是普通的variable，标识为IS_VAR。</p><br />
<br />
<p>下面的图画出了5种case，第1种不经过zend_do_begin_dynamic_function_call，而后4种会调用zend_do_begin_dynamic_function_call处理，注意最后2种不经过zend_do_begin_function_call：<br />
<img src="https://xiazemin.github.io/MyBlog/img/begin_func_opcode.png" /></p><br />
<br />
<p>具体看下zend_do_begin_dynamic_function_call的代码：</p><br />
<br />
<p>void zend_do_begin_dynamic_function_call(znode <em>function_name, int ns_call TSRMLS_DC) /</em> {{{ */<br />
{<br />
    unsigned char *ptr = NULL;<br />
    zend_op *opline, *opline2;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 拿一条zend_op<br />
opline = get_next_op(CG(active_op_array) TSRMLS_CC);<br />
<br />
// 参数ns_call表名是否以shortname在命名空间中调用函数<br />
if (ns_call) {<br />
    char *slash;<br />
    int prefix_len, name_len;<br />
    /* In run-time PHP will check for function with full name and<br />
       internal function with short name */<br />
    <br />
    // 第一条指令是ZEND_INIT_NS_FCALL_BY_NAME<br />
    opline-&gt;opcode = ZEND_INIT_NS_FCALL_BY_NAME;<br />
    opline-&gt;op2 = *function_name;<br />
    opline-&gt;extended_value = 0;<br />
    opline-&gt;op1.op_type = IS_CONST;<br />
    Z_TYPE(opline-&gt;op1.u.constant) = IS_STRING;<br />
    Z_STRVAL(opline-&gt;op1.u.constant) = zend_str_tolower_dup(Z_STRVAL(opline-&gt;op2.u.constant), Z_STRLEN(opline-&gt;op2.u.constant));<br />
    Z_STRLEN(opline-&gt;op1.u.constant) = Z_STRLEN(opline-&gt;op2.u.constant);<br />
    opline-&gt;extended_value = zend_hash_func(Z_STRVAL(opline-&gt;op1.u.constant), Z_STRLEN(opline-&gt;op1.u.constant) + 1);<br />
    <br />
    // 再拿一条zend_op，指令为ZEND_OP_DATA<br />
    slash = zend_memrchr(Z_STRVAL(opline-&gt;op1.u.constant), '\\', Z_STRLEN(opline-&gt;op1.u.constant));<br />
    prefix_len = slash-Z_STRVAL(opline-&gt;op1.u.constant)+1;<br />
    name_len = Z_STRLEN(opline-&gt;op1.u.constant)-prefix_len;<br />
    opline2 = get_next_op(CG(active_op_array) TSRMLS_CC);<br />
    opline2-&gt;opcode = ZEND_OP_DATA;<br />
    opline2-&gt;op1.op_type = IS_CONST;<br />
    Z_TYPE(opline2-&gt;op1.u.constant) = IS_LONG;<br />
    if(!slash) {<br />
        zend_error(E_CORE_ERROR, "Namespaced name %s should contain slash", Z_STRVAL(opline-&gt;op1.u.constant));<br />
    }<br />
    /* this is the length of namespace prefix */<br />
    Z_LVAL(opline2-&gt;op1.u.constant) = prefix_len;<br />
    /* this is the hash of the non-prefixed part, lowercased */<br />
    opline2-&gt;extended_value = zend_hash_func(slash+1, name_len+1);<br />
    SET_UNUSED(opline2-&gt;op2);<br />
} else {<br />
    // 第一条指令是ZEND_INIT_FCALL_BY_NAME<br />
    opline-&gt;opcode = ZEND_INIT_FCALL_BY_NAME;<br />
    opline-&gt;op2 = *function_name;<br />
    <br />
    // 先调用，再定义<br />
    if (opline-&gt;op2.op_type == IS_CONST) {<br />
        opline-&gt;op1.op_type = IS_CONST;<br />
        Z_TYPE(opline-&gt;op1.u.constant) = IS_STRING;<br />
        Z_STRVAL(opline-&gt;op1.u.constant) = zend_str_tolower_dup(Z_STRVAL(opline-&gt;op2.u.constant), Z_STRLEN(opline-&gt;op2.u.constant));<br />
        Z_STRLEN(opline-&gt;op1.u.constant) = Z_STRLEN(opline-&gt;op2.u.constant);<br />
        opline-&gt;extended_value = zend_hash_func(Z_STRVAL(opline-&gt;op1.u.constant), Z_STRLEN(opline-&gt;op1.u.constant) + 1);<br />
    }<br />
    // 以变量当函数名来调用<br />
    else {<br />
        opline-&gt;extended_value = 0;<br />
        SET_UNUSED(opline-&gt;op1);<br />
    }<br />
}<br />
<br />
// 将NULL压入CG(function_call_stack)<br />
zend_stack_push(&amp;CG(function_call_stack), (void *) &amp;ptr, sizeof(zend_function *));<br />
zend_do_extended_fcall_begin(TSRMLS_C); } ns_call参数取值为0或者1。如果在命名空间中，以shortname调用函数，则ns_call = 1，并且会生成2条指令。如果是先调用再定义，或者以变量作函数名，则ns_call = 0，并且只会生成1条指令。<br />
</code></pre></div></div><br />
<br />
<p>以ns_call = 1为例：</p><br />
<br />
<p>&lt;?php<br />
namespace MyProject;</p><br />
<br />
<p>function foo($arg1)<br />
{<br />
    print($arg1);<br />
}</p><br />
<br />
<p>$bar = ‘hello php’;<br />
foo($bar);<br />
 生成的op指令如下所示：<br />
<img src="https://xiazemin.github.io/MyBlog/img/begin_func_opcode_1.png" /><br />
以ns_call = 0，先调用再定义为例：</p><br />
<br />
<p>&lt;?php<br />
$bar = ‘hello php’;<br />
foo($bar);</p><br />
<br />
<p>function foo($arg1)<br />
{<br />
    print($arg1);<br />
}<br />
生成的op指令如下所示：</p><br />
<br />
<p>以ns_call = 0，变量作为函数名为例：</p><br />
<br />
<p>&lt;?php<br />
function foo($arg1)<br />
{<br />
    print($arg1);<br />
}</p><br />
<br />
<p>$bar = ‘hello php’;<br />
$func = ‘foo’;<br />
$func($bar);<br />
生成的op指令如下所示：</p><br />
<br />
<p>上面一共新出现了3条op指令：ZEND_INIT_NS_FCALL_BY_NAME、ZEND_OP_DATA以及ZEND_INIT_FCALL_BY_NAME。</p><br />
<br />
<p>其中，ZEND_INIT_NS_FCALL_BY_NAME和ZEND_INIT_FCALL_BY_NAME都是在运行时从函数表中取出真正被调用的函数。ZEND_OP_DATA在本case中并不起作用，第5章中会具体分析ZEND_OP_DATA。</p><br />
<br />
<p>回到zend_do_begin_dynamic_function_call，在代码的最后向CG(function_call_stack)压入了一个NULL。CG(function_call_stack)在随后的zend_do_pass_param中会有作用，这里压入NULL，意味着随后zend_do_pass_param中会取出NULL，表明无法从函数定义中判断其参数的属性(是否为引用传递等)。</p><br />
<br />
<p>3、编译传参<br />
从前面语法推导式里可以看出，调用函数时的传参，最终由zend_do_pass_param来完成。具体参数该怎么传，实际情况是很复杂的。php语法比较松散，可以传递正常的变量，也可以传递表达式，可以传递引用，甚至可以传递另一个函数调用。</p><br />
<br />
<p>但无论是哪种情况，最终传参逻辑都会编译成类似SEND_VAR，SEND_VAL，SEND_REF，ZEND_SEND_VAR_NO_REF等指令，这些指令和函数中的RECV指令是对应的。具体来说，zend vm进入执行期之后，一般都是会通过SEND_XXX等指令发送参数，然后执行DO_FCALL/DO_FCALL_BY_NAME等指令开始调用函数。进入函数体内之后，再执行RECV完成参数的接收。第2章中我们具体讲解了RECV指令，除非函数不接受参数，否则RECV必定是函数体内的第一条指令。</p><br />
<br />
<p>如下图所示：<br />
 <img src="https://xiazemin.github.io/MyBlog/img/begin_func_opcode_2.png" /><br />
 们给出的示例是一种最简单的情况，也就是传递一个正常的变量。</p><br />
<br />
<p>来看下zend_do_pass_param的实现：</p><br />
<br />
<p>void zend_do_pass_param(znode <em>param, zend_uchar op, int offset TSRMLS_DC) /</em> {{{ */<br />
{<br />
    zend_op *opline;<br />
    int original_op = op;<br />
    zend_function **function_ptr_ptr, *function_ptr;<br />
    int send_by_reference;<br />
    int send_function = 0;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 从CG(function_call_stack)获取当前函数，注意可能拿出的是NULL<br />
zend_stack_top(&amp;CG(function_call_stack), (void **) &amp;function_ptr_ptr);<br />
function_ptr = *function_ptr_ptr;<br />
<br />
// 调用的地方以引用传参，但是php.ini中配置不允许这样，则抛错<br />
if (original_op == ZEND_SEND_REF &amp;&amp; !CG(allow_call_time_pass_reference)) {<br />
    if (function_ptr &amp;&amp;<br />
            function_ptr-&gt;common.function_name &amp;&amp;<br />
            function_ptr-&gt;common.type == ZEND_USER_FUNCTION &amp;&amp;<br />
            !ARG_SHOULD_BE_SENT_BY_REF(function_ptr, (zend_uint) offset)) {<br />
        zend_error(E_DEPRECATED,<br />
                    "Call-time pass-by-reference has been deprecated; "<br />
                    "If you would like to pass it by reference, modify the declaration of %s().  "<br />
                    "If you would like to enable call-time pass-by-reference, you can set "<br />
                    "allow_call_time_pass_reference to true in your INI file", function_ptr-&gt;common.function_name);<br />
    } else {<br />
        zend_error(E_DEPRECATED, "Call-time pass-by-reference has been deprecated");<br />
    }<br />
} 1，首先是从CG(function_call_stack)中获取当前参数对应的函数。注意，可能拿到的只是一个NULL。因为php的语法允许我们先函数调用，再接着对函数进行定义。如前文所述，这种情况下zend_do_begin_function_call中会向CG(function_call_stack)中压入NULL，同时会产生DO_FCALL_BY_NAME指令。<br />
</code></pre></div></div><br />
<br />
<p>2，在传参的语法推导式中，op可能会有3种，分别是ZEND_SEND_VAL、ZEND_SEND_VAR、ZEND_SEND_REF。</p><br />
<br />
<p>expr_without_variable    { Z_LVAL(\(.u.constant) = 1;  zend_do_pass_param(&amp;$1, ZEND_SEND_VAL, Z_LVAL(\).u.constant) TSRMLS_CC); }<br />
variable                 { Z_LVAL(\(.u.constant) = 1;  zend_do_pass_param(&amp;$1, ZEND_SEND_VAR, Z_LVAL(\).u.constant) TSRMLS_CC); }<br />
‘&amp;’ w_variable           { Z_LVAL(\(.u.constant) = 1;  zend_do_pass_param(&amp;$2, ZEND_SEND_REF, Z_LVAL(\).u.constant) TSRMLS_CC); }<br />
这三种op分别对应的语法是expr_without_variable、variable、’&amp;’w_variable，简单来说就是“不含变量的表达式”、“变量”、“引用”。</p><br />
<br />
<p>zend_do_pass_param会判断，如果用户传递的是引用，但同时在php.INI中配置了形如 allow_call_time_pass_reference = Off ，则需要产生一条E_DEPRECATED错误信息，告知用户传递的时候不建议强制写成引用。</p><br />
<br />
<p>其实，还有第4种传参的opcode，即ZEND_SEND_VAR_NO_REF。我们接下来会提到。</p><br />
<br />
<p>// 函数已定义，则根据函数的定义，来决定send_by_reference是否传引用<br />
if (function_ptr) {<br />
    if (ARG_MAY_BE_SENT_BY_REF(function_ptr, (zend_uint) offset)) {<br />
        …<br />
    } else {<br />
        // 要么为0，要么为ZEND_ARG_SEND_BY_REF<br />
        send_by_reference = ARG_SHOULD_BE_SENT_BY_REF(function_ptr, (zend_uint) offset) ? ZEND_ARG_SEND_BY_REF : 0;<br />
    }<br />
}<br />
// 函数为定义，先统一将send_by_reference置为0<br />
else {<br />
    send_by_reference = 0;<br />
}</p><br />
<br />
<p>// 如果用户传递的参数，本身就是一次函数调用，则将op改成ZEND_SEND_VAR_NO_REF<br />
if (op == ZEND_SEND_VAR &amp;&amp; zend_is_function_or_method_call(param)) {<br />
    /* Method call */<br />
    op = ZEND_SEND_VAR_NO_REF;<br />
    send_function = ZEND_ARG_SEND_FUNCTION;<br />
}<br />
// 如果用户传递的参数，是一个表达式，并且结果会产生中间变量，则也将op改成ZEND_SEND_VAR_NO_REF<br />
else if (op == ZEND_SEND_VAL &amp;&amp; (param-&gt;op_type &amp; (IS_VAR|IS_CV))) {<br />
    op = ZEND_SEND_VAR_NO_REF;<br />
}<br />
1，send_by_reference表示根据函数的定义，参数是不是引用。ARG_MAY_BE_SENT_BY_REF和ARG_SHOULD_BE_SENT_BY_REF两个宏这里就不具体叙述了，感兴趣的朋友可以自己阅读代码。</p><br />
<br />
<p>2，op == ZEND_SEND_VAR对应的是variable，假如参数是一个函数调用，也可能会被编译成variable，但是函数调用并不存在显式定义的变量，所以不能直接编译成SEND_VAR指令，因此这里就涉及到了上文提到的第4种opcode，即ZEND_SEND_VAR_NO_REF。例如：</p><br />
<br />
<p>3，op == ZEND_SEND_VAL对应的是一个表达式，如果该表达式产生了一个变量作为结果，则也需要将op改成ZEND_SEND_VAR_NO_REF。例如：</p><br />
<br />
<p>继续来看zend_do_pass_param：</p><br />
<br />
<p>// 如果根据函数定义需要传递引用，且实际传递的参数是变量，则将op改成ZEND_SEND_REF<br />
if (op!=ZEND_SEND_VAR_NO_REF &amp;&amp; send_by_reference==ZEND_ARG_SEND_BY_REF) {<br />
    /* change to passing by reference */<br />
    switch (param-&gt;op_type) {<br />
        case IS_VAR:<br />
        case IS_CV:<br />
            op = ZEND_SEND_REF;<br />
            break;<br />
        default:<br />
            zend_error(E_COMPILE_ERROR, “Only variables can be passed by reference”);<br />
            break;<br />
    }<br />
}</p><br />
<br />
<p>// 如果实际传递的参数是变量，调用zend_do_end_variable_parse处理链式调用<br />
if (original_op == ZEND_SEND_VAR) {<br />
    switch (op) {<br />
        case ZEND_SEND_VAR_NO_REF:<br />
            zend_do_end_variable_parse(param, BP_VAR_R, 0 TSRMLS_CC);<br />
            break;<br />
        case ZEND_SEND_VAR:<br />
            if (function_ptr) {<br />
                zend_do_end_variable_parse(param, BP_VAR_R, 0 TSRMLS_CC);<br />
            } else {<br />
                zend_do_end_variable_parse(param, BP_VAR_FUNC_ARG, offset TSRMLS_CC);<br />
            }<br />
            break;<br />
        case ZEND_SEND_REF:<br />
            zend_do_end_variable_parse(param, BP_VAR_W, 0 TSRMLS_CC);<br />
            break;<br />
    }<br />
}<br />
这里注意param-&gt;op_type是传递的参数经过编译得到znode的op_type，如果不属于变量（IS_VAR、IS_CV），就直接报错了。举例来说：</p><br />
<br />
<p>function foo(&amp;$a)<br />
{<br />
    print($a);<br />
}</p><br />
<br />
<p>foo($bar == 1);  // 抛错 “Only variables can be passed by reference”<br />
上面 $bar == 1 表达式的编译结果，op_type为IS_TMP_VAR，可以看做一种临时的中间结果，并非IS_VAR，IS_CV，因此无法编译成功。看着逻辑有点绕，其实很好理解。因为我们传递引用，实际目的是希望能够在函数中，对这个参数的值进行修改，需要参数是可写的。然而 $bar == 1 产生的中间结果，我们无法做出修改，是只读的。</p><br />
<br />
<p>来看zend_do_pass_param的最后一段：</p><br />
<br />
<p>// 获取下一条zend op指令<br />
opline = get_next_op(CG(active_op_array) TSRMLS_CC);</p><br />
<br />
<p>// extended_value加上不同的附加信息<br />
if (op == ZEND_SEND_VAR_NO_REF) {<br />
    if (function_ptr) {<br />
        opline-&gt;extended_value = ZEND_ARG_COMPILE_TIME_BOUND | send_by_reference | send_function;<br />
    } else {<br />
        opline-&gt;extended_value = send_function;<br />
    }<br />
} else {<br />
    if (function_ptr) {<br />
        opline-&gt;extended_value = ZEND_DO_FCALL;<br />
    } else {<br />
        opline-&gt;extended_value = ZEND_DO_FCALL_BY_NAME;<br />
    }<br />
}</p><br />
<br />
<p>// 设置opcode、op1、op2等<br />
opline-&gt;opcode = op;<br />
opline-&gt;op1 = *param;<br />
opline-&gt;op2.u.opline_num = offset;<br />
SET_UNUSED(opline-&gt;op2);<br />
上面这段代码生成了一条SEND指令。如果我们调用函数时候传递了多个参数，则会调用多次zend_do_pass_param，最终会生成多条SEND指令。</p><br />
<br />
<p>至于指令具体是SEND_VAR，SEND_VAL，还是SEND_RE，亦或是ZEND_SEND_VAR_NO_REF，则依靠zend_do_pass_param中的判断。zend_do_pass_param中的逻辑分支比较多，一下子不能弄明白所有分支也没关系，最重要的是知道它会根据函数的定义以及实际传递的参数，产生最合适的SEND指令。</p><br />
<br />
<p>还是回到我们开始的例子，对于 foo($bar) ，则经过zend_do_pass_param之后，产生的SEND指令细节如下：</p><br />
<br />
<p>4、结束编译<br />
结束函数调用是通过zend_do_end_function_call来完成的。根据前文所述，zend_do_begin_function_call并不产生一条实际的调用指令，但它确定了最终函数调用走的是DO_FCALL还是DO_FCALL_BY_NAME，并且据此来生成ZEND_INIT_NS_FCALL_BY_NAME或ZEND_INIT_FCALL_BY_NAME指令。</p><br />
<br />
<p>实际的调用指令是放在zend_do_end_function_call中来生成的。</p><br />
<br />
<p>具体分析下zend_do_end_function_call：</p><br />
<br />
<p>zend_op *opline;</p><br />
<br />
<p>// 这段逻辑分支现在已经走不到了<br />
if (is_method &amp;&amp; function_name &amp;&amp; function_name-&gt;op_type == IS_UNUSED) {<br />
    /* clone */<br />
    if (Z_LVAL(argument_list-&gt;u.constant) != 0) {<br />
        zend_error(E_WARNING, “Clone method does not require arguments”);<br />
    }<br />
    opline = &amp;CG(active_op_array)-&gt;opcodes[Z_LVAL(function_name-&gt;u.constant)];<br />
} else {<br />
    opline = get_next_op(CG(active_op_array) TSRMLS_CC);</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 函数，名称确定，非dynamic_fcall，函数则生成ZEND_DO_FCALL指令<br />
if (!is_method &amp;&amp; !is_dynamic_fcall &amp;&amp; function_name-&gt;op_type==IS_CONST) {<br />
    opline-&gt;opcode = ZEND_DO_FCALL;<br />
    opline-&gt;op1 = *function_name;<br />
    ZVAL_LONG(&amp;opline-&gt;op2.u.constant, zend_hash_func(Z_STRVAL(function_name-&gt;u.constant), Z_STRLEN(function_name-&gt;u.constant) + 1));<br />
}<br />
// 否则生成ZEND_DO_FCALL_BY_NAME指令<br />
else {<br />
    opline-&gt;opcode = ZEND_DO_FCALL_BY_NAME;<br />
    SET_UNUSED(opline-&gt;op1);<br />
} }<br />
</code></pre></div></div><br />
<br />
<p>// 生成临时变量索引，函数的调用，返回的znode必然是IS_VAR<br />
opline-&gt;result.u.var = get_temporary_variable(CG(active_op_array));<br />
opline-&gt;result.op_type = IS_VAR;<br />
*result = opline-&gt;result;<br />
SET_UNUSED(opline-&gt;op2);</p><br />
<br />
<p>// 从CG(function_call_stack)弹出当前被调用的函数<br />
zend_stack_del_top(&amp;CG(function_call_stack));</p><br />
<br />
<p>// 传参个数<br />
opline-&gt;extended_value = Z_LVAL(argument_list-&gt;u.constant);<br />
其中有一段if逻辑分支已经走不到了，可以忽略。</p><br />
<br />
<p>具体考据：这段逻辑在462eff3中被添加，主要用于当调用__clone魔术方法时传参进行抛错，但在8e30d96中，已经不允许直接调用__clone方法了，在进入zend_do_end_function_call之前便会终止编译，所以实际上已经再也走不到该分支了。</p><br />
<br />
<p>直接看else部分，else生成了一条zend op指令。如果函数名确定，函数已被定义，并且不属于动态调用等，则生成的op指令为ZEND_DO_FCALL，否则生成ZEND_DO_FCALL_BY_NAME。对于ZEND_DO_FCALL指令，其操作数比较明确，为函数名，但是对于ZEND_DO_FCALL_BY_NAME来说，由于被调的函数尚未明确，所以将操作数置为UNUSED。</p><br />
<br />
<p>5、总结<br />
用一张图总结一下函数调用大致的编译流程：<br />
<img src="https://xiazemin.github.io/MyBlog/img/begin_func_opcode_3.png" /></p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category lang
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>