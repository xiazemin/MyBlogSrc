<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">补偿还是幂等来解决一致性问题</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-05-22T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> May 22, 2020</time></p>
					</div>
					 <p>一、「补偿」机制的意义？<br />
以电商的购物场景为例：</p><br />
<br />
<p>客户端 —-&gt;购物车微服务 —-&gt;订单微服务 —-&gt; 支付微服务。</p><br />
<br />
<p>这种调用链非常普遍。</p><br />
<br />
<p>那么为什么需要考虑补偿机制呢？</p><br />
<br />
<p>正如之前几篇文章所说，一次跨机器的通信可能会经过DNS 服务，网卡、交换机、路由器、负载均衡等设备，这些设备都不一定是一直稳定的，在数据传输的整个过程中，只要任意一个环节出错，都会导致问题的产生。</p><br />
<br />
<p>而在分布式场景中，一个完整的业务又是由多次跨机器通信组成的，所以产生问题的概率成倍数增加。</p><br />
<br />
<p>但是，这些问题并不完全代表真正的系统无法处理请求，所以我们应当尽可能的自动消化掉这些异常。</p><br />
<br />
<p>可能你会问，之前也看到过「补偿」和「事务补偿」或者「重试」，它们之间的关系是什么？</p><br />
<br />
<p>你其实可以不用太纠结这些名字，从目的来说都是一样的。就是一旦某个操作发生了异常，如何通过内部机制将这个异常产生的「不一致」状态消除掉。</p><br />
<br />
<p>题外话：在Z哥看来，不管用什么方式，只要通过额外的方式解决了问题都可以理解为是「补偿」，所以「事务补偿」和「重试」都是「补偿」的子集。前者是一个逆向操作，而后者则是一个正向操作。</p><br />
<br />
<p>只是从结果来看，两者的意义不同。「事务补偿」意味着“放弃”，当前操作必然会失败。</p><br />
<br />
<p>重试」则还有处理成功的机会。这两种方式分别适用于不同的场景。</p><br />
<br />
<p>因为「补偿」已经是一个额外流程了，既然能够走这个额外流程，说明时效性并不是第一考虑的因素，所以做补偿的核心要点是：宁可慢，不可错。</p><br />
<br />
<p>因此，不要草率的就确定了补偿的实施方案，需要谨慎的评估。虽说错误无法100%避免，但是抱着这样的一个心态或多或少可以减少一些错误的发生。<br />
<!-- more --><br />
https://www.cnblogs.com/Zachary-Fan/p/compensation.html</p><br />
<br />
<p>二、「补偿」该怎么做？<br />
做「补偿」的主流方式就前面提到的「事务补偿」和「重试」，以下会被称作「回滚」和「重试」。</p><br />
<br />
<p>我们先来聊聊「回滚」。相比「重试」，它逻辑上更简单一些。</p><br />
<br />
<p>「回滚」<br />
Z哥将回滚分为2种模式，一种叫「显式回滚」（调用逆向接口），一种叫「隐式回滚」（无需调用逆向接口）。</p><br />
<br />
<p>最常见的就是「显式回滚」。这个方案无非就是做2个事情：</p><br />
<br />
<p>首先要确定失败的步骤和状态，从而确定需要回滚的范围。一个业务的流程，往往在设计之初就制定好了，所以确定回滚的范围比较容易。但这里唯一需要注意的一点就是：如果在一个业务处理中涉及到的服务并不是都提供了「回滚接口」，那么在编排服务时应该把提供「回滚接口」的服务放在前面，这样当后面的工作服务错误时还有机会「回滚」。</p><br />
<br />
<p>其次要能提供「回滚」操作使用到的业务数据。「回滚」时提供的数据越多，越有益于程序的健壮性。因为程序可以在收到「回滚」操作的时候可以做业务的检查，比如检查账户是否相等，金额是否一致等等。</p><br />
<br />
<p>由于这个中间状态的数据结构和数据大小并不固定，所以Z哥建议你在实现这点的时候可以将相关的数据序列化成一个json，然后存放到一个nosql类型的存储中。</p><br />
<br />
<p>「隐式回滚」相对来说运用场景比较少。它意味着这个回滚动作你不需要进行额外处理，下游服务内部有类似“预占”并且“超时失效”的机制的。例如：</p><br />
<br />
<p>电商场景中，会将订单中的商品先预占库存，等待用户在 15 分钟内支付。如果没有收到用户的支付，则释放库存。</p><br />
<br />
<p>下面聊聊可以有很多玩法，也更容易陷入坑里的「重试」。</p><br />
<br />
<p>「重试」 <br />
「重试」最大的好处在于，业务系统可以不需要提供「逆向接口」，这是一个对长期开发成本特别大的利好，毕竟业务是天天在变的。所以，在可能的情况下，应该优先考虑使用「重试」。</p><br />
<br />
<p>不过，相比「回滚」来说「重试」的适用场景更少一些，所以我们第一步首先要判断，当前场景是否适合「重试」。比如：</p><br />
<br />
<p>下游系统返回「请求超时」、「被限流中」等临时状态的时候，我们可以考虑重试<br />
而如果是返回“余额不足”、“无权限”等明确无法继续的业务性错误的时候就不需要重试了<br />
一些中间件或者rpc框架中返回Http503、404等没有何时恢复的预期的时候，也不需要重试</p><br />
<br />
<p>如果确定要进行「重试」，我们还需要选定一个合适的「重试策略」。主流的「重试策略」主要是以下几种。</p><br />
<br />
<p>策略1.立即重试。有时故障是候暂时性，可能是因网络数据包冲突或硬件组件流量高峰等事件造成的。在此情况下，适合立即重试操作。不过，立即重试次数不应超过一次，如果立即重试失败，应改用其它的策略。</p><br />
<br />
<p>策略2.固定间隔。应用程序每次尝试的间隔时间相同。 这个好理解，例如，固定每 3 秒重试操作。（以下所有示例代码中的具体的数字仅供参考。）</p><br />
<br />
<p>策略1和策略2多用于前端系统的交互式操作中。</p><br />
<br />
<p>策略3.增量间隔。每一次的重试间隔时间增量递增。比如，第一次0秒、第二次3秒、第三次6秒，9、12、15这样。</p><br />
<br />
<p>return (retryCount - 1) * incrementInterval;<br />
使得失败次数越多的重试请求优先级排到越后面，给新进入的重试请求让道。</p><br />
<br />
<p>策略4.指数间隔。每一次的重试间隔呈指数级增加。和增量间隔“殊途同归”，都是想让失败次数越多的重试请求优先级排到越后面，只不过这个方案的增长幅度更大一些。</p><br />
<br />
<p>return 2 ^ retryCount;</p><br />
<br />
<p>策略5.全抖动。在递增的基础上，增加随机性（可以把其中的指数增长部分替换成增量增长。）。适用于将某一时刻集中产生的大量重试请求进行压力分散的场景。</p><br />
<br />
<p>return random(0 , 2 ^ retryCount);</p><br />
<br />
<p>策略6.等抖动。在「指数间隔」和「全抖动」之间寻求一个中庸的方案，降低随机性的作用。适用场景和「全抖动」一样。</p><br />
<br />
<p>var baseNum = 2 ^ retryCount;<br />
return baseNum + random(0 , baseNum);</p><br />
<br />
<p>3、4、5、6策略的表现情况大致是这样。(x轴为重试次数)</p><br />
<br />
<p>为什么说「重试」有坑呢？</p><br />
<br />
<p>正如前面聊到的那样，出于对开发成本考虑，你在做「重试」的时候可能是复用的常规调用的接口。那么此时就不得不提一个「幂等性」问题。</p><br />
<br />
<p>如果实现「重试」选用的技术方案不能100%确保不会重复发起重试，那么「幂等性」问题是一个必须要考虑的问题。哪怕技术方案可以确保100%不会重复发起重试，出于对意外情况的考量，尽量也考虑一下「幂等性」问题。</p><br />
<br />
<p>幂等性：不管对程序发起几次重复调用，程序表现的状态（所有相关的数据变化）与调用一次的结果是一致的话，就是保证了幂等性。</p><br />
<br />
<p>这意味着可以根据需要重复或重试操作，而不会导致意外的影响。对于非幂等操作，算法可能必须跟踪操作是否已经执行。</p><br />
<br />
<p>所以，一旦某个功能支持「重试」，那么整个链路上的接口都需要考虑幂等性问题，不能因为服务的多次调用而导致业务数据的累计增加或减少。</p><br />
<br />
<p>满足「幂等性」其实就是需要想办法识别重复的请求，并且将其过滤掉。思路就是：</p><br />
<br />
<p>给每个请求定义一个唯一标识。<br />
在进行「重试」的时候判断这个请求是否已经被执行或者正在被执行，如果是则抛弃该请求。<br />
第1点，我们可以使用一个全局唯一id生成器或者生成服务（可以扩展阅读，分布式系统中的必备良药 —— 全局唯一单据号生成）。 或者简单粗暴一些，使用官方类库自带的Guid、uuid之类的也行。</p><br />
<br />
<p>然后通过rpc框架在发起调用的客户端中，对每个请求增加一个唯一标识的字段进行赋值。</p><br />
<br />
<p>第2点，我们可以在服务端通过Aop的方式切入到实际的处理逻辑代码之前和之后，一起配合做验证。</p><br />
<br />
<p>大致的代码思路如下。</p><br />
<br />
<p>复制代码<br />
【方法执行前】<br />
if(isExistLog(requestId)){  //1.判断请求是否已被接收过。  对应序号3<br />
    var lastResult = getLastResult();  //2.获取用于判断之前的请求是否已经处理完成。  对应序号4<br />
    if(lastResult == null){<br /><br />
        var result = waitResult();  //挂起等待处理完成<br />
        return result;<br />
    }<br />
    else{<br />
        return lastResult;<br />
    }<br /><br />
}<br />
else{<br />
    log(requestId);  //3.记录该请求已接收<br />
}</p><br />
<br />
<p>//do something..</p><br />
<br />
<p>【方法执行后】<br />
logResult(requestId, result);  //4.将结果也更新一下。<br />
复制代码</p><br />
<br />
<p>如果「补偿」这个工作是通过MQ来进行的话，这事就可以直接在对接MQ所封装的SDK中做。在生产端赋值全局唯一标识，在消费端通过唯一标识消重。</p><br />
<br />
<p>三、「重试」的最佳实践<br />
再聊一些Z哥积累的最佳实践吧（划重点：）），都是针对「重试」的，的确这也是工作中最常用的方案。</p><br />
<br />
<p>「重试」特别适合在高负载情况下被「降级」，当然也应当受到「限流」和「熔断」机制的影响。当「重试」的“矛”与「限流」和「熔断」的“盾”搭配使用，效果才是最好。</p><br />
<br />
<p>需要衡量增加补偿机制的投入产出比。一些不是很重要的问题时，应该「快速失败」而不是「重试」。</p><br />
<br />
<p>过度积极的重试策略（例如间隔太短或重试次数过多）会对下游服务造成不利影响，这点一定要注意。</p><br />
<br />
<p>一定要给「重试」制定一个终止策略。</p><br />
<br />
<p>当回滚的过程很困难或代价很大的情况下，可以接受很长的间隔及大量的重试次数，DDD中经常被提到的「saga」模式其实也是这样的思路。不过，前提是不会因为保留或锁定稀缺资源而阻止其他操作（比如1、2、3、4、5几个串行操作。由于2一直没处理完成导致3、4、5没法继续进行）。</p><br />
<br />
<p>四、总结<br />
这篇我们先聊了下做「补偿」的意义，以及做补偿的2个方式「回滚」和「重试」的实现思路。</p><br />
<br />
<p>然后，提醒你要注意「重试」的时候需要考虑幂等性问题，并且z哥也给出了一个解决思路。</p><br />
<br />
<p>最后，分享了几个z哥总结的针对「重试」的最佳实践。</p><br />
<br />
<p>希望对你有所帮助。</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/55326867</p><br />
<br />
<p>分布式事务产生的原因<br />
数据库分库分表<br />
微服务化<br />
在微服务架构中，每个服务在用本地事务的时候，知道自己执行的事务是成功还是失败，但是无法知道其他服务节点的事务执行情况，因此需要引入协调者TM，负责协调参与者RM的行为，并最终决定这些参与者是否把事务进行提交。<br />
随着微服务架构的流行，让分布式事务问题日益突出， 那么常见的分布式事务解决方案有哪些呢？ 如何理解最终一致性和它的事务补偿机制呢？</p><br />
<br />
<p>刚性事务 - 强一致性<br />
image.png<br />
如上图，这是个标准的全局事务，事务管理器控制着全局事务，管理事务的生命周期，并通过XA协议与资源管理器协调资源；资源管理器负责控制和管理实际的资源 （这里的资源管理器，可以是一个DBMS，或者消息服务管理系统）</p><br />
<br />
<p>两阶段提交<br />
它是XA用于在全局事务中协调多个资源的机制，常用于事务管理器和资源管理器之间，解决一致性问题，分两阶段：</p><br />
<br />
<p>提交事务请求<br />
执行事务请求<br />
image.png<br />
2PC的问题<br />
效率低，与本地事务相比，XA协议的系统开销比较大（数据被锁定的时间跨度整个事务，直到全局事务的结束），只有支持XA协议的资源才能参与分布式事务。<br />
2PC是反可伸缩模式的，在事务处理过程中，参与者需要一直持有资源直到整个事务的结束，这样当业务规模越来越大的情况下，它的局限性就越明显。<br />
数据不一致，在2pc中的第二阶段时，当TM向RM发送提交请求之后，发生局部的网络异常或者在发送提交请求过程中TM发生故障， 这会导致只有一部分RM收到了提交请求，然后没有收到提交请求的RM不会执行事务的提交，于是整个分布式系统便会出现数据不一致。<br />
单点故障， 由于TM的重要性，一旦发生故障，整个事务失效<br />
3PC的改进<br />
增加了超时机制， 主要解决单点故障问题，并减少资源锁定时间，一旦RM无法及时收到来至TM的信息之后，它会默认执行Commit操作， 而不会一直持有事务资源并处于阻塞状态。但是这种机制同样会导致数据不一致的问题，由于网络的原因，TM发送的回滚动作，没有被RM及时的收到，那么RM等待超时后就执行了提交操作，这样就和收到回滚操作并执行的RM之间存在了数据不一致的情况。</p><br />
<br />
<p>柔性事务 - 最终一致性<br />
在2008年，eBay公布了基于BASE准则的最终一致性解决方案，它主要采用了消息队列来辅助实现事务控制流程，其核心通过消息队列的方式来异步执行分布式处理的任务，如果事务失败，则可以发起人工重试的纠正流程（比如对账系统，对处于dead letter queue的问题进行处理）</p><br />
<br />
<p>消息发送一致性<br />
微服务架构下，需要通过网络进行通信，就自然引入了数据传输的不确定性，也就是CAP原理中的P-分区容错，而这里的消息发送一致性是可靠消息的保证。</p><br />
<br />
<p>生成消息的业务动作与消息发送的一致（e.g： 如果业务操作成功，那么由这个业务操作所产生的消息一定会成功投递出去，否则就丢失消息）</p><br />
<br />
<p>最终一致性.png<br />
如上图，保证消息发送一致性的一般流程如下：</p><br />
<br />
<p>Producer先把消息发送给消息中间件服务，消息的状态标记为待确认，这个状态并不会被Consumer消费，对于长期待确认的消息，消息中间件会调用Producer的查询接口，查看最新状态，根据结果决定是否删除消息。<br />
Producer执行完业务操作后，向消息中间件服务，发送确认消息<br />
这时消息的状态会被更改为待发送（可发送）<br />
Consumer监听并接收待发送状态的消息，执行业务处理<br />
Consumer业务处理后，向消息中间件服务发送ACK，确认消息已经收到（消息中间件服务将从队列中删除该消息）<br />
消息的ACK确认流程中，任何一个环节都可能会出问题！</p><br />
<br />
<p>对未ACK的消息，采用按规则重新投递的方式进行处理（很多MQ都提供at least once的投递，持久化和重试机制），一般还会设置重发的次数， 超过次数的消息会进入dead letter queue，等待人工干预或者延后定时处理。</p><br />
<br />
<p>业务接口的幂等性<br />
消息的重复发送会导致业务接口出现重复调用的问题，主要原因就是消息没有及时收到ACK确认导致的， 那如何实现幂等性设计呢？</p><br />
<br />
<p>在实际的业务场景中， 业务接口的幂等性设计，常结合查询操作一起使用，</p><br />
<br />
<p>比如根据唯一标识查询消息是否被处理过， 或者根据消费日志表，来维护消息消费的记录。</p><br />
<br />
<p>保证最终一致性的模式<br />
可查询模式，任何一个服务操作都提供一个可查询接口，用来向外部输出操作执行的状态，下游Consumer可以通过接口得知服务操作执行的状态，然后根据不同的状态做不同的处理操作（执行或者取消）， 该模式对业务接口有一定侵入性。<br />
补偿模式， 有了查询模式，我们能够知道操作的具体状态，如果处于不正常状态，我们可以修正操作中出现的问题，或许是重新执行，或许取消已经完成的操作，通过修复是的整个分布式系统达到最终一致。<br />
最大努力通知模式， 在调用支付宝交易接口或微信支付接口时，一般会在回调页面和接口里，解密参数，然后调用系统中更新交易状态相关的服务，将订单更新为付款成功。同时，只有当回调页面中输出了success字样或者标识业务处理成功相应状态码时，支付宝才会停止回调请求。否则，支付宝会每间隔一段时间后，再向客户方发起回调请求，直到输出成功标识为止</p><br />
<br />
<p>http://www.fecmall.com/topic/534</p><br />
<br />
<p>业务场景是这样的</p><br />
<br />
<p>一个请求过来<br />
更新系统a 的状态从a1-&gt; a2</p><br />
<br />
<p>更新系统 b  的状态从 b1-&gt;b2</p><br />
<br />
<p>更新系统 c 的状态从 c1-&gt; c2</p><br />
<br />
<p>如果系统b 超时</p><br />
<br />
<p>端上发起重试</p><br />
<br />
<p>a和c 系统都做了幂等：<br />
即<br />
不论系统 a 处于 a1 a2 状态都可以 做成功 a1-&gt;a2的扭转<br />
c 也一样，即 c1-&gt;c2  c2-&gt;c2 都可以成功</p><br />
<br />
<p>b系统发现已经是b2了，会查c发现c还是c1,查a的状态是a2<br />
会报错</p><br />
<br />
<p>这个时候是应该在 b失败的时候回滚 a2-&gt;a1还是<br />
b做系统兼容如果状态是a2 b2 c1也返回成功？保证重试的幂等呢</p><br />
<br />
<p>我认为在实时高并非情况下，应该是做幂等</p><br />
<br />
<p>为什么呢<br />
因为在分布式系统中，存储也是分布式的，存在主从不一致性<br />
，回滚操作可能是成功了一半，根本解决不了问题。</p><br />
<br />
<p>业务角度保证接口的幂等是更合理的方式</p><br />
<br />
<p>一切都是要从具体业务场景出发</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category web
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>