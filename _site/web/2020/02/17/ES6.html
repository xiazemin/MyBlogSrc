<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">ES6</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-02-17T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Feb 17, 2020</time></p>
					</div>
					 <p>为什么要处理ES6语法呢？当我们使用新语法来写代码，一些浏览器如果不支持那么就会报错，导致用户体验非常糟糕。我们使用babel来将ES6语法处理成ES5语法，就可以解决这个问题。</p><br />
<br />
<p>Babel官网{:target=”_blank”}<br />
1.安装Babel</p><br />
<br />
<p>yarn add babel-loader @babel/core<br />
<!-- more --><br />
webpack.config.js<br />
安装@babel/preset-env<br />
yarn add @babel/preset-env<br />
.babelrc<br />
{<br />
    “presets”: [“@babel/preset-env”]<br />
}<br />
src/index.js</p><br />
<br />
<p>package.json<br />
{<br />
  “scripts”: {<br />
    “dev”: “npx webpack-dev-server –mode=development –colors”,<br />
    “dist”: “npx webpack –mode=production”,</p><br />
<ul><br />
  <li>“build”: “npx webpack –mode=development –colors”<br />
  }<br />
}<br />
运行webpack<br />
yarn run build<br />
打包完成后我们打开dist目录下main.js，最下面能后找到</li><br />
</ul><br />
<br />
<p>/<strong><em>/ “./src/index.js”:<br />
/</em>!</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>!<em><br /><br />
  !</em></strong> ./src/index.js <strong><em>!<br />
  *</em></strong><strong>**</strong><strong>**</strong><strong>**</strong>/<br />
/<em>! no static exports found */<br />
/</em>**/ (function(module, exports) {</p><br />
<br />
<p>eval(“var arr = [new Promise(function () {}), new Promise(function () {})];\narr.map(function (val) {\n  console.log(val);\n});\n\n//# sourceURL=webpack:///./src/index.js?”);</p><br />
<br />
<p>/***/ })<br />
我们看到ES6语法被转换成了ES5语法，但是只转换了一部分，比如在低版本浏览中还是识别不了Promise、Map这样的语法。</p><br />
<br />
<p>2.兼容低版本浏览器<br />
安装babel/polyfill<br />
yarn add @babel/polyfill<br />
src/index.js</p><br />
<ul><br />
  <li>import “@babel/polyfill”;<br />
const arr = [<br />
  new Promise(() =&gt; {}),<br />
  new Promise(() =&gt; {})<br />
]</li><br />
</ul><br />
<br />
<p>arr.map(val =&gt; {<br />
    console.log(val)<br />
})<br />
运行webpack</p><br />
<br />
<p>yarn run build</p><br />
<br />
<p>从webpack打包输出的信息中可以看到，Promise和Map方法@babel/polyfill自己帮我们做了实现。可是dist/mian.js文件突然增大到941kb，原因就是<br />
main.js文件将整个polyfill都打包进来。我们想要的其实在main.js中用到的方法帮助我们实现，如果没有用到，就不需要打包进main.js。</p><br />
<br />
<p>3.精简代码<br />
.babelrc<br />
{<br />
  “presets”: [<br />
        [<br />
            “@babel/preset-env”,</p><br />
<ul><br />
  <li>{</li><br />
  <li>“useBuiltIns”: “usage”<br />
            }<br />
        ]<br />
    ]<br />
}<br />
运行webpack<br />
yarn run build<br />
ssl<br />
当我们在.babelrc文件中配置”useBuiltIns”: “usage”，我们发现打包出来的main.js文件大小变成29kb。”useBuiltIns”: “usage”作用就是当polyfill去往低版本浏览器添加一些特性的时候，不是把所有的特性都加进了，而是根据你的业务代码来决定添加什么。</li><br />
</ul><br />
<br />
<p>4.设置浏览器版本<br />
.babelrc<br />
{<br />
  “presets”: [<br />
        [<br />
            “@babel/preset-env”,</p><br />
<ul><br />
  <li>{</li><br />
  <li>“targets”: {</li><br />
  <li>“edge”: “17”,</li><br />
  <li>“firefox”: “60”,</li><br />
  <li>“safari”: “11.1”,</li><br />
  <li>“chrome”: “67”</li><br />
  <li>},</li><br />
  <li>“useBuiltIns”: “usage”<br />
            }<br />
        ]<br />
    ]<br />
}<br />
“chrome”: “67”指编译的代码要运行在67版本的chrom浏览器上，如果67版本chrom支持promis等新语法，则不转换，否则进行转换。</li><br />
</ul><br />
<br />
<p>运行webpack<br />
yarn run build<br />
5.插件开发<br />
上面教程如果我们开发项目，完全够用了。但是当我们开发插件时就会有问题，因为上面是将promis等新特性的实现通过全局变量来注入，会污染全局环境。而且写代码还要在js前面添加import “@babel/polyfill”。所以小菜建议下面这种方式</p><br />
<br />
<p>安装pluginTransformRuntime<br />
yarn add @babel/plugin-transform-runtime<br />
yarn add @babel/runtime<br />
yarn add @babel/runtime-corejs2<br />
.babelrc<br />
{<br />
    “presets”: [<br />
        [<br />
            “@babel/preset-env”,<br />
            {<br />
                “targets”: {<br />
                    “chrome”: “67”<br />
                },<br />
                “useBuiltIns”: “usage”<br />
            }<br />
        ]<br />
    ],</p><br />
<ul><br />
  <li>“plugins”: [</li><br />
  <li>[</li><br />
  <li>“@babel/plugin-transform-runtime”,</li><br />
  <li>{</li><br />
  <li>“absoluteRuntime”: false,</li><br />
  <li>“corejs”: 2,</li><br />
  <li>“helpers”: true,</li><br />
  <li>“regenerator”: true,</li><br />
  <li>“useESModules”: false</li><br />
  <li>}</li><br />
  <li>]</li><br />
  <li>]<br />
}<br />
运行webpack<br />
yarn run build<br />
打开dist/main.js文件</li><br />
</ul><br />
<br />
<p>/<strong><em>/ “./src/index.js”:<br />
/</em>!</strong><strong>**</strong><strong>**</strong><strong>**</strong><strong>!<em><br /><br />
  !</em></strong> ./src/index.js <strong><em>!<br />
  *</em></strong><strong>**</strong><strong>**</strong><strong>**</strong>/<br />
/<em>! no exports provided */<br />
/</em>**/ (function(module, <strong>webpack_exports</strong>, <strong>webpack_require</strong>) {</p><br />
<br />
<p>“use strict”;<br />
eval(“<strong>webpack_require</strong>.r(<strong>webpack_exports</strong>);\n/* harmony import <em>/ var _babel_runtime_corejs2_core_js_promise__WEBPACK_IMPORTED_MODULE_0__ = <strong>webpack_require</strong>(/</em>! @babel/runtime-corejs2/core-js/promise <em>/ "./node_modules/@babel/runtime-corejs2/core-js/promise.js");\n/</em> harmony import <em>/ var _babel_runtime_corejs2_core_js_promise__WEBPACK_IMPORTED_MODULE_0<strong>_default = /*#__PURE</strong></em>/<strong>webpack_require</strong>.n(<em>babel_runtime_corejs2_core_js_promise__WEBPACK_IMPORTED_MODULE_0<strong>);\n\nconst arr = [new _babel_runtime_corejs2_core_js_promise__WEBPACK_IMPORTED_MODULE_0</strong>_default.a(() =&gt; {}), new _babel_runtime_corejs2_core_js_promise__WEBPACK_IMPORTED_MODULE_0</em>__default.a(() =&gt; {})];\narr.map(val =&gt; {\n  console.log(val);\n});\n\n//# sourceURL=webpack:///./src/index.js?”);</p><br />
<br />
<p>/***/ })<br />
从打包的代码我们可以看到，向Promise和Map都帮助我们实现了。</p><br />
<br />
<p>js模块化进程的起因<br />
现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。当一个项目开发的越来越复杂的时候，你会遇到一些问题：命名冲突（变量和函数命名可能相同），文件依赖（引入外部的文件数目、顺序问题）等。</p><br />
<br />
<p>JavaScript发展的越来越快，超过了它产生时候的自我定位。这时候js模块化就出现了。</p><br />
<br />
<p>什么是模块化<br />
模块化开发是一种管理方式，是一种生产方式，一种解决问题的方案。他按照功能将一个软件切分成许多部分单独开发,然后再组装起来,每一个部分即为模块。当使用模块化开发的时候可以避免刚刚的问题，并且让开发的效率变高，以及方便后期的维护。</p><br />
<br />
<p>js模块化进程<br />
一、早期：script标签<br />
这是最原始的 JavaScript 文件加载方式，如果把每一个文件看做是一个模块，那么他们的接口通常是暴露在全局作用域下，也就是定义在 window 对象中。</p><br />
<br />
<p>缺点： <br />
1.污染全局作用域 <br />
2.只能按script标签书写顺序加载 <br />
3.文件依赖关系靠开发者主观解决</p><br />
<br />
<p>二、发展一：CommonJS规范<br />
允许模块通过require方法来同步加载（同步意味阻塞）所要依赖的其他模块，然后通过module.exports来导出需要暴露的接口。</p><br />
<br />
<p>// module add.js<br />
module.exports = function add (a, b) { return a + b; }</p><br />
<br />
<p>// main.js<br />
var {add} = require(‘./math’);<br />
console.log(‘1 + 2 = ‘ + add(1,2);</p><br />
<br />
<p>CommonJS 是以在浏览器环境之外构建JavaScript 生态系统为目标而产生的项目，比如在服务器和桌面环境中。</p><br />
<br />
<p>三、发展二：AMD/CMD<br />
（1）AMD<br />
AMD 是 RequireJS 在推广过程中对模块定义的规范化产出（异步模块定义）。</p><br />
<br />
<p>AMD标准中定义了以下两个API：</p><br />
<br />
<p>require([module], callback);<br />
define(id, [depends], callback);<br />
require接口用来加载一系列模块，define接口用来定义并暴露一个模块。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>define(['./a', './b'], function(a, b) {  <br />
    // 依赖必须一开始就写好   <br />
    a.add1()    <br />
    ...  <br />
    b.add2()    <br />
    ...<br />
}) <br />
</code></pre></div></div><br />
<br />
<p>优点： <br />
1、适合在浏览器环境中异步加载模块 2、可以并行加载多个模块</p><br />
<br />
<p>（2）CMD<br />
CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。(在CommomJS和AMD基础上提出)</p><br />
<br />
<p>define(function (requie, exports, module) { <br />
    //依赖可以就近书写 <br />
    var a = require(‘./a’); <br />
    a.add1(); <br />
    … <br />
    if (status) { <br />
        var b = requie(‘./b’); <br />
        b.add2(); <br />
    } <br />
}); <br />
优点： <br />
1、依赖就近，延迟执行 2、可以很容易在服务器中运行</p><br />
<br />
<p>（3）AMD 和 CMD 的区别<br />
AMD和CMD起来很相似，但是还是有一些细微的差别：</p><br />
<br />
<p>1、对于依赖的模块，AMD是提前执行，CMD是延迟执行。</p><br />
<br />
<p>2、AMD推崇依赖前置；CMD推崇依赖就近，只有在用到某个模块的时候再去require。</p><br />
<br />
<p>3、AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一</p><br />
<br />
<p>四、发展三：ES6模块化<br />
EcmaScript6 标准增加了JavaScript语言层面的模块体系定义。</p><br />
<br />
<p>在 ES6 中，我们使用export关键字来导出模块，使用import关键字引用模块。</p><br />
<br />
<p>// module math.jsx<br />
export default class Math extends React.Component{}</p><br />
<br />
<p>// main.js<br />
import Math from “./Math”;<br />
目前很少JS引擎能直接支持 ES6 标准，因此 Babel 的做法实际上是将不被支持的import翻译成目前已被支持的require。</p><br />
<br />
<p>ES6详解八：模块（Module）<br />
基本用法<br />
命名导出(named exports)<br />
可以直接在任何变量或者函数前面加上一个 export 关键字，就可以将它导出。 <br />
这种写法非常简洁，和平时几乎没有区别，唯一的区别就是在需要导出的地方加上一个 export 关键字。 <br />
比如：</p><br />
<br />
<p>export const sqrt = Math.sqrt;<br />
export function square(x) {<br />
    return x * x;<br />
}<br />
export function diag(x, y) {<br />
    return sqrt(square(x) + square(y));<br />
}</p><br />
<br />
<p>然后在另一个文件中这样引用：</p><br />
<br />
<p>import { square, diag } from ‘lib’;<br />
console.log(square(11)); // 121<br />
console.log(diag(4, 3));</p><br />
<br />
<p>你可能会注意到这个奇怪的语法 { square, diag } 不就是前面讲过的 destructing吗。所以你会以为还可以这样写：</p><br />
<br />
<p>import lib from ‘lib’;<br />
 square = lib.square;<br />
但是其实这样是错的，因为 import { square, diag } from ‘lib’; 是import的特有语法，并不是 destructing 语法，所以其实import的时候并不是直接把整个模块以对象的形式引入的。</p><br />
<br />
<p>如果你希望能通过 lib.square 的形式来写，你应该这样导入：</p><br />
<br />
<p>import * as lib from ‘lib’;<br />
 square = lib.square;<br />
不过值得注意的一点是，如果你直接用babel编译，执行是会报错的。因为 babel 并不会完全编译 modules，他只是把 ES6 的modules语法编译成了 CMD 的语法，所以还需要用 browserify 之类的工具再次编译一遍。 <br />
如果你发现 browserify 找不到 lib，可以改成 from ‘./lib’ 试试。</p><br />
<br />
<p>默认导出<br />
大家会发现上面的写法比较麻烦，因为必须要指定一个名字。其实很多时候一个模块只导出了一个变量，根本没必要指定一个名字。 <br />
还有一种用法叫默认导出，就是指定一个变量作为默认值导出：</p><br />
<br />
<p>//—— myFunc.js ——<br />
export default function () { … };</p><br />
<br />
<p>//—— main1.js ——<br />
import myFunc from ‘myFunc’;<br />
myFunc();<br />
默认导出的时候不需要指定一个变量名，它默认就是文件名。 <br />
这里的区别不仅仅是不用写名字，而是 导出的默认值就是模块本身，而不是模块下面的一个属性，即是 import myFunc from ‘myFunc’; 而不是 import {myFunc} from ‘myFunc’;</p><br />
<br />
<p>命名导出结合默认导出<br />
默认导出同样可以结合命名导出来使用：</p><br />
<br />
<p>export default function (obj) {<br />
    …<br />
};<br />
export function each(obj, iterator, context) {<br />
    …<br />
}<br />
export { each as forEach };<br />
上面的代码导出了一个默认的函数，然后由导出了两个命名函数，我们可以这样导入：</p><br />
<br />
<p>import _, { each } from ‘underscore’;<br />
注意这个逗号语法，分割了默认导出和命名导出</p><br />
<br />
<p>其实这个默认导出只是一个特殊的名字叫 default，你也可以就直接用他的名字，把它当做命名导出来用，下面两种写法是等价的：</p><br />
<br />
<p>import { default as foo } from ‘lib’;<br />
import foo from ‘lib’;<br />
同样的，你也可以通过显示指定 default 名字来做默认导出, 下面两种写法是一样的：</p><br />
<br />
<p>//—— module1.js ——<br />
export default 123;</p><br />
<br />
<p>//—— module2.js ——<br />
const D = 123;<br />
export { D as default };<br />
仅支持静态导入导出<br />
ES6规范只支持静态的导入和导出，也就是必须要在编译时就能确定，在运行时才能确定的是不行的，比如下面的代码就是不对的：</p><br />
<br />
<p>//动态导入<br />
var mylib;<br />
if (Math.random()) {<br />
    mylib = require(‘foo’);<br />
} else {<br />
    mylib = require(‘bar’);<br />
}<br />
//动态导出<br />
if (Math.random()) {<br />
    exports.baz = …;<br />
}<br />
为什么要这么做，主要是两点：</p><br />
<br />
<p>性能，在编译阶段即完成所有模块导入，如果在运行时进行会降低速度<br />
更好的检查错误，比如对变量类型进行检查<br />
各种导入和导出方式总结<br />
总结一下，ES6提供了如下几种导入方式：</p><br />
<br />
<p>// Default exports and named exports<br />
import theDefault, { named1, named2 } from ‘src/mylib’;<br />
import theDefault from ‘src/mylib’;<br />
import { named1, named2 } from ‘src/mylib’;</p><br />
<br />
<p>// Renaming: import named1 as myNamed1<br />
import { named1 as myNamed1, named2 } from ‘src/mylib’;</p><br />
<br />
<p>// Importing the module as an object<br />
// (with one property per named export)<br />
import * as mylib from ‘src/mylib’;</p><br />
<br />
<p>// Only load the module, don’t import anything<br />
import ‘src/mylib’;<br />
如下几种导出方式：</p><br />
<br />
<p>//命名导出<br />
export var myVar1 = …;<br />
export let myVar2 = …;<br />
export const MY_CONST = …;</p><br />
<br />
<p>export function myFunc() {<br />
    …<br />
}<br />
export function* myGeneratorFunc() {<br />
    …<br />
}<br />
export class MyClass {<br />
    …<br />
}<br />
// default 导出<br />
export default 123;<br />
export default function (x) {<br />
    return x<br />
};<br />
export default x =&gt; x;<br />
export default class {<br />
    constructor(x, y) {<br />
        this.x = x;<br />
        this.y = y;<br />
    }<br />
};<br />
//也可以自己列出所有导出内容<br />
const MY_CONST = …;<br />
function myFunc() {<br />
    …<br />
}</p><br />
<br />
<p>export { MY_CONST, myFunc };<br />
//或者在导出的时候给他们改个名字<br />
export { MY_CONST as THE_CONST, myFunc as theFunc };</p><br />
<br />
<p>//还可以导出从其他地方导入的模块<br />
export * from ‘src/other_module’;<br />
export { foo, bar } from ‘src/other_module’;<br />
export { foo as myFoo, bar } from ‘src/other_module’;</p><br />
<br />
<p>浅谈webpack打包原理<br />
模块化机制<br />
webpack并不强制你使用某种模块化方案，而是通过兼容所有模块化方案让你无痛接入项目。有了webpack，你可以随意选择你喜欢的模块化方案，至于怎么处理模块之间的依赖关系及如何按需打包，webpack会帮你处理好的。</p><br />
<br />
<p>关于模块化的一些内容，可以看看我之前的文章：js的模块化进程</p><br />
<br />
<p>核心思想：<br />
一切皆模块： <br />
正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以require(‘myJSfile.js’)亦可以require(‘myCSSfile.css’)。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。<br />
按需加载： <br />
传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。<br />
文件管理<br />
每个文件都是一个资源，可以用require/import导入js<br />
每个入口文件会把自己所依赖(即require)的资源全部打包在一起，一个资源多次引用的话，只会打包一份<br />
对于多个入口的情况，其实就是分别独立的执行单个入口情况，每个入口文件不相干(可用CommonsChunkPlugin优化)<br />
打包原理<br />
把所有依赖打包成一个bundle.js文件，通过代码分割成单元片段并按需加载。</p><br />
<br />
<p>如图，entry.js是入口文件，调用了util1.js和util2.js，而util1.js又调用了util2.js。</p><br />
<br />
<p>打包后的bundle.js例子</p><br />
<br />
<p>/<strong>**</strong>/ ([<br />
/* 0 <em>/     //模块id<br />
/</em>**/ function(module, exports, <strong>webpack_require</strong>) {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>__webpack_require__(1);     //require资源文件id<br />
__webpack_require__(2);<br />
</code></pre></div></div><br />
<br />
<p>/<strong><em>/ },<br />
/</em> 1 <em>/<br />
/</em></strong>/ function(module, exports, <strong>webpack_require</strong>) {<br />
    //util1.js文件<br />
    <strong>webpack_require</strong>(2);<br />
    var util1=1;<br />
    exports.util1=util1;</p><br />
<br />
<p>/<strong><em>/ },<br />
/</em> 2 <em>/<br />
/</em></strong>/ function(module, exports) {<br />
    //util2.js文件<br />
    var util2=1;<br />
    exports.util2=util2;</p><br />
<br />
<p>/<strong><em>/ }<br />
…<br />
…<br />
/</em></strong>***/ ]);</p><br />
<br />
<p>bundle.js是以模块 id 为记号，通过函数把各个文件依赖封装达到分割效果，如上代码 id 为 0 表示 entry 模块需要的依赖， 1 表示 util1模块需要的依赖<br />
require资源文件 id 表示该文件需要加载的各个模块，如上代码_webpack_require__(1) 表示 util1.js 模块，<strong>webpack_require</strong>(2) 表示 util2.js 模块<br />
exports.util1=util1 模块化的体现，输出该模块</p><br />
<br />
<p> ECMAScript6 实现了很多强大的新特性，借助 ES6 我们能用更加优雅的方式完成许多强大的功能。只是鉴于许多老版本的浏览器尚未支持 ES6 语法，需要在使用之前转换为 ES5 语法，以使其兼容更多的浏览器。而完成这些转换工作的就是 Babel 了。<br />
  Babel 本质就是一个 JavaScript 编译器，通过：</p><br />
<br />
<p>将 JavaScript 源代码解析成抽象语法树（AST）；<br />
将源代码的 AST 结果一系列转换生成目标代码的 AST；<br />
将目标代码的 AST 转换成 JavaScript 代码。<br />
  就可以完成 ES6 代码到 ES5 代码的转换，当然转换的过程会很复杂，我们在这里先了解一下基本的原理。想深入了解的同学可以通过开发自己的 Babel Plugin，熟悉 AST 的操作流程。</p><br />
<br />
<p>  Babel 本身的安装使用是很简单的，针对我们当前的应用，我们可以通过如下过程实现：</p><br />
<br />
<p>安装 babel-core 包：cnpm i –save-dev babel-core；<br />
新建一个 Babel 测试文件 babelTest.js 并使用 babel-core 转换 ES6 代码（我们使用了 ES6 的箭头函数）：<br />
babelTest.js<br />
图片描述<br />
安装上一步中使用的 babel-preset-env 和 babel-preset-stage-0 包：cnpm i –save-dev babel-preset-env babel-preset-stage-0；（babel-preset-env 是一个主流的 Babel 插件数组；Stage-X 是实验阶段的 Presets，）<br />
TC39 将提案分为以下几个阶段:<br />
Stage 0 - 稻草人: 只是一个想法，可能是 babel 插件。<br />
Stage 1 - 提案: 初步尝试。<br />
Stage 2 - 初稿: 完成初步规范。<br />
Stage 3 - 候选: 完成规范和浏览器初步实现。<br />
Stage 4 - 完成: 将被添加到下一年度发布。<br />
在当前目录执行 babelTest.js 文件：node babelTest.js，控制台输出信息：<br />
图片描述</p><br />
<br />
<p>可以看到我们的 ES6 箭头函数被转换为了 ES5的 ‘(function() {})’。<br />
  了解了 Babel 的基本工作原理，现在让我们用 ES6 的新特性，稍微改写一下我们的 index.js：</p><br />
<br />
<p>index.js<br />
图片描述</p><br />
<br />
<p>  在这里我们用了 ES6 的模板字符串和箭头函数。模板字符串通过用反引号（`）标识字符串，可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br />
  在没有配置 Babel 的情况下，我们通过 webpack 命令打包，可以发现生成的 test.js 文件还是用的 ES6 语法：</p><br />
<br />
<p>test.js<br />
图片描述</p><br />
<br />
<p>注：截图部分是 test.js 的最后参数部分。</p><br />
<br />
<p>  下面让我们看一下如何将 Babel 结合到 webpack 中，来实现 ES6 代码到 ES5 代码的转换。</p><br />
<br />
<p>四、webpack + Babel 构建 ES6 开发平台<br />
  既然要将 webpack 和 Babel 结合在一起，就需要在两者之间建立一条纽带，而通过 webpack 的 loaders 就可以生成这条纽带，现在让我们修改我们的 webpack.config.js 配置文件：</p><br />
<br />
<p>webpack.config.js<br />
图片描述</p><br />
<br />
<p>  可以看到我们在这里加了一段 module.rules 配置项，rules 数组里的每一项就是一条 loader 使用规则，loader 用于对不同类型文件的源代码进行转换，可以使你在 import 或”加载”模块时预处理文件。<br />
  现在我们配置的第一条规则，就是针对以 .js 结尾的文件使用 babel-loader。由于现在我们的项目中还不存在 babel-loader，让我们先通过 cnpm 安装该模块： cnpm i –save-dev babel-loader。</p><br />
<br />
<p>  现在我们已经准备好了 webpack、webpack 和 Babel 的纽带，接下来就需要准备 Babel 的相关配置了。<br />
  在上一节已经介绍了单独使用 Babel 的实现方法，但是在 webpack 中一般情况下我们不会主动调用 babel-core 解析 ES6 代码，而是通过 babel-loader 在 webpack 编译过程中自动解析 ES6 代码。那么现在的问题就是在上一节使用 babel-core 的过程中，我们使用了 env 和 stage-0 两个 preset，现在不使用 babel-core 了，这两个 preset 又应该在哪里配置？<br />
  这里我们有两种方式可以实现上述配置：</p><br />
<br />
<p>使用 Babel 提供的方法：通过 Babel 目录下的 .babelrc 配置文件完成配置（直接创建 .babelrc 文件可能会有命名规范的问题，可以通过 VS Code、Sublime 等编辑器创建该文件）。这里的 .babelrc 就类似于 webpack.config.js 的作用，只是 .babelrc 文件是在 babel-loader 执行的过程中使用的。<br />
.babelrc<br />
图片描述<br />
使用 webpack 提供的方法：在 webpack.config.js 的 module.rules 规则中，我们还可以通过使用 loader 语法配置 Babel 的 presets：<br />
webpack.config.js<br />
图片描述<br />
  我们采用第一种方式配置 .babelrc 文件，项目目录结构如下：<br />
图片描述</p><br />
<br />
<p>  现在让我们在当前目录下执行 webpack 命令并查看生成的 test.js 文件，可以发现我们的 index.js 已经被转换成 ES5 代码了：<br />
  <br />
 https://webpack.js.org/</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category web
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>