<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">node</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-02-17T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Feb 17, 2020</time></p>
					</div>
					 <p>Node.js 创建第一个应用<br />
如果我们使用 PHP 来编写后端的代码时，需要 Apache 或者 Nginx 的 HTTP 服务器，并配上 mod_php5 模块和 php-cgi。</p><br />
<br />
<p>从这个角度看，整个”接收 HTTP 请求并提供 Web 页面”的需求就不需要 PHP 来处理。</p><br />
<br />
<p>不过对 Node.js 来说，概念完全不一样了。使用 Node.js 时，我们不仅仅 在实现一个应用，同时还实现了整个 HTTP 服务器。事实上，我们的 Web 应用以及对应的 Web 服务器基本上是一样的。</p><br />
<br />
<p>在我们创建 Node.js 第一个 “Hello, World!” 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的：</p><br />
<br />
<p>引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。</p><br />
<br />
<p>创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</p><br />
<br />
<p>接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。</p><br />
<br />
<p>创建 Node.js 应用<br />
步骤一、引入 required 模块<br />
我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p><br />
<br />
<p>var http = require(“http”);<br />
步骤二、创建服务器<br />
接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。</p><br />
<br />
<p>实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p><br />
<br />
<p>var http = require(‘http’);</p><br />
<br />
<p>http.createServer(function (request, response) {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 发送 HTTP 头部 <br />
// HTTP 状态值: 200 : OK<br />
// 内容类型: text/plain<br />
response.writeHead(200, {'Content-Type': 'text/plain'});<br />
<br />
// 发送响应数据 "Hello World"<br />
response.end('Hello World\n'); }).listen(8888);<br />
</code></pre></div></div><br />
<br />
<p>// 终端打印如下信息<br />
console.log(‘Server running at http://127.0.0.1:8888/’);<br />
以上代码我们完成了一个可以工作的 HTTP 服务器。</p><br />
<br />
<p>使用 node 命令执行以上的代码：</p><br />
<br />
<p>node server.js<br />
Server running at http://127.0.0.1:8888/<br />
<!-- more --><br />
NPM 使用介绍<br />
NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p><br />
<br />
<p>允许用户从NPM服务器下载别人编写的第三方包到本地使用。<br />
允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。<br />
允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。<br />
由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功:</p><br />
<br />
<p>$ npm -v<br />
2.3.0<br />
如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：</p><br />
<br />
<p>$ sudo npm install npm -g<br />
/usr/local/bin/npm -&gt; /usr/local/lib/node_modules/npm/bin/npm-cli.js<br />
npm@2.14.2 /usr/local/lib/node_modules/npm<br />
如果是 Window 系统使用以下命令即可：</p><br />
<br />
<p>npm install npm -g<br />
使用淘宝镜像的命令：</p><br />
<br />
<p>npm install -g cnpm –registry=https://registry.npm.taobao.org<br />
使用 npm 命令安装模块<br />
npm 安装 Node.js 模块语法格式如下：</p><br />
<br />
<p>$ npm install <Module Name=""><br />
以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express:</Module></p><br />
<br />
<p>$ npm install express<br />
安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。</p><br />
<br />
<p>var express = require(‘express’);<br />
全局安装与本地安装<br />
npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如</p><br />
<br />
<p>npm install express          # 本地安装<br />
npm install express -g   # 全局安装<br />
如果出现以下错误：</p><br />
<br />
<p>npm err! Error: connect ECONNREFUSED 127.0.0.1:8087 <br />
解决办法为：</p><br />
<br />
<p>$ npm config set proxy null<br />
本地安装</p><br />
<ol><br />
  <li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li><br />
  <li>可以通过 require() 来引入本地安装的包。<br />
全局安装</li><br />
  <li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li><br />
  <li>可以直接在命令行里使用。<br />
如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。</li><br />
</ol><br />
<br />
<p>接下来我们使用全局方式安装 express</p><br />
<br />
<p>$ npm install express -g<br />
安装过程输出如下内容，第一行输出了模块的版本号及安装位置。</p><br />
<br />
<p>express@4.13.3 node_modules/express<br />
├── escape-html@1.0.2<br />
├── range-parser@1.0.2<br />
├── merge-descriptors@1.0.0<br />
├── array-flatten@1.1.1<br />
├── cookie@0.1.3<br />
├── utils-merge@1.0.0<br />
├── parseurl@1.3.0<br />
├── cookie-signature@1.0.6<br />
├── methods@1.1.1<br />
├── fresh@0.3.0<br />
├── vary@1.0.1<br />
├── path-to-regexp@0.1.7<br />
├── content-type@1.0.1<br />
├── etag@1.7.0<br />
├── serve-static@1.10.0<br />
├── content-disposition@0.5.0<br />
├── depd@1.0.1<br />
├── qs@4.0.0<br />
├── finalhandler@0.4.0 (unpipe@1.0.0)<br />
├── on-finished@2.3.0 (ee-first@1.1.1)<br />
├── proxy-addr@1.0.8 (forwarded@0.1.0, ipaddr.js@1.0.1)<br />
├── debug@2.2.0 (ms@0.7.1)<br />
├── type-is@1.6.8 (media-typer@0.3.0, mime-types@2.1.6)<br />
├── accepts@1.2.12 (negotiator@0.5.3, mime-types@2.1.6)<br />
└── send@0.13.0 (destroy@1.0.3, statuses@1.2.1, ms@0.7.1, mime@1.3.4, http-errors@1.3.1)<br />
查看安装信息<br />
你可以使用以下命令来查看所有全局安装的模块：</p><br />
<br />
<p>$ npm list -g</p><br />
<br />
<p>├─┬ cnpm@4.3.2<br />
│ ├── auto-correct@1.0.0<br />
│ ├── bagpipe@0.3.5<br />
│ ├── colors@1.1.2<br />
│ ├─┬ commander@2.9.0<br />
│ │ └── graceful-readlink@1.0.1<br />
│ ├─┬ cross-spawn@0.2.9<br />
│ │ └── lru-cache@2.7.3<br />
……<br />
如果要查看某个模块的版本号，可以使用命令如下：</p><br />
<br />
<p>$ npm list grunt</p><br />
<br />
<p>projectName@projectVersion /path/to/project/folder<br />
└── grunt@0.4.1<br />
使用 package.json<br />
package.json 位于模块的目录下，用于定义包的属性。接下来让我们来看下 express 包的 package.json 文件，位于 node_modules/express/package.json 内容：</p><br />
<br />
<p>{<br />
  “name”: “express”,<br />
  “description”: “Fast, unopinionated, minimalist web framework”,<br />
  “version”: “4.13.3”,<br />
  “author”: {<br />
    “name”: “TJ Holowaychuk”,<br />
    “email”: “tj@vision-media.ca”<br />
  },<br />
  “contributors”: [<br />
    {<br />
      “name”: “Aaron Heckmann”,<br />
      “email”: “aaron.heckmann+github@gmail.com”<br />
    },<br />
    {<br />
      “name”: “Ciaran Jessup”,<br />
      “email”: “ciaranj@gmail.com”<br />
    },<br />
    {<br />
      “name”: “Douglas Christopher Wilson”,<br />
      “email”: “doug@somethingdoug.com”<br />
    },<br />
    {<br />
      “name”: “Guillermo Rauch”,<br />
      “email”: “rauchg@gmail.com”<br />
    },<br />
    {<br />
      “name”: “Jonathan Ong”,<br />
      “email”: “me@jongleberry.com”<br />
    },<br />
    {<br />
      “name”: “Roman Shtylman”,<br />
      “email”: “shtylman+expressjs@gmail.com”<br />
    },<br />
    {<br />
      “name”: “Young Jae Sim”,<br />
      “email”: “hanul@hanul.me”<br />
    }<br />
  ],<br />
  “license”: “MIT”,<br />
  “repository”: {<br />
    “type”: “git”,<br />
    “url”: “git+https://github.com/strongloop/express.git”<br />
  },<br />
  “homepage”: “http://expressjs.com/”,<br />
  “keywords”: [<br />
    “express”,<br />
    “framework”,<br />
    “sinatra”,<br />
    “web”,<br />
    “rest”,<br />
    “restful”,<br />
    “router”,<br />
    “app”,<br />
    “api”<br />
  ],<br />
  “dependencies”: {<br />
    “accepts”: “~1.2.12”,<br />
    “array-flatten”: “1.1.1”,<br />
    “content-disposition”: “0.5.0”,<br />
    “content-type”: “~1.0.1”,<br />
    “cookie”: “0.1.3”,<br />
    “cookie-signature”: “1.0.6”,<br />
    “debug”: “~2.2.0”,<br />
    “depd”: “~1.0.1”,<br />
    “escape-html”: “1.0.2”,<br />
    “etag”: “~1.7.0”,<br />
    “finalhandler”: “0.4.0”,<br />
    “fresh”: “0.3.0”,<br />
    “merge-descriptors”: “1.0.0”,<br />
    “methods”: “~1.1.1”,<br />
    “on-finished”: “~2.3.0”,<br />
    “parseurl”: “~1.3.0”,<br />
    “path-to-regexp”: “0.1.7”,<br />
    “proxy-addr”: “~1.0.8”,<br />
    “qs”: “4.0.0”,<br />
    “range-parser”: “~1.0.2”,<br />
    “send”: “0.13.0”,<br />
    “serve-static”: “~1.10.0”,<br />
    “type-is”: “~1.6.6”,<br />
    “utils-merge”: “1.0.0”,<br />
    “vary”: “~1.0.1”<br />
  },<br />
  “devDependencies”: {<br />
    “after”: “0.8.1”,<br />
    “ejs”: “2.3.3”,<br />
    “istanbul”: “0.3.17”,<br />
    “marked”: “0.3.5”,<br />
    “mocha”: “2.2.5”,<br />
    “should”: “7.0.2”,<br />
    “supertest”: “1.0.1”,<br />
    “body-parser”: “~1.13.3”,<br />
    “connect-redis”: “~2.4.1”,<br />
    “cookie-parser”: “~1.3.5”,<br />
    “cookie-session”: “~1.2.0”,<br />
    “express-session”: “~1.11.3”,<br />
    “jade”: “~1.11.0”,<br />
    “method-override”: “~2.3.5”,<br />
    “morgan”: “~1.6.1”,<br />
    “multiparty”: “~4.1.2”,<br />
    “vhost”: “~3.0.1”<br />
  },<br />
  “engines”: {<br />
    “node”: “&gt;= 0.10.0”<br />
  },<br />
  “files”: [<br />
    “LICENSE”,<br />
    “History.md”,<br />
    “Readme.md”,<br />
    “index.js”,<br />
    “lib/”<br />
  ],<br />
  “scripts”: {<br />
    “test”: “mocha –require test/support/env –reporter spec –bail –check-leaks test/ test/acceptance/”,<br />
    “test-ci”: “istanbul cover node_modules/mocha/bin/_mocha –report lcovonly – –require test/support/env –reporter spec –check-leaks test/ test/acceptance/”,<br />
    “test-cov”: “istanbul cover node_modules/mocha/bin/_mocha – –require test/support/env –reporter dot –check-leaks test/ test/acceptance/”,<br />
    “test-tap”: “mocha –require test/support/env –reporter tap –check-leaks test/ test/acceptance/”<br />
  },<br />
  “gitHead”: “ef7ad681b245fba023843ce94f6bcb8e275bbb8e”,<br />
  “bugs”: {<br />
    “url”: “https://github.com/strongloop/express/issues”<br />
  },<br />
  “_id”: “express@4.13.3”,<br />
  “_shasum”: “ddb2f1fb4502bf33598d2b032b037960ca6c80a3”,<br />
  “_from”: “express@*”,<br />
  “_npmVersion”: “1.4.28”,<br />
  “_npmUser”: {<br />
    “name”: “dougwilson”,<br />
    “email”: “doug@somethingdoug.com”<br />
  },<br />
  “maintainers”: [<br />
    {<br />
      “name”: “tjholowaychuk”,<br />
      “email”: “tj@vision-media.ca”<br />
    },<br />
    {<br />
      “name”: “jongleberry”,<br />
      “email”: “jonathanrichardong@gmail.com”<br />
    },<br />
    {<br />
      “name”: “dougwilson”,<br />
      “email”: “doug@somethingdoug.com”<br />
    },<br />
    {<br />
      “name”: “rfeng”,<br />
      “email”: “enjoyjava@gmail.com”<br />
    },<br />
    {<br />
      “name”: “aredridel”,<br />
      “email”: “aredridel@dinhe.net”<br />
    },<br />
    {<br />
      “name”: “strongloop”,<br />
      “email”: “callback@strongloop.com”<br />
    },<br />
    {<br />
      “name”: “defunctzombie”,<br />
      “email”: “shtylman@gmail.com”<br />
    }<br />
  ],<br />
  “dist”: {<br />
    “shasum”: “ddb2f1fb4502bf33598d2b032b037960ca6c80a3”,<br />
    “tarball”: “http://registry.npmjs.org/express/-/express-4.13.3.tgz”<br />
  },<br />
  “directories”: {},<br />
  “_resolved”: “https://registry.npmjs.org/express/-/express-4.13.3.tgz”,<br />
  “readme”: “ERROR: No README data found!”<br />
}<br />
Package.json 属性说明<br />
name - 包名。</p><br />
<br />
<p>version - 包的版本号。</p><br />
<br />
<p>description - 包的描述。</p><br />
<br />
<p>homepage - 包的官网 url 。</p><br />
<br />
<p>author - 包的作者姓名。</p><br />
<br />
<p>contributors - 包的其他贡献者姓名。</p><br />
<br />
<p>dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</p><br />
<br />
<p>repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。</p><br />
<br />
<p>main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。</p><br />
<br />
<p>keywords - 关键字</p><br />
<br />
<p>卸载模块<br />
我们可以使用以下命令来卸载 Node.js 模块。</p><br />
<br />
<p>$ npm uninstall express<br />
卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：</p><br />
<br />
<p>$ npm ls<br />
更新模块<br />
我们可以使用以下命令更新模块：</p><br />
<br />
<p>$ npm update express<br />
搜索模块<br />
使用以下来搜索模块：</p><br />
<br />
<p>$ npm search express<br />
创建模块<br />
创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。</p><br />
<br />
<p>$ npm init<br />
This utility will walk you through creating a package.json file.<br />
It only covers the most common items, and tries to guess sensible defaults.</p><br />
<br />
<p>See <code class="language-plaintext highlighter-rouge">npm help json</code> for definitive documentation on these fields<br />
and exactly what they do.</p><br />
<br />
<p>Use <code class="language-plaintext highlighter-rouge">npm install &lt;pkg&gt; --save</code> afterwards to install a package and<br />
save it as a dependency in the package.json file.</p><br />
<br />
<p>Press ^C at any time to quit.<br />
name: (node_modules) runoob                   # 模块名<br />
version: (1.0.0) <br />
description: Node.js 测试模块(www.runoob.com)  # 描述<br />
entry point: (index.js) <br />
test command: make test<br />
git repository: https://github.com/runoob/runoob.git  # Github 地址<br />
keywords: <br />
author: <br />
license: (ISC) <br />
About to write to ……/node_modules/package.json:      # 生成地址</p><br />
<br />
<p>{<br />
  “name”: “runoob”,<br />
  “version”: “1.0.0”,<br />
  “description”: “Node.js 测试模块(www.runoob.com)”,<br />
  ……<br />
}</p><br />
<br />
<p>Is this ok? (yes) yes<br />
以上的信息，你需要根据你自己的情况输入。在最后输入 “yes” 后会生成 package.json 文件。</p><br />
<br />
<p>接下来我们可以使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：</p><br />
<br />
<p>$ npm adduser<br />
Username: mcmohd<br />
Password:<br />
Email: (this IS public) mcmohd@gmail.com<br />
接下来我们就用以下命令来发布模块：</p><br />
<br />
<p>$ npm publish<br />
如果你以上的步骤都操作正确，你就可以跟其他模块一样使用 npm 来安装。</p><br />
<br />
<p>版本号<br />
使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p><br />
<br />
<p>语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p><br />
<br />
<p>如果只是修复bug，需要更新Z位。<br />
如果是新增了功能，但是向下兼容，需要更新Y位。<br />
如果有大变动，向下不兼容，需要更新X位。<br />
版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如”argv”: “0.0.x”表示依赖于0.0.x系列的最新版argv。</p><br />
<br />
<p>NPM支持的所有版本号范围指定方式可以查看官方文档。</p><br />
<br />
<p>NPM 常用命令<br />
除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。</p><br />
<br />
<p>除了可以在npmjs.org/doc/查看官方文档外，这里再介绍一些NPM常用命令。</p><br />
<br />
<p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p><br />
<br />
<p>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p><br />
<br />
<p>使用npm help <command />可查看某条命令的详细帮助，例如npm help install。</p><br />
<br />
<p>在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。</p><br />
<br />
<p>使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</package></p><br />
<br />
<p>使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。</package></p><br />
<br />
<p>使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p><br />
<br />
<p>使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。</version></package></p><br />
<br />
<p>使用淘宝 NPM 镜像<br />
大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</p><br />
<br />
<p>淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p><br />
<br />
<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p><br />
<br />
<p>$ npm install -g cnpm –registry=https://registry.npm.taobao.org<br />
这样就可以使用 cnpm 命令来安装模块了：</p><br />
<br />
<p>$ cnpm install [name]<br />
更多信息可以查阅：http://npm.taobao.org/。</p><br />
<br />
<p>Node.js REPL(交互式解释器)<br />
Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。</p><br />
<br />
<p>Node 自带了交互式解释器，可以执行以下任务：</p><br />
<br />
<p>读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</p><br />
<br />
<p>执行 - 执行输入的数据结构</p><br />
<br />
<p>打印 - 输出结果</p><br />
<br />
<p>循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。</p><br />
<br />
<p>Node 的交互式解释器可以很好的调试 Javascript 代码。</p><br />
<br />
<p>开始学习 REPL</p><br />
<br />
<p>我们可以输入以下命令来启动 Node 的终端：</p><br />
<br />
<p>$ node</p><br />
<blockquote><br />
<br />
  <p>这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。</p><br />
</blockquote><br />
<br />
<p>Node.js 回调函数<br />
Node.js 异步编程的直接体现就是回调。</p><br />
<br />
<p>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。</p><br />
<br />
<p>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。</p><br />
<br />
<p>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。</p><br />
<br />
<p>回调函数一般作为函数的最后一个参数出现：</p><br />
<br />
<p>function foo1(name, age, callback) { }<br />
function foo2(value, callback1, callback2) { }<br />
阻塞代码实例<br />
创建一个文件 input.txt ，内容如下：</p><br />
<br />
<p>菜鸟教程官网地址：www.runoob.com<br />
创建 main.js 文件, 代码如下：</p><br />
<br />
<p>var fs = require(“fs”);</p><br />
<br />
<p>var data = fs.readFileSync(‘input.txt’);</p><br />
<br />
<p>console.log(data.toString());<br />
console.log(“程序执行结束!”);<br />
以上代码执行结果如下：</p><br />
<br />
<p>$ node main.js<br />
菜鸟教程官网地址：www.runoob.com</p><br />
<br />
<p>程序执行结束!<br />
非阻塞代码实例<br />
创建一个文件 input.txt ，内容如下：</p><br />
<br />
<p>菜鸟教程官网地址：www.runoob.com<br />
创建 main.js 文件, 代码如下：</p><br />
<br />
<p>var fs = require(“fs”);</p><br />
<br />
<p>fs.readFile(‘input.txt’, function (err, data) {<br />
    if (err) return console.error(err);<br />
    console.log(data.toString());<br />
});</p><br />
<br />
<p>console.log(“程序执行结束!”);<br />
以上代码执行结果如下：</p><br />
<br />
<p>$ node main.js<br />
程序执行结束!<br />
菜鸟教程官网地址：www.runoob.com<br />
以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。</p><br />
<br />
<p>因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内</p><br />
<br />
<p>Node.js 事件循环<br />
Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。</p><br />
<br />
<p>Node.js 几乎每一个 API 都是支持回调函数的。</p><br />
<br />
<p>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。</p><br />
<br />
<p>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p><br />
<br />
<p>事件驱动程序<br />
Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。</p><br />
<br />
<p>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。</p><br />
<br />
<p>这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）</p><br />
<br />
<p>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。</p><br />
<br />
<p>整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。</p><br />
<br />
<p>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p><br />
<br />
<p>// 引入 events 模块<br />
var events = require(‘events’);<br />
// 创建 eventEmitter 对象<br />
var eventEmitter = new events.EventEmitter();<br />
以下程序绑定事件处理程序：</p><br />
<br />
<p>// 绑定事件及事件的处理程序<br />
eventEmitter.on(‘eventName’, eventHandler);<br />
我们可以通过程序触发事件：</p><br />
<br />
<p>// 触发事件<br />
eventEmitter.emit(‘eventName’);<br />
实例<br />
创建 main.js 文件，代码如下所示：</p><br />
<br />
<p>实例<br />
// 引入 events 模块<br />
var events = require(‘events’);<br />
// 创建 eventEmitter 对象<br />
var eventEmitter = new events.EventEmitter();</p><br />
<br />
<p>// 创建事件处理程序<br />
var connectHandler = function connected() {<br />
   console.log(‘连接成功。’);</p><br />
<br />
<p>// 触发 data_received 事件 <br />
   eventEmitter.emit(‘data_received’);<br />
}</p><br />
<br />
<p>// 绑定 connection 事件处理程序<br />
eventEmitter.on(‘connection’, connectHandler);</p><br />
<br />
<p>// 使用匿名函数绑定 data_received 事件<br />
eventEmitter.on(‘data_received’, function(){<br />
   console.log(‘数据接收成功。’);<br />
});</p><br />
<br />
<p>// 触发 connection 事件 <br />
eventEmitter.emit(‘connection’);</p><br />
<br />
<p>console.log(“程序执行完毕。”);<br />
接下来让我们执行以上代码：</p><br />
<br />
<p>$ node main.js<br />
连接成功。<br />
数据接收成功。<br />
程序执行完毕。<br />
Node 应用程序是如何工作的？<br />
在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。</p><br />
<br />
<p>接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：</p><br />
<br />
<p>菜鸟教程官网地址：www.runoob.com<br />
创建 main.js 文件，代码如下：</p><br />
<br />
<p>var fs = require(“fs”);</p><br />
<br />
<p>fs.readFile(‘input.txt’, function (err, data) {<br />
   if (err){<br />
      console.log(err.stack);<br />
      return;<br />
   }<br />
   console.log(data.toString());<br />
});<br />
console.log(“程序执行完毕”);<br />
以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。</p><br />
<br />
<p>如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。</p><br />
<br />
<p>执行以上代码，执行结果如下：</p><br />
<br />
<p>程序执行完毕<br />
菜鸟教程官网地址：www.runoob.com<br />
接下来我们删除 input.txt 文件，执行结果如下所示：</p><br />
<br />
<p>程序执行完毕<br />
Error: ENOENT, open ‘input.txt’<br />
因为文件 input.txt 不存在，所以输出了错误信息。</p><br />
<br />
<p>Node.js EventEmitter<br />
Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。</p><br />
<br />
<p>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p><br />
<br />
<p>EventEmitter 类<br />
events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。</p><br />
<br />
<p>你可以通过require(“events”);来访问该模块。</p><br />
<br />
<p>// 引入 events 模块<br />
var events = require(‘events’);<br />
// 创建 eventEmitter 对象<br />
var eventEmitter = new events.EventEmitter();<br />
EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。</p><br />
<br />
<p>下面我们用一个简单的例子说明 EventEmitter 的用法：</p><br />
<br />
<p>//event.js 文件<br />
var EventEmitter = require(‘events’).EventEmitter; <br />
var event = new EventEmitter(); <br />
event.on(‘some_event’, function() { <br />
    console.log(‘some_event 事件触发’); <br />
}); <br />
setTimeout(function() { <br />
    event.emit(‘some_event’); <br />
}, 1000); <br />
执行结果如下：</p><br />
<br />
<p>运行这段代码，1 秒后控制台输出了 ‘some_event 事件触发’。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。</p><br />
<br />
<p>$ node event.js <br />
some_event 事件触发<br />
EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。</p><br />
<br />
<p>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p><br />
<br />
<p>让我们以下面的例子解释这个过程：</p><br />
<br />
<p>//event.js 文件<br />
var events = require(‘events’); <br />
var emitter = new events.EventEmitter(); <br />
emitter.on(‘someEvent’, function(arg1, arg2) { <br />
    console.log(‘listener1’, arg1, arg2); <br />
}); <br />
emitter.on(‘someEvent’, function(arg1, arg2) { <br />
    console.log(‘listener2’, arg1, arg2); <br />
}); <br />
emitter.emit(‘someEvent’, ‘arg1 参数’, ‘arg2 参数’); <br />
执行以上代码，运行的结果如下：</p><br />
<br />
<p>$ node event.js <br />
listener1 arg1 参数 arg2 参数<br />
listener2 arg1 参数 arg2 参数<br />
以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。</p><br />
<br />
<p>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。</p><br />
<br />
<p>EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p><br />
<br />
<p>方法<br />
序号	方法 &amp; 描述<br />
1	addListener(event, listener)<br />
为指定事件添加一个监听器到监听器数组的尾部。<br />
2	on(event, listener)<br />
为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。<br />
server.on(‘connection’, function (stream) {<br />
  console.log(‘someone connected!’);<br />
});<br />
3	once(event, listener)<br />
为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<br />
server.once(‘connection’, function (stream) {<br />
  console.log(‘Ah, we have our first user!’);<br />
});<br />
4	removeListener(event, listener)<br />
移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。</p><br />
<br />
<p>它接受两个参数，第一个是事件名称，第二个是回调函数名称。</p><br />
<br />
<p>var callback = function(stream) {<br />
  console.log(‘someone connected!’);<br />
};<br />
server.on(‘connection’, callback);<br />
// …<br />
server.removeListener(‘connection’, callback);<br />
5	removeAllListeners([event])<br />
移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。<br />
6	setMaxListeners(n)<br />
默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。<br />
7	listeners(event)<br />
返回指定事件的监听器数组。<br />
8	emit(event, [arg1], [arg2], […])<br />
按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。<br />
类方法<br />
序号	方法 &amp; 描述<br />
1	listenerCount(emitter, event)<br />
返回指定事件的监听器数量。<br />
events.EventEmitter.listenerCount(emitter, eventName) //已废弃，不推荐<br />
events.emitter.listenerCount(eventName) //推荐<br />
事件<br />
序号	事件 &amp; 描述<br />
1	newListener<br />
event - 字符串，事件名称</p><br />
<br />
<p>listener - 处理事件函数</p><br />
<br />
<p>该事件在添加新监听器时被触发。</p><br />
<br />
<p>2	removeListener<br />
event - 字符串，事件名称</p><br />
<br />
<p>listener - 处理事件函数</p><br />
<br />
<p>从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</p><br />
<br />
<p>实例<br />
以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。</p><br />
<br />
<p>创建 main.js 文件，代码如下：</p><br />
<br />
<p>var events = require(‘events’);<br />
var eventEmitter = new events.EventEmitter();</p><br />
<br />
<p>// 监听器 #1<br />
var listener1 = function listener1() {<br />
   console.log(‘监听器 listener1 执行。’);<br />
}</p><br />
<br />
<p>// 监听器 #2<br />
var listener2 = function listener2() {<br />
  console.log(‘监听器 listener2 执行。’);<br />
}</p><br />
<br />
<p>// 绑定 connection 事件，处理函数为 listener1 <br />
eventEmitter.addListener(‘connection’, listener1);</p><br />
<br />
<p>// 绑定 connection 事件，处理函数为 listener2<br />
eventEmitter.on(‘connection’, listener2);</p><br />
<br />
<p>var eventListeners = eventEmitter.listenerCount(‘connection’);<br />
console.log(eventListeners + “ 个监听器监听连接事件。”);</p><br />
<br />
<p>// 处理 connection 事件 <br />
eventEmitter.emit(‘connection’);</p><br />
<br />
<p>// 移除监绑定的 listener1 函数<br />
eventEmitter.removeListener(‘connection’, listener1);<br />
console.log(“listener1 不再受监听。”);</p><br />
<br />
<p>// 触发连接事件<br />
eventEmitter.emit(‘connection’);</p><br />
<br />
<p>eventListeners = eventEmitter.listenerCount(‘connection’);<br />
console.log(eventListeners + “ 个监听器监听连接事件。”);</p><br />
<br />
<p>console.log(“程序执行完毕。”);<br />
以上代码，执行结果如下所示：</p><br />
<br />
<p>$ node main.js<br />
2 个监听器监听连接事件。<br />
监听器 listener1 执行。<br />
监听器 listener2 执行。<br />
listener1 不再受监听。<br />
监听器 listener2 执行。<br />
1 个监听器监听连接事件。<br />
程序执行完毕。<br />
error 事件<br />
EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。</p><br />
<br />
<p>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。</p><br />
<br />
<p>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p><br />
<br />
<p>var events = require(‘events’); <br />
var emitter = new events.EventEmitter(); <br />
emitter.emit(‘error’); <br />
运行时会显示以下错误：</p><br />
<br />
<p>node.js:201 <br />
throw e; // process.nextTick error, or ‘error’ event on first tick</p><br />
<p>Error: Uncaught, unspecified ‘error’ event. <br />
at EventEmitter.emit (events.js:50:15) <br />
at Object.<anonymous> (/home/byvoid/error.js:5:9) <br />
at Module._compile (module.js:441:26) <br />
at Object..js (module.js:459:10) <br />
at Module.load (module.js:348:31) <br />
at Function._load (module.js:308:12) <br />
at Array.0 (module.js:479:10) <br />
at EventEmitter._tickCallback (node.js:192:40) <br />
继承 EventEmitter<br />
大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</anonymous></p><br />
<br />
<p>为什么要这样做呢？原因有两点：</p><br />
<br />
<p>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。</p><br />
<br />
<p>其次 JavaScript 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p><br />
<br />
<p>Node.js Buffer(缓冲区)<br />
JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。</p><br />
<br />
<p>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。</p><br />
<br />
<p>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p><br />
<br />
<p>在v6.0之前创建Buffer对象直接使用new Buffer()构造函数来创建对象实例，但是Buffer对内存的权限操作相比很大，可以直接捕获一些敏感信息，所以在v6.0以后，官方文档里面建议使用 Buffer.from() 接口去创建Buffer对象。</p><br />
<br />
<p>Buffer 与字符编码<br />
Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换。</p><br />
<br />
<p>const buf = Buffer.from(‘runoob’, ‘ascii’);</p><br />
<br />
<p>// 输出 72756e6f6f62<br />
console.log(buf.toString(‘hex’));</p><br />
<br />
<p>// 输出 cnVub29i<br />
console.log(buf.toString(‘base64’));<br />
Node.js 目前支持的字符编码包括：</p><br />
<br />
<p>ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</p><br />
<br />
<p>utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</p><br />
<br />
<p>utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</p><br />
<br />
<p>ucs2 - utf16le 的别名。</p><br />
<br />
<p>base64 - Base64 编码。</p><br />
<br />
<p>latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。</p><br />
<br />
<p>binary - latin1 的别名。</p><br />
<br />
<p>hex - 将每个字节编码为两个十六进制字符。</p><br />
<br />
<p>创建 Buffer 类<br />
Buffer 提供了以下 API 来创建 Buffer 类：</p><br />
<br />
<p>Buffer.alloc(size[, fill[, encoding]])： 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0<br />
Buffer.allocUnsafe(size)： 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据<br />
Buffer.allocUnsafeSlow(size)<br />
Buffer.from(array)： 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）<br />
Buffer.from(arrayBuffer[, byteOffset[, length]])： 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。<br />
Buffer.from(buffer)： 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例<br />
Buffer.from(string[, encoding])： 返回一个被 string 的值初始化的新的 Buffer 实例</p><br />
<br />
<p>Node.js Stream(流)<br />
Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。</p><br />
<br />
<p>Node.js，Stream 有四种流类型：</p><br />
<br />
<p>Readable - 可读操作。</p><br />
<br />
<p>Writable - 可写操作。</p><br />
<br />
<p>Duplex - 可读可写操作.</p><br />
<br />
<p>Transform - 操作被写入数据，然后读出结果。</p><br />
<br />
<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p><br />
<br />
<p>data - 当有数据可读时触发。</p><br />
<br />
<p>end - 没有更多的数据可读时触发。</p><br />
<br />
<p>error - 在接收和写入过程中发生错误时触发。</p><br />
<br />
<p>finish - 所有数据已被写入到底层系统时触发。</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category web
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>