<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">Aviator java的表达式引擎化框架</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-04-16T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 16, 2020</time></p>
					</div>
					 <p>Aviator是一个高性能、轻量级的java语言实现的表达式求值引擎，主要用于各种表达式的动态求值。现在已经有很多开源可用的java表达式求值引擎，为什么还需要Avaitor呢？</p><br />
<br />
<p>Aviator的设计目标是轻量级和高性能 ，相比于Groovy、JRuby的笨重，Aviator非常小，加上依赖包也才450K,不算依赖包的话只有70K；当然，Aviator的语法是受限的，它不是一门完整的语言，而只是语言的一小部分集合。</p><br />
<br />
<p>其次，Aviator的实现思路与其他轻量级的求值器很不相同，其他求值器一般都是通过解释的方式运行，而Aviator则是直接将表达式编译成Java字节码，交给JVM去执行。简单来说，Aviator的定位是介于Groovy这样的重量级脚本语言和IKExpression这样的轻量级表达式引擎之间。<br />
<!-- more --><br />
Aviator的特性</p><br />
<br />
<p>支持大部分运算操作符，包括算术操作符、关系运算符、逻辑操作符、正则匹配操作符(=~)、三元表达式?: ，并且支持操作符的优先级和括号强制优先级，具体请看后面的操作符列表。</p><br />
<br />
<p>支持函数调用和自定义函数</p><br />
<br />
<p>支持正则表达式匹配，类似Ruby、Perl的匹配语法，并且支持类Ruby的$digit指向匹配分组。<br />
自动类型转换，当执行操作的时候，会自动判断操作数类型并做相应转换，无法转换即抛异常。<br />
支持传入变量，支持类似a.b.c的嵌套变量访问。<br />
性能优秀<br />
Aviator的限制：</p><br />
<br />
<p>没有if else、do while等语句，没有赋值语句，仅支持逻辑表达式、算术表达式、三元表达式和正则匹配。<br />
没有位运算符<br />
整体结构¶<br />
Aviator的结构非常简单，一个典型的求值器的结构</p><br />
<br />
<p>依赖包¶<br />
commons-beanutils和commons-logging</p><br />
<br />
<p>使用手册¶<br />
执行表达式¶<br />
Aviator的使用都是集中通过com.googlecode.aviator.AviatorEvaluator这个入口类来处理，最简单的例子，执行一个计算1+2+3的表达式：</p><br />
<br />
<p>import com.googlecode.aviator.AviatorEvaluator; <br />
public class SimpleExample { <br />
    public static void main(String[] args) { <br />
        Long result = (Long) AviatorEvaluator.execute(“1+2+3”); <br />
        System.out.println(result); <br />
    } <br />
}<br />
细心的朋友肯定注意到结果是Long，而不是Integer。这是因为Aviator的数值类型仅支持Long和Double，任何整数都将转换成Long，任何浮点数都将转换为Double，包括用户传入的变量数值。这个例子的打印结果将是正确答案6。</p><br />
<br />
<p>使用变量¶<br />
想让Aviator对你say hello吗？很简单，传入你的名字，让Aviator负责字符串的相加：</p><br />
<br />
<p>import com.googlecode.aviator.AviatorEvaluator;</p><br />
<br />
<p>public class SayHello { <br />
    public static void main(String[] args) { <br />
        if (args.length &lt; 1) { <br />
            System.err.print(“Usesage: Java SayHello yourname”); <br />
        } <br />
        String yourname = args[0]; <br />
        Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;(); <br />
        env.put(“yourname”, yourname); <br />
        String result = (String) AviatorEvaluator.execute(“ ‘hello ‘ + yourname “, env); <br />
        System.out.println(result); <br />
    } <br />
}<br />
上面的例子演示了怎么向表达式传入变量值，表达式中的yourname是一个变量，默认为null，通过传入Map&lt;String,Object&gt;的变量绑定环境，将yourname设置为你输入的名称。env的key是变量名，value是变量的值。</p><br />
<br />
<p>上面例子中的’hello ‘是一个Aviator的String，Aviator的String是任何用单引号或者双引号括起来的字符序列，String可以比较大小（基于unicode顺序），可以参与正则匹配，可以与任何对象相加，任何对象与String相加结果为String。String中也可以有转义字符，如/n、//、/’等。</p><br />
<br />
<p>AviatorEvaluator.execute(“ ‘a/”b’ “);   //字符串 a’b <br />
AviatorEvaluator.execute(“ /”a/’b/” “);  //字符串 a”b <br />
AviatorEvaluator.execute(“ ‘hello’+3 “);  //字符串 hello 3 <br />
AviatorEvaluator.execute(“ ‘hello ‘+ unknow “);  //字符串 hello null<br />
调用函数¶<br />
Aviator支持函数调用，函数调用的风格类似lua，下面的例子获取字符串的长度：</p><br />
<br />
<p>AviatorEvaluator.execute(“string.length(‘hello’)”);<br />
string.length(‘hello’)是一个函数调用，string.length是一个函数,’hello’是调用的参数。</p><br />
<br />
<p>再用string.substring来截取字符串：</p><br />
<br />
<p>AviatorEvaluator.execute(“string.contains(/”test/”,string.substring(‘hello’,1,2))”);<br />
通过string.substring(‘hello’,1,2)获取字符串’e’，然后通过函数string.contains判断e是否在’test’中。可以看到，函数可以嵌套调用。</p><br />
<br />
<p>Aviator的内置函数列表请看后面。</p><br />
<br />
<p>自定义函数¶<br />
Aviator除了内置的函数之外，还允许用户自定义函数，只要实现com.googlecode.aviator.runtime.type.AviatorFunction接口，并注册到AviatorEvaluator即可使用</p><br />
<br />
<p>public interface AviatorFunction { <br />
    /** <br />
     * Get the function name <br />
     *<br /><br />
     * @return <br />
     */ <br />
    public String getName();</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/** <br />
 * call function <br />
 *  <br />
 * @param env <br />
 *            Variable environment <br />
 * @param args <br />
 *            Function arguments <br />
 * @return <br />
 */ <br />
public AviatorObject call(Map&lt;String, Object&gt; env, AviatorObject... args);  } 可以看一个例子，我们实现一个add函数来做数值的相加：<br />
</code></pre></div></div><br />
<br />
<p>import com.googlecode.aviator.runtime.function.FunctionUtils; <br />
  import com.googlecode.aviator.runtime.type.AviatorDouble; <br />
  import com.googlecode.aviator.runtime.type.AviatorFunction; <br />
  import com.googlecode.aviator.runtime.type.AviatorObject; <br />
  public class AddFunction implements AviatorFunction {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    public AviatorObject call(Map&lt;String, Object&gt; env, AviatorObject... args) { <br />
        if (args.length != 2) { <br />
            throw new IllegalArgumentException("Add only supports two arguments"); <br />
        } <br />
        Number left = FunctionUtils.getNumberValue(0, args, env); <br />
        Number right = FunctionUtils.getNumberValue(1, args, env); <br />
        return new AviatorDouble(left.doubleValue() + right.doubleValue()); <br />
    } <br />
 <br />
 <br />
    public String getName() { <br />
        return "add"; <br />
    } <br />
 <br />
} 注册到AviatorEvaluator并调用如下：<br />
<br />
    //注册函数 <br />
    AviatorEvaluator.addFunction(new AddFunction()); <br />
    System.out.println(AviatorEvaluator.execute("add(1,2)")); <br />
    System.out.println(AviatorEvaluator.execute("add(add(1,2),100)")); 注册函数通过AviatorEvaluator.addFunction方法，移除可以通过removeFunction。<br />
</code></pre></div></div><br />
<br />
<p>编译表达式¶<br />
上面提到的例子都是直接执行表达式，事实上Aviator背后都帮你做了编译并执行的工作。你可以自己先编译表达式，返回一个编译的结果，然后传入不同的env来复用编译结果，提高性能，这是更推荐的使用方式：</p><br />
<br />
<p>import java.util.HashMap; <br />
import java.util.Map;</p><br />
<br />
<p>import com.googlecode.aviator.AviatorEvaluator; <br />
import com.googlecode.aviator.Expression;</p><br />
<br />
<p>public class CompileExample { <br />
    public static void main(String[] args) { <br />
        String expression = “a-(b-c)&gt;100”; <br />
        // 编译表达式 <br />
        Expression compiledExp = AviatorEvaluator.compile(expression);</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;(); <br />
    env.put("a", 100.3); <br />
    env.put("b", 45); <br />
    env.put("c", -199.100); <br />
 <br />
    // 执行表达式 <br />
    Boolean result = (Boolean) compiledExp.execute(env); <br />
    System.out.println(result); <br />
}  } 通过compile方法可以将表达式编译成Expression的中间对象，当要执行表达式的时候传入env并调用Expression的execute方法即可。表达式中使用了括号来强制优先级，这个例子还使用了&gt;用于比较数值大小，比较运算符!=、==、&gt;、&gt;=、&lt;、&lt;=不仅可以用于数值，也可以用于String、Pattern、Boolean等等，甚至是任何用户传入的两个都实现了java.lang。Comparable接口的对象之间。<br />
</code></pre></div></div><br />
<br />
<p>编译后的结果你可以自己缓存，也可以交给Aviator帮你缓存，AviatorEvaluator内部有一个全局的缓存池，如果你决定缓存编译结果，可以通过：</p><br />
<br />
<p>public static Expression compile(String expression, boolean cached)<br />
将cached设置为true即可，那么下次编译同一个表达式的时候将直接返回上一次编译的结果。使缓存失效通过：</p><br />
<br />
<p>public static void invalidateCache(String expression)<br />
方法。</p><br />
<br />
<p>访问数组和集合¶<br />
可以通过中括号去访问数组和java.util.List对象，可以通过map.key访问java.util.Map中key对应的value，一个例子：</p><br />
<br />
<p>import java.util.ArrayList; <br />
import java.util.Date; <br />
import java.util.HashMap; <br />
import java.util.List; <br />
import java.util.Map;</p><br />
<br />
<p>import com.googlecode.aviator.AviatorEvaluator;</p><br />
<br />
<p>public class CollectionExample { <br />
    public static void main(String[] args) { <br />
        final List<String> list = new ArrayList<String>(); <br />
        list.add("hello"); <br />
        list.add(" world");</String></String></p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    final int[] array = new int[3]; <br />
    array[0] = 0; <br />
    array[1] = 1; <br />
    array[2] = 3; <br />
 <br />
    final Map&lt;String, Date&gt; map = new HashMap&lt;String, Date&gt;(); <br />
    map.put("date", new Date()); <br />
 <br />
    Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;(); <br />
    env.put("list", list); <br />
    env.put("array", array); <br />
    env.put("mmap", map); <br />
 <br />
    System.out.println(AviatorEvaluator.execute( <br />
        "list[0]+list[1]+'/narray[0]+array[1]+array[2]='+(array[0]+array[1]+array[2]) +' /ntoday is '+mmap.date ", env)); <br />
}  } 三元操作符¶ Aviator不提供if else语句，但是提供了三元操作符?:用于条件判断，使用上与java没有什么不同：<br />
</code></pre></div></div><br />
<br />
<p>import java.util.HashMap; <br />
import java.util.Map;</p><br />
<br />
<p>import com.googlecode.aviator.AviatorEvaluator;</p><br />
<br />
<p>public class TernaryOperatorExample { <br />
    public static void main(String[] args) { <br />
        if (args.length &lt; 1) { <br />
            System.err.println(“Usage: java TernaryOperatorExample [number]”); <br />
            System.exit(1); <br />
        } <br />
        int num = Integer.parseInt(args[0]); <br />
        Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;(); <br />
        env.put(“a”, num); <br />
        String result = (String) AviatorEvaluator.execute(“a&gt;0? ‘yes’:’no’”, env); <br />
        System.out.println(result); <br />
    } <br />
}<br />
这个例子用来判断用户传入的数字是否是正整数，是的话打印yes。</p><br />
<br />
<p>Aviator的三元表达式对于两个分支的结果类型并不要求一致，可以是任何类型，这一点与java不同。</p><br />
<br />
<p>正则表达式匹配¶<br />
Aviator支持类Ruby和Perl风格的表达式匹配运算，通过=~操作符，如下面这个例子匹配email并提取用户名返回：</p><br />
<br />
<p>import java.util.HashMap; <br />
import java.util.Map;</p><br />
<br />
<p>import com.googlecode.aviator.AviatorEvaluator;</p><br />
<br />
<p>public class RegularExpressionExample { <br />
    public static void main(String[] args) { <br />
        String email = “killme2008@gmail.com”; <br />
        Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;(); <br />
        env.put(“email”, email); <br />
        String username = (String) AviatorEvaluator.execute(“email=~/([//w0-8]+@//w+[//.//w+]+)/ ? $1:’unknow’”, env); <br />
        System.out.println(username); <br />
    } <br />
}<br />
email与正则表达式//(//w0-8+@//w+//.//w++)/通过=~操作符来匹配，结果为一个Boolean类型，因此可以用于三元表达式判断，匹配成功的时候返回$1，指代正则表达式的分组1，也就是用户名，否则返回unknown。这个例子将打印killme2008这个用户名。</p><br />
<br />
<p>Aviator在表达式级别支持正则表达式，通过//括起来的字符序列构成一个正则表达式，正则表达式可以用于匹配（作为=~的右操作数)、比较大小，匹配仅能与字符串进行匹配。匹配成功后，Aviator会自动将匹配成功的分组放入$num的变量中，其中$0指代整个匹配的字符串，而$1表示第一个分组，以此类推。</p><br />
<br />
<p>Aviator的正则表达式规则跟Java完全一样，因为内部其实就是使用java.util.regex.Pattern做编译的。</p><br />
<br />
<p>变量的语法糖衣¶<br />
Aviator有个方便用户使用变量的语法糖衣，当你要访问变量a中的某个属性b，那么你可以通过a.b访问到，更进一步，a.b.c将访问变量a的b属性中的c属性值，推广开来也就是说Aviator可以将变量声明为嵌套访问的形式，一个例子，Foo类有属性i、f、date：</p><br />
<br />
<p>public class Foo { <br />
        int i; <br />
        float f; <br />
        Date date = new Date();</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    public Foo(int i, float f, Date date) { <br />
        super(); <br />
        this.i = i; <br />
        this.f = f; <br />
        this.date = date; <br />
    } <br />
 <br />
    public int getI() { <br />
        return i; <br />
    } <br />
 <br />
    public void setI(int i) { <br />
        this.i = i; <br />
    } <br />
 <br />
    public float getF() { <br />
        return f; <br />
    } <br />
 <br />
    public void setF(float f) { <br />
        this.f = f; <br />
    } <br />
 <br />
    public Date getDate() { <br />
        return date; <br />
    } <br />
 <br />
    public void setDate(Date date) { <br />
        this.date = date; <br />
    } <br />
} Foo类符合JavaBean规范，并且是public的，我们执行一个表达式来描述Foo:<br />
</code></pre></div></div><br />
<br />
<p>import java.util.Date; <br />
import java.util.HashMap; <br />
import java.util.Map;</p><br />
<br />
<p>import com.googlecode.aviator.AviatorEvaluator;</p><br />
<br />
<p>public class VariableExample { <br />
    public static void main(String[] args) { <br />
        Foo foo = new Foo(100, 3.14f, new Date()); <br />
        Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;(); <br />
        env.put(“foo”, foo);</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    String result = <br />
            (String) AviatorEvaluator.execute( <br />
                " '[foo i='+ foo.i + ' f='+foo.f+' year='+(foo.date.year+1900)+ ' month='+foo.date.month +']' ", <br />
                env); <br />
    System.out.println(result); <br />
 <br />
}  } 细看下表达式：<br />
</code></pre></div></div><br />
<br />
<p>‘[foo i=’+ foo.i + ‘ f=’+foo.f+’ year=’+(foo.date.year+1900)+ ‘ month=’+foo.date.month +’]’<br />
可以看到我们通过foo.i和foo.f的方式来访问foo变量中的i和f属性，并且通过foo.date.year的方式来访问foo中date对象的year属性（其实是getYear方法）。</p><br />
<br />
<p>nil对象¶<br />
nil是Aviator内置的常量，类似java中的null，表示空的值。nil跟null不同的在于，在java中null只能使用在==、!=的比较运算符，而nil还可以使用&gt;、&gt;=、&lt;、&lt;=等比较运算符。Aviator规定，任何对象都比nil大除了nil本身。用户传入的变量如果为null，将自动以nil替代。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    AviatorEvaluator.execute("nil == nil");  //true <br />
    AviatorEvaluator.execute(" 3&gt; nil");    //true <br />
    AviatorEvaluator.execute(" true!= nil");    //true <br />
    AviatorEvaluator.execute(" ' '&gt;nil ");  //true <br />
    AviatorEvaluator.execute(" a==nil ");   //true,a is null nil与String相加的时候，跟java一样显示为null<br />
</code></pre></div></div><br />
<br />
<p>日期比较¶<br />
Aviator并不支持日期类型，如果要比较日期，你需要将日期写字符串的形式，并且要求是形如”yyyy-MM-dd HH:mm:ss:SS”的字符串，否则都将报错。 字符串跟java.util.Date比较的时候将自动转换为Date对象进行比较：</p><br />
<br />
<p>import java.text.SimpleDateFormat; <br />
import java.util.Date; <br />
import java.util.HashMap; <br />
import java.util.Map;</p><br />
<br />
<p>import com.googlecode.aviator.AviatorEvaluator;</p><br />
<br />
<p>public class DateExample { <br />
    public static void main(String[] args) throws Exception { <br />
        Map&lt;String, Object&gt; env = new HashMap&lt;String, Object&gt;(); <br />
        final Date date = new Date(); <br />
        String dateStr = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss:SS”).format(date); <br />
        env.put(“date”, date); <br />
        env.put(“dateStr”, dateStr);</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Boolean result = (Boolean) AviatorEvaluator.execute("date==dateStr", env); <br />
    System.out.println(result); <br />
 <br />
    result = (Boolean) AviatorEvaluator.execute("date &gt; '2009-12-20 00:00:00:00' ", env); <br />
    System.out.println(result); <br />
 <br />
    result = (Boolean) AviatorEvaluator.execute("date &lt; '2200-12-20 00:00:00:00' ", env); <br />
    System.out.println(result); <br />
 <br />
    result = (Boolean) AviatorEvaluator.execute("date ==date ", env); <br />
    System.out.println(result); <br />
} <br />
</code></pre></div></div><br />
<br />
<p>}<br />
也就是说String除了能跟String比较之外，还能跟nil和date字符串比较。</p><br />
<br />
<p>两种模式¶<br />
默认AviatorEvaluator以编译速度优先：</p><br />
<br />
<p>AviatorEvaluator.setOptimize(AviatorEvaluator.COMPILE);<br />
你可以修改为运行速度优先，这会做更多的编译优化：</p><br />
<br />
<p>AviatorEvaluator.setOptimize(AviatorEvaluator.EVAL);<br />
语法手册¶<br />
下面是Aviator详细的语法规则定义。</p><br />
<br />
<p>数据类型¶<br />
Number类型：数字类型，支持两种类型，分别对应Java的Long和Double，也就是说任何整数都将被转换为Long，而任何浮点数都将被转换为Double，包括用户传入的数值也是如此转换。不支持科学计数法，仅支持十进制。如-1、100、2.3等。<br />
String类型： 字符串类型，单引号或者双引号括起来的文本串，如’hello world’，变量如果传入的是String或者Character也将转为String类型。<br />
Bool类型： 常量true和false，表示真值和假值，与java的Boolean.TRUE和Boolean.False对应。<br />
Pattern类型： 类似Ruby、perl的正则表达式，以//括起来的字符串，如//d+/，内部实现为java.util.Pattern。<br />
变量类型： 与Java的变量命名规则相同，变量的值由用户传入，如”a”、”b”等<br />
nil类型: 常量nil,类似java中的null，但是nil比较特殊，nil不仅可以参与==、!=的比较，也可以参与&gt;、&gt;=、&lt;、&lt;=的比较，Aviator规定任何类型都n大于nil除了nil本身，nil==nil返回true。用户传入的变量值如果为null，那么也将作为nil处理，nil打印为null。<br />
操作符¶<br />
算术运算符¶<br />
Aviator支持常见的算术运算符，包括+ - * / % 五个二元运算符，和一元运算符”-“。其中 - * / %和一元的”-“仅能作用于Number类型。</p><br />
<br />
<p>”+”不仅能用于Number类型，还可以用于String的相加，或者字符串与其他对象的相加。Aviator规定，任何类型与String相加，结果为String。</p><br />
<br />
<p>逻辑运算符¶<br />
Avaitor的支持的逻辑运算符包括，一元否定运算符”!”，以及逻辑与的”&amp;&amp;”，逻辑或的”||”。逻辑运算符的操作数只能为Boolean。</p><br />
<br />
<p>关系运算符¶<br />
Aviator支持的关系运算符包括”&lt;” “&lt;=” “&gt;” “&gt;=” 以及”==”和”!=” 。</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>&amp;&amp;和</td><br />
      <td> </td><br />
      <td>都执行短路规则。</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>关系运算符可以作用于Number之间、String之间、Pattern之间、Boolean之间、变量之间以及其他类型与nil之间的关系比较，不同类型除了nil之外不能相互比较。</p><br />
<br />
<p>Aviator规定任何对象都比nil大除了nil之外。</p><br />
<br />
<p>匹配运算符¶<br />
匹配运算符”=~”用于String和Pattern的匹配，它的左操作数必须为String，右操作数必须为Pattern。匹配成功后，Pattern的分组将存于变量$num，num为分组索引。</p><br />
<br />
<p>三元运算符¶<br />
Aviator没有提供if else语句，但是提供了三元运算符 “?:”，形式为 bool ? exp1: exp2。 其中bool必须为结果为Boolean类型的表达式，而exp1和exp2可以为任何合法的Aviator表达式，并且不要求exp1和exp2返回的结果类型一致。</p><br />
<br />
<p>操作符列表¶<br />
Aviator支持操作符的优先级，并且允许通过括号来强制优先级，下面是完整的操作符列表，按照优先级从高到低的顺序排列：</p><br />
<br />
<p>序号	操作符	结合性	操作数限制<br />
0	() [ ]	从左到右	()用于函数调用，[ ]用于数组和java.util.List的元素访问，要求[indx]中的index必须为整型<br />
1	! -	从右到左	! 能用于Boolean,- 仅能用于Number<br />
2	* / %	从左到右	Number之间<br />
3	+ -	从左到右	+ - 都能用于Number之间, + 还能用于String之间，或者String和其他对象<br />
4	&lt; &lt;= &gt; &gt;=	从左到右	Number之间、String之间、Pattern之间、变量之间、其他类型与nil之间<br />
5	== != =~	从左到右	==和!=作用于Number之间、String之间、Pattern之间、变量之间、其他类型与nil之间以及String和java.util.Date之间，=~仅能作用于String和Pattern之间<br />
6	&amp;&amp;	从左到右	Boolean之间，短路<br />
7	||	从左到右	Boolean之间，短路<br />
8	? :	从右到左	第一个操作数的结果必须为Boolean，第二和第三操作数结果无限制</p><br />
<br />
<p>类型转换规则¶<br />
Java的byte short int long都转化为Long类型，Java的float,double都将转化为Double类型。Java的char String都将转化为String。Java的null都将转为nil。<br />
当两个操作符都是Double或者都是Long的时候，各自按照Double或者Long的类型执行<br />
当两个操作符中某一个是Double的时候，另一个操作数也将转换成Double，按照Double类型执行。<br />
任何类型与String相加，结果为String<br />
任何类型都比nil大，除了nil本身。<br />
nil在打印或者与字符串相加的时候，显示为null<br />
形如”yyyy-MM-dd HH:mm:ss:SS”的字符串，在与java.util.Date做比较的时候将尝试转换成java.util.Date对象比较。</p><br />
<br />
<p>没有规定的类型转换操作，除了未知的变量类型之间，都将抛出异常。</p><br />
<br />
<p>常量和变量¶</p><br />
<br />
<p>true	真值<br />
false	假值<br />
nil	空值<br />
$digit	正则表达式匹配成功后的分组，$0表示匹配的字符串，$1表示第一个分组 etc.</p><br />
<br />
<p>内置函数¶</p><br />
<br />
<p>函数名称	说明<br />
sysdate()	返回当前日期对象java.util.Date<br />
rand()	返回一个介于0-1的随机数，double类型<br />
print([out],obj)	打印对象，如果指定out，向out打印，否则输出到控制台<br />
println([out],obj)	与print类似，但是在输出后换行<br />
now()	返回System.currentTimeMillis<br />
string.contains(s1,s2)	判断s1是否包含s2，返回Boolean<br />
string.length(s)	求字符串长度,返回Long<br />
string.startsWith(s1,s2)	s1是否以s2开始，返回Boolean<br />
string.endsWith(s1,s2)	s1是否以s2结尾,返回Boolean<br />
string.substring(s,begin[,end])	截取字符串s，从begin到end，end如果忽略的话，将从begin到结尾，与java.util.String.substring一样。<br />
math.abs(d)	求d的绝对值<br />
math.sqrt(d)	求d的平方根<br />
math.pow(d1,d2)	求d1的d2次方<br />
math.log(d)	求d的自然对数<br />
math.log10(d)	求d以10为底的对数<br />
math.sin(d)	正弦函数<br />
math.cos(d)	余弦函数<br />
math.tan(d)	正切函数<br />
map(seq,fun)	将函数fun作用到集合seq每个元素上，返回新元素组成的集合<br />
filter(seq,predicate)	将谓词predicate作用在集合的每个元素上，返回谓词为true的元素组成的集合<br />
count(seq)	返回集合大小<br />
include(seq,element)	判断element是否在集合seq中，返回boolean值<br />
sort(seq)	排序集合，仅对数组和List有效，返回排序后的新集合<br />
reduce(seq,fun,init)	fun接收两个参数，第一个是集合元素，第二个是累积的init，本函数用于将fun作用在集合每个元素和初始值上面，返回最终的init值<br />
seq.eq(value)	返回一个谓词，用来判断传入的参数是否跟value相等,用于filter函数，如filter(seq,seq.eq(3)) 过滤返回等于3的元素组成的集合<br />
seq.neq(value)	与seq.eq类似，返回判断不等于的谓词<br />
seq.gt(value)	返回判断大于value的谓词<br />
seq.ge(value)	返回判断大于等于value的谓词<br />
seq.lt(value)	返回判断小于value的谓词<br />
seq.le(value)	返回判断小于等于value的谓词<br />
seq.nil()	返回判断是否为nil的谓词<br />
seq.exists()	返回判断不为nil的谓词</p><br />
<br />
<p>数字支持科学计数法，如2e10,3e-3等，大小写e皆可。<br />
支持大整数运算，任意以大写字母N结尾或者超过long范围的整数都将被解析为java.math.BigInteger并进行算术等运算，如1N,999999999999999999999等。<br />
支持高精度运算，任意以大写字母M结尾的数字都将被解析为java.math.BigDecimal类型并进行算术等运算，如1.1M,3.5M等。<br />
更新math库支持这两种新数字类型。<br />
更新用户指南，添加大数运算和精度运算一节。<br />
AviatorEvaluator新增API:setMathContext(java.math.MathContext) <br />
用于设置decimal类型的运算精度。<br />
Maven 支持：</p><br />
<br />
<dependency>  <br />
       <groupId>com.googlecode.aviator</groupId>  <br />
       <artifactId>aviator</artifactId>  <br />
       <version>2.3.0</version>  <br />
  </dependency><br />
<br />
<p>Aviator是一个高性能、轻量级的java语言实现的表达式求值引擎，主要用于各种表达式的动态求值。<br />
Aviator的设计目标是轻量级和高性能 ，相比于Groovy、JRuby的笨重，Aviator非常小，加上依赖包也才450K,不算依赖包的话只有70K；当然，Aviator的语法是受限的，它不是一门完整的语言，而只是语言的一小部分集合。<br />
其次，Aviator的实现思路与其他轻量级的求值器很不相同，其他求值器一般都是通过解释的方式运行，而Aviator则是直接将表达式编译成Java字节码，交给JVM去执行。简单来说，Aviator的定位是介于Groovy这样的重量级脚本语言和IKExpression这样的轻量级表达式引擎之间。<br />
特性<br />
Aviator的特性</p><br />
<br />
<p>支持大部分运算操作符，包括算术操作符、关系运算符、逻辑操作符、正则匹配操作符(=~)、三元表达式?: ，并且支持操作符的优先级和括号强制优先级，具体请看后面的操作符列表。</p><br />
<br />
<p>支持函数调用和自定义函数</p><br />
<br />
<p>支持正则表达式匹配，类似Ruby、Perl的匹配语法，并且支持类Ruby的$digit指向匹配分组。</p><br />
<br />
<p>自动类型转换，当执行操作的时候，会自动判断操作数类型并做相应转换，无法转换即抛异常。</p><br />
<br />
<p>支持传入变量，支持类似a.b.c的嵌套变量访问。</p><br />
<br />
<p>性能优秀<br />
Aviator的限制：</p><br />
<br />
<p>没有if else、do while等语句，没有赋值语句，仅支持逻辑表达式、算术表达式、三元表达式和正则匹配。</p><br />
<br />
<p>没有位运算符 文档地址：http://www.slideshare.net/killme2008/aviator</p><br />
<br />
<p>下载：https://code.google.com/p/aviator/downloads/list</p><br />
<br />
<p>项目主页： https://code.google.com/p/aviator/</p><br />
<br />
<p>用户指南：https://code.google.com/p/aviator/wiki/User_Guide_zh</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category web
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>