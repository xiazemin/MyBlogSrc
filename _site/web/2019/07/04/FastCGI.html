<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">FastCGI MIT 文档</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-07-04T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jul 4, 2019</time></p>
					</div>
					 <p>http://www.mit.edu/~yandros/doc/specs/fcgi-spec.html#S1<br />
<!-- more --><br />
FastCGI Specification<br />
Mark R. Brown<br />
Open Market, Inc.<br />
Document Version: 1.0<br />
29 April 1996<br />
Copyright © 1996 Open Market, Inc. 245 First Street, Cambridge, MA 02142 U.S.A.<br />
Tel: 617-621-9500 Fax: 617-621-1703 URL: http://www.openmarket.com/</p><br />
<br />
<p>$Id: fcgi-spec.html,v 1.1.1.1 2000/08/21 05:24:03 yandros Exp $</p><br />
<ol><br />
  <li>Introduction</li><br />
  <li>Initial Process State<br />
2.1 Argument list<br />
2.2 File descriptors<br />
2.3 Environment variables<br />
2.4 Other state</li><br />
  <li>Protocol Basics<br />
3.1 Notation<br />
3.2 Accepting Transport Connections<br />
3.3 Records<br />
3.4 Name-Value Pairs<br />
3.5 Closing Transport Connections</li><br />
  <li>Management Record Types<br />
4.1 FCGI_GET_VALUES, FCGI_GET_VALUES_RESULT<br />
4.2 FCGI_UNKNOWN_TYPE</li><br />
  <li>Application Record Types<br />
5.1 FCGI_BEGIN_REQUEST<br />
5.2 Name-Value Pair Streams: FCGI_PARAMS, FCGI_RESULTS<br />
5.3 Byte Streams: FCGI_STDIN, FCGI_DATA, FCGI_STDOUT, FCGI_STDERR<br />
5.4 FCGI_ABORT_REQUEST<br />
5.5 FCGI_END_REQUEST</li><br />
  <li>Roles<br />
6.1 Role Protocols<br />
6.2 Responder<br />
6.3 Authorizer<br />
6.4 Filter</li><br />
  <li>Errors</li><br />
  <li>Types and Constants</li><br />
  <li>References<br />
A. Table: Properties of the record types<br />
B. Typical Protocol Message Flow</li><br />
  <li>Introduction<br />
FastCGI is an open extension to CGI that provides high performance for all Internet applications without the penalties of Web server APIs.<br />
This specification has narrow goal: to specify, from an application perspective, the interface between a FastCGI application and a Web server that supports FastCGI. Many Web server features related to FastCGI, e.g. application management facilities, have nothing to do with the application to Web server interface, and are not described here.</li><br />
</ol><br />
<br />
<p>This specification is for Unix (more precisely, for POSIX systems that support Berkeley Sockets). The bulk of the specification is a simple communications protocol that is independent of byte ordering and will extend to other systems.</p><br />
<br />
<p>We’ll introduce FastCGI by comparing it with conventional Unix implementations of CGI/1.1. FastCGI is designed to support long-lived application processes, i.e. application servers. That’s a major difference compared with conventional Unix implementations of CGI/1.1, which construct an application process, use it respond to one request, and have it exit.</p><br />
<br />
<p>The initial state of a FastCGI process is more spartan than the initial state of a CGI/1.1 process, because the FastCGI process doesn’t begin life connected to anything. It doesn’t have the conventional open files stdin, stdout, and stderr, and it doesn’t receive much information through environment variables. The key piece of initial state in a FastCGI process is a listening socket, through which it accepts connections from a Web server.</p><br />
<br />
<p>After a FastCGI process accepts a connection on its listening socket, the process executes a simple protocol to receive and send data. The protocol serves two purposes. First, the protocol multiplexes a single transport connection between several independent FastCGI requests. This supports applications that are able to process concurrent requests using event-driven or multi-threaded programming techniques. Second, within each request the protocol provides several independent data streams in each direction. This way, for instance, both stdout and stderr data pass over a single transport connection from the application to the Web server, rather than requiring separate pipes as with CGI/1.1.</p><br />
<br />
<p>A FastCGI application plays one of several well-defined roles. The most familiar is the Responder role, in which the application receives all the information associated with an HTTP request and generates an HTTP response; that’s the role CGI/1.1 programs play. A second role is Authorizer, in which the application receives all the information associated with an HTTP request and generates an authorized/unauthorized decision. A third role is Filter, in which the application receives all the information associated with an HTTP request, plus an extra stream of data from a file stored on the Web server, and generates a “filtered” version of the data stream as an HTTP response. The framework is extensible so that more FastCGI can be defined later.</p><br />
<br />
<p>In the remainder of this specification the terms “FastCGI application,” “application process,” or “application server” are abbreviated to “application” whenever that won’t cause confusion.</p><br />
<br />
<ol><br />
  <li>Initial Process State<br />
2.1 Argument list<br />
By default the Web server creates an argument list containing a single element, the name of the application, taken to be the last component of the executable’s path name. The Web server may provide a way to specify a different application name, or a more elaborate argument list.<br />
Note that the file executed by the Web server might be an interpreter file (a text file that starts with the characters #!), in which case the application’s argument list is constructed as described in the execve manpage.</li><br />
</ol><br />
<br />
<p>2.2 File descriptors<br />
The Web server leaves a single file descriptor, FCGI_LISTENSOCK_FILENO, open when the application begins execution. This descriptor refers to a listening socket created by the Web server.<br />
FCGI_LISTENSOCK_FILENO equals STDIN_FILENO. The standard descriptors STDOUT_FILENO and STDERR_FILENO are closed when the application begins execution. A reliable method for an application to determine whether it was invoked using CGI or FastCGI is to call getpeername(FCGI_LISTENSOCK_FILENO), which returns -1 with errno set to ENOTCONN for a FastCGI application.</p><br />
<br />
<p>The Web server’s choice of reliable transport, Unix stream pipes (AF_UNIX) or TCP/IP (AF_INET), is implicit in the internal state of the FCGI_LISTENSOCK_FILENO socket.</p><br />
<br />
<p>2.3 Environment variables<br />
The Web server may use environment variables to pass parameters to the application. This specification defines one such variable, FCGI_WEB_SERVER_ADDRS; we expect more to be defined as the specification evolves. The Web server may provide a way to bind other environment variables, such as the PATH variable.<br />
2.4 Other state<br />
The Web server may provide a way to specify other components of an application’s initial process state, such as the priority, user ID, group ID, root directory, and working directory of the process.</p><br />
<ol><br />
  <li>Protocol Basics<br />
3.1 Notation<br />
We use C language notation to define protocol message formats. All structure elements are defined in terms of the unsigned char type, and are arranged so that an ISO C compiler lays them out in the obvious manner, with no padding. The first byte defined in the structure is transmitted first, the second byte second, etc.<br />
We use two conventions to abbreviate our definitions.</li><br />
</ol><br />
<br />
<p>First, when two adjacent structure components are named identically except for the suffixes “B1” and “B0,” it means that the two components may be viewed as a single number, computed as B1«8 + B0. The name of this single number is the name of the components, minus the suffixes. This convention generalizes in an obvious way to handle numbers represented in more than two bytes.</p><br />
<br />
<p>Second, we extend C structs to allow the form</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    struct {<br />
        unsigned char mumbleLengthB1;<br />
        unsigned char mumbleLengthB0;<br />
        ... /* other stuff */<br />
        unsigned char mumbleData[mumbleLength];<br />
    }; meaning a structure of varying length, where the length of a component is determined by the values of the indicated earlier component or components. 3.2 Accepting Transport Connections A FastCGI application calls accept() on the socket referred to by file descriptor FCGI_LISTENSOCK_FILENO to accept a new transport connection. If the accept() succeeds, and the FCGI_WEB_SERVER_ADDRS environment variable is bound, the application application immediately performs the following special processing: FCGI_WEB_SERVER_ADDRS: The value is a list of valid IP addresses for the Web server. If FCGI_WEB_SERVER_ADDRS was bound, the application checks the peer IP address of the new connection for membership in the list. If the check fails (including the possibility that the connection didn't use TCP/IP transport), the application responds by closing the connection.<br />
</code></pre></div></div><br />
<br />
<p>FCGI_WEB_SERVER_ADDRS is expressed as a comma-separated list of IP addresses. Each IP address is written as four decimal numbers in the range [0..255] separated by decimal points. So one legal binding for this variable is FCGI_WEB_SERVER_ADDRS=199.170.183.28,199.170.183.71.</p><br />
<br />
<p>An application may accept several concurrent transport connections, but it need not do so.<br />
3.3 Records<br />
Applications execute requests from a Web server using a simple protocol. Details of the protocol depend upon the application’s role, but roughly speaking the Web server first sends parameters and other data to the application, then the application sends result data to the Web server, and finally the application sends the Web server an indication that the request is complete.<br />
All data that flows over the transport connection is carried in FastCGI records. FastCGI records accomplish two things. First, records multiplex the transport connection between several independent FastCGI requests. This multiplexing supports applications that are able to process concurrent requests using event-driven or multi-threaded programming techniques. Second, records provide several independent data streams in each direction within a single request. This way, for instance, both stdout and stderr data can pass over a single transport connection from the application to the Web server, rather than requiring separate connections.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    typedef struct {<br />
        unsigned char version;<br />
        unsigned char type;<br />
        unsigned char requestIdB1;<br />
        unsigned char requestIdB0;<br />
        unsigned char contentLengthB1;<br />
        unsigned char contentLengthB0;<br />
        unsigned char paddingLength;<br />
        unsigned char reserved;<br />
        unsigned char contentData[contentLength];<br />
        unsigned char paddingData[paddingLength];<br />
    } FCGI_Record; A FastCGI record consists of a fixed-length prefix followed by a variable number of content and padding bytes. A record contains seven components: version: Identifies the FastCGI protocol version. This specification documents FCGI_VERSION_1. type: Identifies the FastCGI record type, i.e. the general function that the record performs. Specific record types and their functions are detailed in later sections. requestId: Identifies the FastCGI request to which the record belongs. contentLength: The number of bytes in the contentData component of the record. paddingLength: The number of bytes in the paddingData component of the record. contentData: Between 0 and 65535 bytes of data, interpreted according to the record type. paddingData: Between 0 and 255 bytes of data, which are ignored. We use a relaxed C struct initializer syntax to specify constant FastCGI records. We omit the version component, ignore padding, and treat requestId as a number. Thus {FCGI_END_REQUEST, 1, {FCGI_REQUEST_COMPLETE,0}} is a record with type == FCGI_END_REQUEST, requestId == 1, and contentData == {FCGI_REQUEST_COMPLETE,0}. Padding The protocol allows senders to pad the records they send, and requires receivers to interpret the paddingLength and skip the paddingData. Padding allows senders to keep data aligned for more efficient processing. Experience with the X window system protocols shows the performance benefit of such alignment. We recommend that records be placed on boundaries that are multiples of eight bytes. The fixed-length portion of a FCGI_Record is eight bytes.<br />
</code></pre></div></div><br />
<br />
<p>Managing Request IDs<br />
The Web server re-uses FastCGI request IDs; the application keeps track of the current state of each request ID on a given transport connection. A request ID R becomes active when the application receives a record {FCGI_BEGIN_REQUEST, R, …} and becomes inactive when the application sends a record {FCGI_END_REQUEST, R, …} to the Web server.<br />
While a request ID R is inactive, the application ignores records with requestId == R, except for FCGI_BEGIN_REQUEST records as just described.</p><br />
<br />
<p>The Web server attempts to keep FastCGI request IDs small. That way the application can keep track of request ID states using a short array rather than a long array or a hash table. An application also has the option of accepting only one request at a time. In this case the application simply checks incoming requestId values against the current request ID.</p><br />
<br />
<p>Types of Record Types<br />
There are two useful ways of classifying FastCGI record types.<br />
The first distinction is between management records and application records. A management record contains information that is not specific to any Web server request, such as information about the protocol capabilities of the application. An application record contains information about a particular request, identified by the requestId component.</p><br />
<br />
<p>Management records have a requestId value of zero, also called the null request ID. Application records have a nonzero requestId.</p><br />
<br />
<p>The second distinction is between discrete and stream records. A discrete record contains a meaningful unit of data all by itself. A stream record is part of a stream, i.e. a series of zero or more non-empty records (length != 0) of the stream type, followed by an empty record (length == 0) of the stream type. The contentData components of a stream’s records, when concatenated, form a byte sequence; this byte sequence is the value of the stream. Therefore the value of a stream is independent of how many records it contains or how its bytes are divided among the non-empty records.</p><br />
<br />
<p>These two classifications are independent. Among the record types defined in this version of the FastCGI protocol, all management record types are also discrete record types, and nearly all application record types are stream record types. But three application record types are discrete, and nothing prevents defining a management record type that’s a stream in some later version of the protocol.</p><br />
<br />
<p>3.4 Name-Value Pairs<br />
In many of their roles, FastCGI applications need to read and write varying numbers of variable-length values. So it is useful to adopt a standard format for encoding a name-value pair.<br />
FastCGI transmits a name-value pair as the length of the name, followed by the length of the value, followed by the name, followed by the value. Lengths of 127 bytes and less can be encoded in one byte, while longer lengths are always encoded in four bytes:</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    typedef struct {<br />
        unsigned char nameLengthB0;  /* nameLengthB0  &gt;&gt; 7 == 0 */<br />
        unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */<br />
        unsigned char nameData[nameLength];<br />
        unsigned char valueData[valueLength];<br />
    } FCGI_NameValuePair11;<br />
<br />
    typedef struct {<br />
        unsigned char nameLengthB0;  /* nameLengthB0  &gt;&gt; 7 == 0 */<br />
        unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */<br />
        unsigned char valueLengthB2;<br />
        unsigned char valueLengthB1;<br />
        unsigned char valueLengthB0;<br />
        unsigned char nameData[nameLength];<br />
        unsigned char valueData[valueLength<br />
                ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];<br />
    } FCGI_NameValuePair14;<br />
<br />
    typedef struct {<br />
        unsigned char nameLengthB3;  /* nameLengthB3  &gt;&gt; 7 == 1 */<br />
        unsigned char nameLengthB2;<br />
        unsigned char nameLengthB1;<br />
        unsigned char nameLengthB0;<br />
        unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */<br />
        unsigned char nameData[nameLength<br />
                ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];<br />
        unsigned char valueData[valueLength];<br />
    } FCGI_NameValuePair41;<br />
<br />
    typedef struct {<br />
        unsigned char nameLengthB3;  /* nameLengthB3  &gt;&gt; 7 == 1 */<br />
        unsigned char nameLengthB2;<br />
        unsigned char nameLengthB1;<br />
        unsigned char nameLengthB0;<br />
        unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */<br />
        unsigned char valueLengthB2;<br />
        unsigned char valueLengthB1;<br />
        unsigned char valueLengthB0;<br />
        unsigned char nameData[nameLength<br />
                ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];<br />
        unsigned char valueData[valueLength<br />
                ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];<br />
    } FCGI_NameValuePair44; The high-order bit of the first byte of a length indicates the length's encoding. A high-order zero implies a one-byte encoding, a one a four-byte encoding. This name-value pair format allows the sender to transmit binary values without additional encoding, and enables the receiver to allocate the correct amount of storage immediately even for large values.<br />
</code></pre></div></div><br />
<br />
<p>3.5 Closing Transport Connections<br />
The Web server controls the lifetime of transport connections. The Web server can close a connection when no requests are active. Or the Web server can delegate close authority to the application (see FCGI_BEGIN_REQUEST). In this case the application closes the connection at the end of a specified request.<br />
This flexibility accommodates a variety of application styles. Simple applications will process one request at a time and accept a new transport connection for each request. More complex applications will process concurrent requests, over one or multiple transport connections, and will keep transport connections open for long periods of time.</p><br />
<br />
<p>A simple application gets a significant performance boost by closing the transport connection when it has finished writing its response. The Web server needs to control the connection lifetime for long-lived connections.</p><br />
<br />
<p>When an application closes a connection or finds that a connection has closed, the application initiates a new connection.</p><br />
<br />
<ol><br />
  <li>Management Record Types<br />
4.1 FCGI_GET_VALUES, FCGI_GET_VALUES_RESULT<br />
The Web server can query specific variables within the application. The server will typically perform a query on application startup in order to to automate certain aspects of system configuration.<br />
The application receives a query as a record {FCGI_GET_VALUES, 0, …}. The contentData portion of a FCGI_GET_VALUES record contains a sequence of name-value pairs with empty values.</li><br />
</ol><br />
<br />
<p>The application responds by sending a record {FCGI_GET_VALUES_RESULT, 0, …} with the values supplied. If the application doesn’t understand a variable name that was included in the query, it omits that name from the response.</p><br />
<br />
<p>FCGI_GET_VALUES is designed to allow an open-ended set of variables. The initial set provides information to help the server perform application and connection management:</p><br />
<br />
<p>FCGI_MAX_CONNS: The maximum number of concurrent transport connections this application will accept, e.g. “1” or “10”.<br />
FCGI_MAX_REQS: The maximum number of concurrent requests this application will accept, e.g. “1” or “50”.<br />
FCGI_MPXS_CONNS: “0” if this application does not multiplex connections (i.e. handle concurrent requests over each connection), “1” otherwise.<br />
An application may receive a FCGI_GET_VALUES record at any time. The application’s response should not involve the application proper but only the FastCGI library.<br />
4.2 FCGI_UNKNOWN_TYPE<br />
The set of management record types is likely to grow in future versions of this protocol. To provide for this evolution, the protocol includes the FCGI_UNKNOWN_TYPE management record. When an application receives a management record whose type T it does not understand, the application responds with {FCGI_UNKNOWN_TYPE, 0, {T}}.<br />
The contentData component of a FCGI_UNKNOWN_TYPE record has the form:</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    typedef struct {<br />
        unsigned char type;    <br />
        unsigned char reserved[7];<br />
    } FCGI_UnknownTypeBody; The type component is the type of the unrecognized management record.<br />
</code></pre></div></div><br />
<br />
<ol><br />
  <li><br />
    <p>Application Record Types<br />
5.1 FCGI_BEGIN_REQUEST<br />
The Web server sends a FCGI_BEGIN_REQUEST record to start a request.<br />
The contentData component of a FCGI_BEGIN_REQUEST record has the form:</p><br />
<br />
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> typedef struct {<br />
     unsigned char roleB1;<br />
     unsigned char roleB0;<br />
     unsigned char flags;<br />
     unsigned char reserved[5];<br />
 } FCGI_BeginRequestBody; The role component sets the role the Web server expects the application to play. The currently-defined roles are:<br />
</code></pre></div>    </div><br />
  </li><br />
</ol><br />
<br />
<p>FCGI_RESPONDER<br />
FCGI_AUTHORIZER<br />
FCGI_FILTER<br />
Roles are described in more detail in Section 6 below.<br />
The flags component contains a bit that controls connection shutdown:</p><br />
<br />
<p>flags &amp; FCGI_KEEP_CONN: If zero, the application closes the connection after responding to this request. If not zero, the application does not close the connection after responding to this request; the Web server retains responsibility for the connection.<br />
5.2 Name-Value Pair Stream: FCGI_PARAMS<br />
FCGI_PARAMS is a stream record type used in sending name-value pairs from the Web server to the application. The name-value pairs are sent down the stream one after the other, in no specified order.<br />
5.3 Byte Streams: FCGI_STDIN, FCGI_DATA, FCGI_STDOUT, FCGI_STDERR<br />
FCGI_STDIN is a stream record type used in sending arbitrary data from the Web server to the application. FCGI_DATA is a second stream record type used to send additional data to the application.<br />
FCGI_STDOUT and FCGI_STDERR are stream record types for sending arbitrary data and error data respectively from the application to the Web server.</p><br />
<br />
<p>5.4 FCGI_ABORT_REQUEST<br />
The Web server sends a FCGI_ABORT_REQUEST record to abort a request. After receiving {FCGI_ABORT_REQUEST, R}, the application responds as soon as possible with {FCGI_END_REQUEST, R, {FCGI_REQUEST_COMPLETE, appStatus}}. This is truly a response from the application, not a low-level acknowledgement from the FastCGI library.<br />
A Web server aborts a FastCGI request when an HTTP client closes its transport connection while the FastCGI request is running on behalf of that client. The situation may seem unlikely; most FastCGI requests will have short response times, with the Web server providing output buffering if the client is slow. But the FastCGI application may be delayed communicating with another system, or performing a server push.</p><br />
<br />
<p>When a Web server is not multiplexing requests over a transport connection, the Web server can abort a request by closing the request’s transport connection. But with multiplexed requests, closing the transport connection has the unfortunate effect of aborting all the requests on the connection.</p><br />
<br />
<p>5.5 FCGI_END_REQUEST<br />
The application sends a FCGI_END_REQUEST record to terminate a request, either because the application has processed the request or because the application has rejected the request.<br />
The contentData component of a FCGI_END_REQUEST record has the form:</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    typedef struct {<br />
        unsigned char appStatusB3;<br />
        unsigned char appStatusB2;<br />
        unsigned char appStatusB1;<br />
        unsigned char appStatusB0;<br />
        unsigned char protocolStatus;<br />
        unsigned char reserved[3];<br />
    } FCGI_EndRequestBody; The appStatus component is an application-level status code. Each role documents its usage of appStatus.<br />
</code></pre></div></div><br />
<br />
<p>The protocolStatus component is a protocol-level status code; the possible protocolStatus values are:</p><br />
<br />
<p>FCGI_REQUEST_COMPLETE: normal end of request.<br />
FCGI_CANT_MPX_CONN: rejecting a new request. This happens when a Web server sends concurrent requests over one connection to an application that is designed to process one request at a time per connection.<br />
FCGI_OVERLOADED: rejecting a new request. This happens when the application runs out of some resource, e.g. database connections.<br />
FCGI_UNKNOWN_ROLE: rejecting a new request. This happens when the Web server has specified a role that is unknown to the application.</p><br />
<ol><br />
  <li>Roles<br />
6.1 Role Protocols<br />
Role protocols only include records with application record types. They transfer essentially all data using streams.<br />
To make the protocols reliable and to simplify application programming, role protocols are designed to use nearly sequential marshalling. In a protocol with strictly sequential marshalling, the application receives its first input, then its second, etc. until it has received them all. Similarly, the application sends its first output, then its second, etc. until it has sent them all. Inputs are not interleaved with each other, and outputs are not interleaved with each other.</li><br />
</ol><br />
<br />
<p>The sequential marshalling rule is too restrictive for some FastCGI roles, because CGI programs can write to both stdout and stderr without timing restrictions. So role protocols that use both FCGI_STDOUT and FCGI_STDERR allow these two streams to be interleaved.</p><br />
<br />
<p>All role protocols use the FCGI_STDERR stream just the way stderr is used in conventional applications programming: to report application-level errors in an intelligible way. Use of the FCGI_STDERR stream is always optional. If an application has no errors to report, it sends either no FCGI_STDERR records or one zero-length FCGI_STDERR record.</p><br />
<br />
<p>When a role protocol calls for transmitting a stream other than FCGI_STDERR, at least one record of the stream type is always transmitted, even if the stream is empty.</p><br />
<br />
<p>Again in the interests of reliable protocols and simplified application programming, role protocols are designed to be nearly request-response. In a truly request-response protocol, the application receives all of its input records before sending its first output record. Request-response protocols don’t allow pipelining.</p><br />
<br />
<p>The request-response rule is too restrictive for some FastCGI roles; after all, CGI programs aren’t restricted to read all of stdin before starting to write stdout. So some role protocols allow that specific possibility. First the application receives all of its inputs except for a final stream input. As the application begins to receive the final stream input, it can begin writing its output.</p><br />
<br />
<p>When a role protocol uses FCGI_PARAMS to transmit textual values, such as the values that CGI programs obtain from environment variables, the length of the value does not include the terminating null byte, and the value itself does not include a null byte. An application that needs to provide environ(7) format name-value pairs must insert an equal sign between the name and value and append a null byte after the value.</p><br />
<br />
<p>Role protocols do not support the non-parsed header feature of CGI. FastCGI applications set response status using the Status and Location CGI headers.</p><br />
<br />
<p>6.2 Responder<br />
A Responder FastCGI application has the same purpose as a CGI/1.1 program: It receives all the information associated with an HTTP request and generates an HTTP response.<br />
It suffices to explain how each element of CGI/1.1 is emulated by a Responder:</p><br />
<br />
<p>The Responder application receives CGI/1.1 environment variables from the Web server over FCGI_PARAMS.<br />
Next the Responder application receives CGI/1.1 stdin data from the Web server over FCGI_STDIN. The application receives at most CONTENT_LENGTH bytes from this stream before receiving the end-of-stream indication. (The application receives less than CONTENT_LENGTH bytes only if the HTTP client fails to provide them, e.g. because the client crashed.)<br />
The Responder application sends CGI/1.1 stdout data to the Web server over FCGI_STDOUT, and CGI/1.1 stderr data over FCGI_STDERR. The application sends these concurrently, not one after the other. The application must wait to finish reading FCGI_PARAMS before it begins writing FCGI_STDOUT and FCGI_STDERR, but it needn’t finish reading from FCGI_STDIN before it begins writing these two streams.<br />
After sending all its stdout and stderr data, the Responder application sends a FCGI_END_REQUEST record. The application sets the protocolStatus component to FCGI_REQUEST_COMPLETE and the appStatus component to the status code that the CGI program would have returned via the exit system call.<br />
A Responder performing an update, e.g. implementing a POST method, should compare the number of bytes received on FCGI_STDIN with CONTENT_LENGTH and abort the update if the two numbers are not equal.<br />
6.3 Authorizer<br />
An Authorizer FastCGI application receives all the information associated with an HTTP request and generates an authorized/unauthorized decision. In case of an authorized decision the Authorizer can also associate name-value pairs with the HTTP request; when giving an unauthorized decision the Authorizer sends a complete response to the HTTP client.<br />
Since CGI/1.1 defines a perfectly good way to represent the information associated with an HTTP request, Authorizers use the same representation:</p><br />
<br />
<p>The Authorizer application receives HTTP request information from the Web server on the FCGI_PARAMS stream, in the same format as a Responder. The Web server does not send CONTENT_LENGTH, PATH_INFO, PATH_TRANSLATED, and SCRIPT_NAME headers.<br />
The Authorizer application sends stdout and stderr data in the same manner as a Responder. The CGI/1.1 response status specifies the disposition of the request. If the application sends status 200 (OK), the Web server allows access. Depending upon its configuration the Web server may proceed with other access checks, including requests to other Authorizers.<br />
An Authorizer application’s 200 response may include headers whose names are prefixed with Variable-. These headers communicate name-value pairs from the application to the Web server. For instance, the response header</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Variable-AUTH_METHOD: database lookup transmits the value "database lookup" with name AUTH-METHOD. The server associates such name-value pairs with the HTTP request and includes them in subsequent CGI or FastCGI requests performed in processing the HTTP request. When the application gives a 200 response, the server ignores response headers whose names aren't prefixed with Variable- prefix, and ignores any response content. For Authorizer response status values other than "200" (OK), the Web server denies access and sends the response status, headers, and content back to the HTTP client.<br />
</code></pre></div></div><br />
<br />
<p>6.4 Filter<br />
A Filter FastCGI application receives all the information associated with an HTTP request, plus an extra stream of data from a file stored on the Web server, and generates a “filtered” version of the data stream as an HTTP response.<br />
A Filter is similar in functionality to a Responder that takes a data file as a parameter. The difference is that with a Filter, both the data file and the Filter itself can be access controlled using the Web server’s access control mechanisms, while a Responder that takes the name of a data file as a parameter must perform its own access control checks on the data file.</p><br />
<br />
<p>The steps taken by a Filter are similar to those of a Responder. The server presents the Filter with environment variables first, then standard input (normally form POST data), finally the data file input:</p><br />
<br />
<p>Like a Responder, the Filter application receives name-value pairs from the Web server over FCGI_PARAMS. Filter applications receive two Filter-specific variables: FCGI_DATA_LAST_MOD and FCGI_DATA_LENGTH.<br />
Next the Filter application receives CGI/1.1 stdin data from the Web server over FCGI_STDIN. The application receives at most CONTENT_LENGTH bytes from this stream before receiving the end-of-stream indication. (The application receives less than CONTENT_LENGTH bytes only if the HTTP client fails to provide them, e.g. because the client crashed.)<br />
Next the Filter application receives the file data from the Web server over FCGI_DATA. This file’s last modification time (expressed as an integer number of seconds since the epoch January 1, 1970 UTC) is FCGI_DATA_LAST_MOD; the application may consult this variable and respond from a cache without reading the file data. The application reads at most FCGI_DATA_LENGTH bytes from this stream before receiving the end-of-stream indication.<br />
The Filter application sends CGI/1.1 stdout data to the Web server over FCGI_STDOUT, and CGI/1.1 stderr data over FCGI_STDERR. The application sends these concurrently, not one after the other. The application must wait to finish reading FCGI_STDIN before it begins writing FCGI_STDOUT and FCGI_STDERR, but it needn’t finish reading from FCGI_DATA before it begins writing these two streams.<br />
After sending all its stdout and stderr data, the application sends a FCGI_END_REQUEST record. The application sets the protocolStatus component to FCGI_REQUEST_COMPLETE and the appStatus component to the status code that a similar CGI program would have returned via the exit system call.<br />
A Filter should compare the number of bytes received on FCGI_STDIN with CONTENT_LENGTH and on FCGI_DATA with FCGI_DATA_LENGTH. If the numbers don’t match and the Filter is a query, the Filter response should provide an indication that data is missing. If the numbers don’t match and the Filter is an update, the Filter should abort the update.</p><br />
<ol><br />
  <li>Errors<br />
A FastCGI application exits with zero status to indicate that it terminated on purpose, e.g. in order to perform a crude form of garbage collection. A FastCGI application that exits with nonzero status is assumed to have crashed. How a Web server or other application manager responds to applications that exit with zero or nonzero status is outside the scope of this specification.<br />
A Web server can request that a FastCGI application exit by sending it SIGTERM. If the application ignores SIGTERM the Web server can resort to SIGKILL.</li><br />
</ol><br />
<br />
<p>FastCGI applications report application-level errors with the FCGI_STDERR stream and the appStatus component of the FCGI_END_REQUEST record. In many cases an error will be reported directly to the user via the FCGI_STDOUT stream.</p><br />
<br />
<p>On Unix, applications report lower-level errors, including FastCGI protocol errors and syntax errors in FastCGI environment variables, to syslog. Depending upon the severity of the error, the application may either continue or exit with nonzero status.</p><br />
<br />
<ol><br />
  <li>Types and Constants<br />
/*<br />
    <ul><br />
      <li>Listening socket file number<br />
 */<br />
#define FCGI_LISTENSOCK_FILENO 0</li><br />
    </ul><br />
  </li><br />
</ol><br />
<br />
<p>typedef struct {<br />
    unsigned char version;<br />
    unsigned char type;<br />
    unsigned char requestIdB1;<br />
    unsigned char requestIdB0;<br />
    unsigned char contentLengthB1;<br />
    unsigned char contentLengthB0;<br />
    unsigned char paddingLength;<br />
    unsigned char reserved;<br />
} FCGI_Header;</p><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Number of bytes in a FCGI_Header.  Future versions of the protocol</li><br />
  <li>will not reduce this number.<br />
 */<br />
#define FCGI_HEADER_LEN  8</li><br />
</ul><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Value for version component of FCGI_Header<br />
 */<br />
#define FCGI_VERSION_1           1</li><br />
</ul><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Values for type component of FCGI_Header<br />
 */<br />
#define FCGI_BEGIN_REQUEST       1<br />
#define FCGI_ABORT_REQUEST       2<br />
#define FCGI_END_REQUEST         3<br />
#define FCGI_PARAMS              4<br />
#define FCGI_STDIN               5<br />
#define FCGI_STDOUT              6<br />
#define FCGI_STDERR              7<br />
#define FCGI_DATA                8<br />
#define FCGI_GET_VALUES          9<br />
#define FCGI_GET_VALUES_RESULT  10<br />
#define FCGI_UNKNOWN_TYPE       11<br />
#define FCGI_MAXTYPE (FCGI_UNKNOWN_TYPE)</li><br />
</ul><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Value for requestId component of FCGI_Header<br />
 */<br />
#define FCGI_NULL_REQUEST_ID     0</li><br />
</ul><br />
<br />
<p>typedef struct {<br />
    unsigned char roleB1;<br />
    unsigned char roleB0;<br />
    unsigned char flags;<br />
    unsigned char reserved[5];<br />
} FCGI_BeginRequestBody;</p><br />
<br />
<p>typedef struct {<br />
    FCGI_Header header;<br />
    FCGI_BeginRequestBody body;<br />
} FCGI_BeginRequestRecord;</p><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Mask for flags component of FCGI_BeginRequestBody<br />
 */<br />
#define FCGI_KEEP_CONN  1</li><br />
</ul><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Values for role component of FCGI_BeginRequestBody<br />
 */<br />
#define FCGI_RESPONDER  1<br />
#define FCGI_AUTHORIZER 2<br />
#define FCGI_FILTER     3</li><br />
</ul><br />
<br />
<p>typedef struct {<br />
    unsigned char appStatusB3;<br />
    unsigned char appStatusB2;<br />
    unsigned char appStatusB1;<br />
    unsigned char appStatusB0;<br />
    unsigned char protocolStatus;<br />
    unsigned char reserved[3];<br />
} FCGI_EndRequestBody;</p><br />
<br />
<p>typedef struct {<br />
    FCGI_Header header;<br />
    FCGI_EndRequestBody body;<br />
} FCGI_EndRequestRecord;</p><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Values for protocolStatus component of FCGI_EndRequestBody<br />
 */<br />
#define FCGI_REQUEST_COMPLETE 0<br />
#define FCGI_CANT_MPX_CONN    1<br />
#define FCGI_OVERLOADED       2<br />
#define FCGI_UNKNOWN_ROLE     3</li><br />
</ul><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Variable names for FCGI_GET_VALUES / FCGI_GET_VALUES_RESULT records<br />
 */<br />
#define FCGI_MAX_CONNS  “FCGI_MAX_CONNS”<br />
#define FCGI_MAX_REQS   “FCGI_MAX_REQS”<br />
#define FCGI_MPXS_CONNS “FCGI_MPXS_CONNS”</li><br />
</ul><br />
<br />
<p>typedef struct {<br />
    unsigned char type;  <br /><br />
    unsigned char reserved[7];<br />
} FCGI_UnknownTypeBody;</p><br />
<br />
<p>typedef struct {<br />
    FCGI_Header header;<br />
    FCGI_UnknownTypeBody body;<br />
} FCGI_UnknownTypeRecord;</p><br />
<ol><br />
  <li>References<br />
National Center for Supercomputer Applications, The Common Gateway Interface, version CGI/1.1.<br />
D.R.T. Robinson, The WWW Common Gateway Interface Version 1.1, Internet-Draft, 15 February 1996.</li><br />
</ol><br />
<br />
<p>A. Table: Properties of the record types<br />
The following chart lists all of the record types and indicates these properties of each:<br />
WS-&gt;App: records of this type can only be sent by the Web server to the application. Records of other types can only be sent by the application to the Web server.<br />
management: records of this type contain information that is not specific to a Web server request, and use the null request ID. Records of other types contain request-specific information, and cannot use the null request ID.<br />
stream: records of this type form a stream, terminated by a record with empty contentData. Records of other types are discrete; each carries a meaningful unit of data.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                           WS-&gt;App   management  stream<br />
<br />
    FCGI_GET_VALUES           x          x<br />
    FCGI_GET_VALUES_RESULT               x<br />
    FCGI_UNKNOWN_TYPE                    x<br />
<br />
    FCGI_BEGIN_REQUEST        x<br />
    FCGI_ABORT_REQUEST        x<br />
    FCGI_END_REQUEST<br />
    FCGI_PARAMS               x                    x<br />
    FCGI_STDIN                x                    x<br />
    FCGI_DATA                 x                    x<br />
    FCGI_STDOUT                                    x <br />
    FCGI_STDERR                                    x     <br />
</code></pre></div></div><br />
<br />
<p>B. Typical Protocol Message Flow<br />
Additional notational conventions for the examples:<br />
The contentData of stream records (FCGI_PARAMS, FCGI_STDIN, FCGI_STDOUT, and FCGI_STDERR) is represented as a character string. A string ending in “ … “ is too long to display, so only a prefix is shown.<br />
Messages sent to the Web server are indented with respect to messages received from the Web server.<br />
Messages are shown in the time sequence experienced by the application.</p><br />
<ol><br />
  <li><br />
    <p>A simple request with no data on stdin, and a successful response:<br />
{FCGI_BEGIN_REQUEST,   1, {FCGI_RESPONDER, 0}}<br />
{FCGI_PARAMS,          1, “\013\002SERVER_PORT80\013\016SERVER_ADDR199.170.183.42 … “}<br />
{FCGI_PARAMS,          1, “”}<br />
{FCGI_STDIN,           1, “”}</p><br />
<br />
    <p>{FCGI_STDOUT,      1, “Content-type: text/html\r\n\r\n&lt;html&gt;\n&lt;head&gt; … “}<br />
 {FCGI_STDOUT,      1, “”}<br />
 {FCGI_END_REQUEST, 1, {0, FCGI_REQUEST_COMPLETE}}</p><br />
  </li><br />
  <li><br />
    <p>Similar to example 1, but this time with data on stdin. The Web server chooses to send the parameters using more FCGI_PARAMS records than before:</p><br />
  </li><br />
</ol><br />
<br />
<p>{FCGI_BEGIN_REQUEST,   1, {FCGI_RESPONDER, 0}}<br />
{FCGI_PARAMS,          1, “\013\002SERVER_PORT80\013\016SER”}<br />
{FCGI_PARAMS,          1, “VER_ADDR199.170.183.42 … “}<br />
{FCGI_PARAMS,          1, “”}<br />
{FCGI_STDIN,           1, “quantity=100&amp;item=3047936”}<br />
{FCGI_STDIN,           1, “”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{FCGI_STDOUT,      1, "Content-type: text/html\r\n\r\n&lt;html&gt;\n&lt;head&gt; ... "}<br />
{FCGI_STDOUT,      1, ""}<br />
{FCGI_END_REQUEST, 1, {0, FCGI_REQUEST_COMPLETE}} 3. Similar to example 1, but this time the application detects an error. The application logs a message to stderr, returns a page to the client, and returns non-zero exit status to the Web server. The application chooses to send the page using more FCGI_STDOUT records:<br />
</code></pre></div></div><br />
<br />
<p>{FCGI_BEGIN_REQUEST,   1, {FCGI_RESPONDER, 0}}<br />
{FCGI_PARAMS,          1, “\013\002SERVER_PORT80\013\016SERVER_ADDR199.170.183.42 … “}<br />
{FCGI_PARAMS,          1, “”}<br />
{FCGI_STDIN,           1, “”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{FCGI_STDOUT,      1, "Content-type: text/html\r\n\r\n&lt;ht"}<br />
{FCGI_STDERR,      1, "config error: missing SI_UID\n"}<br />
{FCGI_STDOUT,      1, "ml&gt;\n&lt;head&gt; ... "}<br />
{FCGI_STDOUT,      1, ""}<br />
{FCGI_STDERR,      1, ""}<br />
{FCGI_END_REQUEST, 1, {938, FCGI_REQUEST_COMPLETE}} 4. Two instances of example 1, multiplexed onto a single connection. The first request is more difficult than the second, so the application finishes the requests out of order:<br />
</code></pre></div></div><br />
<br />
<p>{FCGI_BEGIN_REQUEST,   1, {FCGI_RESPONDER, FCGI_KEEP_CONN}}<br />
{FCGI_PARAMS,          1, “\013\002SERVER_PORT80\013\016SERVER_ADDR199.170.183.42 … “}<br />
{FCGI_PARAMS,          1, “”}<br />
{FCGI_BEGIN_REQUEST,   2, {FCGI_RESPONDER, FCGI_KEEP_CONN}}<br />
{FCGI_PARAMS,          2, “\013\002SERVER_PORT80\013\016SERVER_ADDR199.170.183.42 … “}<br />
{FCGI_STDIN,           1, “”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{FCGI_STDOUT,      1, "Content-type: text/html\r\n\r\n"}<br />
</code></pre></div></div><br />
<br />
<p>{FCGI_PARAMS,          2, “”}<br />
{FCGI_STDIN,           2, “”}</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{FCGI_STDOUT,      2, "Content-type: text/html\r\n\r\n&lt;html&gt;\n&lt;head&gt; ... "}<br />
{FCGI_STDOUT,      2, ""}<br />
{FCGI_END_REQUEST, 2, {0, FCGI_REQUEST_COMPLETE}}<br />
{FCGI_STDOUT,      1, "&lt;html&gt;\n&lt;head&gt; ... "}<br />
{FCGI_STDOUT,      1, ""}<br />
{FCGI_END_REQUEST, 1, {0, FCGI_REQUEST_COMPLETE}}<br />
</code></pre></div></div><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category web
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>