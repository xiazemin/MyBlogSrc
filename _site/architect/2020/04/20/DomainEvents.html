<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">DomainEvents</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-04-20T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 20, 2020</time></p>
					</div>
					 <p>Spring Data之@DomainEvents注解<br />
背景<br />
在对一个Entity进行save操作时，往往需要触发后续的业务流程，通常采用如下做法</p><br />
<br />
<p>public void saveUser(){<br />
	User user = …<br />
	user = repository.save(user);</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>doSomething(user); }<br />
</code></pre></div></div><br />
<br />
<p>public void action(){<br />
	User user = …<br />
	saveUser(user);<br />
	doSomething(user);<br />
}</p><br />
<br />
<p>其中有一些注意事项，例如</p><br />
<br />
<p>doSomething与saveUser在同一个事务中，需要考虑doSomething中的异常对repository.save(user)的影响<br />
doSomething与saveUser不在同一个事务中，那么在doSomething中查询user时将查询不到，因为saveUser的事务还未提交。<br />
这种情况则需要将doSomething上移到调用saveUser同级的地方调用这种情况则需要将doSomething上移到调用saveUser同级的地方调用<br />
DomainEvents<br />
近日在Spring Data的官方手册中看到@DomainEvents的介绍。官方解释是由Repositoty管理的Entity是源于聚合根（ aggregate roots）的，在领域驱动设计系统中，可以通过聚合根发出领域事件。在Spring Data中可以通过@DomainEvents注解在聚合根的方法上，从而可以简单快捷的发出事件。下面就来看一下，DomainEvents的具体使用效果。<br />
首先定义一个普通的Entity</p><br />
<br />
<p>@Data<br />
@Entity<br />
@Table(name = “t_user”)<br />
@AllArgsConstructor<br />
@NoArgsConstructor<br />
public class User {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Id<br />
@GeneratedValue(strategy = GenerationType.IDENTITY)<br />
private Long id;<br />
<br />
private String firstName;<br />
<br />
private String lastName;<br />
<br />
private Integer age;<br />
<br />
//该方法会在userRepository.save()调用时被触发调用<br />
@DomainEvents<br />
Collection&lt;UserSaveEvent&gt; domainEvents() {<br />
    return Arrays.asList(new UserSaveEvent(this.id));<br />
}<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>其中UserSaveEvent的定义如下</p><br />
<br />
<p>@Data<br />
@AllArgsConstructor<br />
public class UserSaveEvent {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private Long id;<br />
</code></pre></div></div><br />
<br />
<p>}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
再定义一个UserService消费发出的事件</p><br />
<br />
<p>@Service<br />
public class UserService {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Autowired<br />
private UserRepository userRepository;<br />
<br />
//接受User发出的类型为UserSaveEvent的DomainEvents事件<br />
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)<br />
public void event(UserSaveEvent event){<br />
    System.out.println(userRepository.getOne(event.getId()));<br />
}<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>其中@TransactionalEventListener注解的phase有多个选项</p><br />
<br />
<p>BEFORE_COMMIT<br />
AFTER_COMMIT<br />
AFTER_ROLLBACK<br />
AFTER_COMPLETION<br />
看名字就知道它们的作用和区别了，因为事件是repository.save发出的，这里就涉及到了事务。通过phase的不同选项，就能选择是在事务提交前获取事件，还是提交后，或者混滚的时候。</p><br />
<br />
<p>运行一下单元测试</p><br />
<br />
<p>@Before<br />
public void before(){</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>userRepository.saveAll(Arrays.asList(<br />
        new User(null,"刘","一", 20),<br />
        new User(null,"陈","二", 20),<br />
        new User(null,"张","三", 20),<br />
        new User(null,"李","四", 20),<br />
        new User(null,"王","五", 20),<br />
        new User(null,"赵","六", 20),<br />
        new User(null,"孙","七", 20),<br />
        new User(null,"周","八", 20)<br />
)); }<br />
</code></pre></div></div><br />
<br />
<p>控制台输出</p><br />
<br />
<p>Hibernate: insert into t_user (id, age, first_name, last_name) values (null, ?, ?, ?)<br />
Hibernate: insert into t_user (id, age, first_name, last_name) values (null, ?, ?, ?)<br />
Hibernate: insert into t_user (id, age, first_name, last_name) values (null, ?, ?, ?)<br />
Hibernate: insert into t_user (id, age, first_name, last_name) values (null, ?, ?, ?)<br />
User(id=1, firstName=刘, lastName=一, age=20)<br />
User(id=2, firstName=陈, lastName=二, age=20)<br />
User(id=3, firstName=张, lastName=三, age=20)<br />
User(id=4, firstName=李, lastName=四, age=20)</p><br />
<br />
<p>上面是使用的phase = TransactionPhase.AFTER_COMMIT，即事务提交后响应事件，所以userRepository.getOne(event.getId())能查询到user对象。如果改成TransactionPhase.BEFORE_COMMIT呢</p><br />
<br />
<p>@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)<br />
public void event(UserSaveEvent event){<br />
    System.out.println(userRepository.getOne(event.getId()));<br />
}</p><br />
<br />
<p>其实效果是一样的也能查询到user，难道BEFORE_COMMIT没起作用？没提交事务前按理是查询不到的才对。<br />
其实是因为session的缓存，因为event方法并没有添加@Async注解异步，也没有@Transactional(value = Transactional.TxType.REQUIRES_NEW)开启新事务，所以这时与发送事件的repository.save还在一个事务内。</p><br />
<br />
<p>如果给event方法开启新事务</p><br />
<br />
<p>@TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT)<br />
@Transactional(value = Transactional.TxType.REQUIRES_NEW)<br />
public void event(UserSaveEvent event){<br />
    System.out.println(userRepository.getOne(event.getId()));<br />
}</p><br />
<br />
<p>这样查询就会报错，因为查不到了</p><br />
<br />
<p>org.springframework.orm.jpa.JpaObjectRetrievalFailureException: Unable to find com.learn.data.entity.User with id 1; nested exception is javax.persistence.EntityNotFoundException: Unable to find com.learn.data.entity.User with id 1<br />
1<br />
再将phase改成TransactionPhase.AFTER_COMMIT试试</p><br />
<br />
<p>@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)<br />
@Transactional(value = Transactional.TxType.REQUIRES_NEW)<br />
public void event(UserSaveEvent event){<br />
    System.out.println(userRepository.getOne(event.getId()));<br />
}</p><br />
<br />
<p>控制输出</p><br />
<br />
<p>Hibernate: insert into t_user (id, age, first_name, last_name) values (null, ?, ?, ?)<br />
Hibernate: insert into t_user (id, age, first_name, last_name) values (null, ?, ?, ?)<br />
Hibernate: insert into t_user (id, age, first_name, last_name) values (null, ?, ?, ?)<br />
Hibernate: insert into t_user (id, age, first_name, last_name) values (null, ?, ?, ?)<br />
Hibernate: select user0<em>.id as id1_0_0</em>, user0<em>.age as age2_0_0</em>, user0<em>.first_name as first_na3_0_0</em>, user0<em>.last_name as last_nam4_0_0</em> from t_user user0_ where user0<em>.id=?<br />
User(id=1, firstName=刘, lastName=一, age=20)<br />
Hibernate: select user0</em>.id as id1<em>0_0</em>, user0<em>.age as age2_0_0</em>, user0<em>.first_name as first_na3_0_0</em>, user0<em>.last_name as last_nam4_0_0</em> from t_user user0_ where user0<em>.id=?<br />
User(id=2, firstName=陈, lastName=二, age=20)<br />
Hibernate: select user0</em>.id as id1<em>0_0</em>, user0<em>.age as age2_0_0</em>, user0<em>.first_name as first_na3_0_0</em>, user0<em>.last_name as last_nam4_0_0</em> from t_user user0_ where user0<em>.id=?<br />
User(id=3, firstName=张, lastName=三, age=20)<br />
Hibernate: select user0</em>.id as id1<em>0_0</em>, user0<em>.age as age2_0_0</em>, user0<em>.first_name as first_na3_0_0</em>, user0<em>.last_name as last_nam4_0_0</em> from t_user user0_ where user0_.id=?<br />
User(id=4, firstName=李, lastName=四, age=20)</p><br />
<br />
<p>现在能查询到了，但控制台里面的查询打出了select语句，与没有添加@Transactional时是不一样了，没有@Transactional注解时是没有select语句的，说明JPA查询的是seesion缓存并没有真正执行查询。</p><br />
<br />
<p>结束<br />
@DomainEvents和@TransactionalEventListener的组合使用，给我们处理实体保存后触发事件。特别是异步事件（给event方法加上@Async，同时开启@EnableAsync）是非常简便的，它是一种领域驱动的思想，让代码显得更加的内聚。<br />
<!-- more --><br />
https://www.cnblogs.com/daxnet/archive/2012/12/27/2836372.html</p><br />
<br />
<p>在最近的一次代码签入中，Byteart Retail已经可以支持领域事件（Domain Events）的定义和处理了。在这篇文章中，我将详细介绍领域事件机制在Byteart Retail案例中的具体实现。</p><br />
<br />
<p>在进行领域建模的时候，我们就已经知道保证领域模型纯净度的必要性。简而言之，领域模型中的各个对象都应该是POCO（POJO）对象，而不应向其添加任何与技术架构相关的内容。Udi Dahan曾经说过：“The main assertion being that you do <em>not</em> need to inject anything into your domain entities. Not services. Not repositories. Nothing.”。因此，在之前有朋友提出过，是否可以在Domain Model中访问仓储？现在看来，答案是否定的。那么Domain Service呢？当然也不行。顺便提一下，在当前版本的Byteart Retail中的Domain Service访问了仓储，这是一个不太合理的做法，在下个版本中我将进行改进。那么，如果在某些业务需求下，需要访问这些技术层面的东西，又该怎么办呢？比如当系统管理员完成销售订单的发货操作时，希望向客户发送一份电子邮件。此时就要用到领域事件。</p><br />
<br />
<p>领域事件是应用系统中众多事件的一种分类。企业级应用程序事件大致可以分为三类：系统事件、应用事件和领域事件。领域事件的触发点在领域模型（Domain Model）中，故以此得名。通过使用领域事件，我们可以实现领域模型对象状态的异步更新、外部系统接口的委托调用，以及通过事件派发机制实现系统集成。在进行实际业务分析的过程中，如果在通用语言中存在“当a发生时，我们就需要做到b。”这样的描述，则表明a可以定义成一个领域事件。领域事件的命名一般也就是“产生事件的对象名称+完成的动作的过去式”的形式，比如：订单已经发货的事件（OrderDispatchedEvent）、订单已被收货和确认的事件（OrderConfirmedEvent）等。在当前的Byteart Retail案例的源代码中，就引入了这两种领域事件。事实上针对该案例而言，还有很多地方可以使用领域事件，比如当客户地址变更时，可以通过事件处理器来更新所有该事件发生前所有未发货订单的客户收货地址等。当然，为了简单起见，案例仅演示了上述两种事件。</p><br />
<br />
<p>另外，领域事件本身具有自描述性。它不仅能够表述系统发生了什么事情，而且还能够描述发生事件的动机。例如AddressChangedEvent可以衍生出两个派生类：ContactMovedEvent和AddressCorrectedEvent，虽然这两种事件都会导致地址信息的变更，但它们所表述的动机是不同的：前者体现了地址变更是因为联系人的地址发生了改变，而后者则体现了地址变更是因为地址信息原本是错的，现在被更正过来了。</p><br />
<br />
<p>现在，我们开始逐步讨论领域事件在Byteart Retail案例中的实现方式。</p><br />
<br />
<p>定义一个领域事件<br />
通常，我们会为领域事件定义一个接口（IDomainEvent接口），所有实现了该接口的类型都被认为是一个领域事件的类型。为了能够向事件处理器等事件管理机构提供完善的信息，我们可以在这个接口中设置一些属性，比如事件发生的时间戳、事件来源以及事件的ID值等等，当然这些内容都是根据具体的项目需求而定的。在Byteart Retail案例中，又定义了一个抽象类（DomainEvent类），该类实现了IDomainEvent接口，同时在这个类中提供了一个带参构造函数，它接受一个代表事件来源（Event Source）的领域实体作为参数，因此，在整个Byteart Retail中约定，所有领域事件类型都继承于DomainEvent类型，以便强制每个类型都需要提供一个相同参数类型的带参构造函数。这样做的好处是，每当开发人员初始化一个领域事件，都必须设置其产生的事件来源，在开发上达成了一种契约，有效地降低了错误的产生。</p><br />
<br />
<p>比如，上文所提到的OrderDispatchedEvent定义如下：</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
/// &lt;summary&gt;<br />
/// 表示当针对某销售订单进行发货时所产生的领域事件。<br />
/// &lt;/summary&gt;<br />
public class OrderDispatchedEvent : DomainEvent<br />
{<br />
    #region Ctor<br />
    /// &lt;summary&gt;<br />
    /// 初始化一个新的<c>OrderDispatchedEvent</c>类型的实例。<br />
    /// &lt;/summary&gt;<br />
    /// <param name="source" />产生领域事件的事件源对象。&lt;/param&gt;<br />
    public OrderDispatchedEvent(IEntity source) : base(source) { }<br />
    #endregion</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#region Public Properties<br />
/// &lt;summary&gt;<br />
/// 获取或设置订单发货的日期。<br />
/// &lt;/summary&gt;<br />
public DateTime DispatchedDate { get; set; }<br />
#endregion } 在这个事件定义中，构造函数接受一个IEntity类型的参数，以表示产生当前事件的实体对象，此外，它还包含了订单发货的日期信息。<br />
</code></pre></div></div><br />
<br />
<p>领域事件的派发和处理<br />
处理领域事件的机制称为“事件处理器（Event Handler）”，而领域事件的派发，我们则是通过“事件聚合器（Event Aggregator）”实现的。接下来，我们讨论这两个部分的具体实现过程。</p><br />
<br />
<p>事件处理器（Event Handler）<br />
事件处理器的任务是处理捕获的事件，它的职责是相对单一的：只需要对传入的信息进行处理即可。因此，在实现上我们可以将其定义为一个泛型接口，例如在Byteart Retail中，它被定义为IDomainEventHandler<TDomainEvent>接口，TDomainEvent类型参数指定了事件处理器所能够处理的领域事件的类型。一般情况下，该接口只提供一个Handle方法，该方法接受一个类型为TDomainEvent的对象（即领域事件实例）作为参数。所有实现了该接口的类型都被认为是能够处理特定类型领域事件的事件处理器。与领域事件的设计相同，在Byteart Retail中，还提供了一个名为DomainEventHandler<TDomainEvent>的泛型抽象类，该类直接实现了IDomainEventHandler<TDomainEvent>接口，同时实现了一个异步事件处理的方法：HandleAsync。同理，为了达成开发规范，在Byteart Retail中，所有领域事件处理器都应该继承于DomainEventHandler<TDomainEvent>抽象类，并实现其中的抽象方法：Handle方法。由于模板方法模式的支持，开发人员无需考虑异步事件处理的实现（即HandleAsync方法会创建一个用于异步任务处理的Task对象，来执行Handle方法所定义的操作）。</TDomainEvent></TDomainEvent></TDomainEvent></TDomainEvent></p><br />
<br />
<p>此外，为了简化编程模型，Byteart Retail还支持基于委托的事件处理器。这个设计其实并不是必须的，但在Byteart Retail中，为了简化事件订阅的操作，还是引入了这样一种基于委托的事件处理器。在某些情况下，事件处理逻辑会比较简单，比如仅仅是在捕获到某个事件时更新领域对象的状态，那么对于这样一些应用场景，开发人员就无需为每一个相对简单的事件处理逻辑定义一个单独的事件处理器类型，而只需要让委托的匿名方法来订阅和处理事件即可，这样做不仅简洁而且便于单体测试。有关事件处理器如何去订阅领域事件，我们将在下一小节“事件聚合器”中讨论。还是先让我们来看看Byteart Retail中是如何实现这种基于委托的事件处理器的。</p><br />
<br />
<p>在Byteart Retail中，有一个特殊的领域事件处理器，它与其它领域事件处理器一样，也继承于DomainEventHandler<TDomainEvent>泛型抽象类，但它的特殊性在于，它会在构造函数中接受一个Action<TDomainEvent>类型的委托作为参数，于是，通过一种类似装饰器模式的方式，将Action<TDomainEvent>委托“装饰”成DomainEventHandler<TDomainEvent>类型的对象：</TDomainEvent></TDomainEvent></TDomainEvent></TDomainEvent></p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
/// &lt;summary&gt;<br />
/// 表示代理给定的领域事件处理委托的领域事件处理器。<br />
/// &lt;/summary&gt;<br />
/// <typeparam name="TEvent"></typeparam><br />
internal sealed class ActionDelegatedDomainEventHandler<TEvent> : DomainEventHandler<TEvent><br />
    where TEvent : class, IDomainEvent<br />
{<br />
    #region Private Fields<br />
    private readonly Action<TEvent> eventHandlerDelegate;<br />
    #endregion</TEvent></TEvent></TEvent></p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#region Ctor<br />
/// &lt;summary&gt;<br />
/// 初始化一个新的&lt;c&gt;ActionDelegatedDomainEventHandler{TEvent}&lt;/c&gt;实例。<br />
/// &lt;/summary&gt;<br />
/// &lt;param name="eventHandlerDelegate"&gt;用于当前领域事件处理器所代理的事件处理委托。&lt;/param&gt;<br />
public ActionDelegatedDomainEventHandler(Action&lt;TEvent&gt; eventHandlerDelegate)<br />
{<br />
    this.eventHandlerDelegate = eventHandlerDelegate;<br />
}<br />
#endregion<br />
 <br />
// 其它函数和属性暂时忽略 } 在此类中Handle方法的实现就非常简单了：<br />
</code></pre></div></div><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
/// &lt;summary&gt;<br />
/// 处理给定的事件。<br />
/// &lt;/summary&gt;<br />
/// <param name="evnt" />需要处理的事件。&lt;/param&gt;<br />
public override void Handle(TEvent evnt)<br />
{<br />
    this.eventHandlerDelegate(evnt);<br />
}<br />
这种做法的优点是，可以将基于委托的事件处理器当成是普通的事件处理器类型，从而统一了事件订阅和事件派发的接口定义。</p><br />
<br />
<p>需要注意的是，对于ActionDelegatedDomainEventHandler而言，实例之间的相等性并不是由实例本身决定的，而是由其所代理的委托决定的，这对于事件处理器对事件的订阅，以及事件聚合器对事件的派发，都有着重要的影响。根据这个分析，我们就需要重载Equals方法，使用Delegate.Equals方法来判定两个委托的相等性。在Byteart Retail中，IDomainEventHandler<TDomainEvent>接口还实现了IEquatable接口，因此，只需要重载IEquatable接口中定义的Equals方法即可：</TDomainEvent></p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
/// &lt;summary&gt;<br />
/// 获取一个<see cref="Boolean"></see>值，该值表示当前对象是否与给定的类型相同的另一对象相等。<br />
/// &lt;/summary&gt;<br />
/// <param name="other" />需要比较的与当前对象类型相同的另一对象。&lt;/param&gt;<br />
/// <returns>如果两者相等，则返回true，否则返回false。</returns><br />
public override bool Equals(IDomainEventHandler<TEvent> other)<br />
{<br />
    if (ReferenceEquals(this, other))<br />
        return true;<br />
    if ((object)other == (object)null)<br />
        return false;<br />
    ActionDelegatedDomainEventHandler<TEvent> otherDelegate = <br />
        other as ActionDelegatedDomainEventHandler<TEvent>;<br />
    if ((object)otherDelegate == (object)null)<br />
        return false;<br />
    // 使用Delegate.Equals方法判定两个委托是否是代理的同一方法。<br />
    return Delegate.Equals(this.eventHandlerDelegate, otherDelegate.eventHandlerDelegate);<br />
}<br />
现在我们已经定义好了事件处理器接口以及相关的类，同时也根据需要实现了几个简单的事件处理器（具体代码请参考Byteart Retail案例中ByteartRetail.Domain.Events.Handlers命名空间下的类）。接下来我们要让领域模型能够在业务需要的地方触发领域事件，并让这些事件处理器能够对获得的事件进行处理。在Byteart Retail案例中，这部分内容是使用“事件聚合器”实现的。</TEvent></TEvent></TEvent></p><br />
<br />
<p>事件聚合器（Event Aggregator）<br />
事件聚合器是一种企业应用架构模式，其作用主要是聚合领域模型中的事件处理器，以便事件在触发的时候，被聚合的事件处理器能够对事件进行处理。在Byteart Retail中，事件聚合器的结构如下：</p><br />
<br />
<p>image</p><br />
<br />
<p>在这个设计中，事件聚合器提供了三种接口：Publish、Subscribe和Unsubscribe。Subscribe接口的主要作用是，向事件聚合器注册指定类型事件的处理器，那么对于事件处理器而言，它就是在侦听（订阅）某个事件的发生；而Unsubscribe的作用则正好相反：它会解除某个事件处理器对指定类型事件的侦听，也就是当事件被触发时，不再侦听该事件的事件处理器将不会执行处理任务；至于Publish接口就非常简单了：领域模型使用Publish接口直接向事件聚合器派发事件，事件聚合器在观察到事件发生时，将处理权转交给侦听了该事件的处理器。事件聚合器的引入，使得事件能够被一次派发，多处处理，为应用程序的领域事件处理架构提供了扩展性的同时，也简化了事件订阅过程。</p><br />
<br />
<p>在Byteart Retail中，事件聚合器是一个静态类，之所以不设计成实例类，是因为我们无法将其以任何形式注射到领域模型中，更不可能让领域对象提供一个参数为EventAggregator类型的构造函数。这一点与保持领域模型的纯净度有关。Event Aggregator的具体实现代码，请参考ByteartRetail.Domain.Events命名空间下的DomainEventAggregator类。接下来，我们将领域事件的产生、订阅、派发和处理的过程总结一下。</p><br />
<br />
<p>领域事件的订阅、派发和处理<br />
首先，在领域模型参与业务逻辑之前，应用程序架构需要对所需处理的领域事件进行订阅。回顾一下，面向DDD的经典分层架构中，应用层的职责是协调各组件（比如事务、仓储、领域模型等）的任务执行，因此领域事件的订阅也应该在应用层服务被初始化的时候进行。具体到Byteart Retail案例中，就是在应用服务（Application Service）的构造函数中进行。</p><br />
<br />
<p>以OrderServiceImpl类型（该类型位于ByteartRetail.Application.Implementation命名空间下）为例，在构造函数中我们扩展了一个参数：一个IDomainEventHandler<OrderDispatchedEvent>类型的数组，进而在构造函数中，通过使用DomainEventAggregator类，对传入的事件处理器进行订阅操作：</OrderDispatchedEvent></p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
public OrderServiceImpl(IRepositoryContext context,<br />
    IShoppingCartRepository shoppingCartRepository,<br />
    IShoppingCartItemRepository shoppingCartItemRepository,<br />
    IProductRepository productRepository,<br />
    IUserRepository customerRepository,<br />
    ISalesOrderRepository salesOrderRepository,<br />
    IDomainService domainService,<br />
    IDomainEventHandler<OrderDispatchedEvent>[] orderDispatchedDomainEventHandlers)<br />
    :base(context)<br />
{<br />
    this.shoppingCartRepository = shoppingCartRepository;<br />
    this.shoppingCartItemRepository = shoppingCartItemRepository;<br />
    this.productRepository = productRepository;<br />
    this.userRepository = customerRepository;<br />
    this.salesOrderRepository = salesOrderRepository;<br />
    this.domainService = domainService;<br />
    this.orderDispatchedDomainEventHandlers.AddRange(orderDispatchedDomainEventHandlers);</OrderDispatchedEvent></p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>foreach (var handler in this.orderDispatchedDomainEventHandlers)<br />
    DomainEventAggregator.Subscribe&lt;OrderDispatchedEvent&gt;(handler);<br />
DomainEventAggregator.Subscribe&lt;OrderConfirmedEvent&gt;(orderConfirmedEventHandlerAction);<br />
DomainEventAggregator.Subscribe&lt;OrderConfirmedEvent&gt;(orderConfirmedEventHandlerAction2); } 构造函数中最后两行是对与OrderConfirmedEvent相关的事件处理委托进行订阅，以演示基于委托的事件处理器的实现方式。这两个委托在OrderServiceImpl类型中，以只读字段（readonly field）的形式进行定义：<br />
</code></pre></div></div><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
private readonly Action<OrderConfirmedEvent> orderConfirmedEventHandlerAction = e =&gt;<br />
    {<br />
        SalesOrder salesOrder = e.Source as SalesOrder;<br />
        salesOrder.DateDelivered = e.ConfirmedDate;<br />
        salesOrder.Status = SalesOrderStatus.Delivered;<br />
    };</OrderConfirmedEvent></p><br />
<br />
<p>private readonly Action<OrderConfirmedEvent> orderConfirmedEventHandlerAction2 = _ =&gt;<br />
    {</OrderConfirmedEvent></p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>}; orderConfirmedEventHandlerAction2的定义无非也就是一个演示而已（演示接下来要讨论的事件处理器退订），因此我也没有在这个匿名方法里填写任何处理逻辑。至于构造函数的IDomainEventHandler&lt;OrderDispatchedEvent&gt;数组参数，则是通过Unity注入的，修改一下服务端的web.config文件即可：<br />
</code></pre></div></div><br />
<br />
<p>SNAGHTMLbb5949e</p><br />
<br />
<p>接下来，在应用层完成操作后，需要解除事件处理器对事件的订阅（即退订），为了实现这个功能，我修改了IApplicationServiceContract的接口定义，并让ApplicationService类继承于DisposableObject类，之后，在WCF服务上，设置其InstanceContextMode为PerSession，也就是每当WCF客户端建立一次与服务端的连接时，创建一次服务实例，而当客户端关闭并撤销连接时，销毁服务实例。于是，在完成了这些结构调整后，每当一次WCF会话完成后，ApplicationService的Dispose方法就会被调用。那么每个应用层服务的具体实现（OrderServiceImpl、ProductServiceImpl、UserServiceImpl、PostbackServiceImpl）只需根据自己的需要重载Dispose方法，即可在Dispose方法中解除事件处理器对事件的订阅：</p><br />
<br />
<p>1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
protected override void Dispose(bool disposing)<br />
{<br />
    if (disposing)<br />
    {<br />
        foreach (var handler in this.orderDispatchedDomainEventHandlers)<br />
            DomainEventAggregator.Unsubscribe<OrderDispatchedEvent>(handler);<br />
        DomainEventAggregator.Unsubscribe<OrderConfirmedEvent>(orderConfirmedEventHandlerAction);<br />
        DomainEventAggregator.Unsubscribe<OrderConfirmedEvent>(orderConfirmedEventHandlerAction2);<br />
    }<br />
}<br />
最后，领域事件的触发就非常简单了：直接调用DomainEventAggregator.Publish即可。整个过程大致可以用下面的序列图描述：</OrderConfirmedEvent></OrderConfirmedEvent></OrderDispatchedEvent></p><br />
<br />
<p>image</p><br />
<br />
<p>至此，我们已经大致了解了Byteart Retail案例中领域事件部分的设计与实现，回顾一下，这些内容包括：领域事件的定义、事件处理器、事件聚合器，以及这些组件之间的相互协作关系。读者朋友如果能够仔细阅读本案例的源代码，相信还能了解到更多深层次的细节问题。然而，事情还没有结束，我们还需要把讨论范围扩大到一个更高的层次：应用事件（Application Event）。虽然它已经超出领域事件的范围，但我还是要在本文中对其进行介绍，因为这个概念很容易造成开发人员对事件类别的混淆。</p><br />
<br />
<p>还有什么问题吗？<br />
在本文最开始的时候提出了一个简单的应用场景：“当系统管理员完成销售订单的发货操作时，希望向客户发送一份电子邮件”，这种需求是最常见不过的了。虽然“完成销售订单的发货”被定义成一个领域事件（事实上它也就是一个领域事件），但处理电子邮件发送的逻辑，却并不是领域事件处理器的任务。通过分析不难得知，领域事件处理器对领域事件的处理，在于整个事务被提交之前。领域事件处理器可以以一种更为复杂的方式来获取或设置领域对象的状态，但对于与事务相关的事件处理过程，领域事件处理器就不是一个很好的选择。试想，如果在领域事件处理器中将电子邮件发送出去了，而接下来的事务提交却失败了，于是就造成了客户所收到的订单状态与实际状态不符的情形。</p><br />
<br />
<p>正确的做法应该是，在领域事件被触发时，将其记录下来，当执行事务提交时，将已记录的领域事件转换成应用事件，并派发到事件总线。这个派发过程可以是同步的，也可以是异步的。接下来的电子邮件发送逻辑就由侦听该事件总线的事件处理器负责执行。这里牵涉到一个分布式事务处理的问题。对于“发送电子邮件”这样的功能，我想，对分布式事务处理的要求应该也没有那么明显：数据库事务提交成功后，直接让基础结构层组件发送电子邮件就可以了，如果发送电子邮件失败，也完全无需回滚数据库事务。大不了客户抱怨说没有收到邮件，系统管理员通过事件日志对发送邮件的功能进行排错即可。但对于某些应用事件，比如客户订房成功后，系统就会将订房成功的事件发送到支付系统，支付系统在多次尝试付款失败后，就需要完成房间退订逻辑，以防止房间被无限制占用，在这些场景下，分布式事务处理就有着一定的必须性（当然你也可以说让支付系统无限制地重试，或者说找Sales Rep进行7x24的跟踪排错来解决事务问题，但我们暂时先不考虑这些解决方案）。</p><br />
<br />
<p>Byteart Retail考虑了这些问题存在的可能性，在事件系统和仓储部分大致进行了以下改动：</p><br />
<br />
<p>引入事件总线系统（IBus接口），应用事件处理器可以侦听该接口来接收需要处理的应用事件；应用层同样可以使用该接口来派发应用事件<br />
实现了一个面向Event Dispatcher的事件总线，通过使用Event Dispatcher，Byteart Retail的事件总线可以支持Sequential、Parallel以及ParallelNoWait三种不同的事件派发方式（详见代码中的注释内容）<br />
更改了AggregateRoot抽象类的实现，引入了存储领域事件的部分<br />
更改了RepositoryContext抽象类的实现，在Commit方法中，不仅执行了仓储本身的提交事务（新的DoCommit方法），而且还会将存储在聚合根中的领域事件派发到事件总线。事件总线定义了其本身是否支持分布式事务处理，RepositoryContext会根据这个设置来决定是否需要启用Distributed Transaction Coordinator（不过貌似Message Queue的解决方案中，也只有MSMQ能够支持MS DTC）<br />
详细的实现部分，我就不在这里一一叙述了，请读者朋友们自己阅读本案例的源代码，尤其是ByteartRetail.Events和ByteartRetail.Events.Handlers命名空间下的类型代码。</p><br />
<br />
<p>执行效果<br />
本文最后，就让我们一起看一下领域事件部分的执行效果。以系统管理员发货为例，按理系统会产生一个OrderDispatchedEvent领域事件，领域模型通过领域事件处理器更新订单的发货日期和状态，与此同时，会将产生的领域事件暂存在聚合根中。当订单更新被提交时，被保存的领域事件将被派发到事件总线，进而邮件发送处理器会捕获到这个事件并发送邮件给客户。</p><br />
<br />
<p>首先，启动Byteart Retail的WCF服务和ASP.NET MVC应用程序，用daxnet/daxnet账户登录，并在账户设置中确保该账户的电子邮件地址设置正确。然后，使用该账户在系统中任意购买一件商品，完成下单后，退出系统，并用admin/admin账户登录，在“管理”-&gt;“销售订单管理”页面中，找到刚刚收到的订单，并点击“发货”按钮进行发货处理：</p><br />
<br />
<p>https://www.cnblogs.com/irocker/p/domain-events-pattern-example.html<br />
本文展示的是一个关于网上调查的项目。想象下，当用户完成了一个调查，我们想通知所有人调查已经结束，分配一个人去检查调用问卷。</p><br />
<br />
<p>领域对象<br />
public class Survey<br />
{<br />
    public Guid Id { get; private set; }<br />
    public DateTime EndTime { get; private set; }<br />
    public string QualityChecker { get; set; }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public Survey()<br />
{<br />
    this.Id = Guid.NewGuid();<br />
}<br />
<br />
public void EndSurvey()<br />
{<br />
    EndTime = DateTime.Now;<br />
    DomainEvent.Raise(new EndOfSurvey() { Survey = this });<br />
} } 这个领域对象非常简单，只有一个行为：EndSurvey().<br />
</code></pre></div></div><br />
<br />
<p>那么这里的DomainEvent是个什么东西呢？它是一个静态类，它发布了一个EndOfSurvey事件。从项目源码中可以看到所有的事件都放在名为Events的文件夹下面。领域对象放在Domain文件夹下面。</p><br />
<br />
<p>EndOfSurvey事件<br />
现在Survey对象希望发布一个EndOfSurvey事件。这个事件的代码如下：</p><br />
<br />
<p>public class EndOfSurvey : IDomainEvent<br />
{<br />
    public Survey Survey { get; set; }<br />
}<br />
EndOfSurvey包含一个Survey实例。它继承自IDomainEvent，这样我们知道他是一个领域事件。本例中所有的事件都要继承自IDomainEvent。 这个接口的定义很简单：</p><br />
<br />
<p>public interface IDomainEvent { }<br /><br />
DomainEvent类<br />
public static class DomainEvent<br />
{<br />
    public static IEventDispatcher Dispatcher { get; set; }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public static void Raise&lt;T&gt;(T @event) where T : IDomainEvent<br />
{<br />
    Dispatcher.Dispatch(@event);<br />
}<br />
</code></pre></div></div><br />
<br />
<p>}<br />
源码中的DomainEvent比这个要复杂点，但最重要的便是上面的代码了。</p><br />
<br />
<p>IEventDispatcher是一个ioc容器。它负责找到正确的handler来处理EndOfSurvey事件。</p><br />
<br />
<p>public interface IEventDispatcher<br />
{<br />
    void Dispatch<TEvent>(TEvent eventToDispatch) where TEvent : IDomainEvent;<br />
}<br />
泛型方法Raise<T>能让我们发布无数的事件，Dispatcher自动找出对应的handler。</T></TEvent></p><br />
<br />
<p>下面定义一个处理所有事件的handler接口：</p><br />
<br />
<p>public interface IDomainHandler<T> where T : IDomainEvent<br />
{<br />
    void Handle(T @event);<br />
}<br />
我将IEventDispatcher.cs和IDomainHandler.cs都放在一个名为Services的文件夹下面。其他的项目必须提供具体的实现。</T></p><br />
<br />
<p>domain程序集的代码就是这些了。</p><br />
<br />
<p>定义domain事件handler<br />
我创建了另外一个项目用来写event handler。</p><br />
<br />
<p>EndOfSurveyHandler用来处理EndOfSurvey事件：</p><br />
<br />
<p>public class EndOfSurveyHandler:IDomainHandler<EndOfSurvey><br />
{<br />
    public void Handle(EndOfSurvey args)<br />
    {<br />
        args.Survey.QualityChecker = "Ivan Amalo";<br />
        // 发送邮件给Ivan，通知他来检查调查问卷<br />
    }<br />
}<br />
如果想使用repository进行一些数据持续化的工作，或者使用一些其他的服务，可以将这些repository和服务通过构造函数注入进来。</EndOfSurvey></p><br />
<br />
<p>EndOfSurveyHandler和EndOfSurvey事件是怎么联系起来的呢？</p><br />
<br />
<p>将所有的代码集成起来<br />
下面要讲Survey.FrontEnd是一个MVC + WebApi应用，这个应用将DomainEvent，Dispatcher，Handler都结合了起来。</p><br />
<br />
<p>这个项目依赖于Ninject.MVC3。</p><br />
<br />
<p>现在我们需要来实现在之前定义的IEventDispatcher。</p><br />
<br />
<p>public class NinjectEventContainer : IEventDispatcher<br />
{<br />
    private readonly IKernel _kernel;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public NinjectEventContainer(IKernel kernel)<br />
{<br />
    _kernel = kernel;<br />
}<br />
<br />
public void Dispatch&lt;TEvent&gt;(TEvent eventToDispatch) where TEvent : IDomainEvent<br />
{<br />
    foreach (var handler in _kernel.GetAll&lt;IDomainHandler&lt;TEvent&gt;&gt;())<br />
    {<br />
        handler.Handle(eventToDispatch);<br />
    }<br />
} } Dispatch方法使用kernel来查找所有实现了IDomainHandler的handler。在我们的例子中查找的是EndOfSurveyHanlder，然后执行它的Handle()方法。<br />
</code></pre></div></div><br />
<br />
<p>在NinjectWebCommon.cs中我们定义了handler和event的对应关系。</p><br />
<br />
<p>private static void RegisterServices(IKernel kernel)<br />
{<br />
    DomainEvent.Dispatcher = new NinjectEventContainer(kernel);<br />
    kernel.Bind&lt;IDomainHandler<EndOfSurvey>&gt;().To<EndOfSurveyHandler>();<br />
}   <br />
这就是我们将所有东西集成起来需要做的事情。</EndOfSurveyHandler></EndOfSurvey></p><br />
<br />
<p>测试<br />
我在EndOfSurveyHandler.cs中发布事件的代码那设置了一个断点，来测试事件已经发布，其对应的handler也被执行。</p><br />
<br />
<p>控制器的代码非常简单，如下：</p><br />
<br />
<p>public ActionResult Index()<br />
{<br />
    var survey = new Core.Domain.Survey();<br />
    survey.EndSurvey();</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return View(survey); } 执行这个action， Ivan Amalo应该被分配成为这个调查问卷的检查者，并且将EndDate设为当前时间<br />
</code></pre></div></div><br />
<br />
<p>这是使用Axon Framework探索CQRS架构的一系列帖子中的帖子。 建议在继续阅读本系列之前阅读本系列中的前几篇文章，因为这有助于形成围绕所讨论主题的连续性线索。 您可以从使用Axon Framework探索CQRS架构开始：简介</p><br />
<br />
<p>有一个Github项目（exploringCQRSwithAxon），其中包含一个简单的应用程序，伴随本系列中的帖子。 它是一个说明性的应用程序，允许在两个虚构账户之间进行借记，贷记和转账。 很明显这是一个简单的应用程序，它是有目的的。 其目的不是捕获任何复杂的域，而是帮助说明CQRS体系结构的各个组件以及如何使用Axon Framework构建这些不同的组件。</p><br />
<br />
<p>Following with the sample application.<br />
要使项目处于说明此帖中的事物主题的状态：</p><br />
<br />
<p>首先下载项目:</p><br />
<br />
<p>git clone git@github.com:dadepo/exploringCQRSwithAxon.git<br />
1<br />
然后 check out 本次提交的 commit hash:</p><br />
<br />
<p>git checkout 06411af499a8d9dab62e1697820ca1c696f766dd<br />
1<br />
您可以通过执行mvn spring-boot来检查它之后运行应用程序：在根目录中运行，因为应用程序是使用Spring启动构建的。</p><br />
<br />
<p>在上一篇文章中，我们能够利用Axon的构建块来建立一个存储库，从中我们可以检索我们的聚合根。</p><br />
<br />
<p>我们还有适当的命令处理组件，以便我们能够调度最终改变应用程序状态的命令。 但正如该帖子末尾所述，尽管我们能够拥有最终导致状态变化的命令，但我们还没有触及CQRS的核心。</p><br />
<br />
<p>这是因为我们仍然使用相同的模型和基础结构来执行命令处理和查询组件。 正如在使用Axon Framework探索CQRS架构中所介绍的那样：简介CQRS的核心是具有处理写入（命令）和读取（查询）的独特且独立的组件。</p><br />
<br />
<p>那么，我们如何理解CQRS的核心并将命令组件与查询组件分开？ 为了回答这个问题，让我们再看一下我们在介绍性帖子中介绍的CQRS架构图：</p><br />
<br />
<p>cqrs</p><br />
<br />
<p>在图中，我们看到事件总线位于与命令/写入有关的体系结构的一侧和与读取/查询有关的一侧。 因此，为了回答我们的问题，我们利用事件总线来实现我们所寻求的分离。</p><br />
<br />
<p>How does this work? It work thus:<br />
在写入方面，命令会导致domain中的状态更改<br />
models/aggregates<br />
domain中的状态更改会导致domain events捕获已更改的内容<br />
domian 事件发布到事件总线。<br />
在read/query方面，事件处理程序监听这些事件并使用它们传达的信息来维护应用程序状态的反映。 然后将此状态用于应用程序的读取端。<br />
从域模型中的更改发布的事件在技术上称为域事件，Axon带有必要的基础结构，用于在域模型中发生更改时发布这些域事件。</p><br />
<br />
<p>本文的下一部分将介绍对其他示例应用程序所做的代码更改，以便连接并使用必要的Axon组件来实现命令端与查询端的这种分离，基本上是下图中突出显示的组件：</p><br />
<br />
<p>cqrs-event</p><br />
<br />
<p>Overview of code changes<br />
Updating Init Script<br />
由于我们将为查询提供另一个model/storage，因此我们更新了启动脚本以创建一个Account_View表，该表将用于读取应用程序的状态。 我们还插入了两个虚拟账号：表中的acc-one和acc-two。 所以我们的init（）方法现在看起来如此：</p><br />
<br />
<p>@PostConstruct<br />
private void init(){<br />
  // init the tables for commands<br />
  TransactionTemplate transactionTmp = new TransactionTemplate(txManager);<br />
  transactionTmp.execute(new TransactionCallbackWithoutResult() {<br />
      @Override<br />
      protected void doInTransactionWithoutResult(TransactionStatus status) {<br />
          UnitOfWork uow = DefaultUnitOfWork.startAndGet();<br />
          repository.add(new Account(“acc-one”));<br />
          repository.add(new Account(“acc-two”));<br />
          uow.commit();<br />
      }<br />
  });</p><br />
<br />
<p>// init the tables for query/view<br />
 JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);<br />
 jdbcTemplate<br />
       .execute(“create table account_view (account_no VARCHAR , <br />
                                                      balance FLOAT )”);</p><br />
<br />
<p>jdbcTemplate<br />
       .update(“insert into account_view (account_no, balance) values (?, ?)”, <br />
                                              new Object[]{“acc-one”, 0.0});</p><br />
<br />
<p>jdbcTemplate<br />
       .update(“insert into account_view (account_no, balance) values (?, ?)”, <br />
                                             new Object[]{“acc-two”, 0.0});<br />
}</p><br />
<br />
<p>Add an Event Bus<br />
我们需要一个 event bus。它的基础架构允许将事件路由到事件处理程序。</p><br />
<br />
<p>您会注意到事件总线可能看起来类似于命令总线，因为它们都是消息调度基础结构。就功能而言，它们在本质上是不同的。</p><br />
<br />
<p>是的，命令总线调度命令，事件总线调度事件，但命令总线使用的命令用于表示在最近的将来需要发生的事情，并且它期望有一个且只有一个命令处理程序将解释并执行命令中捕获的意图。</p><br />
<br />
<p>另一方面，事件总线，路由事件和事件是过去发生的事情的表达，并且事件可能有零个或多个事件处理程序。</p><br />
<br />
<p>EventBus是描述事件调度组件的Axon接口。 Axon带有几个实现，对于我们的示例应用程序，我们将使用SimpleEventBus。因此我们将其连接为Spring bean：</p><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>The simple command bus, an implementation of an EventBus</li><br />
  <li>mostly appropriate in a single JVM, single threaded use case.</li><br />
  <li>@return the {@link SimpleEventBus}<br />
*/<br />
@Bean<br />
public SimpleEventBus eventBus() {<br />
return new SimpleEventBus();<br />
}</li><br />
</ul><br />
<br />
<p>我们还需要连接Axon基础设施，以便能够轻松的设置事件处理程序，以响应发布到事件总线的事件。</p><br />
<br />
<p>Axon Framework附带@EventHandler注释，可用于将方法标记为事件处理程序。 方法的第一个参数表示方法应响应的事件类型。</p><br />
<br />
<p>AnnotationEventListenerBeanPostProcessor扫描具有@EventHandler方法的Spring bean，并自动将它们作为事件处理程序注册到事件总线。</p><br />
<br />
<p>AnnotationEventListenerBeanPostProcessor是AnnotationCommandHandlerBeanPostProcessor的事件计数器部分。</p><br />
<br />
<p>我们注册AnnotationEventListenerBeanPostProcessor：</p><br />
<br />
<p>@Bean<br />
AnnotationEventListenerBeanPostProcessor <br />
                 annotationEventListenerBeanPostProcessor() {<br />
  /**</p><br />
<ul><br />
  <li>The AnnotationEventListenerBeanPostProcessor <br />
finds all beans that has methods annotated with @EventHandler</li><br />
  <li>and subscribe them to the eventbus.<br />
   */<br />
  AnnotationEventListenerBeanPostProcessor listener = <br />
                          new AnnotationEventListenerBeanPostProcessor();<br />
  listener.setEventBus(eventBus());<br />
  return listener;<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
[UPDATE]<br />
从版本2.3开始，Axon Framework提供了@AnnotationDriven注释，可以防止必须显式声明AnnotationEventListenerBeanPostProcessor类型的bean。 要使用它，只需使用@AnnotationDriven注释Spring @Configuration类，所有@ CommandHandler和@EventHandler将自动扫描并注册到各自的总线。 随附的示例应用程序已更新（使用d6c9f18750f8f7d4c341c80a07bdf44c5a815783提交）以使用@ AnnotationDriven。</li><br />
</ul><br />
<br />
<p>接下来，我们需要对我们的配置进行的最后更新是为GenericJpaReposirtory提供事件总线。</p><br />
<br />
<p>Update the Repository with Event Bus<br />
GenericJpaRepository需要事件总线，因为它将在我们的域对象中发生更改时发布域事件。 我们在下面的配置中提供事件总线：</p><br />
<br />
<p>@Bean<br />
public GenericJpaRepository genericJpaRepository() {<br />
  SimpleEntityManagerProvider entityManagerProvider = <br />
                      new SimpleEntityManagerProvider(entityManager);</p><br />
<br />
<p>GenericJpaRepository genericJpaRepository = <br />
                      new GenericJpaRepository(entityManagerProvider, <br />
                                                         Account.class);</p><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>Configuring the repository with an event bus which allows the repository</li><br />
  <li>to be able to publish domain events<br />
   */<br />
  genericJpaRepository.setEventBus(eventBus());<br />
  return genericJpaRepository;<br />
}</li><br />
</ul><br />
<br />
<p>domain model的更改<br />
然后我们转到Account.class，这是我们的设置中的Aggregate Root和Aggregate。 我们添加了允许在状态发生变化时发布domain event的代码。</p><br />
<br />
<p>我们的debit方法现在看起来如此：</p><br />
<br />
<p>public void debit(Double debitAmount) {</p><br />
<br />
<p>if (Double.compare(debitAmount, 0.0d) &gt; 0 &amp;&amp;<br />
  this.balance - debitAmount &gt; -1) {<br />
  this.balance -= debitAmount;</p><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>A change in state of the Account has occurred which can</li><br />
  <li>be represented by an to an event: i.e.</li><br />
  <li>the account has been debited so an AccountDebitedEvent</li><br />
  <li>is created and registered.<br />
  *</li><br />
  <li>When the repository stores this change in state, it will</li><br />
  <li>also publish the AccountDebitedEvent</li><br />
  <li>to the outside world.<br />
  */<br />
  AccountDebitedEvent accountDebitedEvent = <br />
          new AccountDebitedEvent(this.id, debitAmount, this.balance);<br />
  registerEvent(accountDebitedEvent);</li><br />
</ul><br />
<br />
<p>} else {<br />
  throw new IllegalArgumentException(“Cannot debit with the amount”);<br />
}</p><br />
<br />
<p>}</p><br />
<br />
<p>25<br />
和 credit 方法:</p><br />
<br />
<p>public void credit(Double creditAmount) {</p><br />
<br />
<p>if (Double.compare(creditAmount, 0.0d) &gt; 0 &amp;&amp;<br />
       Double.compare(creditAmount, 1000000) &lt; 0) {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   this.balance += creditAmount;<br />
</code></pre></div></div><br />
<br />
<p>/**</p><br />
<ul><br />
  <li>A change in state of the Account has occurred which</li><br />
  <li>can be represented by an to an event: i.e.</li><br />
  <li>the account has been credited so an AccountCreditedEvent</li><br />
  <li>is created and registered.<br />
  *</li><br />
  <li>When the repository stores this change in state, it will</li><br />
  <li>also publish the AccountCreditedEvent</li><br />
  <li>to the outside world.<br />
  */<br />
  AccountCreditedEvent accountCreditedEvent = <br />
          new AccountCreditedEvent(this.id, creditAmount, this.balance);<br />
  registerEvent(accountCreditedEvent);<br />
 } else {<br />
  throw new IllegalArgumentException(“Cannot credit with the amount”);<br />
  }<br />
}</li><br />
</ul><br />
<br />
<p>我们在其中创建AccountDebitedEvent或AccountCreditedEvent并使用registerEvent()来注册创建的事件。</p><br />
<br />
<p>我们之所以有registerEvent()方法，因为我们的Account类扩展了AbstractAggregateRoot。</p><br />
<br />
<p>registerEvent()公开了Axon机制，用于在域对象保存到存储库时跟踪需要发布到事件总线的域事件。</p><br />
<br />
<p>我们提到AccountDebitEvent和AccountCreditedEvent作为表示帐户debited/credit的事件。 它们是域事件。 因此，代表这些event 的class如下：</p><br />
<br />
<p>public class AccountCreditedEvent {</p><br />
<br />
<p>private final String accountNo;<br />
  private final Double amountCredited;<br />
  private final Double balance;</p><br />
<br />
<p>public AccountCreditedEvent(String accountNo, <br />
                 Double amountCredited, Double balance) {<br />
      this.accountNo = accountNo;<br />
      this.amountCredited = amountCredited;<br />
      this.balance = balance;<br />
  }</p><br />
<br />
<p>public String getAccountNo() {<br />
      return accountNo;<br />
  }</p><br />
<br />
<p>public Double getAmountCredited() {<br />
      return amountCredited;<br />
  }</p><br />
<br />
<p>public Double getBalance() {<br />
      return balance;<br />
  }<br />
}</p><br />
<br />
<p>和</p><br />
<br />
<p>public class AccountDebitedEvent {<br />
  private final String accountNo;<br />
  private final Double amountDebited;<br />
  private final Double balance;</p><br />
<br />
<p>public AccountDebitedEvent(String accountNo, <br />
                 Double amountDebited, Double balance) {<br />
      this.accountNo = accountNo;<br />
      this.amountDebited = amountDebited;<br />
      this.balance = balance;<br />
  }</p><br />
<br />
<p>public String getAccountNo() {<br />
      return accountNo;<br />
  }</p><br />
<br />
<p>public Double getAmountDebited() {<br />
      return amountDebited;<br />
  }</p><br />
<br />
<p>public Double getBalance() {<br />
      return balance;<br />
  }<br />
}</p><br />
<br />
<p>到目前为止我们取得了什么成果？在我们继续之前，让我们先看看它。</p><br />
<br />
<p>我们现在有了域事件（AccountCreditedEvent和AccountDebitedEvent），我们更新了域对象以发布这些域事件，并且我们已经使用必要的基础结构更新了我们的配置，允许发布域事件。 我们需要添加的下一件事是事件处理程序。</p><br />
<br />
<p>Adding Event Handlers<br />
我们添加了两个事件处理程序：AccountDebitedEventHandler</p><br />
<br />
<p>@Component<br />
public class AccountDebitedEventHandler {</p><br />
<br />
<p>@Autowired<br />
DataSource dataSource;</p><br />
<br />
<p>@EventHandler<br />
public void handle AccountDebitedEvent(AccountDebitedEvent event) {</p><br />
<br />
<p>JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</p><br />
<br />
<p>// Get the current states as reflected in the event<br />
 String accountNo = event.getAccountNo();<br />
 Double balance = event.getBalance();</p><br />
<br />
<p>// Update the view<br />
 String updateQuery = “UPDATE account_view SET balance = ? <br />
                                             WHERE account_no = ?”;<br />
 jdbcTemplate.update(updateQuery, new Object[]{balance, accountNo});<br />
 }<br />
}</p><br />
<br />
<p>和 AccountCreditedEventHandler</p><br />
<br />
<p>@Component<br />
public class AccountCreditedEventHandler {</p><br />
<br />
<p>@Autowired<br />
DataSource dataSource;</p><br />
<br />
<p>@EventHandler<br />
public void handleAccountCreditedEvent(AccountCreditedEvent event, <br />
Message eventMessage, @Timestamp DateTime moment) {</p><br />
<br />
<p>JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);</p><br />
<br />
<p>// Get the current states as reflected in the event<br />
String accountNo = event.getAccountNo();<br />
Double balance = event.getBalance();</p><br />
<br />
<p>// Update the view<br />
String updateQuery = “UPDATE account_view SET balance = ? <br />
                                           WHERE account_no = ?”;<br />
jdbcTemplate.update(updateQuery, new Object[]{balance, accountNo});</p><br />
<br />
<p>System.out.println(“Events Handled With EventMessage “ + <br />
            eventMessage.toString() + “ at “ + moment.toString());<br />
}<br />
}</p><br />
<br />
<p>可以看出，事件处理方法使用@EventHandler进行注释。 它们响应的事件类型由带注释的方法的第一个参数指示。</p><br />
<br />
<p>由于我们已在配置中注册了AnnotationEventListenerBeanPostProcessor，因此这些类将被订阅为事件总线的事件处理程序。</p><br />
<br />
<p>那么在这些事件处理方法中会发生什么呢？ 我们从各个事件中提取信息，并使用JDBC更新Account_view表，该表是用于查询/读取操作的表。</p><br />
<br />
<p>在这个结点上需要注意的一件重要事情是，我们将视图数据存储在与用于命令操作的表不同的表中。<br />
我们也没有对视图层使用任何ORM映射（JPA等），我们也没有任何特殊的类在映射其状态时为Account建model。 这种特性是CQRS看待事物的核心。 事实上，使用CQRS，我们的查询层可以使用不同的简化抽象实现，可以轻松地针对查询/读取操作进行优化。</p><br />
<br />
<p>handleAccountCreditedEvent()方法展示了Axon为事件处理提供的一些附加功能。 可以看出，我们有两个额外的参数。 消息eventMessage包含事件消息：metadata，id等和@Timestamp DateTime时刻，它是在事件发布的时刻注入的。</p><br />
<br />
<p>接下来要做的是更新我们的视图（ViewController / Javascript）以使用这个新设置。</p><br />
<br />
<p>更新视图<br />
我们更新ViewController的getAccounts方法以使用普通JDBC来查询帐户的状态：</p><br />
<br />
<p>@Controller<br />
public class ViewController {</p><br />
<br />
<p>@Autowired<br />
 private DataSource dataSource;</p><br />
<br />
<p>@RequestMapping(value = “/view”, <br />
                method = RequestMethod.GET, <br />
                produces = MediaType.APPLICATION_JSON_VALUE)<br />
 @ResponseBody<br />
 public List&lt;Map&lt;String, Double» getAccounts() {</p><br />
<br />
<p>JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);<br />
   List&lt;Map&lt;String, Double» queryResult = <br />
   jdbcTemplate.query(“SELECT * from account_view ORDER BY account_no”, <br />
                                                  (rs, rowNum) -&gt; {<br />
   return new HashMap&lt;String, Double&gt;() {{<br />
                           put(rs.getString(“ACCOUNT_NO”),<br />
                           rs.getDouble(“BALANCE”));<br />
   }};<br />
});</p><br />
<br />
<p>return queryResult;<br />
 }<br />
}</p><br />
<br />
<p>轮询 /view endpoint 的JavaScript仍然存在。</p><br />
<br />
<p>通过所有这些更改，当您运行应用程序时，您仍然可以选择信用卡或借记卡，并在余额部分中反映余额。 就在这一次，借记/贷记是通过与用于查看账户当前余额的组件不同的组件完成的。</p><br />
<br />
<p>Overview of the Axon Building Blocks<br />
在这篇文章中，我们讨论了Axon Framework中的一些新构建块。 让我们来迅速回顾一下：</p><br />
<br />
<p>SimpleEventBus<br />
Axon基础设施负责事件路由到事件处理程序。</p><br />
<br />
<p>AnnotationEventListenerBeanPostProcessor<br />
在Spring应用程序中使用手动方式使用Axon。它扫描具有@EventHandler注释的Spring bean，并自动将它们注册为事件处理程序到事件总线。</p><br />
<br />
<p>RegisterEvent method<br />
可以通过在扩展AbstractAggregateRoot的域对象中的方法，以注册用于发布的域事件。</p><br />
<br />
<p>概要<br />
到目前为止，我们已经能够以CQRS的方式，设置应用程序的组件。</p><br />
<br />
<p>您会注意到我们在没有提及或使用事件溯源（Event Sourcing）的情况下完成了这项工作，这表明如果您不需要它时，您可以在不使用事件源的情况下构建CQRS应用程序。</p><br />
<br />
<p>但是如果你想使用Event Sourcing怎么办？ Axon Framework如何提供帮助？ 下一篇文章探索使用Axon Framework的CQRS：应用事件采购答案，询问如何使用Axon Framework在CQRS应用程序中使用事件溯源。</p><br />
<br />
<p>https://blog.csdn.net/quguang65265/article/details/81382319</p><br />
<br />
<p>https://www.cnblogs.com/daxnet/archive/2013/04/30/3052029.html</p><br />
<br />
<p>http://www.360doc.com/content/13/1226/09/10504424_340184984.shtml<br />
https://www.cnblogs.com/uoyo/p/12421553.html</p><br />
<br />
<p>https://www.jdon.com/eda.html<br />
https://www.jdon.com/48068<br />
https://blog.christianposta.com/microservices/why-microservices-should-be-event-driven-autonomy-vs-authority/</p><br />
<br />
<p>https://www.jdon.com/49113</p><br />
<br />
<p>https://www.jdon.com/eda.html<br />
https://www.jdon.com/event.html</p><br />
<br />
<p>https://www.jdon.com/49081</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category architect
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>