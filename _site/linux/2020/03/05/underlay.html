<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">underlay overlay</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-03-05T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Mar 5, 2020</time></p>
					</div>
					 <p>sdn网络中underlay和overlay网络的区别：</p><br />
<br />
<p>1、概念不同</p><br />
<br />
<p>underlay是传统单层网络，是当前数据中心网络基础转发架构的网络，而overlay是一层逻辑网络，指通过控制协议对边缘的网络设备进行网络构建和扩展。</p><br />
<br />
<p>联系：</p><br />
<br />
<p>underlay网络与overlay网络相互独立而又相互联系。</p><br />
<br />
<p>1、overlay网络使用underlay网络点对点传递报文</p><br />
<br />
<p>2、报文如何传递到overlay网络的目的节点完全取决于underlay网络的控制平面和数据平面</p><br />
<br />
<p>3、报文在overlay网络出入的节点处理则完全由overlay网络的封装协议来决定</p><br />
<br />
<p>4、Overlay网络也是一个网络，是建立在Underlay网络之上的网络</p><br />
<br />
<p>5、Overlay网络的节点通过虚拟的或逻辑的链接进行通信，每一个虚拟的或逻辑的链接对应于Underlay网络的一条路径(Path)，由多个前后衔接的链接组成。</p><br />
<br />
<p>SDN的相关概念：</p><br />
<br />
<p>软件定义网络（Software Defined Network, SDN ），是Emulex网络一种新型网络创新架构，是网络虚拟化的一种实现方式，其核心技术OpenFlow通过将网络设备控制面与数据面分离开来，从而实现了网络流量的灵活控制，使网络作为管道变得更加智能。<br />
<!-- more --><br />
随着云计算、大数据、移动互联网等新技术的普及，部署大量虚拟机成为一种必然趋势。不过，虚拟机需要在网络中无限制地迁移到目的物理位置，在传统数据中心网络中几乎无法满足，这样虚拟机在迁移范围上要受到网络架构限制，在规模上要受网络规格限制，网络隔离和分离能力也制约着虚拟机的大批量部署，解决这些虚拟机迁移问题理想的方案是在传统单层网络（Underlay）基础上叠加（Overlay）一层逻辑网络，将网络分成两个组成部分。在 Underlay网络中，所有的转发行为都由控制器决定，控制器通过OpenFlow协议或者定制的BGP协议将转发表项下发给转发器，转发器仅仅执行动作，没有单独的控制面；而在Overlay网络中，这种网络的转发器一般都是传统设备，不支持OpenFlow，或者私有定制协议不能部署，这时就要用到隧道技术。基础网络还是传统网络形式，通过路由协议打通各个节点，但是在服务器接入点，采用隧道技术将数据报文进行封装或者解封装。对传统网络来说见到的就是普通的数据报文，转发即可。隧道技术实际上就是报文的马甲，迷惑网络设备，让设备以为是自己人，实际上在外表以下还有一个真实转发的内容。</p><br />
<br />
<p>Underlay网络</p><br />
<br />
<p>以太网从最开始设计出来就是一个分布式网络，没有中心的控制节点，网路中的各个设备之间通过协议传递的方式学习网络的可达信息，由每台设备自己决定要如何转发，这直接导致了没有整体观念，不能从整个网络的角度对流量进行调控。由于要完成所有网络设备之间的互通，就必须使用通用的语言，这就是网络协议，RFC就是网络协议的法律，相当于国际法，各个设备供应商遵从国际法行事，就基本保证了整个网络世界的正常运行。Underlay就是当前数据中心网路基础转发架构的网络，只要数据中心网络上任意两点路由可达即可，指的是物理基础层。我们可以通过物理网络设备本身的技术改良、扩大设备数量、带宽规模等完善Underlay网络，其包含了一切现有的传统网络技术。</p><br />
<br />
<p>Overlay网络</p><br />
<br />
<p>Overlay在网络技术领域，是一种网络架构上叠加的虚拟化技术模式，其大体框架是对基础网络不进行大规模修改的条件下，实现应用在网络上的承载，并能与其它网络业务分离。它是建立在已有网络上的虚拟网，用逻辑节点和逻辑链路构成了Overlay网络。Overlay网络是具有独立的控制和转发平面，对于连接在Overlay边缘设备之外的终端系统来说，物理网络是透明的。通过部署Overlay网络，可以实现物理网络向云和虚拟化的深度延伸，使云资源池化能力可以摆脱物理网络的重重限制，是实现云网融合的关键。Overlay网络也是一个网络，不过是建立在Underlay网络之上的网络。Overlay网络的节点通过虚拟的或逻辑的链接进行通信，每一个虚拟的或逻辑的链接对应于Underlay网络的一条路径(Path)，由多个前后衔接的链接组成。</p><br />
<br />
<p>Overlay技术可以分为网络Overlay，主机Overlay和混合式Overlay三大类。网络Overlay是指通过控制协议对边缘的网络设备进行网络构建和扩展，也就是本文所讲的Overlay网络技术。Overlay网络技术多种多样，一般采用TRILL、VxLan、GRE、NVGRE等隧道技术。TRILL（Transparent Interconnection of Lots of Links）技术是电信设备厂商主推的新型环网技术；NVGRE（Network Virtualization using Generic Routing Encapsulation）和STT（Stateless Transport Tunneling Protocol）是IT厂商主推的Overlay技术；以及大家非常熟悉的VXLAN（Virtual eXtensible LAN）等基于隧道的封装技术。由于这些也都是新增的协议，均需要升级现有网络设备才能支持。Overlay网络中应用部署的位置将不受限制，网络设备可即插即用、自动配置下发，自动运行，Overlay网络业务变化，基础网络不感知，并对传统网络改造极少，最为重要的是虚拟机和物理服务器都可以接入Overlay网络中。</p><br />
<br />
<p>Overlay网络和Underlay网络是相互独立的，Overlay网络使用Underlay网络点对点传递报文，而报文如何传递到Overlay网络的目的节点完全取决于Underlay网络的控制平面和数据平面，报文在Overlay网络入和出节点的处理(如丢弃，转发)则完全由Overlay网络的封装协议来决定。既然是隧道技术，就需要在原有报文的基础增加一些报文头，这无疑会增加网络转发负担，要多传递一些“无用”字节报文，会降低网路性能，Underlay方式才是数据中心网络发展的终极形式。还有Overlay网络并没有完全的与物理网络解耦合，仍然需要在服务器和网络设备上做大量的人工配置，Overlay网络的部署在可维护性上不是减少，反而是增加了运维的负担。Overlay网络和Underlay网络实际上并不是什么新鲜概念，比如在传统网络中，L3VPN、灵活QINQ、MACinMAC等功能都是隧道技术，这些协议的作用和Overlay的实现作用非常类似，只不过Overlay所用到的新协议考虑更多的是虚拟机迁移、移动性，新协议定义内容更加丰富和合理而已。Overlay网络技术充分考虑到了数据中心网络的现实问题，现有的网络很难一下子切换到SDN网络，网络完全由控制器和Underlay网络构成，转发平面与控制平面完全解耦。Overlay网络就可以充分利用现有的物理网络，完全虚拟出一张逻辑网络，这样完全可以满足虚拟机在网络里任意迁移的目的，又不会浪费现有的网络资源，是在SDN网络和传统网络之间做出的一种折衷方案，网络的未来必要还是Underlay加控制器的方案。</p><br />
<br />
<p>将数据中心网络分为Underlay和Overlay两个部分，是在数据中心虚拟化的大背景下产生的，虽然目前Overlay网络更为重要，但是也需要Underlay网络，而且Underlay网络必不可少，在相当长的一段时间内，两种网络形式将长期并存。随着SDN技术的成熟，Overlay网络也许会慢慢退出历史舞台，完全由控制器接管网络。</p><br />
<br />
<p>网络虚拟化(Network Virtualization)对于很多网络工程师尤其是刚入行的新手常常有一种懵懵懂懂，不甚了然的神秘感觉，虽然常常为之想入非非，最终还是似是而非。在这篇BLOG里面，除了举例，不涉及具体的技术和实现，尽量展现网络虚拟化背后的最基本的原理(Rationale)和思想(Idea)。可能很多人都发现，理解网络技术和协议背后的原理和思想比具体配置操作这些技术和协议更重要，这就是说，知其然当然很好，但更好的是知其所以然。毫无疑问，这一原则同样地适用于其他计算机科学领域。</p><br />
<br />
<p>虚拟网络也是网络</p><br />
<br />
<p>一般地，一个虚拟网络是在物理网络或在其他虚拟网络之上，用软件的方法构造出的逻辑网络(Logic Network)，以实现用户定义的网络拓扑(Networking Topology)并满足用户特定的需求。主要应用的场景是多租户云计算数据中心，在下文中，我们还要展开讨论。上面的定义其实没有真正揭示虚拟网络的内涵，实际上，虚拟网络也是网络，如果从网络是什么这个简单得常常被忽略的问题出发，来探讨虚拟网络的具体内涵，似乎更容易抓住这一概念的本质。我们可以从静态和动态两个角度来审视网络：</p><br />
<br />
<p>从静态的角度来看，网络可表示为数据结构中的图(Graph)，网络的节点(如交换机和路由器，一些文献把他们统称为Datapath)是为图的顶点(Vertex)，而链接(Link)就是图的边(Edge)，这就是网络的拓扑视图。对于每一个网络节点，其数据(Data Traffic)转发行为由一系列的查询表(Lookup Table)如二层MAC表(L2 MAC Table)、三层路由表(L3 FIB Table)，ACL(Access Control Lists)表来定义。当从某个端口收到一个数据报文(Packet)或数据帧(Frame)时，转发引擎(Forwarding Engine)通过解析，查表，应用策略(如 QoS)，最后，将报文或帧从另一个端口转出。这里只是给出非常粗略的描述，实际的情况要复杂很多，其实这也就是我们平常所说的网络的数据平面(Data Plane)，对应于物理交换机的交换芯片的转发引擎的功能。当然，也可以看做SDN模式下，由Controller控制的数据转发设备(如OpenFlow交换机)。</p><br />
<br />
<p>从动态的角度来看，网络把数据流(Data Traffic)从一个和网络连接的主机(Host)送到另一个和网络连接的主机，这里，主机可以是物理服务器，也可以是虚拟计算机(Virtual Machine)。为此，事先要有一个定义好的地址空间，每个主机和网络节点都被分配(动态的或静态的)一个唯一标识自己的地址，如IP地址。这样，根据地址就能够识别出每个主机在网络中的位置，即接入网络的入口节点。两个主机要交换数据，首先要计算出他们之间的数据流的通路，上文把网络比作数据结构的图，这里的通路当然相当于图中的路径(Path)了，可表示为一个向量，其中的每个元素代表一个网络节点/顶点，两个相邻的网络节点/顶点之间有链路/边相连接，向量的头元素和尾元素分别与通信的主机相连。数据流透过这一通路，经过中间网络节点的中转，就从源主机到达目的主机。几乎所有的L3路由协议，无论是距离矢量(distance-vector)路由协议如BGP还是链路状态(link-state)路由协议如OSPF，顾名思义，都有一个简单的目标，就是计算并生成主机或子网之间的路由，即通路，并最终将具体的Route Entries安装到网络节点的FIB中。本质上，L2的网络也有自己的机制来计算通路，转发数据，如Ethernet交换机通过MAC地址学习(MAC Learning)来获取数据帧的Egress端口，从而将数据流转发到目的主机。上述的这一动态过程是由网络的控制平面(Control Plane)来管理的，网络操作员(Network Operator)通过控制平面配置L2/L3的路由和转发协议，达到数据在主机之间交换的目的。对应于交换机，控制平面就是运行在CPU之上的操作系统；而对于SDN的模式来说，控制平面是由Controller及上面的应用来实现的。更通俗地讲，在两个主机交换数据之前，网络的控制平面需要回答三个问题：第一，你是谁？(目的主机的地址是什么？)；第二，你在哪里？(目的主机和网络的哪个节点连接？)；第三，如何找到你？(到达目的主机的通路如何建立？)。</p><br />
<br />
<p>简单总结一下，网络有两部分构成：第一，由网络节点(datapath)作为顶点和网络链接作为边构成的静态的拓扑图；第二，由各种网络协议构成的动态的数据流路由转发机制。若是忘掉那些枯燥繁杂的各式各样的系统、设备、协议的配置细节，网络其实就是这点事儿，看起来并不复杂。虚拟网络作为逻辑意义上的网络，具备网络的所有组成要素，包括网络拓扑，如网络节点、链接、网络节点中的查询表等，相对于物理网络，这些只不过是虚拟的，逻辑的，软件实现的。同样地，虚拟网络也可以是L2网络或L3网络，分别使用不同的控制平面管理，因此也是可配置的。</p><br />
<br />
<p>文献1在讨论SDN(Software Defined Networking)编程语言Pyretic的拓扑抽象(Topology Abstraction)时，使用了一种叫做Network Object的机制，实际上就是给编程用户提供了一个虚拟网络。上图是Network Object的一个多对一(many-to-one)的示例，对于用户而言，可见的(Visible)是上面的一个虚拟交换机连接三个主机的虚拟网络，而不是下面的由三个交换机组成的物理网络。这一虚拟网络对于实现某些应用提供了极大的方便，假设给定一个SDN的Controller，使用OpenFlow实现一个类似L2网络的MAC-Learning模块时，开发者就只需面对单独的一个虚拟交换机，而不必考虑物理网络的复杂的拓扑结构，也无须考虑如何用spanning tree来避免循环回路的细枝末节，从而只要把相关的Flow Entries安装在这一个假设支持OpenFlow的虚拟交换机上，何等简单快捷。而对于虚拟交换机到物理交换机的映射，则由Pyretic的runtime系统来完成，它还要把用户安装到虚拟交换机上面的Flow Entries转换成各个物理交换机的Flow Entries并安装到物理交换机上。具体的细节可阅读文献1。</p><br />
<br />
<p>实际上，虚拟网络也并不是什么新概念。目前广泛使用的VLAN技术就是把一个物理的L2网络变身为多个逻辑的虚拟L2网络，与此同时，也把一个广播域(broadcast domain)分隔成多个广播域。而VRF(VPN Routing/Forwarding)之于L3就如同VLAN之于L2，VRF可以使一个物理路由器(Router)拥有多个FIB，从而把单一的路由器分隔成多个“虚拟”的路由器，以支持不同的VPN实例(Instance)。这是两个一对多(one-to-many)的虚拟网络的例子。</p><br />
<br />
<p>虚拟网络所为何事</p><br />
<br />
<p>虚拟网络的兴起不是偶然的，这要从云计算说起。云应用模式下，存在着多个云资源的租赁者(Tenant)，所有的租户共享云服务商的物理基础设施，包括服务器，存储，网络，这就形成了多租户模式(Muti-Tenancy)。这种方式特别地受到资金并不富裕的互联网创业公式的青睐。租户希望云服务商提供的网络作为自身企业网络自然的延伸和扩展，所谓“自然”就是不需要改变自身网络配置的情况下和云服务商提供的网络资源无缝的集成在一起。与此同时，也能够把自身企业网络承载的应用和服务自然地迁移部署到云服务商的网络上。对云服务商的数据中心来说，传统的L2/L3的网络技术很难适应这个难度很高的技术挑战，必须改变已有的网络管理的模式和向租户提供网络资源(provision)的方式。</p><br />
<br />
<p>租户希望快速的把自己的应用部署到云服务商提供的网络、计算和存储的资源，而且这些资源要具有高度的可扩展性和可伸缩性。比如某租户在云端的数据中心部署一个典型的Web应用，一般地，Web应用有表示层(Presentation Tier)、业务层(Business Tier)和数据层(Data Storage Tier)构成，各层之间相互隔离，由复杂的网络连接完成数据交换，如下图所示。联通这些服务器或虚拟机，需要网络管理员一个设备一个设备的配置，这是极其琐碎且很容易出错的工作，需要耗费很长的时间反复调试。另外，这样的Web应用对计算和存储资源的需求是可扩展的和可伸缩的，意味着连接这些计算和存储资源的网络拓扑也要随之变大变小，无疑更加重了配置的工作。更加不幸的是，云服务提供商的数据中心要承载成千上万的倏兴倏灭的不同租户的应用，这些应用对部署的时间往往有苛刻的要求。并且，出于安全的考虑，不同应用之间的网络还要实施严格的隔离，不允许有数据交换。所以必须以更加高效的灵活的可靠的方式向租户的应用提供动态变化的网络服务。</p><br />
<br />
<p>一方面，租户能够快速的获取虚拟的计算和存储资源，另一方面，却需要较长时间等待网络资源配置的完成。面对云模式下新的应用需求，网络陷入了疲于奔命的尴尬的窘境，等待着虚拟化的救赎。计算存储资源的虚拟化通过hypervisor的技术已趋成熟，云计算虚拟化的最后一里路就是网络的虚拟化。这意味着，云服务商给租户的网络是虚拟网络，尽管使用相同的底层物理网络的基础设施，每个租户得到的虚拟网络(包括控制平面和数据平面)却是相互独立的，完全隔离的，通过云服务商提供的控制平面，租户可任意的配置管理自己的虚拟网络。更为重要的是，在软件的帮助下，虚拟网络可以很快地交付给租户。加上虚拟的计算和存储资源，每个租户的虚拟资源形成一个完整的VPC(Virtual Private Cloud)。虚拟网络隔离的特性使得每个虚拟网络可以使用重叠的甚至相同的地址空间，而不必担心相互干扰。如两个L3的虚拟网络都可以使用10.0.0.0/8作为自己的地址空间，一个L2的虚拟网络不可能看到或学到另外一个L2虚拟网络的设备的MAC地址，更不可能通过L2协议交换数据。对于混合云(Hybrid Cloud)的租户，这是极大的方便，因为云端的虚拟网络可以使用租户自身网络的地址空间，而不用考虑这一地址空间是如何定义的。</p><br />
<br />
<p>如果我们把这种计算、存储和网络资源的租赁模式看做云，那么，正是虚拟技术把计算的云装扮成云卷云舒的曼妙世界。</p><br />
<br />
<p>Overlay助力虚拟网络</p><br />
<br />
<p>从现有的产品和解决方案来看，虚拟网络大多是借助于Overlay的技术实现的，如VMware的NSX。Overlay网络也是一个网络，不过是建立在Unerlay网络之上的网络。Overlay网络的节点通过虚拟的或逻辑的链接进行通信，每一个虚拟的或逻辑的链接对应于Underlay网络的一条路径(Path)，由多个前后衔接的链接组成。需要注意的是，Overlay网络和Underlay网络是相互独立的，Overlay网络使用Underlay网络点对点(peer-to-peer)的传递报文，而报文如何传递到Overlay网络的目的节点完全取决于Underlay网络的控制平面和数据平面，报文在Overlay网络Ingress和Egress节点的处理(如抛弃，转发)则完全由Overlay网络的封装协议来决定。Overlay/Underlay既不新鲜，也不神秘，比如在TCP/IP的Layer模型中，L3的IP网络可以看做L2的Ethernet网络的Overlay网络，而L2的Ehernet网络就是L3的IP网络的Underlay网络。</p><br />
<br />
<p>由此不难看出，在向租户提供虚拟资源租赁服务时，每个租户的虚拟网络就实现为以云服务商数据中心IP网络为Underlay网络的Overlay网络。上图给出了云服务数据中心虚拟网络功能模块的简单示意图，省略了许多细节。假设每个物理服务器中装有多个不同租户的虚拟机，如Tenant A，Tenant B和Tenant C，图中分别以不同的颜色来标识。租户的虚拟机通过物理的或逻辑的链接接入IP网络(即Underlay网络)的虚拟边缘设备(NVE, Network Virtualization Edge)。NVE是实现虚拟网络的关键模块，它可以实现为Hypevisor的虚拟交换机的功能，也可以在物理交换机或路由器中实现。对于一个给定租户的虚拟网络，NVE帮助建立终端节点到终端节点的逻辑链接，即隧道。要完成这一任务，在每个NVE中维护一个可达信息(Reachability Information)的MAP表，结合我们的例子，其内容如下。根据实现技术和隧道封装协议的不同，可达信息的内容和形式也会大相径庭，这里只是为了说明的方便，给出一个简化的版本。在表中，Address指的是NVE的地址，VNID(Virtual Network Identifier)是虚拟机VM所属的虚拟网络的全局唯一ID，每个租户可以有一个或多个虚拟网络，VAP(Virtual Access Point)是VM接入NVE的虚拟接口，NVE可用它来判断报文来之哪个VM。假设Tenant A的虚拟机VM_A1向VM_A2发送一个报文，NVE 1得到这个报文后，就可以进行隧道封装，具体如何封装由隧道的封装协议来定义，一般地，封装之后，外层的封装协议的协议头中必定包括如下信息：虚拟网络的ID，源IP地址和目的IP地址，外层的源IP地址就是NVE 1(Ingress)的IP地址，外层的目的IP地址就是NVE 2(Egress)的IP地址。这些封装信息都可以从关键的可达信息MAP表中获取。封装后的报文就可以作为普通的IP报文在Underlay的IP网络中从一个NVE传递到另一个NVE。NVE 2收到报文后，解封装，根据VNID及报文本身的地址信息，将报文转给VM_A2。</p><br />
<br />
<p>NVE是如何获取可达信息MAP表的呢？这由虚拟网络或Overlay网络的控制平面完成，有两种方法：第一种方式可称为分布式的方法，NVE首先得到和其直接相关的可达信息，即直连的VM和VM的VNID，然后NVE之间直接对话，相互交换可达信息，VM和NVE之间以及NVE和NVE之间要有定义好的标准的对话协议，这和传统的路由协议的原理完全一样，其缺点是需要就这些对话协议单独配置每个NVE；第二种方式是集中式的方法，也就是SDN的方法，SDN的三个显著特征就是数据平面与管理平面隔离，集中式管理和可编程，因此，可达信息可通过类似于OpenStack的Orchestration系统配置计算和存储资源时自动生成，再由控制器(Controller)中转到每个参与的NVE，这是一个自动配置的过程(Automatic Configuration)，可快速向租户交互云端的网络虚拟资源。SDN的方法的最大优点就是一个字，快！因此，这会是云计算数据中心部署SDN解决方案的最大动力。可达信息MAP表还是支持VM动态迁移的秘密所在，一个VM无论迁移到哪个物理服务器上，只要通过上述两种方式使得每个NVE的可达信息MAP表及时更新，就能够保持该VM与外界的正常通信。</p><br />
<br />
<p>VXLAN:看个例子吧</p><br />
<br />
<p>目前，数据中心实现虚拟网络最为看好的封装协议就是VXLAN，背后有Cisco和VMware的支持。VXLAN是以IP网络作为Underlay网络，向租户提供L2的虚拟网络，当然也是Overlay网络。VXLAN把租户的Ethernet数据帧(Frame)封装到UDP报文中，如下图(来自文献6)。然后，在Underlay的IP网络中通过隧道从一个VTEP(VXLAN Tunnel End Point)传递到另一个VTEP，不难理解，VTEP相当于上文中的NVE，而VXLAN ID就相当于上文的VNID，VXLAN ID有24位的编码空间，大大超过VLAN的12位编码空间。</p><br />
<br />
<p>VXLAN的可达信息MAP表有两个表：VTEP L2 Table和VLAN to VXLAN ID MAP， 如下图所示(来自文献6)。Ingress VTEP封装时，从VLAN ID查询到VXLAN ID，然后根据MAC和VXLAN ID得到远端的Egress VTEP的IP地址；Egress VTEP解封装时，其过程与之相反。</p><br />
<br />
<p>https://edu.51cto.com/center/course/lesson/index?id=155206</p><br />
<br />
<p>在SDN如火如荼的今天，每一个网络工程师见到最多的术语大概就是Underlay、Overlay、大二层了。每一个人理解这些技术一定有一套自己的见解，今天站在我个人的家角度来探讨一下Underlay、Overlay、大二层技术。</p><br />
<br />
<p>我第一次在网络领域看到overlay这个术语大概在2011年左右，刚入门开始学习MPLS/ L 3 VPN那会。我们不妨来看一下MPLS/ L3 VPN中介绍的Overlay是怎样的。</p><br />
<br />
<p>VPN的两大类别：</p><br />
<br />
<p>Peer-to-Peer VPN<br />
Overlay VPN</p><br />
<br />
<p>相关术语——</p><br />
<br />
<p>1，P network：运营商核心网络，也就是提供VPN服务供应商自己的网络 “P = provider”</p><br />
<br />
<p>2，C network：客户网络 “C = customer”</p><br />
<br />
<p>3，P device： 运营商网络核心设备</p><br />
<br />
<p>4，PE device：运营商网络边缘设备，用于连接P网络与C网络 “PE = Provider Edge”</p><br />
<br />
<p>5，CE device：客户网络边缘设备，用于连接P网络与C网络 “CE = Customer Edge”</p><br />
<br />
<p>Peer-to-Peer VPN 与 overlay VPN的区别：</p><br />
<br />
<p>在peet-to-peer VPN的实现中，C网络路由会在P网络内传递，P设备也会参与C网络的路由选择，这句话突出的重点就是：P网络与C网络融为一体，C网络路由的任何改变都会影响到P网络。</p><br />
<br />
<p>在overlay VPN的实现中，CE对接PE设备，P网络提供所有CE之间的网络可达性，基于这个网络可达性为基准，CE通过隧道技术构建点到点的VPN互联。隧道基于诸如：GRE、L2TP、PPTP、IPsec。VPN隧道把多个分布于不同位置的网络相互互联起来，这些VPN隧道组成的网络就是overlay网络。它们完全独立与底层的P网络，P网络只负责提供VPN隧道的src-dst可达性。</p><br />
<br />
<p>到这里其实已经把underlay与overlay的概念引出来了，underlay就是底层承载网，overlay就是基于底层网络互联互通的基础加上隧道技术去构建一个虚拟的网络。overlay的核心其实就是打隧道（tunnel）。</p><br />
<br />
<p>总结一下：</p><br />
<br />
<p>underlay是底层网络，负责互联互通</p><br />
<br />
<p>overlay是基于隧道技术实现的，overlay的流量需要跑在underlay之上。</p><br />
<br />
<p>VPN场景的Underlay/Overlay就介绍到这里，接下来讨论下DC（DataCenter）网络</p><br />
<br />
<p>server-virtualization 技术把物理服务器虚拟化成多个虚拟机，企业应用部署在虚拟机上，hypervisor/VMM用来监控虚拟机状态，当故障即将来了的时候，hypervisor通过相关技术（vmotion、live migration）把运行在当前物理机上的虚拟机迁移到其他物理机上。虚机迁移这个动作对用用户是透明的，所以在迁移前后必须保证虚机的MAC/IP 是保持不变的。这样就意味着迁移必须在一个二层广播域内完成。（一个IP子网=一个广播域）</p><br />
<br />
<p>在传统的基于STP的组网结构中，为了避免二层广播域太大，二层终结在汇聚交换机上，一组汇聚上的同一VLAN在一个广播域内，这里我们况且把一组汇聚称为一个POD。在传统架构中，虚机迁移只能在POD内完成。</p><br />
<br />
<p>STP组网二层无法扩大的原因：<br />
因为以太网交换机的工作原理是learn/flooding，这样的机制下如果二层域太大，一个broadcast就有可能影响到所有节点。并且STP是树形结构，单路径转发（冗余路径被阻塞），现代数据中心互联40G/100G情况下，会存在严重的资源浪费。</p><br />
<br />
<p>这个时候MAC Routing技术（Trill/Fabric-Path）应运而生，控制层面采用成熟的IS-IS协议，同时引入AF（assert-forwarder）来破环，这样就可以基于TriLL/Fabirc-Path来构建二层全连接网络。</p><br />
<br />
<p>但是很不幸的是，Trill弥补了STP技术的缺陷，实现了full-mesh的Layer 2 连接，扩大了二层范围，但是由于机制过于复杂、trill域内所有设备必须支持trill、多租户能力不足等缺陷。导致该技术只是昙花一现，并没有做到大范围的部署。</p><br />
<br />
<p>Network Virtualization Overlays（NOV3技术）</p><br />
<br />
<p>NOV3技术代表：</p><br />
<br />
<p>VxLAN（VMware）</p><br />
<br />
<p>NvGRE（Microsoft）</p><br />
<br />
<p>STT（Nicira）</p><br />
<br />
<p>可以看到NOV3技术的发起者都是软件厂商， VMware（私有云）、Microsoft（公有云）、Nicira（SDN）。</p><br />
<br />
<p>NOV3技术的实现原理其实非常简单，VxLAN=MAC in UDP 、NvGRE = MAC in GRE、STT = MAC in TCP（伪TCP），显而言之都是一种再封装技术，基于新的头部实现隧道互联。使用这些隧道组成的逻辑网络就是数据中心的overlay。基于隧道的发起点不同，又分为硬件overlay（隧道两端是物理交换机）、软件overlay（隧道两端是vSwitch）。</p><br />
<br />
<p>当NOV3应用于现代数据中心时，隧道是基于IP实现的，所以underlay的作用就只是提供隧道两端IP可达性，这样底层物理组网就非常可以三层到边，构建CLOS结构的网状IP Fabric。</p><br />
<br />
<p>underlay完成三层互通之后，overlay如何设计、优化就可以独立讨论，因为overlay的任何变化都不会对underlay产生影响。</p><br />
<br />
<p>到这里就大概了解了什么是underlay、overlay，为什么需要大二层、如何构建大二层网络。关于underlay的路由拓扑设计，overlay的控制层面设计后期我们分开讨论。</p><br />
<br />
<p>在SDN如火如荼的今天，每一个网络工程师见到最多的术语大概就是Underlay、Overlay、大二层了。每一个人理解这些技术一定有一套自己的见解，今天站在我个人的家角度来探讨一下Underlay、Overlay、大二层技术。</p><br />
<br />
<p>我第一次在网络领域看到overlay这个术语大概在2011年左右，刚入门开始学习MPLS/ L 3 VPN那会。我们不妨来看一下MPLS/ L3 VPN中介绍的Overlay是怎样的。</p><br />
<br />
<p>VPN的两大类别：</p><br />
<br />
<p>Peer-to-Peer VPN<br />
Overlay VPN</p><br />
<br />
<p>相关术语——</p><br />
<br />
<p>1，P network：运营商核心网络，也就是提供VPN服务供应商自己的网络 “P = provider”</p><br />
<br />
<p>2，C network：客户网络 “C = customer”</p><br />
<br />
<p>3，P device： 运营商网络核心设备</p><br />
<br />
<p>4，PE device：运营商网络边缘设备，用于连接P网络与C网络 “PE = Provider Edge”</p><br />
<br />
<p>5，CE device：客户网络边缘设备，用于连接P网络与C网络 “CE = Customer Edge”</p><br />
<br />
<p>Peer-to-Peer VPN 与 overlay VPN的区别：</p><br />
<br />
<p>在peet-to-peer VPN的实现中，C网络路由会在P网络内传递，P设备也会参与C网络的路由选择，这句话突出的重点就是：P网络与C网络融为一体，C网络路由的任何改变都会影响到P网络。</p><br />
<br />
<p>在overlay VPN的实现中，CE对接PE设备，P网络提供所有CE之间的网络可达性，基于这个网络可达性为基准，CE通过隧道技术构建点到点的VPN互联。隧道基于诸如：GRE、L2TP、PPTP、IPsec。VPN隧道把多个分布于不同位置的网络相互互联起来，这些VPN隧道组成的网络就是overlay网络。它们完全独立与底层的P网络，P网络只负责提供VPN隧道的src-dst可达性。</p><br />
<br />
<p>到这里其实已经把underlay与overlay的概念引出来了，underlay就是底层承载网，overlay就是基于底层网络互联互通的基础加上隧道技术去构建一个虚拟的网络。overlay的核心其实就是打隧道（tunnel）。</p><br />
<br />
<p>总结一下：</p><br />
<br />
<p>underlay是底层网络，负责互联互通</p><br />
<br />
<p>overlay是基于隧道技术实现的，overlay的流量需要跑在underlay之上。</p><br />
<br />
<p>VPN场景的Underlay/Overlay就介绍到这里，接下来讨论下DC（DataCenter）网络</p><br />
<br />
<p>server-virtualization 技术把物理服务器虚拟化成多个虚拟机，企业应用部署在虚拟机上，hypervisor/VMM用来监控虚拟机状态，当故障即将来了的时候，hypervisor通过相关技术（vmotion、live migration）把运行在当前物理机上的虚拟机迁移到其他物理机上。虚机迁移这个动作对用用户是透明的，所以在迁移前后必须保证虚机的MAC/IP 是保持不变的。这样就意味着迁移必须在一个二层广播域内完成。（一个IP子网=一个广播域）</p><br />
<br />
<p>在传统的基于STP的组网结构中，为了避免二层广播域太大，二层终结在汇聚交换机上，一组汇聚上的同一VLAN在一个广播域内，这里我们况且把一组汇聚称为一个POD。在传统架构中，虚机迁移只能在POD内完成。</p><br />
<br />
<p>STP组网二层无法扩大的原因：<br />
因为以太网交换机的工作原理是learn/flooding，这样的机制下如果二层域太大，一个broadcast就有可能影响到所有节点。并且STP是树形结构，单路径转发（冗余路径被阻塞），现代数据中心互联40G/100G情况下，会存在严重的资源浪费。</p><br />
<br />
<p>这个时候MAC Routing技术（Trill/Fabric-Path）应运而生，控制层面采用成熟的IS-IS协议，同时引入AF（assert-forwarder）来破环，这样就可以基于TriLL/Fabirc-Path来构建二层全连接网络。</p><br />
<br />
<p>但是很不幸的是，Trill弥补了STP技术的缺陷，实现了full-mesh的Layer 2 连接，扩大了二层范围，但是由于机制过于复杂、trill域内所有设备必须支持trill、多租户能力不足等缺陷。导致该技术只是昙花一现，并没有做到大范围的部署。</p><br />
<br />
<p>Network Virtualization Overlays（NOV3技术）</p><br />
<br />
<p>NOV3技术代表：</p><br />
<br />
<p>VxLAN（VMware）</p><br />
<br />
<p>NvGRE（Microsoft）</p><br />
<br />
<p>STT（Nicira）</p><br />
<br />
<p>可以看到NOV3技术的发起者都是软件厂商， VMware（私有云）、Microsoft（公有云）、Nicira（SDN）。</p><br />
<br />
<p>NOV3技术的实现原理其实非常简单，VxLAN=MAC in UDP 、NvGRE = MAC in GRE、STT = MAC in TCP（伪TCP），显而言之都是一种再封装技术，基于新的头部实现隧道互联。使用这些隧道组成的逻辑网络就是数据中心的overlay。基于隧道的发起点不同，又分为硬件overlay（隧道两端是物理交换机）、软件overlay（隧道两端是vSwitch）。</p><br />
<br />
<p>当NOV3应用于现代数据中心时，隧道是基于IP实现的，所以underlay的作用就只是提供隧道两端IP可达性，这样底层物理组网就非常可以三层到边，构建CLOS结构的网状IP Fabric。</p><br />
<br />
<p>underlay完成三层互通之后，overlay如何设计、优化就可以独立讨论，因为overlay的任何变化都不会对underlay产生影响。</p><br />
<br />
<p>到这里就大概了解了什么是underlay、overlay，为什么需要大二层、如何构建大二层网络。关于underlay的路由拓扑设计，overlay的控制层面设计后期我们分开讨论。</p><br />
<br />
<p>https://zhuanlan.zhihu.com/p/32486650</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category linux
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>