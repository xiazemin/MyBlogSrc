<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">rsync scp sftp 文件同步方式</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-05-24T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> May 24, 2020</time></p>
					</div>
					 <p>对于线下环境<br />
直接 scp -r /home/user/xxx user@10.96.10.10:/home/user/xxx</p><br />
<br />
<p>对于线上线下经过中转站的文件，只能sftp了<br />
tar -czvf conf.tar /home/conf<br />
sftp -oPort=80 user@ftp.com<br />
put<br />
get<br />
tar -zxvf conf.tar -C /<br />
对应目录覆盖<br />
<!-- more --><br />
rsync命令是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。rsync使用所谓的“rsync算法”来使本地和远程两个主机之间的文件达到同步，这个算法只传送两个文件的不同部分，而不是每次都整份传送，因此速度相当快。</p><br />
<br />
<p>rsync功能 <br />
作为命令，实现本地-远程文件同步<br />
作为服务，实现本地-远程文件同步<br />
rsync特点 <br />
可以镜像保存整个目录树和文件系统<br />
可以保留原有的权限(permission,mode)，owner,group,时间(修改时间,modify time)，软硬链接，文件acl,文件属性(attributes)信息等<br />
传输效率高，使用同步算法，只比较变化的<br />
支持匿名传输，方便网站镜像；也可以做验证，加强安全<br />
rsync同类服务 <br />
sync 同步：刷新文件系统缓存，强制将修改过的数据块写入磁盘，并且更新超级块。<br />
async 异步：将数据先放到缓冲区，再周期性（一般是30s）的去同步到磁盘。<br />
rsync 远程同步：remote synchronous<br />
rsync -av /etc/passwd /tmp/1.txt</p><br />
<br />
<p>rsync -av /tmp/1.txt 192.168.36.131:/tmp/2.txt</p><br />
<br />
<p>rsync格式<br />
rsync [OPTION] … SRC   DEST<br />
rsync [OPTION] … SRC   [user@]host:DEST<br />
rsync [OPTION] … [user@]host:SRC   DEST<br />
rsync [OPTION] … SRC   [user@]host::DEST<br />
rsync [OPTION] … [user@]host::SRC   DEST</p><br />
<br />
<p>rsync常用选项<br />
-a 包含-rtplgoD<br />
-r 同步目录时要加上，类似cp时的-r选项<br />
-v 同步时显示一些信息，让我们知道同步的过程<br />
-l 保留软连接<br />
-L 加上该选项后，同步软链接时会把源文件给同步<br />
-p 保持文件的权限属性<br />
-o 保持文件的属主<br />
-g 保持文件的属组<br />
-D 保持设备文件信息<br />
-t 保持文件的时间属性<br />
–delete 删除DEST中SRC没有的文件<br />
–exclude 过滤指定文件，如–exclude “logs”会把文件名包含logs的文件或者目录过滤掉，不同步<br />
-P 显示同步过程，比如速率，比-v更加详细<br />
-u 加上该选项后，如果DEST中的文件比SRC新，则不同步<br />
-z 传输时压缩<br />
rsync通过ssh方式同步<br />
-e “ssh -p 22” 指定端口：<br />
rsync 通过服务的方式同步<br />
 1.编辑配置文件/etc/rsyncd.conf<br />
 2.启动服务rsync –daemon<br />
 3.格式：rsync -av test1/ test@192.168.36.130::test/<br />
rsyncd.conf样例：</p><br />
<br />
<p>port=873<br />
log file=/var/log/rsync.log<br />
pid file=/var/run/rsyncd.pid<br />
address=192.168.36.130<br />
[test]<br />
path=/tmp/rsync<br />
use chroot=true<br />
max connections=4<br />
read only=no<br />
list=true<br />
uid=root<br />
gid=root<br />
auth users=test<br />
secrets file=/etc/rsyncd.passwd<br />
hosts allow=192.168.36.131 （多个ip以空格隔开，也可以写ip段：192.168.36.0/24）<br />
 rsyncd.conf配置文件详解</p><br />
<br />
<p>port：指定在哪个端口启动rsyncd服务，默认是873端口。<br />
 log file：指定日志文件。<br />
 pid file：指定pid文件，这个文件的作用涉及服务的启动、停止等进程管理操作。<br />
 address：指定启动rsyncd服务的IP。假如你的机器有多个IP，就可以指定由其中一个启动rsyncd服务，如果不指定该参数，默认是在全部IP上启动。<br />
 []：指定模块名，里面内容自定义。<br />
 path：指定数据存放的路径。<br />
 use chroot true|false：表示在传输文件前首先chroot到path参数所指定的目录下。这样做的原因是实现额外的安全防护，但缺点是需要以roots权限，并且不能备份指向外部的符号连接所指向的目录文件。默认情况下chroot值为true，如果你的数据当中有软连接文件，阿铭建议你设置成false。<br />
 max connections：指定最大的连接数，默认是0，即没有限制。<br />
 read only ture|false：如果为true，则不能上传到该模块指定的路径下。<br />
 list：表示当用户查询该服务器上的可用模块时，该模块是否被列出，设定为true则列出，false则隐藏。<br />
 uid/gid：指定传输文件时以哪个用户/组的身份传输。<br />
 auth users：指定传输时要使用的用户名。<br />
 secrets file：指定密码文件，该参数连同上面的参数如果不指定，则不使用密码验证。注意该密码文件的权限一定要是600。格式：用户名:密码<br />
 hosts allow：表示被允许连接该模块的主机，可以是IP或者网段，如果是多个，中间用空格隔开。 <br />
 当设置了auth users和secrets file后，客户端连服务端也需要用用户名密码了，若想在命令行中带上密码，可以设定一个密码文件<br />
 rsync -avL test@192.168.36.130::test/test1/  /tmp/test8/ –password-file=/etc/pass <br />
 其中/etc/pass内容就是一个密码，权限要改为600<br />
把端口改了之后需要使用–port 指定端口</p><br />
<br />
<p>rsync是类unix系统下的数据镜像备份工具，从软件的命名上就可以看出来了——remote sync。它的特性如下：</p><br />
<br />
<p>1、可以镜像保存整个目录树和文件系统。<br />
2、可以很容易做到保持原来文件的权限、时间、软硬链接等等。<br />
3、无须特殊权限即可安装。<br />
4、优化的流程，文件传输效率高。<br />
5、可以使用rcp、ssh等方式来传输文件，当然也可以通过直接的socket连接。<br />
6、支持匿名传输。</p><br />
<br />
<p>https://blog.51cto.com/wanwentao/579008</p><br />
<br />
<p>https://www.samba.org/ftp/rsync/rsync.html</p><br />
<br />
<p>2.1 说在前面的话<br />
rsync官方网站: https://www.samba.org/ftp/rsync/rsync.html</p><br />
<br />
<p>rsync是可以实现增量备份的工具。配合任务计划，rsync能实现定时或间隔同步，配合inotify或sersync，可以实现触发式的实时同步。</p><br />
<br />
<p>rsync可以实现scp的远程拷贝(rsync不支持远程到远程的拷贝，但scp支持)、cp的本地拷贝、rm删除和”ls -l”显示文件列表等功能。但需要注意的是，rsync的最终目的或者说其原始目的是实现两端主机的文件同步，因此实现的scp/cp/rm等功能仅仅只是同步的辅助手段，且rsync实现这些功能的方式和这些命令是不一样的。事实上，rsync有一套自己的算法，其算法原理以及rsync对算法实现的机制可能比想象中要复杂一些。平时使用rsync实现简单的备份、同步等功能足以，没有多大必要去深究这些原理性的内容。但是想要看懂rsync命令的man文档、使用”-vvvv”分析rsync执行过程，以及实现rsync更强大更完整的功能，没有这些理论知识的支持是绝对不可能实现的。本篇文章将简单介绍rsync的使用方法和它常用的功能。在本篇文章之后的下几篇文章中，将介绍inotify+rsync和sersync，再之后将详细解释rsync相关的原理，其中包括官方技术报告的翻译(即算法原理)、rsync同步的整个过程(也是官方推荐文章的翻译)，然后专门使用一篇文章通过示例来详细解释rsync算法原理，最后给出rsync的man文档翻译。希望各位朋友能藉此深入rsync。</p><br />
<br />
<p>回归正题，以下是rsync相关基础内容。</p><br />
<br />
<p>2.2 rsync同步基本说明<br />
rsync的目的是实现本地主机和远程主机上的文件同步(包括本地推到远程，远程拉到本地两种同步方式)，也可以实现本地不同路径下文件的同步，但不能实现远程路径1到远程路径2之间的同步(scp可以实现)。</p><br />
<br />
<p>不考虑rsync的实现细节，就文件同步而言，涉及了源文件和目标文件的概念，还涉及了以哪边文件为同步基准。例如，想让目标主机上的文件和本地文件保持同步，则是以本地文件为同步基准，将本地文件作为源文件推送到目标主机上。反之，如果想让本地主机上的文件和目标主机上的文件保持同步，则目标主机上的文件为同步基准，实现方式是将目标主机上的文件作为源文件拉取到本地。当然，要保持本地的两个文件相互同步，rsync也一样能实现，这就像Linux中cp命令一样，以本地某文件作为源，另一文件作为目标文件，但请注意，虽然rsync和cp能达到相同的目的，但它们的实现方式是不一样的。</p><br />
<br />
<p>既然是文件同步，在同步过程中必然会涉及到源和目标两文件之间版本控制的问题，例如是否要删除源主机上没有但目标上多出来的文件，目标文件比源文件更新(newer than source)时是否仍要保持同步，遇到软链接时是拷贝软链接本身还是拷贝软链接所指向的文件，目标文件已存在时是否要先对其做个备份等等。</p><br />
<br />
<p>rsync同步过程中由两部分模式组成：决定哪些文件需要同步的检查模式以及文件同步时的同步模式。</p><br />
<br />
<p>(1).检查模式是指按照指定规则来检查哪些文件需要被同步，例如哪些文件是明确被排除不传输的。默认情况下，rsync使用”quick check”算法快速检查源文件和目标文件的大小、mtime(修改时间)是否一致，如果不一致则需要传输。当然，也可以通过在rsync命令行中指定某些选项来改变quick check的检查模式，比如”–size-only”选项表示”quick check”将仅检查文件大小不同的文件作为待传输文件。rsync支持非常多的选项，其中检查模式的自定义性是非常有弹性的。</p><br />
<br />
<p>(2).同步模式是指在文件确定要被同步后，在同步过程发生之前要做哪些额外工作。例如上文所说的是否要先删除源主机上没有但目标主机上有的文件，是否要先备份已存在的目标文件，是否要追踪链接文件等额外操作。rsync也提供非常多的选项使得同步模式变得更具弹性。</p><br />
<br />
<p>相对来说，为rsync手动指定同步模式的选项更常见一些，只有在有特殊需求时才指定检查模式，因为大多数检查模式选项都可能会影响rsync的性能。</p><br />
<br />
<p>2.3 rsync三种工作方式<br />
以下是rsync的语法：</p><br />
<br />
<p>Local:  rsync [OPTION…] SRC… [DEST]</p><br />
<br />
<p>Access via remote shell:<br />
  Pull: rsync [OPTION…] [USER@]HOST:SRC… [DEST]<br />
  Push: rsync [OPTION…] SRC… [USER@]HOST:DEST</p><br />
<br />
<p>Access via rsync daemon:<br />
  Pull: rsync [OPTION…] [USER@]HOST::SRC… [DEST]<br />
        rsync [OPTION…] rsync://[USER@]HOST[:PORT]/SRC… [DEST]<br />
  Push: rsync [OPTION…] SRC… [USER@]HOST::DEST<br />
        rsync [OPTION…] SRC… rsync://[USER@]HOST[:PORT]/DEST<br />
由此语法可知，rsync有三种工作方式：</p><br />
<br />
<p>(1).本地文件系统上实现同步。命令行语法格式为上述”Local”段的格式。</p><br />
<br />
<p>(2).本地主机使用远程shell和远程主机通信。命令行语法格式为上述”Access via remote shell”段的格式。</p><br />
<br />
<p>(3).本地主机通过网络套接字连接远程主机上的rsync daemon。命令行语法格式为上述”Access via rsync daemon”段的格式。</p><br />
<br />
<p>前两者的本质是通过管道通信，即使是远程shell。而方式(3)则是让远程主机上运行rsync服务，使其监听在一个端口上，等待客户端的连接。</p><br />
<br />
<p>但是，还有第四种工作方式：通过远程shell也能临时启动一个rsync daemon，这不同于方式(3)，它不要求远程主机上事先启动rsync服务，而是临时派生出rsync daemon，它是单用途的一次性daemon，仅用于临时读取daemon的配置文件，当此次rsync同步完成，远程shell启动的rsync daemon进程也会自动消逝。此通信方式的命令行语法格式同”Access via rsync daemon”，但要求options部分必须明确指定”–rsh”选项或其短选项”-e”。</p><br />
<br />
<p>以下是对rsync语法的简单说明，由于rsync支持一百多个选项，所以此处只介绍几个常用选项。完整的选项说明以及rsync的使用方法见我翻译的”man rsync”。</p><br />
<br />
<p>Local:  rsync [OPTION…] SRC… [DEST]</p><br />
<br />
<p>Access via remote shell:<br />
  Pull: rsync [OPTION…] [USER@]HOST:SRC… [DEST]<br />
  Push: rsync [OPTION…] SRC… [USER@]HOST:DEST</p><br />
<br />
<p>Access via rsync daemon:<br />
  Pull: rsync [OPTION…] [USER@]HOST::SRC… [DEST]<br />
        rsync [OPTION…] rsync://[USER@]HOST[:PORT]/SRC… [DEST]<br />
  Push: rsync [OPTION…] SRC… [USER@]HOST::DEST<br />
        rsync [OPTION…] SRC… rsync://[USER@]HOST[:PORT]/DEST<br />
其中，第一个路径参数一定是源文件路径，即作为同步基准的一方，可以同时指定多个源文件路径。最后一个路径参数则是目标文件路径，也就是待同步方。路径的格式可以是本地路径，也可以是使用user@host:path或user@host::path的远程路径，如果主机和path路径之间使用单个冒号隔开，表示使用的是远程shell通信方式，而使用双冒号隔开的则表示的是连接rsync daemon。另外，连接rsync daemon时，还提供了URL格式的路径表述方式rsync://user@host/path。</p><br />
<br />
<p>如果仅有一个SRC或DEST参数，则将以类似于”ls -l”的方式列出源文件列表(只有一个路径参数，总会认为是源文件)，而不是复制文件。</p><br />
<br />
<p>如果对rsync不熟悉，可暂先只了解本地以及远程shell格式的user@host:path路径格式。例如：</p><br />
<br />
<p>[root@xuexi ~]# rsync /etc/fstab /tmp                # 在本地同步<br />
[root@xuexi ~]# rsync -r /etc 172.16.10.5:/tmp       # 将本地/etc目录拷贝到远程主机的/tmp下，以保证远程/tmp目录和本地/etc保持同步<br />
[root@xuexi ~]# rsync -r 172.16.10.5:/etc /tmp       # 将远程主机的/etc目录拷贝到本地/tmp下，以保证本地/tmp目录和远程/etc保持同步<br />
[root@xuexi ~]# rsync /etc/                          # 列出本地/etc/目录下的文件列表<br />
[root@xuexi ~]# rsync 172.16.10.5:/tmp/              # 列出远程主机上/tmp/目录下的文件列表<br />
另外，使用rsync一定要注意的一点是，源路径如果是一个目录的话，带上尾随斜线和不带尾随斜线是不一样的，不带尾随斜线表示的是整个目录包括目录本身，带上尾随斜线表示的是目录中的文件，不包括目录本身。例如：</p><br />
<br />
<p>[root@xuexi ~]# rsync -a /etc /tmp<br />
[root@xuexi ~]# rsync -a /etc/ /tmp<br />
第一个命令会在/tmp目录下创建etc目录，而第二个命令不会在/tmp目录下创建etc目录，源路径/etc/中的所有文件都直接放在/tmp目录下。</p><br />
<br />
<p>2.4 选项说明和示例<br />
接下来是rsync的选项说明。</p><br />
<br />
<p>-v：显示rsync过程中详细信息。可以使用”-vvvv”获取更详细信息。<br />
-P：显示文件传输的进度信息。(实际上”-P”=”–partial –progress”，其中的”–progress”才是显示进度信息的)。<br />
-n –dry-run  ：仅测试传输，而不实际传输。常和”-vvvv”配合使用来查看rsync是如何工作的。<br />
-a –archive  ：归档模式，表示递归传输并保持文件属性。等同于”-rtopgDl”。<br />
-r –recursive：递归到目录中去。<br />
-t –times：保持mtime属性。强烈建议任何时候都加上”-t”，否则目标文件mtime会设置为系统时间，导致下次更新<br />
          ：检查出mtime不同从而导致增量传输无效。<br />
-o –owner：保持owner属性(属主)。<br />
-g –group：保持group属性(属组)。<br />
-p –perms：保持perms属性(权限，不包括特殊权限)。<br />
-D        ：是”–device –specials”选项的组合，即也拷贝设备文件和特殊文件。<br />
-l –links：如果文件是软链接文件，则拷贝软链接本身而非软链接所指向的对象。<br />
-z        ：传输时进行压缩提高效率。<br />
-R –relative：使用相对路径。意味着将命令行中指定的全路径而非路径最尾部的文件名发送给服务端，包括它们的属性。用法见下文示例。<br />
–size-only ：默认算法是检查文件大小和mtime不同的文件，使用此选项将只检查文件大小。<br />
-u –update ：仅在源mtime比目标已存在文件的mtime新时才拷贝。注意，该选项是接收端判断的，不会影响删除行为。<br />
-d –dirs   ：以不递归的方式拷贝目录本身。默认递归时，如果源为”dir1/file1”，则不会拷贝dir1目录，使用该选项将拷贝dir1但不拷贝file1。<br />
–max-size  ：限制rsync传输的最大文件大小。可以使用单位后缀，还可以是一个小数值(例如：”–max-size=1.5m”)<br />
–min-size  ：限制rsync传输的最小文件大小。这可以用于禁止传输小文件或那些垃圾文件。<br />
–exclude   ：指定排除规则来排除不需要传输的文件。<br />
–delete    ：以SRC为主，对DEST进行同步。多则删之，少则补之。注意”–delete”是在接收端执行的，所以它是在<br />
            ：exclude/include规则生效之后才执行的。<br />
-b –backup ：对目标上已存在的文件做一个备份，备份的文件名后默认使用”~”做后缀。<br />
–backup-dir：指定备份文件的保存路径。不指定时默认和待备份文件保存在同一目录下。<br />
-e          ：指定所要使用的远程shell程序，默认为ssh。<br />
–port      ：连接daemon时使用的端口号，默认为873端口。<br />
–password-file：daemon模式时的密码文件，可以从中读取密码实现非交互式。注意，这不是远程shell认证的密码，而是rsync模块认证的密码。<br />
-W –whole-file：rsync将不再使用增量传输，而是全量传输。在网络带宽高于磁盘带宽时，该选项比增量传输更高效。<br />
–existing  ：要求只更新目标端已存在的文件，目标端还不存在的文件不传输。注意，使用相对路径时如果上层目录不存在也不会传输。<br />
–ignore-existing：要求只更新目标端不存在的文件。和”–existing”结合使用有特殊功能，见下文示例。<br />
–remove-source-files：要求删除源端已经成功传输的文件。<br />
rsync的选项非常多，能够实现非常具有弹性的功能，以上选项仅仅只是很小一部分常用的选项，关于更完整更详细的选项说明，见我的rsync man手册翻译。</p><br />
<br />
<p>虽然选项非常多，但最常用的选项组合是”avz”，即压缩和显示部分信息，并以归档模式传输。</p><br />
<br />
<p>2.4.1 基础示例<br />
以下是几个本地同步示例和通过远程shell实现的同步示例，示例中没有使用”-a”选项，目的是为了更清晰地说明各选项的作用。</p><br />
<br />
<p>(1).将/etc/fstab拷贝到/tmp目录下。</p><br />
<br />
<p>[root@xuexi ~]# rsync /etc/fstab /tmp<br />
(2).将/etc/cron.d目录拷贝到/tmp下。</p><br />
<br />
<p>[root@xuexi ~]# rsync -r /etc/cron.d /tmp<br />
该命令会在目标主机上创建/tmp/cron.d目录，并将/etc/cron.d/中的文件放入到/tmp/cron.d/目录中，也就是说默认情况下，是不会在目录路径下创建上层目录/etc的。</p><br />
<br />
<p>(3).将/etc/cron.d目录拷贝到/tmp下，但要求在/tmp下也生成etc子目录。</p><br />
<br />
<p>[root@xuexi ~]# rsync -R -r /etc/cron.d /tmp<br />
其中”-R”选项表示使用相对路径，此相对路径是以目标目录为根的。对于上面的示例，表示在目标上的/tmp下创建etc/cron.d目录，即/tmp/etc/cron.d，etc/cron.d的根”/”代表的就是目标/tmp。</p><br />
<br />
<p>如果要拷贝的源路径较长，但只想在目标主机上保留一部分目录结构，例如要拷贝/var/log/anaconda/*到/tmp下，但只想在/tmp下保留从log开始的目录，如何操作？使用一个点代表相对路径的起始位置即可，也就是将长目录进行划分。</p><br />
<br />
<p>[root@xuexi ~]# rsync -R -r /var/./log/anaconda /tmp<br />
这样，从点开始的目录都是相对路径，其相对根目录为目标路径。所以对于上面的示例，将在目标上创建/tmp/log/anaconda/*。</p><br />
<br />
<p>(4).对远程目录下已存在文件做一个备份。</p><br />
<br />
<p>[root@xuexi ~]# rsync -R -r –backup /var/./log/anaconda /tmp<br />
这样在目标目录下，已存在的文件就被做一个备份，备份文件默认使用”~”做后缀，可以使用”–suffix”指定备份后缀。</p><br />
<br />
<p>[root@xuexi tmp]# ll log/anaconda/<br />
total 3112<br />
-rw——- 1 root root    6668 Jul 14 12:45 anaconda.log<br />
-rw——- 1 root root    6668 Jul 14 11:44 anaconda.log~<br />
-rw——- 1 root root    3826 Jul 14 12:45 ifcfg.log<br />
-rw——- 1 root root    3826 Jul 14 11:44 ifcfg.log~<br />
-rw——- 1 root root 1102699 Jul 14 12:45 journal.log<br />
-rw——- 1 root root 1102699 Jul 14 11:44 journal.log~<br />
-rw——- 1 root root       0 Jul 14 12:45 ks-script-1uLekR.log<br />
-rw——- 1 root root       0 Jul 14 11:44 ks-script-1uLekR.log~<br />
-rw——- 1 root root       0 Jul 14 12:45 ks-script-iGpl4q.log<br />
-rw——- 1 root root       0 Jul 14 11:44 ks-script-iGpl4q.log~<br />
-rw——- 1 root root  160420 Jul 14 12:45 packaging.log<br />
-rw——- 1 root root  160420 Jul 14 11:44 packaging.log~<br />
-rw——- 1 root root   27906 Jul 14 12:45 program.log<br />
-rw——- 1 root root   27906 Jul 14 11:44 program.log~<br />
-rw——- 1 root root   78001 Jul 14 12:45 storage.log<br />
-rw——- 1 root root   78001 Jul 14 11:44 storage.log~<br />
-rw——- 1 root root  197961 Jul 14 12:45 syslog<br />
-rw——- 1 root root  197961 Jul 14 11:44 syslog~<br />
可以使用”–backup-dir”指定备份文件保存路径，但要求保存路径必须存在。</p><br />
<br />
<p>[root@xuexi ~]# mkdir /tmp/log_back</p><br />
<br />
<p>[root@xuexi ~]# rsync -R -r –backup –backup-dir=/tmp/log_back /var/./log/anaconda /tmp<br />
指定备份路径后，默认将不会加备份后缀，除非使用”–suffix”显式指定后缀，如”–suffix=~”。</p><br />
<br />
<p>[root@xuexi tmp]# tree /tmp/log_back/<br />
/tmp/log_back/<br />
└── log<br />
    └── anaconda<br />
        ├── anaconda.log<br />
        ├── ifcfg.log<br />
        ├── journal.log<br />
        ├── ks-script-1uLekR.log<br />
        ├── ks-script-iGpl4q.log<br />
        ├── packaging.log<br />
        ├── program.log<br />
        ├── storage.log<br />
        └── syslog<br />
(5).指定ssh连接参数，如端口、连接的用户、ssh选项等。</p><br />
<br />
<p>[root@xuexi tmp]# &gt;~/.ssh/known_hosts   # 先清空host key以便下面的测试</p><br />
<br />
<p>[root@xuexi tmp]# rsync -e “ssh -p 22 -o StrictHostKeyChecking=no” /etc/fstab 172.16.10.5:/tmp<br />
Warning: Permanently added ‘172.16.10.5’ (RSA) to the list of known hosts.<br />
root@172.16.10.5’s password:<br />
可见直接指定ssh参数是生效的。</p><br />
<br />
<p>(6).”–existing”和”–ignore-existing”</p><br />
<br />
<p>”–existing”是只更新目标端已存在的文件。</p><br />
<br />
<p>目前/tmp/{a,b}目录中内容如下，bashrc在a目录中，crontab在b目录中，且a目录中多了一个c子目录。</p><br />
<br />
<p>[root@xuexi ~]# tree /tmp/{a,b}<br />
/tmp/a<br />
├── bashrc<br />
├── c<br />
│   └── find<br />
├── fstab<br />
├── profile<br />
└── rc.local<br />
/tmp/b<br />
├── crontab<br />
├── fstab<br />
├── profile<br />
└── rc.local</p><br />
<br />
<p>1 directory, 9 files<br />
使用”–existing”选项使得只更新目标端已存在的文件。</p><br />
<br />
<p>[root@xuexi ~]# rsync -r -v –existing /tmp/a/ /tmp/b         <br /><br />
sending incremental file list<br />
fstab<br />
profile<br />
rc.local</p><br />
<br />
<p>sent 2972 bytes  received 70 bytes  6084.00 bytes/sec<br />
total size is 204755  speedup is 67.31<br />
结果只有3个目标上已存在的文件被更新了，由于目标上没有c目录，所以c目录中的文件也没有进行传输。</p><br />
<br />
<p>而”–ignore-existing”是更新目标端不存在的文件。</p><br />
<br />
<p>[root@xuexi ~]# rsync -r -v –ignore-existing /tmp/a/ /tmp/b<br />
sending incremental file list<br />
bashrc<br />
c/<br />
c/find</p><br />
<br />
<p>sent 202271 bytes  received 54 bytes  404650.00 bytes/sec<br />
total size is 204755  speedup is 1.01<br />
“–existing”和”–ignore-existing”结合使用时，有个特殊功效，当它们结合”–delete”使用的时候，文件不会传输，但会删除receiver端额外多出的文件。</p><br />
<br />
<p>$ mkdir a b<br />
$ touch a/{1..4}.txt<br />
$ touch b/a.log</p><br />
<br />
<p>$ rsync -nrv –delete a/ b/<br />
sending incremental file list<br />
deleting a.log<br />
1.txt<br />
2.txt<br />
3.txt<br />
4.txt</p><br />
<br />
<p>sent 118 bytes  received 33 bytes  302.00 bytes/sec<br />
total size is 0  speedup is 0.00 (DRY RUN)</p><br />
<br />
<p>$ rsync -nrv –existing –ignore-existing –delete a/ b/<br />
sending incremental file list<br />
deleting a.log</p><br />
<br />
<p>sent 106 bytes  received 21 bytes  254.00 bytes/sec<br />
total size is 0  speedup is 0.00 (DRY RUN)<br />
实际上，”–existing”和”–ingore-existing”是传输规则，只会影响receiver要求让sender传输的文件列表，在receiver决定哪些文件需要传输之前的过程，是这两个选项无法掌控的，所以各种规则、”–delete”等操作都不会被这两个选项影响。</p><br />
<br />
<p>(7).”–remove-source-files”删除源端文件。</p><br />
<br />
<p>使用该选项后，源端已经更新成功的文件都会被删除，源端所有未传输或未传输成功的文件都不会被移除。未传输成功的原因有多种，如exclude排除了，”quick check”未选项该文件，传输中断等等。</p><br />
<br />
<p>总之，显示在”rsync -v”被传输列表中的文件都会被移除。如下：</p><br />
<br />
<p>[root@xuexi ~]# rsync -r -v –remove-source-files /tmp/a/anaconda /tmp/a/audit /tmp     <br /><br />
sending incremental file list<br />
anaconda/anaconda.log<br />
anaconda/ifcfg.log<br />
anaconda/journal.log<br />
anaconda/ks-script-1uLekR.log<br />
anaconda/ks-script-iGpl4q.log<br />
anaconda/packaging.log<br />
anaconda/program.log<br />
anaconda/storage.log<br />
anaconda/syslog<br />
audit/audit.log</p><br />
<br />
<p>sent 4806915 bytes  received 204 bytes  9614238.00 bytes/sec<br />
total size is 4805676  speedup is 1.00<br />
上述显示出来的文件在源端全部被删除。</p><br />
<br />
<p>2.4.2 “–exclude”排除规则<br />
使用”–exclude”选项指定排除规则，排除那些不需要传输的文件。</p><br />
<br />
<p>[root@xuexi tmp]# rsync -r -v –exclude=”anaconda/*.log” /var/log/anaconda /var/log/audit /tmp<br />
sending incremental file list<br />
anaconda/<br />
anaconda/syslog<br />
audit/<br />
audit/audit.log</p><br />
<br />
<p>sent 3365629 bytes  received 58 bytes  6731374.00 bytes/sec<br />
total size is 3365016  speedup is 1.00<br />
上例中只排除了anaconda目录中的log文件，但是audit目录中的log文件是正常传输的。</p><br />
<br />
<p>注意，一个”–exclude”只能指定一条规则，要指定多条排除规则，需要使用多个”–exclude”选项，或者将排除规则写入到文件中，然后使用”–exclude-from”选项读取该规则文件。</p><br />
<br />
<p>另外，除了”–exclude”排除规则，还有”–include”包含规则，顾名思义，它就是筛选出要进行传输的文件，所以include规则也称为传输规则。它的使用方法和”–exclude”一样。如果一个文件即能匹配排除规则，又能匹配包含规则，则先匹配到的立即生效，生效后就不再进行任何匹配。</p><br />
<br />
<p>最后，关于规则，最重要的一点是它的作用时间。当发送端敲出rsync命令后，rsync将立即扫描命令行中给定的文件和目录(扫描过程中还会按照目录进行排序，将同一个目录的文件放在相邻的位置)，这称为拷贝树(copy tree)，扫描完成后将待传输的文件或目录记录到文件列表中，然后将文件列表传输给接收端。而筛选规则的作用时刻是在扫描拷贝树时，所以会根据规则来匹配并决定文件是否记录到文件列表中(严格地说是会记录到文件列表中的，只不过排除的文件会被标记为hide隐藏起来)，只有记录到了文件列表中的文件或目录才是真正需要传输的内容。换句话说，筛选规则的生效时间在rsync整个同步过程中是非常靠前的，它会影响很多选项的操作对象，最典型的如”–delete”。也许，你看完这一整篇文章都没感觉到这一点的重要性，但如果你阅读rsync的man文档或者学习rsync的原理，你一定会深有体会。</p><br />
<br />
<p>实际上，排除规则和包含规则都只是”–filter”筛选规则的两种特殊规则。”–filter”比较复杂，它有自己的规则语法和匹配模式，由于篇幅有限，以及考虑到本文的难度定位，”–filter”规则不便在此多做解释，仅简单说明下规则类，帮助理解下文的”–delete”。</p><br />
<br />
<p>以下是rsync中的规则种类，不解之处请结合下文的”–delete”分析：</p><br />
<br />
<p>(1).exclude规则：即排除规则，只作用于发送端，被排除的文件不会进入文件列表(实际上是加上隐藏规则进行隐藏)。</p><br />
<br />
<p>(2).include规则：即包含规则，也称为传输规则，只作用于发送端，被包含的文件将明确记录到文件列表中。</p><br />
<br />
<p>(3).hide规则：即隐藏规则，只作用于发送端，隐藏后的文件对于接收端来说是看不见的，也就是说接收端会认为它不存在于源端。</p><br />
<br />
<p>(4).show规则：即显示规则，只作用于发送端，是隐藏规则的反向规则。</p><br />
<br />
<p>(5).protect规则：即保护规则，该规则只作用于接收端，被保护的文件不会被删除掉。</p><br />
<br />
<p>(6).risk规则：即取消保护规则。是protect的反向规则。</p><br />
<br />
<p>除此之外，还有一种规则是”clear规则”，作用是删除include/exclude规则列表。</p><br />
<br />
<p>2.4.2.1 如何一次写对exclude规则<br />
很多人写不来规则，总发现写出来后没有生效，要写成功一次规则得要不断地进行调试、调试、调试，令人无比心烦。</p><br />
<br />
<p>其实很多工具的规则写法是类似的，比如tar也一样。规则写好后不生效的原因一般有两种：绝对路径和相对路径的问题、尾随斜线的问题。</p><br />
<br />
<p>一般来说，操作的路径是绝对路径，那么规则里必须也写绝对路径，而且必须写完整的绝对路径。操作的路径是相对路径，那么规则里必须写相对路径，从哪里开始相对可能和工具有关。比如要操作路径”/abc/def”，想要筛选def下的所有txt文件，必须写成”/abc/def/<em>.txt”，如果操作路径是”abc/def”，那么要筛选这个目录下的所有txt文件，可能需要写成”abc/def/</em>.txt”，也有可能写成”<em>.txt”，甚至写成”def/</em>.txt”，写成哪种形式依赖于这个软件如何解析相对路径。</p><br />
<br />
<p>对于rsync来说，要更复杂一些，因为除了bash的相对路径外，它自身还提供了一个相对路径的解析规则，而且尾随斜线也会影响规则的写法。这就是为什么写rsync规则非常麻烦的原因。</p><br />
<br />
<p>我这里提供一个判断规则写法的方式，纯属我个人的经验总结：使用”-n”选项是dry run模式，也就是只测试不传输，”-i”选项是输出要传输文件的路径。”-i”只是一个便捷性选项，可以替换成其它选项来自定义输出格式，有时候通过这些信息来做一些判断是非常有用的，具体的可以翻man手册。</p><br />
<br />
<p>root:~$ rsync -nr -i a b/<br />
cd+++++++++ a/</p><br />
<blockquote><br />
  <p>f+++++++++ a/1.txt<br />
f+++++++++ a/2.txt<br />
f+++++++++ a/3.txt<br />
f+++++++++ a/4.txt<br />
这里已经显示了传输文件的路径”a/*“，也就是说包括了目录a，且是相对路径的。所以要写规则时，需要加上这个a路径，比如下面的排除规则。</p><br />
</blockquote><br />
<br />
<p>root:~$ rsync -nr -i –exclude=”a/2.txt”  a b/<br />
cd+++++++++ a/</p><br />
<blockquote><br />
  <p>f+++++++++ a/1.txt<br />
f+++++++++ a/3.txt<br />
f+++++++++ a/4.txt</p><br />
</blockquote><br />
<br />
<p>root:~$ rsync -nr -i –exclude=”a/*.txt”  a b/<br />
cd+++++++++ a/<br />
如果上面的传输路径a加上尾随斜线，再看-i的输出路径信息，发现已经改变了：</p><br />
<br />
<p>root:~$ rsync -nr -i a/ b/</p><br />
<blockquote><br />
  <p>f+++++++++ 1.txt<br />
f+++++++++ 2.txt<br />
f+++++++++ 3.txt<br />
f+++++++++ 4.txt<br />
所以这时的排除规则中不应该包含a目录前缀：</p><br />
</blockquote><br />
<br />
<p>root:~$ rsync -nr -i –exclude=”2.txt” ./a/ b/</p><br />
<blockquote><br />
  <p>f+++++++++ 1.txt<br />
f+++++++++ 3.txt<br />
f+++++++++ 4.txt</p><br />
</blockquote><br />
<br />
<p>2.4.3 “–delete”解释<br />
使用”–delete”选项后，接收端的rsync会先删除目标目录下已经存在，但源端目录不存在的文件。也就是”多则删之，少则补之”。</p><br />
<br />
<p>例如，先实现一次同步，再向目标目录中拷贝一个新文件，这样目标目录中就比源目录多出一个文件。</p><br />
<br />
<p>[root@xuexi ~]# rsync -r /etc/cron.d /tmp/</p><br />
<br />
<p>[root@xuexi ~]# cp /etc/fstab /tmp/cron.d/</p><br />
<br />
<p>[root@xuexi ~]# ls /tmp/cron.d/<br />
0hourly  fstab  raid-check  sysstat<br />
再使用”–delete”选项，这时会将目标端多出的文件给删除掉，然后进行同步。</p><br />
<br />
<p>[root@xuexi ~]# rsync -r -v /etc/cron.d /tmp –delete<br />
sending incremental file list<br />
deleting cron.d/fstab<br />
cron.d/0hourly<br />
cron.d/raid-check<br />
cron.d/sysstat</p><br />
<br />
<p>sent 704 bytes  received 70 bytes  1548.00 bytes/sec<br />
total size is 471  speedup is 0.61<br />
这样的行为实现了远程删除的功能，对于作用于本地的rsync，也就实现了rm的本地删除功能。而且，如果使用空目录作为源目录，则它的作用是清空目录上的整个目录。</p><br />
<br />
<p>如果将”–delete”选项和”–exclude”选项一起使用，则被排除的文件不会被删除。例如：</p><br />
<br />
<p>[root@xuexi ~]# rsync -r /var/log/anaconda /var/log/audit /tmp  # 先进行一次同步以便测试</p><br />
<br />
<p>[root@xuexi ~]# cp /etc/fstab /tmp/anaconda/                    # 拷贝一个新文件到目标目录以便测试</p><br />
<br />
<p>[root@xuexi ~]# rsync -r -v –exclude=”anaconda/*.log” /var/log/anaconda /var/log/audit /tmp –delete<br />
sending incremental file list<br />
deleting anaconda/fstab<br />
anaconda/syslog<br />
audit/audit.log</p><br />
<br />
<p>sent 3406190 bytes  received 52 bytes  6812484.00 bytes/sec<br />
total size is 3405579  speedup is 1.00<br />
结果发现只删除了”anaconda/fstab”文件，被”–exclude”规则匹配的anaconda/*.log文件都没有被删除。也就是网上所说的言论：exclude排除的文件不会被删除。</p><br />
<br />
<p>结论是没错的，但我想很多人不知道为何会如此，也可能从来没想过为何会如此，所以我简单地做个说明。</p><br />
<br />
<p>在发送端将文件列表发送给接收端后，接收端的generator(要是不知道，你认为是某个就好了)进程会扫描每个文件列表中的信息，然后对列表中的每个信息条目都计算数据块校验码，最后将数据库校验码发给发送端，发送端通过校验码来匹配哪些数据块是需要传输的，这样就实现了增量传输的功能——只传输改变的部分，不会传输整个文件。而delete删除的时间点是generator进程处理每个文件列表时、生成校验码之前进行的，先将目标上存在但源上不存在的多余文件删除，这样就无需为多余的文件生成校验码。</p><br />
<br />
<p>所以，delete动作是比”–exclude”规则更晚执行的，被”–exclude”规则排除的文件不会进入文件列表中，在执行了delete时会认为该文件不存在于源端，从而导致目标端将这些文件删除。但这是想当然的，尽管理论上确实是这样的，但是rsync为了防止众多误删除情况，提供了两种规则：保护规则(protect)和取消保护规则(risk)。默认情况下，”–delete”和”–exclude”一起使用时，虽然发送端的exclude规则将文件标记为隐藏，使得接收端认为这些被排除文件在源端不存在，但rsync会将这些隐藏文件标记为保护文件，使得它们不受delete行为的影响，这样delete就删除不了这些被排除的文件。如果还是想要强行删除被exclude排除的文件，可以使用”–delete-excluded”选项强制取消保护，这样即使被排除的文件也会被删除。</p><br />
<br />
<p>那么现在，是否理解了网上的言论”exclude排除的文件不会被删除”？</p><br />
<br />
<p>除了”–delete”，相关的选项还有”–delete-before”、”–delete-during”、”–delete-delay”等，它们都隐含了”–delete”选项，它们分别表示generator处理各个文件列表之前一次性全部删除待删除文件、处理文件列表时处理到哪个文件列表就删除该文件列表中的待删除文件，以及同步完所有数据后一次性删除所有待删除文件。</p><br />
<br />
<p>举个例子，假如源端要传输3个目录a、b、c，在目标端a目录中有a1、a2、a3共3个文件需要被删除，b目录中有b1、b2、b3需要删除，同理c目录也一样c1、c2、c3需要被删除。</p><br />
<br />
<p>如果是”–delete-before”，则在目标端rsync刚启动时，就会把a1-a3、b1-b3、c1-c3一次性删除，然后才会处理文件列表中的a目录，处理完a后处理b，再是c。</p><br />
<br />
<p>如果是”–delete-during”，则在目标端rsync刚启动时，先处理文件列表中的a目录，处理a目录时发现此目录中有待删除文件a1-a3，顺手就删除它们，然后完成a目录的相关操作，再处理文件列表中的b目录，发现也有待删除文件b1-b3，顺手删除它们，同理c1-c3也如此。</p><br />
<br />
<p>如果是”–delete-delay”，则同步完文件列表中的a/b/c目录后，最后一次性删除a1-a3、b1-b3、c1-c3。</p><br />
<br />
<p>其实”–delete”选项大多数情况下默认采用的就是”–delete-during”。</p><br />
<br />
<p>2.5 rsync daemon模式</p><br />
<br />
<p>2.5.1 简单介绍<br />
既然rsync通过远程shell就能实现两端主机上的文件同步，还要使用rsync的服务干啥？试想下，你有的机器上有一堆文件需要时不时地同步到众多机器上去，比如目录a、b、c是专门传输到web服务器上的，d/e、f、g/h是专门传输到ftp服务器上的，还要对这些目录中的某些文件进行排除，如果通过远程shell连接方式，无论是使用排除规则还是包含规则，甚至一条一条rsync命令地传输，这都没问题，但太过繁琐且每次都要输入同样的命令显得太死板。使用rsync daemon就可以解决这种死板问题。而且，rsync daemon是向外提供服务的，这样只要告诉了别人rsync的url路径，外人就能向ftp服务器一样获取文件列表并进行选择性地下载，所以，你所制定的列表，你的同事也可以获取到并使用。</p><br />
<br />
<p>举个简单的例子，Linux内核官网www.kernel.org提供rsync的下载方式，官方给出的地址是rsync://rsync.kernel.org/pub，可以根据这个地址找出你想下载的内核版本。例如要找出linux-3.0.15版本的内核相关文件。</p><br />
<br />
<p>[root@xuexi ~]# rsync –no-motd -r -v -f “+ <em>/” -f “+ linux-3.0.15</em>” -f “- *” -m rsync://rsync.kernel.org/pub/<br />
receiving file list … done<br />
drwxr-xr-x         124 2017/07/14 20:27:22 .<br />
drwxr-xr-x         178 2014/11/12 05:50:10 linux<br />
drwxr-xr-x        4096 2017/06/27 05:46:27 linux/kernel<br />
drwxr-xr-x      237568 2017/07/05 20:49:33 linux/kernel/v3.x<br />
-rw-r–r–    76803806 2012/01/04 03:00:31 linux/kernel/v3.x/linux-3.0.15.tar.bz2<br />
-rw-r–r–    96726195 2012/01/04 03:00:31 linux/kernel/v3.x/linux-3.0.15.tar.gz<br />
-rw-r–r–         836 2012/01/04 03:00:31 linux/kernel/v3.x/linux-3.0.15.tar.sign<br />
-rw-r–r–    63812604 2012/01/04 03:00:31 linux/kernel/v3.x/linux-3.0.15.tar.xz</p><br />
<br />
<p>sent 59 bytes  received 80.19K bytes  12.35K bytes/sec<br />
total size is 237.34M  speedup is 2957.66<br />
你无需关注上面的规则代表什么意思，需要关注的重点是通过rsync可以向外提供文件列表并提供相应的下载。</p><br />
<br />
<p>同样，你还可以根据路径，将rsync daemon上的文件拉取到本地实现下载的功能。</p><br />
<br />
<p>[root@xuexi ~]# rsync –no-motd -avzP rsync://rsync.kernel.org/pub/linux/kernel/v3.x/linux-3.0.15.tar.bz2 /tmp<br />
receiving incremental file list<br />
linux-3.0.15.tar.bz2<br />
     2834426   3%   300.51kB/s    0:40:22<br />
下面就来介绍下rsync daemon。</p><br />
<br />
<p>rsync daemon是”rsync –daemon”或再加上其他一些选项启动的，它会读取配置文件，默认是/etc/rsyncd.conf，并默认监听在873端口上，当外界有客户端对此端口发起连接请求，通过这个网络套接字就可以完成连接，以后与该客户端通信的所有数据都通过该网络套接字传输。</p><br />
<br />
<p>rsync daemon的通信方式和传输通道与远程shell不同。远程shell连接的两端是通过管道完成通信和数据传输的，即使连接的一端是远程主机，当连接到目标端时，将在目标端上根据远程shell进程fork出rsync进程使其成为rsync server。而rsync daemon是事先在server端上运行好的rsync后台进程(根据启动选项，也可以设置为非后台进程)，它监听套接字等待client端的连接，连接建立后所有通信方式都是通过套接字完成的。</p><br />
<br />
<p>注意，rsync中的server的概念从来就不代表是rsync daemon，server在rsync中只是一种通用称呼，只要不是发起rsync请求的client端，就是server端，你可以认为rsync daemon是一种特殊的server，其实daemon更应该称之为service。(之所以解释这一点，是避免各位初学的朋友在阅读man rsync过程中产生误解)</p><br />
<br />
<p>以下是rsync client连接rsync daemon时的命令语法：</p><br />
<br />
<p>Pull: rsync [OPTION…] [USER@]HOST::SRC… [DEST]<br />
      rsync [OPTION…] rsync://[USER@]HOST[:PORT]/SRC… [DEST]<br />
Push: rsync [OPTION…] SRC… [USER@]HOST::DEST<br />
      rsync [OPTION…] SRC… rsync://[USER@]HOST[:PORT]/DEST<br />
连接命令有两种类型，一种是rsync风格使用双冒号的”rsync user@host::src dest”，一种是url风格的”rsync://user@host:port/src dest”。对于rsync风格的连接命令，如果想要指定端口号，则需要使用选项”–port”。</p><br />
<br />
<p>上述语法中，其中daemon端的路径，如user@host::src，它的src代表的是模块名，而不是真的文件系统中的路径。关于rsync中的模块，相信见了下面的配置文件就会知道是什么意思。</p><br />
<br />
<p>2.5.2 daemon配置文件rsyncd.conf<br />
默认”rsync –daemon”读取的配置文件为/etc/rsyncd.conf，有些版本的系统上可能该文件默认不存在。rsyncd.conf的配置见man rsyncd.conf。以下是部分内容：</p><br />
<br />
<p>[root@xuexi ~]# cat /etc/rsyncd.conf</p><br />
<h1 id="etcrsyncd-configuration-file-for-rsync-daemon-mode">/etc/rsyncd: configuration file for rsync daemon mode</h1><br />
<br />
<h1 id="see-rsyncdconf-man-page-for-more-options">See rsyncd.conf man page for more options.</h1><br />
<br />
<h1 id="configuration-example">configuration example:</h1><br />
<br />
<h1 id="uid--nobody">uid = nobody</h1><br />
<h1 id="gid--nobody">gid = nobody</h1><br />
<h1 id="use-chroot--yes">use chroot = yes</h1><br />
<h1 id="max-connections--4">max connections = 4</h1><br />
<h1 id="pid-file--varrunrsyncdpid">pid file = /var/run/rsyncd.pid</h1><br />
<h1 id="exclude--lostfound">exclude = lost+found/</h1><br />
<h1 id="transfer-logging--yes">transfer logging = yes</h1><br />
<h1 id="timeout--900">timeout = 900</h1><br />
<h1 id="ignore-nonreadable--yes">ignore nonreadable = yes</h1><br />
<h1 id="dont-compress----gz-tgz-zip-z-z-rpm-deb-bz2">dont compress   = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2</h1><br />
<br />
<h1 id="ftp1">[ftp1]</h1><br />
<h1 id="path--homeftp">path = /home/ftp</h1><br />
<h1 id="comment--ftp-export-area">comment = ftp export area</h1><br />
<p>在上述示例配置文件中，先定义了一些全局选项，然后定义了[ftp1]，这个用中括号包围的”[ftp1]”就是rsync中所谓的模块，ftp1为模块ID，必须保证唯一，每个模块中必须定义一项”path”，path定义的是该模块代表的路径，例如此示例文件中，如果想请求ftp1模块，则在客户端使用”rsync user@host::ftp1”，这表示访问user@host上的/home/ftp目录，如果要访问/home/ftp目录下的子目录www，则”rsync user@host::ftp1/www”。</p><br />
<br />
<p>以下是常见的配置项，也算是一个配置示例：</p><br />
<br />
<p>######### 全局配置参数 ##########<br />
port=888    # 指定rsync端口。默认873<br />
uid = rsync # rsync服务的运行用户，默认是nobody，文件传输成功后属主将是这个uid<br />
gid = rsync # rsync服务的运行组，默认是nobody，文件传输成功后属组将是这个gid<br />
use chroot = no # rsync daemon在传输前是否切换到指定的path目录下，并将其监禁在内<br />
max connections = 200 # 指定最大连接数量，0表示没有限制<br />
timeout = 300         # 确保rsync服务器不会永远等待一个崩溃的客户端，0表示永远等待<br />
motd file = /var/rsyncd/rsync.motd   # 客户端连接过来显示的消息<br />
pid file = /var/run/rsyncd.pid       # 指定rsync daemon的pid文件<br />
lock file = /var/run/rsync.lock      # 指定锁文件<br />
log file = /var/log/rsyncd.log       # 指定rsync的日志文件，而不把日志发送给syslog<br />
dont compress = *.gz *.tgz *.zip *.z *.Z *.rpm *.deb *.bz2  # 指定哪些文件不用进行压缩传输</p><br />
<br />
<p>###########下面指定模块，并设定模块配置参数，可以创建多个模块###########<br />
[longshuai]        # 模块ID<br />
path = /longshuai/ # 指定该模块的路径，该参数必须指定。启动rsync服务前该目录必须存在。rsync请求访问模块本质就是访问该路径。<br />
ignore errors      # 忽略某些IO错误信息<br />
read only = false  # 指定该模块是否可读写，即能否上传文件，false表示可读写，true表示可读不可写。所有模块默认不可上传<br />
write only = false # 指定该模式是否支持下载，设置为true表示客户端不能下载。所有模块默认可下载<br />
list = false       # 客户端请求显示模块列表时，该模块是否显示出来，设置为false则该模块为隐藏模块。默认true<br />
hosts allow = 10.0.0.0/24 # 指定允许连接到该模块的机器，多个ip用空格隔开或者设置区间<br />
hosts deny = 0.0.0.0/32   # 指定不允许连接到该模块的机器<br />
auth users = rsync_backup # 指定连接到该模块的用户列表，只有列表里的用户才能连接到模块，用户名和对应密码保存在secrts file中，<br />
                          # 这里使用的不是系统用户，而是虚拟用户。不设置时，默认所有用户都能连接，但使用的是匿名连接<br />
secrets file = /etc/rsyncd.passwd # 保存auth users用户列表的用户名和密码，每行包含一个username:passwd。由于”strict modes”<br />
                                  # 默认为true，所以此文件要求非rsync daemon用户不可读写。只有启用了auth users该选项才有效。<br />
[xiaofang]    # 以下定义的是第二个模块<br />
path=/xiaofang/<br />
read only = false<br />
ignore errors<br />
comment = anyone can access<br />
注意：</p><br />
<br />
<p>(1).客户端推到服务端时，文件的属主和属组是配置文件中指定的uid和gid。但是客户端从服务端拉的时候，文件的属主和属组是客户端正在操作rsync的用户身份，因为执行rsync程序的用户为当前用户。</p><br />
<br />
<p>(2).auth users和secrets file这两行不是一定需要的，省略它们时将默认使用匿名连接。但是如果使用了它们，则secrets file的权限必须是600。客户端的密码文件也必须是600。</p><br />
<br />
<p>(3).关于secrets file的权限，实际上并非一定是600，只要满足除了运行rsync daemon的用户可读即可。是否检查权限的设定是通过选项strict mode设置的，如果设置为false，则无需关注文件的权限。但默认是yes，即需要设置权限。</p><br />
<br />
<p>配置完后，再就是提供模块相关目录、身份验证文件等。</p><br />
<br />
<p>[root@xuexi ~]# useradd -r -s /sbin/nologin rsync</p><br />
<br />
<p>[root@xuexi ~]# mkdir /{longshuai,xiaofang}</p><br />
<br />
<p>[root@xuexi ~]# chown -R rsync.rsync /{longshuai,xiaofang}<br />
提供模块longshuai身份验证文件，由于rsync daemon是以root身份运行的，所以要求身份验证文件对非root用户不可读写，所以设置为600权限。</p><br />
<br />
<p>[root@xuexi ~]# echo “rsync_backup:123456” » /etc/rsyncd.passwd</p><br />
<br />
<p>[root@xuexi ~]# chmod 600 /etc/rsyncd.passwd <br />
然后启动rsync daemon，启动方式很简单。</p><br />
<br />
<p>[root@xuexi ~]# rsync –daemon<br />
如果是CentOS 7，则自带启动脚本。</p><br />
<br />
<p>[root@xuexi ~]# systemctl start rsyncd<br />
看看该脚本的内容。</p><br />
<br />
<p>[root@xuexi ~]# cat /usr/lib/systemd/system/rsyncd.service<br />
[Unit]<br />
Description=fast remote file copy program daemon<br />
ConditionPathExists=/etc/rsyncd.conf</p><br />
<br />
<p>[Service]<br />
EnvironmentFile=/etc/sysconfig/rsyncd<br />
ExecStart=/usr/bin/rsync –daemon –no-detach “$OPTIONS”</p><br />
<br />
<p>[Install]<br />
WantedBy=multi-user.target<br />
可以看到启动方法也仅仅只是多了一个”–no-detach”，该选项表示rsync不将自己从终端上剥离。</p><br />
<br />
<p>总之，启动好rysnc daemon后，它就监听在指定的端口上，等待客户端的连接。</p><br />
<br />
<p>由于上述示例中的模块longshuai配置了身份验证功能，所以客户端连接时会询问密码。如果不想手动输入密码，则可以使用”–password-file”选项提供密码文件，密码文件中只有第一行才是传递的密码，其余所有的行都会被自动忽略。</p><br />
<br />
<p>例如在客户端上：</p><br />
<br />
<p>[root@xuexi ~]# echo “123456” &gt; /tmp/rsync_passwd<br />
然后使用该”–password-file”连接需要身份验证的longshuai模块。</p><br />
<br />
<p>[root@xuexi ~]# echo “123456” &gt; /tmp/rsync_passwd<br />
如果需要访问模块中的某个文件，则：</p><br />
<br />
<p>[root@xuexi ~]# rsync –list-only –port 888 rsync_backup@172.16.l0.6::longshuai/a/b –password-file=/tmp/rsync_passwd<br />
还可以使用url格式语法：</p><br />
<br />
<p>[root@xuexi ~]# rsync –list-only rsync://rsync_backup@172.16.l0.6:888/longshuai/a/b –password-file=/tmp/rsync_passwd</p><br />
<br />
<p>2.6 远程shell方式连接使用daemon<br />
在前文说了rsync有三种工作方式：本地同步模式、远程shell模式和rsync daemon模式。前两者是使用管道进行通信和传输数据的，后者是通过网络套接字进行通信和传输数据的，且rsync daemon要求在server端必须已经运行好rsync且监听在指定端口上。</p><br />
<br />
<p>但rsync支持第4种工作方式：通过远程shell方式连接rsync daemon。也就是将第二种和第三种方式结合起来。虽然这种方式用的不多，但还是有必要稍微解释下，为你阅读rsync的man文档提供一些帮助。</p><br />
<br />
<p>为了下面称呼的方便，暂且将通过远程shell连接使用daemon的方式成为”远程shell daemon”，当然，官方并没有这样的术语，仅仅只是本人在此为了方便而如此称呼。</p><br />
<br />
<p>远程shell daemon的方式严格地说是”远程shell通信方式+使用rsync daemon的功能”。所以它的通信方式和远程shell是一样的，在客户端发起远程shell连接，在server端fork远程shell进程以启动rsync进程，但这个rsync进程是临时的rsync daemon，它只读取配置文件中client所请求的模块部分，且只读取模块部分中的path和身份认证相关内容，(也就是说不会将全局配置项和其它模块项加载到内存，该模块下的其他配置也不会生效)，当rsync操作完成，该rsync daemon就消逝并从内存中被清理。而且，远程shell daemon启动的临时daemon不会和已经在server端运行的rsync daemon冲突，它们可以并存。由于远程shell连接的最终目标是rsync模块，所以它只能使用rsync daemon语法。</p><br />
<br />
<p>以下是语法格式：为了简洁，没有指定src还是dest，且以ssh这个远程shell为例。</p><br />
<br />
<p>rsync [options] –rsh=ssh auth_user@host::module</p><br />
<br />
<p>rsync [options] –rsh=”ssh -l ssh_user” auth_user@host::module</p><br />
<br />
<p>rsync [options] -e “ssh -l ssh_user” auth_user@host::module</p><br />
<br />
<p>rsync [options] -e “ssh -l ssh_user” rsync://auth_user@host/module</p><br />
<br />
<p>涉及了两个用户ssh_user和auth_user，由于使用的是远程shell通信方式，所以client要和server端建立ssh连接，ssh_user就是ssh连接server的用户。auth_user则是模块中的身份认证用户。如果不指定”ssh_user”，则默认将使用auth_user，但很多时候auth_user都只是一个虚拟用户，这样就建立不了ssh连接导致失败，所以建议明确指定ssh_user和auth_user。</p><br />
<br />
<p>举个例子就能说明上面的一切。以下是server端配置文件/etc/rsyncd.conf中的一个模块配置，稍后将从client端使用远程shell方式请求该模块</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category linux
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>