<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">linux最大进程数、最大打开文件数</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-01-08T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jan 8, 2020</time></p>
					</div>
					 <p>ulimit 是一种 linux 系统的内键功能，它具有一套参数集，用于为由它生成的 shell 进程及其子进程的资源使用设置限制。本文将在后面的章节中详细说明 ulimit 的功能，使用以及它的影响，并以具体的例子来详细地阐述它在限制资源使用方面的影响。</p><br />
<br />
<p>ulimit 的功能和用法</p><br />
<br />
<p>ulimit 功能简述</p><br />
<br />
<p>假设有这样一种情况，当一台 Linux 主机上同时登陆了 10 个人，在系统资源无限制的情况下，这 10 个用户同时打开了 500 个文档，而假设每个文档的大小有 10M，这时系统的内存资源就会受到巨大的挑战。</p><br />
<br />
<p>而实际应用的环境要比这种假设复杂的多，例如在一个嵌入式开发环境中，各方面的资源都是非常紧缺的，对于开启文件描述符的数量，分配堆栈的大小，CPU 时间，虚拟内存大小，等等，都有非常严格的要求。资源的合理限制和分配，不仅仅是保证系统可用性的必要条件，也与系统上软件运行的性能有着密不可分的联系。这时，ulimit 可以起到很大的作用，它是一种简单并且有效的实现资源限制的方式。</p><br />
<br />
<p>ulimit 用于限制 shell 启动进程所占用的资源，支持以下各种类型的限制：所创建的内核文件的大小、进程数据块的大小、Shell 进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell 进程所能使用的最大虚拟内存。同时，它支持硬资源和软资源的限制。</p><br />
<br />
<p>作为临时限制，ulimit 可以作用于通过使用其命令登录的 shell 会话，在会话终止时便结束限制，并不影响于其他 shell 会话。而对于长期的固定限制，ulimit 命令语句又可以被添加到由登录 shell 读取的文件中，作用于特定的 shell 用户。<br />
<!-- more --><br />
在下面的章节中，将详细介绍如何使用 ulimit 做相应的资源限制。</p><br />
<br />
<p>如何使用 ulimit</p><br />
<br />
<p>ulimit 通过一些参数选项来管理不同种类的系统资源。在本节，我们将讲解这些参数的使用。</p><br />
<br />
<p>ulimit 命令的格式为：ulimit [options] [limit]</p><br />
<br />
<p>具体的 options 含义以及简单示例可以参考以下表格。</p><br />
<br />
<p>表 1. ulimit 参数说明</p><br />
<br />
<p>选项 [options]	含义	例子<br />
-H	设置硬资源限制，一旦设置不能增加。	ulimit – Hs 64；限制硬资源，线程栈大小为 64K。<br />
-S	设置软资源限制，设置后可以增加，但是不能超过硬资源设置。	ulimit – Sn 32；限制软资源，32 个文件描述符。<br />
-a	显示当前所有的 limit 信息。	ulimit – a；显示当前所有的 limit 信息。<br />
-c	最大的 core 文件的大小， 以 blocks 为单位。	ulimit – c unlimited； 对生成的 core 文件的大小不进行限制。<br />
-d	进程最大的数据段的大小，以 Kbytes 为单位。	ulimit -d unlimited；对进程的数据段大小不进行限制。<br />
-f	进程可以创建文件的最大值，以 blocks 为单位。	ulimit – f 2048；限制进程可以创建的最大文件大小为 2048 blocks。<br />
-l	最大可加锁内存大小，以 Kbytes 为单位。	ulimit – l 32；限制最大可加锁内存大小为 32 Kbytes。<br />
-m	最大内存大小，以 Kbytes 为单位。	ulimit – m unlimited；对最大内存不进行限制。<br />
-n	可以打开最大文件描述符的数量。	ulimit – n 128；限制最大可以使用 128 个文件描述符。<br />
-p	管道缓冲区的大小，以 Kbytes 为单位。	ulimit – p 512；限制管道缓冲区的大小为 512 Kbytes。<br />
-s	线程栈大小，以 Kbytes 为单位。	ulimit – s 512；限制线程栈的大小为 512 Kbytes。<br />
-t	最大的 CPU 占用时间，以秒为单位。	ulimit – t unlimited；对最大的 CPU 占用时间不进行限制。<br />
-u	用户最大可用的进程数。	ulimit – u 64；限制用户最多可以使用 64 个进程。<br />
-v	进程最大可用的虚拟内存，以 Kbytes 为单位。	ulimit – v 200000；限制最大可用的虚拟内存为 200000 Kbytes。</p><br />
<br />
<p>我们可以通过以下几种方式来使用 ulimit：</p><br />
<br />
<p>在用户的启动脚本中<br />
如果用户使用的是 bash，就可以在用户的目录下的 .bashrc 文件中，加入 ulimit – u 64，来限制用户最多可以使用 64 个进程。此外，可以在与 .bashrc 功能相当的启动脚本中加入 ulimt。</p><br />
<br />
<p>在应用程序的启动脚本中<br />
如果用户要对某个应用程序 myapp 进行限制，可以写一个简单的脚本 startmyapp。</p><br />
<br />
<p>ulimit – s 512 <br />
 myapp</p><br />
<br />
<p>以后只要通过脚本 startmyapp 来启动应用程序，就可以限制应用程序 myapp 的线程栈大小为 512K。</p><br />
<br />
<p>直接在控制台输入<br />
 user@tc511-ui:~&gt;ulimit – p 256</p><br />
<br />
<p>限制管道的缓冲区为 256K。</p><br />
<br />
<p>用户进程的有效范围</p><br />
<br />
<p>ulimit 作为对资源使用限制的一种工作，是有其作用范围的。那么，它限制的对象是单个用户，单个进程，还是整个系统呢？事实上，ulimit 限制的是当前 shell 进程以及其派生的子进程。举例来说，如果用户同时运行了两个 shell 终端进程，只在其中一个环境中执行了 ulimit – s 100，则该 shell 进程里创建文件的大小收到相应的限制，而同时另一个 shell 终端包括其上运行的子程序都不会受其影响：</p><br />
<br />
<p>Shell 进程 1<br />
 ulimit – s 100 <br />
 cat testFile &gt; newFile <br />
 File size limit exceeded</p><br />
<br />
<p>Shell 进程 2<br />
 cat testFile &gt; newFile <br />
 ls – s newFile <br />
 323669 newFile</p><br />
<br />
<p>那么，是否有针对某个具体用户的资源加以限制的方法呢？答案是有的，方法是通过修改系统的 /etc/security/limits 配置文件。该文件不仅能限制指定用户的资源使用，还能限制指定组的资源使用。该文件的每一行都是对限定的一个描述，格式如下：</p><br />
<br />
<domain> <type> <item> <value> <br />
<br />
domain 表示用户或者组的名字，还可以使用 * 作为通配符。Type 可以有两个值，soft 和 hard。Item 则表示需要限定的资源，可以有很多候选值，如 stack，cpu，nofile 等等，分别表示最大的堆栈大小，占用的 cpu 时间，以及打开的文件数。通过添加对应的一行描述，则可以产生相应的限制。例如：<br />
<br />
 * hard noflle 100 <br />
<br />
该行配置语句限定了任意用户所能创建的最大文件数是 100。<br />
<br />
现在已经可以对进程和用户分别做资源限制了，看似已经足够了，其实不然。很多应用需要对整个系统的资源使用做一个总的限制，这时候我们需要修改 /proc 下的配置文件。/proc 目录下包含了很多系统当前状态的参数，例如 /proc/sys/kernel/pid_max，/proc/sys/net/ipv4/ip_local_port_range 等等，从文件的名字大致可以猜出所限制的资源种类。由于该目录下涉及的文件众多，在此不一一介绍。有兴趣的读者可打开其中的相关文件查阅说明。<br />
<br />
 <br />
回页首<br />
<br />
ulimit 管理系统资源的例子<br />
<br />
ulimit 提供了在 shell 进程中限制系统资源的功能。本章列举了一些使用 ulimit 对用户进程进行限制的例子，详述了这些限制行为以及对应的影响，以此来说明 ulimit 如何对系统资源进行限制，从而达到调节系统性能的功能。<br />
<br />
使用 ulimit 限制 shell 的内存使用<br />
<br />
在这一小节里向读者展示如何使用 – d，– m 和 – v 选项来对 shell 所使用的内存进行限制。<br />
<br />
首先我们来看一下不设置 ulimit 限制时调用 ls 命令的情况：<br />
<br />
<br />
图 2. 未设置 ulimit 时 ls 命令使用情况<br />
 <br />
大家可以看到此时的 ls 命令运行正常。下面设置 ulimit：<br />
<br />
 &gt;ulimit -d 1000 -m 1000 -v 1000<br />
<br />
这里再温习一下前面章节里介绍过的这三个选项的含义：<br />
<br />
-d：设置数据段的最大值。单位：KB。<br />
<br />
-m：设置可以使用的常驻内存的最大值。单位：KB。<br />
<br />
-v：设置虚拟内存的最大值。单位：KB。<br />
<br />
通过上面的 ulimit 设置我们已经把当前 shell 所能使用的最大内存限制在 1000KB 以下。接下来我们看看这时运行 ls 命令会得到什么样的结果：<br />
<br />
 haohe@sles10-hehao:~/code/ulimit&gt; ls test -l <br />
 /bin/ls: error while loading shared libraries: libc.so.6: failed to map segment <br />
 from shared object: Cannot allocate memory <br />
<br />
从上面的结果可以看到，此时 ls 运行失败。根据系统给出的错误信息我们可以看出是由于调用 libc 库时内存分配失败而导致的 ls 出错。那么我们来看一下这个 libc 库文件到底有多大：<br />
<br />
<br />
图 3. 查看 libc 文件大小<br />
 <br />
从上面的信息可以看出，这个 libc 库文件的大小是 1.5MB。而我们用 ulimit 所设置的内存使用上限是 1000KB，小于 1.5MB，这也就充分证明了 ulimit 所起到的限制 shell 内存使用的功能。<br />
<br />
使用 ulimit 限制 shell 创建的文件的大小<br />
<br />
接下来向读者展示如何使用 -f 选项来对 shell 所能创建的文件大小进行限制。<br />
<br />
首先我们来看一下，没有设置 ulimit -f 时的情况：<br />
<br />
<br />
图 4. 查看文件<br />
 <br />
现有一个文件 testFile 大小为 323669 bytes，现在使用 cat 命令来创建一个 testFile 的 copy：<br />
<br />
<br />
图 5. 未设置 ulimit 时创建复本<br />
 <br />
从上面的输出可以看出，我们成功的创建了 testFile 的拷贝 newFile。<br />
<br />
下面我们设置 ulimt – f 100：<br />
<br />
 &gt; ulimit -f 100<br />
<br />
-f 选项的含义是：用来设置 shell 可以创建的文件的最大值。单位是 blocks。<br />
<br />
现在我们再来执行一次相同的拷贝命令看看会是什么结果：<br />
<br />
<br />
图 6. 设置 ulimit 时创建复本<br />
 <br />
这次创建 testFile 的拷贝失败了，系统给出的出错信息时文件大小超出了限制。在 Linux 系统下一个 block 的默认大小是 512 bytes。所以上面的 ulimit 的含义就是限制 shell 所能创建的文件最大值为 512 x 100 = 51200 bytes，小于 323669 bytes，所以创建文件失败，符合我们的期望。这个例子说明了如何使用 ulimit 来控制 shell 所能创建的最大文件。<br />
<br />
使用 ulimit 限制程序所能创建的 socket 数量<br />
<br />
考虑一个现实中的实际需求。对于一个 C/S 模型中的 server 程序来说，它会为多个 client 程序请求创建多个 socket 端口给与响应。如果恰好有大量的 client 同时向 server 发出请求，那么此时 server 就会需要创建大量的 socket 连接。但在一个系统当中，往往需要限制单个 server 程序所能使用的最大 socket 数，以供其他的 server 程序所使用。那么我们如何来做到这一点呢？答案是我们可以通过 ulimit 来实现！细心的读者可能会发现，通过前面章节的介绍似乎没有限制 socket 使用的 ulimit 选项。是的，ulimit 并没有哪个选项直接说是用来限制 socket 的数量的。但是，我们有 -n 这个选项，它是用于限制一个进程所能打开的文件描述符的最大值。在 Linux 下一切资源皆文件，普通文件是文件，磁盘打印机是文件，socket 当然也是文件。在 Linux 下创建一个新的 socket 连接，实际上就是创建一个新的文件描述符。如下图所示（查看某个进程当前打开的文件描述符信息）：<br />
<br />
<br />
图 7. 查看进程打开文件描述符<br />
 <br />
因此，我们可以通过使用 ulimit – n 来限制程序所能打开的最大文件描述符数量，从而达到限制 socket 创建的数量。<br />
<br />
使用 ulimit 限制 shell 多线程程序堆栈的大小（增加可用线程数量）<br />
<br />
在最后一个例子中，向大家介绍如何使用 -s（单位 KB）来对线程的堆栈大小进行限制，从而减少整个多线程程序的内存使用，增加可用线程的数量。这个例子取自于一个真实的案例。我们所遇到的问题是系统对我们的多线程程序有如下的限制：<br />
<br />
ulimit -v 200000<br />
<br />
根据本文前面的介绍，这意味着我们的程序最多只能使用不到 200MB 的虚拟内存。由于我们的程序是一个多线程程序，程序在运行时会根据需要创建新的线程，这势必会增加总的内存需求量。一开始我们对堆栈大小的限制是 1024 （本例子中使用 1232 来说明）：<br />
<br />
 # ulimit – s 1232<br />
<br />
当我们的程序启动后，通过 pmap 来查看其内存使用情况，可以看到多个占用 1232KB 的数据段，这些就是程序所创建的线程所使用的堆栈：<br />
<br />
<br />
图 8. 程序线程所使用的堆栈<br />
 <br />
每当一个新的线程被创建时都需要新分配一段大小为 1232KB 的内存空间，而我们总的虚拟内存限制是 200MB，所以如果我们需要创建更多的线程，那么一个可以改进的方法就是减少每个线程的固定堆栈大小，这可以通过 ulimit – s 来实现：<br />
<br />
 # ulimit -s 512 <br />
<br />
我们将堆栈大小设置为 512KB，这时再通过 pmap 查看一下我们的设置是否起作用：<br />
<br />
<br />
图 9. 设置 ulimit 后堆栈大小<br />
 <br />
从上面的信息可以看出，我们已经成功的将线程的堆栈大小改为 512KB 了，这样在总内存使用限制不变的情况下，我们可以通过本小节介绍的方法来增加可以创建的线程数，从而达到改善程序的多线程性能。<br />
<br />
 <br />
回页首<br />
<br />
总结<br />
<br />
综上所述，linux 系统中的 ulimit 指令，对资源限制和系统性能优化提供了一条便捷的途径。从用户的 shell 启动脚本，应用程序启动脚本，以及直接在控制台，都可以通过该指令限制系统资源的使用，包括所创建的内核文件的大小、进程数据块的大小、Shell 进程创建文件的大小、内存锁住的大小、常驻内存集的大小、打开文件描述符的数量、分配堆栈的最大大小、CPU 时间、单个用户的最大线程数、Shell 进程所能使用的最大虚拟内存，等等方面。本文中的示例非常直观的说明了 ulimit 的使用及其产生的效果，显而易见，ulimit 对我们在 Linux 平台的应用和开发工作是非常实用的。<br />
<br />
运行在Linux系统上的Java程序运行了一段时间后出现"Too many open files"的异常情况。<br />
<br />
　　这种情况常见于高并发访问文件系统，多线程网络连接等场景。程序经常访问的文件、socket在Linux中都是文件file，系统需要记录每个当前访问file的name、location、access authority等相关信息，这样的一个实体被称为file entry。“open files table”(图中橙色标识)存储这些file entry，以数组的形式线性管理。文件描述符(file descriptor)作为进程到open files table的指针，也就是open files table的下标索引，将每个进程与它所访问的文件关联起来了。<br />
　　<br />
　　每个进程中都有一个file descriptor table管理当前进程所访问(open or create)的所有文件，文件描述符关联着open files table中文件的file entry。细节不表，对于open files table能容纳多少file entry。Linux系统配置open files table的文件限制，如果超过配置值，就会拒绝其它文件操作的请求，并抛出Too many open files异常。这种限制有系统级和用户级之分。<br />
<br />
　　系统级：<br />
<br />
　　系统级设置对所有用户有效。可通过两种方式查看系统最大文件限制<br />
<br />
　　1 cat /proc/sys/fs/file-max<br />
<br />
　　2 sysctl -a 查看结果中fs.file-max这项的配置数量<br />
<br />
　　如果需要增加配置数量就修改/etc/sysctl.conf文件，配置fs.file-max属性，如果属性不存在就添加。<br />
<br />
　　配置完成后使用sysctl -p来通知系统启用这项配置<br />
<br />
　　用户级：<br />
<br />
　　Linux限制每个登录用户的可连接文件数。可通过 ulimit -n来查看当前有效设置。如果想修改这个值就使用 ulimit -n 命令。<br />
<br />
　　对于文件描述符增加的比例，资料推荐是以2的幂次为参考。如当前文件描述符数量是1024，可增加到2048，如果不够，可设置到4096，依此类推。<br />
<br />
　　在出现Too many open files问题后，首先得找出主要原因。最大的可能是打开的文件或是socket没有正常关闭。为了定位问题是否由Java进程引起，通过Java进程号查看当前进程占用文件描述符情况：<br />
<br />
　　lsof -p $java_pid 每个文件描述符的具体属性<br />
<br />
　　lsof -p $java_pid | wc -l 当前Java进程file descriptor table中FD的总量<br />
<br />
　　分析命令的结果，可判断问题是否由非正常释放资源所引起。<br />
<br />
　　如果我们只是普通用户，只是暂时的修改ulimit -n，可以直接shell命令来修改(ulimit -n 1024000)。但是这个设置时暂时的保留!当我们退出bash后，该值恢复原值。<br />
<br />
　　如果要永久修改ulimit，需要修改/etc/security/limits.conf。<br />
<br />
　　vim /etc/security/limits.conf<br />
<br />
　　# 添加如下的行<br />
<br />
　　* soft nofile 2048<br />
<br />
　　* hard nofile 2048<br />
<br />
　　以下是说明：<br />
<br />
　　* 代表针对所有用户<br />
<br />
　　noproc 是代表最大进程数<br />
<br />
　　nofile 是代表最大文件打开数<br />
<br />
　　添加格式：<br />
<br />
　　[username | @groupname] type resource limit<br />
<br />
　　[username | @groupname]：设置需要被限制的用户名，组名前面加@和用户名区别。也可以用通配符*来做所有用户的限制。<br />
<br />
　　type：有 soft，hard 和 -，soft 指的是当前系统生效的设置值。hard 表明系统中所能设定的最大值。soft 的限制不能比hard 限制高。用 - 就表明同时设置了 soft 和 hard 的值。<br />
<br />
　　resource：<br />
<br />
　　core - 限制内核文件的大小(kb)<br />
<br />
　　date - 最大数据大小(kb)<br />
<br />
　　fsize - 最大文件大小(kb)<br />
<br />
　　memlock - 最大锁定内存地址空间(kb)<br />
<br />
　　nofile - 打开文件的最大数目<br />
<br />
　　rss - 最大持久设置大小(kb)<br />
<br />
　　stack - 最大栈大小(kb)<br />
<br />
　　cpu - 以分钟为单位的最多 CPU 时间<br />
<br />
　　noproc - 进程的最大数目<br />
<br />
　　as - 地址空间限制<br />
<br />
　　maxlogins - 此用户允许登录的最大数目<br />
<br />
　　实例：<br />
<br />
　　username soft nofile 2048<br />
<br />
　　username hard nofile 2048<br />
<br />
　　@groupname soft nofile 2048<br />
<br />
　　@groupname hard nofile 2048<br />
　　<br />
1、查看系统及最大打开文件数<br />
<br />
[root@localhost ~]# cat /proc/sys/fs/file-max<br />
65535<br />
2、查看当前用户最大打开文件数<br />
<br />
# ulimit -Hn //查看硬限制<br />
# ulimit -Sn //查看软限制<br />
二、设置最大打开文件数<br />
1、系统及的设置<br />
<br />
# vi /etc/sysctl.conf<br />
增加：<br />
<br />
fs.file-max = 100000<br />
立即生效：<br />
<br />
# sysctl -p<br />
2、用户级设置<br />
<br />
vi /etc/security/limits.conf<br />
设置如下：<br />
<br />
httpd soft nofile 4096<br />
httpd hard nofile 10240<br />
httpd是用户，可以使用通配符*表示所有用户。<br />
要使 limits.conf 文件配置生效，必须要确保 pam_limits.so 文件被加入到启动文件中。<br />
查看 /etc/pam.d/login 文件中有：<br />
<br />
session required /lib/security/pam_limits.so<br />
也可以在/etc/profile后面加上ulimit -n 10240<br />
使用如下命令立即生效：<br />
<br />
# su - httpd<br />
$ ulimit -Hn 10240<br />
$ ulimit -Sn 4096<br />
<br />
一、查看最大打开文件数<br />
1、查看系统及最大打开文件数<br />
<br />
[root@localhost ~]# cat /proc/sys/fs/file-max<br />
65535<br />
2、查看当前用户最大打开文件数<br />
<br />
# ulimit -Hn //查看硬限制<br />
# ulimit -Sn //查看软限制<br />
二、设置最大打开文件数<br />
1、系统及的设置<br />
<br />
# vi /etc/sysctl.conf<br />
增加：<br />
<br />
fs.file-max = 100000<br />
立即生效：<br />
<br />
# sysctl -p<br />
2、用户级设置<br />
<br />
vi /etc/security/limits.conf<br />
设置如下：<br />
<br />
httpd soft nofile 4096<br />
httpd hard nofile 10240<br />
httpd是用户，可以使用通配符*表示所有用户。<br />
要使 limits.conf 文件配置生效，必须要确保 pam_limits.so 文件被加入到启动文件中。<br />
查看 /etc/pam.d/login 文件中有：<br />
<br />
session required /lib/security/pam_limits.so<br />
也可以在/etc/profile后面加上ulimit -n 10240<br />
使用如下命令立即生效：<br />
<br />
# su - httpd<br />
$ ulimit -Hn 10240<br />
$ ulimit -Sn 4096<br />
<br />
<br />
一个进程，能打开的最大文件个数<br />
################################################################################<br />
打开文件是什么意思?<br />
 <br />
打开文件是为了获得操作这个文件的句柄。句柄是用来标识对象的。<br />
对句柄形象的理解是你把东西存到管理处，拿到一个存储格子的号码。<br />
如果句柄是一个整数(文件句柄就是这样），更容易想到它的实现是一个固定地址的数组。<br />
 <br />
句柄的实现, 也可以是一个指针。<br />
应用程序启动后，组成这个程序的各对象是住留在内存的。如果简单地理解，似乎我们只要获知这个内存的首地址，<br />
那么就可以随时用这个地址访问对象。<br />
但是，系统内存管理器经常在内存中来回移动对象，以此来满足各种应用程序的内存需要。<br />
对象被移动意味着它的地址变化了。如何满足这种要求。<br />
 <br />
为了解决这个问题，操作系统为各应用程序腾出一些内存储地址，用来专门登记各应用对象在内存中的地址变化，<br />
而这个地址(存储单元的位置)本身是不变的。内存管理器在移动对象位置后，把对象新的地址告知这个句柄地址来保存。<br />
这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。<br />
这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。  <br />
 <br />
句柄地址(稳定)→记载着→对象在内存中的地址(不稳定)  <br />
 <br />
程序退出会自动关闭文件句柄吗?<br />
程序退出，分配的内存将全部归还系统， 未关闭的句柄也会归还。<br />
------------------------------------------------------------<br />
可打开的文件个数测试代码<br />
------------------------------------------------------------<br />
[hjj@hjj /home/testapp]$ cat fileopennum.c<br />
#include <stdio.h><br />
#include <fcntl.h><br />
 <br />
int main(int argc, char *argv[])<br />
{<br />
    int i=0;<br />
    int fd;<br />
    char name[256];<br />
    while(1)<br />
    {<br />
        sprintf(name,"name%04d.tst",i);<br />
        fd=open(name, O_WRONLY|O_CREAT,0777);<br />
        if(fd == -1)<br />
        {<br />
            perror("error create file fd:");<br />
            printf("file name:%s\n", name);<br />
            break;<br />
        }<br />
        printf("%s opened,fd:%d\n", name,fd);<br />
        i++;<br />
    }<br />
 <br />
    printf("press a key to continue...\n");<br />
    int c=getchar();<br />
    return 0;<br />
}<br />
[hjj@hjj /home/testapp]$ make<br />
g++ -g   -c -o fileopennum.o fileopennum.c<br />
g++  -o fileopennum fileopennum.o<br />
 <br />
[hjj@hjj /home/testapp]$ ./fileopennum<br />
name0000.tst opened,fd:3<br />
name0001.tst opened,fd:4<br />
name0002.tst opened,fd:5<br />
....<br />
name40953.tst opened,fd:40956<br />
name40954.tst opened,fd:40957<br />
name40955.tst opened,fd:40958<br />
name40956.tst opened,fd:40959<br />
error create file fd:: Too many open files<br />
file name:name40957.tst<br />
press a key to continue...<br />
 <br />
------------------------------------------------------------<br />
lsof 查看打开的文件<br />
------------------------------------------------------------<br />
注意： fd 0,1,2 已经被保留为:stdin,stdout,stderr<br />
下面命令，事件会很漫长...<br />
[hjj@hjj /home/testapp]$ lsof |grep name<br />
fileopenn 19077       hjj    3w      REG              253,2        0    3671931 /home/testapp/name0000.tst<br />
fileopenn 19077       hjj    4w      REG              253,2        0    3673172 /home/testapp/name0001.tst<br />
fileopenn 19077       hjj    5w      REG              253,2        0    3673179 /home/testapp/name0002.tst<br />
fileopenn 19077       hjj    6w      REG              253,2        0    3673183 /home/testapp/name0003.tst<br />
.....<br />
 <br />
下面命令，会很快...<br />
[hjj@hjj /home/testapp]$ lsof -c fileopen<br />
COMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME<br />
fileopenn 19077  hjj  cwd    DIR  253,2  1372160 3671071 /home/testapp<br />
fileopenn 19077  hjj  rtd    DIR  253,0     4096       2 /<br />
fileopenn 19077  hjj  txt    REG  253,2     9172 3671438 /home/testapp/fileopennum<br />
fileopenn 19077  hjj  mem    REG  253,0   156928 1441817 /lib64/ld-2.12.so<br />
fileopenn 19077  hjj  mem    REG  253,0  1926800 1441931 /lib64/libc-2.12.so<br />
fileopenn 19077  hjj  mem    REG  253,0   599384 1442023 /lib64/libm-2.12.so<br />
fileopenn 19077  hjj  mem    REG  253,0    93320 1447971 /lib64/libgcc_s-4.4.7-20120601.so.1<br />
fileopenn 19077  hjj  mem    REG  253,0   989840 3100263 /usr/lib64/libstdc++.so.6.0.13<br />
fileopenn 19077  hjj    0u   CHR  136,0      0t0       3 /dev/pts/0<br />
fileopenn 19077  hjj    1u   CHR  136,0      0t0       3 /dev/pts/0<br />
fileopenn 19077  hjj    2u   CHR  136,0      0t0       3 /dev/pts/0<br />
fileopenn 19077  hjj    3w   REG  253,2        0 3671931 /home/testapp/name0000.tst<br />
fileopenn 19077  hjj    4w   REG  253,2        0 3673172 /home/testapp/name0001.tst<br />
fileopenn 19077  hjj    5w   REG  253,2        0 3673179 /home/testapp/name0002.tst<br />
....<br />
 <br />
下面的命令，针对部分名称最合适，支持通配符。<br />
[hjj@hjj /home/testapp]$ lsof name*<br />
COMMAND     PID USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME<br />
fileopenn 20373  hjj    3w   REG  253,2        0 3671931 name0000.tst<br />
fileopenn 20373  hjj    4w   REG  253,2        0 3673172 name0001.tst<br />
fileopenn 20373  hjj    5w   REG  253,2        0 3673179 name0002.tst<br />
....<br />
 <br />
退出了程序，再用lsof name* 已经没有name...文件句柄了。<br />
 <br />
文件句柄的可打开个数，由一个系统参数控制，open files<br />
[hjj@hjj /home/testapp]$ ulimit -a<br />
core file size          (blocks, -c) 0<br />
data seg size           (kbytes, -d) unlimited<br />
scheduling priority             (-e) 0<br />
file size               (blocks, -f) unlimited<br />
pending signals                 (-i) 14706<br />
max locked memory       (kbytes, -l) 64<br />
max memory size         (kbytes, -m) unlimited<br />
open files                      (-n) 40960<br />
pipe size            (512 bytes, -p) 8<br />
POSIX message queues     (bytes, -q) 819200<br />
real-time priority              (-r) 0<br />
stack size              (kbytes, -s) 10240<br />
cpu time               (seconds, -t) unlimited<br />
max user processes              (-u) 10240<br />
virtual memory          (kbytes, -v) unlimited<br />
file locks                      (-x) unlimited<br />
 <br />
------------------------------------------------------------<br />
永久修改open files 个数限制。<br />
------------------------------------------------------------<br />
[hjj@hjj /home/testapp]$ cat /etc/security/limits.conf  <br />
 <br />
hjj        soft    nofile           40960<br />
hjj        hard    nofile              40960  <br />
# End of file<br />
 <br />
什么是硬限制，硬限制是实际的限制，而软限制，是warnning限制，只会給出warning，<br />
ulimit命令本身就有分软硬设置，加-H就是硬，加-S就是软，没有加上的话，就是两个一起改<br />
默认显示的是软限制.<br />
</fcntl.h></stdio.h></value></item></type></domain><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category linux
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>