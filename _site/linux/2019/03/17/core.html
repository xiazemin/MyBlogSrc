<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">core dump</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-03-17T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Mar 17, 2019</time></p>
					</div>
					 <p>有的程序可以通过编译, 但在运行时会出现Segment fault(段错误). 这通常都是指针错误引起的. 但这不像编译错误一样会提示到文件某一行, 而是没有任何信息, 使得我们的调试变得困难起来.</p><br />
<br />
<p>gdb: 有一种办法是, 我们用gdb的step, 一步一步寻找. 这放在短小的代码中是可行的, 但要让你step一个上万行的代码, 我想你会从此厌恶程序员这个名字, 而把他叫做调试员. 我们还有更好的办法, 这就是core file.</p><br />
<br />
<p>ulimit: 如果想让系统在信号中断造成的错误时产生core文件, 我们需要在shell中按如下设置: #设置core大小为无限 ulimit -c unlimited #设置文件大小为无限 ulimit unlimited 这些需要有root权限, 在ubuntu下每次重新打开中断都需要重新输入上面的第一条命令, 来设置core大小为无限.</p><br />
<br />
<p>用gdb查看core文件: 下面我们可以在发生运行时信号引起的错误时发生core dump了. 发生core dump之后, 用gdb进行查看core文件的内容, 以定位文件中引发core dump的行. gdb [exec file] [core file] 如: gdb ./test test.core 在进入gdb后, 用bt命令查看backtrace以检查发生程序运行到哪里, 来定位core dump的文件-&gt;行.</p><br />
<br />
<ol><br />
  <li>什么是Core：</li><br />
</ol><br />
<br />
<p>Sam之前一直以为Core Dump中Core是 Linux Kernel的意思. 今天才发现在这里，Core是另一种意思：</p><br />
<br />
<p>在使用半导体作为内存的材料前，人类是利用线圈当作内存的材料（发明者为王安），线圈就叫作 core ，用线圈做的内存就叫作 core memory。如今 ，半导体工业澎勃发展，已经没有人用 core memory 了，不过，在许多情况下， 人们还是把记忆体叫作 core 。</p><br />
<br />
<ol><br />
  <li>什么是Core Dump：</li><br />
</ol><br />
<br />
<p>我们在开发（或使用）一个程序时，最怕的就是程序莫明其妙地当掉。虽然系统没事，但我们下次仍可能遇到相同的问题。于是这时操作系统就会把程序当掉 时的内存内容 dump 出来（现在通常是写在一个叫 core 的 file 里面），让 我们或是 debugger 做为参考。这个动作就叫作 core dump。</p><br />
<br />
<ol><br />
  <li>Core Dump时会生成何种文件：</li><br />
</ol><br />
<br />
<p>Core Dump时，会生成诸如 core.进程号 的文件。</p><br />
<br />
<ol><br />
  <li>为何有时程序Down了，却没生成 Core文件。</li><br />
</ol><br />
<br />
<p>Linux下，有一些设置，标明了resources available to the shell and to processes。 可以使用#ulimit -a 来看这些设置。 (ulimit是bash built-in Command)</p><br />
<br />
<p>-a All current limits are reported</p><br />
<br />
<p>-c The maximum size of core files created</p><br />
<br />
<p>-d The maximum size of a process鈥檚 data segment</p><br />
<br />
<p>-e The maximum scheduling priority (“nice”)</p><br />
<br />
<p>-f The maximum size of files written by the shell and its children</p><br />
<br />
<p>-i The maximum number of pending signals</p><br />
<br />
<p>-l The maximum size that m ay be locked into memory</p><br />
<br />
<p>-m The maximum resident set size (has no effect on Linux)</p><br />
<br />
<p>-n The maximum number of open file descriptors (most systems do not allow this value to be set)</p><br />
<br />
<p>-p The pipe size in 512-byte blocks (this may not be set)</p><br />
<br />
<p>-q The maximum number of bytes in POSIX message queues</p><br />
<br />
<p>-r The maximum real-time scheduling priority</p><br />
<br />
<p>-s The maximum stack size</p><br />
<br />
<p>-t The maximum amount of cpu time in seconds</p><br />
<br />
<p>-u The maximum number of processes available to a single user</p><br />
<br />
<p>-v The maximum amount of virtual memory available to the shell</p><br />
<br />
<p>-x The maximum number of file locks</p><br />
<br />
<p>从这里可以看出，如果 -c是显示：core file size (blocks, -c) 如果这个值为0，则无法生成core文件。所以可以使用： <br />
#ulimit -c 1024 或者 #ulimit -c unlimited 来使能 core文件。</p><br />
<br />
<p>如果程序出错时生成Core 文件，则会显示Segmentation fault (core dumped) 。</p><br />
<br />
<ol><br />
  <li><br />
    <p>Core Dump的核心转储文件目录和命名规则: <br />
/proc/sys/kernel /core_uses_pid可以控制产生的core文件的文件名中是否添加pid作为扩展，如果添加则文件内容为1，否则为0</p><br />
  </li><br />
  <li><br />
    <p>如何使用Core文件： <br />
在Linux下，使用： <br />
#gdb -c core.pid program_name <br />
就可以进入gdb模式。 <br />
输入where，就可以指出是在哪一行被Down掉，哪个function内，由谁调用等等。 <br />
(gdb) where <br />
或者输入 bt。 <br />
(gdb) bt</p><br />
  </li><br />
  <li><br />
    <p>如何让一个正常的程序down: <br />
#kill -s SIGSEGV pid</p><br />
  </li><br />
  <li><br />
    <p>察看Core文件输出在何处： <br />
存放Coredump的目录即进程的当前目录，一般就是当初发出命令启动该进程时所在的目录。但如果是通过脚本启动，则脚本可能会修改当前目录，这时进程真正的当前目录就会与当初执行脚本所在目录不同。这时可以查看”/proc/<进程pid>/cwd“符号链接的目标来确定进程真正的当前目录地址。通过系统服务启动的进程也可通过这一方法查看。<br />
<!-- more --><br />
分析coredump的工具</进程pid></p><br />
  </li><br />
</ol><br />
<br />
<p>现在大部分类unix操作系统都提供了分析core文件的工具，比如 GNU Binutils Binary File Descriptor library (BFD),GNU Debugger (gdb），mdb等</p><br />
<br />
<p>coredump的文件格式</p><br />
<br />
<p>类unix操作系统中使用efi格式保存coredump文件。</p><br />
<br />
<p>在solairs下</p><br />
<br />
<p>bash-3.2# file *unix.3 ELF 32-bit LSB executable 80386 Version 1, statically linked, not stripped, no debugging information availableunix.4 ELF 32-bit LSB executable 80386 Version 1, statically linked, not stripped, no debugging information available</p><br />
<br />
<p>造成程序coredump的原因很多，这里根据以往的经验总结一下：</p><br />
<br />
<p>1 内存访问越界<br />
  a) 由于使用错误的下标，导致数组访问越界<br />
  b) 搜索字符串时，依靠字符串结束符来判断字符串是否结束，但是字符串没有正常的使用结束符<br />
  c) 使用strcpy, strcat, sprintf, strcmp, strcasecmp等字符串操作函数，将目标字符串读/写爆。应该使用strncpy, strlcpy, strncat, strlcat, snprintf, strncmp, strncasecmp等函数防止读写越界。</p><br />
<br />
<p>2 多线程程序使用了线程不安全的函数。<br />
应该使用下面这些可重入的函数，尤其注意红色标示出来的函数，它们很容易被用错：<br />
asctime_r(3c) gethostbyname_r(3n) getservbyname_r(3n) ctermid_r(3s) gethostent_r(3n) getservbyport_r(3n) ctime_r(3c) getlogin_r(3c) getservent_r(3n) fgetgrent_r(3c) getnetbyaddr_r(3n) getspent_r(3c) fgetpwent_r(3c) getnetbyname_r(3n) getspnam_r(3c) fgetspent_r(3c) getnetent_r(3n) gmtime_r(3c) gamma_r(3m) getnetgrent_r(3n) lgamma_r(3m) getauclassent_r(3) getprotobyname_r(3n) localtime_r(3c) getauclassnam_r(3) etprotobynumber_r(3n) nis_sperror_r(3n) getauevent_r(3) getprotoent_r(3n) rand_r(3c) getauevnam_r(3) getpwent_r(3c) readdir_r(3c) getauevnum_r(3) getpwnam_r(3c) strtok_r(3c) getgrent_r(3c) getpwuid_r(3c) tmpnam_r(3s) getgrgid_r(3c) getrpcbyname_r(3n) ttyname_r(3c) getgrnam_r(3c) getrpcbynumber_r(3n) gethostbyaddr_r(3n) getrpcent_r(3n)</p><br />
<br />
<p>3 多线程读写的数据未加锁保护。<br />
对于会被多个线程同时访问的全局数据，应该注意加锁保护，否则很容易造成core dump</p><br />
<br />
<p>4 非法指针<br />
  a) 使用空指针<br />
  b) 随意使用指针转换。一个指向一段内存的指针，除非确定这段内存原先就分配为某种结构或类型，或者这种结构或类型的数组，否则不要将它转换为这种结构或类型 的指针，而应该将这段内存拷贝到一个这种结构或类型中，再访问这个结构或类型。这是因为如果这段内存的开始地址不是按照这种结构或类型对齐的，那么访问它 时就很容易因为bus error而core dump.</p><br />
<br />
<p>5 堆栈溢出<br />
不要使用大的局部变量（因为局部变量都分配在栈上），这样容易造成堆栈溢出，破坏系统的栈和堆结构，导致出现莫名其妙的错误。</p><br />
<br />
<p>coredump文件的生成方法以及使用方法：</p><br />
<br />
<p>（假设下例是在x86上交叉编译，而在arm上运行异常的现象）</p><br />
<br />
<p>1． 在arm内核里加入coredump的支持（一般内核都支持coredump,不用重编）</p><br />
<br />
<p>2． 运行命令，此时允许coredump文件产生：(在arm上)<br />
 ulimit –cunlimited</p><br />
<br />
<p>3． 执行程序：（在arm上）<br />
./test<br />
在异常退出时，会显示如下信息，注意括号里的内容<br />
Segmentation fault (core dumped)<br />
程序执行目录下将产生*core文件</p><br />
<br />
<p>4． 用gdb分析：（在x86上）<br />
arm-linux-gdb ./testtest.core<br />
再用gdb的bt或where看就可以了<br />
(arm-linux-gdb的编译见<调试工具之四gdbserve>)</调试工具之四gdbserve></p><br />
<br />
<p>系统支持生成core并设置存储位置的方法：</p><br />
<br />
<p>1&gt; 在/etc/profile中加入以下一行，这将允许生成coredump文件<br />
ulimit -c unlimited</p><br />
<br />
<p>2&gt; 在rc.local中加入以下一行，这将使程序崩溃时生成的coredump文件位于/tmp目录下:<br />
echo /tmp/core.%e.%p &gt; /proc/sys/kernel/core_pattern</p><br />
<br />
<p>/tmp/也可以是其它的目录位置。最佳位置应当满足以下需求：</p><br />
<ul><br />
  <li>对所有用户可写</li><br />
  <li>空间容量足够大</li><br />
  <li>掉电后文件不丢失</li><br />
</ul><br />
<br />
<ol><br />
  <li><br />
    <p>前言:<br />
有的程序可以通过编译, 但在运行时会出现Segment fault(段错误). 这通常都是指针错误引起的.<br />
但这不像编译错误一样会提示到文件-&gt;行, 而是没有任何信息, 使得我们的调试变得困难起来.</p><br />
  </li><br />
  <li><br />
    <p>gdb:<br />
有一种办法是, 我们用gdb的step, 一步一步寻找. <br />
这放在短小的代码中是可行的, 但要让你step一个上万行的代码, 我想你会从此厌恶程序员这个名字, 而把他叫做调试员.<br />
我们还有更好的办法, 这就是core file.</p><br />
  </li><br />
  <li><br />
    <p>ulimit:<br />
如果想让系统在信号中断造成的错误时产生core文件, 我们需要在shell中按如下设置:<br />
#设置core大小为无限<br />
ulimit -c unlimited<br />
#设置文件大小为无限<br />
ulimit unlimited</p><br />
  </li><br />
</ol><br />
<br />
<p>这些需要有root权限, 在ubuntu下每次重新打开中断都需要重新输入上面的第一条命令, 来设置core大小为无限.</p><br />
<br />
<ol><br />
  <li>用gdb查看core文件:<br />
下面我们可以在发生运行时信号引起的错误时发生core dump了.<br />
发生core dump之后, 用gdb进行查看core文件的内容, 以定位文件中引发core dump的行.<br />
gdb [exec file] [core file]<br />
如:<br />
gdb ./test test.core<br />
在进入gdb后, 用bt命令查看backtrace以检查发生程序运行到哪里, 来定位core dump的文件-&gt;行.</li><br />
</ol><br />
<br />
<p>当我们的程序崩溃时，内核有可能把该程序当前内存映射到core文件里，方便程序员找到程序出现问题的地方。最常出现的，几乎所有C程序员都出现过的错误就是“段错误”了。也是最难查出问题原因的一个错误。下面我们就针对“段错误”来分析core文件的产生、以及我们如何利用core文件找到出现崩溃的地方。</p><br />
<br />
<p>何谓core文件</p><br />
<br />
<p>当一个程序崩溃时，在进程当前工作目录的core文件中复制了该进程的存储图像。core文件仅仅是一个内存映象(同时加上调试信息)，主要是用来调试的。</p><br />
<br />
<p>当程序接收到以下UNIX信号会产生core文件：</p><br />
<br />
<p>名字</p><br />
<br />
<p>说明</p><br />
<br />
<p>ANSI C  POSIX.1</p><br />
<br />
<p>SVR4  4.3+BSD</p><br />
<br />
<p>缺省动作</p><br />
<br />
<p>SIGABRT</p><br />
<br />
<p>异常终止(abort)</p><br />
<br />
<p>.       .</p><br />
<br />
<p>.      .</p><br />
<br />
<p>终止w/core</p><br />
<br />
<p>SIGBUS</p><br />
<br />
<p>硬件故障</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      .<br />
</code></pre></div></div><br />
<br />
<p>.      .</p><br />
<br />
<p>终止w/core</p><br />
<br />
<p>SIGEMT</p><br />
<br />
<p>硬件故障</p><br />
<br />
<p>.      .</p><br />
<br />
<p>终止w/core</p><br />
<br />
<p>SIGFPE</p><br />
<br />
<p>算术异常</p><br />
<br />
<p>.       .</p><br />
<br />
<p>.      .</p><br />
<br />
<p>终止w/core</p><br />
<br />
<p>SIGILL</p><br />
<br />
<p>非法硬件指令</p><br />
<br />
<p>.       .</p><br />
<br />
<p>.      .</p><br />
<br />
<p>终止w/core</p><br />
<br />
<p>SIGIOT</p><br />
<br />
<p>硬件故障</p><br />
<br />
<p>.      .</p><br />
<br />
<p>终止w/core</p><br />
<br />
<p>SIGQUIT</p><br />
<br />
<p>终端退出符</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      .<br />
</code></pre></div></div><br />
<br />
<p>.      .</p><br />
<br />
<p>终止w/core</p><br />
<br />
<p>SIGSEGV</p><br />
<br />
<p>无效存储访问</p><br />
<br />
<p>.       .</p><br />
<br />
<p>.      .</p><br />
<br />
<p>终止w/core</p><br />
<br />
<p>SIGSYS</p><br />
<br />
<p>无效系统调用</p><br />
<br />
<p>.      .</p><br />
<br />
<p>终止w/core</p><br />
<br />
<p>SIGTRAP</p><br />
<br />
<p>硬件故障</p><br />
<br />
<p>.      .</p><br />
<br />
<p>终止w/core</p><br />
<br />
<p>SIGXCPU</p><br />
<br />
<p>超过CPU限制(setrlimit)</p><br />
<br />
<p>.      .</p><br />
<br />
<p>终止w/core</p><br />
<br />
<p>SIGXFSZ</p><br />
<br />
<p>超过文件长度限制(setrlimit)</p><br />
<br />
<p>.      .</p><br />
<br />
<p>终止w/core</p><br />
<br />
<p>在系统默认动作列，“终止w/core”表示在进程当前工作目录的core文件中复制了该进程的存储图像（该文件名为core，由此可以看出这种功能很久之前就是UNIX功能的一部分）。大多数UNIX调试程序都使用core文件以检查进程在终止时的状态。</p><br />
<br />
<p>core文件的产生不是POSIX.1所属部分,而是很多UNIX版本的实现特征。UNIX第6版没有检查条件(a)和(b)，并且其源代码中包含如下说明：“如果你正在找寻保护信号，那么当设置-用户-ID命令执行时，将可能产生大量的这种信号”。4.3 + BSD产生名为core.prog的文件，其中prog是被执行的程序名的前1 6个字符。它对core文件给予了某种标识，所以是一种改进特征。</p><br />
<br />
<p>表中“硬件故障”对应于实现定义的硬件故障。这些名字中有很多取自UNIX早先在DP-11上的实现。请查看你所使用的系统的手册，以确切地确定这些信号对应于哪些错误类型。</p><br />
<br />
<p>下面比较详细地说明这些信号。</p><br />
<br />
<p>? SIGABRT 调用abort函数时产生此信号。进程异常终止。</p><br />
<br />
<p>? SIGBUS  指示一个实现定义的硬件故障。</p><br />
<br />
<p>? SIGEMT  指示一个实现定义的硬件故障。</p><br />
<br />
<p>EMT这一名字来自PDP-11的emulator trap 指令。</p><br />
<br />
<p>? SIGFPE  此信号表示一个算术运算异常，例如除以0，浮点溢出等。</p><br />
<br />
<p>? SIGILL  此信号指示进程已执行一条非法硬件指令。</p><br />
<br />
<p>4.3BSD由abort函数产生此信号。SIGABRT现在被用于此。</p><br />
<br />
<p>? SIGIOT  这指示一个实现定义的硬件故障。</p><br />
<br />
<p>IOT这个名字来自于PDP-11对于输入／输出TRAP(input/output TRAP)指令的缩写。系统V的早期版本，由abort函数产生此信号。SIGABRT现在被用于此。</p><br />
<br />
<p>? SIGQUIT 当用户在终端上按退出键（一般采用Ctrl-\）时，产生此信号，并送至前台进</p><br />
<br />
<p>程组中的所有进程。此信号不仅终止前台进程组（如SIGINT所做的那样），同时产生一个core文件。</p><br />
<br />
<p>? SIGSEGV 指示进程进行了一次无效的存储访问。</p><br />
<br />
<p>名字SEGV表示“段违例（segmentation violation）”。</p><br />
<br />
<p>? SIGSYS  指示一个无效的系统调用。由于某种未知原因，进程执行了一条系统调用指令，</p><br />
<br />
<p>但其指示系统调用类型的参数却是无效的。</p><br />
<br />
<p>? SIGTRAP 指示一个实现定义的硬件故障。</p><br />
<br />
<p>此信号名来自于PDP-11的TRAP指令。</p><br />
<br />
<p>? SIGXCPU SVR4和4.3+BSD支持资源限制的概念。如果进程超过了其软C P U时间限制，则产生此信号。</p><br />
<br />
<p>? SIGXFSZ 如果进程超过了其软文件长度限制，则SVR4和4.3+BSD产生此信号。</p><br />
<br />
<p>摘自《UNIX环境高级编程》第10章 信号。</p><br />
<br />
<p>使用core文件调试程序</p><br />
<br />
<p>看下面的例子：</p><br />
<br />
<p>/<em>core_dump_test.c</em>/<br />
 #include <stdio.h><br />
const char *str = "test";<br />
void core_test(){<br />
    str[1] = 'T';<br />
}</stdio.h></p><br />
<br />
<p>int main(){<br />
    core_test();<br />
    return 0;<br />
}</p><br />
<br />
<p>编译：<br />
gcc –g core_dump_test.c -o core_dump_test</p><br />
<br />
<p>如果需要调试程序的话，使用gcc编译时加上-g选项，这样调试core文件的时候比较容易找到错误的地方。</p><br />
<br />
<p>执行：<br />
 ./core_dump_test<br />
段错误</p><br />
<br />
<p>运行core_dump_test程序出现了“段错误”，但没有产生core文件。这是因为系统默认core文件的大小为0，所以没有创建。可以用ulimit命令查看和修改core文件的大小。<br />
ulimit -c 0<br />
ulimit -c 1000<br />
ulimit -c 1000</p><br />
<br />
<p>-c 指定修改core文件的大小，1000指定了core文件大小。也可以对core文件的大小不做限制，如：</p><br />
<br />
<p>ulimit -c unlimited<br />
ulimit -c unlimited</p><br />
<br />
<p>如果想让修改永久生效，则需要修改配置文件，如 .bash_profile、/etc/profile或/etc/security/limits.conf。</p><br />
<br />
<p>再次执行：<br />
./core_dump_test<br />
段错误 (core dumped)<br />
ls core.*<br />
core.6133</p><br />
<br />
<p>可以看到已经创建了一个core.6133的文件.6133是core_dump_test程序运行的进程ID。</p><br />
<br />
<p>调式core文件<br />
core文件是个二进制文件，需要用相应的工具来分析程序崩溃时的内存映像。</p><br />
<br />
<p>file core.6133</p><br />
<br />
<p>core.6133: ELF 32-bit LSB core file Intel 80386, version 1 (SYSV), SVR4-style, from ‘core_dump_test’</p><br />
<br />
<p>在Linux下可以用GDB来调试core文件。</p><br />
<br />
<p>gdb core_dump_test core.6133</p><br />
<br />
<p>GNU gdb Red Hat Linux (5.3post-0.20021129.18rh)<br />
Copyright 2003 Free Software Foundation, Inc.<br />
GDB is free software, covered by the GNU General Public License, and you are<br />
welcome to change it and/or distribute copies of it under certain conditions.<br />
Type “show copying” to see the conditions.<br />
There is absolutely no warranty for GDB.  Type “show warranty” for details.<br />
This GDB was configured as “i386-redhat-linux-gnu”…<br />
Core was generated by `./core_dump_test’.<br />
Program terminated with signal 11, Segmentation fault.<br />
Reading symbols from /lib/tls/libc.so.6…done.<br />
Loaded symbols for /lib/tls/libc.so.6<br />
Reading symbols from /lib/ld-linux.so.2…done.<br />
Loaded symbols for /lib/ld-linux.so.2<br />
#0  0x080482fd in core_test () at core_dump_test.c:7<br />
7           str[1] = ‘T’;<br />
(gdb) where<br />
#0  0x080482fd in core_test () at core_dump_test.c:7<br />
#1  0x08048317 in main () at core_dump_test.c:12<br />
#2  0x42015574 in __libc_start_main () from /lib/tls/libc.so.6</p><br />
<br />
<p>GDB中键入where，就会看到程序崩溃时堆栈信息（当前函数之前的所有已调用函数的列表（包括当前函数），gdb只显示最近几个），我们很容易找到我们的程序在最后崩溃的时候调用了core_dump_test.c 第7行的代码，导致程序崩溃。注意：在编译程序的时候要加入选项-g。您也可以试试其他命令，　如　fram、list等。更详细的用法，请查阅GDB文档。</p><br />
<br />
<p>core文件创建在什么位置</p><br />
<br />
<p>在进程当前工作目录的下创建。通常与程序在相同的路径下。但如果程序中调用了chdir函数，则有可能改变了当前工作目录。这时core文件创建在chdir指定的路径下。有好多程序崩溃了，我们却找不到core文件放在什么位置。和chdir函数就有关系。当然程序崩溃了不一定都产生core文件。</p><br />
<br />
<p>什么时候不产生core文件</p><br />
<br />
<p>在下列条件下不产生core文件：<br />
( a )进程是设置-用户-ID，而且当前用户并非程序文件的所有者；<br />
( b )进程是设置-组-ID，而且当前用户并非该程序文件的组所有者；<br />
( c )用户没有写当前工作目录的许可权；<br />
( d )文件太大。core文件的许可权(假定该文件在此之前并不存在)通常是用户读/写，组读和其他读。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category linux
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>