<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">tcp_retries</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-12-13T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Dec 13, 2019</time></p>
					</div>
					 <p>https://pracucci.com/linux-tcp-rto-min-max-and-tcp-retries2.html<br />
TCP retransmits an unacknowledged packet up to tcp_retries2 sysctl setting times (defaults to 15) using an exponential backoff timeout for which each retransmission timeout is between TCP_RTO_MIN (200 ms) and TCP_RTO_MAX (120 seconds). Once the 15th retry expires (by default), the TCP stack will notify the layers above (ie. app) of a broken connection.</p><br />
<br />
<p>The value of TCP_RTO_MIN and TCP_RTO_MAX is hardcoded in the Linux kernel and defined by the following constants:</p><br />
<br />
<p>#define TCP_RTO_MAX ((unsigned)(120*HZ))<br />
#define TCP_RTO_MIN ((unsigned)(HZ/5))<br />
<!-- more --><br />
http://perthcharles.github.io/2015/09/06/wiki-rtt-estimator/</p><br />
<br />
<p>http://perthcharles.github.io/2015/09/07/wiki-tcp-retries/</p><br />
<br />
<p>Linux中确实定义了两个参数来限定超时重传的次数的，以下是源码中Documentation/networking/ip-sysctl.txt文档中的描述</p><br />
<br />
<p>tcp_retries1 - INTEGER<br />
    This value influences the time, after which TCP decides, that<br />
    something is wrong due to unacknowledged RTO retransmissions,<br />
    and reports this suspicion to the network layer.<br />
    See tcp_retries2 for more details.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RFC 1122 recommends at least 3 retransmissions, which is the<br />
default.<br />
</code></pre></div></div><br />
<br />
<p>tcp_retries2 - INTEGER<br />
    This value influences the timeout of an alive TCP connection,<br />
    when RTO retransmissions remain unacknowledged.<br />
    Given a value of N, a hypothetical TCP connection following<br />
    exponential backoff with an initial RTO of TCP_RTO_MIN would<br />
    retransmit N times before killing the connection at the (N+1)th RTO.</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The default value of 15 yields a hypothetical timeout of 924.6<br />
seconds and is a lower bound for the effective timeout.<br />
TCP will effectively time out at the first RTO which exceeds the<br />
hypothetical timeout.<br />
<br />
RFC 1122 recommends at least 100 seconds for the timeout,<br />
which corresponds to a value of at least 8. 就是这样一段话，可能由于过于概括，会令人产生很多疑问，甚至产生一些误解。 比如常见的问题有： a. 超过tcp_retries1这个阈值后，到底是report了怎样一种suspicion呢？ b. tcp_retries1和tcp_retries2的数字是表示RTO重传的次数上限，对吗？ c. 文档中提到，924.6s is a lower bound for the effective timeout。 这里的effective timeout是指什么？ 为什么是lower bound，tcp_retries2不应该是限制重传次数的upper bound吗？<br />
</code></pre></div></div><br />
<br />
<p>// RTO timer的处理函数是tcp_retransmit_timer()，与tcp_retries1相关的代码调用关系如下<br /><br />
tcp_retransmit_timer()<br />
    =&gt; tcp_write_timeout()  // 判断是否重传了足够的久<br />
        =&gt; retransmit_timed_out(sk, sysctl_tcp_retries1, 0, 0)  // 判断是否超过了阈值</p><br />
<br />
<p>// tcp_write_timeout()的具体相关内容<br /><br />
…<br />
if ((1 « sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) {<br />
    // 如果超时发生在三次握手期间，此时有专门的tcp_syn_retries来负责限定重传次数<br />
    …<br />
} else {    // 如果超时发生在数据发送期间<br />
    // 这个函数负责判断重传是否超过阈值，返回真表示超过。后续会详细分析这个函数<br /><br />
    if (retransmits_timed_out(sk, sysctl_tcp_retries1, 0, 0)) { <br />
        /* Black hole detection */<br />
        tcp_mtu_probing(icsk, sk);  // 如果开启tcp_mtu_probing(默认关闭)了，则执行PMTU</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    dst_negative_advice(sk);    // 更新路由缓存<br />
}<br />
... } 从以上的代码可以看到，一旦重传超过阈值tcp_retries1，主要的动作就是更新路由缓存。 用以避免由于路由选路变化带来的问题。<br />
</code></pre></div></div><br />
<br />
<p>重传超过tcp_retries2会怎样<br />
会直接放弃重传，关闭TCP流</p><br />
<br />
<p>// 依然还是在tcp_write_timeout()中，retry_until一般是tcp_retries2<br />
…<br />
if (retransmits_timed_out(sk, retry_until, syn_set ? 0 : icsk-&gt;icsk_user_timeout, syn_set)) {<br />
    /* Has it gone just too far? */<br />
    tcp_write_err(sk);      // 调用tcp_done关闭TCP流<br />
    return 1;<br />
}<br />
retries限制的重传次数吗<br />
咋一看文档，很容易想到retries的数字就是限定的重传的次数，甚至源码中对于retries常量注释中都写着”This is how many retries it does…”</p><br />
<br />
<p>#define TCP_RETR1       3   /*<br />
                             * This is how many retries it does before it<br />
                             * tries to figure out if the gateway is<br />
                             * down. Minimal RFC value is 3; it corresponds<br />
                             * to ~3sec-8min depending on RTO.<br />
                             */</p><br />
<br />
<p>#define TCP_RETR2       15  /*<br />
                             * This should take at least<br />
                             * 90 minutes to time out.<br />
                             * RFC1122 says that the limit is 100 sec.<br />
                             * 15 is ~13-30min depending on RTO.<br />
                             */<br />
那就就来看看retransmits_timed_out的具体实现，看看到底是不是限制的重传次数</p><br />
<br />
<p>/* This function calculates a “timeout” which is equivalent to the timeout of a</p><br />
<ul><br />
  <li>TCP connection after “boundary” unsuccessful, exponentially backed-off</li><br />
  <li>retransmissions with an initial RTO of TCP_RTO_MIN or TCP_TIMEOUT_INIT if</li><br />
  <li><br />
    <p>syn_set flag is set.<br />
 */<br />
static bool retransmits_timed_out(struct sock *sk,<br />
                           unsigned int boundary,<br />
                           unsigned int timeout,<br />
                           bool syn_set)<br />
{<br />
 unsigned int linear_backoff_thresh, start_ts;<br />
 // 如果是在三次握手阶段，syn_set为真<br />
 unsigned int rto_base = syn_set ? TCP_TIMEOUT_INIT : TCP_RTO_MIN;</p><br />
<br />
    <p>if (!inet_csk(sk)-&gt;icsk_retransmits)<br />
         return false;</p><br />
<br />
    <p>// retrans_stamp记录的是数据包第一次发送的时间，在tcp_retransmit_skb()中设置<br />
 if (unlikely(!tcp_sk(sk)-&gt;retrans_stamp))<br />
         start_ts = TCP_SKB_CB(tcp_write_queue_head(sk))-&gt;when;<br />
 else<br />
         start_ts = tcp_sk(sk)-&gt;retrans_stamp;</p><br />
<br />
    <p>// 如果用户态未指定timeout，则算一个出来<br />
 if (likely(timeout == 0)) {<br />
         /* 下面的计算过程，其实就是算一下如果以rto_base为第一次重传间隔，<br />
          * 重传boundary次需要多长时间<br />
          */<br />
         linear_backoff_thresh = ilog2(TCP_RTO_MAX/rto_base);</p><br />
<br />
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     if (boundary &lt;= linear_backoff_thresh)<br />
             timeout = ((2 &lt;&lt; boundary) - 1) * rto_base;<br />
     else<br />
             timeout = ((2 &lt;&lt; linear_backoff_thresh) - 1) * rto_base +<br />
                     (boundary - linear_backoff_thresh) * TCP_RTO_MAX;  }  // 如果数据包第一次发送的时间距离现在的时间间隔，超过了timeout值，则认为重传超于阈值了  return (tcp_time_stamp - start_ts) &gt;= timeout; } 从以上的代码分析可以看到，真正起到限制重传次数的并不是真正的重传次数。 而是以tcp_retries1或tcp_retries2为boundary，以rto_base(如TCP_RTO_MIN 200ms)为初始RTO，计算得到一个timeout值出来。如果重传间隔超过这个timeout，则认为超过了阈值。 上面这段话太绕了，下面举两个个例子来说明<br />
</code></pre></div>    </div><br />
  </li><br />
</ul><br />
<br />
<p>以判断是否放弃TCP流为例，如果tcp_retries2=15，那么计算得到的timeout=924600ms。</p><br />
<br />
<ol><br />
  <li><br />
    <p>如果RTT比较小，那么RTO初始值就约等于下限200ms<br />
由于timeout总时长是924600ms，表现出来的现象刚好就是重传了15次，超过了timeout值，从而放弃TCP流</p><br />
  </li><br />
  <li><br />
    <p>如果RTT较大，比如RTO初始值计算得到的是1000ms<br />
那么根本不需要重传15次，重传总间隔就会超过924600ms。<br />
比如我测试的一个RTT=400ms的情况，当tcp_retries2=10时，仅重传了3次就放弃了TCP流<br />
另外几个小问题<br />
理解了Linux决定重传次数的真实机制，就不难回答一下几个问题了</p><br />
  </li><br />
</ol><br />
<br />
<blockquote><br />
  <blockquote><br />
    <p>effective timeout指的是什么？<br /><br />
« 就是retransmits_timed_out计算得到的timeout值</p><br />
  </blockquote><br />
</blockquote><br />
<br />
<blockquote><br />
  <blockquote><br />
    <p>924.6s是怎么算出来的？<br />
« 924.6s = (( 2 « 9) -1) * 200ms + (15 - 9) * 120s</p><br />
  </blockquote><br />
</blockquote><br />
<br />
<blockquote><br />
  <blockquote><br />
    <p>为什么924.6s是lower bound？<br />
« 重传总间隔必须大于timeout值，即 (tcp_time_stamp - start_ts) &gt;= timeout</p><br />
  </blockquote><br />
</blockquote><br />
<br />
<blockquote><br />
  <blockquote><br />
    <p>那RTO超时的间隔到底是不是源码注释的”15 is ~13-30min depending on RTO.”呢？<br /><br />
« 显然不是! 虽然924.6s(15min)是一个lower bound，但是它同时也是一个upper bound!<br />
   怎么理解？举例说明<br /><br />
        1. 如果某个RTO值导致，在已经重传了14次后，总重传间隔开销是924s<br />
        那么它还需要重传第15次，即使离924.6s只差0.6s。这就是发挥了lower bound的作用<br />
        2. 如果某个RTO值导致，在重传了10次后，总重传间隔开销是924s<br />
        重传第11次后，第12次超时触发时计算得到的总间隔变为1044s，超过924.6s<br />
        那么此时会放弃第12次重传，这就是924.6s发挥了upper bound的作用<br />
   总的来说，在Linux3.10中，如果tcp_retres2设置为15。总重传超时周期应该在如下范围内<br />
        [924.6s, 1044.6s)<br />
所以综合上述，Linux并不是直接拿tcp_retries1和tcp_retries2来限制重传次数的，而是用计算得到<br />
的一个timeout值来判断是否要放弃重传的。真正的重传次数同时与RTT相关。</p><br />
  </blockquote><br />
</blockquote><br />
<br />
<p>/proc/sys/net目录<br />
　　所有的TCP/IP参数都位于/proc/sys/net目录下（请注意，对/proc/sys/net目录下内容的修改都是临时的，任何修改在系统重启后都会丢失），例如下面这些重要的参数：</p><br />
<br />
<p>参数（路径+文件）</p><br />
<br />
<p>描述</p><br />
<br />
<p>默认值</p><br />
<br />
<p>优化值</p><br />
<br />
<p>/proc/sys/net/core/rmem_default</p><br />
<br />
<p>默认的TCP数据接收窗口大小（字节）。</p><br />
<br />
<p>229376</p><br />
<br />
<p>256960</p><br />
<br />
<p>/proc/sys/net/core/rmem_max</p><br />
<br />
<p>最大的TCP数据接收窗口（字节）。</p><br />
<br />
<p>131071</p><br />
<br />
<p>513920</p><br />
<br />
<p>/proc/sys/net/core/wmem_default</p><br />
<br />
<p>默认的TCP数据发送窗口大小（字节）。</p><br />
<br />
<p>229376</p><br />
<br />
<p>256960</p><br />
<br />
<p>/proc/sys/net/core/wmem_max</p><br />
<br />
<p>最大的TCP数据发送窗口（字节）。</p><br />
<br />
<p>131071</p><br />
<br />
<p>513920</p><br />
<br />
<p>/proc/sys/net/core/netdev_max_backlog</p><br />
<br />
<p>在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。</p><br />
<br />
<p>1000</p><br />
<br />
<p>2000</p><br />
<br />
<p>/proc/sys/net/core/somaxconn</p><br />
<br />
<p>定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数。</p><br />
<br />
<p>128</p><br />
<br />
<p>2048</p><br />
<br />
<p>/proc/sys/net/core/optmem_max</p><br />
<br />
<p>表示每个套接字所允许的最大缓冲区的大小。</p><br />
<br />
<p>20480</p><br />
<br />
<p>81920</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_mem</p><br />
<br />
<p>确 定TCP栈应该如何反映内存使用，每个值的单位都是内存页（通常是4KB）。第一个值是内存使用的下限；第二个值是内存压力模式开始对缓冲区使用应用压力 的上限；第三个值是内存使用的上限。在这个层次上可以将报文丢弃，从而减少对内存的使用。对于较大的BDP可以增大这些值（注意，其单位是内存页而不是字 节）。</p><br />
<br />
<p>94011  125351  188022</p><br />
<br />
<p>131072  262144  524288</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_rmem</p><br />
<br />
<p>为 自动调优定义socket使用的内存。第一个值是为socket接收缓冲区分配的最少字节数；第二个值是默认值（该值会被rmem_default覆 盖），缓冲区在系统负载不重的情况下可以增长到这个值；第三个值是接收缓冲区空间的最大字节数（该值会被rmem_max覆盖）。</p><br />
<br />
<p>4096  87380  4011232</p><br />
<br />
<p>8760  256960  4088000</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_wmem</p><br />
<br />
<p>为 自动调优定义socket使用的内存。第一个值是为socket发送缓冲区分配的最少字节数；第二个值是默认值（该值会被wmem_default覆 盖），缓冲区在系统负载不重的情况下可以增长到这个值；第三个值是发送缓冲区空间的最大字节数（该值会被wmem_max覆盖）。</p><br />
<br />
<p>4096  16384  4011232</p><br />
<br />
<p>8760  256960  4088000</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_keepalive_time</p><br />
<br />
<p>TCP发送keepalive探测消息的间隔时间（秒），用于确认TCP连接是否有效。</p><br />
<br />
<p>7200</p><br />
<br />
<p>1800</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_keepalive_intvl</p><br />
<br />
<p>探测消息未获得响应时，重发该消息的间隔时间（秒）。</p><br />
<br />
<p>75</p><br />
<br />
<p>30</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_keepalive_probes</p><br />
<br />
<p>在认定TCP连接失效之前，最多发送多少个keepalive探测消息。</p><br />
<br />
<p>9</p><br />
<br />
<p>3</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_sack</p><br />
<br />
<p>启用有选择的应答（1表示启用），通过有选择地应答乱序接收到的报文来提高性能，让发送者只发送丢失的报文段，（对于广域网通信来说）这个选项应该启用，但是会增加对CPU的占用。</p><br />
<br />
<p>1</p><br />
<br />
<p>1</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_fack</p><br />
<br />
<p>启用转发应答，可以进行有选择应答（SACK）从而减少拥塞情况的发生，这个选项也应该启用。</p><br />
<br />
<p>1</p><br />
<br />
<p>1</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_timestamps</p><br />
<br />
<p>TCP时间戳（会在TCP包头增加12个字节），以一种比重发超时更精确的方法（参考RFC 1323）来启用对RTT 的计算，为实现更好的性能应该启用这个选项。</p><br />
<br />
<p>1</p><br />
<br />
<p>1</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_window_scaling</p><br />
<br />
<p>启用RFC 1323定义的window scaling，要支持超过64KB的TCP窗口，必须启用该值（1表示启用），TCP窗口最大至1GB，TCP连接双方都启用时才生效。</p><br />
<br />
<p>1</p><br />
<br />
<p>1</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_syncookies</p><br />
<br />
<p>表示是否打开TCP同步标签（syncookie），内核必须打开了CONFIG_SYN_COOKIES项进行编译，同步标签可以防止一个套接字在有过多试图连接到达时引起过载。</p><br />
<br />
<p>1</p><br />
<br />
<p>1</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_tw_reuse</p><br />
<br />
<p>表示是否允许将处于TIME-WAIT状态的socket（TIME-WAIT的端口）用于新的TCP连接 。</p><br />
<br />
<p>0</p><br />
<br />
<p>1</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_tw_recycle</p><br />
<br />
<p>能够更快地回收TIME-WAIT套接字。</p><br />
<br />
<p>0</p><br />
<br />
<p>1</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_fin_timeout</p><br />
<br />
<p>对于本端断开的socket连接，TCP保持在FIN-WAIT-2状态的时间（秒）。对方可能会断开连接或一直不结束连接或不可预料的进程死亡。</p><br />
<br />
<p>60</p><br />
<br />
<p>30</p><br />
<br />
<p>/proc/sys/net/ipv4/ip_local_port_range</p><br />
<br />
<p>表示TCP/UDP协议允许使用的本地端口号</p><br />
<br />
<p>32768  61000</p><br />
<br />
<p>1024  65000</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_max_syn_backlog</p><br />
<br />
<p>对于还未获得对方确认的连接请求，可保存在队列中的最大数目。如果服务器经常出现过载，可以尝试增加这个数字。</p><br />
<br />
<p>2048</p><br />
<br />
<p>2048</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_low_latency</p><br />
<br />
<p>允许TCP/IP栈适应在高吞吐量情况下低延时的情况，这个选项应该禁用。</p><br />
<br />
<p>0</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_westwood</p><br />
<br />
<p>启用发送者端的拥塞控制算法，它可以维护对吞吐量的评估，并试图对带宽的整体利用情况进行优化，对于WAN 通信来说应该启用这个选项。</p><br />
<br />
<p>0</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_bic</p><br />
<br />
<p>为快速长距离网络启用Binary Increase Congestion，这样可以更好地利用以GB速度进行操作的链接，对于WAN通信应该启用这个选项。</p><br />
<br />
<p>1</p><br />
<br />
<p>/etc/sysctl.conf文件</p><br />
<br />
<p>　　/etc /sysctl.conf是一个允许你改变正在运行中的Linux系统的接口。它包含一些TCP/IP堆栈和虚拟内存系统的高级选项，可用来控制 Linux网络配置，由于/proc/sys/net目录内容的临时性，建议把TCPIP参数的修改添加到/etc/sysctl.conf文件, 然后保存文件，使用命令“/sbin/sysctl –p”使之立即生效。具体修改方案参照上文：</p><br />
<br />
<p>net.core.rmem_default = 256960</p><br />
<br />
<p>net.core.rmem_max = 513920</p><br />
<br />
<p>net.core.wmem_default = 256960</p><br />
<br />
<p>net.core.wmem_max = 513920</p><br />
<br />
<p>net.core.netdev_max_backlog = 2000</p><br />
<br />
<p>net.core.somaxconn = 2048</p><br />
<br />
<p>net.core.optmem_max = 81920</p><br />
<br />
<p>net.ipv4.tcp_mem = 131072  262144  524288</p><br />
<br />
<p>net.ipv4.tcp_rmem = 8760  256960  4088000</p><br />
<br />
<p>net.ipv4.tcp_wmem = 8760  256960  4088000</p><br />
<br />
<p>net.ipv4.tcp_keepalive_time = 1800</p><br />
<br />
<p>net.ipv4.tcp_keepalive_intvl = 30</p><br />
<br />
<p>net.ipv4.tcp_keepalive_probes = 3</p><br />
<br />
<p>net.ipv4.tcp_sack = 1</p><br />
<br />
<p>net.ipv4.tcp_fack = 1</p><br />
<br />
<p>net.ipv4.tcp_timestamps = 1</p><br />
<br />
<p>net.ipv4.tcp_window_scaling = 1</p><br />
<br />
<p>net.ipv4.tcp_syncookies = 1</p><br />
<br />
<p>net.ipv4.tcp_tw_reuse = 1</p><br />
<br />
<p>net.ipv4.tcp_tw_recycle = 1</p><br />
<br />
<p>net.ipv4.tcp_fin_timeout = 30</p><br />
<br />
<p>net.ipv4.ip_local_port_range = 1024  65000</p><br />
<br />
<p>net.ipv4.tcp_max_syn_backlog = 2048</p><br />
<br />
<p>Doc2：</p><br />
<br />
<p>可调优的内核变量存在两种主要接口：sysctl命令和/proc文件系统，proc中与进程无关的所有信息都被移植到sysfs中。IPV4协议栈的 sysctl参数主要是sysctl.net.core、sysctl.net.ipv4，对应的/proc文件系统是/proc/sys/net /ipv4和/proc/sys/net/core。只有内核在编译时包含了特定的属性，该参数才会出现在内核中。</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>对于内核参数应该谨慎调节，这些参数通常会影响到系统的整体性能。内核在启动时会根据系统的资源情况来初始化特定的变量，这种初始化的调节一般会满足通常的性能需求。<br />
<br />
应用程序通过socket系统调用和远程主机进行通讯，每一个socket都有一个读写缓冲区。读缓冲区保存了远程主机发送过来的数据，如果缓冲区已满， 则数据会被丢弃，写缓冲期保存了要发送到远程主机的数据，如果写缓冲区已慢，则系统的应用程序在写入数据时会阻塞。可知，缓冲区是有大小的。<br />
</code></pre></div></div><br />
<br />
<p>socket缓冲区默认大小：<br />
/proc/sys/net/core/rmem_default     对应net.core.rmem_default<br />
/proc/sys/net/core/wmem_default     对应net.core.wmem_default<br />
    上面是各种类型socket的默认读写缓冲区大小，然而对于特定类型的socket则可以设置独立的值覆盖默认值大小。例如tcp类型的socket就可以用/proc/sys/net/ipv4/tcp_rmem和tcp_wmem来覆盖。</p><br />
<br />
<p>socket缓冲区最大值：<br />
/proc/sys/net/core/rmem_max        对应net.core.rmem_max<br />
/proc/sys/net/core/wmem_max        对应net.core.wmem_max</p><br />
<br />
<p>/proc/sys/net/core/netdev_max_backlog    对应 net.core.netdev_max_backlog<br />
    该参数定义了当接口收到包的速率大于内核处理包的速率时，设备的输入队列中的最大报文数。</p><br />
<br />
<p>/proc/sys/net/core/somaxconn        对应 net.core.somaxconn<br />
    通过listen系统调用可以指定的最大accept队列backlog，当排队的请求连接大于该值时，后续进来的请求连接会被丢弃。</p><br />
<br />
<p>/proc/sys/net/core/optmem_max          对应 net.core.optmem_max<br />
    每个socket的副缓冲区大小。</p><br />
<br />
<p>TCP/IPV4内核参数：<br />
    在创建socket的时候会指定socke协议和地址类型。TCP socket缓冲区大小是他自己控制而不是由core内核缓冲区控制。<br />
/proc/sys/net/ipv4/tcp_rmem     对应net.ipv4.tcp_rmem<br />
/proc/sys/net/ipv4/tcp_wmem     对应net.ipv4.tcp_wmem<br />
    以上是TCP socket的读写缓冲区的设置，每一项里面都有三个值，第一个值是缓冲区最小值，中间值是缓冲区的默认值，最后一个是缓冲区的最大值，虽然缓冲区的值不受core缓冲区的值的限制，但是缓冲区的最大值仍旧受限于core的最大值。</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_mem<br /><br />
    该内核参数也是包括三个值，用来定义内存管理的范围，第一个值的意思是当page数低于该值时，TCP并不认为他为内存压力，第二个值是进入内存的压力区 域时所达到的页数，第三个值是所有TCP sockets所允许使用的最大page数，超过该值后，会丢弃后续报文。page是以页面为单位的，为系统中socket全局分配的内存容量。</p><br />
<br />
<p>socket的结构如下图：</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_window_scaling      对应net.ipv4.tcp_window_scaling<br />
    管理TCP的窗口缩放特性，因为在tcp头部中声明接收缓冲区的长度为26位，因此窗口不能大于64K，如果大于64K，就要打开窗口缩放。</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_sack    对应net.ipv4.tcp_sack<br />
    管理TCP的选择性应答，允许接收端向发送端传递关于字节流中丢失的序列号，减少了段丢失时需要重传的段数目，当段丢失频繁时，sack是很有益的。</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_dsack   对应net.ipv4.tcp_dsack<br />
    是对sack的改进，能够检测不必要的重传。</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_fack    对应net.ipv4.tcp_fack<br />
    对sack协议加以完善，改进tcp的拥塞控制机制。</p><br />
<br />
<p>TCP的连接管理：<br />
/proc/sys/net/ipv4/tcp_max_syn_backlog    对应net.ipv4.tcp_max_syn_backlog<br />
    每一个连接请求(SYN报文)都需要排队，直至本地服务器接收，该变量就是控制每个端口的 TCP SYN队列长度的。如果连接请求多余该值，则请求会被丢弃。</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_syn_retries    对应net.ipv4.tcp_syn_retries<br />
    控制内核向某个输入的SYN/ACK段重新发送相应的次数，低值可以更好的检测到远程主机的连接失败。可以修改为3</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_retries1    对应net.ipv4.tcp_retries1<br />
    该变量设置放弃回应一个tcp连接请求前，需要进行多少次重试。</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_retries2    对应net.ipv4.tcp_retries2<br />
    控制内核向已经建立连接的远程主机重新发送数据的次数，低值可以更早的检测到与远程主机失效的连接，因此服务器可以更快的释放该连接，可以修改为5</p><br />
<br />
<p>TCP连接的保持：<br />
/proc/sys/net/ipv4/tcp_keepalive_time        对应net.ipv4.tcp_keepalive_time<br />
    如果在该参数指定的秒数内连接始终处于空闲状态，则内核向客户端发起对该主机的探测</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_keepalive_intvl    对应net.ipv4.tcp_keepalive_intvl<br />
    该参数以秒为单位，规定内核向远程主机发送探测指针的时间间隔</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_keepalive_probes   对应net.ipv4.tcp_keepalive_probes<br />
    该参数规定内核为了检测远程主机的存活而发送的探测指针的数量，如果探测指针的数量已经使用完毕仍旧没有得到客户端的响应，即断定客户端不可达，关闭与该客户端的连接，释放相关资源。</p><br />
<br />
<p>/proc/sys/net/ipv4/ip_local_port_range   对应net.ipv4.ip_local_port_range<br />
    规定了tcp/udp可用的本地端口的范围。</p><br />
<br />
<p>TCP连接的回收：<br />
/proc/sys/net/ipv4/tcp_max_tw_buckets     对应net.ipv4.tcp_max_tw_buckets<br />
   该参数设置系统的TIME_WAIT的数量，如果超过默认值则会被立即清除。</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_tw_reuse           对应net.ipv4.tcp_tw_reuse<br />
   该参数设置TIME_WAIT重用，可以让处于TIME_WAIT的连接用于新的tcp连接</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_tw_recycle         对应net.ipv4.tcp_tw_recycle<br />
   该参数设置tcp连接中TIME_WAIT的快速回收。</p><br />
<br />
<p>/proc/sys/net/ipv4/tcp_fin_timeout       对应net.ipv4.tcp_fin_timeout<br />
   设置TIME_WAIT2进入CLOSED的等待时间。</p><br />
<br />
<p>/proc/sys/net/ipv4/route/max_size<br />
   内核所允许的最大路由数目。</p><br />
<br />
<p>/proc/sys/net/ipv4/ip_forward<br />
   接口间转发报文</p><br />
<br />
<p>/proc/sys/net/ipv4/ip_default_ttl<br />
   报文可以经过的最大跳数</p><br />
<br />
<p>虚拟内存参数：<br />
/proc/sys/vm/</p><br />
<br />
<p>在linux kernel 2.6.25之前通过ulimit -n(setrlimit(RLIMIT_NOFILE))设置每个进程的最大打开文件句柄数不能超过NR_OPEN(1024*1024),也就是 100多w(除非重新编译内核)，而在25之后，内核导出了一个sys接口可以修改这个最大值/proc/sys/fs/nr_open。shell里不 能直接更改，是因为登录的时候pam已经从limits.conf中设置了上限，ulimit命令只能在低于上限的范围内发挥了。</p><br />
<br />
<p>Linux中查看socket状态：<br />
cat /proc/net/sockstat #（这个是ipv4的）</p><br />
<br />
<p>sockets: used 137<br />
TCP: inuse 49 orphan 0 tw 3272 alloc 52 mem 46<br />
UDP: inuse 1 mem 0<br />
RAW: inuse 0<br />
FRAG: inuse 0 memory 0<br />
说明：<br />
sockets: used：已使用的所有协议套接字总量<br />
TCP: inuse：正在使用（正在侦听）的TCP套接字数量。其值≤ netstat –lnt | grep ^tcp | wc –l<br />
TCP: orphan：无主（不属于任何进程）的TCP连接数（无用、待销毁的TCP socket数）<br />
TCP: tw：等待关闭的TCP连接数。其值等于netstat –ant | grep TIME_WAIT | wc –l<br />
TCP：alloc(allocated)：已分配（已建立、已申请到sk_buff）的TCP套接字数量。其值等于netstat –ant | grep ^tcp | wc –l<br />
TCP：mem：套接字缓冲区使用量（单位不详。用scp实测，速度在4803.9kB/s时：其值=11，netstat –ant 中相应的22端口的Recv-Q＝0，Send-Q≈400）<br />
UDP：inuse：正在使用的UDP套接字数量<br />
RAW：<br />
FRAG：使用的IP段数量</p><br />
<br />
<p>https://stackoverflow.com/questions/5907527/application-control-of-tcp-retransmission-on-linux</p><br />
<br />
<p>https://access.redhat.com/solutions/726753</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category linux
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>