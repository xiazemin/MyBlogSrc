<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">Socket 源码</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-06-10T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jun 10, 2019</time></p>
					</div>
					 <p>Kernel提供了一组内核态的socket API，基本上在用户态的sockt API在内核中都有对应的API。 在net/socket.c中可以看到如下导出符号：</p><br />
<br />
<p>EXPORT_SYMBOL(kernel_sendmsg);<br /><br />
EXPORT_SYMBOL(kernel_recvmsg);<br /><br />
EXPORT_SYMBOL(sock_create_kern);<br /><br />
EXPORT_SYMBOL(sock_release);<br /><br />
EXPORT_SYMBOL(kernel_bind);<br /><br />
EXPORT_SYMBOL(kernel_listen);<br /><br />
EXPORT_SYMBOL(kernel_accept);<br /><br />
EXPORT_SYMBOL(kernel_connect);<br /><br />
EXPORT_SYMBOL(kernel_getsockname);<br /><br />
EXPORT_SYMBOL(kernel_getpeername);<br /><br />
EXPORT_SYMBOL(kernel_getsockopt);<br /><br />
EXPORT_SYMBOL(kernel_setsockopt);<br /><br />
EXPORT_SYMBOL(kernel_sendpage);<br /><br />
EXPORT_SYMBOL(kernel_sock_ioctl);<br /><br />
EXPORT_SYMBOL(kernel_sock_shutdown);<br />
<!-- more --><br />
struct socket<br />
{<br />
     socket_state  state; // socket state</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> short   type ; // socket type<br />
 <br />
 unsigned long  flags; // socket flags<br />
 <br />
 struct fasync_struct  *fasync_list;<br />
 <br />
 wait_queue_head_t wait;<br />
 <br />
 struct file *file;<br />
 <br />
 struct sock *sock;  // socket在网络层的表示；<br />
 <br />
 const struct proto_ops *ops;<br />
</code></pre></div></div><br />
<br />
<p>}</p><br />
<br />
<p>struct socket结构体的类型<br />
enum sock_type<br />
{<br />
   SOCK_STREAM = 1, // 用于与TCP层中的tcp协议数据的struct socket</p><br />
<br />
<p>SOCK_DGRAM  = 2, //用于与TCP层中的udp协议数据的struct socket</p><br />
<br />
<p>SOCK_RAW    = 3, // raw struct socket</p><br />
<br />
<p>SOCK_RDM    = 4, //可靠传输消息的struct socket</p><br />
<br />
<p>SOCK_SEQPACKET = 5,// sequential packet socket</p><br />
<br />
<p>SOCK_DCCP   = 6,</p><br />
<br />
<p>SOCK_PACKET = 10, //从dev level中获取数据包的socket<br />
};</p><br />
<br />
<p>struct socket 中的flags字段取值：<br />
  #define SOCK_ASYNC_NOSPACE  0<br />
  #define SOCK_ASYNC_WAITDATA 1<br />
  #define SOCK_NOSPACE        2<br />
  #define SOCK_PASSCRED       3<br />
  #define SOCK_PASSSEC        4</p><br />
<br />
<p>源码剖析：</p><br />
<br />
<p>为方便大家理清思路，先介绍几个中间函数。建议：像这些大型软件项目，函数内通常还会调用一些公用的基础类的工具函数，我们在阅读源码时，应该先弄清楚这些函数，这样当阅读对应函数时，能很好地把握该函数的内部细节。</p><br />
<br />
<p>/<em>下面两个函数实现地址用户空间和内核空间地址之间的相互移动</em>/<br />
//从uaddr拷贝ulen大小的数据到kaddr<br />
static int move_addr_to_kernel(void *uaddr, int ulen, void *kaddr)<br />
{<br />
	int err;<br />
	if(ulen&lt;0||ulen&gt;MAX_SOCK_ADDR)<br />
		return -EINVAL;<br />
	if(ulen==0)<br />
		return 0;<br />
	//检查用户空间的指针所指的指定大小存储块是否可读<br />
	if((err=verify_area(VERIFY_READ,uaddr,ulen))&lt;0)<br />
		return err;<br />
	memcpy_fromfs(kaddr,uaddr,ulen);//实质是memcpy函数<br />
	return 0;<br />
}<br />
//注意的是，从内核拷贝数据到用户空间是值-结果参数<br />
//ulen这个指向某个整数变量的指针，当函数被调用的时候，它告诉内核需要拷贝多少<br />
//函数返回时，该参数作为一个结果，告诉进程，内核实际拷贝了多少信息<br />
static int move_addr_to_user(void *kaddr, int klen, void *uaddr, int *ulen)<br />
{<br />
	int err;<br />
	int len;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//判断ulen指向的存储块是否可写，就是判断ulen是否可作为左值	<br />
if((err=verify_area(VERIFY_WRITE,ulen,sizeof(*ulen)))&lt;0)<br />
	return err;<br />
len=get_fs_long(ulen);//len = *ulen，ulen作为值传入，告诉要拷贝多少数据<br />
if(len&gt;klen)<br />
	len=klen;//供不应求，按供的算。实际拷贝的数据<br />
if(len&lt;0 || len&gt; MAX_SOCK_ADDR)<br />
	return -EINVAL;<br />
if(len)<br />
{<br />
//判断uaddr用户空间所指的存储块是否可写<br />
	if((err=verify_area(VERIFY_WRITE,uaddr,len))&lt;0)<br />
		return err;<br />
	memcpy_tofs(uaddr,kaddr,len);//实质是调用memcpy<br />
}<br />
 	put_fs_long(len,ulen);//*ulen = len，作为结果返回，即实际拷贝了多少数据<br />
 	return 0; } 下面这个函数一看就知道什么意思 static inline unsigned long get_user_long(const int *addr) {<br />
return *addr; }<br />
</code></pre></div></div><br />
<br />
<p>#define get_fs_long(addr) get_user_long((int *)(addr))</p><br />
<br />
<p>为套接字分配文件描述符，套接字其实同普通的文件描述符差不多，分配文件描述符的同时需要一个file结构，file结构中f_inode字段指向inode(这里的形参)<br />
/*</p><br />
<ul><br />
  <li>为网络套接字分配一个文件描述符 <br />
 */</li><br />
</ul><br />
<br />
<p>static int get_fd(struct inode *inode)<br />
{<br />
	int fd;<br />
	struct file *file;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*<br />
 *	Find a file descriptor suitable for return to the user. <br />
 */<br />
 <br />
file = get_empty_filp();//分配文件对象，文件描述符对应实体，file结构体指示一个打开的文件，filp:file pointer<br />
if (!file) <br />
	return(-1);<br />
//找到可用的文件描述符<br />
for (fd = 0; fd &lt; NR_OPEN; ++fd)<br />
	if (!current-&gt;files-&gt;fd[fd]) <br />
		break;<br />
//没有空闲可用的文件描述符，则退出<br />
if (fd == NR_OPEN) <br />
{<br />
	file-&gt;f_count = 0;<br />
	return(-1);<br />
}<br />
//在文件描述符集合中删除一个新的文件描述符<br />
FD_CLR(fd, ¤t-&gt;files-&gt;close_on_exec);<br />
	current-&gt;files-&gt;fd[fd] = file;//赋值，挂钩<br />
file-&gt;f_op = &amp;socket_file_ops;//指定操作函数集，实现了网络操作的普通文件接口<br />
file-&gt;f_mode = 3;//权限<br />
file-&gt;f_flags = O_RDWR;//标志，可读可写<br />
file-&gt;f_count = 1;//引用计数<br />
file-&gt;f_inode = inode;//与文件inode建立联系,inode为对文件的索引<br />
if (inode) <br />
	inode-&gt;i_count++;//inode的引用计数也要增1<br />
file-&gt;f_pos = 0;//偏移值<br />
return(fd); }<br />
</code></pre></div></div><br />
<br />
<p>每个文件描述符都与对应的inode结构关联，通过文件描述符可以找到file结构，通过file结构可以找到inode，而socket结构又是作为inode结构中的一个变量，反过来，inode也是作为socket结构的一个变量，分配套接字时，两者之间需要建立关联，见sock_alloc()。<br />
/*</p><br />
<ul><br />
  <li>通过inode结构查找对应的socket结构<br />
 */<br />
inline struct socket *socki_lookup(struct inode *inode)<br />
{<br />
return &amp;inode-&gt;u.socket_i;//socket结构是作为inode结构中的一个变量<br />
}</li><br />
</ul><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>给定文件描述符返回socket结构以及file结构指针<br />
 */</li><br />
</ul><br />
<br />
<p>static inline struct socket *sockfd_lookup(int fd, struct file **pfile)<br />
{<br />
	struct file *file;<br />
	struct inode *inode;<br />
	//有效性检查，并从文件描述符中得到对应的file结构<br />
	if (fd &lt; 0 || fd &gt;= NR_OPEN || !(file = current-&gt;files-&gt;fd[fd])) <br />
		return NULL;<br />
	//得到对应inode结构<br />
	inode = file-&gt;f_inode;<br />
	if (!inode || !inode-&gt;i_sock)<br />
		return NULL;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (pfile) <br />
	*pfile = file;//参数返回file结构指针<br />
//返回inode对应的socket结构<br />
return socki_lookup(inode); }  下面开始socket结构的处理了 分配一个socket结构<br />
</code></pre></div></div><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>分配一个socket结构<br />
 */</li><br />
</ul><br />
<br />
<p>struct socket *sock_alloc(void)<br />
{<br />
	struct inode * inode;<br />
	struct socket * sock;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inode = get_empty_inode();//分配一个inode对象<br />
if (!inode)<br />
	return NULL;<br />
//获得的inode结构的初始化<br />
inode-&gt;i_mode = S_IFSOCK;<br />
inode-&gt;i_sock = 1;<br />
inode-&gt;i_uid = current-&gt;uid;<br />
inode-&gt;i_gid = current-&gt;gid;<br />
 <br />
sock = &amp;inode-&gt;u.socket_i;<br />
sock-&gt;state = SS_UNCONNECTED;<br />
sock-&gt;flags = 0;<br />
sock-&gt;ops = NULL;<br />
sock-&gt;data = NULL;<br />
sock-&gt;conn = NULL;<br />
sock-&gt;iconn = NULL;<br />
sock-&gt;next = NULL;<br />
sock-&gt;wait = &amp;inode-&gt;i_wait;<br />
sock-&gt;inode = inode;//回绑<br />
sock-&gt;fasync_list = NULL;<br />
sockets_in_use++;//系统当前使用的套接字数量加1<br />
return sock; }<br />
</code></pre></div></div><br />
<br />
<p>释放（关闭）套接字<br />
/*</p><br />
<ul><br />
  <li>Release a socket.<br />
 */<br />
//释放对端的套接字<br />
static inline void sock_release_peer(struct socket *peer)<br />
{<br />
peer-&gt;state = SS_DISCONNECTING;//状态切换到正在处理关闭连接<br />
wake_up_interruptible(peer-&gt;wait);//唤醒指定的注册在等待队列上的进程<br />
sock_wake_async(peer, 1);//异步唤醒，涉及到套接字状态的改变，需要通知相应进程进行某种处理<br />
}</li><br />
</ul><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>释放(关闭)一个套接字<br />
 */</li><br />
</ul><br />
<br />
<p>void sock_release(struct socket *sock)<br />
{<br />
	int oldstate;<br />
	struct socket *peersock, *nextsock;</p><br />
<br />
<p>//只要套接字不是出于未连接状态，就将其置为正在处理关闭连接状态<br />
	if ((oldstate = sock-&gt;state) != SS_UNCONNECTED)<br />
		sock-&gt;state = SS_DISCONNECTING;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*<br />
 *	Wake up anyone waiting for connections. <br />
 */ //iconn只用于服务器端，表示等待连接但尚未完成连接的客户端socket结构链表<br />
for (peersock = sock-&gt;iconn; peersock; peersock = nextsock) <br />
{<br />
	nextsock = peersock-&gt;next;<br />
	sock_release_peer(peersock);<br />
}<br />
 <br />
/*<br />
 * Wake up anyone we're connected to. First, we release the<br />
 * protocol, to give it a chance to flush data, etc.<br />
 */<br />
//如果该套接字已连接，peersock指向其连接的服务器端套接字<br />
peersock = (oldstate == SS_CONNECTED) ? sock-&gt;conn : NULL;<br />
//转调用release函数<br />
if (sock-&gt;ops) <br />
	sock-&gt;ops-&gt;release(sock, peersock);<br />
//释放对端套接字<br />
if (peersock)<br />
	sock_release_peer(peersock);<br />
--sockets_in_use;	/* 数量减1 */<br />
iput(SOCK_INODE(sock)); } socket 结构 /*  * Internal representation of a socket. not all the fields are used by  * all configurations:  *  *		server			client  * conn		client connected to	server connected to  * iconn	list of clients		-unused-  *		 awaiting connections  * wait		sleep for clients,	sleep for connection,  *		sleep for i/o		sleep for i/o  */  //该结构表示一个网络套接字 struct socket {   short			type;		/* 套接字所用的流类型*/   socket_state		state;//套接字所处状态   long			flags;//标识字段，目前尚无明确作用   struct proto_ops	*ops;		/* 操作函数集指针	*/<br />
/* data保存指向‘私有'数据结构指针，在不同的域指向不同的数据结构		*/   //在INET域，指向sock结构，UNIX域指向unix_proto_data结构   void			*data;	   //下面两个字段只用于UNIX域   struct socket		*conn;		/* 指向客户端连接的服务器端套接字	*/   struct socket		*iconn;		/* 指向正等待连接的客户端	*/   struct socket		*next;//链表   struct wait_queue	**wait;		/* 等待队列	*/   struct inode		*inode;//inode结构指针   struct fasync_struct  *fasync_list;	/* 异步唤醒链表结构	*/ };<br />
</code></pre></div></div><br />
<br />
<p>创建套接字socket，socket<br />
/*</p><br />
<ul><br />
  <li>系统调用，创建套接字socket。涉及到socket结构的创建.<br />
 */</li><br />
</ul><br />
<br />
<p>static int sock_socket(int family, int type, int protocol)<br />
{<br />
	int i, fd;<br />
	struct socket *sock;<br />
	struct proto_ops *ops;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* 匹配应用程序调用socket()函数时指定的协议 */<br />
for (i = 0; i &lt; NPROTO; ++i) <br />
{<br />
	if (pops[i] == NULL) continue;<br />
	if (pops[i]-&gt;family == family) <br />
		break;<br />
}<br />
//没有匹配的协议，则出错退出<br />
if (i == NPROTO) <br />
{<br />
  		return -EINVAL;<br />
}<br />
 <br />
ops = pops[i];<br />
</code></pre></div></div><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Check that this is a type that we know how to manipulate and</li><br />
  <li>the protocol makes sense here. The family can still reject the</li><br />
  <li>protocol later.<br />
 */<br />
  //套接字类型检查<br />
if ((type != SOCK_STREAM &amp;&amp; type != SOCK_DGRAM &amp;&amp;<br />
    type != SOCK_SEQPACKET &amp;&amp; type != SOCK_RAW &amp;&amp;<br />
    type != SOCK_PACKET) || protocol &lt; 0)<br />
        return(-EINVAL);</li><br />
</ul><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Allocate the socket and allow the family to set things up. if</li><br />
  <li>the protocol is 0, the family is instructed to select an appropriate</li><br />
  <li><br />
    <p>default.<br />
 <em>/<br />
//分配套接字结构<br />
if (!(sock = sock_alloc())) <br />
{<br />
    printk(“NET: sock_socket: no more sockets\n”);<br />
    return(-ENOSR);	/</em> Was: EAGAIN, but we are out of<br />
               system resources! */<br />
}<br />
//指定对应类型，协议，以及操作函数集<br />
sock-&gt;type = type;<br />
sock-&gt;ops = ops;<br />
//分配下层sock结构，sock结构是比socket结构更底层的表示一个套接字的结构<br />
//前面博文有说明:http://blog.csdn.net/wenqian1991/article/details/21740945<br />
//socket是通用的套接字结构体，而sock与具体使用的协议相关<br />
if ((i = sock-&gt;ops-&gt;create(sock, protocol)) &lt; 0) <br />
{<br />
    sock_release(sock);<br />
    return(i);<br />
}<br />
//分配一个文件描述符并在后面返回给应用层序作为以后的操作句柄<br />
if ((fd = get_fd(SOCK_INODE(sock))) &lt; 0) <br />
{<br />
    sock_release(sock);<br />
    return(-EINVAL);<br />
}</p><br />
<br />
    <p>return(fd);<br />
}</p><br />
  </li><br />
</ul><br />
<br />
<p>给socket绑定一个端口，bind<br />
/*</p><br />
<ul><br />
  <li>Bind a name to a socket. Nothing much to do here since it’s</li><br />
  <li>the protocol’s responsibility to handle the local address.<br />
 *</li><br />
  <li>We move the socket address to kernel space before we call</li><br />
  <li>the protocol layer (having also checked the address is ok).<br />
 */<br />
 //建议对于理解这类系统调用函数，先看看应用层的对应函数，如bind，listen等<br />
 //bind函数对应的BSD层函数，用于绑定一个本地地址，服务器端<br />
 //umyaddr表示需要绑定的地址结构，addrlen表示改地址结构的长度<br />
static int sock_bind(int fd, struct sockaddr *umyaddr, int addrlen)<br />
{<br />
struct socket *sock;<br />
int i;<br />
char address[MAX_SOCK_ADDR];<br />
int err;<br />
//套接字参数有效性检查<br />
if (fd &lt; 0 || fd &gt;= NR_OPEN || current-&gt;files-&gt;fd[fd] == NULL)<br />
    return(-EBADF);<br />
//获取fd对应的socket结构<br />
if (!(sock = sockfd_lookup(fd, NULL))) <br />
    return(-ENOTSOCK);<br />
//将地址从用户缓冲区复制到内核缓冲区<br />
if((err=move_addr_to_kernel(umyaddr,addrlen,address))&lt;0)<br />
  	return err;<br />
//转调用bind指向的函数<br />
if ((i = sock-&gt;ops-&gt;bind(sock, (struct sockaddr *)address, addrlen)) &lt; 0) <br />
{<br />
    return(i);<br />
}<br />
return(0);<br />
}</li><br />
</ul><br />
<br />
<p>监听客户端请求，listen<br />
/*</p><br />
<ul><br />
  <li>Perform a listen. Basically, we allow the protocol to do anything</li><br />
  <li>necessary for a listen, and if that works, we mark the socket as</li><br />
  <li>ready for listening.<br />
 */<br />
//服务器端监听客户端的连接请求<br />
//fd表示bind后的套接字，backlog表示排队的最大连接个数<br />
//listen函数把一个未连接的套接字转换为一个被动套接字，<br />
//指示内核应接受该套接字的连接请求</li><br />
</ul><br />
<br />
<p>static int sock_listen(int fd, int backlog)<br />
{<br />
	struct socket *sock;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (fd &lt; 0 || fd &gt;= NR_OPEN || current-&gt;files-&gt;fd[fd] == NULL)<br />
	return(-EBADF);<br />
if (!(sock = sockfd_lookup(fd, NULL))) <br />
	return(-ENOTSOCK);<br />
//前提是没有建立连接<br />
if (sock-&gt;state != SS_UNCONNECTED) <br />
{<br />
	return(-EINVAL);<br />
}<br />
//调用底层实现函数<br />
if (sock-&gt;ops &amp;&amp; sock-&gt;ops-&gt;listen)<br />
	sock-&gt;ops-&gt;listen(sock, backlog);<br />
sock-&gt;flags |= SO_ACCEPTCON;//设置标识字段<br />
return(0); }<br />
</code></pre></div></div><br />
<br />
<p>服务器接收请求，accept<br />
/*</p><br />
<ul><br />
  <li>For accept, we attempt to create a new socket, set up the link</li><br />
  <li>with the client, wake up the client, then return the new</li><br />
  <li>connected fd. We collect the address of the connector in kernel</li><br />
  <li>space and move it to user at the very end. This is buggy because</li><br />
  <li><br />
    <p>we open the socket then return an error.<br />
 */<br />
//用于服务器接收一个客户端的连接请求，这里是值-结果参数，之前有说到<br />
//fd 为监听后套接字。最后返回一个记录了本地与目的端信息的套接字<br />
//upeer_sockaddr用来返回已连接客户的协议地址，如果对协议地址不感兴趣就NULL<br />
static int sock_accept(int fd, struct sockaddr *upeer_sockaddr, int *upeer_addrlen)<br />
{<br />
struct file *file;<br />
struct socket *sock, *newsock;<br />
int i;<br />
char address[MAX_SOCK_ADDR];<br />
int len;</p><br />
<br />
    <p>if (fd &lt; 0 || fd &gt;= NR_OPEN || ((file = current-&gt;files-&gt;fd[fd]) == NULL))<br />
    return(-EBADF);<br />
  	if (!(sock = sockfd_lookup(fd, &amp;file))) <br />
    return(-ENOTSOCK);<br />
if (sock-&gt;state != SS_UNCONNECTED)//socket各个状态的演变是一步一步来的 <br />
{<br />
    return(-EINVAL);<br />
}<br />
//这是tcp连接，得按步骤来<br />
if (!(sock-&gt;flags &amp; SO_ACCEPTCON))//没有listen<br />
{<br />
    return(-EINVAL);<br />
}<br />
//分配一个新的套接字，用于表示后面可进行通信的套接字<br />
if (!(newsock = sock_alloc())) <br />
{<br />
    printk(“NET: sock_accept: no more sockets\n”);<br />
    return(-ENOSR);	/* Was: EAGAIN, but we are out of system<br />
               resources! */<br />
}<br />
newsock-&gt;type = sock-&gt;type;<br />
newsock-&gt;ops = sock-&gt;ops;<br />
//套接字重定向，目的是初始化新的用于数据传送的套接字<br />
//继承了第一参数传来的服务器的IP和端口号信息<br />
if ((i = sock-&gt;ops-&gt;dup(newsock, sock)) &lt; 0) <br />
{<br />
    sock_release(newsock);<br />
    return(i);<br />
}<br />
//转调用inet_accept函数<br />
i = newsock-&gt;ops-&gt;accept(sock, newsock, file-&gt;f_flags);<br />
if ( i &lt; 0) <br />
{<br />
    sock_release(newsock);<br />
    return(i);<br />
}<br />
//分配一个文件描述符，用于以后的数据传送<br />
if ((fd = get_fd(SOCK_INODE(newsock))) &lt; 0) <br />
{<br />
    sock_release(newsock);<br />
    return(-EINVAL);<br />
}<br />
//返回通信远端的地址<br />
if (upeer_sockaddr)<br />
{//得到客户端地址，并复制到用户空间<br />
    newsock-&gt;ops-&gt;getname(newsock, (struct sockaddr *)address, &amp;len, 1);<br />
    move_addr_to_user(address,len, upeer_sockaddr, upeer_addrlen);<br />
}<br />
return(fd);<br />
}</p><br />
  </li><br />
</ul><br />
<br />
<p>客户端主动发起连接请求，connect<br />
/*</p><br />
<ul><br />
  <li>首先将要连接的源端地址从用户缓冲区复制到内核缓冲区，之后根据套接字目前所处状态</li><br />
  <li><br />
    <p>采取对应措施，如果状态有效，转调用connect函数<br />
 */<br />
 //这是客户端，表示客户端向服务器端发送连接请求<br />
static int sock_connect(int fd, struct sockaddr *uservaddr, int addrlen)<br />
{<br />
struct socket *sock;<br />
struct file *file;<br />
int i;<br />
char address[MAX_SOCK_ADDR];<br />
int err;</p><br />
<br />
    <p>if (fd &lt; 0 || fd &gt;= NR_OPEN || (file=current-&gt;files-&gt;fd[fd]) == NULL)<br />
    return(-EBADF);<br />
if (!(sock = sockfd_lookup(fd, &amp;file)))<br />
    return(-ENOTSOCK);</p><br />
<br />
    <p>if((err=move_addr_to_kernel(uservaddr,addrlen,address))&lt;0)<br />
  	return err;<br />
//根据状态采取对应措施<br />
switch(sock-&gt;state) <br />
{<br />
    case SS_UNCONNECTED:<br />
        /* This is ok… continue with connect <em>/<br />
        break;<br />
    case SS_CONNECTED:<br />
        /</em> Socket is already connected <em>/<br />
        if(sock-&gt;type == SOCK_DGRAM) /</em> Hack for now - move this all into the protocol <em>/<br />
            break;<br />
        return -EISCONN;<br />
    case SS_CONNECTING:<br />
        /</em> Not yet connected… we will check this. */</p><br />
<br />
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    /*<br />
     *	FIXME:  for all protocols what happens if you start<br />
     *	an async connect fork and both children connect. Clean<br />
     *	this up in the protocols!<br />
     */<br />
    break;<br />
default:<br />
    return(-EINVAL); } i = sock-&gt;ops-&gt;connect(sock, (struct sockaddr *)address, addrlen, file-&gt;f_flags); if (i &lt; 0)  {<br />
return(i); } return(0); } 上面几个函数则是我们应用编程是socket、bind、listen、accept、connect 函数对应的内核的系统调用函数，可以看出，对应的sock_ 函数内部也是转调用了下一层的函数。 所有网络调用函数都具有共同的入口函数 sys_socket /*<br />
</code></pre></div>    </div><br />
  </li><br />
  <li>System call vectors. Since I (RIB) want to rewrite sockets as streams,</li><br />
  <li>we have this level of indirection. Not a lot of overhead, since more of</li><br />
  <li>the work is done via read/write/select directly.<br />
 *</li><br />
  <li>I’m now expanding this up to a higher level to separate the assorted</li><br />
  <li>kernel/user space manipulations and global assumptions from the protocol</li><br />
  <li>layers proper - AC.<br />
 <em>/<br />
//本函数是网络栈专用操作函数集的总入口函数，主要是将请求分配，调用具体的底层函数进行处理<br />
asmlinkage int sys_socketcall(int call, unsigned long *args)<br />
{<br />
int er;<br />
switch(call) <br />
{<br />
    case SYS_SOCKET://socket函数<br />
        er=verify_area(VERIFY_READ, args, 3 * sizeof(long));<br />
        if(er)<br />
            return er;<br />
        return(sock_socket(get_fs_long(args+0),<br />
            get_fs_long(args+1),//返回地址上的值<br />
            get_fs_long(args+2)));<br />
    case SYS_BIND://bind函数<br />
        er=verify_area(VERIFY_READ, args, 3 * sizeof(long));<br />
        if(er)<br />
            return er;<br />
        return(sock_bind(get_fs_long(args+0),<br />
            (struct sockaddr *)get_fs_long(args+1),<br />
            get_fs_long(args+2)));<br />
    case SYS_CONNECT://connect函数<br />
        er=verify_area(VERIFY_READ, args, 3 * sizeof(long));<br />
        if(er)<br />
            return er;<br />
        return(sock_connect(get_fs_long(args+0),<br />
            (struct sockaddr *)get_fs_long(args+1),<br />
            get_fs_long(args+2)));<br />
    case SYS_LISTEN://listen函数<br />
        er=verify_area(VERIFY_READ, args, 2 * sizeof(long));<br />
        if(er)<br />
            return er;<br />
        return(sock_listen(get_fs_long(args+0),<br />
            get_fs_long(args+1)));<br />
    case SYS_ACCEPT://accept函数<br />
        er=verify_area(VERIFY_READ, args, 3 * sizeof(long));<br />
        if(er)<br />
            return er;<br />
        return(sock_accept(get_fs_long(args+0),<br />
            (struct sockaddr *)get_fs_long(args+1),<br />
            (int *)get_fs_long(args+2)));<br />
    case SYS_GETSOCKNAME://getsockname函数<br />
        er=verify_area(VERIFY_READ, args, 3 * sizeof(long));<br />
        if(er)<br />
            return er;<br />
        return(sock_getsockname(get_fs_long(args+0),<br />
            (struct sockaddr *)get_fs_long(args+1),<br />
            (int *)get_fs_long(args+2)));<br />
    case SYS_GETPEERNAME://getpeername函数<br />
        er=verify_area(VERIFY_READ, args, 3 * sizeof(long));<br />
        if(er)<br />
            return er;<br />
        return(sock_getpeername(get_fs_long(args+0),<br />
            (struct sockaddr *)get_fs_long(args+1),<br />
            (int *)get_fs_long(args+2)));<br />
    case SYS_SOCKETPAIR://socketpair函数<br />
        er=verify_area(VERIFY_READ, args, 4 * sizeof(long));<br />
        if(er)<br />
            return er;<br />
        return(sock_socketpair(get_fs_long(args+0),<br />
            get_fs_long(args+1),<br />
            get_fs_long(args+2),<br />
            (unsigned long *)get_fs_long(args+3)));<br />
    case SYS_SEND://send函数<br />
        er=verify_area(VERIFY_READ, args, 4 * sizeof(unsigned long));<br />
        if(er)<br />
            return er;<br />
        return(sock_send(get_fs_long(args+0),<br />
            (void *)get_fs_long(args+1),<br />
            get_fs_long(args+2),<br />
            get_fs_long(args+3)));<br />
    case SYS_SENDTO://sendto函数<br />
        er=verify_area(VERIFY_READ, args, 6 * sizeof(unsigned long));<br />
        if(er)<br />
            return er;<br />
        return(sock_sendto(get_fs_long(args+0),<br />
            (void *)get_fs_long(args+1),<br />
            get_fs_long(args+2),<br />
            get_fs_long(args+3),<br />
            (struct sockaddr *)get_fs_long(args+4),<br />
            get_fs_long(args+5)));<br />
    case SYS_RECV://recv函数<br />
        er=verify_area(VERIFY_READ, args, 4 * sizeof(unsigned long));<br />
        if(er)<br />
            return er;<br />
        return(sock_recv(get_fs_long(args+0),<br />
            (void *)get_fs_long(args+1),<br />
            get_fs_long(args+2),<br />
            get_fs_long(args+3)));<br />
    case SYS_RECVFROM://recvfrom函数<br />
        er=verify_area(VERIFY_READ, args, 6 * sizeof(unsigned long));<br />
        if(er)<br />
            return er;<br />
        return(sock_recvfrom(get_fs_long(args+0),<br />
            (void *)get_fs_long(args+1),<br />
            get_fs_long(args+2),<br />
            get_fs_long(args+3),<br />
            (struct sockaddr *)get_fs_long(args+4),<br />
            (int *)get_fs_long(args+5)));<br />
    case SYS_SHUTDOWN://shutdown函数<br />
        er=verify_area(VERIFY_READ, args, 2</em> sizeof(unsigned long));<br />
        if(er)<br />
            return er;<br />
        return(sock_shutdown(get_fs_long(args+0),<br />
            get_fs_long(args+1)));<br />
    case SYS_SETSOCKOPT://setsockopt函数<br />
        er=verify_area(VERIFY_READ, args, 5<em>sizeof(unsigned long));<br />
        if(er)<br />
            return er;<br />
        return(sock_setsockopt(get_fs_long(args+0),<br />
            get_fs_long(args+1),<br />
            get_fs_long(args+2),<br />
            (char *)get_fs_long(args+3),<br />
            get_fs_long(args+4)));<br />
    case SYS_GETSOCKOPT://getsockopt函数<br />
        er=verify_area(VERIFY_READ, args, 5</em>sizeof(unsigned long));<br />
        if(er)<br />
            return er;<br />
        return(sock_getsockopt(get_fs_long(args+0),<br />
            get_fs_long(args+1),<br />
            get_fs_long(args+2),<br />
            (char *)get_fs_long(args+3),<br />
            (int *)get_fs_long(args+4)));<br />
    default:<br />
        return(-EINVAL);<br />
}<br />
}</li><br />
</ul><br />
<br />
<p>下面再看看socket.c 即BSD socket层中的其余函数<br />
/*</p><br />
<ul><br />
  <li>Sockets are not seekable.<br />
 */</li><br />
</ul><br />
<br />
<p>static int sock_lseek(struct inode *inode, struct file *file, off_t offset, int whence)<br />
{<br />
	return(-ESPIPE);<br />
}</p><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Read data from a socket. ubuf is a user mode pointer. We make sure the user</li><br />
  <li>area ubuf…ubuf+size-1 is writable before asking the protocol.<br />
 */</li><br />
</ul><br />
<br />
<p>static int sock_read(struct inode *inode, struct file *file, char *ubuf, int size)<br />
{<br />
	struct socket *sock;<br />
	int err;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!(sock = socki_lookup(inode))) <br />
{<br />
	printk("NET: sock_read: can't find socket for inode!\n");<br />
	return(-EBADF);<br />
}<br />
if (sock-&gt;flags &amp; SO_ACCEPTCON) <br />
	return(-EINVAL);<br />
 <br />
if(size&lt;0)<br />
	return -EINVAL;<br />
if(size==0)<br />
	return 0;<br />
if ((err=verify_area(VERIFY_WRITE,ubuf,size))&lt;0)<br />
  	return err;<br />
return(sock-&gt;ops-&gt;read(sock, ubuf, size, (file-&gt;f_flags &amp; O_NONBLOCK))); }<br />
</code></pre></div></div><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>Write data to a socket. We verify that the user area ubuf..ubuf+size-1 is</li><br />
  <li>readable by the user process.<br />
 */</li><br />
</ul><br />
<br />
<p>static int sock_write(struct inode *inode, struct file *file, char *ubuf, int size)<br />
{<br />
	struct socket *sock;<br />
	int err;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!(sock = socki_lookup(inode))) <br />
{<br />
	printk("NET: sock_write: can't find socket for inode!\n");<br />
	return(-EBADF);<br />
}<br />
 <br />
if (sock-&gt;flags &amp; SO_ACCEPTCON) <br />
	return(-EINVAL);<br />
<br />
if(size&lt;0)<br />
	return -EINVAL;<br />
if(size==0)<br />
	return 0;<br />
	<br />
if ((err=verify_area(VERIFY_READ,ubuf,size))&lt;0)<br />
  	return err;<br />
return(sock-&gt;ops-&gt;write(sock, ubuf, size,(file-&gt;f_flags &amp; O_NONBLOCK))); }<br />
</code></pre></div></div><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>You can’t read directories from a socket!<br />
 */</li><br />
</ul><br />
<br />
<p>static int sock_readdir(struct inode *inode, struct file *file, struct dirent *dirent,<br />
	     int count)<br />
{<br />
	return(-EBADF);<br />
}</p><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>With an ioctl arg may well be a user mode pointer, but we don’t know what to do</li><br />
  <li>with it - thats up to the protocol still.<br />
 */</li><br />
</ul><br />
<br />
<p>int sock_ioctl(struct inode *inode, struct file *file, unsigned int cmd,<br />
	   unsigned long arg)<br />
{<br />
	struct socket *sock;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!(sock = socki_lookup(inode))) <br />
{<br />
	printk("NET: sock_ioctl: can't find socket for inode!\n");<br />
	return(-EBADF);<br />
}<br />
  	return(sock-&gt;ops-&gt;ioctl(sock, cmd, arg)); }<br />
</code></pre></div></div><br />
<br />
<p>static int sock_select(struct inode *inode, struct file *file, int sel_type, select_table * wait)<br />
{<br />
	struct socket *sock;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!(sock = socki_lookup(inode))) <br />
{<br />
	printk("NET: sock_select: can't find socket for inode!\n");<br />
	return(0);<br />
}<br />
 <br />
/*<br />
 *	We can't return errors to select, so it's either yes or no. <br />
 */<br />
 <br />
if (sock-&gt;ops &amp;&amp; sock-&gt;ops-&gt;select)<br />
	return(sock-&gt;ops-&gt;select(sock, sel_type, wait));<br />
return(0); }<br />
</code></pre></div></div><br />
<br />
<p>void sock_close(struct inode *inode, struct file *filp)<br />
{<br />
	struct socket *sock;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*<br />
 *	It's possible the inode is NULL if we're closing an unfinished socket. <br />
 */<br />
 <br />
if (!inode) <br />
	return; //找对inode对应的socket结构<br />
if (!(sock = socki_lookup(inode))) <br />
{<br />
	printk("NET: sock_close: can't find socket for inode!\n");<br />
	return;<br />
}<br />
sock_fasync(inode, filp, 0);//更新异步通知列表<br />
sock_release(sock);//释放套接字 }<br />
</code></pre></div></div><br />
<br />
<p>/*</p><br />
<ul><br />
  <li><br />
    <p>Update the socket async list<br />
 */<br />
//输入参数on的取值决定是分配还是释放一个fasync_struct结构，该结构用于异步唤醒<br />
static int sock_fasync(struct inode *inode, struct file *filp, int on)<br />
{<br />
struct fasync_struct *fa, *fna=NULL, **prev;<br />
struct socket *sock;<br />
unsigned long flags;</p><br />
<br />
    <p>if (on)//分配<br />
{<br />
    fna=(struct fasync_struct *)kmalloc(sizeof(struct fasync_struct), GFP_KERNEL);<br />
    if(fna==NULL)<br />
        return -ENOMEM;<br />
}</p><br />
<br />
    <p>sock = socki_lookup(inode);</p><br />
<br />
    <p>prev=&amp;(sock-&gt;fasync_list);</p><br />
<br />
    <p>save_flags(flags);//保存当前状态<br />
cli();</p><br />
<br />
    <p>//从链表中找到与file结构对应的fasync_struct<br />
for(fa=<em>prev; fa!=NULL; prev=&amp;fa-&gt;fa_next,fa=</em>prev)<br />
    if(fa-&gt;fa_file==filp)<br />
        break;</p><br />
<br />
    <p>if(on)//分配后的建立联系<br />
{<br />
    //如果已经有对应的file结构，则释放之前创建的<br />
    if(fa!=NULL)<br />
    {<br />
        kfree_s(fna,sizeof(struct fasync_struct));<br />
        restore_flags(flags);<br />
        return 0;<br />
    }<br />
    //如果没有，则挂载这个新创建的结构<br />
    fna-&gt;fa_file=filp;<br />
    fna-&gt;magic=FASYNC_MAGIC;<br />
    fna-&gt;fa_next=sock-&gt;fasync_list;<br />
    sock-&gt;fasync_list=fna;<br />
}<br />
//释放<br />
else<br />
{<br />
    if(fa!=NULL)<br />
    {<br />
        *prev=fa-&gt;fa_next;<br />
        kfree_s(fa,sizeof(struct fasync_struct));<br />
    }<br />
}<br />
restore_flags(flags);//恢复状态<br />
return 0;<br />
}</p><br />
  </li><br />
</ul><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>异步唤醒函数，通过遍历socket结构中fasync_list变量指向的队列，</li><br />
  <li>对队列中每个元素调用kill_fasync函数<br />
 */<br />
int sock_wake_async(struct socket *sock, int how)<br />
{<br />
 if (!sock || !sock-&gt;fasync_list)<br />
     return -1;<br />
 switch (how)<br />
 {<br />
     case 0:<br />
         //kill_fasync函数即通过相应的进程发送信号。这就是异步唤醒功能<br />
         kill_fasync(sock-&gt;fasync_list, SIGIO);<br />
         break;<br />
     case 1:<br />
         if (!(sock-&gt;flags &amp; SO_WAITDATA))<br />
             kill_fasync(sock-&gt;fasync_list, SIGIO);<br />
         break;<br />
     case 2:<br />
         if (sock-&gt;flags &amp; SO_NOSPACE)<br />
         {<br />
             kill_fasync(sock-&gt;fasync_list, SIGIO);<br />
             sock-&gt;flags &amp;= ~SO_NOSPACE;<br />
         }<br />
         break;<br />
 }<br />
 return 0;<br />
}</li><br />
</ul><br />
<br />
<p>/*</p><br />
<ul><br />
  <li>只用于UNIX域名(iconn,conn只用于UNIX域)，用于处理一个客户端连接请求<br />
 */</li><br />
</ul><br />
<br />
<p>int sock_awaitconn(struct socket *mysock, struct socket *servsock, int flags)<br />
{<br />
	struct socket *last;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*<br />
 *	We must be listening<br />
 */<br />
 //检查服务器端是否是处于监听状态，即可以进行连接<br />
if (!(servsock-&gt;flags &amp; SO_ACCEPTCON)) <br />
{<br />
	return(-EINVAL);<br />
}<br />
</code></pre></div></div><br />
<br />
  	/*<br />
  	 *	Put ourselves on the server’s incomplete connection queue. <br />
  	 */<br />
  	 //将本次客户端连接的套接字插入服务器端，socket结构iconn字段指向的链表<br />
  	 //表示客户端正等待连接<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mysock-&gt;next = NULL;<br />
cli();<br />
if (!(last = servsock-&gt;iconn)) <br />
	servsock-&gt;iconn = mysock;<br />
else <br />
{<br />
	while (last-&gt;next) <br />
		last = last-&gt;next;<br />
	last-&gt;next = mysock;<br />
}<br />
mysock-&gt;state = SS_CONNECTING;//正在处理连接<br />
mysock-&gt;conn = servsock;//客户端连接的服务器端套接字<br />
sti();<br />
 <br />
/*<br />
 * Wake up server, then await connection. server will set state to<br />
 * SS_CONNECTED if we're connected.<br />
 */<br />
 //唤醒服务器端进程，以处理本地客户端连接<br />
wake_up_interruptible(servsock-&gt;wait);<br />
sock_wake_async(servsock, 0);<br />
 <br />
//检查连接状态<br />
if (mysock-&gt;state != SS_CONNECTED) <br />
{<br />
	if (flags &amp; O_NONBLOCK)<br />
		return -EINPROGRESS;<br />
	//等待服务器端处理本次连接<br />
	interruptible_sleep_on(mysock-&gt;wait);<br />
	<br />
	//检查连接状态，如果仍然没有建立连接<br />
	if (mysock-&gt;state != SS_CONNECTED &amp;&amp;<br />
	    mysock-&gt;state != SS_DISCONNECTING) <br />
	{<br />
	/*原因如下<br />
	 * if we're not connected we could have been<br />
	 * 1) interrupted, so we need to remove ourselves<br />
	 *    from the server list<br />
	 * 2) rejected (mysock-&gt;conn == NULL), and have<br />
	 *    already been removed from the list<br />
	 */<br />
	 //如果被其他中断，需要主动将本地socket从对方服务器中iconn中删除<br />
		if (mysock-&gt;conn == servsock) <br />
		{<br />
			cli();<br />
			//找到iconn中的本地socket结构<br />
			if ((last = servsock-&gt;iconn) == mysock)<br />
				servsock-&gt;iconn = mysock-&gt;next;<br />
			else <br />
			{<br />
				while (last-&gt;next != mysock) <br />
					last = last-&gt;next;<br />
				last-&gt;next = mysock-&gt;next;<br />
			}<br />
			sti();<br />
		}<br />
		//被服务器拒绝，本地socket已经被删除，无需手动删除<br />
		return(mysock-&gt;conn ? -EINTR : -EACCES);//两种原因情况的返回<br />
	}<br />
}<br />
return(0); } 其余没有贴出的函数，也基本上是这么个流程。 socket.c 文件中函数的实现绝大多数都是简单调用下层函数，而这些下层函数就是af_inet.c 文件中定义的函数。socket.c 对应 BSD socket层，文件af_inet.c 则对应的是INET socket层。这些上下层次的表示从函数的嵌套调用关系上体现出来。<br />
</code></pre></div></div><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category linux
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>