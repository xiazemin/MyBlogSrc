<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">block chain 区块链</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2018-03-18T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Mar 18, 2018</time></p>
					</div>
					 <p>参考：<br />
http://zhibimo.com/read/wang-miao/mastering-bitcoin/Chapter05.html<br />
https://www.zhihu.com/question/37290469<br />
<!-- more --><br />
比特币——〉区块链是比特币的底层技术。或者比特币——〉比特币是一种区块链。具体到什么是区块链的问题，目前没有看到很好的定义和介绍，更多的是大而化之地讲区块链的意义在哪里的空泛文章，要不然就是一水的矿工和挖矿。所以我来从纯理论角度说一下我个人对区块链的定义：1，区块链是一个放在非安全环境中的分布式数据库（系统）。2，区块链采用密码学的方法来保证已有数据不可能被篡改。3，区块链采用共识算法来对于新增数据达成共识。具有以上三个性质的系统，就是区块链。1，区块链是一个放在非安全环境中的分布式数据库（系统）。这里的要点有两个：（1）分布式，（2）非安全环境。首先，这是一个分布式的，去中心化的系统。所以，有一个中心服务器或者节点的，不是区块链。节点都是安全的，无恶意的，那这不是区块链。同理，从应用的角度讲，如果你的应用必须要使用中心节点（例如要用超级计算机做深度学习）或者没必要考虑节点不安全的情况（例如某个安全的工厂里的传感器），那么并不需要考虑区块链技术。至于后面的词“数据库”，目前大部分成熟的区块链都是数据库，例如比特币就是一个分布式账本，而账本其实就是数据。然后，根据数据的格式，又可以分三种——1，数据是完全不相关的，只是达成的共识，没有有效无效之分；2，数据有某些逻辑结构，例如账本中，一笔交易实际上除了金额，还有输入和输出，连接到之前的交易，这些数据需要通过逻辑验证（例如交易中，节点需要验证输入的交易是否有效）；3，数据拥有图灵完备的逻辑，而验证的时候需要通过节点使用算力运算，每笔交易可以有不同的输出和状态，每个节点要做的不仅仅是验证交易的真实性和输入的正确性，还要根据交易里的逻辑读入数值，进行验算然后再验证结果。比特币的系统就是第二种，又叫分布式账本；以太坊是第三种。第三种可以支持智能合约。用比特币举例的话，1，它是一个完全去中心化的系统，2，它放在一个非安全的环境，它并不要求所有使用比特币的人都没有恶意。2，区块链采用密码学的方法来保证已有数据不可能被篡改。这个是误解最多的部分，因为很多人一提到区块链就只觉得是这个。诚然，这部分很重要，而且确实区块链也因此得名，但这只是区块链的定义的一部分。这个部分的两个核心要点是：（1）密码学哈希函数，（2）非对称加密。两个都是密码学的基础概念，网上都有非常清晰的定义，我只简单说下：（密码学）哈希函数：一个函数Y=H(X)，有如下性质：1，有X可以很容易算出Y；2，有Y不可能算出X；3，有Y不可能找到另一个X’使得H(X’)=Y；3.5，如果X和X’相差很小，H(X)和H(X’)则完全不相关。这东西主要用于验证信息完整性——在一个信息后面放上这个信息的哈希值，这个值很小，例如256bit，而且计算方便。收到信息之后收信人再算一遍哈希值，对比两者就知道这条信息是否被篡改过了。如果被篡改过，哪怕只有一bit，整个哈希值也会截然不同。而根据哈希函数的性质，没有人能够伪造出另一个消息具有同样的哈希值，也就是说篡改过的数据完全不可能通过哈希校验。非对称加密：这东西很好理解——对称加密就是有个密钥，可以理解成保险箱钥匙，你把消息加密变成密文，没有人能看懂这是啥，然后同一把钥匙解密成原来的消息。非对称加密就是有两把钥匙，一把叫公钥，一把叫私钥，用其中一把加密的话，只能用另一把解密，反之亦然。另一个重要的性质是，给你密文，明文和其中一把钥匙，你还是解不出来另一把钥匙是啥。原理基本上是基于一些困难数学问题，例如因数分解和离散对数，常用的有RSA，Diffie-Hellman和ECC（椭圆曲线），比特币用的是椭圆曲线。非对称加密除了和对称加密一样用于信息加密之外，还有另一个用途，就是身份验证。因为通常情况我们假设一对公私钥，公钥是公开的，而私钥只有本人有，于是一个人如果有对应的私钥，我们就可以认定他是本人。其中一个重要的应用就是数字签名——某个消息后面，发信人对这个消息做哈希运算，然后用私钥加密。接着收信人首先对消息进行哈希运算，接着用相应的公钥解密数字签名，再对比两个哈希值，如果相同，就代表这个消息是本人发出的而且没有被篡改过。以上是基础知识，至于区块链怎么实现的，很简单：交易（数据）写在区块里。第一个区块叫创世区块，写啥都行。从第二个区块开始，每个区块的第一部分有前一区块的哈希值。此外，区块里的每一笔交易（数据），都有发起人的数字签名来保证真实性和合法性。于是，先前区块里的任何数据都不可被篡改，原因见上。到这为止有人可能会问：为什么要弄个链啊？直接所有数据加个哈希值不就行了？因为——这个数据库并不是静止的啊。数据库的数据是会增加的，而每次增加的数据，就是一个区块，于是这些生成时间不同的区块，就以这种形式链在一起了。至于如何增加区块，就涉及到第三个部分——共识算法。3，区块链采用共识算法来对于新增数据达成共识。共识算法的目的，就是让所有节点对于新增区块达成共识，也就是说，所有人都要认可新增的区块。对于有中心的系统，这事很简单，中心说什么大家同意就好了，但是放到去中心化系统里，尤其是当有些节点有恶意的时候，这东西非常复杂，计算机科学里有个相应的问题，叫做“拜占庭将军问题”或者“拜占庭容错”（BFT）。有很多用Lamport给出的那个例子来讲BFT的东西，我在这里换一个角度。Lamport大神当年提出这个问题的时候在斯坦福研究中心给NASA做项目，他提出这个问题的原因并不是考虑类似比特币的应用场景（整个互联网成千上万个用户），而是考虑特殊背景下的一个简单的系统——航天飞机的控制系统。如果有航空背景的同学可能知道，飞机有三套独立的控制系统，为什么呢？因为任何系统都不可能完全不出故障，就算飞机控制系统的故障率已经极低了，还是有飞到一半这东西坏了的可能。于是我们可以弄两套独立的系统，同时坏掉的几率就会大大降低。可是两套独立的系统还是不足以容下一个系统的错误——一架飞机迎面飞来，两套系统一个说要躲，一个说不躲，那到底是躲还是不躲呢？所以我们需要三台独立的系统，这样，如果有一个系统有故障了，还有两台能正常工作，能少数服从多数给出正确的结果。学过纠错码的同学对这个应该不陌生，这个系统的输出之间的汉明间距是3，所以可以纠正一位的错误。然而，对于航天飞机，在冷战的背景下，万一某个系统不是坏掉了，而是被敌人控制了呢？三套系统还够吗？答案是否定的，因为不同于单纯只是坏掉的节点，恶意节点可以做一些别的事来阻止整个系统达成共识。这个部分略复杂要讲的话要单开一帖，所以我们只说最简单的情况（无签名同步系统）。我们管三个系统叫ABC，正常工作流程是三个人每次得出结果就互相告诉一下，然后每个人选多数人同意的结果。这是个没有中央节点的分布式系统，也就是说三人不能聚在一起开个会啥的，仨人只能两两通信。这个时候，假设C有恶意，它的目标是破坏这个系统。于是，假设正确的读数是1，A和B都得出了1这个结果，这个时候C这个小婊砸告诉A说“我的结果是0，B也觉得是0”，同时打个电话跟B说“哎我觉得是0，A也这么说”，于是A和B就懵逼了。假设你是A，你听到了两个不同版本的B的答案，B说自己选了1，C说B选了0，可是A这个时候没法知道B和C谁才是那个骗了自己的小婊砸，因为如果B真的告诉A选了1然后告诉C是0，他听到的结果和现在是一模一样的。于是结论是，拜占庭容错，也就是需要容下一个恶意系统而非错误系统，需要4个独立系统。（当然，签名可以解决这个问题，但是这只是同步系统的情况，在异步系统里这问题会变得更加复杂，原因是正常节点的回答有延迟，而恶意节点可以不回复，所以，正常节点一方面要等另一个节点的回复，但是它又不知道对方会不会回复因为对方有可能会有恶意，而在收到回复之前，它完全没法判断对方是正常节点还是恶意节点，这个问题叫异步BFT，也是BFT的最复杂的情况，这里不再做更多的解释，下文提到的BFT算法，其实都是异步BFT的算法）Lamport提出这个问题之后，有无数的算法被提出来，统称BFT（拜占庭容错）算法，其中最有代表性的叫PBFT，然后由于最近区块链的热度，无数针对区块链应用场景优化过的BFT算法也涌现出来，但是一个重要的问题是，所有目前的BFT算法，都只能应用在小型网络里。原因很简单——因为BFT这个问题是设计给类似于航天飞机控制系统这样的场景的，早期的算法考虑的也主要是这种场景。PBFT论文里考虑的就是一个5个节点的系统。就算算上新提出的BFT算法，也最多应用在不超过100个节点的网络里。这个问题被搁置了很久，直到比特币的诞生——中本聪从某种意义上简化了这个问题，在比特币中，同样是共识问题，中本聪引入了一个重要的假设——奖励，他之所以能这样做的原因是，他考虑的是一个数字货币，也就是说共识这个东西是有价值的。于是在这样的系统上，他提出了工作证明机制。所有挖矿，矿工，最长链，分叉等等等等，都可以归结为一句话：说话是要有代价的，说真话是有好处的，说假话是要扣钱的……这就是目前两类共识算法的核心区别：BFT共识模型：恶意节点可以干任何事。比特币共识模型：模型中有公认的“价值”，每个节点说话都需要一定代价，诚实节点会受到奖励，而恶意节点由于只付出代价而收不到奖励，变相受到了惩罚。也就是说，BFT共识模型其实涵盖了比特币共识模型的场景，比特币共识其实放宽了BFT共识模型的限制。比特币共识对于BFT的优势在于，由于给恶意节点的能力做了限制，恶意节点所能造成的破坏大大降低了，尤其是对于异步系统——BFT共识里恶意节点可以一直拒绝相应而诚实节点还需要一直等它（因为不知道它是不是恶意的），而对于比特币共识，随你便，你不响应就没有奖励可拿。于是，比特币共识算法可以应用于成千上万个节点，而且，任何人随时都可以加入，不需要预先在网络里注册自己的身份（而BFT算法里，网络中节点的数量和身份都必须是已知的）。但比特币共识的缺陷在于，首先，得有个有价值的东西，也就是说放在比特币里这东西还行，以太坊的话现在可能也凑合，但是其他数字货币嘛……BFT共识有个严格的限定，就是恶意节点不能超过总数的1/3，然而其实比特币共识没有这样的限制，唯一的限制就是假定大部分节点都是理性的，是逐利的，也就是会采用最佳的策略来赚取最大的价值。所以，严格来说，自私挖矿这种行为在比特币共识里是允许的，而多数攻击，其实也算不上一种攻击，因为这些都没有突破比特币共识的框架——如果这个价值无限大，比特币共识是非常可靠的。然而这并不是事实，因为并不是每个虚拟货币都和比特币一样值钱，而在价值不高的情况下，比特币共识的前提就站不住脚了——当损失可能是几千上万块钱的时候，假定每个人都是理性的是合理，但是如果损失就几分钱这个假设就相当扯淡了，事实上也发生过一个比特币矿池跑到另一个货币恶意挖矿搞垮对手的情况。此外，比特币共识是最长链共识，也就是说最长链–&gt;大多数–&gt;理性，于是分叉是允许的。于是导致了一些附带的问题，例如，如果网络有延迟，你怎么知道你手里那条链是整个网络里当前的最长链呢？于是，如果需要传输的数据多，那么延迟加大。延迟加大，那么越多的人手里的链并不是全网络的最长链。于是，全网络的最长链，就没法代表大多数。这就打破了比特币共识的根本，这也是为什么比特币区块频率是10分钟一块的原因。比特币目前有个著名的7币交易每秒的上限，而现在扩容闹得很厉害，以太坊的交易格式不同，也用了新的工作证明，想要改成权益证明，但这些都不本质。真正本质的是，在目前的网络条件下，如果适用全网的话，比特币共识的交易量基本上超不过100笔交易每秒这个量级。上面这几段有可能太深了，简单来说，BFT共识和比特币共识的区别可以这么理解：BFT共识：来，大家开个会讨论一下集思广益啊，讨论出大家都满意的结果为止。问题：开会的效率大家都懂，人越多越不容易出结果。只能用于少数节点，用于上千个节点的话……大家想象一下一天开一次人大的场景。比特币共识：你的诗念得不错，组织已经决定了，今天就你来当领导了，做得好有奖，做不好扣钱。问题：奖励几千块钱还好，奖励几分钱谁好好干？而区块链也就因此被分成了泾渭分明的两类，很多人都听过什么公有链私有链联盟链，但是，如果你们以为这是根据应用区分的就大错特错，其实，这两种区块链最本质的区别，还是因为共识模型或者说算法不同——BFT算法没法应用于大量节点，所以用BFT算法的就没法做公有链。而比特币共识得有个价值体系，这东西去做私有链联盟链就很不靠谱，因为一个单纯逐利的人的假设还算靠谱，但是如果对象是公司的话，公司的利益就太复杂了，不能简单认为他们只追逐区块链上那点价值。1，公有链，以比特币，以太坊和所有虚拟货币为代表，都采用比特币共识，共识算法基本上都采用工作证明机制，也就是挖矿那些，这种机制其他回答里已经讲得够清楚了，就略过。工作证明一切都好，除了费电……费多少电呢？比特币的话，差不多和一个百万人级别的城市那么多。此外以太坊的创始人特别喜欢权益证明，似乎很快要小范围投入使用（100个区块里一个用权益证明）。但是目前为止，大家对这东西的可靠性还持观望态度。2，私有链和联盟链。以IBM的hyperledger-fabric，以及一大堆其他的类似于tendermint，甚至R3 corda和ripple为代表，都用BFT共识。其实这方面的应用已经很多了，问题是，1，目前基本上所有应用给人的感觉都还是为了做区块链而区块链，真的觉得这东西好到不可或缺的应用还基本没有。2，由于为了区块链而区块链，其实很多场景的安全性和可靠性还值得怀疑，这点经常被被公有链的支持者诟病。</p><br />
<br />
<p>问题1：类两军问题<br />
在分布式计算中在异步系统和不可靠的通道上达到一致性是不可能的<br />
在这种情况下，因为是点对点的通信，双方不可能在这种情况下达到信息的一致性。严谨一点，就是“在分布式计算上，试图在异步系统和不可靠的通道上达到一致性是不可能的”。</p><br />
<br />
<p>问题2：拜占庭将军问题拜占庭罗马帝国在军事行动中，采取将军投票的策略来决定是进攻还是撤退，也就是说如果多数人决定进攻，就上去干。但是军队中如果有奸细（比如将军已经反水故意乱投票，或者传令官叛变擅自修改军令），那怎么保证最后投票的结果真正反映了忠诚的将军的意愿呢？拜占庭将军问题反映到信息交换领域中来，可以理解为在一个去中心的系统中，有一些节点是坏掉的，它们可能向外界广播错误的信息或者不广播信息，在这种情况下如何验证数据传输的准确性。区块链技术的诞生现在让我们来一步一步在去中心化的系统中解决这些问题，见证区块链技术雏形的诞生。1我们先来建立一个去中心化的系统，为了方便理解，我们来看一个简单的去中心化借贷模型：如果A借了B 100块钱，这个时候，A在人群中大喊“我是A，我借给了B 100块钱！”，B也在人群中大喊“我是B，A借给了我100块钱！”，此时路人甲乙丙丁都听到了这些消息，因此所有人都在心中默默记下了“A借给了B100块钱”。你看，这个时候一个去中心化的系统就建立起来了，这个系统中不需要银行，也不需要借贷协议和收据，严格来说，甚至不需要人与人长久的信任关系（比如B突然又改口说“我不欠A钱！”，这个时候人民群众就会站出来说“不对，我的小本本上记录了你某天借了A100块钱！”）。<br />
可能你已经发现了，在上述的模型中，所谓的“100块钱”已经不重要了。换句话说，任何东西都可以在这个模型中交换，甚至你可以凭空杜撰一个东西，只要大家承认，你就可以让你杜撰的东西流通。比如：我在人群中高喊一声“我创造了10个查克拉！”，我甚至不需要知道查克拉是什么，也不需要关心世界上是不是真的有查克拉，只要大家都听到，然后在自己的小本本上记下“LaiW3n有10个查克拉”，于是我就真的有100个查克拉了。从此以后，我便可以声称我给了某人1个查克拉，只要路人甲乙丙丁都收到并且承认了这一信息，那我就算完成了这次交易，哪怕世界上没有查克拉。你现在脑海中是不是浮现出了三个字——“比特币”？由于真正的区块链和比特币比我上述的模型复杂太多，细节也丰富太多，因此以下还是以查克拉举例，毕竟本文是Blockchain for Babies.（笑）3假设过了很长一段时间，我凭空创造的查克拉已经在这个系统中流通了起来，大家都开始认可了查克拉。但是这个系统中一共就只有10个查克拉，于是有人动了坏心思，他在人群中高呼“我有10个查克拉！”怎么办？大家是直接在本本上记下他有10个查克拉么，这样不是人人都可以伪造查克拉了么？为了防止这种现象发生，我决定在我创造查克拉的时候给我的查克拉打上标记（更准确地说，我是给我喊的那句“我创造了10个查克拉”打上标记，比如标记为001），这样以后在每一笔交易的时候，我在高喊“我给了某某1个查克拉！”的时候，会附加上额外的一句话：“这1个查克拉的来源是记为001的那条记录，我的这句话标记为002！”。我们再抽象一点，某人喊话的内容的格式就变成了：“这句话编号xxx，上一句话的编号是yyy，我给了某某1个查克拉！”，这样就解决了伪造的问题。其实上述模型就变成一个简化的中本聪第一版比特币区块链协议：<br />
看到这里你基本已经能够生动形象又不涉及任何细节地向你的弱智室友解释区块链了。但是也许你的室友是一个有打破沙锅问到底精神求是学子，因此你最好继续准好回答以下这几个问题。1. “凭啥？”你室友可能会问：“凭啥你喊一句话我就帮你记？我的小本本不要钱么？”。为了激励大家帮我传话和记账，我决定给第一个听到我喊话并且记录在小本本上的人一些奖励：第一个听到我喊话并记录下来的人，你就凭空得到了1个查克拉，这个查克拉是整个系统对你幸苦记账的报酬，而你记录了这句话之后，要马上告诉其它人你已经记录好了，让别人放弃继续记录这句话，并给你自己的记录编号让别人有据可查，然后你再把我的话加上你的记录编号一起喊出来，供下一个人记账。当这个规则定下以后，这个系统中一定会出现一批人，他们开始竖着耳朵监听周围发出的声音，以抢占第一个记账的权利。对的，你脑海中是不是又浮现出了“比特币挖矿”的字眼？值得一提的是，关于比特币挖矿， @玲珑邪僧举了一个很形象的例子：单身汪们要找女票，国民岳母说我有好多女儿，这样吧我给你们出点题目，解出一个就给其中一个姑娘的微信号。单身汪们疯狂竞争，想破脑袋去解题。只要其中一只汪解出一道题，就立马得意洋洋地昭告天下，示威全部单身汪，这个姑娘是我的啦，你们放弃吧。其他单身汪们即使不服也没有办法，惆怅懊恼也不是个事儿啊，还是麻溜地立马去解下一道题目吧。这只喜赢姑娘的幸运小汪被岳母认可后还能得到25个货币单位的彩礼，简直人生赢家。2. “听谁的？”在这个系统中，如果我和另一个人C几乎同时地喊出一句：“为了艾泽拉斯！”。由于听众所处的位置不同，一定会有人先听到我说的那句话，而另外一些人则先听到C的那句话，如果我们规定只能有一个人说出这句话，那到底这句话是谁说的？如果不加任何条件，那么上述的情况一定会这样发展：一部分人认为这句话是我说的，在听到这句话之后开始记账，之后他们所做的所有事情都是基于这个事实，并且随着这个信息一次次的传下去，这条信息链会越来越深；而另外一群认为是C先说这句话的人，也会按照这样的趋势发展。这样，原本是一条唯一的信息链，在我们喊出“为了艾泽拉斯”这句话之后，分叉了！？<br />
“区块链”分叉这会导致怎样的情况呢？按照我们的设想，应该每个人的小本本上记录的东西都是一样的，都是一条可以把所有信息串联起来的链条。但是在这一刻，他们小本本上记录的东西不一样了！这还玩毛啊？以后还怎么确定交易和信息的真实性！？为了解决这个问题，我又追加了新的规则：每个人在记录小本本的时候，需要脱鞋然后用脚拿笔，在小本本上用正楷体书写！有了这个规定，由于用脚写字难度很大，每个人至少需要10分钟才能写完，而且由于每个人用脚写字的熟练度不通，写完这句话所用的时间也不同，因此一定会有人先写完然后高呼“我写完了！那句话是LaiW3n喊的！”，这样其它正在写这句话的人便会停笔，然后在小本本上重新开始写“那句话是来文写的，上一句的编号是xxx”。如果你对上述我的解决方法感兴趣，你可以对照我上面的比喻去了解以下知识：“听谁的”——中本聪破解“拜占庭将军问题”的算法“在小本本上记录”——比特币挖矿“脱鞋用脚写字”——比特币挖矿难度“脱鞋写字速度”——算力“新的规则”——工作量证明链3. “双花”问题这个时候你的室友可能又要问：如果我同时宣布我给了A一个查克拉和我给了B一个查克拉，但是我只有一个查克拉，那咋整？是A和B都收到了查克拉还是咋地？这个时候你只需要托起他的下巴，温柔地看着他的眼睛，用手刮刮他的鼻子，说：“小妖精，你把这种情况带到上面的规则中去试试？”</p><br />
<br />
<p>在节点的视野里，大概每十分钟会凭空产生一个建立在自己平行宇宙世界的神奇区块（你可以将区块想象为一个盒子），这个区块里放着一些数字货币以及一张小纸条，小纸条上记录了这十分钟内产生的那唯一一笔交易信息，比如说——“小A转账给了小B100元”；当然，这段信息肯定是被加密处理过的，为的就是保证只有小A和小B（通过他们手上的钥匙）才有能力解读里面真正的内容。这个神奇的区块被创造出来之后，很快被埋在了地底下，至于埋在哪里？没有一个人不知道，需要所有计算机节点一起参与进来掘地三尺后才有可能找到（找到一个有效的工作量证明）。显然，这是一件工作量巨大、成果随机的事件。但是呢，对于计算机节点来说，一旦从地底下挖出这个区块，他将获得区块内价值不菲的数字货币，以及“小A转账给了小B100元”过程中小A所支付的小费。同时，对于这个节点来说，也只有他才有权利真正记录小纸条里的内容，这是一份荣耀，而其他节点相当于只能使用它的复制品，一个已经没有数字货币加持的副本。当然这个神奇的区块还有一些其他很特别的地方，后面我们会再细细聊。为了更好的描述，我们将计算机节点从地底下挖出区块的过程叫做「挖矿」，刚才说了，这是一件工作量巨大、运气成分较多、但收益丰厚的事儿。过了一会儿，来自中国上海浦东新区张衡路上的一个节点突然跳出来很兴奋的说：“ 我挖到区块了！里面的小纸条都是有效的！奖励归我！” 。虽然此刻张衡路节点已经拿到了数字货币，但对于其他计算机节点来说，因为这里面还涉及到其他一些利益瓜葛，他们不会选择默认相信张衡路节点所说的话；基于陌生节点彼此不信任的原则，他们拿过张衡路节点所谓挖到的区块（副本），开始校验区块内的小纸条信息是否真实有效等等。在区块链世界里，节点们正是通过校验小纸条信息的准确性，或间接或直接判断成功挖出区块的节点是否撒谎。（如何定义小纸条信息真实有效，后面会讲解，这里暂不做赘述）。在校验过程中，各个节点们会直接通过下面两个行为表达自己对张衡路节点的认同（准确无误）和态度：停止已经进行了一半甚至80%的挖矿进程；将张衡路节点成功挖出的区块（副本）追加到自己区块链的末尾。你可以稍微有点困惑：停止可能已经执行了80%的挖矿行为，那之前80%的工作不是就白做了嘛？！然后，区块链的末尾又是个什么鬼东西？对于第一个困惑。我想说，你说的一点没错，但是没办法，现实就是这么残酷，即便工作做了80%，那也得放弃，这80%的工作劳苦几乎可以视为无用功，绝对的伤财劳众。第二个困惑，区块链和区块链的末尾是什么鬼？这里因为事先并没有讲清楚，但是你可以简单想象一下：区块是周期性不断的产生和不断的被挖出来，一个计算机节点可能事先已经执行了N次“从别人手上拿过区块 -&gt; 校验小纸条有效性”的流程，肯定在自己的节点上早已经存放了N个区块，这些区块会按照时间顺序整齐的一字排列成为一个链状。没错，这个链条，就是你一直以来认为的那个区块链。如果你还是不能够理解，没关系，文章后面还会有很多次机会深入研究。# 走进区块内，探索消息的本质上面我们构建了一个最简单的区块链世界的模型，相信大多数同学都已经轻松掌握了。但是别骄傲也别着急，这还只是一些皮毛中的皮毛，坐好，下面我们准备开车了。前面我们说到“大概每十分钟会凭空产生一个神奇的区块，这个区块里放了一张小纸条，上面记录了这十分钟内产生的这唯一一笔交易信息”。显然，十分钟内产生的交易肯定远不止一条，可能是上万条，这上万条数据在区块链世界是如何组织和处理的呢？另外，为什么在纸条上记录的只是某一次的交易信息，而不是某一个人的余额？余额好像更符合我们现实世界的理解才对。既然存在这样那样的疑问。现在我们就把视线暂时从“区块”、“区块链”这些看起来似乎较大实体的物质中移开，进入到区块内更微观的世界里一探究竟，看看小纸条到底是怎么一回事，它的产生以及它终其一生的使命：发起交易的时候，发起人会收到一张小纸条，他需要将交易记录比如说“盗盗转账给张三40元”写在纸上。说来也神奇，当写完的那一刹那，在小纸条的背面会自动将这段交易记录格式化成至少包含了“输入值”和“输出值”这两个重要字段；“输入值”用于记录数字货币的有效来源，“输出值”记录着数字货币发往的对象。刚刚创建的小纸条立马被标记成为“未确认”的小纸条。从地下成功挖出区块并最终连接到区块链里的小纸条一开始会被标记为“有效”。若这条有效的小纸条作为其他交易的输入值被使用，那么，这个有效的小纸条很快会被标记为“无效”。因为各种原因，区块从链上断开、丢弃，曾经这个区块内被标记为“有效”的小纸条会被重新标记为“未确认”。区块链里面没有账户余额的概念，你真正拥有的数字资产实际上是一段交易信息；通过简单的加减法运算获知你数字钱包里的余额。上面的1、2、3仅仅作为结论一开始强行灌输给你的知识点，其中有几个描述可能会有点绕，让你觉得云里雾里，没有关系，因为我们立刻、马上就开始会细说里面的细枝末节。<img src="https://pic4.zhimg.com/50/v2-9b6d8ac951f48d7cd31b7d4f3e266c69_hd.jpg" data-size="normal" data-rawwidth="1662" data-rawheight="806" class="origin_image zh-lightbox-thumb" width="1662" data-original="https://pic4.zhimg.com/v2-9b6d8ac951f48d7cd31b7d4f3e266c69_r.jpg" />上图，是区块内，盗盗在一张小纸条上记录下的交易信息，后被格式化的呈现上图就是从无数打包进区块内的小纸条中，抽取出来的一张，以及它最终被格式化后的缩影。单看右侧的图可能很容易产生误会，虽然看起来有多行，但实际上就是“盗盗转账给张三40个比特币”这一条交易数据另外的一种呈现形态。因为区块链世界里面这么规定，每一条交易记录，必须有能力追溯到交易发起者 发起这笔交易、其中所涉及金额的上一笔全部交易信息；即这笔钱从何而来的问题。这其实很容易理解，在去中心化的网络中，通过建立交易链、和通过交易链上的可溯源性间接保证数据安全和有效。我们继续看，在区块链世界里，我们是如何仅通过“盗盗转账给张三40个比特币” 这条交易信息完成转账流程的。其实跟现实中你在路边买一个包子的流程大抵上相同。第一步：判断是否有足够的余额完成交易这里我们再一次重申，区块链世界是没有余额的概念，余额是通过简单数字的加减最终获得，你拥有所谓的数字货币实际上是因为你拥一条交易记录，即 “盗盗转账给张三40个比特币”！这里，我们还是拿这条记录说事：追溯“输出值”是“盗盗”相关的全部有效交易记录作为，对有效交易中的数字进行简单求和，判断是否大于等于40，如果确实大于等于，则将这些有效的交易记录合并形成一条新的交易记录（如下图）。如果小于40，其实可以不需要再继续往下探讨。<img src="https://pic1.zhimg.com/50/v2-90202117662d6ffef784185525b7573e_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1654" data-rawheight="1028" class="origin_image zh-lightbox-thumb" width="1654" data-original="https://pic1.zhimg.com/v2-90202117662d6ffef784185525b7573e_r.jpg" />就上图的例子，我们追溯到曾经转账给盗盗的有效交易记录有“小A转账给盗盗10 btc”、“小B转账给盗盗20 btc”、“小C转账给盗盗 25 btc”，我们需要将这三条交易记录合并成一条更复杂描述的交易记录，即 “( 小A转账给盗盗10 btc + 小B转账给盗盗20 btc + 小C转账给盗盗 25 btc ) 转账给张三40 btc ”第二步：判断是否需要找零对追溯到的有效交易数字求和，如果发现大于需要支付的金额，需要将多出的数字重新支付给自己，相当于找零。对应生成了一条全新的交易记录（如下图）。<img src="https://pic3.zhimg.com/50/v2-7b564661d4e1d6693ed89b71e0c68192_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1614" data-rawheight="796" class="origin_image zh-lightbox-thumb" width="1614" data-original="https://pic3.zhimg.com/v2-7b564661d4e1d6693ed89b71e0c68192_r.jpg" />就上图例子来说，我们最后合并成的交易记录 “( 小A转账给盗盗10 btc + 小B转账给盗盗20 btc + 小C转账给盗盗 25 btc + 盗盗转账给盗盗15 btc ) 转账给张三40 btc ” 事实上等同于“盗盗转账给张三40 btc”。其中“盗盗转账给盗盗15 btc”就可以理解找零。第三步：发出去，让全球节点认同和备份小纸条这条内部重新处理过的复杂交易记录被塞进区块，埋到地下，等待节点挖出来，一旦区块被挖矿成功，并且该区块最终被连在了区块链的主链上。张三将最终拥有了这条交易记录，而先前的“小A转账给盗盗10 btc” 、“小B转账给盗盗20 btc” 、“小C转账给盗盗25 btc”都将被视为已经使用过的交易记录——从此被贴上“无效”的标签，意味着这些交易记录将永远不会再被追溯到。我们最后一次重申，只是希望让你加深印象：拥有数字货币=拥有交易记录！通过设计巧妙的精巧密码学保证数据安全记录着交易信息的小纸条借助区块这个载体，在分布式的网络中以不同的轨迹错综复杂的传递，我们前面说了，你真正拥有的数字资产实际上是一段交易信息，而不是你常规意义上理解的货币。所以这个过程就需要重点解决两个问题：接受到的这条交易记录在传输过程没有被其他人所篡改接受到的这条交易记录确实是由发起交易的人所创造在这里，我们需要事先引入两个知识点，可能稍微有点难消化，但都是计算机领域较为成熟的和基础的概念。第一个知识点：Hash()函数。你只需要知道，任意长度的字符串、甚至文件体本身经过Hash函数工厂的加工，都会输出一个固定长度的字符串；同时，输入的字符串或者文件稍微做一丢丢的改动，Hash() 函数给出的输出结果都将发生翻天覆地的改变。注意，Hash()函数是公开的，任何人都能使用。<img src="https://pic4.zhimg.com/50/v2-c9ae46fb889b14065f7988e3db803777_hd.jpg" data-size="normal" data-rawwidth="1622" data-rawheight="694" class="origin_image zh-lightbox-thumb" width="1622" data-original="https://pic4.zhimg.com/v2-c9ae46fb889b14065f7988e3db803777_r.jpg" />上图，仅仅一个小数点的变化，输出的结果已经翻天覆地第二个知识点：非对称加密。你也只需要了解，任何人手里都有两把钥匙，其中一把只有自己知道，叫做“私钥”，以及一把可以公布于众，叫做“公钥”；通过私钥加密的信息，必须通过公钥才能解密，连自己的私钥也无解。公钥可以通过私钥生成多把。有了这些知识点的加持，上面两个问题开始变得有解。下面我们来看下内部是如何扭转和工作的吧，这里拿“小A 转账给了小B 100元钱” 举例： <img src="https://pic2.zhimg.com/50/v2-5491adb338c4d680f05797525b452e6d_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1724" data-rawheight="1352" class="origin_image zh-lightbox-thumb" width="1724" data-original="https://pic2.zhimg.com/v2-5491adb338c4d680f05797525b452e6d_r.jpg" />第一步：小A会先用Hash函数对自己的小纸条进行处理，得到一个固定长度的字符串，这个字符串就等价于这张小纸条。第二步：小A使用只有自己知道的那一把私钥，对上面固定长度的字符串进行再加密，生成一份名叫数字签名的字符串，这份数字签名能够充分证明是基于这张小纸条的。你可以这么理解，在现实中，你需要对某一份合同的签署，万一有人拿你曾经在其他地方留下的签名复制粘贴过来怎么办？！最好的办法，就是在你每一次签名的时候，故意在字迹当中留下一些同这份合同存在某种信息关联的小细节，通过对小细节的观察可以知道这个签名有没有被移花接木。步骤一和步骤二的结合就是为了生成这样一份有且仅针对这条小纸条有效的签名。第三步：小A将「明文的小纸条」、刚刚加密成功的「数字签名」，以及自己那把可以公布于众的「公钥」打包一起发给小B。第四步：当小B收这三样东西，首先会将明文的小纸条进行Hash()处理，得到一个字符串，我们将其命名为“字符串1”。然后，小B使用小A公布的公钥，对发过来的数字签名进行解密，得到另外一个“字符串2”。通过比对“字符串1”和“字符串2”的一致性，便可充分证明：小B接受到的小纸条就是小A发出来的小纸条，这张小纸条在中途没有被其他人所篡改；且这张小纸条确实是由小A所编辑。可以看得出来，加解密的过程几乎是一环套一环，中途任何环节被篡改，结果都是大相径庭。借助这一连串的机制，其实已经能够很好的在公开、匿名、彼此不信任的分布式网络环境中解决数字交易过程中可能遇到的很多问题。这个环节可能确实有点难理解，现在，我需要你停下来，静下心，花上几分钟闭目慢慢回味其中设计精湛的地方。掌握了这部分知识以后，我们在这里回答一下前面没有解释清楚的问题，「节点对区块的检验」检验的到底是什么？实际上就是：检验区块内的交易记录签名是否准确（是否被篡改）检验区块内的交易记录输入值是否“有效”（是否使用过）检验区块内的交易记录输入值的数字之和是否大于等于输出值的数字…# 重回“区块”和“区块链”的世界好了，对小纸条和交易记录的研究我们点到为止，其实信息量已经是巨大的了，让我们合上盖子，重回较大实体、继续聊聊“区块”和“区块链”的话题。还记得，咱们在一开始讲到关于区块的特征吗？区块创造后被埋在地下，需要经过节点们马不停蹄的挖采、而且是凭运气的挖采才有可能获得——不仅仅如此，事实上他还有其他很多神奇的地方，比如说：凭空产生的区块在刚刚创建的时候会形成一股强大的黑洞效应，它会尝试将这段时间全世界各个节点上产生的所有小纸条（交易记录）统统吸进来；在合上区块盖子之前，同时会在区块内放上一些数字货币以及其他一些东西。区块拥有一个唯一的ID，但它只会在这个区块被节点成功从地下挖出来之后创建。这个ID至少会跟「区块内所有小纸条的集合」、「即将与之相连的上一个区块ID」以及「挖矿节点的运气值」等因素相关。既然前面我们已经简单了解了“Hash()函数”这个东西，这里不妨透露给大家：“区块ID = Hash(‘区块内所有小纸条的集合’+’即将与之相连的上一个区块ID’+‘挖矿节点的运气值’+’…’)” ；基于先前掌握的知识，然后你应该知道区块内任意一张小纸条的信息稍微做改动、或者节点挖矿运气好一点坏一点等等，当前区块的ID都会 “ biu~ ”的发生改变。基于上述1、2点，如果阅读足够仔细的同学可能会有些头大。在文章开头为了更好的描述，我在设计简化区块链系统的时候故意模棱两可了几个概念，这也许已经误导到了部分同学。这里不得不停下来和你一起修正下之前在你大脑中已经构建的区块链世界观。我们前面讲道，“在节点的视野里，大概每十分钟会凭空产生一个建立在自己平行宇宙世界的神奇区块”。如何正确去理解这句话呢？——拥有上帝之眼的你，可以这么拆解问题、看待问题：同一个周期内，全网并不是产生唯一的一个区块等待挖掘；每个节点事实上都在周期性的创造区块和挖出区块；只是在某一个节点的视野里，它不能感知到另外一个节点上区块的产生。为何这里要特别强调“在某一个节点的视野里”，就是因为我们刚刚讲到，从区块的视角来说，区块的凭空产生，是基于即将与之相连的上一个区块ID；而从节点的视角来看，区块的凭空产生是基于当前节点区块链末尾的那个区块ID产生的。全网会尽力控制在一个周期内只有一个节点能够成功挖出区块，但是不能够完全避免多个节点同时挖出区块的可能性；如何尽力控制？比如说，当大伙挖矿的热情高涨、工作效率提高，区块会被埋在更深更广的地方等。简而言之，通过提高工作难度，来维持这个平衡。另外，值得注意的：产生区块、挖出区块、校验区块，他们的时间周期近乎相同。挖矿，本质是通过与或运算，去碰撞一个出一个满足规则的随机数。这个部分要细讲的话，估计又可以写出两三千字来。我觉得到目前为止，并不影响主轴知识点的讲解，这一块会作为后续知识结构的完善被撰写（计划1月24日前完成）。感兴趣的同学可以Google百度查阅下什么叫“挖矿”、“工作量证明 POW”等。</p><br />
<br />
<p>分叉现在，我们终于对“区块”这个概念有了更全面的认识，文章开头讲的故事就可以继续展开来絮叨絮叨：假如几乎同一时间，「中国上海浦东新区张衡路」上的节点和「美国纽约曼哈顿第五大道」上的节点异口同声喊出来：“我挖到区块了！里面的小纸条都是有效的！奖励归我！”。其他节点也几乎同时参与了对这两个区块的校验，结果发现这俩都没毛病，各节点也开始犯困，因为在他们的视野里他们并不清楚最后哪一个区块应该会被主链接纳。算了！都连在自己区块链尾巴上吧，这时尴尬了，区块链硬生生的被分叉了！<img src="https://pic3.zhimg.com/50/v2-adf7653af863541e4cc811b04b86bd20_hd.jpg" data-size="normal" data-rawwidth="1392" data-rawheight="534" class="origin_image zh-lightbox-thumb" width="1392" data-original="https://pic3.zhimg.com/v2-adf7653af863541e4cc811b04b86bd20_r.jpg" />产生分叉你肯定在想，那还得了，这种情况继续下去，每个节点的区块以及他们整理维护的小纸条都将变得不一样，这已经严重违背了区块链世界里第一大最基本原则——所有节点共同维护同一份数据。所以，为了解决这个问题，区块链世界引入了一条新的规则——拥有最多区块的支链将是真正被认可有价值的，较短的支链将会被直接Kill掉。我们大伙都知道挖矿的过程存在巨大的工作量（如果没有任何难度，把区块扔在人群中，必然同一时间发现区块的节点数量将大大增加，也就会产生无数的支链，通过这个例子，你大概也就能够明白，区块链世界为什么需要设置工作难度了吧），并且在计算机的硅基世界里，不可能出现所谓 “同时” 的概念，哪怕纳秒的差别，那也总是会有先后顺序。所以理论上，“分叉”的这种僵局很快会在下一个区块被挖掘出来（以及校验区块）的时候被打破，实在不行下下个，或者下下下个……总之机制可以让整个分叉的区块链世界迅速稳定下来。<img src="https://pic3.zhimg.com/50/v2-ea23da89340837df3e6e0f6cd2d072d1_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1402" data-rawheight="980" class="origin_image zh-lightbox-thumb" width="1402" data-original="https://pic3.zhimg.com/v2-ea23da89340837df3e6e0f6cd2d072d1_r.jpg" />“分叉”这种僵局在确认下一个区块（以及校验小纸条）的时候被打破，从而整个区块链世界迅速稳定下来就上图而言，所有基于张衡路节点挖矿获得的区块以及后续区块的那条分支被视为有价值，最终会全部保留了下来；其他节点会统一效仿那个拥有更长分支链的节点所做的决策。另外，值得一提的是，同一时间，较短分支上的区块会立即丢弃，而里面的小纸条也会随之释放出来，被重新标记上“未确认”。“双花”与“51%攻击”你可能已经开始困惑或者有点兴奋，末尾几个区块的排序在修复过程中，因为时间差肯定会产生一些模棱两可的地方，这往往会给数据安全埋下一颗雷。一个最简单的假设——我记录的一张小纸条很不巧地被归在了一条较短的支链上，这条支链在竞争过程中理所当然输掉了比赛，区块被丢弃、小纸条被无情的贴上“未确认”的标签。在等待下次区块重新确认的过程中，这个时间差内，我，好像、似乎可以做点什么坏事 ԅ(¯﹃¯ԅ) ，就比如说“双花”（双花，花两次，双重支付的意思）你脑海中也许很快浮过的这样的构想，可不可能通过下面这种方法触发双花问题的产生，从而让我不劳而获：<img src="https://pic4.zhimg.com/50/v2-82f01cc16cbd1f3227ae107fb75723db_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1592" data-rawheight="994" class="origin_image zh-lightbox-thumb" width="1592" data-original="https://pic4.zhimg.com/v2-82f01cc16cbd1f3227ae107fb75723db_r.jpg" />假设有一个名叫X-Man的坏家伙，他控制了一个计算机节点，这个节点拥有比地球上任何一个节点算力都强大的计算机集群。首先，X-Man事先创造了一条独立的（不去广而告之）、含有比较多区块的链条。其中一个区块里放着“X-Man转账给X-Man 1000元”的纸条。接着，X-Man跟张三购买了一部手机，他在小纸条上记录下“X-Man转账给张三1000元”；这条信息被三次确认后（即三个区块被真实挖出、校验和连接），然后，张三把手机给了X-Man。X-Man拿到手机之后，按下机房的开关，试图将先前已经创造的区块链条连接在自己这个节点区块链的末尾。大功告成，X-Man拥有了一条更长的区块链条，那些较短、存放着“X-Man转账给张三1000元”的区块链，以及在区块链世界里那则真实转账行为被一同成功销毁。（?）事实真的如此吗？在这里我可以很负责任的说，too young too simple，区块链世界规则的制定远比我们想象的要健全很多，还记得我们之前讲的“区块的ID至少会跟区块内所有小纸条的集合、即将与之相连的上一个区块ID以及挖矿节点的运气值等因素相关”。 在这里，正是因为打算连接到主链的时候，事先准备的链子会意识到马上要连接上的那个区块ID发生了改变，随之而来的是后面所有区块ID都瞬间。节点不得不重新对后续区块的解锁以及对区块内小纸条的校验。 <img src="https://pic2.zhimg.com/50/v2-5ac7eb9be1b35362b75443020e59974a_hd.jpg" data-caption="" data-size="normal" data-rawwidth="1646" data-rawheight="980" class="origin_image zh-lightbox-thumb" width="1646" data-original="https://pic2.zhimg.com/v2-5ac7eb9be1b35362b75443020e59974a_r.jpg" />在区块链的世界，重新计算的行为等同于把自己（节点）置身于同一个起跑线，跟世界上其他所有的节点一同竞争挖矿。你会说，我拥有更强大的计算能力，但是对不起，跟你竞争的对象并不是第五大道、南京西路、香榭丽舍大道上的某一个节点，而是全球所有算力的集合，在这个集合中，你拥有的算力永远都只是一个很小的子集。所以，根据区块链算力民主、少数服从多数的基本原则，这个构想将永远不会成立。除非….你控制着全球51%的算力，这也就是区块链世界里另外一个著名的概念，叫做“51%攻击”，但这也仅仅是一个理论值，在真实世界里这样的攻击我个人觉得是很难发动起来的，这里面就牵涉到很多经济、哲学甚至政治的因素。举个最简单的例子：X-Man为了回滚刚刚发生的一笔交易记录，成功发起了51%攻击，这意味着很快整个区块链系统将会崩盘，因为这次攻击已经严重伤害到人们对这套系统的信任，接着比特币开始暴跌至几乎一文不值；但是这个拥有51%算力的X-Man原本完完全全可以通过挖矿的方式获取更多收益，购买无数的iPhone手机。那他不是脑袋不是坏了还能是啥？</p><br />
<br />
<p>去中心化的系统中，到底是谁在发行货币？是无限量发行吗？<br />
比特币的货币是通过挖矿（工作量证明）来发行的，总数量是通过程序写死了2100万个，而第一笔区块奖励也是硬编码写死的。矿工挖出一个区块所获得的奖励，每隔21万个区块将减少一半，按照平均10分钟挖出一个区块的执行效率，也就就说差不多每四年会锐减一次。2009年1月起每个区块奖励50个比特币，2012年11月减半为每个区块25个比特币，2016年7月减半为12.5个比特币。基于这个规则，到2140年，所有比特币(20,999,999,980)将全部发行完毕，之后不会再有新的比特币产生。</p><br />
<br />
<p>矿工节点的收益除了挖出区块以外还有哪些？<br />
矿工节点的收益主要由两部分组成：1）挖出新区块的奖励；2）挖出新区块内所含交易的交易费。但就目前来说，一个区块内的交易费大概只占到矿工总收入的0.5%甚至更少，大部分收益主要还是来自于挖矿所得的比特币奖励。然而，随着挖矿奖励的递减，以及每个区块中包含的交易数量增加，交易费在矿工收益中所占的比重将会逐渐增加。在2140年之后，所有的矿工收益将完全由交易费构成。</p><br />
<br />
<p>一、什么是51%攻击？</p><br />
<br />
<p>一提到对比特币的攻击，大部分人想到的就是51%攻击。所谓51%攻击，就是利用比特币使用算力作为竞争条件的特点，使用算力优势撤销自己已经发生的付款交易。如果有人掌握了50%以上的算力，他能够比其他人更快地找到开采区块需要的那个随机数，因此他实际上拥有了绝对哪个一区块的有效权利。</p><br />
<br />
<p>矿池发动51%攻击的可能是否微乎其微©</p><br />
<br />
<p>他能够：<br />
1、修改自己的交易记录，这可以使他进行双重支付<br />
2、阻止区块确认部分或者全部交易<br />
3、阻止部分或全部矿工开采到任何有效的区块<br />
但是他无法做到：<br />
1、修改其他人的交易记录<br />
2、阻止交易被发出去（交易会被发出，只是显示0个确认而已）<br />
3、改变每个区块产生的比特币数量<br />
4、凭空产生比特币<br />
5、把不属于他的比特币发送给自己或其他人</p><br />
<br />
<p>二、一个典型51%攻击案例</p><br />
<br />
<p>如果我有整个网络51%的计算速度，我可以计算出一个这样的区块链，包含我发送所有的比特币到我的私人账户上这个交易信息。这个区块链的长度为10，但是我不向网络广播。同时，我把所有的比特币在交易市场换成美元并提取出来。这笔交易记录在正常的那个区块链中。</p><br />
<br />
<p>当我的美元提取正在进行中的时候，那个正常的区块链的长度是9，而我的区块链长度是10。现在我向网络广播出去，然后观察，网络会确认我的区块链是正确的。</p><br />
<br />
<p>但是美元已经被我提取了，损失的是交易市场。</p><br />
<br />
<p>我也可以用这种方式拿比特币买任何东西。如果这样的事情发生个几次，对比特币将是致命的，至少会严重的伤害人们对这个系统的信任度。</p><br />
<br />
<p>比特币发动51%攻击具体思路大致如下：</p><br />
<br />
<p>准备工作：</p><br />
<br />
<ol><br />
  <li><br />
    <p>既然是51%攻击，就必须首先掌握足够的算力，无论是控制矿池，还是利用其它计算资源，总之必须使你的算力领先与现在网络总算力，领先的幅度越大，成功的可能性越高;</p><br />
  </li><br />
  <li><br />
    <p>拿到足够的BTC作为筹码，无论是自己挖到的，还是从任何渠道买的，都可以;</p><br />
  </li><br />
</ol><br />
<br />
<p>攻击步骤：</p><br />
<br />
<ol><br />
  <li><br />
    <p>将手中的BTC充值各大交易所，然后卖掉，提现;或者也可以直接卖给某人或某一群人;</p><br />
  </li><br />
  <li><br />
    <p>运用手中的算力，从自己对外付款交易之前的区块开始，忽略自己所有对外的付款交易，重新构造后面的区块，利用算力优势与全网赛跑，当最终创建的区块长度超过原主分支区块，成为新的主分支，至此，攻击完成;</p><br />
  </li><br />
</ol><br />
<br />
<p>攻击结果： 由于撤销了所有对外付款交易，等于收回来所以已卖掉的比特币。</p><br />
<br />
<p>可行性评估： 现在比特币全网算力差不多90T，而且还会快速增长，现在看来只有现在的几大矿池联合，才具有发动51%攻击的实力，普通个人或机构实施此攻击的可能性越来越小。</p><br />
<br />
<p>三、51%攻击成功可能性大吗？</p><br />
<br />
<p>过去几年比特币网络的算力悄无声息的增长到了无比之大，这大大增加了比特币成功的可能性。反之也可以解释为什么山寨币不靠谱，太容易被51%攻击啦。在依赖密码学的数字货币领域，先发优秀是非常明显的。所以51%攻击对于比特币来说并不是一个什么大问题（早在2013年7月，比特币全网算力已经达到世界前500强超级计算机算力之和的20倍），即使有政府集全国之力秘密造出一台超级计算机，用来击溃比特币来挽救自己的货币发行体系，它会发现使用该能力进行挖矿便可垄断比特币的发行权，其收益远大于击溃比特币，动机也就不复存在了。</p><br />
<br />
<p>参考中心化与去中心化 https://www.douban.com/note/624421270/图说区块链 https://book.douban.com/subject/27084306/区块链是什么，如何简单易懂地介绍区块链？ https://www.zhihu.com/question/37290469 什么是比特币51%攻击？ http://8btc.com/article-1949-1.html区块链与新经济：数字货币2.0时代 https://book.douban.com/subject/26804497/詳解比特幣原理和運行機制 https://www.youtube.com/watch?v=P4seQcP77H4区块链是什么：从技术架构到哲学核心 https://v.qq.com/x/page/x0518nuh2z7_0.html区块链核心算法解析 https://book.douban.com/subject/27081206/深入理解比特幣的安全性及程式交易安全性與相關的密碼學原理 https://www.youtube.com/watch?v=3w1Tg3B_oKQ 深度了解区块链——拜占庭将军问题深入探讨 https://wallstreetcn.com/articles/338061精通比特币-挖矿与共识 http://zhibimo.com/read/wang-miao/mastering-bitcoin/Chapter08.html</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>为什么会出现这样的用工荒，其实原因很简单，就是懂区块链的太少了，先给大家普及一下区块链的知识。区块链技术是指通过去中心化和去信任的方式集体维护一个可靠数据库的技术，可以用4个关键词去形容：去中心化（Decentralized）、去信任（Trustless）、集体维护（Collectively maintain）、可靠数据库（Reliable Database）。区块链又分为以下几种：1、公开区块链(public blockchain) 例子：比特币，Ethereum Frontier。公开区块链上的数据所有人都可以访问，所有人都可以发出交易等待被写入区块链。共识过程的参与者（对应比特币中的矿工）通过密码学技术以及内建的经济激励维护数据库的安全。公开区块链是完全的分布式。2、协作区块链(federated blockchain) 例子：Hyperledger以及德勤等会计所尝试的审计系统。参与区块链的节点是事先选择好的，节点间很可能是有很好的网络连接。这样的区块链上可以采用非工作量证明的其他共识算法，比如有100家金融机构之间建立了某个区块链，规定必须67个以上的机构同意才算达成共识。这样的区块链上的数据可以是公开的也可以是这些节点参与者内部。部分意义上的分布式。3、私有区块链(private blockchain) 例子：Eris Industries。参与的节点只有用户自己，数据的访问和使用有严格的权限管理。近期部分金融机构公布的内部使用的区块链技术大都语焉不详，不过很可能都在这个范围内。关于区块链本身的知识就说到这里吧,网上和知乎上有很多的文章在介绍，我就不在此累赘了。因为自己最近也在学习研究区块链，接下来就给大家分享一下自己关于区块链学习的一些经验。以下共3种学习的方式，大家可以根据自己的实际情况去选择：（1）看书；（2）看视频；（3）找人带或者参加培训第一：看书给大家说一些自己曾经看过的，感觉比较有价值的书目（1）.《精通比特币》原版名《Mastering Bitcoin》，了解比特币的最佳之选。在线阅读：介绍</td><br />
      <td>精通比特币（2）.《区块链——从数字货币到信用社会》 了解区块链概念的不错的一本书，多位行业大咖倾力合作而成。（3）.《深入浅出以太坊》  对以太坊研究较深的汪晓明所做，可以系统了解和学习以太坊。(4).《区块链开发者指南（待出版）》 期待已久，由申屠青春和汪晓明两位行业大牛主编，可以盯着，出版买一本学习学习。除了看书，再给大家推荐一些文章（1）【区块链之菜鸟入门】系列文章1）亲，你淘的区块链到了！2）区块链发展史：从拜占庭将军问题到智慧契约 3）来来来，这篇科普告诉你“区块链”到底是个啥？ 4）区块链——颠覆式创新技术 （2）【区块链之技术进阶】系列文章1）区块链：通往互联网第二纪元的革命 2）金融的未来，区块链将用于何方？3）让这篇技术贴告诉你区块链是怎么运行的4）扒一扒某乎上面对于区块链的理解（一）5)扒一扒某乎上面对于区块链的理解（二）6）从技术现实理解区块链：基于SQL模型创建BQL7）掰一掰区块链共识机制与分布式一致性算法8）Attention please！区块链技术的风险！ （3）【区块链之技术实战】系列文章1）群雄激辩区块链2）颠覆银行基础架构的区块链3）在金融领域，区块链该咋用呢？4）区块链开源项目合集：Hello，BlockChain！5）有了区块链做公益，再也不用担心我的捐款啦 4）【区块链与未来】系列文章 1）区块链只与互联网+金融有关？让法律人和你聊聊 2）“区块链+”火花四溅的未来 3）&amp;quot;公共记账簿&amp;quot;？哼，区块链远比你想象的强大的多 4）区块链技术将重塑我们的世界第二：看视频（1）火币网李林的区块链是什么http://m.youku.com/video/id_XMTQwODE4NDAyNA==.html?spm=a2h0j.8191439.Recommend.1~3!2~A（2）比特币原理概要–非技术版http://video.8btc.com/video/34555（3）比特币底层原理 http://video.8btc.com/video/31288（4）以太坊技术视频系列(汪晓明)   http://ethcast.com/（5）小蚁的价值体现在哪里 https://m.v.qq.com/x/page/c/m/v/c0319zih9mv.html?ptag=v.qq.com%23v.play.adaptor%232&amp;amp;mreferrer=http%3A%2F%2Fv.qq.com%2Fvplus%2Fbec429068169e2ea1599f137e94888bc%3F_wv%3D1031第三：找人带或者参加培训（1）小蚁开发学院技术出身的可以去小蚁开发学院https://www.antsh.org/school，适合有一定基础的开发工作者去学习。（2）朵朵学院老蘑菇独撑的朵朵学院http://www.wanbizu.com/p/37467.html，在淘宝可以买到系列教程，课程不贵，对大家还是比较有用的。（3）海绵学堂海绵学堂www.51haimian.cn是最近刚发现的一所线下培训机构，号称是全国首家做区块链培训的机构，比较适合系统的学习一下区块链，找个老司机带，上手会快一些，入行容易些。</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>1、加密货币<br />
在一步一步发明发明比特币之前，解释几个直观的认知：</p><br />
<br />
<p>我们常说的比特币，是加密货币（Cryptocurrency）的一种，而加密货币实现去中心化的最关键的技术是区块链</p><br />
<br />
<p>有些地方可能把加密货币又称为数字货币（或称电子货币），但实际上，加密货币是数字货币的子集，同为子集的还有虚拟货币（如Q币），加密货币的称谓要更加专业</p><br />
<br />
<p>加密货币一定具有下列三个特点</p><br />
<br />
<p>去中心的清算<br />
分布式的记账<br />
离散化的支付<br />
为了实现这些特点，需要使用到区块链技术。这里的区块链技术是一个很广义的范畴，它包含了密码学，算法等很多不同的内容，其中最精彩的点子，可算是工作量证明 = 共识信用了</p><br />
<br />
<p>2、一步一步发明比特币<br />
2.1、第一个用户需求 - 账本和电子签名的由来<br />
第一个用户需求描述了中心化清算系统几个关键内容的由来，只对区块链感兴趣的读者可以跳过<br />
经济体的蓬勃发展离不开交易。在交易过程中，人们早已发现使用一般等价物（如金银）十分麻烦，发明了纸币（最早的来自中国，北宋时代四川地区的纸币交子的清算体系，是生产力发展的必然产物，最终的目标是提高生产效率），现如今，人们发现，携带现金也很麻烦</p><br />
<br />
<p>这是第一个基本用户需求：摆脱现金进行交易带来的不便</p><br />
<br />
<p>【解决办法】几个用户使用公共账本记录转账记录，月底结算，账本公开，每个人都可以修改，也就是说可以在上面添加新行（一笔交易），如小明转账给小红10块钱</p><br />
<br />
<p>2.1.1、产生的问题1：身份问题<br />
在这个账本条目上我们无法确认交易双方小明和小红是否是本人，可能出现伪造（逍遥法外电影中的伪造支票）</p><br />
<br />
<p>【解决办法】使用电子签名，即公钥 - 私钥对</p><br />
<br />
<p>记住，电子签名被发明的核心目的是希望在电子文档也能有一个类似与现实中个人笔迹的签名，目的一定是：确认写这个签名的人是本人，即身份确认（验证）</p><br />
<br />
<p>私钥顾名思义，也叫做密钥，是你本人需要需要妥善保管和保存的</p><br />
<br />
<p>Sign(\text{信息},私钥) = \text{电子签名}</p><br />
<br />
<p>Sign在这里是一个函数，可以理解为一连串计算（变换），这一连串计算有一个特点，就是输入值只要改变一点点，输出就会完全改变。信息和私钥一起，可以得到一个电子签名。并且这个电子签名不能被轻易的复制到其他信息里，原因是因为每一个电子签名都和这一段信息有关联。</p><br />
<br />
<p>Verify(\text{信息},\text{电子签名},\text{公钥}) = \text{真/假}</p><br />
<br />
<p>在进行验证的时候，Verify也是一个函数，输入值是信息，电子签名，公钥，输出是一个True or False，来判断这个电子签名是真的还是假的。</p><br />
<br />
<p>这个时候可能有人就要问了，这个电子签名我难道不能试出来吗？很不幸，这是一个有256bit的1/0字符串，可能性是 2^{256} ，无穷大。</p><br />
<br />
<p>解释完电子签名，我们来看看实例。小明使用自己的私钥加上小明转给小红10块钱的文字通过Sign函数生成一个签名（256位），把签名放在这条转账信息的后面，通过之前的讲解，这个签名就能保证小明已经过目了，并且说：“这真的是我小明，不用怀疑了！肯定是我”</p><br />
<br />
<p>直观结果是，我们可以利用密码学的手段，只要有对应人的数字签名，我们保证小明和小红的身份能被100%确认真实</p><br />
<br />
<p>但是这个解决方案有一个小漏洞：可以复制同一行信息来伪造交易记录，解决的办法是添加一个这笔交易独有的信息（比如时间戳）</p><br />
<br />
<p>2.1.2、产生的问题2：欠债跑路问题<br />
如果小明在此时账户上已经没有足够的余额进行支付，就会出现超支问题</p><br />
<br />
<p>【解决办法】添加余额记录，此时就不可避免的需要一个中间担保人（国家？信誉机构？银行？）为小明进行余额担保</p><br />
<br />
<p>2.1.3、一个大家都遵守的协议<br />
此时，现代金融体系的框架基本建立完毕，协议内容是</p><br />
<br />
<p>任何人都可以在账本上添加新行<br />
固定时间间隔时用真金白银进行清算<br />
只有有签名的交易是有效的<br />
中间担保的人保证不可超支<br />
此时发现一个很有趣的结论，这个比较严谨的协议有一个特点：如果所有人都按照这个协议来办事，我们可以用任何形式的东西来代替人民币了，换句话说，就是我根本不关心你在账本上添加的新行的交易内容是什么，可以是任何东西</p><br />
<br />
<p>利用这个提出需求再解决问题的过程，强化一个认知：货币 = 交易记录（账本），即货币的本质是交易记录，在这背后，有一个前提是，货币的另一个本质是一种共识，我们都信任它有价值的共识</p><br />
<br />
<p>2.2、第二个用户需求：账本放在哪里？<br />
传统的（现在的）解决方案当时是，使用中心代理-银行，来存放账本</p><br />
<br />
<p>既然是第二个用户需求，那肯定就是因为现在的解决方案大家都不满意</p><br />
<br />
<p>2.2.1、核心需求：去中心化<br />
中心化的痛点大致可以说几点</p><br />
<br />
<p>银行效率低下，一笔跨国转账的等待时间较长<br />
胖银行金融体系因部分准备金制度等等方便的规则，能抬升杠杆，产生金融泡沫，进一步诱发金融危机<br />
私有财产神圣不可侵犯是精英与平民，剥削与被剥削者几个世纪以来博弈的风暴中心<br />
当然还有很多没有提到（比如好处，控制经济发展速度，调控供需平衡等），总之，是一种一直饱受诟病的清算方式，此时，中本聪在2009年横空出世，他提出了一种全新的清算方法，并且真正解决了陌生人间信用的问题！接下来就是真正的一步一步的发明比特币了</p><br />
<br />
<p>2.2.2、如何实现分布记账（去中心化）<br />
为了去中心化，我们可以反其道而行之：每个用户保存账本，分布记账。用户产生一笔交易就将这笔交易广播到到网络上所有的节点上，这样不就完美的去中心化了？</p><br />
<br />
<p>只要是明眼人都能发现，太天真的，这个方法行不通。若行不通，那就把行不通的原因总结出来</p><br />
<br />
<p>遇到问题，总结不可行的原因，寻找解决方案。这是整个人类不断前进的核心最小单位<br />
2.2.2.1、问题核心<br />
如何让所有人都同意这个新账本？如何保持这些账本同步？有一笔交易发生时，如何让其他人都听到并相信这一笔交易呢？</p><br />
<br />
<p>这些问题才是真正的核心：是否能在协议（办法，规则）中添加几行，找到办法，来决定是否接受交易，并确定交易顺序，使你可以放心的相信，世界上遵守同一协议的所有人手上的账本都和你的一模一样呢？（问题描述值得品读，只有抽象出问题才能更好的去寻找解决方案）</p><br />
<br />
<p>2.2.2.2、☆解决方案<br />
解决的思路是：哪个账本的计算工作量大，就信任哪个账本。换个角度来说是【让交易欺诈和账本不一的情形的计算力成本高到不能接受甚至完全不可行】</p><br />
<br />
<p>1、密码学：哈希函数</p><br />
<br />
<p>哈希函数，输入可以是任意信息或者文件，输出是固定长度的比特串。例如256bit的1/0串，这个输出叫做这个信息的“哈希值”或者“摘要”（digest）。SHA256就是一个哈希函数</p><br />
<br />
<p>密码哈希函数有几个特点</p><br />
<br />
<p>特点是输入值稍微变化后，结果就会有很大的不同，完全无法预测不同输入间的规律<br />
逆向计算不可行，只能使用试错法（穷举法），解空间2^{256}<br />
在每一个账本后添加一个特殊数字，对整个列表使用SHA256，我们要求这个特殊数字可以使得输出值的开头有30个零（关于如何确定0的个数问题，在后面部分有详细的说明）</p><br />
<br />
<p>根据之前说过SHA256的性质：输入变化输出不可预测，找到这个特殊数字唯一的办法就是穷举。换言之，你很容易就证明了他们进行了海量的计算。而这个特殊数字就叫做工作量证明（proof of work）</p><br />
<br />
<p>这就意味着，所有的工作量证明就对应了交易列表（账本 Ledger），如果你修改了一个交易，哪怕只是其中一个字符，就会完全改变哈希值，就得重做工作量证明，直观动图如下</p><br />
<br />
<p>2、区块链 - 信任与共识的基石</p><br />
<br />
<p>每一个小账本被称为区块，每一个不同的区块链协议（产生不同的加密货币）都会规定每一个区块的大小（最初比特币为1M）</p><br />
<br />
<p>账本组成区块，区块构成链表，区块的头包含前一块的哈希值，这就是区块链</p><br />
<br />
<p>如此一来，任何人就不能随意修改其中的内容，或者交换顺序。如果你这么做，意味着你需要重新计算所有的特殊数字</p><br />
<br />
<p>规定，允许世界上的每一个人建造区块。每一个新建区块的人（找到了这个特殊数字 - SHA256值有30个零）都能获得奖励，对于新建区块的这部分人（矿工）来说</p><br />
<br />
<p>没有发送者信息，不需要签名<br />
每一个新区块都会给整个币种增加新的虚拟（加密）货币<br />
新建区块的过程又被称为“挖矿”：需要大量工作量并且可以向整个经济体注入新的货币<br />
挖矿的工作是：接受交易信息，建造区块，把区块广播出去，然后得到新的钱作为奖励<br />
对每个矿工来说，每个区块就像一个小彩票，所有人都在拼命快速猜数字，直到有一个幸运儿找到了一个特殊数字，使得整个区块的哈希值开头有许多个零，就能得到奖励。我记得有一个知乎答主给了一个形象的比喻，区块链就像一个拥有貌美如花女儿（区块）的国王，有很多的青年翘首以盼，而国王的方法是出了一道很难得题目让所有的青年计算（学习改变人生），谁算的快（在计算哈希值过程也可能是运气好）就能抱得美人归<br />
对于想用这个系统来收付款的用户来说，他们不需要收听所有的交易，而只要收听矿工们广播出来的区块，然后更新到自己保存的区块链中就可以了<br />
3、51%算力-共识攻击</p><br />
<br />
<p>这里有一个小漏洞，因为网络的延迟或者有人在篡改区块链等因素，你作为一个收听网络广播的用户，如果同时接受到两条不同的区块链怎么办？其中的交易信息发生了冲突</p><br />
<br />
<p>注：区块链本身就是最终的大账本，发生交易的唯一方法就是把你的交易加入到大账本上。具体来说，就是让矿工把你的交易记录加入它新挖到的区块中，并把这个区块链接到区块链上。链表的纽带，当然就是工作量证明<br />
对于上面的问题，用户的解决方案也比较简单：即，只保留最长的，也就是包含的工作量最大的那一条</p><br />
<br />
<p>这里有一个Trick，即所谓信任工作量最大不仅仅是出【一道难题】，还通过等待多个区块的产生引入世界上所有矿工之间的博弈（吃瓜群众，坐看大戏，谁厉害我选谁，你们尽管斗）</p><br />
<br />
<p>个人观点：区块链的Idea最核心的创新就是从技术上把信任和贪婪画了等号。因为贪婪（希望去竞争建立区块的建立和交易费）所以信任（全网算力越大，用户越放心），这句话甚至带上了些许哲学和传奇的色彩</p><br />
<br />
<p>对于用户来说，是这样一种情景</p><br />
<br />
<p>其中的原因是，你可以假设Alice希望篡改一个交易信息，那么就意味着Alice需要不断的通过计算维护这个区块链了。也就是说每一次有新的区块链产生，Alice都需要不断的抢到这个彩票，理论上来说，他至少必须拥有全网51%以上的算力才能做到这一点，更多的，随着用户等待区块的增加，这个难度，幂次上升，在7-8个区块链产生后，概率上来讲，就是绝对信任</p><br />
<br />
<p>此时</p><br />
<br />
<p>我们用数字签名保证了不能伪造交易记录<br />
用区块链及工作量证明保证了不能篡改其中的信息<br />
这两点，就完成了：证明区块链的每一条交易记录都是可信的这一终极目标</p><br />
<br />
<p>2.2.3、总结 - 系统可行性分析<br />
只需给出一个命题来思考：我们如何才能在这个系统下骗人呢？</p><br />
<br />
<p>如果你想篡改一笔不存在的交易记录，那么你必须比所有人都算的快，赢得这个彩票<br />
但所有用户会继续收听其他矿工的广播<br />
所以为了让所有用户继续相信这个伪造的区块<br />
你必须投入自己所有的工作量，不断给篡改后的区块链分叉增添新的区块<br />
记住：根据协议，所有用户会一直信任他所知道的最长的链<br />
是的，你持续的竞争过世界上所有的矿工的概率或者说代价，实在太大了，得不偿失（其实法律也是一样的道理，它强制给违法的人给予惩罚，让违法者付出他们不能承受的代价了保证公平和社会稳定运行）<br />
注意，作为一个用户，你不能立马相信你所听到的最新区块，而是应该等待多几个区块被创建过后，再确认这的确是世界所有人都在使用的区块链<br />
2.3、发明过程中的关键点<br />
电子签名 Digital Signatures<br />
公共账本就是货币 The Ledger is the currency<br />
去中心化 Decentralize<br />
工作量证明 Proof of work<br />
区块链 Block Chain<br />
3、比特币技术<br />
到这里，已经发明了比特币，解决了去中心化的信任这一难题。只对比特币和区块链是什么这个问题感兴趣的读者，可以停在这里了，希望大家可以在我的叙述中解决一些困惑！鞠躬！</p><br />
<br />
<p>针对比特币的一些实现的内在细节，继续在探索和学习的道路上披荆斩棘。新技术，新点子，要拥抱它，使用它，判断它，必须先追根究底了解它。</p><br />
<br />
<p>我们知道区块链中记载的核心内容，对于比特币（加密货币）来说就是转账记录。但是，一个概念真正落地成大众可以用的服务，有很多技术上，协议上的细节。接下里的部分主要探讨一些比特币具体实现方面的细节，如网络节点构成，比特币的计算难度系数，比特币总量的由来，比特币一笔交易发生的内部细节等</p><br />
<br />
<p>3.1、比特币网络节点的构成<br />
比特币网络是一种点对点的数字现金系统（P2P），网络节点中每台机器都彼此对等。P2P网络不存在任何服务端、层级关系或者中心化服务。</p><br />
<br />
<p>3.1.1、节点类型与分工</p><br />
<br />
<p>一个全功能节点包含上述4个模块【钱包Wallet】【矿工Miner】【完整区块链fullBlock-chain database】【网络路由节点Network routing】</p><br />
<br />
<p>【网络路由节点】使得节点具有参与验证并传播交易与区块信息，发现监听并维持点对点的链接的能力<br />
【完整区块链】具有此模块的节点被称为：全节点。它能够独自自主的校验所有交易，不需要任何其他信息。<br />
【钱包】比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的，数字密钥实际上并不是存储在网络中，而是由用户生成并存储在一个文件或简单的数据库中，称为钱包。有些节点仅仅保留区块链的一部分，通过一种”简易支付验证“（SPV Simplified Payment Verification）的方法来完成交易<br />
【矿工】挖矿节点以相互竞争的方式创造新的区块。有一些挖矿节点也是全节点，可以独立挖矿；还有一些参与矿池挖矿的节点是轻量级节点，必须依赖矿池服务器维护全节点进行工作<br />
拥有全部四个模块被称之为核心客户端（Bitcoin Core），除了这些主要节点类型外，还有一些服务器及节点运行其他协议，如特殊矿池挖矿协议、轻量级客户端访问协议。</p><br />
<br />
<p>下表为扩展比特币网络的不同节点类型</p><br />
<br />
<p>3.1.2、扩展比特币网络<br />
要在全世界的网络中完成整个的交易，下图描述了一个扩展比特币网络，它包含了多重类型的节点、网关服务器、边缘路由器、钱包客户端以及它们互相连接所需要的各类协议，比特币互相连接的接口一般使用8333端口</p><br />
<br />
<p>可以参看这个文章了解Stratum协议，Stratum协议详解<br />
http://www.8btc.com/stratum_protocol</p><br />
<br />
<p>3.2、如何控制区块产生速度恒定<br />
3.2.1、难度系数<br />
我们在发明比特币的过程已经详细说明了工作量证明寻找一个特殊数字使得SHA256函数的输出字符串的前n位是零</p><br />
<br />
<p>对于每一种不同的加密货币来说，都有一个值需要在建立货币的时候时候被定义，即每一个新区块在当前全网算力的条件被发现的【平均时间】，这也是难度系数的由来</p><br />
<br />
<p>比特币10分钟；以太坊15秒；瑞波币3.5秒；莱特币2.5分钟<br />
抛开代码算法层面来说，实现方法就是通过找前n位是0的方法。从概率角度来说，n值越大，意味找到这个这个数的解范围越小。</p><br />
<br />
<p>随着需求0的数目一个一个增加，需要的计算时间将会程指数增长。</p><br />
<br />
<p>那么肯定会问，这个难度值如何动态调整？由谁调整？</p><br />
<br />
<p>3.2.2、难度调整方式<br />
难度的调整实在每个完整节点中自动发生的。如果网络发现区块产生速率比10分钟要快时会增加难度。如果发现比10分钟慢时则降低难度。</p><br />
<br />
<p>例如比特币中的是这样定义的：每2016个区块后计算生成它们花费的时长，比上20160（14天）调整一次。有人可能会问，如果在这十四天内计算能力暴涨怎么办，其实这个10分钟的区块新建间隔的规定也只是一个估计要求，真实情况下，这个时间会偏离10分钟这个设定值很多，但是这种偏差并不会对整个区块链的运行产生影响</p><br />
<br />
<p>3.3、比特币总量的由来<br />
我们已经知道，矿工没新建一个区块就可以得到一定数量的比特币作为奖励，最开始，一个区块可以得到50BTC的奖励，之后每210000个区块，奖励减半，直到2140年，所有的比特币将会发放完毕，可以得到公式Total = 210000 \times(50 + 25 + 12.5 + \ldots) = 20999999980 \approx \text{2100万}</p><br />
<br />
<p>而这个规则不同的竞争币种都可以自由设置。但是因为交易费的存在，挖矿的人还是会有收益，否则无法建立新的区块，那么整个比特币网络就瘫痪了</p><br />
<br />
<p>3.4、比特币的交易处理能力<br />
3.4.1、现在比特币区块链的区块信息<br />
我现在直接从BLOCKCHAIN上，在我写下这句话的时候，最新的区块是情况</p><br />
<br />
<p>其中的重量是指的实际存储的大小，这个值和交易协议有关，其实可以忽略。非常幸运的是，这几个区块放佛是专门为讲解这一节而出现的，这可能是天意吧</p><br />
<br />
<p>另外插一句，你会发现平均区块建立间隔时间，的确和10分钟这个设计值差距很大吧</p><br />
<br />
<p>3.4.2、区块容量<br />
比特币从被创建时，或者说源代码中规定了，区块容量是1M。最初设计成1M的原因一方面，防止DOS攻击。另一方面，当年中本聪在创建区块链的时候的容量是32M，但是他通过一个说明为”Clear up“这样毫不起眼的Commit把区块容量改成了1M，为防止区块链体积增长过快，为区块容量这个问题添加了些神秘色彩。好吧，我承认，中本聪就已经非常具有神秘色彩了，是在神秘色彩上添上了些故事</p><br />
<br />
<p>通过上表我们知道，1M的容量意味着比特币最大的处理交易数量在约2400（486882区块1034.39的大小很接近了），在给出一张时间和每秒交易数量的关系图表(交互表格点击链接)</p><br />
<br />
<p>这是一张对数图，纵坐标是每秒交易数量，横坐标是时间。其中，蓝色圆圈的大小代表的是比特币内存池（mempool）的大小（交易在等待矿工处理之前都会暂时存在这里）。<br />
一句话总结，这是一个拥堵的网络，已经重负不堪。</p><br />
<br />
<p>再来看一张比特币交易费和区块使用率之间的关系图(交互表格可以点击链接)</p><br />
<br />
<p>蓝色的圈大小是Mempool的大小。横坐标是区块容量的使用情况，纵坐标是每一个区块的可以得到的交易费用。<br />
手续费随区块使用率开始增长，甚至出现了4BTC一个区块2400笔交易的情况，意味着挖到这个区块的人通过交易费得到的汇报接近了本身建立区块的回报</p><br />
<br />
<p>有一个结论是，扩容后，因为每一个区块的交易承载量增加，矿工的交易费收入肯定会减少。因为，通过上表可以发现，只有当区块使用程度接近95%时候，交易费才有明显的增长</p><br />
<br />
<p>再看一张用户执行交易需要等待的时长和区块使用比例间关系的图表(交互图表点击链接)</p><br />
<br />
<p>蓝色的圈大小是Mempool的大小。横坐标是区块容量的使用情况，纵坐标是用户平均需要等待的时间，单位是分钟。<br />
通过上面三张表我们可以知道，矿工的计算力是整个区块链信用的基石（记住贪婪=信任），所以对矿工的激励不能少，而对于用户来说，当然希望自己的交易越快速完成越好。</p><br />
<br />
<p>对于矿工来说，区块使用率超过95%是一个很好的信号，那意味着我可以拿到更多的奖励。奖励太低，在区块建立奖励越来越少的情况下，安全性（信任）就慢慢的得不到保障。这么说来，这也就变成了一个Trade-off博弈过程</p><br />
<br />
<p>分析下来，类似门罗币（menero）实现的根据网络负载来动态调整区块容量的设计似乎很合理</p><br />
<br />
<p>3.4.3、比特币扩容之争<br />
这是一场复杂的博弈斗争，使用隔离见证增长区块容量，并出现了比特币现金这个新的币种。</p><br />
<br />
<p>如果想要了解这里面的很多技术，英文是必须过硬的，因为比特币代码开源，可以随意fork，只要英文功底过硬，阅读白皮书，文档等，这些不同技术的处理方法都是能够学到的</p><br />
<br />
<p>3.5、比特币的一笔交易过程中到底发生了什么<br />
我们可以确认的是，每一笔都将记录在大账本中，那么我们需要研究的内容，就是区块中交易内容内的具体数据结构</p><br />
<br />
<p>3.5.1、交易结构<br />
每一个交易块包含的内容如下表所示</p><br />
<br />
<p>最后这个值是解锁时间，定义了能被加到区块链里的最早交易时间。大多是时候设为0，表示立马执行。</p><br />
<br />
<p>一笔比特币交易是一个含有输入值和输出值的数据结构。该数据结构包含了将一笔资金从初始点（输入值）转移至目标地址（输出值）的代码信息。比特币交易的输入值和输出值与账号或者身份信息无关。可以把它理解为一种被特定秘密信息锁定的一定数量的比特币。只有拥有者或者知道这个秘密信息的人可以解锁</p><br />
<br />
<p>3.5.2、交易的输入和输出<br />
比特币交易的基本单位是未经使用的一个交易输出，简称UTXO（unspent transaction outputs）</p><br />
<br />
<p>可以把UTXO类比为我们使用的人民币1，5，10，20，50，100的面值，对于UTXO来说，它的面值可以是一”聪“的任意倍数（1BTC等于一亿聪）但是这个有着任意面值的”人民币“不能随意打开，还被加上一道类似红包支付口令的密码，只有拥有这个密码的人才可以使用这个UTXO，UTXO包含，币值+一段代码（锁，只有有钥匙的人才能打开）</p><br />
<br />
<p>被交易消耗的UTXO被称为交易输入，由交易创建的UTXO被称为交易输出</p><br />
<br />
<p>3.5.2.1、交易输出<br />
不同面值的UTXO是由交易输出来提供的。你可以想象你需要购买一个3.1BTC的物品，你并不能从你的钱包中找到几个UTXO来得到3.1BTC，但是你刚好拥有一个4BTC的UTXO，你使用这个UTXO作为付款，那么你需要自己手动构建一个0.9的UTXO返还给你自己。</p><br />
<br />
<p>一个交易输出包含两个部分</p><br />
<br />
<p>一定量的比特币。被命名为“聪”（satoshis）<br />
一个锁定脚本。给这个UTXO上锁，保证只有收款人地址的私钥才可以打开<br />
3.5.2.2、交易输入<br />
每个交易输入是在构造的一笔交易（使用UTXO），比如你需要支付0.015BTC，钱包会寻找一个0.01BTC和0.005BTC的UTXO来组成这一笔交易。交易输入中还会包含一个解锁脚本，这是一个签名，可以类比成支付宝红包密码的口令</p><br />
<br />
<p>3.5.2.3、交易费<br />
交易费 = 求和（所有输入） - 求和（所有输出）</p><br />
<br />
<p>这里有一个比较有意思的地方，就是因为找零的输出UTXO是交易的发起这自己构建的，如果很不幸，你忘记了自己构建找零的UTXO，那么这些多余的BTC就会变成矿工的劳务费</p><br />
<br />
<p>例如，我需要和小明进行交易，需要购买一个商品，花费0.8BTC，为了确保这笔交易能被更快的处理（添加到大账本上），我要在其中添加一笔交易费，假设0.01BTC（忽略人傻钱多），那就意味着这笔交易会需要我从钱包中找到几个UTXO能组成0.81BTC。但如果我的钱包内找不出这样的UTXO，只有一个1BTC的UTXO可用，那么我就需要构建一个0.19BTC的UTXO作为找零回到自己的钱包</p><br />
<br />
<p>交易费只和交易字段使用的字节大小有关，与参与交易的比特币币值无关。UTXO是有尺寸的，比如某人想支付一笔很大的BTC交易，但是他的钱包中有很多小尺寸的UTXO，如果加入了很多个UTXO，就以为这他的交易会变复杂且尺寸大。</p><br />
<br />
<p>3.5.2.4、解锁和锁定脚本<br />
在实际实现的时候，这个“支付宝红包口令”被称为脚本，是一种基于逆波兰表示法的基于堆栈的执行语言。具体细节感兴趣的读者可以去比特币的Github研究代码。关于脚本有很多细节上的定义和实现方法，这里限于篇幅不展开描述了</p><br />
<br />
<p>3.5.3、矿工费和优先级<br />
我们知道，每一笔交易都是广播到区块链上，由矿工决定是不是加入到新区块上的。那么这里就会涉及到一个问题，谁的交易的优先级更高，是先来后到？还是谁给前多谁就能加入到新区块中？</p><br />
<br />
<p>在区块容量一节中，有一张图表直观的展示了现在网络中一笔交易的等待时间，其中最长的，也就是30分钟，如果你不是一个超级急性子，很多时候还是可以接受的（毕竟跨国转账1-2个工作日）</p><br />
<br />
<p>优先级 = 输入值块龄 * 输出值块龄 / 交易总长度</p><br />
<br />
<p>一个交易想成为“较高优先级”，需满足条件：优先值大于57600000，等价于1个BTC，年龄为1天，交易的大小为250字节</p><br />
<br />
<p>区块中前50KB的字节是保留给“较高优先级”的，其实这一机制也保证了一笔交易不会等待时间无现长。但是我们要知道，内存池（存放待处理交易的位置）中的交易，如果在没有处理后消失，所以钱包必须拥有不断重新广播未被处理交易的功能</p><br />
<br />
<p>3.5.4、创币交易 - Coinbase<br />
每一个新建立的区块，都会有新的比特币作为奖励被产生，这个交易是一个特殊交易，被称为创币交易（Coinbase奖励）</p><br />
<br />
<p>创币交易中不存在解锁脚本（也叫ScriptSig字段），被Coinbase的数据取代，长度最小2字节，最大100字节，除了开始的几个自己以外，矿工可以任意使用Coinbase的其他部分。比如创世区块中，Coinbase的输入中的字段是：The Times 03/Jan/2009 Chancellor on brink of second bailout for banks，是泰晤士日报当天的头版文章标题：财政大臣将再次对银行施以援手。</p><br />
<br />
<p>3.6、Merkle树<br />
每个区块中的所有交易，都是用Merkle树来表示的。换句话说，交易的存储数据结构是，Merkle树</p><br />
<br />
<p>3.6.1、什么是Merkle树<br />
Merkle树是一种哈希二叉树，它可以用来进行快速查找和检验大规模数据完整性。对于比特币网络来说，使用Merkle树来存储交易信息的目的是为了高效的查找和校验某笔交易的信息是否存在</p><br />
<br />
<p>当N个数据元素经过加密（使用两次SHA256算法，也称double-SHA256），至多计算2log_2(N)次就能检查出任意某元素是否在树中</p><br />
<br />
<p>3.6.2、构造Merkle树<br />
假设我们有A B C D四笔交易字段，首先需要把这四个数据Hash化。然后把这些哈细化的数据通过串联相邻叶子节点的哈希值然后哈希化。基本过程如下图所示</p><br />
<br />
<p>叶子节点必须是偶数（平衡树），如果遇到奇数的情况，把最后一个节点自身复制一个，凑偶</p><br />
<br />
<p>3.6.3、Merkle树的效率<br />
下表显示了证明区块中存在某笔交易所需转化为Merkle路径的数据量</p><br />
<br />
<p>可以发现，即使区块容量达到16MB规模，为证明交易存在的Merkle路径长度增长也极其缓慢（幂指数增长取对数变为线性增长）</p><br />
<br />
<p>3.6.4、Merkle应用 - 简单支付验证节点（SPV）<br />
我们知道，每当一笔新的交易产生的时候，我们必须验证这笔交易是否真的存在，在SPV节点中，不保存区块链，仅仅保存区块头。使用认证路径或者Merkle路径来验证交易是否存在于区块中</p><br />
<br />
<p>例如，一个SPV节点需要处理一笔支付，它需要验证这笔交易在某个区块中是否存在，才能决定是不是把这笔交易添加到这个区块中，那么它只需要接收少于1KB大小的，有关区块头和Merkle路径的信息，比接收完整区块（大约1MB）大小少了1千倍。简单来说，可以想象，Merkle树类似一个数组（这也是哈希表的最简单表示），下标是区块字段，下标对应数组存储的内容是这笔交易是否存在的值（True or False）</p><br />
<br />
<p>所谓比特币交易就是从一个比特币钱包向另一个中转账，每笔交易都有数字签名来保证安全。一个交易一旦发生那么就是对所有人都公开的，每个交易的历史可以最终追溯到相应的比特币最初被挖出来的那个点</p><br />
<br />
<p>世上本无币，只有交易记录</p><br />
<br />
<p>比特币并不存在于任何地方，即使是硬盘上。有人如果持有比特币，那么他们其实是拥有特定比特币的地址，但是其实所谓的币并不是直接就存在于这个地址中的，地址就相当于你的银行账户。但是世界上没有一个可以摸得着的实物，或者是一个数据文件，可以被叫做“比特币”的。</p><br />
<br />
<p>有的只是各个地址之间的转账记录，余额时增时减。所有的交易都存放在一个非常大的账本文件中，这个文件叫做“区块链”。如果想知道一个比特币地址中的余额，那么这个不是直接存放在比特币地址中的，我们需要到区块链中去计算出来。</p><br />
<br />
<p>一个交易长成啥样</p><br />
<br />
<p>如果 Alice 给 Bob 发送一些比特币，那么这个交易就有三项信息：</p><br />
<br />
<p>输入。这里面记录了最初 Alice 拥有的这些币是从哪个地址转给她的，假设她是从她的朋友 Eve 那里得到的币。</p><br />
<br />
<p>数目。这个就是 Alice 到底给 Bob 转了多少个比特币。</p><br />
<br />
<p>输出。Bob 的比特币地址。</p><br />
<br />
<p>发送过程如何进行<br />
比特币交易中是如何发送币的呢？你需要两个东西，一个是比特币地址另一个是对应的私钥。比特币地址跟银行账号不一样，你不需要签署一堆文件去申请，它们是随机生成的，就是一串由字母和数字组成的字符串。私钥也是类似的一个字符串，但是这个是要严格保密的。比特币地址就好像一个透明的存钱罐，每个人都可以看到里面有什么，但是只有拥有私钥的人才能打开它。</p><br />
<br />
<p>当 Alice 想要给 Bob 转币的时候，就用私钥来签署一段信息，其中包括输入，数目和输出这三项前面已经提过的内容。这样，信息广播到比特币网络上，矿工就可以验证这次交易，把交易加入区块链中了。</p><br />
<br />
<p>为啥交易会有十分钟的等待时间<br />
因为交易需要经过矿工的验证确认之后才能写到区块链之中，所以你必须要等待一下，等待他们挖矿成功。</p><br />
<br />
<p>比特币协议里面设置了挖矿完成的大概时间是10分钟。所以商家可能会等到你的交易所在的区块被确认之后才会给你发货。但是也有商家不会让你去等，基于对你的一个信任，相信你不会在交易没有得到确认之前有去拿同一笔钱花在别的地方。不过一般这只适用于小额交易。</p><br />
<br />
<p>输入和输出中的数额不相等怎么办？<br />
因为比特币只是以交易记录的形式存在，所以很多时候你的一个地址上面其实是对应很多个交易的。可能 Jane 发送给了 Alice 40个比特币，Lucy 给了40个，Eve 给了20个，这些都是不同时间的不同的交易，他们并没有被合成到 Alice 的一个钱包里形成一个有100个币的文件，而是仍然作为独立的各个交易记录存在。</p><br />
<br />
<p>当 Alice 想要给 Bob 转币的时候，她的钱包就会找到几个交易，让它们的数额加起来正好是 Alice 想要转的数目。 当然，很可能在 Alice 想要给 Bob 转币的时候，她没有办法找到几个交易加起来正好是转账数额。也许她想要转 30 个币，但是钱包中根本没有一个交易或是多个交易的和正好是这个数目。</p><br />
<br />
<p>同时，她没有办法把一个交易切割成小的数额。就是这样，你没有办法切割一个大的交易成为多个小数额，每次都必须花掉整个交易。但是不用担心，系统会给她把多发送出去的币作为找零还给你。</p><br />
<br />
<p>Alice 这时就可以把 Jane 给她发送过来的两个币发送给 Bob，这样 Jane 就是“输入”，Bob 就是“输出”，“数额”是30个币，这时 Alice 真正想要转账的数目。这样，Alice 的钱包就会自动给她的这次交易创建两个输出：把30个币给 Bob，剩下的30放到一个新的地址中，这个是找回的零钱。</p><br />
<br />
<p>交易过程收费吗？<br />
交易手续费是综合多种因素得出的。有些钱包可以让你手动设置手续费。交易中那部分没有被对方收到，同时也没有找零回来的就是手续费。这笔钱最终会被得到记账权的那个幸运的矿工所得到。</p><br />
<br />
<p>目前，很多矿工都不收手续费。但是随着每次挖矿成功系统奖励给矿工的币不断减少，未来肯定会有更多的矿工会收取手续费的。</p><br />
<br />
<p>一直以来有一件很让人恼火的事情就是计算矿工费的过程非常复杂难懂。不过后来大家对协议做了相应的修改，现在的软件能够自动处理矿工费的问题了。</p><br />
<br />
<p>能开收据吗？<br />
比特币系统设计时并没有考虑收据问题。不过0.9版本的比特币中稍微修改一下付款的方式，让整个过程更方便。支付服务商，例如 Bitpay，也提供一些基本交易过程提供不了的功能，例如提供收据或者交易确认页面等。</p><br />
<br />
<p>能发送小额的比特币吗？<br />
比特币理论上是可以无限切割的。目前最小的比特币单位叫做“中本聪”，相当于0.00000001个比特币。</p><br />
<br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category cryptology
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>