<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">反向二进制迭代(Reverse Binary Iteration)算法</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-04-09T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 9, 2020</time></p>
					</div>
					 <p>edis中一个db就是一个大dict，也就是实现的可伸缩hash表。其操作支持遍历scan类操作，按stl容器中场景的逻辑，如果一个迭代器在迭代过程中被修改(插入或删除)元素，迭代器可能失效。</p><br />
<br />
<p>redis中，由于在scan操作时，整个dict会有大量的增加和删除操作，如果失效迭代器重新遍历可能永远无法完成scan操作，所以其实现的scan遍历操作使用了Reverse Binary Iteration算法，意思是遍历的顺序递增操作是二进制反向的，也就是该数字递增是二进制高位加1，向低位进位。</p><br />
<br />
<p>因为dict的具体实现是通过索引找到bucket，bucket中可以容纳多个key，并且会进行rehash操作，要实现的目标是：</p><br />
<br />
<p>在迭代开始时刻起，没有被删除的key都能被遍历。<br />
在迭代器rehash操作后，没有被删除的key尽可能少的被重复遍历。<br />
dict的rehash长度是都是2倍增加或半数减少，在遍历过程中cursor的变化是采用反向二进制增加的，在hash长度为8和16时，cursor的增长如下：</p><br />
<br />
<p>8: 000 –&gt; 100 –&gt; 010 –&gt; 110 –&gt; 001 –&gt; 101 –&gt; 011 –&gt; 111 –&gt; 000 <br /><br />
16: 0000 –&gt; 1000 –&gt; 0100 –&gt; 1100 –&gt; 0010 –&gt; 1010 –&gt; 0110 –&gt; 1110 –&gt; 0001 –&gt; 1001 –&gt; 0101 –&gt; 1101 –&gt; 0011 –&gt; 1011 –&gt; 0111 –&gt; 1111 –&gt; 0000 <br /><br />
rehash增长<br />
如果cursor是2，在长度8的hash表中下标是010，在长度16的hash表中下标是0010和1010，这两个是相邻的，这个特性很重要，能够保证在rehash之后，0010之前的bucket都是已经遍历过的，不需要再重复遍历。在增长到16后，下次迭代的cursor为0110，所以不会漏掉也不会重复遍历。</p><br />
<br />
<p>rehash缩小<br />
在16缩小成8的情况下，当在长度16时，在迭代完成1010后，rehash成8大小，cursor变成010。在大小为16时已经完成0000，1000，0100，1100，0010和1010迭代，大小变为8后，为了防止漏掉bucket，下次迭代从010开始，0010和1010已经迭代过，所以会出现重复。<br />
https://github.com/antirez/redis/pull/579#issuecomment-16871583</p><br />
<br />
<!-- more --><br />
<p>遍历一个稳定的字典，当然不是什么难事，但Redis中的字典因为有rehash的过程，使字典可能扩展，也可能缩小。这就带来了问题，如果在两次遍历中间，字典的结构发生了变化（扩展或缩小），字典中的元素所在的位置相应的会发生变化，那如何保证字典中原有的元素都可以被遍历？又如何能尽可能少的重复迭代呢？</p><br />
<br />
<p>         这就是该算法的精妙所在，使用该算法，可以做到下面两点：</p><br />
<br />
<p>         a：开始遍历那一刻的所有元素，只要不被删除，肯定能被遍历到，不管字典扩展还是缩小；</p><br />
<br />
<p>         b：该算法可能会返回重复元素，但是已经把返回重复元素的可能性降到了最低;</p><br />
<br />
<p> </p><br />
<br />
<p>一：游标cursor的演变</p><br />
<br />
<p>         该算法使用了游标cursor来遍历字典，它表示本次要访问的bucket的索引。bucket中保存了一个链表，因此每次迭代都会把该bucket的链表中的所有元素都遍历一遍。</p><br />
<br />
<p>         第一次迭代时，cursor置为0，dictScan函数的返回值作为下一个cursor再次调用dictScan，最终，dictScan函数返回0表示迭代结束。</p><br />
<br />
<p>         首先看一下cursor的演变过程，也是该算法的核心所在。这里cursor的演变是采用了reverse binary iteration方法，也就是每次是向cursor的最高位加1，并向低位方向进位。</p><br />
<br />
<p>         下面具体解释，首先，根据dictScan写一个简单的测试函数，用来看cursor的演变过程：</p><br />
<br />
<p>void test_dictScan_cursor(int tablesize)<br />
{<br />
    unsigned long v;<br />
    unsigned long m0;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v = 0;<br />
m0 = tablesize-1;<br />
 <br />
printbits(v, (int)log2(tablesize));<br />
printf(" --&gt; ");<br />
 <br />
do<br />
{   <br />
    v |= ~m0;<br />
    v = rev(v);<br />
    v++;      <br />
    v = rev(v);<br />
 <br />
    printbits(v, (int)log2(tablesize));<br />
    printf(" --&gt; ");<br />
}while (v != 0);    <br />
<br />
printf("\b\b\b\b\b     \n"); }          参数tablesize表示哈希表的大小，printbits用来打印v的低n二进制位，n等于log2(tablesize)，以tablesize为8和16分别运行该函数，结果如下：<br />
</code></pre></div></div><br />
<br />
<p>000 –&gt; 100 –&gt; 010 –&gt; 110 –&gt; 001 –&gt; 101 –&gt; 011 –&gt; 111 –&gt; 000</p><br />
<br />
<p>0000 –&gt; 1000 –&gt; 0100 –&gt; 1100 –&gt; 0010 –&gt; 1010 –&gt; 0110 –&gt; 1110 –&gt; 0001 –&gt; 1001 –&gt; 0101 –&gt; 1101 –&gt; 0011 –&gt; 1011 –&gt; 0111 –&gt; 1111 –&gt; 0000 <br /><br />
         这就是所谓的reverse binaryiteration方法，也就是每次是向v的最高位加1，并向低位方向进位。比如1101的下一个数是0011，因为1101的前三个数为110，最高位加1，并且向低位进位就是001，所以最终得到0011。</p><br />
<br />
<p> </p><br />
<br />
<p>         在Redis中，字典的哈希表长度始终为2的n次方。因此m0始终是一个低n位全为1，其余为全为0的数。整个计算过程，都是在v的低n位数中进行的，比如长度为16的哈希表，则n=4，因此v是从0到15这几个数之间的转换。下面解释一下计算过程：</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>         第一步：v</td><br />
      <td>= ~m0;                 //用于保留v的低n位数，其余位全置为1：</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p> </p><br />
<br />
<p>         第二步：v = versebits2(v);    //将v的二进制位进行翻转，所以，v的低n位数成了高n位数，并且进行了翻转：</p><br />
<br />
<p> </p><br />
<br />
<p>         第三步：v++;</p><br />
<br />
<p> </p><br />
<br />
<p>         最后一步：v =versebits2(v);                 //再次翻转</p><br />
<br />
<p> </p><br />
<br />
<p>         因此，最终得到的新v，就是向最高位加1，且向低位方向进位。</p><br />
<br />
<p> </p><br />
<br />
<p>二：为什么要这样</p><br />
<br />
<p>         这样设计的原因就在于，字典中的哈希表有可能扩展，也有可能缩小。在字典不稳定的情况下，既要遍历到所有没被删除的元素，又要尽可能较少的重复遍历。</p><br />
<br />
<p>         下面详细解释一下这样设计的好处，以及为什么不是按照正常的0,1,2,…这样的顺序迭代？</p><br />
<br />
<p> </p><br />
<br />
<p>         计算一个哈希表节点索引的方法是hashkey&amp;mask，其中，mask的值永远是哈希表大小减1。哈希表长度为8，则mask为111，因此，节点的索引值就取决于hashkey的低三位，假设是abc。如果哈希表长度为16，则mask为1111，同样的节点计算得到的哈希值不变，而索引值是?abc，其中?既可能是0，也可能是1，也就是说，该节点在长度为16的哈希表中，索引是0abc或者1abc。以此类推，如果哈希表长度为32，则该节点的索引是00abc，01abc，10abc或者11abc中的一个。</p><br />
<br />
<p> </p><br />
<br />
<p>         重新看一下该算法中，哈希表长度分别为8和16时，cursor变化过程：        </p><br />
<br />
<p>000 –&gt; 100 –&gt; 010 –&gt; 110 –&gt; 001 –&gt; 101 –&gt; 011 –&gt; 111 –&gt; 000</p><br />
<br />
<p>0000 –&gt; 1000 –&gt; 0100 –&gt; 1100 –&gt; 0010 –&gt; 1010 –&gt; 0110 –&gt; 1110 –&gt; 0001 –&gt; 1001 –&gt; 0101 –&gt; 1101 –&gt; 0011 –&gt; 1011 –&gt; 0111 –&gt; 1111 –&gt; 0000 <br /><br />
         哈希表长度为8时，第i个cursor（0 &lt;= i &lt;=7），扩展到长度为16的哈希表中，对应的cursor是2i和2i+1，它们是相邻的，这点很重要。 </p><br />
<br />
<p>         首先是字典扩展的情况，假设当前字典哈希表长度为8，在迭代完索引为010的bucket之后，下一个cursor为110。假设在下一次迭代前，字典哈希表长度扩展成了16，110这个cursor，在长度为16的情况下，就成了0110，因此开始迭代索引为0110的bucket中的节点。</p><br />
<br />
<p>         在长度为8时，已经迭代过的cursor分别是：000，100，010。哈希表长度扩展到16后，在这些索引的bucket中的节点，分布到新的bucket中，新bucket的索引将会是：0000，1000，0100，1100，0010，1010。而这些，正好是将要迭代的0110之前的索引，从0110开始，按照长度为16的哈希表cursor变化过程迭代下去，这样既不会漏掉节点，也不会迭代重复的节点。</p><br />
<br />
<p> </p><br />
<br />
<p>         再看一下字典哈希表缩小的情况，也就是由16缩小为8。在长度为16时，迭代完0100的cursor之后，下一个cursor为1100，假设此时哈希表长度缩小为8。1100这个cursor，在长度为8的情况下，就成了100。因此开始迭代索引为100的bucket中的节点。</p><br />
<br />
<p>         在长度为16时，已经迭代过的cursor是：0000，1000，0100，哈希表长度缩小后，这些索引的bucket中的节点，分布到新的bucket中，新bucket的索引将会是：000和100。现在要从索引为100的bucket开始迭代，这样不会漏掉节点，但是之前长度为16时，索引为0100中的节点会被重复迭代，然而，也就仅0100这一个bucket中的节点会重复而已。</p><br />
<br />
<p>         原哈希表长度为x，缩小后长度为y，则最多会有x/y – 1个原bucket的节点会被重复迭代。比如由16缩小为8，则最多就有1个bucket节点会重复迭代，要是由32缩小为8，则最多会有3个。</p><br />
<br />
<p>         当然也有可能不产生重复迭代，还是从16缩小为8的情况，如果已经迭代完1100，下一个cursor为0010，此时长度缩小为8，cursor就成了010。</p><br />
<br />
<p>         长度为16时，已经迭代过的cursor为0000，1000，0100，1100，长度缩小后，这些cursor对应到新的索引是000和100，正好是010之前的索引，从010开始，按照长度为8的cursor走下去，不会漏掉节点，也不会重复迭代节点。</p><br />
<br />
<p>         所以说这种算法，保证了：能迭代完所有节点而不会漏掉；又能尽可能较少的重复遍历。</p><br />
<br />
<p> </p><br />
<br />
<p>         如果按照正常的顺序迭代，下面分别是长度为8和16对应的cursor变化过程：</p><br />
<br />
<p>000 –&gt; 001 –&gt; 010 –&gt; 011 –&gt; 100 –&gt; 101 –&gt; 110 –&gt; 111 –&gt; 000</p><br />
<br />
<p>0000 –&gt; 0001 –&gt; 0010 –&gt; 0011 –&gt; 0100 –&gt; 0101 –&gt; 0110 –&gt; 0111 –&gt; 1000 –&gt; 1001 –&gt; 1010 –&gt; 1011 –&gt; 1100 –&gt; 1101 –&gt; 1110 –&gt; 1111 –&gt; 0000<br /><br />
         字典扩展的情况，当前字典哈希表长度为8，假设在迭代完cursor为010的bucket之后，下一个cursor为011。迭代011之前，字典长度扩展成了16，011这个cursor，在长度为16的情况下，就成了0011，因此开始迭代索引为0011的bucket中的节点。</p><br />
<br />
<p>         在长度为8时，已经迭代过的cursor是：000，001，010。哈希表长度扩展到16后，这些索引的bucket中的节点，会分布到新的bucket中，新bucket的索引将会是：0000，1000，0001，1001，0010和1010。现在要开始迭代的cursor为0011，而1000，1001，1010这些bucket中的节点在后续还是会遍历到，这就产生了重复遍历。</p><br />
<br />
<p>         虽然这种情况不会发生漏掉节点的情况，但是肯定会有重复的情况发生，而且长度变化发生的时机越晚，重复遍历的节点越多，比如长度为8时，迭代完110后，下一个cursor为111，长度扩展为16后，这个cursor就成了0111。</p><br />
<br />
<p>         长度为8时，已经迭代过的cursor为000，001，010，011，100，101，110，扩展到长度为16的哈希表中，这些bucket中的节点会分布到索引为：0000，1000，0001，1001，0010，1010，0011，1011，0100，1100，0101，1101，0110，1110。现在长度为16，要开始迭代cursor为0111，而1000，1001，1010，1011和1110这些节点后续还会遍历到，重复的节点增多了。</p><br />
<br />
<p> </p><br />
<br />
<p>         再看一下长度缩小的情况，长度由16缩小为8。在长度为16时，迭代完0100的cursor之后，下一个cursor为0101，此时长度缩小为8。0101这个cursor，在长度为8的情况下，就成了101。</p><br />
<br />
<p>         在长度为16时，尚未迭代过的cursor是：0101，0110，0111，1000，1001，1010，1011，1100，1101，1110，1111。这些cursor，在哈希表长度缩小后，分配到新的bucket中，索引将会是：000，001，010，011，100，101，110，111。现在要开始迭代的cursor为101，那101之前的000，001，010，011，100这些cursor就不会迭代了，这样，原来的某些节点就被漏掉了。</p><br />
<br />
<p>         另外，还是从16缩小为8的情况，如果已经迭代完1100，下一个cursor为1101，在长度为8的情况下，就成了101。</p><br />
<br />
<p>         长度为16时，已经迭代过的cursor为0000，0001，0010，0011，0100，0101，0110，0111，1000，1001，1010，1011，1100。这些cursor，在哈希表长度缩小后，分配到新的bucket中，索引分别是：000，001，010，011，100，101，110，111。长度变为8后，从101开始，很明显，原来已经迭代过的0101，0110，0111就会产生重复迭代。</p><br />
<br />
<p>         因此，顺序迭代不是一个满足要求的迭代方法。</p><br />
<br />
<p> </p><br />
<br />
<p>         上面的算法是由Pieter Noordhuis设计实现的，Redis之父Salvatore Sanfilippo对该算法的评价是” Hard to explain but awesome.”，可见其牛逼！！！Pieter Noordhuis对该算法的解释见：https://github.com/antirez/redis/pull/579#issuecomment-16871583</p><br />
<br />
<p> </p><br />
<br />
<p>         了解完该算法的核心之后，剩下的就是具体的迭代过程了，dictScan代码如下：</p><br />
<br />
<p>unsigned long dictScan(dict *d,<br />
                       unsigned long v,<br />
                       dictScanFunction *fn,<br />
                       void *privdata)<br />
{<br />
    dictht *t0, *t1;<br />
    const dictEntry *de;<br />
    unsigned long m0, m1;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (dictSize(d) == 0) return 0;<br />
 <br />
if (!dictIsRehashing(d)) {<br />
    t0 = &amp;(d-&gt;ht[0]);<br />
    m0 = t0-&gt;sizemask;<br />
 <br />
    /* Emit entries at cursor */<br />
    de = t0-&gt;table[v &amp; m0];<br />
    while (de) {<br />
        fn(privdata, de);<br />
        de = de-&gt;next;<br />
    }<br />
 <br />
} else {<br />
    t0 = &amp;d-&gt;ht[0];<br />
    t1 = &amp;d-&gt;ht[1];<br />
 <br />
    /* Make sure t0 is the smaller and t1 is the bigger table */<br />
    if (t0-&gt;size &gt; t1-&gt;size) {<br />
        t0 = &amp;d-&gt;ht[1];<br />
        t1 = &amp;d-&gt;ht[0];<br />
    }<br />
 <br />
    m0 = t0-&gt;sizemask;<br />
    m1 = t1-&gt;sizemask;<br />
 <br />
    /* Emit entries at cursor */<br />
    de = t0-&gt;table[v &amp; m0];<br />
    while (de) {<br />
        fn(privdata, de);<br />
        de = de-&gt;next;<br />
    }<br />
 <br />
    /* Iterate over indices in larger table that are the expansion<br />
     * of the index pointed to by the cursor in the smaller table */<br />
    do {<br />
        /* Emit entries at cursor */<br />
        de = t1-&gt;table[v &amp; m1];<br />
        while (de) {<br />
            fn(privdata, de);<br />
            de = de-&gt;next;<br />
        }<br />
 <br />
        /* Increment bits not covered by the smaller mask */<br />
        v = (((v | m0) + 1) &amp; ~m0) | (v &amp; m0);<br />
 <br />
        /* Continue while bits covered by mask difference is non-zero */<br />
    } while (v &amp; (m0 ^ m1));<br />
}<br />
 <br />
v |= ~m0;<br />
 <br />
/* Increment the reverse cursor */<br />
v = rev(v);<br />
v++;<br />
v = rev(v);<br />
 <br />
return v; }          其中的rev函数用来对无符号整数进行二进制位的翻转，具体算法参考《翻转整数的二进制位》，这里不再赘述。<br />
</code></pre></div></div><br />
<br />
<p> </p><br />
<br />
<p>         如果字典当前没有rehash，则比较简单，直接根据v找到需要迭代的bucket索引，针对该bucket中链表中的所有节点，调用用户提供的fn函数。</p><br />
<br />
<p> </p><br />
<br />
<p>         如果字典当前正在rehash，则需要先遍历较小的哈希表，然后是较大的哈希表。</p><br />
<br />
<p>         首先使t0指向小表，t1指向大表；m0为小表的mask，m1为大表的mask。</p><br />
<br />
<p>         根据v&amp;m0，找到t0中需要迭代的bucket，然后迭代其中的每个节点即可。</p><br />
<br />
<p>接下来的代码稍显复杂，但是，本质上，就是t0中，索引为v&amp;m0的bucket中的所有节点，再其扩展到t1中后，遍历其所有可能的bucket中的节点。语言不好描述，举个例子就明白了：若t0长度为8，则m0为111，v&amp;m0就是保留v的低三位，假设为abc。若t1长度为32，则m1为11111，该过程就是：遍历完t0中索引为abc的bucket之后，接着遍历t1中，索引为00abc、01abc、10abc、11abc的bucket中的节点。</p><br />
<br />
<p> </p><br />
<br />
<p>         下面是抽取核心代码的逻辑而写的测试代码：</p><br />
<br />
<p>void test_dictScan_iter(int smalltablesize, int largetablesize)<br />
{<br />
    unsigned long v;<br />
    unsigned long m0, m1;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v = 0;<br />
m0 = smalltablesize-1;<br />
m1 = largetablesize-1;<br />
<br />
do<br />
{   <br />
    printf("\nsmall v is: ");<br />
    printbits(v &amp; m0, (int)log2(smalltablesize));<br />
    printf("\n");<br />
 <br />
    do <br />
    {                   <br />
        printf("large v is: ");<br />
        printbits(v &amp; m1, (int)log2(largetablesize));   <br />
        printf("\n");<br />
 <br />
        v = (((v | m0) + 1) &amp; ~m0) | (v &amp; m0);<br />
    }while (v &amp; (m0 ^ m1));<br />
    <br />
    v |= ~m0;<br />
    v = rev(v);<br />
    v++;      <br />
    v = rev(v);<br />
}while (v != 0);     }<br />
</code></pre></div></div><br />
<br />
<p>         以test_dictScan_iter(8, 32);运行代码，结果如下：</p><br />
<br />
<p>small v is: 000<br />
large v is: 00000<br />
large v is: 01000<br />
large v is: 10000<br />
large v is: 11000</p><br />
<br />
<p>small v is: 100<br />
large v is: 00100<br />
large v is: 01100<br />
large v is: 10100<br />
large v is: 11100</p><br />
<br />
<p>small v is: 010<br />
large v is: 00010<br />
large v is: 01010<br />
large v is: 10010<br />
large v is: 11010</p><br />
<br />
<p>small v is: 110<br />
large v is: 00110<br />
large v is: 01110<br />
large v is: 10110<br />
large v is: 11110</p><br />
<br />
<p>small v is: 001<br />
large v is: 00001<br />
large v is: 01001<br />
large v is: 10001<br />
large v is: 11001</p><br />
<br />
<p>small v is: 101<br />
large v is: 00101<br />
large v is: 01101<br />
large v is: 10101<br />
large v is: 11101</p><br />
<br />
<p>small v is: 011<br />
large v is: 00011<br />
large v is: 01011<br />
large v is: 10011<br />
large v is: 11011</p><br />
<br />
<p>small v is: 111<br />
large v is: 00111<br />
large v is: 01111<br />
large v is: 10111<br />
large v is: 11111<br />
         可见，无论v取何值，只要字典开始扩展了，都会遍历大表中，相应于小表的所有节点。具体的核心逻辑代码如下：</p><br />
<br />
<p>do <br />
{                 <br /><br />
    de = t1-&gt;table[v &amp; m1];<br />
    …<br />
    v = (((v | m0) + 1) &amp; ~m0) | (v &amp; m0);<br />
}while (v &amp; (m0 ^ m1));<br />
         首先迭代t1中，索引为v&amp;m1的bucket，接下来的语句：</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>         v = (((v</td><br />
      <td>m0) + 1) &amp; ~m0)</td><br />
      <td>(v &amp; m0);     就是对v的低m1-m0位加1，并保留v的低m0位。循环条件v &amp;(m0 ^ m1)，表示直到v的低m1-m0位到低m1位之间全部为0为止</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p> 在进行字典的遍历时，有着许多的问题去解决。最难处理的点就是如何在rehash的途中有效率的、不遗漏的遍历全部的哈希节点，因为在此时每个哈希节点的地址与索引都是不确定的。在Redis中，其作者基于reverse binary iteration算法来实现的，直译过来就是反转二进制迭代算法，而且实现的非常精妙，Redis之父Salvatore Sanfilippo对其的评价是” Hard to explain but awesome.”</p><br />
<br />
<p>reverse binary iteration算法<br />
    一句话简单的描述该算法：一个二进制的数字，每次从最高位加一，向低位方向进位。<br />
    不同于平常的进位，reverse binary iteration则是刚好相反着来的。比较下两个例子：</p><br />
<br />
<p>平常进位<br />
000–&gt;001–&gt;010–&gt;011–&gt;100–&gt;101–&gt;110–&gt;111–&gt;000<br />
1<br />
reverse binary iteration进位<br />
000–&gt;100–&gt;010–&gt;110–&gt;001–&gt;101–&gt;011–&gt;111–&gt;000<br />
1<br />
    现在来谈谈如何实现该算法：该算法的思路是利用二进制的两次反转来实现进制方向的不同，从而实现从最高位加一，向低位方向进位。 在Redis中，假设mask代表着哈希表大小的掩码，hashcode代表着键的哈希值，因为哈希表的大小总是是2的n次方，所以它的掩码mask总是如此，即掩码的二进制后n位全为1：</p><br />
<br />
<p>//掩码等于哈希表的大小减一<br />
…..000001…..1<br />
//例如：哈希表的大小为8，则其掩码为7<br />
//二进制表示为：….00111<br />
1<br />
2<br />
3<br />
4<br />
    假设mask=111，hashcode=101，步骤如下：</p><br />
<br />
<ol><br />
  <li><br />
    <table><br />
      <tbody><br />
        <tr><br />
          <td>hashcode</td><br />
          <td>= ～mask：保留与mask长度相同的低n位数，其余为全为1，hashcode=1…101</td><br />
        </tr><br />
      </tbody><br />
    </table><br />
  </li><br />
  <li>rev（hashcoded）：二进制反转，hashcode=101…1</li><br />
  <li>hashcode++:hashcode=1100…</li><br />
  <li>rev（hashcoded）：二进制再次反转，hashcode=011</li><br />
</ol><br />
<br />
<p>    可见，经过两次反转后，hashcode成功的向低位进了1：</p><br />
<br />
<p>101–&gt;011<br />
1<br />
    反转二进制的代码如下，有着大量的移位操作：</p><br />
<br />
<p>//v为二进制<br />
static unsigned long rev(unsigned long v) {<br />
    unsigned long s = 8 * sizeof(v); // bit size; must be power of 2<br />
    unsigned long mask = ~0;<br />
    while ((s »= 1) &gt; 0) {<br />
        mask ^= (mask « s);<br />
        v = ((v » s) &amp; mask) | ((v « s) &amp; ~mask);<br />
    }<br />
    return v;<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
选择的理由<br />
    谈理由之前，先来说明下在Redis中的一个很秒的操作，就是获取键的索引值操作。</p><br />
<br />
<p>// 计算新哈希表的哈希值，以及节点插入的索引位置<br />
h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[0].sizemask;<br />
1<br />
2<br />
    之所以说它妙，是因为它通过此操作可以将不同大小的哈希表之间的相同哈希节点给关联起来。 假如，一个大小为8的哈希表，它的mask（掩码）为111，那么键的索引值就取决于键的哈希值（hashcode）的后三位，如果hashcode&amp;mask=101（索引值），而现在它要rehash到一个大小为16的哈希表中，掩码为1111，掩码后三位是完全相同的，且键值是不会改变的，所以在大小为16的哈希表中，这个键的索引值要么是0101，要么就是1101。同理，关联到大小为32中，就有四种情况：00101,01101,10101,11101。</p><br />
<br />
<p>    也就是说，只要索引值后n位是相同的，那么它们就是相互关联的。这样就可以带来一个好处：假如在大小为4的哈希表里遍历了01这个索引值，那么在大小为8的表里，只需要遍历索引值为001与101两个位置即可找到对应的哈希节点，而不用全部遍历。相反也是如此。</p><br />
<br />
<p>    谈到遍历，或许我们首先想到的是顺序遍历，因为这个方式最为简单直接。但是在遍历Redis中的字典却行不通，我们分析下为什么行不通。假如Redis正在进行rehsah，ht[0]的大小为4，而ht[1]的大小为8，两者如果都按顺序遍历的话(为方便比较都用二进制表示)：</p><br />
<br />
<p>//大小为8<br />
000–&gt;001–&gt;010–&gt;011–&gt;100–&gt;101–&gt;110–&gt;111–&gt;1000<br />
//大小为4<br />
00–&gt;01–&gt;10–&gt;11–&gt;100<br />
1<br />
2<br />
3<br />
4<br />
    在顺序遍历中，假如是大小为8的哈希表rehash为大小为4的哈希表，假如在遍历010这个点时，其余的数据rehash到了大小为4的哈希表中，010在大小为4的哈希表中就为10，也就是从10开始遍历大小为4的哈希表，但是010后面的100,101会被rehash到00与01这两个位置，也就是说原来的这两个节点没有被遍历到，造成了哈希节点的遗漏。</p><br />
<br />
<p>    再来看reverse binary iteration算法的遍历：</p><br />
<br />
<p>//大小为16<br />
0000–&gt;1000–&gt;0100–&gt;1100–&gt;0010–&gt;1010–&gt;0110–&gt;1110–&gt;0001–&gt;1001–&gt;0101–&gt;1101–&gt;0011–&gt;1011–&gt;0111–&gt;1111–&gt;0000<br />
//大小为8<br />
000–&gt;100–&gt;010–&gt;110–&gt;001–&gt;101–&gt;011–&gt;111–&gt;000<br />
//大小为4<br />
00–&gt;10–&gt;01–&gt;11–&gt;00<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
    在这里，你会发现一个很奇妙的规律，大小为n的哈希表第i个索引值与大小为k×n的哈希表第n个索引值之间的关系是:</p><br />
<br />
<p>n=k*i+j;(j&gt;=0&amp;&amp;j&lt;=k-1,k为整数)<br />
1<br />
    这就保证了字典缩小时不会产生遗漏哈希节点的产生，因为相同关联的索引值都是相邻的。且在小表中的索引值是对应在大表里相关联的索引值第一位 即在小表中为10的索引值，在大表中索引值010是与之相关联的索引值的第一位。两种方法都会产生遍历重复的节点，但是后一种方法遍历的重复节点的概率较少，而且遍历到重复节点容易在应用层得到解决。</p><br />
<br />
<p>    最后来看看,Redis具体是怎么做的吧：</p><br />
<br />
<p>unsigned long dictScan(dict *d,<br />
                       unsigned long v,<br />
                       dictScanFunction *fn,<br />
                       void *privdata)<br />
{<br />
    dictht *t0, *t1;<br />
    const dictEntry *de;<br />
    unsigned long m0, m1;<br />
    // 跳过空字典<br />
    if (dictSize(d) == 0) return 0;<br />
    // 迭代只有一个哈希表的字典<br />
    if (!dictIsRehashing(d)) {<br />
        // 指向哈希表<br />
        t0 = &amp;(d-&gt;ht[0]);<br />
        // 记录 mask<br />
        m0 = t0-&gt;sizemask;<br />
        // 指向哈希桶<br />
        de = t0-&gt;table[v &amp; m0];<br />
        // 遍历桶中的所有节点<br />
        while (de) {<br />
            fn(privdata, de);<br />
            de = de-&gt;next;<br />
        }<br />
    // 迭代有两个哈希表的字典<br />
    } else {<br />
        // 指向两个哈希表<br />
        t0 = &amp;d-&gt;ht[0];<br />
        t1 = &amp;d-&gt;ht[1];<br />
        // 确保 t0 比 t1 要小，为了从小的哈希表直接得到大的哈希表的关联索引值<br />
        //比如：大小为4的哈希表索引值01关联到大小为8的哈希表：001与101<br />
        if (t0-&gt;size &gt; t1-&gt;size) {<br />
            t0 = &amp;d-&gt;ht[1];<br />
            t1 = &amp;d-&gt;ht[0];<br />
        }<br />
        // 记录掩码<br />
        m0 = t0-&gt;sizemask;<br />
        m1 = t1-&gt;sizemask;<br />
        // 指向桶，并迭代桶中的所有节点<br />
        de = t0-&gt;table[v &amp; m0];<br />
        while (de) {<br />
            fn(privdata, de);<br />
            de = de-&gt;next;<br />
        }<br />
        do {<br />
            // 指向桶，并迭代桶中的所有节点<br />
            de = t1-&gt;table[v &amp; m1];<br />
            while (de) {<br />
                fn(privdata, de);<br />
                de = de-&gt;next;<br />
            }<br />
           //增量位不被较小的掩码覆盖<br />
            v = (((v | m0) + 1) &amp; ~m0) | (v &amp; m0);<br />
            //如果掩码差异覆盖的位不为零则继续<br />
        } while (v &amp; (m0 ^ m1));<br />
    }<br />
//用reverse binary iteration计算下一个索引值，并返回（到0结束）<br />
    v |= ~m0;<br />
    v = rev(v);<br />
    v++;<br />
    v = rev(v);<br />
    return v;<br />
}<br />
1<br />
2<br />
3<br />
4<br />
5<br />
6<br />
7<br />
8<br />
9<br />
10<br />
11<br />
12<br />
13<br />
14<br />
15<br />
16<br />
17<br />
18<br />
19<br />
20<br />
21<br />
22<br />
23<br />
24<br />
25<br />
26<br />
27<br />
28<br />
29<br />
30<br />
31<br />
32<br />
33<br />
34<br />
35<br />
36<br />
37<br />
38<br />
39<br />
40<br />
41<br />
42<br />
43<br />
44<br />
45<br />
46<br />
47<br />
48<br />
49<br />
50<br />
51<br />
52<br />
53<br />
54<br />
55<br />
56<br />
57<br />
58<br />
59<br />
60<br />
61<br />
62<br />
    代码中，需注意到几个地方：</p><br />
<br />
<p>v = (((v | m0) + 1) &amp; ~m0) | (v &amp; m0);  1式<br />
1<br />
    这句话的意思是找到与v相关联的大哈希表里的所有索引值。</p><br />
<br />
<p>while (v &amp; (m0 ^ m1));  2式<br />
1<br />
    这个意思是判断是否还有与v相关联的索引值。</p><br />
<br />
<p>    假如有二进制k=110，m0=3，m1=7。</p><br />
<br />
<p>k=110<br />
1式运算后：k=1110，k &amp; (m0 ^ m1)=1000，符合条件<br />
1式运算后：k=10110，k &amp; (m0 ^ m1)=0，不符合符合条件，循环结束<br />
    可见确实如此，上述，找出了与小哈希表中相关联的索引值1110，另外一个则是其本身0110</p><br />
<br />
<p>SCAN 命令用于迭代当前数据库中的数据库键。<br />
SSCAN 命令用于迭代集合键中的元素。<br />
HSCAN 命令用于迭代哈希键中的键值对。<br />
ZSCAN 命令用于迭代有序集合中的元素（包括元素成员和元素分值）。</p><br />
<br />
<p>SCAN、SSCAN、HSCAN、ZSCAN每次执行都只会返回少量元素，所以这些命令可以用于生产环境，而不会出现像KEYS、SMEMBERS命令带来的问题，当KEYS命令被用于处理一个大的数据库时，又或者SMEMBERS命令被用于处理一个大的集合键时，它们可能会阻塞服务器达数秒之久。</p><br />
<br />
<p>SCAN cursor [MATCH pattern] [COUNT count]<br />
SSCAN、HSCAN、ZSCAN的第一个参数总是一个数据库键；而SCAN命令则不需要在第一个参数提供任何数据库键，因为它迭代的是当前数据库中的所有数据库键。<br />
可以通过增量式迭代命令提供的 COUNT 选项来指定每次迭代返回元素的最大值；COUNT参数的默认值为10。</p><br />
<br />
<p>scan 0</p><br />
<br />
<p>sadd myset 1 2 3 foo foobar feelsgood<br />
sscan myset 0 match f*</p><br />
<br />
<p>SCAN命令是一个基于游标的迭代器，每次被调用之后，都会向用户返回一个新的游标，用户在下次迭代时需要使用这个新游标作为SCAN 命令的游标参数，以此来延续之前的迭代过程。</p><br />
<br />
<p>当SCAN命令的游标参数设置为0时，服务器将开始一次新的迭代，而当服务器向用户返回值为0的游标时，表示迭代已结束。<br />
如果一个元素是在迭代过程中被添加到数据集的，又或者是在迭代过程中从数据集中被删除的，那么这个元素可能会被返回，也可能不会。</p><br />
<br />
<p>在同一时间，可以有任意多个客户端对同一数据集进行迭代，客户端每次执行迭代都需要传入一个游标，并在迭代执行之后获得一个新的游标，而这个游标就包含了迭代的所有状态，因此，服务器无须为迭代记录任何状态。<br />
因为迭代的所有状态都保存在游标里面，而服务器无须为迭代保存任何状态，所以客户端可以在中途停止一个迭代，而无须对服务器进行任何通知。即使有任意数量的迭代在中途停止，也不会产生任何问题。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category algorithm
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>