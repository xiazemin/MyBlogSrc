<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">HashTable</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2020-04-15T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 15, 2020</time></p>
					</div>
					 <p>https://segmentfault.com/a/1190000022288951<br />
一、线性查找<br />
我们要通过一个键key来查找相应的值value。有一种最简单的方式，就是将键值对存放在链表里，然后遍历链表来查找是否存在key，存在则更新键对应的值，不存在则将键值对链接到链表上。</p><br />
<br />
<p>这种链表查找，最坏的时间复杂度为：O(n)，因为可能遍历到链表最后也没找到。</p><br />
<br />
<p>二、散列查找<br />
有一种算法叫散列查找，也称哈希查找，是一种空间换时间的查找算法，依赖的数据结构称为哈希表或散列表：HashTable。<br />
<!-- more --><br />
Hash: 翻译为散列，哈希，主要指压缩映射，它将一个比较大的域空间映射到一个比较小的域空间。 简单的说就是把任意长度的消息压缩到某一固定长度的消息摘要的函数。Hash 算法虽然是一种算法，但更像一种思想，没有一个固定的公式，只要符合这种思想的算法都称 Hash 算法。<br />
散列查找，主要是将键进行hash计算得出一个大整数，然后与数组长度进行取余，这样一个比较大的域空间就只会映射到数组的下标范围，利用数组索引快的特征，用空间换时间的思路，使得查找的速度快于线性查找。</p><br />
<br />
<p>首先有一个大数组，每当存一个键值对时，先把键进行哈希，计算出的哈希值是一个整数，使用这个整数对数组长度取余，映射到数组的某个下标，把该键值对存起来，取数据时按同样的步骤进行查找。</p><br />
<br />
<p>有两种方式实现哈希表：线性探测法和拉链法。</p><br />
<br />
<p>三、哈希表：线性探测法<br />
线性探测法实现的哈希表是一个大数组。</p><br />
<br />
<p>首先，哈希表数据结构会初始化N个大小的数组，然后存取键key时，会求键的哈希值hash(key)，这是一个整数。然后与数组的大小进行取余：hash(key)%N，将会知道该键值对要存在数组的哪个位置。</p><br />
<br />
<p>如果数组该位置已经被之前的键值对占领了，也就是哈希冲突，那么会偏移加1，探测下个位置是否被占用，如果下个位置为空，那么占位，否则继续探测。查找时，也是查看该位置是否为该键，不是则继续往该位置的下一个位置查找。因为这个步骤是线性的，所以叫线性探测法。</p><br />
<br />
<p>因为线性探测法很少使用，我们接下来主要分析拉链法。</p><br />
<br />
<p>四、哈希表：拉链法<br />
拉链法实现的哈希表是一个数组链表，也就是数组中的元素是链表。数组链表很像一条条拉链，所以又叫拉链法查找。</p><br />
<br />
<p>首先，哈希表数据结构会初始化N个大小的数组，然后存取键key时，会求键的哈希值hash(key)，这是一个整数。然后与数组的大小进行取余：hash(key)%N，将会知道该键值对要存在数组的哪个位置。</p><br />
<br />
<p>如果数组该位置已经被之前的键值对占领了，也就是哈希冲突，那么键值对会追加到之前键值对的后面，形成一条链表。</p><br />
<br />
<p>比如键51的哈希hash(51)假设为4，那么hash(51) % 4 = 4 % 4 = 0，所以放在数组的第一个位置，同样键43的哈希hash(43)假设为8，那么hash(43) % 4 = 8 % 4 = 0，同样要放在数组的第一个位置。</p><br />
<br />
<p>因为哈希冲突了，所以键43链接在键51后面。</p><br />
<br />
<p>查找的时候，也会继续这个过程，比如查找键43，进行哈希后得到位置0， 定位到数组第一位，然后遍历这条链表，先找到键51，发现不到，往下找，直到找到键43。</p><br />
<br />
<p>Golang内置的数据类型：字典map就是用拉链法的哈希表实现的，但相对复杂，感兴趣的可参考标准库runtime下的map.go文件。</p><br />
<br />
<p>五、哈希函数<br />
当哈希冲突不严重的时候，查找某个键，只需要求哈希值，然后取余，定位到数组的某个下标即可，时间复杂度为：O(1)。</p><br />
<br />
<p>当哈希冲突十分严重的时候，每个数组元素对应的链表会越来越长，即使定位到数组的某个下标，也要遍历一条很长很长的链表，就退化为查找链表了，时间复杂度为：O(n)。</p><br />
<br />
<p>所以哈希表首先要解决的问题是寻找相对均匀，具有很好随机分布性的哈希函数hash()，这样才不会扎堆冲突。</p><br />
<br />
<p>Golang语言实现的哈希函数参考了以下两种哈希算法：</p><br />
<br />
<p>xxhash:https://code.google.com/p/xxhash<br />
cityhash:https://code.google.com/p/cityhash<br />
当然还有其他哈希算法如MurmurHash:https://code.google.com/p/smhasher。</p><br />
<br />
<p>还有哈希算法如Md4和Md5等。</p><br />
<br />
<p>因为研究均匀随机分布的哈希算法，是属于数学专家们的工作，我们在此不展开了。</p><br />
<br />
<p>我们使用号称计算速度最快的哈希xxhash，我们直接用该库来实现哈希：https://github.com/OneOfOne/xxhash：</p><br />
<br />
<p>实现如下:</p><br />
<br />
<p>package main</p><br />
<br />
<p>import (<br />
    “fmt”<br />
    “github.com/OneOfOne/xxhash”<br />
)</p><br />
<br />
<p>// 将一个键进行Hash<br />
func XXHash(key []byte) uint64 {<br />
    h := xxhash.New64()<br />
    h.Write(key)<br />
    return h.Sum64()<br />
}</p><br />
<br />
<p>func main() {<br />
    keys := []string{“hi”, “my”, “friend”, “I”, “love”, “you”, “my”, “apple”}<br />
    for _, key := range keys {<br />
        fmt.Printf(“xxhash(‘%s’)=%d\n”, key, XXHash([]byte(key)))<br />
    }<br />
}<br />
输出：</p><br />
<br />
<p>xxhash(‘hi’)=16899831174130972922<br />
xxhash(‘my’)=13223332975333369668<br />
xxhash(‘friend’)=4642001949237932008<br />
xxhash(‘I’)=12677399051867059349<br />
xxhash(‘love’)=12577149608739438547<br />
xxhash(‘you’)=943396405629834470<br />
xxhash(‘my’)=13223332975333369668<br />
xxhash(‘apple’)=6379808199001010847<br />
拿到哈希值之后，我们要对结果取余，方便定位到数组下标index。如果数组的长度为len，那么index = xxhash(key) % len。</p><br />
<br />
<p>我们已经寻找到了计算较快，且均匀随机分布的哈希算法xxhash了，现在就是要解决取余操作中的数组长度选择的问题，数组的长度len应该如何选择？</p><br />
<br />
<p>比如数组长度len=8，那么取余之后可能有这些结果:</p><br />
<br />
<p>xxhash(key) % 8 = 0，1，2，3，4，5，6，7<br />
如果我们选择2^x作为数组长度有一个很好的优点，就是计算速度变快了，如下是一个恒等式：</p><br />
<br />
<p>恒等式 hash % 2^k = hash &amp; (2^k-1)，表示截断二进制的位数，保留后面的 k 位<br />
这样取余%操作将变成按位&amp;操作：</p><br />
<br />
<p>哈希表数组长度 len=8，<br />
存在一个哈希值 hash=165，二进制表示为 1010 0101</p><br />
<br />
<p>所以：</p><br />
<br />
<p>165 % 8 <br />
= 165 % 2^3<br />
= 165 &amp; (2^3-1)<br />
= 165 &amp; 7<br />
= 1010 0101 &amp; 0000 0111 <br />
= 0000 0000 0101 <br />
= 5<br />
选择2^x长度会使得计算速度更快，但是相当于截断二进制后保留后面的k位，如果存在很多哈希值的值很大，位数超过了k位，而二进制后k位都相同，那么会导致大片哈希冲突。</p><br />
<br />
<p>即使如此，存在很大哈希值的情况很少发生，大部分哈希值的二进制位数都不会超过k位，因此编程语言Golang使用了这种2^x长度作为哈希表的数组长度。</p><br />
<br />
<p>实际上hash(key) % len的分布是和len有关的，一组均匀分布的hash(key)在len是素数时才能做到均匀。</p><br />
<br />
<p>素数(prime number)，也叫质数，是指在大于1的自然数中，除了1和它本身以外不再有其他因数的自然数，也就是与任何数的最大公约数都为1。<br />
举例如下：</p><br />
<br />
<p>f(n)为哈希表的下标，哈希表的长度是 m，而哈希值是 n，记 w=gcd(m,n) 为两个数的最大公约数，</p><br />
<br />
<p>那么：</p><br />
<br />
<p>f(n) = n % m <br />
     = n - a<em>m (a=0,1,2,3,4…)<br />
     = w * (n/w-a</em>m/w)</p><br />
<br />
<p>因为 w=gcd(m,n)，所以 (n/w-a*m/w) 是一个整数。</p><br />
<br />
<p>所以哈希表的下标 f(n) 只会是 w=gcd(m,n) 的倍数，倍数就注定了不会均匀分布在 <code class="language-plaintext highlighter-rouge">[0,m-1]</code>，除非 w=1。</p><br />
<br />
<p>在哈希值数列数量特别多的情况，对偶数和奇数数列进行取余求下标，如长度 m=5 和 m=6：</p><br />
<br />
<p>哈希数值：2 4 6 8 10 12 14 16 18 20 22…<br />
m=5时下标：2 4 1 3 0 2 4 1 3 0 2…<br />
m=6时下标：2 4 0 2 4 0 2 4 0 2 4…</p><br />
<br />
<p>哈希数值：1 3 5 7 9 11 13 15 17…<br />
m=5时下标：1 3 0 2 4 1 3 0 2…<br />
m=6时下标：1 3 5 1 3 5 1 3 5…</p><br />
<br />
<p>偶数队列可以看到素数5一直重复 <code class="language-plaintext highlighter-rouge">2 4 1 3 0</code>，而合数6一直重复 <code class="language-plaintext highlighter-rouge">2 4 0</code>，只有素数均匀分布。</p><br />
<br />
<p>奇数队列可以看到素数5一直重复 <code class="language-plaintext highlighter-rouge">1 3 0 2 4</code>，而合数6一直重复 <code class="language-plaintext highlighter-rouge">1 3 5</code>，只有素数均匀分布。</p><br />
<br />
<p>将偶数和奇数数列合并起来，步长为1时，素数和奇数都一样均匀，仅当步长不为1时的随机数列，素数会更均匀点。<br />
我们实现拉链哈希表的时候，为了数组扩容和计算更方便，仍然还是使用2^x的数组长度。</p><br />
<br />
<p>六、实现拉链哈希表<br />
我们将实现一个简单的哈希表版本。</p><br />
<br />
<p>实现拉链哈希表有以下的一些操作：</p><br />
<br />
<p>初始化：新建一个2^x个长度的数组，一开始x较小。<br />
添加键值：进行hash(key) &amp; (2^x-1)，定位到数组下标，查找数组下标对应的链表，如果链表有该键，更新其值，否则追加元素。<br />
获取键值：进行hash(key) &amp; (2^x-1)，定位到数组下标，查找数组下标对应的链表，如果链表不存在该键，返回 false，否则返回该值以及 true。<br />
删除键值：进行hash(key) &amp; (2^x-1)，定位到数组下标，查找数组下标对应的链表，如果链表不存在该键，直接返回，否则删除该键。<br />
进行键值增删时如果数组容量太大或者太小，需要相应缩容或扩容。<br />
哈希查找的速度快，主要是利用空间换时间的优点。如果哈希表的数组特别大特别大，那么哈希冲突的几率就会降低。然而哈希表中的数组太大或太小都不行，太大浪费了空间，太小则哈希冲突太严重，所以需要对哈希表中的数组进行缩容和扩容。</p><br />
<br />
<p>如何伸缩主要根据哈希表的大小和已添加的元素数量来决定。假设哈希表的大小为16，已添加到哈希表中的键值对数量是8，我们称8/16=0.5为加载因子factor。</p><br />
<br />
<p>我们可以设定加载因子factor &lt;= 0.125时进行数组缩容，每次将容量砍半，当加载因子factor &gt;= 0.75进行数组扩容，每次将容量翻倍。</p><br />
<br />
<p>大部分编程语言实现的哈希表只会扩容，不会缩容，因为对于一个经常访问的哈希表来说，缩容后会很快扩容，造成的哈希搬迁成本巨大，这个成本比起存储空间的浪费还大，所以我们在这里只实现哈希表扩容。</p><br />
<br />
<p>我们使用结构体HashMap来表示哈希表：</p><br />
<br />
<p>const (<br />
    // 扩容因子<br />
    expandFactor = 0.75<br />
)</p><br />
<br />
<p>// 哈希表<br />
type HashMap struct {<br />
    array        []*keyPairs // 哈希表数组，每个元素是一个键值对<br />
    capacity     int         // 数组容量<br />
    len          int         // 已添加键值对元素数量<br />
    capacityMask int         // 掩码，等于 capacity-1<br />
    // 增删键值对时，需要考虑并发安全<br />
    lock sync.Mutex<br />
}</p><br />
<br />
<p>// 键值对，连成一个链表<br />
type keyPairs struct {<br />
    key   string      // 键<br />
    value interface{} // 值<br />
    next  *keyPairs   // 下一个键值对<br />
}<br />
其中array为哈希表数组，capacity为哈希表的容量，capacityMask为容量掩码，主要用来计算数组下标，len为实际添加的键值对元素数量。</p><br />
<br />
<p>我们还使用了lock来实现并发安全，防止并发增删元素时数组伸缩，产生混乱。</p><br />
<br />
<p>使用expandFactor = 0.75作为扩容因子，没什么其他的理由，只是它刚刚好，你也可以设置成0.72等任何值。</p><br />
<br />
<p>6.1. 初始化哈希表<br />
// 创建大小为 capacity 的哈希表<br />
func NewHashMap(capacity int) *HashMap {<br />
    // 默认大小为 16<br />
    defaultCapacity := 1 « 4<br />
    if capacity &lt;= defaultCapacity {<br />
        // 如果传入的大小小于默认大小，那么使用默认大小16<br />
        capacity = defaultCapacity<br />
    } else {<br />
        // 否则，实际大小为大于 capacity 的第一个 2^k<br />
        capacity = 1 « (int(math.Ceil(math.Log2(float64(capacity)))))<br />
    }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 新建一个哈希表<br />
m := new(HashMap)<br />
m.array = make([]*keyPairs, capacity, capacity)<br />
m.capacity = capacity<br />
m.capacityMask = capacity - 1<br />
return m }<br />
</code></pre></div></div><br />
<br />
<p>// 返回哈希表已添加元素数量<br />
func (m *HashMap) Len() int {<br />
    return m.len<br />
}<br />
我们可以传入capacity来初始化当前哈希表数组容量，容量掩码capacityMask = capacity-1主要用来计算数组下标。</p><br />
<br />
<p>如果传入的容量小于默认容量16，那么将16作为哈希表的初始数组大小。否则将第一个大于capacity的2 ^ k值作为数组的初始大小。</p><br />
<br />
<p>6.2. 计算哈希值和数组下标<br />
// 求 key 的哈希值<br />
var hashAlgorithm = func(key []byte) uint64 {<br />
    h := xxhash.New64()<br />
    h.Write(key)<br />
    return h.Sum64()<br />
}</p><br />
<br />
<p>// 对键进行哈希求值，并计算下标<br />
func (m *HashMap) hashIndex(key string, mask int) int {<br />
    // 求哈希<br />
    hash := hashAlgorithm([]byte(key))<br />
    // 求下标<br />
    index := hash &amp; uint64(mask)<br />
    return int(index)<br />
}<br />
首先，为结构体生成一个hashIndex方法。</p><br />
<br />
<p>根据公式hash(key) &amp; (2^x-1)，使用xxhash哈希算法来计算键key的哈希值，并且和容量掩码mask进行&amp;求得数组的下标，用来定位键值对该放在数组的哪个下标下。</p><br />
<br />
<p>6.2. 添加键值对<br />
以下是添加键值对核心方法：</p><br />
<br />
<p>// 哈希表添加键值对<br />
func (m *HashMap) Put(key string, value interface{}) {<br />
    // 实现并发安全<br />
    m.lock.Lock()<br />
    defer m.lock.Unlock()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 键值对要放的哈希表数组下标<br />
index := m.hashIndex(key, m.capacityMask)<br />
<br />
// 哈希表数组下标的元素<br />
element := m.array[index]<br />
<br />
// 元素为空，表示空链表，没有哈希冲突，直接赋值<br />
if element == nil {<br />
    m.array[index] = &amp;keyPairs{<br />
        key:   key,<br />
        value: value,<br />
    }<br />
} else {<br />
    // 链表最后一个键值对<br />
    var lastPairs *keyPairs<br />
<br />
    // 遍历链表查看元素是否存在，存在则替换值，否则找到最后一个键值对<br />
    for element != nil {<br />
        // 键值对存在，那么更新值并返回<br />
        if element.key == key {<br />
            element.value = value<br />
            return<br />
        }<br />
<br />
        lastPairs = element<br />
        element = element.next<br />
    }<br />
<br />
    // 找不到键值对，将新键值对添加到链表尾端<br />
    lastPairs.next = &amp;keyPairs{<br />
        key:   key,<br />
        value: value,<br />
    }<br />
}<br />
<br />
// 新的哈希表数量<br />
newLen := m.len + 1<br />
<br />
// 如果超出扩容因子，需要扩容<br />
if float64(newLen)/float64(m.capacity) &gt;= expandFactor {<br />
    // 新建一个原来两倍大小的哈希表<br />
    newM := new(HashMap)<br />
    newM.array = make([]*keyPairs, 2*m.capacity, 2*m.capacity)<br />
    newM.capacity = 2 * m.capacity<br />
    newM.capacityMask = 2*m.capacity - 1<br />
<br />
    // 遍历老的哈希表，将键值对重新哈希到新哈希表<br />
    for _, pairs := range m.array {<br />
        for pairs != nil {<br />
            // 直接递归Put<br />
            newM.Put(pairs.key, pairs.value)<br />
            pairs = pairs.next<br />
        }<br />
    }<br />
<br />
    // 替换老的哈希表<br />
    m.array = newM.array<br />
    m.capacity = newM.capacity<br />
    m.capacityMask = newM.capacityMask<br />
}<br />
<br />
m.len = newLen } 首先使用锁实现了并发安全：<br />
</code></pre></div></div><br />
<br />
<p>m.lock.Lock()<br />
    defer m.lock.Unlock()<br />
接着使用哈希算法计算出数组的下标，并取出该下标的元素：</p><br />
<br />
<p>// 键值对要放的哈希表数组下标<br />
    index := m.hashIndex(key, m.capacityMask)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 哈希表数组下标的元素<br />
element := m.array[index] 如果该元素为空表示链表是空的，不存在哈希冲突，直接将键值对作为链表的第一个元素：<br />
</code></pre></div></div><br />
<br />
<p>// 元素为空，表示空链表，没有哈希冲突，直接赋值<br />
    if element == nil {<br />
        m.array[index] = &amp;keyPairs{<br />
            key:   key,<br />
            value: value,<br />
        }<br />
    }<br />
否则，则遍历链表，查找键是否存在：</p><br />
<br />
<p>// 链表最后一个键值对<br />
        var lastPairs *keyPairs</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // 遍历链表查看元素是否存在，存在则替换值，否则找到最后一个键值对<br />
    for element != nil {<br />
        // 键值对存在，那么更新值并返回<br />
        if element.key == key {<br />
            element.value = value<br />
            return<br />
        }<br />
<br />
        lastPairs = element<br />
        element = element.next<br />
    } 当element.key == key，那么键存在，直接更新值，退出该函数。否则，继续往下遍历。<br />
</code></pre></div></div><br />
<br />
<p>当跳出for element != nil时，表示找不到键值对，那么往链表尾部添加该键值对：</p><br />
<br />
<p>// 找不到键值对，将新键值对添加到链表尾端<br />
        lastPairs.next = &amp;keyPairs{<br />
            key:   key,<br />
            value: value,<br />
        }<br />
最后，检查是否需要扩容，如果需要则扩容：</p><br />
<br />
<p>// 新的哈希表数量<br />
         newLen := m.len + 1</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     // 如果超出扩容因子，需要扩容<br />
     if float64(newLen)/float64(m.capacity) &gt;= expandFactor {<br />
         // 新建一个原来两倍大小的哈希表<br />
         newM := new(HashMap)<br />
         newM.array = make([]*keyPairs, 2*m.capacity, 2*m.capacity)<br />
         newM.capacity = 2 * m.capacity<br />
         newM.capacityMask = 2*m.capacity - 1<br />
<br />
         // 遍历老的哈希表，将键值对重新哈希到新哈希表<br />
         for _, pairs := range m.array {<br />
             for pairs != nil {<br />
                 // 直接递归Put<br />
                 newM.Put(pairs.key, pairs.value)<br />
                 pairs = pairs.next<br />
             }<br />
         }<br />
<br />
         // 替换老的哈希表<br />
         m.array = newM.array<br />
         m.capacity = newM.capacity<br />
         m.capacityMask = newM.capacityMask<br />
     }<br />
<br />
     m.len = newLen 创建了一个新的两倍大小的哈希表：newM := new(HashMap)，然后遍历老哈希表中的键值对，重新Put进新哈希表。<br />
</code></pre></div></div><br />
<br />
<p>最后将新哈希表的属性赋予老哈希表。</p><br />
<br />
<p>6.3. 获取键值对<br />
// 哈希表获取键值对<br />
func (m *HashMap) Get(key string) (value interface{}, ok bool) {<br />
    // 实现并发安全<br />
    m.lock.Lock()<br />
    defer m.lock.Unlock()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 键值对要放的哈希表数组下标<br />
index := m.hashIndex(key, m.capacityMask)<br />
<br />
// 哈希表数组下标的元素<br />
element := m.array[index]<br />
<br />
// 遍历链表查看元素是否存在，存在则返回<br />
for element != nil {<br />
    if element.key == key {<br />
        return element.value, true<br />
    }<br />
<br />
    element = element.next<br />
}<br />
<br />
return } 同样先加锁实现并发安全，然后进行哈希算法计算出数组下标：index := m.hashIndex(key, m.capacityMask)，取出元素：element := m.array[index]。<br />
</code></pre></div></div><br />
<br />
<p>对链表进行遍历：</p><br />
<br />
<p>// 遍历链表查看元素是否存在，存在则返回<br />
    for element != nil {<br />
        if element.key == key {<br />
            return element.value, true<br />
        }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    element = element.next<br />
} 如果键在哈希表中存在，返回键的值element.value和true。<br />
</code></pre></div></div><br />
<br />
<p>6.4. 删除键值对<br />
// 哈希表删除键值对<br />
func (m *HashMap) Delete(key string) {<br />
    // 实现并发安全<br />
    m.lock.Lock()<br />
    defer m.lock.Unlock()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 键值对要放的哈希表数组下标<br />
index := m.hashIndex(key, m.capacityMask)<br />
<br />
// 哈希表数组下标的元素<br />
element := m.array[index]<br />
<br />
// 空链表，不用删除，直接返回<br />
if element == nil {<br />
    return<br />
}<br />
<br />
// 链表的第一个元素就是要删除的元素<br />
if element.key == key {<br />
    // 将第一个元素后面的键值对链上<br />
    m.array[index] = element.next<br />
    m.len = m.len - 1<br />
    return<br />
}<br />
<br />
// 下一个键值对<br />
nextElement := element.next<br />
for nextElement != nil {<br />
    if nextElement.key == key {<br />
        // 键值对匹配到，将该键值对从链中去掉<br />
        element.next = nextElement.next<br />
        m.len = m.len - 1<br />
        return<br />
    }<br />
<br />
    element = nextElement<br />
    nextElement = nextElement.next<br />
} } 删除键值对，如果键值对存在，那么删除，否则什么都不做。<br />
</code></pre></div></div><br />
<br />
<p>键值对删除时，哈希表并不会缩容，我们不实现缩容。</p><br />
<br />
<p>同样先加锁实现并发安全，然后进行哈希算法计算出数组下标：index := m.hashIndex(key, m.capacityMask)，取出元素：element := m.array[index]。</p><br />
<br />
<p>如果元素是空的，表示链表为空，那么直接返回：</p><br />
<br />
<p>// 空链表，不用删除，直接返回<br />
    if element == nil {<br />
        return<br />
    }<br />
否则查看链表第一个元素的键是否匹配：element.key == key，如果匹配，那么对链表头部进行替换，链表的第二个元素补位成为链表头部：</p><br />
<br />
<p>// 链表的第一个元素就是要删除的元素<br />
    if element.key == key {<br />
        // 将第一个元素后面的键值对链上<br />
        m.array[index] = element.next<br />
        m.len = m.len - 1<br />
        return<br />
    }<br />
如果链表的第一个元素不匹配，那么从第二个元素开始遍历链表，找到时将该键值对删除，然后将前后两个键值对连接起来：</p><br />
<br />
<p>// 下一个键值对<br />
    nextElement := element.next<br />
    for nextElement != nil {<br />
        if nextElement.key == key {<br />
            // 键值对匹配到，将该键值对从链中去掉<br />
            element.next = nextElement.next<br />
            m.len = m.len - 1<br />
            return<br />
        }</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    element = nextElement<br />
    nextElement = nextElement.next<br />
} 6.4. 遍历打印哈希表 // 哈希表遍历 func (m *HashMap) Range() {<br />
// 实现并发安全<br />
m.lock.Lock()<br />
defer m.lock.Unlock()<br />
for _, pairs := range m.array {<br />
    for pairs != nil {<br />
        fmt.Printf("'%v'='%v',", pairs.key, pairs.value)<br />
        pairs = pairs.next<br />
    }<br />
}<br />
<br />
fmt.Println() } 遍历哈希表比较简单，粗暴的遍历数组，如果数组中的链表不为空，打印链表中的元素。<br />
</code></pre></div></div><br />
<br />
<p>6.4. 示例运行<br />
func main() {<br />
    // 新建一个哈希表<br />
    hashMap := NewHashMap(16)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 放35个值<br />
for i := 0; i &lt; 35; i++ {<br />
    hashMap.Put(fmt.Sprintf("%d", i), fmt.Sprintf("v%d", i))<br />
}<br />
fmt.Println("cap:", hashMap.Capacity(), "len:", hashMap.Len())<br />
<br />
// 打印全部键值对<br />
hashMap.Range()<br />
<br />
key := "4"<br />
value, ok := hashMap.Get(key)<br />
if ok {<br />
    fmt.Printf("get '%v'='%v'\n", key, value)<br />
} else {<br />
    fmt.Printf("get %v not found\n", key)<br />
}<br />
<br />
// 删除键<br />
hashMap.Delete(key)<br />
fmt.Println("after delete cap:", hashMap.Capacity(), "len:", hashMap.Len())<br />
value, ok = hashMap.Get(key)<br />
if ok {<br />
    fmt.Printf("get '%v'='%v'\n", key, value)<br />
} else {<br />
    fmt.Printf("get %v not found\n", key)<br />
} } 输出：<br />
</code></pre></div></div><br />
<br />
<p>cap: 128 len: 35<br />
‘20’=’v20’,’16’=’v16’,’4’=’v4’,’32’=’v32’,’2’=’v2’,’28’=’v28’,’24’=’v24’,’10’=’v10’,’9’=’v9’,’15’=’v15’,’12’=’v12’,’29’=’v29’,’3’=’v3’,’19’=’v19’,’30’=’v30’,’27’=’v27’,’14’=’v14’,’13’=’v13’,’22’=’v22’,’7’=’v7’,’11’=’v11’,’23’=’v23’,’1’=’v1’,’31’=’v31’,’18’=’v18’,’17’=’v17’,’8’=’v8’,’26’=’v26’,’25’=’v25’,’0’=’v0’,’5’=’v5’,’34’=’v34’,’21’=’v21’,’6’=’v6’,’33’=’v33’,<br />
get ‘4’=’v4’<br />
after delete cap: 128 len: 34<br />
get 4 not found<br />
首先hashMap := NewHashMap(16)新建一个16容量的哈希表。然后往哈希表填充35个键值对，遍历打印出来hashMap.Range()。</p><br />
<br />
<p>可以看到容量从16一直翻倍到128，而打印出来的键值对是随机的。</p><br />
<br />
<p>获取键值对时：value, ok := hashMap.Get(key)能正常获取到值：get ‘4’=’v4’。</p><br />
<br />
<p>删除键值对：hashMap.Delete(key)后，哈希表的容量不变，但元素数量变少：after delete cap: 128 len: 34。</p><br />
<br />
<p>尝试再一次获取键4，报错：get 4 not found。</p><br />
<br />
<p>七. 总结<br />
哈希表查找，是一种用空间换时间的查找算法，时间复杂度能达到：O(1)，最坏情况下退化到查找链表：O(n)。但均匀性很好的哈希算法以及合适空间大小的数组，在很大概率避免了最坏情况。</p><br />
<br />
<p>哈希表在添加元素时会进行伸缩，会造成较大的性能消耗，所以有时候会用到其他的查找算法：树查找算法。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category algorithm
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>