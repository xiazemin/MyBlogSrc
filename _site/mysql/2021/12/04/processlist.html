<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">processlist</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2021-12-04T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Dec 4, 2021</time></p>
					</div>
					 <p>he status variables have the following meanings.</p><br />
<br />
<p>Aborted_clients</p><br />
<br />
<p>The number of connections that were aborted because the client died without closing the connection properly. See Section B.3.2.10, “Communication Errors and Aborted Connections”.</p><br />
<br />
<p>Aborted_connects</p><br />
<br />
<p>The number of failed attempts to connect to the MySQL server. See Section B.3.2.10, “Communication Errors and Aborted Connections”.</p><br />
<br />
<p>For additional connection-related information, check the Connection_errors_xxx status variables and the host_cache table.</p><br />
<br />
<p>Binlog_cache_disk_use</p><br />
<br />
<p>The number of transactions that used the temporary binary log cache but that exceeded the value of binlog_cache_size and used a temporary file to store statements from the transaction.</p><br />
<br />
<p>The number of nontransactional statements that caused the binary log transaction cache to be written to disk is tracked separately in the Binlog_stmt_cache_disk_use status variable.</p><br />
<br />
<p>Binlog_cache_use</p><br />
<br />
<p>The number of transactions that used the binary log cache.</p><br />
<br />
<p>Binlog_stmt_cache_disk_use</p><br />
<br />
<p>The number of nontransaction statements that used the binary log statement cache but that exceeded the value of binlog_stmt_cache_size and used a temporary file to store those statements.</p><br />
<br />
<p>Binlog_stmt_cache_use</p><br />
<br />
<p>The number of nontransactional statements that used the binary log statement cache.</p><br />
<br />
<p>Bytes_received</p><br />
<br />
<p>The number of bytes received from all clients.</p><br />
<br />
<p>Bytes_sent</p><br />
<br />
<p>The number of bytes sent to all clients.</p><br />
<br />
<p>Com_xxx</p><br />
<br />
<p>The Com_xxx statement counter variables indicate the number of times each xxx statement has been executed. There is one status variable for each type of statement. For example, Com_delete and Com_update count DELETE and UPDATE statements, respectively. Com_delete_multi and Com_update_multi are similar but apply to DELETE and UPDATE statements that use multiple-table syntax.</p><br />
<br />
<p>If a query result is returned from query cache, the server increments the Qcache_hits status variable, not Com_select. See Section 8.10.3.4, “Query Cache Status and Maintenance”.</p><br />
<br />
<p>All Com_stmt_xxx variables are increased even if a prepared statement argument is unknown or an error occurred during execution. In other words, their values correspond to the number of requests issued, not to the number of requests successfully completed.</p><br />
<br />
<p>The Com_stmt_xxx status variables are as follows:</p><br />
<br />
<p>Com_stmt_prepare</p><br />
<br />
<p>Com_stmt_execute</p><br />
<br />
<p>Com_stmt_fetch</p><br />
<br />
<p>Com_stmt_send_long_data</p><br />
<br />
<p>Com_stmt_reset</p><br />
<br />
<p>Com_stmt_close</p><br />
<br />
<p>Those variables stand for prepared statement commands. Their names refer to the COM_xxx command set used in the network layer. In other words, their values increase whenever prepared statement API calls such as mysql_stmt_prepare(), mysql_stmt_execute(), and so forth are executed. However, Com_stmt_prepare, Com_stmt_execute and Com_stmt_close also increase for PREPARE, EXECUTE, or DEALLOCATE PREPARE, respectively. Additionally, the values of the older statement counter variables Com_prepare_sql, Com_execute_sql, and Com_dealloc_sql increase for the PREPARE, EXECUTE, and DEALLOCATE PREPARE statements. Com_stmt_fetch stands for the total number of network round-trips issued when fetching from cursors.</p><br />
<br />
<p>Com_stmt_reprepare indicates the number of times statements were automatically reprepared by the server after metadata changes to tables or views referred to by the statement. A reprepare operation increments Com_stmt_reprepare, and also Com_stmt_prepare.</p><br />
<br />
<p>Compression</p><br />
<br />
<p>Whether the client connection uses compression in the client/server protocol.</p><br />
<br />
<p>Connection_errors_xxx</p><br />
<br />
<p>These variables provide information about errors that occur during the client connection process. They are global only and represent error counts aggregated across connections from all hosts. These variables track errors not accounted for by the host cache (see Section 5.1.11.2, “DNS Lookups and the Host Cache”), such as errors that are not associated with TCP connections, occur very early in the connection process (even before an IP address is known), or are not specific to any particular IP address (such as out-of-memory conditions).</p><br />
<br />
<p>Connection_errors_accept</p><br />
<br />
<p>The number of errors that occurred during calls to accept() on the listening port.</p><br />
<br />
<p>Connection_errors_internal</p><br />
<br />
<p>The number of connections refused due to internal errors in the server, such as failure to start a new thread or an out-of-memory condition.</p><br />
<br />
<p>Connection_errors_max_connections</p><br />
<br />
<p>The number of connections refused because the server max_connections limit was reached.</p><br />
<br />
<p>Connection_errors_peer_address</p><br />
<br />
<p>The number of errors that occurred while searching for connecting client IP addresses.</p><br />
<br />
<p>Connection_errors_select</p><br />
<br />
<p>The number of errors that occurred during calls to select() or poll() on the listening port. (Failure of this operation does not necessarily means a client connection was rejected.)</p><br />
<br />
<p>Connection_errors_tcpwrap</p><br />
<br />
<p>The number of connections refused by the libwrap library.</p><br />
<br />
<p>Connections</p><br />
<br />
<p>The number of connection attempts (successful or not) to the MySQL server.</p><br />
<br />
<p>Created_tmp_disk_tables</p><br />
<br />
<p>The number of internal on-disk temporary tables created by the server while executing statements.</p><br />
<br />
<p>You can compare the number of internal on-disk temporary tables created to the total number of internal temporary tables created by comparing Created_tmp_disk_tables and Created_tmp_tables values.</p><br />
<br />
<p>See also Section 8.4.4, “Internal Temporary Table Use in MySQL”.</p><br />
<br />
<p>Created_tmp_files</p><br />
<br />
<p>How many temporary files mysqld has created.</p><br />
<br />
<p>Created_tmp_tables</p><br />
<br />
<p>The number of internal temporary tables created by the server while executing statements.</p><br />
<br />
<p>You can compare the number of internal on-disk temporary tables created to the total number of internal temporary tables created by comparing Created_tmp_disk_tables and Created_tmp_tables values.</p><br />
<br />
<p>See also Section 8.4.4, “Internal Temporary Table Use in MySQL”.</p><br />
<br />
<p>Each invocation of the SHOW STATUS statement uses an internal temporary table and increments the global Created_tmp_tables value.</p><br />
<br />
<p>Delayed_errors</p><br />
<br />
<p>The number of rows written with INSERT DELAYED for which some error occurred (probably duplicate key).</p><br />
<br />
<p>This status variable is deprecated (because DELAYED inserts are deprecated); expect it to be removed in a future release.</p><br />
<br />
<p>Delayed_insert_threads</p><br />
<br />
<p>The number of INSERT DELAYED handler threads in use for nontransactional tables.</p><br />
<br />
<p>This status variable is deprecated (because DELAYED inserts are deprecated); expect it to be removed in a future release.</p><br />
<br />
<p>Delayed_writes</p><br />
<br />
<p>The number of INSERT DELAYED rows written to nontransactional tables.</p><br />
<br />
<p>This status variable is deprecated (because DELAYED inserts are deprecated); expect it to be removed in a future release.</p><br />
<br />
<p>Flush_commands</p><br />
<br />
<p>The number of times the server flushes tables, whether because a user executed a FLUSH TABLES statement or due to internal server operation. It is also incremented by receipt of a COM_REFRESH packet. This is in contrast to Com_flush, which indicates how many FLUSH statements have been executed, whether FLUSH TABLES, FLUSH LOGS, and so forth.</p><br />
<br />
<p>Handler_commit</p><br />
<br />
<p>The number of internal COMMIT statements.</p><br />
<br />
<p>Handler_delete</p><br />
<br />
<p>The number of times that rows have been deleted from tables.</p><br />
<br />
<p>Handler_external_lock</p><br />
<br />
<p>The server increments this variable for each call to its external_lock() function, which generally occurs at the beginning and end of access to a table instance. There might be differences among storage engines. This variable can be used, for example, to discover for a statement that accesses a partitioned table how many partitions were pruned before locking occurred: Check how much the counter increased for the statement, subtract 2 (2 calls for the table itself), then divide by 2 to get the number of partitions locked.</p><br />
<br />
<p>Handler_mrr_init</p><br />
<br />
<p>The number of times the server uses a storage engine’s own Multi-Range Read implementation for table access.</p><br />
<br />
<p>Handler_prepare</p><br />
<br />
<p>A counter for the prepare phase of two-phase commit operations.</p><br />
<br />
<p>Handler_read_first</p><br />
<br />
<p>The number of times the first entry in an index was read. If this value is high, it suggests that the server is doing a lot of full index scans (for example, SELECT col1 FROM foo, assuming that col1 is indexed).</p><br />
<br />
<p>Handler_read_key</p><br />
<br />
<p>The number of requests to read a row based on a key. If this value is high, it is a good indication that your tables are properly indexed for your queries.</p><br />
<br />
<p>Handler_read_last</p><br />
<br />
<p>The number of requests to read the last key in an index. With ORDER BY, the server issues a first-key request followed by several next-key requests, whereas with ORDER BY DESC, the server issues a last-key request followed by several previous-key requests.</p><br />
<br />
<p>Handler_read_next</p><br />
<br />
<p>The number of requests to read the next row in key order. This value is incremented if you are querying an index column with a range constraint or if you are doing an index scan.</p><br />
<br />
<p>Handler_read_prev</p><br />
<br />
<p>The number of requests to read the previous row in key order. This read method is mainly used to optimize ORDER BY … DESC.</p><br />
<br />
<p>Handler_read_rnd</p><br />
<br />
<p>The number of requests to read a row based on a fixed position. This value is high if you are doing a lot of queries that require sorting of the result. You probably have a lot of queries that require MySQL to scan entire tables or you have joins that do not use keys properly.</p><br />
<br />
<p>Handler_read_rnd_next</p><br />
<br />
<p>The number of requests to read the next row in the data file. This value is high if you are doing a lot of table scans. Generally this suggests that your tables are not properly indexed or that your queries are not written to take advantage of the indexes you have.</p><br />
<br />
<p>Handler_rollback</p><br />
<br />
<p>The number of requests for a storage engine to perform a rollback operation.</p><br />
<br />
<p>Handler_savepoint</p><br />
<br />
<p>The number of requests for a storage engine to place a savepoint.</p><br />
<br />
<p>Handler_savepoint_rollback</p><br />
<br />
<p>The number of requests for a storage engine to roll back to a savepoint.</p><br />
<br />
<p>Handler_update</p><br />
<br />
<p>The number of requests to update a row in a table.</p><br />
<br />
<p>Handler_write</p><br />
<br />
<p>The number of requests to insert a row in a table.</p><br />
<br />
<p>Innodb_available_undo_logs</p><br />
<br />
<p>The total number of available InnoDB rollback segments. Supplements the innodb_rollback_segments system variable, which defines the number of active rollback segments.</p><br />
<br />
<p>Innodb_buffer_pool_dump_status</p><br />
<br />
<p>The progress of an operation to record the pages held in the InnoDB buffer pool, triggered by the setting of innodb_buffer_pool_dump_at_shutdown or innodb_buffer_pool_dump_now.</p><br />
<br />
<p>For related information and examples, see Section 14.8.3.5, “Saving and Restoring the Buffer Pool State”.</p><br />
<br />
<p>Innodb_buffer_pool_load_status</p><br />
<br />
<p>The progress of an operation to warm up the InnoDB buffer pool by reading in a set of pages corresponding to an earlier point in time, triggered by the setting of innodb_buffer_pool_load_at_startup or innodb_buffer_pool_load_now. If the operation introduces too much overhead, you can cancel it by setting innodb_buffer_pool_load_abort.</p><br />
<br />
<p>For related information and examples, see Section 14.8.3.5, “Saving and Restoring the Buffer Pool State”.</p><br />
<br />
<p>Innodb_buffer_pool_bytes_data</p><br />
<br />
<p>The total number of bytes in the InnoDB buffer pool containing data. The number includes both dirty and clean pages. For more accurate memory usage calculations than with Innodb_buffer_pool_pages_data, when compressed tables cause the buffer pool to hold pages of different sizes.</p><br />
<br />
<p>Innodb_buffer_pool_pages_data</p><br />
<br />
<p>The number of pages in the InnoDB buffer pool containing data. The number includes both dirty and clean pages. When using compressed tables, the reported Innodb_buffer_pool_pages_data value may be larger than Innodb_buffer_pool_pages_total (Bug #59550).</p><br />
<br />
<p>Innodb_buffer_pool_bytes_dirty</p><br />
<br />
<p>The total current number of bytes held in dirty pages in the InnoDB buffer pool. For more accurate memory usage calculations than with Innodb_buffer_pool_pages_dirty, when compressed tables cause the buffer pool to hold pages of different sizes.</p><br />
<br />
<p>Innodb_buffer_pool_pages_dirty</p><br />
<br />
<p>The current number of dirty pages in the InnoDB buffer pool.</p><br />
<br />
<p>Innodb_buffer_pool_pages_flushed</p><br />
<br />
<p>The number of requests to flush pages from the InnoDB buffer pool.</p><br />
<br />
<p>Innodb_buffer_pool_pages_free</p><br />
<br />
<p>The number of free pages in the InnoDB buffer pool.</p><br />
<br />
<p>Innodb_buffer_pool_pages_latched</p><br />
<br />
<p>The number of latched pages in the InnoDB buffer pool. These are pages currently being read or written, or that cannot be flushed or removed for some other reason. Calculation of this variable is expensive, so it is available only when the UNIV_DEBUG system is defined at server build time.</p><br />
<br />
<p>Innodb_buffer_pool_pages_misc</p><br />
<br />
<p>The number of pages in the InnoDB buffer pool that are busy because they have been allocated for administrative overhead, such as row locks or the adaptive hash index. This value can also be calculated as Innodb_buffer_pool_pages_total − Innodb_buffer_pool_pages_free − Innodb_buffer_pool_pages_data. When using compressed tables, Innodb_buffer_pool_pages_misc may report an out-of-bounds value (Bug #59550).</p><br />
<br />
<p>Innodb_buffer_pool_pages_total</p><br />
<br />
<p>The total size of the InnoDB buffer pool, in pages. When using compressed tables, the reported Innodb_buffer_pool_pages_data value may be larger than Innodb_buffer_pool_pages_total (Bug #59550)</p><br />
<br />
<p>Innodb_buffer_pool_read_ahead</p><br />
<br />
<p>The number of pages read into the InnoDB buffer pool by the read-ahead background thread.</p><br />
<br />
<p>Innodb_buffer_pool_read_ahead_evicted</p><br />
<br />
<p>The number of pages read into the InnoDB buffer pool by the read-ahead background thread that were subsequently evicted without having been accessed by queries.</p><br />
<br />
<p>Innodb_buffer_pool_read_ahead_rnd</p><br />
<br />
<p>The number of “random” read-aheads initiated by InnoDB. This happens when a query scans a large portion of a table but in random order.</p><br />
<br />
<p>Innodb_buffer_pool_read_requests</p><br />
<br />
<p>The number of logical read requests.</p><br />
<br />
<p>Innodb_buffer_pool_reads</p><br />
<br />
<p>The number of logical reads that InnoDB could not satisfy from the buffer pool, and had to read directly from disk.</p><br />
<br />
<p>Innodb_buffer_pool_wait_free</p><br />
<br />
<p>Normally, writes to the InnoDB buffer pool happen in the background. When InnoDB needs to read or create a page and no clean pages are available, InnoDB flushes some dirty pages first and waits for that operation to finish. This counter counts instances of these waits. If innodb_buffer_pool_size has been set properly, this value should be small.</p><br />
<br />
<p>Innodb_buffer_pool_write_requests</p><br />
<br />
<p>The number of writes done to the InnoDB buffer pool.</p><br />
<br />
<p>Innodb_data_fsyncs</p><br />
<br />
<p>The number of fsync() operations so far. The frequency of fsync() calls is influenced by the setting of the innodb_flush_method configuration option.</p><br />
<br />
<p>Innodb_data_pending_fsyncs</p><br />
<br />
<p>The current number of pending fsync() operations. The frequency of fsync() calls is influenced by the setting of the innodb_flush_method configuration option.</p><br />
<br />
<p>Innodb_data_pending_reads</p><br />
<br />
<p>The current number of pending reads.</p><br />
<br />
<p>Innodb_data_pending_writes</p><br />
<br />
<p>The current number of pending writes.</p><br />
<br />
<p>Innodb_data_read</p><br />
<br />
<p>The amount of data read since the server was started (in bytes).</p><br />
<br />
<p>Innodb_data_reads</p><br />
<br />
<p>The total number of data reads (OS file reads).</p><br />
<br />
<p>Innodb_data_writes</p><br />
<br />
<p>The total number of data writes.</p><br />
<br />
<p>Innodb_data_written</p><br />
<br />
<p>The amount of data written so far, in bytes.</p><br />
<br />
<p>Innodb_dblwr_pages_written</p><br />
<br />
<p>The number of pages that have been written to the doublewrite buffer. See Section 14.12.1, “InnoDB Disk I/O”.</p><br />
<br />
<p>Innodb_dblwr_writes</p><br />
<br />
<p>The number of doublewrite operations that have been performed. See Section 14.12.1, “InnoDB Disk I/O”.</p><br />
<br />
<p>Innodb_have_atomic_builtins</p><br />
<br />
<p>Indicates whether the server was built with atomic instructions.</p><br />
<br />
<p>Innodb_log_waits</p><br />
<br />
<p>The number of times that the log buffer was too small and a wait was required for it to be flushed before continuing.</p><br />
<br />
<p>Innodb_log_write_requests</p><br />
<br />
<p>The number of write requests for the InnoDB redo log.</p><br />
<br />
<p>Innodb_log_writes</p><br />
<br />
<p>The number of physical writes to the InnoDB redo log file.</p><br />
<br />
<p>Innodb_num_open_files</p><br />
<br />
<p>The number of files InnoDB currently holds open.</p><br />
<br />
<p>Innodb_os_log_fsyncs</p><br />
<br />
<p>The number of fsync() writes done to the InnoDB redo log files.</p><br />
<br />
<p>Innodb_os_log_pending_fsyncs</p><br />
<br />
<p>The number of pending fsync() operations for the InnoDB redo log files.</p><br />
<br />
<p>Innodb_os_log_pending_writes</p><br />
<br />
<p>The number of pending writes to the InnoDB redo log files.</p><br />
<br />
<p>Innodb_os_log_written</p><br />
<br />
<p>The number of bytes written to the InnoDB redo log files.</p><br />
<br />
<p>Innodb_page_size</p><br />
<br />
<p>InnoDB page size (default 16KB). Many values are counted in pages; the page size enables them to be easily converted to bytes.</p><br />
<br />
<p>Innodb_pages_created</p><br />
<br />
<p>The number of pages created by operations on InnoDB tables.</p><br />
<br />
<p>Innodb_pages_read</p><br />
<br />
<p>The number of pages read from the InnoDB buffer pool by operations on InnoDB tables.</p><br />
<br />
<p>Innodb_pages_written</p><br />
<br />
<p>The number of pages written by operations on InnoDB tables.</p><br />
<br />
<p>Innodb_row_lock_current_waits</p><br />
<br />
<p>The number of row locks currently being waited for by operations on InnoDB tables.</p><br />
<br />
<p>Innodb_row_lock_time</p><br />
<br />
<p>The total time spent in acquiring row locks for InnoDB tables, in milliseconds.</p><br />
<br />
<p>Innodb_row_lock_time_avg</p><br />
<br />
<p>The average time to acquire a row lock for InnoDB tables, in milliseconds.</p><br />
<br />
<p>Innodb_row_lock_time_max</p><br />
<br />
<p>The maximum time to acquire a row lock for InnoDB tables, in milliseconds.</p><br />
<br />
<p>Innodb_row_lock_waits</p><br />
<br />
<p>The number of times operations on InnoDB tables had to wait for a row lock.</p><br />
<br />
<p>Innodb_rows_deleted</p><br />
<br />
<p>The number of rows deleted from InnoDB tables.</p><br />
<br />
<p>Innodb_rows_inserted</p><br />
<br />
<p>The number of rows inserted into InnoDB tables.</p><br />
<br />
<p>Innodb_rows_read</p><br />
<br />
<p>The number of rows read from InnoDB tables.</p><br />
<br />
<p>Innodb_rows_updated</p><br />
<br />
<p>The number of rows updated in InnoDB tables.</p><br />
<br />
<p>Innodb_truncated_status_writes</p><br />
<br />
<p>The number of times output from the SHOW ENGINE INNODB STATUS statement has been truncated.</p><br />
<br />
<p>Key_blocks_not_flushed</p><br />
<br />
<p>The number of key blocks in the MyISAM key cache that have changed but have not yet been flushed to disk.</p><br />
<br />
<p>Key_blocks_unused</p><br />
<br />
<p>The number of unused blocks in the MyISAM key cache. You can use this value to determine how much of the key cache is in use; see the discussion of key_buffer_size in Section 5.1.7, “Server System Variables”.</p><br />
<br />
<p>Key_blocks_used</p><br />
<br />
<p>The number of used blocks in the MyISAM key cache. This value is a high-water mark that indicates the maximum number of blocks that have ever been in use at one time.</p><br />
<br />
<p>Key_read_requests</p><br />
<br />
<p>The number of requests to read a key block from the MyISAM key cache.</p><br />
<br />
<p>Key_reads</p><br />
<br />
<p>The number of physical reads of a key block from disk into the MyISAM key cache. If Key_reads is large, then your key_buffer_size value is probably too small. The cache miss rate can be calculated as Key_reads/Key_read_requests.</p><br />
<br />
<p>Key_write_requests</p><br />
<br />
<p>The number of requests to write a key block to the MyISAM key cache.</p><br />
<br />
<p>Key_writes</p><br />
<br />
<p>The number of physical writes of a key block from the MyISAM key cache to disk.</p><br />
<br />
<p>Last_query_cost</p><br />
<br />
<p>The total cost of the last compiled query as computed by the query optimizer. This is useful for comparing the cost of different query plans for the same query. The default value of 0 means that no query has been compiled yet. The default value is 0. Last_query_cost has session scope.</p><br />
<br />
<p>Last_query_cost can be computed accurately only for simple, “flat” queries, but not for complex queries such as those containing subqueries or UNION. For the latter, the value is set to 0.</p><br />
<br />
<p>Last_query_partial_plans</p><br />
<br />
<p>The number of iterations the query optimizer made in execution plan construction for the previous query. Last_query_cost has session scope.</p><br />
<br />
<p>Max_used_connections</p><br />
<br />
<p>The maximum number of connections that have been in use simultaneously since the server started.</p><br />
<br />
<p>Not_flushed_delayed_rows</p><br />
<br />
<p>The number of rows waiting to be written to nontransactional tables in INSERT DELAYED queues.</p><br />
<br />
<p>This status variable is deprecated (because DELAYED inserts are deprecated); expect it to be removed in a future release.</p><br />
<br />
<p>Open_files</p><br />
<br />
<p>The number of files that are open. This count includes regular files opened by the server. It does not include other types of files such as sockets or pipes. Also, the count does not include files that storage engines open using their own internal functions rather than asking the server level to do so.</p><br />
<br />
<p>Open_streams</p><br />
<br />
<p>The number of streams that are open (used mainly for logging).</p><br />
<br />
<p>Open_table_definitions</p><br />
<br />
<p>The number of cached .frm files.</p><br />
<br />
<p>Open_tables</p><br />
<br />
<p>The number of tables that are open.</p><br />
<br />
<p>Opened_files</p><br />
<br />
<p>The number of files that have been opened with my_open() (a mysys library function). Parts of the server that open files without using this function do not increment the count.</p><br />
<br />
<p>Opened_table_definitions</p><br />
<br />
<p>The number of .frm files that have been cached.</p><br />
<br />
<p>Opened_tables</p><br />
<br />
<p>The number of tables that have been opened. If Opened_tables is big, your table_open_cache value is probably too small.</p><br />
<br />
<p>Performance_schema_xxx</p><br />
<br />
<p>Performance Schema status variables are listed in Section 22.16, “Performance Schema Status Variables”. These variables provide information about instrumentation that could not be loaded or created due to memory constraints.</p><br />
<br />
<p>Prepared_stmt_count</p><br />
<br />
<p>The current number of prepared statements. (The maximum number of statements is given by the max_prepared_stmt_count system variable.)</p><br />
<br />
<p>Qcache_free_blocks</p><br />
<br />
<p>The number of free memory blocks in the query cache.</p><br />
<br />
<p>Qcache_free_memory</p><br />
<br />
<p>The amount of free memory for the query cache.</p><br />
<br />
<p>Qcache_hits</p><br />
<br />
<p>The number of query cache hits.</p><br />
<br />
<p>The discussion at the beginning of this section indicates how to relate this statement-counting status variable to other such variables.</p><br />
<br />
<p>Qcache_inserts</p><br />
<br />
<p>The number of queries added to the query cache.</p><br />
<br />
<p>Qcache_lowmem_prunes</p><br />
<br />
<p>The number of queries that were deleted from the query cache because of low memory.</p><br />
<br />
<p>Qcache_not_cached</p><br />
<br />
<p>The number of noncached queries (not cacheable, or not cached due to the query_cache_type setting).</p><br />
<br />
<p>Qcache_queries_in_cache</p><br />
<br />
<p>The number of queries registered in the query cache.</p><br />
<br />
<p>Qcache_total_blocks</p><br />
<br />
<p>The total number of blocks in the query cache.</p><br />
<br />
<p>Queries</p><br />
<br />
<p>The number of statements executed by the server. This variable includes statements executed within stored programs, unlike the Questions variable. It does not count COM_PING or COM_STATISTICS commands.</p><br />
<br />
<p>The discussion at the beginning of this section indicates how to relate this statement-counting status variable to other such variables.</p><br />
<br />
<p>Questions</p><br />
<br />
<p>The number of statements executed by the server. This includes only statements sent to the server by clients and not statements executed within stored programs, unlike the Queries variable. This variable does not count COM_PING, COM_STATISTICS, COM_STMT_PREPARE, COM_STMT_CLOSE, or COM_STMT_RESET commands.</p><br />
<br />
<p>The discussion at the beginning of this section indicates how to relate this statement-counting status variable to other such variables.</p><br />
<br />
<p>Rpl_semi_sync_master_clients</p><br />
<br />
<p>The number of semisynchronous replicas.</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_net_avg_wait_time</p><br />
<br />
<p>The average time in microseconds the source waited for a replica reply.</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_net_wait_time</p><br />
<br />
<p>The total time in microseconds the source waited for replica replies.</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_net_waits</p><br />
<br />
<p>The total number of times the source waited for replica replies.</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_no_times</p><br />
<br />
<p>The number of times the source turned off semisynchronous replication.</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_no_tx</p><br />
<br />
<p>The number of commits that were not acknowledged successfully by a replica.</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_status</p><br />
<br />
<p>Whether semisynchronous replication currently is operational on the source. The value is ON if the plugin has been enabled and a commit acknowledgment has occurred. It is OFF if the plugin is not enabled or the source has fallen back to asynchronous replication due to commit acknowledgment timeout.</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_timefunc_failures</p><br />
<br />
<p>The number of times the source failed when calling time functions such as gettimeofday().</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_tx_avg_wait_time</p><br />
<br />
<p>The average time in microseconds the source waited for each transaction.</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_tx_wait_time</p><br />
<br />
<p>The total time in microseconds the source waited for transactions.</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_tx_waits</p><br />
<br />
<p>The total number of times the source waited for transactions.</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_wait_pos_backtraverse</p><br />
<br />
<p>The total number of times the source waited for an event with binary coordinates lower than events waited for previously. This can occur when the order in which transactions start waiting for a reply is different from the order in which their binary log events are written.</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_wait_sessions</p><br />
<br />
<p>The number of sessions currently waiting for replica replies.</p><br />
<br />
<p>This variable is available only if the source-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_master_yes_tx</p><br />
<br />
<p>The number of commits that were acknowledged successfully by a replica.</p><br />
<br />
<p>This variable is available only if the master-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rpl_semi_sync_slave_status</p><br />
<br />
<p>Whether semisynchronous replication currently is operational on the replica. This is ON if the plugin has been enabled and the replica I/O thread is running, OFF otherwise.</p><br />
<br />
<p>This variable is available only if the replica-side semisynchronous replication plugin is installed.</p><br />
<br />
<p>Rsa_public_key</p><br />
<br />
<p>This variable is available if MySQL was compiled using OpenSSL (see Section 6.3.4, “SSL Library-Dependent Capabilities”). Its value is the public key used by the sha256_password authentication plugin for RSA key pair-based password exchange. The value is nonempty only if the server successfully initializes the private and public keys in the files named by the sha256_password_private_key_path and sha256_password_public_key_path system variables. The value of Rsa_public_key comes from the latter file.</p><br />
<br />
<p>For information about sha256_password, see Section 6.4.1.4, “SHA-256 Pluggable Authentication”.</p><br />
<br />
<p>Select_full_join</p><br />
<br />
<p>The number of joins that perform table scans because they do not use indexes. If this value is not 0, you should carefully check the indexes of your tables.</p><br />
<br />
<p>Select_full_range_join</p><br />
<br />
<p>The number of joins that used a range search on a reference table.</p><br />
<br />
<p>Select_range</p><br />
<br />
<p>The number of joins that used ranges on the first table. This is normally not a critical issue even if the value is quite large.</p><br />
<br />
<p>Select_range_check</p><br />
<br />
<p>The number of joins without keys that check for key usage after each row. If this is not 0, you should carefully check the indexes of your tables.</p><br />
<br />
<p>Select_scan</p><br />
<br />
<p>The number of joins that did a full scan of the first table.</p><br />
<br />
<p>Slave_heartbeat_period</p><br />
<br />
<p>Shows the replication heartbeat interval (in seconds) on a replica.</p><br />
<br />
<p>Slave_last_heartbeat</p><br />
<br />
<p>Shows when the most recent heartbeat signal was received by a replica, as a TIMESTAMP value.</p><br />
<br />
<p>Slave_open_temp_tables</p><br />
<br />
<p>The number of temporary tables that the replica SQL thread currently has open. If the value is greater than zero, it is not safe to shut down the replica; see Section 17.4.1.29, “Replication and Temporary Tables”.</p><br />
<br />
<p>Slave_received_heartbeats</p><br />
<br />
<p>This counter increments with each replication heartbeat received by a replica since the last time that the replica was restarted or reset, or a CHANGE MASTER TO statement was issued.</p><br />
<br />
<p>Slave_retried_transactions</p><br />
<br />
<p>The total number of times since startup that the replica SQL thread has retried transactions.</p><br />
<br />
<p>Slave_rows_last_search_algorithm_used</p><br />
<br />
<p>The search algorithm that was most recently used by this replica to locate rows for row-based replication. The result shows whether the replica used indexes, a table scan, or hashing as the search algorithm for the last transaction executed on any channel.</p><br />
<br />
<p>The method used depends on the setting for the slave_rows_search_algorithms system variable, and the keys that are available on the relevant table.</p><br />
<br />
<p>This variable is available only for debug builds of MySQL.</p><br />
<br />
<p>Slave_running</p><br />
<br />
<p>This is ON if this server is a replica that is connected to a replication source, and both the I/O and SQL threads are running; otherwise, it is OFF.</p><br />
<br />
<p>Slow_launch_threads</p><br />
<br />
<p>The number of threads that have taken more than slow_launch_time seconds to create.</p><br />
<br />
<p>Slow_queries</p><br />
<br />
<p>The number of queries that have taken more than long_query_time seconds. This counter increments regardless of whether the slow query log is enabled. For information about that log, see Section 5.4.5, “The Slow Query Log”.</p><br />
<br />
<p>Sort_merge_passes</p><br />
<br />
<p>The number of merge passes that the sort algorithm has had to do. If this value is large, you should consider increasing the value of the sort_buffer_size system variable.</p><br />
<br />
<p>Sort_range</p><br />
<br />
<p>The number of sorts that were done using ranges.</p><br />
<br />
<p>Sort_rows</p><br />
<br />
<p>The number of sorted rows.</p><br />
<br />
<p>Sort_scan</p><br />
<br />
<p>The number of sorts that were done by scanning the table.</p><br />
<br />
<p>Ssl_accept_renegotiates</p><br />
<br />
<p>The number of negotiates needed to establish the connection.</p><br />
<br />
<p>Ssl_accepts</p><br />
<br />
<p>The number of accepted SSL connections.</p><br />
<br />
<p>Ssl_callback_cache_hits</p><br />
<br />
<p>The number of callback cache hits.</p><br />
<br />
<p>Ssl_cipher</p><br />
<br />
<p>The current encryption cipher (empty for unencrypted connections).</p><br />
<br />
<p>Ssl_cipher_list</p><br />
<br />
<p>The list of possible SSL ciphers (empty for non-SSL connections).</p><br />
<br />
<p>Ssl_client_connects</p><br />
<br />
<p>The number of SSL connection attempts to an SSL-enabled source.</p><br />
<br />
<p>Ssl_connect_renegotiates</p><br />
<br />
<p>The number of negotiates needed to establish the connection to an SSL-enabled source.</p><br />
<br />
<p>Ssl_ctx_verify_depth</p><br />
<br />
<p>The SSL context verification depth (how many certificates in the chain are tested).</p><br />
<br />
<p>Ssl_ctx_verify_mode</p><br />
<br />
<p>The SSL context verification mode.</p><br />
<br />
<p>Ssl_default_timeout</p><br />
<br />
<p>The default SSL timeout.</p><br />
<br />
<p>Ssl_finished_accepts</p><br />
<br />
<p>The number of successful SSL connections to the server.</p><br />
<br />
<p>Ssl_finished_connects</p><br />
<br />
<p>The number of successful replica connections to an SSL-enabled source.</p><br />
<br />
<p>Ssl_server_not_after</p><br />
<br />
<p>The last date for which the SSL certificate is valid. To check SSL certificate expiration information, use this statement:</p><br />
<br />
<p>mysql&gt; SHOW STATUS LIKE ‘Ssl_server_not%’;<br />
+———————–+————————–+<br />
| Variable_name         | Value                    |<br />
+———————–+————————–+<br />
| Ssl_server_not_after  | Apr 28 14:16:39 2025 GMT |<br />
| Ssl_server_not_before | May  1 14:16:39 2015 GMT |<br />
+———————–+————————–+<br />
In MySQL 5.6, the value is empty unless the connection uses SSL.</p><br />
<br />
<p>Ssl_server_not_before</p><br />
<br />
<p>The first date for which the SSL certificate is valid.</p><br />
<br />
<p>In MySQL 5.6, the value is empty unless the connection uses SSL.</p><br />
<br />
<p>Ssl_session_cache_hits</p><br />
<br />
<p>The number of SSL session cache hits.</p><br />
<br />
<p>Ssl_session_cache_misses</p><br />
<br />
<p>The number of SSL session cache misses.</p><br />
<br />
<p>Ssl_session_cache_mode</p><br />
<br />
<p>The SSL session cache mode.</p><br />
<br />
<p>Ssl_session_cache_overflows</p><br />
<br />
<p>The number of SSL session cache overflows.</p><br />
<br />
<p>Ssl_session_cache_size</p><br />
<br />
<p>The SSL session cache size.</p><br />
<br />
<p>Ssl_session_cache_timeouts</p><br />
<br />
<p>The number of SSL session cache timeouts.</p><br />
<br />
<p>Ssl_sessions_reused</p><br />
<br />
<p>How many SSL connections were reused from the cache.</p><br />
<br />
<p>Ssl_used_session_cache_entries</p><br />
<br />
<p>How many SSL session cache entries were used.</p><br />
<br />
<p>Ssl_verify_depth</p><br />
<br />
<p>The verification depth for replication SSL connections.</p><br />
<br />
<p>Ssl_verify_mode</p><br />
<br />
<p>The verification mode used by the server for a connection that uses SSL. The value is a bitmask; bits are defined in the openssl/ssl.h header file:</p><br />
<br />
<h1 id="define-ssl_verify_none-----------------0x00">define SSL_VERIFY_NONE                 0x00</h1><br />
<h1 id="define-ssl_verify_peer-----------------0x01">define SSL_VERIFY_PEER                 0x01</h1><br />
<h1 id="define-ssl_verify_fail_if_no_peer_cert-0x02">define SSL_VERIFY_FAIL_IF_NO_PEER_CERT 0x02</h1><br />
<h1 id="define-ssl_verify_client_once----------0x04">define SSL_VERIFY_CLIENT_ONCE          0x04</h1><br />
<p>SSL_VERIFY_PEER indicates that the server asks for a client certificate. If the client supplies one, the server performs verification and proceeds only if verification is successful. SSL_VERIFY_CLIENT_ONCE indicates that a request for the client certificate is done only in the initial handshake.</p><br />
<br />
<p>Ssl_version</p><br />
<br />
<p>The SSL protocol version of the connection (for example, TLSv1). If the connection is not encrypted, the value is empty.</p><br />
<br />
<p>Table_locks_immediate</p><br />
<br />
<p>The number of times that a request for a table lock could be granted immediately.</p><br />
<br />
<p>Table_locks_waited</p><br />
<br />
<p>The number of times that a request for a table lock could not be granted immediately and a wait was needed. If this is high and you have performance problems, you should first optimize your queries, and then either split your table or tables or use replication.</p><br />
<br />
<p>Table_open_cache_hits</p><br />
<br />
<p>The number of hits for open tables cache lookups.</p><br />
<br />
<p>Table_open_cache_misses</p><br />
<br />
<p>The number of misses for open tables cache lookups.</p><br />
<br />
<p>Table_open_cache_overflows</p><br />
<br />
<p>The number of overflows for the open tables cache. This is the number of times, after a table is opened or closed, a cache instance has an unused entry and the size of the instance is larger than table_open_cache / table_open_cache_instances.</p><br />
<br />
<p>Tc_log_max_pages_used</p><br />
<br />
<p>For the memory-mapped implementation of the log that is used by mysqld when it acts as the transaction coordinator for recovery of internal XA transactions, this variable indicates the largest number of pages used for the log since the server started. If the product of Tc_log_max_pages_used and Tc_log_page_size is always significantly less than the log size, the size is larger than necessary and can be reduced. (The size is set by the –log-tc-size option. This variable is unused: It is unneeded for binary log-based recovery, and the memory-mapped recovery log method is not used unless the number of storage engines that are capable of two-phase commit and that support XA transactions is greater than one. (InnoDB is the only applicable engine.)</p><br />
<br />
<p>Tc_log_page_size</p><br />
<br />
<p>The page size used for the memory-mapped implementation of the XA recovery log. The default value is determined using getpagesize(). This variable is unused for the same reasons as described for Tc_log_max_pages_used.</p><br />
<br />
<p>Tc_log_page_waits</p><br />
<br />
<p>For the memory-mapped implementation of the recovery log, this variable increments each time the server was not able to commit a transaction and had to wait for a free page in the log. If this value is large, you might want to increase the log size (with the –log-tc-size option). For binary log-based recovery, this variable increments each time the binary log cannot be closed because there are two-phase commits in progress. (The close operation waits until all such transactions are finished.)</p><br />
<br />
<p>Threads_cached</p><br />
<br />
<p>The number of threads in the thread cache.</p><br />
<br />
<p>Threads_connected</p><br />
<br />
<p>The number of currently open connections.</p><br />
<br />
<p>Threads_created</p><br />
<br />
<p>The number of threads created to handle connections. If Threads_created is big, you may want to increase the thread_cache_size value. The cache miss rate can be calculated as Threads_created/Connections.</p><br />
<br />
<p>Threads_running</p><br />
<br />
<p>The number of threads that are not sleeping.</p><br />
<br />
<p>Uptime</p><br />
<br />
<p>The number of seconds that the server has been up.</p><br />
<br />
<p>Uptime_since_flush_status</p><br />
<br />
<p>The number of seconds since the most recent FLUSH STATUS statement.</p><br />
<br />
<p>https://dev.mysql.com/doc/refman/5.6/en/server-status-variables.html<br />
<!-- more --><br />
mysql 支持三种连接方式</p><br />
<br />
<p>socket<br />
named pipe<br />
shared memory<br />
named pipe 和 shared memory 只能在本地连接数据库，适用场景较少</p><br />
<br />
<p>thread_cache<br />
参数 thread_cache_size 控制了 thread_cache 的大小， 设为0时关闭 thread_cache，不缓存空闲thread</p><br />
<br />
<p>mysql&gt; show status like ‘Threads%’;<br />
+——————-+——-+<br />
| Variable_name     | Value |<br />
+——————-+——-+<br />
| Threads_cached    | 1     |<br />
| Threads_connected | 1     |<br />
| Threads_created   | 2     |<br />
| Threads_running   | 1     |<br />
+——————-+——-+<br />
4 rows in set (0.02 sec)</p><br />
<br />
<p>Threads_cached：缓存的 thread，新连接建立时，优先使用cache中的thread</p><br />
<br />
<p>Threads_connected：已连接的 thread</p><br />
<br />
<p>Threads_created：建立的 thread 数量</p><br />
<br />
<p>Threads_running：running状态的 thread 数量</p><br />
<br />
<p>Threads_created = Threads_cached + Threads_connected</p><br />
<br />
<p>Threads_running &lt;= Threads_connected</p><br />
<br />
<p>MySQL 建立新连接非常消耗资源，频繁使用短连接，又没有其他组件实现连接池时，可以适当提高 thread_cache_size，降低新建连接的开销</p><br />
<br />
<p>.每个连接的限制<br />
除了参数 max_user_connections 限制每个用户的最大连接数，还可以对每个用户制定更细致的限制</p><br />
<br />
<p>以下四个限制保存在mysql.user表中</p><br />
<br />
<p>MAX_QUERIES_PER_HOUR 每小时最大请求数（语句数量）<br />
MAX_UPDATES_PER_HOUR 每小时最大更新数（更新语句的数量）<br />
MAX_CONNECTIONS_PER_HOUR 每小时最大连接数<br />
MAX_USER_CONNECTIONS 这个用户的最大连接数</p><br />
<br />
<p>http://mysql.taobao.org/monthly/2018/02/07/</p><br />
<br />
<p>客户购买的DB连接数是这个。max_connections，允许同时连接DB的客户端的最大线程数。如果客户端的连接数超过了max_connections,应用就会收到“too many connections”的错误。</p><br />
<br />
<p>已经创建的连接数<br />
Threads_created是为处理连接而创建的线程数。再明确一点来说是连接到DB的，客户端的线程数。它包含Threads_running。 如果Threads_created很大，可能需要调整thread_cache_size。<br />
线程cache命中率=Threads_created/Connections，cache命中率当然越大越好，如果命中率较低，可以考虑增加thread_cache_size。</p><br />
<br />
<p>https://developer.aliyun.com/article/683460</p><br />
<br />
<p>线程的状态信息：</p><br />
<br />
<p>已经创建的连接数<br />
Threads_created是为处理连接而创建的线程数。再明确一点来说是连接到DB的，客户端的线程数。它包含Threads_running。 如果Threads_created很大，可能需要调整thread_cache_size。</p><br />
<br />
<p>线程cache命中率=Threads_created/Connections，cache命中率当然越大越好，如果命中率较低，可以考虑增加thread_cache_size。</p><br />
<br />
<p>已经连接的连接数<br />
Thread_connected当前打开的连接数。</p><br />
<br />
<p>活跃连接数<br />
Threads_running官方的说法是“没有sleep的线程数”。顾名思义是：在DB端正在执行的客户端线程总数。Server端保持这些连接同时客户端等待回复。有些线程可能消耗CPU或者IO，有些线程可能啥也没做单纯等表锁或行锁释放。当DB执行完这个线程，客户端收到回复，线程的状态就会从”running” 变成 “connected”.</p><br />
<br />
<p>如果发现活跃链接数突然增高，通常是以下原因：</p><br />
<br />
<p>应用缓存失效<br />
突发流量</p><br />
<br />
<p>https://cloud.tencent.com/developer/article/1816132</p><br />
<br />
<p>查看processlist这个表，表结构<br />
ID：线程ID，这个信息对统计来说没有太大作用</p><br />
<br />
<p>USER：连接使用的账号，这个是一个统计维度，用于统计来自每个账号的连接数</p><br />
<br />
<p>HOST：连接客户端的IP/hostname+网络端口号，这也是一个统计维度，用于确定发起连接的客户端</p><br />
<br />
<p>DB：连接使用的default database，DB通常对应具体服务，可以用于判断服务的连接分布，这算一个统计维度</p><br />
<br />
<p>COMMAND：连接的动作，实际上是说连接处于哪个阶段，常见的有Sleep、Query、Connect、Statistics等，这也是一个统计维度，主要用于判断连接是否处于空闲状态</p><br />
<br />
<p>TIME：连接处于当前状态的时间，单位是s，这个在后面进行分析，暂不算在连接状态的统计维度中</p><br />
<br />
<p>STATE：连接的状态，表示当前MySQl连接正在做什么操作，这算一个统计维度，可能的值也比较多，详细可以查阅官方文档</p><br />
<br />
<p>INFO：连接正在执行的SQL，这个在下一节分析，暂不算在连接状态的统计维度中</p><br />
<br />
<p>https://dbaplus.cn/news-11-1396-1.html</p><br />
<br />
<p>mysql -uroot -h127.0.0.1 -e”use svc_t; show processlist;” |grep -v Sleep |wc -l<br />
show status like ‘Table%’;<br />
mysql -uroot -h127.0.0.1 -e”use svc_t;show status like ‘Table%’;”<br />
mysql -uroot -h127.0.0.1 -e”use svc_t;show status like ‘%lock%’;”<br />
mysql -uroot -h127.0.0.1 -e”use svc_t;SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS; “<br />
mysql -uroot -h127.0.0.1 -e”use svc_t;SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;  “<br />
mysql -uroot -h127.0.0.1 -e”use svc_t;show variables like ‘%timeout%’; “</p><br />
<br />
<p>后台线程<br />
默认情况下，InnoDB 存储引擎有 13 个后台线程：</p><br />
<br />
<p>一个 master 线程</p><br />
<br />
<p>一个锁监控线程</p><br />
<br />
<p>一个错误监控线程</p><br />
<br />
<p>十个 IO 线程</p><br />
<br />
<p>插入缓存线程</p><br />
<br />
<p>日志线程</p><br />
<br />
<p>读线程（默认 4 个）</p><br />
<br />
<p>写线程（默认 4 个）</p><br />
<br />
<p>内存池<br />
InnoDB 存储引擎的内存池包含：缓冲池、日志缓存池、额外内存池。这些内存的大小分别由配置文件中的参数决定。其中占比最大的是缓冲池，里面包含了数据缓存页、索引、插入缓存、自适应哈希索引、锁信息和数据字典。InnoDB 会在读取数据库数据的时候，将数据缓存到缓冲池中，而在修改数据的时候，会先把缓冲池中的数据修改掉，一旦修改过的数据页就会被标记为脏页，而脏页则会被 master 线程按照一定的频率刷新到磁盘中。日志缓存则是缓存了redo-log 信息，然后再刷新到 redo-log 文件中。额外内存池则是在对一些数据结构本身分配内存时会从额外内存池中申请内存，当该区域内存不足则会到缓冲池中申请。</p><br />
<br />
<p>Master Thread<br />
InnoDB 存储引擎的主要工作都在一个单独的 Master Thread 中完成，其内部由四个循环体构成：主循环（ loop ）、后台循环（ background loop ）、刷新循环（ flush loop ）、暂停循环（ suspend loop ）<br />
https://www.pianshen.com/article/476679761/</p><br />
<br />
<p>一、关于一个SQL的简单的工作过程<br />
1、工作前提描述<br />
　　1、启动MySQL，在内存中分配一个大空间innodb_buffer_pool(还有log_buffer)<br />
　　2、多用户线程连接MySQL，从内存分配用户工作空间(其中排序空间)<br />
　　3、磁盘上有数据库文件、ib_logfile、tmp目录、undo<br />
2、SQL的简易流程<br />
　　1、DQL操作<br />
　　　　1、首先进行内存读<br />
　　　　2、如果buffer pool中没有所需数据，就进行物理读<br />
　　　　3、物理读数据读入buffer pool，再返回给用户工作空间<br />
　　2、DML操作(例update)<br />
　　　　1、内存读，然后进行物理读，读取所需修改的数据行<br />
　　　　2、从磁盘调入undo页到buffer pool中<br />
　　　　3、修改前的数据存入undo页里，产生redo<br />
　　　　4、修改数据行(buffer pool中数据页成脏页)，产生redo<br />
　　　　5、生成的redo先是存于用户工作空间，择机拷入log_buffer中<br />
　　　　6、log线程不断的将log_buffer中的记录写入redo logfile中<br />
　　　　7、修改完所有数据行，提交事务，刻意再触发一下log线程<br />
　　　　8、待log_buffer中的相关信息都写完，响应事务提交成功<br />
　　至此，日志写入磁盘，内存脏块还在buffer pool中(后台周期写入磁盘，释放buffer pool空间)。<br />
　　<br />
　　MySQL的工作机制是单进程多线程：IO线程=一个log线程+四个read线程+四个write线程<br />
　　<br />
　　1、读操作：innodb_read_io_threads<br />
　　1、发起者：用户线程发起读请求<br />
　　2、完成者：读线程执行请求队列中的读请求操作<br />
　　3、如何调整读线程的数量<br />
　　2、写操作：innodb_write_io_threads<br />
　　1、发起者：page_cleaner线程发起<br />
　　2、完成者：写线程执行请求队列中的写请求操作<br />
　　3、如何调整写线程的数量<br />
　　https://www.cnblogs.com/geaozhang/p/7214257.html<br />
　　<br />
　　<br />
 Killing Threads (PROCESSLIST, KILL)<br />
 Killing threads (KILL)<br />
Once you’ve identified the problem thread, you can use the KILL command to kill it. There are basic two variations on the KILL command.</p><br />
<br />
<h1 id="kill-the-entire-connection">Kill the entire connection.</h1><br />
<p>KILL thread_id;<br />
KILL CONNECTION thread_id;</p><br />
<br />
<h1 id="terminate-the-currently-executing-statement-but-leave-the-connection-intact">Terminate the currently executing statement, but leave the connection intact.</h1><br />
<p>KILL QUERY thread_id;<br />
https://oracle-base.com/articles/mysql/mysql-killing-threads</p><br />
<br />
<p>27.12.21.5 The processlist Table<br />
ID</p><br />
<br />
<p>The connection identifier. This is the same value displayed in the Id column of the SHOW PROCESSLIST statement, displayed in the PROCESSLIST_ID column of the Performance Schema threads table, and returned by the CONNECTION_ID() function within the thread.</p><br />
<br />
<p>USER</p><br />
<br />
<p>The MySQL user who issued the statement. A value of system user refers to a nonclient thread spawned by the server to handle tasks internally, for example, a delayed-row handler thread or an I/O or SQL thread used on replica hosts. For system user, there is no host specified in the Host column. unauthenticated user refers to a thread that has become associated with a client connection but for which authentication of the client user has not yet occurred. event_scheduler refers to the thread that monitors scheduled events (see Section 25.4, “Using the Event Scheduler”).</p><br />
<br />
<p>Note<br />
A USER value of system user is distinct from the SYSTEM_USER privilege. The former designates internal threads. The latter distinguishes the system user and regular user account categories (see Section 6.2.11, “Account Categories”).</p><br />
<br />
<p>HOST</p><br />
<br />
<p>The host name of the client issuing the statement (except for system user, for which there is no host). The host name for TCP/IP connections is reported in host_name:client_port format to make it easier to determine which client is doing what.</p><br />
<br />
<p>DB</p><br />
<br />
<p>The default database for the thread, or NULL if none has been selected.</p><br />
<br />
<p>COMMAND</p><br />
<br />
<p>The type of command the thread is executing on behalf of the client, or Sleep if the session is idle. For descriptions of thread commands, see Section 8.14, “Examining Server Thread (Process) Information”. The value of this column corresponds to the COM_xxx commands of the client/server protocol and Com_xxx status variables. See Section 5.1.10, “Server Status Variables”</p><br />
<br />
<p>TIME</p><br />
<br />
<p>The time in seconds that the thread has been in its current state. For a replica SQL thread, the value is the number of seconds between the timestamp of the last replicated event and the real time of the replica host. See Section 17.2.3, “Replication Threads”.</p><br />
<br />
<p>STATE</p><br />
<br />
<p>An action, event, or state that indicates what the thread is doing. For descriptions of STATE values, see Section 8.14, “Examining Server Thread (Process) Information”.</p><br />
<br />
<p>Most states correspond to very quick operations. If a thread stays in a given state for many seconds, there might be a problem that needs to be investigated.</p><br />
<br />
<p>INFO</p><br />
<br />
<p>The statement the thread is executing, or NULL if it is executing no statement. The statement might be the one sent to the server, or an innermost statement if the statement executes other statements. For example, if a CALL statement executes a stored procedure that is executing a SELECT statement, the INFO value shows the SELECT statement.</p><br />
<br />
<p>https://docs.oracle.com/cd/E17952_01/mysql-8.0-en/performance-schema-processlist-table.html#function_connection-id<br />
https://docs.oracle.com/cd/E17952_01/mysql-8.0-en/performance-schema-processlist-table.html</p><br />
<br />
<p>开启数据库的event执行调度</p><br />
<br />
<blockquote><br />
  <p>查看是否开启定时器</p><br />
</blockquote><br />
<br />
<p>mysql&gt; show variables like ‘%event_scheduler%’;<br />
+—————–+——-+<br />
| Variable_name   | Value |<br />
+—————–+——-+<br />
| event_scheduler | OFF   |<br />
+—————–+——-+<br />
https://www.cnblogs.com/geaozhang/p/6821692.html</p><br />
<br />
<p>How to share mysql connection between http goroutines?<br />
The database/sql package manages the connection pooling automatically for you.</p><br />
<br />
<p>sql.Open(..) returns a handle which represents a connection pool, not a single connection. The database/sql package automatically opens a new connection if all connections in the pool are busy.</p><br />
<br />
<p>Applied to your code this means, that you just need to share the db-handle and use it in the HTTP handlers:</p><br />
<br />
<p>https://stackoverflow.com/questions/17376207/how-to-share-mysql-connection-between-http-goroutines</p><br />
<br />
<p>In Go 1.1 or newer, you can use db.SetMaxIdleConns(N) to limit the number of idle connections in the pool. This doesn’t limit the pool size, though.<br />
In Go 1.2.1 or newer, you can use db.SetMaxOpenConns(N) to limit the number of total open connections to the database. Unfortunately, a deadlock bug (fix) prevents db.SetMaxOpenConns(N) from safely being used in 1.2.</p><br />
<br />
<p>http://go-database-sql.org/connection-pool.html<br />
SetMaxOpenConns用于设置最大打开的连接数，默认值为0表示不限制。<br />
SetMaxIdleConns用于设置闲置的连接数。</p><br />
<br />
<p>设置最大的连接数，可以避免并发太高导致连接mysql出现too many connections的错误。设置闲置的连接数则当开启的一个连接使用完成后可以放在池里等候下一次使用。</p><br />
<br />
<p>https://cloud.tencent.com/developer/article/1071721<br />
http://hopehook.com/blog/golang_db_pool</p><br />
<br />
<p>MySQL的MaxIdleConns不合理，会变成短连接<br />
是我们Go MySQL客户端最重要的配置。</p><br />
<br />
<p>maxIdleCount 最大空闲连接数，默认不配置，是2个最大空闲连接</p><br />
<br />
<p>maxOpen 最大连接数，默认不配置，是不限制最大连接数</p><br />
<br />
<p>maxLifetime 连接最大存活时间</p><br />
<br />
<p>maxIdleTime 空闲连接最大存活时间<br />
当突发流量情况下，由于请求量级过大，超过了最大空闲连接数的负载，那么新的连接在放入连接池的时候，会被关闭，将连接变成短连接，导致服务性能进一步恶化。为了避免这种情况，下面列举了，可以优化的措施。</p><br />
<br />
<p>提前将maxIdleConns设大，避免出现短连接</p><br />
<br />
<p>做好mysql读写分离</p><br />
<br />
<p>提升mysql的吞吐量：精简返回字段，没必要的字段不要返回，能够够快复用连接</p><br />
<br />
<p>吞吐量的包尽量不要太大，避免分包</p><br />
<br />
<p>优化连接池，当客户端到MySQL的连接数大于最大空闲连接的时候，关闭能够做一下延迟（官方不支持，估计只能自己实现）</p><br />
<br />
<p>读请求的最好不要放MySQL里，尽量放redis里<br />
https://blog.51cto.com/u_15127567/2714595<br />
https://developpaper.com/golang-connection-pool-you-must-understand/</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category mysql
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>