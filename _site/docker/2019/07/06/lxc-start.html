<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">lxc-start 源码分析</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-07-06T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Jul 6, 2019</time></p>
					</div>
					 <p>https://github.com/lxc/lxc<br />
lxc_start.c<br />
int main(int argc, char *argv[])<br />
{<br />
    int err = 1;<br />
    struct lxc_conf *conf;    //初始化config结构<br />
    char *const *args;		 //传递的参数<br />
    char *rcfile = NULL;		 //指定配置文件<br />
    char *const default_args[] = {    //默认的args参数<br />
        “/sbin/init”,<br />
        NULL,<br />
    };<br /><br />
struct lxc_container *c;    //lxc-container 的结构体<br />
….<br />
}<br />
<!-- more --><br />
lxc_conf这个数据结构<br />
struct lxc_conf {<br />
    int is_execute;		//容器是否在执行<br />
    char *fstab;			//fstab？<br />
    int tty;				//tty的个数<br />
    int pts;				//pts的个数？<br />
    int reboot;			//重启？<br />
    int need_utmp_watch;		//字面翻译 需要utmp 查看<br />
    signed long personality;		//字面翻译 特点	<br />
    struct utsname *utsname;	//ustname<br />
    struct lxc_list cgroup;		//cgroup list lxc_list只是简单的链表结构<br />
    struct lxc_list id_map;		//id_map list<br />
    struct lxc_list network;		//network list<br />
    struct saved_nic *saved_nics;//saved_nics 结构<br />
    int num_savednics;			//savednics数量？<br />
    int auto_mounts;			//auto_mounts?<br />
    struct lxc_list mount_list;		//mount_list list?<br />
    struct lxc_list caps;			//caps list？<br />
    struct lxc_list keepcaps;		//keepcaps list?<br />
    struct lxc_tty_info tty_info;	//tty的相关信息<br />
    struct lxc_console console;	//console的结构体<br />
    struct lxc_rootfs rootfs;		//rootfs的结构体<br />
    char *ttydir;					//tty目录<br />
int close_all_fds;			//关闭所有fd<br />
struct lxc_list hooks[NUM_LXC_HOOKS];	//hooks 函数</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>char *lsm_aa_profile;   //?<br />
char *lsm_se_context;	//?<br />
int tmp_umount_proc;	//?<br />
char *seccomp;  // filename with the seccomp rules #if HAVE_SCMP_FILTER_CTX<br />
scmp_filter_ctx seccomp_ctx; #endif<br />
int maincmd_fd;		//?<br />
int autodev;  // if 1, mount and fill a /dev at start<br />
int haltsignal; // signal used to halt container<br />
int stopsignal; // signal used to hard stop container<br />
int kmsg;  // if 1, create /dev/kmsg symlink<br />
char *rcfile;   // Copy of the top level rcfile we read<br />
 <br />
// Logfile and loglevel can be set in a container config file.<br />
// Those function as defaults.  The defaults can be overriden<br />
// by command line.  However we don't want the command line<br />
// specified values to be saved on c-&gt;save_config().  So we<br />
// store the config file specified values here.<br />
char *logfile;  // the logfile as specifed in config<br />
int loglevel;   // loglevel as specifed in config (if any)<br />
 <br />
int inherit_ns_fd[LXC_NS_MAX];<br />
 <br />
int start_auto;<br />
int start_delay;<br />
int start_order;<br />
struct lxc_list groups;<br />
int nbd_idx;<br />
 <br />
/* set to true when rootfs has been setup */<br />
bool rootfs_setup; };<br />
</code></pre></div></div><br />
<br />
<p>lxc_container的结构体</p><br />
<br />
<p>/*!</p><br />
<ul><br />
  <li><br />
    <p>An LXC container.<br />
 */<br />
struct lxc_container {<br />
 // private fields<br />
char *name; 		 //container 的名字<br />
char *configfile; 		 // configuration file 的路径<br />
char *pidfile;   		 // 存储pid 的文件名<br />
struct lxc_lock *slock;  //Container semaphore lock. 容器的信号锁<br />
 struct lxc_lock *privlock;//容器的私有信号锁<br />
 int numthreads;			//容器的引用数量，由privlock保护<br />
 struct lxc_conf *lxc_conf;</p><br />
<br />
    <p>// public fields<br />
 char *error_string;		//全局变量 可读的最后显示的error<br />
 int error_num;			//最后error的数字<br />
 bool daemonize;		//容器是否希望开启守护进程<br />
char *config_path;		// configuration file 的路径 和上面的区别？ 全局？<br />
…….					//一堆成员函数   暂不看<br />
}</p><br />
  </li><br />
</ul><br />
<br />
<p>lxc_list_init(&amp;defines);             //初始化list</p><br />
<br />
<p>defines定义在文件开始，为全局变量</p><br />
<br />
<p>static structlxc_list defines;</p><br />
<br />
<p>if(lxc_caps_init())                    //caps初始化</p><br />
<br />
<p>        return err;</p><br />
<br />
<p>到这个函数里看一下。</p><br />
<br />
<p>int lxc_caps_init(void)<br />
{<br />
    uid_t uid = getuid();<br />
    gid_t gid = getgid();<br />
    uid_t euid = geteuid();	//有效uid</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!uid) {				//root权限运行的话就省了后面的步骤了<br />
    INFO("command is run as 'root'");<br />
    return 0;<br />
}   <br />
 <br />
if (uid &amp;&amp; !euid) {<br />
    INFO("command is run as setuid root (uid : %d)", uid);<br />
 <br />
    if (prctl(PR_SET_KEEPCAPS, 1)) {		//prctl 设置进程的选项，为下面set？<br />
        ERROR("failed to 'PR_SET_KEEPCAPS': %m");<br />
        return -1; <br />
    }   <br />
 <br />
    if (setresgid(gid, gid, gid)) {<br />
        ERROR("failed to change gid to '%d': %m", gid);<br />
        return -1; <br />
    }   <br />
 <br />
    if (setresuid(uid, uid, uid)) {<br />
        ERROR("failed to change uid to '%d': %m", uid);<br />
        return -1; <br />
    }   <br />
 <br />
    if (lxc_caps_up()) {<br />
        ERROR("failed to restore capabilities: %m");<br />
        return -1; <br />
    }   <br />
}   <br />
</code></pre></div></div><br />
<br />
<p>if (uid == euid)<br />
INFO(“command is run as user ‘%d’”, uid);</p><br />
<br />
<p>return 0;<br />
}</p><br />
<br />
<p>接着就是读传过来的参数</p><br />
<br />
<p>if(lxc_arguments_parse(&amp;my_args, argc, argv))</p><br />
<br />
<p>        return err;</p><br />
<br />
<p>这个函数就没细看，只需知道将参数传给my_args</p><br />
<br />
<p>判断有没有指定 初始执行的参数，没有的话指定默认参数</p><br />
<br />
<p>if (!my_args.argc)</p><br />
<br />
<p>        args = default_args;</p><br />
<br />
<p>    else       </p><br />
<br />
<p>        args = my_args.argv;</p><br />
<br />
<p> </p><br />
<br />
<p>初始化一堆log的，暂时也没细看</p><br />
<br />
<p>if (lxc_log_init(my_args.name, my_args.log_file, my_args.log_priority,<br />
             my_args.progname, my_args.quiet, my_args.lxcpath[0]))<br />
        return err;<br />
lxc_log_options_no_override();</p><br />
<br />
<p>const char <em>lxcpath = my_args.lxcpath[0];		//lxcpath 很有意思<br />
// lxc_global_config_value(“lxc.lxcpath”)这个写的还是比较复杂的，总之lxcpath会是默认的路径<br />
//指定config的位置，如果没指定，则使用默认的路径的config，通过配置创建新的<br />
/</em><br />
     * rcfile possibilities:<br />
     * 1. rcfile from random path specified in cli option<br />
     * 2. rcfile not specified, use $lxcpath/$lxcname/config<br />
     * 3. rcfile not specified and does not exist.<br />
     <em>/<br />
    /</em> rcfile is specified in the cli option */<br />
    if (my_args.rcfile) {<br />
        rcfile = (char *)my_args.rcfile;<br />
        c = lxc_container_new(my_args.name, lxcpath);<br />
        if (!c) {<br />
            ERROR(“Failed to create lxc_container”);<br />
            return err;<br />
        }<br />
        c-&gt;clear_config(c);<br />
        if (!c-&gt;load_config(c, rcfile)) {<br />
            ERROR(“Failed to load rcfile”);<br />
            lxc_container_put(c);<br />
            return err;<br />
        }<br />
}<br />
 } else {<br />
        int rc;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    rc = asprintf(&amp;rcfile, "%s/%s/config", lxcpath, my_args.name);<br />
    if (rc == -1) {<br />
        SYSERROR("failed to allocate memory");<br />
        return err;<br />
    }<br />
    INFO("using rcfile %s", rcfile);<br />
 <br />
    /* container configuration does not exist */<br />
    if (access(rcfile, F_OK)) {<br />
        free(rcfile);<br />
        rcfile = NULL;<br />
    }<br />
    c = lxc_container_new(my_args.name, lxcpath);<br />
    if (!c) {<br />
        ERROR("Failed to create lxc_container");<br />
        return err;<br />
    } }<br />
</code></pre></div></div><br />
<br />
<p>里面最主要的函数c = lxc_container_new(my_args.name, lxcpath);</p><br />
<br />
<p>struct lxc_container *lxc_container_new(const char *name, const char *configpath)<br />
{<br />
    struct lxc_container *c;			//结构体lxc_container 前面分析过了</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c = malloc(sizeof(*c));			//创建<br />
if (!c) {<br />
    fprintf(stderr, "failed to malloc lxc_container\n");<br />
    return NULL;<br />
}    <br />
memset(c, 0, sizeof(*c));		   //初始0<br />
 <br />
if (configpath)<br />
    c-&gt;config_path = strdup(configpath);			//config_path<br />
else <br />
    c-&gt;config_path = strdup(lxc_global_config_value("lxc.lxcpath"));<br />
 <br />
if (!c-&gt;config_path) {<br />
    fprintf(stderr, "Out of memory\n");<br />
    goto err; <br />
}    <br />
 <br />
remove_trailing_slashes(c-&gt;config_path);<br />
c-&gt;name = malloc(strlen(name)+1);<br />
if (!c-&gt;name) {<br />
    fprintf(stderr, "Error allocating lxc_container name\n");<br />
    goto err; <br />
}    <br />
strcpy(c-&gt;name, name);<br />
 <br />
c-&gt;numthreads = 1; <br />
 // lock这部分没细看<br />
if (!(c-&gt;slock = lxc_newlock(c-&gt;config_path, name))) {<br />
    fprintf(stderr, "failed to create lock\n");<br />
    goto err; <br />
}<br />
 if (!(c-&gt;privlock = lxc_newlock(NULL, NULL))) {<br />
    fprintf(stderr, "failed to alloc privlock\n");<br />
    goto err;<br />
}<br />
 // set config path<br />
 if (!set_config_filename(c)) {<br />
    fprintf(stderr, "Error allocating config file pathname\n");<br />
    goto err;<br />
}<br />
 //load config path<br />
if (file_exists(c-&gt;configfile) &amp;&amp; !lxcapi_load_config(c, NULL))<br />
    goto err;<br />
 //判断容器是否创建失败<br />
 if (ongoing_create(c) == 2) {<br />
    ERROR("Error: %s creation was not completed", c-&gt;name);<br />
    lxcapi_destroy(c);<br />
    lxcapi_clear_config(c);<br />
}<br />
c-&gt;daemonize = true;<br />
c-&gt;pidfile = NULL;<br />
 …… 				//后面都是成员函数赋值 } 现在回到lxc_start 的main函数中 //判断容器是否在运行 if (c-&gt;is_running(c)) {<br />
    ERROR("Container is already running.");<br />
    err = 0;<br />
    goto out;  } /*         * We should use set_config_item() over &amp;defines, which would handle   * unset c-&gt;lxc_conf for us and let us not use lxc_config_define_load()   */ //加载config文件  if (!c-&gt;lxc_conf)<br />
 c-&gt;lxc_conf = lxc_conf_init();  conf = c-&gt;lxc_conf; if (lxc_config_define_load(&amp;defines, conf))<br />
    goto out; //提示信息 if (!rcfile &amp;&amp; !strcmp("/sbin/init", args[0])) {<br />
    ERROR("Executing '/sbin/init' with no configuration file may crash the host");<br />
    goto out;<br />
}<br />
 <br />
if (ensure_path(&amp;conf-&gt;console.path, my_args.console) &lt; 0) {<br />
    ERROR("failed to ensure console path '%s'", my_args.console);<br />
    goto out;<br />
}<br />
 <br />
if (ensure_path(&amp;conf-&gt;console.log_path, my_args.console_log) &lt; 0) {<br />
    ERROR("failed to ensure console log '%s'", my_args.console_log);<br />
    goto out;<br />
}<br />
// pid 文件<br />
if (my_args.pidfile != NULL) {<br />
    if (ensure_path(&amp;c-&gt;pidfile, my_args.pidfile) &lt; 0) {<br />
        ERROR("failed to ensure pidfile '%s'", my_args.pidfile);<br />
        goto out;<br />
    }<br />
}<br />
//一些share_ns 的配置，未细看<br />
 int i;<br />
for (i = 0; i &lt; LXC_NS_MAX; i++) {<br />
    if (my_args.share_ns[i] == NULL)<br />
        continue;<br />
 <br />
    int pid = pid_from_lxcname(my_args.share_ns[i], lxcpath);<br />
    if (pid &lt; 1)<br />
        goto out;<br />
 <br />
    int fd = open_ns(pid, ns_info[i].proc_name);<br />
    if (fd &lt; 0)<br />
        goto out;<br />
    conf-&gt;inherit_ns_fd[i] = fd;<br />
}<br />
//初始化为1<br />
if (!my_args.daemonize) {<br />
    c-&gt;want_daemonize(c, false);<br />
}<br />
 <br />
if (my_args.close_all_fds)<br />
    c-&gt;want_close_all_fds(c, true);<br />
 <br />
err = c-&gt;start(c, 0, args) ? 0 : 1;<br />
 <br />
if (err) {<br />
    ERROR("The container failed to start.");<br />
    if (my_args.daemonize)<br />
        ERROR("To get more details, run the container in foreground mode.");<br />
    ERROR("Additional information can be obtained by setting the "<br />
          "--logfile and --logpriority options.");<br />
    err = c-&gt;error_num;<br />
    lxc_container_put(c);<br />
    return err;<br />
}<br />
</code></pre></div></div><br />
<br />
<p>out:<br />
    lxc_container_put(c);<br />
    return err;<br />
}<br />
直接到c-&gt;start 过程start是调用 lxcapi_start 这个函数指针，现在去看下这个函数到底是怎么讲lxc container 启动起来的。</p><br />
<br />
<p>    传过来的参数是container c，useinit 0，argv=args 即指定的初始化程序</p><br />
<br />
<p>static bool lxcapi_start(struct lxc_container *c, int useinit, char * const argv[])<br />
{<br />
    int ret;<br />
    struct lxc_conf *conf;<br />
    bool daemonize = false;				//守护进程为false<br />
    FILE *pid_fp = NULL;				//pid_file文件的指针<br />
    char *default_args[] = {				//又是default_args<br />
        “/sbin/init”,<br />
        NULL,<br />
    };</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* container exists */<br />
if (!c)								//判断容器是否存在<br />
    return false;<br />
/* container has been setup */<br />
if (!c-&gt;lxc_conf)						//config加载完美<br />
    return false;<br />
 <br />
if ((ret = ongoing_create(c)) &lt; 0) {		//容器是否创建完整<br />
    ERROR("Error checking for incomplete creation");<br />
    return false;<br />
}<br />
if (ret == 2) {<br />
    ERROR("Error: %s creation was not completed", c-&gt;name);<br />
    c-&gt;destroy(c);<br />
    return false;<br />
} else if (ret == 1) {<br />
    ERROR("Error: creation of %s is ongoing", c-&gt;name);<br />
    return false;<br />
}<br />
 <br />
 /* is this app meant to be run through lxcinit, as in lxc-execute? */<br />
if (useinit &amp;&amp; !argv)					//还是判断<br />
    return false;<br />
 <br />
if (container_mem_lock(c))			//lock<br />
    return false;<br />
conf = c-&gt;lxc_conf;					//conf赋值<br />
daemonize = c-&gt;daemonize;			//true<br />
container_mem_unlock(c);		//unlock<br />
 <br />
if (useinit) {						//0<br />
    ret = lxc_execute(c-&gt;name, argv, 1, conf, c-&gt;config_path);<br />
    return ret == 0 ? true : false;<br />
}<br />
 <br />
if (!argv)<br />
    argv = default_args;			//又重新判断 args 是否为空，空即赋值<br />
 /*<br />
* say, I'm not sure - what locks do we want here?  Any?<br />
* Is liblxc's locking enough here to protect the on disk<br />
* container?  We don't want to exclude things like lxc_info<br />
* while container is running...<br />
 * 这段注释给跪了，还是老老实实看他想干嘛吧<br />
*/<br />
if (daemonize) {					//true<br />
    lxc_monitord_spawn(c-&gt;config_path);	//start好像跟前面的版本差别<br />
 <br />
    pid_t pid = fork();<br />
    if (pid &lt; 0)<br />
        return false;<br />
 <br />
    if (pid != 0) {<br />
        /* Set to NULL because we don't want father unlink<br />
         * the PID file, child will do the free and unlink.<br />
         */<br />
        c-&gt;pidfile = NULL;<br />
        return wait_on_daemonized_start(c, pid);		//等下进去，里面有waitpid，所以先看后面<br />
    }<br />
 <br />
    /* second fork to be reparented by init */<br />
    pid = fork();										//两次fork<br />
    if (pid &lt; 0) {<br />
        SYSERROR("Error doing dual-fork");<br />
        return false;<br />
    }<br />
    if (pid != 0)<br />
        exit(0);<br />
    /* like daemon(), chdir to / and redirect 0,1,2 to /dev/null */<br />
    if (chdir("/")) {									//root目录<br />
        SYSERROR("Error chdir()ing to /.");<br />
        return false;<br />
    }<br />
    lxc_check_inherited(conf, -1);<br />
    close(0);					//pipe file? close(1);<br />
    close(2);<br />
    open("/dev/zero", O_RDONLY);<br />
    open("/dev/null", O_RDWR);<br />
    open("/dev/null", O_RDWR);<br />
    setsid();<br />
} else {<br />
    if (!am_single_threaded()) {<br />
        ERROR("Cannot start non-daemonized container when threaded");<br />
        return false;<br />
    }<br />
} /* We need to write PID file after daeminize, so we always<br />
 * write the right PID.<br />
 */<br />
if (c-&gt;pidfile) {								//写入pid 到pidfile<br />
    pid_fp = fopen(c-&gt;pidfile, "w");<br />
    if (pid_fp == NULL) {<br />
        SYSERROR("Failed to create pidfile '%s' for '%s'",<br />
             c-&gt;pidfile, c-&gt;name);<br />
        return false;<br />
    }<br />
 <br />
    if (fprintf(pid_fp, "%d\n", getpid()) &lt; 0) {<br />
        SYSERROR("Failed to write '%s'", c-&gt;pidfile);<br />
        fclose(pid_fp);<br />
        pid_fp = NULL;<br />
        return false;<br />
    }<br />
 <br />
    fclose(pid_fp);<br />
    pid_fp = NULL;<br />
}<br />
</code></pre></div></div><br />
<br />
<p>reboot:<br />
		…..     			<br />
}</p><br />
<br />
<p>现在到 wait_on_daemonized_start(c, pid) 里面看看函数调用的情况</p><br />
<br />
<p>这个就是主线程的pid 在等待其他子线程工作完，然后执行，只能硬着头皮继续看了。</p><br />
<br />
<p>static bool wait_on_daemonized_start(struct lxc_container <em>c, int pid)<br />
{<br />
    /</em> we’ll probably want to make this timeout configurable? */<br />
    int timeout = 5, ret, status;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*<br />
 * our child is going to fork again, then exit.  reap the<br />
 * child<br />
 */<br />
ret = waitpid(pid, &amp;status, 0);<br />
if (ret == -1 || !WIFEXITED(status) || WEXITSTATUS(status) != 0)<br />
    DEBUG("failed waiting for first dual-fork child");<br />
return lxcapi_wait(c, "RUNNING", timeout); } 函数很简单 直接调用了lxcapi_wait。<br />
</code></pre></div></div><br />
<br />
<p>static bool lxcapi_wait(struct lxc_container *c, const char *state, int timeout)<br />
{<br />
    int ret;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (!c)<br />
    return false;<br />
 <br />
ret = lxc_wait(c-&gt;name, state, timeout, c-&gt;config_path);<br />
return ret == 0; }<br />
</code></pre></div></div><br />
<br />
<p>这个依旧很简单又跳走了。。。lxc_wait了</p><br />
<br />
<p>这个函数现在先不细说了，只是检查容器创建是否超时的问题。</p><br />
<br />
<p>reboot:<br />
    conf-&gt;reboot = 0;<br />
    ret = lxc_start(c-&gt;name, argv, conf, c-&gt;config_path);<br />
    …..<br />
}<br />
reboot 又调用lxc-start 泪奔。<br />
int lxc_start(const char *name, char *const argv[], struct lxc_conf *conf,<br />
          const char *lxcpath)<br />
{<br />
    struct start_args start_arg = { //又搞了一个start_args实在不懂<br />
        .argv = argv,<br />
    };   </p><br />
<br />
<p>    if (lxc_check_inherited(conf, -1)) <br />
        return -1;</p><br />
<br />
<p>    conf-&gt;need_utmp_watch = 1; <br />
    return __lxc_start(name, conf, &amp;start_ops, &amp;start_arg, lxcpath); //ok，干上了<br />
}<br />
My god 感觉好戏才刚刚开始。。。。<br />
这里面就是lxc-start的全部，所以分开来讲，前面的废话太多，这次看重点<br />
int __lxc_start(const char <em>name, struct lxc_conf *conf,<br />
        struct lxc_operations</em> ops, void *data, const char *lxcpath)<br />
{<br />
    struct lxc_handler *handler; //结构体，保存container的一些属性<br />
    int err = -1;<br />
    int status;<br />
    int netnsfd = -1;</p><br />
<br />
<p>handler = lxc_init(name, conf, lxcpath); //init<br />
这时候要跳到init中去看看<br />
struct lxc_handler *lxc_init(const char *name, struct lxc_conf *conf, const char *lxcpath)<br />
{<br />
    struct lxc_handler *handler;</p><br />
<br />
<p>    handler = malloc(sizeof(*handler)); //初始化一堆 handler<br />
    if (!handler)<br />
        return NULL;</p><br />
<br />
<p>    memset(handler, 0, sizeof(*handler));</p><br />
<br />
<p>    handler-&gt;conf = conf;<br />
    handler-&gt;lxcpath = lxcpath;<br />
    handler-&gt;pinfd = -1;</p><br />
<br />
<p>    lsm_init();</p><br />
<br />
<p>handler-&gt;name = strdup(name);<br />
if (!handler-&gt;name) {<br />
        ERROR(“failed to allocate memory”);<br />
        goto out_free;<br />
   }<br />
 if (lxc_cmd_init(name, handler, lxcpath)) //cmd_init<br />
        goto out_free_name;<br />
if (lxc_read_seccomp_config(conf) != 0) { //这货直接返回0，什么都没有<br />
       ERROR(“failed loading seccomp policy”);<br />
     goto out_close_maincmd_fd;<br />
}<br />
/* Begin by setting the state to STARTING <em>/<br />
    if (lxc_set_state(name, handler, STARTING)) { //STARTING enum 类型<br />
        ERROR(“failed to set state ‘%s’”, lxc_state2str(STARTING));<br />
        goto out_close_maincmd_fd;<br />
    }<br />
/</em> Start of environment variable setup for hooks <em>/<br />
    if (setenv(“LXC_NAME”, name, 1)) {<br />
        SYSERROR(“failed to set environment variable for container name”);<br />
    }<br />
    if (setenv(“LXC_CONFIG_FILE”, conf-&gt;rcfile, 1)) {<br />
        SYSERROR(“failed to set environment variable for config path”);<br />
    }<br />
    if (setenv(“LXC_ROOTFS_MOUNT”, conf-&gt;rootfs.mount, 1)) {<br />
        SYSERROR(“failed to set environment variable for rootfs mount”);<br />
    }<br />
    if (setenv(“LXC_ROOTFS_PATH”, conf-&gt;rootfs.path, 1)) {<br />
        SYSERROR(“failed to set environment variable for rootfs mount”);<br />
    }<br />
    if (conf-&gt;console.path &amp;&amp; setenv(“LXC_CONSOLE”, conf-&gt;console.path, 1)) {<br />
        SYSERROR(“failed to set environment variable for console path”);<br />
    }<br />
    if (conf-&gt;console.log_path &amp;&amp; setenv(“LXC_CONSOLE_LOGPATH”, conf-&gt;console.log_path, 1)) {<br />
        SYSERROR(“failed to set environment variable for console log”);<br />
}<br />
Prestart 在这个位置，这个是可以配置到config文件中的<br />
/</em> End of environment variable setup for hooks <em>/<br />
if (run_lxc_hooks(name, “pre-start”, conf, handler-&gt;lxcpath, NULL)) {<br />
     ERROR(“failed to run pre-start hooks for container ‘%s’.”, name);<br />
     goto out_aborting;<br />
}<br />
//创建tty <br />
if (lxc_create_tty(name, conf)) {<br />
        ERROR(“failed to create the ttys”);<br />
        goto out_aborting;<br />
}<br />
这个函数打开的是/dev/ptmx这个东西还不是很了解，回头细看<br />
和pts 是主从设备，然后分配pty？<br />
/</em> the signal fd has to be created before forking otherwise<br />
     * if the child process exits before we setup the signal fd,<br />
     * the event will be lost and the command will be stuck */<br />
    handler-&gt;sigfd = setup_signal_fd(&amp;handler-&gt;oldmask);<br />
    if (handler-&gt;sigfd &lt; 0) {<br />
        ERROR(“failed to set sigchild fd handler”);<br />
        goto out_delete_tty;<br />
    }</p><br />
<br />
<p>    /* do this after setting up signals since it might unblock SIGWINCH */<br />
    if (lxc_console_create(conf)) {<br />
        ERROR(“failed to create console”);<br />
        goto out_restore_sigmask;<br />
    }</p><br />
<br />
<p>    if (ttys_shift_ids(conf) &lt; 0) {<br />
        ERROR(“Failed to shift tty into container”);<br />
        goto out_restore_sigmask;<br />
    }</p><br />
<br />
<p>    INFO(“‘%s’ is initialized”, name);<br />
    return handler;<br />
}<br />
Init完成，回到__lxc_start中<br />
if (!handler) {<br />
        ERROR(“failed to initialize the container”);<br />
        return -1;<br />
    }<br />
    handler-&gt;ops = ops;<br />
    handler-&gt;data = data;<br />
// lxc是否支持reboot，配置中handler-&gt;conf-&gt;need_utmp_watch=1表示支持<br />
    if (must_drop_cap_sys_boot(handler-&gt;conf)) {<br />
        #if HAVE_SYS_CAPABILITY_H<br />
        DEBUG(“Dropping cap_sys_boot”);<br />
        #else<br />
        DEBUG(“Can’t drop cap_sys_boot as capabilities aren’t supported”);<br />
        #endif<br />
    } else {<br />
        DEBUG(“Not dropping cap_sys_boot or watching utmp”);<br />
        handler-&gt;conf-&gt;need_utmp_watch = 0;<br />
}<br />
if (geteuid() == 0 &amp;&amp; !lxc_list_empty(&amp;conf-&gt;id_map)) { //effective uid<br />
        /* if the backing store is a device, mount it here and now */<br />
        if (rootfs_is_blockdev(conf)) {<br />
            if (unshare(CLONE_NEWNS) &lt; 0) {<br />
                ERROR(“Error unsharing mounts”);<br />
                goto out_fini_nonet;<br />
            }<br />
            remount_all_slave();<br />
            if (do_rootfs_setup(conf, name, lxcpath) &lt; 0) {<br />
                ERROR(“Error setting up rootfs mount as root before spawn”);<br />
                goto out_fini_nonet;<br />
            }<br />
            INFO(“Set up container rootfs as host root”);<br />
        }<br />
    }<br />
err = lxc_spawn(handler);<br />
    if (err) {<br />
        ERROR(“failed to spawn ‘%s’”, name);<br />
        goto out_fini_nonet;<br />
}<br />
Ok 又一个spawn，进去看看<br />
static int lxc_spawn(struct lxc_handler *handler)<br />
{<br />
    int failed_before_rename = 0;<br />
    const char *name = handler-&gt;name;<br />
    bool cgroups_connected = false;<br />
    int saved_ns_fd[LXC_NS_MAX]; //LXC_NS_MAX<br />
    int preserve_mask = 0, i;<br />
    int netpipepair[2], nveths; //网络相关</p><br />
<br />
<p>    netpipe = -1;<br />
for (i = 0; i &lt; LXC_NS_MAX; i++)<br />
        if (handler-&gt;conf-&gt;inherit_ns_fd[i] != -1) //暂时忽略<br />
            preserve_mask |= ns_info[i].clone_flag;</p><br />
<br />
<p>    if (lxc_sync_init(handler)) //同步socketpair<br />
        return -1;</p><br />
<br />
<p>    handler-&gt;clone_flags = CLONE_NEWPID|CLONE_NEWNS;<br />
    if (!lxc_list_empty(&amp;handler-&gt;conf-&gt;id_map)) {//id_map空，初始NEWUSER<br />
 INFO(“Cloning a new user namespace”);<br />
        handler-&gt;clone_flags |= CLONE_NEWUSER;<br />
    }<br />
//这里开始创建NEWNET了<br />
if (handler-&gt;conf-&gt;inherit_ns_fd[LXC_NS_NET] == -1) {<br />
        if (!lxc_requests_empty_network(handler))<br />
            handler-&gt;clone_flags |= CLONE_NEWNET;<br />
    <br />
        if (!lxc_list_empty(&amp;handler-&gt;conf-&gt;network)) {<br />
    <br />
            /* Find gateway addresses from the link device, which is<br />
             * no longer accessible inside the container. Do this<br />
             * before creating network interfaces, since goto<br />
             * out_delete_net does not work before lxc_clone. */<br />
            if (lxc_find_gateway_addresses(handler)) {<br />
                ERROR(“failed to find gateway addresses”);<br />
                lxc_sync_fini(handler);<br />
                return -1;<br />
            }</p><br />
<br />
<p>            /* that should be done before the clone because we will<br />
             * fill the netdev index and use them in the child<br />
             */<br />
            if (lxc_create_network(handler)) {<br />
                ERROR(“failed to create the network”);<br />
                lxc_sync_fini(handler);<br />
                return -1;<br />
            }<br />
        }<br />
if (save_phys_nics(handler-&gt;conf)) { //save phys nics<br />
            ERROR(“failed to save physical nic info”);<br />
            goto out_abort;<br />
        }<br />
    } else {<br />
        INFO(“Inheriting a net namespace”);<br />
    }<br />
if (handler-&gt;conf-&gt;inherit_ns_fd[LXC_NS_IPC] == -1) { //NS_IPC<br />
        handler-&gt;clone_flags |= CLONE_NEWIPC;<br />
    } else {<br />
        INFO(“Inheriting an IPC namespace”);<br />
    }</p><br />
<br />
<p>    if (handler-&gt;conf-&gt;inherit_ns_fd[LXC_NS_UTS] == -1) { //NS_UTS<br />
        handler-&gt;clone_flags |= CLONE_NEWUTS;<br />
    } else {<br />
        INFO(“Inheriting a UTS namespace”);<br />
    }<br />
if (!cgroup_init(handler)) { //init cgroup<br />
        ERROR(“failed initializing cgroup support”);<br />
        goto out_delete_net;<br />
    }<br />
//这里ops一直为空，搞了半天不知道是怎么初始化ops的<br />
//<strong>attribute</strong>((constructor))很大可能是这个<br />
    cgroups_connected = true;</p><br />
<br />
<p>    if (!cgroup_create(handler)) { <br />
        ERROR(“failed creating cgroups”);<br />
        goto out_delete_net;<br />
    }<br />
/*<br />
     * if the rootfs is not a blockdev, prevent the container from<br />
     * marking it readonly.<br />
     *<br />
     * if the container is unprivileged then skip rootfs pinning<br />
     <em>/<br />
    if (lxc_list_empty(&amp;handler-&gt;conf-&gt;id_map)) { //刚才是空？<br />
        handler-&gt;pinfd = pin_rootfs(handler-&gt;conf-&gt;rootfs.path);<br />
        if (handler-&gt;pinfd == -1)<br />
            INFO(“failed to pin the container’s rootfs”);<br />
    }<br />
if (preserve_ns(saved_ns_fd, preserve_mask) &lt; 0) //打开/prco/self/ns下面的东西<br />
        goto out_delete_net;<br />
    if (attach_ns(handler-&gt;conf-&gt;inherit_ns_fd) &lt; 0) //<br />
        goto out_delete_net;<br />
//下面是创建网络的pipe?<br />
    if (am_unpriv() &amp;&amp; (nveths = count_veths(&amp;handler-&gt;conf-&gt;network))) {<br />
        if (pipe(netpipepair) &lt; 0) {<br />
            SYSERROR(“Error creating pipe”);<br />
            goto out_delete_net;<br />
        }<br />
        /</em> store netpipe in the global var for do_start’s use <em>/<br />
        netpipe = netpipepair[0];<br />
    }<br />
/</em> Create a process in a new set of namespaces */<br />
    handler-&gt;pid = lxc_clone(do_start, handler, handler-&gt;clone_flags);<br />
    if (handler-&gt;pid &lt; 0) {<br />
        SYSERROR(“failed to fork into a new namespace”);<br />
        goto out_delete_net;<br />
my god lxc_clone 又要跳了。。。<br />
首先看下传递的参数吧<br />
do_start函数指针 ，handler， handler-&gt;clone_flags，一堆NS的设置<br />
简述下lxc_clone函数里面的流程<br />
指定一页内存大小做为子进程的栈空间，然后调用系统的clone 进行clone，回头开一章说里面的一些函数调用。<br />
ret = clone(do_clone, stack  + stack_size, flags | SIGCHLD, &amp;clone_arg);<br />
static int do_clone(void *arg)<br />
{<br />
    struct clone_arg *clone_arg = arg;<br />
    return clone_arg-&gt;fn(clone_arg-&gt;arg);<br />
}<br />
Do_clone里调用刚才的clone的指针do_start<br />
Ok，到do_start中去看，<br />
static int do_start(void *data)<br />
{<br />
    struct lxc_handler *handler = data;<br />
    const char *lsm_label = NULL;</p><br />
<br />
<p>    if (sigprocmask(SIG_SETMASK, &amp;handler-&gt;oldmask, NULL)) {<br />
        SYSERROR(“failed to set sigprocmask”);<br />
        return -1;<br />
    }</p><br />
<br />
<p>        /* This prctl must be before the synchro, so if the parent<br />
     * dies before we set the parent death signal, we will detect<br />
     * its death with the synchro right after, otherwise we have<br />
     * a window where the parent can exit before we set the pdeath<br />
     * signal leading to a unsupervized container.<br />
     */<br />
    if (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0)) { //和前面的prctl一样<br />
        SYSERROR(“failed to set pdeath signal”);<br />
        return -1;<br />
    }</p><br />
<br />
<p>lxc_sync_fini_parent(handler);<br />
/* don’t leak the pinfd to the container */<br />
    if (handler-&gt;pinfd &gt;= 0) {<br />
        close(handler-&gt;pinfd);<br />
    }</p><br />
<br />
<p>    /* Tell the parent task it can begin to configure the<br />
     * container and wait for it to finish<br />
     <em>/<br />
    if (lxc_sync_barrier_parent(handler, LXC_SYNC_CONFIGURE))<br />
        return -1;<br />
        <br />
    if (read_unpriv_netifindex(&amp;handler-&gt;conf-&gt;network) &lt; 0)<br />
        goto out_warn_father;<br />
/</em><br />
     * if we are in a new user namespace, become root there to have<br />
     * privilege over our namespace<br />
     <em>/<br />
    if (!lxc_list_empty(&amp;handler-&gt;conf-&gt;id_map)) { //设置gid uid。。<br />
        NOTICE(“switching to gid/uid 0 in new user namespace”);<br />
        if (setgid(0)) {<br />
            SYSERROR(“setgid”);<br />
            goto out_warn_father;<br />
        }<br />
        if (setuid(0)) {<br />
            SYSERROR(“setuid”);<br />
            goto out_warn_father;<br />
        }<br />
        if (setgroups(0, NULL)) {<br />
            SYSERROR(“setgroups”);<br />
            goto out_warn_father;<br />
        }<br />
    }<br />
#if HAVE_SYS_CAPABILITY_H //这个跟编译时候有关，config中也有一条<br />
    if (handler-&gt;conf-&gt;need_utmp_watch) {<br />
        if (prctl(PR_CAPBSET_DROP, CAP_SYS_BOOT, 0, 0, 0)) {<br />
            SYSERROR(“failed to remove CAP_SYS_BOOT capability”);<br />
            goto out_warn_father;<br />
        }<br />
        DEBUG(“Dropped cap_sys_boot”);<br />
    }<br />
#endif<br />
/</em> Setup the container, ip, names, utsname, … <em>/<br />
    if (lxc_setup(handler)) { //终于要配置container了<br />
        ERROR(“failed to setup the container”);<br />
        goto out_warn_father;<br />
    }<br />
Setup的代码就不放出来了，主要的函数贴上来。<br />
setup_utsname(lxc_conf-&gt;utsname)<br />
setup_network(&amp;lxc_conf-&gt;network)<br />
run_lxc_hooks(name, “pre-mount”, lxc_conf)<br />
setup_rootfs(lxc_conf)<br />
if (lxc_conf-&gt;autodev) mount_autodev(lxc_conf-&gt;rootfs.mount)<br />
setup_mount(&amp;lxc_conf-&gt;rootfs, lxc_conf-&gt;fstab, name)<br />
run_lxc_hooks(name, “mount”, lxc_conf)<br />
if (lxc_conf-&gt;autodev) {<br />
run_lxc_hooks(name, “autodev”, lxc_conf)<br />
setup_autodev(lxc_conf-&gt;rootfs.mount) }<br />
setup_console(&amp;lxc_conf-&gt;rootfs, &amp;lxc_conf-&gt;console, lxc_conf-&gt;ttydir)<br />
setup_tty(&amp;lxc_conf-&gt;rootfs, &amp;lxc_conf-&gt;tty_info, lxc_conf-&gt;ttydir)<br />
setup_pivot_root(&amp;lxc_conf-&gt;rootfs)<br />
setup_pts(lxc_conf-&gt;pts)<br />
setup_personality(lxc_conf-&gt;personality)<br />
setup_caps(&amp;lxc_conf-&gt;caps)<br />
后面再好好的研究，先把步骤理清。下面几个先看注释了。<br />
/</em> ask father to setup cgroups and wait for him to finish */<br />
    if (lxc_sync_barrier_parent(handler, LXC_SYNC_CGROUP))<br />
        return -1;</p><br />
<br />
<p>    /* Set the label to change to when we exec(2) the container’s init <em>/<br />
    if (!strcmp(lsm_name(), “AppArmor”))<br />
        lsm_label = handler-&gt;conf-&gt;lsm_aa_profile;<br />
    else if (!strcmp(lsm_name(), “SELinux”))<br />
        lsm_label = handler-&gt;conf-&gt;lsm_se_context;<br />
    if (lsm_process_label_set(lsm_label, 1, 1) &lt; 0)<br />
        goto out_warn_father;<br />
/</em> Some init’s such as busybox will set sane tty settings on stdin,<br />
     * stdout, stderr which it thinks is the console. We already set them<br />
     * the way we wanted on the real terminal, and we want init to do its<br />
     * setup on its console ie. the pty allocated in lxc_console_create()<br />
     * so make sure that that pty is stdin,stdout,stderr.<br />
     */<br />
    if (lxc_console_set_stdfds(handler) &lt; 0)<br />
        goto out_warn_father;</p><br />
<br />
<p>    /* If we mounted a temporary proc, then unmount it now */<br />
tmp_proc_unmount(handler-&gt;conf);<br />
if (lxc_seccomp_load(handler-&gt;conf) != 0)<br />
        goto out_warn_father;</p><br />
<br />
<p>    if (run_lxc_hooks(handler-&gt;name, “start”, handler-&gt;conf, handler-&gt;lxcpath, NULL)) {<br />
        ERROR(“failed to run start hooks for container ‘%s’.”, handler-&gt;name);<br />
        goto out_warn_father;<br />
    }<br />
/* The clearenv() and putenv() calls have been moved here<br />
     * to allow us to use environment variables passed to the various<br />
     * hooks, such as the start hook above.  Not all of the<br />
     * variables like CONFIG_PATH or ROOTFS are valid in this<br />
     * context but others are. <em>/<br />
    if (clearenv()) {<br />
        SYSERROR(“failed to clear environment”);<br />
        /</em> don’t error out though */<br />
    }    </p><br />
<br />
<p>    if (putenv(“container=lxc”)) {<br />
        SYSERROR(“failed to set environment variable”);<br />
        goto out_warn_father;<br />
    }    </p><br />
<br />
<p>    close(handler-&gt;sigfd);</p><br />
<br />
<p>    /* after this call, we are in error because this<br />
     * ops should not return as it execs <em>/<br />
    handler-&gt;ops-&gt;start(handler, handler-&gt;data); //看怎么跳回去<br />
handler在lxc_start 跳到__lxc_start 的时候就给ops的start 赋值函数指针start了，因此直接跳到start函数中。<br />
static int start(struct lxc_handler *handler, void</em> data)<br />
{<br />
    struct start_args *arg = data;</p><br />
<br />
<p>    NOTICE(“exec’ing ‘%s’”, arg-&gt;argv[0]);</p><br />
<br />
<p>    execvp(arg-&gt;argv[0], arg-&gt;argv);<br />
    SYSERROR(“failed to exec %s”, arg-&gt;argv[0]);<br />
    return 0;<br />
}<br />
这里面开始执行容器的rootfs下面的第一个启动选项，default_args是/sbin/init，可以在start的时候指定。<br />
Ok 从clone中回到 lxc_spawn这个中看后面怎么执行的。<br />
if (attach_ns(saved_ns_fd))<br />
        WARN(“failed to restore saved namespaces”);</p><br />
<br />
<p>    lxc_sync_fini_child(handler);<br />
//一些cgroup的配置，将对用的namespace写入cgroup中<br />
    if (lxc_sync_wait_child(handler, LXC_SYNC_CONFIGURE))<br />
        failed_before_rename = 1;<br />
if (!cgroup_create_legacy(handler)) {<br />
        ERROR(“failed to setup the legacy cgroups for %s”, name);<br />
        goto out_delete_net;<br />
    }<br />
    if (!cgroup_setup_limits(handler, false)) {<br />
        ERROR(“failed to setup the cgroup limits for ‘%s’”, name);<br />
        goto out_delete_net;<br />
    }<br />
        <br />
    if (!cgroup_enter(handler))<br />
        goto out_delete_net;<br />
    <br />
    if (!cgroup_chown(handler)) <br />
        goto out_delete_net;<br />
    <br />
    if (failed_before_rename)<br />
        goto out_delete_net;<br />
//网络配置<br />
/* Create the network configuration */<br />
    if (handler-&gt;clone_flags &amp; CLONE_NEWNET) {<br />
        if (lxc_assign_network(&amp;handler-&gt;conf-&gt;network, handler-&gt;pid)) {<br />
            ERROR(“failed to create the configured network”);<br />
            goto out_delete_net;<br />
        }<br />
    }</p><br />
<br />
<p>    if (netpipe != -1) {<br />
        struct lxc_list <em>iterator;<br />
        struct lxc_netdev *netdev;<br />
    <br />
        close(netpipe);<br />
        lxc_list_for_each(iterator, &amp;handler-&gt;conf-&gt;network) {<br />
            netdev = iterator-&gt;elem;<br />
            if (netdev-&gt;type != LXC_NET_VETH)<br />
                continue;<br />
            if (write(netpipepair[1], netdev-&gt;name, IFNAMSIZ) != IFNAMSIZ) {<br />
                ERROR(“Error writing veth name to container”);<br />
                goto out_delete_net;<br />
            }<br />
        }<br />
        close(netpipepair[1]);<br />
}<br />
/</em> map the container uids - the container became an invalid<br />
     * userid the moment it was cloned with CLONE_NEWUSER - this<br />
     * call doesn’t change anything immediately, but allows the<br />
     * container to setuid(0) (0 being mapped to something else on<br />
     * the host) later to become a valid uid again */<br />
    if (lxc_map_ids(&amp;handler-&gt;conf-&gt;id_map, handler-&gt;pid)) {<br />
        ERROR(“failed to set up id mapping”);<br />
        goto out_delete_net;<br />
    }</p><br />
<br />
<p>    /* Tell the child to continue its initialization.  we’ll get<br />
     * LXC_SYNC_CGROUP when it is ready for us to setup cgroups<br />
     */<br />
    if (lxc_sync_barrier_child(handler, LXC_SYNC_POST_CONFIGURE))<br />
        goto out_delete_net;</p><br />
<br />
<p>    if (!cgroup_setup_limits(handler, true)) {<br />
        ERROR(“failed to setup the devices cgroup for ‘%s’”, name);<br />
        goto out_delete_net;<br />
    }</p><br />
<br />
<p>    cgroup_disconnect();<br />
    cgroups_connected = false;<br />
/* Tell the child to complete its initialization and wait for<br />
     * it to exec or return an error.  (the child will never<br />
     * return LXC_SYNC_POST_CGROUP+1.  It will either close the<br />
     * sync pipe, causing lxc_sync_barrier_child to return<br />
     * success, or return a different value, causing us to error<br />
     * out).<br />
     */<br />
    if (lxc_sync_barrier_child(handler, LXC_SYNC_POST_CGROUP))<br />
        return -1;</p><br />
<br />
<p>    if (detect_shared_rootfs())<br />
        umount2(handler-&gt;conf-&gt;rootfs.mount, MNT_DETACH);</p><br />
<br />
<p>    if (handler-&gt;ops-&gt;post_start(handler, handler-&gt;data)) //post_start什么也没干，就赋值，直接return了<br />
        goto out_abort;</p><br />
<br />
<p>    if (lxc_set_state(name, handler, RUNNING)) {<br />
        ERROR(“failed to set state to %s”,<br />
                  lxc_state2str(RUNNING));<br />
        goto out_abort;<br />
    }</p><br />
<br />
<p>    lxc_sync_fini(handler);</p><br />
<br />
<p>    return 0;<br />
现在spaw函数结束，很多细节都没看，里面每个地方估计都要看很久，先把握下流程吧。<br />
netnsfd = get_netns_fd(handler-&gt;pid);</p><br />
<br />
<p>    err = lxc_poll(name, handler);<br />
    if (err) {<br />
        ERROR(“mainloop exited with an error”);<br />
        if (netnsfd &gt;= 0)<br />
            close(netnsfd);<br />
        goto out_abort;<br />
    }<br />
又来了一个poll函数<br />
看看poll做了什么<br />
调用epoll_create用于通信<br />
lxc_mainloop_open(&amp;descr)<br />
注册各种epoll事件<br />
lxc_mainloop_add_handler(&amp;descr, sigfd, signal_handler, &amp;pid)<br />
lxc_console_mainloop_add(&amp;descr, handler)<br />
lxc_command_mainloop_add(name, &amp;descr, handler)<br />
if (handler-&gt;conf-&gt;need_utmp_watch) lxc_utmp_mainloop_add(&amp;descr, handler)<br />
最后返回的时候又调用了lxc_mainloop(&amp;descr)<br />
while (waitpid(handler-&gt;pid, &amp;status, 0) &lt; 0 &amp;&amp; errno == EINTR)<br />
        continue;</p><br />
<br />
<p>    /*<br />
     * If the child process exited but was not signaled,<br />
     * it didn’t call reboot.  This should mean it was an<br />
     * lxc-execute which simply exited.  In any case, treat<br />
     * it as a ‘halt’<br />
     <em>/<br />
        if (WIFSIGNALED(status)) {<br />
        switch(WTERMSIG(status)) {<br />
        case SIGINT: /</em> halt <em>/<br />
            DEBUG(“Container halting”);<br />
            break;<br />
        case SIGHUP: /</em> reboot <em>/<br />
            DEBUG(“Container rebooting”);<br />
            handler-&gt;conf-&gt;reboot = 1;<br />
            break;<br />
        case SIGSYS: /</em> seccomp */<br />
            DEBUG(“Container violated its seccomp policy”);<br />
            break;<br />
        default:<br />
            DEBUG(“unknown exit status for init: %d”, WTERMSIG(status));<br />
            break;<br />
        }<br />
        }</p><br />
<br />
<p>    lxc_rename_phys_nics_on_shutdown(netnsfd, handler-&gt;conf);<br />
    if (netnsfd &gt;= 0)<br />
        close(netnsfd);</p><br />
<br />
<p>    if (handler-&gt;pinfd &gt;= 0) {<br />
        close(handler-&gt;pinfd);<br />
        handler-&gt;pinfd = -1;<br />
}</p><br />
<br />
<p>    lxc_monitor_send_exit_code(name, status, handler-&gt;lxcpath);<br />
    err =  lxc_error_set_and_log(handler-&gt;pid, status);<br />
}</p><br />
<br />
<p>1、首先就是第一个lxc_check_inherited函数</p><br />
<br />
<p>dir = opendir(“/proc/self/fd”);</p><br />
<br />
<p>    if (!dir) {</p><br />
<br />
<p>        WARN(“failed to opendirectory: %m”);</p><br />
<br />
<p>        return -1;</p><br />
<br />
<p>}</p><br />
<br />
<p>此函数是根据配置将/proc/self/fd下，关闭fd。</p><br />
<br />
<p>然后就跳到__lxc_start中</p><br />
<br />
<p>2、看下lxc-init</p><br />
<br />
<p>在init中 设置一些关于LXC_XXX的环境变量，猜测用于后面的使用。</p><br />
<br />
<p>可以再lxc启动的时候加一些脚本。</p><br />
<br />
<p>会在hook中先执行pre-start的前缀的脚本</p><br />
<br />
<p>if (run_lxc_hooks(name, “pre-start”, conf,handler-&gt;lxcpath, NULL)) {</p><br />
<br />
<p>        ERROR(“failed to runpre-start hooks for container ‘%s’.”, name);</p><br />
<br />
<p>        goto out_aborting;</p><br />
<br />
<p>}</p><br />
<br />
<p>继续，后面有调用lxc_create_tty，细致研究发现，这个函数是根据conf中设置tty的个数，通过opentty函数来创建pts给容器使用。</p><br />
<br />
<p>ret = openpty(&amp;pty_info-&gt;master, &amp;pty_info-&gt;slave,pty_info-&gt;name,NULL, NULL);</p><br />
<br />
<p>这个可以再config文件中设置tty的个数</p><br />
<br />
<p>tty的作用是，如果容器配置了根文件系统和inittab文件设置启动gettty，同时在inittab中gettty的个数不能超过设置的tty的个数，否则会出问题</p><br />
<br />
<p>同理 lxc_console_create 也是一样</p><br />
<br />
<p>如果容器配置了根文件系统和inittab文件设置使用控制台,您可能希望指定该控制台的输出。可以在config中设置lxc.console.logfile来指定输出的位置，lxc.console指定console的个数</p><br />
<br />
<p>然后通过ttys_shift_ids来设置tty的owner。</p><br />
<br />
<p>这样init的初始化过程就结束了。</p><br />
<br />
<p>3、然后到must_drop_cap_sys_boot(handler-&gt;conf)这个步骤中。</p><br />
<br />
<p>这个函数会读系统中/proc/sys/kernel/ctrl-alt-del这个文件，判断确定cmd的命令，cmd = v ?LINUX_REBOOT_CMD_CAD_ON : LINUX_REBOOT_CMD_CAD_OFF;</p><br />
<br />
<p>然后会系统调用clone，其中函数指针为container_reboot_supported，最终会调用reboot这个函数，</p><br />
<br />
<p>通过man reboot可以看到细节</p><br />
<br />
<p>LINUX_REBOOT_CMD_CAD_OFF</p><br />
<br />
<p>             (RB_DISABLE_CAD,  0).   CAD is  disabled.   This means  that  the CAD keystroke will cause a SIGINT signalto be sent to init</p><br />
<br />
<p>              (process 1),whereupon this process may decide upon a proper action (maybe: kill allprocesses, sync, reboot).</p><br />
<br />
<p> </p><br />
<br />
<p>       LINUX_REBOOT_CMD_CAD_ON</p><br />
<br />
<p>              (RB_ENABLE_CAD,0x89abcdef).  CAD is enabled.  This means that the CAD keystroke willimmediately cause the  action  associated</p><br />
<br />
<p>              withLINUX_REBOOT_CMD_RESTART.</p><br />
<br />
<p>那么，问题来了，到底reboot什么东西，系统？还是container？一个已经启动，一个正在start过程。</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>暂时还没搞懂，是不是NEWPID</td><br />
      <td>NEWUSER 启动的新的namespace的空间中的东西，可能发SIGINT信号给主机的init的进程。将以前启动的container剩余的部分重新启动？先mark一下。</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>4、然后判断if (geteuid() == 0&amp;&amp; !lxc_list_empty(&amp;conf-&gt;id_map))，id_map是空的，因为目前所有的的流程，都是以privilegecontainer说的，所有非root的用户就不分析了。</p><br />
<br />
<p>检查rootfs_is_blockdev(conf) 感觉函数是在判断rootfs的路径是否为blockdev，然后remount_all_slave打开/proc/self/mountinfo然后将shared enties 改变到slave中，就看当前的系统有没有share entries了。</p><br />
<br />
<p>然后调用do_rootfs_setup(conf, name,lxcpath) 将container rootfs 挂载上去。同时也通过pre-mount的脚本将自定义的一些mount 加进去，因此，这个地方也可以自己自定义，复用一些东西</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>然后调用setup_rootfs，先是调用mount(“”,”/”, NULL, MS_SLAVE</td><br />
      <td>MS_REC, 0)，mount /，调用bdev_init，初始化rootfs。</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>5、然后进去lxc-spawn这个函数中，在别的地方很多次见到spawn这个函数，只知道spawn的英文意思是产卵的意思。这个函数上次分析，里面有很多事在做。</p><br />
<br />
<p>首先将以前的cloneflag 保存，记得start的刚开始初始化的时候如果没设置，ns_info中都设置默认的-1，然后就是同步handler，没什么好说的。</p><br />
<br />
<p>然后就是讲handler的clone_flags设置CLONE_NEWXXX,获取物理网络，等等设置一堆东西， 然后就要想办法将cgroup与namespace联系到一块了，到cgroup_init里面看看是什么流程。</p><br />
<br />
<p>首先，前面一直迷惑的ops怎么被初始化的问题，</p><br />
<br />
<p><strong>attribute</strong>((constructor))</p><br />
<br />
<p>void cgroup_ops_init(void)</p><br />
<br />
<p>这个结构，在函数未调用之前就被执行了，这个回头会在杂篇中讲到，首先程序会根据系统中是否有cgmanager 来使用不同的初始化函数，本文就默认没有cgmanager，调用通用的cgfs_ops_init；返回一个引用值，返回静态变量cgfs_ops；将一些指针赋值，ok，看cgroup_init初始化过程，init指向cgfs_init，因此到cgfs_init这个函数中看一下</p><br />
<br />
<p>首先初始化cgfs_data的数据结构，然后设置cgroup_pattern为全局变量中lxc.cgroup.pattern即在编译中的DEFAULT_CGROUP_PATTERN，默认的是/lxc/%n，这个暂时不知道含义。继续看</p><br />
<br />
<p>然后调用lxc_cgroup_load_meta加载metadata，函数中会判断cgroup的使用情况，然后会调用lxc_cgroup_load_meta2的函数，会查找子系统的白名单，或者指定的hierarchies。</p><br />
<br />
<p>最终返回给handler-&gt;cgroup_data。</p><br />
<br />
<p>然后调用cgroup_create(handler)来创建cgroup，调用ops的create，create的指针指向cgfs_create，是个内联函数，最终调用lxc_cgroupfs_create，lxc_cgroupfs_create(d-&gt;name,d-&gt;cgroup_pattern, md, NULL)用来创建new cgroup</p><br />
<br />
<p>/* we will modify the result of this operation directly,</p><br />
<br />
<p>     * so we don’t have to copythe data structure</p><br />
<br />
<p>     */</p><br />
<br />
<p>   base_info = (path_pattern[0]== ‘/’) ?</p><br />
<br />
<p>    lxc_cgroup_process_info_get_init(meta_data) :    //pattern为/lxc/%n</p><br />
<br />
<p>     lxc_cgroup_process_info_get_self(meta_data);</p><br />
<br />
<p>    if (!base_info)</p><br />
<br />
<p>        return NULL;</p><br />
<br />
<p>其中get_init为returnlxc_cgroup_process_info_get(1, meta);pid 为1号进程get数据，根据/proc/1/cgroup中的信息添加到cgroup_process_info的链表中。</p><br />
<br />
<p>new_cgroup_paths = calloc(meta_data-&gt;maximum_hierarchy + 1,sizeof(char *));</p><br />
<br />
<p>    if (!new_cgroup_paths)</p><br />
<br />
<p>        goto out_initial_error;</p><br />
<br />
<p> </p><br />
<br />
<p>    new_cgroup_paths_sub =calloc(meta_data-&gt;maximum_hierarchy + 1, sizeof(char *));</p><br />
<br />
<p>    if (!new_cgroup_paths_sub)</p><br />
<br />
<p>        goto out_initial_error;</p><br />
<br />
<p>分配空间</p><br />
<br />
<p>/* find mount points we can use */</p><br />
<br />
<p>    for (info_ptr = base_info;info_ptr; info_ptr = info_ptr-&gt;next) {</p><br />
<br />
<p>        h =info_ptr-&gt;hierarchy;</p><br />
<br />
<p>        mp =lxc_cgroup_find_mount_point(h, info_ptr-&gt;cgroup_path, true);</p><br />
<br />
<p>        if (!mp) {</p><br />
<br />
<p>            ERROR(“Could notfind writable mount point for cgroup hierarchy %d while trying to createcgroup.”, h-&gt;index);</p><br />
<br />
<p>            gotoout_initial_error;</p><br />
<br />
<p>        }</p><br />
<br />
<p>        info_ptr-&gt;designated_mount_point= mp;</p><br />
<br />
<p> </p><br />
<br />
<p>        if(lxc_string_in_array(“ns”, (const char **)h-&gt;subsystems))</p><br />
<br />
<p>            continue;</p><br />
<br />
<p>        if(handle_cgroup_settings(mp, info_ptr-&gt;cgroup_path) &lt; 0) {</p><br />
<br />
<p>            ERROR(“Could notset clone_children to 1 for cpuset hierarchy in parent cgroup.”);</p><br />
<br />
<p>            gotoout_initial_error;</p><br />
<br />
<p>        }</p><br />
<br />
<p>}</p><br />
<br />
<p>/* normalize the path */</p><br />
<br />
<p>    cgroup_path_components =lxc_normalize_path(path_pattern);</p><br />
<br />
<p>    if (!cgroup_path_components)</p><br />
<br />
<p>        goto out_initial_error;</p><br />
<br />
<p>来看主要的find_name_on_this_level程序块</p><br />
<br />
<p>/* determine name of the path component we should create */</p><br />
<br />
<p>        if (contains_name&amp;&amp; suffix &gt; 0) {</p><br />
<br />
<p>            char *buf =calloc(strlen(name) + 32, 1);</p><br />
<br />
<p>            if (!buf)</p><br />
<br />
<p>                gotoout_initial_error;</p><br />
<br />
<p>            snprintf(buf, strlen(name)+ 32, “%s-%u”, name, suffix);</p><br />
<br />
<p>            current_component =lxc_string_replace(“%n”, buf, p_eff);</p><br />
<br />
<p>            free(buf);</p><br />
<br />
<p>        } else {</p><br />
<br />
<p>            current_component =contains_name ? lxc_string_replace(“%n”, name, p_eff) : p_eff;</p><br />
<br />
<p>        }</p><br />
<br />
<p>        parts[0] = path_so_far;</p><br />
<br />
<p>        parts[1] =current_component;</p><br />
<br />
<p>        parts[2] = NULL;</p><br />
<br />
<p>        current_subpath =path_so_far ? lxc_string_join(“/”, (const char **)parts, false) :current_component;</p><br />
<br />
<p>/* Now go through each hierarchy and try to create the</p><br />
<br />
<p>         * corresponding cgroup</p><br />
<br />
<p>         */</p><br />
<br />
<p>其中最主要的是</p><br />
<br />
<p>r = create_cgroup(info_ptr-&gt;designated_mount_point,current_entire_path);来创建cgroup的目录层级。</p><br />
<br />
<p>理一下头绪，cgroup通过cgroup.patternd 的模式，然后读取/proc/1/cgroup下去创建相应的cgroup层级，最后创建cgroup的目录。</p><br />
<br />
<p>6、回到lxc-spawn中，然后到通过一些网络的netpipepair设置，这些都不是我们关心的。</p><br />
<br />
<p>最后调用lxc_clone函数调用do_start来对container进行一系列的初始化操作，首先是lxc_setup 前面也介绍了，通过初始化，mount rootfs，网络，autodev，自动挂载/proc,/sys等文件，然后设置tty，console等设置标准输入输出的位置，等等。</p><br />
<br />
<p>然后可以设置if(run_lxc_hooks(handler-&gt;name, “start”, handler-&gt;conf,handler-&gt;lxcpath, NULL)) start脚本来辅助工作，这个也是可以自定义的内容</p><br />
<br />
<p>最后在do_start函数中调用handler-&gt;ops-&gt;start(handler,handler-&gt;data);</p><br />
<br />
<p>ops为lxc的operation中的内容，来看看想干嘛。execvp(arg-&gt;argv[0],arg-&gt;argv);执行start container了，这里面，我们用到的是/init不是默认的/sbin/init，因为我们的容器不是标准的容器，所以这点是不同的。</p><br />
<br />
<p>里面注释也谈到了，当我们执行这个/init的时候，函数就不会返回来了，那么后面的程序怎么办？</p><br />
<br />
<p>所以在do_start中子进程一直等到父进程完成工作和配置。</p><br />
<br />
<p>/* Tell the parent task it can begin to configure the</p><br />
<br />
<p>     * container and wait for itto finish</p><br />
<br />
<p>     */</p><br />
<br />
<p>    if(lxc_sync_barrier_parent(handler, LXC_SYNC_CONFIGURE))</p><br />
<br />
<p>        return -1;</p><br />
<br />
<p>然后父进程进行一系列的配置，其中最主要的就是cgroup的配置，如果容器没有cgroup的话，资源划分就成问题了，</p><br />
<br />
<p>cgroup_setup_limits 资源限制，cgroup_enter将pid进程加入task任务中，等等设置cgroup</p><br />
<br />
<p>然后还是配置网络，将container加入到veth当中，这当年还是要看自己config网络相关的配置，so，网络配置有很多，就忽略网络的问题了。</p><br />
<br />
<p>然后又告诉子进程继续初始化过程</p><br />
<br />
<p>/* Tell the child to continue its initialization.  we’ll get</p><br />
<br />
<p>     * LXC_SYNC_CGROUP when it isready for us to setup cgroups</p><br />
<br />
<p>     */</p><br />
<br />
<p>    if(lxc_sync_barrier_child(handler, LXC_SYNC_POST_CONFIGURE))</p><br />
<br />
<p>        goto out_delete_net;</p><br />
<br />
<p>然后当子进程setup过程完成之后，让父进程设置cgroup，同时父进程设置完cgroup时，也通知子进程完成，此时子进程就真正进入到container的init的进程了。</p><br />
<br />
<p>一直没发现这个LXC_SYNC_POST_CGROUPwait 子进程的信号谁发给他，这个比较疑惑？</p><br />
<br />
<p>最后发现是do_stat这个函数if判断失败后goto的，则表示中间会error，最后还有个post_cgroup，注释是这样说道。</p><br />
<br />
<p>/* Tell the child to complete its initialization and wait for</p><br />
<br />
<p>     * it to exec or return anerror.  (the child will never</p><br />
<br />
<p>     * returnLXC_SYNC_POST_CGROUP+1.  It will eitherclose the</p><br />
<br />
<p>     * sync pipe, causinglxc_sync_barrier_child to return</p><br />
<br />
<p>     * success, or return adifferent value, causing us to error</p><br />
<br />
<p>     * out).</p><br />
<br />
<p>     */</p><br />
<br />
<p>    if(lxc_sync_barrier_child(handler, LXC_SYNC_POST_CGROUP))</p><br />
<br />
<p>        return -1;</p><br />
<br />
<p>然后就是调用post-start，NOTICE 运行的pid，最后设置container的状态为RUNNING,至此spawn就结束了。</p><br />
<br />
<p>回到__lxc_start中，get_netns_fd获得network的状态，然后进入lxc_poll中.后面没什么好说的，现在主要考虑lxc 在exec container的init的进程过后，lxc是如何继续接管程序的。</p><br />
<br />
<p>lxc start部分的源码的大致工作流程已经熟悉，那么就要关注他的核心内容了，就是关于namespace 和 cgroup的内容了。</p><br />
<br />
<p>根据前面的分析已经知道，lxc根据一些配置会自动将flag设置成CLONE_NEWXXX,然后会通过cgroup init 来初始化一堆 cgroup。我们先来看一下。</p><br />
<br />
<p>首先通过cgroup_create 来创建 cgroup，前面介绍都是有个ops 指向函数指针，这里先假设我们用的cgfs，理论上应该和cgroupmanager是一样的方式，可能细节有区别而已。</p><br />
<br />
<p>那么顺理成章create指向cgfs_create，后面就直接说函数指针的位置了。</p><br />
<br />
<p>函数内部通过调用lxc_cgroupfs_create。那么就要从create a newcgroup</p><br />
<br />
<p>static struct cgroup_process_info <em>lxc_cgroupfs_create(const char</em>name, const char <em>path_pattern, struct cgroup_meta_data *meta_data, const char</em>sub_pattern)</p><br />
<br />
<p> </p><br />
<br />
<p>char**cgroup_path_components = NULL;</p><br />
<br />
<p>    char **p = NULL;</p><br />
<br />
<p>    char *path_so_far = NULL;</p><br />
<br />
<p>    char **new_cgroup_paths =NULL;</p><br />
<br />
<p>    char **new_cgroup_paths_sub =NULL;</p><br />
<br />
<p>    struct cgroup_mount_point*mp;</p><br />
<br />
<p>    struct cgroup_hierarchy *h;</p><br />
<br />
<p>    struct cgroup_process_info*base_info = NULL;</p><br />
<br />
<p>    struct cgroup_process_info*info_ptr;</p><br />
<br />
<p>    int saved_errno;</p><br />
<br />
<p>    int r;</p><br />
<br />
<p>    unsigned suffix = 0;</p><br />
<br />
<p>    bool had_sub_pattern = false;</p><br />
<br />
<p>size_t i;</p><br />
<br />
<p> </p><br />
<br />
<p>if (!is_valid_cgroup(name)){                                      //判断name 是否有效</p><br />
<br />
<p>        ERROR(“Invalidcgroup name: ‘%s’”, name);</p><br />
<br />
<p>        errno = EINVAL;</p><br />
<br />
<p>        return NULL;</p><br />
<br />
<p>}</p><br />
<br />
<p> </p><br />
<br />
<p>if (!strstr(path_pattern,”%n”)) {</p><br />
<br />
<p>        ERROR(“Invalidcgroup path pattern: ‘%s’; contains no %%n for specifying container name”,path_pattern);</p><br />
<br />
<p>        errno = EINVAL;</p><br />
<br />
<p>        return NULL;</p><br />
<br />
<p>}</p><br />
<br />
<p>根据privilege 和unprivilege  container的不同读取到proc 下面的pid的不同来确定不同的cgroup 信息。</p><br />
<br />
<p>base_info = (path_pattern[0]== ‘/’) ?</p><br />
<br />
<p>       lxc_cgroup_process_info_get_init(meta_data) :</p><br />
<br />
<p>       lxc_cgroup_process_info_get_self(meta_data);</p><br />
<br />
<p>    if (!base_info)</p><br />
<br />
<p>        return NULL;</p><br />
<br />
<p>new_cgroup_paths =calloc(meta_data-&gt;maximum_hierarchy + 1, sizeof(char *));</p><br />
<br />
<p>    if (!new_cgroup_paths)</p><br />
<br />
<p>        goto out_initial_error;</p><br />
<br />
<p> </p><br />
<br />
<p>在自己机子上面，看到的cgroup：</p><br />
<br />
<p>gudh@lxc-D3F2-CM:~$ cat/proc/self/cgroup</p><br />
<br />
<p>11:name=systemd:/user/1004.user/5.session</p><br />
<br />
<p>10:hugetlb:/user/1004.user/5.session</p><br />
<br />
<p>9:perf_event:/user/1004.user/5.session</p><br />
<br />
<p>8:blkio:/user/1004.user/5.session</p><br />
<br />
<p>7:freezer:/user/1004.user/5.session</p><br />
<br />
<p>6:devices:/user/1004.user/5.session</p><br />
<br />
<p>5:memory:/user/1004.user/5.session</p><br />
<br />
<p>4:cpuacct:/user/1004.user/5.session</p><br />
<br />
<p>3:cpu:/user/1004.user/5.session</p><br />
<br />
<p>2:cpuset:/user/1004.user/5.session</p><br />
<br />
<p>gudh@lxc-D3F2-CM:~$ id</p><br />
<br />
<p>uid=1004(gudh)gid=1004(gudh) groups=1004(gudh),0(root),4(adm)</p><br />
<br />
<p>gudh@lxc-D3F2-CM:~$ cat/proc/1/cgroup</p><br />
<br />
<p>11:name=systemd:/</p><br />
<br />
<p>10:hugetlb:/</p><br />
<br />
<p>9:perf_event:/</p><br />
<br />
<p>8:blkio:/</p><br />
<br />
<p>7:freezer:/</p><br />
<br />
<p>6:devices:/</p><br />
<br />
<p>5:memory:/</p><br />
<br />
<p>4:cpuacct:/</p><br />
<br />
<p>3:cpu:/</p><br />
<br />
<p>2:cpuset:/</p><br />
<br />
<p>然后就是分配path的大小</p><br />
<br />
<p>    new_cgroup_paths_sub =calloc(meta_data-&gt;maximum_hierarchy + 1, sizeof(char *));</p><br />
<br />
<p>    if (!new_cgroup_paths_sub)</p><br />
<br />
<p>        goto out_initial_error;</p><br />
<br />
<p> </p><br />
<br />
<p>查找可以挂载的点，然后创建。</p><br />
<br />
<p>/* find mount points we canuse */</p><br />
<br />
<p>    for (info_ptr = base_info; info_ptr;info_ptr = info_ptr-&gt;next) {</p><br />
<br />
<p>        h = info_ptr-&gt;hierarchy;</p><br />
<br />
<p>        mp = lxc_cgroup_find_mount_point(h,info_ptr-&gt;cgroup_path, true);</p><br />
<br />
<p>        if (!mp) {</p><br />
<br />
<p>            ERROR(“Could not find writablemount point for cgroup hierarchy %d while trying to create cgroup.”,h-&gt;index);</p><br />
<br />
<p>            goto out_initial_error;</p><br />
<br />
<p>        }</p><br />
<br />
<p>        info_ptr-&gt;designated_mount_point =mp;</p><br />
<br />
<p> </p><br />
<br />
<p>        if (lxc_string_in_array(“ns”,(const char **)h-&gt;subsystems))</p><br />
<br />
<p>            continue;</p><br />
<br />
<p>        if (handle_cgroup_settings(mp,info_ptr-&gt;cgroup_path) &lt; 0) {</p><br />
<br />
<p>            ERROR(“Could not setclone_children to 1 for cpuset hierarchy in parent cgroup.”);</p><br />
<br />
<p>            goto out_initial_error;</p><br />
<br />
<p>        }</p><br />
<br />
<p>    }</p><br />
<br />
<p> </p><br />
<br />
<p>cgroup_path_components = lxc_normalize_path(path_pattern);</p><br />
<br />
<p>    if (!cgroup_path_components)</p><br />
<br />
<p>        goto out_initial_error;</p><br />
<br />
<p> </p><br />
<br />
<p>然后根据normalize的path去创建他们。</p><br />
<br />
<p>/* go through the pathcomponents to see if we can create them */</p><br />
<br />
<table><br />
  <tbody><br />
    <tr><br />
      <td>    for (p = cgroup_path_components; *p</td><br />
      <td> </td><br />
      <td>(sub_pattern &amp;&amp; !had_sub_pattern); p++) {</td><br />
    </tr><br />
  </tbody><br />
</table><br />
<br />
<p>        /* we only want to create the samecomponent with -1, -2, etc.</p><br />
<br />
<p>         * if the component contains thecontainer name itself, otherwise</p><br />
<br />
<p>         * it’s not an error if it alreadyexists</p><br />
<br />
<p>         */</p><br />
<br />
<p>        char <em>p_eff = *p ? *p : (char</em>)sub_pattern;</p><br />
<br />
<p>        bool contains_name = strstr(p_eff,”%n”);</p><br />
<br />
<p>        char *current_component = NULL;</p><br />
<br />
<p>        char *current_subpath = NULL;</p><br />
<br />
<p>        char *current_entire_path = NULL;</p><br />
<br />
<p>        char *parts[3];</p><br />
<br />
<p>        size_t j = 0;</p><br />
<br />
<p>        i = 0;</p><br />
<br />
<p> </p><br />
<br />
<p>       /* if we are processing the subpattern, we want to make sure</p><br />
<br />
<p>         * loop is ended the next time around</p><br />
<br />
<p>         */</p><br />
<br />
<p>        if (!*p) {</p><br />
<br />
<p>            had_sub_pattern = true;</p><br />
<br />
<p>            p–;</p><br />
<br />
<p>        }</p><br />
<br />
<p> </p><br />
<br />
<p>然后就到find_name_on_this_level，这里面pattern 应该是/lxc/%n</p><br />
<br />
<p> </p><br />
<br />
<p>        goto find_name_on_this_level;</p><br />
<br />
<p>find_name_on_this_level:</p><br />
<br />
<p>        /* determine name of the path componentwe should create */</p><br />
<br />
<p>        if (contains_name &amp;&amp; suffix&gt; 0) {</p><br />
<br />
<p>            char *buf = calloc(strlen(name) +32, 1);</p><br />
<br />
<p>            if (!buf)</p><br />
<br />
<p>               goto out_initial_error;</p><br />
<br />
<p>            snprintf(buf, strlen(name) + 32,”%s-%u”, name, suffix);</p><br />
<br />
<p>            current_component =lxc_string_replace(“%n”, buf, p_eff);</p><br />
<br />
<p>            free(buf);</p><br />
<br />
<p>        } else {</p><br />
<br />
<p>            current_component = contains_name ?lxc_string_replace(“%n”, name, p_eff) : p_eff;</p><br />
<br />
<p>        }</p><br />
<br />
<p>        parts[0] = path_so_far;</p><br />
<br />
<p>        parts[1] = current_component;</p><br />
<br />
<p>        parts[2] = NULL;</p><br />
<br />
<p>        current_subpath = path_so_far ?lxc_string_join(“/”, (const char **)parts, false) :current_component;</p><br />
<br />
<p>紧接着创建相应的cgroup</p><br />
<br />
<p>for (i = 0, info_ptr =base_info; info_ptr; info_ptr = info_ptr-&gt;next, i++) {</p><br />
<br />
<p>            char *parts2[3];</p><br />
<br />
<p> </p><br />
<br />
<p>            if(lxc_string_in_array(“ns”, (const char**)info_ptr-&gt;hierarchy-&gt;subsystems))</p><br />
<br />
<p>                continue;</p><br />
<br />
<p>            current_entire_path = NULL;</p><br />
<br />
<p> </p><br />
<br />
<p>            parts2[0] =!strcmp(info_ptr-&gt;cgroup_path, “/”) ? “” :info_ptr-&gt;cgroup_path;</p><br />
<br />
<p>            parts2[1] = current_subpath;</p><br />
<br />
<p>            parts2[2] = NULL;</p><br />
<br />
<p>            current_entire_path = lxc_string_join(“/”,(const char **)parts2, false);</p><br />
<br />
<p> </p><br />
<br />
<p>            if (!*p) {</p><br />
<br />
<p>                /* we are processing thesubpath, so only update that one */</p><br />
<br />
<p>                free(new_cgroup_paths_sub[i]);</p><br />
<br />
<p>                new_cgroup_paths_sub[i] =strdup(current_entire_path);</p><br />
<br />
<p>                if (!new_cgroup_paths_sub[i])</p><br />
<br />
<p>                    goto cleanup_from_error;</p><br />
<br />
<p>            } else {</p><br />
<br />
<p>                /* remember which path was usedon this controller */</p><br />
<br />
<p>                free(new_cgroup_paths[i]);</p><br />
<br />
<p>                new_cgroup_paths[i] =strdup(current_entire_path);</p><br />
<br />
<p>                if (!new_cgroup_paths[i])</p><br />
<br />
<p>                    goto cleanup_from_error;</p><br />
<br />
<p>            }</p><br />
<br />
<p> </p><br />
<br />
<p>            r =create_cgroup(info_ptr-&gt;designated_mount_point, current_entire_path);</p><br />
<br />
<p>这样就完成相应的代码设置。</p><br />
<br />
<p>对于pattern 为/lxc/%n 就分两次不同创建在相应的目录，这样cgroup subpath 也同时受到顶层/lxc 的控制，cgroup就成功创建了。</p><br />
<br />
<p> </p><br />
<br />
<p>       然后就到cgroup_create_legacy最终调用lxc_cgroup_create_legacy</p><br />
<br />
<p>直接看注释</p><br />
<br />
<p>/*  </p><br />
<br />
<p>     * if cgroup is mounted at/cgroup and task is in cgroup /ab/, pid 2375 and</p><br />
<br />
<p>     * name is c1,</p><br />
<br />
<p>     * dir: /ab</p><br />
<br />
<p>     * fulloldpath =/cgroup/ab/2375</p><br />
<br />
<p>     * fullnewpath =/cgroup/ab/c1</p><br />
<br />
<p>     * newname = /ab/c1</p><br />
<br />
<p>     */</p><br />
<br />
<p>如果老名字为/sys/cgroup/cpu/lxc/android/2375</p><br />
<br />
<p>那么就改成/sys/cgroup/cpu/lxc/android/android?</p><br />
<br />
<p>加入cgroup一些创建file的 capability</p><br />
<br />
<p> </p><br />
<br />
<p>cgroup_setup_limits 名字很明显设置限额 with_device是false</p><br />
<br />
<p>将在config中加入的device.allow 和device.deny 配置</p><br />
<br />
<p>手动设置的地方</p><br />
<br />
<p> </p><br />
<br />
<p>然后就是cgfs_enter 最后到lxc_cgroupfs_enter</p><br />
<br />
<p>lxc_cgroup_find_mount_point 查找path下面的mount point</p><br />
<br />
<p>cgroup_to_absolute_path absolute path</p><br />
<br />
<p>lxc_write_to_file然后将pid写入到cgroup的absolutepath下面</p><br />
<br />
<p>这样就将pid 与cgroup成功绑定。<br />
cgroup_chown chown的指针目前是NULL 暂时不分析<br />
后面又来了一次 cgroup_setup_limits 这是with_device 是true<br />
此时应该就完成了cgroup的相关设置</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category docker
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>