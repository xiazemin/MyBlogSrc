<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">Namespace</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-10-22T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Oct 22, 2019</time></p>
					</div>
					 <p>Namespace是对全局系统资源的一种封装隔离，使得处于不同namespace的进程拥有独立的全局系统资源，改变一个namespace中的系统资源只会影响当前namespace里的进程，对其他namespace中的进程没有影响。</p><br />
<br />
<p>下面的所有例子都在ubuntu-server-x86_64 16.04下执行通过</p><br />
<br />
<p>Linux内核支持的namespaces<br />
目前，Linux内核里面实现了7种不同类型的namespace。</p><br />
<br />
<p>名称        宏定义             隔离内容<br />
Cgroup      CLONE_NEWCGROUP   Cgroup root directory (since Linux 4.6)<br />
IPC         CLONE_NEWIPC      System V IPC, POSIX message queues (since Linux 2.6.19)<br />
Network     CLONE_NEWNET      Network devices, stacks, ports, etc. (since Linux 2.6.24)<br />
Mount       CLONE_NEWNS       Mount points (since Linux 2.4.19)<br />
PID         CLONE_NEWPID      Process IDs (since Linux 2.6.24)<br />
User        CLONE_NEWUSER     User and group IDs (started in Linux 2.6.23 and completed in Linux 3.8)<br />
UTS         CLONE_NEWUTS      Hostname and NIS domain name (since Linux 2.6.19)<br />
注意： 由于Cgroup namespace在4.6的内核中才实现，并且和cgroup v2关系密切，现在普及程度还不高，比如docker现在就还没有用它，所以在namespace这个系列中不会介绍Cgroup namespace。<br />
<!-- more --><br />
查看进程所属的namespaces<br />
系统中的每个进程都有/proc/[pid]/ns/这样一个目录，里面包含了这个进程所属namespace的信息，里面每个文件的描述符都可以用来作为setns函数(后面会介绍)的参数。</p><br />
<br />
<p>#查看当前bash进程所属的namespace<br />
dev@ubuntu:~$ ls -l /proc/$$/ns   <br /><br />
total 0<br />
lrwxrwxrwx 1 dev dev 0 7月 7 17:24 cgroup -&gt; cgroup:[4026531835] #(since Linux 4.6)<br />
lrwxrwxrwx 1 dev dev 0 7月 7 17:24 ipc -&gt; ipc:[4026531839]       #(since Linux 3.0)<br />
lrwxrwxrwx 1 dev dev 0 7月 7 17:24 mnt -&gt; mnt:[4026531840]       #(since Linux 3.8)<br />
lrwxrwxrwx 1 dev dev 0 7月 7 17:24 net -&gt; net:[4026531957]       #(since Linux 3.0)<br />
lrwxrwxrwx 1 dev dev 0 7月 7 17:24 pid -&gt; pid:[4026531836]       #(since Linux 3.8)<br />
lrwxrwxrwx 1 dev dev 0 7月 7 17:24 user -&gt; user:[4026531837]     #(since Linux 3.8)<br />
lrwxrwxrwx 1 dev dev 0 7月 7 17:24 uts -&gt; uts:[4026531838]       #(since Linux 3.0)<br />
上面每种类型的namespace都是在不同的Linux版本被加入到/proc/[pid]/ns/目录里去的，比如pid namespace是在Linux 3.8才被加入到/proc/[pid]/ns/里面，但这并不是说到3.8才支持pid namespace，其实pid namespace在2.6.24的时候就已经加入到内核了，在那个时候就可以用pid namespace了，只是有了/proc/[pid]/ns/pid之后，使得操作pid namespace更方便了</p><br />
<br />
<p>虽然说cgroup是在Linux 4.6版本才被加入内核，可是在Ubuntu 16.04上，尽管内核版本才4.4，但也支持cgroup namespace，估计应该是Ubuntu将4.6的cgroup namespace这部分代码patch到了他们的4.4内核上。</p><br />
<br />
<p>以ipc:[4026531839]为例，ipc是namespace的类型，4026531839是inode number，如果两个进程的ipc namespace的inode number一样，说明他们属于同一个namespace。这条规则对其他类型的namespace也同样适用。</p><br />
<br />
<p>从上面的输出可以看出，对于每种类型的namespace，进程都会与一个namespace ID关联。</p><br />
<br />
<p>跟namespace相关的API<br />
和namespace相关的函数只有三个，这里简单的看一下，后面介绍UTS namespace的时候会有详细的示例</p><br />
<br />
<p>clone： 创建一个新的进程并把他放到新的namespace中<br />
int clone(int (*child_func)(void *), void *child_stack<br />
            , int flags, void *arg);</p><br />
<br />
<p>flags： <br />
    指定一个或者多个上面的CLONE_NEW*（当然也可以包含跟namespace无关的flags）， <br />
    这样就会创建一个或多个新的不同类型的namespace， <br />
    并把新创建的子进程加入新创建的这些namespace中。<br />
setns： 将当前进程加入到已有的namespace中<br />
int setns(int fd, int nstype);</p><br />
<br />
<p>fd： <br />
    指向/proc/[pid]/ns/目录里相应namespace对应的文件，<br />
    表示要加入哪个namespace</p><br />
<br />
<p>nstype：<br />
    指定namespace的类型（上面的任意一个CLONE_NEW*）：<br />
    1. 如果当前进程不能根据fd得到它的类型，如fd由其他进程创建，<br />
    并通过UNIX domain socket传给当前进程，<br />
    那么就需要通过nstype来指定fd指向的namespace的类型<br />
    2. 如果进程能根据fd得到namespace类型，比如这个fd是由当前进程打开的，<br />
    那么nstype设置为0即可<br />
unshare: 使当前进程退出指定类型的namespace，并加入到新创建的namespace（相当于创建并加入新的namespace）<br />
int unshare(int flags);</p><br />
<br />
<p>flags：<br />
    指定一个或者多个上面的CLONE_NEW*，<br />
    这样当前进程就退出了当前指定类型的namespace并加入到新创建的namespace<br />
clone和unshare的区别<br />
clone和unshare的功能都是创建并加入新的namespace， 他们的区别是：</p><br />
<br />
<p>unshare是使当前进程加入新的namespace</p><br />
<br />
<p>clone是创建一个新的子进程，然后让子进程加入新的namespace，而当前进程保持不变</p><br />
<br />
<p>其它<br />
当一个namespace中的所有进程都退出时，该namespace将会被销毁。当然还有其他方法让namespace一直存在，假设我们有一个进程号为1000的进程，以ipc namespace为例：</p><br />
<br />
<p>通过mount –bind命令。例如mount –bind /proc/1000/ns/ipc /other/file，就算属于这个ipc namespace的所有进程都退出了，只要/other/file还在，这个ipc namespace就一直存在，其他进程就可以利用/other/file，通过setns函数加入到这个namespace</p><br />
<br />
<p>在其他namespace的进程中打开/proc/1000/ns/ipc文件，并一直持有这个文件描述符不关闭，以后就可以用setns函数加入这个namespace。</p><br />
<br />
<p>使用setns模拟将新程序追加到已有的pid namespace中, 发现不起作用.</p><br />
<br />
<p>我的步骤:</p><br />
<br />
<p>找到容器, 查看它的ns</p><br />
<br />
<p>$ docker inspect 7caa18cb2657|grep -i pid<br />
            “Pid”: 13059,<br />
            “PidMode”: “”,<br />
            “PidsLimit”: 0,<br />
$ sudo ls -l /proc/13059/ns<br />
[sudo] chen 的密码：<br />
总用量 0<br />
lrwxrwxrwx 1 root root 0 5月  28 09:15 cgroup -&gt; cgroup:[4026531835]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:15 ipc -&gt; ipc:[4026532571]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:15 mnt -&gt; mnt:[4026532569]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:14 net -&gt; net:[4026532574]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:15 pid -&gt; pid:[4026532572]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:15 pid_for_children -&gt; pid:[4026532572]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:15 user -&gt; user:[4026531837]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:15 uts -&gt; uts:[4026532570]<br />
查看docker exec的效果</p><br />
<br />
<p>$ sudo ps -ef |grep /bin/sh<br />
…<br />
chen     12941 11444  0 09:14 pts/2    00:00:00 docker run -it alpine /bin/sh<br />
root     13059 13033  0 09:14 pts/0    00:00:00 /bin/sh<br />
chen     14750 13127  0 09:23 pts/3    00:00:00 docker exec -it 7caa18cb2657 /bin/sh<br />
root     14839 13033  0 09:23 pts/1    00:00:00 /bin/sh<br />
…<br />
$ sudo ls -l /proc/14839/ns<br />
总用量 0<br />
lrwxrwxrwx 1 root root 0 5月  28 09:25 cgroup -&gt; cgroup:[4026531835]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:25 ipc -&gt; ipc:[4026532571]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:25 mnt -&gt; mnt:[4026532569]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:25 net -&gt; net:[4026532574]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:25 pid -&gt; pid:[4026532572] // 和容器的pid namespace一致<br />
lrwxrwxrwx 1 root root 0 5月  28 09:25 pid_for_children -&gt; pid:[4026532572]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:25 user -&gt; user:[4026531837]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:25 uts -&gt; uts:[4026532570]<br />
使用setns模拟docker exec<br />
使用的setns代码:</p><br />
<br />
<p>#define _GNU_SOURCE<br />
#include <fcntl.h><br />
#include <sched.h><br />
#include <unistd.h><br />
#include <stdlib.h><br />
#include <stdio.h><br />
#include <string.h><br />
#include <errno.h></errno.h></string.h></stdio.h></stdlib.h></unistd.h></sched.h></fcntl.h></p><br />
<br />
<p>// 它需要两个参数: argv[1]是当前进程要加入的 Namespace 文件的路径, 而argv[1]是将要在这个 Namespace 里运行的进程<br />
// 这段代码的的核心操作是通过 open() 系统调用打开了指定的 Namespace 文件，并把这个文件的描述符 fd 交给 setns() 使用. <br />
// 在 setns() 执行后，当前进程就加入了这个文件对应的 Linux Namespace 中.<br />
int main(int argc, char *argv[]) {<br />
    int fd;</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fprintf(stdout, "argv1: %s, argv2\n", argv[1],argv[2]);<br />
<br />
fd = open(argv[1], O_RDONLY);<br />
if (setns(fd, 0) == -1) {<br />
    fprintf(stderr, "setns failed: %s\n", strerror(errno));<br />
    return -1;<br />
}<br />
<br />
if (execvp(argv[2], &amp;argv[2]) != 0 ) {<br />
    fprintf(stderr, "failed to execvp argments %s\n", strerror(errno));<br />
    return -1;<br />
  }<br />
<br />
  printf("all done!\n");<br />
  return 0; } 执行查看效果:<br />
</code></pre></div></div><br />
<br />
<p>$ gcc -o setns setns.c<br />
$ sudo ./setns /proc/13059/ns/pid /bin/bash<br />
[sudo] chen 的密码：<br />
argv1: /proc/13059/ns/pid, argv2:/bin/bash<br />
root@chen-pc:/home/chen/test#<br />
在另一个终端查看效果:</p><br />
<br />
<p>$ sudo ps -ef |grep bin/bash<br />
…<br />
root     16210 13790  0 09:40 pts/6    00:00:00 sudo ./setns /proc/13059/ns/pid /bin/bash<br />
root     16240 16210  0 09:40 pts/6    00:00:00 /bin/bash<br />
…<br />
$ sudo ls -l /proc/16240/ns<br />
总用量 0<br />
lrwxrwxrwx 1 root root 0 5月  28 09:43 cgroup -&gt; cgroup:[4026531835]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:43 ipc -&gt; ipc:[4026531839]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:43 mnt -&gt; mnt:[4026531840]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:43 net -&gt; net:[4026531993]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:43 pid -&gt; pid:[4026531836] # 和容器的pid namespace一致<br />
lrwxrwxrwx 1 root root 0 5月  28 09:43 pid_for_children -&gt; pid:[4026532572]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:43 user -&gt; user:[4026531837]<br />
lrwxrwxrwx 1 root root 0 5月  28 09:43 uts -&gt; uts:[4026531838]<br />
最后发现setns.c模拟结果和容器的pid namespace不一致, 请问这是怎么回事?</p><br />
<br />
<p>我也用sudo ./setns /proc/13059/ns/net /bin/bash模拟过, 发现容器里的ifconfig结果与在模拟中运行的结果一致.</p><br />
<br />
<p>PID namespace 比较特殊..当前调用者所属PID namespace不能被改变</p><br />
<br />
<p>你可以参考下runc的做法，用子进程做这个事.</p><br />
<br />
<p>1 概述<br />
Linux容器技术(LXC)近几年十分流行，而其依托的技术并不是很新的东西，而是Linux内核自带的一套内核级别环境隔离机制。当然，最流行的LXC技术莫过于docker了，现在社区版本更名叫moby了。 Linux容器技术依赖Linux内核的3个主要的隔离机制：chroot，cgroups，namespace。先来看看namespace，在Linux Kernel3.8以后，Linux支持6种namespace。分别是：</p><br />
<br />
<p>namespace	隔离内容	flag<br />
UTS	主机名	CLONE_NEWUTS<br />
IPC	进程间通信	CLONE_NEWIPC<br />
PID	chroot进程树	CLONE_NEWPID<br />
NS(Mount)	挂载点(mount points)	CLONE_NEWNS<br />
NET	网络访问，包括接口	CLONE_NEWNET<br />
USER	将虚拟的本地UID映射到真实的UID	CLONE_NEWUSER<br />
Linux内核提供了一套API用于操作namespace实现环境隔离，目前namespace操作的API包括clone(), setns()以及unshare()等。通过下面的命令我们可以模拟一个类似容器的环境(隔离了PID namespace，并挂载了proc目录)，你可以发现只能看到bash和shell两个进程了，而且PID是1和2。而在原PID namespace，我们可以看到bash进程的PID则是15011。个中缘由，且慢慢道来。</p><br />
<br />
<p>root@ubuntu:/home/vagrant/nstest# sudo unshare –fork –pid –mount-proc bash<br />
root@ubuntu:/home/vagrant/nstest# ps aux<br />
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br />
root         1  0.0  0.0  29164  5876 pts/1    S    22:14   0:00 bash<br />
root         2  0.0  0.0  24388  2592 pts/1    R+   22:14   0:00 ps aux</p><br />
<br />
<p>root@ubuntu:/home/vagrant/nstest# ps -ef|grep unshare<br />
root     15011   952  0 22:14 pts/1    00:00:00 unshare –fork –pid –mount-proc bash<br />
1.1 使用clone创建新进程同时创建namespace<br />
代码 ns.c 从子进程运行 /bin/bash，先从这个例子来看看Linux namespace的作用（为了简单起见，略去了错误检查代码）。</p><br />
<br />
<p>注意到在代码中使用了clone来代替更常见的fork系统调用，clone实际上是Unix系统调用fork的一种更通用的实现方式，它的原型是这样的</p><br />
<br />
<p>int clone(int (<em>child_func)(void *), void *child_stack, int flags, void *arg);<br />
child_func参数为传递子进程运行的主函数，如ns.c中的child_main；child_stack参数为子进程使用的栈空间，参数flags可以指定使用的CLONE_</em>标志，一次可以指定多个flag；而args则是子进程的参数。编译运行上面的代码，结果如下所示，运行正常，但是我们很难区分这是在子进程运行的/bin/bash还是本身的/bin/bash。</p><br />
<br />
<p>root@ubuntu:/home/vagrant/nstest# gcc -Wall ns.c -o ns &amp;&amp; ./ns</p><br />
<ul><br />
  <li>Hello ?</li><br />
  <li>World !<br />
root@ubuntu:/home/vagrant/nstest#  #inside container<br />
root@ubuntu:/home/vagrant/nstest# exit<br />
root@ubuntu:/home/vagrant/nstest#  #outside container<br />
于是，CLONE_NEWUTS可以派上用场了。UTS namespace提供了主机名和域名的隔离，这样每个容器就有独立的主机名和域名，从而可以在网络上被当作一个独立的节点而不是宿主机的一个进程。修改clone函数这行代码，加入CLONE_NEWUTS的flag，然后在子进程中调用sethostname函数，修改后代码 ns_uts.c。</li><br />
</ul><br />
<br />
<p>以root身份运行它</p><br />
<br />
<p>root@ubuntu:/home/vagrant/nstest# gcc -Wall ns_uts.c -o ns_uts &amp;&amp; ./ns_uts</p><br />
<ul><br />
  <li>Hello ?</li><br />
  <li>World !<br />
root@In Namespace:/home/vagrant/nstest#  #inside container<br />
root@In Namespace:/home/vagrant/nstest# exit<br />
root@ubuntu:/home/vagrant/nstest#        #outside container<br />
可以看到，在子进程中hostname变成了In Namespace，而父进程的hostname为ubuntu不受子进程修改hostname的影响，通过CLONE_NEWUTS实现了主机名的隔离。注意，如果不加CLONE_NEWUTS标记运行，会发现退出子进程后hostname也还原了，这是因为bash只在登录的时候读取一次UTS，等你重新登陆就会发现hostname变了。因此，为了hostname隔离，加上CLONE_NEWUTS标志。</li><br />
</ul><br />
<br />
<p>docker容器的hostname也是通过该机制实现的隔离，每个容器都有自己的hostname（默认是容器ID），并不会对宿主机的hostname产生任何影响。</p><br />
<br />
<p>root@ubuntu:/home/ssj# docker exec -it ssjtestnew /bin/bash<br />
root@c9df3369e321:/# hostname<br />
c9df3369e321<br />
1.2 /proc/PID/ns文件<br />
从/proc/PID/ns目录中，我们可以看到一个进程的namespace。比如我们运行上面的 ./ns，并查看父子进程的namespace，结果如下，可以看到ns和子进程bash的ns目录中，除了UTS namespace是不一样的，表明这两个进程在不同的UTS名字空间，其他5个namespace是相同的。/proc/PID/ns目录中的为符号链接，指向的是对应namespace的名字，名字命名规则是namespace类型+inode数字，如ipc:[4026531839]。</p><br />
<br />
<p>root@ubuntu:/home/vagrant# ps -ef <br />
root      3086  2741  0 02:46 pts/0    00:00:00 ./ns<br />
root      3087  3086  0 02:46 pts/0    00:00:00 /bin/bash<br />
root@ubuntu:/home/vagrant# ls -ls /proc/3086/ns/<br />
total 0<br />
0 lrwxrwxrwx 1 root root 0 Aug 16 02:47 ipc -&gt; ipc:[4026531839]<br />
0 lrwxrwxrwx 1 root root 0 Aug 16 02:47 mnt -&gt; mnt:[4026531840]<br />
0 lrwxrwxrwx 1 root root 0 Aug 16 02:47 net -&gt; net:[4026531956]<br />
0 lrwxrwxrwx 1 root root 0 Aug 16 02:47 pid -&gt; pid:[4026531836]<br />
0 lrwxrwxrwx 1 root root 0 Aug 16 02:47 user -&gt; user:[4026531837]<br />
0 lrwxrwxrwx 1 root root 0 Aug 16 02:47 uts -&gt; uts:[4026531838]<br />
root@ubuntu:/home/vagrant# ls -ls /proc/3087/ns/ <br />
total 0<br />
0 lrwxrwxrwx 1 root root 0 Aug 16 02:47 ipc -&gt; ipc:[4026531839]<br />
0 lrwxrwxrwx 1 root root 0 Aug 16 02:47 mnt -&gt; mnt:[4026531840]<br />
0 lrwxrwxrwx 1 root root 0 Aug 16 02:47 net -&gt; net:[4026531956]<br />
0 lrwxrwxrwx 1 root root 0 Aug 16 02:47 pid -&gt; pid:[4026531836]<br />
0 lrwxrwxrwx 1 root root 0 Aug 16 02:47 user -&gt; user:[4026531837]<br />
0 lrwxrwxrwx 1 root root 0 Aug 16 02:47 uts -&gt; uts:[4026532182]<br />
root@ubuntu:/home/vagrant# readlink /proc/3086/ns/uts # show parent UTS namespace<br />
uts:[4026531838]<br />
root@ubuntu:/home/vagrant# readlink /proc/3087/ns/uts # show child UTS namespace<br />
uts:[4026532182]<br />
root@ubuntu:/home/vagrant# touch ~/uts<br />
root@ubuntu:/home/vagrant# mount –bind /proc/3087/ns/uts ~/uts</p><br />
<br />
<p>当然namespace还有其他的用处，只要namespace的文件描述符是打开的，即便该namespace所有进程都终止了，该namespace还是依旧存在。我们如果直接退出程序，可以看到进程退出后/proc/PID目录会整个删掉，包括ns目录。于是，为了保存子进程的UTS namespace，我们用mount命令先挂载该namespace，稍后我们会用setns()将进程加入到该UTS namespace。</p><br />
<br />
<p>mount –bind /proc/3087/ns/uts ~/uts<br />
1.3 加入已经存在的namespace：setns()<br />
通过setns和execve可以让一个进程加入一个已经存在的namespace并在那个namespace执行命令。测试代码 ns_setns.c，这里用到上一节中保留的UTS namespace。</p><br />
<br />
<p>运行结果如下：</p><br />
<br />
<p>root@ubuntu:/home/vagrant/nstest# gcc -o ns_setns ns_setns.c <br />
root@ubuntu:/home/vagrant/nstest# ./ns_setns ~/uts /bin/bash <br />
root@In Namespace:/home/vagrant/nstest# echo $$  ## show pid<br />
3375<br />
root@In Namespace:/home/vagrant/nstest# hostname<br />
In Namespace<br />
root@In Namespace:/home/vagrant/nstest# readlink /proc/3375/ns/<br />
ipc   mnt   net   pid   user  uts <br /><br />
root@In Namespace:/home/vagrant/nstest# readlink /proc/3375/ns/uts <br />
uts:[4026532182]<br />
可以看到该进程的UTS namespace为我们指定的之前保留的child process的UTS namespace。</p><br />
<br />
<p>1.4 隔离一个namespace：unshare()<br />
unshare函数可以让进程脱离一个namespace，它与clone类似，不同的是，unshare不需要创建新的进程，而是在当前进程直接隔离namespace。</p><br />
<br />
<p>测试代码 ns_unshare.c ，运行之，在参数中我们传递-m用来隔离NS namespace（即挂载点的namespace），结果可以看到在新的NS namespace的shell进程中umount了一个目录/run/lock，并不影响老的shell进程的挂载点。</p><br />
<br />
<p>root@ubuntu:/home/vagrant/nstest# echo \(#Show pid of shell<br />
4434<br />
root@ubuntu:/home/vagrant/nstest# readlink /proc/4434/ns/mnt     # Show shell NS namespace id<br />
mnt:[4026532183]<br />
root@ubuntu:/home/vagrant/nstest# cat /proc/4434/mounts|grep '/run/lock'<br />
none /run/lock tmpfs rw,nosuid,nodev,noexec,relatime,size=5120k 0 0<br />
root@ubuntu:/home/vagrant/nstest# ./ns_unshare -m /bin/bash        #Start new shell in separate mount namespace<br />
hello, pid=4927<br />
root@ubuntu:/home/vagrant/nstest# echo\)<br />
4927<br />
root@ubuntu:/home/vagrant/nstest# readlink /proc/4927/ns/mnt   #Show mount namespace ID in new shell<br />
mnt:[4026532184]<br />
root@ubuntu:/home/vagrant/nstest# cat /proc/4927/mounts|grep ‘run/lock’<br />
none /run/lock tmpfs rw,nosuid,nodev,noexec,relatime,size=5120k 0 0<br />
root@ubuntu:/home/vagrant/nstest# umount /run/lock    #Umount dir in separate mount namespace<br />
root@ubuntu:/home/vagrant/nstest# cat /proc/4927/mounts|grep ‘run/lock’<br />
root@ubuntu:/home/vagrant/nstest# exit<br />
root@ubuntu:/home/vagrant/nstest# cat /proc/4434/mounts|grep ‘/run/lock’  #Old shell not affected<br />
none /run/lock tmpfs rw,nosuid,nodev,noexec,relatime,size=5120k 0 0<br />
至此，namespace操作的相关API函数已经都说完了，接下来分别看看这6个namespace。</p><br />
<br />
<p>2 UTS Namespace<br />
UTS是实现主机名和域名的隔离，在第一节中已经说过，这里不再赘述。</p><br />
<br />
<p>3 IPC Namespace<br />
IPC指Unix/Linux下进程间通信的方式，可以通过共享内存，信号量，消息队列，管道等方法实现。这里我们要隔离IPC namespace，实现方式也很简单，在clone函数的flags参数中加入CLONE_NEWIPC即可，这样你可以在新的namespace中创建IPC，甚至是命名一个，并不会有与其他应用冲突的风险。</p><br />
<br />
<p>我们在最初的实例代码ns.c中修改一下，加入CLONE_NEWIPC的flag。修改的代码只有一行，如下。当然这里的CLONE_NEWUTS不是必须的，保留这个flag只是为了更加方便的显示效果。</p><br />
<br />
<p>/*<br />
ns_ipc.c: used to test ipc<br />
*/<br />
[…]<br />
int child_pid = clone(child_main, child_stack+STACK_SIZE,<br />
      CLONE_NEWUTS | CLONE_NEWIPC| SIGCHLD, NULL);<br />
[…]<br />
先通过ipcmk -Q创建一个IPC队列，队列ID为65536，然后运行./ns_ipc，可以看到在新的namespace中并没有该IPC队列，做到了IPC隔离。</p><br />
<br />
<p>root@ubuntu:/home/vagrant/nstest# ipcmk -Q <br />
Message queue id: 65536<br />
root@ubuntu:/home/vagrant/nstest# ipcs -q</p><br />
<br />
<p>—— Message Queues ——–<br />
key        msqid      owner      perms      used-bytes   messages  <br /><br />
0x0a3817cf 65536      root       644        0            0</p><br />
<br />
<p>root@ubuntu:/home/vagrant/nstest# ./ns_ipc</p><br />
<ul><br />
  <li>Hello ?</li><br />
  <li>World !<br />
root@In Namespace:/home/vagrant/nstest# ipcs -q</li><br />
</ul><br />
<br />
<p>—— Message Queues ——–<br />
key        msqid      owner      perms      used-bytes   messages</p><br />
<br />
<p>root@In Namespace:/home/vagrant/nstest# exit<br />
root@ubuntu:/home/vagrant/nstest# ipcs -q</p><br />
<br />
<p>—— Message Queues ——–<br />
key        msqid      owner      perms      used-bytes   messages  <br /><br />
0x0a3817cf 65536      root       644        0            0 <br /><br />
接下来可能有人要问了，那这种父子进程在不同的IPC namespace了，它们之间怎么通信呢？前面说过，进程间通信有信号量，共享内存，管道，FIFO，sockets等。由于上下文的改变，使用信号量也许不是最佳方案。而使用共享内存则有效率上的问题，如果不隔离网络栈的话也可以用sockets，但是我们现在要一步步隔离一切，因此sockets也不合适。FIFO则可以用于任意进程间的通信，FIFO是一种特殊的文件类型，在文件系统中是有对应路径的，它的问题也与sockets类似，因为我们要隔离文件系统的话，它也不合适。管道用于有亲属关系的进程之间通信，比如父子进程或者兄弟进程之间通信，很适合不同namespace的进程通信。</p><br />
<br />
<p>使用管道实现不同namespace之间进程通信的示例代码 ns_ipc.c，运行之，可以看到位于不同namespace的父子进程确实通信成功了。</p><br />
<br />
<p>root@ubuntu:/home/vagrant/nstest# ./ns_ipc</p><br />
<ul><br />
  <li>Hello ?</li><br />
  <li>World !<br />
root@In Namespace:/home/vagrant/nstest# exit<br />
root@ubuntu:/home/vagrant/nstest# <br />
4 PID Namespace<br />
实现PID隔离加上CLONE_NEWPID标识即可。示例代码 ns_pid.c ，运行之：</li><br />
</ul><br />
<br />
<p>root@ubuntu:/home/vagrant/nstest# ./ns_pid</p><br />
<ul><br />
  <li>[ 7627] Hello ?</li><br />
  <li>[    1] World !<br />
root@In Namespace:/home/vagrant/nstest# echo $$    ##In new PID namespace<br />
1<br />
root@In Namespace:/home/vagrant/nstest# kill -KILL 7627<br />
bash: kill: (7627) - No such process</li><br />
</ul><br />
<br />
<p>###host ps view<br />
root@ubuntu:/home/vagrant/nstest# ps -ef|grep 7627<br />
root      7627  2768  0 04:40 pts/1    00:00:00 ./pid<br />
root      7628  7627  0 04:40 pts/1    00:00:00 /bin/bash<br />
可以看到在不同PID namespace中运行的/bin/bash的PID为1。而它的父进程的PID是7627。而在父进程namespace中，可以看到/bin/bash的进程为7268。如果你试图在新的Namespace中去kill某个不同namespace中的进程，则会报错提示进程不存在，达到了进程隔离的目的。</p><br />
<br />
<p>要注意的是，这个时候你在新的namespace中用ps，top等命令去查看，会发现7627这个进程是可见的。这与我们在docker容器中看到的不一致，如在我创建的一个redis容器中，用ps, top其实是只看得到容器所在namespace的进程的。</p><br />
<br />
<p>root@ubuntu:/home/ssj# docker exec -it redistest /bin/bash</p><br />
<br />
<p>root@0b86fb961783:/data# ps -ef<br />
UID        PID  PPID  C STIME TTY          TIME CMD<br />
redis        1     0  0 02:44 ?        00:00:00 redis-server *:6379<br />
root        18     0  0 02:45 ?        00:00:00 /bin/bash<br />
root        25    18  0 02:45 ?        00:00:00 ps -ef<br />
这是因为ps命令读取的是/proc文件系统获取的信息，而文件系统我们还没有隔离，所以在新的namespace中可以看到所有的进程，接下来我们会用NS namespace来实现这个隔离。</p><br />
<br />
<p>5 NS Namespace<br />
NS namespace也就是挂载点相关的了，在第4节的代码基础上加入CLONE_NEWNS的flag，并在子进程挂载 /proc目录。修改后创建进程的代码 ns_ns.c, 运行之:</p><br />
<br />
<p>root@ubuntu:/home/vagrant/nstest# ./ns_ns</p><br />
<ul><br />
  <li>[27137] Hello ?</li><br />
  <li>[    1] World !<br />
root@In Namespace:/home/vagrant/nstest# ps -ef<br />
UID        PID  PPID  C STIME TTY          TIME CMD<br />
root         1     0  0 20:37 pts/0    00:00:00 /bin/bash<br />
root         3     1  0 20:39 pts/0    00:00:00 ps -ef<br />
root@In Namespace:/home/vagrant/nstest# ls /proc/<br />
1      bus       cpuinfo    dma      filesystems  ioports   kcore      kpagecount  meminfo  mpt       partitions   softirqs  sysrq-trigger  tty      vmstat<br />
5      cgroups   crypto driver       fs       ipmi      keys       kpageflags  misc     mtrr      sched_debug  stat  sysvipc    uptime       zoneinfo<br />
acpi       cmdline   devices    execdomains  interrupts   irq       key-users  loadavg     modules  net       self         swaps     timer_list version<br />
buddyinfo  consoles  diskstats  fb       iomem    kallsyms  kmsg       locks       mounts   pagetypeinfo  slabinfo     sys   timer_stats    vmallocinfo<br />
可以看到ps命令确实只显示了当前namespace下面的进程了，而且ls /proc/命令查看发现/proc目录下面的内容也清爽多了。docker使用NS namespace实现了一些文件系统的挂载，原理与这个类似，结合chdir和chroot可以实现一个山寨的docker镜像。</li><br />
</ul><br />
<br />
<p>这个时候我们再来看看docker中PID和NS namespace具体的实现(我的docker版本是1.13.1，其他版本可能有所不同)，我这里在宿主机起了一个redis容器名为redistest，通过pstree可以看到进程关系如下：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    |-dockerd-+-docker-containerd-+-docker-containerd-shim-+-redis-server---3*[{redis-server}]<br />
    |         |                 |                 `-8*[{docker-containe}]<br />
    |         |                 `-12*[{docker-containe}]<br />
    |         `-19*[{dockerd}] 这里对应进程关系就是：<br />
</code></pre></div></div><br />
<br />
<p>dockerd进程创建了一个docker-containerd子进程，而docker-contianerd子进程再创建子进程docker-containerd-shim，也就是对应具体容器的进程。<br />
容器进程docker-containerd-shim创建容器里面的1号进程redis-server。<br />
通过查看/proc/PID/ns目录就可以发现，dockerd，dockerd-containerd以及dockerd-containerd-shim的namespace都是一样的，而容器里面的1号进程 redis-server的namespace除了User namespace外，其他的namespace都已经不同。也就是说，从容器里面的1号进程开始，进程的namespace开始隔离。<br />
另外注意一点的是，当你使用 docker exec -it redistest /bin/bash命令进入容器的时候，这个/bin/bash进程的父进程其实是另外一个 docker-containerd-shim进程，只是/bin/bash进程的namespace和redis-server进程一样，所以这个时候你在redistest容器中ps -ef，可以看到除了redis-server进程外，还有/bin/bash进程。通过exec命令进入容器后，再来看进程关系，是下面这样的:<br />
       |-dockerd-+-docker-containerd-+-docker-containerd-shim-+-redis-server—3<em>[{redis-server}]<br />
        |         |                  |                 <code class="language-plaintext highlighter-rouge">-8*[{docker-containe}]<br />
        |         |                  |-docker-containerd-shim-+-bash<br />
        |         |                  |                 </code>-8</em>[{docker-containe}]<br />
        |         |                  <code class="language-plaintext highlighter-rouge">-12*[{docker-containe}]<br />
        |         </code>-19*[{dockerd}]<br />
而在容器在自己的NS namespace中挂载了很多目录，如下面这些：</p><br />
<br />
<p>/dev/sda8 on /etc/resolv.conf type ext4 (rw,relatime,data=ordered)<br />
/dev/sda8 on /etc/hostname type ext4 (rw,relatime,data=ordered)<br />
/dev/sda8 on /etc/hosts type ext4 (rw,relatime,data=ordered)<br />
…<br />
proc on /proc/irq type proc (ro,nosuid,nodev,noexec,relatime)<br />
proc on /proc/sys type proc (ro,nosuid,nodev,noexec,relatime)<br />
6 NET Namespace<br />
NET namespace是指网络上的隔离，通过加入CLONE_NEWNET来实现。在讨论这个之前，可以先看看通过ip命令如何手动创建network namespace以及veth设备等。veth主要的目的是为了跨NET namespace之间提供一种类似于Linux进程间通信的技术，所以veth总是成对出现，如下面的veth0和veth1。它们位于不同的NET namespace中，在veth设备任意一端接收到的数据，都会从另一端发送出去。veth工作在L2数据链路层，只负责数据传输，不会更改数据包。</p><br />
<br />
<h1 id="create-a-demo-namespace">Create a “demo” namespace</h1><br />
<p>ip netns add demo</p><br />
<br />
<h1 id="create-a-veth-pair">create a “veth” pair</h1><br />
<p>ip link add veth0 type veth peer name veth1</p><br />
<br />
<h1 id="and-move-one-to-the-namespace">and move one to the namespace</h1><br />
<p>ip link set veth1 netns demo</p><br />
<br />
<h1 id="configure-the-interfaces-up--ip">configure the interfaces (up + IP)</h1><br />
<p>ip netns exec demo ip link set lo up<br />
ip netns exec demo ip link set veth1 up<br />
ip netns exec demo ip addr add 169.254.1.2/30 dev veth1<br />
ip link set veth0 up<br />
ip addr add 169.254.1.1/30 dev veth0<br />
执行完成后，我们可以在宿主机里面看到网络设备是这样的:</p><br />
<br />
<p>root@ubuntu:/home/vagrant# ip -d link<br />
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default <br />
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 <br />
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000<br />
    link/ether 08:00:27:ec:df:9c brd ff:ff:ff:ff:ff:ff promiscuity 0 <br />
3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000<br />
    link/ether 08:00:27:57:25:68 brd ff:ff:ff:ff:ff:ff promiscuity 0 <br />
5: veth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000<br />
    link/ether 62:14:fd:45:f8:0e brd ff:ff:ff:ff:ff:ff promiscuity 0 <br />
    veth <br />
root@ubuntu:/home/vagrant# ethtool -S veth0<br />
NIC statistics:<br />
     peer_ifindex: 4<br />
而在demo这个NET namespace中，看到的网络设备是这样的：</p><br />
<br />
<p>root@ubuntu:/home/vagrant# ip netns exec demo ip -d link<br />
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default <br />
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 <br />
4: veth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000<br />
    link/ether 6a:7d:49:3f:bc:8e brd ff:ff:ff:ff:ff:ff promiscuity 0 <br />
    veth <br />
这个原理就是先创建一个新的NET namespace名为demo，然后创建一对veth设备，veth0和veth1，接着将veth1移动到namespace demo，而veth0仍然保留在原来的namespace，然后启动对应的veth设备。这样一对veth设备分属于不同的namespace，并可以通信。然后给veth0和veth1设置ip并启动它们。要查看veth的一对设备中另外一个，可以用 ethtool -S命令。实现上面功能的代码 ns_net.c ，运行之，如下：</p><br />
<br />
<p>root@ubuntu:/home/vagrant/nstest# ./ns_net</p><br />
<ul><br />
  <li>[ 2760] Hello ?</li><br />
  <li>[    1] World !</li><br />
</ul><br />
<br />
<h3 id="宿主机namespace">宿主机namespace</h3><br />
<p>root@ubuntu:/home/vagrant/nstest# ip -d link<br />
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default <br />
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 <br />
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000<br />
    link/ether 08:00:27:ec:df:9c brd ff:ff:ff:ff:ff:ff promiscuity 0 <br />
3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000<br />
    link/ether 08:00:27:57:25:68 brd ff:ff:ff:ff:ff:ff promiscuity 0 <br />
11: veth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000<br />
    link/ether ce:95:ad:9e:ee:6b brd ff:ff:ff:ff:ff:ff promiscuity 0 <br />
    veth</p><br />
<br />
<h3 id="新的namespace">新的namespace</h3><br />
<p>root@In Namespace:/home/vagrant/nstest# ip -d link<br />
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default <br />
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 <br />
10: veth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000<br />
    link/ether 9a:e9:95:53:c3:28 brd ff:ff:ff:ff:ff:ff promiscuity 0 <br />
    veth <br />
root@In Namespace:/home/vagrant/nstest# ethtool -S veth1<br />
NIC statistics:<br />
     peer_ifindex: 11<br />
docker网络分为bridge， host， overlay等几种类型。host就是与主机共用namespace，这里不单独分析了。而bridge就与前面例子中类似，不同的是仅仅有veth容器还无法与外部联通，因此docker借助了网桥技术用于连接不同网段，在L2层进行数据转发，将veth0加入到宿主机的网桥docker0中，并在iptables加入对应的NAT规则，以保证容器可以与外部连通。注意docker中NET namespace的隔离不是通过ip命令实现的(因为不是所有的内核版本都有ip netns这个高级命令)，而是通过netlink基于操作系统调用的方式实现的。而overlay网络则是通过vxlan协议实现，对应的veth会桥接到overlay的NET namespace一个br0网桥上。bridge和overlay网络的一个示意图如下(图来自 deep-dive-into-docker-overlay-networks)，其中192.168.0.X这个是自定义的overlay网络，而172.18.0.X的则是bridge网络，docker网络部分会在下一篇文章再详细分析。</p><br />
<br />
<p>docker网络示意图<br />
7 USER Namespace<br />
7.1 创建新的USER Namespace<br />
加上 CLONE_NEWUSER flag可以实现USER namespace的隔离。示例如下(注意，在debian或者ubuntu中必须设置/proc/sys/kernel/unprivileged_userns_clone这个文件值为1，否则无法以普通用户运行带CLONE_NEWUSER标记的clone命令<br />
)<br />
示例代码 ns_user.c，以普通用户运行之：</p><br />
<br />
<p>vagrant@ubuntu:~/nstest$ id -u<br />
1000<br />
vagrant@ubuntu:~/nstest$ id -g<br />
1000<br />
vagrant@ubuntu:~/nstest$ gcc -o ns_user ns_user.c -lcap<br /><br />
#如果编译报错的话，安装libcap-dev模块，sudo apt-get install libcap-dev<br />
vagrant@ubuntu:~/nstest$ ./user <br />
eUID = 65534;  eGID = 65534;  capabilities: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend+ep<br />
这里有几点注意的：</p><br />
<br />
<p>其一，从capabilities输出可以看到子进程在它的namespace里面有全部的capability，虽然我们是用普通用户权限运行的程序。当一个新的USER namespace创建的时候，这个namespace的第一个进程就被赋予了全部的capability。capability是为了实现更精细化的权限控制而加入的。(我们以前熟知通过设置文件的SUID位，这样非root用户的可执行文件运行后的euid会成为文件的拥有者ID，比如passwd命令运行起来后有root权限。一旦SUID的文件存在漏洞，便可能被利用而增加安全风险）。查看文件的capability的命令为 filecap -a，而查看进程capability的命令为 pscap -a(pscap和filecap工具需要安装 libcap-ng-utils这个包)。对capability的那串数字解码命令为 capsh –decode=00000000000000c0。更多capability的内容见参考资料4。</p><br />
<br />
<p>对于capability，可以看一个简单的例子便于理解。如ubuntu14.04系统中自带的ping工具，它是有设置SUID位的。这里拷贝ping到我的用户目录下名为anotherping，可以看到它的SUID位是没有了的，运行anotherping，会提示权限错误。这里，我们只要将其加上 cap_net_raw权限即可，不需要设置SUID位那么大的权限。</p><br />
<br />
<p>vagrant@ubuntu:~$ ls -ls /bin/ping<br />
44 -rwsr-xr-x 1 root root 44168 May  7  2014 /bin/ping<br />
vagrant@ubuntu:~$ cp /bin/ping anotherping<br />
vagrant@ubuntu:~$ ls -ls anotherping <br />
44 -rwxr-xr-x 1 vagrant vagrant 44168 Aug 27 03:27 anotherping<br />
vagrant@ubuntu:~$ ping -c1 www.163.com<br />
PING 163.xdwscache.ourglb0.com (112.90.246.87) 56(84) bytes of data.<br />
64 bytes from ns.local (112.90.246.87): icmp_seq=1 ttl=63 time=11.9 ms<br />
…<br />
vagrant@ubuntu:~$ ./anotherping -c1 www.163.com<br />
ping: icmp open socket: Operation not permitted</p><br />
<br />
<p>vagrant@ubuntu:~$ sudo setcap cap_net_raw+ep ./anotherping <br />
vagrant@ubuntu:~$ ./anotherping -c1 www.163.com<br />
PING 163.xdwscache.ourglb0.com (112.90.246.87) 56(84) bytes of data.<br />
64 bytes from ns.local (112.90.246.87): icmp_seq=1 ttl=63 time=12.4 ms<br />
…<br />
其二，一个进程的uid和gid在不同的USER namespace是可以不一样的，这需要一个namespace内部映射到namespace外部的映射关系。这样当一个USER namespace中的进程的操作可能影响到外部系统时，可以对这个进程的权限进行检查。如果一个用户ID在USER namespace中没有映射关系，则getuid()系统调用会返回 /proc/sys/kernel/overflowuid值作为用户ID，这个值默认为65534，就如我们前面程序中输出一样(gid对应的文件名为overflowgid)。</p><br />
<br />
<p>其三，尽管通过clone系统调用创建的子进程在新的USER namespace中有所有权限，但是它在parent user namespace是没有任何权限的，即便以root身份运行也是一样。user namespace的创建可以是嵌套的，一个user namespace一定有个parent user namespace，可以有零或者多个 child user namespace。子进程的parent user namespace就是调用clone()或者unshare()通过CLONE_NEWUSER的flag创建新namespace的那个父进程的user namespace。</p><br />
<br />
<p>7.2 映射uid和gid<br />
创建新的user namespace之后第一步就是设置好user和group的映射关系。这个映射通过设置/proc/PID/uid_map(gid_map)实现，格式如下：</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID-inside-ns   ID-outside-ns   length 不是所有的进程都能随便修改映射文件的，必须同时具备如下条件：<br />
</code></pre></div></div><br />
<br />
<p>修改映射文件的进程必须有PID进程所在user namespace的CAP_SETUID/CAP_SETGID权限。进程的capability一般是通过其可执行文件的capability获得。<br />
修改映射文件的进程必须是跟PID在同一个user namespace或者PID的parent user namespace。<br />
映射文件uid_map和gid_map只能写入一次，再次写入会报错。<br />
下面来测试下7.1中的例子：</p><br />
<br />
<p>#在第一个终端运行 ns_user<br />
vagrant@ubuntu:~/nstest$ ./ns_user x<br />
eUID = 65534;  eGID = 65534; capabilities: = …ep</p><br />
<br />
<p>#在第二个终端写入该进程对应的uid_map<br />
vagrant@ubuntu:~/nstest$ ps -C ns_user -o ‘pid ppid uid comm’<br />
  PID  PPID   UID COMMAND<br />
 8775  8577  1000 ns_user<br />
 8776  8775  1000 ns_user<br />
vagrant@ubuntu:~/nstest$ echo ‘0 1000 1’ &gt; /proc/8776/uid_map</p><br />
<br />
<p>#第一个终端此时输出为：<br />
vagrant@ubuntu:~/nstest$ ./ns_user x<br />
eUID = 0;  eGID = 65534; capabilities: = …ep</p><br />
<br />
<p>#在第二个终端继续写入gid_map<br />
vagrant@ubuntu:~/nstest$ echo ‘0 1000 1’ &gt; /proc/8776/gid_map</p><br />
<br />
<p>#第一个终端此时输出为：<br />
vagrant@ubuntu:~/nstest$ ./ns_user x<br />
eUID = 0;  eGID = 0; capabilities: = …ep</p><br />
<br />
<p>可以看到，我们在位于parent user namespace的bash进程中通过echo命令修改uid_map和gid_map都是可以成功的。这是因为我的测试环境的bash进程具有CAP_SETUID和CAP_SETGID权限的，查看/proc/PID/status可以验证进程的权限或者getcap可以验证一个可执行文件的权限，如下验证bash的权限，如果bash原来没有这两个权限，可以通过命令sudo setcap cap_setgid,cap_setuid+ep /bin/bash设置:</p><br />
<br />
<p>vagrant@ubuntu:~/nstest$ cat /proc/$$/status | egrep ‘Cap(Inh|Prm|Eff)’<br />
CapInh: 0000000000000000<br />
CapPrm: 00000000000000c0<br />
CapEff: 00000000000000c0</p><br />
<br />
<p>vagrant@ubuntu:~/nstest$ getcap /bin/bash<br />
/bin/bash = cap_setgid,cap_setuid+ep<br />
这里有个要注意的地方，ubuntu14.04的/bin/bash文件默认就有修改新的user namespace进程的uid_map的权限，如果要修改gid_map要另外加下cap_setgid权限。而其他的可执行文件，默认也是只有cap_setuid权限，比如网上很多文章中提到的一个设置user namespace的例子，在ubuntu14.04里面设置gid_map会失败，因为可执行文件没有cap_setgid权限，需要加上gid权限才能成功修改gid_map。</p><br />
<br />
<p>看这个例子，代码 ns_child_exec.c，执行后可以发现在新的user namespace里面的bash里面通过echo命令设置uid_map和gid_map都会失败，这是因为当一个非root用户的进程执行execve()时，进程的capability会被清空。于是，子进程虽然有新的user namespace所有的权限集合，但是通过它exevce执行的bash进程以及bash进程的子进程是没有对应的capability的。</p><br />
<br />
<p>vagrant@ubuntu:~/nstest$ ./ns_child_exec -U bash<br />
nobody@ubuntu:~/nstest$ id -u  #新的user namespace运行的bash进程<br />
65534<br />
nobody@ubuntu:~/nstest$ id -g<br />
65534<br />
nobody@ubuntu:~/nstest$ echo ‘0 1000 1’ &gt; /proc/\(/uid_map<br />
bash: echo: write error: Operation not permitted<br />
nobody@ubuntu:~/nstest$ echo '0 1000 1' &gt; /proc/\)/gid_map<br />
bash: echo: write error: Operation not permitted<br />
为了设置映射文件，因此需要在父进程中设置，示例代码 userns_child_exec.c。注意一点的是，要在userns_child_exec进程中成功设置gid_map文件，需要给可执行文件加上 cap_setgid权限，此外，还要保证 /bin/bash是有cap_setgid权限的：</p><br />
<br />
<p>root@ubuntu:~/nstest# setcap cap_setgid+ep ./userns_child_exec<br />
vagrant@ubuntu:~/nstest$ ./userns_child_exec -U -M ‘0 1000 1’ -G ‘0 1000 1’ bash<br />
root@ubuntu:~/nstest# id -u # 新的user namespace<br />
0<br />
root@ubuntu:~/nstest# id -g<br />
0<br />
root@ubuntu:~/nstest# cat /proc/$$/status | egrep ‘Cap(Inh|Prm|Eff)’<br />
CapInh: 0000000000000000<br />
CapPrm: 0000003fffffffff<br />
CapEff: 0000003fffffffff<br />
最后一点要注意的是，uid_map文件里面的 ID-outside-ns 这个值是根据当前读取文件的user namespace生成的，这个是什么意思呢？看下面的例子就明白了。在两个终端里面分别运行 userns_child_exec程序，设置不同的ID-inside-ns，运行结果如下所示。也就是说，我们在初始的user namespace创建了2个child user namespace，一个是映射的uid为0，另一个映射的为200，在第一个终端看第二个终端进程对应的映射关系时可以发现uid_map值为 200 0 1，也就是说第二个user namespace中的进程用户ID映射到了当前user namespace的uid 0，而不是初始的user namespace的1000。从第二个终端里面看第一个终端的进程的uid_map正好反转。当然，你如果在第三个终端从初始的user namespace里面去看uid_map，是跟之前一样的。</p><br />
<br />
<h1 id="第一个终端映射-0---1000">第一个终端，映射 0 -&gt; 1000</h1><br />
<p>vagrant@ubuntu:~/nstest$ ./userns_child_exec -U -M ‘0 1000 1’ -G ‘0 1000 1’ bash <br />
root@ubuntu:~/nstest# id -u<br />
0<br />
root@ubuntu:~/nstest# id -g<br />
0<br />
root@ubuntu:~/nstest# echo \(25730<br />
root@ubuntu:~/nstest# cat /proc/\)/uid_map<br />
         0       1000          1<br />
root@ubuntu:~/nstest# cat /proc/26091/uid_map<br /><br />
       200          0          1</p><br />
<br />
<h1 id="第二个终端映射-200-1000">第二个终端，映射 200-&gt;1000</h1><br />
<p>vagrant@ubuntu:~/nstest$ ./userns_child_exec -U -M ‘200 1000 1’ -G ‘200 1000 1’ bash<br />
I have no name!@ubuntu:~/nstest$ id -u<br />
200<br />
I have no name!@ubuntu:~/nstest$ echo \(26091<br />
I have no name!@ubuntu:~/nstest$ cat /proc/\)/uid_map <br />
       200       1000          1<br />
I have no name!@ubuntu:~/nstest$ cat /proc/25730/uid_map <br />
         0        200          1</p><br />
<br />
<h1 id="第三个终端初始user-namespace里面查看映射关系">第三个终端，初始user namespace里面查看映射关系</h1><br />
<p>vagrant@ubuntu:~/nstest$ cat /proc/25730/uid_map <br />
         0       1000          1<br />
vagrant@ubuntu:~/nstest$ cat /proc/26091/uid_map <br />
       200       1000          1<br />
之前我们提到的docker示例中，没有对user namespace进行隔离。user namespace功能虽然在很早就出现了，但是直到Linux kernel 3.8之后这个功能才逐步稳定。docker1.10之后的版本可以通过在docker daemon启动时加上–userns-remap=[USERNAME]来实现USER Namespace的隔离，在实际使用中我们暂时没有用到USER namespace的隔离，不过docker对于CAP很早就有使用的，所以可以看到容器启动的时候如果需要特定功能的需要加–cap-add SYS_ADMIN，NET_ADMIN这些参数。</p><br />
<br />
<p>http://www.man7.org/linux/man-pages/man2/setns.2.html</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category docker
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>