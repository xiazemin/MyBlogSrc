<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">runC</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-10-22T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Oct 22, 2019</time></p>
					</div>
					 <p>https://github.com/opencontainers/runc/tree/v1.0.0-rc6<br />
容器运行时(Container Runtime)是指管理容器和容器镜像的软件。当前业内比较有名的有docker，rkt等。如果不同的运行时只能支持各自的容器，那么显然不利于整个容器技术的发展。于是在2015年6月，由Docker以及其他容器领域的领导者共同建立了围绕容器格式和运行时的开放的工业化标准，即Open Container Initiative(OCI)，OCI具体包含两个标准：运行时标准(runtime-spec)和容器镜像标准(image-spec)。简单来说，容器镜像标准定义了容器镜像的打包形式(pack format)，而运行时标准定义了如何去运行一个容器。</p><br />
<br />
<p>本文包含以下内容：</p><br />
<br />
<p>runC的概念和使用<br />
runC运行容器的原理剖析<br />
本文不包含以下内容：</p><br />
<br />
<p>docker engine使用runC<br />
<!-- more --><br />
runC概念<br />
runC是一个遵循OCI标准的用来运行容器的命令行工具(CLI Tool)，它也是一个Runtime的实现。尽管你可能对这个概念很陌生，但实际上，你的电脑上的docker底层可能正在使用它。至少在笔者的主机上是这样。</p><br />
<br />
<p>root@node-1:~# docker info<br />
…..<br />
Runtimes: runc<br />
Default Runtime: runc <br />
…..<br />
安装runC<br />
runC不仅可以被docker engine使用，它也可以单独使用(它本身就是命令行工具)，以下使用步骤完全来自runC’s README,如果</p><br />
<br />
<p>依赖项<br />
Go version 1.6或更高版本<br />
libseccomp库</p><br />
<br />
<p>yum install libseccomp-devel for CentOS<br />
 apt-get install libseccomp-dev for Ubuntu<br />
下载编译</p><br />
<h1 id="在gopathsrc目录创建githubcomopencontainers目录">在GOPATH/src目录创建’github.com/opencontainers’目录</h1><br />
<blockquote><br />
  <p>cd github.com/opencontainers<br />
git clone https://github.com/opencontainers/runc<br />
cd runc</p><br />
</blockquote><br />
<br />
<blockquote><br />
  <p>make<br />
sudo make install<br />
或者使用go get安装</p><br />
</blockquote><br />
<br />
<h1 id="在gopathsrc目录创建githubcom目录">在GOPATH/src目录创建github.com目录</h1><br />
<blockquote><br />
  <p>go get github.com/opencontainers/runc<br />
cd $GOPATH/src/github.com/opencontainers/runc<br />
make<br />
sudo make install<br />
以上步骤完成后，runC将安装在/usr/local/sbin/runc目录</p><br />
</blockquote><br />
<br />
<p>使用runC<br />
创建一个OCI Bundle<br />
OCI Bundle是指满足OCI标准的一系列文件，这些文件包含了运行容器所需要的所有数据，它们存放在一个共同的目录，该目录包含以下两项：</p><br />
<br />
<p>config.json：包含容器运行的配置数据<br />
container 的 root filesystem<br />
如果主机上安装了docker，那么可以使用docker export命令将已有镜像导出为OCI Bundle的格式</p><br />
<br />
<h1 id="create-the-top-most-bundle-directory">create the top most bundle directory</h1><br />
<blockquote><br />
  <p>mkdir /mycontainer<br />
cd /mycontainer</p><br />
</blockquote><br />
<br />
<h1 id="create-the-rootfs-directory">create the rootfs directory</h1><br />
<blockquote><br />
  <p>mkdir rootfs</p><br />
</blockquote><br />
<br />
<h1 id="export-busybox-via-docker-into-the-rootfs-directory">export busybox via Docker into the rootfs directory</h1><br />
<blockquote><br />
  <p>docker export $(docker create busybox) | tar -C rootfs -xvf -<br />
ls rootfs <br />
bin  dev  etc  home  proc  root  sys  tmp  usr  var<br />
有了root filesystem，还需要config.json，runc spec可以生成一个基础模板，之后我们可以在模板基础上进行修改。</p><br />
</blockquote><br />
<br />
<blockquote><br />
  <p>runc spec<br />
ls<br />
config.json rootfs<br />
生成的config.json模板比较长，这里我将它process中的arg 和 terminal进行修改</p><br />
</blockquote><br />
<br />
<p>{<br />
    “process”: {<br />
        “terminal”:false，     &lt;–  这里改为 true<br />
        “user”: {<br />
            “uid”: 0,<br />
            “gid”: 0<br />
        },<br />
        “args”: [<br />
            “sh”               &lt;– 这里改为 “sleep”,”5”<br />
        ],<br />
        “env”: [<br />
            “PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin”,<br />
            “TERM=xterm”<br /><br />
        ],<br />
        “cwd”: “/”,<br />
    },<br />
    “root”: {<br />
        “path”: “rootfs”,<br />
        “readonly”: true<br />
    }, <br /><br />
    “linux”: {<br />
        “namespaces”: [<br />
            {<br />
                “type”: “pid”<br />
            },<br />
            {<br />
                “type”: “network”<br />
            },<br />
            {<br />
                “type”: “ipc”<br />
            },<br />
            {<br />
                “type”: “uts”<br />
            },<br />
            {<br />
                “type”: “mount”<br />
            }<br />
        ],<br />
    }<br />
} <br />
config.json 文件的内容都是 OCI Container Runtime 的订制，其中每一项值都可以在Runtime Spec找到具体含义，OCI Container Runtime 支持多种平台，因此其 Spec 也分为通用部分（在config.md中描述）以及平台相关的部分（如linux平台上就是config-linux）</p><br />
<br />
<p>process:指定容器启动后运行的进程运行环境，其中最重要的的子项就是args，它指定要运行的可执行程序， 在上面的修改后的模板中，我们将其改成了”sleep 5”<br />
root：指定容器的根文件系统，其中path子项是指向前面导出的中root filesystem的路径<br />
linux: 这一项是平台相关的。其中namespaces表示新创建的容器会额外创建或使用的namespace的类型<br />
运行容器<br />
现在我们使用create命令创建容器</p><br />
<br />
<h1 id="run-as-root">run as root</h1><br />
<blockquote><br />
  <p>cd /mycontainer<br />
runc create mycontainerid<br />
使用list命令查看容器状态为created</p><br />
</blockquote><br />
<br />
<h1 id="view-the-container-is-created-and-in-the-created-state">view the container is created and in the “created” state</h1><br />
<blockquote><br />
  <p>runc list<br />
ID              PID         STATUS      BUNDLE                           CREATED                          OWNER<br />
mycontainerid   12068       created     /mycontainer   2018-12-25T19:45:37.346925609Z                      root <br />
使用start命令查看容器状态</p><br />
</blockquote><br />
<br />
<h1 id="start-the-process-inside-the-container">start the process inside the container</h1><br />
<blockquote><br />
  <p>runc start mycontainerid<br />
在5s内 使用list命令查看容器状态为running</p><br />
</blockquote><br />
<br />
<h1 id="within-5-seconds-view-that-the-container-is-running">within 5 seconds view that the container is running</h1><br />
<p>runc list<br />
ID              PID         STATUS      BUNDLE                           CREATED                          OWNER<br />
mycontainerid   12068       running     /mycontainer   2018-12-25T19:45:37.346925609Z                      root <br />
在5s后 使用list命令查看容器状态为stopped</p><br />
<br />
<h1 id="after-5-seconds-view-that-the-container-has-exited-and-is-now-in-the-stopped-state">after 5 seconds view that the container has exited and is now in the stopped state</h1><br />
<p>runc list<br />
ID              PID         STATUS      BUNDLE                           CREATED                          OWNER<br />
mycontainerid   0           stopped     /mycontainer   2018-12-25T19:45:37.346925609Z                       root <br />
使用delete命令可以删除容器</p><br />
<br />
<h1 id="now-delete-the-container">now delete the container</h1><br />
<p>runc delete mycontainerid<br />
runC 实现<br />
runC可以启动并管理符合OCI标准的容器。简单地说，runC需要利用OCI bundle创建一个独立的运行环境，并执行指定的程序。在Linux平台上，这个环境就是指各种类型的Namespace以及Capability等等配置</p><br />
<br />
<p>代码结构<br />
runC由Go语言实现，当前(2018.12)最新版本是v1.0.0-rc6,代码的结构可分为两大块,一是根目录下的go文件，对应各个runC命令，二是负责创建/启动/管理容器的libcontainer，可以说runC的本质都在libcontainer<br />
runc</p><br />
<br />
<p>runc create 实现原理 (上)<br />
以上面的例子为例，以’runc create’这条命令来看runC是如何完成从无到有创建容器，并运行用户指定的 ‘sleep 5’ 这个进程的。</p><br />
<br />
<p>创建容器，运行 sleep 5 就是我们的目标，请牢记<br />
本文涉及的调用关系如下，可随时翻阅<br />
 setupSpec(context)<br />
 startContainer(context, spec, CT_ACT_CREATE, nil) <br />
   |- createContainer<br />
      |- specconv.CreateLibcontainerConfig<br />
      |- loadFactory(context)<br />
         |- libcontainer.New(……)<br />
      |- factory.Create(id, config)<br />
   |- runner.run(spec.Process)<br />
      |- newProcess(*config, r.init) <br />
      |- r.container.Start(process)<br />
         |- c.createExecFifo()<br />
         |- c.start(process)<br />
            |- c.newParentProcess(process)<br />
            |- parent.start()<br />
create命令的响应入口在 create.go, 我们直接关注其注册的Action的实现，当输入runc create mycontainerid时会执行注册的Action，并且参数存放在Context中</p><br />
<br />
<p>/* run.go  <em>/<br />
Action: func(context *cli.Context) error { <br />
  ……<br />
  spec, err := setupSpec(context)   /</em> (sleep 5 在这里) */</p><br />
<br />
<p>status, err := startContainer(context, spec, CT_ACT_CREATE, nil) <br />
  …..<br />
}<br />
setupSpec：从命令行输入中找到-b 指定的 OCI bundle 目录，若没有此参数，则默认是当前目录。读取config.json文件，将其中的内容转换为Go的数据结构specs.Spec，该结构定义在文件 github.com/opencontainers/runtime-spec/specs-go/config.go,里面的内容都是OCI标准描述的。<br />
sleep 5 到了变量 spec<br />
startContainer：尝试创建启动容器，注意这里的第三个参数是 CT_ACT_CREATE, 表示仅创建容器。本文使用linux平台，因此实际调用的是 utils_linux.go 中的startContainer()。startContainer()根据用户将用户输入的 id 和刚才的得到的 spec 作为输入，调用 createContainer() 方法创建容器，再通过一个runner.run()方法启动它<br />
/× utils_linux.go ×/<br />
func startContainer(context *cli.Context, spec *specs.Spec, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) {<br />
    id := context.Args().First()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>container, err := createContainer(context, id, spec)<br />
<br />
r := &amp;runner{<br />
    container:       container,<br />
    action:          action,<br />
    init:            true,<br />
    ......<br />
}<br />
return r.run(spec.Process) } 这里需要先了解下runC中的几个重要数据结构的关系<br />
</code></pre></div></div><br />
<br />
<p>Container 接口<br />
在runC中，Container用来表示一个容器对象，它是一个抽象接口，它内部包含了BaseContainer接口。从其内部的方法的名字就可以看出，都是管理容器的基本操作</p><br />
<br />
<p>/* libcontainer/container.go <em>/<br />
type BaseContainer interface {<br />
    ID() string<br />
    Status() (Status, error)<br />
    State() (</em>State, error)<br />
    Config() configs.Config<br />
    Processes() ([]int, error)<br />
    Stats() (*Stats, error)<br />
    Set(config configs.Config) error<br />
    Start(process *Process) (err error)<br />
    Run(process *Process) (err error)<br />
    Destroy() error<br />
    Signal(s os.Signal, all bool) error<br />
    Exec() error<br />
}</p><br />
<br />
<p>/* libcontainer/container_linux.go */<br />
type Container interface {<br />
    BaseContainer</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Checkpoint(criuOpts *CriuOpts) error<br />
Restore(process *Process, criuOpts *CriuOpts) error<br />
Pause() error<br />
Resume() error<br />
NotifyOOM() (&lt;-chan struct{}, error)<br />
NotifyMemoryPressure(level PressureLevel) (&lt;-chan struct{}, error) } 有了抽象接口，那么一定有具体的实现，linuxContainer 就是一个实现，或者说，它是当前版本runC在linux平台上的唯一一种实现。下面是其定义，其中的 initPath 非常关键<br />
</code></pre></div></div><br />
<br />
<p>type linuxContainer struct {<br />
    id                   string<br />
    config               *configs.Config<br />
    initPath             string<br />
    initArgs             []string<br />
    initProcess          parentProcess<br />
    …..<br />
}<br />
Factory 接口<br />
在runC中，所有的容器都是由容器工厂（Factory）创建的, Factory 也是一个抽象接口，定义如下，它只包含了4个方法</p><br />
<br />
<p>type Factory interface {<br />
    Create(id string, config *configs.Config) (Container, error)<br />
    Load(id string) (Container, error)<br />
    StartInitialization() error<br />
    Type() string<br />
}<br />
linux平台上的对 Factory 接口也有一个标准实现—LinuxFactory,其中的 InitPath 也非常关键，稍后我们会看到</p><br />
<br />
<p>// LinuxFactory implements the default factory interface for linux based systems.<br />
type LinuxFactory struct {<br />
    // InitPath is the path for calling the init responsibilities for spawning<br />
    // a container.<br />
    InitPath string<br />
    ……</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// InitArgs are arguments for calling the init responsibilities for spawning<br />
// a container.<br />
InitArgs []string } 所以，对于linux平台，Factory 创建 Container 实际上就是 LinuxFactory 创建 linuxContainer<br />
</code></pre></div></div><br />
<br />
<p>回到createContainer(),下面是其实现</p><br />
<br />
<p>func createContainer(context <em>cli.Context, id string, spec *specs.Spec) (libcontainer.Container, error) {<br />
    /</em> 1. 将配置存放到config */<br />
    rootlessCg, err := shouldUseRootlessCgroupManager(context)<br />
    config, err := specconv.CreateLibcontainerConfig(&amp;specconv.CreateOpts{<br />
        CgroupName:       id,<br />
        UseSystemdCgroup: context.GlobalBool(“systemd-cgroup”),<br />
        NoPivotRoot:      context.Bool(“no-pivot”),<br />
        NoNewKeyring:     context.Bool(“no-new-keyring”),<br />
        Spec:             spec,                            <br /><br />
        RootlessEUID:     os.Geteuid() != 0,<br />
        RootlessCgroups:  rootlessCg,<br />
    })</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* 2. 加载Factory */<br />
factory, err := loadFactory(context)<br />
if err != nil {<br />
    return nil, err<br />
}<br />
<br />
/* 3. 调用Factory的Create()方法 */<br />
return factory.Create(id, config) } 可以看到，上面的代码大体上分为<br />
</code></pre></div></div><br />
<br />
<p>将配置存放到 config, 数据类型是 Config.config<br />
加载 Factory，实际返回 LinuxFactory<br />
调用 Factory 的Create()方法<br />
sleep 5 到了变量 config<br />
第1步存放配置没什么好说的，无非是将已有的 spec 和其他一些用户命令行选项配置换成一个数据结构存下来。而第2部加载Factory，在linux上，就是返回一个 LinuxFactory 结构。而这是通过在其内部调用 libcontainer.New()方法实现的</p><br />
<br />
<p>/* utils/utils_linux.go */<br />
func loadFactory(context *cli.Context) (libcontainer.Factory, error) {<br />
    …..<br />
    return libcontainer.New(abs, cgroupManager, intelRdtManager,<br />
        libcontainer.CriuPath(context.GlobalString(“criu”)),<br />
        libcontainer.NewuidmapPath(newuidmap),<br />
        libcontainer.NewgidmapPath(newgidmap))<br />
}<br />
libcontainer.New() 方法在linux平台的实现如下，可以看到，它的确会返回一个LinuxFactory，并且InitPath设置为”/proc/self/exe”，InitArgs设置为”init”</p><br />
<br />
<p>/* libcontainer/factory_linux.go <em>/<br />
func New(root string, options …func(</em>LinuxFactory) error) (Factory, error) {<br />
    …..<br />
    l := &amp;LinuxFactory{<br />
        …..<br />
        InitPath:  “/proc/self/exe”,<br />
        InitArgs:  []string{os.Args[0], “init”},<br />
    }<br />
    ……<br />
    return l, nil<br />
}<br />
得到了具体的 Factory 实现，下一步就是调用其Create()方法,对 linux 平台而言，就是下面这个方法，可以看到，它会将 LinuxFactory 上记录的 InitPath 和 InitArgs 赋给 linuxContainer 并作为结果返回</p><br />
<br />
<p>func (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) {<br />
    ….<br />
    c := &amp;linuxContainer{<br />
        id:            id,  <br /><br />
        config:        config,<br />
        initPath:      l.InitPath,<br />
        initArgs:      l.InitArgs,<br />
    }<br />
     …..<br />
    return c, nil<br />
}<br />
回到 startContainer() 方法，再得到 linuxContainer 后，将创建一个 runner 结构,并调用其run()方法</p><br />
<br />
<p>/* utils_linux.go */<br />
func startContainer(context *cli.Context, spec *specs.Spec, action CtAct, criuOpts *libcontainer.CriuOpts) (int, error) {<br />
    id := context.Args().First()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>container, err := createContainer(context, id, spec)<br />
<br />
r := &amp;runner{<br />
    container:       container,<br />
    action:          action,<br />
    init:            true,     <br />
    ......<br />
}<br />
return r.run(spec.Process) } runner 的 run() 的入参是 spec.Process 结构，我们并不需要关注它的定义，因为它的内容都来源于 config.json 文件，spec.Process 不过是其中 Process 部分的 Go 语言数据的表示。run() 方法的实现如下：<br />
</code></pre></div></div><br />
<br />
<p>func (r <em>runner) run(config *specs.Process) (int, error) { <br />
    ……<br />
    process, err := newProcess(</em>config, r.init)                                  /*  第1部分 <em>/<br />
    ……<br />
    switch r.action {<br />
    case CT_ACT_CREATE:<br />
        err = r.container.Start(process)   /</em> runc start <em>/                      /</em>  第2部分 <em>/<br />
    case CT_ACT_RESTORE:<br />
        err = r.container.Restore(process, r.criuOpts) /</em> runc restore <em>/<br />
    case CT_ACT_RUN:<br />
        err = r.container.Run(process)     /</em> runc run */<br />
    default:<br />
        panic(“Unknown action”)<br />
    }<br />
    ……<br />
    return status, err<br />
}<br />
上面的 run() 可分为两部分</p><br />
<br />
<p>调用 newProcess() 方法, 用 spec.Process 创建 libcontainer.Process,注意第二个参数是 true ，表示新创建的 process 会作为新创建容器的第一个 process。<br />
根据 r.action 的值决定如何操作得到的 libcontainer.Process<br />
sleep 5 到了变量 process<br />
libcontainer.Process 结构定义在 /libcontainer/process.go, 其中大部分内容都来自 spec.Process</p><br />
<br />
<p>/* parent process <em>/<br />
// Process specifies the configuration and IO for a process inside<br />
// a container.<br />
type Process struct {<br />
    Args []string<br />
    Env []string<br />
    User string<br />
    AdditionalGroups []string<br />
    Cwd string<br />
    Stdin io.Reader<br />
    Stdout io.Writer<br />
    Stderr io.Writer<br />
    ExtraFiles []</em>os.File</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ConsoleWidth  uint16<br />
ConsoleHeight uint16<br />
Capabilities *configs.Capabilities<br />
AppArmorProfile string<br />
Label string<br />
NoNewPrivileges *bool<br />
Rlimits []configs.Rlimit<br />
ConsoleSocket *os.File<br />
Init bool<br />
<br />
ops processOperations } 接下来就是要使用 Start() 方法了<br />
</code></pre></div></div><br />
<br />
<p>func (c *linuxContainer) Start(process *Process) error {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if process.Init {<br />
    if err := c.createExecFifo(); err != nil {  /* 1.创建fifo   */<br />
        return err<br />
    }<br />
}<br />
if err := c.start(process); err != nil {        /* 2. 调用start() */<br />
    if process.Init {<br />
        c.deleteExecFifo()<br />
    }<br />
    return err<br />
}<br />
return nil } Start() 方法主要完成两件事<br />
</code></pre></div></div><br />
<br />
<p>创建 fifo: 创建一个名为exec.fifo的管道，这个管道后面会用到<br />
调用 start() 方法，如下<br />
func (c <em>linuxContainer) start(process *Process) error {<br />
    parent, err := c.newParentProcess(process) /</em>  1. 创建parentProcess */</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>err := parent.start();                     /*  2. 启动这个parentProcess */<br />
......<br />
</code></pre></div></div><br />
<br />
<p>start() 也完成两件事:</p><br />
<br />
<p>创建一个 ParentProcess<br />
调用这个 ParentProcess 的 start() 方法<br />
sleep 5 到了变量 parent<br />
那么什么是 parentProcess ? 正如其名，parentProcess 类似于 linux 中可以派生出子进程的父进程，在runC中，parentProcess 是一个抽象接口，如下：</p><br />
<br />
<p>type parentProcess interface {<br />
    // pid returns the pid for the running process.<br />
    pid() int</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// start starts the process execution.<br />
start() error<br />
<br />
// send a SIGKILL to the process and wait for the exit.<br />
terminate() error<br />
<br />
// wait waits on the process returning the process state.<br />
wait() (*os.ProcessState, error)<br />
<br />
// startTime returns the process start time.<br />
startTime() (uint64, error)<br />
<br />
signal(os.Signal) error<br />
<br />
externalDescriptors() []string<br />
<br />
setExternalDescriptors(fds []string) } 它有两个实现，分别为 initProcess 和 setnsProcess ，前者用于创建容器内的第一个进程，后者用于在已有容器内创建新的进程。在我们的创建容器例子中，p.Init = true ，所以会创建 initProcess<br />
</code></pre></div></div><br />
<br />
<p>func (c <em>linuxContainer) newParentProcess(p *Process) (parentProcess, error) {<br />
    parentPipe, childPipe, err := utils.NewSockPair(“init”)  /</em> 1.创建 Socket Pair */</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd, err := c.commandTemplate(p, childPipe)              /* 2. 创建 *exec.Cmd */<br />
<br />
if !p.Init {<br />
    return c.newSetnsProcess(p, cmd, parentPipe, childPipe) <br />
}<br />
<br />
if err := c.includeExecFifo(cmd); err != nil {           /* 3.打开之前创建的fifo */<br />
    return nil, newSystemErrorWithCause(err, "including execfifo in cmd.Exec setup")<br />
}<br />
return c.newInitProcess(p, cmd, parentPipe, childPipe)   /* 4.创建 initProcess */ } newParentProcess() 方法动作有 4 步，前 3 步都是在为第 4 步做准备，即生成 initProcess<br />
</code></pre></div></div><br />
<br />
<p>创建一对 SocketPair 没什么好说的，生成的结果会放到 initProcess<br />
创建 <em>exec.Cmd,代码如下，这里设置了 cmd 要执行的可执行程序和参数来自 c.initPath，即源自 LinuxFactory 的 “/proc/self/exe”,和 “init” ，这表示新执行的程序就是runC本身，只是参数变成了 init，之后又将外面创建的 SocketPair 的一端 childPipe放到了cmd.ExtraFiles ，同时将_LIBCONTAINER_INITPIPE=%d加入cmd.Env,其中 %d为文件描述符的数字<br />
func (c *linuxContainer) commandTemplate(p *Process, childPipe *os.File) (</em>exec.Cmd, error) {<br />
    cmd := exec.Command(c.initPath, c.initArgs[1:]…)<br />
    cmd.Args[0] = c.initArgs[0]</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)<br />
cmd.ExtraFiles = append(cmd.ExtraFiles, childPipe)<br />
cmd.Env = append(cmd.Env,<br />
    fmt.Sprintf("_LIBCONTAINER_INITPIPE=%d", stdioFdCount+len(cmd.ExtraFiles)-1),<br />
)<br />
......<br />
return cmd, nil } includeExecFifo() 方法打开之前创建的 fifo，也将其 fd 放到 cmd.ExtraFiles 中，同时将_LIBCONTAINER_FIFOFD=%d记录到 cmd.Env。 最后就是创建 InitProcess 了，这里首先将_LIBCONTAINER_INITTYPE="standard"加入cmd.Env，然后从 configs 读取需要新的容器创建的 Namespace 的类型，并将其打包到变量 data 中备用，最后再创建 InitProcess 自己，可以看到，这里将之前的一些资源和变量都联系了起来 func (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, parentPipe, childPipe *os.File) (*initProcess, error) {<br />
cmd.Env = append(cmd.Env, "_LIBCONTAINER_INITTYPE="+string(initStandard))<br />
nsMaps := make(map[configs.NamespaceType]string)<br />
for _, ns := range c.config.Namespaces {<br />
    if ns.Path != "" {<br />
        nsMaps[ns.Type] = ns.Path<br />
    }<br />
}<br />
_, sharePidns := nsMaps[configs.NEWPID]<br />
data, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)<br />
if err != nil {<br />
    return nil, err<br />
}<br />
return &amp;initProcess{<br />
    cmd:             cmd,<br />
    childPipe:       childPipe,<br />
    parentPipe:      parentPipe,<br />
    manager:         c.cgroupManager,<br />
    intelRdtManager: c.intelRdtManager,<br />
    config:          c.newInitConfig(p),<br />
    container:       c,<br />
    process:         p,          /*  sleep 5 在这里 */<br />
    bootstrapData:   data,<br />
    sharePidns:      sharePidns,<br />
}, nil } sleep 5 在 initProcess.process 中 回到 linuxContainer 的 start() 方法，创建好了 parent ，下一步就是调用它的 start() 方法了<br />
</code></pre></div></div><br />
<br />
<p>func (c <em>linuxContainer) start(process *Process) error {<br />
    parent, err := c.newParentProcess(process) /</em>  1. 创建parentProcess (已完成) */</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>err := parent.start();                     /*  2. 启动这个parentProcess */<br />
......<br />
</code></pre></div></div><br />
<br />
<p>前文讲到，newParentProcess() 根据源自 config.json 的配置，最终生成变量 initProcess ，这个 initProcess 包含的信息主要有</p><br />
<br />
<p>cmd 记录了要执行的可执行文件名，即 “/proc/self/exe init”，注意不要和容器要执行的 sleep 5 混淆了<br />
cmd.Env 记录了名为 _LIBCONTAINER_FIFOFD=%d 记录的命名管道exec.fifo 的描述符，名为_LIBCONTAINER_INITPIPE=%d记录了创建的 SocketPair 的 childPipe 一端的描述符，名为_LIBCONTAINER_INITTYPE=”standard”记录要创建的容器中的进程是初始进程<br />
initProcess 的 bootstrapData 记录了新的容器要创建哪些类型的 Namespace。<br />
/* libcontainer/container_linux.go <em>/<br />
func (c *linuxContainer) start(process *Process) error {<br />
    parent, err := c.newParentProcess(process) /</em>  1. 创建parentProcess (已完成) */</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>err := parent.start();                     /*  2. 启动这个parentProcess */<br />
...... 准备工作完成之后，就要调用 start() 方法启动。<br />
</code></pre></div></div><br />
<br />
<p>注意: 此时 sleep 5 线索存储在变量 parent 中<br />
runC create的实现原理 (下)<br />
start() 函数实在太长了，因此逐段来看</p><br />
<br />
<p>/* libcontainer/process_linux.go */<br />
func (p *initProcess) start() error {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p.cmd.Start()                 <br />
p.process.ops = p    <br />
io.Copy(p.parentPipe, p.bootstrapData)<br />
<br />
..... } p.cmd.Start() 启动 cmd 中设置的要执行的可执行文件 /proc/self/exe，参数是 init，这个函数会启动一个新的进程去执行该命令，并且不会阻塞。 io.Copy 将 p.bootstrapData 中的数据通过 p.parentPipe 发送给子进程 /proc/self/exe 正是runc程序自己，所以这里相当于是执行runc init，也就是说，我们输入的是runc create命令，隐含着又去创建了一个新的子进程去执行runc init。为什么要额外重新创建一个进程呢？原因是我们创建的容器很可能需要运行在一些独立的 namespace 中，比如 user namespace,这是通过 setns() 系统调用完成的，而在setns man page中写了下面一段话<br />
</code></pre></div></div><br />
<br />
<p>A multi‐threaded process may not change user namespace with setns(). It is not permitted to use setns() to reenter the caller’s current user names‐pace<br />
即多线程的进程是不能通过 setns()改变user namespace的。而不幸的是 Go runtime 是多线程的。那怎么办呢 ？所以setns()必须要在Go runtime 启动之前就设置好,这就要用到cgo了，在Go runtime 启动前首先执行嵌入在前面的 C 代码。</p><br />
<br />
<p>具体的做法在nsenter README描述 在runc init命令的响应在文件 init.go 开头，导入 nsenter 包</p><br />
<br />
<p>/* init.go */<br />
import (<br />
    “os”<br />
    “runtime”</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"github.com/opencontainers/runc/libcontainer"<br />
_ "github.com/opencontainers/runc/libcontainer/nsenter"<br />
"github.com/urfave/cli" ) 而nsenter包中开头通过 cgo 嵌入了一段 C 代码, 调用 nsexec()<br />
</code></pre></div></div><br />
<br />
<p>package nsenter<br />
/*<br />
/* nsenter.go */<br />
#cgo CFLAGS: -Wall<br />
extern void nsexec();<br />
void <strong>attribute</strong>((constructor)) init(void) {<br />
    nsexec();<br />
}<br />
*/<br />
import “C”<br />
接下来，轮到 nsexec() 完成为容器创建新的 namespace 的工作了, nsexec() 同样很长，逐段来看</p><br />
<br />
<p>/* libcontainer/nsenter/nsexec.c */<br />
void nsexec(void)<br />
{<br />
    int pipenum;<br />
    jmp_buf env;<br />
    int sync_child_pipe[2], sync_grandchild_pipe[2];<br />
    struct nlconfig_t config = { 0 };</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*<br />
 * If we don't have an init pipe, just return to the go routine.<br />
 * We'll only get an init pipe for start or exec.<br />
 */<br />
pipenum = initpipe();<br />
if (pipenum == -1)<br />
    return;<br />
<br />
/* Parse all of the netlink configuration. */<br />
nl_parse(pipenum, &amp;config);<br />
   <br />
......     上面这段 C 代码中，initpipe() 从环境中读取父进程之前设置的pipe(_LIBCONTAINER_INITPIPE记录的的文件描述符)，然后调用 nl_parse 从这个管道中读取配置到变量 config ，那么谁会往这个管道写配置呢 ? 当然就是runc create父进程了。父进程通过这个pipe，将新建容器的配置发给子进程，这个过程如下图所示:<br />
</code></pre></div></div><br />
<br />
<p>ipc</p><br />
<br />
<p>发送的具体数据在 linuxContainer 的 bootstrapData() 函数中封装成netlink msg格式的消息。忽略大部分配置，本文重点关注namespace的配置，即要创建哪些类型的namespace，这些都是源自最初的config.json文件。</p><br />
<br />
<p>至此，子进程就从父进程处得到了namespace的配置，继续往下， nsexec() 又创建了两个socketpair,从注释中了解到，这是为了和它自己的子进程和孙进程进行通信。</p><br />
<br />
<p>void nsexec(void)<br />
{<br />
   …..<br />
    /* Pipe so we can tell the child when we’ve finished setting up. */<br />
    if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) &lt; 0)  //  sync_child_pipe is an out parameter<br />
        bail(“failed to setup sync pipe between parent and child”);</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*<br />
 * We need a new socketpair to sync with grandchild so we don't have<br />
 * race condition with child.<br />
 */<br />
if (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) &lt; 0)<br />
    bail("failed to setup sync pipe between parent and grandchild");<br />
</code></pre></div></div><br />
<br />
<p>}<br />
然后就该创建namespace了，看注释可知这里其实有考虑过三个方案</p><br />
<br />
<p>first clone then clone<br />
first unshare then clone<br />
first clone then unshare<br />
最终采用的是方案 3,其中缘由由于考虑因素太多，所以准备之后另写一篇文章分析</p><br />
<br />
<p>接下来就是一个大的 switch case 编写的状态机,大体结构如下，当前进程通过clone()系统调用创建子进程，子进程又通过clone()系统调用创建孙进程，而实际的创建/加入namespace是在子进程完成的</p><br />
<br />
<p>switch (setjmp(env)) {<br />
  case JUMP_PARENT:{<br />
           …..<br />
           clone_parent(&amp;env, JUMP_CHILD);<br />
           …..<br />
       }<br />
  case JUMP_CHILD:{<br />
           ……<br />
           if (config.namespaces)<br />
                join_namespaces(config.namespaces);<br />
           clone_parent(&amp;env, JUMP_INIT);<br />
           ……<br />
       }<br />
  case JUMP_INIT:{<br />
       }<br />
本文不准备展开分析这个状态机了，而将这个状态机的流程画在了下面的时序图中，需要注意的是以下几点</p><br />
<br />
<p>namespaces在runc init 2完成创建<br />
runc init 1和runc init 2最终都会执行exit(0),但runc init 3不会，它会继续执行runc init命令的后半部分。因此最终只会剩下runc create进程和runc init 3进程<br />
runc</p><br />
<br />
<p>再回到runc create进程</p><br />
<br />
<p>func (p *initProcess) start() error {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p.cmd.Start()<br />
p.process.ops = p<br />
io.Copy(p.parentPipe, p.bootstrapData);<br />
<br />
p.execSetns()<br />
...... 再向 runc init发送了 bootstrapData 数据后，便调用 execSetns() 等待runc init 1进程终止，从管道中得到runc init 3的进程 pid,将该进程保存在 p.process.ops<br />
</code></pre></div></div><br />
<br />
<p>/* libcontainer/process_linux.go */<br />
func (p *initProcess) execSetns() error {<br />
    status, err := p.cmd.Process.Wait()</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var pid *pid<br />
json.NewDecoder(p.parentPipe).Decode(&amp;pid)<br />
<br />
process, err := os.FindProcess(pid.Pid)<br />
<br />
p.cmd.Process = process<br />
p.process.ops = p<br />
return nil } 继续 start()<br />
</code></pre></div></div><br />
<br />
<p>func (p *initProcess) start() error {</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...... <br />
p.execSetns()<br />
<br />
fds, err := getPipeFds(p.pid())<br />
p.setExternalDescriptors(fds)<br />
p.createNetworkInterfaces()<br />
<br />
p.sendConfig()<br />
<br />
parseSync(p.parentPipe, func(sync *syncT) error {<br />
    switch sync.Type {<br />
    case procReady:<br />
        .....<br />
        writeSync(p.parentPipe, procRun);<br />
        sentRun = true<br />
    case procHooks:<br />
        .....<br />
        // Sync with child.<br />
        err := writeSync(p.parentPipe, procResume); <br />
        sentResume = true<br />
    }<br />
<br />
    return nil<br />
})<br />
...... 可以看到，runc create又开始通过pipe进行双向通信了，通信的对端自然就是runc init 3进程了，runc init 3进程在执行完嵌入的 C 代码后(实际是runc init 1执行的，但runc init 3也是由runc init 1间接clone()出来的)，因此将开始运行 Go runtime，开始响应init命令<br />
</code></pre></div></div><br />
<br />
<p>sleep 5 通过 p.sendConfig() 发送给了runc init进程<br />
init命令首先通过 libcontainer.New(“”) 创建了一个 LinuxFactory,这个方法在上篇文章中分析过，这里不再解释。然后调用 LinuxFactory 的 StartInitialization() 方法。</p><br />
<br />
<p>/* libcontainer/factory_linux.go */<br />
// StartInitialization loads a container by opening the pipe fd from the parent to read the configuration and state<br />
// This is a low level implementation detail of the reexec and should not be consumed externally<br />
func (l *LinuxFactory) StartInitialization() (err error) {<br />
    var (<br />
        pipefd, fifofd int<br />
        envInitPipe    = os.Getenv(“_LIBCONTAINER_INITPIPE”)<br /><br />
        envFifoFd      = os.Getenv(“_LIBCONTAINER_FIFOFD”)<br />
    )</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Get the INITPIPE.<br />
pipefd, err = strconv.Atoi(envInitPipe)<br />
<br />
var (<br />
    pipe = os.NewFile(uintptr(pipefd), "pipe")<br />
    it   = initType(os.Getenv("_LIBCONTAINER_INITTYPE")) // // "standard" or "setns"<br />
)<br />
<br />
// Only init processes have FIFOFD.<br />
fifofd = -1<br />
if it == initStandard {<br />
    if fifofd, err = strconv.Atoi(envFifoFd); err != nil {<br />
        return fmt.Errorf("unable to convert _LIBCONTAINER_FIFOFD=%s to int: %s", envFifoFd, err)<br />
    }<br />
}<br />
<br />
i, err := newContainerInit(it, pipe, consoleSocket, fifofd)<br />
<br />
// If Init succeeds, syscall.Exec will not return, hence none of the defers will be called.<br />
return i.Init() // } StartInitialization() 方法尝试从环境中读取一系列_LIBCONTAINER_XXX变量的值，还有印象吗？这些值全是在runc create命令中打开和设置的，也就是说，runc create通过环境变量，将这些参数传给了子进程runc init 3<br />
</code></pre></div></div><br />
<br />
<p>拿到这些环境变量后，runc init 3调用 newContainerInit 函数</p><br />
<br />
<p>/* libcontainer/init_linux.go */<br />
func newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd int) (initer, error) {<br />
    var config *initConfig</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* read config from pipe (from runc process) */<br />
son.NewDecoder(pipe).Decode(&amp;config); <br />
populateProcessEnvironment(config.Env);<br />
switch t {<br />
......<br />
case initStandard:<br />
    return &amp;linuxStandardInit{<br />
        pipe:          pipe,<br />
        consoleSocket: consoleSocket,<br />
        parentPid:     unix.Getppid(),<br />
        config:        config, // &lt;=== config<br />
        fifoFd:        fifoFd,<br />
    }, nil<br />
}<br />
return nil, fmt.Errorf("unknown init type %q", t) } newContainerInit() 函数首先尝试从 pipe 读取配置存放到变量 config 中，再存储到变量 linuxStandardInit 中返回<br />
</code></pre></div></div><br />
<br />
<p>runc create                    runc init 3<br />
       |                               |<br />
  p.sendConfig() — config –&gt;  NewContainerInit()<br />
sleep 5 线索在 initStandard.config 中<br />
回到 StartInitialization(),在得到 linuxStandardInit 后，便调用其 Init()方法了</p><br />
<br />
<p>/* init.go */<br />
func (l *LinuxFactory) StartInitialization() (err error) {<br />
    ……<br />
    i, err := newContainerInit(it, pipe, consoleSocket, fifofd)</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>return i.Init()   } 本文忽略掉 Init() 方法前面的一大堆其他配置，只看其最后<br />
</code></pre></div></div><br />
<br />
<p>func (l *linuxStandardInit) Init() error {<br />
   ……<br />
   name, err := exec.LookPath(l.config.Args[0])</p><br />
<br />
<p>syscall.Exec(name, l.config.Args[0:], os.Environ())<br />
}<br />
可以看到，这里终于开始执行 用户最初设置的 sleep 5 了</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category docker
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>