<!DOCTYPE html>
<html>

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Sci blog jekyll theme">
    <meta name="author" content="AIR RAYA Group">
    <link href='/MyBlog/img/favicon.ico' type='image/icon' rel='shortcut icon'/>

    <title>泽民博客 | Jekyll theme</title>

    <link rel="stylesheet" href="/MyBlog/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
    <link rel="stylesheet" href="/MyBlog/css/font-awesome.min.css">
    <link href="/MyBlog/css/simple-sidebar.css" rel="stylesheet">
	<link href="/MyBlog/css/classic-10_7.css" rel="stylesheet" type="text/css">
    <!-- Custom CSS -->
    <link href="/MyBlog/css/style.css" rel="stylesheet">
    <link href="/MyBlog/css/pygments.css" rel="stylesheet">
    <!-- Fonts -->
 <link href="/MyBlog/css/front.css" rel="stylesheet" type="text/css">
 <link href="/MyBlog/css/Josefin_Slab.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Architects_Daughter.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Schoolbell.css" rel="stylesheet" type="text/css">
<link href="/MyBlog/css/Codystar.css" rel="stylesheet" type="text/css">

 <script type="text/javascript" src="/MyBlog/js/jquery-1.12.0.min.js"></script>	

<link href="/MyBlog/css/calendar/common.css" type="text/css"  rel="stylesheet">
<script type="text/javascript" src="/MyBlog/js/calendar/calendar.js"></script>
	<!-- share this -->
	<script type="text/javascript">var switchTo5x=true;</script>
	<script type="text/javascript" src="/MyBlog/js/buttons.js"></script>
	<script type="text/javascript">stLight.options({publisher: "b28464c3-d287-4257-ad18-058346dd35f7", doNotHash: false, doNotCopy: false, hashAddressBar: false});</script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="/MyBlog/js/html5shiv.js"></script>
        <script src="/MyBlog/js/respond.min.js"></script>
    <![endif]-->
   
   <!--百度统计-->
    <script>
    var _hmt = _hmt || [];
    (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?e965cab8c73512b8b23939e7051d93bd";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
    })();
    </script>
    <script async src="/MyBlog/katex/katex.js"></script>
    <link rel="stylesheet" href="/MyBlog/katex/katex.css">

    <!--轮播图片-->
    <!--script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="https://xiazemin.github.io/MyBlog/js/jquery.stripesrotator.js"></script>
    <script type="text/javascript">
                    $(document).ready(function() {
                    alert($('#rotator_xzm'));
                     alert($('#rotator_xzm').fn);
                    $('#rotator_xzm').stripesRotator({ images: [ "https://xiazemin.github.io/MyBlog/img/BPlusTree.png", "https://xiazemin.github.io/MyBlog/img/linuxMMap.jpeg"] });
                    });
    </script-->

    <!--水印-->
    <script type="text/javascript" src="/MyBlog/js/waterMark.js"></script>
    <script type="text/javascript">
    $(document).ready(function(){
    watermark({watermark_txt0:'泽民博客',watermark_txt1:'zemin',watermark_txt2:(new Date()).Format("yyyy-MM-dd hh:mm:ss.S")});
    })
    </script>
     <!--水印-->
     <!--adscene-->
    <script data-ad-client="ca-pub-6672721494777557" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

</head>

 <body>
<div id="wrapper">
 <!-- Navigation -->
    <!-- Sidebar -->
        <div id="sidebar-wrapper">
            <ul class="sidebar-nav">
                <li class="sidebar-brand">
                    <a href="/MyBlog">
                        Home
                    </a>
                </li>
                <li>
                    <a href="#">About</a>
                </li>
                <li>
                    <a href="#">Services</a>
                </li>
                <li>
                    <a href="#">Portfolio</a>
                </li>
                <li>
                    <a href="#">Events</a>
                </li>
                <li>
                    <a href="#">Blog</a>
                </li>
                <li>
                    <a href="#">FAQ</a>
                </li>
                <li>
                    <a href="#">Contact</a>
                </li>
            </ul>
        </div>


    <header class="intro-header">
        <div class="container">
            <div class="row">
                <div class="col-lg-12">
                    <div class="heading text-center">
                        <a href="https://xiazemin.github.io/MyBlog/" style="color: #fff; font-size: 4em; font-family: 'Schoolbell', cursive;">泽民博客</a>
                        <a href="#menu-toggle" class="btn btn-default sciblog" id="menu-toggle" style="font-weight: bold;">&#9776; Menu</a>
                    </div>
                </div>
            </div>
        </div>
    </header>

     <script async src="/MyBlog/js/busuanzi.pure.mini.js"></script>

    <script type="text/javascript" src="/MyBlog/js/jquery.js"></script>
    <script type="text/javascript" src="/MyBlog/js/jquery.stripesrotator.js"></script>


 <div class="container">
	<div class="row">
        <div class="box">
                <div class="col-lg-12">
                    <div class="intro-text text-center">
					<h1 class="post-title" itemprop="name headline">Namespaces</h1>
					<p class="post-meta"> <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">by 夏泽民</span></span> <time datetime="2019-11-13T00:00:00+08:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Nov 13, 2019</time></p>
					</div>
					 <p>命名空间的本质就是指：一种在空间上隔离的概念，当下盛行的许多容器虚拟化技术（典型代表如LXC、Docker）就是基于linux命名空间的概念而来的。<br />
主要是三个系统调用</p><br />
<br />
<p>clone() – 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。<br />
unshare() – 使某进程脱离某个namespace<br />
setns() – 把某进程加入到某个namespace<br />
<!-- more --><br />
首先，我们来看一下一个最简单的clone()系统调用的示例，(后面，我们的程序都会基于这个程序做修改)：</p><br />
<br />
<p>文件名:clone.c</p><br />
<br />
<p>复制代码<br />
#define _GNU_SOURCE <br />
#include &lt;sys/types.h&gt;<br />
#include &lt;sys/wait.h&gt;<br />
#include <stdio.h><br />
#include <sched.h><br />
#include <signal.h><br />
#include <unistd.h></unistd.h></signal.h></sched.h></stdio.h></p><br />
<br />
<p>/* 定义一个给 clone 用的栈，栈大小1M */<br />
#define STACK_SIZE (1024 * 1024) <br />
static char container_stack[STACK_SIZE];</p><br />
<br />
<p>char* const container_args[] = {<br />
    “/bin/bash”,<br />
    NULL<br />
};</p><br />
<br />
<p>int container_main(void* arg)<br />
{<br />
    printf(“Container - inside the container!\n”);<br />
    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */<br />
    execv(container_args[0], container_args);<br />
    printf(“Something’s wrong!\n”);<br />
    return 1;<br />
}</p><br />
<br />
<p>int main()<br />
{<br />
    printf(“Parent - start a container!\n”);<br />
    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） <em>/<br />
    int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, NULL);<br />
    /</em> 等待子进程结束 */<br />
    waitpid(container_pid, NULL, 0);<br />
    printf(“Parent - container stopped!\n”);<br />
    return 0;<br />
}<br />
复制代码<br />
 测试开辟一个新的名称空间:</p><br />
<br />
<p>复制代码<br />
[root@www ~]# gcc -o clone clone.c #编译clone.c<br />
[root@www ~]# ./clone #执行编译的结果<br />
Parent - start a container!<br />
Container - inside the container!<br />
[root@www ~]#         #进入了一隔离的空间<br />
[root@www ~]# exit    #退出该空间<br />
exit<br />
Parent - container stopped!<br />
[root@www ~]#         #又回到最初的空间<br />
复制代码<br />
从上面的程序，我们可以看到，这和pthread基本上是一样的玩法。但是，对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能。</p><br />
<br />
<p>下面， 让我们来看几个例子看看，Linux的Namespace是什么样的。</p><br />
<br />
<p>因为下述测试涉及到用户权限问题，因此我们新建用户egon（本人的英文名，哈哈），并且赋予该用户sudo权限</p><br />
<br />
<p>执行visudo然后新增如下内容： <br />
egon    ALL=(ALL)     NOPASSWD:ALL<br />
2.1 UTS命名空间（系统调用CLONE_NEWUTS）<br />
主要目的是独立出主机名和网络信息服务（NIS）。</p><br />
<br />
<p>文件名:uts.c</p><br />
<br />
<p>复制代码<br />
#define _GNU_SOURCE <br />
#include &lt;sys/types.h&gt;<br />
#include &lt;sys/wait.h&gt;<br />
#include <stdio.h><br />
#include <sched.h><br />
#include <signal.h><br />
#include <unistd.h></unistd.h></signal.h></sched.h></stdio.h></p><br />
<br />
<p>/* 定义一个给 clone 用的栈，栈大小1M */<br />
#define STACK_SIZE (1024 * 1024) <br />
static char container_stack[STACK_SIZE];</p><br />
<br />
<p>char* const container_args[] = {<br />
    “/bin/bash”,<br />
    NULL<br />
};</p><br />
<br />
<p>/* 与uts有关的代码:此处只演示主机名的隔离 <em>/<br />
int container_main(void</em> arg) <br />
{ <br />
    printf(“Container - inside the container!\n”); <br />
    sethostname(“container”,10); /* 设置hostname */ <br />
    execv(container_args[0], container_args); <br />
    printf(“Something’s wrong!\n”); <br />
    return 1; <br />
}</p><br />
<br />
<p>int main() <br />
{ <br />
    printf(“Parent - start a container!\n”); <br />
    int container_pid = clone(container_main, container_stack+STACK_SIZE,<br /><br />
            CLONE_NEWUTS | SIGCHLD, NULL); /*启用CLONE_NEWUTS Namespace隔离 */ <br />
    waitpid(container_pid, NULL, 0); <br />
    printf(“Parent - container stopped!\n”); <br />
    return 0; <br />
} <br />
复制代码<br />
 测试开辟一个新的UTS名称空间/容器container，验证主机名的隔离性:</p><br />
<br />
<p>复制代码<br />
[egon@www ~]$ gcc -o uts uts.c #编译utc.c得到可执行文件uts<br />
[egon@www ~]$ sudo ./uts #需要root权限才能开辟新的container<br />
Parent - start a container!<br />
Container - inside the container!<br />
[root@container egon]#      #进入一个隔离的空间，即一个container<br />
[root@container egon]# hostname #查看该空间下的主机名<br />
container<br />
[root@container egon]# exit #退出该container<br />
exit<br />
Parent - container stopped!<br />
[egon@www ~]$ hostname  #查看最初的空间下的主机名<br />
www.egon.org #发现确实与刚刚我们开辟的container是不同的主机名，验证了隔离性<br />
[egon@www ~]$ <br />
复制代码<br />
2.2 IPC命名空间（系统调用CLONE_NEWIPC）<br />
IPC全称 Inter-Process Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到。</p><br />
<br />
<p>文件名：ipc.c</p><br />
<br />
<p>要启动IPC隔离，我们只需要在调用clone时加上CLONE_NEWIPC参数就可以了（见下述代码标红的地方）</p><br />
<br />
<p>复制代码<br />
#define _GNU_SOURCE <br />
#include &lt;sys/types.h&gt;<br />
#include &lt;sys/wait.h&gt;<br />
#include <stdio.h><br />
#include <sched.h><br />
#include <signal.h><br />
#include <unistd.h></unistd.h></signal.h></sched.h></stdio.h></p><br />
<br />
<p>/* 定义一个给 clone 用的栈，栈大小1M */<br />
#define STACK_SIZE (1024 * 1024) <br />
static char container_stack[STACK_SIZE];</p><br />
<br />
<p>char* const container_args[] = {<br />
    “/bin/bash”,<br />
    NULL<br />
};</p><br />
<br />
<p>/* 与uts有关的代码:此处只演示主机名的隔离 <em>/<br />
int container_main(void</em> arg) <br />
{ <br />
    printf(“Container - inside the container!\n”); <br />
    sethostname(“container”,10); /* 设置hostname */ <br />
    execv(container_args[0], container_args); <br />
    printf(“Something’s wrong!\n”); <br />
    return 1; <br />
}</p><br />
<br />
<p>int main() <br />
{ <br />
    printf(“Parent - start a container!\n”); <br />
    int container_pid = clone(container_main, container_stack+STACK_SIZE,<br /><br />
            CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, NULL); /*新增CLONE_NEWIPC就可以了 */ <br />
    waitpid(container_pid, NULL, 0); <br />
    printf(“Parent - container stopped!\n”); <br />
    return 0; <br />
} <br />
复制代码<br />
预备阶段（在全局新建IPC队列）：</p><br />
<br />
<p>首先，我们先创建一个IPC的Queue(如下所示，全局的Queue ID是0)</p><br />
<br />
<p>ipcmk创建队列</p><br />
<br />
<p>ipcrm删除队列</p><br />
<br />
<p>ipcs查看队列</p><br />
<br />
<p>复制代码<br />
[egon@www ~]$ ipcs -q #查看队列</p><br />
<br />
<p>—— Message Queues ——–<br />
key        msqid      owner      perms      used-bytes   messages  <br /><br />
[egon@www ~]$ ipcmk -Q #在全局创建一个ipc的队列，队列id为0<br />
Message queue id: 0<br />
[egon@www ~]$ ipcs -q #查看刚刚新建的全局的队列的信息</p><br />
<br />
<p>—— Message Queues ——–<br />
key        msqid      owner      perms      used-bytes   messages  <br /><br />
0x0c076dce 0          egon       644        0            0    <br /><br />
复制代码<br />
我们暂且不运行编译的CLONE_NEWIPC的程序ipc，让我们先运行之前编译的uts，发现在子进程中还是能看到这个全局的IPC Queue。</p><br />
<br />
<p>复制代码<br />
[egon@www ~]$ ipcs -q #查看全局的队列</p><br />
<br />
<p>—— Message Queues ——–<br />
key        msqid      owner      perms      used-bytes   messages  <br /><br />
0x0c076dce 0          egon       644        0            0</p><br />
<br />
<p>[egon@www ~]$ sudo ./uts #进入新的uts容器<br />
Parent - start a container!<br />
Container - inside the container!<br />
[root@container egon]# ipcs -q #在uts容器下发现仍然能看到全局的IPC队列，证明此时没有实现IPC隔离</p><br />
<br />
<p>—— Message Queues ——–<br />
key        msqid      owner      perms      used-bytes   messages  <br /><br />
0x0c076dce 0          egon       644        0            0</p><br />
<br />
<p>[root@container egon]# exit #退出uts容器<br />
exit<br />
Parent - container stopped!<br />
[egon@www ~]$ <br />
复制代码<br />
测试开辟一个新的IPC名称空间/容器container，验证IPC的隔离性:</p><br />
<br />
<p>复制代码<br />
[egon@www ~]$ gcc -o ipc ipc.c #编译<br />
[egon@www ~]$ ipcs -q #在全局查看ipc队列，肯定可以看到</p><br />
<br />
<p>—— Message Queues ——–<br />
key        msqid      owner      perms      used-bytes   messages  <br /><br />
0x0c076dce 0          egon       644        0            0</p><br />
<br />
<p>[egon@www ~]$ sudo ./ipc #进入ipc容器<br />
Parent - start a container!<br />
Container - inside the container!<br />
[root@container egon]# ipcs -q #在容器内查看ipc队列，发现查看不到全局的ipc队列，自己这里的ipc队列为空，验证了ipc的隔离性<br />
                               #同理如果在该容器内用ipcmk -Q创建的队列，在全局也无法看到，读者可以自行测试<br />
—— Message Queues ——–<br />
key        msqid      owner      perms      used-bytes   messages</p><br />
<br />
<p>[root@container egon]# exit<br />
exit<br />
Parent - container stopped!<br />
[egon@www ~]$ <br />
复制代码<br />
2.3 PID命名空间（系统调用CLONE_NEWPID）<br />
空间内的PID 是独立分配的，意思就是命名空间内的虚拟 PID 可能会与命名空间外的 PID 相冲突，于是命名空间内的 PID 映射到命名空间外时会使用另外一个 PID。比如说，命名空间内第一个 PID 为1，而在命名空间外就是该 PID 已被 init 进程所使用。</p><br />
<br />
<p>文件名：pid.c</p><br />
<br />
<p>基于ipc.c修改而来，见标红部分，其中只需新增CLONE_NEWPID就完全可实现PID的隔离,而此处我们即加了CLONE_NEWUTS又加了CLONE_NEWIPC,随后才添加了CLONE_NEWPID,代表的意思是：在UTS和IPC隔离的基础之上再进行PID的隔离，此时的容器已经越来越接近于在linux操作系统上新建一个隔离的操作系统了。</p><br />
<br />
<p>复制代码<br />
#define _GNU_SOURCE <br />
#include &lt;sys/types.h&gt;<br />
#include &lt;sys/wait.h&gt;<br />
#include <stdio.h><br />
#include <sched.h><br />
#include <signal.h><br />
#include <unistd.h></unistd.h></signal.h></sched.h></stdio.h></p><br />
<br />
<p>/* 定义一个给 clone 用的栈，栈大小1M */<br />
#define STACK_SIZE (1024 * 1024) <br />
static char container_stack[STACK_SIZE];</p><br />
<br />
<p>char* const container_args[] = {<br />
    “/bin/bash”,<br />
    NULL<br />
};</p><br />
<br />
<p>int container_main(void* arg) <br />
{ <br />
    printf(“Container [%5d] - inside the container!\n”,getpid()); /* 此处的getpid()是为了获取容器的初始进程(init)的pid <em>/<br />
    sethostname(“container”,10); /</em> 设置hostname */ <br />
    execv(container_args[0], container_args); <br />
    printf(“Something’s wrong!\n”); <br />
    return 1; <br />
}</p><br />
<br />
<p>int main() <br />
{ <br />
    printf(“Parent [%5d] - start a container!\n”,getpid()); /* 此处的getpid()则是为了获取父进程的pid <em>/ <br />
    int container_pid = clone(container_main, container_stack+STACK_SIZE,<br /><br />
            CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | SIGCHLD, NULL); /</em>新增CLONE_NEWPID即可,此处代表在UTS和IPC隔离的基础之上再进行PID的隔离，其实我们完全可以只加CLONE_NEWPID自己:这样的话就只代表隔离PID了 */ <br />
    waitpid(container_pid, NULL, 0); <br />
    printf(“Parent - container stopped!\n”); <br />
    return 0; <br />
}<br />
复制代码<br />
 测试开辟一个新的PID名称空间/容器container，验证PID的隔离性:</p><br />
<br />
<p>复制代码<br />
[egon@www ~]$ gcc -o pid pid.c #编译<br />
[egon@www ~]$ sudo ./pid #进入一个新的容器<br />
Parent [ 4520] - start a container!<br />
Container [    1] - inside the container!<br />
[root@container egon]# echo $$ #查看该容器的初始程序（init）ID为1，而全局的init程序的ID也为1，证明了二者的隔离性<br />
1<br />
[root@container egon]# hostname #因为我们在pid.c文件中加入了CLONE_NEWUTS,所以此时的主机名也是隔离的，看到的是自己的主机名<br />
container<br />
[root@container egon]# ipcs -q #因为我们在pid.c文件中也加入了CLONE_NEWIPC，所以此时的IPC也是隔离的，看不到全局新建的那个IPC队列</p><br />
<br />
<p>—— Message Queues ——–<br />
key        msqid      owner      perms      used-bytes   messages <br /><br />
复制代码<br />
 ps：centos7之后使用systemd代替init，此处我们说的初始程序指的就是这二者，是一个意思</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>说明：在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权(比如：屏蔽信号等)，另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程(父进程没有wait它)，那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。<br />
</code></pre></div></div><br />
<br />
<p>但是，我们会发现，在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程。说明并没有完全隔离。这是因为，像ps, top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。</p><br />
<br />
<p>所以，我们还需要对文件系统进行隔离，这就需要用到mount命名空间了</p><br />
<br />
<p>2.4 Mount命名空间（系统调用CLONE_NEWNS）<br />
进程运行时可以将挂载点与系统分离，使用这个功能时，我们可以达到 chroot 的功能，而在安全性方面比 chroot 更高。</p><br />
<br />
<p>文件名：fs.c</p><br />
<br />
<p>复制代码<br />
#define _GNU_SOURCE <br />
#include &lt;sys/types.h&gt;<br />
#include &lt;sys/wait.h&gt;<br />
#include <stdio.h><br />
#include <sched.h><br />
#include <signal.h><br />
#include <unistd.h></unistd.h></signal.h></sched.h></stdio.h></p><br />
<br />
<p>/* 定义一个给 clone 用的栈，栈大小1M */<br />
#define STACK_SIZE (1024 * 1024) <br />
static char container_stack[STACK_SIZE];</p><br />
<br />
<p>char* const container_args[] = {<br />
    “/bin/bash”,<br />
    NULL<br />
};</p><br />
<br />
<p>int container_main(void* arg) <br />
{ <br />
    printf(“Container [%5d] - inside the container!\n”, getpid()); <br />
    sethostname(“container”,10); <br />
    /* 重新mount proc文件系统到 /proc下 */ <br />
    system(“mount -t proc proc /proc”); <br />
    execv(container_args[0], container_args); <br />
    printf(“Something’s wrong!\n”); <br />
    return 1; <br />
}</p><br />
<br />
<p>int main() <br />
{ <br />
    printf(“Parent [%5d] - start a container!\n”, getpid()); <br />
    /* 启用Mount Namespace - 增加CLONE_NEWNS参数 */ <br />
    int container_pid = clone(container_main, container_stack+STACK_SIZE,<br /><br />
            CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL); <br />
    waitpid(container_pid, NULL, 0); <br />
    printf(“Parent - container stopped!\n”); <br />
    return 0; <br />
} <br />
复制代码<br />
我们基于上次pid容器，在没有mount隔离情况下查看/proc、ps aux、top等信息</p><br />
<br />
<p>复制代码<br />
[egon@www ~]$ sudo ./pid<br />
Parent [ 6231] - start a container!<br />
Container [    1] - inside the container!<br />
[root@container egon]# ls /proc/<br />
1    116   132   148  165   18   197  213  230  248  265   282  36    5005  57    63   73   83   938        diskstats    locks         sysrq-trigger<br />
10   117   133   149  166   180  198  214  231  249  266   283  37    51    58    64   731  84   94         dma          mdstat        sysvipc<br />
100  118   134   15   167   181  199  215  232  25   267   284  38    514   59    640  74   841  95         driver       meminfo       timer_list<br />
101  119   135   150  168   182  2    216  233  250  268   285  39    515   5939  641  745  85   957        execdomains  misc          timer_stats<br />
102  12    136   151  169   183  20   217  234  251  2682  29   3944  517   60    642  75   86   96         fb           modules       tty<br />
103  120   137   152  17    184  200  218  235  252  2684  293  3946  52    6047  643  76   863  960        filesystems  mounts        uptime<br />
104  121   138   153  170   185  201  219  236  253  269   294  3982  520   6048  644  77   864  97         fs           mpt           version<br />
105  122   139   154  171   186  202  22   237  254  27    295  40    53    6052  645  78   87   98         interrupts   mtrr          vmallocinfo<br />
106  123   14    155  172   187  203  220  238  255  270   296  41    532   6053  646  780  871  99         iomem        net           vmstat<br />
……省略n行<br /><br />
[root@container egon]# ps aux<br />
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br />
root          1  0.0  0.6  44000  6548 ?        Ss   10:24   0:02 /usr/lib/systemd/systemd –switched-root –system –deserialize 21<br />
root          2  0.0  0.0      0     0 ?        S    10:24   0:00 [kthreadd]<br />
root          3  0.0  0.0      0     0 ?        S    10:24   0:00 [ksoftirqd/0]<br />
root          5  0.0  0.0      0     0 ?        S&lt;   10:24   0:00 [kworker/0:0H]<br />
root          7  0.0  0.0      0     0 ?        S    10:24   0:00 [migration/0]<br />
root          8  0.0  0.0      0     0 ?        S    10:24   0:00 [rcu_bh]<br />
root          9  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/0]<br />
root         10  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/1]<br />
root         11  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/2]<br />
root         12  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/3]<br />
root         13  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/4]<br />
root         14  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/5]<br />
root         15  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/6]<br />
root         16  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/7]<br />
root         17  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/8]<br />
root         18  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/9]<br />
root         19  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/10]<br />
root         20  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/11]<br />
root         21  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/12]<br />
root         22  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/13]<br />
root         23  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/14]<br />
root         24  0.0  0.0      0     0 ?        S    10:24   0:00 [rcuob/15]<br />
……省略n行<br />
复制代码<br />
初次之外还有top命令运行的截图</p><br />
<br />
<p>测试开辟一个新的MOUNT名称空间/容器container，验证MOUNT的隔离性:</p><br />
<br />
<p>复制代码<br />
[egon@www ~]$ gcc -o fs fs.c #编译<br />
[egon@www ~]$ sudo ./fs #进入mount容器<br />
Parent [ 6554] - start a container!<br />
Container [    1] - inside the container!<br />
[root@container egon]#    #此处便是新的容器了<br />
[root@container egon]# ls /proc/ #浏览/proc内容，发现少了好多<br />
1          bus       crypto     execdomains  iomem     keys        loadavg  modules  pagetypeinfo  slabinfo  sysrq-trigger  uptime<br />
13         cgroups   devices    fb           ioports   key-users   locks    mounts   partitions    softirqs  sysvipc        version<br />
acpi       cmdline   diskstats  filesystems  irq       kmsg        mdstat   mpt      sched_debug   stat      timer_list     vmallocinfo<br />
asound     consoles  dma        fs           kallsyms  kpagecount  meminfo  mtrr     scsi          swaps     timer_stats    vmstat<br />
buddyinfo  cpuinfo   driver     interrupts   kcore     kpageflags  misc     net      self          sys       tty            zoneinfo<br />
[root@container egon]# ps aux　＃查看进程信息发现只能两个进程:一个初始进程id为1,另外一个就算ps命令本身<br />
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br />
root          1  0.0  0.2 115384  2092 pts/0    S    11:35   0:00 /bin/bash<br />
root         14  0.0  0.1 139500  1632 pts/0    R+   11:35   0:00 ps aux<br />
复制代码<br />
除此之外执行top命令，发现包括top命令本身，也是只要两个进程</p><br />
<br />
<p>需要强调的一点是：在通过CLONE_NEWNS创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。</p><br />
<br />
<p>并且我们完全可以根据自己的需要来为容器定制mount选项。</p><br />
<br />
<p>Docker的 Mount Namespace</p><br />
<br />
<p>下面就让我们来模拟制作一个镜像，模仿Docker的Mount Namespace</p><br />
<br />
<p>步骤一：</p><br />
<br />
<p>对于chroot来说，chroot 目录，然后切入到目录对应的名称空间下，同理，我们也需要为我们的mount namespace提供一个目录（即镜像），于是我们在/home/egon下新建目录rootfs</p><br />
<br />
<p>rootfs的目录结构参照linux根目录的结构</p><br />
<br />
<p>[root@www ~]# for i in <code class="language-plaintext highlighter-rouge">ls /</code>;do mkdir /home/egon/rootfs/$i -p;done<br />
[root@www ~]# ls /home/egon/rootfs/<br />
bin  boot  data  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var<br />
步骤二 ：</p><br />
<br />
<p>把一些我们需要在命名空间内使用的命令拷贝到/home/egon/rootfs/bin以及/home/egon/rootfs/usr/bin目录下，需要注意的是：/bin/sh命令必须被拷贝，且要被拷贝到/home/egon/rootfs/bin下，否则无法chroot</p><br />
<br />
<p>复制代码<br />
#新增目录<br />
[root@www ~]# mkdir /home/egon/rootfs/usr/libexec<br />
[root@www ~]# mkdir /home/egon/rootfs/usr/bin</p><br />
<br />
<p>#拷贝命令<br />
[root@www ~]# cp -r /bin/*  /home/egon/rootfs/bin/<br />
[root@www ~]# cp -r /usr/bin/*  /home/egon/rootfs/usr/bin/</p><br />
<br />
<p>#拷贝命令依赖的库，可以ldd /bin/ls来查看ls命令用来的库文件，然后定向拷贝，此处我们就简单粗暴的使用<em>拷贝所有了<br />
[root@www ~]# cp -r /lib/</em>  /home/egon/rootfs/lib/<br />
[root@www ~]# cp -r /lib64/*  /home/egon/rootfs/lib64/<br />
[root@www ~]# cp -r /usr/libexec/* /home/egon/rootfs/usr/libexec/</p><br />
<br />
<p>#拷贝命令依赖的一些配置文件<br />
[root@www ~]# cp -r /etc/* /home/egon/rootfs/etc/<br />
复制代码<br />
步骤三：</p><br />
<br />
<p>我们还可以为命名空间定制一些配置文件</p><br />
<br />
<p>复制代码<br />
[root@www ~]# mkdir /home/egon/conf<br />
[root@www ~]# echo ‘egon_hostname’ » /home/egon/conf/hostname #定义hostname文件，用来挂载到命名空间中的/etc/hostname<br />
[root@www ~]# echo ‘1.1.1.1 egon_hostname’ » /home/egon/conf/hosts #定义hosts文件，用来挂载到命名空间中的/etc/hosts<br />
[root@www ~]# echo ‘nameserver 202.110.110.213’ » /home/egon/conf/resolv.conf #定义resolv.conf文件，用来挂载到命名空间中的/etc/resolv.conf<br />
复制代码<br />
同理，我们也可以我新的命名空间定制一些目录</p><br />
<br />
<p>[root@www ~]# mkdir /tmp/t1 #本文最终会将该目录挂载到命名空间中的/mnt目录<br />
[root@www ~]# touch /tmp/t1/egon_test.txt<br />
步骤四：</p><br />
<br />
<p>文件名：newns.c</p><br />
<br />
<p>复制代码<br />
#define _GNU_SOURCE <br />
#include &lt;sys/types.h&gt;<br />
#include &lt;sys/wait.h&gt;<br />
#include &lt;sys/mount.h&gt;<br />
#include <stdio.h><br />
#include <sched.h><br />
#include <signal.h><br />
#include <unistd.h></unistd.h></signal.h></sched.h></stdio.h></p><br />
<br />
<p>/* 定义一个给 clone 用的栈，栈大小1M */<br />
#define STACK_SIZE (1024 * 1024) <br />
static char container_stack[STACK_SIZE];</p><br />
<br />
<p>char* const container_args[] = {<br />
    “/bin/bash”,<br />
    “-l”,<br />
    NULL<br />
};</p><br />
<br />
<p>int container_main(void* arg) <br />
{ <br />
    printf(“Container [%5d] - inside the container!\n”, getpid());</p><br />
<br />
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sethostname("container",10); <br />
 <br />
/* remount "/proc" to make sure the "top" and "ps" show container's information */<br />
if (mount("proc", "rootfs/proc", "proc", 0, NULL) !=0 ) { <br />
    perror("proc"); <br />
} <br />
if (mount("sysfs", "rootfs/sys", "sysfs", 0, NULL)!=0) { <br />
    perror("sys"); <br />
} <br />
if (mount("none", "rootfs/tmp", "tmpfs", 0, NULL)!=0) { <br />
    perror("tmp"); <br />
} <br />
if (mount("udev", "rootfs/dev", "devtmpfs", 0, NULL)!=0) { <br />
    perror("dev"); <br />
} <br />
if (mount("devpts", "rootfs/dev/pts", "devpts", 0, NULL)!=0) { <br />
    perror("dev/pts"); <br />
} <br />
if (mount("shm", "rootfs/dev/shm", "tmpfs", 0, NULL)!=0) { <br />
    perror("dev/shm"); <br />
} <br />
if (mount("tmpfs", "rootfs/run", "tmpfs", 0, NULL)!=0) { <br />
    perror("run"); <br />
} <br />
/*  <br />
 * 模仿Docker的从外向容器里mount相关的配置文件  <br />
 * 你可以查看：/var/lib/docker/containers/&lt;container_id&gt;/目录， <br />
 * 你会看到docker的这些文件的。 <br />
 */ <br />
if (mount("conf/hosts", "rootfs/etc/hosts", "none", MS_BIND, NULL)!=0 || <br />
      mount("conf/hostname", "rootfs/etc/hostname", "none", MS_BIND, NULL)!=0 || <br />
      mount("conf/resolv.conf", "rootfs/etc/resolv.conf", "none", MS_BIND, NULL)!=0 ) { <br />
    perror("conf"); <br />
} <br />
/* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */ <br />
if (mount("/tmp/t1", "rootfs/mnt", "none", MS_BIND, NULL)!=0) { <br />
    perror("mnt"); <br />
} <br />
 <br />
/* chroot 隔离目录 */<br />
if ( chdir("./rootfs") != 0 || chroot("./") != 0 ){ <br />
    perror("chdir/chroot"); <br />
}<br />
 <br />
execv(container_args[0], container_args); <br />
perror("exec1111"); <br />
printf("Something's wrong!\n"); <br />
return 1;  } <br />
</code></pre></div></div><br />
<br />
<p>int main() <br />
{ <br />
    printf(“Parent [%5d] - start a container!\n”, getpid()); <br />
    int container_pid = clone(container_main, container_stack+STACK_SIZE,<br /><br />
            CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL); <br />
    waitpid(container_pid, NULL, 0); <br />
    printf(“Parent - container stopped!\n”); <br />
    return 0; <br />
} <br />
复制代码<br />
步骤五：</p><br />
<br />
<p>复制代码<br />
[egon@www ~]$ gcc -o newns newns.c<br />
[egon@www ~]$ sudo ./newns              #进行新的命名空间<br />
Parent [ 2848] - start a container!<br />
Container [    1] - inside the container!   #基于之前所做，我们已然实现pid隔离<br />
bash-4.2#                                             #chroot进了一个新的命名空间<br />
bash-4.2# pwd                                      #chroot ./rootfs的效果<br />
/<br />
bash-4.2# hostname                             #查看主机名发现实现了主机名隔离<br />
container<br />
bash-4.2# ipcs -q                                  #ipc同样也是隔离的</p><br />
<br />
<p>—— Message Queues ——–<br />
key        msqid      owner      perms      used-bytes   messages</p><br />
<br />
<p>bash-4.2# ps aux<br />
USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br />
root          1  0.0  0.1  11768  1860 pts/0    S    20:55   0:00 /bin/bash -l<br />
root         28  0.0  0.1  35884  1480 pts/0    R+   20:57   0:00 ps aux<br />
bash-4.2# <br />
bash-4.2# <br />
bash-4.2# <br />
bash-4.2# <br />
bash-4.2# <br />
bash-4.2# <br />
bash-4.2# mount<br />
proc on /proc type proc (rw,relatime)<br />
sysfs on /sys type sysfs (rw,relatime,seclabel)<br />
none on /tmp type tmpfs (rw,relatime,seclabel)<br />
udev on /dev type devtmpfs (rw,relatime,seclabel,size=490432k,nr_inodes=122608,mode=755)<br />
devpts on /dev/pts type devpts (rw,relatime,seclabel,mode=600,ptmxmode=000)<br />
shm on /dev/shm type tmpfs (rw,relatime,seclabel)<br />
tmpfs on /run type tmpfs (rw,relatime,seclabel)<br />
/dev/mapper/centos-root on /etc/hosts type xfs (rw,relatime,seclabel,attr2,inode64,noquota)<br />
/dev/mapper/centos-root on /etc/hostname type xfs (rw,relatime,seclabel,attr2,inode64,noquota)<br />
/dev/mapper/centos-root on /etc/resolv.conf type xfs (rw,relatime,seclabel,attr2,inode64,noquota)<br />
/dev/mapper/centos-root on /mnt type xfs (rw,relatime,seclabel,attr2,inode64,noquota)<br />
proc on /proc type proc (rw,relatime)<br />
none on /tmp type tmpfs (rw,relatime,seclabel)<br />
shm on /dev/shm type tmpfs (rw,relatime,seclabel)<br />
tmpfs on /run type tmpfs (rw,relatime,seclabel)<br />
/dev/mapper/centos-root on /etc/hosts type xfs (rw,relatime,seclabel,attr2,inode64,noquota)<br />
/dev/mapper/centos-root on /etc/hostname type xfs (rw,relatime,seclabel,attr2,inode64,noquota)<br />
/dev/mapper/centos-root on /etc/resolv.conf type xfs (rw,relatime,seclabel,attr2,inode64,noquota)<br />
/dev/mapper/centos-root on /mnt type xfs (rw,relatime,seclabel,attr2,inode64,noquota)<br />
bash-4.2# cat /etc/hostname #验证步骤三所述<br />
testhostname<br />
bash-4.2# cat /etc/hosts    #同上<br />
123<br />
bash-4.2# cat /etc/resolv.conf #同上<br />
123<br />
bash-4.2# ls /mnt/             #同上<br />
egon_test.txt<br />
2.5 Network命名空间<br />
用于隔离网络资源（/proc/net、IP 地址、网卡、路由等）。后台进程可以运行在不同命名空间内的相同端口上，用户还可以虚拟出一块网卡。</p><br />
<br />
<p>每个网络命名空间都有自己的路由表，它自己的iptables设置提供nat和过滤。Linux网络命名空间还提供了在网络命名空间内运行进程的功能。</p><br />
<br />
<p>2.6 User命名空间<br />
同进程 ID 一样，用户 ID 和组 ID 在命名空间内外是不一样的，并且在不同命名空间内可以存在相同的 ID。</p><br />

					 <span class='st_sharethis_large' displayText='ShareThis'></span>
						<span class='st_facebook_large' displayText='Facebook'></span>
						<span class='st_twitter_large' displayText='Tweet'></span>
						<span class='st_linkedin_large' displayText='LinkedIn'></span>
						<span class='st_pinterest_large' displayText='Pinterest'></span>
						<span class='st_email_large' displayText='Email'></span>
                </div>
                Category docker
        </div>
	</div>
  
  
       <!--赞-->
    	  <div class="row">
            <div class="col-lg-6">
                <img src="https://xiazemin.github.io/MyBlog/img/webwxgetmsgimg.jpeg"  height="400" width="auto" />
            </div>
          </div>

        <div class="row">
                <div class="col-md-12">
			<div id="disqus_thread"></div>

<div id="gitmentContainer"></div>
<link rel="stylesheet" href="/MyBlog/css/default.css">
<script src="/MyBlog/js/gitment.browser.js"></script>
<script type="text/javascript" src="/MyBlog/js/json2.js"></script>
<script>
var gitment = new Gitment({
    owner: 'xiazemin',
    repo: 'MyBlogComment',
    oauth: {
        client_id: '981ba8c916c262631ea0',
        client_secret: 'a52260ef92de69011ccd1cf355b973ef11d6da0e',
    },
});

var MyGitmentContainer=gitment.render('gitmentContainer');
window.setTimeout(MyGitMentBtnclick,1000); 
//document.ready(function(){ 
//window.onload=function(){}

function MyGitMentBtnclick(){
//var MyGitmentContainer=document.getElementById('gitmentContainer');
	var ele=[],all=MyGitmentContainer.getElementsByTagName("*");
	for(var i=0;i<all.length;i++){
	  if(all[i].className=='gitment-comments-init-btn'){
		MyGitMentBtn=all[i];
		console.log(MyGitMentBtn);
		MyGitMentBtn.click();
	  }
	}
}

</script>



			<!--script>
			/**
			* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
			* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
			*/
			/*
			var disqus_config = function () {
			this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
			this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
			};
			*/
			(function() { // DON'T EDIT BELOW THIS LINE
			var d = document, s = d.createElement('script');

			s.src = '//airrayagroup.disqus.com/embed.js';

			s.setAttribute('data-timestamp', +new Date());
			(d.head || d.body).appendChild(s);
			})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<script id="dsq-count-scr" src="//airrayagroup.disqus.com/count.js" async></script-->
          </div>
       </div>

</div>
<hr>
     <footer>
        <div class="container">
             <a href="/MyBlog/" style="color: green; font-size: 2em; font-family: 'Schoolbell', cursive;">首页</a>
            <div class="row">
                <div class="col-lg-6">
                    <p>Copyright &copy; 2017 465474307@qq.com <p>
                </div>
                <div class="col-lg-6">
                    <p style="float: right;">Jekyll theme by <a href="https://github.com/xiazemin/">夏泽民</a></p>
                </div>
            </div>
        </div>
    </footer>
	
    <!-- jQuery -->
    <script src="/MyBlog/js/jquery-1.12.0.min.js"></script>
    <script src="/MyBlog/js/jquery-migrate-1.2.1.min.js"></script>

    <!-- Latest compiled and minified JavaScript -->
    <script src="/MyBlog/js/bootstrap.min.js" integrity="sha384-0mSbJDEHialfmuBBQP6A4Qrprq5OVfW37PRR3j5ELqxss1yVqOtnepnHVP9aJ7xS" crossorigin="anonymous"></script>
        <!-- Menu Toggle Script -->
    <script>
    $("#menu-toggle").click(function(e) {
        e.preventDefault();
        $("#wrapper").toggleClass("toggled");
    });
    </script>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"100"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/MyBlog/shareapi/js/share.js?v=89860593.js?'];</script>


<!-- 2d  -->
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.0.min.js"></script>
<script type="text/javascript" charset="utf-8"  src="/MyBlog/js/L2Dwidget.min.js"></script>
<script type="text/javascript">
 setTimeout(()=> {
/*L2Dwidget.init({"display": {
        "superSample": 2,
        "width": 200,
        "height": 400,
             "position": "right",
                 "hOffset": 0,
        "vOffset": 0
          }
     });
*/
 L2Dwidget
        .on('*', (name) => {
          console.log('%c EVENT ' + '%c -> ' + name, 'background: #222; color: yellow', 'background: #fff; color: #000')
        })
        .init({
          dialog: {
            // 开启对话框
            enable: true,
            script: {
              // 每空闲 10 秒钟，显示一条一言
              'every idle 10s': '$hitokoto$',
              // 当触摸到星星图案
              'hover .star': '星星在天上而你在我心里 (*/ω＼*)',
              // 当触摸到角色身体
              'tap body': '哎呀！别碰我！',
              // 当触摸到角色头部
              'tap face': '人家已经不是小孩子了！'
            }
          }
        });

})
</script>



    <!--html xmlns:wb="http://open.weibo.com/wb">
    <script src="http://tjs.sjs.sinajs.cn/open/api/js/wb.js" type="text/javascript" charset="utf-8"></script>
    <wb:follow-button uid="2165491993" type="red_1" width="67" height="24" ></wb:follow-button-->

      <!--本文来自-->
     <script type="text/javascript">
      /* 仅IE
     document.body.oncopy = function(){
        setTimeout( 
            function () { 
        var text =window.clipboardData.getData("text"); 
        if (text) { 
            text = text + "/r/n本篇文章来源于 xiazemin 的 泽民博客|https://xiazemin.github.io/MyBlog/index.html 原文链接："+location.href; clipboardData.setData("text", text); 
          }
       },
     100 )
    }
     */
     //绑定在了body上，也可以绑定在其他可用元素行，但是不是所有元素都支持copy和past事件。

     /*
$(document.body).bind({
    copy: function(event) {//copy事件
        //var cpTxt = "复制的数据";
        var clipboardData = window.clipboardData; //for IE
        if (!clipboardData) { // for chrome
            clipboardData = event.originalEvent.clipboardData;
        }

        if (event.clipboardData != null/false/undefined) { //ignore the incorrectness of the truncation
        clipboarddata = event.clipboardData;
        } else if (window.clipboardData != null/false/undefined) {
         clipboarddata = window.clipboardData;
        } else { //default to the last option even if it is null/false/undefined
         clipboarddata = event.originalEvent.clipboardData;
        }

        //e.clipboardData.getData('text');//可以获取用户选中复制的数据
        //clipboardData.setData('Text', cpTxt);
        alert(clipboarddata.getData('text'));
        //$('#message').text('Copy Data : ' + cpTxt);
        return false;//否则设不生效
    },paste: function(e) {//paste事件
        var eve = e.originalEvent
        var cp = eve.clipboardData;
        var data = null;
        var clipboardData = window.clipboardData; // IE
        if (!clipboardData) { //chrome
            clipboardData = e.originalEvent.clipboardData
        }
        data = clipboardData.getData('Text');
        //$('#message').html(data);
    }
});     
*/
function addLink() {
    var body_element = document.getElementsByTagName('body')[0];
    var selection;
    selection = window.getSelection();
    var pagelink = "<br /><br />本文来源：xiazemin 的 泽民博客 <a href='"+document.location.href+"'>"+document.location.href+"</a>";
//+document.location.href+当前页面链接
    var copy_text = selection + pagelink;
    console.log(copy_text);
    var new_div = document.createElement('div');
    new_div.style.left='-99999px';
    new_div.style.position='absolute';
    body_element.appendChild(new_div );
    new_div.innerHTML = copy_text ;
    selection.selectAllChildren(new_div );
    window.setTimeout(function() {
        body_element.removeChild(new_div );
    },0);
}
document.oncopy = addLink;
     </script>
    <!--本文来自-->

</div>
  </body>

</html>