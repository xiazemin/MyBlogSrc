---
title: Golang生成动态库及调用
layout: post
category: golang
author: 夏泽民
---
目前go动态库的生产只支持Linux，Windows下会报这样的错误，`-buildmode=plugin not supported on windows/amd64`
CODE
plugin.so

package main



import (

    "fmt"

    )



func DCall(){
    fmt.Println("plugin.so was called") 
}

func DCallWithParam(msg string){
    fmt.Println("参数内容为:",msg) 
}


func main() {



    fmt.Println("goroute全部退出")

}
<!-- more -->
pluginload.go

package main

import (
    "plugin"
)

func main() {

    //加载动态库
    p, err := plugin.Open("plugin.so")
    if err != nil {
        panic(err)
    }
    //查找函数   
    f, err := p.Lookup("DCall")
    if err != nil {
        panic(err)
    }
    //转换类型后调用函数   
    f.(func())()

    f2, err := p.Lookup("DCallWithParam")
    if err != nil {
        panic(err)
    }

    //带参函数的调用
    f2.(func(string))("hello world,plugin.so")


}
编译动态库
go build --buildmode=plugin plugin.go
调用动态库
go run pluginload.go

使用Golang写C的动态库,当前项目目录
root@working-srv: tree ./
./
|-- hello
|   `-- main.go
`-- main.c
1
2
3
4
5
6
7
root@working-srv: more hello/main.go 
package main

import "C"

func main() {}

//export Hello
func Hello() string {
    return "Hello"
}

//export Test
func Test() {
   println("export Test")
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
root@working-srv: more main.c 
#include<libhello.h>
#include<stdio.h>

void main()
{
    GoString str;
    str=Hello();    
    Test();
    printf("%s\n",str);
}
1
2
3
4
5
6
7
8
9
10
11
12
首先将hello/main.go编译成动态库,使用下面的命令
go build -x -v -ldflags "-s -w" -buildmode=c-shared  -o libhello.so hello
root@working-srv: tree ./
./
|-- hello
|   `-- main.go
|-- libhello.h
|-- libhello.so
`-- main.c
执行完毕的目录结构到多了libhello.h 和 libhello.so
使用下面的命令编译C文件.(-L指定动态链接库目录 -l指定动态链接库文件 -I指定头文件目录)
gcc -I./ -L./ -lhello -o main main.c
root@working-srv: tree ./
./
|-- hello
|   `-- main.go
|-- libhello.h
|-- libhello.so
|-- main
`-- main.c
这里可以看到编译出了main文件.
root@working-srv: ./main 
export Test
Hello

root@working-srv: ./main 
export Test
Hello

这里有个注意的地方就是main.go文件中的//export Hello 和 //export Test这个是有作用的,没有这个就不会生成对应的头文件方法.也就是此方法就不会被导出.