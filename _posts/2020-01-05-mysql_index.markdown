---
title: mysql index
layout: post
category: storage
author: 夏泽民
---
一.索引是什么？
索引是数据库中用来提高查询效率的技术，类似于目录。如果不使用索引，数据会零散的保存在磁盘块中，查询数据需要挨个遍历每一个磁盘块，直到找到数据为止，使用索引后会将磁盘块以树桩结构保存，查询数据时会大大降低磁盘块的访问数量，从而提高查询效率。如果表中的数据很少，使用索引反而会降低查询效率。并且索引会占用磁盘空间，一般只针对查询时常用的字段创建索引。索引分为聚集索引和非聚集索引，通过主键创建的索引称为聚集索引，聚集索引中保存数据，只要给表添加主键约束，则会自动创建聚集索引；通过非主键字段创建的索引称为非聚集索引，非聚集索引中没有数据。还可以通过多个字段来创建复合索引。

二.MySQL中存储索引用的是什么结构？
MySQL中存储索引用的一般都是B+树。它的数据都存放在叶子节点中，同时叶子节点之间还添加了指针形成了链表。有点像HashMap的底层实现，数组 + 链表的结构。
在这里插入图片描述
上图是一个4路B+树，可以清楚的看到，所有的数据都存放在叶子节点上，并且叶子节点之间有指针链表相连。

三.为什么要用B+树？
首先，B+树是平衡树。树的查询效率是log(n)，n为树的高度。如果使用非平衡树，如二叉树。那么在特殊情况，如插入的数据是有序的，会出现什么情况呢？
在这里插入图片描述
二叉树发生了退化，变成了链表，树的高度变高了，影响了查询的效率。由于B+树是平衡树，保证了树的高度是最优的，所以不会出现上述的退化情况。上文展示了一个4路的B+树，可以看出当路数越多时，树的高度是越低的，那么问题来了，为什么不设计一个无限多路的B树来降低树高度，从而提升查询效率呢？先来看看一个无限多路的B树是什么样的。
在这里插入图片描述
不限路数，B树就退化成了一个数组。那么会出现什么问题呢？数据库的索引是存储在硬盘上的，如果数据量大的话，不一定可以一次性加载到内存中。这时候，多路存储的好处就体现出来了，可以每次加载树的一个节点，然后一步步往下找。比如一个三路的B树，每个节点最多有两个数，查找的时候每次载入一个节点进内存就行，就不会出现数据量过大无法加载到内存中的情况。在业务场景中查询数据时，往往是查询多条数据，比如查询最近修改过的10条数据，B+树在B树的基础上进行了优化，B+树的所有数据都在叶子结点，同时有链表结构，只需要找到首尾，就可以把所有的数据找出来了。综上述所述，MySQL中存储索引用B+树的好处主要是降低树高度提高查询效率、多路设计保证硬盘到内存的加载、叶子节点存储数据并且加了指针形成链表在范围查找时只需定位首尾就可以取出所需数据。

为什么能够提高查询速度？
索引就是通过事先排好序，从而在查找时可以应用二分查找等高效率的算法。
一般的顺序查找，复杂度为O(n)，而二分查找复杂度为O(log2n)。当n很大时，二者的效率相差及其悬殊。

举个例子：
表中有一百万条数据，需要在其中寻找一条特定id的数据。如果顺序查找，平均需要查找50万条数据。而用二分法，至多不超过20次就能找到。二者的效率差了2.5万倍！

在一个或者一些字段需要频繁用作查询条件，并且表数据较多的时候，创建索引会明显提高查询速度，因为可由全表扫描改成索引扫描。

（无索引时全表扫描也就是要逐条扫描全部记录，直到找完符合条件的，索引扫描可以直接定位）

不管数据表有无索引，首先在SGA的数据缓冲区中查找所需要的数据，如果数据缓冲区中没有需要的数据时，服务器进程才去读磁盘。
1、无索引，直接去读表数据存放的磁盘块，读到数据缓冲区中再查找需要的数据。
2、有索引，先读入索引表，通过索引表直接找到所需数据的物理地址，并把数据读入数据缓冲区中。

索引有什么副作用吗？
（1）索引是有大量数据的时候才建立的，没有大量数据反而会浪费时间，因为索引是使用二叉树建立.

（2）当一个系统查询比较频繁，而新建，修改等操作比较少时，可以创建索引，这样查询的速度会比以前快很多，同时也带来弊端，就是新建或修改等操作时，比没有索引或没有建立覆盖索引时的要慢。

（3）索引并不是越多越好，太多索引会占用很多的索引表空间，甚至比存储一条记录更多。
对于需要频繁新增记录的表，最好不要创建索引，没有索引的表，执行insert、append都很快，有了索引以后，会多一个维护索引的操作，一些大表可能导致insert 速度非常慢
<!-- more -->
1）数据库设计方面： 
        a. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 
        b. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0

        c. 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时,查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。

        d. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。

        e. 应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引。

        f. 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。

        g. 尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

        h. 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。

        i. 避免频繁创建和删除临时表，以减少系统表资源的消耗。

        j. 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。

        k. 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。

        l. 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。



2)SQL语句方面：

        a. 应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。

        b. 应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如： 

select id from t where num=10 or num=20 

可以这样查询：

select id from t where num=10 union all select id from t where num=20

        c. in 和 not in 也要慎用，否则会导致全表扫描，如： 

select id from t where num in(1,2,3) 

对于连续的数值，能用 between 就不要用 in 了： 

select id from t where num between 1 and 3

        d. 下面的查询也将导致全表扫描： 

select id from t where name like ‘%abc%’

        e. 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。

     然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： 

select id from t where num=@num 

可以改为强制查询使用索引： 

select id from t with(index(索引名)) where num=@num

        f. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如： 

select id from t where num/2=100 

应改为: 

select id from t where num=100*2

        g. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： 

select id from t where substring(name,1,3)=’abc’

–name以abc开头的id

select id from t where datediff(day,createdate,’2005-11-30′)=0

–‘2005-11-30’生成的id 

应改为: 

select id from t where name like ‘abc%’ select id from t where createdate>=’2005-11-30′ and createdate<’2005-12-1′

        h. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

        i. 不要写一些没有意义的查询，如需要生成一个空表结构： 

select col1,col2 into #t from t where 1=0 

这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样： 

create table #t(…)

        j. 很多时候用 exists 代替 in 是一个好的选择： 

select num from a where num in(select num from b) 

用下面的语句替换： 

select num from a where exists(select 1 from b where num=a.num)

        k. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。

        l. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。

        m. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。

        n. 尽量避免大事务操作，提高系统并发能力。



3)java方面：重点内容

        a.尽可能的少造对象。

        b.合理摆正系统设计的位置。大量数据操作，和少量数据操作一定是分开的。大量的数据操作，肯定不是ORM框架搞定的。，

        c.使用jDBC链接数据库操作数据

        d.控制好内存，让数据流起来，而不是全部读到内存再处理，而是边读取边处理；

        e.合理利用内存，有的数据要缓存



如何优化数据库，如何提高数据库的性能?

        1） 硬件调整性能 

    最有可能影响性能的是磁盘和网络吞吐量,解决办法扩大虚拟内存，并保证有足够可以扩充的空间；把数据库服务器上的不必要服务关闭掉；把数据库服务器和主域服务器分开；把SQL数据库服务器的吞吐量调为最大；在具有一个以上处理器的机器上运行SQL。

        2）调整数据库

    若对该表的查询频率比较高，则建立索引；建立索引时，想尽对该表的所有查询搜索操作， 按照where选择条件建立索引，尽量为整型键建立为有且只有一个簇集索引，数据在物理上按顺序在数据页上，缩短查找范围，为在查询经常使用的全部列建立非簇集索引，能最大地覆盖查询；但是索引不可太多，执行UPDATE DELETE INSERT语句需要用于维护这些索引的开销量急剧增加；避免在索引中有太多的索引键；避免使用大型数据类型的列为索引；保证每个索引键值有少数行。

        3）使用存储过程

    应用程序的实现过程中，能够采用存储过程实现的对数据库的操作尽量通过存储过程来实现，因为存储过程是存放在数据库服务器上的一次性被设计、编码、测试，并被再次使用，需要执行该任务的应用可以简单地执行存储过程，并且只返回结果集或者数值，这样不仅可以使程序模块化，同时提高响应速度，减少网络流量，并且通过输入参数接受输入，使得在应用中完成逻辑的一致性实现。

        4）应用程序结构和算法

    建立查询条件索引仅仅是提高速度的前提条件，响应速度的提高还依赖于对索引的使用。因为人们在使用SQL时往往会陷入一个误区，即太关注于所得的结果是否正确，特别是对数据量不是特别大的数据库操作时，是否建立索引和使用索引的好坏对程序的响应速度并不大，因此程序员在书写程序时就忽略了不同的实现方法之间可能存在的性能差异，这种性能差异在数据量特别大时或者大型的或是复杂的数据库环境中（如联机事务处理OLTP或决策支持系统DSS）中表现得尤为明显。在工作实践中发现，不良的SQL往往来自于不恰当的索引设计、不充份的连接条件和不可优化的where子句。在对它们进行适当的优化后，其运行速度有了明显地提高！
    
    mysql大数据下查询，char和varchar对于效率的区别（未建立索引情况下）
问题描述：
两个表的仅有以一个字段属性不同，一个为char另外一个为varchar，（长度设定是40，同时插入相同长度内容）试问再大数据量下，哪个表的查询效率高（在不建立索引的情况下）；

 

原来的理解：
原来的理解是，char的效率更高，这个理解是基于char是固定长度，空间分配好查询速度就快（这个后面就尴尬咯）

 

实际测试：
表结构如下



写了一个定时任务批量插入数据。。。。

后来插入到240w，写个定时任务跑爽爽的

在50w数据量下测试的结果：



到240w后的差距就更明显。

 

在没有索引的情况下，mysql查询走的是主键创建的索引，通过主键查询，数据量大效率的瓶颈是磁盘的io，

当数据量大的时候，char是固定长度，占用的磁盘空间较大，查询效率就降低；

在不同的场景下，瓶颈是不同的；
