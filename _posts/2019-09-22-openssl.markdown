---
title: 签名和加密的区别
layout: post
category: algorithm
author: 夏泽民
---
数据签名和数据加密的过程都是使用公开的密钥系统，但实现的过程正好相反，

数据加密使用的是接受方的密钥对，任何知道接受方公钥的都可以向接受方发送消息，但是只有拥有私钥的才能解密出来；

数据签名使用的是发送方的密钥对，任何接受方都可以用公钥解密，验证数据的正确性。

一句话总结：

数据加密保证了数据接受方的数据安全性。

数据签名保证了数据发送方的数据安全性。

就拿A给B发送经过签名加密信息来说：
1、A对信息签名的作用是确认这个信息是A发出的，不是别人发出的；
2、加密是对内容进行机密性保护，主要是保证信息内容不会被其他人获取，只有B可以获取。

也就是保证整个过程的端到端的唯一确定性，这个信息是A发出的（不是别人），且是发给B的，只有B才被获得具体内容（别人就算截获信息也不能获得具体内容）。
<!-- more -->
数据加密：用公钥加密，只有用私钥解开，因为私钥只有你自己有，所以他保证了数据不能被别人看到
签名：用私钥加密，只能用公钥解密，任何人都可以用公钥验证。因为私钥只有你自己有，所以它可以保证数据只能是你发出的，不可能有别人发出，除非你得私钥丢失或被第三方破解出来

 
数字签名起不到加密作用，但可以确定是谁发出的信息
使用公钥加密算法，可以对明文进行加密，但不能确定是谁发出该消息

签名：私钥签名，公钥验证，所以就算私钥遗失了，以前签名的数据仍然有效，所以私钥一般只有一份

加密：公钥加密，私钥解密，一旦私钥遗失，则数据就无法还原了，所以CA一般会备份加密证书

 数字签名主要经过以下几个过程：

信息发送者使用一单向散列函数（HASH函数）对信息生成信息摘要；

信息发送者使用自己的私钥签名信息摘要；

信息发送者把信息本身和已签名的信息摘要一起发送出去；

信息接收者通过使用与信息发送者使用的同一个单向散列函数（HASH函数）对接收的信息本身生成新的信息摘要，再使用信息发送者的公钥对信息摘要进行验证，以确认信息发送者的身份和信息是否被修改过。

数字加密主要经过以下几个过程：

当信息发送者需要发送信息时，首先生成一个对称密钥，用该对称密钥加密要发送的报文；

信息发送者用信息接收者的公钥加密上述对称密钥；

信息发送者将第一步和第二步的结果结合在一起传给信息接收者，称为数字信封；

信息接收者使用自己的私钥解密被加密的对称密钥，再用此对称密钥解密被发送方加密的密文，得到真正的原文。

数字签名和数字加密的过程虽然都使用公开密钥体系，但实现的过程正好相反，使用的密钥对也不同。
数字签名使用的是发送方的密钥对，发送方用自己的私有密钥进行加密，接收方用发送方的公开密钥进行解密，这是一个一对多的关系，任何拥有发送方公开密钥的人都可以验证数字签名的正确性。
数字加密则使用的是接收方的密钥对，这是多对一的关系，任何知道接收方公开密钥的人都可以向接收方发送加密信息，只有唯一拥有接收方私有密钥的人才能对信息解密。
另外，数字签名只采用了非对称密钥加密算法，它能保证发送信息的完整性、身份认证和不可否认性，而数字加密采用了对称密钥加密算法和非对称密钥加密算法相结合的方法，它能保证发送信息保密性。

openssl_private_encrypt 加密数据
openssl_sign 签名

openssl
算法基础
1.1 对称算法 : 密钥相同，加密解密使用同一密钥

1.2 摘要算法：无论用户输入的数据什么长度，输出的都是固定长度的密文；即信息摘要，可用于判断数据的完整性；目前常用的有 MD5(16字节), SHA1(20字节)

1.3 公钥算法：使用同一个公钥和算法加密(公开)，使用各自的密钥解密; 主要有 RSA、DSA；

1.4 RSA算法：原理：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥，即是公钥(通常1024位)；通常用于数字签名和保密通信；

1.5 DSA算法：原理：DSA是基于整数有限域离散对数难题的；不能用作加密，只用作数字签名；

1.6 openssl简介: c语言开发，是一个功能丰富的开源安全工具箱；openssl 官网

1.7 MD5校验：mac下，可以直接使用终端md5命令，查看生成文件，字符串的md5

1.8 哈希表: 指存储位置与关键字之间建立的确定关系，不同的关键字可能得到同一哈希表。

1.9 伪随机数：软件生成的随机数，一般称之为伪随机数，安全性高的应用使用硬件方式生成随机数（随机数发生器）。

1.10 ASN1 ：描述了一种对数据进行表示、编码、传输和解码的数据格式。它提供了一整套正规的格式用于描述对象的结构，而不管语言上如何执行及这些数据的具体指代，也不用去管到底是什么样的应用程序。

1.11 EVP：openssl evp 提供了丰富的密码学中的和种函数，包括对称算法，摘要算法，签名/验签等；

1.12 PEM : openssl 使用 pem格式来存放各种信息，是默认的信息存放方式；

1.13 Engine：由硬件内部的密码计算方法控件openssl内的各密码计算；从而替换openssl提供的一些密码计算方法；

1.14 X509数字证书:数字证书是将用户(或其他实体)身份与公钥绑定的信息载体。一个合法的数字证书 不仅要符合 X509 格式规范,还必须有 CA 的签名。用户不仅有自己的数字证书,还必 须有对应的私钥。即是 .cer 文件；

1.15 OCSP：在线证书状态协议，用于实时表明 证书状态。

1.16 CRL : 证书撤销列表，是一种包含摊销的证书列表的签名数据结构。好比黑名单。

1.17 PKCS7 : 是各种消息存放的格式标准。这些消息包括：数据、签名数据、数字信封、签名数字信封、摘要数据和加密数据。

1.18 PKCS12: 用于存放用户证书、crl、用户私钥等的个人信息文件；里面的数据是加密的；

@2014-10-27

数字签名流程
假定用户 userA,要给用户 userB，发送信息 sms ;
userA 先生成自己的 公钥 (PKa )和 密钥 (SKa ), 常用的算法有 RSA,DSA;
userA 对信息 sms 做信息摘要处理得到 md5_SMS , 常用的摘要算法md5,sha1;
userA 用 自己的密钥 SKa 加密信息摘要 md5_SMS 得到 enc_md5_SMS,即数字签名；
userA 把 enc_md5_SMS 数字签名 、自己的公钥PKa 以及 原数据 sms 一起发送给 userB;
userB 用同样的摘要算法对 sms 处理得到 userB_md5_SMS；
userB 用 userA的公钥 PKa 解密 数字签名enc_md5_SMS 得到 userB_dec_md5_SMS;
userB 去比较 userB_dec_md5_SMS 和 userB_md5_SMS 是不是相同的，如果相同那么确认数字签名是userA发的，并且数据安全没有被篡改。
数字签名的特性：一是不可冒充，别人假冒不了(因为没有私钥);二是可以保证数据的完整性(因为内容改变信息摘要也改变)；

@2014-10-28

数字信封
数字信封：是将对称密钥通过 非对称加密技术加密,然后将结果分发出去。

假定用户 userA 要给用户 userB，发送信息 sms;
userB 先生成自己的 公钥和私钥，即是 PKb, SKb;
userB 把自己的 公钥 Pkb 分发给 userA, 此公钥可公开；
userA 随机生成一个 对称加密密码 PWD ，然后用 PWD加密信息 sms得到 userA_enc_sms;
userA 用 userB的 PKb 去加密 对称加密密码 PWD 得到 userA_enc_PWD;然后userA 把 userA_enc_PWD 分发给用户 userB(这就是数字信封);
userB收到 userA_enc_PWD 之后，用自己的私钥去解密，就是打开信封，即 用 SKb 解密 userA_enc_PWD 得到 PWD; 即得到对称加密密码；
userB再用 PWD 去 解密数据 userA_enc_sms ，得到 sms; 完成了信息传递;
数字信封克服了私钥加密中分发私钥和公开密钥加密数据时间长的问题；因为对称加密速度快，非对称加密更安全；

@2014-10-29

数字证书
数字证书：是互联网通信中的身份标识(主要是用户身份信息和公钥)，相当于生活中的身份证；一般由CA中心颁发，既CA认证中心，或第三方权威机构；如身份证中的公安局。

数字证书上通常包括：颁发给某人的签名，证书所有人的公钥，CA中心的签名算法，证书的唯一编号，版本，有效期等。

用户userA 生成自己的 公钥和私钥 ,既 PKa,SKa;
用户userA 把自己的公钥和一些其他个人身份信息提交给 CA中心认证；
CA中心在审核用户信息之后，用CA中心的 私钥 SKca 对 用户的PKa和其他信息做 数字签名，然后生成数字证书；
用户userB在拿到userA数字证书时用 CA的公钥PKca 打开数字证书得到userA的公钥PKa，然后比对自己手的PKa，即可验证 userA的身份是否是假冒的;
数字证书上的数字签名可以验证证书在颁发之后是否被修改过。
