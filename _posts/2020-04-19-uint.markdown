---
title: 二进制表示
layout: post
category: golang
author: 夏泽民
---
在C语言中，有标准库limits.h定义了一些最大最小值常量，例如int类型的最大值常量INT_MAX，最小值常量INT_MIN，无符号整型uint类型的最大值常量UINT_MAX

golang的标准库里没有定义这些变量。不过可以用位操作运算，轻松定义这些常量。

无符号整型uint
其最小值是0，其二进制表示的所有位都为0，

const UINT_MIN uint = 0
1
其最大值的二进制表示的所有位都为1，那么，

const UINT_MAX = ^uint(0)
1
有符号整型int
根据补码，其最大值二进制表示，首位0，其余1，那么，

const INT_MAX = int(^uint(0) >> 1)
1
根据补码，其最小值二进制表示，首位1，其余0，那么，

const INT_MIN = ^INT_MAX
<!-- more -->
首先得知道，在java中,int类型占4个字节，1个字节等于8位二进制，所以int类型32位,范围是-2147483648到2147483647，

因为1000 0000, 0000 0000, 0000 0000, 0000 0000这个是-2^31=-2147483648，所以负数多一个。

然后，因为计算机CPU的运算器中只有加法器，所以减法要转化成加法来计算，所以引入了补码。

补码可以解决两同号数相减或两异号数相加的问题。

举个例子，A表示十进制数“+6”，B表示十进制数“-8”，如果把这两个数的原码直接相加，那么

    0000 0110 

+ 1000 1000

————————

    1000 1110                     

结果为-14，很明显是错的。

如果把这两个数的补码相加，那么

    0000 0110     “+6”补码

+  1111 1000      “-8”补码

————————

    1111 1110       “-2”补码

结果是-2的补码，结果是正确的。

要理解上面的补码运算，得先知道一下3点：

1、正数的原码 反码 补码完全相同。

2、负数的反码是将原码按位取反，补码＝反码+1。

3、补码转原码和原码转补码的方法是一样的。

最后根据上面的计算方法，计算INT_MIN - 1的结果，看是不是等于 INT_MAX。



     1000 0000, 0000 0000, 0000 0000, 0000 0000     “-2147483648”补码

+   1111 1111,1111 1111, 1111 1111,1111 1111       “-1”补码

————————————————————————

   1 0111 1111,1111 1111, 1111 1111,1111 1111       

很明显，运算溢出了。舍去溢出的最高位，最后运算的结果是0111 1111,1111 1111, 1111 1111,1111 1111。

又因为正数的原码 反码 补码完全相同。所以0111 1111,1111 1111, 1111 1111,1111 1111就是“2147483647”补码、源码= INT_MAX。

所以，综上所述：INT_MIN - 1的结果等于 INT_MAX。

Golang：二进制补码和fmt.Printf
So computers use Two's complement to internally represent signed integers. I.e., -5 is represented as ^5 + 1 = "1111 1011".

However, trying to print the binary representation, e.g. the following code:

var i int8 = -5
fmt.Printf("%b", i)
Outputs
-101
. Not quite what I'd expect. Is the formatting different or is it not using Two's complement after all?

Interestingly, converting to an unsigned int results in the "correct" bit pattern:

var u uint8 = uint(i)
fmt.Printf("%b", u)
Output is
11111011
- exactly the 2s complement of
-5
.

So it seems to me the value is internally the really using Two's complement, but the formatting is printing the unsigned
5
and prepending a
-
.

Can somebody clarify this?


本文说明一个基本的问题，补码的问题。
需要说明一点补码是对负整数在计算机中存储的一种形式；另一种形式是负数在计算机中可以用符号+负数绝对值的形式表示一个负数；比如（-3: 1000 0011存储）但是这种表示的负数有两个零+0，-0，最要命的一点是不能做算术运算。比如10-3=10+（-3）=0000 1010+ 1000 0011=1000 1101=-13显然是错的。所以负整数必须以补码存储。
负数在计算机中如何表示？
举例来说，+8在计算机中表示为二进制的1000，那么-8怎么表示呢？
很容易想到，可以将一个二进制位（bit）专门规定为符号位，它等于0时就表示正数，等于1时就表示负数。比如，在8位机中，规定每个字节的最高位为符号位。那么，+8就是00001000，而-8则是10001000。
但是，随便找一本《计算机原理》，都会告诉你，实际上，计算机内部采用2的补码（Two’s Complement）表示负数。

在讲补码之前简单介绍机器数，真值，原码和反码的背景。
1、机器数
一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数0，负数为1。
1
比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是0000 0011。如果是 -3 ，就是 1111 1101 。那么，这里的 00000011 和 1111 1101 就是机器数。 机器数包含了符号和数值部分。

2、真值
因为第一位是符号位，所以机器数的形式值就不能很好的表示真正的数值。例如上面的有符号数 1111 1101，其最高位1代表负，其真正数值是 -3 而不是形式值253（1111 1101按无符号整数转换成十进制等于253）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。
例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –0111 1111 = –127；这里所说的比如-3二进制代码为10000011，就是我们计算机里面对-3表示的源码。下面介绍源码
首先说明一点
在计算机内，有符号数有3种表示法：原码、反码和补码。

3、原码
原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制
[+1]原 = 0000 0001
[-1]原 = 1000 0001
因为第一位是符号位, 所以若是8位二进制数，其取值范围就是:
[1111 1111 , 0111 1111]
即[-127 , 127]
原码是人脑最容易理解和计算的表示方式。

4 、反码
反码表示法规定：正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。
[+1] = [ 00000001 ]原码 = [ 00000001 ]反码；
[-1] = [ 10000001 ]原码 = [ 11111110 ]反码；
可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算。

什么是二进制的补码？
注明：正数的补码与负数的补码一致，负数的补码符号位为1，这位1即是符号位也是数值位，然后加1

补码借鉴的模概念，虽然理解起来有点晦涩难懂。可以跳过
模的概念：把一个计量单位称之为模或模数。例如，时钟是以12进制进行计数循环的，即以12为模。
在时钟上，时针加上（正拨）12的整数位或减去（反拨）12的整数位，时针的位置不变。14点钟在舍去模12后，成为（下午）2点钟（14=14-12=2）。从0点出发逆时针拨10格即减去10小时，也可看成从0点出发顺时针拨2格（加上2小时），即2点（0-10=-10=-10+12=2）。因此，在模12的前提下，-10可映射为+2。由此可见，对于一个模数为12的循环系统来说，加2和减10的效果是一样的；因此，在以12为模的系统中，凡是减10的运算都可以用加2来代替，这就把减法问题转化成加法问题了（注：计算机的硬件结构中只有加法器，所以大部分的运算都必须最终转换为加法）。10和2对模12而言互为补数。同理，计算机的运算部件与寄存器都有一定字长的限制（假设字长为16），因此它的运算也是一种模运算。当计数器计满16位也就是65536个数后会产生溢出，又从头开始计数。产生溢出的量就是计数器的模，显然，16位二进制数，它的模数为2^16=65536。在计算中，两个互补的数称为“补码”。比如一个有符号8位的数可以表示256个数据，最大数是0 1 1 1 1 1 1 1（+127），最小数1 0 0 0 0 0 0 0 （-128）；那么第255个数据，加2和减254都是一样的效果得出的结果是第一个数据 ，所以2和254是一样的效果。对于255来说2和254是互补的数。
求一个正数对应补码是一种数值的转换方法，要分二步完成：
第一步，每一个二进制位都取相反值，即取得反码；0变成1，1变成0。比如，00001000的反码就是11110111。
第二步，将上一步得到的反码加1。11110111就变成11111000。所以，00001000的二进制补码就是11111000。也就是说，-8在计算机（8位机）中就是用11111000表示。
不知道你怎么看，反正我觉得很奇怪，为什么要采用这么麻烦的方式表示负数，更直觉的方式难道不好吗？

二进制补码的好处
首先，要明确一点。计算机内部用什么方式表示负数，其实是无所谓的。只要能够保持一一对应的关系，就可以用任意方式表示负数。所以，既然可以任意选择，那么理应选择一种用的爽直观方便的方式。
二进制的补码就是最方便的方式。它的便利体现在，所有的加法运算可以使用同一种电路完成。
还是以-8作为例子。假定有两种表示方法。一种是直觉表示法，即10001000；另一种是2的补码表示法，即11111000。请问哪一种表示法在加法运算中更方便？随便写一个计算式，16 + (-8) = ?16的二进制表示是 00010000，所以用直觉表示法，加法就要写成：
　０００１００００
＋１０００１０００原码形式-8
－－－－－－－－－
　１００１１０００
可以看到，如果按照正常的加法规则，就会得到10011000的结果，转成十进制就是-24。显然，这是错误的答案。也就是说，在这种情况下，正常的加法规则不适用于正数与负数的加法，因此必须制定两套运算规则，一套用于正数加正数，还有一套用于正数加负数。从电路上说，就是必须为加法运算做两种电路。所以用原码表示负数是不行的。
现在，再来看二进制的补码表示法。
　０００１００００
＋１１１１１０００补码形式-8
－－－－－－－－－
１００００１０００
可以看到，按照正常的加法规则，得到的结果是100001000。注意，这是一个9位的二进制数。我们已经假定这是一台8位机，因此最高的第9位是一个溢出位，会被自动舍去。所以，结果就变成了00001000，转成十进制正好是8，也就是16 + (-8) 的正确答案。这说明了，2的补码表示法可以将加法运算规则，扩展到整个整数集，从而用一套电路就可以实现全部整数的加法。

二进制补码的本质，本质是用来表示负整数的
在回答二进制补码为什么能正确实现加法运算之前，我们先看看它的本质，也就是那两个求补码步骤的转换方法是怎么来的。下面描述了一个正数怎么求它对应负数在计算机的表达方式。比如128，正数为10000000，但是惊奇的发现-128也是10000000。但是这里由于属于数据类型的限定，第八位同样一个1代表不同的含义，前面的 1是数值位，后面数的 1是符号位。
要将正数转成对应的负数，其实只要用0减去这个数就可以了。比如，-8其实就是0-8。用模数的概念解释如下图

已知8的二进制是00001000，-8就可以用下面的式子求出：
　００００００００
－００００１０００
－－－－－－－－－- - - -
因为00000000（被减数）小于0000100（减数），所以不够减。请回忆一下小学算术，如果被减数的某一位小于减数，我们怎么办？很简单，问上一位借1就可以了。
所以，0000000也问上一位借了1，也就是说，被减数其实是100000000，这是重点；算式也就改写成：
１００００００００
－００００１０００
－－－－－－－－－- - -
　１１１１１０００
进一步观察，可以发现可分拆为100000000 = 11111111 + 1，所以上面的式子可以拆成两个：
１１１１１１１１
－００００１０００
－－－－－－－－－
　１１１１０１１１取反
＋０００００００１加一
－－－－－－－－－
　１１１１１０００
二进制的补码两个转换步骤就是这么来的。
举个例子，比如-128补码的由来，先把正整数128二进制表示出来10000000求-128的补码
1 1 1 1 1 1 1 1
-1 0 0 0 0 0 0 0
－－－－－－－－－
0 1 1 1 1 1 1 1
+0 0 0 0 0 0 0 1
－－－－－－－－－
1 0 0 0 0 0 0 0
即-128的补码是10000000。8位的结构能表示的最小数是-128；
所以可以总结求补码的范式是这样的：
求n位系统的一个数正数A : 01101101101……….11101100（n位二进制），怎么求他的补码呢，就用n位的1111111111111111111…..111(n位) - 11101101101……….11101100（n位二进制） + 1 = A的补码就行啦！但是
如果一个1111111111111…..111111(n位全为1的正整数的补码)，要用1111111111111…….11111(n+1位) - 1111111111111…..111111(n位全为1的正整数) +1 才能求的她对应的补码。
如uint16 A =200, uint16 B =65535,那么C =A-B;
65535的补码：正数65535为1111 1111 1111 1111，进行下面的计算求得B的补码即-B；先展示有补码符号位，即补码有最高位位1的；
1 1111 1111 1111 1111 -1111 1111 1111 1111 +1 =1 0000 0000 0000 0001,相当于被减数是10 0000 0000 0000 0000（18位） =1 1111 1111 1111 1111 +1
因为A和B 都是16位的无符号数，所以65535的补码最高位舍去，相当于被减数是1 0000 0000 0000 0000 =1111 1111 1111 1111 +1，即可以用上面的范式方法，但是这样-B就没有体现它的负数的符号位了；当然这是因为16位运算超出16位的位都舍去了。即-B=1;即A-B= 200+1 =201。其实也可以用模数概念解释A -B；如下图正数的模数


为什么正数加法也适用于二进制的补码？
实际上，我们要证明的是，X-Y或X+(-Y)可以用X加上Y的2的补码(-Y)完成。
Y的二进制补码等于(11111111-Y)+1。所以，X加上Y的2的补码，就等于：X + (11111111-Y) + 1；我们假定这个算式的结果等于Z，即 Z = X + (11111111-Y) + 1。
接下来，分成两种情况讨论。
第一种情况，如果X小于Y，那么Z是一个负数。这时，我们就对Z采用补码的逆运算，就是在做一次求补码运算，求出它对应的正数绝对值，只要前面加上负号就行了。所以，
Z = -[11111111-Z+1] = -[11111111-(X + (11111111-Y) + 1)+1)] = X - Y;这里如果X Y Z都是无符号型的，且X < Y 那么Z 最终得到的数是|X-Y|距离的绝对值了，比如X=1,Y= 255,那么Z=2,因为从255到1只要加两次就到了。这里你不要问我为什么，这里就用到上面的模概念。
第二种情况，如果X大于Y，这意味着Z肯定大于11111111，但是我们规定了这是8位机，最高的第9位是溢出位，必须被舍去，舍去相当于减去吗！所以减去100000000。所以，
Z = Z - 100000000 = X + (11111111-Y) + 1 - 100000000 = X - Y
这就证明了，在正常的加法规则下，可以利用2的补码得到正数与负数相加的正确结果。换言之，计算机只要部署加法电路和补码电路，就可以完成所有整数的加法

必须使用不安全指针以二进制格式正确表示负数。

package main

import (
    "fmt"
    "strconv"
    "unsafe"
)

func bInt8(n int8) string {
    return strconv.FormatUint(uint64(*(*uint8)(unsafe.Pointer(&n))), 2)
}

func main() {
    fmt.Println(bInt8(-5))
}
输出

11111011

答案在于fmt模块如何格式化二进制数，而不是内部格式。

如果你看一下fmt.integer，该函数的第一个动作之一是将负有符号整数转换为正整数：

   165      negative := signedness == signed && a < 0
   166      if negative {
   167          a = -a
   168      }
然后将逻辑添加-到此处输出的字符串前面。

IOW 在二进制中，-101真的是-加在5前，。

注：fmt.integer从print.go的pp.fmtInt64调用，pp.fmtInt64从pp.printArg相同函数中调用。


计算机使用二进制补码来内部表示有符号整数。即，-5表示为^ 5 + 1 =“1111 1011”。

但是，尝试打印二进制表示，例如以下代码：

var i int8 = -5
fmt.Printf("%b", i)
输出-101。不是我所期待的。格式不同还是根本不用2的补码？

转换为unsigned int会产生“正确”的位模式：

var u uint8 = uint(i)
fmt.Printf("%b", u)
输出是11111011- 完全是-5的补码。

ackage main

import (
	"encoding/binary"
	"fmt"
	"strconv"
)

func main() {
	var a = []byte{0x15, 0x4B}
	var b = []byte{0xE0, 0x15}
	// fmt.Println(fmt.Sprintf("%.16b", 0x154B))
	fmt.Println(GetYuanMa(a), GetYuanMa(b))

}
// 当data为原码时，输出补码
func GetBuMa(data []byte) uint16 {
	var ym uint16
	bm := binary.BigEndian.Uint16(data)
	var bitNum = len(data) * 8
	f := "%." + strconv.Itoa(bitNum) + "b"
	bmStr := fmt.Sprintf(f, bm)
	if string(bmStr[0]) == "1" {
		ym = ^bm + 1
	} else {
		ym = bm
	}
	return ym
}

// 当data为补码时，输出原码。
// 原理: 补码的补码为原码
func GetYuanMa(data []byte) uint16 {
    return GetBuMa(data)
}