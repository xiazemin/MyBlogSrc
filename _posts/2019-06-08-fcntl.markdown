---
title: fcntl函数设置阻塞与非阻塞
layout: post
category: linux
author: 夏泽民
---
用命令F_GETFL和F_SETFL设置文件标志，比如阻塞与非阻塞

F_SETFL     设置给arg描述符状态标志,可以更改的几个标志是：O_APPEND， O_NONBLOCK，O_SYNC和O_ASYNC。

命令字(cmd)F_GETFL和F_SETFL的标志如下面的描述:            

O_NONBLOCK       非阻塞I/O;如果read(2)调用没有可读取的数据,或者如果write(2)操作将阻塞,read或write调用返回-1和EAGAIN错误               　　　　       　　

O_APPEND             强制每次写(write)操作都添加在文件大的末尾,相当于open(2)的O_APPEND标志         

 O_DIRECT              最小化或去掉reading和writing的缓存影响.系统将企图避免缓存你的读或写的数据.

                                如果不能够避免缓存,那么它将最小化已经被缓存了的数 据造成的影响.如果这个标志用的不够好,将大大的降低性能                     

 O_ASYNC              当I/O可用的时候,允许SIGIO信号发送到进程组,例如:当有数据可以读的时候

 注意：      在修改文件描述符标志或文件状态标志时必须谨慎，先要取得现在的标志值，然后按照希望修改它，最后设置新标志值。不能只是执行F_SETFD或F_SETFL命令，这样会关闭以前设置的标志位。
<!-- more -->
用以下方法将socket设置为非阻塞方式 
int flags = fcntl(socket, F_GETFL, 0); 
fcntl(socket, F_SETFL, flags | O_NONBLOCK);
用以下方法将socket设置为非阻塞方式 
int flags = fcntl(socket, F_GETFL, 0); 
fcntl(socket, F_SETFL, flags | O_NONBLOCK);

将非阻塞的设置回阻塞可以用

int flags = fcntl(socket, F_GETFL, 0); 
fcntl(socket, F_SETFL, flags & ~O_NONBLOCK);


功能描述：根据文件描述词来操作文件的特性。

用法： 
int fcntl(int fd, int cmd); 
int fcntl(int fd, int cmd, long arg); 
int fcntl(int fd, int cmd, struct flock *lock);


参数： 
fd：文件描述词。 
cmd：操作命令。 
arg：供命令使用的参数。 
lock：同上。

有以下操作命令可供使用

一. F_DUPFD ：复制文件描述词 。

二. FD_CLOEXEC ：设置close-on-exec标志。如果FD_CLOEXEC位是0，执行execve的过程中，文件保持打开。反之则关闭。

三. F_GETFD ：读取文件描述词标志。

四. F_SETFD ：设置文件描述词标志。

五. F_GETFL ：读取文件状态标志。

六. F_SETFL ：设置文件状态标志。 
其中O_RDONLY， O_WRONLY， O_RDWR， O_CREAT， O_EXCL， O_NOCTTY 和 O_TRUNC不受影响， 
可以更改的标志有 O_APPEND，O_ASYNC， O_DIRECT， O_NOATIME 和 O_NONBLOCK。

七. F_GETLK, F_SETLK 和 F_SETLKW ：获取，释放或测试记录锁，使用到的参数是以下结构体指针： 
F_SETLK：在指定的字节范围获取锁（F_RDLCK, F_WRLCK）或者释放锁（F_UNLCK）。如果与另一个进程的锁操作发生冲突，返回 -1并将errno设置为EACCES或EAGAIN。

F_SETLKW：行为如同F_SETLK，除了不能获取锁时会睡眠等待外。如果在等待的过程中接收到信号，会立即返回并将errno置为EINTR。

F_GETLK：获取文件锁信息。

F_UNLCK：释放文件锁。

为了设置读锁，文件必须以读的方式打开。为了设置写锁，文件必须以写的方式打开。为了设置读写锁，文件必须以读写的方式打开。

八. 信号管理 
F_GETOWN, F_SETOWN, F_GETSIG 和 F_SETSIG 被用于IO可获取的信号。

F_GETOWN：获取当前在文件描述词 fd上接收到SIGIO 或 SIGURG事件信号的进程或进程组标识 。

F_SETOWN：设置将要在文件描述词fd上接收SIGIO 或 SIGURG事件信号的进程或进程组标识 。

F_GETSIG：获取标识输入输出可进行的信号。

F_SETSIG：设置标识输入输出可进行的信号。

使用以上命令，大部分时间程序无须使用select()或poll()即可实现完整的异步I/O。

九. 租约（ Leases） 
F_SETLEASE 和 F_GETLEASE 被用于当前进程在文件上的租约。文件租约提供当一个进程试图打开或折断文件内容时，拥有文件租约的进程将会被通告的机制。

F_SETLEASE：根据以下符号值设置或者删除文件租约

1.F_RDLCK设置读租约，当文件由另一个进程以写的方式打开或折断内容时，拥有租约的当前进程会被通告。 
2.F_WRLCK设置写租约，当文件由另一个进程以读或以写的方式打开或折断内容时，拥有租约的当前进程会被通告。 
3.F_UNLCK删除文件租约。

F_GETLEASE：获取租约类型。

十.文件或目录改变通告 
（linux 2.4以上）当fd索引的目录或目录中所包含的某一文件发生变化时，将会向进程发出通告。arg参数指定的通告事件有以下，两个或多个值可以通过或运算组合。 
1.DN_ACCESS 文件被访问 (read, pread, readv) 
2.DN_MODIFY 文件被修改(write, pwrite,writev, truncate, ftruncate) 
3.DN_CREATE 文件被建立(open, creat, mknod, mkdir, link, symlink, rename) 
4.DN_DELETE 文件被删除(unlink, rmdir) 
5.DN_RENAME 文件被重命名(rename) 
6.DN_ATTRIB 文件属性被改变(chown, chmod, utime[s])

返回说明： 
成功执行时，对于不同的操作，有不同的返回值 
F_DUPFD： 新文件描述词 
F_GETFD： 标志值 
F_GETFL： 标志值 
F_GETOWN： 文件描述词属主 
F_GETSIG： 读写变得可行时将要发送的通告信号，或者0对于传统的SIGIO行为

对于其它命令返回0。

失败返回-1，errno被设为以下的某个值 
EACCES/EAGAIN: 操作不被允许，尚未可行 
EBADF: 文件描述词无效 
EDEADLK: 探测到可能会发生死锁 
EFAULT: 锁操作发生在可访问的地址空间外 
EINTR: 操作被信号中断 
EINVAL： 参数无效 
EMFILE: 进程已超出文件的最大可使用范围 
ENOLCK: 锁已被用尽 
EPERM:权能不允许 
struct flock { 
short l_type; /* 锁类型： F_RDLCK, F_WRLCK, F_UNLCK */ 
short l_whence; /* l_start字段参照点： SEEK_SET(文件头), SEEK_CUR(文件当前位置), SEEK_END(文件尾) */ 
off_t l_start; /* 相对于l_whence字段的偏移量 */ 
off_t l_len; /* 需要锁定的长度 */ 
pid_t l_pid; /* 当前获得文件锁的进程标识（F_GETLK） */ 
};

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>

/**********************使能非阻塞I/O********************
*int flags;
*if(flags = fcntl(fd, F_GETFL, 0) < 0)
*{
*    perror("fcntl");
*    return -1;
*}
*flags |= O_NONBLOCK;
*if(fcntl(fd, F_SETFL, flags) < 0)
*{
*    perror("fcntl");
*    return -1;
*}
*******************************************************/

/**********************关闭非阻塞I/O******************
flags &= ~O_NONBLOCK;
if(fcntl(fd, F_SETFL, flags) < 0)
{
    perror("fcntl");
    return -1;
}
*******************************************************/

int main()
{
    char buf[10] = {0};
    int ret;
    int flags;
    
    //使用非阻塞io
    if(flags = fcntl(STDIN_FILENO, F_GETFL, 0) < 0)
    {
        perror("fcntl");
        return -1;
    }
    flags |= O_NONBLOCK;
    if(fcntl(STDIN_FILENO, F_SETFL, flags) < 0)
    {
        perror("fcntl");
        return -1;
    }

    while(1)
    {
        sleep(2);
        ret = read(STDIN_FILENO, buf, 9);
        if(ret == 0)
        {
            perror("read--no");
        }
        else
        {
            printf("read = %d\n", ret);
        }
        
        write(STDOUT_FILENO, buf, 10);
        memset(buf, 0, 10);
    }

    return 0;
}


#include <fcntl.h>

int non_block(int fd){
    int flag;
    flag = fcntl(fd,F_GETFL);
    flag =flag | O_NONBLOCK;
    return fcntl(fd,F_SETFL,flag);
}
将文件描述符设置成非阻塞的应用：socket编程。
// non_block(listenfd);
    conn = accept(listenfd,(struct sockaddr*)&peeraddr,&peerlen);

accept会阻塞在listenfd等待连接到来，如果设置成非阻塞，accept会返回错误：accept: Resource temporarily unavailable
io多路复用（epoll）依赖这个