---
title: index 索引
layout: post
category: storage
author: 夏泽民
---
有时需要索引很长的字符列，它会使索引变大而且变慢。一个策略就是模拟哈希索引。但是有时这也不够好，那？

通常可以索引开始的几个字符，而不是全部值，以节约空间并得到好的性能。这使索引需要的空间变小，但是也会降低选择性。索引选择性是不重复的索引值 和表中所有行的比值。高选择性的索引有好处，因为它使mysql在查找匹配的时候可以过波掉更多的行。唯一索引的选择率为1，为最佳值。

如果索引BLOG和TEXT列，或者很长的varchar列，就必须定义前缀索引，因为mysql不允许索引它们的全文化。

可以在同一个查询中针对许多不同的前缀长度进行计算，选择选择性好的。 【Linux公社 http://www.linuxidc.com 】

(用LEFT函数，left(city,4))

添加前缀索引

mysql>alter table test.test add key (city(7));

前缀索引能很好地减少索引的大小及提高速度，但是mysql不能在order by 和group by查询中使用前缀索引，也不能把它们用伯覆盖索引。

有时后缀索引也挺有用，例如查找某个域名的所有电子邮件地址。mysql不支持反向索引，但是可以把反向字符串保存起来，并且索引它的前缀。可以用触发器维护这种索引

<!-- more -->
局部分区索引又分为两类：

Local prefixed index（局部前缀索引）

Local nonprefixed index（局部非前缀索引）

Ⅰ：局部前缀索引：以分区键作为索引定义的第一列

Ⅱ：局部非前缀索引：分区键没有作为索引定义的第一列

示例语句：

create table local_index_example(

id number(2),

name varchar2 (50),

sex varchar2(10)

)

partition by range (id)

( partition part_1 values less than (5),

partition part_2 values less than (10)

)

--

创建局部前缀索引；分区键（id）作为索引定义的第一列

create index local_prefixed_index

on local_index_example (id, name) local;

--

创建局部非前缀索引；分区键未作为索引定义的第一列

create index local_nonprefixed_index

on local_index_example (name, id) local;

注意：判断局部索引是前缀还是非前缀的只需要看分区键是否作为索引定义的第一列

3. 什么时候该使用前缀索引？什么时候该使用非前缀索引？

对于该使用前缀还是非前缀索引，这完全取决于你的实际需求，你应该尽量从实际角度出发选择合适的索引方式以充分利用到其分区消除的特性。

如果查询首先访问索引的话，它能否实现分区消除完全取决于查询中使用的谓词（即Where筛选条件）；

比如用上面的 local_index_example 表举例，现有两个查询：

①： select … from local_index_example where id = :id and name = :name;

②： select … from local_index_example where name = :name;

对于以上两个查询来说，如果查询第一步是走索引的话，则：

局部前缀索引 local_prefixed_index 只对 ① 有用；

局部非前缀索引 local_nonprefixed_index 则对 ① 和 ② 均有用；

如果你有多个类似 ① 和 ② 的查询的话，则可以考虑建立局部非前缀索引；如果平常多使用查询 ① 的话，则可以考虑建立局部前缀索引；

总之，重点是你要尽可能保证查询包含的谓词允许索引分区消除

  一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，
在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。
说起加速查询，就不得不提到索引了。


索引

    在MySQL中也叫做“键”，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能
非常关键，尤其是当表中的数据量越来越大时，索引对于性能的影响愈发重要。
索引优化应该是对查询性能优化最有效的手段了。索引能够轻易将查询性能提高好几个数量级。
索引相当于字典的音序表，如果要查某个字，如果不使用音序表，则需要从几百页中逐页去查。

1 索引原理

目的  提高查询效率

本质  通过不断地缩小想要获取数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，
      有了这种索引机制，可以总是用同一种查找方式来锁定数据。

2 磁盘IO与预读

磁盘IO和预读，磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，
  寻道时间  指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在5ms以下；
  旋转延迟  就是我们经常听说的磁盘转速，比如一个磁盘7200转，表示每分钟能转7200次，也就是说1秒钟能转120次，
          旋转延迟就是1/120/2 = 4.17ms；

  传输时间 指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。
       一次磁盘的时间，即一次磁盘IO的时间约等于5+4.17 = 9ms左右，听起来还挺不错的，
但 一台500 -MIPS（Million Instructions Per Second）的机器每秒可以执行5亿条指令，


     磁盘IO是非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光把当前磁盘地址的数据，
而是把相邻的数据也都读取到内存缓冲区内，因为 局部预读性原理 告诉我们，当计算机访问一个地址的数据的时候，
与其相邻的数据也会很快被访问到。每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，
一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO，对索引的数据结构设计非常有帮助。


 3 索引的数据结构
  任何一种数据结构都不是凭空产生的，一定会有它的背景和使用场景，要每次查找数据时把磁盘IO次数控制在一个很小的数量级，
  最好是常数数量级。多路搜索树， b+树 应运而生

浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块1包含数据项17和35，包含指针P1、P2、P3，P1表示小于17的磁盘块，P2表示在17和35之间的磁盘块，P3表示大于35的磁盘块。真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。

  b+树的查找过程

如图所示，如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。真实的情况是，3层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。

   b+树性质

 索引字段要尽量的小：

   通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。
 

 索引的最左匹配特性：

  当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特性。

复制代码
3 MySQL索引
复制代码
1 功能

  索引的功能就是加速查找
  mysql中的 primary key，unique，联合唯一也都是索引，这些索引除了加速查找以外，还有约束的功能

2 MySQL常用的索引

普通索引INDEX：加速查找

唯一索引：
    -主键索引PRIMARY KEY：加速查找+约束（不为空、不能重复）
    -唯一索引UNIQUE:加速查找+约束（不能重复）

联合索引：
    -PRIMARY KEY(id,name):联合主键索引
    -UNIQUE(id,name):联合唯一索引
    -INDEX(id,name):联合普通索引
3 索引的两大类型hash与btree
索引类型，分两类
hash类型的索引：查询单条快，范围查询慢
btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它）

不同的存储引擎支持的索引类型也不一样
InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引；
Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引；
NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引；
Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引；

4 创建/删除索引的语法
  1   ：创建表时
    　　CREATE TABLE 表名 (
                字段名1  数据类型 [完整性约束条件…],
                字段名2  数据类型 [完整性约束条件…],
                [UNIQUE | FULLTEXT | SPATIAL ]   INDEX | KEY
                [索引名]  (字段名[(长度)]  [ASC |DESC]) 
                );


 2   ： CREATE在已存在的表上创建索引
        CREATE  [UNIQUE | FULLTEXT | SPATIAL ]  INDEX  索引名 
                     ON 表名 (字段名[(长度)]  [ASC |DESC]) ;


 3    ：ALTER TABLE在已存在的表上创建索引
        ALTER TABLE 表名 ADD  [UNIQUE | FULLTEXT | SPATIAL ] INDEX
                             索引名 (字段名[(长度)]  [ASC |DESC]) ;
                             
#删除索引：DROP INDEX 索引名 ON 表名字;
5 创建索引时需要注意：
     ===  1 选择区分度高的字段作为 索引 字段
     ===  2 范围 ，条件不明确的 有索引 速度也会很慢
     ===  3 索引字段 不能 通过 *10 avg() 查询
     ===  4  最左前缀 --联合索引 (a,b,c,d)
     重复性高的 字段( name ,gender )不要加索引
     范围大的  索引 速度 会很慢
     like '%xx' % 在左边 索引会很慢 要从头到尾先查询一遍
     用 name, id 字段 作为 索引的 只能 用 本来的字段进行查询 (不能用 id*10, avg(id) 等来查询)
     and 左右条件  会先找 有索引的 查
     or  会按顺序找
     a,b,c,d ==== 联合索引 (a=1,b=1,d=2,c>3)   范围放到最后---最左前缀匹配
            select * from s1 where a=3,b=5,c>3,d=6 (先找 区分度高的 索引)

1. 一定是为搜索条件的字段创建索引，比如select * from s1 where id = 333; 就需要为id加上索引

2.   在表中已经有大量数据的情况下，建索引会很慢，且占用硬盘空间，建完后查询速度加快
  比如create index idx on s1(id);会扫描表中所有的数据，然后以id为数据项，创建索引结构，存放于硬盘的表中。
  建完以后，再查询就会很快了。

3. innodb表的索引 会存放于s1.ibd文件中，而 myisam表的索引 则会有单独的索引文件table1.MYI
  innodb 引擎  --- frm + idb(数据+索引)
  myisam 引擎 ---- frm + myd + myi (数据与索引分离)
MySAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在innodb中，表数据文件本身就是按照B+Tree
（BTree即Balance True）组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，
因此innodb表数据文件本身就是主索引。

   因为inndob的数据文件要按照主键聚集，所以innodb要求表必须要有主键（Myisam可以没有），如果没有显式定义，
则mysql系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则mysql会自动为innodb表生成一个
隐含字段作为主键，这字段的长度为6个字节，类型为长整型.
复制代码
4 正确使用索引
一 索引未命中

并不是说我们创建了索引就一定会加快查询速度，若想利用索引达到预想的提高查询速度的效果，我们在添加索引时，必须遵循以下问题

1 范围问题，或者说条件不明确，条件中出现这些符号或关键字：>、>=、<、<=、!= 、between...and...、like、

大于号、小于号



不等于！=



between ...and...



like





2 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录



3 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

4 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)



5 and/or

复制代码
复制代码
#注意：
条件1 and 条件2:查询原理是：首先条件1与条件2都成立的前提下，才算匹配成功一条记录；其次mysql会按先优先判断索引字段的条件,如果按照该条件为真，但锁定的范围很小，或者干脆为假，那我们即便是没有为其他条件的字段添加索引，最终的结果仍然很快

#例如：
若条件1的字段有索引，而条件2的字段没有索引，那么如果在按照条件1查出的结果很少的情况下，即便我们没有为条件2创建索引，最终的查询速度依然很快

若条件1的字段没有索引，而条件2的字段有索引，那么如果在按照条件2查出的结果很少的情况下，即便我们没有为条件1创建索引，最终的查询速度依然很快
复制代码
复制代码


在左边条件成立但是索引字段的区分度低的情况下（name与gender均属于这种情况），会依次往右找到一个区分度高的索引字段，加速查询





经过分析，在条件为name='egon' and gender='male' and id>333 and email='xxx'的情况下，我们完全没必要为前三个条件的字段加索引，因为只能用上email字段的索引，前三个字段的索引反而会降低我们的查询效率



6 最左前缀匹配原则，非常重要的原则，对于组合索引mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配(指的是范围大了，有索引速度也慢)，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。



7 其他情况

复制代码
 使用函数
    select * from tb1 where reverse(email) = 'egon';
            
- 类型不一致
    如果列是字符串类型，传入条件是必须用引号引起来，不然...
    select * from tb1 where email = 999;
    
#排序条件为索引，则select字段必须也是索引字段，否则无法命中
- order by
    select name from s1 order by email desc;
    当根据索引排序时候，select查询的字段如果不是索引，则速度仍然很慢
    select email from s1 order by email desc;
    特别的：如果对主键排序，则还是速度很快：
        select * from tb1 order by nid desc;
 
- 组合索引最左前缀
    如果组合索引为：(name,email)
    name and email       -- 命中索引
    name                 -- 命中索引
    email                -- 未命中索引


- count(1)或count(列)代替count(*)在mysql中没有差别了

- create index xxxx  on tb(title(19)) #text类型，必须制定长度
复制代码
其他注意事项

复制代码
复制代码
- 避免使用select *
- count(1)或count(列) 代替 count(*)
- 创建表时尽量时 char 代替 varchar
- 表的字段顺序固定长度的字段优先
- 组合索引代替多个单列索引（经常使用多个条件查询时）
- 尽量使用短索引
- 使用连接（JOIN）来代替子查询(Sub-Queries)
- 连表时注意条件类型需一致
- 索引散列值（重复少）不适合建索引，例：性别不适合
复制代码
复制代码
三 覆盖索引与索引合并

复制代码
复制代码
#覆盖索引：
    - 所有字段（条件的，查询结果的等）都是索引字段
    http://blog.itpub.net/22664653/viewspace-774667/

#分析
select age from s1 where id=123 and name = 'egon'; #id字段有索引，但是name字段没有索引
该sql命中了索引，但未覆盖全部。
利用id=123到索引的数据结构中定位到了id字段，但是仍要判断name字段，但是name字段没有索引，而且查询结果的字段age也没有索引
最牛逼的情况是，索引字段覆盖了所有，那全程通过索引来加速查询以及获取结果就ok了
复制代码
复制代码
 

复制代码
复制代码
#索引合并：把多个单列索引合并使用

#分析：
组合索引能做到的事情，我们都可以用索引合并去解决，比如
create index ne on s1(name,email);#组合索引
我们完全可以单独为name和email创建索引，然后按照where name='xxx' and email='xxx'使用 #索引合并

组合索引可以命中：
select * from s1 where name='egon' ;
select * from s1 where name='egon' and email='adf';

索引合并可以命中：
select * from s1 where name='egon' ;
select * from s1 where email='adf';
select * from s1 where name='egon' and email='adf';

乍一看好像索引合并更好了：可以命中更多的情况，但其实要分情况去看，如果是name='egon' and email='adf',那么组合索引的效率要高于索引合并，如果是单条件查，那么还是用索引合并比较合理
复制代码
复制代码
 
5 查询优化神器-explain
关于explain命令相信大家并不陌生，具体用法和字段含义可以参考官网explain-output，这里需要强调rows是核心指标，绝大部分rows小的语句执行一定很快（有例外，下面会讲到）。所以优化语句基本上都是在优化rows。

复制代码
复制代码
执行计划：让mysql预估执行操作(一般正确)
    all < index < range < index_merge < ref_or_null < ref < eq_ref < system/const
    id,email
    
    慢：
        select * from userinfo3 where name='alex'
        
        explain select * from userinfo3 where name='alex'
        type: ALL(全表扫描)
            select * from userinfo3 limit 1;
    快：
        select * from userinfo3 where email='alex'
        type: const(走索引)
复制代码
复制代码
http://blog.itpub.net/29773961/viewspace-1767044/

 
6 慢查询优化的基本步骤
复制代码
复制代码
0.先运行看看是否真的很慢，注意设置SQL_NO_CACHE
1.where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
2.explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
3.order by limit 形式的sql语句让排序的表优先查
4.了解业务方使用场景
5.加索引时参照建索引的几大原则
6.观察结果，不符合预期继续从0分析
复制代码
复制代码
 
7 慢日志管理
复制代码
复制代码
        慢日志
            - 执行时间 > 10
            - 未命中索引
            - 日志文件路径
            
        配置：
            - 内存
                show variables like '%query%';
                show variables like '%queries%';
                set global 变量名 = 值
            - 配置文件
                mysqld --defaults-file='E:\wupeiqi\mysql-5.7.16-winx64\mysql-5.7.16-winx64\my-default.ini'
                
                my.conf内容：
                    slow_query_log = ON
                    slow_query_log_file = D:/....
                    
                注意：修改配置文件之后，需要重启服务