---
title: JSON转换成Go的struct
layout: post
category: golang
author: 夏泽民
---
https://mholt.github.io/json-to-go/
https://github.com/mholt/json-to-go
https://github.com/mailru/easyjson
https://github.com/xeipuuv/gojsonschema
 在左侧粘贴一个JSON结构，右侧将生成相应的Go类型，您可以将其粘贴到程序中。
json
{
 
"code": "FRONTEND_REQ",
 
"name": "AddUserAddressApi",
 
"status": 200,
 
"success": true,
 
"msg": "",
 
"version": "v0.1",
 
"data": {
 
}
}
生成的struct
type AutoGenerated struct {
	Code    string `json:"code"`
	Name    string `json:"name"`
	Status  int    `json:"status"`
	Success bool   `json:"success"`
	Msg     string `json:"msg"`
	Version string `json:"version"`
	Data    struct {
	} `json:"data"`
}
<!-- more -->
http://json2struct.mervine.net/
https://github.com/usthooz/json2go

https://github.com/mailru/easyjson

项目里面需要爬虫去爬高德地图，高德地图的返回json结果里面有时候字段对应值是字符串，有时候对应结果是[]一对中括号，代表结果为空，使用golang自带的json解析工具折腾半天，最后一查资料据说是性能最差的，说某东用的是easyjson去解析处理json文件，大概记录一下处理过程及遇到的坑。

 

1.easyjson的使用

   easyjson提供了一个命令行的工具，可以根据.go源码内的struct自动生成一个代理调用类文件，大概使用过程是先

go get -u github.com/mailru/easyjson
把它下载回来，然后

go install  github.com/mailru/easyjson/easyjson
自动编译安装到%GOPATH%\bin目录下面，需要生成代理代码需要你的项目里面有与json对应的struct，这个见下面的处理过程。

 

2.高德地图官方有在线的调试工具，可以根据参数返回json格式的查询结果，拿到结果以后我最初是手敲代码挨个去对应json文件字段的，其实有全自动的方法，就是访问https://mholt.github.io/json-to-go/ 这个网址，把json文件复制进去，自动就生成好了golang的struct，复制到项目里面，运行easyjson的自动生成代码命令生成项目内的代理代码：

easyjson -all models.go 
以上我是把网站里面生成的代码保存为我本机的models.go里面了，自动生成的文件叫做models_easyjson.go，这里面有序列号反序列化的代码。

 

3.第二步生成的代码去接收高德地图返回的json结果还是有些问题，就是个别字段有值的时候是字符串，没有值的时候是空[]结果的情况，解决办法是把原来的

Tel      []interface{}   `json:"tel"`
改为

Tel      interface{}   `json:"tel"`
就好了。


golang校验json数据内容

ackage main

import (
    "fmt"
    "github.com/xeipuuv/gojsonschema"
)

func main() {

    schemaLoader := gojsonschema.NewStringLoader(`{"type": "object","properties":{"a":{"type":"object"}},"required":["a"]}`) // json格式
    documentLoader := gojsonschema.NewStringLoader(`{"a":"b"}`) // 待校验的json数据

    result, err := gojsonschema.Validate(schemaLoader, documentLoader)
    if err != nil {
        panic(err.Error())
    }

    if result.Valid() {
        fmt.Printf("The document is valid\n")
    } else {
        fmt.Printf("The document is not valid. see errors :\n")
        for _, desc := range result.Errors() {
            fmt.Printf("- %s\n", desc)
        }
    }
}
参考：

https://github.com/xeipuuv/gojsonschema
https://www.cnblogs.com/huanghongbo/p/8628607.html
https://blog.csdn.net/ccq1127/article/details/88061531


https://github.com/atombender/go-jsonschema
https://javascript.ctolib.com/atombender-go-jsonschema.html

https://github.com/a-h/generate
https://ask.csdn.net/questions/1040738?sort=id

https://github.com/xeipuuv/gojsonschema

JSON Schema定义了JSON格式的规范，各种语言都有开源的第三方JSON Schema校验库，例如Go语言的gojsonschema，这样我们就可以定义一份JSON Schema，然后系统的各个模块都可以复用这套JSON规范，不满足规则的数据JSON Schema会直接报错。

语法说明
JSON Schema作为JSON的规范样式，自身也有一套key-value语法用于声明各种规则。

key	value	备注
$schema	
http://json-schema.org/draft-04/schema#

http://json-schema.org/draft-06/schema#

http://json-schema.org/draft-07/schema#

说明是哪个版本的JSON Schema，不同版本间不完全兼容
type	
string、number、integer、boolean、object等

例如{"type":"integer"}说明该字段一定要是整形

说明字段的类型
 pattern	 
{
 　　"type": "string",
　　 "pattern": "^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$"
}

 正则表达式
 enum	 {
　　"type": "string",
　　"enum": ["red", "amber", "green"]
}

 枚举类型
 properties	
 说明该JSON对象有哪些属性/字段

"properties": {
　　"street_address": { "type": "string" },
　　"city": { "type": "string" },
　　"state": { "type": "string" }
},

 属性字段
 definitions	
 通常搭配$ref一起说明使用

{ "$ref": "#/definitions/address" }

 自定义字段
 $ref	 通常用于复杂说明	 引用字段
 required	 "required": ["street_address", "city", "state"]	 必须字段
 oneof	 
{
"oneOf": [
　　{ "type": "number", "multipleOf": 5 },
　　{ "type": "number", "multipleOf": 3 }
]
}

// 10 yes

// 9 yes

// 2 no

 满足其中一个
 allof	 
{
"allOf": [
　　{ "type": "string" },
　　{ "maxLength": 5 }
]
}

// "short" yes

// "too long" no

 满足全部
 multipleOf	 { "type": "number", "multipleOf": 5 },	 倍数
 not	
{ "not": { "type": "string" } }

// 42 yes

//"hello" no 

 取反
 array	
{
"type": "array",
　　"items": {
　　"type": "number"
　　}
}

 数组
 propertyNames	 正则字符串	 定义key的正则规则
 patternProperties	 
{
"type":"object",
"patternProperties":{
　　"^S_":{"type":"string"}
　}
}

 同时限定key和value
 additionalProperties	 boolean	是否允许有格外的属性 
 dependencies	
{
"type":"object",
　　"properties":{
　　　　"name":{"type":"string"},
　　　　"age":{"type":"number"}
},
"dependencies":{
　　"gender":["age"]
}
}

// { "gender":"male" } no
// { "gender":"male", "age":18 } yes

 属性间依赖关系
 uniqueItems	 boolean	 数组元素是否唯一
 minProperties/maxProperties	 number	 最小/大属性个数


https://www.cnblogs.com/makelu/p/11828274.html

https://www.kutu66.com//GitHub/article_116767
https://github.com/alecthomas/jsonschema
https://github.com/xeipuuv/gojsonschema
https://github.com/atombender/go-jsonschema
