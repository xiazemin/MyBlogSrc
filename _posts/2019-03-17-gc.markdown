---
title: gc
layout: post
category: golang
author: 夏泽民
---
垃圾回收方法
引用计数（reference counting）
这是最简单的一种垃圾回收算法，和之前提到的智能指针异曲同工。对每个对象维护一个引用计数，当引用该对象的对象被销毁或更新时被引用对象的引用计数自动减一，当被引用对象被创建或被赋值给其他对象时引用计数自动加一。当引用计数为0时则立即回收对象。

这种方法的优点是实现简单，并且内存的回收很及时。这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，如ios cocoa框架，php，python等。简单引用计数算法也有明显的缺点：

频繁更新引用计数降低了性能。一种简单的解决方法就是编译器将相邻的引用计数更新操作合并到一次更新；还有一种方法是针对频繁发生的临时变量引用不进行计数，而是在引用达到0时通过扫描堆栈确认是否还有临时对象引用而决定是否释放。等等还有很多其他方法，具体可以参考这里。
循环引用问题。当对象间发生循环引用时引用链中的对象都无法得到释放。最明显的解决办法是避免产生循环引用，如cocoa引入了strong指针和weak指针两种指针类型。或者系统检测循环引用并主动打破循环链。当然这也增加了垃圾回收的复杂度。
标记-清除（mark and sweep）
该方法分为两步，标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。这种方法解决了引用计数的不足，但是也有比较明显的问题：每次启动垃圾回收都会暂停当前所有的正常代码执行，回收是系统响应能力大大降低！当然后续也出现了很多mark&sweep算法的变种（如三色标记法）优化了这个问题。

分代收集（generation）
经过大量实际观察得知，在面向对象编程语言中，绝大多数对象的生命周期都非常短。分代收集的基本思想是，将堆划分为两个或多个称为 代（generation）的空间。新创建的对象存放在称为 新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多），随着垃圾回收的重复执行，生命周期较长的对象会被 提升（promotion）到老年代中。因此，新生代垃圾回收和老年代垃圾回收两种不同的垃圾回收方式应运而生，分别用于对各自空间中的对象执行垃圾回收。新生代垃圾回收的速度非常快，比老年代快几个数量级，即使新生代垃圾回收的频率更高，执行效率也仍然比老年代垃圾回收强，这是因为大多数对象的生命周期都很短，根本无需提升到老年代。

GO的垃圾回收器
go语言垃圾回收总体采用的是经典的mark and sweep算法。
<!-- more -->
就是先标记出需要回收的内存对象快，然后在清理掉；

在这里不介绍标记和清理的具体策略（可以参考https://lengzzz.com/note/gc-in-golang），只介绍 GC过程是怎么调度的以及stw相关

这个算法，会导致 stw (stop the world)的问题，中断用户逻辑

触发GC机制

1.    在申请内存的时候，检查当前当前已分配的内存是否大于上次GC后的内存的2倍，若是则触发（主GC线程为当前M）

2.    监控线程发现上次GC的时间已经超过两分钟了，触发；将一个G任务放到全局G队列中去。（主GC线程为执行这个G任务的M）

 

每当触发的时候，在主GC线程中就会走如下的GC流程：

1.    stop the world，等待所有的M休眠；此时所有的业务逻辑代码都停止

2.    标记：分配gc标记任务，唤醒 gcproc个 M（就是第一步休眠的那些），分别做这个，直到所有的M都做完，才结束；并且所有M再次进入休眠

3.    清理：有一个单独的goroutine去清理已经标记的内存对象快

4.    start the world，设置gcwaiting=0，唤醒所有的M（不会超过P个数）

 

对于上面的三个步骤，分别解释：

stop the world：

1.    设置gcwaiting=1，这个在每一个G任务之前会检查一次这个状态，如是，则会将当前M休眠；

2.    如果这个M里面正在运行一个长时间的G任务，咋办呢，难道会等待这个G任务自己切换吗？这样的话可要等10ms啊，不能等！坚决不能等！
所以会主动发出抢占标记（类似于上一篇），让当前G任务中断，再运行下一个G任务的时候，就会走到第1步

3.    一直等待所有的M进入休眠，此时所有的业务逻辑代码都停止

标记：

1.     根据gcproc的个数，分配成gcproc任务段；唤醒gcproc-1个M来执行（当前M也算一个）

2.    对于一个M，唤醒前设置它的helpgc标记，唤醒之后这个M会立马判断这个标记，如是，则开始做分配给自己的标记任务，如果先做完了，就会从别的M里面找一些来做

3.    等每一个M都做完，会再次进入休眠

清理：

1.    通过设置参数，可以以一个单独goroutine  运行，这个功能是在1.3版本之后增加的，这样的话就直接到下一步了，清理过程不是stw的

2.    也可以串行的在主GC线程执行；这样的话则清理过程也是stw的，

start the world：

1.    设置gcwaiting=0

2.    唤醒P个M来继续做G任务（此时没有helpgc标记），业务逻辑代码开始
综上：

是基于1.4版本的，GC过程在标记过程是（STW）的

在1.5版本里面对GC做了很大的优化；采用三色标记，将标记过程细化成三段，只有前后的两段是stw的；极大地缩短了gc的stw时间
