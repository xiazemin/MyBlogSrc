---
title: go中的引用类型
layout: post
category: golang
author: 夏泽民
---
首先，go中的赋值，都是值传递
a := 1
b := a

x := Struct{}
y := x
复制代码他们都是在内存中有独立空间的，也就是copy的过程，所以这里对y的某个属性的改动，并不会影响x
那么我们要让两个变量指向同一个内存怎么办呢，可以使用引用类型：
y := &x
复制代码这时候，y的类型是*Struct，这时候我们可以对y进行修改，修改完之后，x也会发现变化，因为y现在是一个引用类型，他指向的是x结构体所在的内存
我们可以通过:
y.variable = xxx
复制代码来直接调用引用类型的结构体赋值，但是要注意的是，这是go的语法糖，他只是帮助我们简化了通过指针来获取实际内存的过程，完整的写法应该是这样的：
(*y).variable = xxx
复制代码*y是对指针的反引用，可以理解为*y == x。
为什么设计这个语法糖呢，是因为在go里面我们是无法直接操作指针，像c++中直接对内存地址进行计算进而得到其他内存地址的运算，在go里面是默认不支持的
print(y) // 得到类似0x8123这样的内存地址数据

// 理论上可以得到一个新的内存地址，但是在go里默认是不支持的
newAddr := y + 4
复制代码因为无法直接操作地址，所以go就提供语法糖，让我们在使用引用类型进行操作的时候，默认就是对引用所指向的内存地址进行操作。
<!-- more -->
注意我们是可以对引用类型直接赋值的，但是赋值的类型也必须是引用类型
y = &Struct{} // 这样是可以的，但是不能是y = Struct{}

a := 1
b := &a
b = 2  // 这是不行的，因为b的类型是 *int
复制代码特殊的引用类型
能够通过make()函数创建的都是引用类型，比如slice和map，slice虽然看起来像数组，但是他其实是一个指向数组内存空间的一个指针类型
type Slice struct {
    point Point // 内存地址
    len int
    cap int
}
复制代码所以我们在执行：
a := []int
b = a
复制代码会发现，好像b和a指向的是同一个数组，事实确实如此。go中所有的赋值都是值传递，而slice的赋值，也是对slice对象的一次拷贝，也就是说a和b是不同的slice对象，但是他们指向同一个数组
同理map也是如此
