---
title: virtual(虚函数) vtbl(虚函数表)与vptr(虚函数表指针)
layout: post
category: linux
author: 夏泽民
---
虚 函数（Virtual Function）    虚函数表（Virtual Table）vtbl                         vptr(虚函数表指针)  virtual pointer
类的虚函数表是一块连续的内存，每个内存单元中记录一个JMP指令的地址
  注意的是，编译器会为每个有虚函数的类创建一个虚函数表，该虚函数表将被该类的所有对象共享。类的每个虚成员占据虚函数表中的一行。如果类中有N个虚函数，那么其虚函数表将有N*4字节的大小。   虚 函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主要是一个类 的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当 用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。   编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着可以通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。
<!-- more -->
在方法定义时加上virtual，表示此方法是虚拟方法，可供子类覆盖，修改父类的执行 

构造函数不能用虚拟，因为用也没用，不管是在栈上构造对象，还是在堆上构造对象，也不管你以后是否使用父类的指针或引用来指向或引用这个对象，在构造的那“一瞬间”，总归要指明要构造对象的具体类型，所以，对象在构造过程中不存在运行时动态绑定的多态行为。 

例子，假如A是B的父类， 
A* p = new B(); 
则对于虚拟函数f，可以通过A类的指针p直接调用到B类的函数，这就是运行时的多态： 
p->f(); 
B类的对象却必须通过“A* p = new B();”来构造，显然不能通过“A* p = new A();”来构造一个B类对象——这是荒唐的，这只能构造一个A类的对象。所以构造函数虚拟无意义。 
但析构函数就不同了，p明明是个A类的指针，如果析构函数不是虚拟的，那么，你后面就必须这样才能安全的删除这个指针： 
delete (B*)p; 

但如果构造函数是虚拟的，就可以在运行时动态绑定到B类的析构函数，直接： 
delete p; 
就可以了。这就是虚析构函数的作用。而事实上，在运行时，你并不是总是能知道p所指对象的实际类型从而进行强制转换，所以，C++语言既然要支持多态，也就必须支持虚拟析构。 

编 译器总是根据类型来调用类成员函数。但是一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++不管这个指针指向一个基 类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于派生类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资 源泄漏。 

所以建议的方式是将析构函数声明为虚函数。如果你使用MFC，并且以CObject或其派生类为基类，那么MFC已经为你做了 这件事情；CObject的析构函数是虚函数。一个函数一旦声明为虚函数，那么不管你是否加上virtual 修饰符，它在所有派生类中都成为虚函数。但 是由于理解明确起见，建议的方式还是加上virtual 修饰符。 

C++不把虚析构函数直接作为默认值的原因是虚函数表的开销以及和C 语言的类型的兼容性。有虚函数的对象总是在开始的位置包含一个隐含的虚函数表指针成员。如果是对于MFC类CPoint和CSize这样的小型类，增加一 个指针就增加了很多内存占用，而且使得其内存表示和基类POINT和SIZE不一致。如果两个类的内存表示一致，那么这样你可以安全地把一个类的指针或数 组当作另一个类的指针或数组使用。 

通过基类的指针去删除派生类的对象，而基类又没有虚析构函数时，结果将是不可确定的。这意味着编译器 生成的代码将会做任何它喜欢的事：重新格式化你的硬盘，给你的老板发电子邮件，把你的程序源代码传真给你的对手，无论什么事都可能发生。（实际运行时经常 发生的是，派生类的析构函数永远不会被调用。 

实现虚函数需要对象附带一些额外信息，以使对象在运行时可以确定该调用哪个虚函数。对大多 数编译器来说，这个额外信息的具体形式是一个称为vptr（虚函数表指针）的指针。vptr指向的是一个称为vtbl（虚函数表）的函数指针数组。每个有 虚函数的类都附带有一个vtbl。当对一个对象的某个虚函数进行请求调用时，实际被调用的函数是根据指向vtbl的vptr在vtbl里找到相应的函数指 针来确定的。 

虚函数实现的细节不重要,但基类中最好成绩要有.此时就有基本的一条是，无故的声明虚析构函数和永远不去声明一样是错误的。实际上，很多人这样总结：当且仅当类里包含至少一个虚函数的时候才去声明虚析构函数。

对象模型
​ 当一个类本身定义了虚函数，或其父类有虚函数时，为了支持多态机制，编译器将为该类添加一个虚函数指针(vptr）。虚函数指针一般都放在对象内存布局的第一个位置上，这是为了保证在多层继承或多重继承的情况下能以最高效率取到虚函数表。当vprt位于对象内存最前面时，对象的地址即为虚函数指针地址。发生动态绑定时，编译器根据虚指针找到相应的虚函数来执行。

​ 非静态数据成员被配置在每一个类对象之内，静态数据成员、静态和非静态函数被放在类对象之外。虚函数则由下面两个步骤支持：

每个类产生出一堆指向虚函数的指针，放在虚表vptl中。
每个类对象被安插一个虚指针vptr，指向相关的虚表vptl。vptr的设置与重置有每一个类的构造函数、析构函数和拷贝复制运算符自动完成。
<img src="{{site.url}}{{site.baseurl}}/img/vptr_vtabl.png"/>


1.vptr虚指针，vtbl虚函数表

先看看示例代码：

class A
{
public:
    virtual void vfunc1();
    virtual void vfunc2();
    void func1();
    void func2();
private:
    int m_data1,m_data2;
 
};
class B:public A
{
public:
    virtual void vfunc1();
    void func2();
private:
    int m_data3;
};
class C:public B
{
public:
    virtual void vfunc1();
    void func2();
private:
    int m_data1,m_data4;
 
};
可以直到B继承A，C继承B。
并且注意虚函数，如果我这个类里面有虚函数，那么我这个对象里面肯定会多4字节的指针vptr。

继承不仅会继承里面的数据，也会继承里面的函数的调用权，而不是继承函数的内存大小。

所以得出：父类有虚函数，子类一定也有虚函数。

  2.虚函数在内存中长什么样子？

可以看到B继承了A中的vfunc1()与vfunc2()。但是B推翻了A的vfunc1()。类推C也是一样。

从三段代码中可以看到有四个非虚函数：A::func1() A::func2() B::func2() C::func2() 

有四个虚函数：A::vfunc1()  A::vfunc2()  B::vfunc1()  C::vfunc1() 

那么这些函数各自当然占用了内存中的一块。

  3.vptr指针怎么关联这四个虚函数的？

vptr指向vtbl。

先说说这个vtbl中放的是什么？放的是虚函数的地址！


假如我们有一个指针指向c，通过指针去调用虚函数。这是动态绑定。

在C里面，编译器要去实现指针去调用函数，就会用CALL去调用某个函数，将来再return回来，这叫做静态绑定。

动态绑定过程：通过P指针来找到vptr再找到vtbl再从里面找指向的虚函数。

（*(p->vptr)[n])(p);
n就代表vtbl中第几个虚函数。这个n主要看编译器来看你写的代码虚函数在第几个，从0开始。
  4.如果要让一个容器来装某个类，如果这个类是一个形状类，它可能有各种形状，那么它的大小就不一样。

但是容器中肯定是需要存放大小相同的东西。那肯定是存放指针是最好的。

那这个draw()函数一定要是虚函数。

  5.静态绑定和动态绑定理解

静态绑定是C风格中典型的一种，一般是CALL XXXX return XXXX

动态绑定一般需要符合几个条件：第一需要一个指针来调用 第二这个指针必须是要向上转型 第三调用虚函数 符合这三个条件

编译器就会进行动态绑定，这种也叫做虚机制。这个指针调用的是什么需要看P指向哪个对象，它调用的对象就不一样，所以叫做

动态绑定，然而CALL是固定的调用某个地址。

  6.虚函数的这种用法，叫做多态！！！
