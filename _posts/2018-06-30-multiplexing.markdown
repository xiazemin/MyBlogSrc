---
title: multiplexing IO多路复用
layout: post
category: linux
author: 夏泽民
---
1 基础知识回顾
注意：咱们下面说的都是Linux环境下，跟Windows不一样哈~~~

1.1 用户空间和内核空间
　　现在操作系统都采用虚拟寻址，处理器先产生一个虚拟地址，通过地址翻译成物理地址（内存的地址），再通过总线的传递，最后处理器拿到某个物理地址返回的字节。

　　对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。

补充：地址空间就是一个非负整数地址的有序集合。如{0,1,2...}。

1.2 进程上下文切换（进程切换）
　　为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换（也叫调度）。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。

　　从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：
　　1. 保存当前进程A的上下文。

　　上下文就是内核再次唤醒当前进程时所需要的状态，由一些对象（程序计数器、状态寄存器、用户栈等各种内核数据结构）的值组成。

　　这些值包括描绘地址空间的页表、包含进程相关信息的进程表、文件表等。
　　2. 切换页全局目录以安装一个新的地址空间。

　　　　...
　　3. 恢复进程B的上下文。

　　可以理解成一个比较耗资源的过程。

1.3 进程的阻塞
　　正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。

1.4 文件描述符
　　文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。

　　文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。

1.5 直接I/O和缓存I/O
　　缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，以write为例，数据会先被拷贝进程缓冲区，在拷贝到操作系统内核的缓冲区中，然后才会写到存储设备中。

缓存I/O的write：



直接I/O的write：（少了拷贝到进程缓冲区这一步）



 

write过程中会有很多次拷贝，知道数据全部写到磁盘。好了，准备知识概略复习了一下，开始探讨IO模式。

 

回到顶部
2 I/O模式
　　对于一次IO访问（这回以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的缓冲区，最后交给进程。所以说，当一个read操作发生时，它会经历两个阶段：
　　1. 等待数据准备 (Waiting for the data to be ready)
　　2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)

正式因为这两个阶段，linux系统产生了下面五种网络模式的方案：
　　-- 阻塞 I/O（blocking IO）
　　-- 非阻塞 I/O（nonblocking IO）
　　-- I/O 多路复用（ IO multiplexing）
　　-- 信号驱动 I/O（ signal driven IO）
　　-- 异步 I/O（asynchronous IO）

　　注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO 模型。

2.1 block I/O模型（阻塞I/O）
阻塞I/O模型示意图：



read为例：

（1）进程发起read，进行recvfrom系统调用；

（2）内核开始第一阶段，准备数据（从磁盘拷贝到缓冲区），进程请求的数据并不是一下就能准备好；准备数据是要消耗时间的；

（3）与此同时，进程阻塞（进程是自己选择阻塞与否），等待数据ing；

（4）直到数据从内核拷贝到了用户空间，内核返回结果，进程解除阻塞。

也就是说，内核准备数据和数据从内核拷贝到进程内存地址这两个过程都是阻塞的。

 

2.2 non-block（非阻塞I/O模型）
可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：

 

　　

　　（1）当用户进程发出read操作时，如果kernel中的数据还没有准备好；

　　（2）那么它并不会block用户进程，而是立刻返回一个error，从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果；

　　（3）用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call；

　　（4）那么它马上就将数据拷贝到了用户内存，然后返回。

　　所以，nonblocking IO的特点是用户进程在内核准备数据的阶段需要不断的主动询问数据好了没有。

 

2.3 I/O多路复用
　　　　I/O多路复用实际上就是用select, poll, epoll监听多个io对象，当io对象有变化（有数据）的时候就通知用户进程。好处就是单个进程可以处理多个socket。当然具体区别我们后面再讨论，现在先来看下I/O多路复用的流程：



　　（1）当用户进程调用了select，那么整个进程会被block；

      （2）而同时，kernel会“监视”所有select负责的socket；

　　（3）当任何一个socket中的数据准备好了，select就会返回；

　　（4）这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。

　　所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。

　　这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。

　　所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用多线程 + 阻塞 IO的web server性能更好，可能延迟还更大。

　　select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）

　　在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。

 

 2.4 asynchronous I/O（异步 I/O）

　　真正的异步I/O很牛逼，流程大概如下：



（1）用户进程发起read操作之后，立刻就可以开始去做其它的事。

（2）而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。

（3）然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。

 

2.5 小结
（1）blocking和non-blocking的区别
　　调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。

（2）synchronous IO和asynchronous IO的区别
　　在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：
　　　　- A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;
　　　　- An asynchronous I/O operation does not cause the requesting process to be blocked;

　　两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。

　　有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。

　　而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。

（3）non-blocking IO和asynchronous IO的区别

　　可以发现non-blocking IO和asynchronous IO的区别还是很明显的。

　　--在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。

　　--而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。

 

回到顶部
3 事件驱动编程模型
3.1论事件驱动
　　通常，我们写服务器处理模型的程序时，有以下几种模型：
　　　　（1）每收到一个请求，创建一个新的进程，来处理该请求；
　　　　（2）每收到一个请求，创建一个新的线程，来处理该请求；
　　　　（3）每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求
　　上面的几种方式，各有千秋：
　　　　第（1）中方法，由于创建新的进程:实现比较简单，但开销比较大，导致服务器性能比较差。
　　　　第（2）种方式，由于要涉及到线程的同步，有可能会面临死锁等问题。
　　　　第（3）种方式，在写应用程序代码时，逻辑比前面两种都复杂。
　　综合考虑各方面因素，一般普遍认为第（3）种方式是大多数网络服务器采用的方式。
 
3.2 看图说话讲事件驱动模型
　　在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？
　　方式一：创建一个线程，该线程一直循环检测是否有鼠标点击，那么这个方式有以下几个缺点：
　　　　1. CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，这会造成很多的CPU资源浪费；如果扫描鼠标点击的接口是阻塞的呢？
　　　　2. 如果是堵塞的，又会出现下面这样的问题，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；
　　　　3. 如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题；
　　所以，该方式是非常不好的。

方式二：就是事件驱动模型
　　目前大部分的UI编程都是事件驱动模型，如很多UI平台都会提供onClick()事件，这个事件就代表鼠标按下事件。事件驱动模型大体思路如下：
　　　　1. 有一个事件（消息）队列；
　　　　2. 鼠标按下时，往这个队列中增加一个点击事件（消息）；
　　　　3. 有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；
　　　　4. 事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；



　　事件驱动编程是一种网络编程范式，这里程序的执行流由外部事件来决定。它的特点是包含一个事件循环，当外部事件发生时使用回调机制来触发相应的处理。另外两种常见的编程范式是（单线程）同步以及多线程编程。

　　让我们用例子来比较和对比一下单线程、多线程以及事件驱动编程模型。下图展示了随着时间的推移，这三种模式下程序所做的工作。这个程序有3个任务需要完成，每个任务都在等待I/O操作时阻塞自身。阻塞在I/O操作上所花费的时间已经用灰色框标示出来了。



　　在单线程同步模型中，任务按照顺序执行。如果某个任务因为I/O而阻塞，其他所有的任务都必须等待，直到它完成之后它们才能依次执行。这种明确的执行顺序和串行化处理的行为是很容易推断得出的。如果任务之间并没有互相依赖的关系，但仍然需要互相等待的话这就使得程序不必要的降低了运行速度。

　　在多线程版本中，这3个任务分别在独立的线程中执行。这些线程由操作系统来管理，在多处理器系统上可以并行处理，或者在单处理器系统上交错执行。这使得当某个线程阻塞在某个资源的同时其他线程得以继续执行。与完成类似功能的同步程序相比，这种方式更有效率，但程序员必须写代码来保护共享资源，防止其被多个线程同时访问。多线程程序更加难以推断，因为这类程序不得不通过线程同步机制如锁、可重入函数、线程局部存储或者其他机制来处理线程安全问题，如果实现不当就会导致出现微妙且令人痛不欲生的bug。

　　在事件驱动版本的程序中，3个任务交错执行，但仍然在一个单独的线程控制中。当处理I/O或者其他昂贵的操作时，注册一个回调到事件循环中，然后当I/O操作完成时继续执行。回调描述了该如何处理某个事件。事件循环轮询所有的事件，当事件到来时将它们分配给等待处理事件的回调函数。这种方式让程序尽可能的得以执行而不需要用到额外的线程。事件驱动型程序比多线程程序更容易推断出行为，因为程序员不需要关心线程安全问题。

当我们面对如下的环境时，事件驱动模型通常是一个好的选择：

程序中有许多任务，而且…
任务之间高度独立（因此它们不需要互相通信，或者等待彼此）而且…
在等待事件到来时，某些任务会阻塞。
　　当应用程序需要在任务间共享可变的数据时，这也是一个不错的选择，因为这里不需要采用同步处理。

　　网络应用程序通常都有上述这些特点，这使得它们能够很好的契合事件驱动编程模型。
<!-- more -->
1.1流的概念
一个流可以文件、socket、pipe等可以进行IO操作的内核对象。不管是文件，还是套接字，还是管道，我们都可以把他们看作流。

从流中读取数据或者写入数据到流中，可能存在这样的情况：读取数据时，流中还没有数据；写入数据时，流中数据已经满了，没有空间写入了。典型的例子为客户端要从socket流中读入数据，但是服务器还没有把数据准备好。此时有两种处理办法：

阻塞，等待数据准备好了，再读取出来返回；
非阻塞，通过轮询的方式，查询是否有数据可以读取，直到把数据读取返回。
接下来再来了解以下I/O同步、异步、阻塞、非阻塞的概念。

1.2 I/O同步、异步、阻塞、非阻塞
在IO操作过程中，可能会涉及到同步（synchronous）、异步（asynchronous）、阻塞（blocking）、非阻塞（non-blocking）、IO多路复用(IO multiplexing)等概念。他们之间的区别是什么呢？

以网络IO为例，在IO操作过程会涉及到两个对象：

一个是调用这个IO的process (or thread)；
另外一个是一个就是系统内核(kernel)。
在一个IO操作过程中，以read为例，会涉及到两个过程：

等待数据准备好(Waiting for the data to be ready)；
将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)
这两个阶段是否发生阻塞，将产生不同的效果。

阻塞VS非阻塞

阻塞IO：

在1、2阶段都发生阻塞；
调用阻塞IO会一直block住进程，直到操作完成；
非阻塞IO:

在第1阶段没有阻塞，在第2阶段发生阻塞；
调用非阻塞IO会在kernel准备数据的情况下立即返回；
非阻塞IO需要不断轮询，查看数据是否已经准备好了；
阻塞与非阻塞可以简单理解为调用一个IO操作能不能立即得到返回应答，如果不能立即获得返回，需要等待，那就阻塞了；否则就可以理解为非阻塞。

同步VS异步

同步IO：

同步IO操作将导致请求的进程一直被blocked，直到IO操作完成。从这个层次来，阻塞IO、非阻塞IO操作、IO多路复用都是同步IO。

异步IO：

异步IO操作不会导致请求的进程被blocked。当发出IO操作请求，直接返回，等待IO操作完成后，再通知调用进程。

多路复用IO

多路复用IO也是阻塞IO，只是阻塞的方法是select/poll/epoll。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理是select/epoll这个函数会不断轮询所负责的IO操作，当某个IO操作有数据到达时，就通知用户进程。然后由用户进程去操作IO。比较详细的介绍可以参考： 
IO-同步，异步，阻塞，非阻塞和网络IO之阻塞、非阻塞、同步、异步总结

1.3 多路复用概念
I/O多路复用是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

阻塞I/O有一个比较明显的缺点是在I/O阻塞模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，需要多个进程或者多个线程，但是这种方式效率不高。

非阻塞的I/O需要轮询查看流是否已经准备好了，比较典型的方式是忙轮询。

忙轮询 
忙轮询方式是通过不停的把所有的流从头到尾轮询一遍，查询是否有流已经准备就绪，然后又从头开始。如果所有流都没有准备就绪，那么只会白白浪费CPU时间。轮询过程可以参照如下：

while true {
    for i in stream[]; {
        if i has data
              read until unavailable
    }
}
无差别的轮询方式 
为了避免白白浪费CPU时间，我们采用另外一种轮询方式，无差别的轮询方式。即通过引进一个代理，这个代理为select/poll,这个代理可以同时观察多个流的I/O事件。当所有的流都没有准备就绪时，会把当前线程阻塞掉；当有一个或多个流的I/O事件就绪时，就从阻塞状态中醒来，然后轮询一遍所有的流，处理已经准备好的I/O事件。轮询的过程可以参照如下：

while true {
    select(streams[])
    for i in streams[] {
        if i has data
              read until unavailable
    }
}
如果I/O事件准备就绪，那么我们的程序就会阻塞在select处。我们通过select那里只是知道了有I/O事件准备好了，但不知道具体是哪几个流（可能有一个，也可能有多个），所以需要无差别的轮询所有的流，找出已经准备就绪的流。可以看到，使用select时，我们需要O(n)的时间复杂度来处理流，处理的流越多，消耗的时间也就越多。

最小轮询方式

无差别的轮询方式有一个缺点就是，随着监控的流越来越多，需要轮询的时间也会随之增加，效率也会随之降低。所以还有另外一种轮询方式，最小轮询方式，即通过epoll方式来观察多个流，epoll只会把发生了I/O事件的流通知我们，我们对这些流的操作都是有意义的，时间复杂度降低到O（k），其中k为产生I/O事件的流个数。轮询的过程如下：

while true {
    active_stream[] = epoll_wait(epollfd)
    for i in active_stream[] {
        read or write till unavailable
    }
}

select/poll/epoll都是采用I/O多路复用机制的，其中select/poll是采用无差别轮询方式，而epoll是采用最小的轮询方式。

1.4 I/O复用的优势
I/O多路复用的优势并不是对于单个连接能处理的更快，而是在于可以在单个线程/进程中处理更多的连接。

与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

2. I/O复用函数介绍
下面简单的介绍一下I/O复用函数。
2.1 select函数
系统提供Select函数来实现多路复用输入/输出模型，Select系统调用是用来让我们的程序监视多个文件句柄的状态变化。程序会阻塞在select函数上，直到被监视的文件句柄中有一个或多个发生了状态变化。

函数原型

#include <sys/select.h>
#include <sys/time.h>

int select(int maxfd,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)
参数说明：

maxfd：需要监视的最大的文件描述符值+1；
readset：需要检测的可读文件描述符的集合；
writeset：需要检测的可写文件描述符的集合
exceptset：需要检测的异常文件描述符的集合
timeout：超时时间；超时时间有三种情况： 
NULL：永远等待下去，仅在有一个描述字准备好I/O时才返回；
0：立即返回，仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生；
特定的时间值： 如果在指定的时间段里没有事件发生，select将超时返回；
函数返回值有三种情况：

返回0表示超时了；
返回-1，表示出错了；
返回一个大于0的数，表示文件描述符状态改变的个数；
fd_set是一个文件描述符集合，可以通过以下宏来操作：

FD_CLR(inr fd,fd_set* set)：用来清除文件描述符集合set中相关fd的位
FD_ISSET(int fd,fd_set *set)：用来测试文件描述符集合set中相关fd的位是否为真
FD_SET（int fd,fd_set*set）：用来设置文件描述符集合set中相关fd的位
FD_ZERO（fd_set *set）：用来清除文件描述符集合set的全部位
2.2 Poll函数
Poll的处理机制与Select类似，只是Poll选择了pollfd结构体来处理文件描述符的相关操作：

struct pollfd {
    int fd;         /* 文件描述符 */
    short events;   /* 等待的事件 */
    short revents;  /* 实际发生了的事件 */
} ; 
每一个pollfd结构体都指定了一个文件描述符fd，events代表了需要监听该文件描述的事件掩码，可选的有：

POLLIN：有数据可读。
POLLRDNORM：有普通数据可读。
POLLRDBAND：有优先数据可读。
POLLPRI：有紧迫数据可读。
POLLOUT：写数据不会导致阻塞。
POLLWRNORM：写普通数据不会导致阻塞。
POLLWRBAND：写优先数据不会导致阻塞。
POLLMSGSIGPOLL：消息可用。
revents代表文件描述符的操作结果掩码，内核在调用返回时设置这个域。events域中请求的任何事件都可能在revents域中返回，除此之外，revents域还可以包含以下事件：

POLLER：指定的文件描述符发生错误。
POLLHUP：指定的文件描述符挂起事件。
POLLNVAL：指定的文件描述符非法。
poll的函数原型：

# include <poll.h>
int poll ( struct pollfd * fds, unsigned int nfds, int timeout);
参数说明：

fds：需要被监视的文件描述符集合；
nfds：被监视的文件描述符数量；
timeout：超时时间，有三种取值： 
负数：无限超时，一直等到一个指定事件发生；
0：立即返回，并列出准备好的文件描述符；
正数：等待指定的时间，单位为毫秒；
poll函数与select函数的最大不同之处在于：select函数有最大文件描述符的限制，一般1024个，而poll函数对文件描述符的数量没有限制。但select和poll函数都是通过轮询的方式来查询某个文件描述符状态是否发生了变化，并且需要将整个文件描述符集合在用户空间和内核空间之间来回拷贝，这样随着文件描述符的数量增加，相应的开销也随之增加。

2.3epoll函数
epoll是在Linux内核2.6引进的，是select和poll函数的增强版。与select相比，epoll没有文件描述符数量的限制。epoll使用一个文件描述符管理多个文件描述符，将用户关心的文件描述符事件存放到内核的一个事件列表中，这样在用户空间和内核空间只需拷贝一次。

epoll操作是包含有三个接口的：

#include <sys/epoll.h>
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
epoll_create函数：

用创建一个epoll的句柄；
size用来告诉内核这个监听的数目一共有多大，占用一个fd值；
epoll_ctl函数：

epoll的事件注册函数；
参数：

epfd：epoll_create()的返回值；
op：动作，有三种取值：

EPOLL_CTL_ADD：注册新的fd到epfd中；
EPOLL_CTL_MOD：修改已经注册的fd的监听事件；
EPOLL_CTL_DEL：从epfd中删除一个fd；
fd：需要监听的fd；

event： 告诉内核需要监听什么事件，取值有： 
EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；
EPOLLOUT：表示对应的文件描述符可以写；
EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
EPOLLERR：表示对应的文件描述符发生错误；
EPOLLHUP：表示对应的文件描述符被挂断；
EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。
EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列；
epoll_wait函数：

等待事件的产生；
参数： 
events：从内核得到事件的集合；
maxevents：事件集合的大小；
timeout：超时时间，0会立即返回，-1表示永久阻塞，正数表示一个指定的值；
工作模式

epoll对文件描述符的操作由两种模式：水平触发LT（level trigger）和边沿触发ET（edge trigger）。默认的情况下为LT模式。LT模式与ET模式的区别在于：

LT模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用epoll_wait时，会再次响应应用程序并通知此事件。
ET模式：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。
ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

2.4 epoll相比于select/poll的优势？
从上面对select/poll/epoll函数的介绍，可以知道epoll与select/poll相比，具有如下优势：

监视的描述符数量不受限制，所支持的FD上限是最大可以打开文件的数目；
I/O效率不会随着监视fd的数量增长而下降。epoll不同于select和poll轮询的方式，而是通过每个fd定义的回调函数来实现的，只有就绪的fd才会执行回调函数。

多任务式IO主要有select、poll、epoll三种：
select监视一大片文件描述符，监视的范围是最大的文件描述符maxfd加1，并将所监视的文件描述符分为三组，采用FD_ISSET宏查看哪些fd对应的bitmap变为准备状态，就可以对其进行操作。由于select()在各种Unix系统中都很容易实现，相对于微秒级精度的睡眠机 制来讲，经常将select()做为一种可移植的微秒级的睡眠机制：select (0, NULL, NULL, NULL, &tv)。此外BSD还是先了pselect()系统调用。Select可以用在文件描述符数量相对比较确定的场景。
poll是System V的IO多路复用方案，采用pollfd数组来设定需要监视的文件描述符，相比select需要为每个分组检查maxfd+1个比特位，效率更高。

EPoll接口
epoll把监听注册从实际监听中分离出来，从而解决了这个问题。一个系统调用初始化一个epoll上下文，另一个从上下文中加入或删除需要监视的文件描述符，第三个执行真正的事件等待（eventwait)。如果epoll_ctl()的参数event中的events项设置为EPOLLE，fd上的监听称为边沿触发，相反的称为水平触发。对于水平触发的监听，在步骤2里对epoll_wait()的调用将立即返回，以表明pipe可读。对于边沿触发的监听，这个调用直到步骤1发生后才会返回。也就是说，即使调用epoll_wait()时管道已经可读，调用仍然会等待直到有数据写入，之后返回。水平触发是默认行为。也是poll()和select()的行为，也是大多数开发者所期望的。边沿触发需要一个不同的方式来写程序，通常利用非阻塞I/O，并需要仔细检查EAGAIN。
水平触发在一个状态发生时触发。边沿触发只有在状态改变的时候才会产生。水平触发在只关心状态时有用。边沿触发则在关心事件本身时有用。

epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它不会复用文件描述符集合来传递结果而迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。epoll的主要优点有：
1、支持一个进程打开大数目的socket描述符；
2、IO效率不随FD数目增加而线性下降；
3、使用mmap加速内核与用户空间的消息传递。
int epoll_create (int size)
epoll_create()创 建 一 个 epoll实例，返回与该实例关联的文件描述符。这个文件描述符和真正的文件没有关系，仅仅是为了后续调用使用epoll而创建的。

int epoll_ctl (int epfd, int op, int fd, struct epoll_event *event);
在epfd实例中加入一个fd指定的监听文件参数op用来添加、删除、修改fd指定文件的事件。events结构体中的events参数列出了在给定文件描述符上监听的事件。多个事件可以使用位或运算同时指定。最常见的是读写事件的监听： EPOLLIN | EPOLLOUT。

int epoll_wait (int epfd, struct epoll_event events, int maxevents, int timeout);
返回值是事件数，出错返回-1。events要保证有足够的buffer：
events = malloc (sizeof (struct epoll_event) MAX_EVENTS); 
nr_events = epoll_wait (epfd, events, MAX_EVENTS, -1);
如果timeout为 0， 即使没有事件发生 ， 调用也立即返回，此时调用返回0。如果timeout为 -1，调用将一直等待到有事件发生。
