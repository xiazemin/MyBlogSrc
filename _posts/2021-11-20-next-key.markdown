---
title: next-key lock
layout: post
category: mysql
author: 夏泽民
---
其实innodb下的记录锁(也叫行锁)，间隙锁，next-key锁统统属于排他锁。
行锁
记录锁其实很好理解，对表中的记录加锁，叫做记录锁，简称行锁。
用间隙锁，在RR级别下，mysql通过间隙锁可以实现锁定number=5之前的间隙，number=5记录之间的间隙，number=5之后的间隙，从而使的新的记录无法被插入进来。

间隙是怎么划分的？

注：为了方面理解，我们规定(id=A,number=B)代表一条字段id=A,字段number=B的记录，(C，D)代表一个区间，代表C-D这个区间范围。

图一中，根据number列，我们可以分为几个区间：(无穷小，2)，(2，4)，(4，5)，(5，5)，(5,11)，(11，无穷大)。

只要这些区间对应的两个临界记录中间可以插入记录，就认为区间对应的记录之间有间隙。

例如：区间(2，4)分别对应的临界记录是(id=1,number=2)，(id=3，number=4)，这两条记录中间可以插入(id=2,number=3)等记录，那么就认为(id=1,number=2)与(id=3，number=4)之间存在间隙。

很多人会问，那记录(id=6，number=5)与(id=8，number=5)之间有间隙吗？

答案是有的，(id=6，number=5)与(id=8，number=5)之间可以插入记录(id=7，number=5)，因此(id=6,number=5)与(id=8,number=5)之间有间隙的，

间隙锁锁定的区域

根据检索条件向左寻找最靠近检索条件的记录值A，作为左区间，向右寻找最靠近检索条件的记录值B作为右区间，即锁定的间隙为(A，B)。

图一中，where number=5的话，那么间隙锁的区间范围为(4,11)；

间隙锁的目的是为了防止幻读，其主要通过两个方面实现这个目的：

(1)防止间隙内有新数据被插入

(2)防止已存在的数据，更新成间隙内的数据(例如防止numer=3的记录通过update变成number=5)

innodb自动使用间隙锁的条件：

(1)必须在RR级别下

(2)检索条件必须有索引(没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加)

有人会问，为啥update news set id=14 where number=11会阻塞，但是update news set id=11 where number=11却执行成功呢？

间隙锁采用在指定记录的前面和后面以及中间的间隙上加间隙锁的方式避免数据被插入，此图间隙锁锁定的区域是(11，无穷大)，也就是记录(id=13,number=11)之后不能再插入记录，update news set id=14 where number=11这条语句如果执行的话，将会被插入到(id=13,number=11)的后面，也就是在区间(11，无穷大)之间，由于该区间被间隙锁锁定，所以只能阻塞等待，而update news set id=11 where number=11执行后是会被插入到(id=13,number=11)的记录前面，也就不在(11，无穷大)的范围内，所以无需等待，执行成功。
<!-- more -->
https://blog.csdn.net/weixin_42676678/article/details/113199076

间隙锁（Gap Lock）是Innodb在提交下为了解决幻读问题时引入的锁机制，（下面的所有案例没有特意强调都使用可重复读隔离级别）幻读的问题存在是因为新增或者更新操作，这时如果进行范围查询的时候（加锁查询），会出现不一致的问题，这时使用不同的行锁已经没有办法满足要求，需要对一定范围内的数据进行加锁，间隙锁就是解决这类问题的。在可重复读隔离级别下，数据库是通过行锁和间隙锁共同组成的（next-key lock），来实现的

加锁规则有以下特性，我们会在后面的案例中逐一解释：

1.加锁的基本单位是（next-key lock）,他是前开后闭原则
2.插叙过程中访问的对象会增加锁
3.索引上的等值查询--给唯一索引加锁的时候，next-key lock升级为行锁
4.索引上的等值查询--向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁
5.唯一索引上的范围查询会访问到不满足条件的第一个值为止

https://www.jianshu.com/p/32904ee07e56

