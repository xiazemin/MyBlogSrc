---
title: c语言内存管理
layout: post
category: linux
author: 夏泽民
---
在C语言中，关于内存管理的知识点比较多，如函数、变量、作用域、指针等
1.变量：不解释。但需要搞清楚这几种变量类型：

全局变量（外部变量）：出现在代码块{}之外的变量就是全局变量。
局部变量（自动变量）：一般情况下，代码块{}内部定义的变量就是自动变量，也可使用auto显示定义。
静态变量：是指内存位置在程序执行期间一直不改变的变量，用关键字static修饰。代码块内部的静态变量只能被这个代码块内部访问，代码块外部的静态变量只能被定义这个变量的文件访问。
注意：extern修饰变量时，根据具体情况，既可以看作是定义也可以看作是声明；但extern修饰函数时只能是定义，没有二义性。

2.作用域：通常指的是变量的作用域，广义上讲，也有函数作用域及文件作用域等。我理解的作用域就是指某个事物能够存在的区域或范围，比如一滴水只有在0-100摄氏度之间才能存在，超出这个范围，广义上讲的“水”就不存在了，它就变成了冰或气体。

3.函数：不解释。

注意：C语言中函数默认都是全局的，可以使用static关键字将函数声明为静态函数（只能被定义这个函数的文件访问的函数）。
<!-- more -->
二、内存四区
　　计算机中的内存是分区来管理的，程序和程序之间的内存是独立的，不能互相访问，比如QQ和浏览器分别所占的内存区域是不能相互访问的。而每个程序的内存也是分区管理的，一个应用程序所占的内存可以分为很多个区域，我们需要了解的主要有四个区域，通常叫内存四区
　　1.代码区
　　程序被操作系统加载到内存的时候，所有的可执行代码（程序代码指令、常量字符串等）都加载到代码区，这块内存在程序运行期间是不变的。代码区是平行的，里面装的就是一堆指令，在程序运行期间是不能改变的。函数也是代码的一部分，故函数都被放在代码区，包括main函数。

　　注意："int a = 0;"语句可拆分成"int a;"和"a = 0"，定义变量a的"int a;"语句并不是代码，它在程序编译时就执行了，并没有放到代码区，放到代码区的只有"a = 0"这句。

2.静态区
　　静态区存放程序中所有的全局变量和静态变量。

3.栈区
　　栈（stack）是一种先进后出的内存结构，所有的自动变量、函数形参都存储在栈中，这个动作由编译器自动完成，我们写程序时不需要考虑。栈区在程序运行期间是可以随时修改的。当一个自动变量超出其作用域时，自动从栈中弹出。

每个线程都有自己专属的栈；
栈的最大尺寸固定，超出则引起栈溢出；
变量离开作用域后栈上的内存会自动释放。

栈不会很大，一般都是以K为单位。如果在程序中直接将较大的数组保存在函数内的栈变量中，很可能会内存溢出，导致程序崩溃，严格来说应该叫栈溢出（当栈空间以满，但还往栈内存压变量，这个就叫栈溢出）。

4.堆区
　　堆（heap）和栈一样，也是一种在程序运行过程中可以随时修改的内存区域，但没有栈那样先进后出的顺序。更重要的是堆是一个大容器，它的容量要远远大于栈，这可以解决上面实验三造成的内存溢出困难。一般比较复杂的数据类型都是放在堆中。但是在C语言中，堆内存空间的申请和释放需要手动通过代码来完成。对于一个32位操作系统，最大管理管理4G内存，其中1G是给操作系统自己用的，剩下的3G都是给用户程序，一个用户程序理论上可以使用3G的内存空间。堆上的内存必须手动释放（C/C++），除非语言执行环境支持GC（如C#在.NET上运行就有垃圾回收机制）。那堆内存如何使用？

　　接下来看堆内存的分配和释放：

malloc与free
　　malloc函数用来在堆中分配指定大小的内存，单位为字节（Byte），函数返回void *指针；free负责在堆中释放malloc分配的内存。malloc与free一定成对使用
　　
　　堆的容量有多大?理论上讲，它可以使用除了系统占用内存空间之外的所有空间。实际上比这要小些
　　
　　可以通过函数返回一个堆地址，但记得一定用通过free函数释放申请的堆内存空间。"int *p = (int *)malloc(sizeof(int));"换成"static int a = 0"也是合法的。因为静态区的内存在程序运行的整个期间都有效，但是后面的free函数就不能用了！

　　用来在堆中申请内存空间的函数还有calloc和realloc，用法与malloc类似。
　　
　　需要注意以下几点：

栈是从高地址向低地址方向增长；
在C语言中，函数参数的入栈顺序是从右到左，因此UpdateCounter函数的3个参数入栈顺序是a1、c、b；
C语言中形参和实参之间是值传递，UpdateCounter函数里的参数a[1]、c、b与静态区的a[1]、c、b不是同一个；
　　"char *b = NULL"定义一个指针变量b，b的地址是0xFFF8，值为空-->运行到"b = (char*)malloc(1024*sizeof(char))"时才在堆中申请了一块内存（假设这块内存地址为0x77a0080）给了b，此时b的地址并没有变化，但其值变为了0x77a0080，这个值指向了一个堆空间的地址（栈变量的值指向了堆空间），
　　
　　什么时候用堆什么时候用栈呢？一般遵循以下三个原则：

如果明确知道数据占用多少内存，那么数据量较小时用栈，较大时用堆；
如果不知道数据量大小（可能需要占用较大内存），最好用堆（因为这样保险些）；
如果需要动态创建数组，则用堆。

操作系统在管理内存时，最小单位不是字节，而是内存页（32位操作系统的内存页一般是4K）。比如，初次申请1K内存，操作系统会分配1个内存页，也就是4K内存。4K是一个折中的选择，因为：内存页越大，内存浪费越多，但操作系统内存调度效率高，不用频繁分配和释放内存；内存页越小，内存浪费越少，但操作系统内存调度效率低，需要频繁分配和释放内存。嵌入式系统的内存内存资源很稀缺，其内存页会更小，因此在嵌入式开发当中需要特别注意。

（1）代码区（text segment）。存放CPU执行的机器指令（machine instructions）。通常，代码区是可共享的（即另外的执行程序可以调用它），因为对于频繁被执行的程序，只需要在内存中有一份代码即可。代码区通常是只读的，使其只读的原因是防止程序意外地修改了它的指令。另外，代码区还规划了局部变量的相关信息。

（2）全局初始化数据区/静态数据区（initialized data segment/data segment）。该区包含了在程序中明确被初始化的全局变量、静态变量（包括全局静态变量和局部静态变量）和常量数据（如字符串常量）。例如，一个不在任何函数内的声明（全局数据）：

1 int maxcount = 99;
使得变量maxcount根据其初始值被存储到初始化数据区中。

1 static mincount = 100; 
这声明了一个静态数据，如果是在任何函数体外声明，则表示其为一个全局静态变量，如果在函数体内（局部），则表示其为一个局部静态变量。另外，如果在函数名前加上static，则表示此函数只能在当前文件中被调用。

（3）未初始化数据区。亦称BSS区（uninitialized data segment），存入的是全局未初始化变量。BSS这个叫法是根据一个早期的汇编运算符而来，这个汇编运算符标志着一个块的开始。BSS区的数据在程序开始执行之前被内核初始化为0或者空指针（NULL）。例如一个不在任何函数内的声明：

1 long sum[1000];
将变量sum存储到未初始化数据区。

1）代码区（text segment）。代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需要借助栈来实现。代码段： 代码段（code segment/text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。代码区的指令中包括操作码和要操作的对象（或对象地址引用）。如果是立即数（即具体的数值，如5），将直接包含在代码中；如果是局部数据，将在栈区分配空间，然后引用该数据地址；如果是BSS区和数据区，在代码中同样将引用该数据地址。另外，代码段还规划了局部数据所申请的内存空间信息。

（2）全局初始化数据区/静态数据区（Data Segment）。只初始化一次。数据段： 数据段（data segment ）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。data段中的静态数据区存放的是程序中已初始化的全局变量、静态变量和常量。

（3）未初始化数据区（BSS）。在运行时改变其值。BSS 段： BSS 段（bss segment ）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS 是英文Block Started by Symbol 的简称。BSS 段属于静态内存分配，即程序一开始就将其清零了。一般在初始化时BSS段部分将会清零。

（4）栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值等。存放函数的参数值、局部变量的值，以及在进行任务切换时存放当前任务的上下文内容。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆。栈(stack) ：栈又称堆栈， 是用户存放程序临时创建的局部变量，也就是说我们函数括弧"{}"中定义的变量（但不包括static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

（5）堆区（heap）。用于动态内存分配。堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS回收。堆(heap)： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。在将应用程序加载到内存空间执行时，操作系统负责代码段、数据段和BSS段的加载，并将在内存中为这些段分配空间。栈段亦由操作系统分配和管理，而不需要程序员显示地管理；堆段由程序员自己管理，即显式地申请和释放空间。

另外，可执行程序在运行时具有相应的程序属性。在有操作系统支持时，这些属性页由操作系统管理和维护。

C语言程序编译完成之后，已初始化的全局变量保存在DATA段中，未初始化的全局变量保存在BSS段中。TEXT和DATA段都在可执行文件中，由系统从可执行文件中加载；而BSS段不在可执行文件中，由系统初始化。BSS段只保存没有值的变量，所以事实上它并不需要保存这些变量的映像。运行时所需要的BSS段大小记录在目标文件中，但是BSS段并不占据目标文件的任何空间。
<img src="{{site.url}}{{site.baseurl}}/img/stack_bss.png"/>

在操作系统中，一个进程就是处于执行期的程序（当然包括系统资源），实际上正在执行的程序代码的活标本。那么进程的逻辑地址空间是如何划分的呢？

左边的是UNIX/LINUX系统的执行文件，右边是对应进程逻辑地址空间的划分情况。

首先是堆栈区(stack)，堆栈是由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。栈的申请是由系统自动分配，如在函数内部申请一个局部变量 int h，同时判别所申请空间是否小于栈的剩余空间，如若小于的话，在堆栈中为其开辟空间，为程序提供内存，否则将报异常提示栈溢出。  

其次是堆(heap)，堆一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。堆的申请是由程序员自己来操作的，在C中使用malloc函数，而C++中使用new运算符，但是堆的申请过程比较复杂：当系统收到程序的申请时，会遍历记录空闲内存地址的链表，以求寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲 结点链表中删除，并将该结点的空间分配给程序，此处应该注意的是有些情况下，新申请的内存块的首地址记录本次分配的内存块大小，这样在delete尤其是 delete[]时就能正确的释放内存空间。

接着是全局数据区(静态区) (static)，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 另外文字常量区，常量字符串就是放在这里，程序结束后有系统释放。

最后是程序代码区，放着函数体的二进制代码。

为什么要这么分配内存？
（1）一个进程在运行过程中，代码是根据流程依次执行的，只需要访问一次，当然跳转和递归有可能使代码执行多次，而数据一般都需要访问多次，因此单独开辟空间以方便访问和节约空间。

（2）临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。

（3）全局数据和静态数据有可能在整个程序执行过程中都需要访问，因此单独存储管理。

（4）堆区由用户自由分配，以便管理。

内存的分配方式
在C语言中，对象可以使用静态或动态的方式分配内存空间。

静态分配：编译器在处理程序源代码时分配。

动态分配：程序在执行时调用malloc库函数申请分配。

静态内存分配是在程序执行之前进行的因而效率比较高，而动态内存分配则可以灵活的处理未知数目的。

静态与动态内存分配的主要区别如下：

静态对象是有名字的变量，可以直接对其进行操作；动态对象是没有名字的一段地址，需要通过指针间接地对它进行操作。

静态对象的分配与释放由编译器自动处理；动态对象的分配与释放必须由程序员显式地管理，它通过malloc()和free两个函数来完成。

栈和堆的区别
前面已经介绍过，栈是由编译器在需要时分配的，不需要时自动清除的变量存储区。里面的变量通常是局部变量、函数参数等。堆是由malloc()函数分配的内存块，内存释放由程序员手动控制，在C语言为free函数完成。栈和堆的主要区别有以下几点：

（1）管理方式不同。

栈编译器自动管理，无需程序员手工控制；而堆空间的申请释放工作由程序员控制，容易产生内存泄漏。对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M。当然，这个值可以修改。碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问 题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在它弹出之前，在它上面的后进的栈内容已经被弹出，详细的可以参考数据结构。生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的， 比如局部变量的分配。动态分配由malloca函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放，无需我们手工实现。分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址， EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果。

（2）空间大小不同。

栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，当申请的空间超过栈的剩余空间时，将提示溢出。因此，用户能从栈获得的空间较小。

堆是向高地址扩展的数据结构，是不连续的内存区域。因为系统是用链表来存储空闲内存地址的，且链表的遍历方向是由低地址向高地址。由此可见，堆获得的空间较灵活，也较大。栈中元素都是一一对应的，不会存在一个内存块从栈中间弹出的情况。

在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

（3）是否产生碎片。

对于堆来讲，频繁的malloc/free（new/delete）势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低（虽然程序在退出后操作系统会对内存进行回收管理）。对于栈来讲，则不会存在这个问题。

（4）增长方向不同。

堆的增长方向是向上的，即向着内存地址增加的方向；栈的增长方向是向下的，即向着内存地址减小的方向。

（5）分配方式不同。

堆都是程序中由malloc()函数动态申请分配并由free()函数释放的；栈的分配和释放是由编译器完成的，栈的动态分配由alloca()函数完成，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行申请和释放的，无需手工实现。

STACK： 由系统自动分配。例如，声明在函数中一个局部变量 int b;系统自动在栈中为b开辟空间。HEAP：需要程序员自己申请，并指明大小，在C中malloc函数。指向堆中分配内存的指针则可能是存放在栈中的。

（6）分配效率不同。

栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行。堆则是C函数库提供的，它的机制很复杂，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大的空间，如果没有足够大的空间（可能是由于内存碎片太多），就有需要操作系统来重新整理内存空间，这样就有机会分到足够大小的内存，然后返回。显然，堆的效率比栈要低得多。

栈由系统自动分配，速度较快。但程序员是无法控制的。

堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。

（7）申请后系统的响应

栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

（8）堆和栈中的存储内容

栈：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。栈中的内存是在程序编译完成以后就可以确定的，不论占用空间大小，还是每个变量的类型。

堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

（9）存取效率的比较

1 char s1[] = "a";
2 char *s2 = "b";
a是在运行时刻赋值的；而b是在编译时就确定的但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。

（10）防止越界发生

无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难的

原因：在于局部变量的作用域和内存分配的问题，第一char*是指向一个常量，作用域为函数内部，被分配在程序的常量区，直到整个程序结束才被销毁，所以在程序结束前常量还是存在的。而第二个是数组存放的，作用域为函数内部，被分配在栈中，就会在函数调用结束后被释放掉，这时你再调用，肯定就错误了。


局部变量就是在一个有限的范围内的变量，作用域是有限的，对于程序来说，在一个函数体内部声明的普通变量都是局部变量，局部变量会在栈上申请空间，函数结束后，申请的空间会自动释放。而全局变量是在函数体外申请的，会被存放在全局（静态区）上，知道程序结束后才会被结束，这样它的作用域就是整个程序。静态变量和全局变量的存储方式相同，在函数体内声明为static就可以使此变量像全局变量一样使用，不用担心函数结束而被释放。

栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
堆区（heap）—一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表
全局区（静态区）（static）—全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态　　                                变量在相邻的另一块区域。  程序结束后由系统释放。
常量区—常量字符串就是放在这里的，直到程序结束后由系统释放。上面的问题就在这里！！！
代码区—存放函数体的二进制代码。
一般编译器和操作系统实现来说，对于虚拟地址空间的最低（从0开始的几K）的一段空间是未被映射的，也就是说它在进程空间中，但没有赋予物理地址，不能被访问。这也就是对空指针的访问会导致crash的原因，因为空指针的地址是0。至于为什么预留的不是一个字节而是几K，是因为内存是分页的，至少要一页；另外几k的空间还可以用来捕捉使用空指针的情况。

char *a 与char a[] 的区别
char *d = "hello" 中的a是指向第一个字符‘a'的一个指针；char s[20] = "hello" 中数组名a也是执行数组第一个字符'h'的指针。现执行下列操作：strcat(d, s)。把字符串加到指针所指的字串上去，出现段错误，本质原因：*d="0123456789"存放在常量区，是无法修的。而数组是存放在栈中，是可以修改的。两者区别如下：

读写能力：char *a = "abcd"此时"abcd"存放在常量区。通过指针只可以访问字符串常量，而不可以改变它。而char a[20] = "abcd"; 此时 "abcd"存放在栈。可以通过指针去访问和修改数组内容。

赋值时刻：char *a = "abcd"是在编译时就确定了（因为为常量）。而char a[20] = "abcd"; 在运行时确定

存取效率：char *a = "abcd"; 存于静态存储区。在栈上的数组比指针所指向字符串快。因此慢，而char a[20] = "abcd"存于栈上，快。
另外注意：char a[] = "01234"，虽然没有指明字符串的长度，但是此时系统已经开好了，就是大小为6-----'0' '1' '2' '3' '4' '5' '\0'，(注意strlen(a)是不计'\0')
