---
title: 物化视图 material view
layout: post
category: storage
author: 夏泽民
---
物化视图是包括一个查询结果的数据库对象，它是远程数据的的本地副本，或者用来生成基于数据表求和的汇总表。物化视图存储基于远程表的数据，也可以称为快照（类似于MSSQL Server中的snapshot，静态快照） [1]  。对于复制，物化视图允许你在本地维护远程数据的副本，这些副本是只读的。如果你想修改本地副本，必须用高级复制的功能。当你想从一个表或视图中抽取数据时，你可以用从物化视图中抽取。对于数据仓库，创建的物化视图通常情况下是聚合视图，单一表聚合视图和连接视图。（这个是基于本地的基表或者视图的聚合）。物化视图，说白了，就是物理表，只不过这张表通过oracle的内部机制可以定期更新，将一些大的耗时的表连接用物化视图实现，会提高查询的效率。当然要打开查询重写选项
<!-- more -->
1、创建方式（Build Methods）：Build Immediate 和Build Deferred两种。Build Immediate 是在创建物化视图的时候就生成数据，而Build Deferred则在创建时不生成数据，以后根据需要再生成数据。默认为Build Immediate 。
2、查询重写（Query Rewrite）：Enable Query Rewrite和Disable Query Rewrite两种。分别指出创建的物化视图是否支持查询重写。查询重写是指当对物化视图的基表进行查询时，Oracle会自动判断能否通过查询物化视图来得到结果，如果可以，则避免了聚集或连接操作，而直接从已经计算好的物化视图中读取数据。默认为Disable Query Rewrite。
3、刷新（Refresh）：指当基表发生了DML操作后，物化视图何时采用哪种方式和基表进行同步。刷新的模式有两种：On Demand和On Commit。On Demand指物化视图在用户需要的时候进行刷新，可以手工通过DBMS_MVIEW.REFRESH等方法来进行刷新，也可以通过JOB定时进行刷新。On Commit指物化视图在对基表的DML操作提交的同时进行刷新。刷新的方法有四种：Fast 、Complete 、Force和Never。Fast 刷新采用增量刷新，只刷新自上次刷新以后进行的修改。Complete 刷新对整个物化视图进行完全的刷新。如果选择Force方式，则Oracle在刷新时会去判断是否可以进行快速刷新，如果可以则采用FAST方式，否则采用Complete 的方式。Never指物化视图不进行任何刷新。默认值是Force On Demand。
在建立物化视图的时候可以指定Order by 语句，使生成的数据按照一定的顺序进行保存。不过这个语句不会写入物化视图的定义中，而且对以后的刷新也无效。
4、物化视图日志：如果需要进行快速刷新，则需要建立物化视图日志。物化视图日志根据不同物化视图的快速刷新的需要，可以建立为RowID或Primary Key类型的。还可以选择是否包括Sequence、Including New Values以及指定列的列表。
可以指明On PreBuild Table语句将物化视图建立在一个已经存在的表上。这种情况下，物化视图和表必须同名。当删除物化视图时，不会删除同名的表。这种物化视图的查询重写要求参数Query_Rewrite_integerity必须设置为 trusted或者stale_tolerated。
5、物化视图可以进行分区。而且基于分区的物化视图可以支持分区变化跟踪（PCT）。具有这种特性的物化视图，当基表进行了分区维护操作后，仍然可以进行快速刷新操作。对于聚集物化视图，可以在Group by 列表中使用Cube或RollUp，来建立不同等级的聚集物化视图。

物化视图是一种特殊的物理表，“物化”(Materialized)视图是相对普通视图而言的。普通视图是虚拟表，应用的局限性大，任何对视图的查询，Oracle都实际上转换为视图SQL语句的查询。这样对整体查询性能的提高，并没有实质上的好处。

1、物化视图的类型：ON DEMAND、ON COMMIT
    二者的区别在于刷新方法的不同，ON DEMAND顾名思义，仅在该物化视图“需要”被刷新了，才进行刷新(REFRESH)，即更新物化视图，以保证和基表数据的一致性；而ON COMMIT是说，一旦基表有了COMMIT，即事务提交，则立刻刷新，立刻更新物化视图，使得数据和基表一致。

2、ON DEMAND物化视图
    物化视图的创建本身是很复杂和需要优化参数设置的，特别是针对大型生产数据库系统而言。但Oracle允许以这种最简单的，类似于普通视图的方式来做，所以不可避免的会涉及到默认值问题。也就是说Oracle给物化视图的重要定义参数的默认值处理是我们需要特别注意的。
    物化视图的特点：
    (1) 物化视图在某种意义上说就是一个物理表(而且不仅仅是一个物理表)，这通过其可以被user_tables查询出来，而得到佐证；
    (2) 物化视图也是一种段(segment)，所以其有自己的物理存储属性；
    (3) 物化视图会占用数据库磁盘空间，这点从user_segment的查询结果，可以得到佐证；
    创建语句：create materialized view mv_name as select * from table_name
    默认情况下，如果没指定刷新方法和刷新模式，则Oracle默认为FORCE和DEMAND。

    物化视图的数据怎么随着基表而更新？
    Oracle提供了两种方式，手工刷新和自动刷新，默认为手工刷新。也就是说，通过我们手工的执行某个Oracle提供的系统级存储过程或包，来保证物化视图与基表数据一致性。这是最基本的刷新办法了。自动刷新，其实也就是Oracle会建立一个job，通过这个job来调用相同的存储过程或包，加以实现。
    
    ON DEMAND物化视图的特性及其和ON COMMIT物化视图的区别，即前者不刷新(手工或自动)就不更新物化视图，而后者不刷新也会更新物化视图，——只要基表发生了COMMIT。
    创建定时刷新的物化视图：create materialized view mv_name refresh force on demand start with sysdate
next sysdate+1 （指定物化视图每天刷新一次）
    上述创建的物化视图每天刷新，但是没有指定刷新时间，如果要指定刷新时间（比如每天晚上10：00定时刷新一次）：create materialized view mv_name refresh force on demand start with sysdate next to_date( concat( to_char( sysdate+1,'dd-mm-yyyy'),' 22:00:00'),'dd-mm-yyyy hh24:mi:ss')

3、ON COMMIT物化视图
    ON COMMIT物化视图的创建，和上面创建ON DEMAND的物化视图区别不大。因为ON DEMAND是默认的，所以ON COMMIT物化视图，需要再增加个参数即可。

    需要注意的是，无法在定义时仅指定ON COMMIT，还得附带个参数才行。
    创建ON COMMIT物化视图：create materialized view mv_name refresh force on commit as select * from table_name
    备注：实际创建过程中，基表需要有主键约束，否则会报错（ORA-12014）
4、物化视图的刷新
    刷新（Refresh）：指当基表发生了DML操作后，物化视图何时采用哪种方式和基表进行同步。刷新的模式有两种：ON DEMAND和ON COMMIT。（如上所述）
    刷新的方法有四种：FAST、COMPLETE、FORCE和NEVER。FAST刷新采用增量刷新，只刷新自上次刷新以后进行的修改。COMPLETE刷新对整个物化视图进行完全的刷新。如果选择FORCE方式，则Oracle在刷新时会去判断是否可以进行快速刷新，如果可以则采用FAST方式，否则采用COMPLETE的方式。NEVER指物化视图不进行任何刷新。
     对于已经创建好的物化视图，可以修改其刷新方式，比如把物化视图mv_name的刷新方式修改为每天晚上10点刷新一次：alter materialized view mv_name refresh force on demand start with sysdate next to_date(concat(to_char(sysdate+1,'dd-mm-yyyy'),' 22:00:00'),'dd-mm-yyyy hh24:mi:ss')
  
5、物化视图具有表一样的特征，所以可以像对表一样，我们可以为它创建索引，创建方法和对表一样。

6、物化视图的删除：
     虽然物化视图是和表一起管理的，但是在经常使用的PLSQL工具中，并不能用删除表的方式来删除（在表上右键选择‘drop’并不能删除物化视图），可以使用语句来实现：drop materialized view mv_name

 

 

普通视图和物化视图的区别
答曰：普通视图和物化视图根本就不是一个东西，说区别都是硬拼到一起的，首先明白基本概念，普通视图是不存储任何数据的，他只有定义，在查询中是转换为对应的定义SQL去查询，而物化视图是将数据转换为一个表，实际存储着数据，这样查询数据，就不用关联一大堆表，如果表很大的话，会在临时表空间内做大量的操作。
普通视图的三个特征：
1、是简化设计，清晰编码的东西，他并不是提高性能的，他的存在只会降低性能（如一个视图7个表关联，另一个视图8个表，程序员不知道，觉得很方便，把两个视图关联再做一个视图，那就惨了），他的存在未了在设计上的方便性
2、其次，是安全，在授权给其他用户或者查看角度，多个表关联只允许查看，不允许修改，单表也可以同WITH READ ONLY来控制，当然有些项目基于视图做面向对象的开发，即在视图上去做INSTAND OF触发器，就我个人而言是不站同的，虽然开发上方便，但是未必是好事。
3、从不同的角度看不同的维度，视图可以划分维度和权限，并使多个维度的综合，也就是你要什么就可以从不同的角度看，而表是一个实体的而已，一般维度较少（如：人员表和身份表关联，从人员表可以查看人员的维度统计，从身份看，可以看不同种类的身份有那些人或者多少人），其次另一个如系统视图USER_TABLE、TAB、USER_OBJECTS这些视图，不同的用户下看到的肯定是不一样的，看的是自己的东西。

物化视图呢，用于OLAP系统中，当然部分OLTP系统的小部分功能未了提高性能会借鉴一点点，因为表关联的开销很大，所以在开发中很多人就像把这个代价交给定期转存来完成，ORACLE当然也提供了这个功能，就是将视图（或者一个大SQL）的信息转换为物理数据存储，然后提供不同的策略：定时刷还是及时刷、增量刷还是全局刷等等可以根据实际情况进行选择，总之你差的是表，不是视图。


关于在刷新和索引上的区别
答曰：他们两个没有联系吧，刷新我不清楚你是否指的是物化视图的刷新，因为刷新的概念很泛，你说到这里我就理解为物化视图的刷新了，上面也已经说了，这是一种策略和方法，其实它是通过对视图关联表上创建相应的LOG，根据日志信息的SQL同步到物化视图中的，一般来说：定时的一般是全局刷，及时的一般是局部刷。

而索引这个说起来就多了，可以说索引专门是一门课程，大概点来说，索引一般有普通索引、位图索引、唯一性索引（还有全文索引啥的，一般不用），其实仔细研究会发现无论是那一种索引都是B+树为基础，并起存放方式和表一样，是以段为单位，只是内部有树关系而已。
1、普通索引是根据B+树找到第一个（索引时有序的），然后以当前为基准，向后顺序找到不符合条件的健值为止。
2、位图是在叶子节点上根据位图种类对叶子节点的值进行01编码存放（如该字段有1、2、3三种值，就会在叶子节点上有三个位图，每个位图根据健值和ROWID顺序存放是否为1、是否为2、是否为3，所以在RBO下统计很快，CBO下一般会认为是普通索引）。
3、也是按照B+树找，只是找到就不再做任何操作，因为是唯一的。

因为B+查找是一个类似表的查询，而且获取到ROWID后还是要回表查询的，所以这个过程的开销要和全表扫描计算那个结果更加快，ORACLE才会选择是走索引还是走全表扫描，当然对于CBO和RBO选择的方式不一样，具体又是很多，CBO要依赖于表的统计信息，RBO是依赖于尝试。

物化视图（material view）是什么？
物化视图是包括一个查询结果的数据库对象，它是远程数据的的本地副本，或者用来生成基于数据表求和的汇总表。
物化视图存储基于远程表的数据，也可以称为快照（类似于MSSQL Server中的snapshot，静态快照）。对于复制，物化视图允许你在本地维护远程数据的副本，这些副本是只读的。
如果你想修改本地副本，必须用高级复制的功能。当你想从一个表或视图中抽取数据时，你可以用从物化视图中抽取。
对于数据仓库，创建的物化视图通常情况下是聚合视图，单一表聚合视图和连接视图。（这个是基于本地的基表或者视图的聚合）。
物化视图，说白了，就是物理表，只不过这张表通过oracle的内部机制可以定期更新，将一些大的耗时的表连接用物化视图实现，会提高查询的效率。当然要打开查询重写选项；

简而言之，就是具有实体表的视图，而且这个视图还可以根据多种需求和策略进行刷新。此外还有一个非常重要的功能
查询重写（query rewrite) .查询重写能够在某些时候提高你的查询速度。
所谓查询重写，简而言之，就是oracle 的查询优化器发现有个物化视图的语法和你的SQL差不多，那么就会直接访问物化视图，而不是你原来查询中有关的源表。

物化视图能干什么？
或者说，你能拿物化视图做什么用。
前文简单说了下，此处列出一些重要而想详细的功能：

能够提高查询速度，这主要是因为物化视图存储了实际的数据，其次具有查询重写功能。最后，物化视图具有实体表，你也可以在上面建立索引，总之大体上当作一个表用就可以了。
简化了开发任务,意思是开发的人员有的时候，无需直接关注部分sql的性能，而通过dba的努力，使用查询重写来完成性能的提升。
减少了工作量，因为物化视图可以定义两种刷新方式：立即刷新，按需刷新。所谓按需刷新就是你自己手动刷新，或者是定时刷新；所谓立即刷新，即视图主表发生变化的时候，视图立即刷新内容。 你可以根据自己的设备情况，应用情况和需求来控制刷新的方式。
刷新量的灵活限制，你可以快速是刷新（只刷新变化的），也可以全刷新。看你的需要。
物化视图可以分为以下三种类型
包含聚集的物化视图；
只包含连接的物化视图；
嵌套物化视图。
三种物化视图的快速刷新的限制条件有很大区别，而对于其他方面则区别不大。创建物化视图时可以指定多种选项，下面对几种主要的选择进行简单说明：

创建方式（BuildMethods）：包括BUILD IMMEDIATE和BUILD DEFERRED两种。
BUILD IMMEDIATE是在创建物化视图的时候就生成数据。
BUILD DEFERRED则在创建时不生成数据，以后根据需要在生成数据。默认为BUILD IMMEDIATE。

查询重写（QueryRewrite）：包括ENABLE QUERY REWRITE和DISABLE QUERY REWRITE两种。
分别指出创建的物化视图是否支持查询重写。查询重写是指当对物化视图的基表进行查询时，Oracle会自动判断能否通过查询物化视图来得到结果，如果可以，则避免了聚集或连接操作，而直接从已经计算好的物化视图中读取数据。默认为DISABLE QUERY REWRITE。

刷新（Refresh）：指当基表发生了DML操作后，物化视图何时采用哪种方式和基表进行同步。刷新的模式有两种：ON DEMAND和ON COMMIT。ON DEMAND和ON COMMIT物化视图的区别在于其刷新方法的不同，ON DEMAND指物化视图在用户需要的时候进行刷新，可以手工通过DBMS_MVIEW.REFRESH等方法来进行刷新，也可以通过JOB定时进行刷新,即更新物化视图，以保证和基表数据的一致性;而ON COMMIT是说，一旦基表有了COMMIT，即事务提交，则立刻刷新，立刻更新物化视图，使得数据和基表一致。对基表，平常的COMMIT在0.01秒内可以完成，但在有了ON COMMIT视图后，居然要6秒。速度减低了很多倍。ON COMMIT视图对基表的影响可见一斑。

物化视图，根据不同的着重点可以有不同的分类:
按刷新方式分：FAST/COMPLETE/FORCE
按刷新时间的不同：ON DEMAND/ON COMMIT
按是否可更新：UPDATABLE/READ ONLY
按是否支持查询重写：ENABLE QUERY REWRITE/DISABLEQUERY REWRITE
默认情况下，如果没指定刷新方法和刷新模式，则Oracle默认为FORCE和DEMAND。
注意：设置REFRESH ON COMMIT的物化视图不能访问远端对象。
在建立物化视图的时候可以指定ORDER BY语句，使生成的数据按照一定的顺序进行保存。不过这个语句不会写入物化视图的定义中，而且对以后的刷新也无效。

物化视图有三种刷新方式：COMPLETE、FAST和 FORCE。
完全刷新（COMPLETE）会删除表中所有的记录（如果是单表刷新，可能会采用TRUNCATE的方式），然后根据物化视图中查询语句的定义重新生成物化视图。
快速刷新（FAST）采用增量刷新的机制，只将自上次刷新以后对基表进行的所有操作刷新到物化视图中去。FAST必须创建基于主表的视图日志。对于增量刷新选项，如果在子查询中存在分析函数，则物化视图不起作用。
采用FORCE方式，Oracle会自动判断是否满足快速刷新的条件，如果满足则进行快速刷新，否则进行完全刷新。
Oracle物化视图的快速刷新机制是通过物化视图日志完成的。Oracle通过一个物化视图日志还可以支持多个物化视图的快速刷新。物化视图日志根据不同物化视图的快速刷新的需要，可以建立为ROWID或PRIMARY KEY类型的。还可以选择是否包括SEQUENCE、INCLUDING NEW VALUES以及指定列的列表。
