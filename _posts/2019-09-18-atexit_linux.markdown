---
title: atexit
layout: post
category: linux
author: 夏泽民
---
按照ISO C的规定，一个进程可以登记至少32个函数，这些函数将由exit自动调用。atexit（）注册的函数类型应为不接受任何参数的void函数。
http://man7.org/linux/man-pages/man3/atexit.3.html
<!-- more -->
函数名: atexit
头文件:#include<stdlib.h>
功 能: 注册终止函数(即main执行结束后调用的函数)
用 法: void atexit(void (*func)(void));
注意：exit调用这些注册函数的顺序与它们 登记时候的顺序相反。同一个函数如若登记多次，则也会被调用多次。

在atexit(f)调用之前被静态分配的对象的析构函数将在f()的调用之后被调用。在一个atexit(f)调用之后建立的这种对象的析构函数将在f的调用之前被调用。引自《The C++ Programming Language》（Bjarne Stroustrup）

1、背景
对C语言有所了解的人，都知道main函数是整个程序的入口。
但是其实不是，在内核中可以使用链接器来设置程序的开始地方。如下：
当内核使⽤⼀个exec函数执⾏C程序时，在调⽤main函数之前先调⽤⼀个特殊的启动例程。可执⾏程序文件将此启动例程指定为程序的起始地址（这是由连接编辑器设置的，而连接编辑器则由C编辑器调用）。
启动例程从内核获取命令⾏参数和环境变量，然后为调⽤main函数做好准备。
2、atexit
前面我们关注的是程序开始进入时的调用函数，而atexit函数是一个特殊的函数，它是在正常程序退出时调用的函数，我们把他叫为登记函数（函数原型：int atexit (void (*)(void))：

  参数：函数地址
返回值：成功返回0，出错返回非0

根据ISO C的规定，⼀个进程可以登记多至32个函数，这些函数由exit⾃动调⽤，这些函数被称为终⽌处理程序，
atexit函数可以登记这些函数。
值得说明的是：exit调⽤终⽌处理函数的顺序和atexit登记的顺序相反，如果⼀个函数被多次登记，也会被多次调⽤。
3、程序的终止
进程终⽌的⽅式有8种，前5种为正常终⽌，后三种为异常终⽌：

1 从main函数返回；
2 调⽤exit函数；
3 调⽤_exit或_Exit；
4 最后⼀个线程从启动例程返回；
5 最后⼀个线程调⽤pthread_exit；
6 调⽤abort函数；
7 接到⼀个信号并终⽌；
8 最后⼀个线程对取消请求做出响应。

 我们有必要知道，exit()和_exit()以及_Exit()函数的本质区别是是否立即进入内核，_exit()以及_Exit()函数都是在调用后立即进入内核，而不会执行一些清理处理，但是exit()则会执行一些清理处理。
这也是为什么会存在atexit()函数的原因，因为exit()函数需要执行清理处理，需要执行一系列的操作，这些终止处理程序实际上就是完成各种所谓的清除操作的实际执行体。
注意：内核使程序执行的唯一方法是调用一个exec函数。
进程自愿终止的唯一方法是显示或隐式的（调用exit）调用_exit或_Exti。
进程也可非自愿地由一个信号使其终止

当内核使用一个一个exec函数执行c程序时，在调用main函数之前先调用一个特殊的启动例程，可执行程序需将此例程指定为程序的起始地址。启动例程从内核获取命令行参数和环境变量，然后为调用mian函数做好准备。
exec函数说明：
fork函数是用于创建一个子进程，该子进程几乎是父进程的副本，而有时我们希望子进程去执行另外的程序，exec函数族就提供了一个在进程中启动另一个程序执行的方法。它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换了。另外，这里的可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件。
那么在linux中调用exec函数有两种情况：
1）当进程认为自己不能再为系统和用户做出任何贡献时，就可以调用任何exec 函数族让自己重生。
2）如果一个进程想执行另一个程序，那么它就可以调用fork函数新建一个进程，然后调用任何一个exec函数使子进程重生。
进程终止：
进程种植的方式有8种，前5种为正常终止，后3种为异常终止：
1 从main函数返回
2 调⽤用exit函数；
3 调⽤用_exit或_Exit；
4 最后⼀一个线程从启动例程返回；
5 最后⼀一个线程调⽤用pthread_exit；
6 调⽤用abort函数；
7 接到⼀一个信号并终⽌止；
8 最后⼀一个线程对取消请求做出响应。
一般我们都是使用exit函数正常终止进程

#include <stdlib.h>
void exit( int status );
void _Exit( int status );
#include <unistd.h>
void _exit( int status );
_exit和_Exit立即进入内核，而exit要先做一些清理工作（调用执行个终止处理程序，关闭所有标准I/O流），再进入内核。三个函数所带的整形参数称为终止状态或退出状态，如果（a）调用这些函数不带参数，（b）main函数中的return 语句无返回值，（c）main函数没有声明返回类型为整形，则进程的终止状态是未定义的。main函数返回一个整形值与用该值调用exit是等价的。
注意：
exit函数运行时首先会执行由atexit()函数登记的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile()创建的临时文件。
exit()函数用于在程序运行的过程中随时结束程序，exit的参数state是返回给操作系统,返回0表示程序正常结束，非0表示程序非正常结束。
atexit函数：
atexit函数是一个特殊的函数，它是在正常程序退出时调用的函数，我们把他叫为登记函数
（函数原型：int atexit (void (*)(void))）

⼀一个进程可以登记若32个函数，这些函数由exit自动调用，这些函数被称为终止处理函数，atexit函数可以登记这些函数。exit调用终止处理函数的顺序和atexit登记的顺序相反，如果一个函数被多次登记，也会被多次调用。
1
验证atexit函

atexit函数详解
   对C语言有所了解的人都知道main函数是整个程序的入口，但是其实不然，在内核中可以使用链接器来设置程序的开始地方。当内核使⽤⼀个exec函数执⾏C程序时，在调⽤main函数之前先调⽤⼀个特殊的启动例程，可执⾏程序将此例程指定为程序的起始地址。启动例程从内核获取命令⾏参数和环境变量，然后为调⽤main函数做好准备。

      前面我们关注的是程序开始进入时的调用函数，而atexit函数是一个特殊的函数，它是在正常程序退出时调用的函数，我们把他叫为登记函数

　　（函数原型：int atexit (void (*)(void))）：

      ⼀个进程可以登记若⼲个（具体⾃⼰验证⼀下）个函数，这些函数由exit⾃动调⽤，这些函数被称为终⽌处理函数， atexit函数可以登记这些函数。 exit调⽤终⽌处理函数的顺序和atexit登记的顺序相反（网上很多说造成顺序相反的原因是参数压栈造成的，参数的压栈是先进后出，和函数的栈帧相同），如果⼀个函数被多次登记，也会被多次调⽤。

 

atexit函数调用时机

以下函数的调用时程序异常或者正常终止：

进程终⽌的⽅式有8种，前5种为正常终⽌，后三种为异常终⽌：
1 从main函数返回；
2 调⽤exit函数；
3 调⽤_exit或_Exit；
4 最后⼀个线程从启动例程返回；
5 最后⼀个线程调⽤pthread_exit；
6 调⽤abort函数；
7 接到⼀个信号并终⽌；
8 最后⼀个线程对取消请求做出响应。
 
     exit()和_exit()以及_Exit()函数的本质区别是是否立即进入内核，_exit()以及_Exit()函数都是在调用后立即进入内核，而不会执行一些清理处理，但是exit()则会执行一些清理处理，这也是为什么会存在atexit()函数的原因，因为exit()函数需要执行清理处理，需要执行一系列的操作，这些终止处理函数实际上就是完成各种所谓的清除操作的实际执行体。
 
     下面我们来验证atexit的调用顺序和退出顺序：
#include<stdio.h> 
#include<stdlib.h>  //atexit函数所属头文件
   
void func1() 
{ 
    printf("The process is done...\n"); 
} 
void func2() 
{ 
    printf("Clean up the processing\n"); 
} 
void func3() 
{ 
    printf("Exit sucessful..\n"); 
} 
int main() 
{ 
　　//其作用是注册某一个函数，当进程执行结束时，会自动调用注册的函数
　　//注册几次，就执行几次
    atexit(func1); 
    atexit(func2); 
    atexit(func3); 
    exit(0); 
} 
我们可以看到atexit函数的调用顺序是和登记顺序相反的。
 
atexit函数的用途也是比较广泛的：可以按照你予设的顺序摧毁全局变量（类），例如有个log类，你在其它的全局类里也有可能调用到Log类写日志。所以log 类必须最后被析构 。假如没有规定析构顺序，那么程序在退出时将有可能首先析构log类，那么其它的全局类在此时将无法正确写日志。 把数据写回文件, 删除临时文件, 这才是真正有用的.
