---
title: Linux如何实现共享内存
layout: post
category: linux
author: 夏泽民
---
为什么实现共享内存？
采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据[1]：一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回文件的。因此，采用共享内存的通信方式效率是非常高的。

共享内存的通信方式

 Linux的2.2.x内核支持多种共享内存方式，如mmap()系统调用，Posix共享内存，以及系统V共享内存。
 linux发行版本如Redhat 8.0支持mmap()系统调用及系统V共享内存，但还没实现Posix共享内存，
系统调用mmap()通过映射一个普通文件实现共享内存。系统V则是通过映射特殊文件系统shm中的文件实现进程间的共享内存通信。也就是说，每个共享内存区域对应特殊文件系统shm中的一个文件（这是通过shmid_kernel结构联系起来的）

mmap()系统调用实现原理：
mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以向访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。
注：实际上，mmap()系统调用并不是完全为了用于共享内存而设计的。它本身提供了不同于一般对普通文件的访问方式，进程可以像读写内存一样对普通文件的操作。而Posix或系统V的共享内存IPC则纯粹用于共享目的，当然mmap()实现共享内存也是其主要应用之一。

系统V共享内存原理
进程间需要共享的数据被放在一个叫做IPC共享内存区域的地方，所有需要访问该共享区域的进程都要把该共享区域映射到本进程的地址空间中去。系统V共享内存通过shmget获得或创建一个IPC共享内存区域，并返回相应的标识符。内核在保证shmget获得或创建一个共享内存区，初始化该共享内存区相应的shmid_kernel结构注同时，还将在特殊文件系统shm中，创建并打开一个同名文件，并在内存中建立起该文件的相应dentry及inode结构，新打开的文件不属于任何一个进程（任何进程都可以访问该共享内存区）。所有这一切都是系统调用shmget完成的。
注：每一个共享内存区都有一个控制结构struct shmid_kernel，shmid_kernel是共享内存区域中非常重要的一个数据结构，它是存储管理和文件系统结合起来的桥梁
该结构中最重要的一个域应该是shm_file，它存储了将被映射文件的地址。每个共享内存区对象都对应特殊文件系统shm中的一个文件，一般情况下，特殊文件系统shm中的文件是不能用read()、write()等方法访问的，当采取共享内存的方式把其中的文件映射到进程地址空间后，可直接采用访问内存的方式对其访问。
这里我们采用[1]中的图表给出与系统V共享内存相关数据结构：
在这里插入图片描述
正如消息队列和信号灯一样，内核通过数据结构struct ipc_ids shm_ids维护系统中的所有共享内存区域。上图中的shm_ids.entries变量指向一个ipc_id结构数组，而每个ipc_id结构数组中有个指向kern_ipc_perm结构的指针。到这里读者应该很熟悉了，对于系统V共享内存区来说，kern_ipc_perm的宿主是shmid_kernel结构，shmid_kernel是用来描述一个共享内存区域的，这样内核就能够控制系统中所有的共享区域。同时，在shmid_kernel结构的file类型指针shm_file指向文件系统shm中相应的文件，这样，共享内存区域就与shm文件系统中的文件对应起来。
在创建了一个共享内存区域后，还要将它映射到进程地址空间，系统调用shmat()完成此项功能。由于在调用shmget()时，已经创建了文件系统shm中的一个同名文件与共享内存区域相对应，因此，调用shmat()的过程相当于映射文件系统shm中的同名文件过程，原理与mmap()大同小异

系统V与mmap()映射普通文件实现共享内存通信区别：

 1、 系统V共享内存中的数据，从来不写入到实际磁盘文件中去；而通过mmap()映射普通文件实现的共享内存通信可以指定何时将数据写入磁盘文件中。 注：前面讲到，系统V共享内存机制实际是通过映射特殊文件系统shm中的文件实现的，文件系统shm的安装点在交换分区上，系统重新引导后，所有的内容都丢失。
 2、 系统V共享内存是随内核持续的，即使所有访问共享内存的进程都已经正常终止，共享内存区仍然存在（除非显式删除共享内存），在内核重新引导之前，对该共享内存区域的任何改写操作都将一直保留。
 3、 通过调用mmap()映射普通文件进行进程间通信时，一定要注意考虑进程何时终止对通信的影响。而通过系统V共享内存实现通信的进程则不然。 注：这里没有给出shmctl的使用范例，原理与消息队列大同小异
<!-- more -->
https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html
https://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html?ca=drs-
共享内存是一种最为高效的进程间通信方式，进程可以直接读写内存，而不需要任何数据的拷贝。它是IPC对象的一种。

为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一内存区而不需要进行数据的拷贝，从而大大提高的效率。

同步(synchronization)指的是多个任务(线程)按照约定的顺序相互配合完成一件事情。由于多个进程共享一段内存，因此也需要依靠某种同步机制，如互斥锁和信号量等 。

信号灯(semaphore)，也叫信号量。它是不同进程间或一个给定进程内部不同线程间同步的机制。信号灯包括posix有名信号灯、 posix基于内存的信号灯(无名信号灯)和System V信号灯(IPC对象)

方法一、利用POSIX有名信号灯实现共享内存的同步

有名信号量既可用于线程间的同步，又可用于进程间的同步。

两个进程，对同一个共享内存读写，可利用有名信号量来进行同步。一个进程写，另一个进程读，利用两个有名信号量semr, semw。semr信号量控制能否读，初始化为0。 semw信号量控制能否写，初始为1。

读共享内存的程序示例代码如下

semr = sem_open("mysem_r", O_CREAT | O_RDWR , 0666, 0);
        if (semr == SEM_FAILED)
        {
                printf("errno=%d\n", errno);
                return -1;
        }

        semw = sem_open("mysem_w", O_CREAT | O_RDWR, 0666, 1);
        if (semw == SEM_FAILED)
        {
                printf("errno=%d\n", errno);
                return -1;
        }

        if ((shmid = shmget(key, MAXSIZE, 0666 | IPC_CREAT)) == -1)
        {
                perror("semget");
                exit(-1);
        }

        if ((shmadd = (char *)shmat(shmid, NULL, 0)) == (char *)(-1))
        {
                perror("shmat");
                exit(-1);
        }

        while (1)
        {
                em_wait(semr);
                printf("%s\n", shmadd);
                sem_post(semw); 
        }

写共享内存的程序示例代码如下

。。。。。。
        //同读的程序
        while (1)
        {
                sem_wait(semw);
                printf(">");
                fgets(shmadd, MAXSIZE, stdin);
                sem_post(semr); 
        }

方法二、利用POSIX无名信号灯实现共享内存的同步

POSIX无名信号量是基于内存的信号量，可以用于线程间同步也可以用于进程间同步。若实现进程间同步，需要在共享内存中来创建无名信号量。

因此，共享内存需要定义以下的结构体。

typedef struct
        {
                sem_t semr;
                sem_t semw;
                char buf[MAXSIZE];
        }SHM;

读、写程序流程如下图所示。





方法三、利用System V的信号灯实现共享内存的同步

System V的信号灯是一个或者多个信号灯的一个集合。其中的每一个都是单独的计数信号灯。而Posix信号灯指的是单个计数信号灯

System V 信号灯由内核维护，主要函数semget，semop，semctl 。

一个进程写，另一个进程读，信号灯集中有两个信号灯，下标0代表能否读，初始化为0。 下标1代表能否写，初始为1。

程序流程如下：



写的流程和前边的类似。

方法四、利用信号实现共享内存的同步

信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式。利用信号也可以实现共享内存的同步。

思路：

reader和writer通过信号通信必须获取对方的进程号，可利用共享内存保存双方的进程号。

reader和writer运行的顺序不确定，可约定先运行的进程创建共享内存并初始化。

利用pause, kill, signal等函数可以实现该程序（流程和前边类似）。

内存共享： 两个不同进程A、B共享内存的意思是，同一块物理内存被映射到进程A、B各自的进程地址空间。进程A可以即时看到进程B对共享内存中数据的更新，反之亦然。由于多个进程共享同一块内存区域，必然需要某种同步机制，互斥锁和信号量都可以

效率： 采用共享内存通信的一个显而易见的好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝。对于像管道和消息队列等通信方式，则需要在内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次数据[1]： 一次从输入文件到共享内存区，另一次从共享内存区到输出文件。实际上，进程之间在共享内存时，并不总是读写少量数据后就解除映射，有新的通信时，再重新建 立共享内存区域。而是保持共享区域，直到通信完毕为止，这样，数据内容一直保存在共享内存中，并没有写回文件。共享内存中的内容往往是在解除映射时才写回 文件的。因此，采用共享内存的通信方式效率是非常高的。

共享内存实现机制
共享内存是通过把同一块内存分别映射到不同的进程空间中实现进程间通信。而共享内存本身不带任何互斥与同步机制，但当多个进程同时对同一内存进行读写操作时会破坏该内存的内容，所以，在实际中，同步与互斥机制需要用户来完成。
来看几个系统调用函数：
（1）创建共享内存


这里写图片描述
参数：key为输出型参数
size：size的大小应为1024整数倍（4k对齐）
shmflg:权限标志

（2）将共享内存映射到自己的内存空间:shmat
shmat是空间映射，通过创建的共享内存，在它能被进程访问之前，需要把该段内存映射到用户进程空间。shmaddr是用来指定共享内存映射到当前进程中的地址位置，要想改设置有用，shmflag必须设置为SHM_RND标志。大多情况下，应设置为空指针(void*)0,让系统自动选择地址，从而减小程序对硬件的依赖性。shmflag除了上面的设置外，还可以设置为SHM_RDONLY,使得映射过来的地址只读。
返回值：调用成功则返回映射地址的第一个字节，失败返回-1。
（3）解除映射:shmdt


这里写图片描述
参数为要解除的地址空间。
（4）控制共享内存
这里写图片描述
先来看第三个参数的结构体：
这里写图片描述
这里写图片描述
第二个参数cmd的选项：IPC_STAT:得到共享内存的状态，把共享内存的shmid_ds结构体复制到buf里
IPC_SET：改变共享内存的状态，把buf所指的结构体中的uid,gid,mode,复制到共享内存的shmid_ds结构体内
IPC_RMID:删除这块共享内存
BUF：共此内存管理结构体

代码实现：
这里写图片描述

这里写图片描述

这里写图片描述

共享内存的特点：

（1）共享内存就是允许两个不想关的进程访问同一个内存
（2）共享内存是两个正在运行的进程之间共享和传递数据的最有效的方式
（3）不同进程之间共享的内存通常安排为同一段物理内存
（4）共享内存不提供任何互斥和同步机制，一般用信号量对临界资源进行保护。
（5）接口简单

所有进程间通信的特点：

（1）管道
管道分为命名管道和匿名管道。匿名管道只能单向通信，且只能在有亲缘关系的进程间使用，常用于父子进程，当一个进程创建了一个管道，并调用fork创建子进程后，父进程关闭读端，子进程关闭写端，实现单向通信。管道是面向字节流，自带互斥与同步机制，生命周期随进程。
命名管道与匿名管道：命名管道允许毫不相干的两个进程之间

（2）信号量
信号量是一个计数器，可以用来控制多个线程对共享资源的访问，它不是用于交换大批数据，而用于多线程之间的同步，常作为一种锁机制，防止某进程在访问资源时其他进程也来访问，因此，主要作为进程间以及同一进程的不同线程间的同步手段。

（3）消息队列
消息队列是消息的链表，存放在内核中并由消息队列标识符标识，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区受限等特点。消息队列是UNIX下不同进程之间可以实现资源共享的 一种机制，UNIX允许不同进程将格式化的数据流以消息队列形式发送给任意进程，对消息队列具有操作权限的进程都可以使用msgget完成对消息队列的操作控制，通过使用消息类型，进程可以按顺序读信息，或为消息安排优先级顺序。

（4）共享内存
共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他IPC方式运行效率低而专门设计的，它往往与其他机制，如信号量，配合使用，来实现进程间的同步。

创建共享内存分以下几个步骤：

    1.定义共享内存的结构体；

    2.利用CreateFileMapping函数创建共享内存；

    3.定义指向共享内存结构体的指针pShareMem，利用MapViewOfFile函数将刚刚创建的内存映射到定义指针pShareMem。

    读写共享内存分以下几个步骤：

    1.定义共享内存的结构体；

    2.用OpenFileMapping函数打开上面创建的共享内存区，该函数返回共享内存的地址；

    3.将共享内存映射为文件指针；

    4.定义指向共享内存结构体的指针，将共享内存的内容拷贝到结构体指针里。

HANDLE hMap;
HANDLE hAddress;
int iErrCode;

//第一步要定义所要共享的内容的结构体

typedef struct _TShareMem
{
    char Data[256];
}TShareMem;

void CreateMap()
{  
    CString strBuf;
    CString strShare = "共享内存";
    char szBuf[256];
    TShareMem* pShareMem;

    //创建共享内存,这个函数的最后一个参数即是创建的共享内存的名称 

    hMap=::CreateFileMapping((HANDLE)-1,NULL,PAGE_READWRITE,0,sizeof(TShareMem),_T("NewMap"));

    if ( hMap == NULL )  
    {
        iErrCode = GetLastError();
        AfxMessageBox("不能创建内存映射文件!");
    }
    //写共享内存区，将内存映射为文件
    pShareMem = (TShareMem*)MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0);
    memcpy(pShareMem,strShare,strShare.GetLength());   

//或者代码如下：strcpy(pShareMem->Data,szBuf);

//或者用WriteProcessMemory(),代码如下：

 //HANDLE hProcess=::GetCurrentProcess();

//WriteProcessMemory(hProcess,pShareMem,szBuf, 256,0);

 


   

 

//打开刚刚创建的共享内存区，这里可以是另外一个进程中的代码   
    hMap = ::OpenFileMapping( FILE_MAP_WRITE, false, _T("NewMap"));
    if (hMap == 0 )
    {
        iErrCode = GetLastError();
        AfxMessageBox("不能定位内存映射文件块!");
    }
    //读共享内存区 
    hAddress = MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0);
   // pShareMem = (TShareMem*)MapViewOfFile(hMap, FILE_MAP_WRITE, 0, 0, 0); 
    
    if ( hAddress == NULL )
        AfxMessageBox("Can''t View Memory Map");
   //对szBuf进行赋值，每个都是0
    memset(szBuf,0,sizeof(szBuf));

    //拷贝共享内存区的内容 
    CopyMemory(szBuf,hAddress,255);

//或者用strcpy(szBuf, hAddress);

//或者用ReadProcessMemory

// HANDLE hProcess=::GetCurrentProcess();

// ReadProcessMemory(hProcess,pShareMem,szBuf, 256,0);


    AfxMessageBox(szBuf);

//最后不要忘记释放内核对象

CloseHandle(hMap);

UnmapViewOfFile(hAddress);

}


