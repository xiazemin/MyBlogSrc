---
title: orm
layout: post
category: golang
author: 夏泽民
---
什么是“持久化” 
持久（Persistence），即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是将内存中的数据存储在关系型的数据库中，当然也可以存储在磁盘文件中、XML数据文件中等等。

什么是 “持久层” 
持久层（Persistence Layer），即专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联。

 

什么是ORM

即Object-Relationl Mapping，它的作用是在关系型数据库和对象之间作一个映射，这样，我们在具体的操作数据库的时候，就不需要再去和复杂的SQL语句打交道，只要像平时操作对象一样操作它就可以了 。

 

为什么要做持久化和ORM设计(重要)

在目前的企业应用系统设计中，MVC，即 Model（模型）- View（视图）- Control（控制）为主要的系统架构模式。MVC 中的 Model 包含了复杂的业务逻辑和数据逻辑，以及数据存取机制（如 JDBC的连接、SQL生成和Statement创建、还有ResultSet结果集的读取等）等。将这些复杂的业务逻辑和数据逻辑分离，以将系统的紧耦 合关系转化为松耦合关系（即解耦合），是降低系统耦合度迫切要做的，也是持久化要做的工作。MVC 模式实现了架构上将表现层（即View）和数据处理层（即Model）分离的解耦合，而持久化的设计则实现了数据处理层内部的业务逻辑和数据逻辑分离的解耦合。 而 ORM 作为持久化设计中的最重要也最复杂的技术，也是目前业界热点技术。

简单来说，按通常的系统设计，使用 JDBC 操作数据库，业务处理逻辑和数据存取逻辑是混杂在一起的。
一般基本都是如下几个步骤：
1、建立数据库连接，获得 Connection 对象。
2、根据用户的输入组装查询 SQL 语句。
3、根据 SQL 语句建立 Statement 对象 或者 PreparedStatement 对象。
4、用 Connection 对象执行 SQL语句，获得结果集 ResultSet 对象。
5、然后一条一条读取结果集 ResultSet 对象中的数据。
6、根据读取到的数据，按特定的业务逻辑进行计算。
7、根据计算得到的结果再组装更新 SQL 语句。
8、再使用 Connection 对象执行更新 SQL 语句，以更新数据库中的数据。
7、最后依次关闭各个 Statement 对象和 Connection 对象。

由上可看出代码逻辑非常复杂，这还不包括某条语句执行失败的处理逻辑。其中的业务处理逻辑和数据存取逻辑完全混杂在一块。而一个完整的系统要包含成 千上万个这样重复的而又混杂的处理过程，假如要对其中某些业务逻辑或者一些相关联的业务流程做修改，要改动的代码量将不可想象。另一方面，假如要换数据库 产品或者运行环境也可能是个不可能完成的任务。而用户的运行环境和要求却千差万别，我们不可能为每一个用户每一种运行环境设计一套一样的系统。
所 以就要将一样的处理代码即业务逻辑和可能不一样的处理即数据存取逻辑分离开来，另一方面，关系型数据库中的数据基本都是以一行行的数据进行存取的，而程序 运行却是一个个对象进行处理，而目前大部分数据库驱动技术（如ADO.NET、JDBC、ODBC等等）均是以行集的结果集一条条进行处理的。所以为解决 这一困难，就出现 ORM 这一个对象和数据之间映射技术。

举例来说，比如要完成一个购物打折促销的程序，用 ORM 思想将如下实现（引自《深入浅出Hibernate》）：
业务逻辑如下：
public Double calcAmount(String customerid, double amount) 
{
    // 根据客户ID获得客户记录
    Customer customer = CustomerManager.getCustomer(custmerid); 
    // 根据客户等级获得打折规则
    Promotion promotion = PromotionManager.getPromotion(customer.getLevel()); 
    // 累积客户总消费额，并保存累计结果
    customer.setSumAmount(customer.getSumAmount().add(amount); 
    CustomerManager.save(customer); 
    // 返回打折后的金额
    return amount.multiply(protomtion.getRatio()); 
}
这 样代码就非常清晰了，而且与数据存取逻辑完全分离。设计业务逻辑代码的时候完全不需要考虑数据库JDBC的那些千篇一律的操作，而将它交给 CustomerManager 和 PromotionManager 两个类去完成。这就是一个简单的 ORM 设计，实际的 ORM 实现框架比这个要复杂的多。
<!-- more -->
数据库查询
在 go 开发中, 查询数据库一般有两种选择:

使用 orm (gorm\xorm 等)
直接写 SQL
直接编写 SQL 语义清晰, 不易出错, 但是遇到多个可变条件时显得不灵活

ORM 有模型关系, 记录预加载 (sql 生成优化) 等功能, 但是 sql 语句对开发人员相对透明, 管了太多数据库相关的东西, 相对封闭, 语法晦涩语义不明确, 想要操作 db 连接、构造复杂 SQL 很繁琐

查询构造器
对于查询场景少、查询条件相对固定的系统, 直接写 SQL 无疑是一种好的选择。那么, 对于 SQL 多变的场景而又不想使用 orm 的开发者, 如何能快速开发数据层呢?

go 的官方包已经提供了好用的 database/sql 工具, 也有各个数据库的驱动包, 屏蔽了底层驱动差异, 使数据库查询变得简单, 只需提供 SQL 语句和占位符参数即可快速查询, 也无需考虑 SQL 注入等问题。那么, 只要解决了 SQL 语句和占位符参数的构造问题, 就解决了直接写 SQL 的灵活性问题。

为了解决 SQL 语句和占位符参数的构造问题, 我们需要查询构造器 (Query Builder)。简而言之, 查询构造器就是利用 database/sql 的优势, 提供了一种 orm 和 raw sql 之间的中间方案。有了查询构造器, 你可以在遇到不定 SQL 时动态构造 SQL, 遇到复杂确定 SQL 时直接写原生 SQL, 使数据查询更加灵活可控。

思路
做什么
查询构造器, 顾名思义, 最主要的就是构造。构造什么? 查询语句。查询语句本身就是一个满足标准 SQL 规范的字符串, 所以我们要做查询构造器, 主要的任务就是构造字符串。

拆解 SQL
在构造一条 SQL 之前, 不妨看看一条 SQL 是什么样的吧。

SELECT `name`,`age`,`school` FROM `test` WHERE `name` = 'jack'
复杂点的, 带联合查询、分组、排序、分页

SELECT `t1`.`name`,`t1`.`age`,`t2`.`teacher`,`t3`.`address` FROM `test` as t1 LEFT JOIN `test2` as `t2` ON `t1`.`class` = `t2`.`class` INNER JOIN `test3` as t3 ON `t1`.`school` = `t3`.`school` WHERE `t1`.`age` >= 20 GROUP BY `t1`.`age` HAVING COUNT(`t1`.`age`) > 2 ORDER BY `t1`.`age` DESC LIMIT 10 OFFSET 0
当然, 标准 SQL 还有很多语法规定, 这里就不一一举例。而对于规范中最常用的语法, 我们的查询构造器必须要有构造它们的能力

一个标准的查询语句结构如下:

SELECT [字段] FROM [表名] [JOIN 子句] [WHERE 子句] [GROUP BY 子句] [HAVING 子句] [ORDER BY 子句] [LIMIT 子句]
其中 JOIN 子句、WHERE 子句、 HAVING 子句和 LIMIT 子句会用到占位符参数

再看 INSERT、UPDATE、DELETE 操作的结构:

INSERT

INSERT INTO [表名] ([字段名]) VALUES ([要插入的值])
要插入的值会用到占位符参数

UPDATE

UPDATE [表名] [SET 子句] [WHERE 子句] 
SET 子句和 WHERE 子句会用到占位符参数

DELETE

DELETE FROM [表名] [WHERE 子句] 
WHERE 子句会用到占位符参数

OK, 拆解后是不是觉得 SQL 语句的基本结构很简单? 要实现查询构造器, 只需按照这些语句的结构构造出相应的字符串, 并保存需要的占位符参数即可。

实现
有了思路, 实现起来就简单了。

参考其他语言的查询构造器, 方法名直接体现 SQL 语法, 多为链式调用:

$db.table("`test`").
    where("a", ">", 20).
    where("b", "=", "aaa").
    get()
要实现查询构造器, 这是一个好的示范。

话不多说, 开写!

首先定义我们的 SQLBuilder 类型:

type SQLBuilder struct {
    _select       string // select 子句字符串
    _insert       string // insert 子句字符串
    _update       string // update 子句字符串
    _delete       string // delete 子句字符串
    _table        string // 表名
    _join         string // join 子句字符串
    _where        string // where 子句字符串
    _groupBy      string // group by 子句字符串
    _having       string // having 子句字符串
    _orderBy      string // order by 子句字符串
    _limit        string // limit 子句字符串
    _insertParams []interface{} // insert 插入值需要的占位符参数
    _updateParams []interface{} // update SET 子句需要的占位符参数
    _whereParams  []interface{} // where 子句需要的占位符参数
    _havingParams []interface{} // having 子句需要的占位符参数
    _limitParams  []interface{} // limit 子句需要的占位符参数
    _joinParams   []interface{} // join 子句需要的占位符参数
}
SQLBuilder 的构造函数:

func NewSQLBuilder() *SQLBuilder {
    return &SQLBuilder{}
}
获取 SQL 字符串
获取字符串很简单, 只要按照 SQL 的规定将各个子句组合即可。

获取 QuerySQL:

var ErrTableEmpty = errors.New("table empty")

func (sb *SQLBuilder) GetQuerySQL() (string, error) {
    if sb._table == "" {
        return "", ErrTableEmpty
    }
    var buf strings.Builder

    buf.WriteString("SELECT ")
    if sb._select != "" {
        buf.WriteString(sb._select)
    } else {
        buf.WriteString("*")
    }
    buf.WriteString(" FROM ")
    buf.WriteString(sb._table)
    if sb._join != "" {
        buf.WriteString(" ")
        buf.WriteString(sb._join)
    }
    if sb._where != "" {
        buf.WriteString(" ")
        buf.WriteString(sb._where)
    }
    if sb._groupBy != "" {
        buf.WriteString(" ")
        buf.WriteString(sb._groupBy)
    }
    if sb._having != "" {
        buf.WriteString(" ")
        buf.WriteString(sb._having)
    }
    if sb._orderBy != "" {
        buf.WriteString(" ")
        buf.WriteString(sb._orderBy)
    }
    if sb._limit != "" {
        buf.WriteString(" ")
        buf.WriteString(sb._limit)
    }

    return buf.String(), nil
}
tips: 上述代码使用 strings.Builder 包来拼接字符串。当然构造查询语句本身不是一个高频操作, 不考虑效率使用 + 来拼接也是可以的

获取 InsertSQL:

var ErrInsertEmpty = errors.New("insert content empty")

func (sb *SQLBuilder) GetInsertSQL() (string, error) {
    if sb._table == "" {
        return "", ErrTableEmpty
    }
    if sb._insert == "" {
        return "", ErrInsertEmpty
    }

    var buf strings.Builder

    buf.WriteString("INSERT INTO ")
    buf.WriteString(sb._table)
    buf.WriteString(" ")
    buf.WriteString(sb._insert)

    return buf.String(), nil
}
获取 UpdateSQL:

var ErrUpdateEmpty = errors.New("update content empty")

func (sb *SQLBuilder) GetUpdateSQL() (string, error) {
    if sb._table == "" {
        return "", ErrTableEmpty
    }

    if sb._update == "" {
        return "", ErrUpdateEmpty
    }

    var buf strings.Builder

    buf.WriteString("UPDATE ")
    buf.WriteString(sb._table)
    buf.WriteString(" ")
    buf.WriteString(sb._update)
    if sb._where != "" {
        buf.WriteString(" ")
        buf.WriteString(sb._where)
    }

    return buf.String(), nil
}
获取 DeteleSQL:

func (sb *SQLBuilder) GetDeleteSQL() (string, error) {
    if sb._table == "" {
        return "", ErrTableEmpty
    }

    var buf strings.Builder

    buf.WriteString("DELETE FROM ")
    buf.WriteString(sb._table)
    if sb._where != "" {
        buf.WriteString(" ")
        buf.WriteString(sb._where)
    }

    return buf.String(), nil
}
获取占位符参数
同样, 我们要填充占位符 "?" 的参数也需要获得, query、insert、update、delete 拥有的参数类型都有差别, 也都有着不同的顺序


func (sb *SQLBuilder) GetQueryParams() []interface{} {
    params := []interface{}{}
    params = append(params, sb._joinParams...)
    params = append(params, sb._whereParams...)
    params = append(params, sb._havingParams...)
    params = append(params, sb._limitParams...)
    return params
}

func (sb *SQLBuilder) GetInsertParams() []interface{} {
    params := []interface{}{}
    params = append(params, sb._insertParams...)
    return params
}

func (sb *SQLBuilder) GetUpdateParams() []interface{} {
    params := []interface{}{}
    params = append(params, sb._updateParams...)
    params = append(params, sb._whereParams...)
    return params
}

func (sb *SQLBuilder) GetDeleteParams() []interface{} {
    params := []interface{}{}
    params = append(params, sb._whereParams...)
    return params
}
表名设置
设置表名, 这里我们设置完成后返回 SQLBuilder 指针自己, 可以完成链式调用。之后大部分方法都会使用这种方式。

func (sb *SQLBuilder) Table(table string) *SQLBuilder {

    sb._table = table

    return sb
}
用例:

package main

import (
    "github.com/wazsmwazsm/QueryBuilder/builder"
    "log"
)

func main() {
    sb := builder.NewSQLBuilder()

    sql, err := sb.Table("`test`").
        Select("*").
        GetQuerySQL()
    if err != nil {
        log.Fatal(err)
    }

    params := sb.GetQueryParams()

    log.Println(sql)    // SELECT * FROM `test`
    log.Println(params) // []
}
select 子句
设置 select 子句, 支持多个参数用逗号隔开, 注意最后一个逗号要去掉

func (sb *SQLBuilder) Select(cols ...string) *SQLBuilder {
    var buf strings.Builder

    for k, col := range cols {

        buf.WriteString(col)

        if k != len(cols)-1 {
            buf.WriteString(",")
        }
    }

    sb._select = buf.String()

    return sb
}
用例:

package main

import (
    "github.com/wazsmwazsm/QueryBuilder/builder"
    "log"
)

func main() {
    sb := builder.NewSQLBuilder()

    sql, err := sb.Table("`test`").
        Select("`age`", "COUNT(age)").
        GetQuerySQL()
    if err != nil {
        log.Fatal(err)
    }

    params := sb.GetQueryParams()

    log.Println(sql)    // SELECT `age`,COUNT(age) FROM `test`
    log.Println(params) // []
}
where 子句
where
对于 where 子句, 第一个 where 条件需要 WHERE 关键字, 再有其它条件, 会通过 AND 和 OR 来连接, 那么我们可以增加 Where() 和 OrWhere() 方法, 两个方法公共逻辑可以提出来:

func (sb *SQLBuilder) Where(field string, condition string, value interface{}) *SQLBuilder {
    return sb.where("AND", condition, field, value)
}

func (sb *SQLBuilder) OrWhere(field string, condition string, value interface{}) *SQLBuilder {
    return sb.where("OR", condition, field, value)
}

func (sb *SQLBuilder) where(operator string, condition string, field string, value interface{}) *SQLBuilder {
    var buf strings.Builder

    buf.WriteString(sb._where) // 载入之前的 where 子句

    if buf.Len() == 0 { // where 子句还没设置
        buf.WriteString("WHERE ")
    } else { // 已经设置, 拼接 OR 或 AND 操作符
        buf.WriteString(" ")
        buf.WriteString(operator)
        buf.WriteString(" ")
    }

    buf.WriteString(field) // 拼接字段

    buf.WriteString(" ")
    buf.WriteString(condition) // 拼接条件 =、!=、<、>、like 等
    buf.WriteString(" ")
    buf.WriteString("?") // 拼接占位符

    sb._where = buf.String() // 写字符串

    sb._whereParams = append(sb._whereParams, value) // push 占位符参数到数组

    return sb
}
用例:

package main

import (
    "github.com/wazsmwazsm/QueryBuilder/builder"
    "log"
)

func main() {
    sb := builder.NewSQLBuilder()

    sql, err := sb.Table("`test`").
        Select("`name`", "`age`", "`school`").
        Where("`name`", "=", "jack").
        Where("`age`", ">=", 18).
        OrWhere("`name`", "like", "%admin%").
        GetQuerySQL()
    if err != nil {
        log.Fatal(err)
    }

    params := sb.GetQueryParams()

    log.Println(sql)    // SELECT `name`,`age`,`school` FROM `test` WHERE `name` = ? AND `age` >= ? OR `name` like ?
    log.Println(params) // [jack 18 %admin%]
}
上述代码可以解决简单的条件子句, 如果遇到 WHERE a = ? AND (b = ? OR c = ?) 这样的复杂子句, 该如何构造呢? 面对这种场景, 我们需要提供书写原生 where 子句的能力, 增加 WhereRaw() 和 OrWhereRaw() 方法:

func (sb *SQLBuilder) WhereRaw(s string, values ...interface{}) *SQLBuilder {
    return sb.whereRaw("AND", s, values)
}

func (sb *SQLBuilder) OrWhereRaw(s string, values ...interface{}) *SQLBuilder {
    return sb.whereRaw("OR", s, values)
}

func (sb *SQLBuilder) whereRaw(operator string, s string, values []interface{}) *SQLBuilder {
    var buf strings.Builder

    buf.WriteString(sb._where) // append

    if buf.Len() == 0 {
        buf.WriteString("WHERE ")
    } else {
        buf.WriteString(" ")
        buf.WriteString(operator)
        buf.WriteString(" ")
    }

    buf.WriteString(s) // 直接使用 raw SQL 字符串
    sb._where = buf.String()

    for _, value := range values {
        sb._whereParams = append(sb._whereParams, value)
    }

    return sb
}
用例:

package main

import (
    "github.com/wazsmwazsm/QueryBuilder/builder"
    "log"
)

func main() {
    sb := builder.NewSQLBuilder()

    sql, err := sb.Table("`test`").
        Select("`name`", "`age`", "`school`").
        WhereRaw("`title` = ?", "hello").
        Where("`name`", "=", "jack").
        OrWhereRaw("(`age` = ? OR `age` = ?) AND `class` = ?", 22, 25, "2-3").
        GetQuerySQL()
    if err != nil {
        log.Fatal(err)
    }

    params := sb.GetQueryParams()

    log.Println(sql)    // SELECT `name`,`age`,`school` FROM `test` WHERE `title` = ? AND `name` = ? OR (`age` = ? OR `age` = ?) AND `class` = ?
    log.Println(params) // [hello jack 22 25 2-3]
}

where in
where in 也是常见的 where 子句, where in 子句分为 where in、or where in、where not in、or where not in 四种模式, 占位符数量等于 where in 的集合数量。

我们希望构造 where in 子句的方法入参是一个 slice, 占位符的数量等于 slice 的长度, 那么我们需要封装一个生成占位符的函数:

func GenPlaceholders(n int) string {
    var buf strings.Builder

    for i := 0; i < n-1; i++ {
        buf.WriteString("?,") // 生成 n-1 个 "?" 占位符
    }

    if n > 0 {
        buf.WriteString("?") // 生成最后一个占位符, 如果 n <= 0 则不生成任何占位符
    }

    return buf.String()
}

按照 where in 子句的四种模式, 增加 WhereIn() OrWhereIn() WhereNotIn() OrWhereNotIn() 方法:

func (sb *SQLBuilder) WhereIn(field string, values ...interface{}) *SQLBuilder {
    return sb.whereIn("AND", "IN", field, values)
}

func (sb *SQLBuilder) OrWhereIn(field string, values ...interface{}) *SQLBuilder {
    return sb.whereIn("OR", "IN", field, values)
}

func (sb *SQLBuilder) WhereNotIn(field string, values ...interface{}) *SQLBuilder {
    return sb.whereIn("AND", "NOT IN", field, values)
}

func (sb *SQLBuilder) OrWhereNotIn(field string, values ...interface{}) *SQLBuilder {
    return sb.whereIn("OR", "NOT IN", field, values)
}

func (sb *SQLBuilder) whereIn(operator string, condition string, field string, values []interface{}) *SQLBuilder {
    var buf strings.Builder

    buf.WriteString(sb._where) // append

    if buf.Len() == 0 {
        buf.WriteString("WHERE ")
    } else {
        buf.WriteString(" ")
        buf.WriteString(operator)
        buf.WriteString(" ")
    }

    buf.WriteString(field)

    plhs := GenPlaceholders(len(values)) // 生成占位符
    buf.WriteString(" ")
    buf.WriteString(condition)
    buf.WriteString(" ")
    buf.WriteString("(")
    buf.WriteString(plhs) // 拼接占位符
    buf.WriteString(")")

    sb._where = buf.String()

    for _, value := range values { 
        sb._whereParams = append(sb._whereParams, value) // push 占位符参数
    }

    return sb
}
用例:

package main

import (
    "github.com/wazsmwazsm/QueryBuilder/builder"
    "log"
)

func main() {
    sb := builder.NewSQLBuilder()

    sql, err := sb.Table("`test`").
        Select("`name`", "`age`", "`school`").
        WhereIn("`id`", 1, 2, 3).
        OrWhereNotIn("`uid`", 2, 4).
        GetQuerySQL()
    if err != nil {
        log.Fatal(err)
    }

    params := sb.GetQueryParams()

    log.Println(sql)    // SELECT `name`,`age`,`school` FROM `test` WHERE `id` IN (?,?,?) OR `uid` NOT IN (?,?)
    log.Println(params) // [1 2 3 2 4]
}

group by 子句
group by 子句可以根据多个字段分组:

func (sb *SQLBuilder) GroupBy(fields ...string) *SQLBuilder {
    var buf strings.Builder

    buf.WriteString("GROUP BY ")

    for k, field := range fields {

        buf.WriteString(field)

        if k != len(fields)-1 {
            buf.WriteString(",")
        }
    }

    sb._groupBy = buf.String()

    return sb
}
having 子句和 where 子句基本相同, 这里就不费篇幅说明了, 详细见 QueryBuilder/builder/builder.go

用例:

package main

import (
    "github.com/wazsmwazsm/QueryBuilder/builder"
    "log"
)

func main() {
    sb := builder.NewSQLBuilder()

    sql, err := sb.Table("`test`").
        Select("`school`", "`class`", "COUNT(*) as `ct`").
        GroupBy("`school`", "`class`").
        Having("`ct`", ">", "2").
        GetQuerySQL()
    if err != nil {
        log.Fatal(err)
    }

    params := sb.GetQueryParams()

    log.Println(sql)    // SELECT `school`,`class`,COUNT(*) as `ct` FROM `test` GROUP BY `school`,`class` HAVING `ct` > ?
    log.Println(params) // [2]
}

order by 子句和 limit 子句
order by 子句可以根据多个字段来排序:

func (sb *SQLBuilder) OrderBy(operator string, fields ...string) *SQLBuilder {
    var buf strings.Builder

    buf.WriteString("ORDER BY ")

    for k, field := range fields {

        buf.WriteString(field)

        if k != len(fields)-1 {
            buf.WriteString(",")
        }
    }

    buf.WriteString(" ")
    buf.WriteString(operator) // DESC 或 ASC

    sb._orderBy = buf.String()

    return sb
}
limit 来限制查询的结果, 这里我们使用 LIMIT OFFSET 语法, 这个语法是标准 SQL 规定的, LIMIT x,x 这个形式只有 mysql 支持

func (sb *SQLBuilder) Limit(offset, num interface{}) *SQLBuilder {
    var buf strings.Builder

    buf.WriteString("LIMIT ? OFFSET ?")

    sb._limit = buf.String()

    sb._limitParams = append(sb._limitParams, num, offset)

    return sb
}

用例:

package main

import (
    "github.com/wazsmwazsm/QueryBuilder/builder"
    "log"
)

func main() {
    sb := builder.NewSQLBuilder()

    sql, err := sb.Table("`test`").
        Select("`name`", "`age`", "`school`").
        Where("`name`", "=", "jack").
        Where("`age`", ">=", 18).
        OrderBy("DESC", "`age`", "`class`").
        Limit(1, 10).
        GetQuerySQL()
    if err != nil {
        log.Fatal(err)
    }

    params := sb.GetQueryParams()

    log.Println(sql)    // SELECT `name`,`age`,`school` FROM `test` WHERE `name` = ? AND `age` >= ? ORDER BY `age`,`class` DESC LIMIT ? OFFSET ?
    log.Println(params) // [jack 18 10 1]
}

join 子句
使用 join 子句后, SQL 变得复杂。标准 SQL join 有 left join、right join、inner join、full join 几种模式 join 子句的 on 条件类似 where 子句, 连表后需要给表起别名用来区分字段所属...面对这样灵活多变的语法, 我们这里较好的方式就是提供 raw sql 的形式来处理 join 操作:

func (sb *SQLBuilder) JoinRaw(join string, values ...interface{}) *SQLBuilder {
    var buf strings.Builder

    buf.WriteString(sb._join)
    if buf.Len() != 0 {
        buf.WriteString(" ")
    }
    buf.WriteString(join) // 拼接 raw join sql

    sb._join = buf.String()

    for _, value := range values {
        sb._joinParams = append(sb._joinParams, value)
    }

    return sb
}
用例 (构造一个复杂的查询):

package main

import (
    "github.com/wazsmwazsm/QueryBuilder/builder"
    "log"
)

func main() {
    sb := builder.NewSQLBuilder()

    sql, err := sb.Table("`test` as t1").
        Select("`t1`.`name`", "`t1`.`age`", "`t2`.`teacher`", "`t3`.`address`").
        JoinRaw("LEFT JOIN `test2` as `t2` ON `t1`.`class` = `t2`.`class`").
        JoinRaw("INNER JOIN `test3` as t3 ON `t1`.`school` = `t3`.`school`").
        Where("`t1`.`age`", ">=", 18).
        GroupBy("`t1`.`age`").
        Having("COUNT(`t1`.`age`)", ">", 2).
        OrderBy("DESC", "`t1`.`age`").
        Limit(1, 10).
        GetQuerySQL()
    if err != nil {
        log.Fatal(err)
    }

    params := sb.GetQueryParams()

    log.Println(sql)    // SELECT `t1`.`name`,`t1`.`age`,`t2`.`teacher`,`t3`.`address` FROM `test` as t1 LEFT JOIN `test2` as `t2` ON `t1`.`class` = `t2`.`class` INNER JOIN `test3` as t3 ON `t1`.`school` = `t3`.`school` WHERE `t1`.`age` >= ? GROUP BY `t1`.`age` HAVING COUNT(`t1`.`age`) > ? ORDER BY `t1`.`age` DESC LIMIT ? OFFSET ?
    log.Println(params) // [18 2 10 1]
}

insert
insert SQL 构建:

func (sb *SQLBuilder) Insert(cols []string, values ...interface{}) *SQLBuilder {
    var buf strings.Builder

    // 拼接字段
    buf.WriteString("(")
    for k, col := range cols {

        buf.WriteString(col)

        if k != len(cols)-1 {
            buf.WriteString(",")
        }
    }
    buf.WriteString(") VALUES (")

    // 拼接占位符
    for k := range cols {
        buf.WriteString("?")
        if k != len(cols)-1 {
            buf.WriteString(",")
        }
    }
    buf.WriteString(")")

    sb._insert = buf.String()

    for _, value := range values { // push 占位符参数
        sb._insertParams = append(sb._insertParams, value)
    }

    return sb
}
用例:

package main

import (
    "github.com/wazsmwazsm/QueryBuilder/builder"
    "log"
)

func main() {
    sb := builder.NewSQLBuilder()

    sql, err := sb.Table("`test`").
        Insert([]string{"`name`", "`age`"}, "jack", 18).
        GetInsertSQL()
    if err != nil {
        log.Fatal(err)
    }

    params := sb.GetInsertParams()

    log.Println(sql)    // INSERT INTO `test` (`name`,`age`) VALUES (?,?)
    log.Println(params) // [jack 18]
}

update
update SQL 构建:

package main

import (
    "github.com/wazsmwazsm/QueryBuilder/builder"
    "log"
)

func main() {
    sb := builder.NewSQLBuilder()

    sql, err := sb.Table("`test`").
        Update([]string{"`name`", "`age`"}, "jack", 18).
        Where("`id`", "=", 11).
        GetUpdateSQL()
    if err != nil {
        log.Fatal(err)
    }

    params := sb.GetUpdateParams()

    log.Println(sql)    // UPDATE `test` SET `name` = ?,`age` = ? WHERE `id` = ?
    log.Println(params) // [jack 18 11]
}

delete
delete SQL 构建:

package main

import (
    "github.com/wazsmwazsm/QueryBuilder/builder"
    "log"
)

func main() {
    sb := builder.NewSQLBuilder()

    sql, err := sb.Table("`test`").
        Where("`id`", "=", 11).
        GetDeleteSQL()
    if err != nil {
        log.Fatal(err)
    }

    params := sb.GetDeleteParams()

    log.Println(sql)    // DELETE FROM `test` WHERE `id` = ?
    log.Println(params) // [11]
}

OK, 查询构造器的实现到此结束, 是不是很简单呢?

使用
查询构造器实现了, 那么就结合 database/sql 用用吧!

以 mysql 为例:

package main

import (
    "database/sql"
    "fmt"
    _ "github.com/go-sql-driver/mysql"
    "github.com/wazsmwazsm/QueryBuilder/builder"
    "log"
)

// Info 定义一个数据模型, 用于接收查询数据
type Info struct {
    Age      int
    AgeCount int
}

func main() {
    // 创建 mysql 连接
    dataSource := fmt.Sprintf("%s:%s@tcp(%s:%v)/%s?charset=utf8",
        "test", "test", "127.0.0.1", 3306, "test")
    mysqlConn, err := sql.Open("mysql", dataSource)
    if err != nil {
        log.Panic("Db connect failed!" + err.Error())
    }

    // 创建查询构造器实例
    sb := builder.NewSQLBuilder()

    querySQL, err := sb.Table("`test`").
        Select("`age`", "COUNT(age)").
        GroupBy("`age`").
        GetQuerySQL()
    if err != nil {
        log.Fatal(err)
    }

    params := sb.GetQueryParams()

    // 执行查询
    rows, err := mysqlConn.Query(querySQL, params...)
    if err != nil {
        log.Panic(err)
    }
    defer rows.Close()

    // 查询数据绑定到 info 结构中
    infos := []*Info{}
    for rows.Next() {
        info := new(Info)
        if err := rows.Scan(
            &info.Age,
            &info.AgeCount,
        ); err != nil {
            log.Panicln(err)
        }
        infos = append(infos, info)
    }

    for _, info := range infos {
        fmt.Println(info)
    }

}


为了支持业务层中的事务，我试图在Go中查找类似Spring的声明式事务管理，但是没找到，所以我决定自己写一个。 事务很容易在Go中实现，但很难做到正确地实现。

需求:
1.将业务逻辑与事务代码分开。
在编写业务用例时，开发者应该只需考虑业务逻辑，不需要同时考虑怎样给业务逻辑加事务管理。如果以后需要添加事务支持，你可以在现有业务逻辑的基础上进行简单封装，而无需更改任何其他代码。事务实现细节应该对业务逻辑透明。

2.事务逻辑应该作用于用例层（业务逻辑）
不在持久层上。

3.数据服务（数据持久性）层应对事务逻辑透明。
这意味着持久性代码应该是相同的，无论它是否支持事务

4.你可以选择延迟支持事物。
你可以先编写没有事务的用例，稍后可以在不修改现有代码的情况下给该用例加上事务。你只需添加新代码。

我最终的解决方案还不是声明式事务管理，但它非常接近。创建一个真正的声明式事务管理需要付出很多努力，因此我构建了一个可以实现声明式事务的大多数功能的事务管理，同时又没花很多精力。

方案:
最终解决方案涉及本程序的所有层级，我将逐一解释它们。

数据库链接封装

在Go的“sql”lib中，有两个数据库链接sql.DB和sql.Tx. 不需要事务时，使用sql.DB访问数据库; 当需要事务时，你使用sql.Tx. 为了共享代码，持久层需要同时支持两者。 因此需要对数据库链接进行封装，然后把它作为数据库访问方法的接收器。 我从这里¹得到了粗略的想法。

// SqlGdbc (SQL Go database connection) is a wrapper for SQL database handler ( can be *sql.DB or *sql.Tx)
// It should be able to work with all SQL data that follows SQL standard.
type SqlGdbc interface {
    Exec(query string, args ...interface{}) (sql.Result, error)
    Prepare(query string) (*sql.Stmt, error)
    Query(query string, args ...interface{}) (*sql.Rows, error)
    QueryRow(query string, args ...interface{}) *sql.Row
    // If need transaction support, add this interface
    Transactioner
}

// SqlDBTx is the concrete implementation of sqlGdbc by using *sql.DB
type SqlDBTx struct {
    DB *sql.DB
}

// SqlConnTx is the concrete implementation of sqlGdbc by using *sql.Tx
type SqlConnTx struct {
    DB *sql.Tx
}
数据库实现类型SqlDBTx和sqlConnTx都需要实现SqlGdbc接口（包括“Transactioner”）接口才行。 需要为每个数据库（例如MySQL， CouchDB）实现“Transactioner”接口以支持事务。

// Transactioner is the transaction interface for database handler
// It should only be applicable to SQL database
type Transactioner interface {
    // Rollback a transaction
    Rollback() error
    // Commit a transaction
    Commit() error
    // TxEnd commits a transaction if no errors, otherwise rollback
    // txFunc is the operations wrapped in a transaction
    TxEnd(txFunc func() error) error
    // TxBegin gets *sql.DB from receiver and return a SqlGdbc, which has a *sql.Tx
    TxBegin() (SqlGdbc, error)
}
数据库存储层（datastore layer）的事物管理代码

以下是“Transactioner”接口的实现代码，其中只有TxBegin（）是在SqlDBTx（sql.DB）上实现，因为事务从sql.DB开始，然后所有事务的其他操作都在SqlConnTx（sql.Tx）上。 我从这里²得到了这个想法。

// TransactionBegin starts a transaction
func (sdt *SqlDBTx) TxBegin() (gdbc.SqlGdbc, error) {
    tx, err := sdt.DB.Begin()
    sct := SqlConnTx{tx}
    return &sct, err
}

func (sct *SqlConnTx) TxEnd(txFunc func() error) error {
    var err error
    tx := sct.DB

    defer func() {
        if p := recover(); p != nil {
            tx.Rollback()
            panic(p) // re-throw panic after Rollback
        } else if err != nil {
            tx.Rollback() // err is non-nil; don't change it
        } else {
            err = tx.Commit() // if Commit returns error update err with commit err
        }
    }()
    err = txFunc()
    return err
}

func (sct *SqlConnTx) Rollback() error {
    return sct.DB.Rollback()
}
用例层的事物接口

在用例层中，你可以拥有相同业务功能的一个函数的两个版本，一个支持事务，一个不支持，并且它们的名称可以共享相同的前缀，而事务可以添加“withTx”作为后缀。 例如，在以下代码中，“ModifyAndUnregister”是不支持事务的那个，“ModifyAndUnregisterWithTx”是支持事务的那个。 “EnableTxer”是用例层上唯一的事务支持接口，任何支持事务的“用例”都需要它。 这里的所有代码都在是用例层级（包括“EnableTxer”）代码，不涉及数据库内容。

type RegistrationUseCaseInterface interface {
...
    // ModifyAndUnregister change user information and then unregister the user based on the User.Id passed in.
    // It is created to illustrate transaction, no real use.
    ModifyAndUnregister(user *model.User) error
    // ModifyAndUnregisterWithTx change user information and then unregister the user based on the User.Id passed in.
    // It supports transaction
    // It is created to illustrate transaction, no real use.
    ModifyAndUnregisterWithTx(user *model.User) error
    // EnableTx enable transaction support on use case. Need to be included for each use case needs transaction
    // It replaces the underline database handler to sql.Tx for each data service that used by this use case
    EnableTxer
}
// EnableTxer is the transaction interface for use case layer
type EnableTxer interface {
    EnableTx()
}
以下是不包含事务的业务逻辑代码的示例。 “modifyAndUnregister（ruc，user）”是事务和非事务用例函数共享的业务功能。 你需要使用TxBegin（）和TxEnd（）（在TxDataInterface中）来包装业务功能以支持事务，这些是数据服务层接口，并且与数据库访问层无关。 该用例还实现了“EnableTx（）”接口，该接口实际上将底层数据库链接从sql.DB切换到sql.Tx.

// The use case of ModifyAndUnregister without transaction
func (ruc *RegistrationUseCase) ModifyAndUnregister(user *model.User) error {
    return modifyAndUnregister(ruc, user)
}

// The use case of ModifyAndUnregister with transaction
func (ruc *RegistrationUseCase) ModifyAndUnregisterWithTx(user *model.User) error {
    tdi, err := ruc.TxDataInterface.TxBegin()
    if err != nil {
        return errors.Wrap(err, "")
    }
    ruc.EnableTx()
    return tdi.TxEnd(func() error {
        // wrap the business function inside the TxEnd function
        return modifyAndUnregister(ruc, user)
    })
}

// The business function will be wrapped inside a transaction and inside a non-transaction function
// It needs to be written in a way that every error will be returned so it can be catched by TxEnd() function,
// which will handle commit and rollback
func modifyAndUnregister(ruc *RegistrationUseCase, user *model.User) error {
    udi := ruc.UserDataInterface
    err := modifyUser(udi, user)
    if err != nil {
        return errors.Wrap(err, "")
    }
    err = unregisterUser(udi, user.Name)
    if err != nil {
        return errors.Wrap(err, "")
    }
    return nil
}

func (ruc *RegistrationUseCase) EnableTx() {
    // Only UserDataInterface need transaction support here. If there are other data services need it,
    // then they also need to enable transaction here
    ruc.UserDataInterface.EnableTx(ruc.TxDataInterface)
}
为什么我需要在“TxDataInterface”中调用函数“EnbaleTx”来替换底层数据库链接而不是直接在用例中执行？ 因为sql.DB和sql.Tx层级要比用例层低几个级别，直接调用会搞砸依赖关系。 保持合理依赖关系的诀窍是在每一层上都有TxBegin（）和TxEnd（）并逐层调用它们以维持合理的依赖关系。

数据服务层的事物接口

我们讨论了用例层和数据存储层上的事务功能，我们还需要数据服务层中的事务功能将这两者连接在一起。 以下代码是数据服务层的事务接口（“TxDataInterface”）。 “TxDataInterface”是仅为事物管理而创建的数据服务层接口。 每个数据库只需要实现一次。 还有一个“EnableTxer”接口（这是一个数据服务层接口，不要与用例层中的“EnableTxer”接口混淆），实现“EnableTxer”接口将开启数据服务类型对事务的支持，例如， 如果想要“UserDataInterface”支持事物，就需要它实现“EnableTxer”接口。

// TxDataInterface represents operations needed for transaction support.
// It only needs to be implemented once for each database
// For sqlGdbc, it is implemented for SqlDBTx in transaction.go
type TxDataInterface interface {
    // TxBegin starts a transaction. It gets a DB handler from the receiver and return a TxDataInterface, which has a
    // *sql.Tx inside. Any data access wrapped inside a transaction will go through the *sql.Tx
    TxBegin() (TxDataInterface, error)
    // TxEnd is called at the end of a transaction and based on whether there is an error, it commits or rollback the
    // transaction.
    // txFunc is the business function wrapped in a transaction
    TxEnd(txFunc func() error) error
    // Return the underline transaction handler, sql.Tx
    GetTx() gdbc.SqlGdbc
}

// This interface needs to be included in every data service interface that needs transaction support
type EnableTxer interface {
    // EnableTx enables transaction, basically it replaces the underling database handle sql.DB with sql.Tx
    EnableTx(dataInterface TxDataInterface)
}

// UserDataInterface represents interface for user data access through database
type UserDataInterface interface {
...
    Update(user *model.User) (rowsAffected int64, err error)
    // Insert adds a user to a database. The returned resultUser has a Id, which is auto generated by database
    Insert(user *model.User) (resultUser *model.User, err error)
    // Need to add this for transaction support
    EnableTxer
}
以下代码是“TxDataInterface”的实现。 “TxDataSql”是“TxDataInterface”的具体类型。 它调用底层数据库链接的开始和结束函数来执行真正的事务操作。

// TxDataSql is the generic implementation for transaction for SQL database
// You only need to do it once for each SQL database
type TxDataSql struct {
    DB gdbc.SqlGdbc
}

func (tds *TxDataSql) TxEnd(txFunc func() error) error {
    return tds.DB.TxEnd(txFunc)
}

func (tds *TxDataSql) TxBegin() (dataservice.TxDataInterface, error) {

    sqlTx, error := tds.DB.TxBegin()
    tdi := TxDataSql{sqlTx}
    tds.DB = tdi.DB
    return &tdi, error
}
func (tds *TxDataSql) GetTx() gdbc.SqlGdbc {
    return tds.DB
}
事物策略:

你可能会问为什么我在上面的代码中需要“TxDataSql”？ 确实可以在没有它的情况下实现事务，实际上最开的程序里就没有它。 但是我还是要在某些数据服务中实现“TxDataInterface”来开始和结束事务。 由于这是在用例层中完成的，用例层不知道哪个数据服务类型实现了接口，因此必须在每个数据服务接口上实现“TxDataInterface”（例如，“UserDataInterface”和“CourseDataInterface”）以保证 “用例层”不会选择没有接口的“数据服务（data service）”。 在创建“TxDataSql”之后，我只需要在“TxDataSql”中实现一次“TxDataInterface”，然后每个数据服务类型只需要实现“EnableTx（）”就行了。

// UserDataSql is the SQL implementation of UserDataInterface
type UserDataSql struct {
    DB gdbc.SqlGdbc
}

func (uds *UserDataSql) EnableTx(tx dataservice.TxDataInterface) {
    uds.DB = tx.GetTx()
}

func (uds *UserDataSql) FindByName(name string) (*model.User, error) {
    //logger.Log.Debug("call FindByName() and name is:", name)
    rows, err := uds.DB.Query(QUERY_USER_BY_NAME, name)
    if err != nil {
        return nil, errors.Wrap(err, "")
    }
    defer rows.Close()
    return retrieveUser(rows)
}
上面的代码是“UserDataService”接口的实现程序。 “EnableTx（）”方法从“TxDataInterface”获得sql.Tx并将“UserDataSql”中的sql.DB替换为sql.Tx.

数据访问方法（例如，FindByName（））在事务代码和非事务代码之间共享，并且不需要知道“UserDataSql.DB”是sql.DB还是sql.Tx.

依赖关系漏洞:

上面的代码实现中存在一个缺陷，这会破坏我的设计并使其不完美。它是“TxDataInterface”中的函数“GetTx（）”，它是一个数据服务层接口，因此它不应该依赖于gdbc.SqlGdbc（数据库接口）。你可能认为数据服务层的实现代码无论如何都需要访问数据库，当前这是正确的。但是，你可以在将来更改实现去调用gRPC微服务（而不是数据库）。如果接口不依赖于SQL接口的话，则可以自由更改实现，但如果不是，则即使你的接口实现已更改，该接口也会永久保留对SQL的依赖。

为什么它是本程序中打破依赖关系的唯一地方？因为对于其他接口，容器负责创建具体类型，而程序的其余部分仅使用接口。但是对于事务，在创建具体类型之后，需要将底层数据库处理程序从sql.DB替换为sql.Tx，这破坏了设计。

它有解决方法吗？是的，容器可以为需要事务的函数创建sql.Tx而不是sql.DB，这样我就不需要在以后的用例级别中替换它。但是，配置文件中需要一个标志来指示函数是否需要事务， 而且这个标志需要配备给用例中的每个函数。这是一个太大的改动，所以我决定现在先这样，以后再重新审视它。

好处:
通过这个实现，事务代码对业务逻辑几乎是透明的（除了我上面提到的缺陷）。业务逻辑中没有数据存储（datastore）级事务代码，如Tx.Begin，Tx.Commit和Tx.Rollback（但你确实需要业务级别事物函数Tx.Begin和Tx.End），不仅如此，你的持久性代码中也几乎没有数据存储级事务代码。 如需在用例层上启用事务，你只需要在用例上实现EnableTx（）并将业务函数封装在“TxBegin（）”，EnableTx（）和“TxEnd（）”中，如上例所示。 在持久层上，大多数事务代码已经由“txDataService.go”实现，你只需要为特定的数据服务（例如UserDataService）实现“EnableTx”。 事务支持的真正操作是在“transaction.go”文件中实现的，它实现了“Transactioner”接口，它有四个函数，“Rollback”, “Commit”, “TxBegin” 和 “TxEnd”。

对用例增加事物支持的步骤:
假设我们需要在用例“listCourse”中为一个函数添加事务支持，以下是步骤

在列表课程用例（“listCourse.go”）中实现“EnableTxer”界面
在域模型（“course”）数据服务层（courseDataMysql.go）中实现“EnableTxer”接口
创建一个新的事务启用函数并将现有业务函数包装在“TxBegin（）”，EnableTx（）和“TxEnd（）”中
缺陷:
首先，它仍然不是声明​​式事物管理;第二，它没有完全达到需求中的＃4。要将用例函数从非事务更改为事务，你可以创建一个支持事务的新函数，它需要更改调用函数; 或者你修改现有函数并将其包装到事务中，这也需要代码更改。为了实现＃4，需要添加许多代码，因此我将其推迟到以后。第三，它不支持嵌套事务（Nested Transaction），因此你需要手动确保代码中没有发生嵌套事务。如果代码库不是太复杂，这很容易做到。如果你有一个非常复杂的代码库，有很多事务和非事务函数混在一起，那么手工做起来会比较困难，这是需要在程序中实现嵌套事务或找到已经支持它的方案。我没有花时间研究添加嵌套事务所需的工作量，但这可能并不容易。如果你对它感兴趣，这里³是一些讨论。到目前为止，对于大多数情况而言，当前的解决方案可能是在代价不大的情况下的最佳方案。

应用范围:
首先，它只支持SQL数据库的事务。 如果你有NoSql数据库，它将无法工作（大多数NoSql数据库无论如何都不支持事务）。 其次，如果事务跨越了数据库的边界（例如在不同的微服务器之间），那么它将无法工作。 在这种情况下，你需要使用Saga⁴。它的原理是为事物中的每个操作写一个补偿操作，然后在回滚阶段挨个执行每一个补偿操作。 在当前框架中添加Sage解决方案应该不难。

其他数据库相关问题:
关闭数据库链接（Close connection）

我从来没有为数据库链接调用Close（）函数，因为没有必要这样做。 你可以传入sql.DB或sql.Tx作为持久性函数的接收器（receiver）。 对于sql.DB，数据库将自动创建链接池并为你管理链接。 链接完成后，它将返回到链接池，无需关闭。 对于sql.Tx，在事务结束时，你可以提交或回滚，之后链接将返回到连接池，而无需关闭。 请参阅此处⁵ 和 此处⁶ .

对象关系映射（O/R mapping）

我简要地查看了几个“O/R”映射库，但它们没有提供我所需要的功能。 我认为“O/R映射”只适合两种情况。 首先，你的应用程序主要是CRUD，没有太多的查询或搜索; 第二，开发人员不熟悉SQL。 如果不是这种情况，则O/R映射不会提供太多帮助。 我想从扩展数据库模块中获得两个功能，一个是将sql.row加载到我的域模型结构（包括处理NULL值）中（例如“User”），另一个是自动关闭sql类型，如sql.statement或sql.rows。 有一些sql扩展库似乎提供了至少部分这样的功能。 我还没有尝试，但似乎值得一试。

延迟（Defer）:

在进行数据库访问时，你将进行大量重复调用以关闭数据库类型（例如statements, rows）。例如以下代码中的“defer row.close（）”。 你想要记住这一点，要在错误处理函数之后调用“defer row.close（）”，因为如果不是这样，当出现错误时，“rows”将为nil，这将导致恐慌并且不会执行错误处理代码。


func (uds *UserDataSql) Find(id int) (*model.User, error) {
    rows, err := uds.DB.Query(QUERY_USER_BY_ID, id)
    if err != nil {
        return nil, errors.Wrap(err, "")
    }
    defer rows.Close()
    return retrieveUser(rows)
}
恐慌（panic）:

我看到很多Go数据库代码在出现数据库错误时抛出了恐慌（panic）而不是错误（error），这可能会导致微服务出现问题，因为在微服务环境中你通常希望服务一直运行。 假设当更新语句中出现SQL错误时，用户将无法访问该功能，这很糟糕。 但如果因为这个，整个微服务或网站被关闭，那就更糟了。 因此，正确的方法是将错误传播到上一级并让它决定要做什么。 因此正确的做法是不在你的程序中抛出panic，但如果第三方库抛出恐慌呢？ 这时你需要捕获恐慌并从中恢复以保持你的服务正常运行。 我在另一篇文章“日志管理”⁸中有具体示例.

源程序:
完整的源程序链接 github: https://github.com/jfeng45/se...

索引:
[1]db transaction in golang

[2]database/sql Tx—detecting Commit or Rollback

[3]database/sql: nested transaction or save point support

[4]GOTO 2015 • Applying the Saga Pattern • Caitie McCaffrey — YouTube

[5]Common Pitfalls When Using database/sql in Go

[6]Go database/sql tutorial

[7]sqlx

[8]Go Microservice with Clean Architecture: Application Logging

https://stackoverflow.com/questions/26593867/db-transaction-in-golang

https://www.vividcortex.com/blog/2015/09/22/common-pitfalls-go/

http://go-database-sql.org/connection-pool.html

https://www.netmeister.org/blog/ops-lessons.html
