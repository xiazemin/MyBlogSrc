---
title: bash  2>&1
layout: post
category: linux
author: 夏泽民
---
“命令>/dev/null 2>&1 ”等价于“命令 &>/dev/null ”
<!-- more -->
我们在Linux下经常会碰到nohup command>/dev/null 2>&1 &这样形式的命令。首先我们把这条命令大概分解下首先就是一个nohup表示当前用户和系统的回话下的进城忽略响应HUP消息。&是把该命令以后台的job的形式运行。那么就剩下command>/dev/null 2>&1,command>/dev/null较好理解，/dev/null表示一个空设备，就是说吧command的执行结果重定向到空设备中，说白了就是不显示任何信息。那么2>&1又是什么含义?
2>&1
几个基本符号及其含义
/dev/null 表示空设备文件0 表示stdin标准输入1 表示stdout标准输出2 表示stderr标准错误从command>/dev/null说起
其实这条命令是一个缩写版，对于一个重定向命令，肯定是a > b这种形式，那么command > /dev/null难道是command充当a的角色，/dev/null充当b的角色。这样看起来比较合理，其实一条命令肯定是充当不了a，肯定是command执行产生的输出来充当a，其实就是标准输出stdout。所以command > /dev/null相当于执行了command 1 > /dev/null。执行command产生了标准输出stdout(用1表示)，重定向到/dev/null的设备文件中。
说说2>&1
通过上面command > /dev/null等价于command 1 > /dev/null,那么对于2>&1也就好理解了，2就是标准错误，1是标准输出，那么这条命令不就是相当于把标准错误重定向到标准输出么。等等是&1而不是1，这里&是什么？这里&相当于等效于标准输出。这里有点不好理解，先看下面。
command>a 2>a 与 command>a 2>&1的区别
通过上面的分析，对于command>a 2>&1这条命令，等价于command 1>a 2>&1可以理解为执行command产生的标准输入重定向到文件a中，标准错误也重定向到文件a中。那么是否就说command 1>a 2>&1等价于command 1>a 2>a呢。其实不是，command 1>a 2>&1与command 1>a 2>a还是有区别的，区别就在于前者只打开一次文件a，后者会打开文件两次，并导致stdout被stderr覆盖。&1的含义就可以理解为用标准输出的引用，引用的就是重定向标准输出产生打开的a。从IO效率上来讲，command
 1>a 2>&1比command 1>a 2>a的效率更高。
举个栗子
来个shell
//test.sh
#!/bin/sh
t
date
chmod +x test.sh为test.sh增加执行权限。这里我们弄了两条命令，其中t指令并不存在，执行会报错，会输出到stderr。date能正常执行，执行会输出当前时间，会输出到stdout。
执行./test.sh > res1.log结果为
我们发现stderr并没有被重定向到res1.log中，stderr被打印到了屏幕上。这也进一步证明了上面说的./test.sh > res1.log等价于./test.sh 1>res1.log
执行./test.sh>res2.log 2>&1结果为
这次我们发现stdout和stderr都被重定向到了res2.log中了。上面我们未对stderr也就是2说明如何输出，stderr就输出到了屏 幕上，这里我们不仅对stdout进行说明，重定向到res2.log中，对标准错误也进行了说明，让其重定向到res2.log的引用即 res2.log的文件描述符中。
再思考一下
为何2>&1要写在command>1的后面，直接用2可以么。比如ls 2>a。其实这种用法也是可以的，ls命令列出当前的目录，用stdout（1）表示，由于这个时候没有stderr(2)，这个时候执行ls 2>a也会正常产生一个a的文件，但是a的文件中是空的，因为这时候执行ls并没有产生stderr(2)。

分解这个组合：“>/dev/null 2>&1” 为五部分。
1：> 代表重定向到哪里，例如：echo "123" > /home/123.txt
2：/dev/null 代表空设备文件
3：2> 表示stderr标准错误
4：& 表示等同于的意思，2>&1，表示2的输出重定向等同于1
5：1 表示stdout标准输出，系统默认值是1，所以">/dev/null"等同于 "1>/dev/null"



